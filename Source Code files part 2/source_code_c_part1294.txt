, IndexType, JetRow);
                    if (FStatus == FrsErrorNotFound) {
                        if (CmdPkt->Command != CMD_INSERT_TABLE_RECORD) {
                            FStatus = FrsErrorEndOfTable;
                        } else {
                            FStatus = FrsErrorSuccess;
                        }
                    } else
                    if (!FRS_SUCCESS(FStatus)) {
                        jerr = JET_errNoCurrentRecord;
                    }
                    break;


                default:

                    jerr = JET_errInvalidParameter;

                }  // end of switch on AccessCode


                //
                // If record positioning failed then we are done.
                //
                if (!JET_SUCCESS(jerr)) {
                    DPRINT_JS(0, "ERROR - Record Access failed:", jerr);
                    FStatus = DbsTranslateJetError(jerr, FALSE);
                    DPRINT2(0, "ERROR - ReplicaName: %ws  Table: %s\n",
                            (Replica != NULL) ? Replica->ReplicaName->Name : L"<null>",
                            JTableCreate->szTableName);
                    break;
                }

                if (!FRS_SUCCESS(FStatus)) {
                    break;
                }
            }

            //
            // Initialize the JetSet/RetCol arrays and data record buffer
            // addresses to read and write the fields of the data record.
            //
            DbsSetJetColSize(TableCtx);
            DbsSetJetColAddr(TableCtx);

            //
            // Allocate the storage for any unallocated fields in
            // the variable length record fields.
            // Update the JetSet/RetCol arrays appropriately.
            //
            Status = DbsAllocRecordStorage(TableCtx);

            if (!NT_SUCCESS(Status)) {
                DPRINT_NT(0, "ERROR - DbsAllocRecordStorage failed to alloc buffers.", Status);
                WStatus = FrsSetLastNTError(Status);
                FStatus = FrsErrorResource;
                break;
            }

            if (CmdPkt->Command == CMD_READ_TABLE_RECORD) {
                //
                //  Now read the record.
                //
                FStatus = DbsTableRead(ThreadCtx, TableCtx);
                if (!FRS_SUCCESS(FStatus)) {
                    DPRINT_FS(0, "Error - can't read selected record.", FStatus);
                    jerr = JET_errRecordNotFound;
                    DBS_DISPLAY_RECORD_SEV(1, TableCtx, TRUE);
                }
            } else

            if (CmdPkt->Command == CMD_INSERT_TABLE_RECORD) {
                //
                // Insert a new record.
                //
                jerr = DbsInsertTable2(TableCtx);
            } else

            if (CmdPkt->Command == CMD_UPDATE_TABLE_RECORD) {
                //
                // Update an existing record.
                //
                jerr = DbsUpdateTable(TableCtx);
            } else

            if (CmdPkt->Command == CMD_DELETE_TABLE_RECORD) {
                //
                // Delete an existing record.
                //
                jerr = DbsDeleteTableRecord(TableCtx);
            }

            if (!JET_SUCCESS(jerr)) {
                DPRINT_JS(0, "Error on reading, writing or updating table record:", jerr);
                DPRINT2(0, "ReplicaName: %ws  Table: %s\n",
                        Replica->ReplicaName->Name, JTableCreate->szTableName);
                FStatus = DbsTranslateJetError(jerr, FALSE);
            }

            break;
        //
        // Create a new replcia set member.  Write the config record
        // and create the tables.
        //
        case CMD_CREATE_REPLICA_SET_MEMBER:
            FStatus = DbsCreateReplicaTables(ThreadCtx,
                                             Replica, DbsRequest->TableCtx);
            break;

        //
        // Update a replcia set member. Update the config record
        //
        case CMD_UPDATE_REPLICA_SET_MEMBER:
            FStatus = DbsUpdateReplica(ThreadCtx, Replica);
            break;

        //
        // Delete a replcia set member.  Delete the config record
        // and the tables.
        //
        case CMD_DELETE_REPLICA_SET_MEMBER:
            jerr = DbsDeleteReplicaTables(ThreadCtx, Replica);
            break;

        //
        // Open a new replica set member using the replica ID passed in
        // the replica struct.  Initialize the Replica struct and open
        // the tables.
        //
        case CMD_OPEN_REPLICA_SET_MEMBER:
            FStatus = DbsOpenReplicaSet(ThreadCtx, Replica);
            DPRINT_FS(0, "ERROR: CMD_OPEN_REPLICA_SET_MEMBER failed.", FStatus);
            break;
        //
        // Close the open replica tables and release the RtCtx struct.
        //
        case CMD_CLOSE_REPLICA_SET_MEMBER:
            FStatus = DbsCloseSessionReplicaTables(ThreadCtx, Replica);
            DPRINT1_FS(0,"ERROR - DbsCloseSessionReplicaTables failed on Replica %ws :",
                       Replica->ReplicaName->Name, FStatus);
            if (FRS_SUCCESS(FStatus)) {
                DPRINT1(4,"DbsCloseSessionReplicaTables RtCtx complete on %ws\n",
                        Replica->ReplicaName->Name);
            }
            break;


        //
        // Walk through a directory tree and load the IDTable and DIRTable
        //
        case CMD_LOAD_REPLICA_FILE_TREE:

            RtCtx = (PREPLICA_THREAD_CTX) CallContext;
            ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);

            DPRINT5(4, "LoadReplicaTree: %08x, ConfigRecord: %08x,  RtCtx: %08x, %ws, path: %ws\n",
                    Replica, ConfigRecord, RtCtx, Replica->ReplicaName->Name, ConfigRecord->FSRootPath);

            WStatus = DbsLoadReplicaFileTree(ThreadCtx,
                                             Replica,
                                             RtCtx,
                                             ConfigRecord->FSRootPath);
            //
            // If the IDTable already exists and is not empty then we bail.
            //
            FStatus = FrsTranslateWin32Error(WStatus);
            if (WStatus != ERROR_FILE_EXISTS) {
                if (!WIN_SUCCESS(WStatus)) {
                    DisplayErrorMsg(0, WStatus);

                } else {
                    //
                    // Now scan the IDTable and build the DIRTable.
                    //
                    jerr = DbsBuildDirTable(ThreadCtx, &RtCtx->IDTable, &RtCtx->DIRTable);

                    if (!JET_SUCCESS(jerr)) {
                        DPRINT_JS(0, "ERROR - DbsBuildDirTable:", jerr);
                        FStatus = DbsTranslateJetError(jerr, FALSE);
                        break;
                    }
                    DPRINT1(4, "****************  Done  DbsBuildDirTable for %ws ***************\n", Replica->ReplicaName->Name);
                }
            }

            break;


        //
        // Walk through a directory tree and load the IDTable and DIRTable
        //
        case CMD_LOAD_ONE_REPLICA_FILE_TREE:

            RtCtx = (PREPLICA_THREAD_CTX) CallContext;
            ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);

            DPRINT5(4, "LoadOneReplicaTree: %08x, ConfigRecord: %08x,  RtCtx: %08x, %ws, path: %ws\n",
                    Replica, ConfigRecord, RtCtx, Replica->ReplicaName->Name, ConfigRecord->FSRootPath);

            WStatus = DbsLoadReplicaFileTree(ThreadCtx,
                                             Replica,
                                             RtCtx,
                                             ConfigRecord->FSRootPath);
            //
            // If the IDTable already exists and is not empty then we
            // do not recreate it.
            //
            FStatus = FrsTranslateWin32Error(WStatus);
            if (WStatus != ERROR_FILE_EXISTS) {
                if (!WIN_SUCCESS(WStatus)) {
                    DisplayErrorMsg(0, WStatus);
                    break;

                } else {
                    //
                    // Now scan the IDTable and build the DIRTable.
                    //
                    jerr = DbsBuildDirTable(ThreadCtx, &RtCtx->IDTable, &RtCtx->DIRTable);

                    if (!JET_SUCCESS(jerr)) {
                        DPRINT_JS(0, "ERROR - DbsBuildDirTable:", jerr);
                        FStatus = DbsTranslateJetError(jerr, FALSE);
                        break;
                    }
                    DPRINT1(4, "****************  Done  DbsBuildDirTable for %ws ***************\n", Replica->ReplicaName->Name);
                }
            } else {
                FStatus = FrsErrorSuccess;
            }


            //
            // Continue with phase 2 of replica set init here.  This is becuase
            // we need the journal thread free to process the journal buffers
            // from the journal we are about to pause.  Once those journal
            // buffers are complete the journal thread will see the command
            // packet (CMD_JOURNAL_PAUSED) from the journal read thread that
            // sets the event to unwait us.
            //

            //
            // Phase 2.  Init (or add to the volume filter table and the parent
            // File ID table.  But first we Pause the journal so we don't filter
            // against an inconsistent table.  This call will block our thread until
            // the Pause completes or times out.  If we can't pause the volume then
            // we fail.
            //
            WStatus = JrnlPauseVolume(Replica->pVme, 60*1000);
            if (!WIN_SUCCESS(WStatus)) {
                DPRINT_WS(0, "ERROR - Status from Pause", WStatus);
                //
                // The replica state is in the error state.
                //
                FStatus =  FrsErrorReplicaPhase2Failed;
                break;
            }

            DPRINT3(4, "Phase 2 for replica %ws, id: %d, (%08x)\n",
                    Replica->ReplicaName->Name, Replica->ReplicaNumber, Replica);

            WStatus = JrnlPrepareService2(ThreadCtx, Replica);

            if (!WIN_SUCCESS(WStatus)) {
                DPRINT1_WS(4, "Phase 2 for replica %ws Failed; ",
                           Replica->ReplicaName->Name, WStatus);
                //
                // The replica state is in the error state.
                //
                FStatus =  FrsErrorReplicaPhase2Failed;
                break;
            }

            //
            // We are now initialized and the vme is on the Volume Monitor List.
            // The journal state is paused.
            //

            FStatus =  FrsErrorSuccess;

            break;



        case CMD_STOP_REPLICATION_SINGLE_REPLICA:

            FStatus = FrsErrorSuccess;

            ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);
            pVme = Replica->pVme;

            //
            // Journaling never began on this replica
            //
            if (pVme == NULL) {
                DPRINT4(4, "Null pVme when StoppingSingleReplica: %08x, ConfigRecord: %08x,  %ws, path: %ws\n",
                        Replica, ConfigRecord, Replica->ReplicaName->Name, ConfigRecord->FSRootPath);
                FStatus = FrsErrorSuccess;
                break;
            }

            DPRINT4(4, "StoppingSingleReplica: %08x, ConfigRecord: %08x,  %ws, path: %ws\n",
                    Replica, ConfigRecord, Replica->ReplicaName->Name, ConfigRecord->FSRootPath);

            //
            // Pause the journal here. This is becuase
            // we need the journal thread free to process the journal buffers
            // from the journal we are about to pause.  Once those journal
            // buffers are complete the journal thread will see the command
            // packet (CMD_JOURNAL_PAUSED) from the journal read thread that
            // sets the event to unwait us.
            //
            // This call will block our thread until the Pause completes or
            // times out.  If we can't pause the volume then we fail.
            //
            WStatus = JrnlPauseVolume(pVme, 400*1000);
            if (!WIN_SUCCESS(WStatus)) {
                DPRINT_WS(0, "ERROR - Status from Pause", WStatus);
                //
                // The replica state is in the error state.
                //
                FStatus =  FrsErrorJournalPauseFailed;
                break;
            }
            //
            // Clean out the filter and parent file ID tables.
            //
            JrnlCleanOutReplicaSet(Replica);

            //
            // Disable Journalling on this replica set. If this is the last one
            // on the volume then close the handle on the volume and free
            // VME related tables.
            //
            WStatus = JrnlShutdownSingleReplica(Replica, FALSE);
            if (!WIN_SUCCESS(WStatus)) {
                DPRINT_WS(0, "Error from JrnlShutdownSingleReplica", WStatus);
                FStatus = FrsErrorJournalReplicaStop;
            }
#if 0
            //
            // If we still have outstanding change orders in process for this
            // replica we need to wait here until they either go thru retry or
            // retire.
            //
            // Problem is that we can't wait here since the COs need
            // to use the DBService thread.  That's us.
            // see bug number 71165
            //

            // the below caused an AV.
            if (GhtCountEntries(pVme->ActiveInboundChangeOrderTable) != 0) {
                //
                // Build a cmd packet for the DB server to comlete the shutdown.
                // Or return an error status to the caller indicating the caller
                // must check for outstanding cos after which caller can
                // submit the cmd packet.

                // See above. how do we know that CO Accept isn't just about to start another CO?

                //
                // OR could we use the ref count on the replica struct to know
                // that it is OK to do the shutdown below?
                //
            }
#endif


            //
            // Close open tables for this replica set and update config record.
            // Set Replica service state to STOPPED.
            //
            FStatus1 = DbsShutdownSingleReplica(ThreadCtx, Replica);
            if (FRS_SUCCESS(FStatus)) {
                FStatus = FStatus1;
            }

            Replica->pVme = NULL;
            Replica->IsJournaling = FALSE;

            //
            // If no more replicas on this volume then we're done.
            //
            if (pVme->ActiveReplicas == 0) {
                break;
            }

            //
            // Restart the journal.  Check first if it is PAUSED and
            // set state to starting to get it out of the paused state.
            //
            if (pVme->JournalState != JRNL_STATE_INITIALIZING) {
                if (pVme->JournalState == JRNL_STATE_PAUSED) {
                    SET_JOURNAL_AND_REPLICA_STATE(pVme, JRNL_STATE_STARTING);
                } else {
                    DPRINT1(0, "ERROR: CMD_STOP_REPLICATION_SINGLE_REPLICA journal in unexpected state: %s\n",
                            RSS_NAME(pVme->JournalState));
                    SET_JOURNAL_AND_REPLICA_STATE(pVme, JRNL_STATE_ERROR);
                    FRS_ASSERT(!"CMD_STOP_REPLICATION_SINGLE_REPLICA journal in unexpected state");
                    FStatus = FrsErrorJournalStateWrong;
                    break;
                }
            }

            //
            // Set ReplayUsn to start where we left off.
            //
            if (!pVme->ReplayUsnValid) {
                DPRINT1(4, "ReplayUsn was: %08x %08x\n", PRINTQUAD(pVme->ReplayUsn));
                pVme->ReplayUsn = LOAD_JOURNAL_PROGRESS(pVme, pVme->JrnlReadPoint);
                pVme->ReplayUsnValid = TRUE;
                RESET_JOURNAL_PROGRESS(pVme);
            }

            DPRINT1(4, "ReplayUsn is: %08x %08x\n", PRINTQUAD(pVme->ReplayUsn));

            //
            // Crank up a read on the journal to get it going again.
            //
            WStatus = JrnlUnPauseVolume(pVme, NULL, FALSE);

            if (!WIN_SUCCESS(WStatus)) {
                DPRINT_WS(0, "Error from JrnlUnPauseVolume", WStatus);
                FStatus =  FrsErrorJournalStartFailed;
                SET_JOURNAL_AND_REPLICA_STATE(pVme, JRNL_STATE_ERROR);
            } else {
                DPRINT(0, "JrnlUnPauseVolume success.\n");
                FStatus =  FrsErrorSuccess;
            }


            break;

        //
        // Retire the inbound change order by updating the IDTable and deleting
        // the associated inbound log entry.
        //
        case CMD_DBS_RETIRE_INBOUND_CO:

            FStatus = DbsRetireInboundCo(ThreadCtx, CmdPkt);
            break;

        //
        // Inject the handcrafted change order into the outbound log.
        //      Designed to support a version vector join (vvjoin.c)
        //
        case CMD_DBS_INJECT_OUTBOUND_CO:

            FStatus = DbsInjectOutboundCo(ThreadCtx, CmdPkt);
            break;

        //
        // Set the inbound change order to be retried.
        //
        case CMD_DBS_RETRY_INBOUND_CO:

            FStatus = DbsRetryInboundCo(ThreadCtx, CmdPkt);
            break;

        //
        // Save the journal USN and the VSN in each replica set serviced
        // by the specified volume.  The caller has taken a ref on the Vme.
        // We drop it here.
        //
        case CMD_DBS_REPLICA_SAVE_MARK:

            pVme = (PVOLUME_MONITOR_ENTRY) CallContext;
            ForEachListEntry( &pVme->ReplicaListHead, REPLICA, VolReplicaList,
                //
                // Iterator pE is of type REPLICA.
                //
                DbsReplicaSaveMark(ThreadCtx, pE, pVme);
            );

            //
            // Drop the ref on the VME taken by the caller.
            //
            ReleaseVmeRef(pVme);

            FStatus = FrsErrorSuccess;

            break;


        //
        // Save the replica service state and the last shutdown time.
        //
        case CMD_DBS_REPLICA_SERVICE_STATE_SAVE:

            FStatus = DbsUpdateConfigTableFields(ThreadCtx,
                                                 Replica,
                                                 CnfCloseFieldList,
                                                 CnfCloseFieldCount);
            DPRINT1_FS(0, "DbsReplicaServiceStateSave on %ws.", Replica->ReplicaName->Name, FStatus);

            break;


        case CMD_PAUSE_SUBSYSTEM:
        case CMD_QUERY_INFO_SUBSYSTEM:
        case CMD_SET_CONFIG_SUBSYSTEM:
        case CMD_QUERY_CONFIG_SUBSYSTEM:
        case CMD_CANCEL_COMMAND_SUBSYSTEM:
        case CMD_READ_SUBSYSTEM:
        case CMD_WRITE_SUBSYSTEM:
        case CMD_PREPARE_SERVICE1:
        case CMD_PREPARE_SERVICE2:
        case CMD_START_SERVICE:
        case CMD_STOP_SERVICE:
        case CMD_PAUSE_SERVICE:
        case CMD_QUERY_INFO_SERVICE:
        case CMD_SET_CONFIG_SERVICE:
        case CMD_QUERY_CONFIG_SERVICE:
        case CMD_CANCEL_COMMAND_SERVICE:
        case CMD_READ_SERVICE:
        case CMD_WRITE_SERVICE:

        default:
            DPRINT1(0, "ERROR - Unsupported DBService command: %d\n", CmdPkt->Command);

        }  // end switch


        //
        // Cleanup if we did a table operation.
        //
        if (TableCtx != NULL) {
            //
            // If we are using the table ctx on the stack then always close
            // and free the record storage before returning.
            //
            if (TableCtx == TempTableCtx) {
                DbsCloseTable(jerr1, Sesid, TableCtx);
                DbsFreeTableCtx(TableCtx, 1);
            } else
            //
            // It's an allocated table ctx.  Check close and free flags to
            // decide what to do.
            //
            if (AccessClose || AccessFreeTableCtx) {
                DbsCloseTable(jerr1, Sesid, TableCtx);

                if (AccessFreeTableCtx) {
                    DbsFreeTableCtx(TableCtx, 1);
                    DbsRequest->TableCtx = FrsFree(TableCtx);
                }
            }
        }
        FrsRtlUnIdledQueue(IdledQueue);

        //
        // Retire the command packet.
        //
        DbsRequest->FStatus = FStatus;

        FrsCompleteCommand(CmdPkt, FStatus);

    }  // end while

    //
    // terminate thread.
    //

EXIT_THREAD:
    NOTHING;
    //
    //
    // Get exception status.
    //
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }


    } finally {

        if (WIN_SUCCESS(WStatus)) {
            if (AbnormalTermination()) {
                WStatus = ERROR_OPERATION_ABORTED;
            }
        }

        DPRINT_WS(0, "DBService finally.", WStatus);

        //
        // Trigger FRS shutdown if we terminated abnormally.
        //
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT(0, "DBService terminated abnormally, forcing service shutdown.\n");
            FrsIsShuttingDown = TRUE;
            SetEvent(ShutDownEvent);
        }
    }

    //
    // Let the other threads using Jet close down.
    //
    SleepCount = 21;
    while ((OpenDatabases > 1) && (--SleepCount > 0)) {
        Sleep(1*1000);
    }

    //
    // Update time and state fields in the init config record.
    //
    FRS_ASSERT(FrsInitReplica != NULL);

    ConfigRecord = FrsInitReplica->ConfigTable.pDataRecord;
    FRS_ASSERT(ConfigRecord != NULL);

    GetSystemTimeAsFileTime((PFILETIME)&ConfigRecord->LastShutdown);
    SET_SERVICE_STATE(FrsInitReplica, CNF_SERVICE_STATE_CLEAN_SHUTDOWN);
    FStatus = DbsUpdateConfigTableFields(ThreadCtx,
                                         FrsInitReplica,
                                         CnfCloseFieldList,
                                         CnfCloseFieldCount);
    DPRINT_FS(0,"DbsUpdateConfigTableFields for <init> error.", FStatus);

    //
    // Close the table, reset the TableCtx Tid and Sesid.
    // DbsCloseTable is a Macro, writes 1st arg.
    //
    DbsCloseTable(jerr, ThreadCtx->JSesid, (&FrsInitReplica->ConfigTable));
    DPRINT1_JS(0, "ERROR - Table %s close :",
                FrsInitReplica->ConfigTable.pJetTableCreate->szTableName, jerr);

    //
    // Close the session, free the jet thread context, terminate Jet.
    //
    jerr = DbsCloseJetSession(ThreadCtx);
    CLEANUP_JS(0,"DbsCloseJetSession error:", jerr, ERROR_TERM_JET);

    DPRINT(4,"DbsCloseJetSession complete\n");

ERROR_TERM_JET:
    jerr = JetTerm(ThreadCtx->JInstance);
    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(1,"JetTerm error:", jerr);
    } else {
        DPRINT(4,"JetTerm complete\n");
    }
    //
    // Free storage allocated during Now free the storage associated with all the system init config table
    // and the system init REPLICA struct as well.
    //
    FrsInitReplica = FrsFreeType(FrsInitReplica);
    ThreadCtx = FrsFreeType(ThreadCtx);

    //
    // The thread does not return from this call
    //
    DPRINT(0, "DataBase is exiting.\n");
    FrsExitCommandServer(&DBServiceCmdServer, FrsThread);

    return ERROR_SUCCESS;
}


ULONG
DbsRenameFid(
    IN PCHANGE_ORDER_ENTRY ChangeOrder,
    IN PREPLICA            Replica
)
/*++

Routine Description:

    A remote change order has completed installing a new file
    into a temporary file in the target directory. The temporary
    file is now renamed to its final name.

    Any error encountered while performing the above will cause the
    change order to be put into the "wait for install retry" state and
    the rename will be retried periodically.

Arguments:

    ChangeOrder - change order entry containing the final name.
    Replica    -- The Replica set struct.

Return Value:

    WIN_SUCCESS         - No problems
    WIN_RETRY_INSTALL   - retry later
    Anything else       - pretend there were no problems

--*/
{
#undef DEBSUB
#define DEBSUB "DbsRenameFid:"
    DWORD                   NameLen;
    DWORD                   WStatus;
    PCHANGE_ORDER_COMMAND   Coc = &ChangeOrder->Cmd;
    ULONG                   GStatus;
    BOOL                    RemoteCo;


    FRS_ASSERT(COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_RENAME));


    RemoteCo = !CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);

    //
    // Rename the new file into place.  Note: Use the fid to find the file
    // since it is possible (in the case of pre-install files) that the
    // file name (based on CO Guid) when the pre-install file was first
    // created was done by a different CO than this CO which is doing the
    // final reaname.  E.g. the first CO creates pre-install and then goes
    // into the fetch retry state when the connection unjoins.  A later CO
    // arrives for the same file but with a different CO Guid via a different
    // connection.  Bug 367113 was a case like this.
    //
    WStatus = StuPreInstallRename(ChangeOrder);

    if (WIN_ALREADY_EXISTS(WStatus)) {

        //
        // There should be no name collision because the name morph check was
        // done up front when the CO was issued.  So either this is an old
        // file laying around that is not in the database or it was just created
        // locally.  Either way we own the name now so free it up.
        // If it was a local CO that beat us to the name then when the local
        // CO is processed the deleted file will cause it to be rejected.
        // The window where this can occur is narrow since the local CO would
        // have to be generated after the remote CO was already inserted into
        // the process queue ahead of it.  The user will just think they lost
        // the race.
        //
        WStatus = FrsDeleteFileRelativeByName(
                      ChangeOrder->NewReplica->pVme->VolumeHandle,
                      &Coc->NewParentGuid,
                      Coc->FileName,
                      ChangeOrder->NewReplica->pVme->FrsWriteFilter);

        if (!WIN_SUCCESS(WStatus)) {
            CHANGE_ORDER_TRACEW(3, ChangeOrder, "Failed to del name loser - Retry later", WStatus);
            return ERROR_ALREADY_EXISTS;
        }
        WStatus = StuPreInstallRename(ChangeOrder);
    }

    if (WIN_SUCCESS(WStatus)) {
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Final rename success");
        CLEAR_COE_FLAG(ChangeOrder, COE_FLAG_NEED_RENAME);

        //
        // Update the volume parent file ID table for remote Change Orders.
        // Now that the file is installed we could start seeing local COs
        // for it.
        //
        if (RemoteCo) {
            GStatus = QHashInsert(Replica->pVme->ParentFidTable,
                                  &ChangeOrder->FileReferenceNumber,
                                  &ChangeOrder->ParentFileReferenceNumber,
                                  Replica->ReplicaNumber,
                                  FALSE);
            if (GStatus != GHT_STATUS_SUCCESS ) {
                DPRINT1(0, "++ ERROR - QHashInsert on parent FID table status: %d\n", GStatus);
            }

            if (CoIsDirectory(ChangeOrder)) {
                //
                // Update the volume filter table for new remote change orders.
                //
                if (COE_FLAG_ON(ChangeOrder, COE_FLAG_REANIMATION)) {
                    CHANGE_ORDER_TRACE(3, ChangeOrder, "RmtCo AddVolDir Filter - Reanimate");
                } else {
                    CHANGE_ORDER_TRACE(3, ChangeOrder, "RmtCo AddVolDir Filter");
                }

                WStatus = JrnlAddFilterEntryFromCo(Replica, ChangeOrder, NULL);
                if (!WIN_SUCCESS(WStatus)) {

                    //
                    // See comment in  JrnlFilterLinkChildNoError() for how
                    // this can happen.  Let the CO complete.
                    //
                    CHANGE_ORDER_TRACEW(3, ChangeOrder, "JrnlAddFilterEntryFromCo failed", WStatus);
                    WStatus = ERROR_SUCCESS;
                }
            }
        }

        return WStatus;
    }

    //
    // If it's a retriable problem; do so
    //
    if (WIN_RETRY_INSTALL(WStatus) || WIN_ALREADY_EXISTS(WStatus) ||
        WStatus == ERROR_DELETE_PENDING) {
        CHANGE_ORDER_TRACEW(3, ChangeOrder, "Final Rename Failed - Retrying", WStatus);
    } else {
        //
        // Its not a retriable problem; give up
        //
        CHANGE_ORDER_TRACEW(3, ChangeOrder, "Final Rename Failed - Fatal", WStatus);
    }

    return WStatus;
}


ULONG
DbsRetireInboundCoOld(
    IN PTHREAD_CTX ThreadCtx,
    IN PCOMMAND_PACKET CmdPkt
)
/*++

Routine Description:

    Note:  This comment needs to be revised.


    This function retires an inbound change order.

    Change order retire is complicated by the need to propagate the change
    orders so all change orders from the same originator propagate in the same
    sequence that they were generated.  This is because change order dampening
    tracks the highest VSN it has seen so far from a given orginator.  For
    example, if we sent change orders for two different files from the same
    originator to our outbound partner out of sequence, the dampening logic
    would cause the earlier change orders to be ignored (since having a higher
    VSN, the partner concludes that it must be up to date).

    Inbound Change order retire is divided into two phases:
    Initial retire and Final retire.

    Initial retire is when change order processing is sufficiently complete
    such that it can now be propagated when it gets to the head of the
    propagation list.  For local change orders this is when the staging file
    is generated and the change order is retiring.  For remote CO's this is
    when the staging file has been fetched from the inbound partner.  At this
    point we can honor any outbound requests for the file and can dampen
    further inbound change orders for the file.  Even if the install of the
    file is blocked due to a sharing violation on the target file we can still
    send out the staging file.

    Final retire occurs when the change order is completed and has been
    propagated to the oubound log.  It can now be deleted from the inbound
    log.

    The propagation of the change order to the outbound log can occur at the
    time of Initial Retire or later if necessary to preserve the sequence
    order.  Propagation involves inserting the change order into the outbound
    log and updating our version vector.  There is no need to propagate the
    CO if there are not outbound partners or there is a single outbound
    partner and the partner Guid matches the originator Guid of the CO.

    Change orders are issued in order by originator (except for retries).
    When they issue a retire slot is reserved for the version vector entry
    assoicated with the CO originator.  The initial retire activates the slot
    and when the slot reaches the head of the list the final retire operations
    are completed.  Even though a change order is in the retry list it still
    has a retire slot reserved so other change orders that may have completed
    behind it can not propagate to the outbound log until the retrying change
    order either completes or aborts.

    There are state flags in the change order command (that is stored in the
    Inbound and Outbound logs) which track current progress of the Change order.
    When a remote CO has successfully fetched the staging file the VV retire
    slot is activated, Ack is sent to the inbound partner.  The CO flag
    CO_FLAG_VV_ACTIVATED is set so this isn't done again.  If the CO will go
    through the retry path until it finally completes so there is code both
    in the Main retire path and the retry path to check CO_FLAG_VV_ACTIVATED
    and do the work if needed.

    See the comments in DbsRetryInboundCo() for the current retry scenarios.

    A change order can Abort after issuing.  This is typically caused by a later
    update to the file that superceded the update from this CO.

    The table below shows what work is done as an inbound change order is
    processed through the various retire phases or is aborted.


     Local CO     |    Remote CO
   Accept  Abort  | Accept Abort
                  |
                  |
INITIAL_RETIRE    |              [Local CO gened or remote CO fetched stage file.]
     x            |  x           Update the IDTable entry
                  |  x      x    Ack inbound partner
     x       x    |  x      x    Release Issue interlocks (see below).
     x       a    |  x      x    Activate VV entry
                  |
CO_PROPAGATE      |              [slot now at head of list in VVECTOR.C]
     x            |  x      x    Update VV
     x            |  x           Insert CO in outbound log (if partners)
                  |
CO_ABORT          |
             d    |              Delete the IDTable entry
             x    |         x    Delete staging file.
                  |
FINAL_RETIRE      |              [CO PROP done or CO ABORT done]
                  |  x           Delete staging file IF no outbound partners
     x       x    |  x      x    Delete the INlog entry (if no more retry)
     x       x    |  x      x    Delete the Replica Thread Ctx struct
     x       x    |  x      x    Free the Change Order
                  |
                  |
Release Issue Interlocks-
     x       x    |  x      x    Delete the Active Inbound Change Order table entry
     x       x    |  x      x    Delete the Active child entry
     x       x    |  x      x    Delete the entry from the change order GUID table
     x       x    |  x      x    Check if this CO is blocking another and unidle the queue


d - Action performed if file is deleted before it was ever propagated.
a - Entry activated but abort is set so no VV update or propagate occurs.
m - Call VVxx to mark CO as aborted.  If it is not on the list we can do the
    final retire otherwise it is done at CO_PROPAGATE time.

Note - FINAL_RETIRE can only happen after INITIAL_RETIRE or CO_PROPAGATE which
ever occurs last.  A ref count on the change order is used to manage this.

Note - CO_PROPAGATE can happen asynchronous to a retry of the change order.
During retry the CO could be aborted or could finish and another thread could
be doing the CO_PROPAGATE at the same time.  The change order reference count
is used to control who performs the FINAL_RETIRE.


The TableCtx structs in the ChangeOrder RtCtx are used to update the
database records.

Arguments:

    ThreadCtx   -- ptr to the thread context.

    CmdPkt  - The command packt with the retire request.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsRetireInboundCoOld:"

    FRS_ERROR_CODE        FStatus;
    JET_ERR               jerr, jerr1;
    PDB_SERVICE_REQUEST   DbsRequest = &CmdPkt->Parameters.DbsRequest;
    PCONFIG_TABLE_RECORD  ConfigRecord;
    PREPLICA              Replica;
    PCHANGE_ORDER_ENTRY   ChangeOrder;
    PCHANGE_ORDER_COMMAND CoCmd;
    PREPLICA_THREAD_CTX   RtCtx;
    PTABLE_CTX            TmpIDTableCtx;
    PIDTABLE_RECORD       IDTableRec;
    BOOL                  ChildrenExist = FALSE;

    ULONG                 RetireFlags = 0;
    BOOL                  RemoteCo, AbortCo, DeleteCo, FirstTime;
    ULONG                 LocationCmd;
    ULONG                 WStatus;
    ULONG                 Len;


    FRS_ASSERT(DbsRequest != NULL);

    Replica       = DbsRequest->Replica;
    FRS_ASSERT(Replica != NULL);

    ChangeOrder   = (PCHANGE_ORDER_ENTRY) DbsRequest->CallContext;
    FRS_ASSERT(ChangeOrder != NULL);


    CoCmd = &ChangeOrder->Cmd;

    LocationCmd = GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command);
    DeleteCo = (LocationCmd == CO_LOCATION_DELETE) ||
               (LocationCmd == CO_LOCATION_MOVEOUT);

    RemoteCo = !CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);

    FirstTime = !CO_FLAG_ON(ChangeOrder, CO_FLAG_RETRY);

    AbortCo = COE_FLAG_ON(ChangeOrder, COE_FLAG_STAGE_ABORTED) ||
              CO_STATE_IS(ChangeOrder, IBCO_ABORTING);

    ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);
    FRS_ASSERT(ConfigRecord != NULL);


TOP:

    //
    // Increment the Local OR Remote CO Aborted OR Retired counters
    //
    if (AbortCo) {
        if (RemoteCo) {
            PM_INC_CTR_REPSET(Replica, RCOAborted, 1);
        }
        else {
            PM_INC_CTR_REPSET(Replica, LCOAborted, 1);
        }
    }
    else {
        if (RemoteCo) {
            PM_INC_CTR_REPSET(Replica, RCORetired, 1);
        }
        else {
            PM_INC_CTR_REPSET(Replica, LCORetired, 1);
        }
    }

    //
    // A newly created file is first installed into a temporary file
    // and then renamed to its final destination. The rename may fail
    // if the user has used the filename for another file. This case
    // is handled later. However, a subsequent change order may arrive
    // before retrying the failing rename. The new change order will
    // attempt the rename because the idtable entry has the deferred
    // rename bit set. This old change order will be discarded by
    // the reconcile code in ChgOrdAccept().
    //
    // We attempt the rename here so that the file's usn value
    // is correct in the change order.
    //
    // Ditto afor deferred deletes.
    //
    WStatus = ERROR_SUCCESS;
    if (!AbortCo &&
        !DeleteCo &&
        COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_RENAME)) {

        //
        // NOTE: We must use the info in the IDTable to do the final rename
        // since we could have multiple COs in the IBCO_INSTALL_REN_RETRY
        // state and only the IDTable has the correct info re the final location
        // and name for the file.  If the CO does not arrive here in the
        // REN_RETRY state then use the state in the change order as given.
        //
        if (CO_STATE_IS(ChangeOrder, IBCO_INSTALL_REN_RETRY)) {
            RtCtx = ChangeOrder->RtCtx;
            FRS_ASSERT(RtCtx != NULL);

            IDTableRec = RtCtx->IDTable.pDataRecord;
            FRS_ASSERT(IDTableRec != NULL);

            CoCmd->NewParentGuid = IDTableRec->ParentGuid;
            ChangeOrder->NewParentFid = IDTableRec->ParentFileID;

            Len = wcslen(IDTableRec->FileName) * sizeof(WCHAR);
            CopyMemory(CoCmd->FileName, IDTableRec->FileName, Len);
            CoCmd->FileName[Len/sizeof(WCHAR)] = UNICODE_NULL;

            CoCmd->FileNameLength = (USHORT) Len;
        }


        TEST_DBSRENAMEFID_TOP(ChangeOrder);
        WStatus = DbsRenameFid(ChangeOrder, Replica);
        TEST_DBSRENAMEFID_BOTTOM(ChangeOrder, WStatus);

        //
        // Short circuit the retire process if the file could not be renamed
        // into its final destination.  Set the change order as "retry later"
        // in the inbound log.  The change order is done except for this.
        // If this is the first time through for this change order then
        // DbsRetryInboundCo will take care of VV update, partner Ack, ...
        // In addition it updates the IDTable record to show the rename is
        // still pending.
        //
        if (WIN_RETRY_INSTALL(WStatus) ||
            WIN_ALREADY_EXISTS(WStatus)) {
            SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_INSTALL_REN_RETRY);

            return (DbsRetryInboundCo(ThreadCtx, CmdPkt));
        }

    } else

    if (!AbortCo &&
        DeleteCo &&
        COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_DELETE)) {
        //
        // Handle deferred delete.
        //
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Attempt Deferred Delete");

        WStatus = StuDelete(ChangeOrder);
        if (!WIN_SUCCESS(WStatus)) {
            //
            // Short circuit the retire process if the file could not be deleted.
            //
            // If this is a file and we failed to delete send the CO thru
            // delete retry.
            // If this is a dir and we failed to delete because the dir is not
            // empty or we got some other retryable error then first check
            // to see if there are any valid children.  If there are valid
            // children then abort the CO otherwise send it thru delete retry
            // which will mark the IDTable entry as IDREC_FLAGS_DELETE_DEFERRED.
            //
            if (WIN_RETRY_DELETE(WStatus)) {
                if (CoIsDirectory(ChangeOrder)) {
                    //
                    // check to see if there are any valid children
                    //
                    // If the dir has vaild children. Check if these children
                    // are waiting to be deleted. They might have the
                    // IDREC_FLAGS_DELETE_DEFERRED flag set in the idtable.
                    // If there is atleast 1 child entry in the idtable that
                    // has an event time later than the even time on the
                    // change order then we should abort the change order.
                    //

                    TmpIDTableCtx = FrsAlloc(sizeof(TABLE_CTX));
                    TmpIDTableCtx->TableType = TABLE_TYPE_INVALID;
                    TmpIDTableCtx->Tid = JET_tableidNil;

                    jerr = DbsOpenTable(ThreadCtx, TmpIDTableCtx, Replica->ReplicaNumber, IDTablex, NULL);

                    if (JET_SUCCESS(jerr)) {

                        ChildrenExist = JrnlDoesChangeOrderHaveChildren(ThreadCtx, TmpIDTableCtx, ChangeOrder);

                        DbsCloseTable(jerr1, ThreadCtx->JSesid, TmpIDTableCtx);
                        DbsFreeTableCtx(TmpIDTableCtx, 1);
                        FrsFree(TmpIDTableCtx);

                        if (ChildrenExist) {

                            CHANGE_ORDER_TRACE(3, ChangeOrder, "DIR has valid child. Aborting");
                            AbortCo = TRUE;
                            SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_ABORTING);

                            //
                            // Even though we can't delete the dir this del CO was
                            // accepted so we need to update the version info in
                            // the IDTable record.  This ensures that if any new local
                            // changes to this dir are generated, the version info
                            // that gets sent out is current so the CO will be
                            // accepted downstream in the event that the downstream
                            // member did actually accept and process this delete.
                            // If that had happened but later the dir was reanimated
                            // downstream (say because we generated a new child file)
                            // the version info downstream is retained which could
                            // cause a later update (or a delete) from this member
                            // to be rejected (e.g. event time within the window
                            // but out version number is lower than it should be).
                            // bug 290440 is an example of this.
                            //
                            SetFlag(RetireFlags, ISCU_UPDATE_IDT_VERSION);
                            goto TOP;
                        }
                    } else {
                        DPRINT1_JS(0, "DbsOpenTable (IDTABLE) on replica number %d failed.",
                                   Replica->ReplicaNumber, jerr);
                        DbsCloseTable(jerr1, ThreadCtx->JSesid, TmpIDTableCtx);
                        DbsFreeTableCtx(TmpIDTableCtx, 1);
                        FrsFree(TmpIDTableCtx);
                    }

                }
                //
                // Set the change order as IBCO_INSTALL_DEL_RETRY in the
                // inbound log.  The change order is done except for this.  If
                // this is the first time through for this change order then
                // DbsRetryInboundCo will take care of VV update, partner Ack,
                // ...  In addition it updates the IDTable record to show the
                // delete is still pending.
                //
                SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_INSTALL_DEL_RETRY);

                return (DbsRetryInboundCo(ThreadCtx, CmdPkt));
            }
        }
    }

    //
    // Decide what to do about the staging file.
    // A local change order is trying to generate the staging file and a
    // failure here means it hasn't yet been generated.
    // A remote change order is trying to fetch and install the staging file
    // and a failure here means the install could not be completed.
    // There are a number of cases.
    //
    // Local, No partners  -- no staging file is created.
    // Local, 1st time, With partners -- Outlog will del staging file
    // Local, 1st time, Abort, With partners -- Del stagefile (if any)
    // Local, retry, with partners -- stagefile now gen, Outlog dels staging file
    // Local, retry, abort, with partners -- Del stagefile (if any)
    //
    // Remote, No partners  -- Del stagefile
    // Remote, 1st time, with partners -- OLOG will del stagefile
    // Remote, 1st time, Abort, with partners -- Del stagefile
    // Remote, retry, with partners -- Clear flag in olog
    // Remote, retry, Abort, with partners -- clear flag in olog
    //

    SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_COMMIT_STARTED);

    //
    // Check for the case of an aborted CO.  We do nothing here if the user
    // deleted the file so we couldn't generate the staging file.
    //
    if (AbortCo &&
        !COE_FLAG_ON(ChangeOrder, COE_FLAG_STAGE_DELETED)) {
        //
        // If the abort is on a dir create then pitch the CO.
        // (not if it's a parent reanimation though).
        // (not if it's a reparse)
        //

        if (CoIsDirectory(ChangeOrder) &&
            (!COE_FLAG_ON(ChangeOrder, COE_FLAG_PARENT_REANIMATION)) &&
            (!(CoCmd->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT))) {

            if (CO_NEW_FILE(LocationCmd)) {
                //
                // Unfortunately we can get an "update CO" for an existing file
                // and the CO has a location command of CREATE.  So we can't
                // be sure that the error we are seeing is a case of failing
                // to update a pre-existing file in the replica tree that has
                // been deleted out from under us.   If it has been deleted
                // then a local CO should be coming that tells us that.
                // If it hasn't been deleted and the install failed because we
                // ran out of disk space or some other problem then we could
                // have problems later when a child create shows up and there
                // is no parent.  To address this, InstallCsInstallStage()
                // checks if the pre-exisitng target file was deleted and it
                // sends the change order thru retry (or unjoins the connection)
                // as appropriate.  If a dir create fails for some other reason
                // we end up here.
                //
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Dir create failed, aborting");
                FRS_PRINT_TYPE(0, ChangeOrder);
            }
        }
    }

    if (RemoteCo) {

        //
        // Remote CO retire.  Activate VV retire slot if not yet done.
        //
        if (!CO_FLAG_ON(ChangeOrder, CO_FLAG_VV_ACTIVATED)) {

            SetFlag(RetireFlags, ISCU_ACTIVATE_VV | ISCU_ACK_INBOUND);

            if (CO_FLAG_ON(ChangeOrder, CO_FLAG_GROUP_ANY_REFRESH)) {
                SetFlag(RetireFlags, ISCU_DEL_STAGE_FILE);
            } else {
                SetFlag(RetireFlags, ISCU_INS_OUTLOG);
            }

            //SET_CO_FLAG(ChangeOrder, CO_FLAG_VV_ACTIVATED);
        } else if (CO_FLAG_ON(ChangeOrder, CO_FLAG_RETRY)) {
            if (!CO_FLAG_ON(ChangeOrder, CO_FLAG_GROUP_ANY_REFRESH)) {
                SetFlag(RetireFlags, (ISCU_INS_OUTLOG |
                                      ISCU_INS_OUTLOG_NEW_GUID |
                                      ISCU_ACK_INBOUND));
            } else {
                SetFlag(RetireFlags, ISCU_ACK_INBOUND);
            }
        }
        //
        // Install is done.  Clear incomplete flag and update IDT entry
        // with the new file state.
        //
        CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_INSTALL_INCOMPLETE);
        SetFlag(RetireFlags, ISCU_UPDATE_IDT_ENTRY);
        //
        // Note:  If partial installs are provided then only update the
        //        appropriate IDTable elements to prevent data from moving
        //        backwards if the partial instals can complete out of order.
        //
        //
        // If the outlog record has been inserted then its install
        // incomplete flag must be cleared.  If there are no outbound partners
        // then the stage file is deleted in ChgOrdIssueCleanup().
        //
        SetFlag(RetireFlags, ISCU_DEL_STAGE_FILE_IF);

        //
        // If this remote CO is aborting then don't update IDTable and don't
        // insert it into the outbound log if it hasn't happened yet.
        // The flags set above will still cause the VV update and the inbound
        // partner Ack to occur.  If this is a new file then delete the IDTable
        // entry too.
        //
        if (AbortCo) {
            SET_CO_FLAG(ChangeOrder, CO_FLAG_ABORT_CO);  // unused ??
            //
            // If however we are updating our version info, even if the CO is
            // aborting, then allow it to be sent to the outlog so downstream
            // members can make the same choice.  See the case above when we
            // abort because the DIR has a valid child.
            //
            if (!BooleanFlagOn(RetireFlags, ISCU_UPDATE_IDT_VERSION)) {
                ClearFlag(RetireFlags, (ISCU_INS_OUTLOG |
                                        ISCU_INS_OUTLOG_NEW_GUID));
            }

            ClearFlag(RetireFlags, ISCU_UPDATE_IDT_ENTRY);

            if (CO_IFLAG_ON(ChangeOrder, CO_IFLAG_VVRETIRE_EXEC)) {
                SetFlag(RetireFlags, ISCU_CO_ABORT);
            } else {
                SetFlag(RetireFlags, ISCU_ACTIVATE_VV_DISCARD |
                                     ISCU_DEL_PREINSTALL      |
                                     ISCU_DEL_STAGE_FILE);
            }

            if (CO_FLAG_ON(ChangeOrder, CO_FLAG_NEW_FILE)) {
                SetFlag(RetireFlags, ISCU_DEL_IDT_ENTRY);
            }

            TALLY_REMOTECO_STATS(ConfigRecord, NumCoAborts, 1);
        } else {
            TALLY_REMOTECO_STATS(ConfigRecord, NumCoRetired, 1);
        }

    } else {

        //
        // Local CO retire.
        //
        if (AbortCo) {
            //
            // Local CO aborted (probably USN change).  Discard VV retire slot
            // and delete the staging file and delete the IDTable entry if this
            // was a new file.
            //
            SET_CO_FLAG(ChangeOrder, CO_FLAG_ABORT_CO);  // unused ??
            SetFlag(RetireFlags, ISCU_ACTIVATE_VV_DISCARD |
                                 ISCU_DEL_STAGE_FILE);

            if (CO_FLAG_ON(ChangeOrder, CO_FLAG_NEW_FILE)) {
                SetFlag(RetireFlags, ISCU_DEL_IDT_ENTRY);
            }

            TALLY_LOCALCO_STATS(ConfigRecord, NumCoAborts, 1);

        } else {
            //
            // Local CO retire.  Activate VV retire slot if not yet done.
            //
            if (!CO_FLAG_ON(ChangeOrder, CO_FLAG_VV_ACTIVATED)) {
                SetFlag(RetireFlags, ISCU_ACTIVATE_VV);
                //SET_CO_FLAG(ChangeOrder, CO_FLAG_VV_ACTIVATED);
            }
            //
            // None of these events have happened yet.
            //
            SetFlag(RetireFlags, ISCU_UPDATE_IDT_ENTRY);

            if (!CO_FLAG_ON(ChangeOrder, CO_FLAG_GROUP_ANY_REFRESH)) {
                SetFlag(RetireFlags, ISCU_INS_OUTLOG);
            }

            //
            // If this is just an OID reset operation (some other agent tried
            // to change the OID on the file) then we do not insert the CO in
            // the outbound log and we do not update the entire IDTable record
            // (update just the USN field).  If we updated the IDTable entry with
            // the new VSN for this change order AND a VVJOIN scan was going on
            // at the same time then the VVJOIN code will not create a CO for
            // the file since it is expecting that a new CO will be forthcoming
            // in the Outbound log.  That is not true in this case so no CO would
            // get sent to the VVJoining partner.  To avoid this we don't
            // update the VSN field in the change order since the whole deal was
            // a no-op anyway.
            //
            if (CO_FLAG_ON(ChangeOrder, CO_FLAG_JUST_OID_RESET)) {
                ClearFlag(RetireFlags, ISCU_INS_OUTLOG);
                ClearFlag(RetireFlags, ISCU_UPDATE_IDT_ENTRY);
                SetFlag(RetireFlags, ISCU_UPDATE_IDT_FILEUSN);
            }

            TALLY_LOCALCO_STATS(ConfigRecord, NumCoRetired, 1);
        }
    }

    //
    // Mark the FileUsn field of the change order valid.  This allows the
    // OutLog process to make valid USN tests on requested staging files.
    // This can not be set on the retry path because the install and final
    // rename will change the USN on the file.
    //
    // Note: The change order is picking up the usn of the file on this
    // machine.  When the staging file is fetched from the inbound partner the
    // FileUsn reflects the value for the file on this machine and not the usn
    // of the file on the inbound partner Hence, the usn is not valid.  Even if
    // this were fixed by retaining the value of the FileUsn from the inbound
    // partner, the value on the inbound partner may change when the staging
    // file is installed.
    //
    // SET_CO_FLAG(ChangeOrder, CO_FLAG_FILE_USN_VALID);

    //
    // Finally cleanup the CO Issue structs and delete the inbound log entry.
    // Both of these are done under ref count control.
    //
    SetFlag(RetireFlags, (ISCU_ISSUE_CLEANUP));

    if (!COE_FLAG_ON(ChangeOrder, COE_FLAG_DELETE_GEN_CO)) {
        SetFlag(RetireFlags, ISCU_DEL_INLOG);
    }

    //
    // Do it.
    //
    SetFlag(RetireFlags, ISCU_NO_CLEANUP_MERGE);
    FStatus = ChgOrdIssueCleanup(ThreadCtx, Replica, ChangeOrder, RetireFlags);

ERROR_RETURN:

    if (!FRS_SUCCESS(FStatus)) {
        JrnlSetReplicaState(Replica, REPLICA_STATE_ERROR);
        //
        // Note:  Multiple COs can retire and set Replica->FStatus
        //        Need another mechanism if initiator cares.
        //
        Replica->FStatus = FStatus;
    }

    return FStatus;

}


ULONG
DbsDoRenameOrDelete(
    IN  PTHREAD_CTX ThreadCtx,
    IN  PREPLICA Replica,
    IN  PCHANGE_ORDER_ENTRY ChangeOrder,
    OUT PBOOL AbortCo
)
/*++

Routine Description:

    Execute final rename or deferred delete for the change order.
    If the rename or delete fails the caller sends the CO thru the retry path.
    If a dir delete fails because there are now valid children under the dir
    then we abort the CO.

Arguments:

    Replica  -- ptr to replica struct
    ChangeOrder -- ptr to change order entry
    Abort       -- ptr to BOOL to return updated CO abort status.

Return Value:

    FrsStatus
        FrsErrorDirNotEmpty - Delete dir fails due to valid children
        FrsErrorRetry - Operation could not be done now.  Send CO thru retry.
        FrsErrorSuccess - Operation succeeded.

--*/

{
#undef DEBSUB
#define DEBSUB "DbsDoRenameOrDelete:"

    ULONG                 WStatus;
    PCHANGE_ORDER_COMMAND CoCmd;
    PREPLICA_THREAD_CTX   RtCtx;
    PIDTABLE_RECORD       IDTableRec;
    BOOL                  DeleteCo;
    ULONG                 LocationCmd;
    ULONG                 Len;
    JET_ERR               jerr, jerr1;
    BOOL                  ChildrenExist = FALSE;
    PTABLE_CTX            TmpIDTableCtx;

    CoCmd = &ChangeOrder->Cmd;

    LocationCmd = GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command);
    DeleteCo = (LocationCmd == CO_LOCATION_DELETE) ||
               (LocationCmd == CO_LOCATION_MOVEOUT);

    //
    // A newly created file is first installed into a temporary file and then
    // renamed to its final destination.  The rename may fail if the user has
    // used the filename for another file.  This case is handled later.
    // However, a subsequent change order may arrive before retrying the
    // failing rename.  The new change order will attempt the rename because
    // the idtable entry has the deferred rename bit set.  This old change
    // order will be discarded by the reconcile code in ChgOrdAccept().
    //
    // We attempt the rename here so that the file's usn value
    // is correct in the change order.
    //
    // Ditto afor deferred deletes.
    //
    WStatus = ERROR_SUCCESS;
    if (!DeleteCo && COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_RENAME)) {

        //
        // NOTE: We must use the info in the IDTable to do the final rename
        // since we could have multiple COs in the IBCO_INSTALL_REN_RETRY
        // state and only the IDTable has the correct info re the final location
        // and name for the file.  If the CO does not arrive here in the
        // REN_RETRY state then use the state in the change order as given.
        //
        if (CO_STATE_IS(ChangeOrder, IBCO_INSTALL_REN_RETRY)) {
            RtCtx = ChangeOrder->RtCtx;
            FRS_ASSERT(RtCtx != NULL);

            IDTableRec = RtCtx->IDTable.pDataRecord;
            FRS_ASSERT(IDTableRec != NULL);

            CoCmd->NewParentGuid = IDTableRec->ParentGuid;
            ChangeOrder->NewParentFid = IDTableRec->ParentFileID;

            Len = wcslen(IDTableRec->FileName) * sizeof(WCHAR);
            CopyMemory(CoCmd->FileName, IDTableRec->FileName, Len);
            CoCmd->FileName[Len/sizeof(WCHAR)] = UNICODE_NULL;

            CoCmd->FileNameLength = (USHORT) Len;
        }


        TEST_DBSRENAMEFID_TOP(ChangeOrder);
        WStatus = DbsRenameFid(ChangeOrder, Replica);
        TEST_DBSRENAMEFID_BOTTOM(ChangeOrder, WStatus);

        //
        // Short circuit the retire process if the file could not be renamed
        // into its final destination.  Set the change order as "retry later"
        // in the inbound log.  The change order is done except for this.
        // If this is the first time through for this change order then
        // DbsRetryInboundCo will take care of VV update, partner Ack, ...
        // In addition it updates the IDTable record to show the rename is
        // still pending.
        //
        if (WIN_RETRY_INSTALL(WStatus) ||
            WIN_ALREADY_EXISTS(WStatus)) {
            SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_INSTALL_REN_RETRY);

            return FrsErrorRetry;
        }

    } else

    if (DeleteCo && COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_DELETE)) {
        //
        // Handle deferred delete.
        //
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Attempt Deferred Delete");

        WStatus = StuDelete(ChangeOrder);
        if (!WIN_SUCCESS(WStatus)) {
            //
            // Short circuit the retire process if the file could not be deleted.
            //
            // If this is a file and we failed to delete send the CO thru
            // delete retry.
            // If this is a dir and we failed to delete because the dir is not
            // empty or we got some other retryable error then first check
            // to see if there are any valid children.  If there are valid
            // children then abort the CO otherwise send it thru delete retry
            // which will mark the IDTable entry as IDREC_FLAGS_DELETE_DEFERRED.
            //
            if (WIN_RETRY_DELETE(WStatus)) {
                if (CoIsDirectory(ChangeOrder)) {
                    //
                    // check to see if there are any valid children
                    //
                    // If the dir has vaild children. Check if these children
                    // are waiting to be deleted. They might have the
                    // IDREC_FLAGS_DELETE_DEFERRED flag set in the idtable.
                    // If there is atleast 1 child entry in the idtable that
                    // has an event time later than the even time on the
                    // change order then we should abort the change order.
                    //

                    TmpIDTableCtx = FrsAlloc(sizeof(TABLE_CTX));
                    TmpIDTableCtx->TableType = TABLE_TYPE_INVALID;
                    TmpIDTableCtx->Tid = JET_tableidNil;

                    jerr = DbsOpenTable(ThreadCtx, TmpIDTableCtx, Replica->ReplicaNumber, IDTablex, NULL);

                    if (JET_SUCCESS(jerr)) {

                        ChildrenExist = JrnlDoesChangeOrderHaveChildren(ThreadCtx, TmpIDTableCtx, ChangeOrder);

                        DbsCloseTable(jerr1, ThreadCtx->JSesid, TmpIDTableCtx);
                        DbsFreeTableCtx(TmpIDTableCtx, 1);
                        FrsFree(TmpIDTableCtx);

                        if (ChildrenExist) {
                            //
                            // The dir has vaild children.  Abort the CO.
                            //
                            CHANGE_ORDER_TRACE(3, ChangeOrder, "DIR has valid child. Aborting");
                            *AbortCo = TRUE;
                            SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_ABORTING);

                            //
                            // Even though we can't delete the dir this del CO was
                            // accepted so we need to update the version info in
                            // the IDTable record.  This ensures that if any new local
                            // changes to this dir are generated, the version info
                            // that gets sent out is current so the CO will be
                            // accepted downstream in the event that the downstream
                            // member did actually accept and process this delete.
                            // If that had happened but later the dir was reanimated
                            // downstream (say because we generated a new child file)
                            // the version info downstream is retained which could
                            // cause a later update (or a delete) from this member
                            // to be rejected (e.g. event time within the window
                            // but out version number is lower than it should be).
                            // bug 290440 is an example of this.
                            //
                            return FrsErrorDirNotEmpty;
                        }

                    } else {
                        DPRINT1_JS(0, "DbsOpenTable (IDTABLE) on replica number %d failed.",
                                   Replica->ReplicaNumber, jerr);
                        DbsCloseTable(jerr1, ThreadCtx->JSesid, TmpIDTableCtx);
                        DbsFreeTableCtx(TmpIDTableCtx, 1);
                        FrsFree(TmpIDTableCtx);
                    }
                }
                //
                // Set the change order as IBCO_INSTALL_DEL_RETRY in the
                // inbound log.  The change order is done except for this.  If
                // this is the first time through for this change order then
                // DbsRetryInboundCo will take care of VV update, partner Ack,
                // ...  In addition it updates the IDTable record to show the
                // delete is still pending.
                //
                SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_INSTALL_DEL_RETRY);

                return FrsErrorRetry;
            }
        }
    }

    return FrsErrorSuccess;
}

ULONG
DbsRetireInboundCo(
    IN PTHREAD_CTX ThreadCtx,
    IN PCOMMAND_PACKET CmdPkt
)
/*++

Routine Description:

    Add revised comment.

Arguments:

    ThreadCtx   -- ptr to the thread context.

    CmdPkt  - The command packt with the retire request.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsRetireInboundCo:"

    FRS_ERROR_CODE        FStatus;
    PDB_SERVICE_REQUEST   DbsRequest = &CmdPkt->Parameters.DbsRequest;
    PCONFIG_TABLE_RECORD  ConfigRecord;
    PREPLICA              Replica;
    PCHANGE_ORDER_ENTRY   ChangeOrder;
    PREPLICA_THREAD_CTX   RtCtx;
    ULONG                 RetireFlags;
    BOOL                  RemoteCo, AbortCo, ValidDirChild;
    ULONG                 CondTest, i;
    PCO_RETIRE_DECISION_TABLE pDecRow;
    PCHAR                 pTag;
    CHAR                  TempStr[120];


    FRS_ASSERT(DbsRequest != NULL);

    Replica       = DbsRequest->Replica;
    FRS_ASSERT(Replica != NULL);

    ChangeOrder   = (PCHANGE_ORDER_ENTRY) DbsRequest->CallContext;
    FRS_ASSERT(ChangeOrder != NULL);

    RemoteCo = !CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);

    AbortCo = COE_FLAG_ON(ChangeOrder, COE_FLAG_STAGE_ABORTED) ||
              CO_STATE_IS(ChangeOrder, IBCO_ABORTING);

    ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);
    FRS_ASSERT(ConfigRecord != NULL);


    ValidDirChild = FALSE;
    RetireFlags = 0;

    if (!AbortCo) {
        //
        // Do final rename of target file or handle deferred delete.
        //
        FStatus = DbsDoRenameOrDelete(ThreadCtx, Replica, ChangeOrder, &AbortCo);
        if (FStatus == FrsErrorRetry) {
            return (DbsRetryInboundCo(ThreadCtx, CmdPkt));
        }
        //
        // We could get dir not empty if a dir delete now has valid children.
        //
        if (FStatus == FrsErrorDirNotEmpty) {
            ValidDirChild = TRUE;
        }
    }

    //
    // Increment the Local OR Remote CO Aborted OR Retired counters
    //
    if (AbortCo) {
        if (RemoteCo) {
            PM_INC_CTR_REPSET(Replica, RCOAborted, 1);
            TALLY_REMOTECO_STATS(ConfigRecord, NumCoAborts, 1);
        }
        else {
            PM_INC_CTR_REPSET(Replica, LCOAborted, 1);
            TALLY_LOCALCO_STATS(ConfigRecord, NumCoAborts, 1);
        }
    } else {
        if (RemoteCo) {
            PM_INC_CTR_REPSET(Replica, RCORetired, 1);
            TALLY_REMOTECO_STATS(ConfigRecord, NumCoRetired, 1);
        }
        else {
            PM_INC_CTR_REPSET(Replica, LCORetired, 1);
            TALLY_LOCALCO_STATS(ConfigRecord, NumCoRetired, 1);
        }
    }

    //
    // Decide what to do about the staging file.
    // A local change order is trying to generate the staging file and a
    // failure here means it hasn't yet been generated.
    // A remote change order is trying to fetch and install the staging file
    // and a failure here means the install could not be completed.
    // There are a number of cases.
    //
    // Local, No partners  -- no staging file is created.
    // Local, 1st time, With partners -- Outlog will del staging file
    // Local, 1st time, Abort, With partners -- Del stagefile (if any)
    // Local, retry, with partners -- stagefile now gen, Outlog dels staging file
    // Local, retry, abort, with partners -- Del stagefile (if any)
    //
    // Remote, No partners  -- Del stagefile
    // Remote, 1st time, with partners -- OLOG will del stagefile
    // Remote, 1st time, Abort, with partners -- Del stagefile
    // Remote, retry, with partners -- Clear flag in olog
    // Remote, retry, Abort, with partners -- clear flag in olog
    //

    //
    // Check for the case of an aborted CO.  We do nothing here if the user
    // deleted the file so we couldn't generate the staging file.
    //
    if (AbortCo &&
        !COE_FLAG_ON(ChangeOrder, COE_FLAG_STAGE_DELETED)) {
        //
        // If the abort is on a dir create then pitch the CO.
        // (not if it's a parent reanimation though).
        // (not if it's a reparse)
        //

        if (CoIsDirectory(ChangeOrder) &&
            (!COE_FLAG_ON(ChangeOrder, COE_FLAG_PARENT_REANIMATION)) &&
            (!(ChangeOrder->Cmd.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT))) {

            ULONG LocationCmd = GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command);

            if (CO_NEW_FILE(LocationCmd)) {
                //
                // Unfortunately we can get an "update CO" for an existing file
                // and the CO has a location command of CREATE.  So we can't
                // be sure that the error we are seeing is a case of failing
                // to update a pre-existing file in the replica tree that has
                // been deleted out from under us.   If it has been deleted
                // then a local CO should be coming that tells us that.
                // If it hasn't been deleted and the install failed because we
                // ran out of disk space or some other problem then we could
                // have problems later when a child create shows up and there
                // is no parent.  To address this, InstallCsInstallStage()
                // checks if the pre-exisitng target file was deleted and it
                // sends the change order thru retry (or unjoins the connection)
                // as appropriate.  If a dir create fails for some other reason
                // we end up here.
                //
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Dir create failed, aborting");
                FRS_PRINT_TYPE(0, ChangeOrder);
            }
        }
    }

    SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_COMMIT_STARTED);

    //
    // Construct the test value.
    //
    CondTest = (CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO)           ? 1 : 0) << 8
             | (AbortCo                                            ? 1 : 0) << 7
             | (CO_FLAG_ON(ChangeOrder, CO_FLAG_VV_ACTIVATED)      ? 1 : 0) << 6
             | (CO_IFLAG_ON(ChangeOrder, CO_IFLAG_VVRETIRE_EXEC)   ? 1 : 0) << 5
             | (CO_FLAG_ON(ChangeOrder, CO_FLAG_GROUP_ANY_REFRESH) ? 1 : 0) << 4
             | (CO_FLAG_ON(ChangeOrder, CO_FLAG_RETRY)             ? 1 : 0) << 3
             | (CO_FLAG_ON(ChangeOrder, CO_FLAG_JUST_OID_RESET)    ? 1 : 0) << 2
             | (CO_FLAG_ON(ChangeOrder, CO_FLAG_NEW_FILE)          ? 1 : 0) << 1
             | (ValidDirChild                                      ? 1 : 0) << 0;

    //
    // Step thru the change order retire decsion table and select the matching
    // cleanup actions.
    //
    pDecRow = CoRetireDecisionTable;
    i = 0;
    TempStr[0] = '\0';
    while (pDecRow->RetireFlag != 0) {
        if ((CondTest & pDecRow->DontCareMask) == pDecRow->ConditionMatch) {
            RetireFlags |= pDecRow->RetireFlag;
            _snprintf(TempStr, sizeof(TempStr), "%s %d", TempStr, i);
        }
        i++;
        pDecRow += 1;
    }
    DPRINT3(4, "++ CondTest %08x - RetireFlags %08x - %s\n", CondTest, RetireFlags, TempStr);

    if (RemoteCo) {

        //
        // Remote CO retire.  Activate VV retire slot if not yet done.
        //
        //if (!CO_FLAG_ON(ChangeOrder, CO_FLAG_VV_ACTIVATED)) {
            //SET_CO_FLAG(ChangeOrder, CO_FLAG_VV_ACTIVATED);
        //}
        //
        // Install is done.  Clear incomplete flag and update IDT entry
        // with the new file state.
        //
        CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_INSTALL_INCOMPLETE);
        //
        // Note: If partial installs are provided then only update the
        // appropriate IDTable elements to prevent data from moving backwards
        // if the partial instals can complete out of order.

    } else {

        //
        // Local CO retire.
        //
        if (AbortCo) {
            SET_CO_FLAG(ChangeOrder, CO_FLAG_ABORT_CO);  // unused ??
        } //else {
            //
            // Local CO retire.  Activate VV retire slot if not yet done.
            //
            //if (!CO_FLAG_ON(ChangeOrder, CO_FLAG_VV_ACTIVATED)) {
                //SET_CO_FLAG(ChangeOrder, CO_FLAG_VV_ACTIVATED);
            //}

        //}
    }

    //
    // Mark the FileUsn field of the change order valid.  This allows the
    // OutLog process to make valid USN tests on requested staging files.
    // This can not be set on the retry path because the install and final
    // rename will change the USN on the file.
    //
    // Note: The change order is picking up the usn of the file on this
    // machine.  When the staging file is fetched from the inbound partner the
    // FileUsn reflects the value for the file on this machine and not the usn
    // of the file on the inbound partner Hence, the usn is not valid.  Even if
    // this were fixed by retaining the value of the FileUsn from the inbound
    // partner, the value on the inbound partner may change when the staging
    // file is installed.
    //
    // SET_CO_FLAG(ChangeOrder, CO_FLAG_FILE_USN_VALID);

    //
    // Finally cleanup the CO Issue structs and delete the inbound log entry.
    // Both of these are done under ref count control.
    //
    SetFlag(RetireFlags, (ISCU_ISSUE_CLEANUP));

    if (!COE_FLAG_ON(ChangeOrder, COE_FLAG_DELETE_GEN_CO)) {
        SetFlag(RetireFlags, ISCU_DEL_INLOG);
    }

    //
    // Produce a tracking record for the log.
    //
    pTag = (AbortCo) ?
              ((RemoteCo) ? "RemCo, Abort" : "LclCo, Abort") :
              ((RemoteCo) ? "RemCo" : "LclCo");

    FRS_TRACK_RECORD(ChangeOrder, pTag);

    //
    // Do it.
    //
    SetFlag(RetireFlags, ISCU_NO_CLEANUP_MERGE);
    FStatus = ChgOrdIssueCleanup(ThreadCtx, Replica, ChangeOrder, RetireFlags);

ERROR_RETURN:

    if (!FRS_SUCCESS(FStatus)) {
        JrnlSetReplicaState(Replica, REPLICA_STATE_ERROR);
        //
        // Note:  Multiple COs can retire and set Replica->FStatus
        //        Need another mechanism if initiator cares.
        //
        Replica->FStatus = FStatus;
    }

    return FStatus;

}


ULONG
DbsInjectOutboundCo(
    IN PTHREAD_CTX ThreadCtx,
    IN PCOMMAND_PACKET CmdPkt
)
/*++

Routine Description:

    This function injects a handcrafted change order into the outbound log.

    This function is designed to support version vector joining (vvjoin.c).

Arguments:

    ThreadCtx   -- ptr to the thread context.

    CmdPkt  - The command packt with the retire request.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsInjectOutboundCo:"

    FRS_ERROR_CODE        FStatus;
    PDB_SERVICE_REQUEST   DbsRequest = &CmdPkt->Parameters.DbsRequest;
    PREPLICA              Replica;
    PCHANGE_ORDER_ENTRY   ChangeOrder;
    ULONG                 RetireFlags = 0;
    ULONG                 LocationCmd;


    FRS_ASSERT(DbsRequest != NULL);

    Replica       = DbsRequest->Replica;
    FRS_ASSERT(Replica != NULL);

    ChangeOrder   = (PCHANGE_ORDER_ENTRY) DbsRequest->CallContext;
    FRS_ASSERT(ChangeOrder != NULL);

    LocationCmd = GET_CO_LOCATION_CMD(ChangeOrder->Cmd, Command);
    FRS_ASSERT(LocationCmd == CO_LOCATION_CREATE ||
               LocationCmd == CO_LOCATION_DELETE ||
               CO_FLAG_ON(ChangeOrder, CO_FLAG_CONTROL));
    FRS_ASSERT(CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO));

    //
    // Change of plans; allow the propagation to occur so that
    // parallel vvjoins and vvjoinings work (A is vvjoining B is
    // vvjoining C).
    //
    // FRS_ASSERT(CO_FLAG_ON(ChangeOrder, CO_FLAG_REFRESH));

    //
    // Insert into the outbound log and free the change order entry
    // There is no inbound log entry and there is no staging file.
    // The staging file is generated on demand.
    //
    RetireFlags = ISCU_INS_OUTLOG |
                  ISCU_DEL_RTCTX  |
                  ISCU_DEC_CO_REF |
                  ISCU_FREE_CO;

    //
    // Do it.
    //
    SetFlag(RetireFlags, ISCU_NO_CLEANUP_MERGE);
    FStatus = ChgOrdIssueCleanup(ThreadCtx, Replica, ChangeOrder, RetireFlags);

ERROR_RETURN:

    if (!FRS_SUCCESS(FStatus)) {
        JrnlSetReplicaState(Replica, REPLICA_STATE_ERROR);
        //
        // Note:  Multiple COs can retire and set Replica->FStatus
        //        Need another mechanism if initiator cares.
        //
        Replica->FStatus = FStatus;
    }

    return FStatus;

}



ULONG
DbsRetryInboundCo(
    IN PTHREAD_CTX ThreadCtx,
    IN PCOMMAND_PACKET CmdPkt
)
/*++

Routine Description:

    The inbound change order has failed to complete.  This could be due to:

        1.  a sharing violation on the target file for a remote change order
            preventing the Install of the staging file, IBCO_INSTALL_RETRY
        2.  a sharing violation on the source file for a local change order
            preventing the generation of the staging file, IBCO_STAGING_RETRY
        3.  a problem fetching the staging file from an inbound partner for
            a remote chang order, IBCO_FETCH_RETRY
        4.  a problem renaming the file into its target location. IBCO_INSTALL_REN_RETRY
        5.  a problem deleting the file or dir. IBCO_INSTALL_DEL_RETRY

    Set up the change order to be retried. It does the following:

        Set the CO_FLAG_RETRY flag in the change order.
        Once we have the staging file we can activate the version vector
        retire slot.  When the slot reaches the head of the VV retire list
        the version vector is updated and the change order is propagated to
        the outbound log.  Those actions are not done here.

        If a remote CO and the state is IBCO_INSTALL_RETRY then set the
        CO_FLAG_INSTALL_INCOMPLETE flag so the outbound log doesn't delete
        the staging file.

        For remote CO's, when we activate the VV slot we also Ack the inbound
        partner and update the IDT table for the file so new CO's can test
        against it.

        Update the CO in the inbound log. (caller provides the CO state to save)
        Cleanup the Issue Conflict tables.

    The TableCtx structs in the ChangeOrder RtCtx are used to update
    the database records.

Arguments:

    ThreadCtx   -- ptr to the thread context.

    CmdPkt  - The command packt with the retire request.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsRetryInboundCo:"

    JET_ERR               jerr, jerr1;
    FRS_ERROR_CODE        FStatus;
    PDB_SERVICE_REQUEST   DbsRequest = &CmdPkt->Parameters.DbsRequest;
    PREPLICA              Replica;
    PCHANGE_ORDER_ENTRY   ChangeOrder;
    PCHANGE_ORDER_COMMAND CoCmd;
    BOOL                  FirstTime;
    BOOL                  RemoteCo;
    ULONG                 RetireFlags = 0;
    PIDTABLE_RECORD       IDTableRec;
    PCHAR                 pTag;

    // Note: Check that we don't reorder change orders that would cause name
    // space conflicts.  see below.
    //
    // Note: We can't move the change order to the end of the list
    // because it could result in a name conflict with an operation behind
    // it.  E.G. A delete followed by a create with the same name.  Even
    // though the FIDs are different we would still send the change orders
    // out to other replicas in the wrong order.  So name space operations
    // can never be reordered.
    //
    // Examine sequences of name space operations and the effects of reordering.
    // Look for notes on this.
    //

    FRS_ASSERT(DbsRequest != NULL);

    Replica = DbsRequest->Replica;
    FRS_ASSERT(Replica != NULL);

    ChangeOrder = (PCHANGE_ORDER_ENTRY) DbsRequest->CallContext;
    FRS_ASSERT(ChangeOrder != NULL);
    FRS_ASSERT(ChangeOrder->RtCtx != NULL);
    FRS_ASSERT(IS_ID_TABLE(&ChangeOrder->RtCtx->IDTable));

    IDTableRec = ChangeOrder->RtCtx->IDTable.pDataRecord;
    FRS_ASSERT(IDTableRec != NULL);

    CoCmd = &ChangeOrder->Cmd;

    RemoteCo  = !CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);
    FirstTime = !CO_FLAG_ON(ChangeOrder, CO_FLAG_RETRY);

    DPRINT5(4, "++ %s CO State, Flags, File on %s entry: %s  %08x  %ws\n",
            (RemoteCo ? "Remote" : "Local "), (FirstTime ? "1st" : "Nth"),
            PRINT_CO_STATE(ChangeOrder), CoCmd->Flags, CoCmd->FileName);

    //
    // We only understand the following kinds of retry operations.
    //
    if (RemoteCo) {
        FRS_ASSERT(CO_STATE_IS_REMOTE_RETRY(ChangeOrder));
    } else {
        //
        // Can't come thru retry with a moveout generated delete CO since
        // there is no INLOG record for it.
        //
        // Abort the change order because the only reason this co will retry
        // is if the cxtion is unjoining.  The originating, moveout co will
        // regenerate the del cos during the recovery at the next join.
        //
        if (COE_FLAG_ON(ChangeOrder, COE_FLAG_DELETE_GEN_CO)) {
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Moveout Del Retry Aborted");
            SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_ABORTING);
            return  DbsRetireInboundCo(ThreadCtx, CmdPkt);
        }

        //
        // Morph Gen local COs also don't go in the INLog since they get
        // regenerated as long as the Morph Conflict still exists.  So
        // Abort the change order.  The base CO will go thru retry.
        //
        if (CO_FLAG_ON(ChangeOrder, CO_FLAG_MORPH_GEN)) {
            CHANGE_ORDER_TRACE(3, ChangeOrder, "MorphGenCo Aborted");
            SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_ABORTING);
            return  DbsRetireInboundCo(ThreadCtx, CmdPkt);
        }
    }

    //
    // If this is a parent reanimation CO then retry is not an option.
    // Send this bad boy to retire with the Abort flag set.
    //
    if (COE_FLAG_ON(ChangeOrder, COE_FLAG_PARENT_REANIMATION)) {
        CHANGE_ORDER_TRACE(3, ChangeOrder, "Parent Reanimate Retry Aborted");
        SET_CHANGE_ORDER_STATE(ChangeOrder, IBCO_ABORTING);
        return  DbsRetireInboundCo(ThreadCtx, CmdPkt);
    }

    //
    // Aborts must go through retire, NOT retry path.
    //
    FRS_ASSERT(!CO_FLAG_ON(ChangeOrder, CO_FLAG_ABORT_CO));  // unused ??

    //
    // This CO is now a retry change order.
    //
    SET_CO_FLAG(ChangeOrder, CO_FLAG_RETRY);

    //
    // If this is a local CO that is in the process of creating a new file
    // AND we can't generate the staging file or stamp the OID on the file
    // (i.e. state is IBCO_STAGING_RETRY) then we MUST preserve the IDTable
    // entry because it has the FIDs for the file.  The FIDs are not saved
    // in the INlog record, only the GUIDs.  The assigned Guid for the file
    // must also be preserved so the retry re-issue of the CO can find the
    // IDTable Record when it translates the GUID to the FID.
    //
    // Consider the following scenario:
    //  CO1:  Local file create fails to generate stage file due to share viol.
    //        IDTRec->NewFileInprog set.
    //        CO1 goes to retry.
    //
    //  CO2:  Now an update CO arrives for same file as above.  We have to be
    //        sure to use same IDT entry and same GUID assigned to the file
    //        by CO1 otherwise when CO1 is later retried it won't be able
    //        to do the Guid to Fid translation, causing it to assert.  This
    //        occurs regardless of whether CO2 completes, aborts or goes thru
    //        retry since eventually CO1 will be retried.
    //        Clearing NewFileInProgress and setting DeferredCreate ensures this.
    //
    // HOWEVER:
    // If this is a Delete CO with the NEW_FILE_IN_PROGRESS flag set then we
    // are in the process of creating a tombstone entry in the IDTable.  This
    // CO probably got sent thru retry because we unjoined the journal connection.
    // One way a local CO like this gets created is when an incoming remote CO
    // loses a name morph conflict.  A local CO delete is fabricated and sent
    // out so all other members see the result.  In this case, leave the IDTable
    // flags alone so the right things happen when the CO is retried.
    //
    if (!RemoteCo &&
        CO_STATE_IS(ChangeOrder, IBCO_STAGING_RETRY) &&
        IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_NEW_FILE_IN_PROGRESS)) {

        if (!CO_LOCN_CMD_IS(ChangeOrder, CO_LOCATION_DELETE)) {
            ClearIdRecFlag(IDTableRec, IDREC_FLAGS_NEW_FILE_IN_PROGRESS);
            SetIdRecFlag(IDTableRec, IDREC_FLAGS_CREATE_DEFERRED);

            SetFlag(RetireFlags, ISCU_UPDATE_IDT_FLAGS);
        }

        //
        // Prevent deletion of IDTable entry later because a subsequent Local
        // CO (X) may have completed an update on the file and be in the process
        // queue.  If so then we will need the GUID to FID translation provided
        // by this IDTable entry so when we retry this CO later we find the same
        // IDTable entry (but this time with the updated state provided by CO
        // X).  Recall that the InLog record does not keep FIDs so the only way
        // we get back to the same IDTable record that X will use is with the
        // GUID.
        //
        CLEAR_CO_FLAG(ChangeOrder, CO_FLAG_NEW_FILE);
    }




    //
    // Set CO_FLAG_INSTALL_INCOMPLETE to keep the Oubound log from deleting
    // the staging file if this CO still hasn't done the install.
    //
    if (RemoteCo && CO_STATE_IS(ChangeOrder, IBCO_INSTALL_RETRY)) {
        SET_CO_FLAG(ChangeOrder, CO_FLAG_INSTALL_INCOMPLETE);
    }

    //
    // If the change order has progressed far enough to Activate the version
    // vector retire slot and Ack the inbound partner then do it.
    // Local change orders only do this through the normal retire path since we
    // can't propagate the CO to the outbound log until we have a staging file
    // generated.  The partner Ack will happen now but the actual VV update may
    // be delayed if it is blocked by other VV updates in the retire list.  This
    // call just activates the VV retire slot.
    //
    if (!CO_FLAG_ON(ChangeOrder, CO_FLAG_VV_ACTIVATED)) {

        if (RemoteCo && CO_STATE_IS_INSTALL_RETRY(ChangeOrder)) {

            SetFlag(RetireFlags, ISCU_ACTIVATE_VV  | ISCU_ACK_INBOUND);

            //
            // Updating the IDTable on a change order in the retry path will
            // eventually cause it to be rejected when it is later retried.  In
            // addition a dup CO from another inbound partner will also get
            // rejected even though it should get a shot.  So instead of
            // updating the entire record we just update the Flags here.
            // BUT ... see comment below re DELETE_DEFERRED.
            //
            SetFlag(RetireFlags, ISCU_UPDATE_IDT_FLAGS);
            //
            // perf: If the staging file is already fetched then we should detect
            //       that and avoid refetching it.

            if (!CO_FLAG_ON(ChangeOrder, CO_FLAG_GROUP_ANY_REFRESH)) {
                SetFlag(RetireFlags, ISCU_INS_OUTLOG);
            }
            //
            // Don't do it again on future retries.
            //
            //SET_CO_FLAG(ChangeOrder, CO_FLAG_VV_ACTIVATED);
        } else {
            //
            // Can't activate the retire slot so discard it.  If it is a Remote
            // change order and the problem wasn't caused by a loss of the
            // inbound connection then it is probably out of order.
            //
            SetFlag(RetireFlags, ISCU_ACTIVATE_VV_DISCARD);
            if (RemoteCo) {
                if (!COE_FLAG_ON(ChangeOrder, COE_FLAG_NO_INBOUND)) {
                    SET_CO_FLAG(ChangeOrder, CO_FLAG_OUT_OF_ORDER);
                }
            }
        }
    }


    //
    // Regardless of what happened above with VV slot activation several flags
    // need to set in the IDTable record if the remote CO is in one of the
    // install retry states.
    //
    if (RemoteCo && CO_STATE_IS_INSTALL_RETRY(ChangeOrder)) {
        //
        // Set IDREC_FLAGS_RENAME_DEFERRED if we failed to rename the
        // preinstall file to its final destination. The first change order
        // that next comes through for this will try again.
        //
        // BUT...  if this CO is in the IBCO_INSTALL_REN_RETRY state then we
        // have actually finished the CO except for the final rename.  So
        // Update the IDTable Record and the journal's parent fid table and
        // filter table and the version state for future COs, etc.
        // Reconcile() will let this CO pass so the rename can be completed
        // as long as as IDREC_FLAGS_RENAME_DEFERRED remains set.  The first
        // CO that completes the rename will clear the bit.
        //
        if (CO_STATE_IS(ChangeOrder, IBCO_INSTALL_REN_RETRY)) {
            SetIdRecFlag(IDTableRec, IDREC_FLAGS_RENAME_DEFERRED);
            SetFlag(RetireFlags, ISCU_UPDATE_IDT_ENTRY);
        }

        //
        // If we come thru here in the IBCO_INSTALL_RETRY state then don't
        // update the full IDTable Record because that updates the version
        // info which has the effect of rejecting other dup COs that may
        // be able to finish this CO.  In addition this CO would get
        // rejected on retry because reconcile will find a version match.
        // See ChgOrdReconcile() for why it must reject matching COs in the
        // IBCO_INSTALL_RETRY state.  But we still must set
        // IDREC_FLAGS_RENAME_DEFERRED if we found it set when we started
        // this CO so that other COs will try to complete the final rename.
        //
        if (COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_RENAME)) {
            SetIdRecFlag(IDTableRec, IDREC_FLAGS_RENAME_DEFERRED);
        }

        //
        // Set IDREC_FLAGS_DELETE_DEFERRED if we failed to delete the
        // target file/dir. The first change order
        // that next comes through for this will try again.
        //
        // BUT... if this CO is in the delete retry state then we have
        // actually finished the CO except for the final delete.  So Update
        // the IDTable Record.  Reconcile() will let this CO pass as long
        // as IDREC_FLAGS_DELETE_DEFERRED remains set.
        //
        if (CO_STATE_IS(ChangeOrder, IBCO_INSTALL_DEL_RETRY) ||
            COE_FLAG_ON(ChangeOrder, COE_FLAG_NEED_DELETE)) {
            SetIdRecFlag(IDTableRec, IDREC_FLAGS_DELETE_DEFERRED);
            SetFlag(RetireFlags, ISCU_UPDATE_IDT_ENTRY);
        }

        //
        // This CO may have been on a New File.
        //
        // Note: What if this was a dir and another CO comes in while
        //       this one is in retry and hits a name morph conflict?
        //       If we haven't installed how will this CO get handled
        //       assuming we lose the name conflict?
        //
        // If this CO is on a new file then don't clear the NEW_FILE_IN_PROGRESS
        // flag.  This ensures that the CO will get re-issued when it comes
        // up for retry later.  Otherwise the version info in the CO will
        // match the initial version info in the IDTable and the CO will
        // get rejected for sameness.
        //
        if (CO_STATE_IS(ChangeOrder, IBCO_INSTALL_REN_RETRY) ||
            CO_STATE_IS(ChangeOrder, IBCO_INSTALL_DEL_RETRY)) {
            ClearIdRecFlag(IDTableRec, IDREC_FLAGS_NEW_FILE_IN_PROGRESS);
        }

        //
        // Updating the IDTable on a change order in the retry path will
        // eventually cause it to be rejected when it is later retried.  In
        // addition a dup CO from another inbound partner will also get
        // rejected even though it should get a shot.  So instead of
        // updating the entire record we just update the Flags here.
        // BUT ... see comment above re DELETE_DEFERRED.
        //
        SetFlag(RetireFlags, ISCU_UPDATE_IDT_FLAGS);
        //
        // perf: If the staging file is already fetched then we should detect
        // that and avoid refetching it.

    }

    //
    // Produce a tracking record for the log.  First time only or could flood log.
    //
    if (FirstTime) {
        pTag = (RemoteCo) ? "Retry RemCo" : "Retry LclCo";
        FRS_TRACK_RECORD(ChangeOrder, pTag);
    }

    SetFlag(RetireFlags, ISCU_NO_CLEANUP_MERGE);
    FStatus = ChgOrdIssueCleanup(ThreadCtx, Replica, ChangeOrder, RetireFlags);
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT1(0, "++ ERROR - failed to update VV  %08x %08x\n",
                PRINTQUAD(CoCmd->FrsVsn));
        goto RETURN;
    }


    //
    // If we have retried too many times with the result that this CO is
    // blocking other COs in the VV retire list then we need to call
    // ChgOrdIssueCleanup() with ISCU_ACTIVATE_VV_DISCARD set.
    // Then set CO_FLAG_OUT_OF_ORDER so when the staging file for the CO
    // finally arrives (local or remote) we can then propagate
    // we need to call ChgOrdIssueCleanup() with ISCU_INS_OUTLOG set.
    // Since the CO is out of order setting CO_FLAG_OUT_OF_ORDER lets it
    // slip past the change order dampening filters that would otherwise
    // ignore it.
    //
    if (0) {
        // Note: add code to determine if this CO is blocking others in VV retire
        //       and how long it has been sitting in VVretire since the CO was
        //       first issued.

        FStatus = ChgOrdIssueCleanup(ThreadCtx,
                                     Replica,
                                     ChangeOrder,
                                     ISCU_ACTIVATE_VV_DISCARD |
                                     ISCU_NO_CLEANUP_MERGE);
        if (!FRS_SUCCESS(FStatus)) {
            DPRINT1(0, "++ ERROR - failed to discard VV retire slot %08x %08x\n",
                   PRINTQUAD(CoCmd->FrsVsn));
            goto RETURN;
        }
        SET_CO_FLAG(ChangeOrder, CO_FLAG_OUT_OF_ORDER);
    }


RETURN:

    //
    // Count of how many change orders we need to retry for this replica.
    // This count may not be precise.  It is really used as an indicator
    // that there may be retry change orders in the INLOG.  The inlog
    // Retry thread zeros this count before it starts its pass thru the log.
    //
    InterlockedIncrement(&Replica->InLogRetryCount);

    //
    // Now do the issue cleanup.  This has to be done as a seperate step.
    //
    RetireFlags = 0;
    SetFlag(RetireFlags, (ISCU_ISSUE_CLEANUP));

    if (!COE_FLAG_ON(ChangeOrder, COE_FLAG_DELETE_GEN_CO)) {
        SetFlag(RetireFlags, ISCU_UPDATE_INLOG);
    }


    //
    // Note: May need to track retried COs pending so we can block a parent dir MOVEOUT
    //       May just need to leave entry in active child table.
    //       Does the case of a remote co child file update that goes thru retry
    //       followed by a local CO MOVEOUT of the parent DIR work correctly when
    //       the remote CO child file update is retried?
    //
    SetFlag(RetireFlags, ISCU_NO_CLEANUP_MERGE);
    FStatus = ChgOrdIssueCleanup(ThreadCtx, Replica, ChangeOrder, RetireFlags);

    if (!FRS_SUCCESS(FStatus)) {
        JrnlSetReplicaState(Replica, REPLICA_STATE_ERROR);
        //
        // Note:  Multiple COs can retire and set Replica->FStatus
        //        Need another mechanism if initiator cares.
        //
        Replica->FStatus = FStatus;
    }

    return FStatus;

}



ULONG
DbsUpdateRecordField(
    IN PTHREAD_CTX  ThreadCtx,
    IN PREPLICA     Replica,
    IN PTABLE_CTX   TableCtx,
    IN ULONG        IndexField,
    IN PVOID        IndexValue,
    IN ULONG        UpdateField
    )
/*++

Routine Description:

    Update the specified field in the specified record in the specified table
    in the specified Replica.  The data for the update comes from the TableCtx
    structure which has been pre-initialized.

Arguments:

    ThreadCtx   - The thread context, provides session ID and database ID.

    Replica     - The Replica context, provides the table list for this replica.

    TableCtx    - The table ctx that has the data record for the field update.

    IndexField  - The field code for the index to use.

    IndexValue  - ptr to index value to identify the record.

    UpdateField - The field code for the column to update.

Return Value:

    FrsError status.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsUpdateRecordField:"

    JET_ERR  jerr;
    ULONG    FStatus;
    ULONG    ReplicaNumber = Replica->ReplicaNumber;

    FRS_ASSERT(TableCtx != NULL);
    FRS_ASSERT(Replica != NULL);
    FRS_ASSERT(IndexValue != NULL);
    FRS_ASSERT(TableCtx->TableType != TABLE_TYPE_INVALID);
    FRS_ASSERT(TableCtx->pDataRecord != NULL);

    //
    // Init the table context struct by allocating the storage for the data
    // record and the jet record descriptors.  Open the table.
    //
    jerr = DbsOpenTable(ThreadCtx, TableCtx, ReplicaNumber, TableCtx->TableType, NULL);
    if (!JET_SUCCESS(jerr)) {
        return DbsTranslateJetError(jerr, FALSE);
    }

    //
    // Seek to the desired record.
    //
    jerr = DbsSeekRecord(ThreadCtx, IndexValue, IndexField, TableCtx);
    if (JET_SUCCESS(jerr)) {
        //
        // Write the desired field.
        //
        FStatus = DbsWriteTableField(ThreadCtx, ReplicaNumber, TableCtx, UpdateField);
        DPRINT1_FS(0, "++ ERROR - DbsWriteTableField on %ws :", Replica->ReplicaName->Name, FStatus);
    } else {
        DPRINT1_JS(0, "++ ERROR - DbsSeekRecord on %ws :", Replica->ReplicaName->Name, jerr);
        FStatus = DbsTranslateJetError(jerr, FALSE);
    }

    //
    // Close the table.
    //
    DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
    DPRINT1_JS(0, "++ ERROR - DbsCloseTable on %ws :", Replica->ReplicaName->Name, jerr);

    return FStatus;
}


ULONG
DbsUpdateVV(
    IN PTHREAD_CTX          ThreadCtx,
    IN PREPLICA             Replica,
    IN PREPLICA_THREAD_CTX  RtCtx,
    IN ULONGLONG            OriginatorVsn,
    IN GUID                 *OriginatorGuid
    )
/*++

Routine Description:

    This function update an entry in the VVTable in the database.

Arguments:

    ThreadCtx
    RtCtx
    Replica
    OriginatorVsn
    OriginatorGuid

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsUpdateVV:"

    ULONG               FStatus;
    PVVTABLE_RECORD     VVTableRec;
    PTABLE_CTX          TableCtx;
    TABLE_CTX           TempTableCtx;
    BOOL                Update = TRUE;

    DPRINT2(4, "++ Update Replica Vvector to %08x %08x for %ws\n",
            PRINTQUAD(OriginatorVsn), Replica->SetName->Name);
    //
    // Use local table ctx if not provided.
    //
    if (RtCtx == NULL) {
        TableCtx = &TempTableCtx;
        TableCtx->TableType = TABLE_TYPE_INVALID;
        TableCtx->Tid = JET_tableidNil;
    } else {
        TableCtx = &RtCtx->VVTable;
    }

    //
    // Update the database
    //
    DbsAllocTableCtx(VVTablex, TableCtx);

    VVTableRec = (PVVTABLE_RECORD)TableCtx->pDataRecord;
    VVTableRec->VVOriginatorVsn = OriginatorVsn;
    COPY_GUID(&VVTableRec->VVOriginatorGuid, OriginatorGuid);

    FStatus = DbsUpdateTableRecordByIndex(ThreadCtx,
                                          Replica,
                                          TableCtx,
                                          &VVTableRec->VVOriginatorGuid,
                                          VVOriginatorGuidx,
                                          VVTablex);
    if (FStatus == FrsErrorNotFound) {
        Update = FALSE;
        FStatus = DbsInsertTable(ThreadCtx, Replica, TableCtx, VVTablex, NULL);
    }
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT1_FS(0,"++ ERROR - %s failed.", (Update) ? "Update VV" : "Insert VV" , FStatus);
        goto RETURN;
    }

    FStatus = FrsErrorSuccess;

RETURN:

    if (TableCtx == &TempTableCtx) {
        DbsFreeTableCtx(TableCtx, 1);
    }

    return FStatus;
}


ULONG
DbsUpdateConfigTable(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA    Replica
    )
/*++

Routine Description:

    This function updates the config record. It uses
    the replica number in the data record to seek to
    the config record.

Arguments:

    ThreadCtx   -- ptr to the thread context.

    Replica -- ptr to replica struct.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsUpdateConfigTable:"

    JET_ERR                 jerr, jerr1;
    NTSTATUS                Status;
    PTABLE_CTX              TableCtx;

    TableCtx = &Replica->ConfigTable;
    FRS_ASSERT(IS_CONFIG_TABLE(TableCtx));

    //
    // open the configuration table, seek to the config record and update it.
    //
    jerr = DbsOpenTable(ThreadCtx,
                        TableCtx,
                        Replica->ReplicaNumber,
                        ConfigTablex,
                        NULL);
    if (!JET_SUCCESS(jerr)) {
        return DbsTranslateJetError(jerr, FALSE);
    }

    jerr = DbsSeekRecord(ThreadCtx,
                         &Replica->ReplicaNumber,
                         ReplicaNumberIndexx,
                         TableCtx);
    CLEANUP1_JS(0, "ERROR - DbsSeekRecord on %ws :",
                Replica->ReplicaName->Name, jerr, errout);

    //
    // Initialize the JetSet/RetCol arrays and data record buffer
    // addresses to write the fields of the data record.
    //
    DbsSetJetColSize(TableCtx);
    DbsSetJetColAddr(TableCtx);

    //
    // Allocate the storage for any unallocated fields in the variable
    // length record fields (this should be a nop since all of these should have
    // been allocated by now) and update the JetSet/RetCol arrays appropriately
    // for the variable length fields.
    //
    Status = DbsAllocRecordStorage(TableCtx);
    if (!NT_SUCCESS(Status)) {
        DPRINT_NT(0, "ERROR - DbsAllocRecordStorage failed to alloc buffers.", Status);
        return FrsErrorResource;
    }

    //
    // Update the record.
    //
    DBS_DISPLAY_RECORD_SEV(5, TableCtx, FALSE);
    jerr = DbsUpdateTable(TableCtx);
    CLEANUP1_JS(0, "ERROR - DbsUpdateTable on %ws :",
                Replica->ReplicaName->Name, jerr, errout);

errout:
    //
    // Close the table, reset the TableCtx Tid and Sesid.
    // DbsCloseTable is a Macro, writes 1st arg.
    //
    DbsCloseTable(jerr1, ThreadCtx->JSesid, TableCtx);
    DPRINT_JS(0,"ERROR - JetCloseTable failed:", jerr1);
    jerr = JET_SUCCESS(jerr) ? jerr1 : jerr;

    return DbsTranslateJetError(jerr, FALSE);
}




ULONG
DbsUpdateConfigTableFields(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA    Replica,
    IN PULONG      RecordFieldx,
    IN ULONG       FieldCount
    )
/*++

Routine Description:

    This function updates selected fields in the config record. It uses
    the replica number in the data record to seek to the config record.

Arguments:

    ThreadCtx   -- ptr to the thread context.
    Replica -- ptr to replica struct.
    RecordFieldx -- ptr to an array of field ids for the columns to update.
    FieldCount -- Then number of field entries in the RecordFieldx array.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsUpdateConfigTableFields:"

    JET_ERR                 jerr, jerr1;
    NTSTATUS                Status;
    PTABLE_CTX              TableCtx;
    ULONG                   FStatus;

    TableCtx = &Replica->ConfigTable;
    FRS_ASSERT(IS_CONFIG_TABLE(TableCtx));

    //
    // open the configuration table, seek to the config record and update it.
    //
    jerr = DbsOpenTable(ThreadCtx,
                        TableCtx,
                        Replica->ReplicaNumber,
                        ConfigTablex,
                        NULL);
    if (!JET_SUCCESS(jerr)) {
        return DbsTranslateJetError(jerr, FALSE);
    }

    jerr = DbsSeekRecord(ThreadCtx,
                         &Replica->ReplicaNumber,
                         ReplicaNumberIndexx,
                         TableCtx);
    CLEANUP1_JS(0, "ERROR - DbsSeekRecord on %ws :",
                Replica->ReplicaName->Name, ,jerr, errout);

    //
    // Initialize the JetSet/RetCol arrays and data record buffer
    // addresses to write the fields of the data record.
    //
    DbsSetJetColSize(TableCtx);
    DbsSetJetColAddr(TableCtx);

    //
    // Allocate the storage for any unallocated fields in the variable
    // length record fields (this should be a nop since all of these should have
    // been allocated by now) and update the JetSet/RetCol arrays appropriately
    // for the variable length fields.
    //
    Status = DbsAllocRecordStorage(TableCtx);
    if (!NT_SUCCESS(Status)) {
        DPRINT_NT(0, "ERROR - DbsAllocRecordStorage failed to alloc buffers.", Status);
        return FrsErrorResource;
    }

    //
    // Update the record.
    //
    DBS_DISPLAY_RECORD_SEV_COLS(4, TableCtx, FALSE, RecordFieldx, FieldCount);
    FStatus = DbsWriteTableFieldMult(ThreadCtx,
                                     Replica->ReplicaNumber,
                                     TableCtx,
                                     RecordFieldx,
                                     FieldCount);
    DPRINT1_FS(0, "ERROR - DbsUpdateConfigTableFields on %ws :",
               Replica->ReplicaName->Name, FStatus);

    //
    // Leave table open for other update calls.
    //
    return FStatus;

errout:
    //
    // Close the table, reset the TableCtx Tid and Sesid.
    // DbsCloseTable is a Macro, writes 1st arg.
    //
    DbsCloseTable(jerr1, ThreadCtx->JSesid, TableCtx);
    DPRINT_JS(0,"ERROR - JetCloseTable failed:", jerr1);
    jerr = JET_SUCCESS(jerr) ? jerr1 : jerr;

    return DbsTranslateJetError(jerr, FALSE);
}



ULONG
DbsUpdateIDTableFields(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA    Replica,
    IN PCHANGE_ORDER_ENTRY  ChangeOrder,
    IN PULONG      RecordFieldx,
    IN ULONG       FieldCount
    )
/*++

Routine Description:

    This function updates selected fields in the IDTable record. It uses
    the replica number in the data record to seek to the config record.

Arguments:

    ThreadCtx   -- ptr to the thread context.
    Replica -- ptr to replica struct whose IDTable is to be updated.
    ChangeOrder -- Provides the IDTable Ctx and associated data record.
    RecordFieldx -- ptr to an array of field ids for the columns to update.
    FieldCount -- Then number of field entries in the RecordFieldx array.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsUpdateIDTableFields:"

    JET_ERR                 jerr, jerr1;
    NTSTATUS                Status;
    PTABLE_CTX              TableCtx;
    ULONG                   FStatus;
    PIDTABLE_RECORD         IDTableRec;

    FRS_ASSERT(Replica != NULL);
    FRS_ASSERT(ChangeOrder != NULL);
    FRS_ASSERT(ChangeOrder->RtCtx != NULL);

    TableCtx    = &ChangeOrder->RtCtx->IDTable;

    FRS_ASSERT(IS_ID_TABLE(TableCtx));
    IDTableRec = TableCtx->pDataRecord;
    FRS_ASSERT(IDTableRec != NULL);


    //
    // open the ID table, seek to the record and update it.
    //
    jerr = DbsOpenTable(ThreadCtx,
                        TableCtx,
                        Replica->ReplicaNumber,
                        IDTablex,
                        NULL);
    if (!JET_SUCCESS(jerr)) {
        goto errout;
    }

    jerr = DbsSeekRecord(ThreadCtx,
                        &IDTableRec->FileGuid,
                         GuidIndexx,
                         TableCtx);
    CLEANUP1_JS(0, "ERROR - DbsSeekRecord on %ws :",
                Replica->ReplicaName->Name, jerr, errout);

    //
    // Initialize the JetSet/RetCol arrays and data record buffer
    // addresses to write the fields of the data record.
    //
    DbsSetJetColSize(TableCtx);
    DbsSetJetColAddr(TableCtx);

    //
    // Allocate the storage for any unallocated fields in the variable
    // length record fields (this should be a nop since all of these should have
    // been allocated by now) and update the JetSet/RetCol arrays appropriately
    // for the variable length fields.
    //
    Status = DbsAllocRecordStorage(TableCtx);
    if (!NT_SUCCESS(Status)) {
        DPRINT_NT(0, "ERROR - DbsAllocRecordStorage failed to alloc buffers.", Status);
        return FrsErrorResource;
    }

    //
    // Update the record.
    //
    DBS_DISPLAY_RECORD_SEV_COLS(4, TableCtx, FALSE, RecordFieldx, FieldCount);
    FStatus = DbsWriteTableFieldMult(ThreadCtx,
                                     Replica->ReplicaNumber,
                                     TableCtx,
                                     RecordFieldx,
                                     FieldCount);
    DPRINT1_FS(0, "ERROR - DbsUpdateConfigTableFields on %ws :",
               Replica->ReplicaName->Name, FStatus);

errout:
    //
    // Close the table, reset the TableCtx Tid and Sesid.
    // DbsCloseTable is a Macro, writes 1st arg.
    //
    DbsCloseTable(jerr1, ThreadCtx->JSesid, TableCtx);
    DPRINT_JS(0,"ERROR - JetCloseTable failed:", jerr1);
    jerr = JET_SUCCESS(jerr) ? jerr1 : jerr;

    return DbsTranslateJetError(jerr, FALSE);
}



ULONG
DbsFreeRtCtx(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA    Replica,
    IN PREPLICA_THREAD_CTX   RtCtx,
    IN BOOL SessionErrorCheck
    )
/*++

Routine Description:

    Close any open tables in the RtCtx and free all the storage.

Arguments:

    ThreadCtx   -- ptr to the thread context.
    Replica -- ptr to replica struct.
    RtCtx  - ptr to the replica thread ctx to be closed and freed.
    SessionErrorCheck - True means generate an error message if the Session ID
                        in the ThreadCtx does not match the Session Id used
                        to open a given table in the Replica-Thread ctx.
                        False means keep quiet.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsFreeRtCtx:"

    JET_ERR         jerr;

    if (RtCtx != NULL) {
        jerr = DbsCloseReplicaTables(ThreadCtx, Replica, RtCtx, SessionErrorCheck);
        if (JET_SUCCESS(jerr)) {
            //
            // Remove the Replica-Thread context from the Replica List and
            // free the storage associated with all the table contexts and
            // the REPLICA_THREAD_CTX struct as well.
            //
            FrsRtlRemoveEntryList(&Replica->ReplicaCtxListHead,
                                  &RtCtx->ReplicaCtxList);
            RtCtx = FrsFreeType(RtCtx);
        } else {
            DPRINT_JS(0,"ERROR - DbsCloseReplicaTables failed:", jerr);
            return DbsTranslateJetError(jerr, FALSE);
        }
    }

    return FrsErrorSuccess;

}


ULONG
DbsInsertTable(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA    Replica,
    IN PTABLE_CTX  TableCtx,
    IN ULONG       TableType,
    IN PVOID       DataRecord
    )
/*++

Routine Description:

    This function inserts a new record into the specified table.  It inits
    the supplied TableCtx as needed and uses the data record pointer if non-null.

    If the TableCtx is already initialized it must match the TableType specified.

    If the DataRecord is NULL then the TableCtx must be pre-inited with data.

Arguments:

    ThreadCtx   -- ptr to the thread context.
    Replica -- ptr to replica struct.
    TableCtx  - ptr to the table ctx.
    TableType - The table type code
    DataRecord -- ptr to the data record being inserted.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsInsertTable:"

    JET_ERR   jerr, jerr1;
    ULONG     ReplicaNum = Replica->ReplicaNumber;

    FRS_ASSERT(TableCtx != NULL);

    FRS_ASSERT((TableCtx->TableType == TABLE_TYPE_INVALID) ||
               (TableCtx->TableType == TableType));

    FRS_ASSERT((DataRecord != NULL) || (TableCtx->pDataRecord != NULL));

    //
    // Open the table
    //
    jerr = DbsOpenTable(ThreadCtx, TableCtx, ReplicaNum, TableType, DataRecord);
    CLEANUP_JS(0,"Error - OpenTable failed:", jerr, RETURN);

    //
    // Insert the new record into the database.
    //
    jerr = DbsInsertTable2(TableCtx);
    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(1, "error inserting record:", jerr);
        DBS_DISPLAY_RECORD_SEV(5, TableCtx, FALSE);
        DUMP_TABLE_CTX(TableCtx);
    }
    //
    // Close the table, reset the TableCtx Tid and Sesid.
    // DbsCloseTable is a Macro, writes 1st arg.
    //
RETURN:

    DbsCloseTable(jerr1, ThreadCtx->JSesid, TableCtx);
    DPRINT_JS(0,"Error - JetCloseTable failed:", jerr1);
    jerr = JET_SUCCESS(jerr) ? jerr1 : jerr;

    return DbsTranslateJetError(jerr, FALSE);
}




ULONG
DbsUpdateTableRecordByIndex(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA    Replica,
    IN PTABLE_CTX  TableCtx,
    IN PVOID       pIndex,
    IN ULONG       IndexType,
    IN ULONG       TableType
    )
/*++

Routine Description:


    This function updates the Table record with the specified Index for the
    specified replica.  It does a one shot open/update/close.

Arguments:

    ThreadCtx   -- ptr to the thread context.
    Replica -- ptr to replica struct.
    TableCtx  - ptr to a Table ctx. If NULL we provide a temp.
    pIndex - ptr to the index value to select the record.
    IndexType - The type code for the index to use in selecting the record.
    TableType - The type code for the table.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsUpdateTableRecordByIndex:"


    JET_ERR         jerr, jerr1;
    NTSTATUS        Status;
    LONG            RetryCount = UPDATE_RETRY_COUNT;


    jerr = DbsOpenTable(ThreadCtx, TableCtx, Replica->ReplicaNumber, TableType, NULL);
    if (!JET_SUCCESS(jerr)) {
        return DbsTranslateJetError(jerr, FALSE);
    }


UPDATE_ERROR_RETRY:

    //
    // Seek to the IDtable record using the object ID (GUID) and update it.
    // The ObjectID is the primary key so it never changes.  The FID can change.
    //
    jerr = DbsSeekRecord(ThreadCtx, pIndex, IndexType, TableCtx);
    CLEANUP1_JS(1, "ERROR - DbsSeekRecord on %ws",
                Replica->ReplicaName->Name, jerr, RETURN);

    //
    // Initialize the JetSet/RetCol arrays and data record buffer
    // addresses to write the fields of the data record.
    //
    DbsSetJetColSize(TableCtx);
    DbsSetJetColAddr(TableCtx);

    //
    // Allocate the storage for any unallocated fields in the variable
    // length record fields (this should be a nop since all of these should have
    // been allocated by now) and update the JetSet/RetCol arrays appropriately
    // for the variable length fields.
    //
    Status = DbsAllocRecordStorage(TableCtx);
    if (!NT_SUCCESS(Status)) {
        DPRINT_NT(0, "ERROR - DbsAllocRecordStorage failed to alloc buffers.", Status);
        goto RETURN;
    }

    //
    // Update the record.
    //
    jerr = DbsUpdateTable(TableCtx);
    DPRINT1_JS(0, "ERROR DbsUpdateTable on %ws", Replica->ReplicaName->Name, jerr);


RETURN:
    //
    // Close the table, reset the TableCtx Tid and Sesid.
    // DbsCloseTable is a Macro, writes 1st arg.
    //
    DbsCloseTable(jerr1, ThreadCtx->JSesid, TableCtx);
    DPRINT_JS(0,"ERROR - JetCloseTable failed:", jerr1);
    jerr = (JET_SUCCESS(jerr)) ? jerr1 : jerr;

    //
    // workaround attempt to deal with JET_errRecordTooBig error.
    //
    if ((jerr == JET_errRecordTooBig) && (--RetryCount > 0)) {
        DPRINT_JS(0, "ERROR - RecordTooBig, retrying : ", jerr);
        goto UPDATE_ERROR_RETRY;
    }

    if ((JET_SUCCESS(jerr)) && (RetryCount != UPDATE_RETRY_COUNT)) {
        DPRINT(5, "DbsUpdateTableRecordByIndex retry succeeded\n");
    }

    return DbsTranslateJetError(jerr, FALSE);
}



ULONG
DbsDeleteTableRecordByIndex(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA    Replica,
    IN PTABLE_CTX  TableCtx,
    IN PVOID       pIndex,
    IN ULONG       IndexType,
    IN ULONG       TableType
    )
/*++

Routine Description:

    This function deletes the Table record with the specified Index for the
    specified replica.

Arguments:

    ThreadCtx   -- ptr to the thread context.
    Replica -- ptr to replica struct.
    TableCtx  - ptr to a Table ctx. If NULL we provide a temp.
    pIndex - ptr to the index value to select the record.
    IndexType - The type code for the index to use in selecting the record.
    TableType - The type code for the table.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsDeleteTableRecordByIndex:"

    JET_ERR           jerr, jerr1;
    TABLE_CTX         TempTableCtx;

    //
    // Use local table ctx if not provided.
    //
    if (TableCtx == NULL) {
        TableCtx = &TempTableCtx;
        TableCtx->TableType = TABLE_TYPE_INVALID;
        TableCtx->Tid = JET_tableidNil;
    }

    //
    // Seek to the IDTable record and delete it.
    //
    jerr = DbsOpenTable(ThreadCtx, TableCtx, Replica->ReplicaNumber, TableType, NULL);
    CLEANUP1_JS(0, "ERROR - JetOpenTable on %ws:",
                Replica->ReplicaName->Name, jerr, RETURN);

    jerr = DbsSeekRecord(ThreadCtx, pIndex, IndexType, TableCtx);
    CLEANUP1_JS(0, "ERROR - DbsSeekRecord on %ws :",
                Replica->ReplicaName->Name, jerr, RETURN);

    jerr = DbsDeleteTableRecord(TableCtx);
    DPRINT1_JS(0, "ERROR - DbsDeleteRecord on %ws :", Replica->ReplicaName->Name, jerr);

    //
    // Close the table, reset the TableCtx Tid and Sesid.
    // DbsCloseTable is a Macro, writes 1st arg.
    //
RETURN:
    DbsCloseTable(jerr1, ThreadCtx->JSesid, TableCtx);
    DPRINT_JS(0,"ERROR - JetCloseTable failed:", jerr1);
    jerr = (JET_SUCCESS(jerr)) ? jerr1 : jerr;

    if (TableCtx == &TempTableCtx) {
        DbsFreeTableCtx(TableCtx, 1);
    }

    return DbsTranslateJetError(jerr, FALSE);
}



ULONG
DbsReadTableRecordByIndex(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA    Replica,
    IN PTABLE_CTX  TableCtx,
    IN PVOID       pIndex,
    IN ULONG       IndexType,
    IN ULONG       TableType
    )
/*++

Routine Description:

    This function reads the Table record with the specified Index for the
    specified replica.  It does a one shot open, read and close.
    The data record is returned in the Callers TableCtx.

Arguments:

    ThreadCtx   -- ptr to the thread context.
    Replica -- ptr to replica struct.
    TableCtx  - ptr to a Table ctx.
    pIndex - ptr to the index value to select the record.
    IndexType - The type code for the index to use in selecting the record.
    TableType - The type code for the table.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "DbsReadTableRecordByIndex:"

    JET_ERR           jerr, jerr1;

    //
    // Open the requested table.
    //
    jerr = DbsOpenTable(ThreadCtx, TableCtx, Replica->ReplicaNumber, TableType, NULL);
    CLEANUP1_JS(0, "ERROR - JetOpenTable on %ws:",
                Replica->ReplicaName->Name, jerr, RETURN);

    //
    // Read the record.
    //
    jerr = DbsReadRecord(ThreadCtx, pIndex, IndexType, TableCtx);
    if (jerr != JET_errRecordNotFound) {
        DPRINT1_JS(0, "ERROR - DbsReadRecord on %ws", Replica->ReplicaName->Name, jerr);
    }

    //
    // Close the table, reset the TableCtx Tid and Sesid.
    // DbsCloseTable is a Macro, writes 1st arg.
    //
RETURN:
    DbsCloseTable(jerr1, ThreadCtx->JSesid, TableCtx);
    if (!JET_SUCCESS(jerr1)) {
        DPRINT_JS(0,"ERROR - JetCloseTable failed:", jerr1);
        jerr = (JET_SUCCESS(jerr)) ? jerr1 : jerr;
    }

    //
    // Translate the jet error but don't print it if just RecordNotFound.
    //
    return DbsTranslateJetError(jerr, (jerr != JET_errRecordNotFound));
}




ULONG
DbsOpenTable(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX  TableCtx,
    IN ULONG       ReplicaNumber,
    IN ULONG       TableType,
    IN PVOID       DataRecord
)
/*++

Routine Description:

    This function initializes a table context structure, allocating the initial
    storage for the data record and then opens a jet table specified by the
    TableType parameter and the ReplicaNumber parameter.
    and inits the TableCtx with the table id,

Arguments:

    ThreadCtx     -- ptr to the thread context.
    TableCtx      -- ptr to the table context.
    ReplicaNumber -- The ID number of the replica whose table is being opened.
    TableType     -- The table type code to open.
    DataRecord    -- NULL if we alloc data record storage else caller provides.

Return Value:

    Jet status code. JET_errSuccess if successful.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsOpenTable:"

    JET_ERR      jerr;
    CHAR         TableName[JET_cbNameMost];
    JET_TABLEID  Tid;
    NTSTATUS     Status;
    JET_TABLEID  FrsOpenTableSaveTid;   // for FrsOpenTableMacro DEBUG

    //
    // Allocate a new table context using the table type of the caller.
    //
    Status = DbsAllocTableCtxWithRecord(TableType, TableCtx, DataRecord);

    //
    // Open the table, if it's not already open. Check the session id for match.
    //
    jerr = DBS_OPEN_TABLE(ThreadCtx, TableCtx, ReplicaNumber, TableName, &Tid);
    CLEANUP1_JS(0, "ERROR - FrsOpenTable (%s) :", TableName, jerr, ERROR_RETURN);

    //
    // Initialize the JetSet/RetCol arrays and data record buffer addresses
    // to read and write the fields of the ConfigTable records into ConfigRecord.
    //
    DbsSetJetColSize(TableCtx);
    DbsSetJetColAddr(TableCtx);

    //
    // Allocate the storage for the variable length fields in the record and
    // update the JetSet/RetCol arrays appropriately.
    //
    Status = DbsAllocRecordStorage(TableCtx);

    if (NT_SUCCESS(Status)) {
        return JET_errSuccess;
    }

    DPRINT_NT(0, "ERROR - DbsAllocRecordStorage failed to alloc buffers.", Status);
    DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
    jerr = JET_errOutOfMemory;

ERROR_RETURN:
    DbsFreeTableCtx(TableCtx, 1);
    return jerr;
}



PTABLE_CTX
DbsCreateTableContext(
    IN ULONG TableType
)
/*++

Routine Description:

    This function allocates and initializes a table context structure,
    allocating the initial storage for the data record.

Arguments:

    TableType     -- The table type code to open.

Return Value:

    TableCtx      -- ptr to the table context.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsCreateTableContext:"

    NTSTATUS     Status;
    PTABLE_CTX   TableCtx;

    //
    // Allocate a new table context using the table type of the caller.
    //

    TableCtx = FrsAlloc(sizeof(TABLE_CTX));
    TableCtx->TableType = TABLE_TYPE_INVALID;
    Status = DbsAllocTableCtx(TableType, TableCtx);

    //
    // Initialize the JetSet/RetCol arrays and data record buffer addresses
    // to read and write the fields of the ConfigTable records into ConfigRecord.
    //
    DbsSetJetColSize(TableCtx);
    DbsSetJetColAddr(TableCtx);

    //
    // Allocate the storage for the variable length fields in the record and
    // update the JetSet/RetCol arrays appropriately.
    //
    Status = DbsAllocRecordStorage(TableCtx);

    if (!NT_SUCCESS(Status)) {
        DPRINT_NT(0, "ERROR - DbsAllocRecordStorage failed to alloc buffers.", Status);
        DbsFreeTableCtx(TableCtx, 1);
        TableCtx = FrsFree(TableCtx);
    }

    return TableCtx;
}


BOOL
DbsFreeTableContext(
    IN PTABLE_CTX TableCtx,
    IN JET_SESID  Sesid
)
/*++

Routine Description:

    This function frees a tablectx struct.  If the table is still open and the
    Session ID doesn't match the ID of the thread that opened the table
    the function fails otherwise it closes the table and frees the storage.

Arguments:

    TableCtx  -- ptr to the table context.
    Sesid     -- If the table is still open this is jet session ID that was used.

Return Value:

    TRUE if table context was released.
    FALSE if table still open and session ID mismatch.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsFreeTableContext:"

    JET_ERR jerr;

    if ((TableCtx == NULL) ||
        (Sesid == JET_sesidNil)) {
        DPRINT2(0, "ERROR - DbsFreeTableContext called with bad param.  TableCtx: %08x, Sesid %08x\n",
                TableCtx, Sesid);
        return FALSE;
    }
    //
    // Close the tables and reset TableCtx Tid and Sesid.   Macro writes 1st arg.
    //
    if (IS_TABLE_OPEN(TableCtx)) {
        DbsCloseTable(jerr, Sesid, TableCtx);
        if (jerr == JET_errInvalidSesid) {
            return FALSE;
        }
    }

    DbsFreeTableCtx(TableCtx, 1);

    FrsFree(TableCtx);

    return TRUE;
}



PCOMMAND_PACKET
DbsPrepareCmdPkt (
    PCOMMAND_PACKET CmdPkt,
    PREPLICA        Replica,
    ULONG           CmdRequest,
    PTABLE_CTX      TableCtx,
    PVOID           CallContext,
    ULONG           TableType,
    ULONG           AccessRequest,
    ULONG           IndexType,
    PVOID           KeyValue,
    ULONG           KeyValueLength,
    BOOL            Submit
    )
/*++

Routine Description:

    Post a database service request for the given replica set.

    WARNING -
    The caller passes pointers to the replica struct, the call context and
    the KeyValue.  Until this request is completed the data in these structures
    can't be changed and the memory can't be released.

    The one exception is the KeyValue.  If we allocate the command packet here
    then the key value is appended to the end of the command packet.

Arguments:

    CmdPkt          -- If NULL then alloc is done here.
    Replica         -- ptr to Replica struct.
    CmdRequest      -- read, write, update
    TableCtx        -- Table context handle (NULL on first call)
    CallContext     -- optional call specific data
    TableType       -- Type code for the table to access
    AccessRequest   -- (ByKey, First, Last, Next) | Close
    IndexType       -- The table index to use
    KeyValue        -- The record key value for lookup
    KeyValueLength  -- The Length of the key value
    Submit          -- If true then submit to command to the server.

Return Value:

    ptr to the command packet.

--*/
{

#undef DEBSUB
#define DEBSUB "DbsPrepareCmdPkt:"

    PVOID KeyData;

    //
    // Allocate a command packet unless the caller provided one.
    // Put the key value at the end of the packet so the caller's
    // storage can go away.
    //

    if (CmdPkt == NULL) {
            CmdPkt = FrsAllocCommandEx(&DBServiceCmdServer.Queue,
                                      (USHORT)CmdRequest,
                                       KeyValueLength+8);
            //
            // Put the key value at the end of the packet.  Quadword align it.
            //
            KeyData = (PCHAR)CmdPkt + sizeof(COMMAND_PACKET);
            KeyData = (PVOID) QuadAlign(KeyData);

            CopyMemory(KeyData, KeyValue, KeyValueLength);
            KeyValue = KeyData;
    } else {
        //
        // pickup new command and make sure cmd pkt goes to right server.
        //
        CmdPkt->TargetQueue = &DBServiceCmdServer.Queue;
        CmdPkt->Command = (USHORT)CmdRequest;
    }

    //
    // Capture the parameters.
    //
    CmdPkt->Parameters.DbsRequest.Replica        = Replica;
    CmdPkt->Parameters.DbsRequest.TableCtx       = TableCtx;
    CmdPkt->Parameters.DbsRequest.CallContext    = CallContext;
    CmdPkt->Parameters.DbsRequest.TableType      = TableType;
    CmdPkt->Parameters.DbsRequest.AccessRequest  = AccessRequest;
    CmdPkt->Parameters.DbsRequest.IndexType      = IndexType;
    CmdPkt->Parameters.DbsRequest.KeyValue       = KeyValue;
    CmdPkt->Parameters.DbsRequest.KeyValueLength = KeyValueLength;
    CmdPkt->Parameters.DbsRequest.FStatus        = 0;
    CmdPkt->Parameters.DbsRequest.FieldCount     = 0;

    //
    // Queue the request.
    //

    if (Submit) {
        FrsSubmitCommandServer(&DBServiceCmdServer, CmdPkt);
        DPRINT3(4,"DBServiceRequest posted for Replica %ws,  Req: %d, Ctx: %08x\n",
               ((Replica) ? Replica->ReplicaName->Name : L"Null"), CmdRequest, CallContext);
    } else {
        DPRINT3(4,"DBServiceRequest prepared for Replica %ws,  Req: %d, Ctx: %08x\n",
               ((Replica) ? Replica->ReplicaName->Name : L"Null"), CmdRequest, CallContext);
    }

    return CmdPkt;

}


ULONG
DbsProcessReplicaFaultList(
    PDWORD  pReplicaSetsDeleted
    )
{
#undef DEBSUB
#define DEBSUB "DbsProcessReplicaFaultList:"

    ULONG    FStatus              = FrsErrorSuccess;
    BOOL     FoundReplicaToDelete = FALSE;
    PREPLICA ReplicaToDelete      = NULL;
    DWORD    ReplicaSetsDeleted   = 0;
    WCHAR    DsPollingIntervalStr[7]; // Max interval is NTFRSAPI_MAX_INTERVAL.
    PWCHAR   FStatusUStr          = NULL;
    extern   ULONG  DsPollingInterval;

    do {
        FoundReplicaToDelete = FALSE;
        //
        // Scan the FAULT list.
        //
        ForEachListEntry( &ReplicaFaultListHead, REPLICA, ReplicaList,
            //
            // The Loop iterator pE is of type PREPLICA.
            //
            DPRINT4(4, ":S: Replica (%d) %ws is in the Fault List with FStatus %s and State %d\n",
                pE->ReplicaNumber,
                (pE->ReplicaName != NULL) ? pE->ReplicaName->Name : L"<null>",
                 ErrLabelFrs(pE->FStatus),pE->ServiceState);
            if (REPLICA_STATE_NEEDS_RESTORE(pE->ServiceState)) {
                //
                // If a replica is in this state then close it and delete it. At the
                // next poll the replica will be recreated.
                //
                FoundReplicaToDelete = TRUE;
                ReplicaToDelete = pE;
                break;
            }
        );
        if (FoundReplicaToDelete && (ReplicaToDelete != NULL)) {
            //
            // Delete the replica from DB.
            //
            DPRINT1(4,":S: WARN - Stopping and deleting replica (%ws) from DB\n",ReplicaToDelete->ReplicaName->Name);
            //
            // Get the DsPollingInteval in minutes.
            //
            _itow(DsPollingInterval / (60 * 1000), DsPollingIntervalStr, 10);

            FStatusUStr = FrsAtoW(ErrLabelFrs(ReplicaToDelete->FStatus));

            EPRINT3(EVENT_FRS_ERROR_REPLICA_SET_DELETED, ReplicaToDelete->SetName->Name, FStatusUStr,
                    DsPollingIntervalStr);

            FrsFree(FStatusUStr);
            //
            // If this is the sysvol replica set then unshare the sysvols by setting sysvolready to 0.
            // Sysvolready will be reset when this DC completes the first vvjoin after it is recreated,
            //
            if (FRS_RSTYPE_IS_SYSVOL(ReplicaToDelete->ReplicaSetType)) {
                RcsSetSysvolReady(0);
            }
            RcsSubmitReplicaSync(ReplicaToDelete, NULL, NULL, CMD_DELETE_NOW);
            RcsCloseReplicaSetmember(ReplicaToDelete);
            RcsCloseReplicaCxtions(ReplicaToDelete);
            RcsDeleteReplicaFromDb(ReplicaToDelete);

            FrsRtlRemoveEntryQueue(&ReplicaFaultListHead, &ReplicaToDelete->ReplicaList);
            //
            // Remove the replica from any in-memory tables that it might be in.
            //
            if (RcsFindReplicaByGuid(ReplicaToDelete->ReplicaName->Guid) != NULL) {
                GTabDelete(ReplicasByGuid, ReplicaToDelete->ReplicaName->Guid, NULL, NULL);
            }

            if (RcsFindReplicaByNumber(ReplicaToDelete->ReplicaNumber) != NULL) {
                GTabDelete(ReplicasByNumber, &ReplicaToDelete->ReplicaNumber, NULL, NULL);
            }

            ++ReplicaSetsDeleted;

        }
    } while ( FoundReplicaToDelete );

    //
    // For now all we do is print out the error status above for each
    // replica set that failed to init.  If we return an error then our
    // caller will treat this as the DBservice failing to start which will
    // hose any replica sets that opened successfully.
    //
    // Until we have better recovery / reporting code we return Success status.
    //
    if (pReplicaSetsDeleted != NULL) {
        *pReplicaSetsDeleted = ReplicaSetsDeleted;
    }

    return FrsErrorSuccess;


#if 0
    //  may still need to Add more details to why replica set failed to init.

    // CHECK FOR
    // No system volume init record means invalid database because
    // the system volume replica tables are the templates for creating
    // the tables for all the other replicas.
    //

    //
    // The Open failed.  Classify error and recover if possible.
    //

    if ((FStatus == FrsErrorDatabaseCorrupted) ||
        (FStatus == FrsErrorInternalError)) {

        //
        // Sys Vol Replica is either not there or bad.
        // Delete it Create a new set of Replica Tables.
        //
        DPRINT(0,"ERROR - Deleting system volume replica tables.\n");
        //LogUnhandledError(err);

        jerr = DbsDeleteReplicaTables(ThreadCtx, ReplicaSysVol);
    }
    if (FStatus == FrsErrorNotFound) {
        //
        // Create the system volume replica tables in Jet.
        //
        DPRINT(0,"Creating system volume replica tables.\n");
        FStatus = DbsCreateReplicaTables(ThreadCtx, ReplicaSysVol);
        if (!FRS_SUCCESS(FStatus)) {
            DPRINT_FS(0, "ERROR - DbsCreateReplicaTables failed.", FStatus);
            //LogUnhandledError(err);
            return FStatus;
        }
    }

#endif
}


ULONG
DbsInitializeIDTableRecord(
    IN OUT PTABLE_CTX            TableCtx,
    IN     HANDLE                FileHandleArg,
    IN     PREPLICA              Replica,
    IN     PCHANGE_ORDER_ENTRY   ChangeOrder,
    IN     PWCHAR                FileName,
    IN OUT BOOL                  *ExistingOid
    )
/*++
Routine Description:

    Initialize a new IDTable record provided in the TableCtx param.
    The data is for a file specified by the open file handle.
    This routine is used by three types of callers:

    1. ReplicaTree Load - In this case ChangeOrder is NULL and the caller fills
       in some of the IDTable record fields.

    2. Local change orders - Changes that originate from the local machine.
       Here we get some info from the file itself.

    3. Remote change orders - Here the change comes in from a remote machine.
       We build an initial IDTable record and leave some fields for the caller
       to add later.

    No fields of the change order are set here.  The caller must do that.
    It also gets (and may set) the object ID from the file.

Arguments:

    TableCtx   -- The table context containing the ID Table record.
    FileHandleArg -- The open file handle.
    Replica    -- The target replica struct provides a link to the volume
                  monitor entry that provides the next VSN for replica tree
                  loads and the config record for the OriginatorGuid.
    ChangeOrder-- The change order for local or remote change orders.
    FileName   -- The filename for error messages.
    ExistingOid -- INPUT:  TRUE means use existing File OID if found.
                   RETURN:  TRUE means an existing File OID was used.

Return Value:

    WIN32 Status

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsInitializeIDTableRecord:"


    USN                           CurrentFileUsn;
    FILETIME                      SystemTime;
    FILE_NETWORK_OPEN_INFORMATION FileNetworkOpenInfo;

    PCONFIG_TABLE_RECORD ConfigRecord;
    PIDTABLE_RECORD      IDTableRec;

    NTSTATUS Status;
    ULONG    WStatus;
    HANDLE   FileHandle;

    BOOL RemoteCo = FALSE;
    BOOL MorphGenCo = FALSE;

    BOOL ReplicaTreeLoad;
    ULONG Len;


    ReplicaTreeLoad = (ChangeOrder == NULL);

    IDTableRec = (PIDTABLE_RECORD) (TableCtx->pDataRecord);
    ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);


    GetSystemTimeAsFileTime(&SystemTime);

    //
    //
    COPY_TIME(&IDTableRec->TombStoneGC, &SystemTime);

    //
    // Assume everything goes ok.  If any error occurs getting the data
    // to create the IDTable entry set ReplEnabled to FALSE.
    //
    IDTableRec->ReplEnabled = TRUE;

    ClearIdRecFlag(IDTableRec, IDREC_FLAGS_DELETED);
    ZeroMemory(&IDTableRec->Extension, sizeof(IDTABLE_RECORD_EXTENSION));


    //
    // Fields common to both local and remote change orders.
    //
    if (!ReplicaTreeLoad) {

        RemoteCo = !CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO);
        MorphGenCo = CO_FLAG_ON(ChangeOrder, CO_FLAG_MORPH_GEN);

        IDTableRec->ParentGuid     = ChangeOrder->Cmd.NewParentGuid;
        IDTableRec->ParentFileID   = ChangeOrder->NewParentFid;

        IDTableRec->VersionNumber  = ChangeOrder->Cmd.FileVersionNumber;
        IDTableRec->EventTime      = ChangeOrder->Cmd.EventTime.QuadPart;
        IDTableRec->OriginatorGuid = ChangeOrder->Cmd.OriginatorGuid;
        IDTableRec->OriginatorVSN  = ChangeOrder->Cmd.FrsVsn;

        Len = (ULONG) ChangeOrder->Cmd.FileNameLength;
        CopyMemory(IDTableRec->FileName, ChangeOrder->Cmd.FileName, Len);
        IDTableRec->FileName[Len/2] = UNICODE_NULL;
    }

    //
    // Field init for remote Change Orders or name Morph conflict gened COs.
    // For the latter the info is already in the CO just like remote COs.
    //
    if (RemoteCo || MorphGenCo) {

        IDTableRec->FileGuid = ChangeOrder->Cmd.FileGuid;

        //
        // We don't have a local file ID yet for the remote change order.
        // The Fid will be established after the remote CO is accepted and
        // we have created the target file container.  The caller will have to
        // initialize the following fields when the data is available.
        //
        // IDTableRec->FileID =
        // ChangeOrder->FileReferenceNumber =
        // IDTableRec->FileObjID =   (the full 64 byte object ID)
        //
        IDTableRec->FileCreateTime.QuadPart = (LONGLONG) 0;
        IDTableRec->FileWriteTime.QuadPart  = (LONGLONG) 0;
        IDTableRec->FileSize                = ChangeOrder->Cmd.FileSize;
        IDTableRec->CurrentFileUsn          = (USN) 0;

        IDTableRec->FileAttributes  = ChangeOrder->Cmd.FileAttributes;
        IDTableRec->FileIsDir = CoIsDirectory(ChangeOrder);

        //
        // That's it for remote COs.  The caller provides the rest.
        //
        return ERROR_SUCCESS;
    }

    //
    // Field init for data that comes from the local file.
    // This is for a local change order or a replica tree load.
    //
    if (ReplicaTreeLoad) {
        //
        // The caller provides the data for:
        //      ParentFileID, ParentGuid and Filename
        // in the IDTable record.
        //
        // Use the handle supplied and get the File ID, object ID,
        // file times and attributes.
        //
        WStatus = FrsReadFileDetails(FileHandleArg,
                                     FileName,
                                     &IDTableRec->FileObjID,
                                     &IDTableRec->FileID,
                                     &FileNetworkOpenInfo,
                                     ExistingOid);
        CLEANUP1_WS(0, "ERROR - FrsReadFileDetails(%ws), File Not Replicated.",
                    FileName, WStatus, RETURN_ERROR);

        //
        // Set the initial version number of the file to 0 and the event
        // time to the create time.
        //
        IDTableRec->VersionNumber = 0;
        COPY_TIME(&IDTableRec->EventTime, &SystemTime);
        //
        // Set the Originator GUID to us and the initial file USN to the
        // next FRS volume serial number.
        //
        NEW_VSN(Replica->pVme, &IDTableRec->OriginatorVSN);
        IDTableRec->OriginatorGuid = ConfigRecord->ReplicaVersionGuid;

        //
        // Keep the version vector up-to-date for VvJoin.
        //
        VVUpdate(Replica->VVector, IDTableRec->OriginatorVSN, &IDTableRec->OriginatorGuid);

        //
        // Capture the File's last write USN so we can use it for consistency
        // checking between the database and the file tree.
        //
        FrsReadFileUsnData(FileHandleArg, &IDTableRec->CurrentFileUsn);

        //
        // The following data fields are inited for ReplciaTree walks.
        //
        COPY_GUID(&IDTableRec->FileGuid, &IDTableRec->FileObjID);

        IDTableRec->FileCreateTime  = FileNetworkOpenInfo.CreationTime;
        IDTableRec->FileWriteTime   = FileNetworkOpenInfo.LastWriteTime;
        IDTableRec->FileSize        = FileNetworkOpenInfo.AllocationSize.QuadPart;
        IDTableRec->FileAttributes  = FileNetworkOpenInfo.FileAttributes;
        IDTableRec->FileIsDir       = (FileNetworkOpenInfo.FileAttributes &
                                       FILE_ATTRIBUTE_DIRECTORY) != 0;
    } else {
        //
        // This is a local change order.  Open the file by FID to get the
        // file times and attributes.
        //
        IDTableRec->FileID = ChangeOrder->FileReferenceNumber;
        IDTableRec->FileAttributes  = ChangeOrder->Cmd.FileAttributes;
        IDTableRec->FileIsDir       = CoIsDirectory(ChangeOrder);

        //
        // ASSIGN OBJECT ID
        //
        WStatus = ChgOrdHammerObjectId(ChangeOrder->Cmd.FileName,    //Name,
                                       (PULONG)&IDTableRec->FileID,  //Id,
                                       FILE_ID_LENGTH,               //IdLen,
                                       Replica->pVme,                //pVme,
                                       FALSE,                        //CallerSupplied
                                       &IDTableRec->CurrentFileUsn,  //*Usn,
                                       &IDTableRec->FileObjID,       //FileObjID,
                                       ExistingOid);                 //*ExistingOid

        if (WIN_NOT_FOUND(WStatus)) {
            //
            // The file has been deleted.
            //
            // The idtable record will never be inserted and we
            // will forget about this file (as we should).
            //
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Deleted by user");
            return WStatus;
        }

        if (!WIN_SUCCESS(WStatus)) {
            //
            // This object id will be hammered on the file prior to
            // generating the staging file.
            // Link tracking: if the OID was tunneled by NTFS.
            //
            ZeroMemory(&IDTableRec->FileObjID, sizeof(IDTableRec->FileObjID));
            FrsUuidCreate((GUID *)(&IDTableRec->FileObjID.ObjectId[0]));
        }
        COPY_GUID(&IDTableRec->FileGuid, &IDTableRec->FileObjID);

        //
        // Read some optional debug info
        //
        WStatus = FrsOpenSourceFileById(&FileHandle,
                                        &FileNetworkOpenInfo,
                                        NULL,
                                        Replica->pVme->VolumeHandle,
                                        (PULONG)&ChangeOrder->FileReferenceNumber,
                                        FILE_ID_LENGTH,
//                                        READ_ACCESS,
//                                        STANDARD_RIGHTS_READ | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | ACCESS_SYSTEM_SECURITY | SYNCHRONIZE,
                                        READ_ATTRIB_ACCESS,
                                        ID_OPTIONS,
                                        SHARE_ALL,
                                        FILE_OPEN);

        if (WIN_NOT_FOUND(WStatus)) {
            //
            // The file has been deleted.
            //
            //
            // The idtable record will never be inserted and we
            // will forget about this file (as we should).
            //
            CHANGE_ORDER_TRACE(3, ChangeOrder, "Deleted by user");
            return WStatus;
        }

        if (!WIN_SUCCESS(WStatus)) {
            DPRINT_WS(0, "Some other error from OpenByFid", WStatus);
            //
            // Some other error occurred on the open.  We will assign
            // an object id that will be written to the file prior
            // to generating the staging file. This could break link tracking.
            // We don't want to lose track of this file.  The code that generates
            // the staging file will retry for us.
            //
            return ERROR_SUCCESS;
        }
        //
        // Get the last USN on the file and check it with the USN in the change
        // order.  If they are different then the file has changed again
        // and we can pitch this change order.
        //
        // Note: For this to work the we have to be sure that the change order
        //       to come replicates all the info this change order modifies too.
        //       e.g. if this was a create or an update and the later change order
        //       is a rename to move the file to a diff sub-dir then we have
        //       to propagate the file as well as the rename.  For the future.
        //
        // Get the File's current USN so we can check for consistency later
        // when the change order is about to be sent to an outbound partner.
        //
        FrsReadFileUsnData(FileHandle, &IDTableRec->CurrentFileUsn);
        FRS_CLOSE(FileHandle);

        //
        // Optional debug info
        //
        IDTableRec->FileCreateTime  = FileNetworkOpenInfo.CreationTime;
        IDTableRec->FileWriteTime   = FileNetworkOpenInfo.LastWriteTime;

        //
        // Use the most current info, if available, but don't disable
        // replication if we have only the info from the change order.
        //
        IDTableRec->FileSize        = FileNetworkOpenInfo.AllocationSize.QuadPart;
        IDTableRec->FileAttributes  = FileNetworkOpenInfo.FileAttributes;
        IDTableRec->FileIsDir       = (FileNetworkOpenInfo.FileAttributes &
                                       FILE_ATTRIBUTE_DIRECTORY) != 0;

        //
        // It is possible for the file attributes to have changed between the
        // time the USN record was processed and now.  Record the current
        // attributes in the change order.  This is especially true for dir
        // creates since while the dir was open other changes may have occurred.
        //
        if (ChangeOrder->Cmd.FileAttributes != FileNetworkOpenInfo.FileAttributes) {
            CHANGE_ORDER_TRACEX(3, ChangeOrder, "New File Attr= ", FileNetworkOpenInfo.FileAttributes);
            ChangeOrder->Cmd.FileAttributes = FileNetworkOpenInfo.FileAttributes;
        }
    }

    return ERROR_SUCCESS;

RETURN_ERROR:

    IDTableRec->ReplEnabled = FALSE;
    return WStatus;
}



typedef struct _LOAD_CONTEXT {
    ULONG               NumFiles;
    ULONG               NumDirs;
    ULONG               NumSkipped;
    ULONG               NumFiltered;
    LONGLONG            ParentFileID;
    GUID                ParentGuid;
    PREPLICA            Replica;
    PREPLICA_THREAD_CTX RtCtx;
    PTHREAD_CTX         ThreadCtx;
} LOAD_CONTEXT, *PLOAD_CONTEXT;

DWORD
DbsLoadReplicaFileTreeForceOpen(
    OUT HANDLE                      *OutFileHandle,
    IN  HANDLE                      DirectoryHandle,
    IN  PWCHAR                      DirectoryName,
    IN  DWORD                       DirectoryLevel,
    IN  PFILE_DIRECTORY_INFORMATION DirectoryRecord,
    IN  DWORD                       DirectoryFlags,
    IN  PWCHAR                      FileName,
    IN  PLOAD_CONTEXT               LoadContext
    )
{
/*++

Routine Description:

    FileName could not be opened with write access. Force
    open FileName, resetting attributes if needed.

Arguments:

    OutFileHandle       - Returned opened handle
    DirectoryHandle     - Handle for this directory.
    DirectoryName       - Relative name of directory
    DirectoryLevel      - Directory level (0 == root)
    DirectoryFlags      - See tablefcn.h, ENUMERATE_DIRECTORY_FLAGS_
    DirectoryRecord     - Record from DirectoryHandle
    FileName            - From DirectoryRecord (w/terminating NULL)
    LoadContext         - global info and state

Return Value:

    Nt Error Status.

--*/
#undef DEBSUB
#define DEBSUB  "DbsLoadReplicaFileTreeForceOpen:"

    NTSTATUS                NtStatus = 0;
    DWORD                   WStatus = ERROR_SUCCESS;
    HANDLE                  FileHandle = INVALID_HANDLE_VALUE;
    HANDLE                  AttrHandle = INVALID_HANDLE_VALUE;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    FILE_BASIC_INFORMATION  BasicInformation;
    IO_STATUS_BLOCK         IoStatusBlock;
    UNICODE_STRING          ObjectName;

    //
    // Initialize output
    //
    *OutFileHandle = INVALID_HANDLE_VALUE;

    //
    // Object name used in later NT function calls
    //
    ObjectName.Length = (USHORT)DirectoryRecord->FileNameLength;
    ObjectName.MaximumLength = (USHORT)DirectoryRecord->FileNameLength;
    ObjectName.Buffer = DirectoryRecord->FileName;

    //
    // Relative open with write-attr access
    //
    ZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectAttributes.ObjectName = &ObjectName;
    ObjectAttributes.RootDirectory = DirectoryHandle;
    NtStatus = NtCreateFile(&AttrHandle,
//                            ATTR_ACCESS,
                            READ_ATTRIB_ACCESS | WRITE_ATTRIB_ACCESS,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            NULL,                  // AllocationSize
                            FILE_ATTRIBUTE_NORMAL,
                            (FILE_SHARE_READ |
                             FILE_SHARE_WRITE |
                             FILE_SHARE_DELETE),
                            FILE_OPEN,
                            OPEN_OPTIONS,
                            NULL,                  // EA buffer
                            0                      // EA buffer size
                            );
    CLEANUP_NT(0, "ERROR - NtCreateFile failed.", NtStatus, CLEANUP);

    //
    // Mark the handle so that we do not pick this journal record.
    //
    WStatus = FrsMarkHandle(LoadContext->Replica->pVme->VolumeHandle, AttrHandle);
    DPRINT1_WS(0, "++ WARN - FrsMarkHandle(%ws)", DirectoryRecord->FileName, WStatus);

    //
    // Set the attributes to allow write access
    //
    ZeroMemory(&BasicInformation, sizeof(BasicInformation));
    BasicInformation.FileAttributes =
        (DirectoryRecord->FileAttributes & ~NOREPL_ATTRIBUTES) | FILE_ATTRIBUTE_NORMAL;
    NtStatus = NtSetInformationFile(AttrHandle,
                                    &IoStatusBlock,
                                    &BasicInformation,
                                    sizeof(BasicInformation),
                                    FileBasicInformation);
    CLEANUP_NT(0, "ERROR - NtSetInformationFile failed.", NtStatus, CLEANUP);

    //
    // Relative open with RW access
    //
    ZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectAttributes.ObjectName = &ObjectName;
    ObjectAttributes.RootDirectory = DirectoryHandle;


    NtStatus = NtCreateFile(&FileHandle,
//                                WRITE_ACCESS | READ_ACCESS,
                            READ_ATTRIB_ACCESS | WRITE_ATTRIB_ACCESS |
                            (BooleanFlagOn(DirectoryRecord->FileAttributes, FILE_ATTRIBUTE_DIRECTORY) ? FILE_LIST_DIRECTORY : 0),
                            &ObjectAttributes,
                            &IoStatusBlock,
                            NULL,                  // AllocationSize
                            FILE_ATTRIBUTE_NORMAL,
                            (FILE_SHARE_READ |
                             FILE_SHARE_WRITE |
                             FILE_SHARE_DELETE),
                            FILE_OPEN,
                            OPEN_OPTIONS,
                            NULL,                  // EA buffer
                            0                      // EA buffer size
                            );

    CLEANUP_NT(0, "ERROR - NtCreateFile failed.", NtStatus, CLEANUP);

    //
    // Reset the attributes back to their original values
    //
    ZeroMemory(&BasicInformation, sizeof(BasicInformation));
    BasicInformation.FileAttributes = DirectoryRecord->FileAttributes | FILE_ATTRIBUTE_NORMAL;
    NtStatus = NtSetInformationFile(AttrHandle,
                                    &IoStatusBlock,
                                    &BasicInformation,
                                    sizeof(BasicInformation),
                                    FileBasicInformation);
    if (!NT_SUCCESS(NtStatus)) {
        DPRINT1_NT(0, "WARN - IGNORE NtSetInformationFile(%ws);.", FileName, NtStatus);
        NtStatus = STATUS_SUCCESS;
    }

    //
    // SUCCESS
    //
    *OutFileHandle = FileHandle;
    FileHandle = INVALID_HANDLE_VALUE;

CLEANUP:
    FRS_CLOSE(FileHandle);
    FRS_CLOSE(AttrHandle);

    return NtStatus;
}


DWORD
DbsLoadReplicaFileTreeWorker(
    IN  HANDLE                      DirectoryHandle,
    IN  PWCHAR                      DirectoryName,
    IN  DWORD                       DirectoryLevel,
    IN  PFILE_DIRECTORY_INFORMATION DirectoryRecord,
    IN  DWORD                       DirectoryFlags,
    IN  PWCHAR                      FileName,
    IN  PLOAD_CONTEXT               LoadContext
    )
{
/*++

Routine Description:

    Search a directory tree and build the inital IDTable.

Arguments:

    DirectoryHandle     - Handle for this directory.
    DirectoryName       - Relative name of directory
    DirectoryLevel      - Directory level (0 == root)
    DirectoryFlags      - See tablefcn.h, ENUMERATE_DIRECTORY_FLAGS_
    DirectoryRecord     - Record from DirectoryHandle
    FileName            - From DirectoryRecord (w/terminating NULL)
    LoadContext         - global info and state

Return Value:

    WIN32 Error Status.

--*/
#undef DEBSUB
#define DEBSUB  "DbsLoadReplicaFileTreeWorker:"

    DWORD                   FStatus;
    DWORD                   WStatus;
    NTSTATUS                NtStatus;
    JET_ERR                 jerr;
    ULONG                   LevelCheck;
    PTABLE_CTX              TableCtx;
    PIDTABLE_RECORD         IDTableRec;
    PCONFIG_TABLE_RECORD    ConfigRecord;
    PREPLICA                Replica;
    UNICODE_STRING          ObjectName;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    IO_STATUS_BLOCK         IoStatusBlock;
    GUID                    SaveParentGuid;
    LONGLONG                SaveParentFileID;
    BOOL                    Excluded;
    BOOL                    ExistingOid;
    HANDLE                  FileHandle = INVALID_HANDLE_VALUE;

    //
    // Filter out temporary files.
    //
    if (DirectoryRecord->FileAttributes & FILE_ATTRIBUTE_TEMPORARY) {
        WStatus = ERROR_SUCCESS;
        goto CLEANUP;
    }

    //
    // Choose filter list and level (caller filters . and ..)
    //
    Replica = LoadContext->Replica;
    ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);
    if (DirectoryRecord->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        //
        // No dirs at the bottom level in the volume filter table.
        //
        LevelCheck = ConfigRecord->ReplDirLevelLimit-1;
        LoadContext->NumDirs++;
    } else {
        //
        // Files are allowed at the bottom level.
        //
        LevelCheck = ConfigRecord->ReplDirLevelLimit;
        LoadContext->NumFiles++;
    }

    //
    // If the Level Limit is exceeded then skip the file or dir.
    // Skip files or dirs matching an entry in the respective exclusion list.
    //
    if (DirectoryLevel >= LevelCheck) {
        LoadContext->NumFiltered++;
        WStatus = ERROR_SUCCESS;
        goto CLEANUP;
    }
    ObjectName.Length = (USHORT)DirectoryRecord->FileNameLength;
    ObjectName.MaximumLength = (USHORT)DirectoryRecord->FileNameLength;
    ObjectName.Buffer = DirectoryRecord->FileName;

    LOCK_REPLICA(Replica);

    //
    // If not explicitly included then check the excluded filter list.
    //
    Excluded = FALSE;
    if (DirectoryRecord->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        if (!FrsCheckNameFilter(&ObjectName, &Replica->DirNameInclFilterHead)) {
            Excluded = FrsCheckNameFilter(&ObjectName, &Replica->DirNameFilterHead);
        }
    } else {
        if (!FrsCheckNameFilter(&ObjectName, &Replica->FileNameInclFilterHead)) {
            Excluded = FrsCheckNameFilter(&ObjectName, &Replica->FileNameFilterHead);
        }
    }

    UNLOCK_REPLICA(Replica);

    if (Excluded) {
        LoadContext->NumFiltered++;
        WStatus = ERROR_SUCCESS;
        goto CLEANUP;
    }

    TableCtx = &LoadContext->RtCtx->IDTable;
    IDTableRec = (PIDTABLE_RECORD) TableCtx->pDataRecord;

    //
    // Set the value of the Parent Guid & File ID from our caller.
    //
    COPY_GUID(&IDTableRec->ParentGuid, &LoadContext->ParentGuid);
    IDTableRec->ParentFileID = LoadContext->ParentFileID;

    //
    // Add the file name to the data record.
    //
    wcscpy(IDTableRec->FileName, FileName);

    //
    // Open the file and build the ID Table entry from the file data.
    // Open with WRITE Access in case we need to write the Object ID.
    //

    //
    // Can't open readonly file with write access. Reset
    // READONLY|SYSTEM|HIDDEN attributes temporarily so that
    // the file/dir can be open for write access.
    //
    if (DirectoryRecord->FileAttributes & NOREPL_ATTRIBUTES) {
        NtStatus = DbsLoadReplicaFileTreeForceOpen(&FileHandle,
                                                   DirectoryHandle,
                                                   DirectoryName,
                                                   DirectoryLevel,
                                                   DirectoryRecord,
                                                   DirectoryFlags,
                                                   FileName,
                                                   LoadContext);
    } else {

        //
        // Relative open
        //
        ZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
        ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
        ObjectAttributes.ObjectName = &ObjectName;
        ObjectAttributes.RootDirectory = DirectoryHandle;
        NtStatus = NtCreateFile(&FileHandle,
//                                WRITE_ACCESS | READ_ACCESS,
//                                STANDARD_RIGHTS_READ | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | ACCESS_SYSTEM_SECURITY | SYNCHRONIZE | FILE_LIST_DIRECTORY,
                                READ_ATTRIB_ACCESS | WRITE_ATTRIB_ACCESS |
                                (BooleanFlagOn(DirectoryRecord->FileAttributes, FILE_ATTRIBUTE_DIRECTORY) ? FILE_LIST_DIRECTORY : 0),
                                &ObjectAttributes,
                                &IoStatusBlock,
                                NULL,                  // AllocationSize
                                FILE_ATTRIBUTE_NORMAL,
                                (FILE_SHARE_READ |
                                 FILE_SHARE_WRITE |
                                 FILE_SHARE_DELETE),
                                FILE_OPEN,
                                OPEN_OPTIONS,
                                NULL,                  // EA buffer
                                0                      // EA buffer size
                                );

    }

    //
    // Error opening file or directory
    //
    if (!NT_SUCCESS(NtStatus)) {
        DPRINT1_NT(0, "ERROR - Skipping %ws: NtCreateFile()/ForceOpen().",
                   FileName, NtStatus);
        if (DirectoryFlags & ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE) {
            WStatus = ERROR_SUCCESS;
        } else {
            WStatus = FrsSetLastNTError(NtStatus);
        }
        LoadContext->NumSkipped++;
        goto CLEANUP;
    }

    //
    // Mark the handle so that we do not pick this journal record.
    //
    WStatus = FrsMarkHandle(LoadContext->Replica->pVme->VolumeHandle, FileHandle);
    DPRINT1_WS(0, "++ WARN - FrsMarkHandle(%ws)", DirectoryRecord->FileName, WStatus);

    //
    // Create an IDTable Entry for this file preserving the OID if requested.
    //
    ExistingOid = PreserveFileOID;
    WStatus = DbsInitializeIDTableRecord(TableCtx,
                                         FileHandle,
                                         Replica,
                                         NULL,
                                         FileName,
                                         &ExistingOid);

    DBS_DISPLAY_RECORD_SEV(5, TableCtx, FALSE);
    //
    // Insert the entry.
    //
    if (IDTableRec->ReplEnabled) {
        jerr = DbsWriteReplicaTableRecord(LoadContext->ThreadCtx,
                                          Replica->ReplicaNumber,
                                          TableCtx);
        if (!JET_SUCCESS(jerr)) {
            DPRINT_JS(0, "ERROR - writing IDTable record:", jerr);
        } else {
            //
            // Keep the VVector up-to-date for vvjoin
            //
            FStatus = DbsUpdateVV(LoadContext->ThreadCtx,
                                  Replica,
                                  LoadContext->RtCtx,
                                  IDTableRec->OriginatorVSN,
                                  &IDTableRec->OriginatorGuid);
            DPRINT1_FS(0, "ERROR - Updating VV for %ws;", IDTableRec->FileName, FStatus);

            if (!FRS_SUCCESS(FStatus)) {
                jerr = JET_errInvalidLoggedOperation;
            }
        }
    }

    if ((!IDTableRec->ReplEnabled) || (!JET_SUCCESS(jerr))) {
        //
        // LOG an error message so the user or admin can see what happened.
        //
        DPRINT1(0, "ERROR - Replication disabled for file %ws\n", FileName);
        LoadContext->NumSkipped++;
        if (DirectoryFlags & ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE) {
            WStatus = ERROR_SUCCESS;
        } else {
            WStatus = ERROR_REQUEST_ABORTED;
        }
        goto CLEANUP;
    }

    if (FrsIsShuttingDown) {
        DPRINT(0, "WARN - IDTable Load aborted; service shutting down\n");
        WStatus = ERROR_PROCESS_ABORTED;
        goto CLEANUP;
    }

    //
    // Recurse
    //
    if (DirectoryRecord->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        //
        // Save context information across recursions
        //
        COPY_GUID(&SaveParentGuid, &LoadContext->ParentGuid);
        SaveParentFileID = LoadContext->ParentFileID;
        COPY_GUID(&LoadContext->ParentGuid, &IDTableRec->FileObjID);
        LoadContext->ParentFileID = IDTableRec->FileID;
        WStatus = FrsEnumerateDirectoryRecurse(DirectoryHandle,
                                               DirectoryName,
                                               DirectoryLevel,
                                               DirectoryRecord,
                                               DirectoryFlags,
                                               FileName,
                                               FileHandle,
                                               LoadContext,
                                               DbsLoadReplicaFileTreeWorker);
        //
        // Restore context
        //
        COPY_GUID(&LoadContext->ParentGuid, &SaveParentGuid);
        LoadContext->ParentFileID = SaveParentFileID;
        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP;
        }
    }

    WStatus = ERROR_SUCCESS;

CLEANUP:
    FRS_CLOSE(FileHandle);

    return WStatus;
}


ULONG
DbsLoadReplicaFileTree(
    IN PTHREAD_CTX         ThreadCtx,
    IN PREPLICA            Replica,
    IN PREPLICA_THREAD_CTX RtCtx,
    IN LPTSTR              RootPath
    )
{
/*++

Routine Description:

    Search a directory tree and build the inital IDTable.
    It is REQUIRED that the root path begin with a drive letter.


Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.

    Replica - The Replica struct for this replica set.

    RtCtx - The Replica Thread Context to use in building the ID Table.

    RootPath - Root of replica set

Return Value:

    WIN32 Error Status.

--*/
#undef DEBSUB
#define DEBSUB  "DbsLoadReplicaFileTree:"

    DWORD                   FStatus;
    DWORD                   WStatus;
    JET_ERR                 jerr;
    PTABLE_CTX              TableCtx;
    PIDTABLE_RECORD         IDTableRec;
    DWORD                   FileAttributes;
    HANDLE                  FileHandle = INVALID_HANDLE_VALUE;
    HANDLE                  AttrHandle = INVALID_HANDLE_VALUE;
    BOOL                    ResetAttrs = FALSE;
    LOAD_CONTEXT            LoadContext;
    FILE_OBJECTID_BUFFER    ObjectIdBuffer;
    PCONFIG_TABLE_RECORD    ConfigRecord;
    BOOL                    ExistingOid;


    TableCtx = &RtCtx->IDTable;
    IDTableRec = (PIDTABLE_RECORD) TableCtx->pDataRecord;
    ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);

    DPRINT3(5, "^^^^^ TableCtx %08x, IDTableRec %08x, ConfigRecord %08x\n",
           TableCtx, IDTableRec, ConfigRecord);

    //
    // Process the root node outside the recursive directory scan
    //
    DPRINT1(4, "****  Begin DbsLoadReplicaFileTree of %ws *******\n", RootPath);

    FileAttributes = GetFileAttributes(RootPath);
    if (FileAttributes == 0xFFFFFFFF) {
        WStatus = GetLastError();
        DPRINT1_WS(0, "ERROR - GetFileAttributes(%ws);", RootPath, WStatus);
        //
        // I don't know why the error code is mapped to this value
        // but, bsts...
        //
        WStatus = ERROR_BAD_PATHNAME;
        goto CLEANUP;
    } else {
        if (!(FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            DPRINT1(0, "ERROR - Root path (%ws) is not an directory\n", RootPath);
            WStatus = ERROR_BAD_PATHNAME;
            goto CLEANUP;
        }
    }
    //
    // If the ID table is not empty then don't do the initial load of
    // the ID table.
    //
    if (JET_SUCCESS(DbsTableMoveFirst(ThreadCtx,
                          TableCtx,
                          Replica->ReplicaNumber,
                          GuidIndexx))) {
        DPRINT1(4, "IDTable for Replica %ws not empty.  Load skiped\n",
               Replica->ReplicaName->Name);
        WStatus = ERROR_FILE_EXISTS;
        goto CLEANUP;
    }

    //
    // Can't open readonly dir with write access. Reset
    // READONLY|SYSTEM|HIDDEN attributes temporarily so that
    // the file/dir can be open for write access.
    //
    if (FileAttributes & NOREPL_ATTRIBUTES) {
        if (!SetFileAttributes(RootPath,
                               ((FileAttributes & ~NOREPL_ATTRIBUTES) | FILE_ATTRIBUTE_NORMAL))) {
            WStatus = GetLastError();
            DPRINT1_WS(0, "WARN - IGNORE SetFileAttributes(%ws);", RootPath, WStatus);
        } else {
            ResetAttrs = TRUE;
        }
    }

    //
    // Make sure the object ID on the root of our tree is correct.
    // Always open the replica root by masking off the FILE_OPEN_REPARSE_POINT flag
    // because we want to open the destination dir not the junction if the root
    // happens to be a mount point.
    //
    WStatus = FrsOpenSourceFileW(&FileHandle,
                                 RootPath,
//                                 WRITE_ACCESS | READ_ACCESS,
                                 READ_ATTRIB_ACCESS | WRITE_ATTRIB_ACCESS | FILE_LIST_DIRECTORY,
                                 OPEN_OPTIONS & ~FILE_OPEN_REPARSE_POINT);
    CLEANUP1_WS(0, "ERROR - FrsOpenSourceFile(%ws); ", RootPath, WStatus, CLEANUP);

    //
    // Set the attributes back to their original value
    //
    if (ResetAttrs) {
        if (!SetFileAttributes(RootPath, FileAttributes | FILE_ATTRIBUTE_NORMAL)) {
            WStatus = GetLastError();
            DPRINT1_WS(0, "WARN - IGNORE SetFileAttributes(reset %ws);", RootPath, WStatus);
        } else {
            ResetAttrs = FALSE;
        }
    }

    //
    // Stamp the replica Root GUID on the object ID of the
    // root dir.  Mutliple replica members of a given replica set
    // can be on the same machine but must be on distinct volumes.
    // This is because a given file in a replica tree has an object ID
    // which must be the same for all replica members but NTFS requires
    // the file object IDs to be unique on a volume.
    //
    // Restricting multi-member sets to different volumes may no longer
    // be necessary since the root guid is now unique for every replica
    // set creation.
    //
    ZeroMemory(&ObjectIdBuffer, sizeof(FILE_OBJECTID_BUFFER));
    COPY_GUID(&ObjectIdBuffer, &ConfigRecord->ReplicaRootGuid);

    WStatus = FrsGetOrSetFileObjectId(FileHandle, RootPath, TRUE, &ObjectIdBuffer);
    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }

    //
    // Replica tree root does not have a parent
    //
    ZeroMemory(&IDTableRec->ParentGuid, sizeof(GUID));
    IDTableRec->ParentFileID = (LONGLONG)0;

    //
    // The root of the replica tree is always a keeper
    //
    wcscpy(IDTableRec->FileName, L"<<<ReplicaTreeRoot>>>");

    //
    // Create an IDTable Entry for this file.
    //
    ExistingOid = TRUE;
    WStatus = DbsInitializeIDTableRecord(TableCtx,
                                         FileHandle,
                                         Replica,
                                         NULL,
                                         RootPath,
                                         &ExistingOid);
    DBS_DISPLAY_RECORD_SEV(5, TableCtx, FALSE);
    //
    // Insert the entry.
    //
    if (IDTableRec->ReplEnabled) {
        jerr = DbsWriteReplicaTableRecord(ThreadCtx,
                                          Replica->ReplicaNumber,
                                          TableCtx);
        if (!JET_SUCCESS(jerr)) {
            DPRINT1_JS(0, "ERROR - writing IDTable record for %ws; ",
                       IDTableRec->FileName, jerr);
        } else {
            //
            // Keep the VVector up-to-date for vvjoin
            //
            FStatus = DbsUpdateVV(ThreadCtx,
                                  Replica,
                                  RtCtx,
                                  IDTableRec->OriginatorVSN,
                                  &IDTableRec->OriginatorGuid);
            DPRINT1_FS(0, "ERROR - Updating VV for %ws;", IDTableRec->FileName, FStatus);
            if (!FRS_SUCCESS(FStatus)) {
                jerr = JET_errInvalidLoggedOperation;
            }
        }
    }

    if ((!IDTableRec->ReplEnabled) || (!JET_SUCCESS(jerr))) {
        //
        // LOG an error message so the user or admin can see what happened.
        //
        DPRINT1_JS(0, "ERROR - Replication disabled for file %ws;", RootPath, jerr);
        WStatus = ERROR_GEN_FAILURE;
        goto CLEANUP;
    }


    //
    // If this replica set member is not marked as the primary then skip
    // the initial directory load (other than the root which was just done).
    // This member gets all its files with a VVJOIN request to an
    // inbound partner.
    //
    if (!BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_PRIMARY)) {
        WStatus = ERROR_SUCCESS;
        goto CLEANUP;
    }

    //
    // Advance to the next level
    //
    ZeroMemory(&LoadContext, sizeof(LoadContext));
    LoadContext.ParentFileID = IDTableRec->FileID;
    COPY_GUID(&LoadContext.ParentGuid, &IDTableRec->FileObjID);
    LoadContext.Replica = Replica;
    LoadContext.RtCtx = RtCtx;
    LoadContext.ThreadCtx = ThreadCtx;

    WStatus = FrsEnumerateDirectory(FileHandle,
                                    RootPath,
                                    1,          // level 0 is root
                                    ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE,
                                    &LoadContext,
                                    DbsLoadReplicaFileTreeWorker);
    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }
    DPRINT4(4, "Load File Tree done: %d dirs; %d files; %d skipped, %d filtered\n",
            LoadContext.NumDirs, LoadContext.NumFiles,
            LoadContext.NumSkipped, LoadContext.NumFiltered);

    DPRINT(5, "****************  Done  DbsLoadReplicaFileTree  ****************\n");

    WStatus = ERROR_SUCCESS;

CLEANUP:

    FRS_CLOSE(FileHandle);
    FRS_CLOSE(AttrHandle);

    //
    // Set the attributes back to their original value
    //
    if (ResetAttrs) {
        if (!SetFileAttributes(RootPath, FileAttributes | FILE_ATTRIBUTE_NORMAL)) {
            DPRINT1_WS(0, "WARN - IGNORE SetFileAttributes(cleanup %ws);",
                    RootPath, GetLastError());
        }
    }
    return WStatus;
}



DWORD
DbsEnumerateDirectoryPreExistingWorker(
    IN  HANDLE                      DirectoryHandle,
    IN  PWCHAR                      DirectoryName,
    IN  DWORD                       DirectoryLevel,
    IN  PFILE_DIRECTORY_INFORMATION DirectoryRecord,
    IN  DWORD                       DirectoryFlags,
    IN  PWCHAR                      FileName,
    IN  PPREEXISTING                PreExisting
    )
/*++
Routine Description:
    Move existing files over into the preexisting directory. Create
    if needed.

Arguments:
    DirectoryHandle     - Handle for this directory.
    DirectoryName       - Relative name of directory
    DirectoryLevel      - Directory level (0 == root)
    DirectoryFlags      - See tablefcn.h, ENUMERATE_DIRECTORY_FLAGS_
    DirectoryRecord     - Record from DirectoryHandle
    FileName            - From DirectoryRecord (w/terminating NULL)
    PreExisting         - Context

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define DEBSUB  "DbsEnumerateDirectoryPreExistingWorker:"
    DWORD   WStatus = ERROR_SUCCESS;
    PWCHAR  OldPath = NULL;
    PWCHAR  NewPath = NULL;

    //
    // Preexisting directory; don't move it
    //
    if (WSTR_EQ(FileName, NTFRS_PREEXISTING_DIRECTORY)) {
        WStatus = ERROR_SUCCESS;
        goto CLEANUP;
    }

    OldPath = FrsWcsPath(PreExisting->RootPath, FileName);
    NewPath = FrsWcsPath(PreExisting->PreExistingPath, FileName);

    if (!MoveFileEx(OldPath, NewPath, MOVEFILE_WRITE_THROUGH)) {
        WStatus = GetLastError();
        DPRINT2_WS(0, "ERROR - MoveFileEx(%ws, %ws);", OldPath, NewPath, WStatus);
        goto CLEANUP;
    } else {
        PreExisting->MovedAFile = TRUE;
    }

CLEANUP:
    FrsFree(OldPath);
    FrsFree(NewPath);
    return WStatus;
}




ULONG
DbsPrepareRoot(
    IN PREPLICA Replica
    )
/*++

Routine Description:

    Delete the current preexisting directory and the current preinstall
    directory. If Root contains objects, move them into a newly
    created preexisting directory. Create the preinstall directory.

    WARN: The replica set must not exist.

Arguments:

    Replica - The replica is not in the DB but the checks for
              overlapping directories has been completed.

Return Value:

    WIN32 STATUS

--*/
{
#undef DEBSUB
#define DEBSUB "DbsPrepareRoot:"
    ULONG       WStatus;
    DWORD       NumberOfPartners;
    DWORD       BurFlags;
    DWORD       RegLen;
    DWORD       RegType;
    HANDLE      RootHandle          = INVALID_HANDLE_VALUE;
    PWCHAR      PreInstallPath      = NULL;
    PWCHAR      PreExistingPath     = NULL;
    HKEY        hKey = 0;
    PREEXISTING PreExisting;
    WCHAR       GuidW[GUID_CHAR_LEN + 1];
    DWORD       NumOfCxtions;
    BOOL        bStatus             = FALSE;
    PWCHAR      CmdFile             = NULL;

    DPRINT3(4, "Preparing root %ws for %ws\\%ws\n",
            Replica->Root, Replica->SetName->Name, Replica->MemberName->Name);


    //
    // Delete any NTFRS Command files that may exist under the root.
    // E.g. NTFRS_CMD_FILE_MOVE_ROOT
    //
    CmdFile = FrsWcsCat3(Replica->Root, L"\\", NTFRS_CMD_FILE_MOVE_ROOT);
    if (GetFileAttributes(CmdFile) != 0xffffffff) {
        bStatus = DeleteFile(CmdFile);
        if (!bStatus) {
            DPRINT2(0,"ERROR - Deleting Command file %ws. WStatus = %d\n", CmdFile, GetLastError());
        }
    }
    CmdFile = FrsFree(CmdFile);

    //
    // Delete the preinstall directory (continue on error)
    //
    PreInstallPath = FrsWcsPath(Replica->Root, NTFRS_PREINSTALL_DIRECTORY);
    WStatus = FrsDeletePath(PreInstallPath, ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE);
    DPRINT1_WS(3, "++ Warn - FrsDeletePath(%ws) (IGNORED);", PreInstallPath, WStatus);

    //
    // Delete the preexisting directory (continue on error)
    //
    PreExistingPath = FrsWcsPath(Replica->Root, NTFRS_PREEXISTING_DIRECTORY);
    WStatus = FrsDeletePath(PreExistingPath, ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE);
    DPRINT1_WS(3, "++ ERROR - FrsDeletePath(%ws) (IGNORED);", PreExistingPath, WStatus);

    //
    // Have we seen this set before? If so, did it have partners?
    // Recreating w/partners   - Reset primary (move files out of way)
    // Recreating w/o partners - Set primary (reload idtable from files)
    // Creating w or w/o partners - Respect primary flag
    //
    // Open the Replica Sets section and fetch the number of partners.
    //
    GuidToStrW(Replica->MemberName->Guid, GuidW);

    WStatus = CfgRegOpenKey(FKC_CUMSET_N_NUMBER_OF_PARTNERS, GuidW, 0, &hKey);

    //
    // If brand new replica; no assumptions about primary can be made
    //
    CLEANUP3_WS(4, "++ WARN - Cannot query partners for %ws, %ws\\%ws (assuming new replica) :",
                Replica->SetName->Name, FRS_CUMULATIVE_SETS_SECTION, GuidW,
                WStatus, MOVE_PREEXISTING_FILES);
    RegCloseKey(hKey);


    //
    // Read the Number of Partners value.
    //
    WStatus = CfgRegReadDWord(FKC_CUMSET_N_NUMBER_OF_PARTNERS,
                              GuidW,
                              0,
                              &NumberOfPartners);
    //
    // If brand new replica; no assumptions about primary can be made
    //
    CLEANUP3_WS(4, "++ WARN - Cannot query partners for %ws, %ws\\%ws (assuming new replica) :",
                Replica->SetName->Name, FRS_CUMULATIVE_SETS_SECTION, GuidW,
                WStatus, MOVE_PREEXISTING_FILES);

    //
    // Read the Backup / Restore flags.
    //
    WStatus = CfgRegReadDWord(FKC_CUMSET_N_BURFLAGS, GuidW, 0, &BurFlags);

    if (!WIN_SUCCESS(WStatus)) {
        //
        // Can't check for BurFlags; Assume non-authoritative restore.
        //
        DPRINT4_WS(4, "++ WARN - Cannot query BurFlags for %ws, %ws\\%ws -> %ws;",
                Replica->SetName->Name, FRS_CUMULATIVE_SETS_SECTION, GuidW,
                FRS_VALUE_BURFLAGS, WStatus);
        DPRINT(4, "++ WARN - Assuming non-authoritative restore.\n");

        BurFlags = (NTFRSAPI_BUR_FLAGS_RESTORE |
                    NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE);
        WStatus = ERROR_SUCCESS;
    }

    //
    // Recreating w/partners   - Reset primary (move files out of way)
    // Recreating w/o partners - Set primary (reload idtable from files)
    // If the NumOfCxtions is > 0, subtract 1 for the
    // journal connection which is not a real cxtion.
    //
    NumOfCxtions = GTabNumberInTable(Replica->Cxtions);
    if (NumOfCxtions) {
        NumOfCxtions -= 1;
    }
    DPRINT5(4, "++ Recreating %ws\\%ws; %d Reg, %d Ds, %08x CnfFlags\n",
            Replica->SetName->Name, Replica->MemberName->Name,
            NumberOfPartners, NumOfCxtions, Replica->CnfFlags);
    //
    // Primary restore
    //
    if ((BurFlags & NTFRSAPI_BUR_FLAGS_RESTORE) &&
        (BurFlags & NTFRSAPI_BUR_FLAGS_PRIMARY)) {
        //
        // Force a primary restore.  This means we reload the IDTable using
        // the files on disk.
        //
        DPRINT1(4, "++ Force primary on %ws\n", Replica->SetName->Name);
        SetFlag(Replica->CnfFlags, CONFIG_FLAG_PRIMARY);
        ClearFlag(Replica->CnfFlags, CONFIG_FLAG_SEEDING);
    } else {
        //
        // Not Primary and has partners (either now or in the past).
        //
        if (NumberOfPartners > 0) {
            ClearFlag(Replica->CnfFlags, CONFIG_FLAG_PRIMARY);

            SetFlag(Replica->CnfFlags, CONFIG_FLAG_SEEDING);
        } else {
            //
            // Not primary but NO PARTNERS in the past so if no connections
            // then we will preload the IDTable by setting PRIMARY.
            //
             if (NumOfCxtions == 0) {
                SetFlag(Replica->CnfFlags, CONFIG_FLAG_PRIMARY);
            } else {
                ClearFlag(Replica->CnfFlags, CONFIG_FLAG_PRIMARY);
            }
            ClearFlag(Replica->CnfFlags, CONFIG_FLAG_SEEDING);
        }
    }

    //
    // Unshare SYSVOL if needed
    //
    if (FRS_RSTYPE_IS_SYSVOL(Replica->ReplicaSetType)) {
        RcsSetSysvolReady(0);
        if (BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_PRIMARY)) {
            EPRINT1(EVENT_FRS_SYSVOL_NOT_READY_PRIMARY_2, ComputerName);
        } else {
            EPRINT1(EVENT_FRS_SYSVOL_NOT_READY_2, ComputerName);
        }
    }

    DPRINT5(4, "++ DONE Recreating %ws\\%ws; %d Reg, %d Ds, %08x CnfFlags\n",
            Replica->SetName->Name, Replica->MemberName->Name,
            NumberOfPartners, NumOfCxtions, Replica->CnfFlags);


    //
    // Move over preexisting files
    //

MOVE_PREEXISTING_FILES:

    if (!BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_PRIMARY)) {
        //
        // Create the preexisting directory (continue on error)
        //
        if (!CreateDirectory(PreExistingPath, NULL)) {
            WStatus = GetLastError();
            if (!WIN_SUCCESS(WStatus) && !WIN_ALREADY_EXISTS(WStatus)) {
                DPRINT1_WS(3, "++ ERROR - CreateDirecotry(%ws); ", PreExistingPath, WStatus);
                goto CLEANUP;
            }
        }

        //
        // Restrict access to the preexisting directory.
        //
        WStatus = FrsRestrictAccessToFileOrDirectory(PreExistingPath, NULL, FALSE);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT1_WS(0, "++ ERROR - FrsRestrictAccessToFileOrDirectory(%ws);",
                    PreExistingPath, WStatus);
            goto CLEANUP;
        }

        //
        // Open the root path.
        // Always open the replica root by masking off the FILE_OPEN_REPARSE_POINT flag
        // because we want to open the destination dir not the junction if the root
        // happens to be a mount point.
        //
        WStatus = FrsOpenSourceFileW(&RootHandle,
                                     Replica->Root,
//                                     READ_ACCESS,
                                     READ_ATTRIB_ACCESS | WRITE_ATTRIB_ACCESS | FILE_LIST_DIRECTORY,
                                     OPEN_OPTIONS & ~FILE_OPEN_REPARSE_POINT);
        CLEANUP1_WS(0, "ERROR - FrsOpenSourceFile(%ws); ",
                    Replica->Root, WStatus, CLEANUP);

        //
        // Enumerate the directory (continue on error).
        // The children of the exisitng root dir are renamed into the
        // pre-existing dir instead of just renaming the existing root dir.
        // This preserves the ACL, alternate data streams, etc, on
        // the root dir.  Could have done a backup/restore sequence on the
        // root dir but that is a lot of work too.
        //
        PreExisting.MovedAFile      = FALSE;
        PreExisting.RootPath        = Replica->Root;
        PreExisting.PreExistingPath = PreExistingPath;

        WStatus = FrsEnumerateDirectory(RootHandle,
                                        Replica->Root,
                                        0,
                                        ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE,
                                        &PreExisting,
                                        DbsEnumerateDirectoryPreExistingWorker);
        DPRINT1_WS(3, "++ WARN - FrsMoveExisting(%ws);", PreExistingPath, WStatus);

        //
        // Delete the preexisting directory if no files were moved
        //
        if (!PreExisting.MovedAFile) {
            WStatus = FrsDeletePath(PreExistingPath,
                                    ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE);
            if (!WIN_SUCCESS(WStatus)) {
                DPRINT1_WS(3, "++ WARN - FrsDeletePath(%ws);", PreExistingPath,  WStatus);
                goto CLEANUP;
            }
            DPRINT3(4, "++ DID NOT move files from %ws for %ws\\%ws\n",
                    Replica->Root, Replica->SetName->Name, Replica->MemberName->Name);
        } else {
            EPRINT2(EVENT_FRS_MOVED_PREEXISTING, Replica->Root, PreExistingPath);
            DPRINT3(4, "++ Moved files from %ws for %ws\\%ws\n",
                    Replica->Root, Replica->SetName->Name, Replica->MemberName->Name);
        }
    }

    //
    // DONE
    //
    WStatus = ERROR_SUCCESS;

CLEANUP:

    FRS_CLOSE(RootHandle);

    FrsFree(PreInstallPath);
    FrsFree(PreExistingPath);
    DPRINT3_WS(4, "++ DONE Preparing root %ws for %ws\\%ws; ",
               Replica->Root, Replica->SetName->Name, Replica->MemberName->Name, WStatus);

    if (!WIN_SUCCESS(WStatus)) {
        EPRINT1(EVENT_FRS_PREPARE_ROOT_FAILED, Replica->Root);
    }

    return WStatus;
}


JET_ERR
DbsBuildDirTable(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    IDTableCtx,
    IN PTABLE_CTX    DIRTableCtx
    )

/*++

Routine Description:

    This function opens the tables specified by the table context
    (if they are not already open) and builds the DIRTable contents by
    scanning the IDTable for directory entries.

    If the TableCtx->Tid field is NOT JET_tableidNil then
    we assume it is good FOR THIS SESSION and do not reopen the table.

    Note:  NEVER use table IDs across sessions or threads.

Arguments:

    ThreadCtx  - Provides the Jet Sesid and Dbid.

    IDTableCtx   - The ID table context providing the data uses the following:

            JTableCreate - The table create structure which provides info
                           about the columns that were created in the table.

            JRetColumn - The JET_RETRIEVECOLUMN struct array to tell
                         Jet where to put the data.

            ReplicaNumber - The id number of the replica this table belongs too.


    DIRTableCtx   - The DIR table context to load:

            JTableCreate - The table create structure which provides info
                           about the columns that were created in the table.

            JSetColumn - The JET_SETCOLUMN struct array to tell
                         Jet where to get the data.

            ReplicaNumber - The id number of the replica this table belongs too.

PERF COMMENTS:

    Two things can be done to make this more efficient.

    1. Build a special IDTable JET_RETRIEVECOLUMN struct to only pull the necessary
       fields from the IDTable record.

    2. Point the addresses in the DIRTable JET_SETCOLUMN struct to the fields in the
       IDTable JET_RETRIEVECOLUMN struct and avoid the copy.


Return Value:

    Jet Error Status.  If we encounter an error the tables are closed and
    the error status is returned.  Return JET_errSuccess if all OK.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsBuildDirTable:"

    JET_ERR    jerr, jerr1;
    JET_SESID  Sesid;
    NTSTATUS   Status;
    ULONG      ReplicaNumber;

    JET_TABLEID IDTid;
    CHAR        IDTableName[JET_cbNameMost];

    JET_TABLEID DIRTid;
    CHAR        DIRTableName[JET_cbNameMost];
    JET_TABLEID FrsOpenTableSaveTid;   // for FrsOpenTableMacro DEBUG




    Sesid          = ThreadCtx->JSesid;
    ReplicaNumber  = IDTableCtx->ReplicaNumber;


    //
    // Open the ID table, if not already open. Check the session id for match.
    //
    jerr = DBS_OPEN_TABLE(ThreadCtx, IDTableCtx, ReplicaNumber, IDTableName, &IDTid);
    CLEANUP1_JS(0, "FrsOpenTable (%s) :", IDTableName, jerr, ERROR_RET_TABLE);

    //
    // Open the DIR Table, if not already open. Check the session id for match.
    //
    jerr = DBS_OPEN_TABLE(ThreadCtx, DIRTableCtx, ReplicaNumber, DIRTableName, &DIRTid);
    CLEANUP1_JS(0, "FrsOpenTable (%s) :", DIRTableName, jerr, ERROR_RET_TABLE);

    //
    // Initialize the JetSet/RetCol arrays and data record buffer addresses
    // to write the fields of the DIRTable records from the DIRTableRec.
    //
    DbsSetJetColSize(DIRTableCtx);
    DbsSetJetColAddr(DIRTableCtx);

    //
    // Allocate the storage for the variable length fields in the record and
    // update the JetSet/RetCol arrays appropriately.
    //
    Status = DbsAllocRecordStorage(DIRTableCtx);
    CLEANUP_NT(0, "ERROR - DbsAllocRecordStorage failed to alloc buffers.",
               Status, ERROR_RET_TABLE);

    //
    // Scan thru the IDTable by the FileGuidIndex calling
    // DbsBuildDirTableWorker() for each record to make entires in the DIRTable.
    //

    jerr = FrsEnumerateTable(ThreadCtx,
                             IDTableCtx,
                             GuidIndexx,
                             DbsBuildDirTableWorker,
                             DIRTableCtx);

    //
    //  We're done.  Return success if we made it to the end of the ID Table.
    //
    if (jerr == JET_errNoCurrentRecord ) {
        return JET_errSuccess;
    } else {
        return jerr;
    }

    //
    // Error return paths
    //

ERROR_RET_TABLE:

    //
    // Close the tables and reset TableCtx Tid and Sesid.   Macro writes 1st arg.
    //
    DbsCloseTable(jerr1, Sesid, IDTableCtx);
    DbsCloseTable(jerr1, Sesid, DIRTableCtx);

    return jerr;

}



JET_ERR
DbsBuildDirTableWorker(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it checks if the IDTable record is for a directory and
    if so, writes a DIRTable record.  The caller of FrsEnumerateTable()
    has opened the DIRTable and passed the DIRTableCtx thru the Context
    argument.

Arguments:

    ThreadCtx - Needed to access Jet.
    TableCtx  - A ptr to an IDTable context struct.
    Record    - A ptr to a IDTable record.
    Context   - A ptr to a DIRTable context struct.

Thread Return Value:

    A Jet error status.  Success means call us with the next record.
    Failure means don't call again and pass our status back to the
    caller of FrsEnumerateTable().

--*/
{
#undef DEBSUB
#define DEBSUB "DbsBuildDirTableWorker:"

    JET_ERR jerr;

    PTABLE_CTX  DIRTableCtx = (PTABLE_CTX) Context;

    PDIRTABLE_RECORD DIRTableRec = (PDIRTABLE_RECORD) (DIRTableCtx->pDataRecord);

    PIDTABLE_RECORD IDTableRec = (PIDTABLE_RECORD) Record ;

    //
    // Include the record if the file is a directory, replication is enabled
    // on the directory and the directory is not marked for deletion or was
    // a new file in progress when the system last went down.
    //
    if (IDTableRec->FileIsDir) {

        //
        // Build the DIRTable record.
        //
        DIRTableRec->DFileGuid      = IDTableRec->FileGuid;
        DIRTableRec->DFileID        = IDTableRec->FileID;
        DIRTableRec->DParentFileID  = IDTableRec->ParentFileID;
        DIRTableRec->DReplicaNumber = DIRTableCtx->ReplicaNumber;
        wcscpy(DIRTableRec->DFileName, IDTableRec->FileName);


        if (IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_NEW_FILE_IN_PROGRESS) ||
            !IDTableRec->ReplEnabled ||
            IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETED)) {

            //
            // Clean up the DIR Table so we keep bogus entries out of the
            // journal's parent file ID and the Filter Tables
            //
            jerr = DbsDeleteRecord(ThreadCtx,
                                   (PVOID) &DIRTableRec->DFileGuid,
                                   DFileGuidIndexx,
                                   DIRTableCtx);
            DPRINT_JS(3, "WARNING - Dir table record delete failed:", jerr);
        } else {

            //
            // Now insert the DIR Table record.
            //
            jerr = DbsInsertTable2(DIRTableCtx);
            DPRINT_JS(3, "WARNING - Dir table record insert error:", jerr);
        }
    }

    //
    // Return success so we can keep going thru the ID table.
    //
    return JET_errSuccess;
}



JET_ERR
DbsBuildVVTableWorker(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it inserts a copy of the record from the VVTable into
    the generic table addressed by Context.

Arguments:

    ThreadCtx - Needed to access Jet.
    TableCtx  - A ptr to an VVTable context struct.
    Record    - A ptr to a VVTable record.
    Context   - A ptr to a generic table

Thread Return Value:

    JET_errSuccess

--*/
{
#undef DEBSUB
#define DEBSUB "DbsBuildVVTableWorker:"

    PGEN_TABLE      VV          = (PGEN_TABLE)Context;
    PVVTABLE_RECORD VVTableRec  = (PVVTABLE_RECORD)Record;

    //
    // Insert the version into the replica's version vector
    //
    DPRINT1(4, "Enumerating VV for %08x %08x\n",
           PRINTQUAD(VVTableRec->VVOriginatorVsn));
    VVUpdate(VV, VVTableRec->VVOriginatorVsn, &VVTableRec->VVOriginatorGuid);
    //
    // Return success so we can keep going thru the VV table.
    //
    return JET_errSuccess;
}


VOID
DbsCopyCxtionRecordToCxtion(
    IN PTABLE_CTX   TableCtx,
    IN PCXTION      Cxtion
    )
/*++

Routine Description:

    Copy the cxtion record fields into the cxtion

Arguments:

    TableCtx
    Cxtion

Thread Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsCopyCxtionRecordToCxtion:"
    POUT_LOG_PARTNER    OutLogPartner;
    PCXTION_RECORD      CxtionRecord = TableCtx->pDataRecord;


    //
    // Update the in memory structure
    //

    //
    // Cxtion Name
    //
    Cxtion->Name = FrsBuildGName(FrsDupGuid(&CxtionRecord->CxtionGuid),
                                 FrsWcsDup(CxtionRecord->CxtionName));
    if (!Cxtion->Name->Name) {
        DPRINT(0, "ERROR - Cxtion's name is NULL!\n");
        Cxtion->Name->Name = FrsWcsDup(L"<unknown>");
    }
    //
    // Partner Name
    //
    Cxtion->Partner = FrsBuildGName(FrsDupGuid(&CxtionRecord->PartnerGuid),
                                    FrsWcsDup(CxtionRecord->PartnerName));
    if (!Cxtion->Partner->Name) {
        DPRINT1(0, "ERROR - %ws: Cxtion's partner's name is NULL!\n",
                Cxtion->Name->Name);
        Cxtion->Partner->Name = FrsWcsDup(L"<unknown>");
    }

    //
    // Partner DNS Name
    //
    Cxtion->PartnerDnsName = FrsWcsDup(CxtionRecord->PartnerDnsName);
    if (!Cxtion->PartnerDnsName) {
        DPRINT1(0, "ERROR - %ws: Cxtion's PartnerDnsName is NULL!\n",
                Cxtion->Name->Name);
        Cxtion->PartnerDnsName = FrsWcsDup(Cxtion->Partner->Name);
    }

    //
    // Partner server name
    //
    Cxtion->PartSrvName = FrsWcsDup(CxtionRecord->PartSrvName);
    if (!Cxtion->PartSrvName) {
        DPRINT1(0, "ERROR - %ws: Cxtion's PartSrvName is NULL!\n",
                Cxtion->Name->Name);
        Cxtion->PartSrvName = FrsWcsDup(L"<unknown>");
    }

    //
    // Parnter PrincName
    //
    DbsUnPackStrW(&Cxtion->PartnerPrincName, CrPartnerPrincNamex, TableCtx);
    if (!Cxtion->PartnerPrincName) {
        DPRINT1(0, "ERROR - %ws: Cxtion's PartnerPrincName is NULL!\n",
                Cxtion->Name->Name);
        Cxtion->PartnerPrincName = FrsWcsDup(L"<unknown>");
    }

    //
    // Parnter SID
    //
    DbsUnPackStrW(&Cxtion->PartnerSid, CrPartnerSidx, TableCtx);
    if (!Cxtion->PartnerSid) {
        DPRINT1(0, "ERROR - %ws: Cxtion's PartnerSid is NULL!\n",
                Cxtion->Name->Name);
        Cxtion->PartnerSid = FrsWcsDup(L"<unknown>");
    }

    //
    // Partner Auth Level
    //
    Cxtion->PartnerAuthLevel = CxtionRecord->PartnerAuthLevel;

    //
    // Inbound
    //
    Cxtion->Inbound = CxtionRecord->Inbound;

    //
    // LastJoinTime
    //
    COPY_TIME(&Cxtion->LastJoinTime, &CxtionRecord->LastJoinTime);

    //
    // Schedule
    //
    DbsUnPackSchedule(&Cxtion->Schedule, CrSchedulex, TableCtx);
    DBS_DISPLAY_SCHEDULE(4, L"Schedule unpacked for Cxtion:", Cxtion->Schedule);


    Cxtion->TerminationCoSeqNum = CxtionRecord->TerminationCoSeqNum;

    //
    // Cxtion Flags
    // High short belongs to cxtion
    //
    Cxtion->Flags &= ~CXTION_FLAGS_CXTION_RECORD_MASK;
    Cxtion->Flags |= (CxtionRecord->Flags & CXTION_FLAGS_CXTION_RECORD_MASK);

    //
    // Cxtion options.
    //
    Cxtion->Options = CxtionRecord->Options;
    Cxtion->Priority = FRSCONN_GET_PRIORITY(Cxtion->Options);

    //
    // OUT LOG PARTNER
    //
    if (Cxtion->Inbound) {
        return;
    }
    Cxtion->OLCtx = FrsAllocType(OUT_LOG_PARTNER_TYPE);
    OutLogPartner = Cxtion->OLCtx;
    OutLogPartner->Cxtion = Cxtion;
    //
    // Low short belongs to outlogpartner
    //
    OutLogPartner->Flags &= ~OLP_FLAGS_CXTION_RECORD_MASK;
    OutLogPartner->Flags |= (CxtionRecord->Flags & OLP_FLAGS_CXTION_RECORD_MASK);
    OutLogPartner->COLx = CxtionRecord->COLx;
    OutLogPartner->COTx = CxtionRecord->COTx;
    OutLogPartner->COTxNormalModeSave = CxtionRecord->COTxNormalModeSave;
    OutLogPartner->COTslot = CxtionRecord->COTslot;
    OutLogPartner->OutstandingQuota = MaxOutLogCoQuota;  //CxtionRecord->OutstandingQuota
    CopyMemory(OutLogPartner->AckVector, CxtionRecord->AckVector, ACK_VECTOR_BYTES);

    //
    // Schedule
    //
    DbsUnPackSchedule(&Cxtion->Schedule, CrSchedulex, TableCtx);
    DBS_DISPLAY_SCHEDULE(4, L"Schedule unpacked for Cxtion:", Cxtion->Schedule);
}


JET_ERR
DbsBuildCxtionTableWorker(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it inserts a copy of the record from the CxtionTable
    into the generic table addressed by Context.

Arguments:

    ThreadCtx - Needed to access Jet.
    TableCtx
    Record
    Context -- Pointer to the replica structure.

Thread Return Value:

    JET_errSuccess

--*/
{
#undef DEBSUB
#define DEBSUB "DbsBuildCxtionTableWorker:"

    PCXTION        Cxtion;
    ULONG          NameLen;
    PWCHAR         CxNamePtr;
    PREPLICA       Replica = (PREPLICA)Context;
    PGEN_TABLE     Cxtions = (PGEN_TABLE)Replica->Cxtions;

    DBS_DISPLAY_RECORD_SEV(5, TableCtx, TRUE);
    //
    // Copy the cxtion record into a cxtion structure
    //
    Cxtion = FrsAllocType(CXTION_TYPE);
    DbsCopyCxtionRecordToCxtion(TableCtx, Cxtion);

    //
    // Insert the version into the replica's version vector
    //
    DPRINT2(4, "Enumerating Cxtion %ws -> %ws\n",
            Cxtion->Name->Name, Cxtion->Partner->Name);

    RcsCheckCxtionSchedule(Replica, Cxtion);
    SetCxtionState(Cxtion, CxtionStateUnjoined);
    GTabInsertEntry(Cxtions, Cxtion, Cxtion->Name->Guid, NULL);

    //
    // Set the OID data structure which is a part of the counter data structure
    // stored in the hash table.  Add ReplicaConn Instance to the registry
    //
    DPRINT(4, "PERFMON:Adding Connection:CREATEDB.C:1\n");
    RcsCreatePerfmonCxtionName(Replica, Cxtion);

    //
    // Return success so we can keep going thru the VV table.
    //
    return JET_errSuccess;
}


JET_ERR
DbsInlogScanWorker(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it processes a record from the Inbound log table.

    It scans the inbound log table counting the number of retry change orders,
    the max USN on any local change order and it reconstructs the version vector
    retire list for those change orders that don't have VVExec set.

Arguments:

    ThreadCtx - Needed to access Jet.
    TableCtx  - A ptr to an inbound log context struct.
    Record    - A ptr to a change order command record.
    Context   - A ptr to the Replica struct we are working on.

Thread Return Value:

    JET_errSuccess if enum is to continue.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsInlogScanWorker:"

    PREPLICA              Replica = (PREPLICA) Context;
    PCHANGE_ORDER_COMMAND CoCmd = (PCHANGE_ORDER_COMMAND)Record;


    DBS_DISPLAY_RECORD_SEV(4, TableCtx, TRUE);

    //
    // Reconstruct the CO retry count.
    //
    Replica->InLogRetryCount += 1;

    //
    // Find largest (most recent) local journal Usn.  Recovery can only
    // advance to the FirstUsn record that may be combined into a single
    // change order with others.  If we advanced to the last USN record
    // contributing to this change order we could skip over intervening
    // USN records for other files in the replica tree that could not be
    // combined with this change order.  Then if we crashed after this
    // change order made it to the inbound log but before those others made it
    // we would end up skipping them.
    //
    // NOTE - as it stands now we could end up reprocessing USN records for
    // file operations that had already been combined into this change order.
    //
    //
    if (BooleanFlagOn(CoCmd->Flags, CO_FLAG_LOCALCO)) {
        if (Replica->JrnlRecoveryStart < CoCmd->JrnlFirstUsn) {
            Replica->JrnlRecoveryStart = CoCmd->JrnlFirstUsn;
        }
    }

    return JET_errSuccess;
}


VOID
DbsExitIfDiskFull (
    IN JET_ERR  jerr
    )
/*++

Routine Description:

    Shutdown the service if the disk is full.

Arguments:

    jerr    - JET error status

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsExitIfDiskFull:"

    ULONG                FStatus;

    //
    // Shutdown if the database volume is full
    //
    if (jerr == JET_errDiskFull || jerr == JET_errLogDiskFull) {
        DPRINT1(0, "ERROR - Disk is full on %ws; shutting down\n", WorkingPath);
        EPRINT2(EVENT_FRS_DATABASE_SPACE, ComputerName, WorkingPath);
        //
        // exit and allow the service controller to restart us
        //
        FrsSetServiceStatus(SERVICE_STOPPED,
                            0,
                            DEFAULT_SHUTDOWN_TIMEOUT * 1000,
                            ERROR_NO_SYSTEM_RESOURCES);

        DEBUG_FLUSH();

        exit(ERROR_NO_SYSTEM_RESOURCES);
    }
}

JET_ERR
DbsInitJet(
    JET_INSTANCE  *JInstance
    )
/*++

Routine Description:

    This function sets up global Jet Params and calls JetInit().

Arguments:

    JInstance - ptr to JET_INSTSANCE Context.

Return Value:

    Jet status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsInitJet:"

    JET_ERR    jerr;
    ULONG  MaxOpenTables;
    ULONG  CacheSizeMin;

    //
    // Initialize jet directories
    //
    strcpy(JetSystemParamsDef.ChkPointFilePath, JetSysA);
    strcpy(JetSystemParamsDef.TempFilePath, JetTempA);
    strcpy(JetSystemParamsDef.LogFilePath, JetLogA);

    //
    // Initialize Jet.
    //
    jerr = JetSetSystemParameter(JInstance, 0, JET_paramSystemPath, 0, JetSysA);
    CLEANUP_JS(0, "ERROR - JetSetSystemParameter(JET_paramSystemPath):", jerr, ERROR_RET_NOJET);

    jerr = JetSetSystemParameter(JInstance, 0, JET_paramTempPath, 0, JetTempA);
    CLEANUP_JS(0, "ERROR - JetSetSystemParameter(JET_paramTempPath):", jerr, ERROR_RET_NOJET);

    jerr = JetSetSystemParameter(JInstance, 0, JET_paramLogFilePath, 0, JetLogA);
    CLEANUP_JS(0, "ERROR - JetSetSystemParameter(JET_paramLogFilePath):", jerr, ERROR_RET_NOJET);

    jerr = JetSetSystemParameter(JInstance, 0, JET_paramCircularLog, 1, NULL);
    DPRINT_JS(0, "WARN - JetSetSystemParameter(JET_paramCircularLog):", jerr);

    //
    // Increase the maximum number of open tables that Jet will allow.
    //
    MaxOpenTables = MaxNumberReplicaSets * NUMBER_JET_TABLES_PER_REPLICA_SET;
    jerr = JetSetSystemParameter(JInstance, 0, JET_paramMaxOpenTables,
                                 MaxOpenTables, NULL);
    DPRINT_JS(0, "WARN - JetSetSystemParameter(JET_paramMaxOpenTables):", jerr);

    //
    // Increase the number of open database sessions.
    // JET_paramMaxSessions        maximum number of sessions [128]
    // Needed with lots of outbound partners doing lots of concurrent VVJoins.
    //
    jerr = JetSetSystemParameter(JInstance, 0, JET_paramMaxSessions,
                                 MaxNumberJetSessions, NULL);
    DPRINT_JS(0, "++ WARN - JetSetSystemParameter(JET_paramMaxSessions):", jerr);

    //
    // Increase the number of table cursors based on the number of tables.
    // JET_paramMaxCursors
    //
    jerr = JetSetSystemParameter(JInstance, 0, JET_paramMaxCursors,
                                 MaxOpenTables * 2, NULL);
    DPRINT_JS(0, "++ WARN - JetSetSystemParameter(JET_paramMaxCursors):", jerr);

    //
    //  JET_paramCacheSizeMin must be at lease 4 times JET_paramMaxSessions
    //  or JetInit will fail.
    //
    CacheSizeMin = max(4 * MaxNumberJetSessions, 64);
    jerr = JetSetSystemParameter(JInstance, 0, JET_paramCacheSizeMin,
                                 CacheSizeMin, NULL);
    CLEANUP_JS(0, "++ WARN - JetSetSystemParameter(JET_paramCacheSizeMin):", jerr, ERROR_RET_NOJET);


//#define JET_paramCacheSizeMin           60  /* minimum cache size in pages [64] */
//#define JET_paramCacheSize              41  /* current cache size in pages [512] */
//#define JET_paramCacheSizeMax           23  /* maximum cache size in pages [512] */



    DPRINT1(1, ":S: calling JetInit with %s \n", JetFileA);
    jerr = JetInit(JInstance);
    DPRINT1_JS(0, "++ ERROR - JetInit with %s :", JetFileA, jerr);

ERROR_RET_NOJET:

    return jerr;
}



JET_ERR
DbsCreateEmptyDatabase(
    PTHREAD_CTX ThreadCtx,
    PTABLE_CTX TableCtx
    )
/*++

Routine Description:

    This function controls the creation of the initial database.
    This includes creation of the config table and the initial
    configuration record <init>.  At completion it closes the database,
    terminates the Jet Session and makes a backup copy in NEWFRS.JDB.

Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.

    TableCtx  -- The table context struct which contains:

                RecordBase - The base address of the record buffer to
                             read/write from/to jet.

                JTableCreate - The table create structure which provides info
                               about the columns that were created in the table.

Return Value:

    Jet Error Status

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsCreateEmptyDatabase:"
    JET_INSTANCE JInstance = JET_instanceNil;
    JET_SESID    Sesid;
    JET_DBID     Dbid;
    JET_TABLEID  ConfigTid;
    JET_ERR      jerr      = JET_errSuccess;
    JET_ERR      jerr1     = JET_errSuccess;
    ULONG        i;
    ULONG        MaxOpenTables;
    NTSTATUS     Status;
    PCHAR        JetSys, JetTemp, JetLog;

    PCONFIG_TABLE_RECORD ConfigRecord;
    PJET_TABLECREATE     JTableCreate;
    GUID                 ReplicaMemberGuid;

    JET_TABLECREATE      TableCreate;
    CHAR                 TableName[JET_cbNameMost];


#define UNUSED_JET_szPARAM ""

    DPRINT1(0, "Creating empty Database Structure: %s\n", JetFileA);


    //
    // Get the Table Create struct for the config table to create.
    //
    JTableCreate = TableCtx->pJetTableCreate;

    //
    // Initialize Jet returning the handle.
    //
    jerr = DbsInitJet(&JInstance);
    CLEANUP_JS(0, "ERROR - DbsInitJet failed:", jerr, ERROR_RET_NOJET);

    ThreadCtx->JInstance = JInstance;

    //
    // Setup a Jet Session returning the session ID.
    // The last 2 params are username and password.
    //
    jerr = JetBeginSession(JInstance, &Sesid, NULL, NULL);
    CLEANUP1_JS(0, "++ ERROR - JetBeginSession with %s :", JetFileA, jerr, ERROR_RET_TERM);

    TableCtx->Sesid = Sesid;
    ThreadCtx->JSesid = Sesid;

    //
    // Create the database returning the database handle.  Do this with recovery
    // off to make it go faster.  Then when the DB is later detached and
    // reattached recovery is reenabled.  Note that the global param,
    // JET_paramRecovery turns recovery off for the Jet Runtime system
    // (process state) and would need to be explicitly turned back on.
    //
    jerr = JetCreateDatabase(Sesid, JetFileA, UNUSED_JET_szPARAM, &Dbid, 0);
    CLEANUP1_JS(0, "++ ERROR - JetCreateDatabase(%s) :", JetFileA, jerr, ERROR_RET_SESSION);

    ThreadCtx->JDbid = Dbid;

    //
    // Create the config table and save in the Table context.
    //
    jerr = DbsCreateJetTable(ThreadCtx, JTableCreate);
    CLEANUP1_JS(0, "++ ERROR - DbsCreateJetTable(%s) :",
                JTableCreate->szTableName, jerr, ERROR_RET_DB);

    ConfigTid = JTableCreate->tableid;
    TableCtx->Tid = JTableCreate->tableid;

    DPRINT(1,"++ Config table created.\n");

    //
    // Initialize the Jet Set/Ret Col arrays and buffer addresses to read and
    // write the fields of the ConfigTable records into ConfigRecord.
    //
    DbsSetJetColSize(TableCtx);
    DbsSetJetColAddr(TableCtx);
    //
    // Allocate the storage for the variable length fields in the record and
    // update the JetSet/RetCol arrays appropriately.
    //
    Status = DbsAllocRecordStorage(TableCtx);
    CLEANUP_NT(0, "ERROR - DbsAllocRecordStorage failed to alloc buffers.",
               Status, ERROR_RET_TABLE);

    //
    // Allocate enough record space for the Jet system parameters.
    //
    jerr = DbsReallocateFieldBuffer(TableCtx,
                                    JetParametersx,
                                    sizeof(JET_SYSTEM_PARAMS),
                                    FALSE);
    CLEANUP_JS(0, "ERROR - DbsReallocateFieldBuffer failed:", jerr, ERROR_RET_TABLE);

    //
    // Get pointer to data record and build the FRS system init record.
    //
    ConfigRecord = (PCONFIG_TABLE_RECORD) (TableCtx->pDataRecord);
    FrsUuidCreate(&ReplicaMemberGuid);
    DbsDBInitConfigRecord(TableCtx,
                          &ReplicaMemberGuid,               // ReplicaSetGuid
                          FRS_SYSTEM_INIT_RECORD,           // ReplicaSetName
                          FRS_SYSTEM_INIT_REPLICA_NUMBER,   // ReplicaNumber
                          FRS_SYSTEM_INIT_PATH,             // ReplicaRootPath
                          FRS_SYSTEM_INIT_PATH,             // ReplicaStagingPath
                          FRS_SYSTEM_INIT_PATH);            // ReplicaVolume
#if 0

//    EnterFieldData(TableCtx, LastShutdownx, &SystemTime, sizeof(FILETIME), 0);
//    EnterFieldData(TableCtx, FieldId, SrcData, Len, Flags);

//    Flags : FRS_FIELD_NULL, FRS_FIELD_USE_ADDRESS,
#endif

    //
    // Now insert the FRS system <init> record.
    //
    jerr = DbsInsertTable2(TableCtx);
    CLEANUP_JS(0, "ERROR - DbsInsertTable2 failed inserting <init> config record.",
               jerr, ERROR_RET_TABLE);

    //
    // Create the template tables using ReplicaNumber 0 (DBS_TEMPLATE_TABLE_NUMBER).
    //
    DPRINT(0, "Creating initial template tables.\n");

    jerr = JetBeginTransaction(Sesid);
    CLEANUP_JS(0, "ERROR - JetBeginTran failed creating template tables.",
               jerr, ERROR_RET_TABLE);


    for (i=0; i<TABLE_TYPE_MAX; i++) {

        //
        // To avoid a mutex we copy the DBTable struct to a local and init
        // the table name here instead of writing into the global struct.
        //
        CopyMemory(&TableCreate, &DBTables[i], sizeof(JET_TABLECREATE));
        TableCreate.szTableName = TableName;

        //
        // Create the template table name.
        //
        sprintf(TableName, "%s%05d", DBTables[i].szTableName, DBS_TEMPLATE_TABLE_NUMBER);

        //
        // The first set of table creates use replica number
        // DBS_TEMPLATE_TABLE_NUMBER (0) to make a set of template tables
        // can be used by subsequent creates of the same table type.
        // This ensures that the column IDs of each table of a given type
        // are the same.
        //
        TableCreate.szTemplateTableName = NULL;
        //
        // No initial allocation of pages for the template tables.
        //
        TableCreate.ulPages = 0;

        jerr = DbsCreateJetTable(ThreadCtx, &TableCreate);
        CLEANUP1_JS(1, "Table %s create error:", TableName, jerr, ERROR_RETURN_TEMPLATE);

        jerr = JetCloseTable(Sesid, TableCreate.tableid);
        CLEANUP1_JS(1, "Table %s close error:", TableName, jerr, ERROR_RETURN_TEMPLATE);
    }

    //
    // Commit the table creates.
    //
    jerr = JetCommitTransaction(Sesid, 0);
    CLEANUP_JS(0, "ERROR - JetCommitTran failed creating template tables.",
               jerr, ERROR_RETURN_TEMPLATE);


#if DBG
    //
    // Fill up the jet database using very high replica numbers to more quickly
    // cause out-of-space errors later.
    //
    if (DebugInfo.DbsOutOfSpace) {
        DWORD   i;
        DWORD   DbsOutOfSpace;

        DPRINT(0, "++ DBG - Filling the database\n");
        DbsOutOfSpace = DebugInfo.DbsOutOfSpace;
        DebugInfo.DbsOutOfSpace = 0;
        for (i = 0; i < 1000; ++i) {
            FrsUuidCreate(&ReplicaMemberGuid);
            DbsDBInitConfigRecord(TableCtx,
                                  &ReplicaMemberGuid,               // ReplicaSetGuid
                                  L"DBS_OUT_OF_SPACE",              // ReplicaSetName
                                  DBS_MAX_REPLICA_NUMBER - (i + 1),
                                  FRS_SYSTEM_INIT_PATH,             // ReplicaRootPath
                                  FRS_SYSTEM_INIT_PATH,             // ReplicaStagingPath
                                  FRS_SYSTEM_INIT_PATH              // ReplicaVolume
                                  );
            jerr = DbsInsertTable2(TableCtx);
            if (!JET_SUCCESS(jerr)) {
                goto ERROR_RET_TABLE;
            }
        }
        DebugInfo.DbsOutOfSpace = DbsOutOfSpace;
        DPRINT(0, "++ DBG - DONE Filling the database\n");
    }
#endif DBG

    goto RETURN;


ERROR_RETURN_TEMPLATE:

    //
    // Roll back the table creates.
    //
    jerr1 = JetRollback(Sesid, 0);
    DPRINT_JS(0, "ERROR - JetRollback failed on creating template tables.", jerr1);

    //
    // DEBUG OPTION: Delete fill file
    //
    DBG_DBS_OUT_OF_SPACE_EMPTY(DBG_DBS_OUT_OF_SPACE_OP_CREATE);

//
// Common return path with error entries.  Can't use DbsCloseJetSession since
// this is a DB create and we aren't attached.
//
RETURN:
ERROR_RET_TABLE:
    //
    // Close the table, reset TableCtx Tid and Sesid.    Macro writes 1st arg.
    //
    DbsCloseTable(jerr1, Sesid, TableCtx);
    DPRINT1_JS(0, "++ ERROR - JetCloseTable(%s) :", JTableCreate->szTableName, jerr1);

ERROR_RET_DB:

    jerr1 = JetCloseDatabase(Sesid, Dbid, 0);
    DPRINT1_JS(0, "++ ERROR - JetCloseDatabase(%s) :", JetFileA, jerr1);

    TableCtx->Tid = JET_tableidNil;
    ThreadCtx->JDbid = JET_dbidNil;

ERROR_RET_SESSION:

    jerr1 = JetEndSession(Sesid, 0);
    DPRINT1_JS(0, "++ ERROR - JetEndSession(%s) :", JetFileA, jerr1);

    TableCtx->Sesid = JET_sesidNil;
    ThreadCtx->JSesid = JET_sesidNil;

ERROR_RET_TERM:

    jerr1 = JetTerm(JInstance);
    DPRINT1_JS(0, "++ ERROR - JetTerm(%s) :", JetFileA, jerr1);

    if (JET_SUCCESS(jerr1)) {
        DPRINT2(1, "++ JetTerm(%s) %s complete\n", JetFileA, JTableCreate->szTableName);
    }

    ThreadCtx->JInstance = JET_instanceNil;
    GJetInstance = JET_instanceNil;

ERROR_RET_NOJET:

    if (JET_SUCCESS(jerr)) {
        //
        // Copy this to a Backup.
        //
        // CopyFileA(szJetFilePath, "T:\\NEWFRS.JDB", FALSE);
    } else {
        //LogUnhandledError(jerr);
    }
    //
    // Shutdown if the database volume is full
    //
    DbsExitIfDiskFull(jerr);
    DbsExitIfDiskFull(jerr1);

    return jerr;
}



VOID
DbsDBInitConfigRecord(
    IN PTABLE_CTX   TableCtx,
    IN GUID  *ReplicaSetGuid,
    IN PWCHAR ReplicaSetName,
    IN ULONG  ReplicaNumber,
    IN PWCHAR ReplicaRootPath,
    IN PWCHAR ReplicaStagingPath,
    IN PWCHAR ReplicaVolume
    )
/*++

Routine Description:

    Fill in the fields of a config record.

Arguments:

    TableCtx            - ptr to the table context for the replica
    ReplicaSetGuid      - ptr to GUID assigned to the replica set.
    ReplicaSetName      - replica set name, unicode
    ReplicaNumber       - internal replica ID number
    ReplicaRootPath     - Root path to the base of the replica set (unicode)
    ReplicaStagingPath  - Path to file replication staging area
    ReplicaVolume       - NTFS Volume the replica tree lives on.

Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsDBInitConfigRecord:"

    FILETIME        SystemTime;
    HANDLE          FileHandle;
    IO_STATUS_BLOCK Iosb;
    PFILE_FS_VOLUME_INFORMATION VolumeInfo;
    ULONG           VolumeInfoLength;
    DWORD           WStatus;
    NTSTATUS        Status;
    ULONG           Length;
    PCONFIG_TABLE_RECORD    ConfigRecord = TableCtx->pDataRecord;
    CHAR            TimeStr[TIME_STRING_LENGTH];

    //
    // The size of var len DT_BINARY records must be set in the Type/Size
    // prefix so DbsInsertTable2 knows how big it is.
    //
    //
    // For now make the ReplicaSetGuid and the ReplciaMemberGuid the same.
    // The DS init will change the ReplicaSetGuid to the Guid on the
    // set object and the ReplicaRootGuid will be newly created.
    //
    COPY_GUID(&ConfigRecord->ReplicaSetGuid,    ReplicaSetGuid);
    COPY_GUID(&ConfigRecord->ReplicaMemberGuid, ReplicaSetGuid);
    COPY_GUID(&ConfigRecord->ReplicaRootGuid,   ReplicaSetGuid);

    wcscpy(ConfigRecord->ReplicaSetName, ReplicaSetName);
    ConfigRecord->ReplicaNumber = ReplicaNumber;
    ConfigRecord->ReplicaMemberUSN = 0;

    ConfigRecord->DSConfigVersionNumber = 0;


    FrsUuidCreate(&ConfigRecord->FSVolGuid);
    FrsUuidCreate(&ConfigRecord->ReplicaVersionGuid);

    ConfigRecord->FSVolLastUSN = 0;

    ConfigRecord->FrsVsn = 0;

    //
    // LastShutdown must start out as 0 when the replica set is first
    // created so we know to start reading the USN journal at its current
    // location.
    //
    ConfigRecord->LastShutdown = 0;

    GetSystemTimeAsFileTime(&SystemTime);
    COPY_TIME(&ConfigRecord->LastPause,             &SystemTime);
    COPY_TIME(&ConfigRecord->LastDSCheck,           &SystemTime);
    COPY_TIME(&ConfigRecord->LastReplCycleStart,    &SystemTime);
    COPY_TIME(&ConfigRecord->DirLastReplCycleEnded, &SystemTime);

    //LastReplCycleStatus;

    wcscpy(ConfigRecord->FSRootPath, ReplicaRootPath);

    wcscpy(ConfigRecord->FSStagingAreaPath, ReplicaStagingPath);

    //
    // VOLUME_INFORMATION   FSVolInfo;
    //
    if (WSTR_NE(ReplicaRootPath, FRS_SYSTEM_INIT_PATH)) {
        WStatus = FrsOpenSourceFileW(&FileHandle, ReplicaVolume,
//                                     READ_ACCESS,
                                     READ_ATTRIB_ACCESS,
                                     OPEN_OPTIONS);
        if (WIN_SUCCESS(WStatus)) {

            VolumeInfoLength = sizeof(*VolumeInfo)+MAXIMUM_VOLUME_LABEL_LENGTH;
            VolumeInfo = ConfigRecord->FSVolInfo;

            //
            // Get the info.
            //
            Status = NtQueryVolumeInformationFile(FileHandle,
                                                  &Iosb,
                                                  VolumeInfo,
                                                  VolumeInfoLength,
                                                  FileFsVolumeInformation);
            if ( NT_SUCCESS(Status) ) {

                VolumeInfo->VolumeLabel[VolumeInfo->VolumeLabelLength/2] = UNICODE_NULL;
                FileTimeToString((PFILETIME) &VolumeInfo->VolumeCreationTime, TimeStr);

                DPRINT5(4,"++ %-16ws (%d), %s, VSN: %08X, VolCreTim: %s\n",
                        VolumeInfo->VolumeLabel,
                        VolumeInfo->VolumeLabelLength,
                       (VolumeInfo->SupportsObjects ? "(obj)" : "(no-obj)"),
                        VolumeInfo->VolumeSerialNumber,
                        TimeStr);

            } else {
                DPRINT_NT(0, "++ ERROR - Replica root QueryVolumeInformationFile failed.", Status);
            }

            //
            // Close the file and check for errors.
            //
            Status = NtClose(FileHandle);

            if (!NT_SUCCESS(Status)) {
                DPRINT_NT(0, "++ ERROR - Close file handle failed on Replica root.", Status);
            }

        } else {
            DPRINT_WS(0, "++ ERROR - Replica root open failed;", WStatus);
        }
    }

    // *FSRootSD;
    //SnapFileSizeLimit;
    //ActiveServCntlCommand;
    ConfigRecord->ServiceState = CNF_SERVICE_STATE_CREATING;

    ConfigRecord->ReplDirLevelLimit = 0x7FFFFFFF;

    //InboundPartnerState;

    wcscpy(ConfigRecord->AdminAlertList, TEXT("Admin1, Admin2, ..."));

    //ThrottleSched;
    //ReplSched;
    //FileTypePrioList;

    //ResourceStats;
    //PerfStats;
    //ErrorStats;

    ConfigRecord->TombstoneLife = ParamTombstoneLife;     // days
    //GarbageCollPeriod;
    //MaxOutBoundLogSize;
    //MaxInBoundLogSize;
    //UpdateBlockedTime;
    //EventTimeDiffThreshold;
    //FileCopyWarningLevel;
    //FileSizeWarningLevel;
    //FileSizeNoRepLevel;

    //
    // The following fields are only present in the system init config record.
    //
    if (ReplicaNumber == FRS_SYSTEM_INIT_REPLICA_NUMBER) {
        Length = MAX_RDN_VALUE_SIZE+1;
        GetComputerName(ConfigRecord->MachineName, &Length );

        FrsUuidCreate(&ConfigRecord->MachineGuid);
        wcscpy(ConfigRecord->FSDatabasePath, JetFile);
        wcscpy(ConfigRecord->FSBackupDatabasePath, JetFile);
        CopyMemory(ConfigRecord->JetParameters, &JetSystemParamsDef, sizeof(JetSystemParamsDef));
        DbsPackStrW(ServerPrincName, ReplicaPrincNamex, TableCtx);
    }

    return;
}



JET_ERR
DbsOpenConfig(
    IN OUT PTHREAD_CTX    ThreadCtx,
    IN OUT PTABLE_CTX     TableCtx
    )
/*++

Routine Description:

    This function opens the config table and reads the FRS init record to get
    system parameters.  It then restarts Jet using the appropriate Jet params.

    If we fail find the system init record we return JET_errInvalidDatabase.
    This forces a rebuild of the database.

Arguments:

    ThreadCtx   - The thread context.  The Jet instance, session id and DB ID
                  are returned here.

    TableCtx    - Table context for the Config table.

Return Value:

    Jet status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsOpenConfig:"

    JET_ERR    jerr, jerr1;
    ULONG      i;

    JET_INSTANCE  JInstance;
    JET_SESID     Sesid;
    JET_DBID      Dbid;
    JET_TABLEID   ConfigTid;
    PCONFIG_TABLE_RECORD ConfigRecord;

    BOOL                Tried1414Fix = FALSE;
    PJET_SYSTEM_PARAMS  JetSystemParams;
    PJET_PARAM_ENTRY    Jpe;

    BOOL      FirstTime = TRUE;
    ULONG     ActualLength;
    ULONG_PTR Lvalue;

    CHAR   StrValue[100];
    WCHAR  CommandLine[MAX_CMD_LINE];



    DPRINT1(5, "<<<<<<<...E N T E R I N G -- %s...>>>>>>>>\n", DEBSUB);

    //
    // Initialize Jet returning the handle.
    //
    jerr = DbsInitJet(&JInstance);
    CLEANUP_JS(0, "ERROR - DbsInitJet failed:", jerr, ERROR_RET_NOJET);


REINIT_JET:

    ThreadCtx->JInstance = JInstance;
    GJetInstance = JInstance;

    //
    // Setup a Jet Session returning the session ID and Dbid in ThreadCtx.
    //
    jerr = DbsCreateJetSession(ThreadCtx);
    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(1, "++ ERROR - DbsCreateJetSession:", jerr);

        //
        // perform a manual recovery process for -1414 in the event log.
        //
        // 4/10/2000 - Supposedly jet has been fixed to allow us to reconstruct the
        // indexes on tables with fixed ddls.  When this tests ok then the
        // following workaround can be removed.
        //
        if (jerr == JET_errSecondaryIndexCorrupted) {

            //
            // Fork a process to run utility for the user.
            //
            // "esentutl /d %JetFile /l%JetLog /s%JetSys".
            //
            if (!Tried1414Fix) {

                DPRINT(0,"++ Attempting corrective action.\n");

                JetTerm(JInstance);

                Tried1414Fix = TRUE;

                _snwprintf(CommandLine, ARRAY_SZ(CommandLine),
                           L"esentutl /d %ws /l%ws /s%ws", JetFile, JetLog, JetSys);

                DPRINT1(0,"++ Running: %ws\n", CommandLine);

                jerr = FrsRunProcess(CommandLine, INVALID_HANDLE_VALUE,
                                     INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE);

                DPRINT_JS(0, "++ esentutl status:", jerr);
                DPRINT(0,"++ Retrying database init\n");
                jerr = JetInit(&JInstance);
                CLEANUP1_JS(0, "++ ERROR - JetInit with %s :", JetFileA, jerr, ERROR_RET_NOJET);
                goto REINIT_JET;
            }
            //
            // esentutl didn't fix the problem.
            //
            EPRINT4(EVENT_FRS_JET_1414, ComputerName, JetFile, JetLog, JetSys);
        }

        if (DbsTranslateJetError(jerr, FALSE) == FrsErrorDatabaseCorrupted) {
            //
            // Added for Testing.
            //
            DPRINT(0, "++ Database corrupted *****************\n");
        }

        goto ERROR_RET_TERM;
    }

    Sesid = ThreadCtx->JSesid;
    Dbid  = ThreadCtx->JDbid;

    DPRINT(4,"++ DbsOpenConfig - JetOpenDatabase complete\n");

    //
    // Dump the Jet system parameters.
    //
    for (i=0; i<MAX_JET_SYSTEM_PARAMS; i++) {
        if (JetSystemParamsDef.ParamEntry[i].ParamType == JPARAM_TYPE_LAST) {
            break;
        }
        Lvalue = 0;
        StrValue[0] = '\0';

        jerr = JetGetSystemParameter(JInstance,
                                     Sesid,
                                     JetSystemParamsDef.ParamEntry[i].ParamId,
                                     &Lvalue,
                                     StrValue,
                                     sizeof(StrValue));

        DPRINT3(1, "++ %-25s: %8d, %s\n",
               JetSystemParamsDef.ParamEntry[i].ParamName, (ULONG)Lvalue, StrValue);

    }
    //
    // On the first time through read the init config record and reinit
    // Jet if required.
    //
    if (FirstTime) {
        FirstTime = FALSE;

        //
        // This opens the Table if it's not already open.
        //
        //
        // Recreate any deleted indexes.
        //
        // An index may get deleted during the call to JetAttachDatabase()
        // when the JET_bitDbDeleteCoruptIndexes grbit is set. Jet
        // normally marks indexes as corrupt when the build number
        // changes because jet has no way of knowing if the collating
        // sequence in the current build is different than those in
        // other builds.
        //
        jerr = DbsRecreateIndexes(ThreadCtx, TableCtx);
        CLEANUP_JS(0, "++ ERROR - DbsRecreateIndexes:", jerr, ERROR_RET_TABLE);

        ConfigRecord = (PCONFIG_TABLE_RECORD) (TableCtx->pDataRecord);
        wcscpy(ConfigRecord->ReplicaSetName, TEXT("This is junk"));
        ConfigRecord->ReplicaMemberGuid.Data1 = 0;
        ConfigRecord->ReplicaNumber = FRS_SYSTEM_INIT_REPLICA_NUMBER;

        jerr = DbsReadRecord(ThreadCtx,
                             &ConfigRecord->ReplicaNumber,
                             ReplicaNumberIndexx,
                             TableCtx);

        if (!JET_SUCCESS(jerr)) {
            DPRINT_JS(0, "++ ERROR - DbsReadRecord:", jerr);
            if (jerr == JET_errRecordNotFound) {
                //
                // No system init record means database not initialized.
                //
                jerr = JET_errNotInitialized;
                DbsTranslateJetError(jerr, TRUE);
            }
            goto ERROR_RET_TABLE;
        }

        // DUMP_TABLE_CTX(TableCtx);
        DBS_DISPLAY_RECORD_SEV(5, TableCtx, TRUE);
        ConfigTid = TableCtx->Tid;


        //
        //  Check the init config record for Jet init params.
        //  The first param type that changes a setting causes us to
        //  stop Jet, set the new parameters and restart.  First check that
        //  the system parameter field looks reasonable.
        //
        ConfigRecord = (PCONFIG_TABLE_RECORD) (TableCtx->pDataRecord);
        JetSystemParams = ConfigRecord->JetParameters;

        ActualLength = FRS_GET_RFIELD_LENGTH_ACTUAL(TableCtx, JetParametersx);
        DbsDisplayJetParams(JetSystemParams, ActualLength);


        if ((ActualLength == sizeof(JET_SYSTEM_PARAMS)) &&
            (JetSystemParams != NULL)  &&
            (JetSystemParams->ParamEntry[MAX_JET_SYSTEM_PARAMS-1].ParamType
                == JPARAM_TYPE_LAST)) {

#if 0
    // Note:  left as example code but deleted since params may change (e.g., jet path)
            i = 0;
            while (JetSystemParams->ParamEntry[i].ParamType == JPARAM_TYPE_SKIP) {
                i += 1;
            }

            if (JetSystemParams->ParamEntry[i].ParamType != JPARAM_TYPE_LAST) {
                //
                // Close the table, reset TableCtx Tid and Sesid.
                // Close Jet.  DbsCloseTable is a Macro writes 1st arg.
                //

                DPRINT(0, "++ Closing Jet and setting new parameters.\n");
                DbsCloseTable(jerr, Sesid, TableCtx);
                JetCloseDatabase(Sesid, Dbid, 0);
                InterlockedDecrement(&OpenDatabases);
                JetDetachDatabase(Sesid, JetFileA);
                JetEndSession(Sesid, 0);
                JetTerm(JInstance);

                //
                // Set up the new Jet Parameters.
                //
                Jpe = JetSystemParams->ParamEntry;
                while (Jpe->ParamType != JPARAM_TYPE_LAST) {

                    switch (Jpe->ParamType) {

                    case JPARAM_TYPE_SKIP:

                        break;


                    case JPARAM_TYPE_LONG:
                        DPRINT2(0, "++ %-24s : %d\n", Jpe->ParamName, Jpe->ParamValue);

                        jerr = JetSetSystemParameter(
                            &JInstance, Sesid, Jpe->ParamId, Jpe->ParamValue, NULL);

                        DPRINT1_JS(0, "++ ERROR - Failed to set Jet System Parameter: %s :",
                                   Jpe->ParamName, jerr);
                        break;


                    case JPARAM_TYPE_STRING:
                        DPRINT2(0, "++ %-24s : %s\n", Jpe->ParamName,
                            (PCHAR)JetSystemParams+Jpe->ParamValue);

                        jerr = JetSetSystemParameter(
                            &JInstance, Sesid, Jpe->ParamId, 0,
                            ((PCHAR) JetSystemParams) + Jpe->ParamValue);

                        DPRINT1_JS(0, "++ ERROR - Failed to set Jet System Parameter: %s :",
                                   Jpe->ParamName, jerr);
                        break;


                    default:

                        DPRINT3(0, "++ ERROR - %-24s : %s <invalid parameter type, %d>\n",
                            Jpe->ParamName,
                            (PCHAR)JetSystemParams+Jpe->ParamValue,
                            Jpe->ParamType);

                    } // end switch

                    Jpe += 1;
                }
                //
                // Reinitialize Jet
                //
                DPRINT(0, "++ New parameters set, restarting jet.\n");
                jerr = JetInit(&JInstance);
                CLEANUP1_JS(0, "++ ERROR - JetInit with %s :", JetFileA, jerr, ERROR_RET_NOJET);
                goto REINIT_JET;
            }
#endif 0
        } else {
            DPRINT2(0, "++ ERROR - JetSystemParams struct invalid. Base/Len: %08x/%d\n",
                    JetSystemParams, ActualLength);
            //
            // No system init record means database not initialized.
            //
            jerr = JET_errNotInitialized;
            DbsTranslateJetError(jerr, TRUE);

            //
            // Dump the config table in replic name order.
            //
            DbsDumpTable(ThreadCtx, TableCtx, ReplicaSetNameIndexx);


            goto ERROR_RET_TABLE;
        }

    } // if(FirstTime)

    //
    // Return the jet context to the caller.
    //
    GJetInstance = JInstance;
    ThreadCtx->JInstance  = JInstance;
    ThreadCtx->JSesid     = Sesid;
    ThreadCtx->JDbid      = Dbid;

    return jerr;


//
// Error return paths
//

ERROR_RET_TABLE:
    //
    // Close the table, reset TableCtx Tid and Sesid.  Macro writes 1st arg.
    //
    DbsCloseTable(jerr1, Sesid, TableCtx);

ERROR_RET_DB:
    JetCloseDatabase(Sesid, Dbid, 0);

ERROR_RET_ATTACH:
    JetDetachDatabase(Sesid, JetFileA);

ERROR_RET_SESSION:
    JetEndSession(Sesid, 0);

ERROR_RET_TERM:
    JetTerm(JInstance);

ERROR_RET_NOJET:
    //LogUnhandledError(jerr);

    GJetInstance = JET_instanceNil;
    ThreadCtx->JInstance = JET_instanceNil;
    ThreadCtx->JSesid = JET_sesidNil;
    ThreadCtx->JDbid  = JET_dbidNil;

    return jerr;
}


ULONG
DbsCheckForOverlapErrors(
    IN PREPLICA     Replica
    )
/*++

Routine Description:

    This function checks if the passed in replica set overlaps with any
    existing replica sets. Following overlaps are checked.

    ReplicaRoot  - OtherReplicaRoot
    ReplicaRoot  - OtherReplicaStage
    ReplicaRoot  - ReplicaStage
    ReplicaRoot  - Log Directory.
    ReplicaRoot  - Working Directory
    ReplicaStage - OtherReplicaRoot


Arguments:

    Replica New or reanimating replica set.

Return Value:

    Frs Status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsCheckForOverlapErrors:"

    DWORD                WStatus;
    ULONG                FStatus                = FrsErrorSuccess;
    PVOID                Key;
    PREPLICA             DbReplica;
    PWCHAR               DebugInfoLogDir         = NULL;
    PWCHAR               ReplicaRoot             = NULL;
    PWCHAR               TraversedWorkingPath    = NULL;
    PWCHAR               ReplicaStage            = NULL;
    PWCHAR               DbReplicaRoot           = NULL;
    PWCHAR               DbReplicaStage          = NULL;

    //
    // Check for invalid nesting of Replica Root, working path and staging path.
    //
    ReplicaRoot = FrsFree(ReplicaRoot);
    WStatus = FrsTraverseReparsePoints(Replica->Root, &ReplicaRoot);
    if ( !WIN_SUCCESS(WStatus) ) {
        DPRINT2(0,"ERROR - FrsTraverseReparsePoints for %ws, WStatus = %d\n", Replica->Root, WStatus);
    }

    WStatus = FrsTraverseReparsePoints(WorkingPath, &TraversedWorkingPath);
    if ( !WIN_SUCCESS(WStatus) ) {
        DPRINT2(0,"ERROR - FrsTraverseReparsePoints for %ws, WStatus = %d\n", WorkingPath, WStatus);
    }

    if (ReplicaRoot && TraversedWorkingPath && FrsIsParent(ReplicaRoot, TraversedWorkingPath)) {

        EPRINT2(EVENT_FRS_OVERLAPS_WORKING, Replica->Root, WorkingPath);

        FStatus = FrsErrorResourceInUse;

        CLEANUP4_FS(3, ":S: ERROR - Working directory, %ws, overlaps set %ws\\%ws's root, %ws.",
                    WorkingPath, Replica->ReplicaName->Name,
                    Replica->MemberName->Name, Replica->Root, FStatus, ERROR_RETURN_OVERLAP);
    }

    ReplicaStage = FrsFree(ReplicaStage);
    WStatus = FrsTraverseReparsePoints(Replica->Stage, &ReplicaStage);
    if ( !WIN_SUCCESS(WStatus) ) {
        DPRINT2(0,"ERROR - FrsTraverseReparsePoints for %ws, WStatus = %d\n", Replica->Stage, WStatus);
    }

    if (ReplicaRoot && ReplicaStage && FrsIsParent(ReplicaRoot, ReplicaStage)) {

        EPRINT2(EVENT_FRS_OVERLAPS_STAGE, Replica->Root, Replica->Stage);

        FStatus = FrsErrorResourceInUse;

        CLEANUP4_FS(3, ":S: ERROR - Staging directory, %ws, overlaps set %ws\\%ws's root, %ws.",
                Replica->Stage, Replica->ReplicaName->Name,
                Replica->MemberName->Name, Replica->Root, FStatus, ERROR_RETURN_OVERLAP);
    }

    //
    // Logging path overlaps a replica set
    //
    if (!DebugInfo.Disabled && DebugInfo.LogDir) {
        if (ReplicaRoot && DebugInfoLogDir && FrsIsParent(ReplicaRoot, DebugInfoLogDir)) {

            EPRINT2(EVENT_FRS_OVERLAPS_LOGGING, Replica->Root, DebugInfo.LogFile);

            FStatus = FrsErrorResourceInUse;

            CLEANUP4_FS(3, ":S: ERROR - Logging directory, %ws, overlaps set %ws\\%ws's root, %ws.\n",
                    DebugInfo.LogFile, Replica->ReplicaName->Name,
                    Replica->MemberName->Name, Replica->Root, FStatus, ERROR_RETURN_OVERLAP);
        }
    }

    //
    // Check against all the other replica sets.
    //
    Key = NULL;
    while (DbReplica = RcsFindNextReplica(&Key)) {

        //
        // Don't check tombstoned members
        //
        if (!IS_TIME_ZERO(DbReplica->MembershipExpires)) {
            continue;
        }

        //
        // Don't check with itself. This can happen when we are trying to
        // reanimate an old replica set.
        //
        if (GUIDS_EQUAL(Replica->ReplicaName->Guid, DbReplica->ReplicaName->Guid)) {
            continue;
        }

        //
        // Check if the Root path, staging path or working path of the
        // new replica intersect with any existing replica set on this computer.
        //
        // The new replica's root or stage can't be under an existing
        // replica root or vice-versa.
        //
        DbReplicaRoot = FrsFree(DbReplicaRoot);
        WStatus = FrsTraverseReparsePoints(DbReplica->Root, &DbReplicaRoot);
        if ( !WIN_SUCCESS(WStatus) ) {
            DPRINT2(0,"ERROR - FrsTraverseReparsePoints for %ws, WStatus = %d\n", DbReplica->Root, WStatus);
        }

        if (DbReplicaRoot && ReplicaRoot && FrsIsParent(DbReplicaRoot, ReplicaRoot)) {

            EPRINT2(EVENT_FRS_OVERLAPS_ROOT, Replica->Root, DbReplica->Root);

            FStatus = FrsErrorResourceInUse;

            CLEANUP4_FS(3, ":S: ERROR - Root directory, %ws, overlaps set %ws\\%ws's root, %ws.",
                    Replica->Root, DbReplica->ReplicaName->Name,
                    DbReplica->MemberName->Name, DbReplica->Root, FStatus, ERROR_RETURN_OVERLAP);
        }

        if (DbReplicaRoot && ReplicaStage && FrsIsParent(DbReplicaRoot, ReplicaStage)) {

            EPRINT3(EVENT_FRS_OVERLAPS_OTHER_STAGE,
                    Replica->Root, Replica->Stage, DbReplica->Root);

            FStatus = FrsErrorResourceInUse;

            CLEANUP4_FS(3, ":S: ERROR - Staging directory, %ws, overlaps set %ws\\%ws's root, %ws.",
                    Replica->Stage, DbReplica->ReplicaName->Name,
                    DbReplica->MemberName->Name, DbReplica->Root, FStatus, ERROR_RETURN_OVERLAP);
        }

        //
        // An existing replica stage can't be under the new replica root or
        // vice-versa.
        //
        DbReplicaStage = FrsFree(DbReplicaStage);
        WStatus = FrsTraverseReparsePoints(DbReplica->Stage, &DbReplicaStage);
        if ( !WIN_SUCCESS(WStatus) ) {
            DPRINT2(0,"ERROR - FrsTraverseReparsePoints for %ws, WStatus = %d\n", DbReplica->Stage, WStatus);
        }

        if (ReplicaRoot && DbReplicaStage && FrsIsParent(ReplicaRoot, DbReplicaStage)) {

            EPRINT3(EVENT_FRS_OVERLAPS_OTHER_STAGE,
                    Replica->Root, DbReplica->Stage, DbReplica->Root);

            FStatus = FrsErrorResourceInUse;

            CLEANUP4_FS(3, ":S: ERROR - Root directory, %ws, overlaps set %ws\\%ws's staging dir, %ws.\n",
                    Replica->Root, DbReplica->ReplicaName->Name,
                    DbReplica->MemberName->Name, DbReplica->Stage, FStatus, ERROR_RETURN_OVERLAP);
        }

    }   // End loop over existing replica sets.

ERROR_RETURN_OVERLAP:

    FrsFree(DebugInfoLogDir);
    FrsFree(ReplicaRoot);
    FrsFree(TraversedWorkingPath);
    FrsFree(ReplicaStage);
    FrsFree(DbReplicaRoot);
    FrsFree(DbReplicaStage);

    return FStatus;
}


ULONG
DbsCreateReplicaTables (
    IN PTHREAD_CTX  ThreadCtx,
    IN PREPLICA     Replica,
    IN PTABLE_CTX   TableCtx
    )
/*++

Routine Description:

    This function creates a set of jet tables for the new replica set.
    The TableCtx parameter is initialized for a config record.

    If we fail to create a table then the create table
    fails and any residue is cleaned up via Jet tran rollback.
    We also delete any of the other tables in the group that were
    created successfully.

Arguments:

    ThreadCtx   - Thread context, provides session and database IDs.
    Replica
    TableCtx

Return Value:

    Frs Status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsCreateReplicaTables:"

    DWORD                WStatus;
    ULONG                FStatus                = FrsErrorSuccess;
    JET_ERR              jerr, jerr1;
    JET_SESID            Sesid;
    ULONG                i;
    PCHAR                ConfigTableName;
    JET_TABLECREATE      TableCreate;
    PCONFIG_TABLE_RECORD ConfigRecord;
    DWORD                MemberSize;
    PCHAR                MemberName;
    DWORD                FilterSize;
    PCHAR                Filter;

    GUID                 ReplicaRootGuid;
    CHAR                 TemplateName[JET_cbNameMost];
    CHAR                 TableName[JET_cbNameMost];

    Sesid = ThreadCtx->JSesid;

    FStatus = DbsCheckForOverlapErrors(Replica);
    if (!FRS_SUCCESS(FStatus)) {
        return FStatus;
    }

    //
    // Cleanup the root directory
    //     Delete preinstall directory
    //     Delete preexisting directory
    //     move existing files into preexisting directory
    //
    WStatus = DbsPrepareRoot(Replica);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT2_WS(0, ":S: ERROR - DbsPrepareRoot(%ws, %s);", Replica->Root,
                   (BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_PRIMARY)) ?
                    "PRIMARY" : "NOT PRIMARY",  WStatus);
        return FrsErrorPrepareRoot;
    }

    //
    // Init the config record.
    //
    Replica->Volume = FrsWcsVolume(Replica->Root);
    ConfigRecord = TableCtx->pDataRecord;
    Replica->ReplicaNumber = InterlockedIncrement(&FrsMaxReplicaNumberUsed);
    DbsDBInitConfigRecord(TableCtx,
                          Replica->ReplicaName->Guid,
                          Replica->ReplicaName->Name,
                          Replica->ReplicaNumber,
                          Replica->Root,    // Root Path
                          Replica->Stage,   // Staging Path
                          Replica->Volume);

    //
    // Originiator Guid
    //
    COPY_GUID(&Replica->ReplicaVersionGuid, &ConfigRecord->ReplicaVersionGuid);

    //
    // Config record flags (CONFIG_FLAG_... in schema.h)
    //
    ConfigRecord->CnfFlags = Replica->CnfFlags;

    //
    // Root Guid
    //
    FrsUuidCreate(&ReplicaRootGuid);
    FrsFree(Replica->ReplicaRootGuid);
    Replica->ReplicaRootGuid = FrsDupGuid(&ReplicaRootGuid);
    COPY_GUID(&ConfigRecord->ReplicaRootGuid, Replica->ReplicaRootGuid);

    //
    // Tombstone
    //
    COPY_TIME(&ConfigRecord->MembershipExpires, &Replica->MembershipExpires);

    //
    // Set Type
    //
    ConfigRecord->ReplicaSetType = Replica->ReplicaSetType;

    //
    // Set Guid
    //
    COPY_GUID(&ConfigRecord->ReplicaSetGuid, Replica->SetName->Guid);

    //
    // Set Name
    //
    wcscpy(ConfigRecord->ReplicaSetName, Replica->SetName->Name);

    //
    // Member Guid
    // Replication to two different directories on the same computer
    // is allowed. Hence, a replica set will have multiple configrecords
    // in the DB, one for each "member". The member guid is used for
    // uniqueness.
    //
    COPY_GUID(&ConfigRecord->ReplicaMemberGuid, Replica->MemberName->Guid);
    //
    // Member Name
    //
    MemberSize = (wcslen(Replica->MemberName->Name) + 1) * sizeof(WCHAR);
    FStatus = DBS_REALLOC_FIELD(TableCtx, ReplicaMemberNamex, MemberSize, FALSE);
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT_FS(0, "ERROR - reallocating member name.", FStatus);
        Replica->FStatus = FStatus;
    } else {
        MemberName = DBS_GET_FIELD_ADDRESS(TableCtx, ReplicaMemberNamex);
        CopyMemory(MemberName, Replica->MemberName->Name, MemberSize);
    }

    //
    // Pack other fields into the config record blob
    //
    FStatus = DbsPackIntoConfigRecordBlobs(Replica, TableCtx);
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT_FS(0, "ERROR - packing blob.", FStatus);
        Replica->FStatus = FStatus;
    }


    // Note: look for filters in per-replica set reg keys too. future.

    //
    // File filter
    //
    // For now the inclusion filter is registry only and is not saved in the config record.
    //
    FrsFree(Replica->FileInclFilterList);
    Replica->FileInclFilterList =  FrsWcsDup(RegistryFileInclFilterList);

    if (!Replica->FileFilterList) {
        Replica->FileFilterList =  FRS_DS_COMPOSE_FILTER_LIST(
                                       NULL,
                                       RegistryFileExclFilterList,
                                       DEFAULT_FILE_FILTER_LIST);
    }

    FilterSize = (wcslen(Replica->FileFilterList) + 1) * sizeof(WCHAR);
    FStatus = DBS_REALLOC_FIELD(TableCtx, FileFilterListx, FilterSize, FALSE);
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT_FS(0, "ERROR - reallocating file filter.", FStatus);
        Replica->FStatus = FStatus;
    } else {
        Filter = DBS_GET_FIELD_ADDRESS(TableCtx, FileFilterListx);
        CopyMemory(Filter, Replica->FileFilterList, FilterSize);
    }

    //
    // Directory filter
    //
    // For now the inclusion filter is registry only and is not saved in the config record.
    //
    FrsFree(Replica->DirInclFilterList);
    Replica->DirInclFilterList =  FrsWcsDup(RegistryDirInclFilterList);

    if (!Replica->DirFilterList) {
        Replica->DirFilterList =  FRS_DS_COMPOSE_FILTER_LIST(
                                      NULL,
                                      RegistryDirExclFilterList,
                                      DEFAULT_DIR_FILTER_LIST);
    }

    FilterSize = (wcslen(Replica->DirFilterList) + 1) * sizeof(WCHAR);
    FStatus = DBS_REALLOC_FIELD(TableCtx, DirFilterListx, FilterSize, FALSE);
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT_FS(0, "ERROR - reallocating dir filter.", FStatus);
        Replica->FStatus = FStatus;
    } else {
        Filter = DBS_GET_FIELD_ADDRESS(TableCtx, DirFilterListx);
        CopyMemory(Filter, Replica->DirFilterList, FilterSize);
    }

    GetSystemTimeAsFileTime(&ConfigRecord->LastDSChangeAccepted);

    if (!FRS_SUCCESS(Replica->FStatus)) {
        return Replica->FStatus;
    }

    //
    // First try to read the config entry for a replica with this name.
    // If we find it then fail with JET_errTableDuplicate.
    //
    // Only the ReplicaNumber and ReplicaMemberGuid need to be unique for
    // each replica set.  See index defs in schema.c.
    //

    jerr = JetBeginTransaction(Sesid);
    CLEANUP1_JS(0, "ERROR - JetBeginTran failed creating tables for replica %d.",
                Replica->ReplicaNumber, jerr, ERROR_RETURN_0);

    //
    // DEBUG OPTION: Fill up the volume containing the database
    //
    DBG_DBS_OUT_OF_SPACE_FILL(DBG_DBS_OUT_OF_SPACE_OP_CREATE);

    //
    // Create the initial set of tables for a replica set with ReplicaNumber.
    //
    for (i=0; i<TABLE_TYPE_MAX; i++) {

        //
        // To avoid a mutex we copy the DBTable struct to a local and init
        // the table name here instead of writing into the global struct.
        //
        CopyMemory(&TableCreate, &DBTables[i], sizeof(JET_TABLECREATE));
        TableCreate.szTableName = TableName;

        //
        // Create a unique table name by suffixing the replica number to
        // the base table name.
        //
        sprintf(TableName, "%s%05d", DBTables[i].szTableName, Replica->ReplicaNumber);

        //
        // The first set of table creates use replica number
        // DBS_TEMPLATE_TABLE_NUMBER (0) to make a set of template tables
        // can be used by subsequent creates of the same table type.
        // This ensures that the column IDs of each table of a given type
        // are the same.  Also set the grbit to FixedDDL.  This means we
        // can't add indexes or columns but the access to the table is faster
        // because jet can avoid taking some critical sections.
        // Set the TemplateTableName to the name of the Template table (0).
        //
        TableCreate.grbit = JET_bitTableCreateFixedDDL;
        TableCreate.rgcolumncreate = NULL;
        TableCreate.cColumns = 0;
        TableCreate.rgindexcreate = NULL;
        TableCreate.cIndexes = 0;

        sprintf(TemplateName, "%s%05d", DBTables[i].szTableName, DBS_TEMPLATE_TABLE_NUMBER);
        TableCreate.szTemplateTableName = TemplateName;

        jerr = DbsCreateJetTable(ThreadCtx, &TableCreate);
        CLEANUP1_JS(1, "Table %s create error:", TableName, jerr, ERROR_RETURN);

        jerr = JetCloseTable(Sesid, TableCreate.tableid);
        CLEANUP1_JS(1, "Table %s close error:", TableName, jerr, ERROR_RETURN);

    }

    //
    // Tables were created.  Now init and write a config record for this
    // replica set member.
    //

    ConfigTableName = TableCtx->pJetTableCreate->szTableName;

    //
    // Write the config record supplied in the TableCtx parameter to the
    // config table.  The table is opened as needed.
    //
    DBS_DISPLAY_RECORD_SEV(4, TableCtx, FALSE);

    jerr = DbsWriteReplicaTableRecord(ThreadCtx,
                                      FrsInitReplica->ReplicaNumber,
                                      TableCtx);
    //
    // DEBUG OPTION - Trigger an out-of-space error
    //
    DBG_DBS_OUT_OF_SPACE_TRIGGER(jerr);
    CLEANUP2_JS(0, "ERROR - DbsWriteReplicaTableRecord for table (%s), replica (%ws),",
                ConfigTableName, ConfigRecord->ReplicaSetName, jerr, ERROR_RETURN);

    //
    // Close the table, reset TableCtx Tid and Sesid.  Macro writes 1st arg.
    //
    DbsCloseTable(jerr, Sesid, TableCtx);
    CLEANUP1_JS(0, "ERROR - Table %s close:", ConfigTableName, jerr, ERROR_RETURN);

    //
    // Commit the table create and the config entry write.
    //
    jerr = JetCommitTransaction(Sesid, 0);
    CLEANUP1_JS(0, "ERROR - JetCommitTran failed creating tables for replica %d.",
                Replica->ReplicaNumber, jerr, ERROR_RETURN);

    //
    // DEBUG OPTION: Delete fill file
    //
    DBG_DBS_OUT_OF_SPACE_EMPTY(DBG_DBS_OUT_OF_SPACE_OP_CREATE);

    //
    // New set of tables added for Replica.
    //
    return FrsErrorSuccess;


//
// Delete any tables we created before the failure occurred.
//
ERROR_RETURN:

    //
    // Roll back the table creates.
    //
    jerr1 = JetRollback(Sesid, 0);
    DPRINT1_JS(0, "ERROR - JetRollback failed creating tables for replica %d.",
               Replica->ReplicaNumber, jerr1);

    //
    // DEBUG OPTION: Delete fill file
    //
    DBG_DBS_OUT_OF_SPACE_EMPTY(DBG_DBS_OUT_OF_SPACE_OP_CREATE);

    //
    // Shutdown if the database volume is full
    //
    DbsExitIfDiskFull(jerr1);
    DbsExitIfDiskFull(jerr);

ERROR_RETURN_0:

    return DbsTranslateJetError(jerr, FALSE);
}




JET_ERR
DbsDeleteReplicaTables (
    IN PTHREAD_CTX  ThreadCtx,
    IN OUT PREPLICA Replica
    )
/*++

Routine Description:

    This function deletes a set of jet tables for the given replica set.
    It gets the necessary paramters from the Replica struct
    The config record is deleted..

Arguments:

    ThreadCtx   - The thread context, provides session ID and database ID.

    Replica     - The Replica context.

Return Value:

    Status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsDeleteReplicaTables:"

    JET_ERR      jerr, jerr1;
    JET_SESID    Sesid;
    JET_DBID     Dbid;
    PTABLE_CTX   TableCtx;
    ULONG        i;
    ULONG        ReplicaNumber = Replica->ReplicaNumber;
    CHAR         TableName[JET_cbNameMost];

    PCONFIG_TABLE_RECORD ConfigRecord;

    //
    // Check if this is the init record number or the template table number.
    //
    if ((Replica->ReplicaNumber == FRS_SYSTEM_INIT_REPLICA_NUMBER) ||
        WSTR_EQ(Replica->ReplicaName->Name, NTFRS_RECORD_0)        ||
        WSTR_EQ(Replica->Root, FRS_SYSTEM_INIT_PATH)               ||
        WSTR_EQ(Replica->ReplicaName->Name, FRS_SYSTEM_INIT_RECORD) ) {
        DPRINT1(4, "ERROR: Invalid replica number: %d\n", ReplicaNumber);
        return JET_errSuccess;
    }

    Sesid = ThreadCtx->JSesid;
    Dbid  = ThreadCtx->JDbid;

    jerr = JetBeginTransaction(Sesid);
    CLEANUP1_JS(0, "ERROR - JetBeginTran failed deleting tables for replica %d.",
                   ReplicaNumber, jerr, ERROR_RETURN_0);

    //
    // DEBUG OPTION: Cause out of space errors
    //
    DBG_DBS_OUT_OF_SPACE_FILL(DBG_DBS_OUT_OF_SPACE_OP_DELETE);

    //
    // Delete set of tables for a replica set with ReplicaNumber.
    //
    for (i=0; i<TABLE_TYPE_MAX; i++) {

        //
        // Create the table name by suffixing the replica number to
        // the base table name.  Then delete the table.  The table may not be
        // found if we crashed during create or had to stop part way through
        // a delete because table was in use.
        //
        sprintf(TableName, "%s%05d", DBTables[i].szTableName, ReplicaNumber);

        DPRINT1(4, ":S: Deleting Table %s: \n", TableName);

        jerr = JetDeleteTable(Sesid, Dbid, TableName);
        if ((!JET_SUCCESS(jerr)) && (jerr != JET_errObjectNotFound)) {
            if (jerr == JET_errCannotDeleteTemplateTable) {
                DPRINT2(1, "++ Table %s delete error: %d. Ignore error.\n", TableName, jerr);
            } else {
                DPRINT1_JS(1, "++ Table %s delete error:", TableName, jerr);
            //
            // Commit where we are and stop. The replica state tells us the delete
            // has started.
            //
            goto COMMIT;
            }
        }
    }

    //
    //
    // Now delete the config record.
    //
    // Also - Need to check if replica name is in use when creating a new replica.
    //
    //        We could restrict reading and writing of the config entry to
    //        a single thread or a special class of threads so all threads
    //        don't have to open the config table.
    //        We could fill in fields of the config entry without doing the
    //        actual write here. But it's best to make it all part of one
    //        transaction.
    TableCtx = &FrsInitReplica->ConfigTable;
    ConfigRecord = (PCONFIG_TABLE_RECORD) (TableCtx->pDataRecord);

    //
    // delete the replica config record by an Index on the ReplicaNumber
    //

    jerr = DbsDeleteRecord(ThreadCtx, (PVOID) &ReplicaNumber, ReplicaNumberIndexx, TableCtx);

    //
    // DEBUG OPTION - Trigger an out-of-space error
    //
    DBG_DBS_OUT_OF_SPACE_TRIGGER(jerr);

    CLEANUP_JS(0, "++ ERROR - DbsDeleteRecord:", jerr, ERROR_RETURN);


COMMIT:
    //
    // Commit the transaction.
    //
    jerr = JetCommitTransaction(Sesid, 0);
    CLEANUP1_JS(0, "++ ERROR - JetCommitTran failed creating tables for replica %d.",
                ReplicaNumber, jerr, ERROR_RETURN);

    //
    // DEBUG OPTION: Delete fill file
    //
    DBG_DBS_OUT_OF_SPACE_EMPTY(DBG_DBS_OUT_OF_SPACE_OP_DELETE);

    return JET_errSuccess;


//
// Delete failed.
//
ERROR_RETURN:

ERROR_ROLLBACK:
    //
    // Roll back the transaction.
    //
    jerr1 = JetRollback(Sesid, 0);
    DPRINT1_JS(0, "++ ERROR - DbsDeleteReplicaTables: JetRollback failed on replica number %d.",
               ReplicaNumber, jerr1);

    //
    // DEBUG OPTION: Delete fill file
    //
    DBG_DBS_OUT_OF_SPACE_EMPTY(DBG_DBS_OUT_OF_SPACE_OP_DELETE);

    //
    // Shutdown if the database volume is full
    //
    DbsExitIfDiskFull(jerr1);
    DbsExitIfDiskFull(jerr);

ERROR_RETURN_0:

    return jerr;
}


JET_ERR
DbsOpenReplicaTables (
    IN PTHREAD_CTX  ThreadCtx,
    IN PREPLICA     Replica,
    IN PREPLICA_THREAD_CTX RtCtx
    )
/*++

Routine Description:

    This function opens a set of Jet tables for the given replia and thread.
    The Jet table handles are thread specific because transaction state is
    per-thread.  So each thread that needs to access the Jet tables for a
    given replica must first open the tables.  The replica number comes from
    the Replica struct.

Arguments:

    ThreadCtx   - The thread context, provides session ID and database ID.

    Replica     - The Replica context, provides the table list for this replica.

    RtCtx       - Store the table ids/handles for the opened tables.

Return Value:

    Status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsOpenReplicaTables:"

    JET_ERR      jerr, jerr1 = JET_errSuccess;
    JET_TABLEID  Tid;

    ULONG        i;
    NTSTATUS     Status;
    ULONG        ReplicaNumber;
    PTABLE_CTX   TableCtx;
    PJET_TABLECREATE DBJTableCreate;
    CHAR         TableName[JET_cbNameMost];
    JET_TABLEID  FrsOpenTableSaveTid;   // for FrsOpenTableMacro DEBUG


    ReplicaNumber = Replica->ReplicaNumber;

    //
    // Get the base of the array of TableCtx structs from the replica thread
    // context struct and the base of the table create structs.
    //
    TableCtx = (RtCtx)->RtCtxTables;
    DBJTableCreate = DBTables;

    DUMP_TABLE_CTX(TableCtx);

    //
    // Open the initial set of tables for the replica set.
    //
    for (i=0; i<TABLE_TYPE_MAX; i++) {

        TableCtx->pJetTableCreate = &DBTables[i];

        //
        // Open the table, if it's not already open. Check the session id for match.
        //
        jerr = DBS_OPEN_TABLE(ThreadCtx, TableCtx, ReplicaNumber, TableName, &Tid);
        CLEANUP1_JS(0, "++ ERROR - FrsOpenTable (%s) :", TableName, jerr, ERROR_RETURN);

        //
        // Initialize the JetSet/RetCol arrays and data record buffer addresses
        // to read and write the fields of the ConfigTable records into ConfigRecord.
        //
        DbsSetJetColSize(TableCtx);
        DbsSetJetColAddr(TableCtx);

        //
        // Allocate the storage for the variable length fields in the record and
        // update the JetSet/RetCol arrays appropriately.
        //
        Status = DbsAllocRecordStorage(TableCtx);
        CLEANUP_NT(0, "ERROR - DbsAllocRecordStorage failed to alloc buffers.",
                   Status, ERROR_RETURN);

        TableCtx += 1;
    }

    return JET_errSuccess;

//
// Close any tables that we opened.
//
ERROR_RETURN:

    jerr1 = jerr;
    jerr = DbsCloseReplicaTables(ThreadCtx, Replica, RtCtx, TRUE);
    DPRINT_JS(0, "++ ERROR - DbsCloseReplicaTables:", jerr);

    return jerr1;

}



JET_ERR
DbsCloseReplicaTables (
    IN PTHREAD_CTX  ThreadCtx,
    IN PREPLICA Replica,
    IN PREPLICA_THREAD_CTX RtCtx,
    IN BOOL SessionErrorCheck
    )
/*++

Routine Description:

    This function closes a set of Replica tables for the given ReplicaThreadCtx.

Arguments:

    ThreadCtx   - The thread context, provides session ID and database ID.
    Replica     - Ptr to Replica struct that has list head for RtCtx.
    RtCtx       - The table ids/handles for the open tables.
    SessionErrorCheck - True means generate an error message if the Session ID
                        in the ThreadCtx does not match the Session Id used
                        to open a given table in the Replica-Thread ctx.
                        False means keep quiet.
Return Value:

    Jet Status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsCloseReplicaTables:"

    JET_ERR      jerr, jerr1 = JET_errSuccess;
    JET_SESID    Sesid;
    ULONG        i;
    PTABLE_CTX   TableCtx;
    PCHAR        TableName;

    Sesid = ThreadCtx->JSesid;

    //
    // Get the base of the array of TableCtx structs from the replica thread
    // context struct.
    //
    TableCtx = (RtCtx)->RtCtxTables;

    //
    // Close any open tables in this replica thread context.
    //
    for (i=0; i<TABLE_TYPE_MAX; i++, TableCtx++) {

        //
        //  Check for table not open or not initialized.
        //
        if (!IS_TABLE_OPEN(TableCtx) ||
            !IS_REPLICA_TABLE(TableCtx->TableType)){
            continue;
        }

        //
        // Table is open.  Check the thread session ID for a match with the
        // session id used when the table was opened.
        //
        TableName = TableCtx->pJetTableCreate->szTableName;
        if (Sesid != TableCtx->Sesid) {
            if (SessionErrorCheck) {
                DPRINT3(0, "++ ERROR - DbsCloseReplicaTables (%s) bad sesid : %d should be %d\n",
                        TableName, Sesid, TableCtx->Sesid);
                jerr1 = JET_errInvalidSesid;
            }

        } else {
            //
            // Close the table, reset TableCtx Tid and Sesid.  Macro writes 1st arg.
            //
            DbsCloseTable(jerr1, Sesid, TableCtx);
            DPRINT1_JS(0, "++ ERROR - Table %s close :", TableName, jerr1);
        }
    }

    return jerr1;
}



FRS_ERROR_CODE
DbsCloseSessionReplicaTables (
    IN PTHREAD_CTX  ThreadCtx,
    IN OUT PREPLICA Replica
    )
/*++
Routine Description:

    Walk the Replica Thread Context list and close all tables that were opened
    by this session using the session ID in the ThreadCtx.  If the
    ReplicaCtxListHead ends up empty we then close the Replica->ConfigTable.

Arguments:

    ThreadCtx   - The thread context, provides session ID and database ID.
    Replica     - The Replica context, provides the table list for this replica.

Return Value:

    FRS Error Status code.
--*/
{
#undef DEBSUB
#define DEBSUB "DbsCloseSessionReplicaTables:"

    JET_ERR      jerr = JET_errSuccess;
    JET_SESID    Sesid;
    ULONG        i;
    FRS_ERROR_CODE FStatus, FStatus1;
    PTABLE_CTX   TableCtx;
    PCHAR        TableName;
    BOOL         UpdateConfig;
    PCONFIG_TABLE_RECORD  ConfigRecord;
    PVOLUME_MONITOR_ENTRY pVme;

    FStatus = FrsErrorSuccess;

    //
    // Shut down outbound log processing
    //
    FStatus1 = OutLogSubmit(Replica, NULL, CMD_OUTLOG_REMOVE_REPLICA);
    DPRINT2_FS(0, "ERROR removing replica %ws\\%ws :",
               Replica->ReplicaName->Name, Replica->MemberName->Name, FStatus1);
    FStatus = FRS_SUCCESS(FStatus) ? FStatus1 : FStatus;

    Sesid = ThreadCtx->JSesid;
    ForEachListEntry( &Replica->ReplicaCtxListHead, REPLICA_THREAD_CTX, ReplicaCtxList,
        //
        // loop iterator pE is type PREPLICA_THREAD_CTX.  Don't generate an
        // error message if the session ID on a table doesn't match ours.
        //
        jerr = DbsFreeRtCtx(ThreadCtx, Replica, pE, FALSE);
    );

    ConfigRecord = Replica->ConfigTable.pDataRecord;
    FRS_ASSERT(ConfigRecord != NULL);

    //
    // If the replica set membership has been deleted then we only update
    // one more time.
    //
    UpdateConfig = (IS_TIME_ZERO(Replica->MembershipExpires) ||
                   (ConfigRecord->LastShutdown < (Replica->MembershipExpires -
                                                  ReplicaTombstoneInFileTime)));
    //
    // If for some reason journaling never started for this Replica the ptr
    // to the volume Monitor entry is still NULL.
    //
    pVme = Replica->pVme;
    if ((pVme != NULL) && UpdateConfig) {
        //
        // Save the restart point for the Journal USN and the FRS Volume VSN.
        //
        FStatus1 = DbsReplicaSaveMark(ThreadCtx, Replica, pVme);
        DPRINT1_FS(0, "ERROR - DbsReplicaSaveMark on %ws.",
                   Replica->ReplicaName->Name, FStatus1);
        FStatus = FRS_SUCCESS(FStatus) ? FStatus1 : FStatus;

    } else {
        JrnlSetReplicaState(Replica, REPLICA_STATE_STOPPED);
    }

    //
    // If all Replica-Thread contexts are closed, update last shutdown time
    // and service state and close this Replica's config open.
    //
    if (FrsRtlCountList(&Replica->ReplicaCtxListHead) == 0) {
        TableCtx = &Replica->ConfigTable;

        if (ConfigRecord->ServiceState != CNF_SERVICE_STATE_CREATING) {
            //
            // If we never got out of the creating state then leave it marked
            // as creating.  This can happen when a new replica set is
            // created but the service is shutdown before it was ever
            // started up.  The result in this case is a bogus value for
            // the journal restart USN.
            //
            SET_SERVICE_STATE(Replica, CNF_SERVICE_STATE_CLEAN_SHUTDOWN);
        }

        if (UpdateConfig) {
            //
            // Update time and state fields in the config record.
            //
            GetSystemTimeAsFileTime((PFILETIME)&ConfigRecord->LastShutdown);
            FStatus1 = DbsUpdateConfigTableFields(ThreadCtx,
                                                  Replica,
                                                  CnfCloseFieldList,
                                                  CnfCloseFieldCount);
            FStatus = FRS_SUCCESS(FStatus) ? FStatus1 : FStatus;
        }

        //
        // Close the table, reset the TableCtx Tid and Sesid.
        // DbsCloseTable is a Macro, writes 1st arg.
        //
        TableName = TableCtx->pJetTableCreate->szTableName;
        DbsCloseTable(jerr, Sesid, TableCtx);
        FStatus1 = DbsTranslateJetError(jerr, FALSE);
        DPRINT1_FS(0, "ERROR - Table %s close :", TableName, FStatus1);
        FStatus = FRS_SUCCESS(FStatus) ? FStatus1 : FStatus;

    } else {
        DPRINT1(0, "WARNING - Not all RtCtx's closed on %ws.  Config record still open.\n",
                Replica->ReplicaName->Name);
        FStatus1 = FrsErrorSessionNotClosed;
        FStatus = FRS_SUCCESS(FStatus) ? FStatus1 : FStatus;
    }

    //
    // Close the preinstall directory.
    //
    if (FRS_SUCCESS(FStatus) &&
        HANDLE_IS_VALID(Replica->PreInstallHandle)) {
        FRS_CLOSE(Replica->PreInstallHandle);
    }

    Replica->FStatus = FStatus;     // Note: not thread safe.

    return FStatus;
}



ULONG
DbsInitOneReplicaSet(
    PREPLICA Replica
    )
/*++

Routine Description:

    This routine inits a new replica set and starts replication.
    Initialize the replica tables with the initial directory contents
    pause the journal, update the filter table, and restarts the journal.

Arguments:

    Replica -- ptr to an initialized Replica struct.

Thread Return Value:

    An FrsError status.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsInitOneReplicaSet:"

    ULONG                 WStatus;
    ULONG                 FStatus;
    PCOMMAND_PACKET       CmdPkt;
    PCONFIG_TABLE_RECORD  ConfigRecord;
    PVOLUME_MONITOR_ENTRY pVme;
    ULONG                 NewServiceState = CNF_SERVICE_STATE_RUNNING;

    //
    // Replica set init is serialized because it involves work by both the
    // the Journal monitor thread and the Database service thread. The problem
    // arises when more than one thread calls this function (e.g. at startup)
    // because the first one to call can be returning here to unpause the
    // journal while the second thread has already paused the journal as
    // part of the CMD_JOURNAL_INIT_ONE_RS request.  One solution is to
    // create a count of pause requests active on each volume and make
    // each unpause request wait on an event until the count goes to zero.
    // Need to ensure that pause and unpause requests are balanced and that
    // any waiters are released if the journal enters the stopped or error
    // states.
    //
    // This is a performance issue so for now we just make init single threaded.
    //
    // Perf: Add pause count for multi-thread replica set init.
    //

    ACQUIRE_DBS_INIT_LOCK;

    //
    // Initialize the replica tables with the initial directory contents
    // pause the journal, update the filter table.  Journal is left paused.
    // The command is submitted to the Journal which does the first part.  It
    // then moves on to the the DB server using
    // CMD_LOAD_ONE_REPLICA_FILE_TREE to do the second part which may involve
    // creating the initial IDTable contents.  Control then moves to
    // JrnlPrepareService2 which uses the IDTable contents to init the
    // journal filter tables and parent FID table.  Finally it inserts the
    // created replica struct onto the pVme->ReplicaListHead and then
    // completes the command.  When the sync call returns, the packet has
    // been transformed into a DB request packet.
    //

    CmdPkt = FrsAllocCommand(&JournalProcessQueue, CMD_JOURNAL_INIT_ONE_RS);
    JrReplica(CmdPkt) = Replica;
    JrpVme(CmdPkt) = NULL;


    //
    // Don't free the packet when the command completes.
    //
    FrsSetCompletionRoutine(CmdPkt, FrsCompleteKeepPkt, NULL);

    //
    // SUBMIT Cmd.
    // Wait until command request is completed.  But if we timeout we can't
    // just delete the cmd packet because it may be on a list somewhere.
    //
    WStatus = FrsSubmitCommandAndWait(CmdPkt, FALSE, INFINITE);

    //
    // Check the return status.  Note: The packet is now a DB service packet
    // if it made it past the Journal init phase.
    //
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT_WS(1, "CMD_JOURNAL_INIT_ONE_RS failed", WStatus);

        if (WStatus == ERROR_JOURNAL_ENTRY_DELETED) {
            JrnlSetReplicaState(Replica, REPLICA_STATE_JRNL_WRAP_ERROR);
            FStatus = FrsErrorJournalWrapError;
        } else {
            FStatus = Replica->FStatus;
            if (FRS_SUCCESS(FStatus)) {
                FStatus = FrsErrorJournalStartFailed;
            }
            JrnlSetReplicaState(Replica, REPLICA_STATE_ERROR);
        }

        FrsFreeCommand(CmdPkt, NULL);
        CmdPkt = NULL;
        goto RESUME_JOURNAL;
    }

    FStatus = CmdPkt->Parameters.DbsRequest.FStatus;
    FrsFreeCommand(CmdPkt, NULL);
    CmdPkt = NULL;

    if (!FRS_SUCCESS(FStatus)) {
        DPRINT_FS(0, "ERROR initing journal:", FStatus);
        //
        // Put replica on the fault list.
        //
        JrnlSetReplicaState(Replica, REPLICA_STATE_ERROR);
        goto RESUME_JOURNAL;
    }

    DPRINT(4, ":S: Journal Initialized success.\n");

    pVme = Replica->pVme;

    //
    // Update the save point for the VSN and USN for this replica set.
    //
    DPRINT3(4, ":S: VSN Save Triggered: NextVsn: %08x %08x  "
                                   "LastUsnSaved: %08x %08x  "
                                   "CurrUsnDone: %08x %08x\n",
            PRINTQUAD(pVme->FrsVsn),
            PRINTQUAD(pVme->LastUsnSavePoint),
            PRINTQUAD(pVme->CurrentUsnRecordDone));

    FStatus = DbsRequestSaveMark(pVme, TRUE);
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT1_FS(0, "++ ERROR updating VSN, USN save point for %ws.",
                   Replica->ReplicaName->Name, FStatus);
        //
        // If we can't mark our progress then we can't start.
        // Put replica on the fault list.
        //
        JrnlSetReplicaState(Replica, REPLICA_STATE_ERROR);
        goto RESUME_JOURNAL;
    }

    //
    // As the final step before we can restart the journal for this replica set
    // we need to first re-submit any local change orders that are in the
    // inbound log to the change order process queue for the volume.
    // Allocate command packet and submit to the CO Retry thread
    // (ChgOrdRetryCS).  Wait until the command is completed.
    //
    // This scan has to be done before we start the journal otherwise we end
    // up resubmitting new local change orders a second time.
    //
    DPRINT(4, ":S: Scanning for pending local COs to retry.\n");
    ChgOrdRetrySubmit(Replica, NULL, FCN_CORETRY_LOCAL_ONLY, TRUE);

    //
    // If replay USN is not valid then pickup at JrnlReadPoint (where we left off).
    // Otherwise set the replay point to the min of replay and this replica's
    // LastUsnRecordProcessed.
    //
    if (!pVme->ReplayUsnValid) {
        pVme->ReplayUsn = LOAD_JOURNAL_PROGRESS(pVme, pVme->JrnlReadPoint);
        pVme->ReplayUsnValid = TRUE;
    }

    DPRINT1(4, ":S: ReplayUsn was:    %08x %08x\n", PRINTQUAD(pVme->ReplayUsn));

    pVme->ReplayUsn = min(pVme->ReplayUsn, Replica->LastUsnRecordProcessed);

    DPRINT1(4, ":S: ReplayUsn is now: %08x %08x\n", PRINTQUAD(pVme->ReplayUsn));

RESUME_JOURNAL:

    //
    // If this init failed and the journal had been paused then
    // reStart the journal where it left off.  Set the state to
    // JRNL_STATE_STARTING before calling JrnlUnPauseVolume.
    //
    if (!FRS_SUCCESS(FStatus)) {

        NewServiceState = CNF_SERVICE_STATE_ERROR;

        pVme = Replica->pVme;

        if ((pVme == NULL) || (pVme->JournalState != JRNL_STATE_PAUSED)) {
            goto RETURN;
        }

        DPRINT1(4, ":S: ReplayUsn was: %08x %08x\n", PRINTQUAD(pVme->ReplayUsn));
        pVme->ReplayUsn = LOAD_JOURNAL_PROGRESS(pVme, pVme->JrnlReadPoint);
        pVme->ReplayUsnValid = TRUE;
        RESET_JOURNAL_PROGRESS(pVme);
        SET_JOURNAL_AND_REPLICA_STATE(pVme, JRNL_STATE_STARTING);
    }

    DPRINT1(4, ":S: ReplayUsn now: %08x %08x\n", PRINTQUAD(pVme->ReplayUsn));

    //
    // Crank up the first read on the journal to get it going.
    //
    WStatus = JrnlUnPauseVolume(Replica->pVme, NULL, FALSE);

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT_WS(0, "Error from JrnlUnPauseVolume", WStatus);
        FStatus = FrsErrorJournalStartFailed;
    } else {
        DPRINT(5, ":S: JrnlUnPauseVolume success.\n");
        Replica->IsJournaling = TRUE;
    }


RETURN:

    //
    // If all went OK, this replica set is running.
    //
    SET_SERVICE_STATE(Replica, NewServiceState);

    //
    // If LastShutDown is zero save the current time so if we crash after
    // this point we won't think that this replica set has never started
    // but the service state in the config record is set to RUNNING.
    //
    if (NewServiceState == CNF_SERVICE_STATE_RUNNING) {

        //
        // Need to do this in the DBService thread since this is called by the
        // Replica command server and it has no DB thread context.
        //
        ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);
        if (ConfigRecord->LastShutdown == 0) {

            GetSystemTimeAsFileTime((PFILETIME)&ConfigRecord->LastShutdown);

            FStatus = DbsRequestReplicaServiceStateSave(Replica, TRUE);
            DPRINT_FS(0,"++ ERROR: DbsUpdateConfigTableFields error.", FStatus);
        }
    }

    RELEASE_DBS_INIT_LOCK;

    return FStatus;
}



ULONG
DbsShutdownSingleReplica(
    IN PTHREAD_CTX  ThreadCtx,
    IN PREPLICA     Replica
    )
/*++

Routine Description:

    Close the open tables for this replica set and update the config record.
    Set Replica service state to Stopped.  Put the Replica struct on the
    stopped list.

    ASSUMES: That this replica's journal is paused so we can write out
             the current progress point.

Arguments:

    ThreadCtx   - The thread context, provides session ID and database ID.

    Replica     - The Replica context, provides the table list for this replica.

Return Value:

    FrsError status.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsShutdownSingleReplica:"

    ULONG                 FStatus;

    FStatus = DbsCloseSessionReplicaTables(ThreadCtx, Replica);
    DPRINT1_FS(0,"++ ERROR - DbsCloseSessionReplicaTables failed on Replica %ws",
            Replica->ReplicaName->Name, FStatus);

    if (FStatus == FrsErrorSessionNotClosed) {
        JrnlSetReplicaState(Replica, REPLICA_STATE_STOPPED);
    } else

    if (!FRS_SUCCESS(FStatus)) {
        JrnlSetReplicaState(Replica, REPLICA_STATE_ERROR);

    } else {
        DPRINT1(4,"++ DbsCloseSessionReplicaTables RtCtx complete on %ws\n",
                Replica->ReplicaName->Name);
        JrnlSetReplicaState(Replica, REPLICA_STATE_STOPPED);
    }


    DPRINT(4, "\n");
    DPRINT1(4, "++ ==== start of Active INLOG Retry table dump for %ws ===========\n",
            Replica->ReplicaName->Name);
    DPRINT(4, "\n");

    QHashEnumerateTable(Replica->ActiveInlogRetryTable, QHashDump, NULL);
    DPRINT(4, "\n");
    DPRINT(4, "++ ==== End of Active INLOG Retry table dump ===========\n");
    DPRINT(4, "\n");


#if 0
    // Note: Perf: Can't do this until we know that all inprocess Local and
    // Remote COs are done.
    //
    // Release the memory for the Name Conflict table.
    //
    Replica->NameConflictTable = FrsFreeType(Replica->NameConflictTable);
    Replica->ActiveInlogRetryTable  = FrsFreeType(Replica->ActiveInlogRetryTable);
#endif

    return FStatus;

}



JET_ERR
DbsOpenTable0(
    IN  PTHREAD_CTX   ThreadCtx,
    IN  PTABLE_CTX    TableCtx,
    IN  ULONG         ReplicaNumber,
    OUT PCHAR         TableName,
    OUT JET_TABLEID  *Tid
    )
/*++

Routine Description:

    This function opens a jet table and inits the TableCtx with the table id,
    session id and replica number.  It returns the table name and the Tid.
    If the table is already open it checks that the Sesid from the TableCtx
    Matches the current session ID in the Thread context.  If the columnId
    fields in the JET_COLUMNCREATE structure are not defined then we get them
    from Jet.

    Macro Ref:  DBS_OPEN_TABLE

Arguments:

    ThreadCtx     -- ptr to the thread context.
    TableCtx      -- ptr to the table context.
    ReplicaNumber -- The ID number of the replica whose table is being opened.
    TableName     -- The full table name is returned.
    Tid           -- The Table ID is returned.

Return Value:

    Tid is returned as JET_tableidNil if the open fails.
    TableName is always returned (BaseTableName || ReplicaNumber)

    Jet status code as function return.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsOpenTable0:"

    JET_ERR           jerr, jerr1;
    JET_SESID         Sesid;
    JET_DBID          Dbid;
    PJET_TABLECREATE  JTableCreate;
    PJET_COLUMNCREATE JColDesc;
    JET_COLUMNDEF     JColDef;
    ULONG             NumberColumns;
    ULONG             i;
    PCHAR             BaseTableName;
    PCHAR             TName;
    PREPLICA          Replica;


    Dbid           = ThreadCtx->JDbid;
    Sesid          = ThreadCtx->JSesid;
    JTableCreate   = TableCtx->pJetTableCreate;
    BaseTableName  = JTableCreate->szTableName;


    // DUMP_TABLE_CTX(TableCtx);
    //
    // Construct the table name by suffixing with a 5 digit number.
    // (unless it's a single table).
    //
    if (BooleanFlagOn(TableCtx->PropertyFlags, FRS_TPF_SINGLE)) {
        TName = BaseTableName;
        strcpy(TableName, BaseTableName);
    } else {
        TName = TableName;
        sprintf(TableName, "%s%05d", BaseTableName, ReplicaNumber);
    }

    //
    // Check for Open Table and open it if necc.
    //
    if (!IS_TABLE_OPEN(TableCtx)) {

        //
        // Open the table.
        //
        jerr = JetOpenTable(Sesid, Dbid, TName, NULL, 0, 0, Tid);

        if ((!JET_SUCCESS(jerr)) && (jerr != JET_wrnTableEmpty)) {
            DPRINT1_JS(0, "++ ERROR - JetOpenTable (%s) :", TName, jerr);
            *Tid = JET_tableidNil;
            return jerr;
        }

        //
        // Update the table context.
        //
        TableCtx->Tid = *Tid;
        TableCtx->ReplicaNumber = ReplicaNumber;
        TableCtx->Sesid = Sesid;
    } else {
        //
        // Table is open.  Check the thread session ID for a match with the
        // session id used when the table was opened.
        //
        if (Sesid != TableCtx->Sesid) {
            DPRINT3(0, "++ ERROR - FrsOpenTable (%s) bad sesid : %08x should be %08x\n",
                    TName, Sesid, TableCtx->Sesid);

            *Tid = JET_tableidNil;
            return JET_errInvalidSesid;

        } else {
            //
            // Table is open and the session id matches.  Return TableCtx->Tid.
            //
            *Tid = TableCtx->Tid;

            //
            // Table number better match.
            //
            if (TableCtx->ReplicaNumber != ReplicaNumber) {
                DPRINT2(0, "++ ERROR - TableCtx is open for Replica number: %d, "
                       "  Now reusing it for %s without first closing\n",
                       ReplicaNumber, TableName);

                Replica = RcsFindReplicaByNumber(ReplicaNumber);
                if (Replica != NULL) {
                    FRS_PRINT_TYPE(0, Replica);
                } else {
                    DPRINT1(0, "++ SURPRISE - ReplicaNumber %d not found in lookup table\n", ReplicaNumber);
                }

                DUMP_TABLE_CTX(TableCtx);
                DBS_DISPLAY_RECORD_SEV(0, TableCtx, TRUE);
                FRS_ASSERT(!"DbsOpenReplicaTable: Open TableCtx is reused without close.");
            }
        }
    }

    //
    // Now check that the ColumnIds are defined in the JET_COLUMNCREATE struct.
    //

    JColDesc = JTableCreate->rgcolumncreate;

    if (JColDesc->columnid != JET_COLUMN_ID_NIL) {
        return JET_errSuccess;
    }
    NumberColumns  = JTableCreate->cColumns;

    for (i=0; i<NumberColumns; i++) {
        jerr = JetGetColumnInfo(Sesid,
                                Dbid,
                                TName,
                                JColDesc->szColumnName,
                                &JColDef,
                                sizeof(JColDef),
                                0);

        if (!JET_SUCCESS(jerr)) {
            DPRINT(0, "++ ERROR - Failed to get columnID. Can't open table.\n");
            DPRINT(0, "++ ERROR - Either old DB or someone changed the column name.\n");
            DPRINT2_JS(0, "++ ERROR - JetGetColumnInfo(%s) col(%s) : ",
                       JTableCreate->szTableName, JColDesc->szColumnName, jerr);

            DbsCloseTable(jerr1, Sesid, TableCtx);
            DPRINT_JS(0,"++ ERROR - JetCloseTable failed:", jerr1);

            *Tid = JET_tableidNil;
            return jerr;
        }


        JColDesc->columnid = JColDef.columnid;
        JColDesc += 1;
    }

    return  JET_errSuccess;
}



JET_ERR
DbsCreateJetTable (
    IN PTHREAD_CTX   ThreadCtx,
    IN PJET_TABLECREATE   JTableCreate
    )
/*++

Routine Description:

    This function creates a jet table with the columns and indexes.
    It checks the error returns.  It takes a JET_TABLECREATE
    struct which describes each column of the table and the indexes.  It returns
    the table ID and the column ID in the structure.

    If we fail to create all the columns or the indexes then the create table
    fails and the caller will cleanup by calling rollback.

Arguments:

    ThreadCtx   - The thread context, provides session ID and database ID.

    JTableCreate - The table descriptor struct.

Return Value:

    Jet status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsCreateJetTable:"

    JET_ERR    jerr;
    JET_SESID  Sesid;
    JET_DBID   Dbid;
    ULONG      j;
    ULONG              ColCount;
    JET_COLUMNCREATE  *ColList;
    ULONG              IndexCount;
    JET_INDEXCREATE   *IndexList;


    Sesid          = ThreadCtx->JSesid;
    Dbid           = ThreadCtx->JDbid;

    //
    // Call Jet to create the table with associated columns and indexes.
    //
    jerr = JetCreateTableColumnIndex(Sesid, Dbid, JTableCreate);
    CLEANUP1_JS(0, "ERROR - JetCreateTableColumnIndex(%s) :",
                JTableCreate->szTableName, jerr, RETURN);

    //
    // Make sure everything got created.
    //
    if (JTableCreate->cCreated == 0) {
        //
        // Error while creating the table.
        //
        jerr = JET_errNotInitialized;
        CLEANUP1_JS(0, "ERROR - JetCreateTableColumnIndex(%s) cCre == 0",
                    JTableCreate->szTableName, jerr, RETURN);

    } else if (JTableCreate->cCreated < (JTableCreate->cColumns+1)) {
        //
        // Error while creating the columns.
        // Check the error returns on each of the columns.
        //
        ColList = JTableCreate->rgcolumncreate;
        ColCount = JTableCreate->cColumns;
        for (j=0; j<ColCount; j++) {
            jerr = ColList[j].err;
            CLEANUP2_JS(0, "ERROR - JetCreateTableColumnIndex(%s) col(%s) :",
                       JTableCreate->szTableName, ColList[j].szColumnName, jerr, RETURN);
        }
        //
        // Even if no error above we still didn't create all the columns.
        //
        jerr = JET_errNotInitialized;
        CLEANUP2_JS(0, "ERROR - JetCreateTableColumnIndex(%s) col(%s) cCre < col count:",
                    JTableCreate->szTableName,
                    ColList[JTableCreate->cCreated-1].szColumnName, jerr, RETURN);

    } else if (JTableCreate->cIndexes &&
               JTableCreate->cCreated == (JTableCreate->cColumns+1)) {
        //
        // Error while creating the indexes
        //
        jerr = JET_errNotInitialized;
        CLEANUP1_JS(0, "ERROR - JetCreateTableColumnIndex(%s) :",
                    JTableCreate->szTableName, jerr, RETURN);

    } else if (JTableCreate->cCreated <
              (JTableCreate->cColumns + JTableCreate->cIndexes + 1)) {
        //
        // Not all indexes were created.  This test should never occur
        // because jet should return JET_wrnCreateIndexFailed instead.
        // Check the error returns on each of the index creates.
        //
        IndexList = JTableCreate->rgindexcreate;
        IndexCount = JTableCreate->cIndexes;
        for (j=0; j<IndexCount; j++) {
            jerr = IndexList[j].err;
            CLEANUP2_JS(0, "ERROR - JetCreateTableColumnIndex(%s) index(%s) :",
                        JTableCreate->szTableName, IndexList[j].szIndexName, jerr, RETURN);
        }

        //
        // Even if no error above we still didn't create all the indexes.
        //
        jerr = JET_errNotInitialized;
        CLEANUP2_JS(0, "ERROR - JetCreateTableColumnIndex(%s) Index(%s) cre fail :",
                JTableCreate->szTableName,
                IndexList[JTableCreate->cCreated - (1 + JTableCreate->cColumns)].szIndexName,
                jerr, RETURN);
    }

    //
    // Apparently no error occurred.
    // But check the column and index error returns just to be sure.
    // Check the error returns on each of the columns.
    //
    ColList = JTableCreate->rgcolumncreate;
    ColCount = JTableCreate->cColumns;
    for (j=0; j<ColCount; j++) {
        jerr = ColList[j].err;
        CLEANUP2_JS(0, "ERROR - JetCreateTableColumnIndex(%s) col(%s) :",
                    JTableCreate->szTableName, ColList[j].szColumnName, jerr, RETURN);
    }

    //
    // Check the error returns on each of the index creates.
    //
    IndexList = JTableCreate->rgindexcreate;
    IndexCount = JTableCreate->cIndexes;
    for (j=0; j<IndexCount; j++) {
        jerr = IndexList[j].err;
        CLEANUP2_JS(0, "ERROR - JetCreateTableColumnIndex(%s) index(%s) :",
                    JTableCreate->szTableName, IndexList[j].szIndexName, jerr, RETURN);
    }

RETURN:
    return jerr;
}



ULONG
DbsTableRead(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx
    )
/*++

Routine Description:

    This routine reads a record from the open table specified by the table
    ctx.  It assumes the TableCtx storage is initialized and has been positioned
    to the desired record.

Arguments:

    ThreadCtx - A thread context for accessing Jet.
    TableCtx - A ptr to the Table context of the open table to enumerate.

Thread Return Value:

    Frs error status.

--*/

{
#undef DEBSUB
#define DEBSUB "DbsTableRead:"

    JET_ERR              jerr, jerr1;
    ULONG                FStatus = FrsErrorSuccess;
    JET_SESID            Sesid;
    PJET_TABLECREATE     JTableCreate;
    PJET_RETRIEVECOLUMN  JRetColumn;
    PJET_COLUMNCREATE    JColDesc;
    JET_TABLEID          Tid;
    ULONG                NumberColumns;
    ULONG                i;
    PRECORD_FIELDS       FieldInfo;

    //
    // Point to the table create struct for column info and the
    // pointer to the record fields struct.
    //
    JTableCreate = TableCtx->pJetTableCreate;
    FieldInfo    = TableCtx->pRecordFields + 1;   // jump over elt 0

    Sesid          = ThreadCtx->JSesid;

    JRetColumn     = TableCtx->pJetRetCol;
    Tid            = TableCtx->Tid;

    NumberColumns  = JTableCreate->cColumns;
    JColDesc       = JTableCreate->rgcolumncreate;


#if 0
    //
    // Debug loop to retrieve columns one by one.
    //
    jerr = JET_errSuccess;
    for (i=0; i<NumberColumns; i++) {

        jerr1 = JetRetrieveColumn (Sesid,
                                   Tid,
                                   JRetColumn[i].columnid,
                                   JRetColumn[i].pvData,
                                   JRetColumn[i].cbData,
                                   &JRetColumn[i].cbActual,
                                   0,
                                   NULL);

        JRetColumn[i].err = jerr1;

        //DPRINT6(0, "JetRetrieveColumn(%2d): status %d, Sesid %08x, Tid %08x, Colid %5d, pvData %08x, ",
        //        i, jerr1, Sesid, Tid, JRetColumn[i].columnid, JRetColumn[i].pvData);
        //printf("cbData %5d, CbActual %5d\n", JRetColumn[i].cbData, JRetColumn[i].cbActual);

        DPRINT2_JS(0, "JetRetrieveColumn error on table (%s) for field (%s) :",
                   TableName, JTableCreate->rgcolumncreate[i].szColumnName, jerr1);
        jerr = JET_SUCCESS(jerr) ? jerr1 : jerr;
    }
    FStatus = DbsTranslateJetError(jerr, FALSE);
#endif


    jerr = JetRetrieveColumns(Sesid, Tid, JRetColumn, NumberColumns);

    if (!JET_SUCCESS(jerr)) {
        DPRINT1_JS(0, "JetRetrieveColumns on (%s) :", JTableCreate->szTableName, jerr);
        DBS_DISPLAY_RECORD_SEV(5, TableCtx, TRUE);

        if (jerr == JET_errRecordDeleted) {
            DPRINT1(0, "ERROR - Table (%s) Record is deleted\n", JTableCreate->szTableName);
            FStatus = DbsTranslateJetError(jerr, FALSE);
        } else {
            //
            // Try again.  Maybe we had some buffer too small problems.
            //
            jerr = DbsCheckSetRetrieveErrors(TableCtx);

            if (!JET_SUCCESS(jerr)) {
                DPRINT1_JS(0, "CheckRetrieveColumns on (%s) :", JTableCreate->szTableName, jerr);
                FStatus = DbsTranslateJetError(jerr, FALSE);
                DBS_DISPLAY_RECORD_SEV(1, TableCtx, TRUE);
            }
        }
    } else {
        //
        // need to scan the error codes for warnings like JET_wrnColumnNull.
        // JetRetrieveColumns() above doesn't return this status.
        //
        for (i=0; i<NumberColumns; i++) {

            //
            // Skip spare fields.
            //
            if (IsSpareField(FieldInfo[i].DataType)) {
                continue;
            }

            //
            // Null column is not an error but if it is for a fixed sized
            // buffer with a variable length field then zero the buffer.
            //
            if (JRetColumn[i].err == JET_wrnColumnNull) {
                if ((IsFixedSzBufferField(FieldInfo[i].DataType)) &&
                    (JColDesc[i].coltyp == JET_coltypLongBinary)) {

                    DPRINT1(5, "++ Null jet data column (%s) for fixed size buffer, zeroing\n",
                            JColDesc[i].szColumnName);

                    ZeroMemory(JRetColumn[i].pvData, FieldInfo[i].Size);
                }
            } else {
                //
                // Some other type of retrieve error.  Complain.
                //
                jerr = JRetColumn[i].err;
                DPRINT1_JS(5, "++ Jet retrieve error for column %s :",
                          JColDesc[i].szColumnName, jerr);
            }
        }
    }

    return FStatus;
}


JET_ERR
DbsMakeKey(
    IN JET_SESID    Sesid,
    IN JET_TABLEID  Tid,
    IN PCHAR        IndexName,
    IN PVOID       *KeyValueArray)
{
/*++

Routine Description:

    Decode the Index name and pass the value of each key segment to
    JetMakeKey.

    Assumes:  The caller has opened the table and called JetSetCurrentIndex.

Arguments:

    Sesid  -- A jet session ID.
    Tid    -- The table ID for this table.
    IndexName -- The index name string to decode for this index.
    KeyValueArray - Each entry in the array is a pointer to the key value for
                    the respective key segment.

Return Value:

    Jet error status.

--*/
#undef DEBSUB
#define DEBSUB "DbsMakeKey:"

    JET_ERR      jerr;
    ULONG        i = 0;
    ULONG        NumKeys = 1;
    ULONG        KeyLength;
    PVOID        KeyValue;
    CHAR         KeyLengthCode;
    CHAR         GuidStr[GUID_CHAR_LEN];
    PCHAR        Format;
    JET_GRBIT    KeyFlags = JET_bitNewKey;
    BOOL         MultiKeyLookup = FALSE;

#define DMK_SEV 4

    //
    // If the first character of the Index Name is a digit then this index is
    // composed of n keys.  The following n characters tell us how to compute
    // the keylength for each component.  E.G. a 2 key index on a Guid and a
    // Long binary would have a name prefix of "2GL...".
    // If the first character is not a digit then this is a single key index
    // and the first character is the key length code as follows:
    //
    //  L: Long binary     length is 4 bytes
    //  Q: Quad binary     length is 8 bytes
    //  G: 16 byte GUID    length is 16 bytes
    //  W: Wide Char       length is 2 * wcslen
    //  C: Narrow Char     length is strlen
    //
    KeyLengthCode = IndexName[i];
    MultiKeyLookup = (KeyLengthCode > '0') && (KeyLengthCode <= '9');

    if (MultiKeyLookup) {
        NumKeys = KeyLengthCode - '0';
        KeyLengthCode = IndexName[++i];
        DPRINT2(DMK_SEV, "++ Multi-valued key: %s, %d\n", IndexName, NumKeys);
    }

    while (NumKeys-- > 0) {

        KeyValue = *KeyValueArray;
        KeyValueArray += 1;
        //
        // Calculate the key length.
        //
               if (KeyLengthCode == 'L') {KeyLength = 4;
        } else if (KeyLengthCode == 'Q') {KeyLength = 8;
        } else if (KeyLengthCode == 'G') {KeyLength = 16;
        } else if (KeyLengthCode == 'C') {KeyLength = strlen((PCHAR)KeyValue)+1;
        } else if (KeyLengthCode == 'W') {KeyLength = 2 * (wcslen((PWCHAR)KeyValue)+1);
        } else {
            return JET_errIndexInvalidDef;
        }

        //
        // Print out the KeyValue using the correct format.
        //
        if (MultiKeyLookup) {
                   if (KeyLengthCode == 'L') {Format = "++ MakeKey: Index %s, KeyValue = %d,  KeyLen = %d\n";
            } else if (KeyLengthCode == 'Q') {Format = "++ MakeKey: Index %s, KeyValue = %08x %08x, KeyLen = %d\n";
            } else if (KeyLengthCode == 'G') {Format = "++ MakeKey: Index %s, KeyValue = %s,  KeyLen = %d\n";
            } else if (KeyLengthCode == 'C') {Format = "++ MakeKey: Index %s, KeyValue = %s,  KeyLen = %d\n";
            } else if (KeyLengthCode == 'W') {Format = "++ MakeKey: Index %s, KeyValue = %ws, KeyLen = %d\n";
            };

            if (KeyLengthCode == 'L') {
                DPRINT3(DMK_SEV, Format, IndexName, *(PULONG)KeyValue, KeyLength);
            } else

            if (KeyLengthCode == 'Q') {
                DPRINT4(DMK_SEV, Format, IndexName, *((PULONG)KeyValue+1), *(PULONG)KeyValue, KeyLength);
            } else

            if (KeyLengthCode == 'G') {
                GuidToStr((GUID *)KeyValue, GuidStr);
                DPRINT3(DMK_SEV, Format, IndexName, GuidStr, KeyLength);
            } else {
                DPRINT3(DMK_SEV, Format, IndexName, KeyValue, KeyLength);
            }
        }

        //
        // Give Jet the next key segment.
        //
        jerr = JetMakeKey(Sesid, Tid, KeyValue, KeyLength, KeyFlags);
        CLEANUP1_JS(0, "++ JetMakeKey error on key segment %d :", i, jerr, RETURN);

        KeyFlags = 0;
        KeyLengthCode = IndexName[++i];
    }

    jerr = JET_errSuccess;

RETURN:
    return jerr;
}


JET_ERR
DbsRecordOperation(
    IN PTHREAD_CTX   ThreadCtx,
    IN ULONG         Operation,
    IN PVOID         KeyValue,
    IN ULONG         RecordIndex,
    IN PTABLE_CTX    TableCtx
    )

/*++

Routine Description:

    This function opens the table specified by the table context
    (if it's not already open) and performs the operation on a record
    with Key = RecordName and Index = RecordIndex.
    For a read the data is loaded into the TableCtx data record.
    The variable length buffers are allocated as needed.

    If the TableCtx->Tid field is NOT JET_tableidNil then
    we assume it is good FOR THIS SESSION and do not reopen the table.
    If the Table was not opened by the caller then we close it at the
    end of the operation UNLESS the operation is only a seek request.
    So for read and delte requests, if you want the table open after the
    call then the caller must open it.

    Note:  NEVER use table IDs across sessions or threads.

    Note:  The Delete operation assumes the caller handles the begin
           and commit transaction details.  If you want a simple one shot
           delete use DbsDeleteTableRecord().

    MacroRef:  DbsReadRecord
    MacroRef:  DbsDeleteRecord
    MacroRef:  DbsSeekRecord

Arguments:

    ThreadCtx  - Provides the Jet Sesid and Dbid.

    Operation  - The request operation.  SEEK, READ or DELETE.

    KeyValue   - The key value of the desired record to operate on.

    RecordIndex - The index to use when accessing the table.  From the index
                  enum list for the table in schema.h.

    TableCtx   - The table context uses the following:

            JTableCreate - The table create structure which provides info
                           about the columns that were created in the table.

            JRetColumn - The JET_RETRIEVECOLUMN struct array to tell
                         Jet where to put the data.

            ReplicaNumber - The id number of the replica this table belongs too.

Return Value:

    Jet Status.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsRecordOperation:"

    JET_ERR      jerr, jerr1;
    JET_SESID    Sesid;
    JET_TABLEID  Tid;
    ULONG        i;
    NTSTATUS     Status;
    ULONG        ReplicaNumber;
    ULONG        FStatus;
    PCHAR        BaseTableName;
    PCHAR        IndexName;
    ULONG        NumberColumns;
    CHAR         TableName[JET_cbNameMost];
    JET_TABLEID  FrsOpenTableSaveTid;   // for FrsOpenTableMacro

    PJET_TABLECREATE    JTableCreate;
    PJET_INDEXCREATE    JIndexDesc;
    PJET_RETRIEVECOLUMN JRetColumn;


    Sesid          = ThreadCtx->JSesid;
    ReplicaNumber  = TableCtx->ReplicaNumber;

    //
    // Open the table, if it's not already open. Check the session id for match.
    // It returns constructed table name and Tid.
    //
    jerr = DBS_OPEN_TABLE(ThreadCtx, TableCtx, ReplicaNumber, TableName, &Tid);
    CLEANUP1_JS(0, "ERROR - FrsOpenTable (%s) :", TableName, jerr, RETURN);

    //
    // Get the ptr to the table create struct, the retrieve col struct and the
    // and the Tid from the TableCtx.  Get the base of the Index Descriptor
    // array, the number of columns in the table and the base table name from
    // the jet table create struct.
    //
    JTableCreate   = TableCtx->pJetTableCreate;
    JRetColumn     = TableCtx->pJetRetCol;
    Tid            = TableCtx->Tid;

    JIndexDesc     = JTableCreate->rgindexcreate;
    NumberColumns  = JTableCreate->cColumns;
    BaseTableName  = JTableCreate->szTableName;

    //
    // Get the index name based on RecordIndex argument.
    //
    IndexName = JIndexDesc[RecordIndex].szIndexName;

    //
    // Use the specified index.
    // perf: - should we remember this in the TableCtx to avoid the call?
    //
    jerr = JetSetCurrentIndex(Sesid, Tid, IndexName);
    CLEANUP_JS(0, "ERROR - JetSetCurrentIndex error:", jerr, ERROR_RET_TABLE);

    //
    // Make the key value for the target record.
    //
    jerr = DbsMakeKey(Sesid, Tid, IndexName, &KeyValue);
    if (!JET_SUCCESS(jerr)) {
        if (jerr == JET_errIndexInvalidDef) {
            sprintf(TableName, "%s%05d", BaseTableName, TableCtx->ReplicaNumber);
            DPRINT2(0, "++ Schema error - Invalid keycode on index (%s) accessing table (%s)\n",
                   IndexName, TableName);
        }
        DbsTranslateJetError(jerr, TRUE);
        goto ERROR_RET_TABLE;
    }

    //
    // Seek to the record.
    //
    jerr = JetSeek(Sesid, Tid, JET_bitSeekEQ);

    //
    // If the record is not there (we were looking for equality) then return.
    //
    if (jerr == JET_errRecordNotFound) {
        DPRINT_JS(4, "JetSeek - ", jerr);
        return jerr;
    }
    CLEANUP_JS(0, "JetSeek error:", jerr, ERROR_RET_TABLE);

    //
    // Perform Record read if requested.
    //
    if (Operation & ROP_READ) {
        //
        // Initialize the JetSet/RetCol arrays and data record buffer addresses
        // to read and write the fields of the ConfigTable records into ConfigRecord.
        //
        DbsSetJetColSize(TableCtx);
        DbsSetJetColAddr(TableCtx);

        //
        // Allocate the storage for the variable length fields in the record and
        // update the JetSet/RetCol arrays appropriately.
        //
        Status = DbsAllocRecordStorage(TableCtx);
        CLEANUP_NT(0, "++ ERROR - DbsAllocRecordStorage failed to alloc buffers.",
                   Status, ERROR_RET_FREE_RECORD);

        //
        // Now read the record.
        //
        FStatus = DbsTableRead(ThreadCtx, TableCtx);
        if (!FRS_SUCCESS(FStatus)) {
            DPRINT_FS(0, "Error - can't read selected record.", FStatus);
            jerr = JET_errRecordNotFound;
            goto ERROR_RET_FREE_RECORD;
        }
        DBS_DISPLAY_RECORD_SEV(5, TableCtx, TRUE);

    }

    //
    // Perform record delete if requested.
    //
    if (Operation & ROP_DELETE) {
        jerr = JetDelete(Sesid, Tid);
        DPRINT1_JS(0, "JetDelete error for %s :", TableName, jerr);
    }

    //
    // Close the table if this function opened it and operation was not a seek.
    //
    if ((Operation != ROP_SEEK) && (FrsOpenTableSaveTid == JET_tableidNil)) {
        DbsCloseTable(jerr1, Sesid, TableCtx);
        DPRINT1_JS(0, "DbsCloseTable error %s :", TableName, jerr1);
    }

    //
    // Success.
    //
RETURN:

    return jerr;

ERROR_RET_FREE_RECORD:

    //
    // Free any runtime allocated record buffers.
    //
    DbsFreeRecordStorage(TableCtx);

ERROR_RET_TABLE:

    //
    // Close the table and reset TableCtx Tid and Sesid.   Macro writes 1st arg.
    //
    DbsCloseTable(jerr1, Sesid, TableCtx);

    return jerr;
}



ULONG
DbsRecordOperationMKey(
    IN PTHREAD_CTX   ThreadCtx,
    IN ULONG         Operation,
    IN PVOID         *KeyValueArray,
    IN ULONG         RecordIndex,
    IN PTABLE_CTX    TableCtx
    )

/*++

Routine Description:

    This function opens the table specified by the table context
    (if it's not already open) and performs the operation on a record
    with a multivalued key.
    For a read the data is loaded into the TableCtx data record.
    The variable length buffers are allocated as needed.

    If the TableCtx->Tid field is NOT JET_tableidNil then
    we assume it is good FOR THIS SESSION and do not reopen the table.
    If the Table was not opened by the caller then we close it at the
    end of the operation UNLESS the operation is only a seek request.
    So for read and delte requests, if you want the table open after the
    call then the caller must open it.

    Note:  NEVER use table IDs across sessions or threads.

    Note:  The Delete operation assumes the caller handles the begin
           and commit transaction details.  If you want a simple one shot
           delete use DbsDeleteTableRecord().

Arguments:

    ThreadCtx  - Provides the Jet Sesid and Dbid.

    Operation  - The request operation.  SEEK, READ or DELETE.

    KeyValueArray -  A ptr array to the key values for a multi-key index.

    RecordIndex - The index to use when accessing the table.  From the index
                  enum list for the table in schema.h.

    TableCtx   - The table context uses the following:

            JTableCreate - The table create structure which provides info
                           about the columns that were created in the table.

            JRetColumn - The JET_RETRIEVECOLUMN struct array to tell
                         Jet where to put the data.

            ReplicaNumber - The id number of the replica this table belongs too.

Return Value:

    Frs Status.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsRecordOperationMKey:"

    JET_ERR      jerr, jerr1;
    JET_SESID    Sesid;
    JET_TABLEID  Tid;
    ULONG        i;
    NTSTATUS     Status;
    ULONG        ReplicaNumber;
    ULONG        FStatus = FRS_MAX_ERROR_CODE;
    PCHAR        BaseTableName;
    PCHAR        IndexName;
    CHAR         TableName[JET_cbNameMost];
    JET_TABLEID  FrsOpenTableSaveTid;   // for FrsOpenTableMacro

    PJET_TABLECREATE    JTableCreate;
    PJET_INDEXCREATE    JIndexDesc;
    PJET_RETRIEVECOLUMN JRetColumn;


    Sesid          = ThreadCtx->JSesid;
    ReplicaNumber  = TableCtx->ReplicaNumber;

    //
    // Open the table, if it's not already open. Check the session id for match.
    // It returns constructed table name and Tid.
    //
    jerr = DBS_OPEN_TABLE(ThreadCtx, TableCtx, ReplicaNumber, TableName, &Tid);
    CLEANUP1_JS(0, "ERROR - FrsOpenTable (%s) :", TableName, jerr, ERROR_RET_FREE_RECORD);

    //
    // Get the ptr to the table create struct, the retrieve col struct and the
    // and the Tid from the TableCtx.  Get the base of the Index Descriptor
    // array, the number of columns in the table and the base table name from
    // the jet table create struct.
    //
    JTableCreate   = TableCtx->pJetTableCreate;
    JRetColumn     = TableCtx->pJetRetCol;
    Tid            = TableCtx->Tid;

    JIndexDesc     = JTableCreate->rgindexcreate;
    BaseTableName  = JTableCreate->szTableName;

    //
    // Get the index name based on RecordIndex argument.
    //
    IndexName      = JIndexDesc[RecordIndex].szIndexName;

    //
    // Use the specified index.
    // perf: - should we remember this in the TableCtx to avoid the call?
    //
    jerr = JetSetCurrentIndex(Sesid, Tid, IndexName);
    CLEANUP_JS(0, "ERROR - JetSetCurrentIndex error:", jerr, RET_CLOSE_TABLE);

    //
    // Make the key value for the target record.
    //
    jerr = DbsMakeKey(Sesid, Tid, IndexName, KeyValueArray);
    if (!JET_SUCCESS(jerr)) {
        if (jerr == JET_errIndexInvalidDef) {
            sprintf(TableName, "%s%05d", BaseTableName, TableCtx->ReplicaNumber);
            DPRINT2(0, "++ Schema error - Invalid keycode on index (%s) accessing table (%s)\n",
                   IndexName, TableName);
        }
        goto RET_CLOSE_TABLE;
    }

    //
    // Seek to the record.
    // If the record is not there (we are looking for equality) then return.
    //
    jerr = JetSeek(Sesid, Tid, JET_bitSeekEQ);
    if (jerr == JET_errRecordNotFound) {
        DPRINT_JS(4, "JetSeek - ", jerr);
        return FrsErrorNotFound;
    }
    CLEANUP_JS(0, "JetSeek error:", jerr, RET_CLOSE_TABLE);

    //
    // Perform Record read if requested.
    //
    if (Operation & ROP_READ) {
        //
        // Initialize the JetSet/RetCol arrays and data record buffer addresses
        // to read and write the fields of the ConfigTable records into ConfigRecord.
        //
        DbsSetJetColSize(TableCtx);
        DbsSetJetColAddr(TableCtx);

        //
        // Allocate the storage for the variable length fields in the record and
        // update the JetSet/RetCol arrays appropriately.
        //
        FStatus = FrsErrorResource;
        Status = DbsAllocRecordStorage(TableCtx);
        CLEANUP_NT(0, "++ ERROR - DbsAllocRecordStorage failed to alloc buffers.",
                   Status, ERROR_RET_FREE_RECORD);

        //
        // Now read the record.
        //
        FStatus = DbsTableRead(ThreadCtx, TableCtx);
        if (!FRS_SUCCESS(FStatus)) {
            DPRINT_FS(0, "Error - can't read selected record.", FStatus);
            goto ERROR_RET_FREE_RECORD;
        }
        DBS_DISPLAY_RECORD_SEV(5, TableCtx, TRUE);
    }

    //
    // Perform record delete if requested.
    //
    if (Operation & ROP_DELETE) {
        jerr = JetDelete(Sesid, Tid);
        CLEANUP1_JS(0, "JetDelete error on (%s) :", TableName, jerr, RETURN);
    }

    //
    // Close the table if this function opened it and the operation was not
    // a seek.
    //
    if ((Operation != ROP_SEEK) && (FrsOpenTableSaveTid == JET_tableidNil)) {
        goto RET_CLOSE_TABLE;
    }

    //
    // Success.
    //
    FStatus = FrsErrorSuccess;
    goto RETURN;


    //
    // Error return paths
    //

ERROR_RET_FREE_RECORD:

    //
    // Free any runtime allocated record buffers.
    //
    DbsFreeRecordStorage(TableCtx);


RET_CLOSE_TABLE:

    //
    // Close the table and reset TableCtx Tid and Sesid.   Macro writes 1st arg.
    //
    DbsCloseTable(jerr1, Sesid, TableCtx);
    DPRINT1_JS(0, "++ DbsCloseTable error on (%s)", TableName, jerr1);


RETURN:

    if (FStatus == FRS_MAX_ERROR_CODE) {
        FStatus = DbsTranslateJetError(jerr, FALSE);
    }
    return FStatus;

}



JET_ERR
DbsCreateJetSession(
    IN OUT PTHREAD_CTX    ThreadCtx
    )
/*++

Routine Description:

    This function creates a new jet session and opens the FRS database
    using the jet instance provided in the ThreadCtx.  It returns a
    jet session ID and a database ID to the caller through the ThreadCtx.

Arguments:

    ThreadCtx   - Thread context to init with Jet Instance, Session ID and DBID.

Return Value:

    Jet status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsCreateJetSession:"

    JET_SESID   Sesid;
    JET_DBID    Dbid;
    JET_ERR     jerr, jerr1;

    JET_INSTANCE JInstance;

    JInstance = ThreadCtx->JInstance;

    ThreadCtx->JSesid = JET_sesidNil;
    ThreadCtx->JDbid  = JET_dbidNil;


RETRY_SESSION:

    //
    // Open a jet session.
    //
    jerr = JetBeginSession(JInstance, &Sesid, NULL, NULL);
    CLEANUP_JS(1, "JetBeginSession error:", jerr, ERROR_RET_NO_SESSION);

    DPRINT(4, "JetBeginSession complete\n");

    //
    // Attach the database
    //
    // The call may return a -1414 (Secondary Index Corrupted)
    //
    // The indexes were most likely corrupted because the build number changed
    // and jet marked the UNICODE indexes as corrupt.  As I understand it, jet
    // does this because jet is worried that the collating sequence changed
    // without warning.  The indexes will be rebuilt as the various tables are
    // opened and the deleted indexes detected; someday.
    //
    // Today, our only workaround is to describe a manual recovery
    // process for the user. See comments above.
    //
    // Excerpt from email from jet engineer:
    //
    // To override the FixedDDL flag, you have to open the table with the
    // grbits JET_bitTableDenyRead|JET_bitTablePermitDDL passed to
    // JetOpenTable().  This opens the table in exclusive mode and allows you
    // to add columns and indexes to the table.  Note that no other thread is
    // allowed access to the table while you are creating indexes.
    //
    // BUT the above doesn't quite work at this time because the JetAttachDatabase()
    // returns a -1323 when called with JET_bitDbDeleteCorruptIndexes.
    //

    jerr = JetAttachDatabase(Sesid,
                             JetFileA,
    // Note: Enable when jet fix for above is tested.
                             // JET_bitDbDeleteCorruptIndexes);
                             0);
    if ((!JET_SUCCESS(jerr)) &&
        (jerr != JET_wrnDatabaseAttached) &&
        (jerr != JET_wrnCorruptIndexDeleted)) {
        DPRINT_JS(0, "ERROR - JetAttachDatabase:", jerr);
        //
        // Note: Remove when jet fix for above is tested.
        //
        if (jerr == JET_errSecondaryIndexCorrupted) {
            goto ERROR_RET_SESSION;
        }
    }
    DPRINT(4,"JetAttachDatabase complete\n");
    //
    // The indexes were most likely corrupted because the build number changed
    // and jet marked the UNICODE indexes as corrupt.  As I understand it, jet
    // does this because jet is worried that the collating sequence changed
    // without warning.  The indexes will be rebuilt as the various tables are
    // opened and the deleted indexes detected.
    //
    if (jerr == JET_wrnCorruptIndexDeleted) {
        DPRINT(4, "WARN - Jet indexes were deleted\n");
    }

    //
    // Open database
    //
    jerr = JetOpenDatabase(Sesid, JetFileA, "", &Dbid, 0);
    CLEANUP_JS(1, "JetOpenDatabase error:", jerr, ERROR_RET_ATTACH);

    InterlockedIncrement(&OpenDatabases);
    DPRINT3(4, "DbsCreateJetSession - JetOpenDatabase. Session = %d. Dbid = %d.  Open database count: %d\n",
             Sesid, Dbid, OpenDatabases);

    //
    // Return the jet session and database ID context to the caller.
    //

    ThreadCtx->JSesid = Sesid;
    ThreadCtx->JDbid  = Dbid;

    return JET_errSuccess;

//
// Error return paths, do cleanup.
//

ERROR_RET_DB:
    jerr1 = JetCloseDatabase(Sesid, Dbid, 0);
    DPRINT1_JS(0, "ERROR - JetCloseDatabase(%s) :", JetFileA, jerr1);

ERROR_RET_ATTACH:
    jerr1 = JetDetachDatabase(Sesid, JetFileA);
    DPRINT1_JS(0, "ERROR - JetDetachDatabase(%s) :", JetFileA, jerr1);

ERROR_RET_SESSION:
    jerr1 = JetEndSession(Sesid, 0);
    DPRINT1_JS(0, "ERROR - JetEndSession(%s) :", JetFileA, jerr1);


ERROR_RET_NO_SESSION:

    return jerr;
}



JET_ERR
DbsCloseJetSession(
    IN PTHREAD_CTX  ThreadCtx
    )
/*++

Routine Description:

    This function closes a Jet session.  It closes the database and detaches
    then calls EndSession.  It sets the session ID and the database ID to
    NIL.

Arguments:

    ThreadCtx  -  The thread context provides Sesid and Dbid.

Return Value:

    Jet status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsCloseJetSession:"

    JET_SESID    Sesid;
    JET_ERR      jerr;

    //
    // Recovery and cleanup may sometimes call this function with a NULL
    //
    if (ThreadCtx == NULL)
        return JET_errSuccess;

    //
    // Session ID for this thread
    //
    Sesid = ThreadCtx->JSesid;

    //
    // Close the database handle.
    //
    jerr = JetCloseDatabase(Sesid, ThreadCtx->JDbid, 0);
    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(0,"ERROR - JetCloseDatabase:", jerr);
    } else {
        DPRINT(4,"JetCloseDatabase complete\n");
    }


    //
    // Detach from the database.
    //
    if (InterlockedDecrement(&OpenDatabases) == 0) {
        jerr = JetDetachDatabase(Sesid, NULL);
        if (!JET_SUCCESS(jerr)) {
            DPRINT_JS(0,"ERROR - JetDetachDatabase:", jerr);
        } else {
            DPRINT(4,"JetDetachDatabase complete\n");
        }
    }
    DPRINT1(4, "Open databases: %d\n", OpenDatabases);

    //
    // End the session.
    //
    jerr = JetEndSession(Sesid, 0);
    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(0,"JetEndSession error:", jerr);
    } else {
        DPRINT(4,"JetEndSession complete\n");
    }

    //
    // Clear session and db IDs to catch errors.
    //
    ThreadCtx->JSesid = JET_sesidNil;
    ThreadCtx->JDbid = JET_dbidNil;

    return jerr;

}


JET_ERR
DbsWriteReplicaTableRecord(
    IN PTHREAD_CTX   ThreadCtx,
    ULONG            ReplicaNumber,
    IN PTABLE_CTX    TableCtx
    )
/*++

Routine Description:

    This function writes the contents of the data record provided in the TableCtx
    struct to the corresponding table.  The Sesid comes from the ThreadCtx
    and the ReplicaNumber comes from the Replica struct.

    The table is opened if necessary but we assume the DataRecord in the table
    context is allocated and filled in.
    The JetSetCol struct is assumed to be initialized.

Arguments:

    ThreadCtx  -- ptr to the thread context.
    ReplicaNumber -- The ID number of the replica set.
    TableCtx   -- ptr to the table context.

Return Value:

    Jet status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsWriteReplicaTableRecord:"

    JET_ERR          jerr;
    JET_TABLEID      Tid;

    CHAR             TableName[JET_cbNameMost];
    JET_TABLEID      FrsOpenTableSaveTid;   // for FrsOpenTableMacro DEBUG


    Tid = TableCtx->Tid;

    //
    // Open the table if it's not already open and check the session id for match.
    //
    jerr = DBS_OPEN_TABLE(ThreadCtx, TableCtx, ReplicaNumber, TableName, &Tid);
    CLEANUP1_JS(0, "++ FrsOpenTable (%s) :", TableName, jerr, RETURN);

    //
    // Now insert the record into the table.
    //
    jerr = DbsInsertTable2(TableCtx);
    DPRINT1_JS(0, "++ DbsInsertTable2() Failed on %s.", TableName, jerr);

RETURN:
    return jerr;


}



JET_ERR
DbsInsertTable2(
    IN PTABLE_CTX    TableCtx
    )
{
    return DbsWriteTableRecord(TableCtx, JET_prepInsert);
}




JET_ERR
DbsUpdateTable(
    IN PTABLE_CTX    TableCtx
    )
{
    return DbsWriteTableRecord(TableCtx, JET_prepReplace);
}


JET_ERR
DbsWriteTableRecord(
    IN PTABLE_CTX    TableCtx,
    IN ULONG         JetPrepareUpdateOption
    )
/*++

Routine Description:

    This function inserts or updates a record into a DB Table specified by Tablex.
    It writes all fields in the data record in the TableCtx
    struct to the corresponding table.  The Sesid comes from the TableCtx.

    It is assumed that the DataRecord in the table context is allocated
    and filled in.  The JetSetCol struct is assumed to be initialized.

    This routine updates the field size for those record fields that
    are unicode strings or variable length records.

Arguments:

    TableCtx    - Table context provides Jet sesid, tid, table create ptr,
                  jet set col struct and record data.

    JetPrepareUpdateOption - Either JET_prepInsert or JET_prepReplace

Return Value:

    Jet status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsWriteTableRecord:"

    JET_ERR           jerr, jerr1;
    JET_SESID         Sesid;
    JET_TABLEID       Tid;
    PJET_SETCOLUMN    JSetColumn;
    PJET_SETCOLUMN    JSetColumnNext;
    PJET_TABLECREATE  JTableCreate;
    PJET_COLUMNCREATE JColDesc;
    PRECORD_FIELDS    FieldInfo;

    ULONG bcnt;
    ULONG cbActual;
    ULONG i;
    ULONG NumberColumns;

    CHAR              TableName[JET_cbNameMost];
    char Test[512];
    char  bookmark[255];


    Sesid          = TableCtx->Sesid;
    Tid            = TableCtx->Tid;
    JTableCreate   = TableCtx->pJetTableCreate;
    JSetColumn     = TableCtx->pJetSetCol;
    FieldInfo      = TableCtx->pRecordFields + 1;  // skip elt 0

    NumberColumns  = JTableCreate->cColumns;
    JColDesc       = JTableCreate->rgcolumncreate;

    //
    // Make the table name for error messages.
    //
    sprintf(TableName, "%s%05d",
            JTableCreate->szTableName, TableCtx->ReplicaNumber);

    //
    // Set length values on the variable len fields and clear the error codes.
    //
    for (i=0; i<NumberColumns; i++) {

        JSetColumn[i].err = JET_errSuccess;

        JSetColumn[i].cbData =
            DbsFieldDataSize(&FieldInfo[i], &JSetColumn[i], &JColDesc[i], TableName);
    }

    // Jet600 doesn't allow updates of certain data types (long values
    // like binary in particular) to be updated at transaction level 0.
    // So begin and end a transaction appropriately.

    jerr = JetBeginTransaction(Sesid);
    CLEANUP1_JS(0, "++ DbsWriteTableRecord() Failed on %s.", TableName, jerr, ROLLBACK);

    //
    // DEBUG OPTION: cause out of space error
    //
    DBG_DBS_OUT_OF_SPACE_FILL(DBG_DBS_OUT_OF_SPACE_OP_WRITE);

    jerr = JetPrepareUpdate(Sesid, Tid, JetPrepareUpdateOption);
    CLEANUP1_JS(0, "++ DbsWriteTableRecord() Failed on %s.", TableName, jerr, ROLLBACK);

    DBS_DISPLAY_RECORD_SEV(5, TableCtx, FALSE);

#if 0
    //
    // Set values into the columns of the new record.
    //
    jerr = JetSetColumns(Sesid, Tid, JSetColumn, NumberColumns);
    if (!JET_SUCCESS(jerr)) {
        DPRINT1_JS(0, "++ DbsWriteTableRecord() Failed on %s.", TableName, jerr);

        for (i=0; i<NumberColumns; i++) {

            jerr = JSetColumn[i].err;
            CLEANUP2_JS(0, "++ ERROR - JetSetColumns: Table - %s,  col - %s :",
                         TableName, JColDesc[i].szColumnName, jerr, ROLLBACK);
        }

        goto ROLLBACK;
    }
#endif

    //
    // Set values into the columns of the new record.  Do it 1 column at a
    // time so we can actually get an error status value.
    // Don't write any column if the autoincrement grbit is set.
    //
    JSetColumnNext = JSetColumn;
    for (i=0; i<NumberColumns; i++) {
        if ( (JColDesc[i].grbit & JET_bitColumnAutoincrement) == 0) {

            jerr = JetSetColumns(Sesid, Tid, JSetColumnNext, 1);

            if (!IsSpareField(FieldInfo[i].DataType)) {
                CLEANUP2_JS(0, "++ DbsWriteTableRecord() Failed on %s. Column: %d :",
                            TableName, i, jerr, ROLLBACK);
            }

        }
        JSetColumnNext += 1;
    }
    //
    // Insert the record in the database.  Get the bookmark.
    //
    jerr = JetUpdate(Sesid, Tid, bookmark, sizeof(bookmark), &bcnt);

    //
    // DEBUG OPTION - Trigger an out-of-space error
    //
    DBG_DBS_OUT_OF_SPACE_TRIGGER(jerr);
    CLEANUP1_JS(1, "++ DbsWriteTableRecord() Failed on %s.", TableName, jerr, ROLLBACK);

    jerr = JetGotoBookmark(Sesid, Tid, bookmark, bcnt);
    CLEANUP1_JS(0, "++ DbsWriteTableRecord() Failed on %s.", TableName, jerr, ROLLBACK);

    //
    // Test the insert by retrieving the data from col 0.
    // Note: Perf
    // Remove after debug, except for INlog table. - retrieval after write test.
    // Change Col 0 in inlog to be non-autoinc so we don't have to read it
    // back.  But then it has to be initialized at start up when we scan the log.
    //
    jerr = JetRetrieveColumn(Sesid,
                             Tid,
                             JSetColumn[0].columnid,
                             Test,
                             sizeof(Test),
                             &cbActual,
                             0,NULL);

    CLEANUP1_JS(0, "++ DbsWriteTableRecord() Failed on %s.", TableName, jerr, ROLLBACK);

    //
    // The size and data better match.
    //
    if (cbActual != JSetColumn[0].cbData) {
        jerr = JET_errReadVerifyFailure;
        DPRINT1_JS(0, "++ DbsWriteTableRecord() Failed on %s.", TableName, jerr);
        DPRINT2(0, "++   cbActual = %d, not equal cbData = %d\n",
                cbActual, JSetColumn[0].cbData);
        goto ROLLBACK;
    }

    if ((TableCtx->TableType != INLOGTablex) &&
        (TableCtx->TableType != OUTLOGTablex)) {
        //
        // Column 1 won't match for the LOG tables since it is an autoinc col.
        //
        if (memcmp(Test, JSetColumn[0].pvData, cbActual) != 0) {
            jerr = JET_errReadVerifyFailure;
            DPRINT1_JS(0, "++ DbsWriteTableRecord() Failed on %s.", TableName, jerr);
            DPRINT(0, "++ Data inserted not equal to data returned for column 0\n");
            goto ROLLBACK;
        }
    } else {
        //
        // return the value for column 1 for the LOGs since the caller needs it.
        //
        CopyMemory((const PVOID)JSetColumn[0].pvData, Test, cbActual);
    }

    //
    // Commit the transaction.
    //
    jerr = JetCommitTransaction(Sesid, 0);
    CLEANUP1_JS(0, "++ DbsWriteTableRecord() Failed on %s.", TableName, jerr, ROLLBACK);

    //
    // DEBUG OPTION: Delete fill file
    //
    DBG_DBS_OUT_OF_SPACE_EMPTY(DBG_DBS_OUT_OF_SPACE_OP_WRITE);

    //
    // Success
    //
    return jerr;


    //
    // Failure.  Try to rollback transaction.
    //
ROLLBACK:

    jerr1 = JetRollback(Sesid, 0);
    DPRINT1_JS(0, "++ ERROR - JetRollback failed creating tables for replica %d.",
               TableCtx->ReplicaNumber, jerr1);

    DBS_DISPLAY_RECORD_SEV(1, TableCtx, FALSE);

    //
    // DEBUG OPTION: Delete fill file
    //
    DBG_DBS_OUT_OF_SPACE_EMPTY(DBG_DBS_OUT_OF_SPACE_OP_WRITE);

    //
    // Shutdown if the database volume is full
    //
    DbsExitIfDiskFull(jerr1);
    DbsExitIfDiskFull(jerr);

    return jerr;
}


JET_ERR
DbsDeleteTableRecord(
    IN PTABLE_CTX    TableCtx
    )
/*++

Routine Description:

    This function deletes the current record in the table specified by Tablex.
    The Sesid comes from the TableCtx.

Arguments:

    TableCtx    - Table context provides Jet sesid, tid.

Return Value:

    Jet status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsDeleteTableRecord:"

    JET_ERR           jerr, jerr1;
    JET_SESID         Sesid;
    PJET_COLUMNCREATE JColDesc;
    PJET_TABLECREATE  JTableCreate;
    CHAR              TableName[JET_cbNameMost];

    Sesid          = TableCtx->Sesid;
    JTableCreate   = TableCtx->pJetTableCreate;

    //
    // Make the table name for error messages.
    //
    sprintf(TableName, "%s%05d", JTableCreate->szTableName, TableCtx->ReplicaNumber);

    // Jet600 doesn't allow updates of certain data types (long values
    // like binary in particular) to be updated at transaction level 0.
    // So begin and end a transaction appropriately.

    jerr = JetBeginTransaction(Sesid);
    CLEANUP1_JS(0, "++ DbsDeleteTableRecord() Failed on %s.", TableName, jerr, ROLLBACK);

    DBS_DISPLAY_RECORD_SEV(5, TableCtx, FALSE);

    //
    // DEBUG OPTION: Fill up the volume containing the database
    //
    DBG_DBS_OUT_OF_SPACE_FILL(DBG_DBS_OUT_OF_SPACE_OP_REMOVE);

    jerr = JetDelete(Sesid, TableCtx->Tid);
    //
    // DEBUG OPTION - Trigger an out-of-space error
    //
    DBG_DBS_OUT_OF_SPACE_TRIGGER(jerr);
    CLEANUP1_JS(0, "++ DbsDeleteTableRecord() Failed on %s.", TableName, jerr, ROLLBACK);

    //
    // Commit the transaction.
    //
    jerr = JetCommitTransaction(Sesid, 0);
    CLEANUP1_JS(0, "++ DbsDeleteTableRecord() Failed on %s.", TableName, jerr, ROLLBACK);

    //
    // DEBUG OPTION: Delete fill file
    //
    DBG_DBS_OUT_OF_SPACE_EMPTY(DBG_DBS_OUT_OF_SPACE_OP_REMOVE);

    //
    // Success
    //
    return jerr;

    //
    // Failure.  Try to rollback transaction.
    //
ROLLBACK:

    jerr1 = JetRollback(Sesid, 0);
    DPRINT1_JS(0, "++ ERROR - JetRollback failed creating tables for replica %d.",
               TableCtx->ReplicaNumber, jerr1);
    DBS_DISPLAY_RECORD_SEV(1, TableCtx, FALSE);

    //
    // DEBUG OPTION: Delete fill file
    //
    DBG_DBS_OUT_OF_SPACE_EMPTY(DBG_DBS_OUT_OF_SPACE_OP_REMOVE);

    //
    // Shutdown if the database volume is full
    //
    DbsExitIfDiskFull(jerr1);
    DbsExitIfDiskFull(jerr);

    return jerr;
}

ULONG
DbsWriteTableField(
    IN PTHREAD_CTX   ThreadCtx,
    IN ULONG         ReplicaNumber,
    IN PTABLE_CTX    TableCtx,
    IN ULONG         RecordFieldx
    )
/*++

Routine Description:

    This function writes a single field provided in the data record in the TableCtx
    struct to the corresponding table.  The Sesid comes from the ThreadCtx.

    It is assumed that a previous seek to the desired record has been performed
    and the DataRecord in the table context is allocated and filled in.
    The JetSetCol struct is assumed to be initialized.

    This routine updates the field size for the record in the case of strings
    and variable length records.

Arguments:

    ThreadCtx  -- ptr to the thread context.
    ReplicaNumber  -- ID number of replica set.
    TableCtx   -- ptr to the table context.
    RecordFieldx -- id of the field column to update.

Return Value:

    FrsError status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsWriteTableField:"

    return DbsWriteTableFieldMult(ThreadCtx,
                                  ReplicaNumber,
                                  TableCtx,
                                  &RecordFieldx,
                                  1);
}




ULONG
DbsWriteTableFieldMult(
    IN PTHREAD_CTX   ThreadCtx,
    IN ULONG         ReplicaNumber,
    IN PTABLE_CTX    TableCtx,
    IN PULONG        RecordFieldx,
    IN ULONG         FieldCount
    )
/*++

Routine Description:

    This function writes multiple fields provided in the data record in
    the TableCtx struct to the corresponding table.  The Sesid comes from
    the ThreadCtx.  This is all done under a single transaction.

    It is assumed that a previous seek to the desired record has been performed
    and the DataRecord in the table context is allocated and filled in.
    The JetSetCol struct is assumed to be initialized.

    This routine updates the field sizes for the record in the case of strings
    and variable length fields.

Arguments:

    ThreadCtx  -- ptr to the thread context.
    ReplicaNumber  -- ID number of replica set.
    TableCtx   -- ptr to the table context.
    RecordFieldx -- ptr to an array of field ids for the columns to update.
    FieldCount -- Then number of field entries in the RecordFieldx array.

Return Value:

    FrsError status code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsWriteTableFieldMult:"

    JET_ERR           jerr, jerr1;
    JET_SESID         Sesid;
    JET_TABLEID       Tid;
    PJET_SETCOLUMN    JSetColumn;
    PJET_COLUMNCREATE JColDesc;
    PRECORD_FIELDS    FieldInfo;

    ULONG             NumberColumns;
    PJET_TABLECREATE  JTableCreate;
    CHAR              TableName[JET_cbNameMost];

    ULONG bcnt;
    ULONG cbActual;
    ULONG i, j;

    char Test[512];
    char  bookmark[255];

    //
    // Get the ptr to the table create struct, the set col struct and the
    // and the Tid from the TableCtx.  Get the number of columns in the
    // table from the jet table create struct.
    // Get the Replica number from the replica struct.
    //

    Sesid          = TableCtx->Sesid;
    Tid            = TableCtx->Tid;
    JTableCreate   = TableCtx->pJetTableCreate;
    JSetColumn     = TableCtx->pJetSetCol;
    FieldInfo      = TableCtx->pRecordFields + 1;  // skip elt 0

    NumberColumns  = JTableCreate->cColumns;
    JColDesc       = JTableCreate->rgcolumncreate;

    //
    // Make the table name for error messages.
    //
    sprintf(TableName, "%s%05d", JTableCreate->szTableName, TableCtx->ReplicaNumber);

    //
    // Jet600 doesn't allow updates of certain data types (long values
    // like binary in particular) to be updated at transaction level 0.
    // So begin and end a transaction appropriately.
    //
    jerr = JetBeginTransaction(Sesid);
    CLEANUP1_JS(0, "++ DbsWriteTableFieldMult Failed on %s.",
                TableName, jerr, ROLLBACK);

    //
    // DEBUG OPTION: Fill up the volume containing the database
    //
    DBG_DBS_OUT_OF_SPACE_FILL(DBG_DBS_OUT_OF_SPACE_OP_MULTI);

    jerr = JetPrepareUpdate(Sesid, Tid, JET_prepReplace);
    CLEANUP1_JS(0, "++ DbsWriteTableFieldMult Failed on %s.",
                TableName, jerr, ROLLBACK);

    //
    // Loop thru the fields to be updated.
    //
    for (j=0; j<FieldCount; j++) {
        i = RecordFieldx[j];
        //
        // Check for out of range Field Index or trying to write to a spare field.
        //
        if (i >= NumberColumns) {
            DPRINT2(0, "++ DbsWriteTableFieldMult() parm %d out of range on %s.\n", j, TableName);
            return FrsErrorBadParam;
        }

        if (IsSpareField(FieldInfo[i].DataType)) {
            DPRINT2(0, "++ Warning -- Writing a spare field (%d) on %s.\n", j, TableName);
            return FrsErrorBadParam;
        }

        JSetColumn[i].err = JET_errSuccess;
        JSetColumn[i].cbData =
            DbsFieldDataSize(&FieldInfo[i], &JSetColumn[i], &JColDesc[i], TableName);

        //
        // Set the value into the column of the record.
        //
        jerr = JetSetColumns(Sesid, Tid, &JSetColumn[i], 1);
        CLEANUP1_JS(0, "++ DbsWriteTableFieldMult Failed on %s.",
                    TableName, jerr, ROLLBACK);

        jerr = JSetColumn[i].err;
        CLEANUP2_JS(0, "++ ERROR - DbsWriteTableFieldMult: Table - %s,  col - %s :",
                    TableName, JColDesc[i].szColumnName, jerr, ROLLBACK);
    }
    //
    // Insert the record in the database.  Get the bookmark.
    //
    jerr = JetUpdate(Sesid, Tid, bookmark, sizeof(bookmark), &bcnt);
    //
    // DEBUG OPTION - Trigger an out-of-space error
    //
    DBG_DBS_OUT_OF_SPACE_TRIGGER(jerr);
    CLEANUP1_JS(0, "++ DbsWriteTableFieldMult() Failed on %s.",
                TableName, jerr, ROLLBACK);

#if DBG
    jerr = JetGotoBookmark(Sesid, Tid, bookmark, bcnt);
    CLEANUP1_JS(0, "++ DbsWriteTableFieldMult() Failed on %s.",
                TableName, jerr, ROLLBACK);

    //
    // Test the insert by retrieving the data.
    //
    jerr = JetRetrieveColumn(Sesid,
                             Tid,
                             JSetColumn[i].columnid,
                             Test,
                             sizeof(Test),
                             &cbActual,
                             0,NULL);

    CLEANUP1_JS(0, "++ DbsWriteTableFieldMult() Failed on %s.",
                TableName, jerr, ROLLBACK);

    if ((jerr == JET_wrnBufferTruncated) &&
        (JSetColumn[i].cbData > sizeof(Test))) {
        //
        // Field was bigger then our Test buffer.  Just compare what we got.
        //
        cbActual = JSetColumn[i].cbData;
    }

    //
    // The size and data better match.
    //
    if (cbActual != JSetColumn[i].cbData) {
        jerr = JET_errReadVerifyFailure;
        DPRINT1_JS(0, "++ DbsWriteTableFieldMult() Failed on %s.", TableName, jerr);
        DPRINT2(0, "++   cbActual = %d, not equal cbData = %d\n",
                cbActual, JSetColumn[0].cbData);
        goto ROLLBACK;
    }

    if (memcmp(Test, JSetColumn[i].pvData, min(cbActual, sizeof(Test))) != 0) {
        jerr = JET_errReadVerifyFailure;
        JColDesc =  JTableCreate->rgcolumncreate;
        DPRINT1_JS(0, "++ DbsWriteTableFieldMult() Failed on %s.", TableName, jerr);
        DPRINT1(0, "++ Data inserted not equal to data returned for column %s\n",
               JColDesc[i].szColumnName);
        goto ROLLBACK;
    }
#endif

    //
    // Commit the transaction.
    //
    jerr = JetCommitTransaction(Sesid, 0);
    CLEANUP1_JS(0, "++ DbsWriteTableFieldMult() Failed on %s.",
                TableName, jerr, ROLLBACK);

    //
    // DEBUG OPTION: Delete fill file
    //
    DBG_DBS_OUT_OF_SPACE_EMPTY(DBG_DBS_OUT_OF_SPACE_OP_MULTI);

    //
    // Success
    //
    return FrsErrorSuccess;


    //
    // Failure.  Try to rollback transaction.
    //
ROLLBACK:

    jerr1 = JetRollback(Sesid, 0);
    DPRINT1_JS(0, "++ ERROR - JetRollback failed writing record for replica %d.",
               TableCtx->ReplicaNumber, jerr1);

    //
    // DEBUG OPTION: Delete fill file
    //
    DBG_DBS_OUT_OF_SPACE_EMPTY(DBG_DBS_OUT_OF_SPACE_OP_MULTI);

    //
    // Shutdown if the database volume is full
    //
    DbsExitIfDiskFull(jerr1);
    DbsExitIfDiskFull(jerr);

    return DbsTranslateJetError(jerr, FALSE);
}



ULONG
DbsFieldDataSize(
    IN PRECORD_FIELDS    FieldInfo,
    IN PJET_SETCOLUMN    JSetColumn,
    IN PJET_COLUMNCREATE JColDesc,
    IN PCHAR             TableName
    )
/*++

Routine Description:

    Calculate the actual data size for a record field for insertion into
    a Jet Record.  Handle unicode string types and variable length
    record fields.  The later MUST be prefixed with a size/type
    FRS_NODE_HEADER which provides the size.

    If the Data Type for the field is marked as spare don't alloc storage.

Arguments:


    FieldInfo -- ptr to the table's record field entry.
    JSetColumn -- ptr to the table's JET_SETCOLUMN entry for this field.
    JColDesc -- ptr to the table's JET_COLUMNCREATE entry for this field.
    TableName -- name of table for error messages.

Return Value:

    The field size to use for the insert.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsFieldDataSize:"

    ULONG  DataSize;
    ULONG  DataType = (ULONG) MaskPropFlags(FieldInfo->DataType);
    BOOL   Spare = IsSpareField(FieldInfo->DataType);


    //
    // Obscure table in jet doc says itag sequence must be >0 to overwrite a
    // long value column.
    //
    if ((JColDesc->coltyp == JET_coltypLongText) ||
        (JColDesc->coltyp == JET_coltypLongBinary)) {
        JSetColumn->itagSequence = 1;
    }

    //
    // Check if field buffer has been deleted.
    //
    if (JSetColumn->pvData == NULL) {
        return 0;
    }

    //
    // Strings.
    //
    if ((DataType == DT_UNICODE)   ||
        (DataType == DT_DIR_PATH)  ||
        (DataType == DT_FILE_LIST) ||
        (DataType == DT_FILENAME)) {
        DataSize = Spare ? 0 : 2 * (wcslen(JSetColumn->pvData) + 1);
    } else

    //
    // Fields with Variable sized buffers.
    // *** WARNING ***
    //
    // If the record structure field size is less than the max column width AND
    // is big enough to hold a pointer AND has a datatype of DT_BINARY then the
    // record is assumed to be variable length.  The record insert code
    // automatically adjusts the length from the record's Size prefix.  All
    // DT_BINARY fields MUST BE prefixed with a ULONG SIZE.  There are some
    // fields that are variable length which don't have a size prefix like
    // FSVolInfo in the config record.  But these fields MUST have a unique / non
    // binary data type assigned to them.  Failure to do this causes the insert
    // routines to stuff things up to ColMaxWidth bytes into the database.
    //

    if (FIELD_IS_PTR(FieldInfo->Size, JColDesc->cbMax) &&
        FIELD_DT_IS_BINARY(DataType)) {

        DataSize = Spare ? 0 : *(PULONG)(JSetColumn->pvData);
    } else

    //
    // Fields with fixed Size buffers with var len data.
    //
    // The record field is not a pointer but if the column type is LongBinary
    // then, as above, the first ULONG of data must be the valid data
    // length in the fixed sized buffer.  An example of this is the
    // IDTable record extension fields.  They use a compiled
    // in field size in the record struct declarations but in the Jet schema
    // they are defined as JET_coltypLongBinary with a max size of 2 Meg.
    // The length prefix tells us how much to write.
    //
    // Note: For backward compatibility of new versions of FRS running with
    // with databases written by older versions of FRS it is required that
    // the structure size declarations for fields like the above NEVER get
    // smaller in size.
    //
    if ((JColDesc->coltyp == JET_coltypLongBinary) &&
        IsFixedSzBufferField(FieldInfo->DataType)) {

        DataSize = Spare ? 0 : *(PULONG)(JSetColumn->pvData);
    } else
    if (DataType == DT_FSVOLINFO) {
        //
        // This is a case of fixed size field with a ptr in the base record
        // to a fixed size buffer.   There is no length prefix.
        // DbsAllocRecordStorage() will have called DbsReallocateFieldBuffer()
        // to allocate the buffer and sets JSet/RetColumn.cbData to the
        // allocated size.
        //
        DataSize = JSetColumn->cbData;
    } else {
        //
        // Fixed Size field.
        //
        DataSize = FieldInfo->Size;
    }

    if (DataSize > JColDesc->cbMax) {
        DPRINT4(0, "++ ERROR - DbsFieldDataSize() Failed on %s. Field (%s) too long: %d.  Set to %d.\n",
                TableName, JColDesc->szColumnName, DataSize, JColDesc->cbMax);
        DPRINT(0, "++ Internal error or field max width in schema must increase.\n");
        DataSize = JColDesc->cbMax;
    }

    return DataSize;
}

VOID
DbsSetJetColAddr (
    IN PTABLE_CTX TableCtx
    )
/*++

Routine Description:

    Initialize a Jet Set/Ret Column structure with the record field definitions
    in FieldInfo for the record starting at RecordBase.  The SETCOLUMN struct
    is used in Jet update and retrieval requests to tell Jet where the record
    data is or where to store the data retrieved.

    You must reinitialize the addresses any time you change record buffers to
    point at the new buffer.

Arguments:

    TableCtx  -- The table context struct which contains:

                FieldInfo  - Array of structs describing the size and offset
                             of each field.

                RecordBase - The base address of the record buffer to
                             read/write from/to jet.

                JTableCreate - The table create structure which provides info
                               about the columns that were created in the table.

                JSetColumn - The JET_SETCOLUMN struct array to be initialized.
                             NULL if not provided.

                JRetColumn - The JET_RETRIEVECOLUMN struct array to initialize.
                             NULL if not provided.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsSetJetColAddr:"

    ULONG i;
    ULONG NumberFields;

    PRECORD_FIELDS FieldInfo;
    PVOID RecordBase;
    PJET_TABLECREATE JTableCreate;
    PJET_SETCOLUMN JSetColumn;
    PJET_RETRIEVECOLUMN JRetColumn;
    PJET_COLUMNCREATE JColDesc;

    //
    // Point to the table create struct for column info and the
    // pointer to the record fields struct.
    //
    JTableCreate = TableCtx->pJetTableCreate;
    FieldInfo = TableCtx->pRecordFields + 1;  // skip elt 0.

    //
    // Get ptr to base of the data record.
    //
    RecordBase = TableCtx->pDataRecord;

    //
    // Get ptrs to the Jet Set/Ret column arrays.
    //
    JSetColumn = TableCtx->pJetSetCol;
    JRetColumn = TableCtx->pJetRetCol;

    //
    // Get the column descriptor information.
    //
    JColDesc =  JTableCreate->rgcolumncreate;

    //
    // The first FieldInfo record contains the length.
    //
    NumberFields = (ULONG) TableCtx->pRecordFields[0].Size;
    if (NumberFields != JTableCreate->cColumns) {
        DPRINT3(0, "++ ERROR - Missmatch between FieldInfo.Size (%d) and cColumns (%d) for table %s.  Check Schema.\n",
                NumberFields, JTableCreate->cColumns, JTableCreate->szTableName);
    }

    if (JSetColumn != NULL) {
        for (i=0; i<NumberFields; i++) {
            //
            // If the field size in the record is less than the max for the
            // column then then leave pvData alone.  The caller will allocate
            // a buffer and put a pointer to it in the record.
            // If field is marked as a fixed size buffer then use fixed buffer.
            //
            if ((FieldInfo[i].Size >= JColDesc[i].cbMax) ||
                IsFixedSzBufferField(FieldInfo[i].DataType)) {
                JSetColumn[i].pvData = (PCHAR) RecordBase + FieldInfo[i].Offset;
            }
        }
    }


    if (JRetColumn != NULL) {
        for (i=0; i<NumberFields; i++) {

            if ((FieldInfo[i].Size >= JColDesc[i].cbMax) ||
                IsFixedSzBufferField(FieldInfo[i].DataType)) {
                JRetColumn[i].pvData = (PCHAR) RecordBase + FieldInfo[i].Offset;
            }
        }
    }
}




VOID
DbsSetJetColSize(
    IN PTABLE_CTX TableCtx
    )
/*++

Routine Description:

    This routine initializes columnID and other misc fields in a Jet Set/Ret Col
    structures for a given table so we can use this to set and retrieve multiple
    columns in a single Jet call.


Arguments:

    TableCtx  -- The table context struct which contains:

                FieldInfo  - Array of structs describing the size and offset
                             of each field.

                JTableCreate - The table create structure which provides info
                               about the columns that were created in the table.

                JSetColumn - The JET_SETCOLUMN struct array to be initialized.
                             NULL if not provided.

                JRetColumn - The JET_RETRIEVECOLUMN struct array to initialize.
                             NULL if not provided.

Return Value:

    none.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsSetJetColSize:"

    ULONG MaxCols;
    ULONG i;

    PRECORD_FIELDS FieldInfo;
    PJET_TABLECREATE JTableCreate;
    PJET_SETCOLUMN JSetColumn;
    PJET_RETRIEVECOLUMN JRetColumn;
    PJET_COLUMNCREATE JColDesc;

    //
    // Point to the table create struct for column info and the
    // pointer to the record fields struct.
    //
    JTableCreate = TableCtx->pJetTableCreate;
    FieldInfo = TableCtx->pRecordFields + 1;  // skip elt 0

    //
    // Get ptrs to the Jet Set/Ret column arrays.
    //
    JSetColumn = TableCtx->pJetSetCol;
    JRetColumn = TableCtx->pJetRetCol;

    //
    // Get the column descriptor information.
    //
    MaxCols = JTableCreate->cColumns;
    JColDesc =  JTableCreate->rgcolumncreate;


    //
    // Copy Jet's column ids from the column descriptior to the set column array
    // and set the data width of each column.
    //
    if (JSetColumn != NULL) {
        for (i=0; i<MaxCols; i++) {
            JSetColumn->columnid = JColDesc->columnid;
            //
            // If the field size in the record is less than the max for the
            // column then leave cbData alone.  The caller will allocate
            // a buffer and put a pointer to it in the record.
            // If field is marked as a fixed size buffer then use FieldInfo size.
            //
            if ((FieldInfo[i].Size >= JColDesc->cbMax) ||
                IsFixedSzBufferField(FieldInfo[i].DataType)) {
                JSetColumn->cbData = FieldInfo[i].Size;
            }
            JSetColumn->grbit = 0;
            JSetColumn->ibLongValue = 0;
            JSetColumn->itagSequence = 0;
            JSetColumn->err = JET_errSuccess;

            JSetColumn += 1;
            JColDesc += 1;
        }
    }


    //
    // Do the same for retreive column array if supplied.
    //

    JColDesc =  JTableCreate->rgcolumncreate;

    if (JRetColumn != NULL) {
        for (i=0; i<MaxCols; i++) {
            JRetColumn->columnid = JColDesc->columnid;

            if ((FieldInfo[i].Size >= JColDesc->cbMax) ||
                IsFixedSzBufferField(FieldInfo[i].DataType)) {
                JRetColumn->cbData = FieldInfo[i].Size;
            }
            JRetColumn->grbit = 0;
            JRetColumn->ibLongValue = 0;
            //
            // A zero for itagSequence tells jet to return the number of
            // occurances in a column. For tagged columns (not used here)
            // the value tells jet which of the multi-values to retrieve.
            // To get the data back for fixed and variable columns set this
            // to any non-zero value.
            //
            JRetColumn->itagSequence = 1;
            JRetColumn->columnidNextTagged = 0;
            JRetColumn->err = JET_errSuccess;

            JRetColumn += 1;
            JColDesc += 1;
        }
    }
}





NTSTATUS
DbsAllocRecordStorage(
    IN OUT PTABLE_CTX TableCtx
    )
/*++

Routine Description:

    This routine allocates the storage buffers for the variable length columns
    in which the record field size is supplied as 4 bytes (to hold a ptr).
    The buffer pointers are stored in the record using the FieldInfo offset and
    in the JSetColumn/JRetColumn structs if supplied.

    If the record field is non-null a new buffer is not allocated.  A consistency
    check is made with the pvData fields in the Set/Ret column structs with
    the ptr in the record field.  If they don't match the ptr in the record
    field is used and the old buffer is freed.

    If the record field is null and there is a non-null buffer pointer
    in either the Jet Set/Ret Column structs then that buffer is used.

    Otherwise a new buffer is allocated using the default size in
    JColDesc[i].cbMax.

Arguments:

    TableCtx  -- The table context struct which contains:

                FieldInfo  - Array of structs describing the size and offset
                             of each field.

                RecordBase - The base address of the record buffer to
                             read/write from/to jet.

                JTableCreate - The table create structure which provides info
                               about the columns that were created in the table.

                JSetColumn - The JET_SETCOLUMN struct array to be initialized.
                             NULL if not provided.

                JRetColumn - The JET_RETRIEVECOLUMN struct array to initialize.
                             NULL if not provided.
Return Value:

    STATUS_INSUFFICIENT_RESOURCES if malloc fails.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsAllocRecordStorage:"

    ULONG MaxCols;
    ULONG i;
    ULONG InitialSize;
    PVOID Buf;
    PVOID *RecordField;
    PVOID pRData;
    PVOID pSData;

    PRECORD_FIELDS      FieldInfo;
    PVOID               RecordBase;
    PJET_TABLECREATE    JTableCreate;
    PJET_SETCOLUMN      JSetColumn;
    PJET_RETRIEVECOLUMN JRetColumn;
    PJET_COLUMNCREATE   JColDesc;
    JET_ERR             jerr;

    //
    // Point to the table create struct for column info and the
    // pointer to the record fields struct.
    //
    JTableCreate = TableCtx->pJetTableCreate;
    FieldInfo = TableCtx->pRecordFields + 1;   // jump over elt 0

    //DPRINT2(5, "++ Get record storage for Table %s, pTableCtx %08x\n",
    //        JTableCreate->szTableName, TableCtx);

    //
    // Get ptr to base of the data record.
    //
    RecordBase = TableCtx->pDataRecord;

    //
    // Get ptrs to the Jet Set/Ret column arrays.
    //
    JSetColumn = TableCtx->pJetSetCol;
    JRetColumn = TableCtx->pJetRetCol;

    //
    // Get the column descriptor information.
    //
    MaxCols = JTableCreate->cColumns;
    JColDesc =  JTableCreate->rgcolumncreate;

    for (i=0; i<MaxCols; i++) {

        //
        // If the record structure field size is less than the max column width
        // and is big enough to hold a pointer then allocate the storage for
        // for the field and set the record pointer to point at it.
        // Cap the initial allocation at INITIAL_BINARY_FIELD_ALLOCATION.
        // The field max is set for the Jet Column which is usually much
        // larger.
        //

        if (FIELD_IS_PTR(FieldInfo[i].Size, JColDesc[i].cbMax)) {

            //
            // If the field is marked as spare then don't allocate any buffer
            // space for it.  Spare fields are allocated in Jet's database
            // record structure to avoid the necessity of frequent DB upgrades.
            // To use a spare field in the future clear the spare bit in the
            // record field struct.
            //
            if (IsSpareField(FieldInfo[i].DataType)) {
                continue;
            }

            //
            // If the record field is unaligned then complain and skip it.
            //
            RecordField = (PVOID *) ((PCHAR) RecordBase + FieldInfo[i].Offset);

            if (!ValueIsMultOf4(RecordField)) {
                DPRINT3(0, "++ ERROR - Unaligned ptr to record field %s. base/offset = %08x/%08x\n",
                        JColDesc[i].szColumnName, RecordBase, FieldInfo[i].Offset);
                continue;
            }


            pSData = (PVOID) ((JSetColumn != NULL) ? JSetColumn[i].pvData : NULL);
            pRData =          (JRetColumn != NULL) ? JRetColumn[i].pvData : NULL;

            //
            // If the record field is non-null then it has a buffer assigned.
            // Don't allocate another.  Check consistency with Set/Ret
            // pvData pointers though and do fixup.
            //
            if (*RecordField != NULL) {
                if (pSData != *RecordField) {
                    if (pSData != NULL) {
                        DPRINT3(3, "++ Warning - New binary field buffer (%08x) provided for %s. Old write buffer (%08x) replaced\n",
                                *RecordField, JColDesc[i].szColumnName, pSData);
                        FrsFree(pSData);
                    } else {
                        DPRINT2(3, "++ New binary field buffer (%08x) provided for %s.\n",
                                *RecordField, JColDesc[i].szColumnName);
                    }
                    JSetColumn[i].pvData = *RecordField;
                }

                if (pRData != *RecordField) {
                    if ((pRData != NULL) && (pRData != pSData)) {
                        DPRINT3(3, "++ Warning - New binary field buffer (%08x) provided for %s. Old read buffer (%08x) replaced\n",
                                *RecordField, JColDesc[i].szColumnName, pRData);
                        FrsFree(pRData);
                    } else {
                        DPRINT2(3, "++ New binary field buffer (%08x) provided for %s.\n",
                                *RecordField, JColDesc[i].szColumnName);
                    }
                    JRetColumn[i].pvData = *RecordField;
                }
                continue;
            }

            //
            // RecordField is NULL.  If there is already a buffer allocated
            // then assign it to the record field and don't allocate another.
            //
            if ((pSData != NULL) && (pRData != NULL)) {
                *RecordField = pRData;
                continue;
            }

            //
            // Allocate a new buffer.  cbMax is a column size limit imposed
            // by Jet.  For some columns we want some very large upper bounds
            // but cap the initial allocation at 256 bytes.
            //
            InitialSize = JColDesc[i].cbMax;
            if (InitialSize > INITIAL_BINARY_FIELD_ALLOCATION) {
                InitialSize = INITIAL_BINARY_FIELD_ALLOCATION;
            }
            //
            // Alloc an initial buffer unless NoDefaultAlloc flag is set.
            //
            if (!IsNoDefaultAllocField(FieldInfo[i].DataType)) {
                jerr = DbsReallocateFieldBuffer(TableCtx, i, InitialSize, FALSE);
                if (!JET_SUCCESS(jerr)) {
                    goto ERROR_RET;
                }
            }
        }
    }

    return STATUS_SUCCESS;


ERROR_RET:

    //
    // Free any runtime allocated record buffers.
    //
    DbsFreeRecordStorage(TableCtx);

    return STATUS_INSUFFICIENT_RESOURCES;
}



VOID
DbsFreeRecordStorage(
    IN PTABLE_CTX TableCtx
    )
/*++

Routine Description:

    This routine frees the storage buffers for the variable length columns.
    These are identified by a field size of 4 bytes (to hold a PVOID) and
    a maximum column size that is larger.
    If the pointer is null in the JSetColumn and/or the JRetColumn structs
    then the buffer has been taken and the taker will free it.  The pointer
    in the data record field is also set to null if the buffer is freed.
    This latter is done by DbsReallocateFieldBuffer.

Arguments:

    TableCtx  -- The table context struct which contains:

                FieldInfo  - Array of structs describing the size and offset
                             of each field.

                JTableCreate - The table create structure which provides info
                               about the columns that were created in the table.

Return Value:

    none.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsFreeRecordStorage:"

    ULONG MaxCols;
    ULONG i;

    PRECORD_FIELDS FieldInfo;
    PJET_TABLECREATE JTableCreate;
    PJET_COLUMNCREATE JColDesc;

    //
    // Point to the table create struct for column info and the
    // pointer to the record fields struct.
    //
    JTableCreate = TableCtx->pJetTableCreate;
    FieldInfo = TableCtx->pRecordFields + 1;  // skip elt 0

    if ((JTableCreate == NULL) || (TableCtx->pRecordFields == NULL)) {
        DPRINT2(4, "++ DbsFreeRecordStorage: Null ptr - JTableCreate: %08x, FieldInfo: %08x\n",
                JTableCreate, TableCtx->pRecordFields);
        return;
    }

    //DPRINT2(5, "++ Free record storage for Table %s, pTableCtx %08x\n",
    //        JTableCreate->szTableName, TableCtx);

    //
    // Get the column descriptor information.
    //
    MaxCols = JTableCreate->cColumns;
    JColDesc =  JTableCreate->rgcolumncreate;

    for (i=0; i<MaxCols; i++) {

        //
        // If the record structure field size is less than the max column width
        // and is big enough to hold a pointer then DbsAllocRecordStorage
        // allocated storage for it.
        //
        if (FIELD_IS_PTR(FieldInfo[i].Size, JColDesc[i].cbMax)) {
            //
            // Free the buffer and set the length to zero.
            //
            DbsReallocateFieldBuffer(TableCtx, i, 0, FALSE);
        }
    }
}



JET_ERR
DbsCheckSetRetrieveErrors(
    IN OUT PTABLE_CTX TableCtx
    )
/*++

Routine Description:

    This routine checks the Jet Error returns in the JSetColumn/JRetColumn
    structs.  For variable length fields on retrievals it also checks
    if the buffer size is too small.  If so it allocates a larger buffer and
    refetches the data from jet.

Arguments:

    TableCtx  -- The table context struct which contains:

                JTableCreate - The table create structure which provides info
                               about the columns that were created in the table.

                JSetColumn - The JET_SETCOLUMN struct array to be initialized.
                             NULL if not provided.

                JRetColumn - The JET_RETRIEVECOLUMN struct array to initialize.
                             NULL if not provided.

Return Value:

    Jet Error Status

--*/
{
#undef DEBSUB
#define DEBSUB "DbsCheckSetRetrieveErrors:"

    JET_ERR jerr;
    JET_ERR RetError = JET_errSuccess;
    ULONG MaxCols;
    ULONG i;
    ULONG Actual;

    JET_SESID           Sesid;
    JET_TABLEID         Tid;
    PJET_TABLECREATE    JTableCreate;
    PRECORD_FIELDS      FieldInfo;
    PJET_SETCOLUMN      JSetColumn;
    PJET_RETRIEVECOLUMN JRetColumn;
    PJET_COLUMNCREATE   JColDesc;

    Sesid        = TableCtx->Sesid;
    Tid          = TableCtx->Tid;

    //
    // Point to the table create struct for column info and the
    // pointer to the record fields struct.
    //
    JTableCreate = TableCtx->pJetTableCreate;
    FieldInfo = TableCtx->pRecordFields + 1;   // jump over elt 0

    //
    // Get ptrs to the Jet Set/Ret column arrays.
    //
    JSetColumn = TableCtx->pJetSetCol;
    JRetColumn = TableCtx->pJetRetCol;

    //
    // Get the column descriptor information.
    //
    MaxCols = JTableCreate->cColumns;
    JColDesc =  JTableCreate->rgcolumncreate;

    for (i=0; i<MaxCols; i++) {

        //
        // Skip spare fields.
        //
        if (IsSpareField(FieldInfo[i].DataType)) {
            continue;
        }

        jerr = JET_errSuccess;
        //
        // Look at the error return for the jet set operation.
        //
        if ((JSetColumn != NULL) &&
            (JSetColumn[i].err != JET_wrnColumnNull)) {
            //
            // Check error return on set column
            //
            jerr = JSetColumn[i].err;
            DPRINT1_JS(0, "++ Jet set error for column %s.",
                       JColDesc[i].szColumnName, jerr);
        }

        //
        // Look at the error return for the jet retrieval operation.
        //
        if ((JRetColumn != NULL) && (!JET_SUCCESS(JRetColumn[i].err))) {
            jerr = JRetColumn[i].err;
            //
            // Error return on retrieve column
            //
            // If there wasn't enough room in the buffer for the returned
            // data try to increase the size of the buffer and refetch the
            // data otherwise it's an error.
            //
            if (jerr == JET_wrnBufferTruncated) {
                Actual = JRetColumn[i].cbActual;

                jerr = DbsReallocateFieldBuffer(TableCtx, i, Actual, FALSE);

                if (JET_SUCCESS(jerr)) {
                    //
                    // Now try to go get the data again.
                    //
                    jerr = JetRetrieveColumns(Sesid, Tid, &JRetColumn[i], 1);
                    DPRINT1_JS(0, "++ Jet retrieve error for reallocated column %s.",
                               JColDesc[i].szColumnName, jerr);
                } else
                if (jerr == JET_errInvalidParameter) {
                    //
                    // Buffer wasn't allocated at run time but was too small.
                    // This is a schema def error.
                    //
                    DPRINT1_JS(0, "++ Schema error - Fixed record field too small for %s.",
                               JColDesc[i].szColumnName, jerr);
                }
            } else
            //
            // Null column is not an error but if it is for a fixed sized
            // buffer with a variable length field then zero the buffer.
            //
            if (jerr == JET_wrnColumnNull) {
                if ((IsFixedSzBufferField(FieldInfo[i].DataType)) &&
                    (JColDesc[i].coltyp == JET_coltypLongBinary)) {
                    ZeroMemory(JRetColumn[i].pvData, FieldInfo[i].Size);
                }

                jerr = JET_errSuccess;
            //
            // Some other type of retrieve error.  Complain.
            //
            } else {
                DPRINT1_JS(0, "++ Jet retrieve error for column %s.",
                           JColDesc[i].szColumnName, jerr);
            }
        }
        //
        // Save the first error we were not able to correct.
        //
        RetError = JET_SUCCESS(RetError) ? jerr : RetError;
    }
    //
    // Return the first error we were not able to correct.
    //
    return RetError;

}




JET_ERR
DbsReallocateFieldBuffer(
    IN OUT PTABLE_CTX TableCtx,
    IN ULONG FieldIndex,
    IN ULONG NewSize,
    IN BOOL KeepData
    )
/*++

Routine Description:

    This routine releases the buffer associated with the specified field
    and allocates a new buffer with the desired size.  We update the pointer
    in the data record and the JetSet/RetColumn structs.

Arguments:

    TableCtx  -- The table context struct which contains:

                FieldInfo  - Array of structs describing the size and offset
                             of each field.

                RecordBase - The base address of the record buffer to
                             read/write from/to jet.

                JTableCreate - The table create structure which provides info
                               about the columns that were created in the table.

                JSetColumn - The JET_SETCOLUMN struct array to be initialized.
                             NULL if not provided.

                JRetColumn - The JET_RETRIEVECOLUMN struct array to initialize.
                             NULL if not provided.

    FieldIndex -- The index of the field to change (from the xx_COL_LIST enum).

    NewSize -- The size of the new buffer to allocate.  If NewSize is zero the
               buffer(s) for the field are released and the pointers are
               set to NULL.

    KeepData -- If the NewSize > 0 and KeepData is true then resize the buffer
                but copy the data to the new buffer.  The amount copied is
                min(NewSize, CurrentSize).


Return Value:

    Jet Error Status

--*/
{
#undef DEBSUB
#define DEBSUB "DbsReallocateFieldBuffer:"

    JET_ERR jerr;
    ULONG MaxCols;
    ULONG i;
    ULONG Actual;
    ULONG MoveLength;
    PVOID Buf;
    PVOID *RecordField;
    PVOID ppRF;
    PVOID pRData;
    PVOID pSData;

    PRECORD_FIELDS      FieldInfo;
    PVOID               RecordBase;
    PJET_TABLECREATE    JTableCreate;
    PJET_SETCOLUMN      JSetColumn;
    PJET_RETRIEVECOLUMN JRetColumn;
    PJET_COLUMNCREATE   JColDesc;

    //
    // Point to the table create struct for column info and the
    // pointer to the record fields struct.
    //
    JTableCreate = TableCtx->pJetTableCreate;
    FieldInfo    = TableCtx->pRecordFields + 1;  // skip elt 0

    //
    // Get ptr to base of the data record.
    //
    RecordBase = TableCtx->pDataRecord;

    //
    // Get ptrs to the Jet Set/Ret column arrays.
    //
    JSetColumn = TableCtx->pJetSetCol;
    JRetColumn = TableCtx->pJetRetCol;

    //
    // Get the column descriptor information.
    //
    MaxCols = JTableCreate->cColumns;
    JColDesc =  JTableCreate->rgcolumncreate;

    if (FieldIndex > MaxCols) {
        DPRINT3(0, "++ ERROR - Invalid column index (%d) for Table %s, pTableCtx %08x\n",
                FieldIndex, JTableCreate->szTableName, TableCtx);

        return JET_errInvalidParameter;
    }

    i = FieldIndex;
    Actual = NewSize;

    //
    // Now check if this field even has a runtime allocated buffer.
    //
    if (!FIELD_IS_PTR(FieldInfo[i].Size, JColDesc[i].cbMax)) {
        //
        // Check for a fixed size buffer with a variable sized database column
        // and allow column size to grow up to buffer width.
        //
        if ((IsFixedSzBufferField(FieldInfo[i].DataType)) &&
            (JColDesc[i].coltyp == JET_coltypLongBinary) &&
            (Actual <= FieldInfo[i].Size)) {

            JSetColumn[i].cbData = Actual;
            JRetColumn[i].cbData = Actual;

            return JET_errSuccess;
        } else {
            //
            // Buffer isn't allocated at run time so we can't enlarge it past
            // the field info size.  Return Invalid parameter.
            //
            DPRINT5(0, "++ ERROR - Cannot reallocate fixed record field. Col: %s, base/offset/bufsz/datasz = %08x / %08x / %d / %d\n",
                JColDesc[i].szColumnName, RecordBase, FieldInfo[i].Offset,
                JRetColumn[i].cbData, Actual);

            JSetColumn[i].cbData = FieldInfo[i].Size;
            JRetColumn[i].cbData = FieldInfo[i].Size;

            return JET_errInvalidParameter;
        }
    }


    //
    // Buffer was allocated at run time.  Delete or adjust the buffer size.
    //
    if (Actual > 0) {
        //
        // Reallocate the runtime buffer.
        //
        try {
            Buf = FrsAlloc(Actual);
            //DPRINT5(5, "++ Reallocating record field buffer for %-22s. base/offset/bufsz/datasz = %08x / %08x / %d / %d\n",
            //    JColDesc[i].szColumnName, RecordBase, FieldInfo[i].Offset,
            //    JRetColumn[i].cbData, Actual);
        }
        except(EXCEPTION_EXECUTE_HANDLER) {
            DPRINT1_WS(0, "++ DbsReallocateFieldBuffer realloc failed on size %d :",
                       Actual, GetLastError());
            return JET_errOutOfMemory;
        }
    } else {
        //
        // The request is to delete the buffer.
        //
        Buf = (PVOID) NULL;
        //DPRINT5(5, "++ Releasing record field buffer: %-22s. base/offset/bufsz/datasz = %08x / %08x / %d / %d\n",
        //    JColDesc[i].szColumnName, RecordBase, FieldInfo[i].Offset,
        //    JRetColumn[i].cbData, Actual);
    }


    //
    // We have new buffer.  Free the old one and set ptr to
    // new one in the record field and in the JetRetColumn
    // and SetCol structs.  Set actual size into cbData.
    //
    pSData = (PVOID) ((JSetColumn != NULL) ? JSetColumn[i].pvData : NULL);
    pRData =          (JRetColumn != NULL) ? JRetColumn[i].pvData : NULL;

    RecordField = (PVOID *) ((PCHAR) RecordBase + FieldInfo[i].Offset);

    if (!ValueIsMultOf4(RecordField)) {
        DPRINT3(0, "++ ERROR - Unaligned ptr to record field %s. base/offset = %08x/%08x\n",
                JColDesc[i].szColumnName, RecordBase, FieldInfo[i].Offset);

        Buf = FrsFree(Buf);
        return JET_errInvalidParameter;
    }

    //
    // If we are keeping the data then compare the new length with
    // the length from JSetCol or JRetCol as long as the Record Field
    // pointer matches the respective buffer address.  The size of
    // the buffer in the JSetCol struct has priority.  It is typically
    // the case that the record field pointer and the JSet/RetColumn
    // pointers all point to the same buffer.
    //
    if (KeepData && (RecordBase != NULL)) {
        ppRF = *RecordField;

        if ((ppRF != NULL) && (pSData == ppRF)) {
            MoveLength = min(Actual, JSetColumn[i].cbData);
        } else
        if ((ppRF != NULL) && (pRData == ppRF)) {
            MoveLength = min(Actual, JRetColumn[i].cbData);
        } else {
            MoveLength = 0;
        }
        if (MoveLength > 0) {
            CopyMemory(Buf, ppRF, MoveLength);
        }
    }

    FrsFree(pSData);
    JSetColumn[i].pvData = Buf;
    JSetColumn[i].cbData = Actual;

    if ((pRData != NULL) && (pRData != pSData)) {
        FrsFree(pRData);
    }
    JRetColumn[i].pvData = Buf;
    JRetColumn[i].cbData = Actual;

    //
    // Point the record field at the new buffer.
    //
    if (RecordBase != NULL) {
        *RecordField = Buf;
    }


    return JET_errSuccess;

}





NTSTATUS
DbsAllocTableCtx(
    IN TABLE_TYPE TableType,
    IN OUT PTABLE_CTX TableCtx
    )
/*++

Routine Description:

    This routine allocates memory for a TABLE_CTX struct.  This includes the
    base table record (not including variable len fields) and the
    Jet Set/Ret Column structs.  The allocated memory is zeroed.

Arguments:

    TableType  -- The table context ID number indexes FrsTableProperties.

    TableCtx  -- The table context struct to init.

Return Value:

    STATUS_INSUFFICIENT_RESOURCES if memory alloc fails and any that succeeded
                                  are freed.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsAllocTableCtx:"

    return( DbsAllocTableCtxWithRecord(TableType, TableCtx, NULL));
}


NTSTATUS
DbsAllocTableCtxWithRecord(
    IN TABLE_TYPE TableType,
    IN OUT PTABLE_CTX TableCtx,
    IN PVOID DataRecord
    )
/*++

Routine Description:

    This routine allocates memory for a TABLE_CTX struct.  This includes the
    base table record (not including variable len fields) if DataRecord is
    NULL and the Jet Set/Ret Column structs.  The allocated memory is zeroed.
    If the TableCtx is already initialized and of the same table type then
    we just return after updating the DataRecord pointer if provided.
    If the caller has freed the data record but left the table ctx initialized
    then we allocate a new one here.

    Warning:  THis routine only inits a TableCtx.  The caller must still call:

        DbsSetJetColSize(TableCtx);
        DbsSetJetColAddr(TableCtx);

    to setup the data field addresses for JET and call

        DbsAllocRecordStorage(TableCtx);

    to allocate storage for the variable length fields in the record and
    update the JetSet/RetCol arrays appropriately.

    When done with the TableCtx, close the table and call

        DbsFreeTableCtx(TableCtx, 1);

    to release the all the storage that was allocated.  Note this does not
    free the TableCtx struct itself.  If the TableCtx struct was dynamically
    allocated then a call to DbsFreeTableContext() will close the table and
    then call DbsFreeTableCtx() and FrsFree() on the TableCtx struct.

Arguments:

    TableType  -- The table context ID number indexes FrsTableProperties.

    TableCtx  -- The table context struct to init.

    DataRecord -- The pointer to the inital base data record or NULL if
                  the base data record is allocated here.
                  Warning -- it is up to the caller to ensure that the size
                  of the preallocated data record is correct for the table
                  in question.  No check is make here.

Return Value:

    STATUS_INSUFFICIENT_RESOURCES if memory alloc fails and any that succeeded
                                  are freed.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsAllocTableCtxWithRecord:"


    ULONG NumberColumns;
    ULONG SetColSize;
    ULONG RetColSize;
    ULONG RecordSize;
    PRECORD_FIELDS pRecordFields;


    //DPRINT3(5, "++ Get TableCtx memory for table %s, TableType %d, pTableCtx %08x\n",
    //        DBTables[TableType].szTableName, TableType, TableCtx);

    //if (!ForceInit && (TableCtx->pRecordFields != NULL)) {
    //    return STATUS_SUCCESS;
    //}

    //
    // If table type matches then check the data record and then we are done.
    //
    if (TableCtx->TableType == (ULONG)TableType) {
        //
        // If the data record is gone then allocate a new one.
        // Buffers for variable length fields are added later by  a call
        // to DbsAllocRecordStorage.  Get the base record size from the offset
        // field of element zero of the Record Fields struct for this table.
        // This is a CSHORT so max size is 64KB on base record.
        //
        if (DataRecord == NULL) {
            if (TableCtx->pDataRecord == NULL) {
                RecordSize = (ULONG) TableCtx->pRecordFields->Offset;
                TableCtx->pDataRecord = FrsAlloc(RecordSize);
            }
        } else {
            if ((TableCtx->pDataRecord != NULL) &&
                (TableCtx->pDataRecord != DataRecord)) {
                DPRINT(0, "++ ERROR - Overwriting non-null data record pointer in table ctx.  memory leak??\n");
                DPRINT3(0, "++ For table %s, TableType %d, pTableCtx %08x\n",
                        DBTables[TableType].szTableName, TableType, TableCtx);
            }
            TableCtx->pDataRecord = DataRecord;
        }
        //
        // Table ctx already inited for this table type.
        //
        return STATUS_SUCCESS;
    }


    if (TableType >= TABLE_TYPE_INVALID) {
        DPRINT2(0, "++ ERROR - Invalid Table Type Code: %d, pTableCtx %08x\n",
                TableType, TableCtx);
        FRS_ASSERT(!"Invalid Table Type Code");
        return STATUS_INVALID_PARAMETER;
    }

    try {

        //
        // Get the pointer to the record field definition struct.
        //
        pRecordFields = FrsTableProperties[TableType].RecordFields;
        TableCtx->pRecordFields = pRecordFields;
        //
        // Add the table property fields.
        //
        TableCtx->PropertyFlags = FrsTableProperties[TableType].PropertyFlags;
        //
        // Mark table as not open by a session yet.
        //
        TableCtx->Tid   = JET_tableidNil;
        TableCtx->Sesid = JET_sesidNil;
        TableCtx->ReplicaNumber = FRS_UNDEFINED_REPLICA_NUMBER;
        TableCtx->TableType = TableType;

        //
        // Point to the table create struct for table name and size info and the
        // pointer to the record fields struct.
        //
        TableCtx->pJetTableCreate = &DBTables[TableType];

        //
        // Allocate the initial data record.
        // Buffers for variable length fields are added later by  a call
        // to DbsAllocRecordStorage.  Get the base record size from the offset
        // field of element zero of the Record Fields struct for this table.
        // This is a CSHORT so max size is 64KB on base record.
        //
        if (DataRecord == NULL) {
            RecordSize = (ULONG) pRecordFields->Offset;
            TableCtx->pDataRecord = FrsAlloc(RecordSize);
            SetFlag(TableCtx->PropertyFlags, FRS_TPF_NOT_CALLER_DATAREC);
        } else {
            TableCtx->pDataRecord = DataRecord;
        }

        //
        // Get the number of columns in the table.
        //
        NumberColumns = DBTables[TableType].cColumns;

        //
        // Allocate the Jet Set/Ret column arrays.
        //
        SetColSize = NumberColumns * sizeof(JET_SETCOLUMN);
        TableCtx->pJetSetCol = FrsAlloc(SetColSize);

        RetColSize = NumberColumns * sizeof(JET_RETRIEVECOLUMN);
        TableCtx->pJetRetCol = FrsAlloc(RetColSize);


    }

    except(EXCEPTION_EXECUTE_HANDLER) {

        if (DataRecord == NULL) {
            TableCtx->pDataRecord = FrsFree(TableCtx->pDataRecord);
        }
        TableCtx->pJetSetCol  = FrsFree(TableCtx->pJetSetCol);
        TableCtx->pJetRetCol  = FrsFree(TableCtx->pJetRetCol);

        DPRINT2(0, "++ ERROR - Failed to get TableCtx memory for ID %d, pTableCtx %08x\n",
                 TableType, TableCtx);

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    return STATUS_SUCCESS;

}




VOID
DbsFreeTableCtx(
    IN OUT PTABLE_CTX TableCtx,
    IN ULONG NodeType
    )
/*++

Routine Description:

    This routine frees the memory for a TABLE_CTX struct.  This includes the
    base table record and any variable len fields.
    It marks the freed memory with the hex string 0xDEADBEnn where
    the low byte (nn) is set to the node type being freed to catch users of
    stale pointers.

Arguments:

    TableCtx  -- The table context struct to free.

    NodeType  -- The node type this TABLE_CTX is part of for marking freed mem.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsFreeTableCtx:"

    ULONG NumberColumns = 0;
    ULONG SetColSize;
    ULONG RetColSize;
    ULONG Marker;
    PJET_TABLECREATE JTableCreate;
    PJET_SETCOLUMN JSetColumn;
    PJET_RETRIEVECOLUMN JRetColumn;
    PCHAR BaseTableName;
    ULONG RecordSize;

    if (TableCtx == NULL) {
        DPRINT(0, "++ ERROR - DbsFreeTableCtx TableCtx ia null\n");
        return;
    }

    //
    // If the TableCtx was never allocated then return quietly.
    //
    if (IS_INVALID_TABLE(TableCtx)) {
        return;
    }

    if (!IS_REPLICA_TABLE(TableCtx->TableType)) {
        DPRINT2(3, "++ ERROR - DbsFreeTableCtx TableCtx, bad TableType (%d)\n",
                TableCtx, TableCtx->TableType);
        return;
    }

    JTableCreate = TableCtx->pJetTableCreate;
    if (IS_TABLE_OPEN(TableCtx)) {
        BaseTableName = JTableCreate->szTableName;
        DPRINT2(0, "++ ERROR - DbsFreeTableCtx called with %s%05d table still open\n",
               BaseTableName, TableCtx->ReplicaNumber);
        return;
    }

    //
    // Fill the node with a marker then free it.
    //
    Marker = (ULONG)0xDEADBE00 + NodeType;

    //
    // Release the buffer storage for the record's variable len fields.
    // Then free the base data record.  If the data record pointer is null
    // then the caller has taken the record and will handle freeing the memory.
    // If the caller supplied the data record then we do not free it here.
    //
    if ((TableCtx->pDataRecord != NULL) &&
        BooleanFlagOn(TableCtx->PropertyFlags, FRS_TPF_NOT_CALLER_DATAREC)) {
        //
        // Get the base record size from the offset field of the
        // first Record Fields entry.
        //
        RecordSize = (ULONG) (TableCtx->pRecordFields->Offset);
        DbsFreeRecordStorage(TableCtx);
        FillMemory(TableCtx->pDataRecord, RecordSize, (BYTE)Marker);
        TableCtx->pDataRecord = FrsFree(TableCtx->pDataRecord);
    }

    //
    // Get the number of columns in the table.
    //
    if (JTableCreate != NULL) {
        NumberColumns = JTableCreate->cColumns;
    }

    //
    // Get ptrs to the Jet Set/Ret column arrays.
    //
    JSetColumn = TableCtx->pJetSetCol;
    JRetColumn = TableCtx->pJetRetCol;

    //
    // Free the Jet Set column array.
    //
    if (JSetColumn != NULL) {
        if (NumberColumns == 0) {
            DPRINT2(0, "++ ERROR - Possible memory leak. NumberColumns zero but pJetSetCol: %08x  Table: %s\n",
                   JSetColumn, JTableCreate->szTableName);
        }
        SetColSize = NumberColumns * sizeof(JET_SETCOLUMN);

        FillMemory(JSetColumn, SetColSize, (BYTE)Marker);
        TableCtx->pJetSetCol = FrsFree(JSetColumn);
    }

    //
    // Free the Jet Ret column array.
    //
    if (JRetColumn != NULL) {
        if (NumberColumns == 0) {
            DPRINT2(0, "++ ERROR - Possible memory leak. NumberColumns zero but pJetRetCol: %08x  Table: %s\n",
                   JRetColumn, JTableCreate->szTableName);
        }
        RetColSize = NumberColumns * sizeof(JET_RETRIEVECOLUMN);

        FillMemory(JRetColumn, RetColSize, (BYTE)Marker);
        TableCtx->pJetRetCol = FrsFree(JRetColumn);
    }

    //
    // Mark table as not open and storage freed.
    //
    TableCtx->Tid = JET_tableidNil;
    TableCtx->Sesid = JET_sesidNil;
    TableCtx->pJetTableCreate = NULL;
    TableCtx->PropertyFlags = FRS_TPF_NONE;
    TableCtx->TableType = TABLE_TYPE_INVALID;
    TableCtx->pRecordFields = NULL;

    return;

}


VOID
DbsDisplaySchedule(
    IN ULONG        Severity,
    IN PCHAR        Debsub,
    IN ULONG        LineNo,
    IN PWCHAR       Header,
    IN PSCHEDULE    Schedule
    )
/*++

Routine Description:

    Print the schedule.

Arguments:

    Severity
    Debsub
    Header
    Schedule

Return Value:

    none.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsDisplaySchedule:"
    ULONG   i;

    //
    // Don't print this
    //
    if (!DoDebug(Severity, Debsub))
        return;

    //
    // Get debug lock so our output stays in one piece.
    //
    DebLock();

    DebPrintNoLock(Severity, TRUE, "%ws\n", Debsub, LineNo, Header);
    if (Schedule == NULL) {
        DebUnLock();
        return;
    }

    DebPrintNoLock(Severity, TRUE,
                   "\tBandwidth        : %d\n",
                   Debsub, LineNo,
                   Schedule->Bandwidth);
    DebPrintNoLock(Severity, TRUE,
                   "\tNumberOfSchedules: %d\n",
                   Debsub, LineNo,
                   Schedule->NumberOfSchedules);
    for (i = 0; i < Schedule->NumberOfSchedules; ++i) {
        DebPrintNoLock(Severity, TRUE,
                       "\t\tType: %d\n",
                       Debsub, LineNo,
                       Schedule->Schedules[i].Type);
        DebPrintNoLock(Severity, TRUE,
                       "\t\tOffset: %d\n",
                       Debsub, LineNo,
                       Schedule->Schedules[i].Offset);
    }
    DebUnLock();
}


VOID
DbsDisplayRecord(
    IN ULONG       Severity,
    IN PTABLE_CTX  TableCtx,
    IN BOOL        Read,
    IN PCHAR       Debsub,
    IN ULONG       uLineNo,
    IN PULONG      RecordFieldx,
    IN ULONG       FieldCount
    )
/*++

Routine Description:

    This routine displays the contents of the data record on stdout.
    It uses the field addresses in the JRetColumn struct to access the
    data.  The data type for the display comes from FieldInfo.DataType.

Arguments:

    Severity -- Severity level for print.  (See debug.c, debug.h)
    TableCtx  -- The table context struct which contains:

                FieldInfo  - Array of structs describing the size and offset
                             of each field.

                RecordBase - The base address of the record buffer to
                             read/write from/to jet.

                JTableCreate - The table create structure which provides info
                               about the columns that were created in the table.

                JRetColumn - The JET_RETRIEVECOLUMN struct array to initialize.
                             NULL if not provided.

    Read -- If true then display using the Jet Ret\col info else use Jet Set col info.
    Debsub -- Name of calling subroutine.
    uLineno -- Line number of caller
    RecordFieldx -- ptr to an array of field ids for the columns to display.
    FieldCount -- Then number of field entries in the RecordFieldx array.

MACRO:  FRS_DISPLAY_RECORD
MACRO:  DBS_DISPLAY_RECORD_SEV
MACRO:  DBS_DISPLAY_RECORD_SEV_COLS

Return Value:

    none.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsDisplayRecord:"

    ULONG MaxCols;
    ULONG i, j, k, ULong, *pULong;
    PVOID pData;
    ULONG DataType;
    JET_ERR jerr;

    PRECORD_FIELDS FieldInfo;
    PJET_TABLECREATE JTableCreate;
    PJET_RETRIEVECOLUMN JRetColumn;
    PJET_SETCOLUMN    JSetColumn;
    PJET_COLUMNCREATE JColDesc;

    PVOID RecordBase;
    PVOID RecordField;

    PREPLICA Replica;
    PWCHAR WStr;
    PDATA_EXTENSION_PREFIX ComponentPrefix;
    PDATA_EXTENSION_CHECKSUM DataChkSum;
    PULONG pOffset;
    PIDTABLE_RECORD_EXTENSION IdtExt;
    PCHANGE_ORDER_RECORD_EXTENSION CocExt;

    ULONG Len;
    CHAR  TimeStr[TIME_STRING_LENGTH];
    PFILE_FS_VOLUME_INFORMATION Fsvi;
    CHAR  GuidStr[GUID_CHAR_LEN];
    CHAR TableName[JET_cbNameMost];
    CHAR FlagBuffer[120];

    //
    // Don't print this
    //
    if (!DoDebug(Severity, Debsub))
        return;

    //
    // Get debug lock so our output stays in one piece.
    //
    DebLock();

    //
    // Point to the table create struct for column info and the
    // pointer to the record fields struct.
    // Get ptr to base of the data record.
    //
    JTableCreate = TableCtx->pJetTableCreate;
    FieldInfo    = TableCtx->pRecordFields + 1;  // skip elt 0
    JRetColumn   = TableCtx->pJetRetCol;
    JSetColumn   = TableCtx->pJetSetCol;
    RecordBase   = TableCtx->pDataRecord;
    //
    // If the info isn't there then we can't do it.
    //
    if ((JTableCreate == NULL)            ||
        (TableCtx->pRecordFields == NULL) ||
        (RecordBase == NULL)              ||
        (JSetColumn == NULL)              ||
        (JRetColumn == NULL)) {
        DebUnLock();
        DPRINT5(4, "Null ptr - JTableCreate: %08x, FieldInfo: "
                   "%08x, JRetColumn: %08x, JSetColumn: %08x, "
                   "RecordBase: %08x\n",
                JTableCreate, TableCtx->pRecordFields, JRetColumn,
                JSetColumn, RecordBase);
        return;
    }

    //
    // Get the column descriptor information.
    //
    MaxCols  = JTableCreate->cColumns;
    JColDesc = JTableCreate->rgcolumncreate;


    if (BooleanFlagOn(TableCtx->PropertyFlags, FRS_TPF_SINGLE)) {
        strcpy(TableName, JTableCreate->szTableName);
    } else {
        sprintf(TableName, "%s%05d",
                JTableCreate->szTableName, TableCtx->ReplicaNumber);
    }

    DebPrintNoLock(Severity, TRUE,
                   "Data Record for Table: ...%s...   ===   "
                   "===   ===   ===   ===   ===\n\n",
                   Debsub, uLineNo, TableName);

    //
    // Loop through the columns and print each one.
    //
    for (j=0; j<MaxCols; j++) {
        //
        // Use the selected col list if provided.
        //
        if (RecordFieldx != NULL) {
            if (j >= FieldCount) {
                break;
            }

            i = RecordFieldx[j];

            if (i > MaxCols) {
                DebPrintNoLock(Severity,
                               TRUE,
                               "ERROR - Bad field index: %d\n",
                               Debsub,
                               uLineNo,
                               i);
                continue;
            }
        } else {
            i = j;
        }

        //
        // Skip the spare fields.
        //
        if (IsSpareField(FieldInfo[i].DataType)) {
            continue;
        }

        //
        // If Read is True then use the info in the JetRetColumn struct.
        //
        if (Read) {
            Len   = JRetColumn[i].cbActual;
            pData = JRetColumn[i].pvData;
            jerr  = JRetColumn[i].err;
        } else {
            Len   = JSetColumn[i].cbData;
            pData = (PVOID) JSetColumn[i].pvData;
            jerr  = JSetColumn[i].err;
        }

        DebPrintNoLock(Severity, TRUE, "%-23s | Len/Ad/Er: %4d/%8x/%2d, ",
                       Debsub, uLineNo,
                       JColDesc[i].szColumnName, Len, pData, jerr);

        if (pData == NULL) {
            DebPrintNoLock(Severity, FALSE, "<NullPtr>\n", Debsub, uLineNo);
            continue;
        } else
        if (jerr == JET_wrnBufferTruncated) {
            DebPrintNoLock(Severity, FALSE, "<JET_wrnBufferTruncated>\n", Debsub, uLineNo);
            continue;
        } else
        if (jerr == JET_wrnColumnNull) {
            DebPrintNoLock(Severity, FALSE, "<JET_wrnColumnNull>\n", Debsub, uLineNo);
            continue;
        } else
        if (!JET_SUCCESS(jerr)) {
            DebPrintNoLock(Severity, FALSE, "<not JET_errSuccess>\n", Debsub, uLineNo);
            continue;
        }

        DataType = MaskPropFlags(FieldInfo[i].DataType);

#define FRS_DEB_PRINT(_f, _d) \
        DebPrintNoLock(Severity, FALSE, _f, Debsub, uLineNo, _d)

        switch (DataType) {

        case DT_UNSPECIFIED:

            FRS_DEB_PRINT("%08x\n",  *(ULONG *)pData);
            break;

        case DT_NULL:

            FRS_DEB_PRINT("DT_NULL\n",  NULL);
            break;

        case DT_I2:

            FRS_DEB_PRINT("%8d\n",  *(SHORT *)pData);
            break;

        case DT_LONG:

            FRS_DEB_PRINT("%8d\n",  *(LONG *)pData);
            break;

        case DT_ULONG:

            FRS_DEB_PRINT("%08x\n",  *(ULONG *)pData);
            break;

        case DT_R4:

            FRS_DEB_PRINT("%08x\n",  *(ULONG *)pData);
            break;

        case DT_DOUBLE:

            FRS_DEB_PRINT("%016Lx\n",  *(LONGLONG *)pData);
            break;

        case DT_CURRENCY:

            FRS_DEB_PRINT("%8Ld\n",  *(LONGLONG *)pData);
            break;

        case DT_APDTIME:

            FRS_DEB_PRINT("%08x\n",  *(ULONG *)pData);
            break;

        case DT_ERROR:

            FRS_DEB_PRINT("%08x\n",  *(ULONG *)pData);
            break;

        case DT_BOOL:

            FRS_DEB_PRINT("%08x\n",  *(ULONG *)pData);
            break;

        case DT_OBJECT:

            FRS_DEB_PRINT("%08x\n",  *(ULONG *)pData);
            break;

        case DT_I8:

            FRS_DEB_PRINT("%8Ld\n",  *(LONGLONG *)pData);
            break;

        case DT_X8:
        case DT_USN:

            DebPrintNoLock(Severity, FALSE, "%08x %08x\n", Debsub, uLineNo,
                           *(((ULONG *) pData)+1), *(ULONG *)pData);
            break;

        case DT_STRING8:

            if (Len == 0) {
                DebPrintNoLock(Severity, FALSE, "<null len string>\n", Debsub, uLineNo);
            } else

            if ((((CHAR *)pData)[Len-1]) != '\0') {
                DebPrintNoLock(Severity, FALSE, "<not null terminated>\n", Debsub, uLineNo);
            } else {
                FRS_DEB_PRINT("%s\n",  (CHAR *)pData);
            }
            break;

        case DT_UNICODE:
        case DT_FILENAME:
        case DT_FILE_LIST:
        case DT_DIR_PATH:

            if (Len == 0) {
                DebPrintNoLock(Severity, FALSE, "<null len string>\n", Debsub, uLineNo);
            } else

            if ((((WCHAR *)pData)[(Len/sizeof(WCHAR))-1]) != UNICODE_NULL) {
                DebPrintNoLock(Severity, FALSE, "<not null terminated>\n", Debsub, uLineNo);
            } else {
                FRS_DEB_PRINT("%ws\n",  (WCHAR *)pData);
            }

            break;

        case DT_FILETIME:

            FileTimeToString((PFILETIME) pData, TimeStr);
            FRS_DEB_PRINT("%s\n", TimeStr);
            break;

        case DT_GUID:

            GuidToStr((GUID *) pData, GuidStr);
            FRS_DEB_PRINT("%s\n",  GuidStr);
            break;

        case DT_BINARY:

            FRS_DEB_PRINT("%08x\n",  *(ULONG *)pData);
            break;

        case DT_OBJID:

            GuidToStr((GUID *) pData, GuidStr);
            FRS_DEB_PRINT("%s\n",  GuidStr);
            break;

        case DT_FSVOLINFO:

            Fsvi = (PFILE_FS_VOLUME_INFORMATION) pData;

            DebPrintNoLock(Severity, FALSE,
                           "%ws (%d), %s, VSN: %08X, VolCreTim: ",
                           Debsub, uLineNo,
                           Fsvi->VolumeLabel,
                           Fsvi->VolumeLabelLength,
                           (Fsvi->SupportsObjects ? "(obj)" : "(no-obj)"),
                           Fsvi->VolumeSerialNumber);

            FileTimeToString((PFILETIME) &Fsvi->VolumeCreationTime, TimeStr);
            FRS_DEB_PRINT("%s\n", TimeStr);
            break;

        case DT_IDT_FLAGS:
            //
            // Decode and print the flags field in the IDTable record.
            //
            FrsFlagsToStr(*(ULONG *)pData, IDRecFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
            DebPrintNoLock(Severity, FALSE, "%08x Flags [%s]\n", Debsub, uLineNo,
                           *(ULONG *)pData, FlagBuffer);
            break;

        case DT_COCMD_FLAGS:
            //
            // Decode and print the flags field in the ChangeOrder record.
            //
            FrsFlagsToStr(*(ULONG *)pData, CoFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
            DebPrintNoLock(Severity, FALSE, "%08x Flags [%s]\n", Debsub, uLineNo,
                           *(ULONG *)pData, FlagBuffer);

            break;

        case DT_USN_FLAGS:
            //
            // Decode and print the USN Reason field in the USN Record.
            //
            FrsFlagsToStr(*(ULONG *)pData, UsnReasonNameTable, sizeof(FlagBuffer), FlagBuffer);
            DebPrintNoLock(Severity, FALSE, "%08x Flags [%s]\n", Debsub, uLineNo,
                           *(ULONG *)pData, FlagBuffer);

            break;

        case DT_CXTION_FLAGS:
            //
            // Decode and print the flags field in the connection record.
            //
            FrsFlagsToStr(*(ULONG *)pData, CxtionFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
            DebPrintNoLock(Severity, FALSE, "%08x Flags [%s]\n", Debsub, uLineNo,
                           *(ULONG *)pData, FlagBuffer);
            break;

        case DT_FILEATTR:
            //
            // Decode and print the file attributes field in IDTable and ChangeOrder records.
            //
            FrsFlagsToStr(*(ULONG *)pData, FileAttrFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
            DebPrintNoLock(Severity, FALSE, "%08x Flags [%s]\n", Debsub, uLineNo,
                           *(ULONG *)pData, FlagBuffer);
            break;

        case DT_COSTATE:

            ULong = *(ULONG *)pData;
            DebPrintNoLock(Severity, FALSE, "%08x  CO STATE:  %s\n", Debsub, uLineNo,
                           ULong,
                           (ULong <= IBCO_MAX_STATE) ? IbcoStateNames[ULong] : "INVALID STATE");
            break;

        case DT_COCMD_IFLAGS:
            //
            // Decode and print the Iflags field in the ChangeOrder record.
            //
            FrsFlagsToStr(*(ULONG *)pData, CoIFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
            DebPrintNoLock(Severity, FALSE, "%08x Flags [%s]\n", Debsub, uLineNo,
                           *(ULONG *)pData, FlagBuffer);

            break;

        case DT_CO_LOCN_CMD:
            //
            // Decode and print the change order location command.
            //
            ULong = *(ULONG *)pData;
            k = ((PCO_LOCATION_CMD)(pData))->Command;

            DebPrintNoLock(Severity, FALSE, "%08x  D/F %d   %s\n", Debsub, uLineNo,
                           ULong,
                           ((PCO_LOCATION_CMD)(pData))->DirOrFile,
                           (k <= CO_LOCATION_NUM_CMD) ? CoLocationNames[k] : "Invalid Location Cmd");
            break;

        case DT_REPLICA_ID:
            //
            // Translate the replica ID number to a name.
            //
            ULong = *(ULONG *)pData;
            WStr = L"???";
#if 0
            //
            // Note: can't get the lock below since we will hang.
            // Need another way to get the replica name.
            //
            Replica = RcsFindReplicaById(ULong);
            if ((Replica != NULL) &&
                (Replica->ReplicaName != NULL) &&
                (Replica->ReplicaName->Name != NULL)){
                WStr = Replica->ReplicaName->Name;
            }
#endif
            DebPrintNoLock(Severity, FALSE, "%d  [%ws]\n", Debsub, uLineNo,
                            ULong, WStr);
            break;

        case DT_CXTION_GUID:
            //
            // Translate inbound cxtion guid to string.
            // (need replica ptr to look up the cxtion).
            //
            GuidToStr((GUID *) pData, GuidStr);
            DebPrintNoLock(Severity, FALSE, "%s\n", Debsub, uLineNo, GuidStr);
            break;


        case DT_IDT_EXTENSION:

            if (Len == 0) {
                DebPrintNoLock(Severity, FALSE, "<Zero len string>\n", Debsub, uLineNo);
                break;
            }

            IdtExt = (PIDTABLE_RECORD_EXTENSION) pData;
            if ((IdtExt->FieldSize == 0) || (IdtExt->FieldSize > Len)) {
                DebPrintNoLock(Severity, FALSE, "<FieldSize (%08x) zero or > Len>\n", Debsub, uLineNo,
                               IdtExt->FieldSize);
                break;
            }

            //
            // Loop thru the data component offset array and display each one.
            //
            pOffset = &IdtExt->Offset[0];
            pULong = NULL;

            while (*pOffset != 0) {
                ComponentPrefix = (PDATA_EXTENSION_PREFIX) ((PCHAR)IdtExt + *pOffset);

                //
                // Check for DataExtend_MD5_CheckSum.
                //
                if (ComponentPrefix->Type == DataExtend_MD5_CheckSum) {
                    if (ComponentPrefix->Size != sizeof(DATA_EXTENSION_CHECKSUM)) {
                        DebPrintNoLock(Severity, FALSE, "<MD5_CheckSum Size (%08x) invalid>\n", Debsub, uLineNo,
                                       ComponentPrefix->Size);
                        break;
                    }
                    DataChkSum = (PDATA_EXTENSION_CHECKSUM) ComponentPrefix;
                    pULong = (PULONG) DataChkSum->Data;
                    DebPrintNoLock(Severity, FALSE, "MD5: %08x %08x %08x %08x\n", Debsub, uLineNo,
                                   *pULong, *(pULong+1), *(pULong+2), *(pULong+3));
                    break;
                }

                pOffset += 1;
            }

            if (pULong == NULL) {
                DebPrintNoLock(Severity, FALSE, "No MD5 - ", Debsub, uLineNo);
                pULong = (PULONG) IdtExt;
                for (k=0; k < (IdtExt->FieldSize / sizeof(ULONG)); k++) {
                    DebPrintNoLock(Severity, FALSE, "%08x  ", Debsub, uLineNo, pULong[k]);
                }
                DebPrintNoLock(Severity, FALSE, "\n", Debsub, uLineNo);
            }
            break;


        case DT_COCMD_EXTENSION:

            if (Len == 0) {
                DebPrintNoLock(Severity, FALSE, "<Zero len string>\n", Debsub, uLineNo);
                break;
            }

            if (pData == NULL) {
                DebPrintNoLock(Severity, FALSE, "<NullPtr>\n", Debsub, uLineNo);
                break;
            }

            CocExt = (PCHANGE_ORDER_RECORD_EXTENSION) pData;
            if ((CocExt->FieldSize == 0) || (CocExt->FieldSize > Len)) {
                DebPrintNoLock(Severity, FALSE, "<FieldSize (%08x) zero or > Len>\n", Debsub, uLineNo,
                               CocExt->FieldSize);
                break;
            }

            //
            // Loop thru the data component offset array and display each one.
            //
            pOffset = &CocExt->Offset[0];
            pULong = NULL;

            while (*pOffset != 0) {
                ComponentPrefix = (PDATA_EXTENSION_PREFIX) ((PCHAR)CocExt + *pOffset);

                //
                // Check for DataExtend_MD5_CheckSum.
                //
                if (ComponentPrefix->Type == DataExtend_MD5_CheckSum) {
                    if (ComponentPrefix->Size != sizeof(DATA_EXTENSION_CHECKSUM)) {
                        DebPrintNoLock(Severity, FALSE, "<MD5_CheckSum Size (%08x) invalid>\n", Debsub, uLineNo,
                                       ComponentPrefix->Size);
                        break;
                    }
                    DataChkSum = (PDATA_EXTENSION_CHECKSUM) ComponentPrefix;
                    pULong = (PULONG) DataChkSum->Data;
                    DebPrintNoLock(Severity, FALSE, "MD5: %08x %08x %08x %08x\n", Debsub, uLineNo,
                                   *pULong, *(pULong+1), *(pULong+2), *(pULong+3));
                    break;
                }

                pOffset += 1;
            }

            if (pULong == NULL) {
                DebPrintNoLock(Severity, FALSE, "No MD5 - ", Debsub, uLineNo);
                pULong = (PULONG) CocExt;
                for (k=0; k < (CocExt->FieldSize / sizeof(ULONG)); k++) {
                    DebPrintNoLock(Severity, FALSE, "%08x  ", Debsub, uLineNo, pULong[k]);
                }
                DebPrintNoLock(Severity, FALSE, "\n", Debsub, uLineNo);
            }
            break;


        default:

            FRS_DEB_PRINT("<invalid type: %d>\n",  DataType);


        }  // end switch

    }  // end loop
    DebUnLock();
}



VOID
DbsIPrintExtensionField(
    IN PVOID       ExtRec,
    IN PINFO_TABLE InfoTable
    )

/*++

Routine Description:

    Display the Extension Field record.

    Assumes:
    All data extension formats have the same prefix offset format.
    We use PIDTABLE_RECORD_EXTENSION here.

Arguments:

    ExtRec - ptr to the extension field data.
    InfoTable

Thread Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsIPrintExtensionField:"

    ULONG  k, ULong, *pULong, FieldSize;
    PDATA_EXTENSION_PREFIX   ComponentPrefix;
    PDATA_EXTENSION_CHECKSUM DataChkSum;
    PULONG                   pOffset;


    if (ExtRec == NULL) {
        IPRINT0(InfoTable->Info, "Extension                    : Null\n");
        return;
    }

    FieldSize = ((PIDTABLE_RECORD_EXTENSION)ExtRec)->FieldSize;
    if (FieldSize == 0) {
        IPRINT0(InfoTable->Info, "Extension                    : Fieldsize zero\n");
        return;
    }

    //
    // Loop thru the data component offset array and display each one.
    //
    pOffset = &(((PIDTABLE_RECORD_EXTENSION)ExtRec)->Offset[0]);
    pULong = NULL;

    while (*pOffset != 0) {
        ComponentPrefix = (PDATA_EXTENSION_PREFIX) ((PCHAR)ExtRec + *pOffset);

        //
        // Check for DataExtend_MD5_CheckSum.
        //
        if (ComponentPrefix->Type == DataExtend_MD5_CheckSum) {
            if (ComponentPrefix->Size != sizeof(DATA_EXTENSION_CHECKSUM)) {
                IPRINT1(InfoTable->Info,
                        "Extension                    : MD5 bad size (%08x)\n",
                        ComponentPrefix->Size);
            } else {
                DataChkSum = (PDATA_EXTENSION_CHECKSUM) ComponentPrefix;
                pULong = (PULONG) DataChkSum->Data;
                IPRINT4(InfoTable->Info,
                        "Extension                    : MD5: %08x %08x %08x %08x \n",
                        *pULong, *(pULong+1), *(pULong+2), *(pULong+3));
            }
        }

        pOffset += 1;
    }

    //
    // If the data is garbled then give a raw dump.
    //
    if (pULong == NULL) {
        IPRINT0(InfoTable->Info, "Extension                    : Invalid data\n");
        pULong = (PULONG) ExtRec;

        for (k=0; k < (FieldSize / sizeof(ULONG)); k++) {
            if (k > 16) {
                break;
            }
            IPRINT2(InfoTable->Info, "Extension                    : (%08x) %08x\n", k, pULong[k]);
        }
    }
}



VOID
DbsDisplayRecordIPrint(
    IN PTABLE_CTX  TableCtx,
    IN PINFO_TABLE InfoTable,
    IN BOOL        Read,
    IN PULONG      RecordFieldx,
    IN ULONG       FieldCount
    )
/*++

Routine Description:

    This routine displays the contents of the data record on the infoprint
    interface.  It also doesn't supply the function name, line number or time
    stamp prefix on each record.

    It uses the field addresses in the JRetColumn struct to access the
    data.  The data type for the display comes from FieldInfo.DataType.

Arguments:

    TableCtx  -- The table context struct which contains:

                FieldInfo  - Array of structs describing the size and offset
                             of each field.

                RecordBase - The base address of the record buffer to
                             read/write from/to jet.

                JTableCreate - The table create structure which provides info
                               about the columns that were created in the table.

                JRetColumn - The JET_RETRIEVECOLUMN struct array to initialize.
                             NULL if not provided.

    InfoTable -- Context for InfoPrint call.
    Read -- If true then display using the Jet Ret\col info else use Jet Set col info.
    RecordFieldx -- ptr to an array of field ids for the columns to display.
    FieldCount -- Then number of field entries in the RecordFieldx array.

Return Value:

    none.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsDisplayRecordIPrint:"

    ULONG MaxCols;
    ULONG i, j, k, ULong, *pULong;
    PVOID pData;
    ULONG DataType;
    JET_ERR jerr;

    PRECORD_FIELDS FieldInfo;
    PJET_TABLECREATE JTableCreate;
    PJET_RETRIEVECOLUMN JRetColumn;
    PJET_SETCOLUMN    JSetColumn;
    PJET_COLUMNCREATE JColDesc;

    PVOID RecordBase;

    PREPLICA Replica;
    PWCHAR WStr;

    ULONG Len;
    CHAR  TimeStr[TIME_STRING_LENGTH];
    PFILE_FS_VOLUME_INFORMATION Fsvi;
    CHAR  GuidStr[GUID_CHAR_LEN];
    CHAR TableName[JET_cbNameMost];
    CHAR FlagBuffer[120];


#define FRS_INFO_PRINT(_Format, _d1)                       \
    InfoPrint(InfoTable->Info, "%-28s : " _Format,         \
              JColDesc[i].szColumnName, _d1)

#define FRS_INFO_PRINT2(_Format, _d1, _d2)                 \
    InfoPrint(InfoTable->Info, "%-28s : " _Format,         \
              JColDesc[i].szColumnName, _d1, _d2)

#define FRS_INFO_PRINT3(_Format, _d1, _d2, _d3)            \
    InfoPrint(InfoTable->Info, "%-28s : " _Format,         \
              JColDesc[i].szColumnName, _d1, _d2, _d3)

#define FRS_INFO_PRINT4(_Format, _d1, _d2, _d3, _d4)       \
    InfoPrint(InfoTable->Info, "%-28s : " _Format,         \
              JColDesc[i].szColumnName, _d1, _d2, _d3, _d4)

    //
    // Point to the table create struct for column info and the
    // pointer to the record fields struct.
    // Get ptr to base of the data record.
    //
    JTableCreate = TableCtx->pJetTableCreate;
    FieldInfo    = TableCtx->pRecordFields + 1;  // skip elt 0
    JRetColumn   = TableCtx->pJetRetCol;
    JSetColumn   = TableCtx->pJetSetCol;
    RecordBase   = TableCtx->pDataRecord;
    //
    // If the info isn't there then we can't do it.
    //
    if ((JTableCreate == NULL)            ||
        (TableCtx->pRecordFields == NULL) ||
        (RecordBase == NULL)              ||
        (JSetColumn == NULL)              ||
        (JRetColumn == NULL)) {
        DPRINT5(4, "Null ptr - JTableCreate: %08x, FieldInfo: "
                   "%08x, JRetColumn: %08x, JSetColumn: %08x, "
                   "RecordBase: %08x\n",
                JTableCreate, TableCtx->pRecordFields, JRetColumn,
                JSetColumn, RecordBase);
        return;
    }

    //
    // Get the column descriptor information.
    //
    MaxCols  = JTableCreate->cColumns;
    JColDesc = JTableCreate->rgcolumncreate;


    if (BooleanFlagOn(TableCtx->PropertyFlags, FRS_TPF_SINGLE)) {
        strcpy(TableName, JTableCreate->szTableName);
    } else {
        sprintf(TableName, "%s%05d",
                JTableCreate->szTableName, TableCtx->ReplicaNumber);
    }


    //
    // Loop through the columns and print each one.
    //
    for (j=0; j<MaxCols; j++) {
        //
        // Use the selected col list if provided.
        //
        if (RecordFieldx != NULL) {
            if (j >= FieldCount) {
                break;
            }

            i = RecordFieldx[j];

            if (i > MaxCols) {
                FRS_INFO_PRINT("ERROR - Bad field index: %d\n", i);
                continue;
            }
        } else {
            i = j;
        }

        //
        // Skip the spare fields.
        //
        if (IsSpareField(FieldInfo[i].DataType)) {
            continue;
        }

        //
        // If Read is True then use the info in the JetRetColumn struct.
        //
        if (Read) {
            Len   = JRetColumn[i].cbActual;
            pData = JRetColumn[i].pvData;
            jerr  = JRetColumn[i].err;
        } else {
            Len   = JSetColumn[i].cbData;
            pData = (PVOID) JSetColumn[i].pvData;
            jerr  = JSetColumn[i].err;
        }


        if (pData == NULL) {
            FRS_INFO_PRINT("%s\n", "<NullPtr>");
            continue;
        } else
        if (jerr == JET_wrnBufferTruncated) {
            FRS_INFO_PRINT("%s\n", "<JET_wrnBufferTruncated>");
            continue;
        } else
        if (jerr == JET_wrnColumnNull) {
            FRS_INFO_PRINT("%s\n", "<JET_wrnColumnNull>");
            continue;
        } else
        if (!JET_SUCCESS(jerr)) {
            FRS_INFO_PRINT("%s\n", "<not JET_errSuccess>");
            continue;
        }

        DataType = MaskPropFlags(FieldInfo[i].DataType);


        switch (DataType) {

        case DT_UNSPECIFIED:

            FRS_INFO_PRINT("%08x\n",  *(ULONG *)pData);
            break;

        case DT_NULL:

            FRS_INFO_PRINT("DT_NULL\n",  NULL);
            break;

        case DT_I2:

            FRS_INFO_PRINT("%8d\n",  *(SHORT *)pData);
            break;

        case DT_LONG:

            FRS_INFO_PRINT("%8d\n",  *(LONG *)pData);
            break;

        case DT_ULONG:

            FRS_INFO_PRINT("%08x\n",  *(ULONG *)pData);
            break;

        case DT_R4:

            FRS_INFO_PRINT("%08x\n",  *(ULONG *)pData);
            break;

        case DT_DOUBLE:

            FRS_INFO_PRINT("%016Lx\n",  *(LONGLONG *)pData);
            break;

        case DT_CURRENCY:

            FRS_INFO_PRINT("%8Ld\n",  *(LONGLONG *)pData);
            break;

        case DT_APDTIME:

            FRS_INFO_PRINT("%08x\n",  *(ULONG *)pData);
            break;

        case DT_ERROR:

            FRS_INFO_PRINT("%08x\n",  *(ULONG *)pData);
            break;

        case DT_BOOL:

            FRS_INFO_PRINT("%08x\n",  *(ULONG *)pData);
            break;

        case DT_OBJECT:

            FRS_INFO_PRINT("%08x\n",  *(ULONG *)pData);
            break;

        case DT_I8:

            FRS_INFO_PRINT("%8Ld\n",  *(LONGLONG *)pData);
            break;

        case DT_X8:
        case DT_USN:

            FRS_INFO_PRINT2( "%08x %08x\n", *(((ULONG *) pData)+1), *(ULONG *)pData);
            break;

        case DT_STRING8:

            if (Len == 0) {
                FRS_INFO_PRINT("%s\n", "<null len string>");
            } else

            if ((((CHAR *)pData)[Len-1]) != '\0') {
                FRS_INFO_PRINT("%s\n", "<not null terminated>");
            } else {
                FRS_INFO_PRINT("%s\n",  (CHAR *)pData);
            }
            break;

        case DT_UNICODE:
        case DT_FILENAME:
        case DT_FILE_LIST:
        case DT_DIR_PATH:

            if (Len == 0) {
                FRS_INFO_PRINT("%s\n", "<null len string>");
            } else

            if ((((WCHAR *)pData)[(Len/sizeof(WCHAR))-1]) != UNICODE_NULL) {
                FRS_INFO_PRINT("%s\n", "<not null terminated>");
            } else {
                FRS_INFO_PRINT("%ws\n",  (WCHAR *)pData);
            }

            break;

        case DT_FILETIME:

            FileTimeToString((PFILETIME) pData, TimeStr);
            FRS_INFO_PRINT("%s\n", TimeStr);
            break;

        case DT_GUID:

            GuidToStr((GUID *) pData, GuidStr);
            FRS_INFO_PRINT("%s\n",  GuidStr);
            break;

        case DT_BINARY:

            FRS_INFO_PRINT("%08x\n",  *(ULONG *)pData);
            break;

        case DT_OBJID:

            GuidToStr((GUID *) pData, GuidStr);
            FRS_INFO_PRINT("%s\n",  GuidStr);
            break;

        case DT_FSVOLINFO:

            Fsvi = (PFILE_FS_VOLUME_INFORMATION) pData;

            FRS_INFO_PRINT4("%ws (%d), %s, VSN: %08X, VolCreTim: ",
                           Fsvi->VolumeLabel,
                           Fsvi->VolumeLabelLength,
                           (Fsvi->SupportsObjects ? "(obj)" : "(no-obj)"),
                           Fsvi->VolumeSerialNumber);

            FileTimeToString((PFILETIME) &Fsvi->VolumeCreationTime, TimeStr);
            FRS_INFO_PRINT("%s\n", TimeStr);
            break;

        case DT_IDT_FLAGS:
            //
            // Decode and print the flags field in the IDTable record.
            //
            FrsFlagsToStr(*(ULONG *)pData, IDRecFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
            FRS_INFO_PRINT2("%08x Flags [%s]\n", *(ULONG *)pData, FlagBuffer);
            break;

        case DT_COCMD_FLAGS:
            //
            // Decode and print the flags field in the ChangeOrder record.
            //
            FrsFlagsToStr(*(ULONG *)pData, CoFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
            FRS_INFO_PRINT2("%08x Flags [%s]\n", *(ULONG *)pData, FlagBuffer);

            break;

        case DT_USN_FLAGS:
            //
            // Decode and print the USN Reason field in the USN Record.
            //
            FrsFlagsToStr(*(ULONG *)pData, UsnReasonNameTable, sizeof(FlagBuffer), FlagBuffer);
            FRS_INFO_PRINT2("%08x Flags [%s]\n", *(ULONG *)pData, FlagBuffer);

            break;

        case DT_CXTION_FLAGS:
            //
            // Decode and print the flags field in the connection record.
            //
            FrsFlagsToStr(*(ULONG *)pData, CxtionFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
            FRS_INFO_PRINT2("%08x Flags [%s]\n", *(ULONG *)pData, FlagBuffer);
            break;

        case DT_FILEATTR:
            //
            // Decode and print the file attributes field in IDTable and ChangeOrder records.
            //
            FrsFlagsToStr(*(ULONG *)pData, FileAttrFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
            FRS_INFO_PRINT2("%08x Flags [%s]\n", *(ULONG *)pData, FlagBuffer);
            break;

        case DT_COSTATE:

            ULong = *(ULONG *)pData;
            FRS_INFO_PRINT2("%08x  CO STATE:  %s\n",
                           ULong,
                           (ULong <= IBCO_MAX_STATE) ? IbcoStateNames[ULong] : "INVALID STATE");
            break;

        case DT_COCMD_IFLAGS:
            //
            // Decode and print the Iflags field in the ChangeOrder record.
            //
            FrsFlagsToStr(*(ULONG *)pData, CoIFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
            FRS_INFO_PRINT2("%08x Flags [%s]\n", *(ULONG *)pData, FlagBuffer);

            break;

        case DT_CO_LOCN_CMD:
            //
            // Decode and print the change order location command.
            //
            ULong = *(ULONG *)pData;
            k = ((PCO_LOCATION_CMD)(pData))->Command;

            FRS_INFO_PRINT3("%08x  D/F %d   %s\n", ULong,
                           ((PCO_LOCATION_CMD)(pData))->DirOrFile,
                           (k <= CO_LOCATION_NUM_CMD) ? CoLocationNames[k] : "Invalid Location Cmd");
            break;

        case DT_REPLICA_ID:
            //
            // Translate the replica ID number to a name.
            //
            ULong = *(ULONG *)pData;
            WStr = L"???";
#if 0
            //
            // Note: can't get the lock below since we will hang.
            // Need another way to get the replica name.
            //
            Replica = RcsFindReplicaById(ULong);
            if ((Replica != NULL) &&
                (Replica->ReplicaName != NULL) &&
                (Replica->ReplicaName->Name != NULL)){
                WStr = Replica->ReplicaName->Name;
            }
#endif
            FRS_INFO_PRINT2("%d  [%ws]\n", ULong, WStr);
            break;

        case DT_CXTION_GUID:
            //
            // Translate inbound cxtion guid to string.
            // (need replica ptr to look up the cxtion).
            //
            GuidToStr((GUID *) pData, GuidStr);
            FRS_INFO_PRINT("%s\n", GuidStr);
            break;


        case DT_IDT_EXTENSION:

            if (Len == 0) {
                FRS_INFO_PRINT("%s\n", "<Zero len string>");
                break;
            }

            DbsIPrintExtensionField(pData, InfoTable);

            break;


        case DT_COCMD_EXTENSION:

            if (Len == 0) {
                FRS_INFO_PRINT("%s\n", "<Zero len string>");
                break;
            }

            DbsIPrintExtensionField(pData, InfoTable);

            break;


        default:

            FRS_INFO_PRINT("<invalid type: %d>\n",  DataType);


        }  // end switch

    }  // end loop
}



VOID
DbsDisplayJetParams(
    IN PJET_SYSTEM_PARAMS Jsp,
    IN ULONG ActualLength
    )
/*++

Routine Description:

    This routine displays the contents of the Jet system parameters struct.

Arguments:

    JetSystemParams   -- ptr to param struct.

Return Value:

    none.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsDisplayJetParams:"

    PJET_PARAM_ENTRY Jpe;


    if (ActualLength != sizeof(JET_SYSTEM_PARAMS)) {
        DPRINT1(1, "++ JetSystemParameters: length error: %d\n", ActualLength);
        return;
    }

    if (Jsp == NULL) {
        DPRINT(1, "++ JetSystemParameters: null ptr\n");
        return;
    }

    if (Jsp->ParamEntry[MAX_JET_SYSTEM_PARAMS-1].ParamType != JPARAM_TYPE_LAST) {
        DPRINT(1, "++ JetSystemParameters: ParamEntry[MAX_JET_SYSTEM_PARAMS-1].ParamType != JPARAM_TYPE_LAST\n");
    }

    Jpe = Jsp->ParamEntry;

    while (Jpe->ParamType != JPARAM_TYPE_LAST) {

        if (Jpe->ParamType == JPARAM_TYPE_STRING) {

            DPRINT2(4, "++ %-24s : %s\n", Jpe->ParamName, ((PCHAR)Jsp)+Jpe->ParamValue);

        } else if (Jpe->ParamType == JPARAM_TYPE_LONG) {

            DPRINT2(4, "++ %-24s : %d\n", Jpe->ParamName, Jpe->ParamValue);

        }

        Jpe += 1;
    }
}



JET_ERR
DbsDumpTableWorker(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it dumps the current record in TableCtx.

Arguments:

    ThreadCtx - Needed to access Jet.  (Not used).
    TableCtx - A ptr to a DIRTable context struct.
    Record - A ptr to a DIRTable record.  (Not used).
    Context - A ptr to the Replica set we are loading data for.  (Not used).

Thread Return Value:

    A Jet error status.  Success means call us with the next record.
    Failure means don't call again and pass our status back to the
    caller of FrsEnumerateTable().

--*/
{
#undef DEBSUB
#define DEBSUB "DbsDumpTableWorker:"

    DBS_DISPLAY_RECORD_SEV(5, TableCtx, TRUE);

    return JET_errSuccess;
}


JET_ERR
DbsDumpTable(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN ULONG         RecordIndex
    )

/*++

Routine Description:

    This function opens the table specified by the table context
    (if it's not already open) and dumps the table based on the index
    specified.

    If the TableCtx->Tid field is NOT JET_tableidNil then
    we assume it is good FOR THIS SESSION and do not reopen the table.

    Note:  NEVER use table IDs across sessions or threads.

Arguments:

    ThreadCtx  - Provides the Jet Sesid and Dbid.

    TableCtx   - The table context uses the following:

            JTableCreate - The table create structure which provides info
                           about the columns that were created in the table.

            JRetColumn - The JET_RETRIEVECOLUMN struct array to tell
                         Jet where to put the data.

            ReplicaNumber - The id number of the replica this table belongs too.

    RecordIndex - The index to use when accessing the table.  From the index
                  enum list for the table in schema.h.

Return Value:

    Jet Error Status.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsDumpTable:"

    JET_ERR    jerr, jerr1;
    JET_SESID   Sesid;
    JET_TABLEID  Tid;
    NTSTATUS   Status;
    ULONG      ReplicaNumber;
    JET_TABLEID  FrsOpenTableSaveTid;   // for FrsOpenTableMacro DEBUG

    TABLE_CTX  DumpTableCtxState;
    PTABLE_CTX  DumpTableCtx = &DumpTableCtxState;
    CHAR TableName[JET_cbNameMost];


    Sesid          = ThreadCtx->JSesid;
    ReplicaNumber  = TableCtx->ReplicaNumber;

    //
    // Allocate a new table context using the table type of the caller.
    //
    DumpTableCtx->TableType = TABLE_TYPE_INVALID;
    Status = DbsAllocTableCtx(TableCtx->TableType, DumpTableCtx);

    //
    // Open the table, if it's not already open. Check the session id for match.
    //
    jerr = DBS_OPEN_TABLE(ThreadCtx, DumpTableCtx, ReplicaNumber, TableName, &Tid);
    CLEANUP1_JS(0, "ERROR - FrsOpenTable (%s) :", TableName, jerr, RETURN);

    jerr = FrsEnumerateTable(ThreadCtx, DumpTableCtx, RecordIndex, DbsDumpTableWorker, NULL);

    //
    // Close the table and reset DumpTableCtx Tid and Sesid.   Macro writes 1st arg.
    //
RETURN:
    DbsCloseTable(jerr1, Sesid, DumpTableCtx);

    //
    // Free the table context.
    //
    DbsFreeTableCtx(DumpTableCtx, 1);

    return jerr;
}



JET_ERR
DbsTableMoveFirst(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN ULONG         ReplicaNumber,
    IN ULONG         RecordIndex
    )
/*++

Routine Description:

    This routine opens a table and moves the cursor to the first record
    specified by the RecordIndex.

Arguments:

    ThreadCtx - A thread context for accessing Jet.
    TableCtx - A ptr to the Table context of the open table to enumerate.
    ReplicaNumber - The replica ID.
    RecordIndex - The ID number for the record index to use.

Thread Return Value:

    Jet error status.
        JET_errNoCurrentRecord means the table is empty.
        JET_errSuccess means the table is not empty.

--*/

{
#undef DEBSUB
#define DEBSUB "DbsTableMoveFirst:"

    JET_ERR            jerr, jerr1;
    JET_SESID          Sesid;
    JET_TABLEID        Tid;
    JET_TABLEID        FrsOpenTableSaveTid;   // for FrsOpenTableMacro DEBUG
    PJET_TABLECREATE   JTableCreate;
    PJET_INDEXCREATE   JIndexDesc;
    PCHAR              IndexName;
    CHAR               TableName[JET_cbNameMost];


    Sesid          = ThreadCtx->JSesid;

    Tid            = TableCtx->Tid;
    JTableCreate   = TableCtx->pJetTableCreate;
    JIndexDesc     = JTableCreate->rgindexcreate;

    //
    // Get the index name based on RecordIndex argument.
    //
    IndexName      = JIndexDesc[RecordIndex].szIndexName;

    //
    // Open the table if it's not already open and check the session id for match.
    //
    jerr = DBS_OPEN_TABLE(ThreadCtx, TableCtx, ReplicaNumber, TableName, &Tid);
    CLEANUP1_JS(0, "FrsOpenTable (%s) :", TableName, jerr, RETURN);

    //
    // Use the specified index.
    //
    jerr = JetSetCurrentIndex2(Sesid, Tid, IndexName, JET_bitMoveFirst);
    CLEANUP1_JS(0, "JetSetCurrentIndex (%s) :", TableName, jerr, RETURN);

    //
    // Move to the first record.
    //
    jerr = JetMove(Sesid, Tid, JET_MoveFirst, 0);
    DPRINT_JS(4, "JetSetCurrentIndex error:", jerr);

RETURN:
    return jerr;
}



ULONG
DbsTableMoveToRecord(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN ULONG         RecordIndex,
    IN ULONG         MoveArg
    )
/*++

Routine Description:

    This routine moves the cursor to the record
    specified by the RecordIndex and MoveArg.

Arguments:

    ThreadCtx - A thread context for accessing Jet.
    TableCtx - A ptr to the Table context of the open table to enumerate.
    RecordIndex - The ID number for the record index to use.
    MoveArg - One of FrsMoveFirst, FrsMovePrevious, FrsMoveNext, FrsMoveLast

Return Value:

    FrsErrorStatus         JetErrorStatus

    FrsErrorNotFound    JET_errRecordNotFound
    FrsErrorNotFound    JET_errNoCurrentRecord
    FrsErrorNotFound    JET_wrnTableEmpty
    FrsErrorSuccess     JET_errSuccess
--*/

{
#undef DEBSUB
#define DEBSUB "DbsTableMoveToRecord:"

    JET_ERR            jerr, jerr1;
    JET_SESID          Sesid;
    JET_TABLEID        Tid;
    PJET_TABLECREATE   JTableCreate;
    PJET_INDEXCREATE   JIndexDesc;
    PCHAR              IndexName;


    Sesid          = ThreadCtx->JSesid;
    Tid            = TableCtx->Tid;
    JTableCreate   = TableCtx->pJetTableCreate;
    JIndexDesc     = JTableCreate->rgindexcreate;

    //
    // Get the index name based on RecordIndex argument.
    //
    IndexName      = JIndexDesc[RecordIndex].szIndexName;

    //
    // Use the specified index.
    //
    jerr = JetSetCurrentIndex2(Sesid, Tid, IndexName, JET_bitMoveFirst);
    if (!JET_SUCCESS(jerr)) {
        goto ERROR_RETURN;
    }

    FRS_ASSERT((MoveArg == FrsMoveFirst)    ||
               (MoveArg == FrsMovePrevious) ||
               (MoveArg == FrsMoveNext)     ||
               (MoveArg == FrsMoveLast));

    //
    // Move to requested record.
    //
    jerr = JetMove(Sesid, Tid, MoveArg, 0);
    if (!JET_SUCCESS(jerr)) {
        goto ERROR_RETURN;
    }

    return FrsErrorSuccess;

ERROR_RETURN:

    if ((jerr == JET_errRecordNotFound)  ||
        (jerr == JET_errNoCurrentRecord) ||
        (jerr == JET_wrnTableEmpty)) {
        return  FrsErrorNotFound;
    } else {
        DPRINT_JS(0, "ERROR:", jerr);
        return DbsTranslateJetError(jerr, FALSE);
    }
}

JET_ERR
DbsEnumerateTable2(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN ULONG         RecordIndex,
    IN PENUMERATE_TABLE_ROUTINE RecordFunction,
    IN PVOID         Context,
    IN PENUMERATE_TABLE_PREREAD PreReadFunction
    )
/*++

Routine Description:

    This routine fetches each record of the open table specified by the
    table context and calls the supplied RecordFunction().  The record
    sequence is governed by the RecordIndex ID value.

    IMPROVEMENT: Add another return parameter on the RecordFunction
    (or use status) that tells us to apply an update to the table.
    The RecordFunction has modified some data fields.  Could pass
    back a vector of field IDs that need to be written back to Jet.
    This could be used to walk thru an IDTable and update all the
    FIDs.

Arguments:

    ThreadCtx - A thread context for accessing Jet.
    TableCtx - A ptr to the Table context of the open table to enumerate.
    RecordIndex - The ID number for the record index to use in the enumeration.
    RecordFunction - The function to call for each record in the table.
    Context - A context ptr to pass through to the RecordFunction.
    PreReadFunction - If non-Null this function is called before each DB read.
                      It can be used to change the record address or set up
                      some synchronization.

Thread Return Value:

    Jet error status.

    If the RecordFunction returns a JET_errWriteConflict value then we retry
    the read operation.
    If the RecordFunction returns any other  NON SUCCESS value
    this value is returned to our caller.

--*/

{
#undef DEBSUB
#define DEBSUB "DbsEnumerateTable2:"

    JET_SESID            Sesid;
    PJET_TABLECREATE     JTableCreate;
    PJET_RETRIEVECOLUMN  JRetColumn;
    JET_TABLEID          Tid;
    PJET_INDEXCREATE     JIndexDesc;
    ULONG                NumberColumns;
    PCHAR                IndexName;
    JET_ERR              jerr, jerr1;
    ULONG                FStatus;
    LONG                 Trips;

    Sesid          = ThreadCtx->JSesid;

    JTableCreate   = TableCtx->pJetTableCreate;
    JRetColumn     = TableCtx->pJetRetCol;
    Tid            = TableCtx->Tid;

    JIndexDesc     = JTableCreate->rgindexcreate;
    NumberColumns  = JTableCreate->cColumns;

    //
    // Get the index name based on RecordIndex argument.
    //
    IndexName      = JIndexDesc[RecordIndex].szIndexName;

    //
    // Use the specified index.
    //
    jerr = JetSetCurrentIndex2(Sesid, Tid, IndexName, JET_bitMoveFirst);
    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(0, "JetSetCurrentIndex:", jerr);
        return jerr;
    }

    //
    // Initialize the JetSet/RetCol arrays and data record buffer addresses
    // to read and write the fields of the ConfigTable records into ConfigRecord.
    //
    DbsSetJetColSize(TableCtx);
    DbsSetJetColAddr(TableCtx);

    //
    // Allocate the storage for the variable length fields in the record and
    // update the JetSet/RetCol arrays appropriately.
    //
    DbsAllocRecordStorage(TableCtx);

    //
    // Move to the first record.
    //
    jerr = JetMove(Sesid, Tid, JET_MoveFirst, 0);

    //
    // If the record is not there then return.
    //
    if (jerr == JET_errNoCurrentRecord ) {
        DPRINT(4, "JetMove - empty table\n");
        return JET_wrnTableEmpty;
    }

    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(0, "JetMove error:", jerr);
        return jerr;
    }

    while( JET_SUCCESS(jerr) ) {

        Trips = 10000;
RETRY_READ:

        //
        // Call the PreRead Function if supplied.
        //
        if (PreReadFunction != NULL) {
            jerr = (PreReadFunction)(ThreadCtx, TableCtx, Context);
            if (!JET_SUCCESS(jerr)) {
                break;
            }
        }

        FStatus = DbsTableRead(ThreadCtx, TableCtx);
        if (!FRS_SUCCESS(FStatus)) {
            DPRINT_FS(0, "Error - can't read selected record.", FStatus);
            jerr = JET_errRecordNotFound;
            DBS_DISPLAY_RECORD_SEV(1, TableCtx, TRUE);
        } else {
            //
            // Call the RecordFunction to process the record data.
            //
            jerr = (RecordFunction)(ThreadCtx,
                                    TableCtx,
                                    TableCtx->pDataRecord,
                                    Context);

            if ((jerr == JET_errInvalidObject) && (--Trips > 0)) {
                goto RETRY_READ;
            }

            FRS_ASSERT(Trips != 0);

            if (!JET_SUCCESS(jerr)) {
                break;
            }
        }

        //
        // go to next record in table.
        //
        jerr = JetMove(Sesid, Tid, JET_MoveNext, 0);
        //
        // If the record is not there then return.
        //
        if (jerr == JET_errNoCurrentRecord ) {
            DPRINT(4, "JetMove - end of table\n");
            break;
        }

        if (!JET_SUCCESS(jerr)) {
            DPRINT_JS(0, "JetMove error:", jerr);
            break;
        }
    }

    return jerr;
}





JET_ERR
DbsEnumerateOutlogTable(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN ULONG         RecordIndexLimit,
    IN PENUMERATE_OUTLOGTABLE_ROUTINE RecordFunction,
    IN PVOID         Context
    )
/*++

Routine Description:

    This routine fetches each record of the open outlog table specified by the
    table context and calls the supplied RecordFunction().  The record
    sequence is the sequence number field.

    The enumeration is sequential starting from the lowest record
    in the table and stopping at the specified limit (unless the
    RecordFunction() stops us sooner).  If a record is not found then
    a null value for the record pointer is passed to the function.

    IMPROVEMENT: Add another return parameter on the RecordFunction
    (or use status) that tells us to apply an update to the table.
    The RecordFunction has modified some data fields.  Could pass
    back a vector of field IDs that need to be written back to Jet.
    This could be used to walk thru an IDTable and update all the
    FIDs.

Arguments:

    ThreadCtx - A thread context for accessing Jet.
    TableCtx - A ptr to the Table context of the open table to enumerate.
    RecordIndexLimit - The index limit at which to stop the enumeration.
    RecordFunction - The function to call for each record in the table.
    Context - A context ptr to pass through to the RecordFunction.

Thread Return Value:

    Jet error status.

    If the RecordFunction returns a JET_errWriteConflict value then we retry
    the read operation.
    If the RecordFunction returns any other  NON SUCCESS value
    this value is returned to our caller.

--*/

{
#undef DEBSUB
#define DEBSUB "DbsEnumerateOutlogTable:"

    JET_SESID            Sesid;
    PJET_TABLECREATE     JTableCreate;
    PJET_RETRIEVECOLUMN  JRetColumn;
    JET_TABLEID          Tid;
    PJET_INDEXCREATE     JIndexDesc;
    ULONG                NumberColumns;
    PCHAR                IndexName;
    JET_ERR              jerr, jerr1;
    ULONG                FStatus;
    LONG                 Trips;
    PCHANGE_ORDER_COMMAND CoCmd;
    ULONG                OutLogSeqNumber = 0;


    Sesid          = ThreadCtx->JSesid;

    JTableCreate   = TableCtx->pJetTableCreate;
    JRetColumn     = TableCtx->pJetRetCol;
    Tid            = TableCtx->Tid;

    JIndexDesc     = JTableCreate->rgindexcreate;
    NumberColumns  = JTableCreate->cColumns;

    //
    // Get the index name based on Outlog sequence number.
    //
    IndexName      = JIndexDesc[OLSequenceNumberIndexx].szIndexName;

    //
    // Use the specified index.
    //
    jerr = JetSetCurrentIndex2(Sesid, Tid, IndexName, JET_bitMoveFirst);
    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(0, "JetSetCurrentIndex error:", jerr);
        return jerr;
    }

    //
    // Initialize the JetSet/RetCol arrays and data record buffer addresses
    // to read and write the fields of the ConfigTable records into ConfigRecord.
    //
    DbsSetJetColSize(TableCtx);
    DbsSetJetColAddr(TableCtx);

    //
    // Allocate the storage for the variable length fields in the record and
    // update the JetSet/RetCol arrays appropriately.
    //
    DbsAllocRecordStorage(TableCtx);

    //
    // Move to the first record.
    //
    jerr = JetMove(Sesid, Tid, JET_MoveFirst, 0);

    //
    // If the record is not there then return.
    //
    if (jerr == JET_errNoCurrentRecord ) {
        DPRINT(4, "JetMove - empty table\n");
        return JET_wrnTableEmpty;
    }

    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(0, "JetMove error:", jerr);
        return jerr;
    }

    FStatus = FrsErrorSuccess;
    while( OutLogSeqNumber < RecordIndexLimit ) {

        Trips = 10;
RETRY_READ:


        if (FRS_SUCCESS(FStatus)) {
            //
            // Read the record.
            //
            FStatus = DbsTableRead(ThreadCtx, TableCtx);
            if (!FRS_SUCCESS(FStatus)) {
                goto RETRY_READ;
            }
            CoCmd = (PCHANGE_ORDER_COMMAND) TableCtx->pDataRecord;
            OutLogSeqNumber = CoCmd->SequenceNumber;
        } else

        if (FStatus == FrsErrorNotFound) {
            //
            // No record at this sequence number.  Bump the number and
            // call record function with a null record.
            //
            OutLogSeqNumber += 1;
            CoCmd = NULL;
        } else {
            DPRINT1_FS(0, "Error - reading selected record. jerr = %d,", jerr, FStatus);
            jerr = JET_errRecordNotFound;
            break;
        }


        //
        // Call the RecordFunction to process the record data.
        //
        jerr = (RecordFunction)(ThreadCtx, TableCtx, CoCmd, Context, OutLogSeqNumber);

        if ((jerr == JET_errInvalidObject) && (--Trips > 0)) {
            goto RETRY_READ;
        }

        FRS_ASSERT(Trips != 0);

        if (!JET_SUCCESS(jerr)) {
            break;
        }

        //
        // go to next record in table.
        //
        jerr = JetMove(Sesid, Tid, JET_MoveNext, 0);

        if (jerr == JET_errNoCurrentRecord) {
            FStatus = FrsErrorNotFound;
        } else {
            FStatus = DbsTranslateJetError(jerr, FALSE);
        }

    }

    return jerr;
}





ULONG
DbsRequestSaveMark(
    PVOLUME_MONITOR_ENTRY pVme,
    BOOL                  Wait
    )
/*++
Routine Description:

     Capture current Journal USN and Volume Sequence Number to save with
     the active replica sets using this journal.

     Caller must Acquire the VME lock so we can get the reference.

Arguments:

    pVme -- Volume Monitor Entry with saved USN and VSN state.

    Wait -- True if we are to wait until update completes.

Return Value:
    FrsError status.  Only if wait is true else FrsErrorSuccess returned.

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsRequestSaveMark:"

    ULONG           FStatus = FrsErrorSuccess;
    ULONG           WStatus;
    PCOMMAND_PACKET CmdPkt;


    //
    // Get the reference on the Vme.  If the return is zero the Vme is gone.
    // The reference is dropped by savemark code.
    //
    if (AcquireVmeRef(pVme) == 0) {
        return FrsErrorSuccess;
    }

    //
    // Tell the DBService to save the mark point.
    //
    CmdPkt = DbsPrepareCmdPkt(NULL,                   //  CmdPkt,
                              NULL,                   //  Replica,
                              CMD_DBS_REPLICA_SAVE_MARK,  //  CmdRequest,
                              NULL,                   //  TableCtx,
                              pVme,                   //  CallContext,
                              0,                      //  TableType,
                              0,                      //  AccessRequest,
                              0,                      //  IndexType,
                              NULL,                   //  KeyValue,
                              0,                      //  KeyValueLength,
                              FALSE);                 //  Submit

    FRS_ASSERT(CmdPkt != NULL);


    if (Wait) {
        //
        // Make the call synchronous.
        // Don't free the packet when the command completes.
        //
        FrsSetCompletionRoutine(CmdPkt, FrsCompleteKeepPkt, NULL);

        //
        // SUBMIT db command request and wait for completion.
        //
        WStatus = FrsSubmitCommandServerAndWait(&DBServiceCmdServer, CmdPkt, INFINITE);
        DPRINT_WS(0, "ERROR: DB Command failed", WStatus);

        FStatus = CmdPkt->Parameters.DbsRequest.FStatus;
        FrsFreeCommand(CmdPkt, NULL);

    } else {

        //
        // Fire and forget the command.
        //
        FrsSubmitCommandServer(&DBServiceCmdServer, CmdPkt);
    }

    return FStatus;
}



ULONG
DbsReplicaSaveMark(
    IN PTHREAD_CTX           ThreadCtx,
    IN PREPLICA              Replica,
    IN PVOLUME_MONITOR_ENTRY pVme
    )
/*++

Routine Description:

    Save the volume sequence number and FSVolLastUSN in the Replica
    config record.  This routine should only be called if the Replica
    Service state is active.  Except for shutdown or error save situations.

    Journal Replay Mode : A given replica set is in "journal replay mode"
    when the journal read point has moved back to a point prior to the
    LastUsnRecordProceesed by this replica set.  This occurs when another
    replica set starts up and has to read from an older point in the journal.
    All journal records that normally would be processed by a replica set are
    ignored as long as the replica set is in replay mode.

    The following state variables are used to track USN Journal Processing.

                                ----------- WHERE UPDATED -----------

    Replica->InlogCommitUsn   - Here to keep up with SaveUsn *
                              - In ChgOrdReject() in lieu of Inlog Insert
                              - In ChgOrdInsertInlogRecord() after Inlog Insert

    Replica->LastUsnRecordProcessed
                              - Here to keep up with SaveUsn *
                              - At bottom of Jrnl Monitor thread loop if
                                the replica service state is active and not
                                in jrnl replay mode.
                              - In JrnlSetReplicaState when the state change
                                goes from ACTIVE to PAUSED.

    pVme->CurrentUsnRecordDone **
                              - In Jrnl Monitor thread when I/O is stopped.
                              - In Jrnl Monitor thread when USN records are filtered out.
                              - At bottom of Jrnl Monitor thread loop.

    Replica->LocalCoQueueCount
                              - In JrnlUpdateChangeOrder() when a CO is removed
                                from the process queue. dec
                              - In JrnlUpdateChangeOrder() when a CO is added
                                to the process queue. inc
                              - At the bottom of the CO process loop in
                                ChgOrdAccept(). dec
                              - In ChgOrdInsertProcessQueue() when a Local CO
                                is re-inserted onto the process queue. inc
                              - In ChgOrdReanimate() when a reanimate local
                                co is generated for a dead parent.

    ConfigRecord->FSVolLastUSN - Updated Here.


* Necessary to update them here in the event that there is a lot of activity
on the volume but none involving this replica set.  If a crash were to occur
and we failed to keep these read pointers up to date we could find ourselves
reading from a deleted portion of the journal and think we had lost journal data.

** It is possible, depending on timing between threads, for the InlogCmmitUsn to
move past LastUsnRecordProcessed.  This is a benign and transient event.



    DbsReplicaSaveMark is called directly or indirectly by
        - CMD_DBS_REPLICA_SAVE_MARK
        - DbsCloseSessionReplicaTables()
        - DbsRequestSaveMark().  Uses above DB command dispatch point.
        - DbsInitOneReplicaSet() when R/S is initialized to checkpoint the
          VSN restart point.
        - At the top of the Jrnl Monitor thread after JRNL_USN_SAVE_POINT_INTERVAL bytes
          (currently 16Kb) are consumed.
        - by the NEW_VSN macro every VSN_SAVE_INTERVAL (currently 256)
          VSNs are generated.

    This function can be called by the Jrnl Monitor thread, the Change order
    accept thread(s) or the DB thread(s).


Arguments:

    ThreadCtx  -- A Thread context to use for dbid and sesid.
    Replica    -- ptr to Replica struct.
    pVme       -- prt to volume monitor entry serving this Replica.

Return Value:

    FrsError status

--*/
{
#undef DEBSUB
#define DEBSUB "DbsReplicaSaveMark:"


    USN SaveUsn;
    ULONG FStatus;

    PCONFIG_TABLE_RECORD ConfigRecord;
    PCXTION              Cxtion;

    BOOL ReplayMode;
    BOOL ReplicaPaused;
    BOOL JrnlCxtionValid;

    ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);
    LOCK_VME(pVme);

    DPRINT2(4, ":U: Replica->InlogCommitUsn: %08x %08x   Replica->LastUsnRecordProcessed: %08x %08x\n",
            PRINTQUAD(Replica->InlogCommitUsn),
            PRINTQUAD(Replica->LastUsnRecordProcessed));

    if (Replica->LastUsnRecordProcessed < Replica->InlogCommitUsn) {
        DPRINT2(1, ":U: Warning:  possible USN progress update error. "
                " LastUsnRecordProcessed %08x %08x  < InlogCommitUsn %08x %08x\n",
                PRINTQUAD(Replica->LastUsnRecordProcessed),
                PRINTQUAD(Replica->InlogCommitUsn));
    }

    FRS_ASSERT(Replica->LocalCoQueueCount >= 0);

    //
    // This replica set is in replay mode if the Current USN record is before
    // the LastUsnRecordProcessed for the replica and the Replica state is active
    // or paused.
    //
    // If there are local change orders pending in the process queue or
    // replica set is not active (stopped, in error state) then
    // we can only advance the SaveUsn point to the InlogCommitUsn.
    //
    // Otherwise we can advance it to either the:
    //
    //     LastUsnRecordProcessed for the replica if in replay mode or paused, or
    //     CurrentUsnRecordDone otherwise.
    //
    ReplayMode = REPLICA_REPLAY_MODE(Replica, pVme);
    ReplicaPaused = (Replica->ServiceState == REPLICA_STATE_PAUSED);

    //
    // If the Journal Cxtion is "Unjoined" for this Replica Set then our
    // restart point is limited to the InlogCommitUsn since ChangeOrderAccept
    // will be throwing away all local COs.
    //
    JrnlCxtionValid = TRUE;
    LOCK_CXTION_TABLE(Replica);

    Cxtion = GTabLookupNoLock(Replica->Cxtions, &Replica->JrnlCxtionGuid, NULL);
    if ((Cxtion == NULL) ||
        !CxtionFlagIs(Cxtion, CXTION_FLAGS_JOIN_GUID_VALID) ||
        !CxtionStateIs(Cxtion, CxtionStateJoined) ) {
        JrnlCxtionValid = FALSE;
    }

    UNLOCK_CXTION_TABLE(Replica);


    //
    // Investigate: May need a lock around test of LocalCoQueueCount and fetch of
    //       CurrentUsnRecord to avoid small window in which a crash/recovery
    //       would skip a USN record just put on the queue.  Sigh
    //       an alternative is to capture the count and current USN record
    //       values at the call site.  This may work better.

    // Check if having the pVme lock is sufficient.

    if ((Replica->LocalCoQueueCount == 0) && JrnlCxtionValid &&
        ((Replica->ServiceState == REPLICA_STATE_ACTIVE) || ReplicaPaused)) {

        AcquireQuadLock(&pVme->QuadWriteLock);
        SaveUsn = (ReplayMode || ReplicaPaused) ? Replica->LastUsnRecordProcessed
                                                : pVme->CurrentUsnRecordDone;
        ReleaseQuadLock(&pVme->QuadWriteLock);

        if (ReplayMode || ReplicaPaused) {
            DPRINT1(4, ":U: Replay mode or replica paused (Qcount is zero)."
                    "  SaveUsn advanced to Replica->LastUsnRecordProcessed: %08x %08x\n",
                    PRINTQUAD(Replica->LastUsnRecordProcessed));
        } else {
            DPRINT1(4, ":U: Not Replay mode and not replica paused (Qcount is zero)."
                    "  SaveUsn advanced to pVme->CurrentUsnRecordDone: %08x %08x\n",
                    PRINTQUAD(pVme->CurrentUsnRecordDone));
        }

        //
        // Advance the Inlog Commit Point if we were able to move past it.
        // Note - This can put the InlogCommitUsn past the LastUsnRecordProcessed
        // for this replica set since the latter is only advanced when a record
        // for this replica set is sent to change order processing.  So advance
        // it as well.
        //
        if (SaveUsn > Replica->InlogCommitUsn) {

            AcquireQuadLock(&pVme->QuadWriteLock);
            //
            // retest with the lock.
            //
            if (SaveUsn > Replica->InlogCommitUsn) {
                Replica->InlogCommitUsn = SaveUsn;
                Replica->LastUsnRecordProcessed = SaveUsn;
            }
            ReleaseQuadLock(&pVme->QuadWriteLock);

            DPRINT1(4, ":U: Replica->InlogCommitUsn advanced to: %08x %08x\n",
                    PRINTQUAD(Replica->InlogCommitUsn));
        }
    } else {
        AcquireQuadLock(&pVme->QuadWriteLock);
        SaveUsn = Replica->InlogCommitUsn;
        ReleaseQuadLock(&pVme->QuadWriteLock);

        DPRINT4(4, ":U: Replica->ServiceState not active (%s) or Qcount nonzero (%d)"
                " or JrnlCxtionUnjoined (%s) SaveUsn advanced to InlogCommitUsn: %08x %08x\n",
                RSS_NAME(Replica->ServiceState),
                Replica->LocalCoQueueCount,
                JrnlCxtionValid ? "No" : "Yes",
                PRINTQUAD(SaveUsn));
    }

    //
    // If the new save USN is less than or equal to FSVolLastUSN (our last save
    // point) for this Replica then we ignore it.  This could happen when we
    // have something in the queue that has not made it to the inbound log after
    // a long period of inactivity (on our Replica set) where we were advancing
    // our save point with the CurrentUsnRecord.  Or it could be due to having
    // just entered replay mode because another replica set started up.
    //

    AcquireQuadLock(&pVme->QuadWriteLock);
    if (SaveUsn > ConfigRecord->FSVolLastUSN) {
        ConfigRecord->FSVolLastUSN = SaveUsn;
    }
    ReleaseQuadLock(&pVme->QuadWriteLock);

    //
    // Save current VSN.  Check that it never moves backwards.
    //
    FRS_ASSERT(pVme->FrsVsn >= ConfigRecord->FrsVsn);
    if ((pVme->FrsVsn - ConfigRecord->FrsVsn) > 2*MaxPartnerClockSkew) {
        DPRINT3(0, ":U: ERROR - Vsn out of date for %ws (pVme Vsn %08x %08x ; ConfigVsn %08x %08x)\n",
                Replica->ReplicaName->Name,
                PRINTQUAD(pVme->FrsVsn),
                PRINTQUAD(ConfigRecord->FrsVsn));
    }
    ConfigRecord->FrsVsn = pVme->FrsVsn;

    //
    // Update the selected fields in the config record.
    //
    FStatus = DbsUpdateConfigTableFields(ThreadCtx,
                                         Replica,
                                         CnfMarkPointFieldList,
                                         CnfMarkPointFieldCount);
    DPRINT1_FS(0, ":U: DbsUpdateConfigTableFields(%ws);", Replica->ReplicaName->Name, FStatus);

    DPRINT2(4, ":U: Save ConfigRecord->FSVolLastUSN %08x %08x    ConfigRecord->FrsVsn  %08x %08x\n",
            PRINTQUAD(ConfigRecord->FSVolLastUSN), PRINTQUAD(ConfigRecord->FrsVsn));

    FRS_ASSERT(FRS_SUCCESS(FStatus));

    //
    // The lock extends to here to avoid a race with another thread attempting
    // to save this state in the DB and getting them out of order.
    // Use an inprogress flag if this is a perf problem.
    //
    UNLOCK_VME(pVme);

    return FStatus;

}


ULONG
DbsRequestReplicaServiceStateSave(
    IN PREPLICA Replica,
    IN BOOL     Wait
    )
/*++
Routine Description:

     Call the DBService thread to save the replica service state.

Arguments:


    Replica    -- ptr to Replica struct.

    Wait -- True if we are to wait until update completes.

Return Value:
    FrsError status.  Only if wait is true else FrsErrorSuccess returned.

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsRequestReplicaServiceStateSave:"

    ULONG           FStatus = FrsErrorSuccess;
    ULONG           WStatus;
    PCOMMAND_PACKET CmdPkt;


    //
    // Tell the DBService to save the mark point.
    //
    CmdPkt = DbsPrepareCmdPkt(NULL,                   //  CmdPkt,
                              Replica,                //  Replica,
                              CMD_DBS_REPLICA_SERVICE_STATE_SAVE,  //  CmdRequest,
                              NULL,                   //  TableCtx,
                              NULL,                   //  CallContext,
                              0,                      //  TableType,
                              0,                      //  AccessRequest,
                              0,                      //  IndexType,
                              NULL,                   //  KeyValue,
                              0,                      //  KeyValueLength,
                              FALSE);                 //  Submit

    FRS_ASSERT(CmdPkt != NULL);


    if (Wait) {
        //
        // Make the call synchronous.
        // Don't free the packet when the command completes.
        //
        FrsSetCompletionRoutine(CmdPkt, FrsCompleteKeepPkt, NULL);

        //
        // SUBMIT db command request and wait for completion.
        //
        WStatus = FrsSubmitCommandServerAndWait(&DBServiceCmdServer, CmdPkt, INFINITE);
        DPRINT_WS(0, "ERROR: DB Command failed", WStatus);

        FStatus = CmdPkt->Parameters.DbsRequest.FStatus;
        FrsFreeCommand(CmdPkt, NULL);

    } else {

        //
        // Fire and forget the command.
        //
        FrsSubmitCommandServer(&DBServiceCmdServer, CmdPkt);
    }

    return FStatus;
}



VOID
DbsReplicaSaveStats(
    IN PTHREAD_CTX  ThreadCtx,
    IN PREPLICA     Replica
    )
/*++

Routine Description:

    Save the Stats in the Replica config record.

Arguments:

    ThreadCtx  -- A Thread context to use for dbid and sesid.
    Replica    -- ptr to Replica struct.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsReplicaSaveStats:"

    ULONG FStatus;

    //
    // Update the selected fields in the config record.
    //
    FStatus = DbsUpdateConfigTableFields(ThreadCtx,
                                         Replica,
                                         CnfStatFieldList,
                                         CnfStatFieldCount);
    DPRINT1_FS(0, "DbsReplicaSaveStats on %ws.", Replica->ReplicaName->Name, FStatus);
}



ULONG
DbsFidToGuid(
    IN PTHREAD_CTX   ThreadCtx,
    IN PREPLICA      Replica,
    IN PTABLE_CTX    TableCtx,
    IN PULONGLONG    Fid,
    OUT GUID         *Guid
    )
/*++
Routine Description:

    Translate the File IDs to it's object ID (GUID) by
    doing a lookup in the IDTable for the replica.

    Since the caller supplies the table context we do not free the table ctx
    storage here.  We do close the table though.  It is up to the caller to
    free the table ctx memory when finished with it.  Note that the same
    table ctx can be used on multiple calls thereby saving the cost of
    memory allocation each time.  To free the table ctx internal storage:

            DbsFreeTableContext(TableCtx, ThreadCtx->JSesid);
            TableCtx = NULL;


Arguments:
    ThreadCtx  -- A Thread context to use for dbid and sesid.
    Replica    -- The Replica ID table to do the lookup in.
    TableCtx   -- Caller supplied so we don't have to alloc storage on every call.
    Fid  -- The parent file ID to translate
    Guid -- The output parent object ID.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsFidToGuid:"

    JET_ERR     jerr, jerr1;

    PIDTABLE_RECORD      IDTableRec;
    ULONG       FStatus = FrsErrorSuccess;
    CHAR        GuidStr[GUID_CHAR_LEN];

    //
    // PERF: switch to using the DIR Table once the updates are in place.
    //
    if (Replica == NULL) {
        ZeroMemory(Guid, sizeof(GUID));
        return FrsErrorBadParam;
    }
    //
    // Open the IDTable for this replica and Read the IDTable Record
    // for the File ID.
    //
    jerr = DbsOpenTable(ThreadCtx, TableCtx, Replica->ReplicaNumber, IDTablex, NULL);

    if (!JET_SUCCESS(jerr)) {
        ZeroMemory(Guid, sizeof(GUID));
        return DbsTranslateJetError(jerr, FALSE);
    }

    jerr = DbsReadRecord(ThreadCtx, Fid, FileIDIndexx, TableCtx);

    IDTableRec = (PIDTABLE_RECORD) (TableCtx->pDataRecord);

    //
    // If the record is not found return the GUID, even if it is marked deleted.
    // That would just mean that a remote CO was processing a delete while a
    // local operation was updating the file and generating a USN record with
    // the FID.
    //
    if (!JET_SUCCESS(jerr)) {
        ZeroMemory(Guid, sizeof(GUID));
        FStatus = DbsTranslateJetError(jerr, FALSE);
    } else {
        COPY_GUID(Guid, &IDTableRec->FileGuid);

        if (IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETED)) {
            FStatus = FrsErrorIdtFileIsDeleted;
        } else {
            FStatus = FrsErrorSuccess;
        }
    }

    DbsCloseTable(jerr1, ThreadCtx->JSesid, TableCtx);

    GuidToStr((GUID *) Guid, GuidStr);
    DPRINT2(3,"++ FID to GUID: %08x %08x -> %s\n", PRINTQUAD(*Fid), GuidStr);

    return FStatus;
}




ULONG
DbsGuidToFid(
    IN PTHREAD_CTX   ThreadCtx,
    IN PREPLICA      Replica,
    IN PTABLE_CTX    TableCtx,
    IN GUID          *Guid,
    OUT PULONGLONG   Fid
    )
/*++
Routine Description:

    Translate the  File IDs to it's object ID (GUID) by
    doing a lookup in the IDTable for the replica.

    Since the caller supplies the table context we do not free the table ctx
    storage here.  We do close the table though.  It is up to the caller to
    free the table ctx memory when finished with it.  Note that the same
    table ctx can be used on multiple calls thereby saving the cost of
    memory allocation each time.  To free the table ctx internal storage:

            DbsFreeTableContext(TableCtx, ThreadCtx->JSesid);
            TableCtx = NULL;


Arguments:
    ThreadCtx  -- A Thread context to use for dbid and sesid.
    Replica    -- The Replica ID table to do the lookup in.
    TableCtx   -- Caller supplied so we don't have to alloc storage on every call.
    Guid -- The input parent object ID to translate.
    Fid  -- The output parent file ID

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsGuidToFid:"

    JET_ERR     jerr, jerr1;

    PIDTABLE_RECORD      IDTableRec;
    ULONG       FStatus;
    CHAR        GuidStr[GUID_CHAR_LEN];

    //
    // switch to using the DIR Table once the updates are in place.
    //

    if (Replica == NULL) {
        *Fid = ZERO_FID;
        return FrsErrorBadParam;
    }
    //
    // Open the IDTable for this replica and Read the IDTable Record
    // for the File ID.
    //
    jerr = DbsOpenTable(ThreadCtx, TableCtx, Replica->ReplicaNumber, IDTablex, NULL);

    if (!JET_SUCCESS(jerr)) {
        *Fid = ZERO_FID;
        return DbsTranslateJetError(jerr, FALSE);
    }

    jerr = DbsReadRecord(ThreadCtx, Guid, GuidIndexx, TableCtx);


    IDTableRec = (PIDTABLE_RECORD) (TableCtx->pDataRecord);

    //
    // If the record is not found or it is marked deleted, return a FID of zero.
    //
    if (!JET_SUCCESS(jerr)) {
        *Fid = ZERO_FID;
        FStatus = DbsTranslateJetError(jerr, FALSE);
    } else {
        //
        // 209483   B3SS : Assertion Qkey != 0
        // Return a fid even if the entry is deleted. The co will be
        // rejected eventually but intervening code asserts if fid is 0.
        //
        CopyMemory(Fid, &IDTableRec->FileID, sizeof(ULONGLONG));
        if (IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETED)) {
            FStatus = FrsErrorIdtFileIsDeleted;

        } else {
            FStatus = FrsErrorSuccess;
        }
    }

    DbsCloseTable(jerr1, ThreadCtx->JSesid, TableCtx);

    GuidToStr(Guid, GuidStr);
    DPRINT2(3,"++ GUID to FID: %s -> %08x %08x\n", GuidStr, PRINTQUAD(*Fid));

    return FStatus;
}




PUCHAR
PackMem(
    IN PUCHAR Dst,
    IN PVOID  Src,
    IN ULONG  Num
    )
/*++
Routine Description:
    Copy memory from Src to Dst and return the address of the byte
    at Dst + Num;

Arguments:
    Dst
    Src
    Num

Return Value:
    Dst + Num
--*/
{
#undef DEBSUB
#define DEBSUB  "PackMem:"
    CopyMemory(Dst, (PUCHAR)Src, Num);
    return Dst + Num;
}




PUCHAR
UnPackMem(
    IN PUCHAR Next,
    IN PVOID  Dst,
    IN ULONG  Num
    )
/*++
Routine Description:
    Copy memory from Next to Dst and return the address of the byte
    at Next + Num;

Arguments:
    Next
    Dst
    Num

Return Value:
    Next + Num
--*/
{
#undef DEBSUB
#define DEBSUB  "UnPackMem:"
    CopyMemory(Dst, Next, Num);
    return Next + Num;
}




ULONG
SizeOfString(
    IN PWCHAR String
    )
/*++
Routine Description:
    Size the string for the blob. The string begins with its length,
    including the null terminator, in a ULONG.

Arguments:
    String

Return Value:
    Size of the string + length
--*/
{
#undef DEBSUB
#define DEBSUB  "SizeOfString:"
    ULONG   Size;

    Size = sizeof(Size);
    if (String)
        Size += (wcslen(String) + 1) * sizeof(WCHAR);
    return Size;
}




PUCHAR
UnPackString(
    IN  PUCHAR   Next,
    OUT PWCHAR   *String
    )
/*++
Routine Description:
    Allocate and return a copy of the string at Next

Arguments:
    Next
    String

Return Value:
    Address of the copy of the string at Next and the address
    of the byte following the string.
--*/
{
#undef DEBSUB
#define DEBSUB  "UnPackString:"
    ULONG   Len;

    *String = NULL;

    Next = UnPackMem(Next, &Len, sizeof(Len));
    if (Len) {
        *String = FrsAlloc(Len);
        Next = UnPackMem(Next, *String, Len);
    }
    return Next;
}




PUCHAR
PackString(
    IN PUCHAR   Next,
    IN PWCHAR   String
    )
/*++
Routine Description:
    Pack the string into the blob

Arguments:
    Next
    String

Return Value:
    Address of the byte following the string.
--*/
{
#undef DEBSUB
#define DEBSUB  "PackString:"
    ULONG   Len;

    Len = (String) ? (wcslen(String) + 1) * sizeof(WCHAR) : 0;
    Next = PackMem(Next, &Len, sizeof(Len));
    if (Len)
        Next = PackMem(Next, String, Len);
    return Next;
}





ULONG
SizeOfGName(
    IN PGNAME GName
    )
/*++
Routine Description:
    Size the GName

Arguments:
    GName

Return Value:
    Size of the guid/name making up the gname
--*/
{
#undef DEBSUB
#define DEBSUB  "SizeGName:"
    return sizeof(GUID) + SizeOfString(GName->Name);
}





PUCHAR
UnPackGName(
    IN  PUCHAR   Next,
    OUT PGNAME   *GName
    )
/*++
Routine Description:
    Allocate and return a copy of the gname at Next

Arguments:
    Next
    GName

Return Value:
    Address of the copy of the gname at Next and the address
    of the byte following the gname.
--*/
{
#undef DEBSUB
#define DEBSUB  "UnPackGName:"
    PWCHAR  Name;

    *GName = FrsBuildGName((GUID *)FrsAlloc(sizeof(GUID)), NULL);
    Next = UnPackMem(Next, (*GName)->Guid, sizeof(GUID));
    return UnPackString(Next, &(*GName)->Name);
}





PUCHAR
PackGName(
    IN PUCHAR   Next,
    IN PGNAME   GName
    )
/*++
Routine Description:
    Pack the gname into the blob

Arguments:
    Next
    GName

Return Value:
    Address of the byte following the gname in the blob.
--*/
{
#undef DEBSUB
#define DEBSUB  "PackGName:"
    Next = PackMem(Next, GName->Guid, sizeof(GUID));
    return PackString(Next, GName->Name);
}





ULONG
DbsPackInboundPartnerState(
    IN  PREPLICA    Replica,
    IN  PTABLE_CTX  TableCtx
    )
/*++
Routine Description:
    Build a blob and attach it to the InboundPartnerState field.

Arguments:
    Replica
    TableCtx

Return Value:
    None
--*/
{
#undef DEBSUB
#define DEBSUB  "DbsPackInboundPartnerState:"
    PUCHAR  Next;
    ULONG   BlobSize;
    ULONG   FStatus;

    //
    // COMPUTE BLOB SIZE
    //

    //
    // Primitive types
    //
    BlobSize = 0;
    BlobSize += sizeof(BlobSize);
    BlobSize += sizeof(NtFrsMajor);
    BlobSize += sizeof(NtFrsMinor);

    //
    // Reallocate the blob
    //
    FStatus = DBS_REALLOC_FIELD(TableCtx, InboundPartnerStatex, BlobSize, FALSE);
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT(0, "++ ERROR - reallocating inbound partner blob\n");
        return FStatus;
    }

    //
    // POPULATE THE BLOB
    //
    Next = DBS_GET_FIELD_ADDRESS(TableCtx, InboundPartnerStatex);

    //
    // Primitive types
    //
    Next = PackMem(Next, &BlobSize, sizeof(BlobSize));
    Next = PackMem(Next, &NtFrsMajor, sizeof(NtFrsMajor));
    Next = PackMem(Next, &NtFrsMinor, sizeof(NtFrsMinor));

    FRS_ASSERT(Next == BlobSize +
                   (PUCHAR)DBS_GET_FIELD_ADDRESS(TableCtx, InboundPartnerStatex));

    //
    // Done
    //
    return FrsErrorSuccess;
}


ULONG
DbsUnPackInboundPartnerState(
    IN PREPLICA     Replica,
    IN PTABLE_CTX   TableCtx
    )
/*++
Routine Description:
    Unpack the InboundPartnerState blob.

Arguments:
    Replica
    TableCtx

Return Value:
    None
--*/
{
#undef DEBSUB
#define DEBSUB  "DbsUnPackInboundPartnerState:"
    PUCHAR  Next;
    ULONG   BlobSize;
    ULONG   ConfigMajor;
    ULONG   ConfigMinor;

    //
    // POPULATE THE BLOB
    //
    Next = DBS_GET_FIELD_ADDRESS(TableCtx, InboundPartnerStatex);
    if (Next == NULL) {
        return FrsErrorSuccess;
    }

    //
    // Blob's size
    //
    Next = UnPackMem(Next, &BlobSize, sizeof(BlobSize));
    if (BlobSize == 0) {
        return FrsErrorSuccess;
    }

    //
    // Major, minor
    //
    Next = UnPackMem(Next, &ConfigMajor, sizeof(ConfigMajor));
    Next = UnPackMem(Next, &ConfigMinor, sizeof(ConfigMinor));
    if (ConfigMajor != NtFrsMajor) {
        DPRINT(0, "++ ERROR - BAD MAJOR IN CONFIG RECORD; shutting down\n");
        FRS_ASSERT(!"BAD MAJOR VERSION NUMBER IN CONFIG RECORD.");
        return FrsErrorAccess;
    }

    FRS_ASSERT(Next == BlobSize +
                   (PUCHAR)DBS_GET_FIELD_ADDRESS(TableCtx, InboundPartnerStatex));

    //
    // Done
    //
    return ERROR_SUCCESS;
}


ULONG
DbsPackIntoConfigRecordBlobs(
    IN  PREPLICA    Replica,
    IN  PTABLE_CTX  TableCtx
    )
/*++
Routine Description:
    Build a blob and attach it to the configrecord->InboundPartnerState

Arguments:
    Replica
    TableCtx

Return Value:
    None
--*/
{
#undef DEBSUB
#define DEBSUB  "DbsPackIntoConfigRecordBlobs:"

    ULONG   FStatus;

    FStatus = DbsPackInboundPartnerState(Replica, TableCtx);
    if (FRS_SUCCESS(FStatus)) {
        FStatus = DbsPackSchedule(Replica->Schedule, ReplSchedx, TableCtx);
    }
    return FStatus;
}


ULONG
DbsUnPackFromConfigRecordBlobs(
    IN  PREPLICA    Replica,
    IN  PTABLE_CTX  TableCtx
    )
/*++
Routine Description:
    Unpack the ConfigRecord's blobs.

Arguments:
    Replica
    TableCtx

Return Value:
    None
--*/
{
#undef DEBSUB
#define DEBSUB  "DbsUnPackFromConfigRecordBlobs:"
    ULONG   FStatus;

    FStatus = DbsUnPackInboundPartnerState(Replica, TableCtx);

    if (FRS_SUCCESS(FStatus)) {
        FStatus = DbsUnPackSchedule(&Replica->Schedule, ReplSchedx, TableCtx);
        DBS_DISPLAY_SCHEDULE(4, L"Schedule unpacked for Replica:", Replica->Schedule);
    }

    return FStatus;
}



ULONG
DbsPackSchedule(
    IN  PSCHEDULE   Schedule,
    IN  ULONG       Fieldx,
    IN  PTABLE_CTX  TableCtx
    )
/*++
Routine Description:
    Build a blob and attach it to the ReplSched field.

Arguments:
    Schedule
    Fieldx
    TableCtx

Return Value:
    None
--*/
{
#undef DEBSUB
#define DEBSUB  "DbsPackSchedule:"
    PUCHAR  Next;
    ULONG   BlobSize;
    ULONG   FStatus;
    ULONG   ScheduleLength;

    DBS_DISPLAY_SCHEDULE(4, L"Schedule packing:", Schedule);

    //
    // EMPTY BLOB
    //
    if (Schedule == NULL) {
        FStatus = DBS_REALLOC_FIELD(TableCtx, Fieldx, 0, FALSE);
        DPRINT_FS(0, "++ ERROR - reallocating schedule blob to 0.", FStatus);
        return FStatus;
    }

    //
    // COMPUTE BLOB SIZE
    //

    //
    // Primitive types
    //
    BlobSize = 0;
    BlobSize += sizeof(BlobSize);
    BlobSize += sizeof(ScheduleLength);
    ScheduleLength = (Schedule->Schedules[Schedule->NumberOfSchedules - 1].Offset
                      + SCHEDULE_DATA_ENTRIES);
    BlobSize += ScheduleLength;

    //
    // Reallocate the blob
    //
    FStatus = DBS_REALLOC_FIELD(TableCtx, Fieldx, BlobSize, FALSE);
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT1_FS(0, "++ ERROR - reallocating schedule blob to %d.", BlobSize, FStatus);
        return FStatus;
    }

    //
    // POPULATE THE BLOB
    //
    Next = DBS_GET_FIELD_ADDRESS(TableCtx, Fieldx);

    //
    // Primitive types
    //
    Next = PackMem(Next, &BlobSize, sizeof(BlobSize));
    Next = PackMem(Next, &ScheduleLength, sizeof(ScheduleLength));
    Next = PackMem(Next, Schedule, ScheduleLength);

    FRS_ASSERT(Next == BlobSize +
               (PUCHAR)DBS_GET_FIELD_ADDRESS(TableCtx, Fieldx));

    //
    // Done
    //
    return FrsErrorSuccess;
}




ULONG
DbsUnPackSchedule(
    IN PSCHEDULE    *Schedule,
    IN ULONG        Fieldx,
    IN PTABLE_CTX   TableCtx
    )
/*++
Routine Description:
    Unpack the schedule blob.

Arguments:
    Schedule
    Fieldx
    TableCtx

Return Value:
    None
--*/
{
#undef DEBSUB
#define DEBSUB  "DbsUnPackSchedule:"
    PUCHAR  Next;
    ULONG   BlobSize;
    ULONG   ScheduleLength;

    //
    // No schedule so far
    //
    *Schedule = FrsFree(*Schedule);

    //
    // POPULATE THE BLOB
    //
    Next = DBS_GET_FIELD_ADDRESS(TableCtx, Fieldx);
    if (Next == NULL) {
        return FrsErrorSuccess;
    }

    //
    // Blob's size
    //
    Next = UnPackMem(Next, &BlobSize, sizeof(BlobSize));
    if (BlobSize == 0) {
        return FrsErrorSuccess;
    }

    //
    // Schedule's size
    //
    Next = UnPackMem(Next, &ScheduleLength, sizeof(ScheduleLength));
    if (ScheduleLength == 0) {
        return FrsErrorSuccess;
    }

    *Schedule = FrsAlloc(ScheduleLength);
    Next = UnPackMem(Next, *Schedule, ScheduleLength);

    FRS_ASSERT(Next == BlobSize +
                   (PUCHAR)DBS_GET_FIELD_ADDRESS(TableCtx, Fieldx));
    //
    // Done
    //
    return FrsErrorSuccess;
}


ULONG
DbsPackStrW(
    IN  PWCHAR      StrW,
    IN  ULONG       Fieldx,
    IN  PTABLE_CTX  TableCtx
    )
/*++
Routine Description:
    Update a variable length string field.

Arguments:
    StrW
    Fieldx
    TableCtx

Return Value:
    None
--*/
{
#undef DEBSUB
#define DEBSUB  "DbsPackStrW:"
    PUCHAR  Next;
    ULONG   BlobSize;
    ULONG   FStatus;

    //
    // EMPTY BLOB
    //
    if (StrW == NULL) {
        FStatus = DBS_REALLOC_FIELD(TableCtx, Fieldx, 0, FALSE);
        DPRINT_FS(0, "++ ERROR - reallocating string blob to 0.", FStatus);
        return FStatus;
    }

    //
    // COMPUTE BLOB SIZE
    //
    BlobSize = (wcslen(StrW) + 1) * sizeof(WCHAR);

    //
    // Reallocate the blob
    //
    FStatus = DBS_REALLOC_FIELD(TableCtx, Fieldx, BlobSize, FALSE);
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT1_FS(0, "++ ERROR - reallocating string blob to %d.", BlobSize, FStatus);
        return FStatus;
    }

    //
    // POPULATE THE BLOB
    //
    Next = DBS_GET_FIELD_ADDRESS(TableCtx, Fieldx);
    CopyMemory(Next, StrW, BlobSize);

    //
    // Done
    //
    return FrsErrorSuccess;
}




ULONG
DbsUnPackStrW(
    OUT PWCHAR       *StrW,
    IN  ULONG        Fieldx,
    IN  PTABLE_CTX   TableCtx
    )
/*++
Routine Description:
    Unpack the string

Arguments:
    StrW
    Fieldx
    TableCtx

Return Value:
    None
--*/
{
#undef DEBSUB
#define DEBSUB  "DbsUnPackStrW:"
    PUCHAR  Next;
    ULONG   BlobSize;

    //
    // No string so far
    //
    *StrW = FrsFree(*StrW);

    //
    // Find the address of the string
    //
    Next = DBS_GET_FIELD_ADDRESS(TableCtx, Fieldx);
    if (Next == NULL) {
        return FrsErrorSuccess;
    }

    //
    // Blob's size
    //
    BlobSize = (wcslen((PWCHAR)Next) + 1) * sizeof(WCHAR);
    if (BlobSize == 0) {
        return FrsErrorSuccess;
    }

    //
    // Unpack the string
    //
    *StrW = FrsAlloc(BlobSize);
    CopyMemory(*StrW, Next, BlobSize);

    //
    // Done
    //
    return FrsErrorSuccess;
}



PVOID
DbsDataExtensionFind(
    IN PVOID ExtBuf,
    IN DATA_EXTENSION_TYPE_CODES TypeCode
    )
/*++
Routine Description:

    Search the data extension buffer for the desired data component.

Arguments:
    ExtBuf    -- Ptr to data extension buffer.

    TypeCode  -- The component data type to find.

Return Value:

    Ptr to the data component or NULL if not found.

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsDataExtensionFind:"


    PULONG pOffset;
    PULONG pULong;
    PDATA_EXTENSION_PREFIX    ComponentPrefix;
    PIDTABLE_RECORD_EXTENSION IdtExt;



    FRS_ASSERT(TypeCode < DataExtend_Max);
    FRS_ASSERT(ExtBuf != NULL);

    //
    // All data extensions have the same prefix layout so use the IDTable.
    //
    IdtExt = (PIDTABLE_RECORD_EXTENSION) ExtBuf;

    if (IdtExt->FieldSize == 0) {
        return NULL;
    }

    if (IdtExt->FieldSize >= REALLY_BIG_EXTENSION_SIZE) {
        pULong = ExtBuf;

        DPRINT5(5, "Extension Buffer: (%08x) %08x %08x %08x %08x\n",
                   pULong, *(pULong+0), *(pULong+1), *(pULong+2), *(pULong+3));
        DPRINT5(5, "Extension Buffer: (%08x) %08x %08x %08x %08x\n",
                   (PCHAR)pULong+16, *(pULong+4), *(pULong+5), *(pULong+6), *(pULong+7));

        FRS_ASSERT(!"IdtExt->FieldSize invalid");
    }

    //
    // Loop thru the data component offset array to find the desired type.
    //
    pOffset = &IdtExt->Offset[0];

    while (*pOffset != 0) {
        ComponentPrefix = (PDATA_EXTENSION_PREFIX) ((PCHAR)IdtExt + *pOffset);

        if (ComponentPrefix->Type == TypeCode) {
            return  ComponentPrefix;
        }
        pOffset += 1;
    }

    return NULL;
}


VOID
DbsDataInitIDTableExtension(
    IN PIDTABLE_RECORD_EXTENSION IdtExt
    )
/*++
Routine Description:

    Init the IDTable data extension buffer.

Arguments:
    IdtExt    -- Ptr to data extension buffer.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsDataInitIDTableExtension:"

    PDATA_EXTENSION_PREFIX    ComponentPrefix;

    FRS_ASSERT(IdtExt != NULL);

    //
    // Init the extension buffer.
    //
    IdtExt->FieldSize = sizeof(IDTABLE_RECORD_EXTENSION);
    IdtExt->Major = 0;
    IdtExt->OffsetCount = ARRAY_SZ(IdtExt->Offset);

    //
    // Init offset to Data Checksum Component and its prefix.
    //
    IdtExt->Offset[0] = OFFSET(IDTABLE_RECORD_EXTENSION, DataChecksum);
    IdtExt->DataChecksum.Prefix.Size = sizeof(DATA_EXTENSION_CHECKSUM);
    IdtExt->DataChecksum.Prefix.Type = DataExtend_MD5_CheckSum;

    //
    // Terminate offset vector with a zero
    //
    IdtExt->OffsetLast = 0;
}





VOID
DbsDataInitCocExtension(
    IN PCHANGE_ORDER_RECORD_EXTENSION CocExt
    )
/*++
Routine Description:

    Init the Change Order record extension buffer.

Arguments:

    CocExt -- Ptr to data extension buffer.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB  "DbsDataInitCocExtension:"

    PDATA_EXTENSION_PREFIX    ComponentPrefix;

    FRS_ASSERT(CocExt != NULL);

    //
    // Init the extension buffer.
    //
    CocExt->FieldSize = sizeof(CHANGE_ORDER_RECORD_EXTENSION);
    CocExt->Major = 0;
    CocExt->OffsetCount = ARRAY_SZ(CocExt->Offset);

    //
    // Init offset to Data Checksum Component and its prefix.
    //
    CocExt->Offset[0] = OFFSET(CHANGE_ORDER_RECORD_EXTENSION, DataChecksum);
    CocExt->DataChecksum.Prefix.Size = sizeof(DATA_EXTENSION_CHECKSUM);
    CocExt->DataChecksum.Prefix.Type = DataExtend_MD5_CheckSum;

    //
    // Terminate offset vector with a zero
    //
    CocExt->OffsetLast = 0;

}



VOID
DbsInitialize (
    VOID
    )
/*++
Routine Description:
    External entrypoint for database initialization.

Arguments:
    None.

Return Value:
    winerror
--*/
{
#undef DEBSUB
#define DEBSUB  "DbsInitialize:"
    PCOMMAND_PACKET CmdPkt;
    BOOL            EmptyDatabase;
    ULONG           Status;

    PCO_RETIRE_DECISION_TABLE pDecRow;
    ULONG  DCMask, CondMatch, i, j;

    //
    // Init the global replica list.
    //
    FrsInitializeQueue(&ReplicaListHead, &ReplicaListHead);

    FrsInitializeQueue(&ReplicaStoppedListHead, &ReplicaStoppedListHead);

    FrsInitializeQueue(&ReplicaFaultListHead, &ReplicaFaultListHead);

    //
    // Lock held when moving a replica set between state lists
    //
    InitializeCriticalSection(&JrnlReplicaStateLock);

    //
    // Step thru the decision table and init the Don't care mask and Condition
    // Match fields for each row.
    //
    pDecRow = CoRetireDecisionTable;
    j = 0;

    while (pDecRow->RetireFlag != 0) {
        DCMask = 0;
        CondMatch = 0;
        for (i=0; i < ARRAY_SZ(pDecRow->ConditionTest); i++) {
            if (pDecRow->ConditionTest[i] == 0) {
                // Don't care field sets mask and match to zero.
                DCMask    = (DCMask    << 1) | 0;
                CondMatch = (CondMatch << 1) | 0;
            } else
            if (pDecRow->ConditionTest[i] == 1) {
                // Match on 1 (or True) field sets mask and match to one.
                DCMask    = (DCMask    << 1) | 1;
                CondMatch = (CondMatch << 1) | 1;
            } else {
                // Match on 0 (or False) field sets mask to one and match to zero.
                DCMask    = (DCMask    << 1) | 1;
                CondMatch = (CondMatch << 1) | 0;
            }
        }
        pDecRow->DontCareMask = DCMask;
        pDecRow->ConditionMatch = CondMatch;
        DPRINT3(4, ":I: Retire Decision[%2d] Mask, Match :  %08x  %08x\n",
                j++, DCMask, CondMatch);

        pDecRow += 1;
    }

    //
    // Create the File System monitor thread.  It inits its process queue
    // and then waits for a packet.  First packet should be to init.
    //
    //
    // Init the journal queue and setup our entry in the sybsystem
    // queue vector so we can receive commands.
    //
    FrsInitializeQueue(&JournalProcessQueue, &JournalProcessQueue);

    if (!ThSupCreateThread(L"JRNL", NULL, Monitor, ThSupExitThreadNOP)) {
        DPRINT(0, ":S: ERROR - Could not create Monitor thread\n");
        return;
    }

    //
    // Create the Database Service command server.  It inits its process queue
    // and then waits for a packet.  First packet should be to init.
    // The purpose of this service thread is to to perform simple operations
    // on the database from a thread environment where you don't have an
    // open table and it's not worth the effort to do it there.  E.G. updating
    // the Volume Sequence Number in a Replicas REPLICA struct.
    //
    //
    FrsInitializeCommandServer(&DBServiceCmdServer,
                               DBSERVICE_MAX_THREADS,
                               L"DBCs",
                               DBService);
    //
    // Init the DBService sub-system.
    //
    CmdPkt = DbsPrepareCmdPkt(NULL,                //  CmdPkt,
                              NULL,                //  Replica,
                              CMD_INIT_SUBSYSTEM,  //  CmdRequest,
                              NULL,                //  TableCtx,
                              NULL,                //  CallContext,
                              0,                   //  TableType,
                              0,                   //  AccessRequest,
                              0,                   //  IndexType,
                              NULL,                //  KeyValue,
                              0,                   //  KeyValueLength,
                              TRUE);               //  Submit

    //
    // Init and start the journal sub-system.
    //
    CmdPkt = FrsAllocCommand(&JournalProcessQueue, CMD_INIT_SUBSYSTEM);
    FrsSubmitCommand(CmdPkt, FALSE);
}


VOID
DbsShutDown (
    VOID
    )
/*++
Routine Description:
    External entrypoint for database shutdown.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "DbsShutDown:"

PCOMMAND_PACKET      CmdPkt;
    //
    // Tell the DBService sub-system to stop.
    //
    DbsPrepareCmdPkt(NULL,                //  CmdPkt,
                     NULL,                //  Replica,
                     CMD_STOP_SUBSYSTEM,  //  CmdRequest,
                     NULL,                //  TableCtx,
                     NULL,                //  CallContext,
                     0,                   //  TableType,
                     0,                   //  AccessRequest,
                     0,                   //  IndexType,
                     NULL,                //  KeyValue,
                     0,                   //  KeyValueLength,
                     TRUE);               //  Submit
}



#if 0
// Test code.

VOID
DbsOperationTest(
    VOID
    )
/*++

Routine Description:

    This is a test routine that reads and writes config records and creates
    a new replica set.

Arguments:

    None.

Thread Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsOperationTest:"


    ULONG                WStatus;
    ULONG                FStatus;
    ULONG                AccessRequest;
    PFRS_REQUEST_COUNT   DbRequestCount;
    PDB_SERVICE_REQUEST  DbsRequest;
    GUID                 ReplicaMemberGuid;
    ULONG                ReplicaNumber;
    PCOMMAND_PACKET      CmdPkt;
    PTABLE_CTX           TableCtx;
    PCONFIG_TABLE_RECORD ConfigRecord;
    FILETIME             SystemTime;

    //
    // Allocate and init a request count struct so we know when our commands
    // have been finished.
    //
    DPRINT(0, "BEGIN DBS READ LOOP ***************************************\n");
    DbRequestCount = FrsAlloc(sizeof(FRS_REQUEST_COUNT));
    FrsInitializeRequestCount(DbRequestCount);

    AccessRequest = DBS_ACCESS_FIRST;
    CmdPkt = NULL;
    TableCtx = NULL;
    FStatus = FrsErrorSuccess;

    while (FStatus != FrsErrorEndOfTable) {

        CmdPkt = DbsPrepareCmdPkt(CmdPkt,              //  CmdPkt,
                                  NULL,                //  Replica,
                                  CMD_READ_TABLE_RECORD, //  CmdRequest,
                                  TableCtx,            //  TableCtx,
                                  NULL,                //  CallContext,
                                  ConfigTablex,        //  TableType,
                                  AccessRequest,       //  AccessRequest,
                                  ReplicaSetNameIndexx,//  IndexType,
                                  NULL,                //  KeyValue,
                                  0,                   //  KeyValueLength,
                                  FALSE);              //  Submit

        if (CmdPkt == NULL) {
            DPRINT(0, "ERROR - Failed to init the cmd pkt\n");
            break;
        }
        FrsIncrementRequestCount(DbRequestCount);
        FrsSetCompletionRoutine(CmdPkt, FrsCompleteRequestCountKeepPkt, DbRequestCount);

        FrsSubmitCommandServer(&DBServiceCmdServer, CmdPkt);
        //
        // Wait until command request is completed.
        //
        WStatus = FrsWaitOnRequestCount(DbRequestCount, 10000);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT_WS(0, "ERROR - FrsWaitOnRequestCount(DbRequestCount) failed", WStatus);
            break;
        }

        DbsRequest = &CmdPkt->Parameters.DbsRequest;
        TableCtx = DBS_GET_TABLECTX(DbsRequest);
        FStatus = DbsRequest->FStatus;

        if (FRS_SUCCESS(FStatus)) {
            //
            // Print the config record.
            //
            if (TableCtx == NULL) {
                DPRINT(0, "ERROR - TableCtx is NULL on return from DBS.\n");
            }
            // FRS_DISPLAY_RECORD(TableCtx, TRUE);
        } else
        if (FStatus == FrsErrorEndOfTable) {
            break;
        } else {
            DPRINT_FS(0, "ERROR - Read DBservice request failed.", FStatus);
            break;
        }

        //
        // Now write the record back by key with a minor change.
        //

        ConfigRecord = (PCONFIG_TABLE_RECORD) DBS_GET_RECORD_ADDRESS(DbsRequest);

        ConfigRecord->MaxInBoundLogSize += 1;  // Testing

        DbsPrepareCmdPkt(CmdPkt,                        //  CmdPkt,
                         NULL,                          //  Replica,
                         CMD_UPDATE_TABLE_RECORD,       //  CmdRequest,
                         TableCtx,                      //  TableCtx,
                         NULL,                          //  CallContext,
                         ConfigTablex,                  //  TableType,
                         DBS_ACCESS_BYKEY,              //  AccessRequest,
                         ReplicaNumberIndexx,           //  IndexType,
                         &ConfigRecord->ReplicaNumber,  //  KeyValue,
                         sizeof(ULONG),                 //  KeyValueLength,
                         FALSE);                        //  Submit

        FrsIncrementRequestCount(DbRequestCount);
        FrsSetCompletionRoutine(CmdPkt, FrsCompleteRequestCountKeepPkt, DbRequestCount);

        FrsSubmitCommandServer(&DBServiceCmdServer, CmdPkt);
        //
        // Wait until command request is completed.
        //
        WStatus = FrsWaitOnRequestCount(DbRequestCount, 10000);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT_WS(0, "ERROR - FrsWaitOnRequestCount(DbRequestCount) failed", WStatus);
            break;
        }

        DbsRequest = &CmdPkt->Parameters.DbsRequest;
        TableCtx = DBS_GET_TABLECTX(DbsRequest);
        FStatus = DbsRequest->FStatus;

        if (FRS_SUCCESS(FStatus)) {
            //
            // Print the config record.
            //
            if (TableCtx == NULL) {
                DPRINT(0, "ERROR - TableCtx is NULL on return from DBS.\n");
            }
            // FRS_DISPLAY_RECORD(TableCtx, TRUE);
        } else {
            DPRINT_FS(0, "ERROR - Write DBservice request failed.", FStatus);
            break;
        }

        ConfigRecord = NULL;
        AccessRequest = DBS_ACCESS_NEXT;

    }  // end of while()

    //
    // Close the table and cleanup the request count.
    //
    if (CmdPkt != NULL) {
        //
        // change the completion routine to delete the cmd pkt and send the close.
        // This frees the table context and the associated data record.
        //
        FrsSetCompletionRoutine(CmdPkt, FrsFreeCommand, 0);

        DbsPrepareCmdPkt(CmdPkt,                   //  CmdPkt,
                         NULL,                     //  Replica,
                         CMD_CLOSE_TABLE,          //  CmdRequest,
                         TableCtx,                 //  TableCtx,
                         NULL,                     //  CallContext,
                         0,                        //  TableType,
                         DBS_ACCESS_FREE_TABLECTX, //  AccessRequest,
                         0,                        //  IndexType,
                         NULL,                     //  KeyValue,
                         0,                        //  KeyValueLength,
                         TRUE);                    //  Submit

    }


    DPRINT(0, "END DBS READ LOOP ***************************************\n");


    //
    // The following example creates a new replica set member.
    // It inserts a new record into the config table and creates a set
    // of associated replica tables.
    //
    // First create a table context for the record.
    //
    DPRINT(0, "BEGIN DBS INSERT ***************************************\n");

    TableCtx = DbsCreateTableContext(ConfigTablex);

    CmdPkt = NULL;
    CmdPkt = DbsPrepareCmdPkt(CmdPkt,              //  CmdPkt,
                              NULL,                //  Replica,
                              CMD_CREATE_REPLICA_SET_MEMBER, //  CmdRequest,
                              TableCtx,            //  TableCtx,
                              NULL,                //  CallContext,
                              ConfigTablex,        //  TableType,
                              DBS_ACCESS_CLOSE,    //  AccessRequest,
                              0,                   //  IndexType,
                              NULL,                //  KeyValue,
                              0,                   //  KeyValueLength,
                              FALSE);              //  Submit

    if (CmdPkt == NULL) {
        DPRINT(0, "ERROR - Failed to init the cmd pkt\n");
        FrsDeleteRequestCount(DbRequestCount);
        goto DB_QUERY_FAILED;
    }

    DbsRequest = &CmdPkt->Parameters.DbsRequest;
    ConfigRecord = (PCONFIG_TABLE_RECORD) DBS_GET_RECORD_ADDRESS(DbsRequest);

    //
    // Init the config record.
    //
    FrsUuidCreate(&ReplicaMemberGuid);
    ReplicaNumber = InterlockedIncrement(&FrsMaxReplicaNumberUsed);

    DbsDBInitConfigRecord(ConfigRecord,                // ConfigRecord
                          &ReplicaMemberGuid,          // ReplicaSetGuid
                          TEXT("Replica-V:foo3"),      // ReplicaSetName
                          ReplicaNumber,               // ReplicaNumber
                          TEXT("u:\\sub1\\foo3"),      // ReplicaRootPath
                          TEXT("u:\\tmp"),             // ReplicaStagingPath
                          TEXT("u:\\"));               // ReplicaVolume

    GetSystemTimeAsFileTime(&SystemTime);
    COPY_TIME(&ConfigRecord->LastDSChangeAccepted, &SystemTime);

    // FRS_DISPLAY_RECORD(TableCtx, TRUE);
    //
    // Resize some of the binary fields.
    //

    DPRINT3(4, "Field ThrottleSched- Size: %d, MaxSize %d, Address: %08x\n",
        DBS_GET_FIELD_SIZE(TableCtx, ThrottleSchedx),
        DBS_GET_FIELD_SIZE_MAX(TableCtx, ThrottleSchedx),
        DBS_GET_FIELD_ADDRESS(TableCtx, ThrottleSchedx));


    DPRINT3(4, "Field FileTypePrioList- Size: %d, MaxSize %d, Address: %08x\n",
        DBS_GET_FIELD_SIZE(TableCtx, FileTypePrioListx),
        DBS_GET_FIELD_SIZE_MAX(TableCtx, FileTypePrioListx),
        DBS_GET_FIELD_ADDRESS(TableCtx, FileTypePrioListx));


    FStatus = DBS_REALLOC_FIELD(TableCtx, ThrottleSchedx, 100, FALSE);
    DPRINT_FS(0, "Error - Failed realloc of ThrottleSched.", FStatus);

    FStatus = DBS_REALLOC_FIELD(TableCtx, FileTypePrioListx, 0, FALSE);
    DPRINT_FS(0, "Error - Failed realloc of FileTypePrioListx.", FStatus);

    DPRINT3(4, "Field ThrottleSched- Size: %d, MaxSize %d, Address: %08x\n",
        DBS_GET_FIELD_SIZE(TableCtx, ThrottleSchedx),
        DBS_GET_FIELD_SIZE_MAX(TableCtx, ThrottleSchedx),
        DBS_GET_FIELD_ADDRESS(TableCtx, ThrottleSchedx));

    DPRINT3(4, "Field FileTypePrioList- Size: %d, MaxSize %d, Address: %08x\n",
        DBS_GET_FIELD_SIZE(TableCtx, FileTypePrioListx),
        DBS_GET_FIELD_SIZE_MAX(TableCtx, FileTypePrioListx),
        DBS_GET_FIELD_ADDRESS(TableCtx, FileTypePrioListx));

    // FRS_DISPLAY_RECORD(TableCtx, TRUE);

    //
    // Set up request count and completion routine.  Then submit the command.
    //
    FrsIncrementRequestCount(DbRequestCount);
    FrsSetCompletionRoutine(CmdPkt, FrsCompleteRequestCountKeepPkt, DbRequestCount);

    FrsSubmitCommandServer(&DBServiceCmdServer, CmdPkt);
    //
    // Wait until command request is completed.
    //
    WStatus = FrsWaitOnRequestCount(DbRequestCount, 10000);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT_WS(0, "ERROR - FrsWaitOnRequestCount(DbRequestCount) failed", WStatus);
        //
        // Can't free memory because DB server could still use it.
        //
        goto DB_QUERY_FAILED2;
    }

    FStatus = DbsRequest->FStatus;

    if (FRS_SUCCESS(FStatus)) {
        //
        // Print the config record.
        //
        if (TableCtx == NULL) {
            DPRINT(0, "ERROR - TableCtx is NULL on return from DBS.\n");
        }
        // FRS_DISPLAY_RECORD(TableCtx, TRUE);
    } else {
        DPRINT_FS(0, "ERROR - Insert DBservice request failed.", FStatus);
    }


    //
    // Pitch the table context and the command packet.
    //
    if (!DbsFreeTableContext(TableCtx, 0)) {
        DPRINT(0, "ERROR - Failed to free the table context\n");
    }

    FrsFreeCommand(CmdPkt, NULL);


    FrsDeleteRequestCount(DbRequestCount);

DB_QUERY_FAILED:
    DbRequestCount = FrsFree(DbRequestCount);

DB_QUERY_FAILED2:

    DPRINT(0, "END DBS WRITE TEST ***************************************\n");


}

#endif 0




#if 0


//
// Wrapper for NtQuerySystemInformation call.
// (assumes that Status is declared as NTSTATUS and QuerySysInfoReturnLength
// is declared ULONG).
//
#define QuerySysInfo(_InfoClass, _InfoStruct) \
    Status = NtQuerySystemInformation(_InfoClass, \
                                     &_InfoStruct, \
                                     sizeof(_InfoStruct), \
                                     &QuerySysInfoReturnLength); \
    if (!NT_SUCCESS(Status)) {  \
        printf ("NtQuerySystemInfo - %s failed ", #_InfoClass);  \
        printf ("with status %x on %s\n", Status, #_InfoStruct);  \
        DisplayNTStatus(Status); \
        }

#define QuerySysInfo3(_InfoClass, _InfoStruct, _InfoAddress) \
    Status = NtQuerySystemInformation(_InfoClass, \
                                      _InfoAddress, \
                                     sizeof(_InfoStruct), \
                                     &QuerySysInfoReturnLength); \
    if (!NT_SUCCESS(Status)) {  \
        printf ("NtQuerySystemInfo - %s failed ", #_InfoClass);  \
        printf ("with status %x on %s\n", Status, #_InfoStruct);  \
        DisplayNTStatus(Status); \
        }


    ULONG QuerySysInfoReturnLength;
    NTSTATUS Status;
    ULONG i;
    SYSTEM_TIMEOFDAY_INFORMATION LocalTimeOfDayInfo;
    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION ProcessorPerformanceInfo[MAX_CPUS];
    SYSTEM_PERFORMANCE_INFORMATION SystemPerformanceInfo;
    SYSTEM_EXCEPTION_INFORMATION SystemExceptionInfo;
    SYSTEM_INTERRUPT_INFORMATION SystemInterruptInfo[MAX_CPUS];
    SYSTEM_CONTEXT_SWITCH_INFORMATION ContextSwitchInfo;

    QuerySysInfo(SystemTimeOfDayInformation, LocalTimeOfDayInfo);



    QuerySysInfo(SystemPerformanceInformation, SystemPerformanceInfo);

QuerySysInfo(SystemProcessorPerformanceInformation, ProcessorPerformanceInfo);
QuerySysInfo(SystemExceptionInformation, SystemExceptionInfo);
QuerySysInfo(SystemInterruptInformation, SystemInterruptInfo);
QuerySysInfo(SystemContextSwitchInformation, ContextSwitchInfo);

    NtQuerySystemInformation(
        SystemTimeOfDayInformation,
        &LocalTimeOfDayInfo,
        sizeof(LocalTimeOfDayInfo),
        &ReturnLocalTimeOfDayInfoLength);

    UpTime = (LocalTimeOfDayInfo.CurrentTime.QuadPart -
             LocalTimeOfDayInfo.BootTime.QuadPart) / (LONGLONG) 10000000;
    printf("System Up Time (hours)          %8.2f\n", (float)UpTime/3600.0);

        szChar = sizeof(Buf);
    GetVolumeInformation(NULL, NULL, (ULONG) NULL, NULL, NULL, NULL, Buf, szChar);
    printf( "Filesystem Type: %s\n", Buf );

        //
    //      Get the disk space status:
    //
    GetDiskFreeSpace( NULL, &sec, &bytes, &fclust, &tclust );
    printf( "\t%-16s %3.1f/%3.1f\n",
                            "Disk Space",
                            ((double)sec*bytes*fclust)/MBYTE,
                            ((double)sec*bytes*tclust)/MBYTE );



        CHAR KernelPath[MAX_PATH];
        GetSystemDirectory(KernelPath,sizeof(KernelPath));


    for (i = 0; i < NumberCpus; i++) {
        Sample->TotalCpuTime[i] = ProcessorPerformanceInfo[i].KernelTime.QuadPart +
                                  ProcessorPerformanceInfo[i].UserTime.QuadPart;
        //
        // kernel time also includes the system idle thread so remove this
        // from the kernel time component.
        //
        Sample->KernelTime[i] = ProcessorPerformanceInfo[i].KernelTime.QuadPart -
                                ProcessorPerformanceInfo[i].IdleTime.QuadPart;

        Sample->CpuTime[i] = Sample->KernelTime[i] +
                             ProcessorPerformanceInfo[i].UserTime.QuadPart;
        Sample->Nb3ClientCpuTime += Sample->CpuTime[i];

        Sample->IdleTime[i] = ProcessorPerformanceInfo[i].IdleTime.QuadPart;
        Sample->UserTime[i] = ProcessorPerformanceInfo[i].UserTime.QuadPart;
        //
        // Note that DpcTime and InterruptTime are also included in Kernel Time.
        //
        Sample->DpcTime[i] = ProcessorPerformanceInfo[i].DpcTime.QuadPart;
        Sample->InterruptTime[i] = ProcessorPerformanceInfo[i].InterruptTime.QuadPart;
        Sample->InterruptCount[i] = (ULONGLONG) ProcessorPerformanceInfo[i].InterruptCount;

        Sample->CpuCtxSwitches[i] = SystemInterruptInfo[i].ContextSwitches;
        Sample->DpcCount[i]       = SystemInterruptInfo[i].DpcCount;
        Sample->DpcRate[i]        = SystemInterruptInfo[i].DpcRate;
        Sample->DpcBypassCount[i] = SystemInterruptInfo[i].DpcBypassCount;
        Sample->ApcBypassCount[i] = SystemInterruptInfo[i].ApcBypassCount;

        Sample->ServerRequests[i] = (ULONGLONG) SrvSampleStatistics.SrvRequests[i];
        Sample->ServerRequestsPerInterrupt[i] = Sample->ServerRequests[i];
        Sample->ServerRequestsPerCtxsw[i] = Sample->ServerRequests[i];
        Sample->ServerRequestTime[i] = SrvSampleStatistics.SrvRequestTime[i];
        Sample->ServerClients[i]     = (ULONGLONG) SrvSampleStatistics.SrvClients[i];
        Sample->ServerQueueLength[i] = (ULONGLONG) SrvSampleStatistics.SrvQueueLength[i];

        Sample->ServerBytesReceived[i]   = SrvSampleStatistics.SrvBytesReceived[i];
        Sample->ServerBytesSent[i]       = SrvSampleStatistics.SrvBytesSent[i];
        Sample->ServerReadOperations[i]  = SrvSampleStatistics.SrvReadOperations[i];
        Sample->ServerBytesRead[i]       = SrvSampleStatistics.SrvBytesRead[i];
        Sample->ServerWriteOperations[i] = SrvSampleStatistics.SrvWriteOperations[i];
        Sample->ServerBytesWritten[i]    = SrvSampleStatistics.SrvBytesWritten[i];

        Sample->ServerActiveThreads[i]   = (ULONGLONG) SrvSampleStatistics.SrvActiveThreads[i];
        Sample->ServerAvailableThreads[i]= (ULONGLONG) SrvSampleStatistics.SrvAvailableThreads[i];
        Sample->ServerFreeWorkItems[i]   = (ULONGLONG) SrvSampleStatistics.SrvFreeWorkItems[i];
        Sample->ServerStolenWorkItems[i] = (ULONGLONG) SrvSampleStatistics.SrvStolenWorkItems[i];
        Sample->ServerNeedWorkItem[i]    = (ULONGLONG) SrvSampleStatistics.SrvNeedWorkItem[i];
        Sample->ServerCurrentClients[i]  = (ULONGLONG) SrvSampleStatistics.SrvCurrentClients[i];

    }
    Sample->TimeStamp = LocalTimeOfDayInfo.CurrentTime.QuadPart;



void
ShowConfiguration(
    VOID
    )
{
    LPMEMORYSTATUSEX ms:
    CHAR    Buf[80];
    ULONG   szChar;
    ULONG   dWord;
    ULONG   sec, bytes, fclust, tclust;
    BYTE    major, minor;
    time_t  timet;
    SYSTEM_FLAGS_INFORMATION SystemFlags;
    SYSTEM_TIMEOFDAY_INFORMATION LocalTimeOfDayInfo;
    ULONG ReturnLocalTimeOfDayInfoLength;
    NTSTATUS Status;
    LONGLONG UpTime;
    CHAR    *architecture;
    CHAR    *processor;
    ULONG NumberProcessors;
    ULONG ProcessorSpeed;

    GetProcessorArchitecture(&processor,
                             &architecture,
                             &NumberProcessors,
                             &ProcessorSpeed);

    timet = time((time_t *)NULL);
    printf( "%s\n", ctime(&timet));

    //
    //      Get the machine name and output it:
    //
    szChar = sizeof(Buf);
    GetComputerName( Buf, &szChar );
    printf( "\nArchitecture: %s\nType: %s\nComputerName: %s\n",
           architecture, processor, Buf );
    printf( "Number of Processors: %lu\n", NumberProcessors );

    if (ProcessorSpeed != 0) {
        printf("Processor Speed (MHz)           %5.1f\n",
               (double)(ProcessorSpeed)/1.0E6);
    } else {
        printf("Processor Speed (MHz)     Not Available\n");
    }


    //
    //      Get the system version number:
    //
    dWord = GetVersion();
    major = (BYTE) dWord & 0xFF;
    minor = (BYTE) (dWord & 0xFF00) >> 8;
    printf( "Windows NT Version %d.%d (Build %lu)\n",
                                            major, minor, dWord >> 16 );

    //
    //      Get the system memory status:
    //
    printf( "\nMemory Status (MBYTES Avail/Total):\n" );
    ms.dwLength = sizeof(ms);
    GlobalMemoryStatusEx(&ms);
    printf( "\t%-16s %3.1f/%3.1f\n",
                            "Physical Memory:",
                            (double)ms.ullAvailPhys/MBYTE,                            (double)ms.dwTotalPhys/MBYTE );
    printf( "\t%-16s %3.1f/%3.1f\n",
                            "Paging File:",
                            (double)ms.ullAvailPageFile/MBYTE,
                            (double)ms.ullTotalPageFile/MBYTE );


    //
    //      Get the disk space status:
    //
    GetDiskFreeSpace( NULL, &sec, &bytes, &fclust, &tclust );
    printf( "\t%-16s %3.1f/%3.1f\n",
                            "Disk Space",
                            ((double)sec*bytes*fclust)/MBYTE,
                            ((double)sec*bytes*tclust)/MBYTE );

    printf("\n\n");

    Status = NtQuerySystemInformation(
        SystemFlagsInformation,
        &SystemFlags,
        sizeof(SystemFlags),
        NULL);
    if (NT_SUCCESS(Status)) {
        printf("System Flags                    %08X\n", SystemFlags);
    } else {
        printf("System Flags              Not Available\n");
        DisplayNTStatus(Status);
    }


    NtQuerySystemInformation(
        SystemTimeOfDayInformation,
        &LocalTimeOfDayInfo,
        sizeof(LocalTimeOfDayInfo),
        &ReturnLocalTimeOfDayInfoLength);

    UpTime = (LocalTimeOfDayInfo.CurrentTime.QuadPart -
             LocalTimeOfDayInfo.BootTime.QuadPart) / (LONGLONG) 10000000;
    printf("System Up Time (hours)          %8.2f\n", (float)UpTime/3600.0);

#ifdef notinterested
    //
    //      Get the current pathname and filesystem type:
    //
    szChar = sizeof(Buf);
    GetCurrentDirectory(szChar, Buf );
    printf( "\nCurrent Directory: %s\n", Buf );
    printf( "TestDisk: %c%c,    ", Buf[0], Buf[1] );

    szChar = sizeof(Buf);
    GetVolumeInformation(NULL, NULL, (ULONG) NULL, NULL, NULL, NULL, Buf, szChar);
    printf( "Filesystem Type: %s\n", Buf );

    //
    //      Get the system pathname and filesystem type:
    //
    szChar = sizeof(Buf);
    GetSystemDirectory(Buf, szChar );
    printf( "SystemDisk: %c%c,  ", Buf[0], Buf[1] );

    szChar = sizeof(Buf);
    GetVolumeInformation(NULL, NULL, (ULONG) NULL, NULL, NULL, NULL, Buf, szChar);
    printf( "Filesystem Type: %s\n", Buf );

#endif

    printf("\n");
}




NTSTATUS
PrintPriority()
{
    THREAD_BASIC_INFORMATION ThreadBasicInfo;
    PROCESS_BASIC_INFORMATION ProcessBasicInfo;
    NTSTATUS Status;

    Status = NtQueryInformationThread(NtCurrentThread(),
                                      ThreadBasicInformation,
                                      &ThreadBasicInfo,
                                      sizeof(ThreadBasicInfo),
                                      NULL);
    if (!NT_SUCCESS(Status)) {
        printf("NtQueryInformationThread failed with Status %08x\n", Status);
        DisplayNTStatus(Status);
    }

    printf("Current thread priority is %d, affinity mask is %08x\n",
            ThreadBasicInfo.Priority,
            ThreadBasicInfo.AffinityMask);

    printf("Current thread base priority (really diff between thread prio and process base prio) is %d\n",
            ThreadBasicInfo.BasePriority);



    Status = NtQueryInformationProcess(NtCurrentProcess(),
                                      ProcessBasicInformation,
                                      &ProcessBasicInfo,
                                      sizeof(ProcessBasicInfo),
                                      NULL);
    if (!NT_SUCCESS(Status)) {
        printf("NtQueryInformationProcess failed with Status %08x\n", Status);
        DisplayNTStatus(Status);
        return (Status);
    }
    printf("Current process base priority is %d, affinity mask is %08x\n",
            ProcessBasicInfo.BasePriority,
            ProcessBasicInfo.AffinityMask);


    return (STATUS_SUCCESS);
}

#endif

#if 0

//
// Add the following test -
// Get the vol info when the volume root is opened in JrnlOpen() and save
// it in the Vme struct.  Each time we init a replica set and open the replica root
// dir for the first time, get the vol info again using the replica root and
// verify that the replica root is on the actual volume.  This handles the
// case where one of the dirs in the replica root is actually a junction
// point which would take us to a different volume.
//

// try GetVolumeNameForVolumeMountPoint()

Status = NtQueryVolumeInformationFile(
            Handle,
            &IoStatusBlock,
            VolumeInfo,
            VolumeInfoLength,
            FileFsVolumeInformation
            );

typedef struct _FILE_FS_VOLUME_INFORMATION {
    LARGE_INTEGER VolumeCreationTime;
    ULONG VolumeSerialNumber;
    ULONG VolumeLabelLength;
    BOOLEAN SupportsObjects;
    WCHAR VolumeLabel[1];
} FILE_FS_VOLUME_INFORMATION, *PFILE_FS_VOLUME_INFORMATION;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\setup\service\service.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    addsrvc.c

Abstract:
    Create the file replication service (ntfrs):
        addsrvc <full path to exe>

Author:
    Billy J. Fuller 2-Sep-1997

Environment
    User mode winnt

--*/

#include <windows.h>
#include <string.h>
#include <winsvc.h>
#include <stdio.h>
#include <config.h>
#include <malloc.h>

//
// Lower case
//
#define FRS_WCSLWR(_s_) \
{ \
    if (_s_) { \
        _wcslwr(_s_); \
    } \
}


SC_HANDLE
OpenServiceHandle(
    IN PWCHAR  ServiceName
    )
/*++
Routine Description:
    Open a service on a machine.

Arguments:
    ServiceName - the service to open

Return Value:
    The service's handle or NULL.
--*/
{
    SC_HANDLE       SCMHandle;
    SC_HANDLE       ServiceHandle;

    //
    // Attempt to contact the SC manager.
    //
    SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (SCMHandle == NULL) {
        printf("Couldn't open service control manager; error %d\n",
               GetLastError());
        return NULL;
    }

    //
    // Contact the service.
    //
    ServiceHandle = OpenService(SCMHandle, ServiceName, SERVICE_ALL_ACCESS);
    CloseServiceHandle(SCMHandle);
    return ServiceHandle;
}


DWORD
FrsGetServiceState(
    IN PWCHAR   ServiceName
    )
/*++
Routine Description:
    Return the service's state

Arguments:
    ServiceName - the service to check

Return Value:
    The service's state or 0 if the state could not be obtained.
--*/
{
    BOOL            Status;
    SC_HANDLE       ServiceHandle;
    SERVICE_STATUS  ServiceStatus;

    //
    // Open the service.
    //
    ServiceHandle = OpenServiceHandle(ServiceName);
    if (ServiceHandle == NULL)
        return 0;

    //
    // Get the service's status
    //
    if (!ControlService(ServiceHandle,
                        SERVICE_CONTROL_INTERROGATE,
                        &ServiceStatus)) {
        CloseServiceHandle(ServiceHandle);
        return GetLastError();
    }
    return ServiceStatus.dwCurrentState;
}


VOID
FrsWaitServicePending(
    IN PWCHAR   ServiceName,
    IN ULONG    IntervalMS,
    IN ULONG    TotalMS
    )
/*++
Routine Description:
    Wait for a service to leave any "pending" state. Check every so often,
    up to a maximum time.

Arguments:
    ServiceName     - Name of the NT service to interrogate.
    IntervalMS      - Check every IntervalMS milliseconds.
    TotalMS         - Stop checking after this long.

Return Value:
    TRUE    - Service is not in a pending state
    FALSE   - Service is still in a pending state
--*/
{
    DWORD   State;

    do {
        State = FrsGetServiceState(ServiceName);
        if (State == 0)
            return;
        switch (State) {
            case ERROR_IO_PENDING:
                printf("IO is pending for %ws; waiting\n", ServiceName);
                break;
            case SERVICE_START_PENDING:
                printf("Start is pending for %ws; waiting\n", ServiceName);
                break;
            case SERVICE_STOP_PENDING:
                printf("Stop is pending for %ws; waiting\n", ServiceName);
                break;
            case SERVICE_CONTINUE_PENDING:
                printf("Continue is pending for %ws; waiting\n", ServiceName);
                break;
            case SERVICE_PAUSE_PENDING:
                printf("Pause is pending for %ws; waiting\n", ServiceName);
                break;
            default:;
                return;
        }
        Sleep(IntervalMS);
    } while ((TotalMS -= IntervalMS) > 0);
}


VOID
FrsStartService(
    IN PWCHAR   ServiceName
    )
/*++
Routine Description:
    Start a service on a machine.

Arguments:
    ServiceName - the service to start

Return Value:
    None.
--*/
{
    SC_HANDLE   ServiceHandle;

    //
    // Open the service.
    //
    ServiceHandle = OpenServiceHandle(ServiceName);
    if (ServiceHandle == NULL) {
        printf("Couldn't open %ws\n", ServiceName);
        return;
    }
    //
    // Start the service
    //
    if (!StartService(ServiceHandle, 0, NULL)) {
        printf("Couldn't start %ws; error %d\n",
               ServiceName, GetLastError());
        CloseServiceHandle(ServiceHandle);
        return;
    }
    CloseServiceHandle(ServiceHandle);
    printf("Started %ws\n", ServiceName);
}


VOID
FrsStopService(
    IN PWCHAR  ServiceName
    )
/*++
Routine Description:
    Stop a service on a machine.

Arguments:
    ServiceName - the service to stop

Return Value:
    None.
--*/
{
    BOOL            Status;
    SC_HANDLE       ServiceHandle;
    SERVICE_STATUS  ServiceStatus;

    //
    // Open the service.
    //
    ServiceHandle = OpenServiceHandle(ServiceName);
    if (ServiceHandle == NULL) {
        printf("Couldn't open %ws\n", ServiceName);
        return;
    }

    //
    // Stop the service
    //
    Status = ControlService(ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus);
    if (!Status) {
        printf("Couldn't stop %ws; error %d\n",
               ServiceName, GetLastError());
        CloseServiceHandle(ServiceHandle);
        return;
    }
    CloseServiceHandle(ServiceHandle);
    printf("Stopped %ws\n", ServiceName);
}


VOID
FrsPauseService(
    IN PWCHAR  ServiceName
    )
/*++
Routine Description:
    Pause a service on a machine.

Arguments:
    ServiceName - the service to pause

Return Value:
    None.
--*/
{
    BOOL            Status;
    SC_HANDLE       ServiceHandle;
    SERVICE_STATUS  ServiceStatus;

    //
    // Open the service.
    //
    ServiceHandle = OpenServiceHandle(ServiceName);
    if (ServiceHandle == NULL) {
        printf("Couldn't open %ws\n", ServiceName);
        return;
    }

    //
    // Stop the service
    //
    Status = ControlService(ServiceHandle, SERVICE_CONTROL_PAUSE, &ServiceStatus);
    if (!Status) {
        printf("Couldn't pause %ws; error %d\n",
               ServiceName, GetLastError());
        CloseServiceHandle(ServiceHandle);
        return;
    }
    CloseServiceHandle(ServiceHandle);
    printf("Paused %ws\n", ServiceName);
}


VOID
FrsContinueService(
    IN PWCHAR  ServiceName
    )
/*++
Routine Description:
    Continue a service on a machine.

Arguments:
    ServiceName - the service to continue

Return Value:
    None.
--*/
{
    BOOL            Status;
    SC_HANDLE       ServiceHandle;
    SERVICE_STATUS  ServiceStatus;

    //
    // Open the service.
    //
    ServiceHandle = OpenServiceHandle(ServiceName);
    if (ServiceHandle == NULL) {
        printf("Couldn't open %ws\n", ServiceName);
        return;
    }

    //
    // Stop the service
    //
    Status = ControlService(ServiceHandle, SERVICE_CONTROL_CONTINUE, &ServiceStatus);
    if (!Status) {
        printf("Couldn't continue %ws; error %d\n",
               ServiceName, GetLastError());
        CloseServiceHandle(ServiceHandle);
        return;
    }
    CloseServiceHandle(ServiceHandle);
    printf("Continued %ws\n", ServiceName);
}



VOID
FrsDeleteService(
    IN PWCHAR ServiceName
    )
/*++
Routine Description:
    Delete a service on a machine.

Arguments:
    ServiceName - the service to delete

Return Value:
    None.
--*/
{
    SC_HANDLE       ServiceHandle;

    // FrsWaitServicePending(ServiceName, 5000, 20000);

    //
    // Open the service
    //
    ServiceHandle = OpenServiceHandle(ServiceName);
    if (ServiceHandle == NULL) {
        return;
    }

    //
    // Delete the service
    //
    if (!DeleteService(ServiceHandle) &&
        GetLastError() != ERROR_SERVICE_MARKED_FOR_DELETE) {
        printf("Couldn't delete %ws; error %d\n",
               ServiceName,
               GetLastError());
    }
    CloseServiceHandle(ServiceHandle);
    printf("Deleted %ws\n", ServiceName);
}


VOID
FrsCreateService(
    IN PWCHAR   ServiceName,
    IN PWCHAR   PathName,
    IN PWCHAR   DisplayName
    )
/*++
Routine Description:
    If the service doesn't exist on the machine, create it.

Arguments:
    ServiceName - the service to create
    PathName    - the path of the service's .exe
    DisplayName - the display name of the service

Return Value:
    TRUE    - Service was created (or already existed)
    FALSE   - Service was not created and didn't already exist
--*/
{
    SC_HANDLE       SCMHandle;
    SC_HANDLE       ServiceHandle;


    //
    // Attempt to contact the SC manager.
    //
    SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
    if (SCMHandle == NULL) {
        printf("Couldn't open service control manager; error %d\n",
               GetLastError());
        return;
    }

    //
    // Create the service
    //
    ServiceHandle = CreateService(
                        SCMHandle,
                        ServiceName,
                        DisplayName,
                        SERVICE_ALL_ACCESS,     // XXX is this right!!!
                        SERVICE_WIN32_OWN_PROCESS,
                        SERVICE_DEMAND_START,
                        SERVICE_ERROR_NORMAL,
                        PathName,
                        NULL,       // No load order group
                        NULL,       // No Tag Id required
                        L"eventlog\0rpcss\0",
                        NULL,
                        NULL);     // No password

    if (ServiceHandle == NULL) {
        FrsWaitServicePending(ServiceName, 5000, 20000);
        //
        // Create the service
        //
        ServiceHandle = CreateService(SCMHandle,
                                      ServiceName,
                                      DisplayName,
                                      SERVICE_ALL_ACCESS,
                                      SERVICE_WIN32_OWN_PROCESS,
                                      SERVICE_DEMAND_START,
                                      SERVICE_ERROR_NORMAL,
                                      PathName,
                                      NULL,
                                      NULL,
                                      L"eventlog\0rpcss\0",
                                      NULL,
                                      NULL);
    }
    CloseServiceHandle(SCMHandle);

    //
    // Couldn't create the service
    //
    if (ServiceHandle == NULL) {
        printf("Couldn't create %ws; error %d\n",
               ServiceName, GetLastError());
    } else {
        CloseServiceHandle(ServiceHandle);
        printf("Created %ws\n", ServiceName);
    }
}


PWCHAR *
ConvertArgv(
    DWORD argc,
    PCHAR *argv
    )
/*++
Routine Description:
    Convert short char argv into wide char argv

Arguments:
    argc    - From main
    argv    - From main

Return Value:
    Address of the new argv
--*/
{
    PWCHAR  *newargv;

    newargv = malloc((argc + 1) * sizeof(PWCHAR));
    newargv[argc] = NULL;

    while (argc-- >= 1) {
        newargv[argc] = malloc((strlen(argv[argc]) + 1) * sizeof(WCHAR));
        wsprintf(newargv[argc], L"%hs", argv[argc]);
        FRS_WCSLWR(newargv[argc]);
    }
    return newargv;
}


VOID
_cdecl
main(
    IN DWORD argc,
    IN PCHAR *argv
    )
/*++
Routine Description:
    Create the file replication service:
        addsrvc <full path to exe>

Arguments:
    None.

Return Value:
    None.
--*/
{
    DWORD   i;
    PWCHAR  *NewArgv;

    if (argc == 1) {
        printf("service create [full path to exe]\n");
        printf("service delete\n");
        printf("service start\n");
        printf("service stop\n");
        printf("service pause\n");
        printf("service continue\n");
        return;
    }

    NewArgv = ConvertArgv(argc, argv);

    //
    // CLI overrides registry
    //
    for (i = 1; i < argc; ++i) {
        //
        // create
        //
        if (wcsstr(NewArgv[i], L"create")) {
            FrsDeleteService(SERVICE_NAME);
            FrsCreateService(SERVICE_NAME,
                             NewArgv[2],
                             SERVICE_LONG_NAME);
            break;
        //
        // delete
        //
        } else if (wcsstr(NewArgv[i], L"delete")) {
            FrsDeleteService(SERVICE_NAME);
            break;
        //
        // start
        //
        } else if (wcsstr(NewArgv[i], L"start")) {
            FrsStartService(SERVICE_NAME);
            break;
        //
        // stop
        //
        } else if (wcsstr(NewArgv[i], L"stop")) {
            FrsStopService(SERVICE_NAME);
            break;
        //
        // pause
        //
        } else if (wcsstr(NewArgv[i], L"pause")) {
            FrsPauseService(SERVICE_NAME);
            break;
        //
        // continue
        //
        } else if (wcsstr(NewArgv[i], L"continue")) {
            FrsContinueService(SERVICE_NAME);
            break;
        //
        //   unknown
        //
        } else {
            printf("Don't understand \"%ws\"\n", NewArgv[i]);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\repl\outlog.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    outlog.c

Abstract:

    Each Replica Set may have some number of outbound partners.  An outbound
    partner can be in one of three sets at any point in time, Inactive,
    Active, and Eligible.  The Inactive set tracks those partners that have
    not yet joined or have returned a failure status from a send request.
    The Eligible set contains those partners that can currently accept a
    change order.  They have joined and they have not exceeded their quota
    of outstanding change orders.  The Active set contains those partners
    that have joined but are not currently eligible.

    This module processes outbound change orders.  The source can be either
    local change orders or inbound remote change orders.  The flow for each
    replica set is as follows:

    - Accept change order from inbound log subsystem and insert it into
      the outbound log for the replica set.

    - Form the current set of "eligible" outbound partners (i.e. those that have
      joined and have not exceeded their outstanding Change Order Quota.

    - Find the joint leading change order index (JLx) over the eligible set.
      The Leading index for each outbound partner is the index of the next
      change order in the outbound log to be sent to that partner.

    - Starting at JLx and continuing to the current maximum change order in
      the outbound log (COmax) send the change order to each outbound partner
      (OBP) subject to the following:

        1. The current change order sequence number or index (COCx) is greater
           than or equal to the leading change order index for this
           partner (COLx) (i.e. the partner has not seen this log entry).

        2. The change order originator Guid, version number pair are greater
           than the entry in the version vector being maintained for this
           outbound partner.  The version vector was inited when the partner
           joined.  If not we don't need to send the partner this change order.

    - As the outstanding change order count for each outbound partner reaches
      their outstanding Change Order Quota the partner is removed from the
      "eligible" set.

    - The above loop ends when the eligible set is empty or we reach COmax
      in the outbound log.

    - Wait on either a new entry in the outbound log or a change order
      acknowledgement from an outbound partner and then start over, forming
      a new eligible set.

The following diagram illustrates the relationship between COTx, COLx and COmax.
It is for a 64 element Ack Vector of a typical outbound partner.  The first
line contains a 1 if an ack has been received.  The second line shows a T and
L for the Trailing and Leading index respectively (COTx and COLx).  The
difference between L and T is 23 change orders, 2 of which have been acked
leaving 21 outstanding.  The "M" is the current change order max.  Change
orders from L to M have not yet been sent out to this partner.  The line with
the caret shows the current CO being acked.  Since this is at the COTx point
it will advance by one.  The Ack vector is a sliding window of the
outstanding change orders for the partner.  The "origin" is at "T".  As
change orders are sent out "L" is advanced but it can't catch up to "T".
When "T" and "L" are the same, no change orders are still outstanding to this
partner.  This lets us track the Acks from the partner even when they return
out of order relative to the order the change orders were sent.

COTx: 215,  COLx: 238,  Outstanding: 21
 |...........................................1.1..................|
 |_______________________T______________________L________M________|
 |                       ^                                        |



Assumptions/Objectives:

1. Allow batch delivery of change orders to reduce CO packet count.

2. The inbound log subsystem enforces sequence interlocks between change
   orders but once the change order is issued it can complete out of order
   relative to when it started.  (sounds like a RISC machine).  This is because
   different change orders can involve different file sizes so their fetch times
   can vary.

3. Multiple outbound partners can have different throughputs and schedules.

4. We can do lazy database updates of the trailing change order index number
   (COTx), the outbound log commit point, that we keep for each outbound
   partner.  This allows us to reduce the frequency of database updates but it
   means that an outbound partner may see a change order more than once in the
   event of a crash.  It must be prepared to discard them.

5. Each outbound partner must respond with a positive acknowledgement when it
   retires each change order even if it never fetches the staging file
   because it either rejected the changeorder or it already got it from another
   source (i.e. it dampened it).  Failure to do this causes our ack tracker
   for this partner to stall and we periodically resend the oldest un-acked
   change order until the partner acks it or we drop the connection.

Author:

    David A. Orbits  16-Aug-1997

Environment

    User mode, winnt32

--*/
#include <ntreppch.h>
#pragma  hdrstop

#include <frs.h>
#include <tablefcn.h>
#include <perrepsr.h>

//
// The following is the data entry format for tracking the dominant file in
// the Replica OutLogDominantTable and the connection MustSendTable.
//
typedef struct _DOMINANT_FILE_ENTRY_ {

    GUID        FileGuid;       // File Guid  (Must be at offset zero in struct)
    ULONGLONG   TimeSent;       // The time this File was last sent on the cxtion.
    ULONG       OLSeqNum;       // Outlog sequence number for change order.
    ULONG       Flags;          // Misc Flags.

} DOMINANT_FILE_ENTRY, *PDOMINANT_FILE_ENTRY;

#define  DFT_FLAG_DELETE    0x00000001     // The OLSeqNum is for a CO that deletes the file.


//
// The following fields are updated when an outbound partner's OutLog process
// state is saved.
//
ULONG OutLogUpdateFieldList[] = {CrFlagsx,
                                 CrCOLxx,
                                 CrCOTxx,
                                 CrCOTslotx,
                                 CrAckVectorx,
                                 CrCOTxNormalModeSavex};


PCHAR OLReplicaProcStateNames[OL_REPLICA_PROC_MAX_STATE+1];
PCHAR OLPartnerStateNames[OLP_MAX_STATE+1];

FRS_QUEUE  OutLogWork;



//
// Outlog partner state flags.
//
FLAG_NAME_TABLE OlpFlagNameTable[] = {
    {OLP_FLAGS_ENABLED_CXTION    , "EnabledCxtion "  },
    {OLP_FLAGS_GENERATED_CXTION  , "GenedCxtion "    },
    {OLP_FLAGS_VVJOIN_MODE       , "VvjoinMode "     },
    {OLP_FLAGS_LOG_TRIMMED       , "LogTrimmed "     },
    {OLP_FLAGS_REPLAY_MODE       , "ReplayMode "     },

    {0, NULL}
};


//
// The default max number of change orders outstanding.
//
extern ULONG MaxOutLogCoQuota;

//
// A CO update for a given file will not be sent out more frequently than this.
//
extern ULONG GOutLogRepeatInterval;

//
// The time in sec between checks for cleaning the outbound log.
//
#define OUT_LOG_CLEAN_INTERVAL (30*1000)
#define OUT_LOG_POLL_INTERVAL  (30*1000)

//
// Save the partner state in the DB every OUT_LOG_SAVE_INTERVAL change orders
// handled.
//
#define OUT_LOG_SAVE_INTERVAL  15

#define OUT_LOG_TRACK_PARTNER_STATE_UPDATE(_par_, _Commit_, _Eval_)      \
{                                                                        \
    PSINGLE_LIST_ENTRY SingleList;                                       \
    SingleList = ((_par_)->COTx >=                                       \
                  ((_par_)->COTxLastSaved + OUT_LOG_SAVE_INTERVAL)) ?    \
                   (_Commit_) : (_Eval_);                                \
    PushEntryList(SingleList, &(_par_)->SaveList);                       \
}




ULONG
OutLogAddReplica(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA Replica
);

ULONG
OutLogRemoveReplica(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA Replica
);

ULONG
OutLogInitPartner(
    PREPLICA Replica,
    PCXTION Cxtion
);

ULONG
OutLogEnterUnjoinedPartner(
    PREPLICA Replica,
    POUT_LOG_PARTNER OutLogPartner
);

ULONG
OutLogAddNewPartner(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX TableCtx,
    IN PREPLICA Replica,
    IN PCXTION Cxtion
);

ULONG
OutLogDeactivatePartner(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX TableCtx,
    IN PREPLICA Replica,
    IN PCXTION Cxtion
);

ULONG
OutLogActivatePartnerCmd(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX  TableCtx,
    IN PREPLICA    Replica,
    IN PCXTION     PartnerCxtion,
    IN BOOL        HaveLock
);

ULONG
OutLogActivatePartner(
    IN PREPLICA Replica,
    IN PCXTION  PartnerCxtion,
    IN BOOL     HaveLock
);

ULONG
OutLogRemovePartner(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX TableCtx,
    IN PREPLICA Replica,
    IN PCXTION Cxtion
);

ULONG
OutLogReadPartner(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX TableCtx,
    IN PREPLICA Replica,
    IN PCXTION Cxtion
);

ULONG
OutLogClosePartner(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX TableCtx,
    IN PREPLICA Replica,
    IN PCXTION Cxtion
);

ULONG
OutLogProcess(
    PVOID  FrsThreadCtxArg
);

ULONG
OutLogProcessReplica(
    PTHREAD_CTX  ThreadCtx,
    PREPLICA     Replica
);

BOOL
OutLogSendCo(
    PTHREAD_CTX           ThreadCtx,
    PREPLICA              Replica,
    POUT_LOG_PARTNER      Partner,
    PCHANGE_ORDER_COMMAND CoCmd,
    ULONG                 JointLeadingIndex
);

BOOL
OutLogOptimize(
    IN PREPLICA              Replica,
    IN POUT_LOG_PARTNER      Partner,
    IN PCHANGE_ORDER_COMMAND CoCmd,
    OUT PCHAR                *SendTag
);

VOID
OutLogSkipCo(
    PREPLICA              Replica,
    ULONG                 JointLeadingIndex
);

ULONG
OutLogCommitPartnerState(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX TableCtx,
    IN PREPLICA Replica,
    IN PCXTION Cxtion
);

ULONG
OutLogReadCo(
    PTHREAD_CTX          ThreadCtx,
    PREPLICA             Replica,
    ULONG                Index
);

ULONG
OutLogDeleteCo(
    PTHREAD_CTX ThreadCtx,
    PREPLICA    Replica,
    ULONG       Index
);

ULONG
OutLogStartProcess(
    PREPLICA Replica
);

ULONG
OutLogSubmitCo(
    PREPLICA Replica,
    PCHANGE_ORDER_ENTRY ChangeOrder
);

VOID
OutLogAVToStr(
    POUT_LOG_PARTNER OutLogPartner,
    ULONG RetireCOx,
    PCHAR *OutStr1,
    PCHAR *OutStr2,
    PCHAR *OutStr3
    );

ULONG
OutLogRetireCo(
    PREPLICA Replica,
    ULONG COx,
    PCXTION Partner
);

BOOL
OutLogMarkAckVector(
    PREPLICA Replica,
    ULONG COx,
    POUT_LOG_PARTNER OutLogPartner
);

ULONG
OutLogSavePartnerState(
    IN PTHREAD_CTX        ThreadCtx,
    IN PREPLICA           Replica,
    IN PSINGLE_LIST_ENTRY CommitList,
    IN PSINGLE_LIST_ENTRY EvalList
);

ULONG
OutLogSaveSinglePartnerState(
    IN PTHREAD_CTX        ThreadCtx,
    IN PREPLICA           Replica,
    IN PTABLE_CTX         TableCtx,
    IN POUT_LOG_PARTNER   OutLogPartner
);

ULONG
OutLogPartnerVVJoinStart(
    IN PTHREAD_CTX        ThreadCtx,
    IN PREPLICA           Replica,
    IN POUT_LOG_PARTNER   OutLogPartner
);

ULONG
OutLogPartnerVVJoinDone(
    IN PTHREAD_CTX        ThreadCtx,
    IN PREPLICA           Replica,
    IN POUT_LOG_PARTNER   OutLogPartner
);

ULONG
OutLogCleanupLog(
    PTHREAD_CTX  ThreadCtx,
    PREPLICA     Replica
);

VOID
OutLogCopyCxtionToCxtionRecord(
    IN PCXTION      Cxtion,
    IN PTABLE_CTX   CxtionRecord
);

#define OUT_LOG_DUMP_PARTNER_STATE(_sev, _olp, _cox, _desc) \
    FrsPrintTypeOutLogPartner(_sev, NULL, 0, _olp, _cox, _desc, DEBSUB, __LINE__)

VOID
FrsPrintTypeOutLogPartner(
    IN ULONG            Severity,   OPTIONAL
    IN PVOID            Info,       OPTIONAL
    IN DWORD            Tabs,       OPTIONAL
    IN POUT_LOG_PARTNER Olp,
    IN ULONG            RetireCox,
    IN PCHAR            Description,
    IN PCHAR            Debsub,     OPTIONAL
    IN ULONG            uLineNo     OPTIONAL
    );

ULONG
DbsReplicaHashCalcCoSeqNum (
    PVOID Buf,
    ULONG Length
    );

FrsDoesCoAlterNameSpace(
    IN PCHANGE_ORDER_COMMAND Coc
    );

JET_ERR
DbsEnumerateOutlogTable(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN ULONG         RecordIndexLimit,
    IN PENUMERATE_OUTLOGTABLE_ROUTINE RecordFunction,
    IN PVOID         Context
    );


VOID
ShutDownOutLog(
    VOID
    )
/*++
Routine Description:

    Run down the outbound log queue.

Arguments:

    None.

Return Value:

    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "ShutDownOutLog:"
    FrsRunDownCommand(&OutLogWork);
}








VOID
OutLogInitialize(
    VOID
    )
/*++
Routine Description:

    Initialize the Outbound log subsystem.

Arguments:

    None.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogInitialize:"
    LIST_ENTRY  ListHead;


    OLReplicaProcStateNames[OL_REPLICA_INITIALIZING] = "OL_REPLICA_INITIALIZING";
    OLReplicaProcStateNames[OL_REPLICA_WAITING]      = "OL_REPLICA_WAITING";
    OLReplicaProcStateNames[OL_REPLICA_WORKING]      = "OL_REPLICA_WORKING";
    OLReplicaProcStateNames[OL_REPLICA_STOPPING]     = "OL_REPLICA_STOPPING";
    OLReplicaProcStateNames[OL_REPLICA_STOPPED]      = "OL_REPLICA_STOPPED";
    OLReplicaProcStateNames[OL_REPLICA_NOPARTNERS]   = "OL_REPLICA_NOPARTNERS";
    OLReplicaProcStateNames[OL_REPLICA_ERROR]        = "OL_REPLICA_ERROR";


    OLPartnerStateNames[OLP_INITIALIZING]       = "OLP_INITIALIZING";
    OLPartnerStateNames[OLP_UNJOINED]           = "OLP_UNJOINED";
    OLPartnerStateNames[OLP_ELIGIBLE]           = "OLP_ELIGIBLE";
    OLPartnerStateNames[OLP_STANDBY]            = "OLP_STANDBY";
    OLPartnerStateNames[OLP_AT_QUOTA]           = "OLP_AT_QUOTA";
    OLPartnerStateNames[OLP_INACTIVE]           = "OLP_INACTIVE";
    OLPartnerStateNames[OLP_ERROR]              = "OLP_ERROR";

    FrsInitializeQueue(&OutLogWork, &OutLogWork);

    //
    // Create the outlog process thread.
    //
    if (!FrsIsShuttingDown &&
        !ThSupCreateThread(L"OutLog", NULL, OutLogProcess, ThSupExitThreadNOP)) {
        DPRINT(0, "ERROR - Could not create OutLogProcess thread\n");
        FRS_ASSERT(!"Could not create OutLogProcess thread");
    }
}



BOOL
OutLogDominantKeyMatch(
    PVOID Buf,
    PVOID QKey
)
/*++

Routine Description:
    Check for an exact key match.

Arguments:
    Buf -- ptr to a Guid1.
    QKey -- ptr to Guid2.

Return Value:
    TRUE if exact match.

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogDominantKeyMatch:"

    PULONG pUL1, pUL2;

    pUL1 = (PULONG) Buf;
    pUL2 = (PULONG) QKey;

    if (!ValueIsMultOf4(pUL1)) {
        DPRINT2(0, "ERROR - Unaligned key value - addr: %08x, Data: %08x\n", pUL1, *pUL1);
        FRS_ASSERT(ValueIsMultOf4(pUL1));
        return 0xFFFFFFFF;
    }
    if (!ValueIsMultOf4(pUL2)) {
        DPRINT2(0, "ERROR - Unaligned key value - addr: %08x, Data: %08x\n", pUL2, *pUL2);
        FRS_ASSERT(ValueIsMultOf4(pUL2));
        return 0xFFFFFFFF;
    }

    return GUIDS_EQUAL(pUL1, pUL2);
}



ULONG
OutLogDominantHashCalc(
    PVOID Buf,
    PULONGLONG QKey
)
/*++

Routine Description:
    Calculate a hash value for the file guid used in the OutLog Dominant File Table.

Arguments:
    Buf -- ptr to a Guid.
    QKey -- Returned 8 byte hash key for the QKey field of QHASH_ENTRY.

Return Value:
    32 bit hash value.

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogDominantHashCalc:"

    PULONG  pUL = (PULONG) Buf;
    PUSHORT pUS = (PUSHORT) Buf;

    if (!ValueIsMultOf4(pUL)) {
        DPRINT2(0, "ERROR - Unaligned key value - addr: %08x, Data: %08x\n", pUL, *pUL);
        FRS_ASSERT(ValueIsMultOf4(pUL));
        return 0xFFFFFFFF;
    }

    //
    // Calc QKey, 4 byte hash is ok.
    //
    *QKey = (ULONGLONG) (pUL[0] ^ pUL[1] ^ pUL[2] ^ pUL[3]);

    //
    // Calc hash based on the time.  Include node part for remote COs.
    //
    return (ULONG) (pUS[0] ^ pUS[1] ^ pUS[2] ^ pUS[6] ^ pUS[7]);
}

BOOL
OutLogFavorDominantFile(
    IN PCHANGE_ORDER_COMMAND  CoCmd
)
/*++

Routine Description:

    Test if this CO is a candidate for Outlog skipping.  The criteria are:
    1. Files only.
    2. CO can't change the name space so no renames, deletes or creates.
    3. CO can't be a directed co or a vvjoin co or an out of order co.
    4. CO can't be an abortco, any type of refresh co, a control co, or Morphgenco.

Arguments:

    CoCmd - ptr to CO command record.

Return Value:

    TRUE if CO is a candidate for OutLog skipping.

--*/
{
#undef DEBSUB
#define DEBSUB "OutLogFavorDominantFile:"

    CHAR FlagBuffer[160];

    //
    // Certain types of COs can't be skipped.
    //
    if (FrsDoesCoAlterNameSpace(CoCmd)) {
        DPRINT(4, "++ noskip - alters name space\n");
        return FALSE;
    }

    if (CoCmdIsDirectory(CoCmd)) {
        DPRINT(4, "++ noskip - is directory\n");
        return FALSE;
    }

    if (COC_FLAG_ON(CoCmd, (CO_FLAG_ABORT_CO          |
                            CO_FLAG_GROUP_ANY_REFRESH |
                            CO_FLAG_OUT_OF_ORDER      |
                            CO_FLAG_NEW_FILE          |
                            CO_FLAG_CONTROL           |
                            CO_FLAG_VVJOIN_TO_ORIG    |
                            CO_FLAG_MORPH_GEN         |
                            CO_FLAG_DIRECTED_CO))) {

        FrsFlagsToStr(CoCmd->Flags, CoFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
        DPRINT2(4, "++ noskip - wrong CO type CoFlags: %08x [%s]\n",
                CoCmd->Flags, FlagBuffer);
        return FALSE;
    }

    return TRUE;
}



BOOL
OutLogIsValidDominantFile(
    IN PCHANGE_ORDER_COMMAND  CoCmd
)
/*++

Routine Description:

    Test if this CO is a valid file for the OutLog dominant file table.

    1. Files only.
    2. CO can't be a directed co or a vvjoin co or an out of order Co.
    3. CO can't be an abortco, any type of refresh co, a control co, or Morphgenco.

    Note: The dominant file table can contain name space changing COs since
    we always ship the data with the file.  So we can skip a file update CO
    in favor of some dominant CO that may also rename or even delete the file.
    The latter is especially important since there is no point in shipping
    an update if a later CO is going to just delete the file.

    Note: An out of order CO is not allowed in the dominant file table since
    it may have reconcile data that would cause it to be rejected while the
    current CO would be accepted.  If this becomes an important case code could
    be added to determine the reconciliation result between the current outlog
    CO and the dominant CO.  I doubt this is worth it.


Arguments:

    CoCmd - ptr to CO command record.

Return Value:

    TRUE if CO is a candidate for OutLog Dominant file table.

--*/
{
#undef DEBSUB
#define DEBSUB "OutLogIsValidDominantFile:"

    CHAR FlagBuffer[160];


    //
    // Certain types of COs can't be skipped.
    //
    if (CoCmdIsDirectory(CoCmd)) {
        DPRINT(4, "++ not valid dominant file: directory\n",);
        return FALSE;
    }

    if (COC_FLAG_ON(CoCmd, (CO_FLAG_ABORT_CO          |
                            CO_FLAG_GROUP_ANY_REFRESH |
                            CO_FLAG_OUT_OF_ORDER      |
                            CO_FLAG_NEW_FILE          |
                            CO_FLAG_CONTROL           |
                            CO_FLAG_VVJOIN_TO_ORIG    |
                            CO_FLAG_MORPH_GEN         |
                            CO_FLAG_DIRECTED_CO))) {

        FrsFlagsToStr(CoCmd->Flags, CoFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
        DPRINT1(4, "++ not valid dominant file: wrong CO type CoFlags: %08x \n",
                CoCmd->Flags);
        DPRINT1(4, "++ [%s]\n", FlagBuffer);
        return FALSE;
    }

    return TRUE;
}


JET_ERR
OutLogInitDominantFileTableWorker (
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    TableCtx,
    IN PVOID         Record,
    IN PVOID         Context
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it processes a record from the Outbound log table.

    It scans the Outbound log table and rebuilds the Dominate File Table.

Arguments:

    ThreadCtx - Needed to access Jet.
    TableCtx  - A ptr to an outbound log context struct.
    Record    - A ptr to a change order command record.
    Context   - A ptr to the Replica struct we are working on.

Thread Return Value:

    JET_errSuccess if enum is to continue.

--*/
{
#undef DEBSUB
#define DEBSUB "OutLogInitDominantFileTableWorker:"

    JET_ERR                 jerr;
    PDOMINANT_FILE_ENTRY    DomFileEntry;
    PQHASH_ENTRY            QHashEntry;

    PREPLICA                Replica = (PREPLICA) Context;
    PCHANGE_ORDER_COMMAND   CoCmd   = (PCHANGE_ORDER_COMMAND)Record;
    CHAR                    GuidStr[GUID_CHAR_LEN];

    //
    // Ignore if entry does not meet criteria.
    //
    GuidToStr(&CoCmd->FileGuid, GuidStr);
    DPRINT2(4, ":S: Dominant file check of %ws %s\n", CoCmd->FileName, GuidStr);

    //
    // Certain types of COs are not candidates for skipping.
    //
    if (!OutLogIsValidDominantFile(CoCmd)) {
        return JET_errSuccess;
    }

    //
    // This is a candidate.  Update the Dominant File Table.
    //
    jerr = JET_errSuccess;

    QHashAcquireLock(Replica->OutLogDominantTable);

    QHashEntry = QHashLookupLock(Replica->OutLogDominantTable, &CoCmd->FileGuid);
    if (QHashEntry != NULL) {
        //
        // Found a match, bump the count and record latest sequence number.
        //
        DomFileEntry = (PDOMINANT_FILE_ENTRY) (QHashEntry->Flags);
        QHashEntry->QData += 1;
        DomFileEntry->OLSeqNum = CoCmd->SequenceNumber;
    } else {
        //
        // Not found, insert new entry.
        //
        DomFileEntry = FrsAlloc(sizeof(DOMINANT_FILE_ENTRY));
        if (DomFileEntry != NULL) {
            DomFileEntry->Flags = 0;
            COPY_GUID(&DomFileEntry->FileGuid, &CoCmd->FileGuid);
            DomFileEntry->OLSeqNum = CoCmd->SequenceNumber;

            if (DOES_CO_DELETE_FILE_NAME(CoCmd)) {
                SetFlag(DomFileEntry->Flags, DFT_FLAG_DELETE);
            }

            QHashEntry = QHashInsertLock(Replica->OutLogDominantTable,
                                         &CoCmd->FileGuid,
                                         NULL,
                                         (ULONG_PTR) DomFileEntry);

            if (QHashEntry == NULL) {
                DPRINT2(4, "++ ERROR - Failed to insert entry into Replica OutLogDominant Table for %ws (%s)",
                        CoCmd->FileName, GuidStr);
                jerr = JET_wrnNyi;
            }
        } else {
            jerr = JET_wrnNyi;
        }
    }

    QHashReleaseLock(Replica->OutLogDominantTable);

    return jerr;
}


ULONG
OutLogInitDominantFileTableWorkerPart2 (
    PQHASH_TABLE Table,
    PQHASH_ENTRY BeforeNode,
    PQHASH_ENTRY TargetNode,
    PVOID Context
    )
/*++

Routine Description:

    This function is called thru QHashEnumerateTable() to remove entries
    that have no multiples.

Arguments:

    Table - the hash table being enumerated
    BeforeNode  -- ptr to the QhashEntry before the node of interest.
    TargetNode  -- ptr to the QhashEntry of interest.
    Context - Replica ptr.

Return Value:

    FrsError Status

--*/

{
#undef DEBSUB
#define DEBSUB  "OutLogInitDominantFileTableWorkerPart2:"

    PDOMINANT_FILE_ENTRY DomFileEntry;

    if (TargetNode->QData == QUADZERO) {

        //DPRINT5(4, "BeforeNode: %08x, Link: %08x,"
        //           " Flags: %08x, Tag: %08x %08x, Data: %08x %08x\n",
        //       BeforeNode, TargetNode->NextEntry, TargetNode->Flags,
        //       PRINTQUAD(TargetNode->QKey), PRINTQUAD(TargetNode->QData));

        //
        // Free the dominate file entry node.
        //
        DomFileEntry = (PDOMINANT_FILE_ENTRY) (TargetNode->Flags);
        FrsFree(DomFileEntry);
        TargetNode->Flags = 0;

        //
        // Tell QHashEnumerateTable() to delete the QHash node and continue the enum.
        //
        return FrsErrorDeleteRequested;
    }

    return FrsErrorSuccess;
}


ULONG
OutLogDumpDominantFileTableWorker(
    PQHASH_TABLE Table,
    PQHASH_ENTRY BeforeNode,
    PQHASH_ENTRY TargetNode,
    PVOID Context
    )
/*++

Routine Description:

    Dump the OutLog Dominant File Table.

Arguments:

    Table - the hash table being enumerated
    BeforeNode  -- ptr to the QhashEntry before the node of interest.
    TargetNode  -- ptr to the QhashEntry of interest.
    Context - Replica ptr.

Return Value:

    FrsErrorSuccess

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogDumpDominantFileTableWorker:"

    PDOMINANT_FILE_ENTRY DomFileEntry = (PDOMINANT_FILE_ENTRY) (TargetNode->Flags);
    CHAR                 GuidStr[GUID_CHAR_LEN];

    GuidToStr(&DomFileEntry->FileGuid, GuidStr);

    DPRINT4(4,":S: QKey: %08x %08x, Data: %08x %08x, OLSeqNum: %6d, FileGuid: %s\n",
            PRINTQUAD(TargetNode->QKey), PRINTQUAD(TargetNode->QData),
            DomFileEntry->OLSeqNum, GuidStr);

    return FrsErrorSuccess;
}


ULONG
OutLogAddReplica(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA Replica
)
/*++
Routine Description:

    Add a new replica set to the outbound log process.  Called once when
    Replica set is created.  Determine continuation index for Out Log.
    Init the outlog partner structs.  Init the outlog table for the replica.

Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.
    Replica -- The replica set struct for the outbound log.

Return Value:

    FrsErrorStatus

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogAddReplica:"

    JET_ERR         jerr, jerr1;
    ULONG           FStatus;
    PTABLE_CTX      TableCtx;

    PCOMMAND_PACKET CmdPkt;
    PVOID           Key;
    PCXTION         OutCxtion;
    PCHANGE_ORDER_COMMAND   CoCmd;
    ULONG           ReplicaNumber = Replica->ReplicaNumber;

    //
    // Only init once per Replica.
    //
    if (Replica->OutLogWorkState != OL_REPLICA_INITIALIZING) {
        return FrsErrorSuccess;
    }

    //
    // Allocate a table context struct to access the outbound log.
    //
    TableCtx = FrsAlloc(sizeof(TABLE_CTX));
    TableCtx->TableType = TABLE_TYPE_INVALID;
    TableCtx->Tid       = JET_tableidNil;

    Replica->OutLogTableCtx   = TableCtx;
    Replica->OutLogSeqNumber = 1;

    //
    // Init the table context and open the outbound log table for this replica.
    // Get the sequence number from the last Outbound log record.
    //
    jerr = DbsOpenTable(ThreadCtx, TableCtx, ReplicaNumber, OUTLOGTablex, NULL);
    if (!JET_SUCCESS(jerr)) {
        DPRINT1_JS(0, "DbsOpenTable (outlog) on replica number %d failed.",
                   ReplicaNumber, jerr);
        DbsCloseTable(jerr1, ThreadCtx->JSesid, TableCtx);
        DbsFreeTableCtx(TableCtx, 1);
        Replica->OutLogTableCtx = FrsFree(TableCtx);
        return DbsTranslateJetError(jerr, FALSE);
    }

    FStatus = DbsTableMoveToRecord(ThreadCtx,
                                   TableCtx,
                                   OLSequenceNumberIndexx,
                                   FrsMoveLast);
    if (FRS_SUCCESS(FStatus)) {
        FStatus = DbsTableRead(ThreadCtx, TableCtx);
        if (FRS_SUCCESS(FStatus)) {
            CoCmd = (PCHANGE_ORDER_COMMAND) TableCtx->pDataRecord;
            Replica->OutLogSeqNumber = CoCmd->SequenceNumber+1;
        }
    } else {
        //
        // Outbound log is empty.  Reset Seq number to 1.  Zero is reserved
        // as the starting index for a partner that has never joined.  After
        // the partner joins for the first time we force a VVJoin and advance
        // the its seq number to the end of the log.
        //
        Replica->OutLogSeqNumber = 1;
    }

    //
    // Everything looks good.  Complete the rest of the init.
    //
    // Allocate an outlog record lock Table for the replica.
    //
    Replica->OutLogRecordLock = FrsFreeType(Replica->OutLogRecordLock);
    Replica->OutLogRecordLock = FrsAllocTypeSize(QHASH_TABLE_TYPE,
                                                 OUTLOG_RECORD_LOCK_TABLE_SIZE);
    SET_QHASH_TABLE_HASH_CALC(Replica->OutLogRecordLock,
                              DbsReplicaHashCalcCoSeqNum);

    //
    // Allocate a hash table to record the dominant file update change order
    // in the oubound log when multiple COs for the same file guid are present.
    // The hash function is on the file Guid.  Then enmerate the outbound log
    // and build the table.
    //
    if (Replica->OutLogDominantTable == NULL) {
        Replica->OutLogDominantTable = FrsAllocTypeSize(QHASH_TABLE_TYPE,
                                                        OUTLOG_DOMINANT_FILE_TABLE_SIZE);
        SET_QHASH_TABLE_FLAG(Replica->OutLogDominantTable, QHASH_FLAG_LARGE_KEY);
        SET_QHASH_TABLE_HASH_CALC2(Replica->OutLogDominantTable, OutLogDominantHashCalc);
        SET_QHASH_TABLE_KEY_MATCH(Replica->OutLogDominantTable, OutLogDominantKeyMatch);
        SET_QHASH_TABLE_FREE(Replica->OutLogDominantTable, FrsFree);

        //
        // Initialize the OutLogDominant Table.
        //
        if ((Replica->OutLogSeqNumber > 1) &&
            (Replica->OutLogRepeatInterval > 0)){
            jerr = FrsEnumerateTable(ThreadCtx,
                                     TableCtx,
                                     OLSequenceNumberIndexx,
                                     OutLogInitDominantFileTableWorker,
                                     Replica);
            if ((!JET_SUCCESS(jerr)) &&
                (jerr != JET_errNoCurrentRecord) &&
                (jerr != JET_wrnTableEmpty)) {
                DPRINT1_JS(0, "++ ERROR - Initializing outlog dominant table for %ws : ",
                           Replica->ReplicaName->Name, jerr);
                DbsTranslateJetError(jerr, FALSE);
            }

            //
            // Now clear out the entries that have no multiples.
            //
            QHashEnumerateTable(Replica->OutLogDominantTable,
                                OutLogInitDominantFileTableWorkerPart2,
                                NULL);

            DPRINT1(4, ":S: Dump of outlog dominant table for %ws\n",
                    Replica->ReplicaName->Name);
            QHashEnumerateTable(Replica->OutLogDominantTable,
                                OutLogDumpDominantFileTableWorker,
                                NULL);
        }
    }

    //
    // Close the table since we are being called from DB thread at startup.
    //
    DbsCloseTable(jerr1, ThreadCtx->JSesid, TableCtx);

    //
    // Allocate and init a command packet to initiate outbound log work on
    // this replica.  Save the ptr to the command packet so we can reuse it
    // each time there is new work for this replica.
    //
    CmdPkt = FrsAllocCommand(&OutLogWork, CMD_OUTLOG_WORK_CO);
    FrsSetCompletionRoutine(CmdPkt, FrsCompleteKeepPkt, NULL);
    CmdPkt->Parameters.OutLogRequest.Replica = Replica;
    //
    // Start out with no outbound partners.
    //
    SET_OUTLOG_REPLICA_STATE(Replica, OL_REPLICA_NOPARTNERS);
    Replica->OutLogCxtionsJoined = 0;

    //
    // Init the out log state for each connection.
    // Make sure we continue at the maximum value for the OutLog Sequence Number.
    //
    Key = NULL;
    while (OutCxtion = GTabNextDatum(Replica->Cxtions, &Key)) {
        //
        // Ignore the (local) journal connection
        //
        if (OutCxtion->JrnlCxtion) {
            continue;
        }
        if (!OutCxtion->Inbound) {
            FRS_ASSERT(OutCxtion->OLCtx != NULL);
            if (OutCxtion->OLCtx->COLx > Replica->OutLogSeqNumber) {
                Replica->OutLogSeqNumber = OutCxtion->OLCtx->COLx;
            }
            OutLogInitPartner(Replica, OutCxtion);
        }
    }

    Replica->OutLogJTx = 0;
    Replica->OutLogJLx = Replica->OutLogSeqNumber;
    //
    // There may be old change orders in the outbound log that
    // weren't cleaned up because the service shut down before
    // the cleanup thread ran. Allow the cleanup thread to run
    // at least once to empty the outbound log of stale change
    // orders.
    //
    Replica->OutLogDoCleanup = TRUE;

    //
    // Save the cmd packet and go make an inital check for work.
    //
    OutLogAcquireLock(Replica);
    if (Replica->OutLogWorkState == OL_REPLICA_WAITING) {
        SET_OUTLOG_REPLICA_STATE(Replica, OL_REPLICA_WORKING);
    }
    Replica->OutLogCmdPkt = CmdPkt;
    OutLogReleaseLock(Replica);
    FrsSubmitCommand(CmdPkt, FALSE);

    return FrsErrorSuccess;
}



ULONG
OutLogRemoveReplica(
    IN PTHREAD_CTX ThreadCtx,
    IN PREPLICA Replica
)
/*++
Routine Description:

    Remove a replica set from the outbound log process.  Free memory.

    Even though we are stopping the Outlog process additional COs can
    still be inserted into the outbound log while we are shutting down.

    OutLogInsertCo() still needs the OutLogRecordLock hash table so it can't
    be released here.  Instead it gets re-inited when the replica struct is
    reinitialized or freed.


Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.
    TableCtx
    Replica -- The replica set struct for the outbound log.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogRemoveReplica:"

    JET_ERR          jerr;
    NTSTATUS         Status;
    POUT_LOG_PARTNER Partner;
    PVOID            Key;
    PCXTION          OutCxtion;
    PTABLE_CTX       TableCtx;

    //
    // Set the state to Initializing.  This prevents any further calls to
    // the outlog process on behalf of this replica set.
    //
    OutLogAcquireLock(Replica);
    if (Replica->OutLogWorkState == OL_REPLICA_INITIALIZING) {
        //
        // Already removed (or never added); done
        //
        OutLogReleaseLock(Replica);
        return FrsErrorSuccess;
    }

    SET_OUTLOG_REPLICA_STATE(Replica, OL_REPLICA_INITIALIZING);
    OutLogReleaseLock(Replica);


    //
    // Remove the outbound connections from the outbound log.
    //
    TableCtx = DbsCreateTableContext(CXTIONTablex);
    Key = NULL;
    while (OutCxtion = GTabNextDatum(Replica->Cxtions, &Key)) {
        //
        // Ignore the (local) journal connection
        //
        if (OutCxtion->JrnlCxtion) {
            continue;
        }

        //
        // If one of the Partner Close requests failed and took an error path
        // then they may have called DbsFreeTableCtx().  Fix this here.
        //
        if (IS_INVALID_TABLE(TableCtx)) {
            Status = DbsAllocTableCtx(CXTIONTablex, TableCtx);
            if (!NT_SUCCESS(Status)) {
                DPRINT_NT(0, "ERROR - DbsAllocRecordStorage failed to alloc buffers.", Status);
                DbsFreeTableCtx(TableCtx, 1);
                continue;
            }
        }

        OutLogClosePartner(ThreadCtx, TableCtx, Replica, OutCxtion);
    }
    DbsFreeTableContext(TableCtx, 0);

    //
    // Close any open table and release the memory.
    //
    DbsCloseTable(jerr, ThreadCtx->JSesid, Replica->OutLogTableCtx);
    DbsFreeTableCtx(Replica->OutLogTableCtx, 1);
    Replica->OutLogTableCtx = FrsFree(Replica->OutLogTableCtx);
    //
    // Free the work command packet.
    //
    Replica->OutLogCmdPkt = FrsFreeType(Replica->OutLogCmdPkt);
    //
    // Free the outlog dominant QHash Table.
    //
    Replica->OutLogDominantTable = FrsFreeType(Replica->OutLogDominantTable);

    //
    // Free the remaining Outbound log partner structs.
    //
    FrsFreeTypeList(&Replica->OutLogEligible);
    FrsFreeTypeList(&Replica->OutLogStandBy);
    FrsFreeTypeList(&Replica->OutLogActive);
    FrsFreeTypeList(&Replica->OutLogInActive);



    return FrsErrorSuccess;
}


ULONG
OutLogInitPartner(
    PREPLICA Replica,
    PCXTION Cxtion
)
/*++
Routine Description:

    Add a new outbound partner to the outbound log process.

Arguments:

    Replica -- The replica set struct for the outbound log.
    Cxtion -- The information about the partner, Guid, Send Queue, Send
                   Quota, ...

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogInitPartner:"
    //
    // Not much needs to be done to enable outbound
    // processing on an inbound cxtion
    //
    if (Cxtion->Inbound) {
        return FrsErrorSuccess;
    }

    FRS_ASSERT(Cxtion->OLCtx);

    OutLogEnterUnjoinedPartner(Replica, Cxtion->OLCtx);

    return FrsErrorSuccess;
}


ULONG
OutLogEnterUnjoinedPartner(
    PREPLICA Replica,
    POUT_LOG_PARTNER OutLogPartner
)
/*++
Routine Description:

    Put a newly inited outbound partner on the inactive list and set its
    state to UNJOINED.  If the Outbound Log Replica state is OL_REPLICA_NOPARTNERS
    then set it to OL_REPLICA_WAITING;

Arguments:

    Replica -- The replica set struct for the outbound log.
    OutLogPartner -- The outbound log context for this partner.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogEnterUnjoinedPartner:"

    OutLogAcquireLock(Replica);

    InsertTailList(&Replica->OutLogInActive, &OutLogPartner->List);
    SET_OUTLOG_PARTNER_STATE(OutLogPartner, OLP_UNJOINED);

    if (Replica->OutLogWorkState == OL_REPLICA_NOPARTNERS) {
        SET_OUTLOG_REPLICA_STATE(Replica, OL_REPLICA_WAITING);
    }

    FRS_ASSERT(OutLogPartner->Cxtion != NULL);
    //
    // Track the count of outlog connections that have joined at least once.
    // If this count is zero then we don't need to hold onto any staging files
    // or put any change orders in the outbound log since the first connection
    // to join will have to do a VVJOIN anyway.
    //
    if (OutLogPartner->Cxtion->LastJoinTime > (ULONGLONG) 1) {
        InterlockedIncrement(&Replica->OutLogCxtionsJoined);
    }

    OutLogReleaseLock(Replica);

    return FrsErrorSuccess;
}



ULONG
OutLogAddNewPartner(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX TableCtx,
    IN PREPLICA Replica,
    IN PCXTION Cxtion
)
/*++
Routine Description:

    Add a new outbound partner to the Replica set.  Initialize the
    Partner state and create an initial record in the partner table.

Arguments:

    ThreadCtx -- Needed to update the database
    TableCtx -- Needed to update the database
    Replica -- The replica set struct for the outbound log.
    Cxtion -- The information about the partner, Guid, Send Queue, Send
                   Quota, ...

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogAddNewPartner:"

    ULONG            FStatus;
    POUT_LOG_PARTNER OutLogPartner;

    //
    // Warning -- called for both inbound and outbound cxtions; be careful.
    //

    FRS_ASSERT(IS_CXTION_TABLE(TableCtx));

    //
    // Allocate an outbound log partner context, link it to the connection info.
    //
    if (!Cxtion->Inbound) {
        OutLogPartner = FrsAllocType(OUT_LOG_PARTNER_TYPE);

        Cxtion->OLCtx = OutLogPartner;
        OutLogPartner->Cxtion = Cxtion;

        //
        // Create the initial state for this new outbound partner.
        // Setting these to zero will cause the new partner to do a VVJoin
        // when it first connects.
        //
        OutLogPartner->COLx = 0;
        OutLogPartner->COTx = 0;

        ResetAckVector(OutLogPartner);

        OutLogPartner->OutstandingQuota = MaxOutLogCoQuota;
        OutLogPartner->COTxLastSaved = OutLogPartner->COTx;
    }
    //
    // Make last join time non-zero so if we come up against an old database
    // with a zero for LastJoinTime the mismatch will cause a VVJOIN.
    //
    Cxtion->LastJoinTime = (ULONGLONG) 1;

    //
    // This is a new connection. Mark it so that we know it has not
    // complete the initial sync. Also pause it so it does not start
    // joining.
    //
    if (BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_SEEDING) && Cxtion->Inbound) {
        SetCxtionFlag(Cxtion, CXTION_FLAGS_INIT_SYNC);
        SetCxtionFlag(Cxtion, CXTION_FLAGS_PAUSED);
    }

    //
    // Update the database record in memory
    //
    OutLogCopyCxtionToCxtionRecord(Cxtion, TableCtx);
    FStatus = DbsInsertTable(ThreadCtx, Replica, TableCtx, CXTIONTablex, NULL);
    DPRINT1_FS(0, "ERROR Adding %ws\\%ws\\%ws -> %ws\\%ws",
               PRINT_CXTION_PATH(Replica, Cxtion), FStatus);

    return FStatus;
}



ULONG
OutLogDeactivatePartner(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX  TableCtx,
    IN PREPLICA    Replica,
    IN PCXTION     Cxtion
)
/*++
Routine Description:

    Put the partner in the Inactive state.  Incoming ACKs can still occur but
    this partner is no longer Eligible to receive change orders.  Note that
    Outbound Change orders still go into the log and when this partner is
    again eligible to receive them the COs will be sent.

Arguments:

    ThreadCtx
    TableCtx
    Replica -- The replica set struct for the outbound log.
    Cxtion -- The information about the partner, Guid, Send Queue, Send
                   Quota, ...

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogDeactivatePartner:"

    ULONG            FStatus;
    POUT_LOG_PARTNER OutLogPartner = Cxtion->OLCtx;
    ULONG            COx;

    //
    // No outbound log state to deactivate for inbound cxtions
    //
    if (Cxtion->Inbound) {
        FRS_ASSERT(OutLogPartner == NULL);
        return FrsErrorSuccess;
    }

    //
    // No need to deactivate more than once, yet.
    //
    if (OutLogPartner->State == OLP_INACTIVE) {
        return FrsErrorSuccess;
    }

    OutLogAcquireLock(Replica);

    SET_OUTLOG_PARTNER_INACTIVE(Replica, OutLogPartner);

    OutLogReleaseLock(Replica);

    OUT_LOG_DUMP_PARTNER_STATE(4, OutLogPartner, OutLogPartner->COTx, "Deactivate");

    //
    // Update the database with the current state of this partner.
    //
    FStatus = OutLogCommitPartnerState(ThreadCtx, TableCtx, Replica, Cxtion);

    return FStatus;

}



ULONG
OutLogActivatePartnerCmd(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX  TableCtx,
    IN PREPLICA    Replica,
    IN PCXTION     Cxtion,
    IN BOOL        HaveLock
)
/*++
Routine Description:

    Read the connection record for this outbound partner so it can resume
    sending change orders where it left off when last deactivated.
    Put the partner into the Eligible or Standby state.  This is called
    via OutLogSubmit() and the command processor so we can read the
    connection record for the partner.

Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.
    TableCtx -- ptr to the connection table ctx.
    Replica -- The replica set struct for the outbound log.
    Cxtion -- The outbound cxtion for this partner.
    HaveLock -- True if the caller has the Outbound log process lock on this
                replica.  Otherwise we acquire it here.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogActivatePartnerCmd:"
    POUT_LOG_PARTNER OutLogPartner = Cxtion->OLCtx;
    ULONG FStatus;

    //
    // Check if this is a call to activate a partner already activated.
    //
    if ((OutLogPartner->State == OLP_ELIGIBLE) ||
        (OutLogPartner->State == OLP_STANDBY)) {
        return FrsErrorSuccess;
    }

    //
    // If the outbound log process is active for this replica and this particular
    // partner is either unjoined or inactive then get its initial state from
    // its connection record.
    //
    if ((Replica->OutLogWorkState == OL_REPLICA_WORKING) ||
        (Replica->OutLogWorkState == OL_REPLICA_WAITING)) {

        if ((OutLogPartner->State == OLP_UNJOINED) ||
            (OutLogPartner->State == OLP_INACTIVE)) {
            FStatus = OutLogReadPartner(ThreadCtx, TableCtx, Replica, Cxtion);
            if (!FRS_SUCCESS(FStatus)) {
                DPRINT_FS(0, "OutLogReadPartner failed.", FStatus);
                return FStatus;
            }
        } else {
            if (OutLogPartner->State != OLP_AT_QUOTA) {
                DPRINT1(1, "ERROR - Attempt to activate partner in %s state\n",
                        OLPartnerStateNames[OutLogPartner->State]);
                return FrsErrorPartnerActivateFailed;
            }
        }
    }

    FStatus = OutLogActivatePartner(Replica, Cxtion, HaveLock);
    DPRINT_FS(1, "OutLogActivatePartner failed.", FStatus);


    return FStatus;

}

ULONG
OutLogCleanupMustSendTableWorker (
    PQHASH_TABLE Table,
    PQHASH_ENTRY BeforeNode,
    PQHASH_ENTRY TargetNode,
    PVOID Context
    )
/*++

Routine Description:

    This function is called thru QHashEnumerateTable() to remove old entries
    from the partner's must-send table.

    The must-send table records the outlog sequence number and the time sent
    of the last change order for a given file.

    If the trailing index for this partner has passed the outlog sequence number
    of the entry and the Time since the CO was sent is greater than
    3 times the OutLogRepeatInterval then we conclude that we are unlikely to
    see a further update to this file so the entry is removed from the table.

Arguments:
    Table - the hash table being enumerated
    BeforeNode  -- ptr to the QhashEntry before the node of interest.
    TargetNode  -- ptr to the QhashEntry of interest.
    Context - Replica ptr.

Return Value:
    FRS status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogCleanupMustSendTableWorker:"

    ULONGLONG            DeltaTime;
    POUT_LOG_PARTNER     OutLogPartner = (POUT_LOG_PARTNER) Context;
    PDOMINANT_FILE_ENTRY MustSendEntry;

    MustSendEntry = (PDOMINANT_FILE_ENTRY) (TargetNode->Flags);

    //
    // If the outlog partner's last saved trailing Index has passed this
    // entry by then delete it.  Use last-saved since it changes more slowly.
    //
    if (MustSendEntry->OLSeqNum < OutLogPartner->COTxLastSaved) {

        if (MustSendEntry->TimeSent > 0) {
            //
            // We have sent a CO for this File in the past.
            // If we have not sent another for DeltaTime sec since
            // COTx passed us by then remove the entry.
            // The current value for DeltaTime is 3 times the RepeatInterval.
            //
            GetSystemTimeAsFileTime((PFILETIME)&DeltaTime);
            DeltaTime -= MustSendEntry->TimeSent;
            DeltaTime /= (ULONGLONG)(10 * 1000 * 1000);

            //
            // TODO:  It would be better if we could avoid using the global
            //        value here but we don't have the ptr to the Replica struct.
            //        Need to pass Replica and OutLogPartner thru a temp context
            //        to make this work.
            //
            if (DeltaTime > 3 * GOutLogRepeatInterval) {
                FrsFree(MustSendEntry);
                TargetNode->Flags = 0;
                //
                // Tell QHashEnumerateTable() to delete the QHash node and continue the enum.
                //
                return FrsErrorDeleteRequested;
            }
        } else {
            FrsFree(MustSendEntry);
            TargetNode->Flags = 0;
            return FrsErrorDeleteRequested;
        }
    }

    return FrsErrorSuccess;
}


ULONG
OutLogActivatePartner(
    IN PREPLICA Replica,
    IN PCXTION  PartnerCxtion,
    IN BOOL     HaveLock
)
/*++
Routine Description:

    Put the partner into the Eligible or Standby state.  Internal call only.

Arguments:

    Replica -- The replica set struct for the outbound log.
    Cxtion -- The outbound cxtion for this partner.
    HaveLock -- True if the caller has the Outbound log process lock on this
                replica.  Otherwise we acquire it here.
Return Value:

    Frs Status
--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogActivatePartner:"
    POUT_LOG_PARTNER OutLogPartner = PartnerCxtion->OLCtx;
    ULONG NewState;
    PLIST_ENTRY NewQueue;
    BOOL Working, Waiting, AtQuota;

    //
    // Check if this is a call to activate a partner already activated.
    //
    if ((OutLogPartner->State == OLP_ELIGIBLE) ||
        (OutLogPartner->State == OLP_STANDBY)) {
        DPRINT(3, "ERROR - Bogus call to OutLogActivatePartner\n");
        return FrsErrorSuccess;
    }

    //
    // On the first activation of this outbound connection allocate the
    // cxtion MustSend hash table to record the dominant file update change
    // order in the oubound log when multiple COs for the same file guid are
    // present.  This is necessary to ensure we send something in the case of
    // a file that is experiencing frequent updates.  The hash function is on
    // the file Guid.
    //
    if (OutLogPartner->MustSendTable == NULL) {
        OutLogPartner->MustSendTable = FrsAllocTypeSize(QHASH_TABLE_TYPE,
                                                        OUTLOG_MUSTSEND_FILE_TABLE_SIZE);
        SET_QHASH_TABLE_FLAG(OutLogPartner->MustSendTable, QHASH_FLAG_LARGE_KEY);
        SET_QHASH_TABLE_HASH_CALC2(OutLogPartner->MustSendTable, OutLogDominantHashCalc);
        SET_QHASH_TABLE_KEY_MATCH(OutLogPartner->MustSendTable, OutLogDominantKeyMatch);
        SET_QHASH_TABLE_FREE(OutLogPartner->MustSendTable, FrsFree);
    } else {

        //
        // Each time we activate an outlog partner we scan its MustSendTable
        // for expired entries.  Change orders created for VVJoins do not
        // get inserted into the MustSendTable so skip the cleanup.
        // Note: may need something smarter here if this gets expensive.
        //
        if (!InVVJoinMode(OutLogPartner)) {
            QHashEnumerateTable(OutLogPartner->MustSendTable,
                                OutLogCleanupMustSendTableWorker,
                                OutLogPartner);
        }
    }

    if (!HaveLock) {OutLogAcquireLock(Replica);}

    //
    // If VVJOIN required then set the leading index to zero to force it.
    //
    if (CxtionFlagIs(PartnerCxtion, CXTION_FLAGS_PERFORM_VVJOIN)) {
        OutLogPartner->COLx = 0;
        ClearCxtionFlag(PartnerCxtion, CXTION_FLAGS_PERFORM_VVJOIN);
    }

    //
    // Ditto if we had to trim the outlog of change orders that never
    // got sent to this cxtion.
    //
    if (BooleanFlagOn(OutLogPartner->Flags, OLP_FLAGS_LOG_TRIMMED)) {
        OutLogPartner->COLx = 0;
        ClearFlag(OutLogPartner->Flags, OLP_FLAGS_LOG_TRIMMED);
    }


    FrsRemoveEntryList(&OutLogPartner->List);

    //
    // If the Outbound log process is not running for this replica,
    // stick the partner struct on the InActive list.
    // Note: we could still see more ACKs come in for this partner.
    //
    NewQueue = &Replica->OutLogInActive;
    NewState = OLP_INACTIVE;

    //
    // If the replica is in the working state, put the partner struct
    // on the standby list (if it's not at the quota limit).  The outbound
    // log process will pick it up when it first starts but if it is
    // already started it will wait until the next cycle.
    //
    // If Replica is waiting for outbound log work put the partner
    // struct on the Eligible list, set the Replica outbound log
    // state to working and insert the command packet on the queue.
    //
    Working = (Replica->OutLogWorkState == OL_REPLICA_WORKING);
    Waiting = (Replica->OutLogWorkState == OL_REPLICA_WAITING);
    AtQuota = (OutLogPartner->OutstandingCos >= OutLogPartner->OutstandingQuota);

    if (Working || Waiting) {

        if (AtQuota) {
            //
            // Activating a partner that is still at max quota for COs
            // outstanding.  Put it on the active list but it won't go to the
            // eligible list until some Acks come back.
            //
            NewQueue = &Replica->OutLogActive;
            NewState = OLP_AT_QUOTA;
            DPRINT3(1, "STILL_AT_QUOTA on OutLog partner %08x on Replica %08x, %ws\n",
                   OutLogPartner, Replica, Replica->ReplicaName->Name);
            FRS_PRINT_TYPE(0, OutLogPartner);
        } else {
            NewQueue = (Working ? &Replica->OutLogStandBy : &Replica->OutLogEligible);
            NewState = (Working ? OLP_STANDBY             : OLP_ELIGIBLE);
        }
    }

    SET_OUTLOG_PARTNER_STATE(OutLogPartner, NewState);
    InsertTailList(NewQueue, &OutLogPartner->List);

    //
    // If Replica is waiting for outbound log work set the Replica outbound
    // log state to working and insert the command packet on the queue.
    //
    if (Waiting && !AtQuota) {
        SET_OUTLOG_REPLICA_STATE(Replica, OL_REPLICA_WORKING);
        FrsSubmitCommand(Replica->OutLogCmdPkt, FALSE);
    }

    if (!HaveLock) {OutLogReleaseLock(Replica);}
    return FrsErrorSuccess;
}


ULONG
OutLogClosePartner(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX  TableCtx,
    IN PREPLICA    Replica,
    IN PCXTION     Cxtion
)
/*++
Routine Description:

    Close the partner, saving its state, and Remove the partner from the
    Outbound log process.  Free the context.

Arguments:

    ThreadCtx
    TableCtx
    Replica -- The replica set struct for the outbound log.
    Cxtion -- The information about the partner, Guid, Send Queue, Send
              Quota, ...

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogClosePartner:"

    POUT_LOG_PARTNER OutLogPartner = Cxtion->OLCtx;
    ULONG            COx;

    //
    // Not open or an inbound cxtion; done
    //
    if (OutLogPartner == NULL) {
        return FrsErrorSuccess;
    }

    OutLogAcquireLock(Replica);
    FrsRemoveEntryList(&OutLogPartner->List);
    SET_OUTLOG_PARTNER_STATE(OutLogPartner, OLP_INITIALIZING);
    OutLogReleaseLock(Replica);

    OUT_LOG_DUMP_PARTNER_STATE(4, OutLogPartner, OutLogPartner->COTx, "Close partner");

    //
    // Update the database with the current state of this partner.
    //
    return OutLogCommitPartnerState(ThreadCtx, TableCtx, Replica, Cxtion);
}




ULONG
OutLogRemovePartner(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX TableCtx,
    IN PREPLICA Replica,
    IN PCXTION ArgCxtion
)
/*++
Routine Description:

    This partner is being removed from the database.

    Remove the partner from the Outbound log process.  If this is the last
    outbound partner for this replica set then empty the outbound log and
    set the outbound replica state to OL_REPLICA_NOPARTNERS.

Assumes:

    The connection is already removed from the connection table so we
    enumerate the table to see if any more oubound partners exist.

Arguments:

    ThreadCtx
    TableCtx
    Replica -- The replica set struct for the outbound log.
    ArgCxtion -- The information about the partner, Guid, Send Queue, Send
                   Quota, ...

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogRemovePartner:"

    PVOID           Key;
    PCXTION_RECORD  CxtionRecord = TableCtx->pDataRecord;
    ULONG           FStatus = FrsErrorSuccess;
    PCXTION         Cxtion;

    FRS_ASSERT(IS_CXTION_TABLE(TableCtx));

    //
    // Copy the fields from the cxtion into the table's cxtion record
    //
    OutLogCopyCxtionToCxtionRecord(ArgCxtion, TableCtx);

    //
    // Seek to the CxtionTable record and delete it.
    //
    FStatus = DbsDeleteTableRecordByIndex(ThreadCtx,
                                          Replica,
                                          TableCtx,
                                          &CxtionRecord->CxtionGuid,
                                          CrCxtionGuidxIndexx,
                                          CXTIONTablex);
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT1_FS(0, "ERROR Deleting %ws\\%ws\\%ws -> %ws\\%ws",
                   PRINT_CXTION_PATH(Replica, ArgCxtion), FStatus);
        return FStatus;
    }

    //
    // Inbound partner; done
    //
    if (ArgCxtion->Inbound) {
        return FStatus;
    }
    FRS_ASSERT(ArgCxtion->OLCtx);

    //
    // An embedded closepartner w/o the state update
    //
    OutLogAcquireLock(Replica);
    FrsRemoveEntryList(&ArgCxtion->OLCtx->List);
    SET_OUTLOG_PARTNER_STATE(ArgCxtion->OLCtx, OLP_INITIALIZING);
    OutLogReleaseLock(Replica);

    //
    // There may be old change orders in the outbound log that
    // weren't cleaned up because the service shut down before
    // the cleanup thread ran. Allow the cleanup thread to run
    // at least once to empty the outbound log of stale change
    // orders.
    //
    Replica->OutLogDoCleanup = TRUE;

    //
    // See if any outbound partners remain.
    //
    LOCK_CXTION_TABLE(Replica);
    Key = NULL;
    while (Cxtion = GTabNextDatumNoLock(Replica->Cxtions, &Key)) {
        if (!Cxtion->Inbound  &&
            !GUIDS_EQUAL(ArgCxtion->Name->Guid, Cxtion->Name->Guid)) {
            UNLOCK_CXTION_TABLE(Replica);
            return FStatus;
        }
    }
    UNLOCK_CXTION_TABLE(Replica);

    //
    // No outbound connections left.
    //
    OutLogAcquireLock(Replica);
    SET_OUTLOG_REPLICA_STATE(Replica, OL_REPLICA_NOPARTNERS);
    Replica->OutLogCxtionsJoined = 0;
    OutLogReleaseLock(Replica);

    return FStatus;
}

ULONG
OutLogReadPartner(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX TableCtx,
    IN PREPLICA Replica,
    IN PCXTION Cxtion
)
/*++
Routine Description:

    Read the outlog partner state from the connection record so we can
    reactivate the partner.

Arguments:

    ThreadCtx
    TableCtx
    Replica -- The replica set struct for the outbound log.
    Cxtion -- The information about the partner, Guid, Send Queue, Send
                   Quota, ...

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogReadPartner:"

    PCXTION_RECORD   CxtionRecord = TableCtx->pDataRecord;
    ULONG            FStatus = FrsErrorSuccess;
    POUT_LOG_PARTNER OutLogPartner;
    ULONG            COx;

    FRS_ASSERT(IS_CXTION_TABLE(TableCtx));

    //
    // Open the connection table for the replica set and read the connection
    // record identified by the connection guid.
    //
    FStatus = DbsReadTableRecordByIndex(ThreadCtx,
                                        Replica,
                                        TableCtx,
                                        Cxtion->Name->Guid,
                                        CrCxtionGuidx,
                                        CXTIONTablex);

    if (!FRS_SUCCESS(FStatus)) {
        return FrsErrorBadOutLogPartnerData;
    }

    //
    // this record should not be for an inbound partner.
    //
    if (Cxtion->Inbound) {
        DPRINT(0, "ERROR - Can't get Outlog partner data from an imbound cxtion.\n");
        return FrsErrorBadOutLogPartnerData;
    }

    OutLogPartner = Cxtion->OLCtx;
    FRS_ASSERT(Cxtion->OLCtx);
    FRS_ASSERT(OutLogPartner->Cxtion == Cxtion);

    OutLogPartner->Flags = CxtionRecord->Flags;
    //
    // The restart point (COLxRestart) is where the leading index left off
    // when the connection last shutdown.  Set the active leading index (COLx)
    // to the saved trailing index so we can resend any change orders that had
    // not been Acked at the time the connection went down.  They could have
    // been lost in transit or if the destination crashed before writing them
    // to the inbound log.  Of course in the meantime Acks may come in for
    // those COs if the outbound partner still has them.  A few special checks
    // are made elsewhere to detect this case and keep the leading index from
    // falling behind the trailing index.  See OutLogMarkAckVector().
    //
    // COLxVVJoinDone is similar to COLxRestart except that it applies only
    // after a VVJoin has finished.  The only behaviorial difference is that
    // The out-of-order change order flag is not set because the normal mode
    // change orders that get sent on the second OutLog pass of a VVJoin are
    // sent in order.  They should get dampened if a directed CO from the VV
    // join has already sent the file.
    //
    OutLogPartner->COLxVVJoinDone = 0;
    OutLogPartner->COLxRestart = CxtionRecord->COLx;
    OutLogPartner->COLx = CxtionRecord->COTx;
    OutLogPartner->COTx = CxtionRecord->COTx;

    OutLogPartner->COTxNormalModeSave = CxtionRecord->COTxNormalModeSave;
    OutLogPartner->COTslot = CxtionRecord->COTslot;
    OutLogPartner->OutstandingQuota = MaxOutLogCoQuota;  //CxtionRecord->OutstandingQuota
    CopyMemory(OutLogPartner->AckVector, CxtionRecord->AckVector, ACK_VECTOR_BYTES);
    OutLogPartner->AckVersion = CxtionRecord->AckVersion;

    OutLogPartner->COTxLastSaved = OutLogPartner->COTx;
    OutLogPartner->OutstandingCos = 0;

    //
    // If the change order leading index for this partner is greater than
    // where we are currently inserting new records then advance to it.
    // Use InterlockedCompareExchange to make sure it doesn't move backwards.
    // This could happen if we get context switched and another thread advances
    // the sequence number.
    //
    ADVANCE_VALUE_INTERLOCKED(&Replica->OutLogSeqNumber, OutLogPartner->COLx);

    OUT_LOG_DUMP_PARTNER_STATE(4, OutLogPartner, OutLogPartner->COTx, "Reactivate");

    //
    // Check if we were already in vvjoin mode.
    // Force a VV join in this case.
    //
    if (InVVJoinMode(OutLogPartner)) {
        SetCxtionFlag(Cxtion, CXTION_FLAGS_PERFORM_VVJOIN);
        ClearFlag(OutLogPartner->Flags, OLP_FLAGS_VVJOIN_MODE);
        DPRINT1(4, "Clearing vvjoin mode (Flags are now %08x)\n",
                OutLogPartner->Flags);
    }

    return FrsErrorSuccess;
}




ULONG
OutLogUpdatePartner(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX TableCtx,
    IN PREPLICA Replica,
    IN PCXTION Cxtion
)
/*++
Routine Description:

    Update the cxtion record in the database.

    ** Warning ** This gets called for both inbound and outbound connections.

Arguments:

    Replica -- The replica set struct for the outbound log.
    Cxtion -- The information about the partner, Guid, Send Queue, Send
                   Quota, ...

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogUpdatePartner:"

    ULONG               FStatus;
    PCXTION_RECORD      CxtionRecord = TableCtx->pDataRecord;
    POUT_LOG_PARTNER    OutLogPartner = Cxtion->OLCtx;

    FRS_ASSERT(IS_CXTION_TABLE(TableCtx));

    //
    // Copy the fields from the cxtion into the table's cxtion record
    //
    OutLogCopyCxtionToCxtionRecord(Cxtion, TableCtx);

    //
    // Open the table and update the requested record.
    //
    FStatus = DbsUpdateTableRecordByIndex(ThreadCtx,
                                          Replica,
                                          TableCtx,
                                          &CxtionRecord->CxtionGuid,
                                          CrCxtionGuidx,
                                          CXTIONTablex);

    DBS_DISPLAY_RECORD_SEV(4, TableCtx, FALSE);
    if (!FRS_SUCCESS(FStatus)) {
        return FStatus;
    }

    //
    // Track the value of the last Change Order Trailing Index saved for
    // outbound connections.
    //
    if (!Cxtion->Inbound) {
        OutLogPartner->COTxLastSaved = OutLogPartner->COTx;
    }

    return FrsErrorSuccess;
}


ULONG
OutLogProcess(
    PVOID  FrsThreadCtxArg
)
/*++
Routine Description:

    Entry point for processing output log change orders.

Arguments:

    FrsThreadCtxArg - thread

Return Value:

    WIN32 Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogProcess:"

    JET_ERR              jerr, jerr1;
    ULONG                WStatus = ERROR_SUCCESS;
    ULONG                FStatus;
    NTSTATUS             Status;

    PFRS_THREAD          FrsThread = (PFRS_THREAD)FrsThreadCtxArg;
    PTHREAD_CTX          ThreadCtx;
    PTABLE_CTX           TableCtx;
    LIST_ENTRY           DeadList;
    PCOMMAND_PACKET      CmdPkt;
    PLIST_ENTRY          Entry;
    PREPLICA             Replica;
    PCXTION              PartnerCxtion;
    ULONG                COx;
    ULONG                TimeNow, NextCleanTime, WaitTime;

    DPRINT(0, "Outbound log processor is starting.\n");

    //
    // The database must be started before we create a jet session
    //      WARN: the database startup code will be adding command
    //      packets to our queue while we are waiting. This should
    //      be okay.
    //      WARN: The database event may be set by the shutdown
    //      code in order to force threads to exit.
    //
    WaitForSingleObject(DataBaseEvent, INFINITE);
    if (FrsIsShuttingDown) {
        ShutDownOutLog();
        goto EXIT_THREAD_NO_INIT;
    }

    //
    // Try-Finally so we shutdown Jet cleanly.
    //
    try {

    //
    // Capture exception.
    //
    try {
        //
        // Allocate a context for Jet to run in this thread.
        //
        ThreadCtx = FrsAllocType(THREAD_CONTEXT_TYPE);
        TableCtx = DbsCreateTableContext(CXTIONTablex);

        //
        // Setup a Jet Session returning the session ID in ThreadCtx.
        //
        jerr = DbsCreateJetSession(ThreadCtx);
        if (JET_SUCCESS(jerr)) {

            DPRINT(4,"JetOpenDatabase complete\n");
        } else {
            DPRINT_JS(0,"ERROR - OpenDatabase failed.  Thread exiting.", jerr);
            FStatus = DbsTranslateJetError(jerr, FALSE);
            DbsFreeTableContext(TableCtx, 0);
            jerr = DbsCloseJetSession(ThreadCtx);
            ThreadCtx = FrsFreeType(ThreadCtx);
            return ERROR_GEN_FAILURE;
        }

        NextCleanTime = GetTickCount();

        DPRINT(0, "Outbound log processor has started.\n");
        while(TRUE) {
            Entry = FrsRtlRemoveHeadQueueTimeout(&OutLogWork, OUT_LOG_POLL_INTERVAL);
            if (Entry == NULL) {
                WStatus = GetLastError();
            } else {
                WStatus = ERROR_SUCCESS;
            }

            //
            // Check if it's time to Clean the log.
            // Note: consider changing to use the delayed command server.
            //
            TimeNow = GetTickCount();
            WaitTime = NextCleanTime - TimeNow;

            if ((WaitTime > OUT_LOG_CLEAN_INTERVAL) || (WaitTime == 0)) {
                DPRINT3(4, "NextCleanTime: %08x  Time: %08x   Diff:  %08x\n",
                       NextCleanTime, TimeNow, WaitTime);
                NextCleanTime += OUT_LOG_CLEAN_INTERVAL;

                //
                // Do outbound log cleanup on each replica if something happened.
                //
                ForEachListEntry( &ReplicaListHead, REPLICA, ReplicaList,
                    // Loop iterator pE is type PREPLICA.
                    DPRINT1(5, "LogCleanup on %ws\n", pE->ReplicaName->Name);
                    if (pE->OutLogDoCleanup && !FrsIsShuttingDown) {
                        DPRINT3(5, "OutLog Cleanup for replica %ws, id: %d, (%08x)\n",
                                pE->ReplicaName->Name, pE->ReplicaNumber, pE);
                        OutLogCleanupLog(ThreadCtx, pE);
                    }
                );
            }

            //
            // Check the return code from remove queue.
            //
            if (WStatus == WAIT_TIMEOUT) {
                DPRINT(5, "Wait timeout\n");
                continue;
            }

            if (WStatus == ERROR_INVALID_HANDLE) {
                DPRINT(1, "OutLog Queue was RunDown.\n");
                //
                // Queue was run down.  Time to exit.
                //
                WStatus = ERROR_SUCCESS;
                goto EXIT_LOOP;
            }

            //
            // Some other error?
            //
            CLEANUP_WS(0, "Wait for queue error", WStatus, EXIT_LOOP);

            //
            // Check for a valid command packet.
            //
            CmdPkt = CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
            if (CmdPkt->Header.Type != COMMAND_PACKET_TYPE) {
                DPRINT1(0, "ERROR - Unknown packet type %d\n", CmdPkt->Header.Type);
                FrsCompleteCommand(CmdPkt, ERROR_GEN_FAILURE);
                continue;
            }

            Replica = CmdPkt->Parameters.OutLogRequest.Replica;
            PartnerCxtion = CmdPkt->Parameters.OutLogRequest.PartnerCxtion;

            //
            // If one of the commands below took an error then they may have
            // called DbsFreeTableCtx().  Fix this here.
            //
            if (IS_INVALID_TABLE(TableCtx)) {
                Status = DbsAllocTableCtx(CXTIONTablex, TableCtx);
                if (!NT_SUCCESS(Status)) {
                    DPRINT_NT(0, "ERROR - DbsAllocRecordStorage failed to alloc buffers.", Status);
                    DbsFreeTableCtx(TableCtx, 1);
                    FrsCompleteCommand(CmdPkt, ERROR_GEN_FAILURE);
                    continue;
                }
            }


            // Note: add try except around the command rather than process terminate

            switch (CmdPkt->Command) {

            case CMD_OUTLOG_WORK_CO:
                DPRINT(5, "OutLogProcessReplica CALL <<<<<<<<<<<<<<<<<<<< \n");
                if (Replica->OutLogWorkState == OL_REPLICA_NOPARTNERS) {
                    break;
                }
                //
                // Process outbound log change orders for this Replica set.
                //
                FStatus = OutLogProcessReplica(ThreadCtx, Replica);

                //
                // If more work to do then requeue the command packet at the end
                // to give other replica sets a chance.
                //
                if (FStatus == FrsErrorMoreWork) {
                    if (!FrsIsShuttingDown) {
                        FrsSubmitCommand(CmdPkt, FALSE);
                        FStatus = FrsErrorSuccess;
                    }
                }

                //
                // If we finished all the work on this replica then we leave it off the
                // queue.  When more work arrives the cmd packet is re-submitted.
                //
                if (!FRS_SUCCESS(FStatus)) {
                    DPRINT_FS(0, "ERROR: OutLogProcessReplica failed.", FStatus);
                    WStatus = ERROR_GEN_FAILURE;
                }
                break;



            case CMD_OUTLOG_ADD_REPLICA:
                DPRINT(5, "OutLogAddReplica CALL <<<<<<<<<<<<<<<<<<<< \n");
                FStatus = OutLogAddReplica(ThreadCtx, Replica);
                break;

            case CMD_OUTLOG_REMOVE_REPLICA:
                DPRINT(5, "OutLogRemoveReplica CALL <<<<<<<<<<<<<<<<<<<< \n");
                FStatus = OutLogRemoveReplica(ThreadCtx, Replica);
                break;

            case CMD_OUTLOG_INIT_PARTNER:
                DPRINT(5, "OutLogInitPartner CALL <<<<<<<<<<<<<<<<<<<< \n");
                FStatus = OutLogInitPartner(Replica, PartnerCxtion);
                break;

            case CMD_OUTLOG_ADD_NEW_PARTNER:
                DPRINT(5, "OutLogAddNewPartner CALL <<<<<<<<<<<<<<<<<<<< \n");
                FStatus = OutLogAddNewPartner(ThreadCtx, TableCtx, Replica, PartnerCxtion);
                break;

            case CMD_OUTLOG_UPDATE_PARTNER:
                DPRINT(5, "OutLogUpdatePartner CALL <<<<<<<<<<<<<<<<<<<< \n");
                FStatus = OutLogUpdatePartner(ThreadCtx, TableCtx, Replica, PartnerCxtion);
                break;

            case CMD_OUTLOG_DEACTIVATE_PARTNER:
                DPRINT(5, "OutLogDeactivatePartner CALL <<<<<<<<<<<<<<<<<<<< \n");
                FStatus = OutLogDeactivatePartner(ThreadCtx, TableCtx, Replica, PartnerCxtion);
                break;

            case CMD_OUTLOG_ACTIVATE_PARTNER:
                DPRINT(5, "OutLogActivatePartner CALL <<<<<<<<<<<<<<<<<<<< \n");
                FStatus = OutLogActivatePartnerCmd(ThreadCtx,
                                                   TableCtx,
                                                   Replica,
                                                   PartnerCxtion,
                                                   FALSE);
                break;

            case CMD_OUTLOG_CLOSE_PARTNER:
                DPRINT(5, "OutLogClosePartner CALL <<<<<<<<<<<<<<<<<<<< \n");
                FStatus = OutLogClosePartner(ThreadCtx, TableCtx, Replica, PartnerCxtion);
                break;

            case CMD_OUTLOG_REMOVE_PARTNER:
                DPRINT(5, "OutLogRemovePartner CALL <<<<<<<<<<<<<<<<<<<< \n");
                FStatus = OutLogRemovePartner(ThreadCtx, TableCtx, Replica, PartnerCxtion);
                break;

            case CMD_OUTLOG_RETIRE_CO:
                DPRINT(5, "OutLogRetireCo CALL <<<<<<<<<<<<<<<<<<<< \n");
                COx = CmdPkt->Parameters.OutLogRequest.SequenceNumber;
                FStatus = OutLogRetireCo(Replica, COx, PartnerCxtion);
                break;

            default:
                DPRINT1(0, "ERROR - Unknown OutLog command %d\n", (ULONG)CmdPkt->Command);
                FStatus = FrsErrorInvalidOperation;

            }  // end switch

            //
            // Retire the command packet. (Note if this is our "work" packet the
            // completion routine is a no-op).
            //
            FrsCompleteCommand(CmdPkt, FStatus);

            continue;

EXIT_LOOP:
            break;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }


    } finally {

        //
        // Shutdown
        //
        if (WIN_SUCCESS(WStatus)) {
            if (AbnormalTermination()) {
                WStatus = ERROR_OPERATION_ABORTED;
            }
        }

        DPRINT_WS(0, "Outlog finally.", WStatus);

        //
        // Do outbound log cleanup on each replica if something happened.
        //
        ForEachListEntry( &ReplicaListHead, REPLICA, ReplicaList,
            // Loop iterator pE is type PREPLICA.
            if (pE->OutLogDoCleanup) {
                DPRINT3(4, "OutLog Cleanup for replica %ws, id: %d, (%08x)\n",
                        pE->ReplicaName->Name, pE->ReplicaNumber, pE);
                OutLogCleanupLog(ThreadCtx, pE);
            }
            //
            // Close down the connection info on each outbound partner.
            //
            OutLogRemoveReplica(ThreadCtx, pE);
        );

        DbsFreeTableContext(TableCtx, 0);

        //
        // Now close the jet session and free the Jet ThreadCtx.
        //
        jerr = DbsCloseJetSession(ThreadCtx);

        if (!JET_SUCCESS(jerr)) {
            DPRINT_JS(0,"DbsCloseJetSession error:", jerr);
        } else {
            DPRINT(4,"DbsCloseJetSession complete\n");
        }

        ThreadCtx = FrsFreeType(ThreadCtx);
    }

EXIT_THREAD_NO_INIT:
    DPRINT1(3, "<<<<<<<...T E R M I N A T I N G -- %s...>>>>>>>>\n", DEBSUB);


    DPRINT(0, "Outbound log processor is exiting.\n");

    //
    // Trigger FRS shutdown if we terminated abnormally.
    //
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT(0, "Outbound log processor terminated abnormally, rundown outlog queue.\n");
        ShutDownOutLog();
        DPRINT(0, "Outbound log processor terminated abnormally, forcing service shutdown.\n");
        FrsIsShuttingDown = TRUE;
        SetEvent(ShutDownEvent);
    }

    ThSupSubmitThreadExitCleanup(FrsThreadCtxArg);
    ExitThread(WStatus);


    return ERROR_SUCCESS;

}


ULONG
OutLogProcessReplica(
    PTHREAD_CTX  ThreadCtx,
    PREPLICA     Replica
)
/*++
Routine Description:

    New work has arrived for this replica.  This could be due to a new change
    order arriving in the outbound log or an outbound partner could have
    acknowledged a change order making it eligible to receive the next one.

    There could be many change orders queued for this replica set.  To keep
    this replica set from consuming resources to the exclusion of other
    replica sets we process a limited number of change orders and then return
    with stats FrsErrorMoreWork.  This causes the command packet to be requeued
    at the end of the OutLogWork queue so we can service other replica sets.

Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.
    Replica -- The replica set struct for the outbound log.

Return Value:

    Frs Status
        FrsErrorMoreWork - if there is more work to do on this Replica Set.
        FrsErrorSuccess  - if there is no more work or no eligible outbound
                           parnters for this replica set.

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogProcessReplica:"

    ULONG FStatus;
    PLIST_ENTRY Entry;
    POUT_LOG_PARTNER Partner;
    ULONG JointLeadingIndex;
    PCHANGE_ORDER_COMMAND CoCmd;
    BOOL MoreCo;
    ULONG LoopCheck = 0;

    //
    // Get the outbound log lock for this replica and hold it until we
    // are finished.  If this is a performance problem with the Ack side
    // then split the lock.
    //
    OutLogAcquireLock(Replica);

    Replica->OutLogRepeatInterval = GOutLogRepeatInterval;

    //
    // A delay before processing the OutLog can give frequently changing files
    // a chance to get into the DominantFileTable.  The question is what is
    // the right delay and where is the right place to put it?
    //
    // Sleep(20*1000);

START_OVER:
    JointLeadingIndex = 0xFFFFFFFF;

    if (Replica->OutLogWorkState == OL_REPLICA_NOPARTNERS) {
        OutLogReleaseLock(Replica);
        return FrsErrorSuccess;
    }


    //
    // Move standby partner entries to the Eligible list.
    //
    ForEachSimpleListEntry(&Replica->OutLogStandBy, OUT_LOG_PARTNER, List,
        // Iterator pE is type *OUT_LOG_PARTNER
        FrsRemoveEntryList(&pE->List);
        pE->State = OLP_ELIGIBLE;
        InsertTailList(&Replica->OutLogEligible, &pE->List);
    );

    //
    // Find the Joint Leading Index for the current group of Eligible partners.
    //
    ForEachSimpleListEntry(&Replica->OutLogEligible, OUT_LOG_PARTNER, List,
        // Iterator pE is type *OUT_LOG_PARTNER

        //
        // A zero in COLx could mean any of the following:
        // 1. This is the first time the partner has ever joined
        // 2. A previous VV Join was interrupted
        // 3. Change order's destined for cxtion were trimmed from the log.
        // 4. The last join time on this connection does not match
        //    (implies DB inconsistency)
        // so do a VVJoin.
        //
        if  (pE->COLx == 0) {
            FStatus = OutLogPartnerVVJoinStart(ThreadCtx, Replica, pE);

            if (!FRS_SUCCESS(FStatus)) {
                DPRINT_FS(0, "Error return from OutLogPartnerVVJoinStart:", FStatus);
                FrsRemoveEntryList(&pE->List);
                InsertTailList(&Replica->OutLogActive, &pE->List);
                FRS_PRINT_TYPE(0, pE);
                continue;
            }
        }

        if (pE->COLx < JointLeadingIndex) {
            JointLeadingIndex = pE->COLx;
        }
    );


    DPRINT1(4, "JointLeadingIndex = 0x%x\n", JointLeadingIndex);
    if (IsListEmpty(&Replica->OutLogEligible)) {
        DPRINT(4, "OutLogEligible list is empty\n");
    }

    //
    // Send change orders to the partners on the eligible list.
    //
    MoreCo = TRUE;
    while (!IsListEmpty(&Replica->OutLogEligible) && !FrsIsShuttingDown) {

        FStatus = OutLogReadCo(ThreadCtx, Replica, JointLeadingIndex);

        if (FStatus == FrsErrorRecordLocked) {
            //
            // We hit the end of the log.  That's it for now.   Change the
            // Replica state to waiting if nothing appeared on the standby list.
            //
            MoreCo = FALSE;
            break;
        } else

        if (FStatus == FrsErrorNotFound) {
            //
            // Deleted log record.  Update ack vector and leading index
            // for each eligible partner and go to the next record.
            // The change order has already been sent and cleaned up.
            //
            OutLogSkipCo(Replica, JointLeadingIndex);

        } else

        if (FRS_SUCCESS(FStatus)){
            //
            // Process the change order.
            // Clear IFLAG bits we don't want to send to outbound partner.
            // Save the Ack sequence number in the CO command so the outbound
            // partner can return it to us.  It's in CO command record so it
            // lives across CO retries in the outbound partner.
            //
            CoCmd = (PCHANGE_ORDER_COMMAND) Replica->OutLogTableCtx->pDataRecord;
            ClearFlag(CoCmd->IFlags, CO_IFLAG_GROUP_OL_CLEAR);
            CoCmd->PartnerAckSeqNumber = CoCmd->SequenceNumber;

            //
            // Send the change order to each Eligible partner.
            //
            Entry = GetListHead(&Replica->OutLogEligible);

            while( Entry != &Replica->OutLogEligible) {
                Partner = CONTAINING_RECORD(Entry, OUT_LOG_PARTNER, List);
                Entry = GetListNext(Entry);

                if(OutLogSendCo(ThreadCtx,
                                Replica,
                                Partner,
                                CoCmd,
                                JointLeadingIndex)) {
                    LoopCheck += 1;
                    FRS_ASSERT(LoopCheck < 1000);
                    goto START_OVER;
                }
            }
        } else {

            //
            // When outlog triming is added see if the jet read is getting
            // JET_errNoCurrentRecord (which otherwise is mapped to FrsErrorInternalError
            //
            DPRINT_FS(0, "ERROR - Unexpected return from OutLogReadCo.", FStatus);
            MoreCo = FALSE;
            break;
        }


        JointLeadingIndex += 1;
    }   // while loop over change orders.

    //
    // Check the Eligible or Standby lists for more work.
    //
    if (IsListEmpty(&Replica->OutLogStandBy) &&
        (!MoreCo || IsListEmpty(&Replica->OutLogEligible)) ) {
        FStatus = FrsErrorSuccess;
        SET_OUTLOG_REPLICA_STATE(Replica, OL_REPLICA_WAITING);
    } else {
        FStatus = FrsErrorMoreWork;
    }


    OutLogReleaseLock(Replica);
    return FStatus;
}

BOOL
OutLogSendCo(
    PTHREAD_CTX           ThreadCtx,
    PREPLICA              Replica,
    POUT_LOG_PARTNER      Partner,
    PCHANGE_ORDER_COMMAND CoCmd,
    ULONG                 JointLeadingIndex
)
/*++
Routine Description:

    Send the change order to the specified outbound partner.

    Assumes caller has the OutLog lock.

Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.
    Replica -- The replica set struct for the outbound log.
    Partner -- ptr to outbound partner context
    CoCmd  -- Change order to send
    JointLeadingIndex -- Sequence number of OutLog CO being sent.

Return Value:

    TRUE - State change requires caller to reevaluate JointLeadingIndex.
    FALSE - Request processed normally

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogSendCo:"

    ULONG      FStatus;
    BOOL       CoDampened, SendIt;
    BOOL       AdjustCOLx;
    PCXTION    Cxtion;
    BOOL       ReevaluateJLx = FALSE;
    PCHAR      SendTag       = "NotSent";
    ULONG      jerr;
    TABLE_CTX  TempTableCtx;
    PTABLE_CTX TableCtx      = &TempTableCtx;


    //
    // If the Ack Vector has wrapped such that we are still waiting
    // for an Ack from the change order in the next slot then we
    // have to stall until the Ack comes in.  This can happen if
    // the CO is fetching a large file or we run into a slug of
    // dampened COs which we quickly run thru.
    //
    if (AVWrapped(Partner)) {
        SET_OUTLOG_PARTNER_AVWRAP(Replica, Partner);
        FRS_PRINT_TYPE(1, Partner);
        CHANGE_ORDER_TRACE2_OLOG(3, CoCmd, "AVWrap ", Replica, Partner->Cxtion);
        //
        // Force a rejoin if the ack vector remains wrapped and there
        // is no network activity from this cxtion's partner. The
        // unacked cos will be resent when the cxtion is rejoined.
        //
        Cxtion = Partner->Cxtion;
        if (Cxtion &&
            CxtionStateIs(Cxtion, CxtionStateJoined)) {
            RcsSubmitReplicaCxtion(Replica, Cxtion, CMD_HUNG_CXTION);
        }
        return ReevaluateJLx;
    }

    //
    // If we have already sent this CO to the partner then move on
    // to the next partner in the list.
    //
    if (JointLeadingIndex < Partner->COLx) {
        CHANGE_ORDER_TRACE2_OLOG(5, CoCmd, "Skip JLx<COLx ", Replica, Partner->Cxtion);
        return ReevaluateJLx;
    }

    FRS_ASSERT(JointLeadingIndex == Partner->COLx);

    //
    // Send out the CO.  The Ack Vector bit could be set if this is
    // a reactivation of the partner or the partner has recently left
    // VVJoin mode.  Don't send the CO again.
    // The CO could also be dampened later based on the version vector.
    //
    CoDampened = SendIt = FALSE;

    if (ReadAVBit(Partner->COLx, Partner) == 1) {
        //
        // The AckVector bit was one.  Clear it and don't send CO.
        //
        ClearAVBit(Partner->COLx, Partner);
        SendTag = "Skip AV=1";
        goto SEND;
    }


    //
    // If this connection is in VVJoin Mode then only send it
    // directed change orders.  Otherwise send out all COs.
    //
    if (!BooleanFlagOn(CoCmd->Flags, CO_FLAG_DIRECTED_CO)) {
        //
        // This is a normal CO.
        // If destination partner is in VVJoin Mode then don't send.
        //
        if (InVVJoinMode(Partner)) {
            DPRINT3(4, "%-11ws (%08x %08x): Partner in VVJoin Mode, hold normal COs - "
                    "Cxtion: %ws\\%ws\\%ws to %ws\\%ws.\n",
                    CoCmd->FileName, PRINTQUAD(CoCmd->FrsVsn),
                    PRINT_CXTION_PATH(Replica, Partner->Cxtion));
            SendTag = "Skip INVVJoin";
        } else {

            if (InReplayMode(Partner) && VVHasVsn(Partner->Cxtion->VVector, CoCmd)) {
                //
                // If we are in the replay range of a completed VVJoin then mark
                // this CO as out of order if it is going to be dampened by the
                // VV on the cxtion.
                // If while we are scanning through the idtable to build tables
                // for vvjoin 2 COs come in the system. The one with lower VSN
                // updates/creates a entry in the idtable before our current scan point
                // and the other CO with higher VSN updates/creates entry at a point
                // ahead of the current scan point. We will send the CO for the higher
                // VSN which will update the VV for that connection as part of vvjoin.
                // Later when we do out replay we will dampen the CO with the lower VSN
                // which has never been sent to the downstream partner.
                //
                SetFlag(CoCmd->Flags, CO_FLAG_OUT_OF_ORDER);
            }

            SendIt = TRUE;
        }
        goto SEND;
    }

    //
    // This is a directed CO.
    // If it is not for this connection then don't send it.
    //
    if (!GUIDS_EQUAL(Partner->Cxtion->Name->Guid, &CoCmd->CxtionGuid)) {
        DPRINT3(4, "%-11ws (%08x %08x): Not sending directed CO to "
                "Cxtion: %ws\\%ws\\%ws to %ws\\%ws.\n",
                CoCmd->FileName, PRINTQUAD(CoCmd->FrsVsn),
                PRINT_CXTION_PATH(Replica, Partner->Cxtion));
        SendTag = "Skip DirCO";
        goto SEND;
    }

    //
    // This is a directed CO for this connection.  If we are in the
    // replay range of a completed VVJoin then don't send it again.
    // NOTE: This only works if no directed COs are sent to this
    // outbound partner other than VVJoin COs while in VVJoin Mode.
    // This is currently true.  Refresh change order requests don't
    // go through the outbound log.
    //
    if (Partner->COLx < Partner->COLxVVJoinDone) {
        // This CO was already sent.
        SendTag = "Skip COLx<VVJoinDone";
        goto SEND;
    }

    //
    // Send it but check if it is a control change order first.
    //
    SendIt = TRUE;
    DPRINT3(4, "%-11ws (%08x %08x): Sending directed CO to Cxtion: %ws\\%ws\\%ws to %ws\\%ws.\n",
            CoCmd->FileName, PRINTQUAD(CoCmd->FrsVsn),
            PRINT_CXTION_PATH(Replica, Partner->Cxtion));

    if (BooleanFlagOn(CoCmd->Flags, CO_FLAG_CONTROL)) {
        //
        // Currently don't prop control change orders.
        //
        SendIt = FALSE;

        //
        // Check for a control CO that is terminating a VVJoin on this connection.
        //
        if ((CoCmd->ContentCmd == FCN_CO_NORMAL_VVJOIN_TERM) ||
            (CoCmd->ContentCmd == FCN_CO_ABNORMAL_VVJOIN_TERM)) {

            //
            // If this is a normal termination and we are currently in replay mode
            // then come out of the replay mode.
            //
            if (InReplayMode(Partner) && (CoCmd->ContentCmd == FCN_CO_NORMAL_VVJOIN_TERM)) {
                ClearFlag(Partner->Flags, OLP_FLAGS_REPLAY_MODE);

                //
                // Open the connection table and update the partner state.
                //
                TableCtx->TableType = TABLE_TYPE_INVALID;
                TableCtx->Tid = JET_tableidNil;

                jerr = DbsOpenTable(ThreadCtx, TableCtx, Replica->ReplicaNumber, CXTIONTablex, NULL);
                if (!JET_SUCCESS(jerr)) {
                    DPRINT1_JS(0, "DbsOpenTable (cxtion) on replica number %d failed.",
                                Replica->ReplicaNumber, jerr);
                }

                OutLogSaveSinglePartnerState(ThreadCtx, Replica, TableCtx, Partner);

                DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
                DbsFreeTableCtx(TableCtx, 1);

                FRS_PRINT_TYPE(4, Partner);

                DPRINT1(4, "Replay mode completed: %ws\\%ws\\%ws -> %ws\\%ws\n",
                        PRINT_CXTION_PATH(Replica, Partner->Cxtion));
                goto SEND;
            }

            if (!InVVJoinMode(Partner)) {
                DPRINT1(4, "Not in vvjoin mode: %ws\\%ws\\%ws -> %ws\\%ws\n",
                        PRINT_CXTION_PATH(Replica, Partner->Cxtion));
                goto SEND;
            }
            //
            // Losing track of the outstanding cos can result in lost change
            // orders for a trigger cxtion.  So wait for the outstanding change
            // orders to finish.
            //
            if (Partner->OutstandingCos) {
                //
                // Pretend it is at quota to reuse an existing codepath
                //
                DPRINT2(4, "WARN - Waiting for %d Cos at vvjoindone: %ws\\%ws\\%ws -> %ws\\%ws\n",
                        Partner->OutstandingCos, PRINT_CXTION_PATH(Replica, Partner->Cxtion));
                SET_OUTLOG_PARTNER_AT_QUOTA(Replica, Partner);
                return ReevaluateJLx;
            }

            FStatus = OutLogPartnerVVJoinDone(ThreadCtx, Replica, Partner);
            if (!FRS_SUCCESS(FStatus)) {
                DPRINT_FS(0, "Error return from OutLogPartnerVVJoinDone:", FStatus);
                FrsRemoveEntryList(&Partner->List);
                InsertTailList(&Replica->OutLogActive, &Partner->List);
                FRS_PRINT_TYPE(0, Partner);
                return ReevaluateJLx;
            }

            //
            // If termination was abnormal then start it up again.
            //
            if (CoCmd->ContentCmd == FCN_CO_ABNORMAL_VVJOIN_TERM) {
                FStatus = OutLogPartnerVVJoinStart(ThreadCtx, Replica, Partner);
                if (!FRS_SUCCESS(FStatus)) {
                    DPRINT_FS(0, "Error return from OutLogPartnerVVJoinStart:", FStatus);
                    FrsRemoveEntryList(&Partner->List);
                    InsertTailList(&Replica->OutLogActive, &Partner->List);
                    FRS_PRINT_TYPE(0, Partner);
                    return ReevaluateJLx;
                }
            }

            //
            // Leading index was changed for connection reevaluate JointLeadingIndex.
            //
            ReevaluateJLx = TRUE;
            return ReevaluateJLx;
        }

        if (CoCmd->ContentCmd == FCN_CO_END_OF_JOIN) {
            if (Partner->Cxtion->PartnerMinor < NtFrsCommMinor) {
                DPRINT3(4, "WARN - Downrev partner (%d < %d): %ws\\%ws\\%ws -> %ws\\%ws\n",
                        Partner->Cxtion->PartnerMinor, NtFrsCommMinor,
                        PRINT_CXTION_PATH(Replica, Partner->Cxtion));

            //
            // This control co is for this join and the join is still valid
            //
            } else
            if (CoCmd->EventTime.QuadPart == (LONGLONG)Partner->Cxtion->LastJoinTime &&
                CxtionStateIs(Partner->Cxtion, CxtionStateJoined)) {

                if (Partner->OutstandingCos > 0) {
                    //
                    // Pretend it is at quota to reuse an existing codepath
                    //
                    DPRINT2(4, "WARN - Waiting for %d Cos at end of join: %ws\\%ws\\%ws -> %ws\\%ws\n",
                            Partner->OutstandingCos, PRINT_CXTION_PATH(Replica, Partner->Cxtion));

                    SET_OUTLOG_PARTNER_AT_QUOTA(Replica, Partner);
                    return ReevaluateJLx;
                } else {

                    DPRINT1(4, "Unjoining at end of join: %ws\\%ws\\%ws -> %ws\\%ws\n",
                            PRINT_CXTION_PATH(Replica, Partner->Cxtion));
                    //
                    // Stop sending change orders and unjoin the cxtion
                    //
                    SET_OUTLOG_PARTNER_UNJOINED(Replica, Partner);
                    RcsSubmitReplicaCxtion(Replica, Partner->Cxtion, CMD_UNJOIN);
                }
            } else {
                DPRINT1(4, "Ignoring; end-of-join guid invalid: %ws\\%ws\\%ws -> %ws\\%ws\n",
                        PRINT_CXTION_PATH(Replica, Partner->Cxtion));
            }
        } else {
            DPRINT2(0, "WARN - Ignoring bad control code %d: %ws\\%ws\\%ws -> %ws\\%ws\n",
                    CoCmd->ContentCmd, PRINT_CXTION_PATH(Replica, Partner->Cxtion));
        }
    }



SEND:
    //
    // Send the CO if enabled.  If it was dampened then set the Ack flag here.
    //
    AdjustCOLx = TRUE;
    if (SendIt) {

        //
        // If this connection is being restarted and the leading
        // index is less than the Restart leading index then mark
        // the CO out of order so it can get past VV dampening checks.
        // We don't know what may have been sent and acked ahead of
        // this point.
        //
        if (Partner->COLx < Partner->COLxRestart) {
            SetFlag(CoCmd->Flags, CO_FLAG_OUT_OF_ORDER);
        }

        //
        // Finally check to see if there is a more recent change order for
        // this file in the OutLogDominantFileTable for this Replica Set.
        //
        SendIt = OutLogOptimize(Replica, Partner, CoCmd, &SendTag);
        if (!SendIt) {
            goto SEND;
        }

        //
        // Increment the Local OR Remote CO Sent counters for both the
        // replica set and the connection.
        //
        if (COC_FLAG_ON(CoCmd, CO_FLAG_LOCALCO)) {
            //
            // Its a Local CO
            //
            PM_INC_CTR_REPSET(Replica, LCOSent, 1);
            PM_INC_CTR_CXTION(Partner->Cxtion, LCOSent, 1);
        }
        else if (!COC_FLAG_ON(CoCmd, CO_FLAG_CONTROL)) {
            //
            // Its a Remote CO
            //
            PM_INC_CTR_REPSET(Replica, RCOSent, 1);
            PM_INC_CTR_CXTION(Partner->Cxtion, RCOSent, 1);
        }

        //
        // Set the Ack Vector Version number into the change order for match
        // up later when the Ack comes in.
        //
        CoCmd->AckVersion = Partner->AckVersion;

        CoDampened = !RcsSendCoToOneOutbound(Replica, Partner->Cxtion, CoCmd);
        if (CoDampened) {
            SendTag = "VVDampened";
            //
            // Increment the OutBound CO dampned counter for both the
            // replica set and the connection.
            //
            PM_INC_CTR_REPSET(Replica, OutCODampned, 1);
            PM_INC_CTR_CXTION(Partner->Cxtion, OutCODampned, 1);

        }
    } else {
        CHANGE_ORDER_TRACE2_OLOG(3, CoCmd, SendTag, Replica, Partner->Cxtion);
        SendTag = NULL;
    }

    if (CoDampened || !SendIt) {
        //
        // CO was dampened.  Set the Ack flag in the ack vector and
        // advance the trailing index for this partner.  The bits
        // behind the trailing index are cleared.
        //
        AdjustCOLx = OutLogMarkAckVector(Replica, Partner->COLx, Partner);
    } else {
        //
        // It was sent.  If the partner has hit its quota of outstanding
        // COs remove it move it from the Eligible list to the Active List.
        // Have the caller reevaluate the joint leading index so it can jump
        // ahead to the next CO to send.
        //
        Partner->OutstandingCos += 1;
        if (Partner->OutstandingCos >= Partner->OutstandingQuota) {
            SET_OUTLOG_PARTNER_AT_QUOTA(Replica, Partner);
            ReevaluateJLx = TRUE;
        }

        SendTag = "Send";

    }

    if (SendTag != NULL) {
        CHANGE_ORDER_TRACE2_OLOG(3, CoCmd, SendTag, Replica, Partner->Cxtion);
    }

    if (AdjustCOLx) {
        Partner->COLx += 1;
    }

    //
    // Save the max Outlog progress point for error checks.
    //
    if (Partner->COLx > Replica->OutLogCOMax) {
        Replica->OutLogCOMax = Partner->COLx;
    }

    OUT_LOG_DUMP_PARTNER_STATE(4, Partner, Partner->COLx-1,
                               (CoDampened || !SendIt ? "dampened" : "send"));

    return ReevaluateJLx;
}


BOOL
OutLogOptimize(
    IN PREPLICA              Replica,
    IN POUT_LOG_PARTNER      Partner,
    IN PCHANGE_ORDER_COMMAND CoCmd,
    OUT PCHAR                *SendTag
)
/*++
Routine Description:

    Finally check to see if there is a more recent change order for
    this file in the OutLogDominantFileTable and that this CO is not
    already in our MustSend Table for this connection.

    Assumes caller has the OutLog lock.

Arguments:
    Replica -- The replica set struct for the outbound log.
    Partner -- ptr to outbound partner context
    CoCmd  -- Change order to send
    SendTag -- return a ptr to a tag string for logging.

Return Value:
    TRUE - This CO must be sent out.
    FALSE - This CO can be skipped.

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogOptimize:"

    ULONGLONG             DeltaTime;
    PQHASH_ENTRY          QHashEntry;
    PDOMINANT_FILE_ENTRY  MustSendEntry, DomFileEntry;

    //
    // If not a valid candidate for skipping then send it.
    //
    // TODO: If the CO in the dominant file table is a delete then we should
    //       favor it and suppress a create CO.  This will evaporate a
    //       create - delete sequence.
    //
    if ((Replica->OutLogRepeatInterval == 0) ||
        !OutLogFavorDominantFile(CoCmd)) {
        goto SEND_IT;
    }

    QHashAcquireLock(Partner->MustSendTable);

    QHashEntry = QHashLookupLock(Partner->MustSendTable, &CoCmd->FileGuid);
    if (QHashEntry != NULL) {
        //
        // Found a match check if this is our MustSend CO.
        //
        DPRINT1(4, "OPT: hit in MustSend Table for COx 0x%x\n", CoCmd->SequenceNumber);
        MustSendEntry = (PDOMINANT_FILE_ENTRY) (QHashEntry->Flags);
        if (MustSendEntry->OLSeqNum > CoCmd->SequenceNumber) {
            //
            // Not yet.
            //
            QHashReleaseLock(Partner->MustSendTable);
            *SendTag = "Skip, Not Dominant";
            goto DO_NOT_SEND;
        }

        if (MustSendEntry->TimeSent > 0) {
            //
            // We have sent a CO for this File in the past.
            // Do not send another for at least RepeatInterval seconds if
            // there is a more recent CO in the DominantFileTable.
            //
            GetSystemTimeAsFileTime((PFILETIME)&DeltaTime);
            DeltaTime -= MustSendEntry->TimeSent;
            DeltaTime /= (ULONGLONG)(10 * 1000 * 1000);
            if (DeltaTime < Replica->OutLogRepeatInterval) {
                //
                // We sent one less than RepeatInterval seconds ago.  Don't
                // send this one if we have a later one in the Dominant
                // File Table.
                //
                QHashAcquireLock(Replica->OutLogDominantTable);
                QHashEntry = QHashLookupLock(Replica->OutLogDominantTable,
                                             &CoCmd->FileGuid);
                if (QHashEntry != NULL) {
                    DomFileEntry = (PDOMINANT_FILE_ENTRY) (QHashEntry->Flags);
                    if (DomFileEntry->OLSeqNum > CoCmd->SequenceNumber){
                        //
                        // There is a later one so skip this one.  But don't
                        // update the MustSendEntry since the later one may
                        // be a long distance back in the queue and we may hit
                        // another CO for this file in the mean time but after
                        // the RepeatInterval has been exceeded.
                        //
                        *SendTag = "Skip, To soon to send";
                        QHashReleaseLock(Replica->OutLogDominantTable);
                        QHashReleaseLock(Partner->MustSendTable);
                        goto DO_NOT_SEND;
                    }
                }
                QHashReleaseLock(Replica->OutLogDominantTable);
            }
        }
        //
        // No dominant CO found.  Send this one.
        //
        MustSendEntry->OLSeqNum = CoCmd->SequenceNumber;
        GetSystemTimeAsFileTime((PFILETIME)&MustSendEntry->TimeSent);

        QHashReleaseLock(Partner->MustSendTable);
        goto SEND_IT;
    }

    //
    // No entry in MustSendTable for this connection.
    // Check for an entry in the OutLog Dominant File Table.
    //
    DPRINT1(4, "OPT: miss in MustSend Table for COx 0x%x\n", CoCmd->SequenceNumber);
    QHashAcquireLock(Replica->OutLogDominantTable);
    QHashEntry = QHashLookupLock(Replica->OutLogDominantTable, &CoCmd->FileGuid);
    if (QHashEntry != NULL) {
        DomFileEntry = (PDOMINANT_FILE_ENTRY) (QHashEntry->Flags);

        //if (DomFileEntry->OLSeqNum >= CoCmd->SequenceNumber) {
            //
            // This CO can be skipped, but make entry in the MustSend table
            // so we have the time sent for future checks.
            //
            MustSendEntry = FrsAlloc(sizeof(DOMINANT_FILE_ENTRY));
            if (MustSendEntry != NULL) {
                memcpy(MustSendEntry, DomFileEntry, sizeof(DOMINANT_FILE_ENTRY));
                MustSendEntry->Flags = 0;
                MustSendEntry->TimeSent = 0;

                QHashEntry = QHashInsertLock(Partner->MustSendTable,
                                             &CoCmd->FileGuid,
                                             NULL,
                                             (ULONG_PTR) MustSendEntry);
                if (QHashEntry != NULL) {
                    DPRINT1(4, "OPT: new entry made in MustSend Table for COx 0x%x\n",
                            CoCmd->SequenceNumber);
                    if (DomFileEntry->OLSeqNum != CoCmd->SequenceNumber){
                        //
                        // We can skip it since there is a later one.
                        // Still made the entry above so we have the
                        // TimeSent for future checks.
                        //
                        QHashReleaseLock(Replica->OutLogDominantTable);
                        QHashReleaseLock(Partner->MustSendTable);
                        *SendTag = "Skip, New Dominant";
                        goto DO_NOT_SEND;
                    } else {
                        GetSystemTimeAsFileTime((PFILETIME)&MustSendEntry->TimeSent);
                    }
                } else {
                    DPRINT(4, "++ WARN - Failed to insert entry into Partner MustSendTable\n");
                    FrsFree(MustSendEntry);
                }
            }
        //}
    } else {
        DPRINT1(4, "OPT: miss in Dom Table for COx 0x%x\n", CoCmd->SequenceNumber);
    }

    QHashReleaseLock(Replica->OutLogDominantTable);
    QHashReleaseLock(Partner->MustSendTable);

SEND_IT:

    return TRUE;

DO_NOT_SEND:

    PM_INC_CTR_REPSET(Replica, OutCODampned, 1);
    PM_INC_CTR_CXTION(Partner->Cxtion, OutCODampned, 1);
    return FALSE;
}

VOID
OutLogSkipCo(
    PREPLICA              Replica,
    ULONG                 JointLeadingIndex
)
/*++
Routine Description:

    The change order at this index has been deleted so skip over it
    for all eligible outbound partners.

    Assumes caller has the OutLog lock.

Arguments:

    Replica -- The replica set struct for the outbound log.
    JointLeadingIndex -- Sequence number of OutLog CO being skiped.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogSkipCo:"

    ULONG FStatus;
    PLIST_ENTRY Entry;
    POUT_LOG_PARTNER Partner;
    BOOL AdjustCOLx;


    //
    // Skip over the CO for each Eligible partner.
    //
    Entry = GetListHead(&Replica->OutLogEligible);

    while( Entry != &Replica->OutLogEligible) {
        Partner = CONTAINING_RECORD(Entry, OUT_LOG_PARTNER, List);
        Entry = GetListNext(Entry);

        //
        // If the Ack Vector has wrapped such that we are still waiting
        // for an Ack from the change order in the next slot then we
        // have to stall until the Ack comes in.  This can happen if
        // the CO is fetching a large file or we run into a slug of
        // dampened COs which we quickly run thru.
        //
        // Note: can not wait forever.  need to force a rejoin at some
        // point. Integrate this with outlog trimming since both will
        // force a VVJoin.
        //
        if (AVWrapped(Partner)) {
            SET_OUTLOG_PARTNER_AVWRAP(Replica, Partner);
            FRS_PRINT_TYPE(1, Partner);
            continue;
        }

        //
        // If we have already sent this CO to the partner then move on
        // to the next partner in the list.
        //
        if (JointLeadingIndex < Partner->COLx) {
            continue;
        }

        FRS_ASSERT(JointLeadingIndex == Partner->COLx);

        //
        // The Ack Vector bit could be set if this is
        // a reactivation of the partner or the partner has recently left
        // VVJoin mode.
        //

        if (ReadAVBit(Partner->COLx, Partner) == 1) {
            //
            // The AckVector bit was one, clear it.
            //
            ClearAVBit(Partner->COLx, Partner);
        }

        //
        // CO was skipped.  Set the Ack flag in the ack vector and
        // advance the trailing index for this partner.  The bits
        // behind the trailing index are cleared.
        //
        AdjustCOLx = OutLogMarkAckVector(Replica, Partner->COLx, Partner);

        if (AdjustCOLx) {
            Partner->COLx += 1;
        }

        //
        // Save the max Outlog progress point for error checks.
        //
        if (Partner->COLx > Replica->OutLogCOMax) {
            Replica->OutLogCOMax = Partner->COLx;
        }

        //OUT_LOG_DUMP_PARTNER_STATE(4, Partner, Partner->COLx-1, "Co Deleted");

    }  // while on eligible list

    return;
}



ULONG
OutLogCommitPartnerState(
    IN PTHREAD_CTX ThreadCtx,
    IN PTABLE_CTX TableCtx,
    IN PREPLICA Replica,
    IN PCXTION Cxtion
)
/*++
Routine Description:

    Update the database with the current state for the specified partner.

Arguments:

    ThreadCtx
    TableCtx
    Replica -- The replica set struct for the outbound log.
    Cxtion -- The Outbound Partner that is Acking the change order.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogCommitPartnerState:"

    return OutLogUpdatePartner(ThreadCtx, TableCtx, Replica, Cxtion);
}




ULONG
OutLogReadCo(
    PTHREAD_CTX          ThreadCtx,
    PREPLICA             Replica,
    ULONG                Index
)
/*++
Routine Description:

    Read the change order specified by the Index from the Outbound Log for
    the Replica.  The data is returned in the Replica->OutLogTableCtx struct.

Arguments:

    ThreadCtx  -- A Thread context to use for dbid and sesid.
    Replica -- The replica set struct for the outbound log.
    Index -- The Index / Sequence Number to use to select the change order.

Return Value:

    Frs Status

--*/
{

#undef DEBSUB
#define DEBSUB  "OutLogReadCo:"

    ULONG                FStatus;
    PTABLE_CTX           TableCtx = Replica->OutLogTableCtx;
    ULONGLONG            Data;

    FRS_ASSERT(IS_OUTLOG_TABLE(TableCtx));

    // Note: Consider a record cache to reduce calls to Jet.

    QHashAcquireLock(Replica->OutLogRecordLock);

    //
    // First check if the outlog record is currently being written or we are
    // at the end of the log.
    //
    Data = Index;

    if ((Index != 0) &&
        ((Index >= Replica->OutLogSeqNumber) ||
         (QHashLookupLock(Replica->OutLogRecordLock, &Data) != NULL))) {
        DPRINT3(3, "OutLog Record lock on Index %08x %08x (Index %08x, Replica %08x)\n",
                PRINTQUAD(Data), Index, Replica->OutLogSeqNumber);
        QHashReleaseLock(Replica->OutLogRecordLock);
        return FrsErrorRecordLocked;
    }

    QHashReleaseLock(Replica->OutLogRecordLock);

    //
    // Open the outbound log table for the replica set and read the requested
    // record identified by the sequence number.
    //
    FStatus = DbsReadTableRecordByIndex(ThreadCtx,
                                        Replica,
                                        TableCtx,
                                        &Index,
                                        OLSequenceNumberIndexx,
                                        OUTLOGTablex);

    if (!FRS_SUCCESS(FStatus)) {

        if (FStatus == FrsErrorNotFound) {
            //
            // No record at this sequence number, probably deleted.
            //
            DPRINT1(4, "Record 0x%x deleted\n", Index);
        }
        return FStatus;
    }

    //DUMP_TABLE_CTX(OutLogTableCtx);
    DBS_DISPLAY_RECORD_SEV(4, TableCtx, TRUE);

    return FrsErrorSuccess;
}


ULONG
OutLogDeleteCo(
    PTHREAD_CTX ThreadCtx,
    PREPLICA    Replica,
    ULONG       Index
)
/*++
Routine Description:

    Delete the change order specified by the Index from the Outbound Log for
    the Replica.  This uses the common Replica->OutLogTableCtx so it must
    be called by the thread that is doing work for this Replica.

    NOTE - THIS IS ONLY OK IF WE KNOW WHICH THREAD IS WORKING ON THE REPLICA
           OR THERE IS ONLY ONE OUTBOUND LOG PROCESS THREAD.

Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.
    Replica -- The replica set struct for the outbound log.
    Index -- The Index / Sequence Number to use to select the change order.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogDeleteCo:"

    return  DbsDeleteTableRecordByIndex(ThreadCtx,
                                        Replica,
                                        Replica->OutLogTableCtx,
                                        &Index,
                                        OLSequenceNumberIndexx,
                                        OUTLOGTablex);

}




ULONG
OutLogInsertCo(
    PTHREAD_CTX         ThreadCtx,
    PREPLICA            Replica,
    PTABLE_CTX          OutLogTableCtx,
    PCHANGE_ORDER_ENTRY ChangeOrder
)
/*++
Routine Description:

    Insert the change order into the outbound log.  This call should only be
    made after the Inbound change order has been completed and the IDTable
    state is updated.  After this call succeeds the caller should then
    delete the record from the Inbound Log.

    Note - This is where the sequence number for the record is assigned.

    Note - This is called by ChgOrdIssueCleanup() in a database thread.

Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.
    Replica -- The replica set struct for the outbound log.
    OutLogTableCtx -- The table context to use for outbound log table access.
    ChangeOrder -- The new change order to check ordering conflicts.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogInsertCo:"

    ULONGLONG             Data;
    JET_ERR               jerr;
    ULONG                 FStatus = FrsErrorSuccess;
    ULONG                 GStatus;
    PCHANGE_ORDER_COMMAND CoCmd = &ChangeOrder->Cmd;
    ULONG                 SequenceNumberSave;
    PDOMINANT_FILE_ENTRY  DomFileEntry;
    PQHASH_ENTRY          QHashEntry;
    CHAR                  GuidStr[GUID_CHAR_LEN];

    //
    // Insert the change order into the outbound log.  Log Cleanup will delete
    // the staging file after it has been sent to all the partners.
    //
    // ** Note ** - The Replica Outlog Sequence number is at the max of all
    // partner leading indexs and the record in the log with the largest
    // sequence number+1.  The interlocked increment is done first to get
    // the next sequence number and then one is subtracted from the result.
    //
    // ** Note ** This change order command is an inbound change order so for
    // consistency and correctness in subsequent operations we save and restore
    // the Sequence Number around this call.  The alternative is to make a copy
    // of the data record first.
    //
    SequenceNumberSave = CoCmd->SequenceNumber;

    //
    // Save the replica ptrs by converting them to local replica ID numbers
    // for storing the record in the database.
    //
    CoCmd->OriginalReplicaNum = ReplicaAddrToId(ChangeOrder->OriginalReplica);
    CoCmd->NewReplicaNum      = ReplicaAddrToId(ChangeOrder->NewReplica);

    //
    // Get the Outlog record lock and add this sequence number to it.
    // This is needed so the outlog process can tell if it hit the end of log
    // if it does a read and gets back record not found.  This lock table
    // allows it to distinguish between a missing outlog change order that
    // will require a VVJoin Scan for the partner from a change order outlog
    // write that hasn't finished yet.
    //
    QHashAcquireLock(Replica->OutLogRecordLock);

    // Perf Note: If we keep the lock table then get rid of the interlocked ops
    CoCmd->SequenceNumber = InterlockedIncrement(&Replica->OutLogSeqNumber) - 1;

    Data = CoCmd->SequenceNumber;
    QHashInsertLock(Replica->OutLogRecordLock, &Data, &Data, 0);

    QHashReleaseLock(Replica->OutLogRecordLock);

    //
    // Open the Outbound log table.
    //
    if (!IS_TABLE_OPEN(OutLogTableCtx)) {
        jerr = DbsOpenTable(ThreadCtx,
                            OutLogTableCtx,
                            Replica->ReplicaNumber,
                            OUTLOGTablex,
                            CoCmd);
        if (!JET_SUCCESS(jerr)) {
            FStatus = DbsTranslateJetError(jerr, TRUE);
            goto RETURN;
        }
    }

    //
    // Update the OutLogDominantTable as necessary.
    //
    Replica->OutLogRepeatInterval = GOutLogRepeatInterval;
    DPRINT1(4, "OPT: Replica OutLogRepeatInterval = %d\n", Replica->OutLogRepeatInterval);
    if ((Replica->OutLogRepeatInterval > 0) &&
         OutLogIsValidDominantFile(CoCmd)) {
        QHashAcquireLock(Replica->OutLogDominantTable);

        DPRINT1(4, "OPT: valid Dom File for COx 0x%x\n", CoCmd->SequenceNumber);

        QHashEntry = QHashLookupLock(Replica->OutLogDominantTable, &CoCmd->FileGuid);
        if (QHashEntry != NULL) {
            //
            // Found a match, bump the count and record latest sequence number.
            //
            DomFileEntry = (PDOMINANT_FILE_ENTRY) (QHashEntry->Flags);
            DPRINT2(4, "OPT: hit in Dom Table for new COx 0x%x, old COx 0x%x\n",
                    CoCmd->SequenceNumber, DomFileEntry->OLSeqNum);
            QHashEntry->QData += 1;
            DomFileEntry->OLSeqNum = CoCmd->SequenceNumber;
            QHashReleaseLock(Replica->OutLogDominantTable);
        } else {
            //
            // Not found in Dominant Table, do the OutLog lookup.
            // Note: The record is not read from the table so we don't know
            // if the CO found actually meets all the requirements for
            // skipping.  That check is made when we actually try to send the
            // CO.  The entries in the OutLogDominantTable do not have to meet
            // the requirements for skipping.  We only want to know that there
            // is a future CO for this File that we will be sending if a previous
            // CO can be skipped.  So a sequence like update a large file followed
            // by a delete of the file will only send the delete.
            //
            QHashReleaseLock(Replica->OutLogDominantTable);
            DPRINT1(4, "OPT: miss in Dom Table for COx 0x%x\n", CoCmd->SequenceNumber);

            jerr = DbsSeekRecord(ThreadCtx,
                                 &CoCmd->FileGuid,
                                 OLFileGuidIndexx,
                                 OutLogTableCtx);
            if (JET_SUCCESS(jerr)) {
                //
                // Found another CO with the same file Guid.  Add an entry to the
                // DominantFileTable.
                //
                GuidToStr(&CoCmd->FileGuid, GuidStr);
                DPRINT3(4, "Found new dominant file entry for replica %ws file: %ws (%s)\n",
                        Replica->ReplicaName->Name, CoCmd->FileName, GuidStr);

                DomFileEntry = FrsAlloc(sizeof(DOMINANT_FILE_ENTRY));
                if (DomFileEntry != NULL) {
                    DomFileEntry->Flags = 0;
                    COPY_GUID(&DomFileEntry->FileGuid, &CoCmd->FileGuid);
                    DomFileEntry->OLSeqNum = CoCmd->SequenceNumber;

                    if (DOES_CO_DELETE_FILE_NAME(CoCmd)) {
                        SetFlag(DomFileEntry->Flags, DFT_FLAG_DELETE);
                    }

                    DPRINT1(4, "OPT: Insert new Dom File for COx 0x%x\n", CoCmd->SequenceNumber);
                    GStatus = QHashInsert(Replica->OutLogDominantTable,
                                          &CoCmd->FileGuid,
                                          NULL,
                                          (ULONG_PTR) DomFileEntry,
                                          FALSE);
                    if (GStatus != GHT_STATUS_SUCCESS) {
                        DPRINT2(4, "++ ERROR - Failed to insert entry into Replica OutLogDominant Table for %ws (%s)",
                                CoCmd->FileName, GuidStr);
                    }
                }
            } else {

                DPRINT1_JS(4, "OPT: Seek for Dom File for COx 0x%x failed", CoCmd->SequenceNumber, jerr);
            }
        }
    }

    //
    // Insert the new CO record into the database.
    //
    jerr = DbsInsertTable2(OutLogTableCtx);
    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(1, "error inserting outlog record:", jerr);
        FStatus = DbsTranslateJetError(jerr, TRUE);
        DBS_DISPLAY_RECORD_SEV(5, OutLogTableCtx, FALSE);
        DUMP_TABLE_CTX(OutLogTableCtx);
    }

    DbsCloseTable(jerr, ThreadCtx->JSesid, OutLogTableCtx);
    DPRINT_JS(0,"Error - JetCloseTable failed:", jerr);


RETURN:
    //
    // Release the record lock.
    //
    if (QHashDelete(Replica->OutLogRecordLock, &Data) != GHT_STATUS_SUCCESS) {
        DPRINT(0, "Error deleting outlog lock table entry\n");
        FRS_ASSERT(!"Error deleting outlog lock table entry");
    }

    CoCmd->SequenceNumber = SequenceNumberSave;

    //
    // Don't free the data record when we free the OutLogTableCtx.
    // The data record is part of the change order.
    //
    OutLogTableCtx->pDataRecord = NULL;

    //
    // Clear the Jet Set/Ret Col address fields for the Change Order
    // Extension buffer to prevent reuse since that buffer goes with the CO.
    //
    DBS_SET_FIELD_ADDRESS(OutLogTableCtx, COExtensionx, NULL);

    if (!FRS_SUCCESS(FStatus)) {
        return FStatus;
    }

    //
    // Poke the Outbound log processor.
    //
    OutLogStartProcess(Replica);

    return FrsErrorSuccess;

}



ULONG
OutLogStartProcess(
    PREPLICA Replica
)
/*++
Routine Description:

    If Outbound log processing for this replica is waiting then queue
    the start work command packet to crank it up.

Arguments:

    Replica -- The replica set struct for the outbound log.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogStartProcess:"


    if (FrsIsShuttingDown) {
        return FrsErrorSuccess;
    }

    if (Replica->OutLogWorkState == OL_REPLICA_WAITING) {
        //
        // Get the lock and recheck.
        //
        OutLogAcquireLock(Replica);
        if (Replica->OutLogWorkState == OL_REPLICA_WAITING) {
            SET_OUTLOG_REPLICA_STATE(Replica, OL_REPLICA_WORKING);
            FrsSubmitCommand(Replica->OutLogCmdPkt, FALSE);
        }
        OutLogReleaseLock(Replica);
    }

    return FrsErrorSuccess;
}



ULONG
OutLogSubmitCo(
    PREPLICA Replica,
    PCHANGE_ORDER_ENTRY ChangeOrder
)
/*++
Routine Description:

    Send the change order to the Outbound Log process to insert it into
    the log and send it to the outbound partners.

    Make a check for a pending change order in the outbound log that applies
    to the same file.  If found and not currently active we delete the
    change order and staging file since this change order will send the
    file again.  Even if the change order has been sent but the file has
    not been fetched or a fetch is in progress we should be able to abort
    the fetch with an error response such that the fetching partner will
    abort the change order.  Note that it still is expected to send the
    ACK response indicating the CO is retired.

    Note - If there are no outbound partners defined for this replica set
    this call is a nop.

Arguments:

    Replica -- The replica set struct for the outbound log.

    ChangeOrder -- The new change order to check ordering conflicts.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogSubmitCo:"

    ULONG WStatus;

    return FrsErrorSuccess;
}





ULONG
OutLogRetireCo(
    PREPLICA Replica,
    ULONG COx,
    PCXTION PartnerCxtion
)
/*++
Routine Description:

    The specified outbound partner is Acking the change order. Set the bit in
    the AckVector and advance the trailing change order index.  Add the
    partner back to the eligible list if necc.

Arguments:

    Replica -- The replica set struct for the outbound log.
    COx  -- The sequence number / index of the change order to retire.
    Partner -- The Outbound Partner that is Acking the change order.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogRetireCo:"

    POUT_LOG_PARTNER OutLogPartner = PartnerCxtion->OLCtx;

    OutLogAcquireLock(Replica);

    //
    // Make sure the index of the retiring change order makes sense.
    //
    if (COx > Replica->OutLogCOMax) {
        DPRINT2(0, "WARNING: COx (0x%x) > Replica->OutLogCOMax (0x%x)\n",
               COx, Replica->OutLogCOMax);
    }

    //
    // Check if this is a duplicate Ack.  Could happen if outbound partner has
    // crashed and is restarting.
    //
    if ((COx < OutLogPartner->COTx) ||
       (ReadAVBit(COx, OutLogPartner) != 0))  {
        OutLogReleaseLock(Replica);
        return FrsErrorSuccess;
    }

    //
    // Set the Ack flag in the ack vector and advance the trailing index for
    // this partner.
    //
    OutLogMarkAckVector(Replica, COx, OutLogPartner);

    //
    // Decrement the count of outstanding change orders for this partner.
    // If the partner is at the Quota limit then queue the partner struct to
    // either the Eligible or Standby lists depending on the outbound log
    // processing state of this replica.
    //
    // If we crash and come back up we could still have change orders out
    // that acks are comming back for.  Since we don't know how many
    // we make sure the OutstandingCo count doesn't go below zero.
    //
    if (OutLogPartner->OutstandingCos > 0) {
        OutLogPartner->OutstandingCos -= 1;
    }

    // Perf Note: Add code to test if the COLx is equal to the max change order seq
    // number for this replica so we suppress queueing the the cmd pkt
    // just to discover there is no pending COs for this replica.

    if (OutLogPartner->State == OLP_AT_QUOTA) {

        //
        // Note - if we ever do dynamic adjustment of OutstandingQuotas then
        // this assert must be fixed.
        //
        FRS_ASSERT(OutLogPartner->OutstandingCos < OutLogPartner->OutstandingQuota);

        //
        // Reactivate this partner since it is now below quota.
        //
        OutLogActivatePartner(Replica, PartnerCxtion, TRUE);

    }

    OutLogReleaseLock(Replica);

    return FrsErrorSuccess;
}



BOOL
OutLogMarkAckVector(
    PREPLICA Replica,
    ULONG COx,
    POUT_LOG_PARTNER OutLogPartner
)
/*++
Routine Description:

    The specified outbound partner is Acking the change order. Set the bit in
    the AckVector and advance the trailing change order index.

    Note: The caller must acquire the outbound log lock.

Arguments:

    Replica -- The replica set struct for the outbound log.
    COx  -- The sequence number / index of the change order to retire.
    Partner -- The Outbound Partner that is Acking the change order.

Return Value:

    TRUE if the caller should update COLx if appropriate.
    FALSE if COLx was adjusted here then caller should leave it alone.

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogMarkAckVector:"

    ULONG Slotx, MaxSlotx;
    BOOL CxtionRestarting, CxtionVVJoining;
    BOOL AdjustCOLx = TRUE;

    //
    // Check if COx is outside the range of the Ack Vector.  If it is then
    // ignore it.  This could happen when a partner is out of date and needs
    // to do a VVJoin.  When the VVJoin terminates we restart at the point in
    // the outlog where the VVJoin started.  This could be a long way back and
    // we could get Acks for VVJoin COs sent that are still ahead of us in the
    // Outlog.  It could also happen when the start of a VVJoin advances the
    // outlog index for the connection to the end of the Outlog.  We could still
    // get some Acks dribbling in for old change orders that are now just
    // finishing from this outbound partner.
    //
    if (SeqNumOutsideAVWindow(COx, OutLogPartner)) {
        DPRINT1(4, "Ack sequence number, 0x%x is outside current AV window. Ignored\n",
               COx);

        OUT_LOG_DUMP_PARTNER_STATE(4, OutLogPartner, COx, "Outside AVWindow");
        return TRUE;
    }

    OUT_LOG_DUMP_PARTNER_STATE(4, OutLogPartner, COx, "Retire (Start)");

    //
    // Set the bit in the Ack Vector at the Change order index.
    //
    SetAVBit(COx, OutLogPartner);
    Slotx = AVSlot(COx, OutLogPartner);

    //
    // If this was the trailing change order index then advance it to the
    // slot of the next unacknowledged change order.
    //
    if (Slotx == OutLogPartner->COTslot) {
        MaxSlotx = Slotx + ACK_VECTOR_SIZE;
        while (++Slotx < MaxSlotx) {
            //
            // As the trailing index is advanced clear the bits behind it.
            // Stop when we hit the next 0 bit.
            //
            OutLogPartner->COTx += 1;
            ClearAVBitBySlot(Slotx-1, OutLogPartner);
            //
            // If this connection is restarting then COLx could be left behind
            // COTx if an ACK comes in for a CO that was sent prior to the
            // connection shutdown.  This can only happen until COLx catches
            // back up to COLxRestart.  During this period keep COLx up with COTx.
            //
            if (OutLogPartner->COLx < (OutLogPartner->COTx-1)) {
                CxtionRestarting = OutLogPartner->COLx <= OutLogPartner->COLxRestart;
                CxtionVVJoining = OutLogPartner->COLx <= OutLogPartner->COLxVVJoinDone;
                if (!CxtionRestarting && !CxtionVVJoining) {
                    OUT_LOG_DUMP_PARTNER_STATE(0,
                                               OutLogPartner,
                                               OutLogPartner->COTx, "Bug");
                    FRS_ASSERT(!"COLx < COTx but Cxtion not Restarting or VVJoining");
                }
                OutLogPartner->COLx = OutLogPartner->COTx;
                AdjustCOLx = FALSE;
                OUT_LOG_DUMP_PARTNER_STATE(0,
                                           OutLogPartner,
                                           OutLogPartner->COTx, "Bug2");
            }

            if (ReadAVBitBySlot(Slotx, OutLogPartner) == 0) {
                break;
            }
        }

        OutLogPartner->COTslot = Slotx & (ACK_VECTOR_SIZE-1);
        Replica->OutLogDoCleanup = TRUE;
    }

    OUT_LOG_DUMP_PARTNER_STATE(4,
                               OutLogPartner,
                               OutLogPartner->COTx,
                               "Retire (end)");

    return AdjustCOLx;
}



ULONG
OutLogSaveSinglePartnerState(
    IN PTHREAD_CTX        ThreadCtx,
    IN PREPLICA           Replica,
    IN PTABLE_CTX         TableCtx,
    IN POUT_LOG_PARTNER   OutLogPartner
)
/*++
Routine Description:

    Save the state of a single outbound partner in the database.

Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.
    Replica -- The replica set struct for the outbound log.
    TableCtx -- ptr to the OutLogTable ctx.
    OutLogPartner -- ptr to struct with current partner state.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogSaveSinglePartnerState:"

    JET_ERR            jerr, jerr1;
    ULONG              FStatus;

    PCXTION_RECORD     CxtionRecord = TableCtx->pDataRecord;
    GUID               *CxtionGuid;


    CxtionRecord->Flags = OutLogPartner->Flags;
    CxtionRecord->COLx = OutLogPartner->COLx;
    CxtionRecord->COTx = OutLogPartner->COTx;
    CxtionRecord->COTxNormalModeSave = OutLogPartner->COTxNormalModeSave;
    CxtionRecord->COTslot = OutLogPartner->COTslot;
    CopyMemory(CxtionRecord->AckVector, OutLogPartner->AckVector, ACK_VECTOR_BYTES);

    //
    // Seek to the record using the connection GUID.
    //
    CxtionGuid = OutLogPartner->Cxtion->Name->Guid;

    jerr = DbsSeekRecord(ThreadCtx, CxtionGuid, CrCxtionGuidx, TableCtx);
    if (!JET_SUCCESS(jerr)) {
        DPRINT1_JS(0, "ERROR Seeking %ws\\%ws\\%ws -> %ws\\%ws :",
                  PRINT_CXTION_PATH(Replica, OutLogPartner->Cxtion), jerr);
        return DbsTranslateJetError(jerr, FALSE);
    }

    //
    // Save the record fields.
    //
    FStatus = DbsWriteTableFieldMult(ThreadCtx,
                                     Replica->ReplicaNumber,
                                     TableCtx,
                                     OutLogUpdateFieldList,
                                     ARRAY_SZ(OutLogUpdateFieldList));
    DPRINT1_FS(0, "ERROR - OutLogSaveSinglePartnerState on %ws:", Replica->ReplicaName->Name, FStatus);

    OutLogPartner->COTxLastSaved = OutLogPartner->COTx;

    return FStatus;
}



ULONG
OutLogSavePartnerState(
    IN PTHREAD_CTX        ThreadCtx,
    IN PREPLICA           Replica,
    IN PSINGLE_LIST_ENTRY CommitList,
    IN PSINGLE_LIST_ENTRY EvalList
)
/*++
Routine Description:

    Update the outbound log state for each partner on the CommitList.
    Then for each partner on the EvalList update the state only if the
    last saved Change Order Trailing index (COTxLastSaved) is less than
    the new joint trailing index that was computed before we were called.
    This is necessary because our caller is about to clean the OutBound log
    up to the new JTx point so those records will be gone from the table.
    If we crash we want COTx to be >= the JTx delete point.

Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.
    Replica -- The replica set struct for the outbound log.
    CommitList -- Ptr to list head of Outlog Partners that need state saved.
    EvalList -- Ptr to list head of OutLog partners than need to be evaluated
                for state save.  They most move up to at least the new Joint
                Trailing Index for the Replica.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogSavePartnerState:"

    JET_ERR            jerr, jerr1;
    ULONG              FStatus;
    TABLE_CTX          TempTableCtx;
    PTABLE_CTX         TableCtx = &TempTableCtx;

    POUT_LOG_PARTNER   OutLogPartner;
    PCXTION_RECORD     CxtionRecord;
    GUID               *CxtionGuid;

    TableCtx->TableType = TABLE_TYPE_INVALID;
    TableCtx->Tid = JET_tableidNil;
    //
    // Open the connection table for this replica.
    //
    jerr = DbsOpenTable(ThreadCtx, TableCtx, Replica->ReplicaNumber, CXTIONTablex, NULL);
    if (!JET_SUCCESS(jerr)) {
        DPRINT1_JS(0, "DbsOpenTable (cxtion) on replica number %d failed.",
                    Replica->ReplicaNumber, jerr);
        FStatus = DbsTranslateJetError(jerr, FALSE);
        DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
        DbsFreeTableCtx(TableCtx, 1);
        return FStatus;
    }

    CxtionRecord = TableCtx->pDataRecord;

    //
    // Update the state of every partner on the commit list.  This ensures that
    // partners that are active will have their state updated even if an inactive
    // partner is preventing the JTx from advancing.
    //
    ForEachSingleListEntry( CommitList, OUT_LOG_PARTNER, SaveList,
        //
        // Iterator pE is of type POUT_LOG_PARTNER.
        //
        OutLogSaveSinglePartnerState(ThreadCtx, Replica, TableCtx, pE);
    );

    //
    // Check the COTxLastSaved of each partner on the Eval list.
    // If it is Less than the new JointTrailing Index then update its state too.
    //
    ForEachSingleListEntry( EvalList, OUT_LOG_PARTNER, SaveList,
        //
        // Iterator pE is of type POUT_LOG_PARTNER.
        //
        if (pE->COTxLastSaved < Replica->OutLogJTx) {
            OutLogSaveSinglePartnerState(ThreadCtx, Replica, TableCtx, pE);
        }
    );

    //
    // Close the table, reset the TableCtx Tid and Sesid.
    // DbsCloseTable is a Macro, writes 1st arg.
    //
    DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(0,"ERROR - JetCloseTable on OutLogSavePartnerState failed:", jerr);
        FStatus = DbsTranslateJetError(jerr, FALSE);
    }

    DbsFreeTableCtx(TableCtx, 1);

    return FStatus;
}

ULONG
OutLogPartnerVVJoinStart(
    IN PTHREAD_CTX        ThreadCtx,
    IN PREPLICA           Replica,
    IN POUT_LOG_PARTNER   OutLogPartner
)
/*++
Routine Description:

    This outbound partner has just entered VVJoin mode.
    Save the current Outlog sequence number for continuation when the
    partner leaves VVJoin Mode.  Reset the ACK vector and update the
    partner state in the database so if the VVJoin is interrupted we can
    restart it.

    Note: The caller must get the Outlog lock.

Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.
    Replica -- The replica set struct for the outbound log.
    OutLogPartner -- ptr to struct with current partner state.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogPartnerVVJoinStart:"

    JET_ERR            jerr, jerr1;
    ULONG              FStatus;
    TABLE_CTX          TempTableCtx;
    PTABLE_CTX         TableCtx = &TempTableCtx;

    FRS_ASSERT(!InVVJoinMode(OutLogPartner));

    //
    // Save the current OutLog insertion point as the restart point when
    // the partner returns to normal mode.
    //
    if (OutLogPartner->COTxNormalModeSave == 0) {
        OutLogPartner->COTxNormalModeSave = Replica->OutLogSeqNumber;
    }

    //
    // Advance the leading and trailing outlog indexes to the end of the outlog.
    //
    OutLogPartner->COLxVVJoinDone = 0;
    OutLogPartner->COLxRestart = 0;
    OutLogPartner->COLx = Replica->OutLogSeqNumber;
    OutLogPartner->COTx = Replica->OutLogSeqNumber;
    OutLogPartner->COTxLastSaved = OutLogPartner->COTxNormalModeSave;

    //
    // For a partner entering VVJoin Mode I would expect the outstanding CO
    // count to be zero.  But it might not be.
    //
    if (OutLogPartner->OutstandingCos > 0) {
        DPRINT1(0, "WARNING: OutstandingCos is %d.  setting to zero.\n", OutLogPartner->OutstandingCos);
    }

    //
    // Reset the Ack Vector and start with a fresh count of outstanding COs.
    //
    ResetAckVector(OutLogPartner);

    //
    // Enable VVJoin Mode.
    //
    SetFlag(OutLogPartner->Flags, OLP_FLAGS_VVJOIN_MODE);

    //
    // Make sure we are not in replay mode.
    //
    ClearFlag(OutLogPartner->Flags, OLP_FLAGS_REPLAY_MODE);

    //
    // Open the connection table and update the partner state now that
    // we are entering VVJoin Mode.
    //
    TableCtx->TableType = TABLE_TYPE_INVALID;
    TableCtx->Tid = JET_tableidNil;

    jerr = DbsOpenTable(ThreadCtx, TableCtx, Replica->ReplicaNumber, CXTIONTablex, NULL);
    if (!JET_SUCCESS(jerr)) {
        DPRINT1_JS(0, "DbsOpenTable (cxtion) on replica number %d failed.",
                    Replica->ReplicaNumber, jerr);
        FStatus = DbsTranslateJetError(jerr, FALSE);
        DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
        DbsFreeTableCtx(TableCtx, 1);
        return FStatus;
    }

    OutLogSaveSinglePartnerState(ThreadCtx, Replica, TableCtx, OutLogPartner);

    DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
    DbsFreeTableCtx(TableCtx, 1);

    FRS_PRINT_TYPE(4, OutLogPartner);
    //
    // Compare the version vectors with the idtable and generate change orders
    //
    SubmitVvJoin(Replica, OutLogPartner->Cxtion, CMD_VVJOIN_START);

    return FrsErrorSuccess;
}

ULONG
OutLogPartnerVVJoinDone(
    IN PTHREAD_CTX        ThreadCtx,
    IN PREPLICA           Replica,
    IN POUT_LOG_PARTNER   OutLogPartner
)
/*++
Routine Description:

    This outbound partner is now leaving VVJoin mode.
    Restore the saved Outlog sequence number so we now send out any
    normal mode change orders that were held up while the VVJoin was going on.

    Reset the ACK vector and update the partner state in the database
    so we know we have left VVJoin mode if the system crashes.

    Note: The caller must get the Outlog lock.

Arguments:
    ThreadCtx -- A Thread context to use for dbid and sesid.
    Replica -- The replica set struct for the outbound log.
    OutLogPartner -- ptr to struct with current partner state.

Return Value:
    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogPartnerVVJoinDone:"

    JET_ERR            jerr, jerr1;
    ULONG              FStatus;
    TABLE_CTX          TempTableCtx;
    PTABLE_CTX         TableCtx = &TempTableCtx;

    FRS_ASSERT(InVVJoinMode(OutLogPartner));

    //
    // Restore the OutLog restart point for this partner.
    //
    OutLogPartner->COLxVVJoinDone = OutLogPartner->COLx;
    OutLogPartner->COLxRestart = OutLogPartner->COTxNormalModeSave;
    OutLogPartner->COLx = OutLogPartner->COTxNormalModeSave;
    OutLogPartner->COTx = OutLogPartner->COTxNormalModeSave;
    OutLogPartner->COTxLastSaved = OutLogPartner->COTxNormalModeSave;
    OutLogPartner->COTxNormalModeSave = 0;

    //
    // Reset the Ack Vector and start with a fresh count of outstanding COs.
    //
    ResetAckVector(OutLogPartner);

    //
    // Leave VVJoin Mode.
    //
    ClearFlag(OutLogPartner->Flags, OLP_FLAGS_VVJOIN_MODE);

    //
    // Enter Replay Mode.
    //
    SetFlag(OutLogPartner->Flags, OLP_FLAGS_REPLAY_MODE);

    //
    // Open the connection table and update the partner state.
    //
    TableCtx->TableType = TABLE_TYPE_INVALID;
    TableCtx->Tid = JET_tableidNil;

    jerr = DbsOpenTable(ThreadCtx, TableCtx, Replica->ReplicaNumber, CXTIONTablex, NULL);
    if (!JET_SUCCESS(jerr)) {
        DPRINT1_JS(0, "DbsOpenTable (cxtion) on replica number %d failed.",
                    Replica->ReplicaNumber, jerr);
        FStatus = DbsTranslateJetError(jerr, FALSE);
        DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
        DbsFreeTableCtx(TableCtx, 1);
        return FStatus;
    }

    OutLogSaveSinglePartnerState(ThreadCtx, Replica, TableCtx, OutLogPartner);

    DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
    DbsFreeTableCtx(TableCtx, 1);

    FRS_PRINT_TYPE(4, OutLogPartner);

    return FrsErrorSuccess;
}

JET_ERR
OutLogCleanupWorker(
    IN PTHREAD_CTX   ThreadCtx,
    IN PTABLE_CTX    OutLogTableCtx,
    IN PCHANGE_ORDER_COMMAND CoCmd,
    IN PVOID         Context,
    IN ULONG         OutLogSeqNumber
)
/*++

Routine Description:

    This is a worker function passed to DbsEnumerateOutlogTable().
    Each time it is called it may delete the record from the table
    and/or delete the corresponding staging file.

Arguments:

    ThreadCtx - Needed to access Jet.
    OutLogTableCtx  - A ptr to an outbound log context struct.
    CoCmd     - A ptr to a change order command record. (NULL if record
                was deleted)
    Context   - A ptr to the Replica struct we are cleaning up.
    OutLogSeqNumber - The sequence number of this record.

Thread Return Value:

    JET_errSuccess

--*/
{
#undef DEBSUB
#define DEBSUB "OutLogCleanupWorker:"

    JET_ERR    jerr, jerr1;
    ULONG      FStatus;
    PREPLICA   Replica = (PREPLICA) Context;
    ULONG      JointTrailingIndex = Replica->OutLogJTx;
    BOOL       DirectedCo;
    PCXTION    Cxtion;

    TABLE_CTX  TempTableCtx;
    PTABLE_CTX TableCtx = &TempTableCtx;

    //
    // Terminate the enumeration early when we catch up to the
    // JointTrailingIndex and there are no VVJoins going on.
    //
    if ((OutLogSeqNumber >= JointTrailingIndex) &&
        (Replica->OutLogCountVVJoins == 0)) {
        return JET_errRecordNotFound;
    }
#if 0
    if (OutLogSeqNumber >= JointTrailingIndex) {
        return JET_errRecordNotFound;
    }
#endif

    //
    // If this record has already been deleted then continue enumeration.
    //
    if (CoCmd == NULL) {
        return JET_errSuccess;
    }

    //
    // If the local install is not done then don't delete the staging file.
    //
    if (BooleanFlagOn(CoCmd->Flags, CO_FLAG_INSTALL_INCOMPLETE)) {
        DPRINT2(4, "Install Incomplete for Index 0x%x, File: %ws\n",
                OutLogSeqNumber, CoCmd->FileName);
        return JET_errSuccess;
    }

    DirectedCo = BooleanFlagOn(CoCmd->Flags, CO_FLAG_DIRECTED_CO);

    if (!DirectedCo) {
        //
        // This is a Normal CO so check it against the JointTrailingIndex to
        // see if it can be deleted.  Note that the JTX has been held back
        // for those partners in VV Join Mode so they will get these COs when
        // they are done with VVJoin Mode.
        //
        if (OutLogSeqNumber >= JointTrailingIndex) {
            return JET_errSuccess;
        }
    } else {
        //
        // This is a directed CO.  It may be VVJoin Related or just a partner
        // initiated refresh request.  It is directed to a single outbound
        // partner.  Either way test the sequence number against
        // the specified partner's current COTx to decide deletion.
        //
        Cxtion = GTabLookup(Replica->Cxtions, &CoCmd->CxtionGuid, NULL);

        //
        // If we don't find the connection then it is deleted so delete the
        // change order.
        //
        if (Cxtion != NULL) {
            FRS_ASSERT(!Cxtion->Inbound);
            FRS_ASSERT(Cxtion->OLCtx != NULL);

            //
            // Check the sequence number against the current trailing index on
            // this connection.  This works regardless of the connection being
            // in Join Mode since the current value is still correct.
            //
            if (OutLogSeqNumber >= Cxtion->OLCtx->COTx) {
                return JET_errSuccess;
            }
        }
    }

    DPRINT2(4, "Deleting OutLog record and staging file for Index 0x%x, File: %ws\n",
            OutLogSeqNumber, CoCmd->FileName);
    //
    // Delete the staging file and then the log record.
    //
    if (StageDeleteFile(CoCmd, TRUE)) {
        //
        // Now delete the outlog record.  If we fail to delete the staging
        // file for some reason the outlog record will stay around so
        // we can try next time.  If there is a problem, complain but keep
        // going.
        //
        jerr = DbsDeleteTableRecord(OutLogTableCtx);
        DPRINT_JS(0, "ERROR - DbsDeleteTableRecord :", jerr);
    }

    //
    // Return success until we hit the Joint Trailing Index.
    //
    return JET_errSuccess;
}



ULONG
OutLogCleanupDominantFileTableWorker (
    PQHASH_TABLE Table,
    PQHASH_ENTRY BeforeNode,
    PQHASH_ENTRY TargetNode,
    PVOID Context
    )
/*++

Routine Description:

    This function is called thru QHashEnumerateTable() to remove entries
    that have no multiples.

Arguments:

    Table - the hash table being enumerated
    BeforeNode  -- ptr to the QhashEntry before the node of interest.
    TargetNode  -- ptr to the QhashEntry of interest.
    Context - Replica ptr.

Return Value:

    Win32 status

--*/

{
#undef DEBSUB
#define DEBSUB  "OutLogCleanupDominantFileTableWorker:"

    PREPLICA   Replica = (PREPLICA) Context;
    ULONG      JointTrailingIndex = Replica->OutLogJTx;

    PDOMINANT_FILE_ENTRY DomFileEntry;

    DomFileEntry = (PDOMINANT_FILE_ENTRY) (TargetNode->Flags);

    //
    // If the Joint Trailing Index has passed this entry by then delete it.
    //
    if (DomFileEntry->OLSeqNum <= JointTrailingIndex) {
        FrsFree(DomFileEntry);
        TargetNode->Flags = 0;
        //
        // Tell QHashEnumerateTable() to delete the QHash node and continue the enum.
        //
        return FrsErrorDeleteRequested;
    }

    return FrsErrorSuccess;
}


VOID
OutLogJointTrailingIndexMerge(
    POUT_LOG_PARTNER Olp,
    PREPLICA         Replica,
    PULONG           JointTrailingIndex
)
/*++
Routine Description:

    Combine outlog partner info to form new joint trailing index.
    Count the number of outlog partners in VV Join Mode.

    Note: The caller has acquired the outbound log lock.

Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.
    Replica -- The replica set struct for the outbound log.
    JointTrailingIndex -- new value returned for JointTrailingIndex.

Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogJointTrailingIndexMerge:"

    ULONG  CleanPoint;


    //
    // Current clean point for this partner is the CO Trailing Index.
    //
    CleanPoint = Olp->COTx;

    //
    // Unless partner is in VV Join Mode in which the clean point was saved
    // in COTxNormalModeSave before entering Join Mode.
    // Count the number of outlog partners in VVJoin Mode.
    //
    if (InVVJoinMode(Olp)) {
        CleanPoint = Olp->COTxNormalModeSave;
        Replica->OutLogCountVVJoins += 1;
    }

    //
    // If this clean point is less than the current JointTrailingIndex then
    // move the JointTrailingIndex back. A zero clean point means this partner
    // has never joined so we will force him to do a VVJoin the first time
    // it joins.  Meanwhile we don't take up log or staging file space if
    // he never joins.
    //
    if ((CleanPoint != 0) && (CleanPoint < *JointTrailingIndex)) {
        *JointTrailingIndex = CleanPoint;
    }

}


ULONG
OutLogCleanupLog(
    PTHREAD_CTX  ThreadCtx,
    PREPLICA     Replica
)
/*++
Routine Description:

    It's time to remove the outbound log change orders that have been
    sent to all the partners for this Replica.  This is done by calculating
    the Joint Trailing Index across all partners and then deleting the
    records up to that point.  When the record is deleted the staging file
    is also deleted.

    WARNING:  It is only safe to call this function after all outbound
    connections have been initialized.  They don't have to be active but
    we need to have loaded up their trailing index state into their
    OUT_LOG_PARTNER struct.

Arguments:

    ThreadCtx -- A Thread context to use for dbid and sesid.
    Replica -- The replica set struct for the outbound log.

Return Value:

    Frs Status

--*/
{
#undef DEBSUB
#define DEBSUB  "OutLogCleanupLog:"

    JET_ERR    jerr, jerr1;
    ULONG      FStatus;
    ULONG      JointTrailingIndex = 0xFFFFFFFF;
    ULONG      OldJointTrailingIndex;
    TABLE_CTX  TempTableCtx;
    PTABLE_CTX TableCtx = &TempTableCtx;
    SINGLE_LIST_ENTRY CommitList, EvalList;


    //
    // Get the outbound log lock for this replica and hold it until we
    // are finished.
    //
    OutLogAcquireLock(Replica);
    Replica->OutLogDoCleanup = FALSE;
    Replica->OutLogCountVVJoins = 0;
    CommitList.Next = NULL;
    EvalList.Next   = NULL;


    //
    // Find the Joint Trailing Index across all partners regardless of their
    // current connected/unconnected state.  Iterator pE is type *OUT_LOG_PARTNER
    // Also count the number of outlog partners in VV Join Mode.
    //

    ForEachSimpleListEntry(&Replica->OutLogEligible, OUT_LOG_PARTNER, List,
        OutLogJointTrailingIndexMerge(pE, Replica, &JointTrailingIndex);
        OUT_LOG_TRACK_PARTNER_STATE_UPDATE(pE, &CommitList, &EvalList);
    );

    ForEachSimpleListEntry(&Replica->OutLogStandBy, OUT_LOG_PARTNER, List,
        OutLogJointTrailingIndexMerge(pE, Replica, &JointTrailingIndex);
        OUT_LOG_TRACK_PARTNER_STATE_UPDATE(pE, &CommitList, &EvalList);
    );

    ForEachSimpleListEntry(&Replica->OutLogActive, OUT_LOG_PARTNER, List,
        OutLogJointTrailingIndexMerge(pE, Replica, &JointTrailingIndex);
        OUT_LOG_TRACK_PARTNER_STATE_UPDATE(pE, &CommitList, &EvalList);
    );

    ForEachSimpleListEntry(&Replica->OutLogInActive, OUT_LOG_PARTNER, List,
        OutLogJointTrailingIndexMerge(pE, Replica, &JointTrailingIndex);
    );

    DPRINT1(4, "Old JointTrailingIndex = 0x%x\n", Replica->OutLogJTx);
    DPRINT1(4, "New JointTrailingIndex = 0x%x\n", JointTrailingIndex);
    DPRINT1(4, "Count of OutLog Partners in VVJoin Mode = %d\n",
            Replica->OutLogCountVVJoins);
    //
    // This shouldn't move backwards.
    //
//    FRS_ASSERT(JointTrailingIndex >= Replica->OutLogJTx)

    if (JointTrailingIndex != 0xFFFFFFFF && Replica->OutLogJTx != 0xFFFFFFFF) {
        FRS_ASSERT(JointTrailingIndex >= Replica->OutLogJTx)
    }

    //
    // Return if no partners or the Outbound log process for this replica is
    // in the Error state.
    //
/*
    if ((JointTrailingIndex == 0xFFFFFFFF) ||
        (Replica->OutLogWorkState == OL_REPLICA_ERROR)) {
        OutLogReleaseLock(Replica);
        return FrsErrorSuccess;
    }
*/

    if (Replica->OutLogWorkState == OL_REPLICA_ERROR) {
        OutLogReleaseLock(Replica);
        return FrsErrorSuccess;
    }

    OldJointTrailingIndex = Replica->OutLogJTx;
    Replica->OutLogJTx = JointTrailingIndex;

    OutLogSavePartnerState(ThreadCtx, Replica, &CommitList, &EvalList);

    OutLogReleaseLock(Replica);

    //
    // Nothing to do if the JointTrailingIndex hasn't advanced and there are
    // no VVJoins going on.
    //
    if ((JointTrailingIndex <= OldJointTrailingIndex) &&
        (Replica->OutLogCountVVJoins == 0)) {
        return FrsErrorSuccess;
    }

    //
    // Clear out the Dominant File Table.up to the JointTrailingIndex.
    //
    QHashEnumerateTable(Replica->OutLogDominantTable,
                        OutLogCleanupDominantFileTableWorker,
                        Replica);

    //
    // Walk through the outbound log up to the JointTrailingIndex (passed
    // through the Replica struct) and delete each record and the staging file.
    // Init the table ctx and then open the outbound log table for this Replica.
    //
    TableCtx->TableType = TABLE_TYPE_INVALID;
    TableCtx->Tid = JET_tableidNil;

    jerr = DbsOpenTable(ThreadCtx, TableCtx, Replica->ReplicaNumber, OUTLOGTablex, NULL);
    if (!JET_SUCCESS(jerr)) {
        DPRINT1_JS(0, "DbsOpenTable (outlog) on replica number %d failed.",
                    Replica->ReplicaNumber, jerr);
        FStatus = DbsTranslateJetError(jerr, FALSE);
        DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
        DbsFreeTableCtx(TableCtx, 1);
        return FStatus;
    }

    jerr = DbsEnumerateOutlogTable(ThreadCtx,
                                   TableCtx,
                                   Replica->OutLogSeqNumber,
                                   OutLogCleanupWorker,
                                   Replica);

    if ((!JET_SUCCESS(jerr)) &&
        (jerr != JET_errRecordNotFound) &&
        (jerr != JET_errNoCurrentRecord)) {
        DPRINT_JS(0, "ERROR - FrsEnumerateTable for OutLogCleanupWorker :", jerr);
    }

    DbsCloseTable(jerr, ThreadCtx->JSesid, TableCtx);
    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(0,"ERROR - JetCloseTable on OutLogCleanupWorker failed :", jerr);
        DbsFreeTableCtx(TableCtx, 1);
        return DbsTranslateJetError(jerr, FALSE);
    }
    DbsFreeTableCtx(TableCtx, 1);

    return FrsErrorSuccess;

}


VOID
OutLogCompletionRoutine(
    IN PCOMMAND_PACKET Cmd,
    IN PVOID           Arg
    )
/*++
Routine Description:
    If a completion event exists in the command packet then
    simply set the event and return. Otherwise, free the command
    packet.

Arguments:
    Cmd
    Arg - Cmd->CompletionArg

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "OutLogCompletionRoutine:"
    DPRINT1(5, "----- OutLog completion 0x%x\n", Cmd);

    if (HANDLE_IS_VALID(Cmd->Parameters.OutLogRequest.CompletionEvent)) {
        SetEvent(Cmd->Parameters.OutLogRequest.CompletionEvent);
        return;
    }
    //
    // Send the packet on to the generic completion routine for freeing
    //
    FrsSetCompletionRoutine(Cmd, FrsFreeCommand, NULL);
    FrsCompleteCommand(Cmd, Cmd->ErrorStatus);
}


ULONG
OutLogSubmit(
    IN PREPLICA Replica,
    IN PCXTION  Cxtion,
    IN USHORT   Command
    )
/*++
Routine Description:
    Submit a command to the outbound log processor

Arguments:
    Replica
    Cxtion
    Command

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "OutLogSubmit:"
    DWORD           WStatus;
    ULONG           FStatus;
    PCOMMAND_PACKET Cmd;

    //
    // Allocate a command packet
    //
    Cmd = FrsAllocCommand(&OutLogWork, Command);
    FrsSetCompletionRoutine(Cmd, OutLogCompletionRoutine, NULL);

    Cmd->Parameters.OutLogRequest.Replica = Replica;
    Cmd->Parameters.OutLogRequest.PartnerCxtion = Cxtion;
    Cmd->Parameters.OutLogRequest.CompletionEvent = FrsCreateEvent(TRUE, FALSE);

    DPRINT2(5, "----- Submitting Command 0x%x for %ws\\%ws\\%ws -> %ws\\%ws\n",
            Command, PRINT_CXTION_PATH(Replica, Cxtion));

    //
    // Hand off to the outbound log processor
    //
    WStatus = FrsRtlInsertTailQueue(&OutLogWork, &Cmd->ListEntry);
    if (!WIN_SUCCESS(WStatus)) {
        FRS_CLOSE(Cmd->Parameters.OutLogRequest.CompletionEvent);
        Cmd->Parameters.OutLogRequest.CompletionEvent = NULL;
        FrsCompleteCommand(Cmd, FrsErrorQueueIsRundown);
        return FrsErrorQueueIsRundown;
    }

    //
    // Wait for the command to finish
    //
    WaitForSingleObject(Cmd->Parameters.OutLogRequest.CompletionEvent, INFINITE);
    FStatus = Cmd->ErrorStatus;
    FRS_CLOSE(Cmd->Parameters.OutLogRequest.CompletionEvent);
    Cmd->Parameters.OutLogRequest.CompletionEvent = NULL;
    FrsCompleteCommand(Cmd, Cmd->ErrorStatus);

    DPRINT1_FS(0, "ERROR Submitting %ws\\%ws\\%ws -> %ws\\%ws",
               PRINT_CXTION_PATH(Replica, Cxtion), FStatus);
    return FStatus;
}


VOID
OutLogCopyCxtionToCxtionRecord(
    IN PCXTION      Cxtion,
    IN PTABLE_CTX   TableCtx
    )
/*++

Routine Description:

    Copy the cxtion fields into the cxtion record for DB update.

Arguments:

    Cxtion
    TableCtx

Thread Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "OutLogCopyCxtionToCxtionRecord:"
    POUT_LOG_PARTNER    OutLogPartner;
    IN PCXTION_RECORD   CxtionRecord = TableCtx->pDataRecord;

    //
    // Update the database record in memory
    //
    if (!Cxtion->Name->Name) {
        DPRINT(0, "ERROR - Cxtion's name is NULL!\n");
        Cxtion->Name->Name = FrsWcsDup(L"<unknown>");
    }
    if (!Cxtion->Partner->Name) {
        DPRINT1(0, "ERROR - %ws: Cxtion's partner's name is NULL!\n",
                Cxtion->Name->Name);
        Cxtion->Partner->Name = FrsWcsDup(L"<unknown>");
    }
    if (!Cxtion->PartSrvName) {
        DPRINT1(0, "ERROR - %ws: Cxtion's PartSrvName is NULL!\n",
                Cxtion->Name->Name);
        Cxtion->PartSrvName = FrsWcsDup(L"<unknown>");
    }
    if (!Cxtion->PartnerPrincName) {
        DPRINT1(0, "ERROR - %ws: Cxtion's PartnerPrincName is NULL!\n",
                Cxtion->Name->Name);
        Cxtion->PartnerPrincName = FrsWcsDup(L"<unknown>");
    }
    if (!Cxtion->PartnerSid) {
        DPRINT1(0, "ERROR - %ws: Cxtion's PartnerSid is NULL!\n",
                Cxtion->Name->Name);
        Cxtion->PartnerSid = FrsWcsDup(L"<unknown>");
    }

    //
    // Cxtion Guid and Name
    //
    COPY_GUID(&CxtionRecord->CxtionGuid, Cxtion->Name->Guid);
    wcsncpy(CxtionRecord->CxtionName, Cxtion->Name->Name, MAX_RDN_VALUE_SIZE + 1);
    CxtionRecord->CxtionName[MAX_RDN_VALUE_SIZE] = L'\0';

    //
    // Partner Guid and Name
    //
    COPY_GUID(&CxtionRecord->PartnerGuid, Cxtion->Partner->Guid);
    wcsncpy(CxtionRecord->PartnerName, Cxtion->Partner->Name, MAX_RDN_VALUE_SIZE + 1);
    CxtionRecord->PartnerName[MAX_RDN_VALUE_SIZE] = L'\0';

    //
    // Partner DNS Name
    //
    wcsncpy(CxtionRecord->PartnerDnsName, Cxtion->PartnerDnsName, DNS_MAX_NAME_LENGTH + 1);
    CxtionRecord->PartnerDnsName[DNS_MAX_NAME_LENGTH] = L'\0';

    //
    // Partner PrincName and Server Name
    //
    DbsPackStrW(Cxtion->PartnerPrincName, CrPartnerPrincNamex, TableCtx);
    wcsncpy(CxtionRecord->PartSrvName, Cxtion->PartSrvName, MAX_RDN_VALUE_SIZE + 1);
    CxtionRecord->PartSrvName[MAX_RDN_VALUE_SIZE] = L'\0';

    //
    // Partner SID
    //
    DbsPackStrW(Cxtion->PartnerSid, CrPartnerSidx, TableCtx);

    //
    // Partner Auth Level
    //
    CxtionRecord->PartnerAuthLevel = Cxtion->PartnerAuthLevel;

    //
    // Inbound Flag
    //
    CxtionRecord->Inbound = Cxtion->Inbound;

    //
    // LastJoinTime
    //
    COPY_TIME(&CxtionRecord->LastJoinTime, &Cxtion->LastJoinTime);

    CxtionRecord->TerminationCoSeqNum = Cxtion->TerminationCoSeqNum;

    //
    // Cxtion options.
    //
    CxtionRecord->Options = Cxtion->Options;

    //
    // Cxtion Flags
    // High short belongs to cxtion
    //
    CxtionRecord->Flags &= ~CXTION_FLAGS_CXTION_RECORD_MASK;
    CxtionRecord->Flags |= (Cxtion->Flags & CXTION_FLAGS_CXTION_RECORD_MASK);

    //
    // OUT LOG PARTNER.  An inbound connection won't have an OutLogPartner struct.
    //
    OutLogPartner = Cxtion->OLCtx;
    if (OutLogPartner) {
        //
        // Low short belongs to outlogpartner
        //
        CxtionRecord->Flags &= ~OLP_FLAGS_CXTION_RECORD_MASK;
        CxtionRecord->Flags |= (OutLogPartner->Flags & OLP_FLAGS_CXTION_RECORD_MASK);
        CxtionRecord->COLx = OutLogPartner->COLx;
        CxtionRecord->COTx = OutLogPartner->COTx;
        CxtionRecord->COTxNormalModeSave = OutLogPartner->COTxNormalModeSave;
        CxtionRecord->COTslot = OutLogPartner->COTslot;
        CxtionRecord->OutstandingQuota = OutLogPartner->OutstandingQuota;
        CopyMemory(CxtionRecord->AckVector, OutLogPartner->AckVector, ACK_VECTOR_BYTES);
        CxtionRecord->AckVersion = OutLogPartner->AckVersion;
    }
    //
    // Pack the schedule blob
    //
    DbsPackSchedule(Cxtion->Schedule, CrSchedulex, TableCtx);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\setup\dscheck\dscheck.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
	dscheck.cxx

Abstract:
	Check the consistency of the DS topology for the system volume. The DS
	tree for sites\site\nTDSSettings\mSFT-DSA\nTDSConnection is copied into
	memory. An RTL Generic Table of the mSFT-DSA objects is built. Duplicates
	are kept on a list anchored by the first occurence of a mSFT-DSA. The
	tree and the table are used to check the consistency of the topology.

	Once the checks have stablized a bit they will be listed here.

Author:
	Billy J. Fuller 3-Mar-1997 (From Jim McNelis)

Environment
	User mode winnt

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <winldap.h>
#include <dsgetdc.h>
#include <tchar.h>

//
// We save code by recursively scanning the DS's hierarchical directory.
// The following constants tell us where we are in the hierarchy.
//
#define	SITES		0
#define	SETTINGZ	1
#define	SERVERS		2
#define	CXTIONS		3


//
// We build an incore copy of the DS hierarchy sites\settings\servers\connections.
// Hence the interrelated structs for site, settings, server, and connection
//
typedef struct cxtion	CXTION,		* PCXTION;
typedef struct server	SERVER,		* PSERVER;
typedef struct settings	SETTINGS,	* PSETTINGS;
typedef struct site		SITE,		* PSITE;

// Connection
struct cxtion {
	PTCHAR		CxtionRDN;			// relative distinguished name
	PSERVER		CxtionServer;		// address of parent
	PCXTION		CxtionNext;			// peers of this connection
	PTCHAR		CxtionPartner;		// inbound partner's RDN
} * Settingss;

// Server
struct server {
	PTCHAR		ServerRDN;			// relative distinguished name
	PSETTINGS	ServerSettings;		// address of parent
	PSERVER		ServerNext;			// peers of this server
	PCXTION		ServerOuts;			// outbound connections
	PCXTION		ServerIns;			// inbound connections
};

// Settings
struct settings {
	PTCHAR		SettingsRDN;		// relative distinguished name
	PSITE		SettingsSite;		// address of parent
	PSETTINGS	SettingsNext;		// peers of this settings
	PSERVER		SettingsServers;	// children of this settings
};

// Site
struct site {
	PTCHAR		SiteRDN;			// relative distinguished name
	PSITE		SiteNext;			// peers of this site
	PSETTINGS	SiteSettings;		// children of this site
} * Sites;


//
// We avoid N**2 algorithms by using the generic table routines to access
// servers by name.
//
RTL_GENERIC_TABLE ServerTable;


//
// The entry in the generic table points to a sever struct. The entry can
// be looked up by the server's relative distinguished name (ServerRDN).
//
// Although duplicate server names are not allowed, a user may have
// created servers with the same RDN. These duplicates are kept as
// a linked list anchored by RtlServerDups. The duplicates are ignored.
// The first entry encountered while scanning the DS tree is used as
// the "correct" server.
//
typedef struct rtlserver RTLSERVER, * PRTLSERVER;
struct rtlserver {
	PRTLSERVER	RtlServerDups;
	PSERVER		RtlServer;
};


RTL_GENERIC_COMPARE_RESULTS
RtlServerCompare(
	PRTL_GENERIC_TABLE Table,
	PVOID FirstStruct,
	PVOID SecondStruct
	)
/*++
Routine Description:
	Compare two entries in the generic table for servers.

Arguments:
	Table			- Address of the table (not used).
	FirstStruct		- PRTLSERVER
	SecondStruct	- PRTLSERVER

Return Value:
	<0	First < Second
	=0	First == Second
	>0	First > Second
--*/
{
	INT			Cmp;

	Cmp = _tcscmp(((PRTLSERVER)FirstStruct)->RtlServer->ServerRDN,
					((PRTLSERVER)SecondStruct)->RtlServer->ServerRDN);
	if (Cmp < 0)
		return (GenericLessThan);
	if (Cmp == 0)
		return (GenericEqual);
	return (GenericGreaterThan);
}

PVOID
RtlServerAllocate(
	PRTL_GENERIC_TABLE Table,
	CLONG ByteSize
	)
/*++
Routine Description:
	Allocate space for a table entry. The entry includes the user-defined
	struct and some overhead used by the generic table routines. The
	generic table routines call this function when they need memory.

Arguments:
	Table		- Address of the table (not used).
	ByteSize	- Bytes to allocate

Return Value:
	Address of newly allocated memory.
--*/
{
	return (PVOID)malloc(ByteSize);
}

VOID
RtlServerFree(
	PRTL_GENERIC_TABLE Table,
	PVOID Buffer
	)
/*++
Routine Description:
	Free the space allocated by RtlServerAllocate(). The generic table
	routines call this function to free memory.

Arguments:
	Table	- Address of the table (not used).
	Buffer	- Address of previously allocated memory

Return Value:
	None.
--*/
{
	free(Buffer);
}

VOID
RtlServerInsert(
	PSERVER Server
	)
/*++
Routine Description:
	Insert a server's name into the table. The new entry in the table
	will point to the originating SERVER. If this name is already in the
	table, then link the new entry off of the old entry.

Arguments:
	Server	- Address of SERVER

Return Value:
	None.
--*/
{
	PRTLSERVER	NewServer;		// Newly allocated table entry
	PRTLSERVER	OldServer;		// Existing entry in the table
	BOOLEAN		NewElement;		// TRUE if insert found existing entry

	// Allocate a new table entry
	NewServer = (PRTLSERVER)malloc(sizeof (*NewServer));
	NewServer->RtlServer = Server;
	NewServer->RtlServerDups = NULL;

	// Insert the entry
	OldServer = (PRTLSERVER)RtlInsertElementGenericTable(
								&ServerTable,
								(PVOID)NewServer,
								sizeof (*NewServer),
								&NewElement);
	// NewServer was copied into the table
	if (NewElement == TRUE) { 
		free(NewServer);
	} else {
		// Entry exists; link NewServer to existing entry
		NewServer->RtlServerDups = OldServer->RtlServerDups;
		OldServer->RtlServerDups = NewServer;
	}
}
PSERVER
RtlServerLookup(
	PTCHAR ServerRDN
	)
/*++
Routine Description:
	Find an entry in the table with the specified name.

Arguments:
	Server	- Address of SERVER

Return Value:
	The address of the SERVER with a matching name or NULL if no
	match was found.
--*/
{
	PRTLSERVER	FoundRtlServer;	// Address of matching table entry
	SERVER		Server;			// Part of the search key
	RTLSERVER	RtlServer;		// Search key
	
	// Set up the search key
	Server.ServerRDN = ServerRDN;
	RtlServer.RtlServer = &Server;

	// Search the table
	FoundRtlServer = (PRTLSERVER)RtlLookupElementGenericTable(&ServerTable, &RtlServer);
	if (FoundRtlServer != NULL)
		return FoundRtlServer->RtlServer;
	return NULL;
}

VOID
FreeRtlServer()
/*++
Routine Description:
	Free every entry in the generic table.

Arguments:
	None.

Return Value:
	None.
--*/
{
	PRTLSERVER	RtlServer;	// Next entry in table
	PRTLSERVER	Dups;		// scan the entries list of dups
	PRTLSERVER	NextDups;	// copy of freed Dups->RtlServerDups

	// For every entry in the table
	for (RtlServer = (PRTLSERVER)RtlEnumerateGenericTable(&ServerTable, TRUE);
		 RtlServer != NULL;
		 RtlServer = (PRTLSERVER)RtlEnumerateGenericTable(&ServerTable, TRUE)) {

		// Free the dups
		for (Dups = RtlServer->RtlServerDups; Dups; Dups = NextDups) {
			NextDups = Dups->RtlServerDups;
			free(Dups);
		}

		// Delete the entry from the table
		RtlDeleteElementGenericTable(&ServerTable, RtlServer);
	}

	// Didn't get all of them?
	if (!RtlIsGenericTableEmpty(&ServerTable)) {
		fprintf(stderr, "****** FreeRtlServer: Server Table is not empty\n");
	}
}

PLDAP
FrsDsOpenDs()
/*++
Routine Description:
	Open and bind to the a primary domain controller.

Arguments:
	None.

Return Value:
	The address of a open, bound LDAP port or NULL if the operation was
	unsuccessful. The caller must free the structure with ldap_unbind().
--*/
{
	PLDAP						ldap;
	LONG						Err;			// Generic error
	PDOMAIN_CONTROLLER_INFO		DCInfo = NULL;	// Domain Controller Info
    ULONG                       ulOptions;

	//
	// Get Info about a Primary Domain Controller (just need the IP address)
	//
	Err = DsGetDcName(
		NULL,								// Computer to remote to
		NULL,								// Domain - use our own
		NULL,								// Domain Guid
		NULL,								// Site Guid
		DS_DIRECTORY_SERVICE_REQUIRED |  	// Flags
			DS_PDC_REQUIRED,
		&DCInfo);							// Return info

	if (Err != ERROR_SUCCESS) {
		fprintf(stderr, "DsGetDcName returned error %d\n", Err);
		fprintf(stderr, "Could not find a Primary Domain Controller\n");
		return NULL;
	}

	//
	// Open and bind to the ldap service (TCP/IP)
	//		The IP address has a leading "\\" that ldap_open can't handle
	//
    //
    // if ldap_open is called with a server name the api will call DsGetDcName 
    // passing the server name as the domainname parm...bad, because 
    // DsGetDcName will make a load of DNS queries based on the server name, 
    // it is designed to construct these queries from a domain name...so all 
    // these queries will be bogus, meaning they will waste network bandwidth,
    // time to fail, and worst case cause expensive on demand links to come up 
    // as referrals/forwarders are contacted to attempt to resolve the bogus 
    // names.  By setting LDAP_OPT_AREC_EXCLUSIVE to on using ldap_set_option 
    // after the ldap_init but before any other operation using the ldap 
    // handle from ldap_init, the delayed connection setup will not call 
    // DsGetDcName, just gethostbyname, or if an IP is passed, the ldap client 
    // will detect that and use the address directly.
    //
//	ldap = ldap_open(&DCInfo->DomainControllerAddress[2], LDAP_PORT);
	ldap = ldap_init(&DCInfo->DomainControllerAddress[2], LDAP_PORT);

	if (ldap == NULL) {
		fprintf(stderr, "ldap_open: Could not open %ws\n", 
						&DCInfo->DomainControllerAddress[2]);
		return NULL;
	}

    //
    // set the options.
    //

    ulOptions = PtrToUlong(LDAP_OPT_ON);
    ldap_set_option(ldap, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions);

	//
	// ldap cannot be used until after the bind operation
	//
	Err = ldap_bind_s(ldap, NULL, NULL, LDAP_AUTH_SSPI);
	if (Err != LDAP_SUCCESS) {
		fprintf(stderr, "ldap_bind_s: %ws\n", ldap_err2string(Err));
		ldap_unbind(ldap);	// XXX Is this necessary?  Will this free ldap?
		return NULL;
	}

	return ldap;
}

PTCHAR *
GetValues(
	IN PLDAP ldap,
	IN PTCHAR Base,
	IN PTCHAR DesiredAttr
	)
/*++
Routine Description:
	Return the DS values for one attribute in an object.

Arguments:
	ldap 		- An open, bound ldap port.
	Base		- The "pathname" of a DS object.
	DesiredAttr	- Return values for this attribute.

Return Value:
	An array of char pointers that represents the values for the attribute.
	The caller must free the array with ldap_value_free(). NULL if unsuccessful.
--*/
{
	LONG			Err;		// Generic error
	PTCHAR			Attr;		// Retrieved from an ldap entry
	BerElement		*Ber;		// Needed for scanning attributes
	PLDAPMessage	Msg = NULL;	// Opaque stuff from ldap subsystem 
	PLDAPMessage	Entry;		// Opaque stuff from ldap subsystem 
	PTCHAR			*Values;	// Array of values for desired attribute
	PTCHAR			Attrs[2];	// Needed for the query

	//
	// Search Base for all of this attribute + values
	//
	Attrs[0] = DesiredAttr;
	Attrs[1] = NULL;
	Err = ldap_search_s(ldap, Base, LDAP_SCOPE_BASE,
				TEXT("(objectClass=*)"), Attrs, 0, &Msg);
	if (Err != LDAP_SUCCESS) {
		fprintf(stderr, "ldap_search_s: %ws: %ws\n", DesiredAttr, ldap_err2string(Err));
        if (Msg) {
	        ldap_msgfree(Msg);
        }
		return NULL;
	}
	Entry = ldap_first_entry(ldap, Msg);
	Attr = ldap_first_attribute(ldap, Entry, &Ber);
	Values = ldap_get_values(ldap, Entry, Attr);
	ldap_msgfree(Msg);
	return Values;
}

PTCHAR
MakeRDN(
	PTCHAR DN
	)
/*++
Routine Description:
	Extract the base component from a distinguished name. The distinguished
	name is assumed to be in DS format (CN=xyz,CN=next one,...)

Arguments:
	DN	- distinguished name

Return Value:
	The address of a base name. The caller must free the memory with free().
--*/
{
	LONG	RDNLen;
	PTCHAR	RDN;

	// Skip the first CN=; if any
	RDN = _tcsstr(DN, TEXT("CN="));
	if (RDN == DN)
		DN += 3;
	
	// Return the string up to the first delimiter
	RDNLen = _tcscspn(DN, TEXT(","));
	RDN = (PTCHAR)malloc(sizeof (TCHAR) * (RDNLen + 1));
	_tcsncpy(RDN, DN, RDNLen);
	RDN[RDNLen] = TEXT('\0');

	return RDN;
}


VOID
GetTree(
	IN PLDAP 	ldap,
	IN PTCHAR 	Base,
	IN LONG		What,
	IN PVOID	Parent,
	IN PTCHAR	Filter
	)
/*++
Routine Description:
	Recursively scan the DS tree beginning at configuration\sites.
Arguments:
	ldap	- opened and bound ldap connection
	Base	- Name of object or container in DS
	What	- Where are we in the DS hierarchy?
	Parent	- Container which contains Base
	Filter	- Limits ldap search to these object classes
Return Value:
	None.
--*/
{
	LONG			Err;		// Generic error
	PLDAPMessage	Msg = NULL;	// Opaque stuff from ldap subsystem 
	PLDAPMessage	Entry;		// Opaque stuff from ldap subsystem 
	PTCHAR			DirName;	// DS name of this object
	PTCHAR			RDN;		// base name derived from DirName
	PTCHAR			*Values;	// entries for this container
	PSITE			Site;		// copy DS site entries into this struct
	PSETTINGS		Settings;	// copy DS settings entries into this struct
	PSERVER			Server;		// copy DS server entries into this struct
	PCXTION			Cxtion;		// copy DS connection entries into this struct

	//
	// Search the DS beginning at Base for the entries of class "Filter" 
	//
	Err = ldap_search_s(ldap, Base, LDAP_SCOPE_ONELEVEL, Filter, NULL, 0, &Msg);
	if (Err != LDAP_SUCCESS) {
        if (Msg) {
	        ldap_msgfree(Msg);
        }
		return;
    }
	//
	// Scan the entries returned from ldap_search
	//
	for (
		Entry = ldap_first_entry(ldap, Msg);
		Entry != NULL;
		Entry = ldap_next_entry(ldap, Entry)) {

			// DS pathname of this entry
			DirName = ldap_get_dn(ldap, Entry);
			if (DirName == NULL)
				continue;
			// base name of the DS pathname
			RDN = MakeRDN(DirName);

			// Where are we in the DS directory hierarchy
			switch (What) {
			case SITES:
				// Copy a site entry into our tree
				Site = (PSITE)malloc(sizeof (*Site));
				Site->SiteRDN = RDN;
				Site->SiteSettings = NULL;
				Site->SiteNext = Sites;
				Sites = Site;
				// Get the settings
				GetTree(ldap, DirName, SETTINGZ, (PVOID)Site, TEXT("(objectClass=nTDSSettings)"));
				break;
			case SETTINGZ:
				// Copy a settings entry into our tree
				Settings = (PSETTINGS)malloc(sizeof (*Settings));
				Settings->SettingsRDN = RDN;
				Settings->SettingsServers = NULL;
				Settings->SettingsSite = (PSITE)Parent;
				Settings->SettingsNext = ((PSITE)Parent)->SiteSettings;
				((PSITE)Parent)->SiteSettings = Settings;
				// Get the servers
				GetTree(ldap, DirName, SERVERS, (PVOID)Settings, TEXT("(objectClass=mSFTDSA)"));
				break;
			case SERVERS:
				// Copy a server entry into our tree
				Server = (PSERVER)malloc(sizeof (*Server));
				Server->ServerRDN = RDN;
				Server->ServerSettings = (PSETTINGS)Parent;
				Server->ServerIns = NULL;
				Server->ServerOuts = NULL;
				Server->ServerNext = ((PSETTINGS)Parent)->SettingsServers;
				((PSETTINGS)Parent)->SettingsServers = Server;
				// Put this server into the generic table
				RtlServerInsert(Server);
				// Get the connections
				GetTree(ldap, DirName, CXTIONS, (PVOID)Server, TEXT("(objectClass=nTDSConnection)"));
				break;
			case CXTIONS:
				// Copy a connection entry into our tree
				Cxtion = (PCXTION)malloc(sizeof (*Cxtion));
				Cxtion->CxtionRDN = RDN;
				Cxtion->CxtionServer = (PSERVER)Parent;
				Cxtion->CxtionPartner = NULL;
				Cxtion->CxtionNext = ((PSERVER)Parent)->ServerIns;
				((PSERVER)Parent)->ServerIns = Cxtion;
				Values = GetValues(ldap, DirName, TEXT("fromServer"));
				// Get the inbound partner's name
				if (Values != NULL) {
					Cxtion->CxtionPartner = MakeRDN(Values[0]);
					ldap_value_free(Values);
				}
				break;
			default:;
			}
			free(DirName);
		}
	ldap_msgfree(Msg);
}

VOID
FrsDsFreeTree(
	)
/*++
Routine Description:
	Frees our copy of the DS tree.

Arguments:
	None.

Return Value:
	None.
--*/
{
	PSITE		Site;		// Scan the sites
	PSETTINGS	Settings;	// Scan the settings
	PSERVER		Server;		// Scan the servers
	PCXTION		Cxtion;		// Scan the connections

	//
	// For every site
	//
	while ((Site = Sites) != NULL) {
		Sites = Site->SiteNext;
		//
		// For every settings
		//
		while ((Settings = Site->SiteSettings) != NULL) {
			Site->SiteSettings = Settings->SettingsNext;
			//
			// For every server
			//
			while ((Server = Settings->SettingsServers) != NULL) {
				Settings->SettingsServers = Server->ServerNext;
				//
				// For every inbound connection
				//
				while ((Cxtion = Server->ServerIns) != NULL) {
					Server->ServerIns = Cxtion->CxtionNext;
					// Free inbound connection
					free(Cxtion->CxtionRDN);
					free(Cxtion->CxtionPartner);
					free(Cxtion);
				}
				//
				// For every outbound connection
				//
				while ((Cxtion = Server->ServerOuts) != NULL) {
					Server->ServerOuts = Cxtion->CxtionNext;
					// Free outbound connection
					free(Cxtion->CxtionRDN);
					free(Cxtion->CxtionPartner);
					free(Cxtion);
				}
				// Free server
				free(Server->ServerRDN);
				free(Server);
			}
			// Free settings
			free(Settings->SettingsRDN);
			free(Settings);
		}
		// Free site
		free(Site->SiteRDN);
		free(Site);
	}
}

VOID
CreateOutBoundPartners(
	)
/*++
Routine Description:
	Scan our copy of the DS tree. For each server, use the generic
	table to find its outbound partners. Update the server's list
	of outbound connections.

Arguments:
	None.

Return Value:
	None.
--*/
{
	PSITE		Site;			// Scan the sites
	PSETTINGS	Settings;		// Scan the settings
	PSERVER		Server;			// Scan the servers
	PCXTION		Cxtion;			// Scan the inbound connections
	PSERVER		InServer;		// My inbound partner
	PCXTION		InCxtion;		// outbound connection added to my inbound partner
	PRTLSERVER	InRtlServer;	// Inbound partner from generic table

	//
	// For every site
	//
	for (Site = Sites;
		 Site != NULL;
		 Site = Site->SiteNext) {
		//
		// For every setting
		//
		for (
			Settings = Site->SiteSettings;
			Settings != NULL;
			Settings = Settings->SettingsNext) {
			//
			// For every server
			//
			for (Server = Settings->SettingsServers;
				 Server != NULL;
				 Server = Server->ServerNext) {
				//
				// For every inbound connection
				//
				for (Cxtion = Server->ServerIns;
					 Cxtion != NULL;
					 Cxtion = Cxtion->CxtionNext) {
					//
					// Find one of our inbound partners and put a copy of
					// this inbound connection on his list of outbound
					// connections after filling in the "partner" field
					// with this server's name.  Basically, create the
					// outbound connections from the inbound connections.
					//

					// Find the inbound partner in the generic table
					InServer = RtlServerLookup(Cxtion->CxtionPartner);
					if (InServer == NULL)
						continue;

					//
					// Dummy up a outbound connection and put it on
					// our inbound partner's list of outbound connections.
					//
					InCxtion = (PCXTION)malloc(sizeof (*InCxtion));
					InCxtion->CxtionRDN = _tcsdup(Cxtion->CxtionRDN);
					InCxtion->CxtionServer = InServer;
					InCxtion->CxtionPartner = _tcsdup(Server->ServerRDN);
					InCxtion->CxtionNext = InServer->ServerOuts;
					InServer->ServerOuts = InCxtion;
				}
			}
		}
	}
}

PTCHAR
GetRoot(
	IN PLDAP ldap
	)
/*++
Routine Description:
	Return the DS pathname of the configuration\sites container.

Arguments:
	ldap	- An open, bound ldap port.

Return Value:
	A malloc'ed string representing the DS pathname of the
	configuration\sites container. Or NULL if the container could
	not be accessed. The caller must free() the string.
--*/
{
	PTCHAR			Config;		// DS pathname of configuration
	PTCHAR			Root;		// DS pathname of configuration\sites
	PTCHAR			*Values;	// values from the attribute "namingContexts"
	LONG			NumVals;	// number of values

	//
	// Search Base for the attribute "namingContext"
	//
	Values = GetValues(ldap, TEXT(""), TEXT("namingContexts"));
	if (Values == NULL)
		return NULL;

	//
	// Find the naming context that begins with "CN=configuration"
	//
	NumVals = ldap_count_values(Values);
	while (NumVals--) {
		Config = _tcsstr(Values[NumVals], TEXT("CN=configuration"));
		if (Config != NULL && Config == Values[NumVals]) {
			//
			// Build the pathname for "configuration\sites"
			//
			Root = (PTCHAR)malloc(
					sizeof (TCHAR) * _tcslen(Config) +
					sizeof (TCHAR) * (_tcslen(TEXT("CN=sites,")) + 1));
			_tcscpy(Root, TEXT("CN=sites,"));
			_tcscat(Root, Config);
			ldap_value_free(Values);
			return Root;
		}
	}
	ldap_value_free(Values);
	return NULL;
}

VOID
FrsDsCheckTree(
	)
/*++
Routine Description:
	Scan our copy of the DS tree and check the consistency of sites and
	settings. XXX we need a list of checks here.

Arguments:
	None.

Return Value:
	None.
--*/
{
	PSITE		Site;		// Scan the sites
	PSETTINGS	Settings;	// Scan the settings

	//
	// No sites
	//
	if (Sites == NULL) {
		fprintf(stderr, "There are no sites\n");
		return;
	}

	//
	// For every site
	//
	for (Site = Sites;
		 Site != NULL;
		 Site = Site->SiteNext) {
		// No Settings
		if (Site->SiteSettings == NULL) {
			fprintf(stderr, "%ws has no NTDS Settings\n", Site->SiteRDN);
		} else {
		// More than one settings
			if (Site->SiteSettings->SettingsNext != NULL) {
				fprintf(stderr, "%ws has more than one NTDS Settings\n", Site->SiteRDN);
				// List the extra settings
				for (Settings = Site->SiteSettings;
					 Settings != NULL;
					 Settings = Settings->SettingsNext)
					fprintf(stderr, "\t%ws\n", Settings->SettingsRDN);
			}
		}
		//
		// For every settings
		//
		for (Settings = Site->SiteSettings;
			 Settings != NULL;
			 Settings = Settings->SettingsNext) {
			// No servers
			if (Settings->SettingsServers == NULL) {
				fprintf(stderr, "%ws has no servers\n", Settings->SettingsRDN);
			}
		}
	}
}
VOID
CheckServers(
	)
/*++
Routine Description:
	Scan the generic table of servers and check the consistency of servers
	and connections. XXX we need a list of checks here.

Arguments:
	None.

Return Value:
	None.
--*/
{
	PVOID		RestartKey;	// Needed for scanning the table
	PSERVER		Server;		// Address of SERVER in copy of DS tree
	PCXTION		Cxtion;		// Address of CXTION in copy of DS tree
	PRTLSERVER	RtlServer;	// Returned by table routines
	PRTLSERVER	Dups;		// Duplicate servers

	//
	// Scan the generic table of servers. Every server is only listed once.
	//
	RestartKey = NULL;
    for (RtlServer = (PRTLSERVER)RtlEnumerateGenericTableWithoutSplaying(&ServerTable, &RestartKey);
         RtlServer != NULL;
         RtlServer = (PRTLSERVER)RtlEnumerateGenericTableWithoutSplaying(&ServerTable, &RestartKey)) {

		//
		// The same server name in multiple sites is not allowed
		//
		if (RtlServer->RtlServerDups != NULL) {
			fprintf(stderr, "%ws is a member of multiple sites\n", RtlServer->RtlServer->ServerRDN);
			fprintf(stderr, "\t%ws\n", RtlServer->RtlServer->ServerSettings->SettingsSite->SiteRDN);
			for (Dups = RtlServer->RtlServerDups; Dups; Dups = Dups->RtlServerDups)
				fprintf(stderr, "\t%ws\n", Dups->RtlServer->ServerSettings->SettingsSite->SiteRDN);
		}
		Server = RtlServer->RtlServer;
		// No inbound connections
		if (Server->ServerIns == NULL)
			fprintf(stderr, "%ws has no inbound connections\n", Server->ServerRDN);
		//
		// For every inbound connection
		//
		for (Cxtion = Server->ServerIns;
			 Cxtion != NULL;
			 Cxtion = Cxtion->CxtionNext) {
			// Connection doesn't have the partner's name
			if (Cxtion->CxtionPartner == NULL)
				fprintf(stderr, "%ws has no inbound server\n", Cxtion->CxtionRDN);
			// Replicating from ourselves is not allowed
			if (_tcscmp(Cxtion->CxtionPartner, Server->ServerRDN) == 0)
				fprintf(stderr, "%ws is its own inbound partner\n", Server->ServerRDN);
		}
		// No outbound connections
		if (Server->ServerOuts == NULL)
			fprintf(stderr, "%ws has no outbound connections\n", Server->ServerRDN);
		//
		// For every outbound connection
		//
		for (Cxtion = Server->ServerOuts;
			 Cxtion != NULL;
			 Cxtion = Cxtion->CxtionNext) {
			// Connection doesn't have the partner's name
			if (Cxtion->CxtionPartner == NULL)
				fprintf(stderr, "%ws has no outbound server\n", Cxtion->CxtionRDN);
			// Replicating to ourselves is not allowed
			if (_tcscmp(Cxtion->CxtionPartner, Server->ServerRDN) == 0)
				fprintf(stderr, "%ws is its own outbound partner\n", Server->ServerRDN);
		}
	}
}

VOID _cdecl
main(
	IN LONG		argc,
	IN PTCHAR	*argv
	)
/*++
Routine Description:
	Open a connection to the DS and copy the DS tree beginning at
	configuration\sites. Check the resulting topology for consistency.
	The generic table routines are used to avoid N**2 algorithms during
	the consistency checks.

Arguments:
	None.

Return Value:
	exit 0	- No errors
	exit 1	- Something went wrong
--*/
{
	PLDAP	ldap	= NULL;		// ldap connection
	PTCHAR	Root	= NULL;		// DS pathname to ...\configuration\sites
	
	//
	// Open and bind a ldap connection to the DS
	//
	ldap = FrsDsOpenDs();
	if (ldap == NULL)
		exit(1);

	//
	// Get the DS pathname down to ...\configuration\sites
	//
	Root = GetRoot(ldap);	
	if (Root == NULL)
		goto out;

	//
	// Create incore copy of the complete DS topology
	//

	// This generic table keeps additional info about the servers
	RtlInitializeGenericTable(&ServerTable, RtlServerCompare,
							  RtlServerAllocate, RtlServerFree, NULL);
	// Create copy of the DS tree
	GetTree(ldap, Root, SITES, NULL, TEXT("(objectClass=site)"));
	// The DS doesn't have connections for outbound partners; create them
	CreateOutBoundPartners();

	//
	// Check consistency
	//
	FrsDsCheckTree();		// check incore copy of DS tree
	CheckServers();		// check generic table of servers


out:
	//
	// Cleanup
	//
	if (Sites != NULL) {
		FreeRtlServer();	// generic table of servers
		FrsDsFreeTree();			// copy of DS tree
	}
	if (Root != NULL)
		free(Root);			// DS pathname to ...\configuration\sites
	if (ldap != NULL)  
		ldap_unbind(ldap);	// release the connection to the DS
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\support\ldaputil.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:
    ldaputil.c

Abstract:
    Collection of functions needed to perform ldao operations.
    These functions are used by ntfrsapi.dll and 
    any other frs tools.


Author:
    Sudarshan Chitre 20-Mar-2001

Environment
    User mode winnt

--*/

#include <ntreppch.h>
#pragma  hdrstop
#include <perrepsr.h>

#undef DEBSUB
#define DEBSUB  "SUP:"

#include <frs.h>
#include <frssup.h>

//###  These functions are also defined in ds,c

//
// Ldap client timeout structure. Value is overwritten by the value of LdapSearchTimeoutInMinutes.
//

LDAP_TIMEVAL    FrsSupLdapTimeout = { 10 * 60 * 60, 0 }; //Default ldap timeout value. Overridden by registry param Ldap Search Timeout Value In Minutes

#define FRS_LDAP_SEARCH_PAGESIZE 1000

DWORD
FrsSupBindToDC (
    IN  PWCHAR    pszDC,
    IN  PSEC_WINNT_AUTH_IDENTITY_W pCreds,
    OUT PLDAP     *ppLDAP
    )
/*++

Routine Description:

    Sets up an LDAP connection to the specified server

Arguments:

    pwszDC - DS DC to bind to
    pCreds - Credentials used to bind to the DS.
    ppLDAP - The LDAP connection information is returned here

Return Value:

    ERROR_SUCCESS - Success

--*/
{
    DWORD   dwErr = ERROR_SUCCESS;
    ULONG   ulOptions;

    //
    // if ldap_open is called with a server name the api will call DsGetDcName 
    // passing the server name as the domainname parm...bad, because 
    // DsGetDcName will make a load of DNS queries based on the server name, 
    // it is designed to construct these queries from a domain name...so all 
    // these queries will be bogus, meaning they will waste network bandwidth,
    // time to fail, and worst case cause expensive on demand links to come up 
    // as referrals/forwarders are contacted to attempt to resolve the bogus 
    // names.  By setting LDAP_OPT_AREC_EXCLUSIVE to on using ldap_set_option 
    // after the ldap_init but before any other operation using the ldap 
    // handle from ldap_init, the delayed connection setup will not call 
    // DsGetDcName, just gethostbyname, or if an IP is passed, the ldap client 
    // will detect that and use the address directly.
    //
//    *ppLDAP = ldap_open(pszDC, LDAP_PORT);
    *ppLDAP = ldap_init(pszDC, LDAP_PORT);

    if(*ppLDAP == NULL)
    {
        dwErr = ERROR_PATH_NOT_FOUND;
    }
    else
    {
        //
        // set the options.
        //
        ulOptions = PtrToUlong(LDAP_OPT_ON);
        ldap_set_option(*ppLDAP, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions);

        //
        // Do a bind...
        //
        dwErr = ldap_bind_s(*ppLDAP,
                            NULL,
                            (PWCHAR)pCreds,
                            LDAP_AUTH_NEGOTIATE);
    }

    return(dwErr);
}

PVOID *
FrsSupFindValues(
    IN PLDAP        Ldap,
    IN PLDAPMessage Entry,
    IN PWCHAR       DesiredAttr,
    IN BOOL         DoBerVals
    )
/*++
Routine Description:
    Return the DS values for one attribute in an entry.

Arguments:
    Ldap        - An open, bound Ldap port.
    Entry       - An Ldap entry returned by Ldap_search_s()
    DesiredAttr - Return values for this attribute.
    DoBerVals   - Return the bervals (for binary data, v.s. WCHAR data)

Return Value:
    An array of char pointers that represents the values for the attribute.
    The caller must free the array with LDAP_FREE_VALUES().
    NULL if unsuccessful.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsSupFindValues:"
    PWCHAR          Attr;       // Retrieved from an Ldap entry
    BerElement      *Ber;       // Needed for scanning attributes

    //
    // Search the entry for the desired attribute
    //
    for (Attr = ldap_first_attribute(Ldap, Entry, &Ber);
         Attr != NULL;
         Attr = ldap_next_attribute(Ldap, Entry, Ber)) {

        if (WSTR_EQ(DesiredAttr, Attr)) {
            //
            // Return the values for DesiredAttr
            //
            if (DoBerVals) {
                return ldap_get_values_len(Ldap, Entry, Attr);
            } else {
                return ldap_get_values(Ldap, Entry, Attr);
            }
        }
    }
    return NULL;
}

PWCHAR
FrsSupWcsDup(
    PWCHAR OldStr
    )
/*++
Routine Description:
    Duplicate a string using our memory allocater

Arguments:
    OldArg  - string to duplicate

Return Value:
    Duplicated string. Free with FRS_SUP_FREE().
--*/
{
#undef DEBSUB
#define DEBSUB "FrsSupWcsDup:"

    PWCHAR  NewStr;

    //
    // E.g., when duplicating NodePartner when none exists
    //
    if (OldStr == NULL) {
        return NULL;
    }

    NewStr = malloc((wcslen(OldStr) + 1) * sizeof(WCHAR));
    if (NewStr != NULL) {
        wcscpy(NewStr, OldStr);
    }

    return NewStr;
}

PWCHAR
FrsSupFindValue(
    IN PLDAP        Ldap,
    IN PLDAPMessage Entry,
    IN PWCHAR       DesiredAttr
    )
/*++
Routine Description:
    Return a copy of the first DS value for one attribute in an entry.

Arguments:
    ldap        - An open, bound ldap port.
    Entry       - An ldap entry returned by ldap_search_s()
    DesiredAttr - Return values for this attribute.

Return Value:
    A zero-terminated string or NULL if the attribute or its value
    doesn't exist. The string is freed with FREE_NO_HEADER().
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsSupFindValue:"
    PWCHAR  Val;
    PWCHAR  *Values;

    // Get ldap's array of values
    Values = (PWCHAR *)FrsSupFindValues(Ldap, Entry, DesiredAttr, FALSE);

    // Copy the first value (if any)
    Val = (Values) ? FrsSupWcsDup(Values[0]) : NULL;

    // Free ldap's array of values
    LDAP_FREE_VALUES(Values);

    return Val;
}

BOOL
FrsSupLdapSearch(
    IN PLDAP        Ldap,
    IN PWCHAR       Base,
    IN ULONG        Scope,
    IN PWCHAR       Filter,
    IN PWCHAR       Attrs[],
    IN ULONG        AttrsOnly,
    IN LDAPMessage  **Msg
    )
/*++
Routine Description:
    Issue the ldap ldap_search_s call, check for errors, and check for
    a shutdown in progress.

Arguments:
    ldap        Session handle to Ldap server.

    Base        The distinguished name of the entry at which to start the search

    Scope
        LDAP_SCOPE_BASE     Search the base entry only.
        LDAP_SCOPE_ONELEVEL Search the base entry and all entries in the first
                            level below the base.
        LDAP_SCOPE_SUBTREE  Search the base entry and all entries in the tree
                            below the base.

    Filter      The search filter.

    Attrs       A null-terminated array of strings indicating the attributes
                to return for each matching entry. Pass NULL to retrieve all
                available attributes.

    AttrsOnly   A boolean value that should be zero if both attribute types
                and values are to be returned, nonzero if only types are wanted.

    mSG         Contains the results of the search upon completion of the call.
                The ldap array of values or NULL if the Base, DesiredAttr, or its
                values does not exist.
                The ldap array is freed with LDAP_FREE_VALUES().

Return Value:

    TRUE if not shutting down.

--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsSupLdapSearch:"

    DWORD           LStatus;

    *Msg  = NULL;

    //
    // Issue the ldap search
    //
    LStatus = ldap_search_ext_s(Ldap,
                                Base,
                                Scope,
                                Filter,
                                Attrs,
                                AttrsOnly,
                                NULL,
                                NULL,
                                &FrsSupLdapTimeout,
                                0,
                                Msg);

    //
    // Check for errors
    //
    if (LStatus != LDAP_SUCCESS) {

        //
        // Increment the DS Searches in Error counter
        //
        LDAP_FREE_MSG(*Msg);
        return FALSE;
    }

    return TRUE;
}

PWCHAR *
FrsSupGetValues(
    IN PLDAP Ldap,
    IN PWCHAR Base,
    IN PWCHAR DesiredAttr
    )
/*++
Routine Description:
    Return all of the DS values for one attribute in an object.

Arguments:
    ldap        - An open, bound ldap port.
    Base        - The "pathname" of a DS object.
    DesiredAttr - Return values for this attribute.

Return Value:
    The ldap array of values or NULL if the Base, DesiredAttr, or its values
    does not exist. The ldap array is freed with LDAP_FREE_VALUES().
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsSupGetValues:"

    PLDAPMessage    Msg = NULL; // Opaque stuff from ldap subsystem
    PWCHAR          *Values;    // Array of values for desired attribute

    //
    // Search Base for all of this attribute + values (objectCategory=*)
    //
    if (!FrsSupLdapSearch(Ldap, Base, LDAP_SCOPE_BASE, CATEGORY_ANY,
                         NULL, 0, &Msg)) {
        return NULL;
    }
    //
    // Return the values for the desired attribute
    //
    Values = (PWCHAR *)FrsSupFindValues(Ldap,
                                       ldap_first_entry(Ldap, Msg),
                                       DesiredAttr,
                                       FALSE);
    LDAP_FREE_MSG(Msg);
    return Values;
}

PWCHAR
FrsSupExtendDn(
    IN PWCHAR Dn,
    IN PWCHAR Cn
    )
/*++
Routine Description:
    Extend an existing DN with a new CN= component.

Arguments:
    Dn  - distinguished name
    Cn  - common name

Return Value:
    CN=Cn,Dn
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsExtendDn:"

    ULONG  Len;
    PWCHAR NewDn;

    if ((Dn == NULL) || (Cn == NULL)) {
        return NULL;
    }

    Len = wcslen(L"CN=,") + wcslen(Dn) + wcslen(Cn) + 1;
    NewDn = (PWCHAR)malloc(Len * sizeof(WCHAR));

    if (NewDn != NULL) {
        wcscpy(NewDn, L"CN=");
        wcscat(NewDn, Cn);
        wcscat(NewDn, L",");
        wcscat(NewDn, Dn);
    }
    return NewDn;
}

PWCHAR
FrsSupGetRootDn(
    PLDAP    Ldap,
    PWCHAR   NamingContext
    )
/*++
Routine Description:

Arguments:

Return Value:
--*/
{
    PWCHAR  Root;       // DS pathname of configuration container
    PWCHAR  *Values;    // values from the attribute "namingContexts"
    DWORD   NumVals;    // number of values

    //
    // Return all of the values for the attribute namingContexts
    //
    Values = FrsSupGetValues(Ldap, CN_ROOT, ATTR_NAMING_CONTEXTS);
    if (Values == NULL)
        return NULL;

    //
    // Find the naming context that begins with CN=Configuration
    //
    NumVals = ldap_count_values(Values);
    while (NumVals--) {
        Root = wcsstr(Values[NumVals], NamingContext);
        if (Root != NULL && Root == Values[NumVals]) {
            Root = FrsSupWcsDup(Root);
            ldap_value_free(Values);
            return Root;
        }
    }
    ldap_value_free(Values);
    return NULL;
}

BOOL
FrsSupLdapSearchInit(
    PLDAP        ldap,
    PWCHAR       Base,
    ULONG        Scope,
    PWCHAR       Filter,
    PWCHAR       Attrs[],
    ULONG        AttrsOnly,
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    )
/*++
Routine Description:
    Issue the ldap_create_page_control and  ldap_search_ext_s calls,
    FrsSupLdapSearchInit(), and FrsSupLdapSearchNext() APIs are used to
    make ldap queries and retrieve the results in paged form.

Arguments:
    ldap        Session handle to Ldap server.

    Base        The distinguished name of the entry at which to start the search.
                A copy of base is kept in the context.

    Scope

                LDAP_SCOPE_BASE     Search the base entry only.

                LDAP_SCOPE_ONELEVEL Search the base entry and all entries in the first
                                    level below the base.

                LDAP_SCOPE_SUBTREE  Search the base entry and all entries in the tree
                                    below the base.

    Filter      The search filter. A copy of filter is kept in the context.

    Attrs       A null-terminated array of strings indicating the attributes
                to return for each matching entry. Pass NULL to retrieve all
                available attributes.

    AttrsOnly   A boolean value that should be zero if both attribute types
                and values are to be returned, nonzero if only types are wanted.

    FrsSearchContext
                An opaques structure that links the FrsSupLdapSearchInit() and
                FrsSupLdapSearchNext() calls together. The structure contains
                the information required to retrieve query results across pages.

Return Value:

    BOOL result.

--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsSupLdapSearchInit:"

    DWORD           LStatus             = LDAP_SUCCESS;
    PLDAPControl    ServerControls[2];
    PLDAPControl    ServerControl       = NULL;
    UINT            i;
    LDAP_BERVAL     cookie1 = { 0, NULL };

    FrsSearchContext->LdapMsg = NULL;
    FrsSearchContext->CurrentLdapMsg = NULL;
    FrsSearchContext->EntriesInPage = 0;
    FrsSearchContext->CurrentEntry = 0;

    FrsSearchContext->BaseDn = FrsSupWcsDup(Base);
    FrsSearchContext->Filter = FrsSupWcsDup(Filter);
    FrsSearchContext->Scope = Scope;
    FrsSearchContext->Attrs = Attrs;


    LStatus = ldap_create_page_control(ldap,
                                      FRS_LDAP_SEARCH_PAGESIZE,
                                      &cookie1,
                                      FALSE, // is critical
                                      &ServerControl
                                     );

    ServerControls[0] = ServerControl;
    ServerControls[1] = NULL;

    if (LStatus != LDAP_SUCCESS) {
        FRS_SUP_FREE(FrsSearchContext->BaseDn);
        FRS_SUP_FREE(FrsSearchContext->Filter);
        return FALSE;
    }

    LStatus = ldap_search_ext_s(ldap,
                      FrsSearchContext->BaseDn,
                      FrsSearchContext->Scope,
                      FrsSearchContext->Filter,
                      FrsSearchContext->Attrs,
                      FALSE,
                      ServerControls,
                      NULL,
                      &FrsSupLdapTimeout,
                      0,
                      &FrsSearchContext->LdapMsg);

    ldap_control_free(ServerControl);

    if  (LStatus  == LDAP_SUCCESS) {
       FrsSearchContext->EntriesInPage = ldap_count_entries(ldap, FrsSearchContext->LdapMsg);
       FrsSearchContext->CurrentEntry = 0;
    }


    if (LStatus != LDAP_SUCCESS) {
        FRS_SUP_FREE(FrsSearchContext->BaseDn);
        FRS_SUP_FREE(FrsSearchContext->Filter);
        return FALSE;
    }

    return TRUE;
}

PLDAPMessage
FrsSupLdapSearchGetNextEntry(
    PLDAP        ldap,
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    )
/*++
Routine Description:
    Get the next entry form the current page of the results
    returned. This call is only made if there is a entry
    in the current page.

Arguments:
    ldap        Session handle to Ldap server.

    FrsSearchContext
                An opaques structure that links the FrsSupLdapSearchInit() and
                FrsSupLdapSearchNext() calls together. The structure contains
                the information required to retrieve query results across pages.

Return Value:

    The first or the next entry from the current page.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsSupLdapSearchGetNextEntry:"

    FrsSearchContext->CurrentEntry += 1;
    if ( FrsSearchContext->CurrentEntry == 1 ) {
        FrsSearchContext->CurrentLdapMsg = ldap_first_entry(ldap ,FrsSearchContext->LdapMsg);
    } else {
        FrsSearchContext->CurrentLdapMsg = ldap_next_entry(ldap ,FrsSearchContext->CurrentLdapMsg);
    }

    return FrsSearchContext->CurrentLdapMsg;
}

DWORD
FrsSupLdapSearchGetNextPage(
    PLDAP        ldap,
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    )
/*++
Routine Description:
    Get the next page from the results returned by ldap_search_ext_s..

Arguments:
    ldap        Session handle to Ldap server.

    FrsSearchContext
                An opaques structure that links the FrsSupLdapSearchInit() and
                FrsSupLdapSearchNext() calls together. The structure contains
                the information required to retrieve query results across pages.

Return Value:
    WINSTATUS

--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsSupLdapSearchGetNextPage:"

    DWORD                     LStatus = LDAP_SUCCESS;
    LDAP_BERVAL               * CurrCookie = NULL;
    PLDAPControl            * CurrControls = NULL;
    ULONG                     retcode = 0;
    ULONG                     TotalEntries = 0;
    PLDAPControl              ServerControls[2];
    PLDAPControl              ServerControl= NULL;



    // Get the server control from the message, and make a new control with the cookie from the server
    LStatus = ldap_parse_result(ldap, FrsSearchContext->LdapMsg, &retcode,NULL,NULL,NULL,&CurrControls,FALSE);
    LDAP_FREE_MSG(FrsSearchContext->LdapMsg);

    if (LStatus != LDAP_SUCCESS) {
        return LdapMapErrorToWin32(LStatus);
    }

    LStatus = ldap_parse_page_control(ldap, CurrControls, &TotalEntries, &CurrCookie);

    if (LStatus != LDAP_SUCCESS) {
        return LdapMapErrorToWin32(LStatus);
    }

    if ( CurrCookie->bv_len == 0 && CurrCookie->bv_val == 0 ) {
       LStatus = LDAP_CONTROL_NOT_FOUND;
       ldap_controls_free(CurrControls);
       ber_bvfree(CurrCookie);
       return LdapMapErrorToWin32(LStatus);
    }


    LStatus = ldap_create_page_control(ldap,
                            FRS_LDAP_SEARCH_PAGESIZE,
                            CurrCookie,
                            FALSE,
                            &ServerControl);

    ServerControls[0] = ServerControl;
    ServerControls[1] = NULL;

    ldap_controls_free(CurrControls);
    CurrControls = NULL;
    ber_bvfree(CurrCookie);
    CurrCookie = NULL;

    if (LStatus != LDAP_SUCCESS) {
        return LdapMapErrorToWin32(LStatus);
    }

    // continue the search with the new cookie
    LStatus = ldap_search_ext_s(ldap,
                   FrsSearchContext->BaseDn,
                   FrsSearchContext->Scope,
                   FrsSearchContext->Filter,
                   FrsSearchContext->Attrs,
                   FALSE,
                   ServerControls,
                   NULL,
                   &FrsSupLdapTimeout,
                   0,
                   &FrsSearchContext->LdapMsg);

    ldap_control_free(ServerControl);

    if (LStatus == LDAP_SUCCESS) {
        FrsSearchContext->EntriesInPage = ldap_count_entries(ldap, FrsSearchContext->LdapMsg);
        FrsSearchContext->CurrentEntry = 0;

    }

    return LdapMapErrorToWin32(LStatus);
}

PLDAPMessage
FrsSupLdapSearchNext(
    PLDAP        ldap,
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    )
/*++
Routine Description:
    Get the next entry form the current page of the results
    returned or from the next page if we are at the end of the.
    current page.

Arguments:
    ldap        Session handle to Ldap server.

    FrsSearchContext
                An opaques structure that links the FrsSupLdapSearchInit() and
                FrsSupLdapSearchNext() calls together. The structure contains
                the information required to retrieve query results across pages.

Return Value:

    The next entry on this page or the first entry from the next page.
    NULL if there are no more entries to return.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsSupLdapSearchNext:"

    DWORD         WStatus = ERROR_SUCCESS;
    PLDAPMessage  NextEntry = NULL;

    if (FrsSearchContext->EntriesInPage > FrsSearchContext->CurrentEntry )
    {
       // return the next entry from the current page
       return FrsSupLdapSearchGetNextEntry(ldap, FrsSearchContext);
    }
    else
    {
       // see if there are more pages of results to get
       WStatus = FrsSupLdapSearchGetNextPage(ldap, FrsSearchContext);
       if (WStatus == ERROR_SUCCESS)
       {
          return FrsSupLdapSearchGetNextEntry(ldap, FrsSearchContext);
       }
    }

    return NextEntry;
}

VOID
FrsSupLdapSearchClose(
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    )
/*++
Routine Description:
    The search is complete. Free the elemetns of the context and reset
    them so the same context can be used for another search.

Arguments:

    FrsSearchContext
                An opaques structure that links the FrsSupLdapSearchInit() and
                FrsSupLdapSearchNext() calls together. The structure contains
                the information required to retrieve query results across pages.

Return Value:

    NONE
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsSupLdapSearchClose:"

    FrsSearchContext->EntriesInPage = 0;
    FrsSearchContext->CurrentEntry = 0;

    FRS_SUP_FREE(FrsSearchContext->BaseDn);
    FRS_SUP_FREE(FrsSearchContext->Filter);
    LDAP_FREE_MSG(FrsSearchContext->LdapMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\test\dstree\dstree.cxx ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    dstree.cxx

Abstract:
    This module is a development tool. It creates dummy entries in the DS.
    The file replication service treats the dummy entries as a topology.
    Without this tool, creating interesting topologies would require many
    more machines than I have on hand.

    The command is run as, "dstree <command-file". command-file is a list
    of command lines and comment lines.

    Command lines are read from standard in, parsed, and then shipped
    off to the command subroutines. The command line syntax is:
        command,site,settings,server,connection,fromserver
    "command" is any of add|delete|list|show|quit. Leading whitespace is
    ignored. Whitespace between commas counts. The comma separated strings
    following "command" are optional. The command line can stop anytime
    after "command" and the command will on be applied to that portion
    of the "Distinquished Name".

    Comment lines are empty lines or lines that begin with /, #, or !.
    The files dstree.add and dstree.del are command files. They create
    and delete a bogus topology.

Author:
    Billy J. Fuller 3-Mar-1997 (From Jim McNelis)

Environment
    User mode winnt

--*/
#include <ntreppch.h>
#pragma  hdrstop
#include <frs.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <winsock2.h>
#include <ntdsapi.h>

#define FREE(_x_)   { if (_x_) free(_x_); _x_ = NULL; }


//
// Some useful DS object classes and object attributes
// that are not included in frs.h
//
#define CN_TEST_SETTINGS            L"NTFRS Test Settings"
#define ATTR_SYSTEM_FLAGS           L"systemFlags"
#define ATTR_SYSTEM_MAY_CONTAIN     L"systemMayContain"
#define ATTR_SYSTEM_MUST_CONTAIN    L"systemMustContain"
#define ATTR_SYSTEM_POSS_SUPERIORS  L"systemPossSuperiors"
#define SCHEMA_NAMING_CONTEXT       L"cn=schema"
#define ATTR_TRUE                   L"TRUE"
#define ATTR_OPTIONS_0              L"0"

//
// For DumpValues
//
PWCHAR   GuidAttrs[] = {
    L"objectGUID",
    L"schemaIDGUID",
    L"frsVersionGUID",
    NULL
};

PWCHAR   BerAttrs[] = {
    L"replPropertyMetaData",
    L"invocationId",
    L"defaultSecurityDescriptor",
    L"objectSid",
    L"lmPwdHistory",
    L"ntPwdHistory",
    L"oMObjectClass",
    NULL
};

//
// For HammerSchema
//
struct AlterAttr {
    PWCHAR  Attr;
    PWCHAR  Value;
};
struct AlterClass {
    PWCHAR  Cn;
    struct  AlterAttr    AlterAttrs[32];
};

struct AlterClass Computer = {
    L"Computer",
    L"mayContain",      L"frsComputerReferenceBL",
    NULL, NULL
};

struct AlterClass NtFrsSettings = {
    L"NTFRS-Settings",
    L"possSuperiors",   L"container",
    L"possSuperiors",   L"organization",
    L"possSuperiors",   L"organizationalUnit",
    L"mayContain",      L"managedBy",
    L"mayContain",      L"frsExtensions",
    NULL, NULL
};

struct AlterClass NtFrsReplicaSet = {
    L"NTFRS-Replica-Set",
    L"mayContain",  L"frsVersionGuid",
    L"mayContain",  L"FrsReplicaSetGuid",
    L"mayContain",  L"frsPrimaryMember",
    L"mayContain",  L"managedBy",
    L"mayContain",  L"frsReplicaSetType",
    L"mayContain",  L"frsDirectoryFilter",
    L"mayContain",  L"frsDSPoll",
    L"mayContain",  L"frsExtensions",
    L"mayContain",  L"frsFileFilter",
    L"mayContain",  L"frsFlags",
    L"mayContain",  L"frsLevelLimit",
    L"mayContain",  L"frsPartnerAuthLevel",
    L"mayContain",  L"frsRootSecurity",
    L"mayContain",  L"frsServiceCommand",
    NULL, NULL
};

struct AlterClass NtDsConnection = {
    L"NTDS-Connection",
    L"possSuperiors", L"nTFRSMember",
    NULL, NULL
};

struct AlterClass Dump = {
    L"Server-Reference",
    L"systemFlags", L"",
    NULL, NULL
};

//
// ATTRIBUTES
//

struct AlterClass FrsExtensions = {
    L"Frs-Extensions",
    L"cn",                  L"Frs-Extensions",
    L"adminDisplayName",    L"Frs-Extensions",
    L"adminDescription",    L"Frs-Extensions",
    L"lDAPDisplayName",     L"frsExtensions",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.82",
    L"oMSyntax",            L"4",
    L"attributeSyntax",     L"2.5.5.10",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"1",
    L"rangeUpper",          L"65536",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsVersionGuid = {
    L"Frs-Version-GUID",
    L"cn",                  L"Frs-Version-GUID",
    L"adminDisplayName",    L"Frs-Version-GUID",
    L"adminDescription",    L"Frs-Version-GUID",
    L"lDAPDisplayName",     L"frsVersionGUID",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.83",
    L"oMSyntax",            L"4",
    L"attributeSyntax",     L"2.5.5.10",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsReplicaSetGuid = {
    L"Frs-Replica-Set-GUID",
    L"cn",                  L"Frs-Replica-Set-GUID",
    L"adminDisplayName",    L"Frs-Replica-Set-GUID",
    L"adminDescription",    L"Frs-Replica-Set-GUID",
    L"lDAPDisplayName",     L"frsReplicaSetGUID",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.84",
    L"oMSyntax",            L"4",
    L"attributeSyntax",     L"2.5.5.10",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"16",
    L"rangeUpper",          L"16",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsDsPoll = {
    L"Frs-DS-Poll",
    L"cn",                  L"Frs-DS-Poll",
    L"adminDisplayName",    L"Frs-DS-Poll",
    L"adminDescription",    L"Frs-DS-Poll",
    L"lDAPDisplayName",     L"frsDSPoll",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.85",
    L"oMSyntax",            L"2",
    L"attributeSyntax",     L"2.5.5.9",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

//
// replica set types
//
struct AlterClass FrsReplicaSetType = {
    L"Frs-Replica-Set-Type",
    L"cn",                  L"Frs-Replica-Set-Type",
    L"adminDisplayName",    L"Frs-Replica-Set-Type",
    L"adminDescription",    L"Frs-Replica-Set-Type",
    L"lDAPDisplayName",     L"frsReplicaSetType",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.86",
    L"oMSyntax",            L"2",
    L"attributeSyntax",     L"2.5.5.9",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsDirectoryFilter = {
    L"Frs-Directory-Filter",
    L"cn",                  L"Frs-Directory-Filter",
    L"adminDisplayName",    L"Frs-Directory-Filter",
    L"adminDescription",    L"bjf l;kjlkj xyz",
    L"lDAPDisplayName",     L"frsDirectoryFilter",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.87",
    L"oMSyntax",            L"64",
    L"attributeSyntax",     L"2.5.5.12",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"1",
    L"rangeUpper",          L"1024",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

//
// OIDs out of sequence
//
struct AlterClass FrsControlDataCreation = {
    L"Frs-Control-Data-Creation",
    L"cn",                  L"Frs-Control-Data-Creation",
    L"adminDisplayName",    L"Frs-Control-Data-Creation",
    L"adminDescription",    L"bob",
    L"lDAPDisplayName",     L"frsControlDataCreation",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7002.00",
    L"oMSyntax",            L"64",
    L"attributeSyntax",     L"2.5.5.12",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"0",
    L"rangeUpper",          L"32",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsControlInboundBacklog = {
    L"Frs-Control-Inbound-Backlog",
    L"cn",                  L"Frs-Control-Inbound-Backlog",
    L"adminDisplayName",    L"Frs-Control-Inbound-Backlog",
    L"adminDescription",    L"george",
    L"lDAPDisplayName",     L"frsControlInboundBacklog",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7002.01",
    L"oMSyntax",            L"64",
    L"attributeSyntax",     L"2.5.5.12",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"0",
    L"rangeUpper",          L"32",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsControlOutboundBacklog = {
    L"Frs-Control-Outbound-Backlog",
    L"cn",                  L"Frs-Control-Outbound-Backlog",
    L"adminDisplayName",    L"Frs-Control-Outbound-Backlog",
    L"adminDescription",    L"Frs-Control-Outbound-Backlog",
    L"lDAPDisplayName",     L"frsControlOutboundBacklog",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7002.02",
    L"oMSyntax",            L"64",
    L"attributeSyntax",     L"2.5.5.12",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"0",
    L"rangeUpper",          L"32",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsFaultCondition = {
    L"Frs-Fault-Condition",
    L"cn",                  L"Frs-Fault-Condition",
    L"adminDisplayName",    L"Frs-Fault-Condition",
    L"adminDescription",    L"Frs-Fault-Condition",
    L"lDAPDisplayName",     L"frsFaultCondition",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7002.03",
    L"oMSyntax",            L"64",
    L"attributeSyntax",     L"2.5.5.12",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"1",
    L"rangeUpper",          L"16",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsVersion = {
    L"Frs-Version",
    L"cn",                  L"Frs-Version",
    L"adminDisplayName",    L"Frs-Version",
    L"adminDescription",    L"Frs-Version",
    L"lDAPDisplayName",     L"frsVersion",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7002.04",
    L"oMSyntax",            L"64",
    L"attributeSyntax",     L"2.5.5.12",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"0",
    L"rangeUpper",          L"32",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsPrimaryMember = {
    L"Frs-Primary-Member",
    L"cn",                  L"Frs-Primary-Member",
    L"adminDisplayName",    L"Frs-Primary-Member",
    L"adminDescription",    L"Frs-Primary-Member",
    L"lDAPDisplayName",     L"frsPrimaryMember",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7002.05",
    L"oMSyntax",            L"127",
    L"attributeSyntax",     L"2.5.5.1",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"systemFlags",         L"2",
    L"linkID",              L"104",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};
//
// END OIDs out of sequence
//

struct AlterClass FrsFileFilter = {
    L"Frs-File-Filter",
    L"cn",                  L"Frs-File-Filter",
    L"adminDisplayName",    L"Frs-File-Filter",
    L"adminDescription",    L"sue and and and",
    L"lDAPDisplayName",     L"frsFileFilter",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.88",
    L"oMSyntax",            L"64",
    L"attributeSyntax",     L"2.5.5.12",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"1",
    L"rangeUpper",          L"1024",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsFlags = {
    L"Frs-Flags",
    L"cn",                  L"Frs-Flags",
    L"adminDisplayName",    L"Frs-Flags",
    L"adminDescription",    L"Frs-Flags",
    L"lDAPDisplayName",     L"frsFlags",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.89",
    L"oMSyntax",            L"2",
    L"attributeSyntax",     L"2.5.5.9",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsLevelLimit = {
    L"Frs-Level-Limit",
    L"cn",                  L"Frs-Level-Limit",
    L"adminDisplayName",    L"Frs-Level-Limit",
    L"adminDescription",    L"Frs-Level-Limit",
    L"lDAPDisplayName",     L"frsLevelLimit",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.90",
    L"oMSyntax",            L"2",
    L"attributeSyntax",     L"2.5.5.9",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsPartnerAuthLevel = {
    L"Frs-Partner-Auth-Level",
    L"cn",                  L"Frs-Partner-Auth-Level",
    L"adminDisplayName",    L"Frs-Partner-Auth-Level",
    L"adminDescription",    L"Frs-Partner-Auth-Level",
    L"lDAPDisplayName",     L"frsPartnerAuthLevel",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.91",
    L"oMSyntax",            L"2",
    L"attributeSyntax",     L"2.5.5.9",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsRootSecurity = {
    L"Frs-Root-Security",
    L"cn",                  L"Frs-Root-Security",
    L"adminDisplayName",    L"Frs-Root-Security",
    L"adminDescription",    L"Frs-Root-Security",
    L"lDAPDisplayName",     L"frsRootSecurity",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.92",
    L"oMSyntax",            L"66",
    L"attributeSyntax",     L"2.5.5.15",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsServiceCommand = {
    L"Frs-Service-Command",
    L"cn",                  L"Frs-Service-Command",
    L"adminDisplayName",    L"Frs-Service-Command",
    L"adminDescription",    L"Frs-Service-Command",
    L"lDAPDisplayName",     L"frsServiceCommand",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.93",
    L"oMSyntax",            L"64",
    L"attributeSyntax",     L"2.5.5.12",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"0",
    L"rangeUpper",          L"512",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsUpdateTimeout = {
    L"Frs-Update-Timeout",
    L"cn",                  L"Frs-Update-Timeout",
    L"adminDisplayName",    L"Frs-Update-Timeout",
    L"adminDescription",    L"Frs-Update-Timeout",
    L"lDAPDisplayName",     L"frsUpdateTimeout",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.94",
    L"oMSyntax",            L"2",
    L"attributeSyntax",     L"2.5.5.9",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsWorkingPath = {
    L"Frs-Working-Path",
    L"cn",                  L"Frs-Working-Path",
    L"adminDisplayName",    L"Frs-Working-Path",
    L"adminDescription",    L"Frs-Working-Path",
    L"lDAPDisplayName",     L"frsWorkingPath",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.95",
    L"oMSyntax",            L"64",
    L"attributeSyntax",     L"2.5.5.12",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"0",
    L"rangeUpper",          L"512",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsStagingPath = {
    L"Frs-Staging-Path",
    L"cn",                  L"Frs-Staging-Path",
    L"adminDisplayName",    L"Frs-Staging-Path",
    L"adminDescription",    L"Frs-Staging-Path",
    L"lDAPDisplayName",     L"frsStagingPath",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.96",
    L"oMSyntax",            L"64",
    L"attributeSyntax",     L"2.5.5.12",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"0",
    L"rangeUpper",          L"512",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsServiceCommandStatus = {
    L"Frs-Service-Command-Status",
    L"cn",                  L"Frs-Service-Command-Status",
    L"adminDisplayName",    L"Frs-Service-Command-Status",
    L"adminDescription",    L"frsServiceCommandStatus",
    L"lDAPDisplayName",     L"frsServiceCommandStatus",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.98",
    L"oMSyntax",            L"64",
    L"attributeSyntax",     L"2.5.5.12",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"0",
    L"rangeUpper",          L"512",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsTimeLastCommand = {
    L"Frs-Time-Last-Command",
    L"cn",                  L"Frs-Time-Last-Command",
    L"adminDisplayName",    L"Frs-Time-Last-Command",
    L"adminDescription",    L"Frs-Time-Last-Command",
    L"lDAPDisplayName",     L"frsTimeLastCommand",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7000.99",
    L"oMSyntax",            L"23",
    L"attributeSyntax",     L"2.5.5.11",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsTimeLastConfigChange = {
    L"Frs-Time-Last-Config-Change",
    L"cn",                  L"Frs-Time-Last-Config-Change",
    L"adminDisplayName",    L"Frs-Time-Last-Config-Change",
    L"adminDescription",    L"Frs-Time-Last-Config-Change",
    L"lDAPDisplayName",     L"frsTimeLastConfigChange",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7001.01",
    L"oMSyntax",            L"23",
    L"attributeSyntax",     L"2.5.5.11",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsRootPath = {
    L"Frs-Root-Path",
    L"cn",                  L"Frs-Root-Path",
    L"adminDisplayName",    L"Frs-Root-Path",
    L"adminDescription",    L"Frs-Root-Path",
    L"lDAPDisplayName",     L"frsRootPath",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7001.02",
    L"oMSyntax",            L"64",
    L"attributeSyntax",     L"2.5.5.12",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"rangeLower",          L"0",
    L"rangeUpper",          L"512",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsComputerReference = {
    L"Frs-Computer-Reference",
    L"cn",                  L"Frs-Computer-Reference",
    L"adminDisplayName",    L"Frs-Computer-Reference",
    L"adminDescription",    L"Frs-Computer-Reference",
    L"lDAPDisplayName",     L"frsComputerReference",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7001.03",
    L"oMSyntax",            L"127",
    L"attributeSyntax",     L"2.5.5.1",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"systemFlags",         L"2",
    L"linkID",              L"100",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsComputerReferenceBl = {
    L"Frs-Computer-Reference-BL",
    L"cn",                  L"Frs-Computer-Reference-BL",
    L"adminDisplayName",    L"Frs-Computer-Reference-BL",
    L"adminDescription",    L"Frs-Computer-Reference-BL",
    L"lDAPDisplayName",     L"frsComputerReferenceBL",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7001.04",
    L"oMSyntax",            L"127",
    L"attributeSyntax",     L"2.5.5.1",
    L"isSingleValued",      L"FALSE",
    L"systemOnly",          L"FALSE",
    L"linkID",              L"101",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsMemberReference = {
    L"Frs-Member-Reference",
    L"cn",                  L"Frs-Member-Reference",
    L"adminDisplayName",    L"Frs-Member-Reference",
    L"adminDescription",    L"Frs-Member-Reference",
    L"lDAPDisplayName",     L"frsMemberReference",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7001.05",
    L"oMSyntax",            L"127",
    L"attributeSyntax",     L"2.5.5.1",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"systemFlags",         L"2",
    L"linkID",              L"102",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

struct AlterClass FrsMemberReferenceBl = {
    L"Frs-Member-Reference-BL",
    L"cn",                  L"Frs-Member-Reference-BL",
    L"adminDisplayName",    L"Frs-Member-Reference-BL",
    L"adminDescription",    L"Frs-Member-Reference-BL",
    L"lDAPDisplayName",     L"frsMemberReferenceBL",
    L"objectClass",         L"attributeSchema",
    L"attributeId",         L"1.2.840.113556.1.4.7001.06",
    L"oMSyntax",            L"127",
    L"attributeSyntax",     L"2.5.5.1",
    L"isSingleValued",      L"TRUE",
    L"systemOnly",          L"FALSE",
    L"linkID",              L"103",
    L"hideFromAB",          L"TRUE",
    NULL, NULL
};

//
// CLASSES
//
struct AlterClass NtFrsMember = {
    L"NTFRS-Member",
    L"cn",                    L"NTFRS-Member",
    L"adminDisplayName",      L"NTFRS-Member",
    L"adminDescription",      L"NTFRS-Member",
    L"lDAPDisplayName",       L"nTFRSMember",
    L"objectClass",           L"classSchema",
    L"rDNAttID",              L"cn",
    L"defaultHidingValue",    L"TRUE",
    L"hideFromAB",            L"TRUE",
    L"subClassOf",            L"leaf",
    L"systemOnly",            L"FALSE",
    L"governsId",             L"1.2.840.113556.1.4.7001.07",
    L"objectClassCategory",   L"1",
    NULL, NULL
};

struct AlterClass NtFrsSubscriptions = {
    L"NTFRS-Subscriptions",
    L"cn",                    L"NTFRS-Subscriptions",
    L"adminDisplayName",      L"NTFRS-Subscriptions",
    L"adminDescription",      L"NTFRS-Subscriptions",
    L"lDAPDisplayName",       L"nTFRSSubscriptions",
    L"objectClass",           L"classSchema",
    L"rDNAttID",              L"cn",
    L"defaultHidingValue",    L"TRUE",
    L"hideFromAB",            L"TRUE",
    L"subClassOf",            L"leaf",
    L"systemOnly",            L"FALSE",
    L"governsId",             L"1.2.840.113556.1.4.7001.08",
    L"objectClassCategory",   L"1",
    NULL, NULL
};

struct AlterClass NtFrsSubscriber = {
    L"NTFRS-Subscriber",
    L"cn",                    L"NTFRS-Subscriber",
    L"adminDisplayName",      L"NTFRS-Subscriber",
    L"adminDescription",      L"NTFRS-Subscriber",
    L"lDAPDisplayName",       L"nTFRSSubscriber",
    L"objectClass",           L"classSchema",
    L"rDNAttID",              L"cn",
    L"defaultHidingValue",    L"TRUE",
    L"hideFromAB",            L"TRUE",
    L"subClassOf",            L"leaf",
    L"systemOnly",            L"FALSE",
    L"governsId",             L"1.2.840.113556.1.4.7001.09",
    L"objectClassCategory",   L"1",
    NULL, NULL
};

struct AlterClass NtFrsMemberEx = {
    L"NTFRS-Member",
    L"possSuperiors",         L"nTFRSReplicaSet",
    L"mayContain",            L"frsExtensions",
    L"mayContain",            L"frsPartnerAuthLevel",
    L"mayContain",            L"frsRootSecurity",
    L"mayContain",            L"frsServiceCommand",
    L"mayContain",            L"schedule",
    L"mayContain",            L"frsComputerReference",
    L"mayContain",            L"ServerReference",
    L"mayContain",            L"frsMemberReferenceBL",
    L"mayContain",            L"frsUpdateTimeout",
    L"mayContain",            L"frsControlDataCreation",
    L"mayContain",            L"frsControlInboundBacklog",
    L"mayContain",            L"frsControlOutboundBacklog",
    L"mayContain",            L"frsFlags",
    NULL, NULL
};

struct AlterClass NtFrsSubscriptionsEx = {
    L"NTFRS-Subscriptions",
    L"possSuperiors",         L"computer",
    L"possSuperiors",         L"nTFRSSubscriptions",
    L"mayContain",            L"frsWorkingPath",
    L"mayContain",            L"frsVersion",
    L"mayContain",            L"frsExtensions",
    NULL, NULL
};

struct AlterClass NtFrsSubscriberEx = {
    L"NTFRS-Subscriber",
    L"possSuperiors",         L"nTFRSSubscriptions",
    L"mustContain",           L"frsRootPath",
    L"mustContain",           L"frsStagingPath",
    L"mayContain",            L"frsExtensions",
    L"mayContain",            L"frsFlags",
    L"mayContain",            L"frsFaultCondition",
    L"mayContain",            L"frsMemberReference",
    L"mayContain",            L"frsUpdateTimeout",
    L"mayContain",            L"frsServiceCommand",
    L"mayContain",            L"frsServiceCommandStatus",
    L"mayContain",            L"schedule",
    L"mayContain",            L"frsTimeLastCommand",
    L"mayContain",            L"frsTimeLastConfigChange",
    NULL, NULL
};

//
// CREATE ATTRIBUTES
//
struct AlterClass   *CreateAttributes[] = {
    &FrsExtensions,
    &FrsVersionGuid,
    &FrsReplicaSetGuid,
    &FrsDsPoll,
    &FrsReplicaSetType,
    &FrsDirectoryFilter,
    &FrsFileFilter,
    &FrsFlags,
    &FrsLevelLimit,
    &FrsPartnerAuthLevel,
    &FrsRootSecurity,
    &FrsServiceCommand,
    &FrsUpdateTimeout,
    &FrsWorkingPath,
    &FrsStagingPath,
    &FrsServiceCommandStatus,
    &FrsTimeLastCommand,
    &FrsTimeLastConfigChange,
    &FrsRootPath,
    &FrsComputerReference,
    &FrsComputerReferenceBl,
    &FrsMemberReference,
    &FrsMemberReferenceBl,
    &FrsControlDataCreation,
    &FrsControlInboundBacklog,
    &FrsControlOutboundBacklog,
    &FrsFaultCondition,
    &FrsVersion,
    &FrsPrimaryMember,
    NULL
};

//
// CREATE CLASSES
//
struct AlterClass   *CreateClasses[] = {
    &NtFrsMember,
    &NtFrsSubscriptions,
    &NtFrsSubscriber,
    NULL
};

//
// ALTER EXISTING CLASSES
//
struct AlterClass   *AlterSchema[] = {
    &Computer,
    &NtFrsSettings,
    &NtFrsReplicaSet,
    &NtDsConnection,
    &NtFrsMemberEx,
    &NtFrsSubscriptionsEx,
    &NtFrsSubscriberEx,
    NULL
};


PWCHAR
MakeRdn(
    IN PWCHAR DN
    )
/*++
Routine Description:
    Extract the base component (relative distinguished name) from a
    distinguished name. The distinguished name is assumed to be in
    DS format (CN=xyz,CN=next one,...). In this case, the returned
    RDN is "xyz".

Arguments:
    DN      - distinguished name

Return Value:
    A zero-terminated string. The string is freed with FREE_NO_HEADER().
--*/
{
    DWORD   RDNLen;
    PWCHAR  RDN;

    if (DN == NULL) {
        return NULL;
    }

    // Skip the first CN=; if any
    RDN = wcsstr(DN, L"CN=");
    if (RDN == DN)
        DN += 3;

    // Return the string up to the first delimiter or EOS
    RDNLen = wcscspn(DN, L",");
    RDN = (PWCHAR)malloc(sizeof(WCHAR) * (RDNLen + 1));
    wcsncpy(RDN, DN, RDNLen);
    RDN[RDNLen] = L'\0';

    return RDN;
}


PWCHAR
FrsDsMakeParentDn(
    IN PWCHAR Dn
    )
/*++
Routine Description:

Arguments:

Return Value:
--*/
{
    DWORD   PLen;

    if (Dn == NULL) {
        return NULL;
    }

    PLen = wcscspn(Dn, L",");
    if (Dn[PLen] != L',') {
        return NULL;
    }
    return FrsWcsDup(&Dn[PLen + 1]);
}



VOID
AddMod(
    IN PWCHAR AttrType,
    IN PWCHAR AttrValue,
    IN OUT LDAPMod ***pppMod
    )
/*++
Routine Description:
    Add an attribute (plus values) to a structure that will eventually be
    used in an ldap_add() function to add an object to the DS. The null-
    terminated array referenced by pppMod grows with each call to this
    routine. The array is freed by the caller using FreeMod().

Arguments:
    AttrType        - The object class of the object.
    AttrValue       - The value of the attribute.
    pppMod          - Address of an array of pointers to "attributes". Don't
                      give me that look -- this is an LDAP thing.

Return Value:
    The pppMod array grows by one entry. The caller must free it with
    FreeMod().
--*/
{
    DWORD   NumMod;     // Number of entries in the Mod array
    LDAPMod **ppMod;    // Address of the first entry in the Mod array
    LDAPMod *Attr;      // An attribute structure
    PWCHAR   *Values;    // An array of pointers to bervals

    if (AttrValue == NULL)
        return;

    //
    // The null-terminated array doesn't exist; create it
    //
    if (*pppMod == NULL) {
        *pppMod = (LDAPMod **)malloc(sizeof (*pppMod));
        **pppMod = NULL;
    }

    //
    // Increase the array's size by 1
    //
    for (ppMod = *pppMod, NumMod = 2; *ppMod != NULL; ++ppMod, ++NumMod);
    *pppMod = (LDAPMod **)realloc(*pppMod, sizeof (*pppMod) * NumMod);

    //
    // Add the new attribute + value to the Mod array
    //
    Values = (PWCHAR *)malloc(sizeof (PWCHAR) * 2);
    Values[0] = _wcsdup(AttrValue);
    Values[1] = NULL;

    Attr = (LDAPMod *)malloc(sizeof (*Attr));
    Attr->mod_values = Values;
    Attr->mod_type = _wcsdup(AttrType);
    Attr->mod_op = LDAP_MOD_ADD;

    (*pppMod)[NumMod - 1] = NULL;
    (*pppMod)[NumMod - 2] = Attr;
}


VOID
AddBerMod(
    IN PWCHAR AttrType,
    IN PCHAR AttrValue,
    IN DWORD AttrValueLen,
    IN OUT LDAPMod ***pppMod
    )
/*++
Routine Description:
    Add an attribute (plus values) to a structure that will eventually be
    used in an ldap_add() function to add an object to the DS. The null-
    terminated array referenced by pppMod grows with each call to this
    routine. The array is freed by the caller using FreeMod().

Arguments:
    AttrType        - The object class of the object.
    AttrValue       - The value of the attribute.
    AttrValueLen    - length of the attribute
    pppMod          - Address of an array of pointers to "attributes". Don't
                      give me that look -- this is an LDAP thing.

Return Value:
    The pppMod array grows by one entry. The caller must free it with
    FreeMod().
--*/
{
    DWORD   NumMod;     // Number of entries in the Mod array
    LDAPMod **ppMod;    // Address of the first entry in the Mod array
    LDAPMod *Attr;      // An attribute structure
    PLDAP_BERVAL    Berval;
    PLDAP_BERVAL    *Values;    // An array of pointers to bervals

    if (AttrValue == NULL)
        return;

    //
    // The null-terminated array doesn't exist; create it
    //
    if (*pppMod == NULL) {
        *pppMod = (LDAPMod **)malloc(sizeof (*pppMod));
        **pppMod = NULL;
    }

    //
    // Increase the array's size by 1
    //
    for (ppMod = *pppMod, NumMod = 2; *ppMod != NULL; ++ppMod, ++NumMod);
    *pppMod = (LDAPMod **)realloc(*pppMod, sizeof (*pppMod) * NumMod);

    //
    // Construct a berval
    //
    Berval = (PLDAP_BERVAL)malloc(sizeof(LDAP_BERVAL));
    Berval->bv_len = AttrValueLen;
    Berval->bv_val = (PCHAR)malloc(AttrValueLen);
    CopyMemory(Berval->bv_val, AttrValue, AttrValueLen);

    //
    // Add the new attribute + value to the Mod array
    //
    Values = (PLDAP_BERVAL *)malloc(sizeof (PLDAP_BERVAL) * 2);
    Values[0] = Berval;
    Values[1] = NULL;

    Attr = (LDAPMod *)malloc(sizeof (*Attr));
    Attr->mod_bvalues = Values;
    Attr->mod_type = _wcsdup(AttrType);
    Attr->mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;

    (*pppMod)[NumMod - 1] = NULL;
    (*pppMod)[NumMod - 2] = Attr;
}


VOID
FreeMod(
    IN OUT LDAPMod ***pppMod
    )
/*++
Routine Description:
    Free the structure built by successive calls to AddMod().

Arguments:
    pppMod  - Address of a null-terminated array.

Return Value:
    *pppMod set to NULL.
--*/
{
    DWORD   i, j;
    LDAPMod **ppMod;

    if (!pppMod || !*pppMod) {
        return;
    }

    //
    // For each attibute
    //
    ppMod = *pppMod;
    for (i = 0; ppMod[i] != NULL; ++i) {
        //
        // For each value of the attribute
        //
        for (j = 0; (ppMod[i])->mod_values[j] != NULL; ++j) {
            //
            // Free the value
            //
            if (ppMod[i]->mod_op & LDAP_MOD_BVALUES) {
                free(ppMod[i]->mod_bvalues[j]->bv_val);
            }
            free((ppMod[i])->mod_values[j]);
        }
        free((ppMod[i])->mod_values);   // Free the array of pointers to values
        free((ppMod[i])->mod_type);     // Free the string identifying the attribute
        free(ppMod[i]);                 // Free the attribute
    }
    free(ppMod);        // Free the array of pointers to attributes
    *pppMod = NULL;     // Now ready for more calls to AddMod()
}


BOOL
LdapSearch(
    IN PLDAP        ldap,
    IN PWCHAR       Base,
    IN ULONG        Scope,
    IN PWCHAR       Filter,
    IN PWCHAR       Attrs[],
    IN ULONG        AttrsOnly,
    IN LDAPMessage  **Res,
    IN BOOL         Quiet
    )
/*++
Routine Description:
    Issue the ldap ldap_search_s call, check for errors, and check for
    a shutdown in progress.

Arguments:
    ldap
    Base
    Scope
    Filter
    Attrs
    AttrsOnly
    Res

Return Value:
    The ldap array of values or NULL if the Base, DesiredAttr, or its values
    does not exist. The ldap array is freed with ldap_value_free().
--*/
{
    DWORD LStatus;

    //
    // Issue the ldap search
    //
    LStatus = ldap_search_s(ldap, Base, Scope, Filter, Attrs, AttrsOnly, Res);
    //
    // Check for errors
    //
    if (LStatus != LDAP_SUCCESS) {
        if (!Quiet) {
            fprintf(stderr, "WARN - Error searching %ws for %ws; LStatus %d: %ws\n",
                    Base, Filter, LStatus, ldap_err2string(LStatus));
        }
        return FALSE;
    }
    //
    // Return TRUE if not shutting down
    //
    return TRUE;
}


BOOL
FrsDsVerifySchedule(
    IN PWCHAR    Name,
    IN ULONG     ScheduleLength,
    IN PSCHEDULE Schedule
    )
/*++
Routine Description:
    Check the schedule for consistency

Arguments:
    Name
    Schedule

Return Value:
    None.
--*/
{
    ULONG       i, j;
    ULONG       Num;
    ULONG       Len;
    ULONG       NumType;
    PUCHAR      NewScheduleData;
    PUCHAR      OldScheduleData;

    if (!Schedule) {
        return TRUE;
    }

    //
    //  Too many schedules
    //
    Num = Schedule->NumberOfSchedules;
    if (Num > 3) {
        fprintf(stderr, "%ws has %d schedules\n", Name, Num);
        return FALSE;
    }

    //
    //  Too few schedules
    //
    if (Num < 1) {
        fprintf(stderr, "%ws has %d schedules\n", Name, Num);
        return FALSE;
    }

    //
    //  Not enough memory
    //
    Len = sizeof(SCHEDULE) +
          (sizeof(SCHEDULE_HEADER) * (Num - 1)) +
          (SCHEDULE_DATA_BYTES * Num);

    if (ScheduleLength < Len) {
        fprintf(stderr, "%ws is short (ds) by %d bytes (%d - %d), %d\n",
                Name,
                Len - ScheduleLength,
                Len,
                ScheduleLength,
                Schedule->Size);
        return FALSE;
    }

    if (Schedule->Size < Len) {
        fprintf(stderr, "%ws is short (size) by %d bytes (%d - %d), %d\n",
                Name,
                Len - Schedule->Size,
                Len,
                Schedule->Size,
                Schedule->Size);
        return FALSE;
    }
    Schedule->Size = Len;

    //
    //  Invalid type
    //
    for (i = 0; i < Num; ++i) {
        switch (Schedule->Schedules[i].Type) {
            case SCHEDULE_INTERVAL:
                break;
            case SCHEDULE_BANDWIDTH:
                break;
            case SCHEDULE_PRIORITY:
                break;
            default:
                fprintf(stderr, "%ws has an invalid schedule type (%d)\n",
                        Name,
                        Schedule->Schedules[i].Type);
                return FALSE;
        }
    }

    //
    // Only 0 or 1 interval
    //
    for (NumType = i = 0; i < Num; ++i)
        if (Schedule->Schedules[i].Type == SCHEDULE_INTERVAL)
            ++NumType;
    if (NumType > 1) {
        fprintf(stderr, "%ws has %d interval schedules\n",
                Name,
                NumType);
        return FALSE;
    }

    //
    // Only 0 or 1 bandwidth
    //
    for (NumType = i = 0; i < Num; ++i)
        if (Schedule->Schedules[i].Type == SCHEDULE_BANDWIDTH)
            ++NumType;
    if (NumType > 1) {
        fprintf(stderr, "%ws has %d bandwidth schedules\n",
                Name,
                NumType);
        return FALSE;
    }

    //
    // Only 0 or 1 priority
    //
    for (NumType = i = 0; i < Num; ++i)
        if (Schedule->Schedules[i].Type == SCHEDULE_PRIORITY)
            ++NumType;
    if (NumType > 1) {
        fprintf(stderr, "%ws has %d priority schedules\n",
                Name,
                NumType);
        return FALSE;
    }

    //
    //  Invalid offset
    //
    for (i = 0; i < Num; ++i) {
        if (Schedule->Schedules[i].Offset >
            ScheduleLength - SCHEDULE_DATA_BYTES) {
            fprintf(stderr, "%ws has an invalid offset (%d)\n",
                    Name,
                    Schedule->Schedules[i].Offset);
            return FALSE;
        }
    }
    return TRUE;
}


VOID
PrintShortSchedule(
    IN PWCHAR    Indent,
    IN PSCHEDULE Schedule,
    IN ULONG     ScheduleLen
    )
/*++
Routine Description:
    Print a short form of the schedule

Arguments:

Return Value:
    None.
--*/
{
    ULONG       i;

    if (!FrsDsVerifySchedule(L"<unknown>", ScheduleLen, Schedule)) {
        return;
    }

    if (!Schedule || !Schedule->NumberOfSchedules) {
        printf("%wsSchedule=\n", Indent);
        return;
    }

    for (i = 0; i < Schedule->NumberOfSchedules; ++i) {
        if (!i) {
            printf("%wsSchedule=Type %d", Indent, Schedule->Schedules[i].Type);
        } else {
            printf(", %d", Schedule->Schedules[i].Type);
        }
    }
    printf("\n");
}


VOID
PrintLongSchedule(
    IN PWCHAR    Indent1,
    IN PWCHAR    Indent2,
    IN PSCHEDULE Schedule,
    IN ULONG     ScheduleLen
    )
/*++
Routine Description:
    Print a short form of the schedule

Arguments:

Return Value:
    None.
--*/
{
    ULONG   i;
    ULONG   Day;
    ULONG   Hour;
    BOOL    PrintIt;
    PUCHAR  ScheduleData;

    if (!FrsDsVerifySchedule(L"<unknown>", ScheduleLen, Schedule)) {
        return;
    }

    if (!Schedule || !Schedule->NumberOfSchedules) {
        printf("%ws%wsSchedule=\n", Indent1, Indent2);
        return;
    }
    for (i = 0; i < Schedule->NumberOfSchedules; ++i) {
        if (!i) {
            printf("%ws%wsSchedule=Type %d",
                   Indent1,
                   Indent2,
                   Schedule->Schedules[i].Type);
        } else {
            printf(", %d", Schedule->Schedules[i].Type);
        }
    }
    printf("\n");

    for (i = 0; i < Schedule->NumberOfSchedules; ++i) {
        ScheduleData = ((PUCHAR)Schedule) + Schedule->Schedules[i].Offset;
        if (Schedule->Schedules[i].Type != SCHEDULE_INTERVAL) {
            continue;
        }
        for (Day = 0; Day < 7; ++Day) {
            if (Day) {
                PrintIt = FALSE;
                for (Hour = 0; Hour < 24; ++Hour) {
                    if (*(ScheduleData + (Day * 24) + Hour) !=
                        *(ScheduleData + ((Day - 1) * 24) + Hour)) {
                        PrintIt = TRUE;
                        break;
                    }
                }
            } else {
                PrintIt = TRUE;
            }
            if (!PrintIt) {
                continue;
            }
            printf("%ws%ws   Day %1d: ", Indent1, Indent2, Day + 1);
            for (Hour = 0; Hour < 24; ++Hour) {
                printf("%1x", *(ScheduleData + (Day * 24) + Hour) & 0x0F);
            }
            printf("\n");
        }
        printf("\n");
    }
}


VOID
PrintSchedule(
    IN PSCHEDULE Schedule
    )
/*++
Routine Description:
    Print the schedule

Arguments:
    Schedule

Return Value:
    None.
--*/
{
    ULONG       i;

    if (Schedule) for (i = 0; i < Schedule->NumberOfSchedules; ++i) {
        printf("    Schedule %d\n", i);
        printf("        Type  : %d\n", Schedule->Schedules[i].Type);
        printf("        Offset: %d\n", Schedule->Schedules[i].Offset);
    }
}


PCHAR
FrsWtoA(
    PWCHAR Wstr
    )
/*++
Routine Description:
    Translate a wide char string into a newly allocated char string.

Arguments:
    Wstr - wide char string

Return Value:
    Duplicated string. Free with FrsFree().
--*/
{
    PCHAR   Astr;

    //
    // E.g., when duplicating NodePartner when none exists
    //
    if (Wstr == NULL)
        return NULL;

    Astr = (PCHAR)malloc(wcslen(Wstr) + 1);
    sprintf(Astr, "%ws", Wstr);

    return Astr;
}


PWCHAR
FrsAtoW(
    PCHAR Astr
    )
/*++
Routine Description:
    Translate a wide char string into a newly allocated char string.

Arguments:
    Wstr - wide char string

Return Value:
    Duplicated string. Free with FrsFree().
--*/
{
    PWCHAR   Wstr;

    //
    // E.g., when duplicating NodePartner when none exists
    //
    if (Astr == NULL) {
        return NULL;
    }

    Wstr = (PWCHAR)malloc((strlen(Astr) + 1) * sizeof(WCHAR));
    swprintf(Wstr, L"%hs", Astr);

    return Wstr;
}


PWCHAR
FrsWcsDup(
    PWCHAR OldStr
    )
/*++
Routine Description:
    Duplicate a string using our memory allocater

Arguments:
    OldArg  - string to duplicate

Return Value:
    Duplicated string. Free with FrsFree().
--*/
{
    PWCHAR  NewStr;

    //
    // E.g., when duplicating NodePartner when none exists
    //
    if (OldStr == NULL)
            return NULL;

    NewStr = (PWCHAR)malloc((wcslen(OldStr) + 1) * sizeof(WCHAR));
    wcscpy(NewStr, OldStr);

    return NewStr;
}


PWCHAR
FrsWcsCat(
    PWCHAR First,
    PWCHAR Second
    )
/*++
Routine Description:
    Concatenate two strings into a new string using our memory allocater

Arguments:
    First   - First string in the concat
    Second  - Second string in the concat

Return Value:
    Duplicated and concatentated string. Free with FrsFree().
--*/
{
    DWORD   Bytes;
    PWCHAR  New;

    // size of new string
    Bytes = (wcslen(First) + wcslen(Second) + 1) * sizeof(WCHAR);
    New = (PWCHAR)malloc(Bytes);

    // Not as efficient as I would like but this routine is seldom used
    wcscpy(New, First);
    wcscat(New, Second);

    return New;
}


ULONG NumSchedules;
VOID
ConditionalBuildSchedule(
    PSCHEDULE   *Schedule,
    PULONG      ScheduleLength
    )

/*++
Routine Description:
    Build a schedule with the specified number of schedules

Arguments:
    Schedule
    ScheduleLength

Return Value:
    Schedule or NULL. Free with free();
--*/
{
    PBYTE   ScheduleData;
    ULONG   j;

    //
    // No schedule, yet
    //
    *Schedule = NULL;
    *ScheduleLength = 0;

    //
    // Create variable sized schedules
    //
    ++NumSchedules;
    if (NumSchedules > 3) {
        NumSchedules = 1;   // shouldn't always create schedule
    }
    if (NumSchedules == 0) {
        return;
    }

    //
    // Construct a phoney schedule; always "on"
    //
    *ScheduleLength = sizeof(SCHEDULE) +
                      ((NumSchedules - 1) * sizeof(SCHEDULE_HEADER)) +
                      (NumSchedules * SCHEDULE_DATA_BYTES);

    *Schedule = (PSCHEDULE)malloc(*ScheduleLength);
    ZeroMemory(*Schedule, *ScheduleLength);
    (*Schedule)->Size = *ScheduleLength;
    (*Schedule)->NumberOfSchedules = NumSchedules;
    (*Schedule)->Schedules[0].Type = SCHEDULE_INTERVAL;
    (*Schedule)->Schedules[0].Offset = sizeof(SCHEDULE) +
                                       ((NumSchedules - 1) * sizeof(SCHEDULE_HEADER)) +
                                       (0 * SCHEDULE_DATA_BYTES);
    if (NumSchedules == 1) {
        goto setschedule;
    }
    (*Schedule)->Schedules[1].Type = SCHEDULE_PRIORITY;
    (*Schedule)->Schedules[1].Offset = sizeof(SCHEDULE) +
                                       ((NumSchedules - 1) * sizeof(SCHEDULE_HEADER)) +
                                       (1 * SCHEDULE_DATA_BYTES);
    if (NumSchedules == 2) {
        goto setschedule;
    }
    (*Schedule)->Schedules[2].Type = SCHEDULE_BANDWIDTH;
    (*Schedule)->Schedules[2].Offset = sizeof(SCHEDULE) +
                                       ((NumSchedules - 1) * sizeof(SCHEDULE_HEADER)) +
                                       (2 * SCHEDULE_DATA_BYTES);
    if (NumSchedules == 3) {
        goto setschedule;
    }

setschedule:
    ScheduleData = ((PBYTE)(*Schedule));
    for (j = 0; j < (SCHEDULE_DATA_BYTES * NumSchedules); ++j) {
        *(ScheduleData + (*Schedule)->Schedules[0].Offset + j) = 0xff;
    }
}


DWORD
FrsDsGetDcInfo(
    IN PDOMAIN_CONTROLLER_INFO *DcInfo,
    IN DWORD Flags
    )
/*++
Routine Description:
    Open and bind to a dc

Arguments:
    DcInfo  - Dc Info
    Flags   - DsGetDcName(Flags)

Return Value:
    DsGetDcName
--*/
{
    DWORD   WStatus;

    WStatus = DsGetDcName(NULL,    // Computer to remote to
                          NULL,    // Domain - use our own
                          NULL,    // Domain Guid
                          NULL,    // Site Guid
                          Flags,
                          DcInfo); // Return info
    //
    // Report the error and retry for any DC
    //
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr, "ERROR - Could not get DC Info; WStatus %d\n", WStatus);
        return WStatus;
    }
    printf("DCINFO for %08x:\n", Flags);
    printf("\tDomainControllerName   : %ws\n", (*DcInfo)->DomainControllerName);
    printf("\tDomainControllerAddress: %ws\n", (*DcInfo)->DomainControllerAddress);
    printf("\tDomainControllerType   : %08x\n",(*DcInfo)->DomainControllerAddressType);
    printf("\tDomainName             : %ws\n", (*DcInfo)->DomainName);
    // printf("\tForestName             : %ws\n", (*DcInfo)->DnsForestName);
    printf("\tDcSiteName             : %ws\n", (*DcInfo)->DcSiteName);
    printf("\tClientSiteName         : %ws\n", (*DcInfo)->ClientSiteName);
    printf("\tFlags                  : %08x\n",(*DcInfo)->Flags);
    return WStatus;
}


PLDAP
FrsDsOpenDs(
    VOID
    )
/*++
Routine Description:
    Open and bind to the a primary domain controller.

Arguments:
    None.

Return Value:
    The address of a open, bound LDAP port or NULL if the operation was
    unsuccessful. The caller must free the structure with ldap_unbind().
--*/
{
    DWORD WStatus;
    PLDAP ldap = NULL;    // ldap handle
    PWCHAR DcAddr;
    PWCHAR DcDnsName;
    PDOMAIN_CONTROLLER_INFO DcInfo;
    ULONG  ulOptions;

    //
    // Get Info about a Global Catalogue
    // Domain Controller (need the IP address)
    //
    // (Nope; try to live without it, Billy)
    //
    bugbug("FORCE_REDISCOVERY was removed per Herron")
    WStatus = FrsDsGetDcInfo(&DcInfo,
                          DS_DIRECTORY_SERVICE_REQUIRED | // Flags
                          DS_WRITABLE_REQUIRED);
    //
    // Report the error and retry for any DC
    //
    if (!WIN_SUCCESS(WStatus)) {
        printf("Retrying FrsDsGetDcInfo with force rediscovery\n");
        FrsDsGetDcInfo(&DcInfo,
                    DS_DIRECTORY_SERVICE_REQUIRED | // Flags
                    DS_WRITABLE_REQUIRED |
                    DS_FORCE_REDISCOVERY);
    }
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr, "ERROR - Could not get DC Info; WStatus %d\n", WStatus);
    }
    DcAddr = DcInfo->DomainControllerAddress;
    DcDnsName = DcInfo->DomainControllerName;

    //
    // if ldap_open is called with a server name the api will call DsGetDcName 
    // passing the server name as the domainname parm...bad, because 
    // DsGetDcName will make a load of DNS queries based on the server name, 
    // it is designed to construct these queries from a domain name...so all 
    // these queries will be bogus, meaning they will waste network bandwidth,
    // time to fail, and worst case cause expensive on demand links to come up 
    // as referrals/forwarders are contacted to attempt to resolve the bogus 
    // names.  By setting LDAP_OPT_AREC_EXCLUSIVE to on using ldap_set_option 
    // after the ldap_init but before any other operation using the ldap 
    // handle from ldap_init, the delayed connection setup will not call 
    // DsGetDcName, just gethostbyname, or if an IP is passed, the ldap client 
    // will detect that and use the address directly.
    //

    //
    // DC's DNS name (w/o the leading \\)
    //
    if (!ldap &&
        DcDnsName &&
        (wcslen(DcDnsName) > 2) &&
        DcDnsName[0] == L'\\' &&
        DcDnsName[1] == L'\\') {
//        ldap = ldap_open(DcDnsName + 2, LDAP_PORT);
        ldap = ldap_init(DcDnsName + 2, LDAP_PORT);
        if (!ldap) {
//            fprintf(stderr, "WARN - ldap_open(DcDnsName + 2 %ws); WStatus %d\n",
//                    DcDnsName + 2,
//                    WStatus);
            fprintf(stderr, "WARN - ldap_init(DcDnsName + 2 %ws); WStatus %d\n",
                    DcDnsName + 2,
                    WStatus);
        } else {
//            printf("ldap_open(DcDnsName + 2 %ws) succeeded\n", DcDnsName + 2);
            printf("ldap_init(DcDnsName + 2 %ws) succeeded\n", DcDnsName + 2);
        }
    }

    //
    // DC's IP Address (w/o the leading \\)
    //
    if (!ldap &&
        DcAddr &&
        (wcslen(DcAddr) > 2) &&
        DcAddr[0] == L'\\' &&
        DcAddr[1] == L'\\') {
//        ldap = ldap_open(DcAddr + 2, LDAP_PORT);
        ldap = ldap_init(DcAddr + 2, LDAP_PORT);
        if (!ldap) {
//            fprintf(stderr, "WARN - ldap_open(DcAddr + 2 %ws); WStatus %d\n",
//                    DcAddr + 2,
//                    WStatus);
            fprintf(stderr, "WARN - ldap_init(DcAddr + 2 %ws); WStatus %d\n",
                    DcAddr + 2,
                    WStatus);
        } else {
//            printf("ldap_open(DcAddr + 2 %ws) succeeded\n", DcAddr + 2);
            printf("ldap_init(DcAddr + 2 %ws) succeeded\n", DcAddr + 2);
        }
    }

    //
    // DC's DNS name
    //
    if (!ldap && DcDnsName) {
//        ldap = ldap_open(DcDnsName, LDAP_PORT);
        ldap = ldap_init(DcDnsName, LDAP_PORT);
        if (!ldap) {
//            fprintf(stderr, "WARN - ldap_open(DcDnsName %ws); WStatus %d\n",
//                    DcDnsName,
//                    WStatus);
            fprintf(stderr, "WARN - ldap_init(DcDnsName %ws); WStatus %d\n",
                    DcDnsName,
                    WStatus);
        } else {
//            printf("ldap_open(DcDnsName %ws) succeeded\n", DcDnsName);
            printf("ldap_init(DcDnsName %ws) succeeded\n", DcDnsName);
        }
    }

    //
    // DC's IP Address
    //
    if (!ldap && DcAddr) {
//        ldap = ldap_open(DcAddr, LDAP_PORT);
        ldap = ldap_init(DcAddr, LDAP_PORT);
        if (!ldap) {
//            fprintf(stderr, "WARN - ldap_open(DcAddr %ws); WStatus %d\n",
//                    DcAddr,
//                    WStatus);
            fprintf(stderr, "WARN - ldap_init(DcAddr %ws); WStatus %d\n",
                    DcAddr,
                    WStatus);
        } else {
//            printf("ldap_open(DcAddr %ws) succeeded\n", DcAddr);
            printf("ldap_init(DcAddr %ws) succeeded\n", DcAddr);
        }
    }

    //
    // Whatever it is, we can't find it.
    //
    if (!ldap) {
//        fprintf(stderr, "ERROR - ldap_open(DNS %ws, IP %ws); WStatus %d\n",
//                DcDnsName,
//                DcAddr,
//                WStatus);
        fprintf(stderr, "ERROR - ldap_init(DNS %ws, IP %ws); WStatus %d\n",
                DcDnsName,
                DcAddr,
                WStatus);
        return NULL;
    }

    //
    // set the option as explained in the comment above.
    //
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    ldap_set_option(ldap, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions);

    //
    // ldap cannot be used until after the bind operation
    //
    WStatus = ldap_bind_s(ldap, NULL, NULL, LDAP_AUTH_NEGOTIATE);
    if (WStatus != LDAP_SUCCESS) {
        fprintf(stderr, "ERROR - ldap_bind_s: %ws\n", ldap_err2string(WStatus));
        ldap_unbind(ldap);
        return NULL;
    }

    return ldap;
}


PWCHAR *
GetValues(
    IN PLDAP  Ldap,
    IN PWCHAR Dn,
    IN PWCHAR DesiredAttr,
    IN BOOL   Quiet
    )
/*++
Routine Description:
    Return the DS values for one attribute in an object.

Arguments:
    ldap        - An open, bound ldap port.
    Base        - The "pathname" of a DS object.
    DesiredAttr - Return values for this attribute.
    Quiet

Return Value:
    An array of char pointers that represents the values for the attribute.
    The caller must free the array with ldap_value_free(). NULL if unsuccessful.
--*/
{
    PWCHAR          Attr;
    BerElement      *Ber;
    PLDAPMessage    LdapMsg;
    PLDAPMessage    LdapEntry;
    PWCHAR          Attrs[2];
    PWCHAR          *Values = NULL;

    //
    // Search Base for all of its attributes + values
    //
    Attrs[0] = DesiredAttr;
    Attrs[1] = NULL;

    //
    // Issue the ldap search
    //
    if (!LdapSearch(Ldap, Dn, LDAP_SCOPE_BASE, CATEGORY_ANY,
                    Attrs, 0, &LdapMsg, Quiet)) {
        return NULL;
    }
    LdapEntry = ldap_first_entry(Ldap, LdapMsg);
    if (LdapEntry) {
        Attr = ldap_first_attribute(Ldap, LdapEntry, &Ber);
        if (Attr) {
            Values = ldap_get_values(Ldap, LdapEntry, Attr);
        }
    }
    ldap_msgfree(LdapMsg);
    return Values;
}


VOID
GuidToStr(
    IN GUID  *pGuid,
    OUT PWCHAR  s
    )
/*++
Routine Description:
    Convert a GUID to a string.

Arguments:
    pGuid - ptr to the GUID.
    s - The output character buffer.
        Must be at least GUID_CHAR_LEN (36 bytes) long.

Function Return Value:
    None.
--*/
{
    if (pGuid != NULL) {
        swprintf(s, L"%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x",
               pGuid->Data1,
               pGuid->Data2,
               pGuid->Data3,
               pGuid->Data4[0],
               pGuid->Data4[1],
               pGuid->Data4[2],
               pGuid->Data4[3],
               pGuid->Data4[4],
               pGuid->Data4[5],
               pGuid->Data4[6],
               pGuid->Data4[7]);
    } else {
        swprintf(s, L"<null>");
    }
}


PWCHAR
GetRootDn(
    IN PLDAP    Ldap,
    IN PWCHAR   NamingContext
    )
/*++
Routine Description:

Arguments:

Return Value:
--*/
{
    PWCHAR  Root;       // DS pathname of configuration container
    PWCHAR  *Values;    // values from the attribute "namingContexts"
    DWORD   NumVals;    // number of values

    //
    // Return all of the values for the attribute namingContexts
    //
    Values = GetValues(Ldap, CN_ROOT, ATTR_NAMING_CONTEXTS, FALSE);
    if (Values == NULL)
        return NULL;

    //
    // Find the naming context that begins with CN=Configuration
    //
    NumVals = ldap_count_values(Values);
    while (NumVals--) {
        _wcslwr(Values[NumVals]);
        Root = wcsstr(Values[NumVals], NamingContext);
        if (Root != NULL && Root == Values[NumVals]) {
            Root = FrsWcsDup(Root);
            ldap_value_free(Values);
            return Root;
        }
    }
    printf("ERROR - COULD NOT FIND %ws\n", NamingContext);
    ldap_value_free(Values);
    return NULL;
}


PWCHAR
ExtendDn(
    IN PWCHAR Dn,
    IN PWCHAR Cn
    )
/*++
Routine Description:
    Extend an existing DN with a new CN= component.

Arguments:
    Dn  - distinguished name
    Cn  - common name

Return Value:
    CN=Cn,Dn
--*/
{
    ULONG  Len;
    PWCHAR NewDn;

    if (!Dn || !Cn) {
        return NULL;
    }

    Len = wcslen(L"CN=,") + wcslen(Dn) + wcslen(Cn) + 1;
    NewDn = (PWCHAR)malloc(Len * sizeof(WCHAR));
    wcscpy(NewDn, L"CN=");
    wcscat(NewDn, Cn);
    wcscat(NewDn, L",");
    wcscat(NewDn, Dn);
    return NewDn;
}


PVOID *
FindValues(
    IN PLDAP        Ldap,
    IN PLDAPMessage LdapEntry,
    IN PWCHAR       DesiredAttr,
    IN BOOL         DoBerValues
    )
/*++
Routine Description:
    Return the DS values for one attribute in an entry.

Arguments:
    Ldap        - An open, bound ldap port.
    LdapEntry   - An ldap entry returned by ldap_search_s()
    DesiredAttr - Return values for this attribute.
    DoVerValues - Return the bervals

Return Value:
    An array of char pointers that represents the values for the attribute.
    The caller must free the array with ldap_value_free(). NULL if unsuccessful.
--*/
{
    PWCHAR      LdapAttr;       // Retrieved from an ldap entry
    BerElement  *Ber;       // Needed for scanning attributes

    //
    // Search the entry for the desired attribute
    //
    for (LdapAttr = ldap_first_attribute(Ldap, LdapEntry, &Ber);
         LdapAttr != NULL;
         LdapAttr = ldap_next_attribute(Ldap, LdapEntry, Ber)) {
        if (_wcsicmp(DesiredAttr, LdapAttr) == 0) {
            //
            // Return the values for DesiredAttr
            //
            if (DoBerValues) {
                return (PVOID *)ldap_get_values_len(Ldap, LdapEntry, LdapAttr);
            } else {
                return (PVOID *)ldap_get_values(Ldap, LdapEntry, LdapAttr);
            }
        }
    }
    return NULL;
}


PWCHAR
FindValue(
    IN PLDAP        Ldap,
    IN PLDAPMessage LdapEntry,
    IN PWCHAR       DesiredAttr
    )
/*++
Routine Description:
    Return a copy of the first DS value for one attribute in an entry.

Arguments:
    Ldap        - An open, bound ldap port.
    LdapEntry   - An ldap entry returned by ldap_search_s()
    DesiredAttr - Return values for this attribute.

Return Value:
    A zero-terminated string or NULL if the attribute or its value
    doesn't exist. The string is freed with FREE_NO_HEADER().
--*/
{
    PWCHAR  Val;
    PWCHAR  *Values;

    // Get ldap's array of values
    Values = (PWCHAR *)FindValues(Ldap, LdapEntry, DesiredAttr, FALSE);

    // Copy the first value (if any)
    Val = (Values) ? FrsWcsDup(Values[0]) : NULL;

    // Free ldap's array of values
    ldap_value_free(Values);

    return Val;
}


BOOL
FindBerValue(
    IN  PLDAP        ldap,
    IN  PLDAPMessage Entry,
    IN  PWCHAR       DesiredAttr,
    OUT ULONG        *Len,
    OUT VOID         **Value
    )
/*++
Routine Description:
    Return a copy of the attributes object's schedule

Arguments:
    ldap        - An open, bound ldap port.
    Entry       - An ldap entry returned by ldap_search_s()
    DesiredAttr - desired attribute
    Len         - length of Value
    Value       - binary value

Return Value:
    The address of a schedule or NULL. Free with FrsFree().
--*/
{
    PLDAP_BERVAL    *Values;
    PSCHEDULE       Schedule;

    *Len = 0;
    *Value = NULL;

    //
    // Get ldap's array of values
    //
    Values = (PLDAP_BERVAL *)FindValues(ldap, Entry, DesiredAttr, TRUE);
    if (!Values) {
        return FALSE;
    }

    //
    // Return a copy of the schedule
    //
    *Len = Values[0]->bv_len;
    if (*Len) {
        *Value = (PWCHAR)malloc(*Len);
        CopyMemory(*Value, Values[0]->bv_val, *Len);
    }
    ldap_value_free_len(Values);
    return TRUE;
}


VOID
DumpValues(
    IN PLDAP    Ldap,
    IN PWCHAR   Dn,
    IN DWORD    Scope,
    IN PWCHAR   Class,
    IN PWCHAR   Attrs[],
    IN BOOL     IfEmpty
    )
/*++
Routine Description:
    Print the values and attributes for an object in the DS.

Arguments:
    ldap    - An open, bound ldap port.
    Base    - The "pathname" of a DS object.
    Scope   - Dump the values about the object (LDAP_SCOPE_BASE) or
              about the objects contained in this object (LDAP_SCOPE_ONELEVEL)

Return Value:
    None.
--*/
{
    PWCHAR          Attr;       // Retrieved from an ldap entry
    BerElement      *Ber;       // Needed for scanning attributes
    PLDAPMessage    Msg;        // Opaque stuff from ldap subsystem
    PLDAPMessage    Entry;      // Opaque stuff from ldap subsystem
    PWCHAR          *Values;    // Array of values for desired attribute
    PLDAP_BERVAL    *Balues;    // Array of values for desired attribute
    DWORD           NumVals;    // Number of entries in Values
    PWCHAR          Rdn;        // An entries "pathname" in the DS
    WCHAR           GuidStr[GUID_CHAR_LEN + 1];
    PWCHAR          EntryDn;
    ULONG           i;

    //
    // Search Base for all of the attributes + values of Class
    //
    if (!LdapSearch(Ldap, Dn,  Scope, Class,
                    Attrs, 0, &Msg, !IfEmpty)) {
        return;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (Entry = ldap_first_entry(Ldap, Msg);
         Entry != NULL;
         Entry = ldap_next_entry(Ldap, Entry)) {

        EntryDn = FindValue(Ldap, Entry, ATTR_DN);
        if (EntryDn) {
            Attr = ldap_first_attribute(Ldap, Entry, &Ber);
            if (Attr) {
                Attr = ldap_next_attribute(Ldap, Entry, Ber);
            }
            if (!IfEmpty && !Attr) {
                continue;
            }
            Rdn = MakeRdn(EntryDn);
            printf("%ws\n", Rdn);
            FREE(EntryDn);
            FREE(Rdn);
        } else {
            Attr = ldap_first_attribute(Ldap, Entry, &Ber);
            if (!IfEmpty && !Attr) {
                continue;
            }
            printf("Entry has no distinguished name\n");
        }

        //
        // Scan the attributes of an entry
        //
        for (Attr = ldap_first_attribute(Ldap, Entry, &Ber);
             Attr != NULL;
             Attr = ldap_next_attribute(Ldap, Entry, Ber)) {

            //
            // Printed above; don't repeat
            //
            if (!wcscmp(Attr, ATTR_DN)) {
                continue;
            }

            //
            // Print the values
            //
            printf("    %ws\n", Attr);

            for (i = 0; GuidAttrs[i]; ++i) {
                if (!wcscmp(Attr, GuidAttrs[i])) {
                    Balues = ldap_get_values_len(Ldap, Entry, Attr);
                    NumVals = ldap_count_values_len(Balues);
                    if (NumVals) {
                        GuidToStr((GUID *)Balues[0]->bv_val, GuidStr);
                        printf("        Length %d; %ws\n",
                               Balues[0]->bv_len, GuidStr);
                    }
                    ldap_value_free_len(Balues);
                    break;
                }
            }
            if (GuidAttrs[i]) {
                continue;
            }
            for (i = 0; BerAttrs[i]; ++i) {
                if (!wcscmp(Attr, BerAttrs[i])) {
                    Balues = ldap_get_values_len(Ldap, Entry, Attr);
                    NumVals = ldap_count_values_len(Balues);
                    if (NumVals) {
                        printf("        Length %d\n",
                               Balues[0]->bv_len);
                    }
                    ldap_value_free_len(Balues);
                    break;
                }
            }
            if (BerAttrs[i]) {
                continue;
            }

            if (!wcscmp(Attr, L"schedule")) {
                Balues = ldap_get_values_len(Ldap, Entry, Attr);
                NumVals = ldap_count_values_len(Balues);
                if (NumVals) {
                    printf("        Length %d; Number %d\n",
                           NumVals,
                           Balues[0]->bv_len,
                           ((PSCHEDULE)(Balues[0]->bv_val))->NumberOfSchedules);
                }
                ldap_value_free_len(Balues);
                continue;
            }
            Values = ldap_get_values(Ldap, Entry, Attr);
            NumVals = ldap_count_values(Values);
            while (NumVals--) {
                printf("        %ws\n", Values[NumVals]);
            }
            ldap_value_free(Values);
        }
    }
    ldap_msgfree(Msg);
}


DWORD
GetDnsName(
    IN  PWCHAR Server,
    OUT PWCHAR *DnsName
    )
/*++
Routine Description:
    Retrieve this machine's DNS name.

Arguments:
    Server
    DnsName - wide char version of dns name

Return Value:
    WSA Status
--*/
{
    INT             SStatus;
    WORD            DnsVersion = MAKEWORD(1, 1);
    struct hostent  *Host;
    WSADATA         WSAData;
    PCHAR           DnsNameA;
    PCHAR           ServerA;

    *DnsName = NULL;

    //
    // Get this machine's DNS name
    //

    //
    // Initialize the socket subsystem
    //
    if (SStatus = WSAStartup(DnsVersion, &WSAData)) {
        fprintf(stderr, "Can't get DNS name; Socket startup error %d\n",
                SStatus);
        return SStatus;
    };
    //
    // Get the DNS name
    //
    ServerA = FrsWtoA(Server);
    Host = gethostbyname(ServerA);
    FREE(ServerA);
    if (Host == NULL) {
        SStatus = WSAGetLastError();
        fprintf(stderr, "Can't get DNS name for %ws; gethostbyname error %d\n",
                Server, SStatus);
        return SStatus;
    }
    if (Host->h_name == NULL) {
        fprintf(stderr, "DNS name for %ws is NULL\n", Server);
        return WSAEFAULT;
    }
    //
    // Return both the ASCII and UNICODE versions
    //
    *DnsName = FrsAtoW(Host->h_name);
    WSACleanup();
    return 0;
}


PWCHAR
GetNextDn(
    IN PLDAP     Ldap,
    PLDAPMessage LdapEntry,
    IN PWCHAR    ParentDn
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    PWCHAR      Cn          = NULL;
    PWCHAR      Dn          = NULL;

    Cn = FindValue(Ldap, LdapEntry, ATTR_CN);
    if (Cn) {
        Dn = ExtendDn(ParentDn, Cn);
        FREE(Cn)
    }
    return Dn;
}


PWCHAR
DumpAttrs(
    IN PLDAP     Ldap,
    PLDAPMessage LdapEntry,
    IN PWCHAR    ParentDn,
    IN PWCHAR    *Attrs,
    IN PWCHAR    Indent
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    DWORD       NumVals;
    ULONG       ScheduleLen;
    ULONG       ExtensionsLen;
    PSCHEDULE   Schedule    = NULL;
    PCHAR       Extensions  = NULL;
    PWCHAR      Val         = NULL;
    PWCHAR      Rdn         = NULL;
    PWCHAR      Pdn         = NULL;
    PWCHAR      PRdn        = NULL;
    PWCHAR      *Values     = NULL;

    if (!Attrs) {
        return NULL;
    }

    while (*Attrs) {
        //
        // Don't bother, the Cn will do
        //
        if (!wcscmp(*Attrs, ATTR_DN)) {
            ++Attrs;
            continue;
        }
        if (!wcscmp(*Attrs, ATTR_COMPUTER_REF_BL)) {
            Values = ldap_get_values(Ldap, LdapEntry, *Attrs);
            NumVals = ldap_count_values(Values);
            while (NumVals--) {
                Rdn = MakeRdn(Values[NumVals]);
                Pdn = FrsDsMakeParentDn(Values[NumVals]);
                PRdn = MakeRdn(Pdn);
                printf("    %ws%ws=%ws\\%ws\n", Indent, *Attrs, PRdn, Rdn);
                FREE(Rdn);
                FREE(Pdn);
                FREE(PRdn);
            }
            ldap_value_free(Values);
        } else if (!wcscmp(*Attrs, ATTR_SCHEDULE)) {
            FindBerValue(Ldap,
                         LdapEntry,
                         ATTR_SCHEDULE,
                         &ScheduleLen,
                         (VOID **)&Schedule);
            if (Schedule) {
                // PrintShortSchedule(Indent, Schedule, ScheduleLen);
                PrintLongSchedule(L"    ", Indent, Schedule, ScheduleLen);
                FREE(Schedule);
            } else {
                printf("    %wsSchedule=\n", Indent);
            }
        } else if (!wcscmp(*Attrs, ATTR_EXTENSIONS)) {
            FindBerValue(Ldap,
                         LdapEntry,
                         ATTR_EXTENSIONS,
                         &ExtensionsLen,
                         (VOID **)&Extensions);
            if (Extensions) {
                FREE(Extensions);
                printf("    %wsExtensions=%d\n", Indent, ExtensionsLen);
            } else {
                printf("    %wsExtensions=\n", Indent);
            }
        } else if (!wcscmp(*Attrs, ATTR_NAMING_CONTEXTS)) {
            Values = ldap_get_values(Ldap, LdapEntry, *Attrs);
            NumVals = ldap_count_values(Values);
            while (NumVals--) {
                printf("    %ws%ws=%ws\n", Indent, *Attrs, Values[NumVals]);
            }
            ldap_value_free(Values);
        } else {
            Val = FindValue(Ldap, LdapEntry, *Attrs);
            if (Val) {
                if (!wcscmp(*Attrs, ATTR_CN)) {
                    printf("%ws%ws\n", Indent, Val);
                } else if (!wcscmp(*Attrs, ATTR_FROM_SERVER)     ||
                           !wcscmp(*Attrs, ATTR_PRIMARY_MEMBER)  ||
                           !wcscmp(*Attrs, ATTR_COMPUTER_REF)    ||
                           !wcscmp(*Attrs, ATTR_COMPUTER_REF_BL) ||
                           !wcscmp(*Attrs, ATTR_MEMBER_REF)      ||
                           !wcscmp(*Attrs, ATTR_MEMBER_REF_BL)   ||
                           !wcscmp(*Attrs, ATTR_SERVER_REF_BL)   ||
                           !wcscmp(*Attrs, ATTR_SERVER_REF)) {
                    Rdn = MakeRdn(Val);
                    Pdn = FrsDsMakeParentDn(Val);
                    PRdn = MakeRdn(Pdn);
                    printf("    %ws%ws=%ws\\%ws\n", Indent, *Attrs, PRdn, Rdn);
                    FREE(Rdn);
                    FREE(Pdn);
                    FREE(PRdn);
                } else {
                    printf("    %ws%ws=%ws\n", Indent, *Attrs, Val);
                }
                FREE(Val);
            } else {
                printf("    %ws%ws=\n", Indent, *Attrs);
            }
        }
        ++Attrs;
    }
    return GetNextDn(Ldap, LdapEntry, ParentDn);
}


VOID
DumpCxtions(
    IN PLDAP    Ldap,
    IN PWCHAR   ParentDn
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          NextDn              = NULL;

    //
    // Cxtions
    //
    DesiredAttrs[0] = ATTR_CN;
    DesiredAttrs[1] = ATTR_FROM_SERVER;
    DesiredAttrs[2] = ATTR_SCHEDULE;
    DesiredAttrs[3] = ATTR_ENABLED_CXTION;
    DesiredAttrs[4] = NULL;
    if (LdapSearch(Ldap, ParentDn, LDAP_SCOPE_ONELEVEL, CATEGORY_CXTION,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = DumpAttrs(Ldap, LdapEntry, ParentDn, DesiredAttrs, L"            ");
            if (NextDn) {
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
}


VOID
DumpMembers(
    IN PLDAP    Ldap,
    IN PWCHAR   ParentDn
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          NextDn              = NULL;

    //
    // Servers
    //
    DesiredAttrs[0] = ATTR_CN;
    DesiredAttrs[1] = ATTR_COMPUTER_REF;
    DesiredAttrs[2] = ATTR_MEMBER_REF_BL;
    DesiredAttrs[3] = ATTR_SERVER_REF;
    DesiredAttrs[4] = NULL;
    // DesiredAttrs[4] = ATTR_CONTROL_CREATION;
    // DesiredAttrs[5] = ATTR_INBOUND_BACKLOG;
    // DesiredAttrs[6] = ATTR_OUTBOUND_BACKLOG;
    // DesiredAttrs[7] = ATTR_SERVICE_COMMAND;
    // DesiredAttrs[8] = ATTR_UPDATE_TIMEOUT;
    // DesiredAttrs[9] = ATTR_EXTENSIONS;
    // DesiredAttrs[10] = ATTR_FLAGS;
    // DesiredAttrs[11] = ATTR_AUTH_LEVEL;
    DesiredAttrs[12] = NULL;
    if (LdapSearch(Ldap, ParentDn,  LDAP_SCOPE_ONELEVEL, CATEGORY_MEMBER,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = DumpAttrs(Ldap, LdapEntry, ParentDn, DesiredAttrs, L"        ");
            if (NextDn) {
                DumpCxtions(Ldap, NextDn);
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
}


VOID
DumpSets(
    IN PLDAP    Ldap,
    IN PWCHAR   ParentDn
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          NextDn              = NULL;

    //
    // Sets
    //
    DesiredAttrs[0] = ATTR_CN;
    DesiredAttrs[1] = ATTR_PRIMARY_MEMBER;
    DesiredAttrs[2] = ATTR_SET_TYPE;
    DesiredAttrs[3] = ATTR_SCHEDULE;
    DesiredAttrs[4] = ATTR_DIRECTORY_FILTER;
    DesiredAttrs[5] = ATTR_FILE_FILTER;
    DesiredAttrs[6] = NULL;
    // DesiredAttrs[7] = ATTR_DS_POLL;
    // DesiredAttrs[8] = ATTR_EXTENSIONS;
    // DesiredAttrs[9] = ATTR_FLAGS;
    // DesiredAttrs[10] = ATTR_LEVEL_LIMIT;
    // DesiredAttrs[11] = ATTR_AUTH_LEVEL;
    DesiredAttrs[12] = NULL;
    if (LdapSearch(Ldap, ParentDn, LDAP_SCOPE_ONELEVEL, CATEGORY_REPLICA_SET,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = DumpAttrs(Ldap, LdapEntry, ParentDn, DesiredAttrs, L"    ");
            if (NextDn) {
                DumpMembers(Ldap, NextDn);
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
}


VOID
DumpContexts(
    IN PLDAP Ldap
    )
/*++
Routine Description:
    Dump every ds object related to replication

Arguments:
    Ldap

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PWCHAR          NextDn              = NULL;
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;

    //
    // Setting
    //
    DesiredAttrs[0] = ATTR_NAMING_CONTEXTS;
    DesiredAttrs[1] = ATTR_DEFAULT_NAMING_CONTEXT;
    DesiredAttrs[2] = NULL;
    if (LdapSearch(Ldap, CN_ROOT, LDAP_SCOPE_BASE, CATEGORY_ANY,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = DumpAttrs(Ldap, LdapEntry, CN_ROOT, DesiredAttrs, L"");
            if (NextDn) {
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
}


VOID
DumpAdminWorld(
    IN PLDAP Ldap
    )
/*++
Routine Description:
    Dump every ds object related to replication

Arguments:
    Ldap

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PWCHAR          ConfigDn            = NULL;
    PWCHAR          ServicesDn          = NULL;
    PWCHAR          NextDn              = NULL;
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;

    //
    // Services
    //
    ConfigDn = GetRootDn(Ldap, CONFIG_NAMING_CONTEXT);
    if (!ConfigDn) {
        return;
    }
    ServicesDn = ExtendDn(ConfigDn, CN_SERVICES);

    //
    // Setting
    //
    DesiredAttrs[0] = ATTR_CN;
    DesiredAttrs[1] = NULL;
    // DesiredAttrs[1] = ATTR_EXTENSIONS;
    DesiredAttrs[2] = NULL;
    if (LdapSearch(Ldap, ServicesDn, LDAP_SCOPE_ONELEVEL, CATEGORY_NTFRS_SETTINGS,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = DumpAttrs(Ldap, LdapEntry, ServicesDn, DesiredAttrs, L"");
            if (NextDn) {
                DumpSets(Ldap, NextDn);
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }

    FREE(ServicesDn);
    FREE(ConfigDn);
}


VOID
DumpSubscribers(
    IN PLDAP    Ldap,
    IN PWCHAR   ParentDn
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          NextDn              = NULL;

    //
    // Subscribers
    //
    DesiredAttrs[0] = ATTR_CN;
    DesiredAttrs[1] = ATTR_REPLICA_ROOT;
    DesiredAttrs[2] = ATTR_REPLICA_STAGE;
    DesiredAttrs[3] = ATTR_MEMBER_REF;
    DesiredAttrs[4] = ATTR_SCHEDULE;
    DesiredAttrs[5] = NULL;
    // DesiredAttrs[4] = ATTR_EXTENSIONS;
    // DesiredAttrs[5] = ATTR_FAULT_CONDITION;
    // DesiredAttrs[6] = ATTR_FLAGS;
    // DesiredAttrs[7] = ATTR_SERVICE_COMMAND;
    // DesiredAttrs[8] = ATTR_SERVICE_COMMAND_STATUS;
    // DesiredAttrs[9] = ATTR_UPDATE_TIMEOUT;
    DesiredAttrs[10] = NULL;
    if (LdapSearch(Ldap, ParentDn, LDAP_SCOPE_ONELEVEL, CATEGORY_SUBSCRIBER,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = DumpAttrs(Ldap, LdapEntry, ParentDn, DesiredAttrs, L"            ");
            if (NextDn) {
                DumpSubscribers(Ldap, NextDn);
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
}


VOID
DumpSubscriptions(
    IN PLDAP    Ldap,
    IN PWCHAR   ParentDn
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          NextDn              = NULL;

    //
    // Servers
    //
    DesiredAttrs[0] = ATTR_CN;
    DesiredAttrs[1] = ATTR_WORKING;
    DesiredAttrs[2] = NULL;
    // DesiredAttrs[2] = ATTR_EXTENSIONS;
    // DesiredAttrs[3] = ATTR_VERSION;
    DesiredAttrs[4] = NULL;
    if (LdapSearch(Ldap, ParentDn, LDAP_SCOPE_ONELEVEL, CATEGORY_SUBSCRIPTIONS,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = DumpAttrs(Ldap, LdapEntry, ParentDn, DesiredAttrs, L"        ");
            if (NextDn) {
                DumpSubscribers(Ldap, NextDn);
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
}


VOID
DumpUserWorld(
    IN PLDAP Ldap
    )
/*++
Routine Description:
    Dump every ds object related to replication

Arguments:
    Ldap

Return Value:
    None.
--*/
{
    DWORD           WStatus;
    PWCHAR          DesiredAttrs[16];
    DWORD           NumVals;
    PWCHAR          *Values             = NULL;
    PWCHAR          NextDn              = NULL;
    PWCHAR          DefaultDn           = NULL;
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    HANDLE          Handle              = NULL;
    DS_NAME_RESULT  *Cracked            = NULL;
    WCHAR           **Crackee;
    PDOMAIN_CONTROLLER_INFO DcInfo;

    //
    // Return all of the values for the attribute namingContexts
    //
    Values = GetValues(Ldap, CN_ROOT, ATTR_DEFAULT_NAMING_CONTEXT, TRUE);
    if (!Values) {
        fprintf(stderr, "ERROR - Can't find %ws in %ws\n",
                ATTR_DEFAULT_NAMING_CONTEXT,
                CN_ROOT);
        return;
    }
    DefaultDn = FrsWcsDup(Values[0]);
    ldap_value_free(Values);

    //
    // Get Info about a Primary Domain Controller (need the IP address)
    //
    WStatus = FrsDsGetDcInfo(&DcInfo,
                          DS_DIRECTORY_SERVICE_REQUIRED | // Flags
                          DS_WRITABLE_REQUIRED);
    //
    // Report the error and carry on
    //
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr, "ERROR - Could not get DC Info; WStatus %d\n",
                WStatus);
    } else {
        WStatus = DsBind(DcInfo->DomainControllerName, NULL, &Handle);
        if (!WIN_SUCCESS(WStatus)) {
            fprintf(stderr, "ERROR - DsBind(%ws); WStatus %d %08x\n",
                    DcInfo->DomainControllerName,
                    WStatus,
                    WStatus);
            WStatus = DsBind(DcInfo->DomainControllerAddress, NULL, &Handle);
            if (!WIN_SUCCESS(WStatus)) {
                fprintf(stderr, "ERROR - DsBind(%ws); WStatus %d %08x\n",
                        DcInfo->DomainControllerAddress,
                        WStatus,
                        WStatus);
            } else {
                printf("DsBind(%ws) succeeded\n", DcInfo->DomainControllerAddress);
            }
        } else {
            printf("DsBind(%ws) succeeded\n", DcInfo->DomainControllerName);
        }
    }

    //
    // Find the naming context that begins with CN=Configuration
    //
    //
    // Computers
    //
    DesiredAttrs[0] = ATTR_CN;
    DesiredAttrs[1] = ATTR_SAM;
    DesiredAttrs[2] = ATTR_DNS_HOST_NAME;
    DesiredAttrs[3] = ATTR_DN;
    DesiredAttrs[4] = ATTR_COMPUTER_REF_BL;
    DesiredAttrs[5] = ATTR_SERVER_REF;
    DesiredAttrs[6] = ATTR_SERVER_REF_BL;
    DesiredAttrs[7] = ATTR_USER_ACCOUNT_CONTROL;
    DesiredAttrs[8] = NULL;
    if (LdapSearch(Ldap, DefaultDn, LDAP_SCOPE_SUBTREE, CATEGORY_COMPUTER,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = DumpAttrs(Ldap, LdapEntry, DefaultDn, DesiredAttrs, L"");
            FREE(NextDn);
            NextDn = FindValue(Ldap, LdapEntry, ATTR_DN);
            if (NextDn && HANDLE_IS_VALID(Handle)) {
                Crackee = &NextDn;
                WStatus = DsCrackNames(Handle,
                                       DS_NAME_NO_FLAGS,
                                       // DS_NAME_FLAG_SYNTACTICAL_ONLY,

                                       DS_FQDN_1779_NAME,

                                       DS_NT4_ACCOUNT_NAME,
                                       //DS_CANONICAL_NAME,

                                       1,
                                       Crackee,
                                       &Cracked);
                if (!WIN_SUCCESS(WStatus)) {
                    printf("ERROR - Cracking name; WStatus %d\n", WStatus);
                } else if (Cracked &&
                           Cracked->cItems &&
                           Cracked->rItems) {
                        if (Cracked->rItems->status) {
                            printf("    ERROR - Can't crack name; status %d\n",
                                   Cracked->rItems->status);
                        } else {
                            printf("    Cracked Domain : %ws\n",
                                   Cracked->rItems->pDomain);
                            printf("    Cracked Account: %ws\n",
                                   Cracked->rItems->pName);
                    }
                    DsFreeNameResult(Cracked);
                    Cracked = NULL;
                }
            }
            if (NextDn) {
                DumpSubscriptions(Ldap, NextDn);
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }

//out:
    if (HANDLE_IS_VALID(Handle)) {
        DsUnBind(&Handle);
    }
    FREE(DefaultDn);
}


VOID
DumpDsDsa(
    IN PLDAP    Ldap,
    IN PWCHAR   ParentDn
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          NextDn              = NULL;

    //
    // Servers
    //
    DesiredAttrs[0] = ATTR_CN;
    DesiredAttrs[1] = ATTR_DN;
    DesiredAttrs[2] = ATTR_SCHEDULE;
    DesiredAttrs[3] = ATTR_SERVER_REF;
    DesiredAttrs[4] = NULL;
    if (LdapSearch(Ldap, ParentDn, LDAP_SCOPE_ONELEVEL, CATEGORY_NTDS_DSA,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = DumpAttrs(Ldap, LdapEntry, ParentDn, DesiredAttrs, L"    ");
            if (NextDn) {
                DumpCxtions(Ldap, NextDn);
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
}


VOID
DumpSysVolWorld(
    IN PLDAP Ldap
    )
/*++
Routine Description:

Arguments:
    Ldap

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PWCHAR          NextDn              = NULL;
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          ConfigDn            = NULL;
    PWCHAR          SitesDn             = NULL;

    //
    // Return all of the values for the attribute namingContexts
    //
    ConfigDn = GetRootDn(Ldap, CONFIG_NAMING_CONTEXT);
    if (!ConfigDn) {
        return;
    }
    SitesDn = ExtendDn(ConfigDn, CN_SITES);

    //
    // Setting
    //
    DesiredAttrs[0] = ATTR_CN;
    DesiredAttrs[1] = ATTR_DNS_HOST_NAME;
    DesiredAttrs[2] = ATTR_DN;
    DesiredAttrs[3] = ATTR_SERVER_REF;
    DesiredAttrs[4] = ATTR_SERVER_REF_BL;
    DesiredAttrs[5] = NULL;
    if (LdapSearch(Ldap, SitesDn,  LDAP_SCOPE_SUBTREE, CATEGORY_SERVER,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = DumpAttrs(Ldap, LdapEntry, SitesDn, DesiredAttrs, L"");
            if (NextDn) {
                FREE(NextDn);
            }
            NextDn = FindValue(Ldap, LdapEntry, ATTR_DN);
            if (NextDn) {
                DumpDsDsa(Ldap, NextDn);
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
//out:
    FREE(ConfigDn);
    FREE(SitesDn);
}


VOID
ScriptCxtions(
    IN PLDAP    Ldap,
    IN PWCHAR   Set,
    IN PWCHAR   ServerDn
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          NextDn              = NULL;
    PWCHAR          From                = NULL;
    PWCHAR          Partner             = NULL;
    PWCHAR          Partners            = NULL;
    PWCHAR          Server              = NULL;
    PWCHAR          Tmp                 = NULL;

    Server = MakeRdn(ServerDn);

    //
    // Cxtions
    //
    DesiredAttrs[0] = ATTR_FROM_SERVER;
    DesiredAttrs[1] = NULL;
    if (LdapSearch(Ldap, ServerDn, LDAP_SCOPE_ONELEVEL, CATEGORY_CXTION,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            From = FindValue(Ldap, LdapEntry, ATTR_FROM_SERVER);
            if (From) {
                Partner = MakeRdn(From);
                if (Partner) {
                    if (Partners) {
                        Tmp = Partners;
                        Partners = FrsWcsCat(Tmp, L" ");
                        FREE(Tmp);
                        Tmp = Partners;
                        Partners = FrsWcsCat(Tmp, Partner);
                        FREE(Tmp);
                        FREE(Partner);
                    } else {
                        Partners = Partner;
                    }
                }
                FREE(From);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
    if (Partners) {
        printf("dstree /i %ws %ws %ws\n", Set, Server, Partners);
    }
    FREE(Server);
}


VOID
GetRootAndStage(
    IN  PLDAP   Ldap,
    IN  PWCHAR  SubscriberDn,
    OUT PWCHAR  *Root,
    OUT PWCHAR  *Stage
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;

    *Root = NULL;
    *Stage = NULL;

    //
    // Subscriber
    //
    DesiredAttrs[0] = ATTR_REPLICA_ROOT;
    DesiredAttrs[1] = ATTR_REPLICA_STAGE;
    DesiredAttrs[2] = NULL;
    if (LdapSearch(Ldap, SubscriberDn, LDAP_SCOPE_BASE, CATEGORY_SUBSCRIBER,
                   DesiredAttrs, 0, &LdapMsg, TRUE)) {
        LdapEntry = ldap_first_entry(Ldap, LdapMsg);
        if (LdapEntry) {
            *Root = FindValue(Ldap, LdapEntry, ATTR_REPLICA_ROOT);
            *Stage = FindValue(Ldap, LdapEntry, ATTR_REPLICA_STAGE);
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
}


VOID
ScriptMembers(
    IN PLDAP    Ldap,
    IN PWCHAR   SetDn,
    IN BOOL     ScriptingServers
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          NextDn              = NULL;
    PWCHAR          Set                 = NULL;
    PWCHAR          Cn                  = NULL;
    PWCHAR          Root                = NULL;
    PWCHAR          Stage               = NULL;
    PWCHAR          MemberBl            = NULL;

    Set = MakeRdn(SetDn);

    //
    // Servers
    //
    DesiredAttrs[0] = ATTR_CN;
    DesiredAttrs[1] = ATTR_REPLICA_ROOT;
    DesiredAttrs[2] = ATTR_REPLICA_STAGE;
    DesiredAttrs[3] = ATTR_MEMBER_REF_BL;
    DesiredAttrs[4] = NULL;
    if (LdapSearch(Ldap, SetDn, LDAP_SCOPE_ONELEVEL, CATEGORY_MEMBER,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            if (ScriptingServers) {
                Cn = FindValue(Ldap, LdapEntry, ATTR_CN);
                MemberBl = FindValue(Ldap, LdapEntry, ATTR_MEMBER_REF_BL);
                if (MemberBl) {
                    GetRootAndStage(Ldap, MemberBl, &Root, &Stage);
                }
                if (Cn) {
                    if (Root && Stage) {
                        printf("dstree /c %ws %ws %ws %ws\n", Set, Cn, Root, Stage);
                    } else {
                        printf("dstree /c %ws %ws\n", Set, Cn);
                    }
                    FREE(Cn);
                    FREE(Root);
                    FREE(Stage);
                    FREE(MemberBl);
                }
            } else {
                NextDn = GetNextDn(Ldap, LdapEntry, SetDn);
                if (NextDn) {
                    ScriptCxtions(Ldap, Set, NextDn);
                    FREE(NextDn);
                }
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
    FREE(Set);
}


VOID
ScriptSets(
    IN PLDAP    Ldap,
    IN PWCHAR   ParentDn
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    PWCHAR          NextDn              = NULL;

    //
    // Sets
    //
    DesiredAttrs[0] = ATTR_CN;
    DesiredAttrs[1] = NULL;
    if (LdapSearch(Ldap, ParentDn, LDAP_SCOPE_ONELEVEL, CATEGORY_REPLICA_SET,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = GetNextDn(Ldap, LdapEntry, ParentDn);
            if (NextDn) {
                ScriptMembers(Ldap, NextDn, TRUE);
                FREE(NextDn);
            }
        }
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = GetNextDn(Ldap,
                               LdapEntry,
                               ParentDn);
            if (NextDn) {
                ScriptMembers(Ldap, NextDn, FALSE);
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
}


VOID
ScriptReplicationWorld(
    VOID
    )
/*++
Routine Description:

Arguments:
    None.

Return Value:
    None.
--*/
{
    PWCHAR          DesiredAttrs[16];
    PLDAP           Ldap                = NULL;
    PWCHAR          ConfigDn            = NULL;
    PWCHAR          ServicesDn          = NULL;
    PWCHAR          NextDn              = NULL;
    PWCHAR          SettingsDn          = NULL;
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;

    //
    // Bind to the ds
    //
    Ldap = FrsDsOpenDs();
    if (!Ldap) {
        return;
    }

    //
    // Services
    //
    ConfigDn = GetRootDn(Ldap, CONFIG_NAMING_CONTEXT);
    if (!ConfigDn) {
        return;
    }
    ServicesDn = ExtendDn(ConfigDn, CN_SERVICES);
    SettingsDn = ExtendDn(ServicesDn, CN_TEST_SETTINGS);
    ScriptSets(Ldap, SettingsDn);

#if 0
Don't script all of the settings; only the test settings
    //
    // Setting
    //
    DesiredAttrs[0] = ATTR_CN;
    DesiredAttrs[1] = NULL;
    if (LdapSearch(Ldap, ServicesDn, LDAP_SCOPE_ONELEVEL, CATEGORY_NTFRS_SETTINGS,
                   DesiredAttrs, 0, &LdapMsg, FALSE)) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = GetNextDn(Ldap, LdapEntry, ServicesDn);
            if (NextDn) {
                ScriptSets(Ldap, NextDn);
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        LdapMsg = NULL;
    }
#endif 0

    ldap_unbind(Ldap);
    FREE(ServicesDn);
    FREE(ConfigDn);
    FREE(SettingsDn);
}


VOID
DoListSchema(
    IN PLDAP                Ldap,
    IN PWCHAR               SchemaDn,
    IN struct AlterClass    *Lists[]
    )
/*++
Routine Description:
    Dump schema

Arguments:
    None.

Return Value:
    None.
--*/
{
    ULONG   i, j;
    ULONG   NumAttrs;
    DWORD   LStatus;
    PWCHAR  Attrs[64];
    PWCHAR  Dn          = NULL;

    for (j = 0; Lists[j]; ++j) {
        Dn = ExtendDn(SchemaDn, Lists[j]->Cn);
        NumAttrs = 0;
        for (i = 0; Lists[j]->AlterAttrs[i].Attr; ++i) {
            if (NumAttrs) {
                if (!wcscmp(Attrs[NumAttrs - 1],
                            Lists[j]->AlterAttrs[i].Attr)) {
                    continue;
                }
            }
            Attrs[NumAttrs++] = Lists[j]->AlterAttrs[i].Attr;
        }
        if (NumAttrs) {
            Attrs[NumAttrs + 0] = ATTR_DN;
            Attrs[NumAttrs + 1] = ATTR_SYSTEM_FLAGS;
            Attrs[NumAttrs + 2] = ATTR_SYSTEM_MAY_CONTAIN;
            Attrs[NumAttrs + 3] = ATTR_SYSTEM_MUST_CONTAIN;
            Attrs[NumAttrs + 4] = ATTR_SYSTEM_POSS_SUPERIORS;
            Attrs[NumAttrs + 5] = NULL;
            DumpValues(Ldap, Dn, LDAP_SCOPE_BASE, CATEGORY_ANY, Attrs, FALSE);
        }
        FREE(Dn);
    }
}


VOID
ListSchema(
    VOID
    )
/*++
Routine Description:
    Dump schema

Arguments:
    None.

Return Value:
    None.
--*/
{
    ULONG           i, j;
    ULONG           NumAttrs;
    DWORD           LStatus;
    PLDAP           Ldap        = NULL;
    PWCHAR          SchemaDn    = NULL;
    PWCHAR          Dn          = NULL;
    LDAPMod         **Mod       = NULL;
    PWCHAR          Attrs[64];

    //
    // Bind to the ds
    //
    Ldap = FrsDsOpenDs();
    if (!Ldap) {
        return;
    }
    SchemaDn = GetRootDn(Ldap, SCHEMA_NAMING_CONTEXT);
    if (!SchemaDn) {
        return;
    }
    DoListSchema(Ldap, SchemaDn, AlterSchema);
    DoListSchema(Ldap, SchemaDn, CreateClasses);
    DoListSchema(Ldap, SchemaDn, CreateAttributes);
    ldap_unbind(Ldap);
    FREE(SchemaDn);
}


VOID
CreateSchema(
    IN PLDAP                Ldap,
    IN PWCHAR               SchemaDn,
    IN struct AlterClass    *Creates[],
    IN DWORD                ExpectedError
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    DWORD   LStatus;
    ULONG   i, j;
    PWCHAR  Dn          = NULL;
    LDAPMod **Mod       = NULL;

    //
    // CREATE ATTRIBUTES OR CLASSES
    //
    for (j = 0; Creates[j]; ++j) {
        Dn = ExtendDn(SchemaDn, Creates[j]->Cn);
        printf("    %-30ws: CRE\n", Creates[j]->Cn);
        for (i = 0; Creates[j]->AlterAttrs[i].Attr; ++i) {
            AddMod(Creates[j]->AlterAttrs[i].Attr,
                   Creates[j]->AlterAttrs[i].Value,
                   &Mod);
        }
        LStatus = ldap_add_s(Ldap, Dn, Mod);
        if (LStatus != LDAP_SUCCESS &&
            LStatus != ExpectedError) {
            fprintf(stderr, "%-30ws  ERROR %ws\n",
                    L"", ldap_err2string(LStatus));
        }
        FreeMod(&Mod);
        FREE(Dn);
    }
}


VOID
UpdateSchema(
    IN PLDAP                Ldap,
    IN PWCHAR               SchemaDn,
    IN BOOL                 Hammering,
    IN struct AlterClass    *Updates[]
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    DWORD   LStatus;
    ULONG   i, j;
    PWCHAR  Dn          = NULL;
    LDAPMod **Mod       = NULL;

    //
    // ALTER EXISTING CLASSES
    //
    for (j = 0; Updates[j]; ++j) {
        Dn = ExtendDn(SchemaDn, Updates[j]->Cn);
        for (i = 0; Updates[j]->AlterAttrs[i].Attr; ++i) {
            AddMod(Updates[j]->AlterAttrs[i].Attr,
                   Updates[j]->AlterAttrs[i].Value,
                   &Mod);
            if (Hammering) {
                printf("    %-30ws: ADD %ws = %ws\n",
                       Updates[j]->Cn,
                       Updates[j]->AlterAttrs[i].Attr,
                       Updates[j]->AlterAttrs[i].Value);
                LStatus = ldap_modify_s(Ldap, Dn, Mod);
                if (LStatus != LDAP_SUCCESS &&
                    LStatus != LDAP_ATTRIBUTE_OR_VALUE_EXISTS) {
                    fprintf(stderr, "%-30ws  ERROR %ws\n",
                            L"", ldap_err2string(LStatus));
                }
            } else {
                printf("    %-30ws: DEL %ws = %ws\n",
                       Updates[j]->Cn,
                       Updates[j]->AlterAttrs[i].Attr,
                       Updates[j]->AlterAttrs[i].Value);
                Mod[0]->mod_op = LDAP_MOD_DELETE;
                LStatus = ldap_modify_s(Ldap, Dn, Mod);
                if (LStatus != LDAP_SUCCESS &&
                    LStatus != LDAP_NO_SUCH_ATTRIBUTE &&
                    LStatus != LDAP_NO_SUCH_OBJECT) {
                    fprintf(stderr, "%-30ws  ERROR %ws\n",
                            L"", ldap_err2string(LStatus));
                }
            }
            FreeMod(&Mod);
        }
        FREE(Dn);
    }
}


VOID
DeleteSchema(
    IN PLDAP                Ldap,
    IN PWCHAR               SchemaDn,
    IN struct AlterClass    *Deletes[],
    IN DWORD                ExpectedError
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    PWCHAR Dn       = NULL;
    DWORD  LStatus;
    ULONG  j;

    //
    // DELETE ATTRIBUTES OR CLASSES
    //
    for (j = 0; Deletes[j]; ++j) {
        Dn = ExtendDn(SchemaDn, Deletes[j]->Cn);
        printf("    %-30ws: DEL\n", Deletes[j]->Cn);
        LStatus = ldap_delete_s(Ldap, Dn);
        if (LStatus != LDAP_SUCCESS &&
            LStatus != ExpectedError) {
            fprintf(stderr, "%-30ws  ERROR %ws\n",
                    L"", ldap_err2string(LStatus));
        }
        FREE(Dn);
    }
}


VOID
RefreshSchema(
    IN PLDAP Ldap
    )
/*++
Routine Description:

Arguments:
    None.

Return Value:
    None.
--*/
{
    DWORD           LStatus;
    LDAPMod         **Mod               = NULL;

    AddMod(L"schemaUpdateNow", L"1", &Mod);
    LStatus = ldap_modify_s(Ldap, L"", Mod);
    FreeMod(&Mod);
    if (LStatus != LDAP_SUCCESS) {
        fprintf(stderr, "Can't force schema update; %ws\n",
                ldap_err2string(LStatus));
        printf("Waiting 5 minutes for schema updates to take effect\n");
        Sleep(5 * 60 * 1000);
    }
}

#define NTDS_SERVICE        L"NTDS"
#define NTDS_ROOT           L"System\\CurrentControlSet\\Services\\" NTDS_SERVICE
#define NTDS_PARAMETERS     NTDS_ROOT L"\\Parameters"
#define NTDS_UPDATE_SCHEMA  L"Schema Update Allowed"
#define NTDS_DELETE_SCHEMA  L"Schema Delete Allowed"


BOOL
PutRegDWord(
    IN PWCHAR   FQKey,
    IN PWCHAR   Value,
    IN DWORD    DWord
    )
/*++
Routine Description:
    This function writes a keyword value into the registry.

Arguments:
    HKey    - Key to be read
    Param   - value string to update
    DWord   - dword to be written

Return Value:
    TRUE    - Success
    FALSE   - Not
--*/
{
#define  DEBSUB  "PutRegDWord:"
    HKEY    HKey;
    DWORD   WStatus;

    //
    // Open the key
    //
    WStatus = RegOpenKey(HKEY_LOCAL_MACHINE, FQKey, &HKey);
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr, "[%ws] \"%ws\" Could not open. WStatus %d\n",
            FQKey, Value, WStatus);
        return FALSE;
    }
    //

    //
    // Write the value
    //
    WStatus = RegSetValueEx(HKey,
                            Value,
                            0,
                            REG_DWORD,
                            (PUCHAR)&DWord,
                            sizeof(DWord));
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr, "%ws: Value not written; WStatus %d\n", Value, WStatus);
        return FALSE;
    }
    return TRUE;
}


VOID
HammerSchema(
    IN BOOL Hammering
    )
/*++
Routine Description:

Arguments:
    None.

Return Value:
    None.
--*/
{
    DWORD           LStatus;
    PLDAP           Ldap                = NULL;
    PWCHAR          SchemaDn            = NULL;
    PWCHAR          Dn                  = NULL;
    LDAPMod         **Mod               = NULL;
    ULONG           i, j;

    if (Hammering) {
        printf("UPDATING SCHEMA...\n");
        if (!PutRegDWord(NTDS_PARAMETERS, NTDS_UPDATE_SCHEMA, 1)) {
            fprintf(stderr, "Could not enable schema update\n");
            return;
        }
    } else {
        printf("RESTORING SCHEMA...\n");
        if (!PutRegDWord(NTDS_PARAMETERS, NTDS_UPDATE_SCHEMA, 1)) {
            fprintf(stderr, "Could not enable schema update\n");
            return;
        }
        if (!PutRegDWord(NTDS_PARAMETERS, NTDS_DELETE_SCHEMA, 1)) {
            fprintf(stderr, "Could not enable schema deletes\n");
            return;
        }
    }

    //
    // Bind to the ds
    //
    Ldap = FrsDsOpenDs();
    if (!Ldap) {
        return;
    }
    SchemaDn = GetRootDn(Ldap, SCHEMA_NAMING_CONTEXT);
    if (!SchemaDn) {
        return;
    }

    //
    // CREATE/DELETE ATTRIBUTES AND CLASSES
    //
    if (Hammering) {
        CreateSchema(Ldap,
                     SchemaDn,
                     CreateAttributes,
                     LDAP_ALREADY_EXISTS);
        RefreshSchema(Ldap);
        CreateSchema(Ldap,
                     SchemaDn,
                     CreateClasses,
                     LDAP_ALREADY_EXISTS);
        RefreshSchema(Ldap);
        UpdateSchema(Ldap,
                     SchemaDn,
                     Hammering,
                     AlterSchema);
    } else {
        UpdateSchema(Ldap,
                     SchemaDn,
                     Hammering,
                     AlterSchema);
        RefreshSchema(Ldap);
        DeleteSchema(Ldap,
                     SchemaDn,
                     CreateClasses,
                     LDAP_NO_SUCH_OBJECT);
        RefreshSchema(Ldap);
        DeleteSchema(Ldap,
                     SchemaDn,
                     CreateAttributes,
                     LDAP_NO_SUCH_OBJECT);
    }
    RefreshSchema(Ldap);
    if (Hammering) {
        printf("SCHEMA UPDATE COMPLETE\n");
    } else {
        printf("SCHEMA RESTORE COMPLETE\n");
    }
    ldap_unbind(Ldap);
    FREE(SchemaDn);
    return;
}


PWCHAR
GetCoDn(
    IN  PLDAP   Ldap,
    IN  PWCHAR  Member,
    OUT PWCHAR  *ServerDn
    )
/*++
Routine Description:
    Find the computer object for Member

Arguments:
    Ldap
    Member
    ServerDn

Return Value:
    Dn of computer object or NULL. Free with FREE.
--*/
{
    PWCHAR          *Values     = NULL;
    PLDAPMessage    LdapMsg     = NULL;
    PLDAPMessage    LdapEntry   = NULL;
    PWCHAR          CoDn        = NULL;
    PWCHAR          Attrs[16];
    WCHAR           Filter[MAX_PATH + 1];



    //
    // Find the default naming context
    //
    Values = GetValues(Ldap, CN_ROOT, ATTR_DEFAULT_NAMING_CONTEXT, TRUE);
    if (!Values) {
        return NULL;
    }
    //
    // Find the computer object with class=computer
    //
    swprintf(Filter,
             L"(&%s(sAMAccountName=%s$))",
             CATEGORY_COMPUTER,
             Member);

    Attrs[0] = ATTR_DN;
    Attrs[1] = ATTR_SERVER_REF;
    Attrs[2] = ATTR_SERVER_REF_BL;
    Attrs[3] = NULL;
    if (LdapSearch(Ldap, Values[0], LDAP_SCOPE_SUBTREE, Filter,
                   Attrs, 0, &LdapMsg, FALSE)) {
        LdapEntry = ldap_first_entry(Ldap, LdapMsg);
        if (LdapEntry) {
            CoDn = FindValue(Ldap, LdapEntry, ATTR_DN);
            if (ServerDn) {
                *ServerDn = FindValue(Ldap, LdapEntry, ATTR_SERVER_REF_BL);
                if (!*ServerDn) {
                    *ServerDn = FindValue(Ldap, LdapEntry, ATTR_SERVER_REF);
                }
            }
        }
        ldap_msgfree(LdapMsg);
    }
    if (CoDn) {
        return CoDn;
    }
    //
    // Find the computer object with class=computer (possible after
    // an NT4 to NT5 upgrade.
    //
    swprintf(Filter,
             L"(&%s(sAMAccountName=%s$))",
             CATEGORY_USER,
             Member);

    Attrs[0] = ATTR_DN;
    Attrs[1] = ATTR_SERVER_REF;
    Attrs[2] = ATTR_SERVER_REF_BL;
    Attrs[3] = NULL;
    if (LdapSearch(Ldap, Values[0], LDAP_SCOPE_SUBTREE, Filter,
                   Attrs, 0, &LdapMsg, FALSE)) {
        LdapEntry = ldap_first_entry(Ldap, LdapMsg);
        if (LdapEntry) {
            CoDn = FindValue(Ldap, LdapEntry, ATTR_DN);
            if (ServerDn) {
                *ServerDn = FindValue(Ldap, LdapEntry, ATTR_SERVER_REF_BL);
                if (!*ServerDn) {
                    *ServerDn = FindValue(Ldap, LdapEntry, ATTR_SERVER_REF);
                }
            }
        }
        ldap_msgfree(LdapMsg);
    }
    ldap_value_free(Values);
    return CoDn;
}


PWCHAR
GetSiteName(
    IN  PWCHAR  Member
    )
/*++
Routine Description:
    Retrieve this machine's site name. We assume the site name
    matches the site container's name in the DS.

Arguments:
    Member - corresponds to site container's name

Return Value:
    Site name or NULL. Free with FREE.
--*/
{
    DWORD   WStatus;
    PWCHAR  Name;
    PWCHAR  Site;

    //
    // Get this machine's DNS name
    //
    WStatus = DsGetSiteName(Member, &Name);
    if (!WIN_SUCCESS(WStatus)) {
        return NULL;
    }
    Site = FrsWcsDup(Name);
    NetApiBufferFree(Name);
    return Site;
}


PWCHAR
GetServerDn(
    IN PLDAP    Ldap,
    IN PWCHAR   Member
    )
/*++
Routine Description:
    Find our server object (assumes that machine name == server name)

Arguments:
    Ldap
    Member

Return Value:
    Server DN (if any)
--*/
{
    PWCHAR          *Values             = NULL;
    PWCHAR          ConfigDn            = NULL;
    PWCHAR          SitesDn             = NULL;
    PWCHAR          Site                = NULL;
    PWCHAR          SiteDn              = NULL;
    PWCHAR          ServersDn           = NULL;
    PWCHAR          ServerDn            = NULL;
    PWCHAR          SettingsDn          = NULL;
    PWCHAR          RealServerDn        = NULL;

    //
    // Return all of the values for the attribute namingContexts
    //
    ConfigDn = GetRootDn(Ldap, CONFIG_NAMING_CONTEXT);
    if (!ConfigDn) {
        return NULL;
    }
    SitesDn = ExtendDn(ConfigDn, CN_SITES);
    Site = GetSiteName(Member);
    if (!Site) {
        goto out;
    }
    SiteDn = ExtendDn(SitesDn, Site);
    ServersDn = ExtendDn(SiteDn, CN_SERVERS);
    ServerDn = ExtendDn(ServersDn, Member);
    SettingsDn = ExtendDn(ServerDn, CN_NTDS_SETTINGS);
    Values = GetValues(Ldap, SettingsDn, ATTR_DN, TRUE);
    if (!Values) {
        goto out;
    }
    RealServerDn = FrsWcsDup(Values[0]);

out:
    FREE(ConfigDn);
    FREE(SitesDn);
    FREE(SiteDn);
    FREE(Site);
    FREE(ServersDn);
    FREE(ServerDn);
    FREE(SettingsDn);
    return RealServerDn;
}


#define SIZEOF_EXTENSIONS   127
VOID
CreateReplicationWorld(
    IN DWORD    argc,
    IN PWCHAR   *Argv,
    IN BOOL     IsPrimary
    )
/*++
Routine Description:
    Create the required objects

Arguments:

Return Value:
    None.
--*/
{
    DWORD           WStatus;
    DWORD           LStatus;
    ULONG           ScheduleLength;
    PWCHAR          Member;
    PWCHAR          Set;
    PWCHAR          Root;
    PWCHAR          Stage;
    GUID            NewGuid;
    GUID            OldGuid;
    CHAR            Extensions[SIZEOF_EXTENSIONS];
    PLDAP           Ldap                = NULL;
    PWCHAR          CoDn                = NULL;
    PWCHAR          SubsDn              = NULL;
    PWCHAR          SubDn               = NULL;
    PWCHAR          Subscriber          = NULL;
    PWCHAR          ConfigDn            = NULL;
    PWCHAR          ServerDn            = NULL;
    PWCHAR          ServicesDn          = NULL;
    PWCHAR          SettingsDn          = NULL;
    PWCHAR          SetDn               = NULL;
    PWCHAR          MemberDn            = NULL;
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    PSCHEDULE       Schedule            = NULL;
    PWCHAR          Cn                  = NULL;
    LDAPMod         **Mod               = NULL;

    Set = Argv[2];
    if (argc > 2) {
        Member = Argv[3];
    }
    if (argc > 3) {
        Root = Argv[4];
        Stage = Argv[5];
    }

    //
    // Bind to the ds
    //
    Ldap = FrsDsOpenDs();
    if (!Ldap) {
        return;
    }

    //
    // ADMIN SIDE
    //
    //
    // Services Dn
    //
    ConfigDn = GetRootDn(Ldap, CONFIG_NAMING_CONTEXT);
    if (!ConfigDn) {
        return;
    }
    ServicesDn = ExtendDn(ConfigDn, CN_SERVICES);
    SettingsDn = ExtendDn(ServicesDn, CN_TEST_SETTINGS);

    //
    // Settings
    //
    UuidCreateNil(&OldGuid);
    AddMod(ATTR_CLASS, ATTR_NTFRS_SETTINGS, &Mod);
    // AddBerMod(ATTR_EXTENSIONS, Extensions, SIZEOF_EXTENSIONS, &Mod);
    LStatus = ldap_add_s(Ldap, SettingsDn, Mod);
    FreeMod(&Mod);
    if (LStatus != LDAP_ALREADY_EXISTS && LStatus != LDAP_SUCCESS) {
        //
        // May be a new schema that lacks the old version guid
        //
        AddBerMod(ATTR_OLD_VERSION_GUID, (PCHAR)&OldGuid, sizeof(GUID), &Mod);
        AddMod(ATTR_CLASS, ATTR_NTFRS_SETTINGS, &Mod);
        // AddBerMod(ATTR_EXTENSIONS, Extensions, sizeof(SIZEOF_EXTENSIONS), &Mod);
        LStatus = ldap_add_s(Ldap, SettingsDn, Mod);
        FreeMod(&Mod);
        if (LStatus != LDAP_ALREADY_EXISTS && LStatus != LDAP_SUCCESS) {
            fprintf(stderr, "ERROR - Can't create %ws: %ws\n",
                    SettingsDn, ldap_err2string(LStatus));
            goto out;
        }
    }

    //
    // Set
    //
    SetDn = ExtendDn(SettingsDn, Set);
    AddMod(ATTR_CLASS, ATTR_REPLICA_SET, &Mod);
    AddMod(ATTR_SET_TYPE, FRS_RSTYPE_OTHERW, &Mod);
    // AddMod(ATTR_DIRECTORY_FILTER, ATTR_DIRECTORY_FILTER, &Mod);
    // AddMod(ATTR_FILE_FILTER, ATTR_FILE_FILTER, &Mod);
    // AddMod(ATTR_DS_POLL, L"17", &Mod);
    // AddMod(ATTR_FLAGS, L"18", &Mod);
    // AddMod(ATTR_LEVEL_LIMIT, L"18", &Mod);
    // AddMod(ATTR_AUTH_LEVEL, L"18", &Mod);
    // AddBerMod(ATTR_EXTENSIONS, Extensions, SIZEOF_EXTENSIONS, &Mod);
    // AddBerMod(ATTR_NEW_SET_GUID,     (PCHAR)&NewGuid, sizeof(GUID), &Mod);
    // AddBerMod(ATTR_NEW_VERSION_GUID, (PCHAR)&NewGuid, sizeof(GUID), &Mod);
    ConditionalBuildSchedule(&Schedule, &ScheduleLength);
    if (Schedule) {
        AddBerMod(ATTR_SCHEDULE, (PCHAR)Schedule, ScheduleLength, &Mod);
    }
    LStatus = ldap_add_s(Ldap, SetDn, Mod);
    FreeMod(&Mod);
    if (LStatus != LDAP_ALREADY_EXISTS && LStatus != LDAP_SUCCESS) {
        //
        // May be a new schema that lacks the old set guid
        //
        AddMod(ATTR_CLASS, ATTR_REPLICA_SET, &Mod);
        AddMod(ATTR_SET_TYPE, FRS_RSTYPE_OTHERW, &Mod);
        // AddMod(ATTR_DIRECTORY_FILTER, ATTR_DIRECTORY_FILTER, &Mod);
        // AddMod(ATTR_FILE_FILTER, ATTR_FILE_FILTER, &Mod);
        // AddMod(ATTR_DS_POLL, L"17", &Mod);
        // AddMod(ATTR_FLAGS, L"18", &Mod);
        // AddMod(ATTR_LEVEL_LIMIT, L"18", &Mod);
        // AddMod(ATTR_AUTH_LEVEL, L"18", &Mod);
        // AddBerMod(ATTR_EXTENSIONS, Extensions, SIZEOF_EXTENSIONS, &Mod);
        AddBerMod(ATTR_OLD_SET_GUID,     (PCHAR)&OldGuid, sizeof(GUID), &Mod);
        AddBerMod(ATTR_NEW_SET_GUID,     (PCHAR)&NewGuid, sizeof(GUID), &Mod);
        AddBerMod(ATTR_NEW_VERSION_GUID, (PCHAR)&NewGuid, sizeof(GUID), &Mod);
        ConditionalBuildSchedule(&Schedule, &ScheduleLength);
        if (Schedule) {
            AddBerMod(ATTR_SCHEDULE, (PCHAR)Schedule, ScheduleLength, &Mod);
        }
        LStatus = ldap_add_s(Ldap, SetDn, Mod);
        FreeMod(&Mod);
        if (LStatus != LDAP_ALREADY_EXISTS && LStatus != LDAP_SUCCESS) {
            fprintf(stderr, "ERROR - Can't create %ws: %ws\n",
                    SetDn, ldap_err2string(LStatus));
            goto out;
        }
    }

    if (argc < 4) {
        goto out;
    }

    //
    // Member
    //
    CoDn = GetCoDn(Ldap, Member, &ServerDn);
    if (!CoDn) {
        fprintf(stderr, "ERROR - Can't get computer object for %ws\n", Member);
        goto out;
    }
    //
    // The CO doesn't have a server reference; create one
    //
    if (!ServerDn) {
        ServerDn = GetServerDn(Ldap, Member);
        if (ServerDn) {
            AddMod(ATTR_SERVER_REF, ServerDn, &Mod);
            LStatus = ldap_modify_s(Ldap, CoDn, Mod);
            FreeMod(&Mod);
            if (LStatus != LDAP_ATTRIBUTE_OR_VALUE_EXISTS &&
                LStatus != LDAP_SUCCESS) {
                AddMod(ATTR_SERVER_REF, CoDn, &Mod);
                LStatus = ldap_modify_s(Ldap, ServerDn, Mod);
                FreeMod(&Mod);
                if (LStatus != LDAP_ATTRIBUTE_OR_VALUE_EXISTS &&
                    LStatus != LDAP_SUCCESS) {
                    fprintf(stderr, "ERROR - Can't update server reference for %ws: %ws\n",
                            CoDn, ldap_err2string(LStatus));
                    fprintf(stderr, "ERROR - Server %ws\n", ServerDn);
                    FREE(ServerDn);
                }
            }
        }
    }
    MemberDn = ExtendDn(SetDn, Member);
    AddMod(ATTR_CLASS, ATTR_MEMBER, &Mod);
    AddMod(ATTR_COMPUTER_REF, CoDn, &Mod);
    // AddMod(ATTR_CONTROL_CREATION, ATTR_CONTROL_CREATION, &Mod);
    // AddMod(ATTR_INBOUND_BACKLOG, ATTR_INBOUND_BACKLOG, &Mod);
    // AddMod(ATTR_OUTBOUND_BACKLOG, ATTR_OUTBOUND_BACKLOG, &Mod);
    // AddMod(ATTR_SERVICE_COMMAND, ATTR_SERVICE_COMMAND, &Mod);
    // AddMod(ATTR_UPDATE_TIMEOUT, L"50", &Mod);
    // AddMod(ATTR_AUTH_LEVEL, L"18", &Mod);
    // AddMod(ATTR_FLAGS, L"3", &Mod);
    // AddBerMod(ATTR_EXTENSIONS, Extensions, SIZEOF_EXTENSIONS, &Mod);
    if (ServerDn) {
        AddMod(ATTR_SERVER_REF, ServerDn, &Mod);
    }
    LStatus = ldap_add_s(Ldap, MemberDn, Mod);
    if (LStatus != LDAP_ALREADY_EXISTS && LStatus != LDAP_SUCCESS) {
        fprintf(stderr, "ERROR - Can't create %ws: %ws\n",
                MemberDn, ldap_err2string(LStatus));
        goto out;
    }
    FreeMod(&Mod);

    //
    // Primary member reference on set
    //
    if (IsPrimary) {
        AddMod(ATTR_PRIMARY_MEMBER, MemberDn, &Mod);
        Mod[0]->mod_op = LDAP_MOD_REPLACE;
        LStatus = ldap_modify_s(Ldap, SetDn, Mod);
        if (LStatus != LDAP_ALREADY_EXISTS && LStatus != LDAP_SUCCESS) {
            fprintf(stderr, "ERROR - Can't set primary member to %ws for %ws: %ws\n",
                    MemberDn, SetDn, ldap_err2string(LStatus));
            goto out;
        }
        FreeMod(&Mod);
      }

    //
    // USER SIDE
    //
    //
    // Subscriptions
    //
    SubsDn = ExtendDn(CoDn, CN_SUBSCRIPTIONS);
    AddMod(ATTR_CLASS, ATTR_SUBSCRIPTIONS, &Mod);
    // AddMod(ATTR_WORKING, L"%SystemRoot%\\ntfrs", &Mod);
    // AddMod(ATTR_VERSION, ATTR_VERSION, &Mod);
    // AddBerMod(ATTR_EXTENSIONS, Extensions, SIZEOF_EXTENSIONS, &Mod);
    LStatus = ldap_add_s(Ldap, SubsDn, Mod);
    if (LStatus != LDAP_ALREADY_EXISTS && LStatus != LDAP_SUCCESS) {
        fprintf(stderr, "ERROR - Can't create %ws: %ws\n",
                SubsDn, ldap_err2string(LStatus));
        goto out;
    }
    FreeMod(&Mod);

    //
    // Subscriber
    //
    Subscriber = FrsWcsCat(Set, Member);
    SubDn = ExtendDn(SubsDn, Subscriber);
    AddMod(ATTR_CLASS, ATTR_SUBSCRIBER, &Mod);
    AddMod(ATTR_REPLICA_ROOT, Root, &Mod);
    AddMod(ATTR_REPLICA_STAGE, Stage, &Mod);
    AddMod(ATTR_MEMBER_REF, MemberDn, &Mod);
    // AddBerMod(ATTR_EXTENSIONS, Extensions, SIZEOF_EXTENSIONS, &Mod);
    // AddMod(ATTR_FAULT_CONDITION, L"NONE", &Mod);
    // AddMod(ATTR_FLAGS, L"1", &Mod);
    // AddMod(ATTR_SERVICE_COMMAND, ATTR_SERVICE_COMMAND, &Mod);
    // AddMod(ATTR_SERVICE_COMMAND_STATUS, L"100", &Mod);
    // AddMod(ATTR_UPDATE_TIMEOUT, L"100", &Mod);
    ConditionalBuildSchedule(&Schedule, &ScheduleLength);
    if (Schedule) {
        AddBerMod(ATTR_SCHEDULE, (PCHAR)Schedule, ScheduleLength, &Mod);
        FREE(Schedule);
    }
    LStatus = ldap_add_s(Ldap, SubDn, Mod);
    if (LStatus != LDAP_ALREADY_EXISTS && LStatus != LDAP_SUCCESS) {
        fprintf(stderr, "ERROR - Can't create %ws: %ws\n",
                SubDn, ldap_err2string(LStatus));
        goto out;
    }
    FreeMod(&Mod);

out:
    ldap_unbind(Ldap);
    if (LdapMsg) {
        ldap_msgfree(LdapMsg);
    }
    FREE(Schedule);
    FREE(Cn);
    FREE(ConfigDn);
    FREE(ServicesDn);
    FREE(SetDn);
    FREE(SettingsDn);
    FREE(MemberDn);
    FREE(CoDn);
    FREE(SubsDn);
    FREE(Subscriber);
    FREE(SubDn);
    FREE(ServerDn);
    FreeMod(&Mod);
}


PWCHAR DupNames[] = {L"_A", L"_B", L"_C", L"_D", L"_E", L"_F", L"_G", L"_H", NULL};
VOID
CreateInbounds(
    IN DWORD    argc,
    IN WCHAR    **Argv
    )
/*++
Routine Description:

Arguments:

Return Value:
    None.
--*/
{
    ULONG           i;
    DWORD           LStatus;
    ULONG           ScheduleLength;
    ULONG           dupx;
    PLDAP           Ldap                = NULL;
    PWCHAR          Cxtion              = NULL;
    PWCHAR          ConfigDn            = NULL;
    PWCHAR          ServicesDn          = NULL;
    PWCHAR          SettingsDn          = NULL;
    PWCHAR          SetDn               = NULL;
    PWCHAR          ServerDn            = NULL;
    PWCHAR          CxtionDn            = NULL;
    PWCHAR          CxtionDnDup         = NULL;

    PWCHAR          PartnerDn           = NULL;
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;
    PSCHEDULE       Schedule            = NULL;
    LDAPMod         **Mod               = NULL;



    //
    // Bind to the ds
    //
    Ldap = FrsDsOpenDs();
    if (!Ldap) {
        return;
    }

    //
    // Server Dn
    //
    ConfigDn = GetRootDn(Ldap, CONFIG_NAMING_CONTEXT);
    if (!ConfigDn) {
        return;
    }
    ServicesDn = ExtendDn(ConfigDn, CN_SERVICES);
    SettingsDn = ExtendDn(ServicesDn, CN_TEST_SETTINGS);


    SetDn = ExtendDn(SettingsDn, Argv[2]);
    ServerDn = ExtendDn(SetDn, Argv[3]);

    for (i = 4; i < argc; ++i) {
        PartnerDn = ExtendDn(SetDn, Argv[i]);
        Cxtion = FrsWcsCat(L"From_", Argv[i]);
        CxtionDn = ExtendDn(ServerDn, Cxtion);
        FREE(Cxtion);

        //
        // Inbounds
        //
        AddMod(ATTR_CLASS, ATTR_CXTION, &Mod);
        AddMod(ATTR_FROM_SERVER, PartnerDn, &Mod);
        AddMod(ATTR_ENABLED_CXTION, ATTR_TRUE, &Mod);
        AddMod(ATTR_OPTIONS, ATTR_OPTIONS_0, &Mod);
        ConditionalBuildSchedule(&Schedule, &ScheduleLength);
        if (Schedule) {
            AddBerMod(ATTR_SCHEDULE, (PCHAR)Schedule, ScheduleLength, &Mod);
            FREE(Schedule);
        }
        LStatus = ldap_add_s(Ldap, CxtionDn, Mod);

        dupx = 0;
        while ((LStatus == LDAP_ALREADY_EXISTS) && (DupNames[dupx] != NULL)) {
            //
            // Try to create a duplicate connection object by putting a suffix on the name.
            //
            Cxtion = FrsWcsCat(L"From_", Argv[i]);
            CxtionDnDup = FrsWcsCat(Cxtion, DupNames[dupx]);
            CxtionDn = ExtendDn(ServerDn, CxtionDnDup);
            FREE(Cxtion);
            FREE(CxtionDnDup);

            LStatus = ldap_add_s(Ldap, CxtionDn, Mod);
            if (LStatus != LDAP_ALREADY_EXISTS) {
                //
                // Dup cxtion created.
                //
                break;
            }
            dupx++;
        }
        if (LStatus != LDAP_ALREADY_EXISTS && LStatus != LDAP_SUCCESS) {
            fprintf(stderr, "ERROR - Can't create %ws: %ws\n",
                    CxtionDn, ldap_err2string(LStatus));
        }
        FreeMod(&Mod);
        FREE(PartnerDn);
        FREE(CxtionDn);
    }
    FREE(ServerDn);
    FREE(SetDn);
    FREE(SettingsDn);
    FREE(ServicesDn);
    FREE(ConfigDn);
    if (Ldap) {
        ldap_unbind(Ldap);
    }
}


BOOL
DeleteUserSubTree(
    IN PLDAP    Ldap,
    IN PWCHAR   Dn
    )
/*++
Routine Description:

Arguments:

Return Value:
--*/
{
    DWORD           LStatus;
    PWCHAR          DesiredAttrs[16];
    PWCHAR          Bl                  = NULL;
    PWCHAR          Co                  = NULL;
    PWCHAR          SubsDn              = NULL;
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;

    DesiredAttrs[0] = ATTR_MEMBER_REF_BL;
    DesiredAttrs[1] = ATTR_COMPUTER_REF;
    DesiredAttrs[2] = ATTR_CLASS;
    DesiredAttrs[3] = NULL;
    LStatus = ldap_search_s(Ldap, Dn, LDAP_SCOPE_BASE, CATEGORY_ANY,
                            DesiredAttrs, 0, &LdapMsg);
    if (LStatus == LDAP_SUCCESS) {
        LdapEntry = ldap_first_entry(Ldap, LdapMsg);

        Co = FindValue(Ldap, LdapEntry, ATTR_COMPUTER_REF);
        Bl = FindValue(Ldap, LdapEntry, ATTR_MEMBER_REF_BL);
        if (Bl && Dn) {
            LStatus = ldap_delete_s(Ldap, Bl);
            if (LStatus != LDAP_SUCCESS && LStatus != LDAP_NO_SUCH_OBJECT) {
                fprintf(stderr, "ERROR - Can't delete BL: %ws\n",
                        ldap_err2string(LStatus));
                fprintf(stderr, "        %ws\n", Dn);
                fprintf(stderr, "        BL %ws\n", Bl);
                FREE(Bl);
                FREE(Dn);
                FREE(Co);
                return FALSE;
            }
        }
        if (Co) {
            SubsDn = ExtendDn(Co, CN_SUBSCRIPTIONS);
            LStatus = ldap_delete_s(Ldap, SubsDn);
            if (LStatus != LDAP_NO_SUCH_OBJECT &&
                LStatus != LDAP_SUCCESS &&
                LStatus != LDAP_NOT_ALLOWED_ON_NONLEAF) {
                fprintf(stderr, "ERROR - Can't delete: %ws\n", ldap_err2string(LStatus));
                fprintf(stderr, "        %ws\n", SubsDn);
                FREE(SubsDn);
                FREE(Bl);
                FREE(Dn);
                FREE(Co);
                return FALSE;
            }
            FREE(SubsDn);
        }
        FREE(Bl);
        FREE(Dn);
        FREE(Co);
        ldap_msgfree(LdapMsg);
    } else if (LStatus != LDAP_NO_SUCH_OBJECT) {
        fprintf(stderr, "ERROR - Can't find: %ws\n", ldap_err2string(LStatus));
        fprintf(stderr, "        %ws\n", Dn);
    }
    return TRUE;
}


VOID
FrsDsDeleteSubTree(
    IN PLDAP    Ldap,
    IN PWCHAR   ParentDn
    )
/*++
Routine Description:

Arguments:
    None.

Return Value:
    None.
--*/
{
    DWORD           LStatus;
    PWCHAR          DesiredAttrs[16];
    PWCHAR          NextDn              = NULL;
    PLDAPMessage    LdapMsg             = NULL;
    PLDAPMessage    LdapEntry           = NULL;

    DesiredAttrs[0] = ATTR_DN;
    DesiredAttrs[1] = NULL;
    LStatus = ldap_search_s(Ldap, ParentDn, LDAP_SCOPE_ONELEVEL, CATEGORY_ANY,
                            DesiredAttrs, 0, &LdapMsg);
    if (LStatus == LDAP_SUCCESS) {
        //
        // Scan the entries returned from ldap_search
        //
        for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
             LdapEntry != NULL;
             LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
            NextDn = FindValue(Ldap, LdapEntry, ATTR_DN);
            if (NextDn) {
                FrsDsDeleteSubTree(Ldap, NextDn);
                FREE(NextDn);
            }
        }
        ldap_msgfree(LdapMsg);
        if (DeleteUserSubTree(Ldap, ParentDn)) {
            LStatus = ldap_delete_s(Ldap, ParentDn);
            if (LStatus != LDAP_SUCCESS) {
                fprintf(stderr, "ERROR - Can't delete: %ws\n", ldap_err2string(LStatus));
                fprintf(stderr, "        %ws\n", ParentDn);
            }
        }
    } else if (LStatus != LDAP_NO_SUCH_OBJECT) {
        fprintf(stderr, "ERROR - Can't find: %ws\n", ldap_err2string(LStatus));
        fprintf(stderr, "        %ws\n", ParentDn);
    }
}


VOID
DeleteReplicationWorld(
    IN DWORD    argc,
    IN PWCHAR   *Argv,
    IN PWCHAR   Settings
    )
/*++
Routine Description:
    Create the required objects

Arguments:
    None.

Return Value:
    None.
--*/
{
    PWCHAR          Dn;
    PWCHAR          ConfigDn    = NULL;
    PWCHAR          ServicesDn  = NULL;
    PWCHAR          SettingsDn  = NULL;
    PWCHAR          SetDn       = NULL;
    PWCHAR          ServerDn    = NULL;
    PWCHAR          Cxtion      = NULL;
    PWCHAR          CxtionDn    = NULL;
    PLDAP           Ldap        = NULL;

    //
    // Bind to the ds
    //
    Ldap = FrsDsOpenDs();
    if (!Ldap) {
        return;
    }

    //
    // Services
    //
    ConfigDn = GetRootDn(Ldap, CONFIG_NAMING_CONTEXT);
    if (!ConfigDn) {
        return;
    }
    ServicesDn = ExtendDn(ConfigDn, CN_SERVICES);
    SettingsDn = ExtendDn(ServicesDn, Settings);
    Dn = SettingsDn;
    if (argc > 2) {
        SetDn = ExtendDn(SettingsDn, Argv[2]);
        Dn = SetDn;
    }
    if (argc > 3) {
        ServerDn = ExtendDn(SetDn, Argv[3]);
        Dn = ServerDn;
    }
    if (argc > 4) {
        Cxtion = FrsWcsCat(L"From_", Argv[4]);
        CxtionDn = ExtendDn(ServerDn, Cxtion);
        Dn = CxtionDn;
    }

    FrsDsDeleteSubTree(Ldap, Dn);

// out:
    ldap_unbind(Ldap);
    FREE(CxtionDn);
    FREE(Cxtion);
    FREE(ServerDn);
    FREE(SetDn);
    FREE(SettingsDn);
    FREE(ServicesDn);
    FREE(ConfigDn);
}


VOID
ModifyFilter(
    IN DWORD    argc,
    IN PWCHAR   *Argv
    )
/*++
Routine Description:
    Change the file and directory filter for the replica set specified.

Arguments:
    argc    - From main
    argv    - From main

Return Value:
    None.
--*/
{
    DWORD           LStatus             = LDAP_SUCCESS;
    PWCHAR          Set;
    PWCHAR          NewFilter;
    PWCHAR          ConfigDn            = NULL;
    PWCHAR          ServicesDn          = NULL;
    PWCHAR          SettingsDn          = NULL;
    PWCHAR          SetDn               = NULL;
    PLDAP           Ldap                = NULL;
    LDAPMod         **Mod               = NULL;

    Set = Argv[3];
    if(argc > 4){
        NewFilter = Argv[4];
    }
    else{
      NewFilter = L" ";
    }

    //
    // Bind to the ds
    //
    Ldap = FrsDsOpenDs();
    if (!Ldap) {
        return;
    }

    //
    // ADMIN SIDE
    //
    //
    // Services Dn
    //
    ConfigDn = GetRootDn(Ldap, CONFIG_NAMING_CONTEXT);
    if (!ConfigDn) {
        return;
    }
    ServicesDn = ExtendDn(ConfigDn, CN_SERVICES);
    SettingsDn = ExtendDn(ServicesDn, CN_TEST_SETTINGS);
    SetDn = ExtendDn(SettingsDn, Set);

    if(!wcscmp(Argv[2],L"/clear")){
        if(!wcscmp(Argv[1],L"/dirfilter")){
            AddMod(ATTR_DIRECTORY_FILTER, L" ", &Mod);
            (*Mod)->mod_op = LDAP_MOD_REPLACE;
        }
        else {
            AddMod(ATTR_FILE_FILTER, L" ", &Mod);
            (*Mod)->mod_op = LDAP_MOD_REPLACE;
        }
        LStatus = ldap_modify_s(Ldap, SetDn, Mod);
    }
    else if(!wcscmp(Argv[2],L"/set")){
        if(!wcscmp(Argv[1],L"/dirfilter")){
            AddMod(ATTR_DIRECTORY_FILTER, NewFilter, &Mod);
            (*Mod)->mod_op = LDAP_MOD_REPLACE;
        }
        else {
            AddMod(ATTR_FILE_FILTER, NewFilter, &Mod);
            (*Mod)->mod_op = LDAP_MOD_REPLACE;
        }
        LStatus = ldap_modify_s(Ldap, SetDn, Mod);
    }
    else {
        // Usage(Argv);
    }

    if (LStatus != LDAP_SUCCESS) {
        fprintf(stderr, "Can't change filter; %ws\n",
                ldap_err2string(LStatus));
    }
    FreeMod(&Mod);
    ldap_unbind(Ldap);
    FREE(SetDn);
    FREE(SettingsDn);
    FREE(ServicesDn);
    FREE(ConfigDn);
}


PWCHAR *
ConvertArgv(
    DWORD argc,
    PCHAR *argv
    )
/*++
Routine Description:
    Convert short char argv into wide char argv

Arguments:
    argc    - From main
    argv    - From main

Return Value:
    Address of the new argv
--*/
{
    PWCHAR  *wideargv;

    wideargv = (PWCHAR *)malloc((argc + 1) * sizeof(PWCHAR));
    wideargv[argc] = NULL;

    while (argc-- >= 1) {
        wideargv[argc] = (PWCHAR)malloc((strlen(argv[argc]) + 1) * sizeof(WCHAR));
        wsprintf(wideargv[argc], L"%hs", argv[argc]);
        // _wcslwr(wideargv[argc]);
    }
    return wideargv;
}


VOID
Usage(
    IN PWCHAR *Argv
    )
/*++
Routine Description:
    Usage messages.

Arguments:
    None.

Return Value:
    None.
--*/
{
    printf("%-24s%ws\n", "Pretty Print", Argv[0]);
    printf("%-24s%ws /dumpcontexts\n",  "dumpcontexts", Argv[0]);
    printf("%-24s%ws /dumpcomputers\n", "dumpcomputers", Argv[0]);
    printf("%-24s%ws /dumpservers\n",   "dumpservers", Argv[0]);
    printf("%-24s%ws /dumpsets\n",      "dumpsets", Argv[0]);
    printf("%-24s%ws /?\n", "Help", Argv[0]);
    printf("%-24s%ws /h\n", "Hammer the schema", Argv[0]);
    printf("%-24s%ws /r\n", "Restore the schema", Argv[0]);
    printf("%-24s%ws /l\n", "List the schema", Argv[0]);
    printf("%-24s%ws /s\n", "Produce script", Argv[0]);
    printf("%-24s%ws /d [Set [Server [Partner]]]\n", "Delete", Argv[0]);
    printf("%-24s%ws /c Set [Server [Root Stage]]\n", "Create sets and servers", Argv[0]);
    printf("%-24s%ws /i Set Server Partner ...\n", "Create inbound cxtions", Argv[0]);
    printf("%-24s%ws [/filefilter |/dirfilter] [/set |/clear] Set FilterString\n", "Modify filters", Argv[0]);
    fflush(stdout);
    ExitProcess(0);
}


#define DUMP_ALL        (0)
#define DUMP_CONTEXTS   (1)
#define DUMP_SETS       (2)
#define DUMP_COMPUTERS  (3)
#define DUMP_SERVERS    (4)
VOID
DumpWorld(
    DWORD Dump
    )
/*++
Routine Description:
    Dump every ds object related to replication

Arguments:
    Dump    - what to dump.

Return Value:
    None.
--*/
{
    PLDAP Ldap;

    //
    // Bind to the ds
    //
    Ldap = FrsDsOpenDs();
    if (!Ldap) {
        return;
    }

    if (Dump == DUMP_ALL || Dump == DUMP_CONTEXTS) {
        printf("***** CONTEXTS\n");
        DumpContexts(Ldap);
    }

    if (Dump == DUMP_ALL || Dump == DUMP_SETS) {
        printf("***** REPLICA SETS\n");
        DumpAdminWorld(Ldap);
    }

    if (Dump == DUMP_ALL || Dump == DUMP_COMPUTERS) {
        printf("\n***** COMPUTERS\n");
        DumpUserWorld(Ldap);
    }

    if (Dump == DUMP_ALL || Dump == DUMP_SERVERS) {
        printf("\n***** SERVERS\n");
        DumpSysVolWorld(Ldap);
    }

    ldap_unbind(Ldap);
}


VOID _cdecl
main(
    IN DWORD argc,
    IN PCHAR *argv
    )
/*++
Routine Description:
    Get access to the DS via ldap. Then read command lines from standard
    in, parse them, and ship them off to the command subroutines. The
    command line is:
        command,site,settings,server,connection,fromserver
    command is any of add|delete|list|show|quit. Leading whitespace is
    ignored. Whitespace between commas counts. The command line can
    stop anytime after "command" and the command will on be applied
    to that portion of the "Distinquished Name".

Arguments:
    None.

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    PWCHAR  *Argv;
    ULONG   i;
    ULONG   OptLen;

    Argv = ConvertArgv(argc, argv);

    if (argc == 1) {
        DumpWorld(DUMP_ALL);
        fflush(stdout);
        ExitProcess(0);
    }

    for (i = 1; i < argc; ++i) {
        OptLen = wcslen(Argv[i]);
        if (OptLen == 2 &&
            ((wcsstr(Argv[i], L"/?") == Argv[i]) ||
             (wcsstr(Argv[i], L"-?") == Argv[i]))) {
            Usage(Argv);
        } else if (OptLen == 2 &&
                ((wcsstr(Argv[i], L"/s") == Argv[i]) ||
                 (wcsstr(Argv[i], L"-s") == Argv[i]))) {
            ScriptReplicationWorld();
            fflush(stdout);
            ExitProcess(0);
        } else if (OptLen == 2 &&
                ((wcsstr(Argv[i], L"/d") == Argv[i]) ||
                 (wcsstr(Argv[i], L"-d") == Argv[i]))) {
            if (argc < 2 || argc > 5) {
                Usage(Argv);
            }
            DeleteReplicationWorld(argc, Argv, CN_TEST_SETTINGS);
            fflush(stdout);
            ExitProcess(0);
        } else if (OptLen == 9 &&
                ((wcsstr(Argv[i], L"/dsysvols") == Argv[i]) ||
                 (wcsstr(Argv[i], L"-dsysvols") == Argv[i]))) {
            if (argc < 2 || argc > 5) {
                Usage(Argv);
            }
            DeleteReplicationWorld(argc, Argv, CN_SYSVOLS);
            fflush(stdout);
            ExitProcess(0);
        } else if (OptLen == 2 &&
                ((wcsstr(Argv[i], L"/h") == Argv[i]) ||
                 (wcsstr(Argv[i], L"-h") == Argv[i]))) {
            HammerSchema(TRUE);
            fflush(stdout);
            ExitProcess(0);
        } else if (OptLen == 2 &&
                ((wcsstr(Argv[i], L"/r") == Argv[i]) ||
                 (wcsstr(Argv[i], L"-r") == Argv[i]))) {
            HammerSchema(FALSE);
            fflush(stdout);
            ExitProcess(0);
        } else if (OptLen == 2 &&
                ((wcsstr(Argv[i], L"/l") == Argv[i]) ||
                 (wcsstr(Argv[i], L"-l") == Argv[i]))) {
            ListSchema();
            fflush(stdout);
            ExitProcess(0);
        } else if (OptLen == 2 &&
                ((wcsstr(Argv[i], L"/i") == Argv[i]) ||
                 (wcsstr(Argv[i], L"-i") == Argv[i]))) {
            if (argc < 5) {
                Usage(Argv);
            }
            CreateInbounds(argc, Argv);
            fflush(stdout);
            ExitProcess(0);
        } else if (OptLen == 2 &&
                ((wcsstr(Argv[i], L"/c") == Argv[i]) ||
                 (wcsstr(Argv[i], L"-c") == Argv[i]))) {
            if (argc != 2 && argc != 3 && argc != 6) {
                Usage(Argv);
            }
            CreateReplicationWorld(argc, Argv, FALSE);
            fflush(stdout);
            ExitProcess(0);
        } else if (OptLen == 3 &&
                ((wcsstr(Argv[i], L"/cp") == Argv[i]) ||
                 (wcsstr(Argv[i], L"-cp") == Argv[i]))) {
            if (argc != 2 && argc != 3 && argc != 6) {
                Usage(Argv);
            }
            CreateReplicationWorld(argc, Argv, TRUE);
            fflush(stdout);
            ExitProcess(0);
        } else if (OptLen >= 10 &&
                ((wcsstr(Argv[i], L"/filefilter") == Argv[i]) ||
                 (wcsstr(Argv[i], L"-filefilter") == Argv[i]) ||
                 (wcsstr(Argv[i], L"/dirfilter") == Argv[i])  ||
                 (wcsstr(Argv[i], L"-dirfilter") == Argv[i]))) {
            if (argc != 4 && argc != 5) {
                Usage(Argv);
            }
            ModifyFilter(argc, Argv);
            fflush(stdout);
            ExitProcess(0);
        } else if ((wcsstr(Argv[i], L"/dumpcontexts") == Argv[i]) ||
                   (wcsstr(Argv[i], L"-dumpcontexts") == Argv[i])) {
            DumpWorld(DUMP_CONTEXTS);
            fflush(stdout);
            ExitProcess(0);
        } else if ((wcsstr(Argv[i], L"/dumpsets") == Argv[i]) ||
                   (wcsstr(Argv[i], L"-dumpsets") == Argv[i])) {
            DumpWorld(DUMP_SETS);
            fflush(stdout);
            ExitProcess(0);
        } else if ((wcsstr(Argv[i], L"/dumpcomputers") == Argv[i]) ||
                   (wcsstr(Argv[i], L"-dumpcomputers") == Argv[i])) {
            DumpWorld(DUMP_COMPUTERS);
            fflush(stdout);
            ExitProcess(0);
        } else if ((wcsstr(Argv[i], L"/dumpservers") == Argv[i]) ||
                   (wcsstr(Argv[i], L"-dumpservers") == Argv[i])) {
            DumpWorld(DUMP_SERVERS);
            fflush(stdout);
            ExitProcess(0);
        } else if ((wcsstr(Argv[i], L"/") == Argv[i]) ||
                   (wcsstr(Argv[i], L"-") == Argv[i])) {
            fprintf(stderr, "ERROR - Don't understand %ws\n", Argv[i]);
            Usage(Argv);
        } else {
            Usage(Argv);
        }
    }
    fflush(stdout);
    ExitProcess(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\test\frs\frs.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    frs.c

Abstract:
    This module is a development tool. It exercises the dcpromo and poke
    APIs.

Author:
    Billy J. Fuller 12-Dec-1997

Environment
    User mode winnt

--*/
#include <ntreppch.h>
#pragma  hdrstop
#include <frs.h>
#include <ntfrsapi.h>

#define FREE(_x_)   { if (_x_) LocalFree(_x_); _x_ = NULL; }


VOID
Win32ToMsg (
    IN PWCHAR Prefix,
    IN DWORD  WStatus
    )

/*++
Routine Description:
    Translate a error code into a error message using FormatMessage()
    and print to stderr. If no message is available, the error code
    is printed in decimal and hex.

Arguments:
    Prefix   - prefix to error message
    WStatus  - Standard win32 error code.

Return Value:
    None.
--*/
{
    DWORD   NumChar;
    PWCHAR  Buffer;

    if (WIN_SUCCESS(WStatus)) {
        return;
    }

    // Use the system formatter for standard error codes
    NumChar = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |
                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                            NULL,
                            WStatus,
                            0,
                            (PWCHAR)&Buffer,
                            0,
                            NULL);
    if (NumChar) {
        fprintf(stderr, "%ws %ws\n", Prefix, Buffer);
    } else {
        fprintf(stderr, "%ws Status %d (0x%08x)\n", Prefix, WStatus, WStatus);
    }
}


VOID
Usage(
    IN DWORD ExitStatus
    )
/*++
Routine Description:
    Print usage and exit

Arguments:
    ExitStatus  - exits with this status

Return Value:
    Exit(ExitStatus)
--*/
{
    printf("frs restore | backup [/all /auth /nonauth /primary /system /ds /normal /key /restart] [dir nonauth|primary|auth ....]\n");
    printf("\t          = excercise the backup/restore api\n");
    printf("\t            WARNING - deletes database\n");
    printf("\trestore   = excercise restore\n");
    printf("\tbackup    = excercise backup\n");
    printf("\t/all      = set all flag (all dirs)\n");
    printf("\t/auth     = set auth flag\n");
    printf("\t/nonauth  = set nonauth flag\n");
    printf("\t/primary  = set primary flag\n");
    printf("\t/system   = set system flag\n");
    printf("\t/ds       = set active directory flag\n");
    printf("\t/normal   = set normal flag\n");
    printf("\t/key      = expect keypath-when-done\n");
    printf("\t/restart  = set restart-service-when-done\n");
    printf("\tSUPPORTED = restore /system /all /nonauth /restart\n");
    printf("\tSUPPORTED = restore /system /all /primary /restart\n");
    printf("\tSUPPORTED = restore /system /all /nonauth /key    \n");
    printf("\tSUPPORTED = restore /system /all /primary /key    \n");
    printf("\tSUPPORTED = restore /ds     /all /nonauth /restart\n");
    printf("\tSUPPORTED = restore /ds     /all /primary /restart\n");
    printf("\tSUPPORTED = restore /ds     /all /nonauth /key    \n");
    printf("\tSUPPORTED = restore /ds     /all /primary /key    \n");
    printf("\tSUPPORTED = restore /ds     /all /nonauth /restart dir primary|nonauth ...\n");
    printf("\tSUPPORTED = restore /ds     /all /primary /restart dir primary|nonauth ...\n");
    printf("\tSUPPORTED = restore /ds     /all /nonauth /key     dir primary|nonauth ...\n");
    printf("\tSUPPORTED = restore /ds     /all /primary /key     dir primary|nonauth ...\n");
    printf("\tSUPPORTED = restore /ds          /nonauth /restart dir primary|nonauth ...\n");
    printf("\tSUPPORTED = restore /ds          /primary /restart dir primary|nonauth ...\n");
    printf("\tSUPPORTED = restore /ds          /nonauth /key     dir primary|nonauth ...\n");
    printf("\tSUPPORTED = restore /ds          /primary /key     dir primary|nonauth ...\n");
    printf("\tSUPPORTED = restore /normal /all /auth\n");
    printf("\tSUPPORTED = backup /normal\n");
    printf("\n");
    printf("frs install stagepath [targetpath]\n");
    printf("\t          = install the staging file\n");
    printf("\tstagepath = path of staging file.\n");
    printf("\ttargetpath= path of target file to OVERWRITE!.\n");
    printf("\n");
    printf("frs [idtable|inlog|outlog] [computer]\n");
    printf("\t          = enumerate the service's idtable/inlog/outlog \n");
    printf("\tcomputer  = talk to the NtFrs service on this machine.\n");
    printf("\n");
    printf("frs [memory|threads|stage] [computer]\n");
    printf("\t          = list the service's memory usage\n");
    printf("\tcomputer  = talk to the NtFrs service on this machine.\n");
    printf("\n");
    printf("frs ds [computer]\n");
    printf("\t          = list the service's view of the DS\n");
    printf("\tcomputer  = talk to the NtFrs service on this machine.\n");
    printf("\n");
    printf("frs sets [computer]\n");
    printf("\t          = list the active replica sets\n");
    printf("\tcomputer  = talk to the NtFrs service on this machine.\n");
    printf("\n");
    printf("frs version [computer]\n");
    printf("\t          = list the api and service versions\n");
    printf("\tcomputer  = talk to the NtFrs service on this machine.\n");
    printf("\n");
    printf("frs poll [/quickly[=[N]]] [/slowly[=[N]]] [/now] [computer]\n");
    printf("\t          = list the current polling intervals.\n");
    printf("\tnow       = Poll now.\n");
    printf("\tquickly   = Poll quickly until stable configuration retrieved.\n");
    printf("\tquickly=  = Poll quickly every default minutes.\n");
    printf("\tquickly=N = Poll quickly every N minutes.\n");
    printf("\tslowly    = Poll slowly until stable configuration retrieved.\n");
    printf("\tslowly=   = Poll slowly every default minutes.\n");
    printf("\tslowly=N  = Poll slowly every N minutes.\n");
    printf("\tcomputer  = talk to the NtFrs service on this machine.\n");
    printf("\n");
    printf("frs promote Parent Account Password Set Type Primary Stage Root\n");
    printf("\tParent    = RPC bindable name of parent DC.\n");
    printf("\tAccount   = Account on Parent.\n");
    printf("\tPassword  = Password for Account on Parent.\n");
    printf("\tSet       = Name of replica set.\n");
    printf("\tType      = Type of replica set (Enterprise or Domain).\n");
    printf("\tPrimary   = Is this the primary member? (1=yes or 0=no)\n");
    printf("\tStage     = Staging path.\n");
    printf("\tRoot      = Root path.\n");
    printf("\n");
    printf("frs demote Set\n");
    printf("\tSet       = Name of replica set.\n");
    printf("\n");
    printf("frs promotesysvols Parent Account Password PrimaryEnterprise PrimaryDomain Stage RootEnterprise RootDomain\n");
    printf("\tParent    = RPC bindable name of parent DC.\n");
    printf("\tAccount   = Account on Parent.\n");
    printf("\tPassword  = Password for Account on Parent.\n");
    printf("\tPrimaryEnterprise   = Is this the primary member? (1=yes or 0=no)\n");
    printf("\tPrimaryDomain       = Is this the primary member? (1=yes or 0=no)\n");
    printf("\tStage     = Staging path.\n");
    printf("\tRootEnterprise      = Root path.\n");
    printf("\tRootDomain          = Root path.\n");
    printf("\n");
    printf("frs demotesysvols\n");

    exit(ExitStatus);
}


PWCHAR *
ConvertArgv(
    DWORD argc,
    PCHAR *argv
    )
/*++
Routine Description:
    Convert short char argv into wide char argv

Arguments:
    argc    - From main
    argv    - From main

Return Value:
    Address of the new argv
--*/
{
    PWCHAR  *wideargv;

    wideargv = LocalAlloc(LMEM_FIXED, (argc + 1) * sizeof(PWCHAR));
    if (wideargv == NULL) {
        fprintf(stderr, "Can't get memory; Win32 Status %d\n",
                GetLastError());
        exit(1);
    }
    wideargv[argc] = NULL;

    while (argc-- >= 1) {
        wideargv[argc] = LocalAlloc(LMEM_FIXED,
                                    (strlen(argv[argc]) + 1) * sizeof(WCHAR));
        if (wideargv[argc] == NULL) {
            fprintf(stderr, "Can't get memory; Win32 Status %d\n",
                    GetLastError());
            exit(1);
        }
        wsprintf(wideargv[argc], L"%hs", argv[argc]);
        FRS_WCSLWR(wideargv[argc]);
    }
    return wideargv;
}


DWORD
Display(
    IN PWCHAR StrW
    )
/*++
Routine Description:
    Display the string

Arguments:
    StrW

Return Value:
    None.
--*/
{
    printf("DISPLAY %ws\n", StrW);
    return ERROR_SUCCESS;
}


DWORD
FrsErrorCallBack(
    IN PWCHAR   Msg,
    IN DWORD    WStatus
    )
/*++
Routine Description:

Arguments:

Return Value:
--*/
{
    fprintf(stderr, "%ws (%d)\n", Msg, WStatus);
    return ERROR_SUCCESS;
}


VOID
ProcessPromote(
    IN DWORD argc,
    IN PWCHAR *Argv
    )
/*++
Routine Description:
    Process the command line for the subcommand promote.

Arguments:
    argc
    Argv

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    DWORD   WStatus;
    PWCHAR  Parent;
    PWCHAR  Account;
    PWCHAR  Password;
    PWCHAR  Set;
    PWCHAR  Type;
    PWCHAR  Primary;
    PWCHAR  Stage;
    PWCHAR  Root;
    DWORD   IsPrimary;

    if (argc != 10) {
        Usage(1);
    }

    Parent = Argv[2];
    Account = Argv[3];
    Password = Argv[4];
    Set = Argv[5];
    Type = Argv[6];
    Primary = Argv[7];
    Stage = Argv[8];
    Root = Argv[9];

    //
    // No account; use impersonation
    //
    if (Account && !*Account) {
        Account = NULL;
        Password = NULL;
    }

    printf("%ws %ws %ws ... %ws\n",
           Argv[0], Argv[1], Parent, Root);

    printf("PROMOTE WITH COMMIT\n");

    //
    // Check params
    //
    if (_wcsicmp(Primary, L"0") && _wcsicmp(Primary, L"1")) {
        printf("Primary must be 0 or 1; not %ws\n", Primary);
        Usage(1);
    }
    if (_wcsicmp(Type, NTFRSAPI_REPLICA_SET_TYPE_ENTERPRISE) &&
        _wcsicmp(Type, NTFRSAPI_REPLICA_SET_TYPE_DOMAIN)) {
        printf("Type must be Enterprise or Domain; not %ws\n", Type);
        Usage(1);
    }
    IsPrimary = wcstoul(Primary, NULL, 10);

    //
    // Prepare
    //
    WStatus = NtFrsApi_PrepareForPromotionW( FrsErrorCallBack );
    if (WStatus == ERROR_SUCCESS) {
        printf("success prepare\n");
    } else {
        printf("failure prepare %08x\n", WStatus);
        Win32ToMsg (L"Promote:", WStatus);
    }

    //
    // Start
    //
    WStatus = NtFrsApi_StartPromotionW(Parent,
                                       Account,
                                       Password,
                                       Display,
                                       FrsErrorCallBack,
                                       Set,
                                       Type,
                                       IsPrimary,
                                       Stage,
                                       Root);
    if (WStatus == ERROR_SUCCESS) {
        printf("success start\n");
    } else {
        printf("failure start %08x\n", WStatus);
        Win32ToMsg (L"Promote:", WStatus);
    }

    //
    // Wait
    //
    printf("Waiting on promotion\n");
    WStatus = NtFrsApi_WaitForPromotionW(30 * 60 * 1000, FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("Wait succeeded\n");
        Win32ToMsg (L"Promote:", WStatus);
    } else {
        printf("failure wait %08x\n", WStatus);
        Win32ToMsg (L"Promote:", WStatus);
    }

    //
    // Commit (or Abort)
    //
    // WStatus = NtFrsApi_AbortPromotionW();
    WStatus = NtFrsApi_CommitPromotionW(0, FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success commit\n");
    } else {
        printf("failure commit %08x\n", WStatus);
        Win32ToMsg (L"Promote:", WStatus);
    }
    exit(0);
}


VOID
ProcessPromoteSysVols(
    IN DWORD argc,
    IN PWCHAR *Argv
    )
/*++
Routine Description:
    Process the command line for the subcommand promotesysvols.

Arguments:
    argc
    Argv

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    DWORD   WStatus;
    PWCHAR  Parent;
    PWCHAR  Account;
    PWCHAR  Password;
    PWCHAR  PrimaryEnterprise;
    PWCHAR  PrimaryDomain;
    PWCHAR  Stage;
    PWCHAR  RootEnterprise;
    PWCHAR  RootDomain;
    DWORD   IsPrimaryEnterprise;
    DWORD   IsPrimaryDomain;
    DWORD   WaitStatus;

    if (argc != 10) {
        Usage(1);
    }

    Parent = Argv[2];
    Account = Argv[3];
    Password = Argv[4];
    PrimaryEnterprise = Argv[5];
    PrimaryDomain = Argv[6];
    Stage = Argv[7];
    RootEnterprise = Argv[8];
    RootDomain = Argv[9];

    printf("%ws %ws %ws %ws %ws %ws %ws %ws %ws %ws\n",
           Argv[0], Argv[1],
           Parent,
           Account,
           Password,
           PrimaryEnterprise,
           PrimaryDomain,
           Stage,
           RootEnterprise,
           RootDomain);

    printf("PROMOTE SYSVOLS WITH COMMIT\n");

    //
    // Check params
    //
    if (_wcsicmp(PrimaryEnterprise, L"0") &&
        _wcsicmp(PrimaryEnterprise, L"1")) {
        printf("Primary Enterprise must be 0 or 1; not %ws\n",
               PrimaryEnterprise);
        Usage(1);
    }
    if (_wcsicmp(PrimaryDomain, L"0") &&
        _wcsicmp(PrimaryDomain, L"1")) {
        printf("Primary Domain must be 0 or 1; not %ws\n",
               PrimaryDomain);
        Usage(1);
    }
    IsPrimaryEnterprise = wcstoul(PrimaryEnterprise, NULL, 10);
    IsPrimaryDomain = wcstoul(PrimaryDomain, NULL, 10);

    //
    // Prepare
    //
    WStatus = NtFrsApi_PrepareForPromotionW(FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success sysvol prepare\n");
    } else {
        printf("ERROR sysvol prepare %d\n", WStatus);
    }

    //
    // Start Enterprise
    //
    WStatus = NtFrsApi_StartPromotionW(Parent,
                                       Account,
                                       Password,
                                       Display,
                                       FrsErrorCallBack,
                                       NTFRSAPI_REPLICA_SET_TYPE_ENTERPRISE,
                                       NTFRSAPI_REPLICA_SET_TYPE_ENTERPRISE,
                                       IsPrimaryEnterprise,
                                       Stage,
                                       RootEnterprise);
    if (WStatus == ERROR_SUCCESS) {
        printf("success sysvol enterprise start\n");
    } else {
        printf("ERROR sysvol enterprise start %d\n", WStatus);
    }

    //
    // Start Domain
    //
    WStatus = NtFrsApi_StartPromotionW(Parent,
                                       Account,
                                       Password,
                                       Display,
                                       FrsErrorCallBack,
                                       NTFRSAPI_REPLICA_SET_TYPE_DOMAIN,
                                       NTFRSAPI_REPLICA_SET_TYPE_DOMAIN,
                                       IsPrimaryDomain,
                                       Stage,
                                       RootDomain);
    if (WStatus == ERROR_SUCCESS) {
        printf("success sysvol domain start\n");
    } else {
        printf("ERROR sysvol domain start %d\n", WStatus);
    }

    //
    // Wait
    //
    printf("Waiting on promotion\n");
    WaitStatus = NtFrsApi_WaitForPromotionW(5 * 60 * 1000,FrsErrorCallBack);
    if (WaitStatus == WAIT_TIMEOUT) {
        printf("Wait timed out\n");
    } else if (WaitStatus == WAIT_FAILED) {
            WStatus = GetLastError();
            printf("ERROR wait sysvols %d\n", WStatus);
    } else {
        printf("Wait sysvols succeeded\n");
    }

    //
    // Commit (or Abort)
    //
    // WStatus = NtFrsApi_AbortPromotionW();
    WStatus = NtFrsApi_CommitPromotionW(0,FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success sysvols commit\n");
    } else {
        printf("ERROR sysvols commit %d\n", WStatus);
    }
    exit(0);
}


VOID
ProcessPromoteAbort(
    IN DWORD argc,
    IN PWCHAR *Argv
    )
/*++
Routine Description:
    Process the command line for the subcommand promoteabort.

Arguments:
    argc
    Argv

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    DWORD   WStatus;
    PWCHAR  Parent;
    PWCHAR  Account;
    PWCHAR  Password;
    PWCHAR  Set;
    PWCHAR  Type;
    PWCHAR  Primary;
    PWCHAR  Stage;
    PWCHAR  Root;
    DWORD   IsPrimary;
    DWORD   WaitStatus;

    if (argc != 10) {
        Usage(1);
    }

    Parent = Argv[2];
    Account = Argv[3];
    Password = Argv[4];
    Set = Argv[5];
    Type = Argv[6];
    Primary = Argv[7];
    Stage = Argv[8];
    Root = Argv[9];

    printf("%ws %ws %ws ... %ws\n",
           Argv[0], Argv[1], Parent, Root);

    printf("PROMOTE WITH ABORT\n");

    //
    // Check params
    //
    if (_wcsicmp(Primary, L"0") && _wcsicmp(Primary, L"1")) {
        printf("Primary must be 0 or 1; not %ws\n", Primary);
        Usage(1);
    }
    if (_wcsicmp(Type, NTFRSAPI_REPLICA_SET_TYPE_ENTERPRISE) &&
        _wcsicmp(Type, NTFRSAPI_REPLICA_SET_TYPE_DOMAIN)) {
        printf("Type must be Enterprise or Domain; not %ws\n", Type);
        Usage(1);
    }
    IsPrimary = wcstoul(Primary, NULL, 10);

    //
    // Prepare
    //
    WStatus = NtFrsApi_PrepareForPromotionW(FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success prepare\n");
    } else {
        printf("failure prepare %d\n", WStatus);
    }

    //
    // Start
    //
    WStatus = NtFrsApi_StartPromotionW(Parent,
                                       Account,
                                       Password,
                                       NULL,
                                       FrsErrorCallBack,
                                       Set,
                                       Type,
                                       IsPrimary,
                                       Stage,
                                       Root);
    if (WStatus == ERROR_SUCCESS) {
        printf("success start\n");
    } else {
        printf("failure start %d\n", WStatus);
    }

    //
    // Abort
    //
    WStatus = NtFrsApi_AbortPromotionW();
    if (WStatus == ERROR_SUCCESS) {
        printf("success abort\n");
    } else {
        printf("failure abort %d\n", WStatus);
    }
    exit(0);
}


VOID
ProcessDemote(
    IN DWORD argc,
    IN PWCHAR *Argv
    )
/*++
Routine Description:
    Process the command line for the subcommand demote.

Arguments:
    argc
    Argv

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    DWORD   WStatus;
    PWCHAR  Set;
    DWORD   WaitStatus;

    if (argc != 3) {
        Usage(1);
    }

    Set = Argv[2];
    printf("%ws %ws %ws\n", Argv[0], Argv[1], Set);

    printf("***** DEMOTE WITH COMMIT\n");

    //
    // Prepare
    //
    WStatus = NtFrsApi_PrepareForDemotionW(FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success demote prepare\n");
    } else {
        printf("failure demote prepare %d\n", WStatus);
    }

    //
    // Start
    //
    WStatus = NtFrsApi_StartDemotionW(Set,FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success demote start\n");
    } else {
        printf("failure demote start %d\n", WStatus);
    }

    //
    // Wait
    //
    WStatus = NtFrsApi_WaitForDemotionW(5 * 60 * 1000,FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success demote wait\n");
    } else {
        printf("failure demote wait %d\n", WStatus);
    }
    //
    // Wait
    //
    printf("Waiting on demotion\n");
    WaitStatus = NtFrsApi_WaitForPromotionW(5 * 60 * 1000,FrsErrorCallBack);
    if (WaitStatus == WAIT_TIMEOUT) {
        printf("Wait timed out\n");
    } else if (WaitStatus == WAIT_FAILED) {
            WStatus = GetLastError();
            printf("failure wait %d\n", WStatus);
    } else {
            printf("Wait succeeded\n");
    }

    //
    // Commit (or Abort)
    //
    WStatus = NtFrsApi_CommitDemotionW(0,FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success demote commit\n");
    } else {
        printf("failure demote commit %d\n", WStatus);
    }
    exit(0);
}


VOID
ProcessDemoteSysVols(
    IN DWORD argc,
    IN PWCHAR *Argv
    )
/*++
Routine Description:
    Process the command line for the subcommand demotesysvols.

Arguments:
    argc
    Argv

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    DWORD   WStatus;
    DWORD   WaitStatus;

    if (argc != 2) {
        Usage(1);
    }

    printf("%ws %ws\n", Argv[0], Argv[1]);

    printf("***** DEMOTE SYSVOLS WITH COMMIT\n");

    //
    // Prepare
    //
    WStatus = NtFrsApi_PrepareForDemotionW(FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success demote sysvols prepare\n");
    } else {
        printf("ERROR demote sysvols prepare %d\n", WStatus);
    }

    //
    // Start
    //
    WStatus = NtFrsApi_StartDemotionW(NTFRSAPI_REPLICA_SET_TYPE_ENTERPRISE,NULL);
    if (WStatus == ERROR_SUCCESS) {
        printf("success demote enterprise start\n");
    } else {
        printf("ERROR demote enterprise start %d\n", WStatus);
    }

    //
    // Start
    //
    WStatus = NtFrsApi_StartDemotionW(NTFRSAPI_REPLICA_SET_TYPE_DOMAIN, FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success demote domain start\n");
    } else {
        printf("ERROR demote domain start %d\n", WStatus);
    }

    //
    // Wait
    //
    WStatus = NtFrsApi_WaitForDemotionW(5 * 60 * 1000, FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success demote sysvols wait\n");
    } else {
        printf("ERROR demote sysvols wait %d\n", WStatus);
    }
    //
    // Wait
    //
    printf("Waiting on demotion\n");
    WaitStatus = NtFrsApi_WaitForPromotionW(5 * 60 * 1000, FrsErrorCallBack);
    if (WaitStatus == WAIT_TIMEOUT) {
        printf("Wait timed out\n");
    } else if (WaitStatus == WAIT_FAILED) {
            WStatus = GetLastError();
            printf("ERROR wait %d\n", WStatus);
    } else {
            printf("Wait demote sysvols succeeded\n");
    }

    //
    // Commit (or Abort)
    //
    WStatus = NtFrsApi_CommitDemotionW(0, FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success demote sysvols commit\n");
    } else {
        printf("ERROR demote sysvols commit %d\n", WStatus);
    }
    exit(0);
}


VOID
ProcessDemoteAbort(
    IN DWORD argc,
    IN PWCHAR *Argv
    )
/*++
Routine Description:
    Process the command line for the subcommand demoteabort.

Arguments:
    argc
    Argv

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    DWORD   WStatus;
    PWCHAR  Set;
    DWORD   WaitStatus;

    if (argc != 3) {
        Usage(1);
    }

    Set = Argv[2];
    printf("%ws %ws %ws\n", Argv[0], Argv[1], Set);

    printf("***** DEMOTE WITH ABORT\n");

    //
    // Prepare
    //
    WStatus = NtFrsApi_PrepareForDemotionW(FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success demote prepare\n");
    } else {
        printf("failure demote prepare %d\n", WStatus);
    }

    //
    // Start
    //
    WStatus = NtFrsApi_StartDemotionW(Set, FrsErrorCallBack);
    if (WStatus == ERROR_SUCCESS) {
        printf("success demote start\n");
    } else {
        printf("failure demote start %d\n", WStatus);
    }

    //
    // Abort
    //
    WStatus = NtFrsApi_AbortDemotionW();
    if (WStatus == ERROR_SUCCESS) {
        printf("success demote abort\n");
    } else {
        printf("failure demote abort %d\n", WStatus);
    }
    exit(0);
}


VOID
ProcessPoll(
    IN DWORD argc,
    IN PWCHAR *Argv
    )
/*++
Routine Description:
    Process the command line for the subcommand poll.

Arguments:
    argc
    Argv

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    DWORD   WStatus;
    DWORD   i;
    ULONG   LongInterval;
    ULONG   ShortInterval;
    ULONG   UseShortInterval;
    ULONG   Interval;
    DWORD   ComputerLen;
    PWCHAR  ComputerName;
    BOOL    SetInterval;

    //
    // Initialize the input parameters
    //
    LongInterval = 0;
    ShortInterval = 0;
    UseShortInterval = 0;
    ComputerName = NULL;
    SetInterval = FALSE;

    for (i = 2; i < argc; ++i) {
        //
        // Process options for poll
        //

        //
        // Not a parameter; must be the computer name
        //
        if (*Argv[i] != L'/' && *Argv[i] != L'-') {
            if (ComputerName) {
                fprintf(stderr, "Multiple computer names are not allowed\n");
                Usage(1);
            }
            ComputerName = Argv[i];
        //
        // /?
        //
        } else if (wcsstr(Argv[i] + 1, L"?") == Argv[i] + 1) {
            Usage(0);
        //
        // /quickly
        //
        } else if (!_wcsnicmp(Argv[i], L"/quickly", 8)) {
            SetInterval = TRUE;
            UseShortInterval = 1;
            if (*(Argv[i] + 8) != L'\0') {
                if (*(Argv[i] + 8) != L'=') {
                    fprintf(stderr, "Don't understand %ws\n", Argv[i]);
                    Usage(1);
                }
                if (*(Argv[i] + 9) == L'\0') {
                    ShortInterval = NTFRSAPI_DEFAULT_SHORT_INTERVAL;
                } else {
                    ShortInterval = wcstoul(Argv[i] + 9, NULL, 10);
                }
                if (ShortInterval < NTFRSAPI_MIN_INTERVAL ||
                    ShortInterval > NTFRSAPI_MAX_INTERVAL) {
                    fprintf(stderr, "Interval must be between %d and %d\n",
                            NTFRSAPI_MIN_INTERVAL, NTFRSAPI_MAX_INTERVAL);
                    Usage(1);
                }
            }
        //
        // /slowly
        //
        } else if (!_wcsnicmp(Argv[i], L"/slowly", 7)) {
            SetInterval = TRUE;
            if (*(Argv[i] + 7) != L'\0') {
                if (*(Argv[i] + 7) != L'=') {
                    fprintf(stderr, "Don't understand %ws\n", Argv[i]);
                    Usage(1);
                }
                if (*(Argv[i] + 8) == L'\0') {
                    LongInterval = NTFRSAPI_DEFAULT_LONG_INTERVAL;
                } else {
                    LongInterval = wcstoul(Argv[i] + 8, NULL, 10);
                }
                if (LongInterval < NTFRSAPI_MIN_INTERVAL ||
                    LongInterval > NTFRSAPI_MAX_INTERVAL) {
                    fprintf(stderr, "Interval must be between %d and %d\n",
                            NTFRSAPI_MIN_INTERVAL, NTFRSAPI_MAX_INTERVAL);
                    Usage(1);
                }
            }
        //
        // /now
        //
        } else if (!_wcsnicmp(Argv[i], L"/now", 4)) {
            SetInterval = TRUE;
            if (*(Argv[i] + 4) != L'\0') {
                fprintf(stderr, "Don't understand %ws\n", Argv[i]);
                Usage(1);
            }
        //
        // Don't understand
        //
        } else {
            fprintf(stderr, "Don't understand %ws\n", Argv[i]);
            Usage(1);
        }
    }
    if (SetInterval) {
        //
        // Set the interval and initiate a new polling cycle
        //
        WStatus = NtFrsApi_Set_DsPollingIntervalW(ComputerName,
                                                  UseShortInterval,
                                                  LongInterval,
                                                  ShortInterval);
        if (!WIN_SUCCESS(WStatus)) {
            Win32ToMsg(L"Can't set interval:", WStatus);
            exit(1);
        }
    } else {
        //
        // Get the current polling cycles
        //
        WStatus = NtFrsApi_Get_DsPollingIntervalW(ComputerName,
                                                  &Interval,
                                                  &LongInterval,
                                                  &ShortInterval);
        if (!WIN_SUCCESS(WStatus)) {
            Win32ToMsg(L"Can't get intervals:", WStatus);
            exit(1);
        }
        printf("Current Interval: %6d minutes\n", Interval);
        printf("Short Interval  : %6d minutes\n", ShortInterval);
        printf("Long Interval   : %6d minutes\n", LongInterval);
    }
    exit(0);
}


VOID
ProcessDump(
    IN DWORD    argc,
    IN PWCHAR   *Argv,
    IN DWORD    TypeOfInformation
    )
/*++
Routine Description:
    Dump bunches of stuff

Arguments:
    argc
    Argv
    TypeOfInformation

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    DWORD   WStatus;
    PCHAR   Line;
    BOOL    FirstTime = TRUE;
    PVOID   Info = NULL;
    PWCHAR  ComputerName = NULL;

    if (argc > 2) {
        ComputerName = Argv[2];
    }

    do {
        WStatus = NtFrsApi_InfoW(ComputerName,
                                 TypeOfInformation,
                                 0,
                                 &Info);
        if (!WIN_SUCCESS(WStatus)) {
            fprintf(stderr, "ERROR NtFrsApi_InfoW() Error %d\n", WStatus);
            NtFrsApi_InfoFreeW(&Info);
            exit(1);
        }
        if (Info) {
            if (!FirstTime) {
                printf("===== THE FOLLOWING INFO MAY BE INCONSISTENT DUE TO REFETCH =====\n");
            }
            FirstTime = FALSE;

            Line = NULL;
            do {
                WStatus = NtFrsApi_InfoLineW(Info, &Line);
                if (!WIN_SUCCESS(WStatus)) {
                    fprintf(stderr, "ERROR NtFrsApi_InfoLineW() Error %d\n", WStatus);
                    NtFrsApi_InfoFreeW(&Info);
                    exit(1);
                }
                if (Line) {
                    printf("%s", Line);
                }
            } while (Line);
        }
    } while (Info);
    exit(0);
}


typedef struct _DIRS DIRS, *PDIRS;
struct _DIRS {
    PDIRS   Next;
    PWCHAR  Dir;
    PVOID   BurSet;
};
VOID
ProcessBackupRestore(
    IN DWORD    argc,
    IN PWCHAR   *Argv,
    IN DWORD    BurFlags
    )
/*++
Routine Description:
    Dump replicated dirs

Arguments:
    argc
    Argv

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    DWORD   WStatus;
    DWORD   i;
    DWORD   BurSetIndex;
    DWORD   DestroyBurFlags = NTFRSAPI_BUR_FLAGS_NONE;
    PVOID   BurContext;
    PVOID   BurSet;
    BOOL    IsSysvol;
    BOOL    ExpectKey = FALSE;
    BOOL    Spin = FALSE;
    HKEY    HKey;
    PWCHAR  DirPath;
    PWCHAR  DirType;
    PDIRS   Dirs = NULL;
    PDIRS   Dir = NULL;
    DWORD   BufferSize;
    WCHAR   Buffer[1024];
    DWORD   Buffer2Size;
    WCHAR   Buffer2[1024];
    DWORD   FiltersSize;
    WCHAR   Filters[1024];
    PWCHAR  Str;

    for (i = 2; i < argc; ++i) {
        printf("%ws\n", Argv[i]);
        if (!_wcsicmp(Argv[i], L"/auth")) {
            BurFlags |= NTFRSAPI_BUR_FLAGS_AUTHORITATIVE;
        } else if (!_wcsicmp(Argv[i], L"/nonauth")) {
            BurFlags |= NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE;
        } else if (!_wcsicmp(Argv[i], L"/primary")) {
            BurFlags |= NTFRSAPI_BUR_FLAGS_PRIMARY;
        } else if (!_wcsicmp(Argv[i], L"/system")) {
            BurFlags |= NTFRSAPI_BUR_FLAGS_SYSTEM;
        } else if (!_wcsicmp(Argv[i], L"/ds")) {
            BurFlags |= NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY;
        } else if (!_wcsicmp(Argv[i], L"/normal")) {
            BurFlags |= NTFRSAPI_BUR_FLAGS_NORMAL;
        } else if (!_wcsicmp(Argv[i], L"/all")) {
            BurFlags |= NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES;
        } else if (!_wcsicmp(Argv[i], L"/restart")) {
            DestroyBurFlags |= NTFRSAPI_BUR_FLAGS_RESTART;
        } else if (!_wcsicmp(Argv[i], L"/unknown")) {
            BurFlags |= 0x80000000;
        } else if (!_wcsicmp(Argv[i], L"/destroyunknown")) {
            DestroyBurFlags |= 0x80000000;
        } else if (!_wcsicmp(Argv[i], L"/key")) {
            ExpectKey = TRUE;
        } else if (!_wcsicmp(Argv[i], L"/spin")) {
            Spin = TRUE;
        } else if (*Argv[i] == L'/') {
            fprintf(stderr, "Don't understand %ws\n", Argv[i]);
            exit(1);
        }
    }
SPIN_ON_INITIALIZE:
    WStatus = NtFrsApiInitializeBackupRestore(FrsErrorCallBack,
                                              BurFlags,
                                              &BurContext);
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr,
                "ERROR NtFrsApiInitializeBackupRestore(%08x) Error %d\n",
                BurFlags,
                WStatus);
        if (Spin) {
            Sleep(2 * 1000);
            goto SPIN_ON_INITIALIZE;
        }
        exit(1);
    }
    WStatus = NtFrsApiGetBackupRestoreSets(BurContext);
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr,
                "WARN NtFrsApiGetBackupRestoreSets() Error %d\n",
                WStatus);
        goto DESTROY;
    }
    BurSetIndex = 0;
    while (TRUE) {
        WStatus = NtFrsApiEnumBackupRestoreSets(BurContext,
                                                BurSetIndex,
                                                &BurSet);
        if (!WIN_SUCCESS(WStatus)) {
            break;
        }
        WStatus = NtFrsApiIsBackupRestoreSetASysvol(BurContext,
                                                    BurSet,
                                                    &IsSysvol);
        if (!WIN_SUCCESS(WStatus)) {
            fprintf(stderr,
                    "ERROR NtFrsApiIsBackupRestoreSetASysvol(%d) Error %d\n",
                    BurSetIndex,
                    WStatus);
            goto DESTROY;
        }
        //
        // Directory
        //
        BufferSize = 1;
        WStatus = NtFrsApiGetBackupRestoreSetDirectory(BurContext,
                                                       BurSet,
                                                       &BufferSize,
                                                       Buffer);
        if (WStatus != ERROR_INSUFFICIENT_BUFFER) {
            fprintf(stderr,
                    "ERROR NtFrsApiIsBackupRestoreSetASysvol(%d) Error %d\n",
                    BurSetIndex,
                    WStatus);
        }
        BufferSize = 1024;
        WStatus = NtFrsApiGetBackupRestoreSetDirectory(BurContext,
                                                       BurSet,
                                                       &BufferSize,
                                                       Buffer);
        if (!WIN_SUCCESS(WStatus)) {
            fprintf(stderr,
                    "ERROR NtFrsApiIsBackupRestoreSetASysvol(%d) Error %d\n",
                    BurSetIndex,
                    WStatus);
            goto DESTROY;
        }
        //
        // Paths
        //
        Buffer2Size = 1;
        FiltersSize = 1;
        WStatus = NtFrsApiGetBackupRestoreSetPaths(BurContext,
                                                   BurSet,
                                                   &Buffer2Size,
                                                   Buffer2,
                                                   &FiltersSize,
                                                   Filters);
        if (WStatus != ERROR_INSUFFICIENT_BUFFER) {
            fprintf(stderr,
                    "ERROR NtFrsApiGetBackupRestorePaths(%d) Error %d\n",
                    BurSetIndex,
                    WStatus);
        }
        Buffer2Size = 1024;
        FiltersSize = 1;
        WStatus = NtFrsApiGetBackupRestoreSetPaths(BurContext,
                                                   BurSet,
                                                   &Buffer2Size,
                                                   Buffer2,
                                                   &FiltersSize,
                                                   Filters);
        if (WStatus != ERROR_INSUFFICIENT_BUFFER) {
            fprintf(stderr,
                    "ERROR NtFrsApiGetBackupRestorePaths(FILTERS %d) Error %d\n",
                    BurSetIndex,
                    WStatus);
        }

        Buffer2Size = 1024;
        FiltersSize = 1024;
        WStatus = NtFrsApiGetBackupRestoreSetPaths(BurContext,
                                                   BurSet,
                                                   &Buffer2Size,
                                                   Buffer2,
                                                   &FiltersSize,
                                                   Filters);
        if (!WIN_SUCCESS(WStatus)) {
            fprintf(stderr,
                    "ERROR NtFrsApiGetBackupRestorePaths(%d) Error %d\n",
                    BurSetIndex,
                    WStatus);
            goto DESTROY;
        }
        if (IsSysvol) {
            printf("BurSet %d: %ws is a sysvol\n",
                   BurSetIndex,
                   Buffer);
        } else {
            printf("BurSet %d: %ws\n",
                   BurSetIndex,
                   Buffer);
        }
        if (Buffer2Size) {
            Str = Buffer2;
            while(*Str) {
                printf("    Path  : %ws\n", Str);
                Str += wcslen(Str) + 1;
            }
        }
        if (FiltersSize) {
            Str = Filters;
            while(*Str) {
                printf("    Filter: %ws\n", Str);
                Str += wcslen(Str) + 1;
            }
        }
        Dir = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(DIRS));
        Dir->Dir = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, BufferSize);
        CopyMemory(Dir->Dir, Buffer, BufferSize);
        Dir->BurSet = BurSet;
        Dir->Next = Dirs;
        Dirs = Dir;
        ++BurSetIndex;
    }
    if (!WIN_SUCCESS(WStatus) && WStatus != ERROR_NO_MORE_ITEMS) {
        fprintf(stderr,
                "ERROR NtFrsApiEnumBackupRestoreSets(%d) Error %d\n",
                BurSetIndex,
                WStatus);
        goto DESTROY;
    }
    for (i = 2; i < argc; ++i) {
        if (*Argv[i] == L'/') {
            continue;
        }
        DirPath = Argv[i++];
        if (i >= argc) {
            printf("%ws does not have a corresponding primary|nonauth\n",
                   DirPath);
            continue;
        }
        DirType = Argv[i];
        printf("Processing %ws %ws\n", DirPath, DirType);
        if (!_wcsicmp(DirType, L"primary")) {
            BurFlags = NTFRSAPI_BUR_FLAGS_PRIMARY;
        } else if (!_wcsicmp(DirType, L"nonauth")) {
            BurFlags = NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE;
        } else {
            printf("Don't understand %ws\n", DirType);
            continue;
        }
        for (Dir = Dirs; Dir; Dir = Dir->Next) {
            if (!_wcsicmp(Dir->Dir, DirPath)) {
                break;
            }
        }
        if (!Dir) {
            printf("%ws not found\n", DirPath);
            continue;
        }
        WStatus = NtFrsApiRestoringDirectory(BurContext,
                                             Dir->BurSet,
                                             BurFlags);
        if (!WIN_SUCCESS(WStatus)) {
            fprintf(stderr,
                    "ERROR NtFrsApiRestoringDirectory(%ws, %08x) Error %d\n",
                    DirPath,
                    BurFlags,
                    WStatus);
            continue;
        }
        WStatus = NtFrsApiFinishedRestoringDirectory(BurContext,
                                                     Dir->BurSet,
                                                     NTFRSAPI_BUR_FLAGS_NONE);
        if (!WIN_SUCCESS(WStatus)) {
            fprintf(stderr,
                    "ERROR NtFrsApiFinishedRestoringDirectory(%ws, %08x) Error %d\n",
                    DirPath,
                    BurFlags,
                    WStatus);
            continue;
        }
        printf("Finished restoring %ws\n", DirPath);
    }

DESTROY:
    if (Spin) {
        printf("Spinning...\n");
    }
    while (Spin) {
        Sleep(2 * 1000);
    }
    BufferSize = 1024;
    WStatus = NtFrsApiDestroyBackupRestore(&BurContext,
                                           DestroyBurFlags,
                                           (ExpectKey) ? &HKey : NULL,
                                           (ExpectKey) ? &BufferSize : NULL,
                                           (ExpectKey) ? Buffer : NULL);
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr,
                "ERROR NtFrsApiDestroyBackupRestore(%08x) Error %d\n",
                DestroyBurFlags,
                WStatus);
        exit(1);
    }
    if (ExpectKey) {
        printf("%08x HKey, %d KeySize, %ws\n", HKey, BufferSize, Buffer);
    }

#if 0
    WStatus = NtFrsApi_GetReplicatedDirectoriesW(FrsErrorCallBack, &Dirs);
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr, "ERROR NtFrsApi_GetReplicatedDirectories() Error %d\n", WStatus);
        exit(1);
    }
    if (Dirs) {
        while (*Dirs != L'\0') {
            fprintf(stdout, "Dirs:%ws:\n", Dirs);
            Dirs = &Dirs[wcslen(Dirs) + 1];
        }
        LocalFree(Dirs);
    }
    WStatus = NtFrsApi_StopServiceForFullNonAuthRestoreW(Primary,
                                                         FrsErrorCallBack);
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr, "ERROR NtFrsApi_StopServiceForFullNonAuth() Error %d\n", WStatus);
        exit(1);
    }
    WStatus = NtFrsApi_StartServiceAfterFullNonAuthRestoreW(FrsErrorCallBack);
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr, "ERROR NtFrsApi_StartServiceAfterFullNonAuth() Error %d\n", WStatus);
        exit(1);
    }
#endif 0
    exit(0);
}


VOID
ProcessComm(
    IN DWORD    argc,
    IN PWCHAR   *Argv,
    IN DWORD    CommCommand
    )
/*++
Routine Description:
    Dump bunches of stuff

Arguments:
    argc
    Argv
    CommCommand

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    DWORD   WStatus;
    PWCHAR  Line;
    PWCHAR  ComputerName1 = NULL;
    PWCHAR  ComputerName2 = NULL;
    PWCHAR  Account = NULL;
    PWCHAR  Password = NULL;
    PVOID   Info = NULL;

    if (argc > 2) {
        ComputerName1 = Argv[2];
        if (ComputerName1 && !*ComputerName1) {
            ComputerName1 = NULL;
        }
    }
    if (argc > 3) {
        ComputerName2 = Argv[3];
        if (ComputerName2 && !*ComputerName2) {
            ComputerName2 = NULL;
        }
    }
    if (argc > 4) {
        Account = Argv[4];
        if (Account && !*Account) {
            Account = NULL;
        }
    }
    if (argc > 5) {
        Password = Argv[5];
        if (Password && !*Password) {
            Password = NULL;
        }
    }

#if 0
    not yet implemented
    WStatus = NtFrsApi_CommW(CommCommand,
                             ComputerName1,
                             ComputerName2,
                             Account,
                             Password,
                             &Info);
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr, "NtFrsApi_CommW() -> %d\n", WStatus);
        exit(1);
    }
    Line = NULL;
AGAIN:
    WStatus = NtFrsApi_InfoLineW(Info, &Line);
    if (!WIN_SUCCESS(WStatus)) {
        fprintf(stderr, "NtFrsApi_InfoLineW() -> %d\n", WStatus);
        exit(1);
    }
    if (Line) {
        printf("%ws", Line);
        goto AGAIN;
    }
    NtFrsApi_Free_InfoW(&Info);
#endif 0
    exit(0);
}


#define PRIV_BUF_LENGTH    (1024)
VOID
LogOnAsComputer(
    )
/*++
Routine Description:
    Check if the caller is a member of Groups

Arguments:
    ServerHandle
    Groups

Return Value:
    Win32 Status
--*/
{
#define  DEBSUB  "CheckGroups:"
    DWORD               WStatus;
    PVOID               PrivBuf;
    DWORD               PrivBufLen;
    DWORD               LastPrivBufLen;
    HANDLE              IdHandle;
    HANDLE              TokenHandle;
    DWORD               i;
    DWORD               j;
    TOKEN_PRIVILEGES    *Tp;
    DWORD               ComputerLen;
    WCHAR               ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD               PrivLen;
    WCHAR               PrivName[MAX_PATH + 1];

    ComputerLen = MAX_COMPUTERNAME_LENGTH;
    ComputerName[0] = L'\0';
    if (!GetComputerName(ComputerName, &ComputerLen)) {
        printf("FRS: Cannot get the computer's name\n");
        return;
    }
    printf("Computer name is %ws\n", ComputerName);

    //
    // For this process
    //
    IdHandle = GetCurrentProcess();
    if (!OpenProcessToken(IdHandle, TOKEN_QUERY, &TokenHandle)) {
        WStatus = GetLastError();
        printf("Can't open process token; WStatus %d\n", WStatus);
        goto cleanup;
    }

    //
    // Get the groups from the access token for this thread or process
    //
    PrivBufLen = PRIV_BUF_LENGTH;
    do {
        PrivBuf = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, PrivBufLen);
        LastPrivBufLen = PrivBufLen;
        if (!GetTokenInformation(TokenHandle,
                                 TokenPrivileges,
                                 PrivBuf,
                                 PrivBufLen,
                                 &PrivBufLen)) {
            WStatus = GetLastError();
            printf("Can't get privs groups; WStatus %d (lastlen %d; curlen %d\n",
                   WStatus,
                   LastPrivBufLen,
                   PrivBufLen);
            FREE(PrivBuf);
        } else {
            WStatus = ERROR_SUCCESS;
        }

    } while (!WIN_SUCCESS(WStatus) && LastPrivBufLen < PrivBufLen);
    if (!WIN_SUCCESS(WStatus)) {
        goto cleanup;
    }

    Tp = (TOKEN_PRIVILEGES *)PrivBuf;
    for (i = 0; i < Tp->PrivilegeCount; ++i) {
        PrivLen = MAX_PATH + 1;
        if (!LookupPrivilegeName(NULL,
                                 &Tp->Privileges[i].Luid,
                                 PrivName,
                                 &PrivLen)) {
            printf("lookuppriv error %d\n", GetLastError());
            exit(0);
        }
        printf("Priv %d is %ws\n", i, PrivName);
    }

    printf("Okay\n");

    CloseHandle(TokenHandle);
    if (!LogonUser(L"Administrator",
                  NULL,
                  NULL,
                  LOGON32_LOGON_SERVICE,
                  LOGON32_PROVIDER_DEFAULT,
                  &TokenHandle)) {
        printf("ERROR - %d logon\n", GetLastError());
        exit(0);
    }

cleanup:
    CloseHandle(TokenHandle);
    CloseHandle(IdHandle);
    FREE(PrivBuf);
}

// --------------- Process Install Stage


BOOL
FrsSetCompression(
    IN PWCHAR   Path,
    IN HANDLE   Handle,
    IN USHORT   TypeOfCompression
    )
/*++
Routine Description:
    Enable compression on Handle.

Arguments:
    Path
    Handle
    TypeOfCompression

Return Value:
    Set the compression mode on a file
--*/
{
    DWORD   BytesReturned;
    if (!DeviceIoControl(Handle,
                         FSCTL_SET_COMPRESSION,
                         &TypeOfCompression,
                         sizeof(TypeOfCompression),
                         NULL,
                         0,
                         &BytesReturned,
                         NULL)) {
        Win32ToMsg(Path, GetLastError());
        return FALSE;
    }
    return TRUE;
}


BOOL
FrsSetFileAttributes(
    PWCHAR  Path,
    HANDLE  Handle,
    ULONG   FileAttributes
    )
/*++
Routine Description:
    This routine sets the file's attributes

Arguments:
    Path        - for error messages
    Handle      - Supplies a handle to the file that is to be marked for delete.
    Attributes  - Attributes for the file
Return Value:
    TRUE - attributes have been set
    FALSE
--*/
{
    IO_STATUS_BLOCK         IoStatus;
    FILE_BASIC_INFORMATION  BasicInformation;
    NTSTATUS                Status;

    //
    // Set the attributes
    //
    ZeroMemory(&BasicInformation, sizeof(BasicInformation));
    BasicInformation.FileAttributes = FileAttributes | FILE_ATTRIBUTE_NORMAL;
    Status = NtSetInformationFile(Handle,
                                  &IoStatus,
                                  &BasicInformation,
                                  sizeof(BasicInformation),
                                  FileBasicInformation);
    if (!NT_SUCCESS(Status)) {
        fprintf(stderr, "NtSetFileInformationFile(%ws); NtStatus 0x%08x\n",
                Path,
                Status);
        return FALSE;
    }
    return TRUE;
}



DWORD
FrsSetFilePointer(
    IN PWCHAR       Name,
    IN HANDLE       Handle,
    IN ULONG        High,
    IN ULONG        Low
    )
/*++
Routine Description:
    Position file pointer

Arguments:
    Handle
    Name
    High
    Low

Return Value:
    Win32 Error Status

--*/
{
#undef DEBSUB
#define DEBSUB  "FrsSetFilePointer:"

    DWORD WStatus;

    Low = SetFilePointer(Handle, Low, &High, FILE_BEGIN);

    if (Low == INVALID_SET_FILE_POINTER) {
        WStatus = GetLastError();
        if (WStatus != NO_ERROR) {
            Win32ToMsg(Name, WStatus);
            return WStatus;
        }
    }

    return ERROR_SUCCESS;
}



BOOL
StuReadFile(
    IN  PWCHAR  Path,
    IN  HANDLE  Handle,
    IN  PVOID   Buf,
    IN  DWORD   BytesToRead,
    OUT PDWORD  BytesRead
    )
/*++
Routine Description:
    Read data from a file

Arguments:
    Path
    Handle
    Buf
    BytesToRead

Return Value:
    TRUE    - no problem
    FALSE   - couldn't read
--*/
{
    BOOL    DidRead;

   //
   // Read the file's name into the file
   //
   DidRead = ReadFile(Handle, Buf, BytesToRead, BytesRead, NULL);

   //
   // Read error
   //
   if (!DidRead) {
       Win32ToMsg(Path, GetLastError());
       return FALSE;
   }
   //
   // Done
   //
   return TRUE;
}


BOOL
FrsSetFileTime(
    IN PWCHAR       Path,
    IN HANDLE       Handle,
    IN FILETIME     *CreateTime,
    IN FILETIME     *AccessTime,
    IN FILETIME     *WriteTime
    )
/*++
Routine Description:
    Position file pointer

Arguments:
    Path
    Handle
    Attributes
    CreateTime
    AccessTime
    WriteTime

Return Value:
    TRUE    - no problem
    FALSE   - couldn't set size
--*/
{
   if (!SetFileTime(Handle, CreateTime, AccessTime, WriteTime)) {
       Win32ToMsg(Path, GetLastError());
       return FALSE;
   }
   return TRUE;
}


#define IOSIZE  (64 * 1024)
VOID
ProcessInstall(
    IN DWORD    argc,
    IN PWCHAR   *Argv
    )
/*++
Routine Description:
    Restore the StagePath to TargetPath if TargetPath is non-NULL.

Arguments:
    argc    - number of argv's
    Argv    - stagepath and, optionally, targetpath

Return Value:
    Win32 status
--*/
{
    BOOL            IsDir;
    BOOL            ExistingOid;
    ULONG           High;
    ULONG           Low;
    ULONG           WStatus;
    ULONG           Restored;
    ULONG           ToRestore;
    ULONG           FileOffset;
    PUCHAR          RestoreBuf      = NULL;
    PVOID           RestoreContext  = NULL;
    DWORD           BytesRead       = 0;
    HANDLE          StageHandle     = INVALID_HANDLE_VALUE;
    PWCHAR          StagePath       = NULL;
    PWCHAR          TargetPath      = NULL;
    HANDLE          TargetHandle    = INVALID_HANDLE_VALUE;
    STAGE_HEADER    Header;
    WIN32_STREAM_ID *StreamId = NULL;
    DWORD           RestoreStreamOffset = 0;
#if 0
typedef struct _WIN32_STREAM_ID {
        DWORD          dwStreamId ;
        DWORD          dwStreamAttributes ;
        LARGE_INTEGER  Size ;
        DWORD          dwStreamNameSize ;
        WCHAR          cStreamName[ ANYSIZE_ARRAY ] ;
} WIN32_STREAM_ID, *LPWIN32_STREAM_ID ;
#endif 0

    //
    // Check params
    //
    if (argc < 3 || argc > 4) {
        Usage(1);
    }

    StagePath = Argv[2];
    if (argc == 4) {
        TargetPath = Argv[3];
    }

    printf("%ws %ws %ws %ws\n",
           Argv[0],
           Argv[1],
           Argv[2],
           (argc == 4) ? Argv[3] : L"");


    //
    // Open the stage file for shared, sequential reads
    //
    //
    // Open the file
    //
    printf("Stage path: %ws\n", StagePath);
    StageHandle = CreateFile(StagePath,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_SEQUENTIAL_SCAN |
                             FILE_FLAG_BACKUP_SEMANTICS,
                             NULL);
    if (StageHandle == INVALID_HANDLE_VALUE) {
        Win32ToMsg(StagePath, GetLastError());
        Win32ToMsg(L"CreateFile(StagePath)", GetLastError());
        goto CLEANUP;
    }


    //
    // Read the header
    //
    if (!ReadFile(StageHandle,
                  &Header,
                  sizeof(STAGE_HEADER),
                  &BytesRead,
                  NULL)) {
        Win32ToMsg(StagePath, GetLastError());
        goto CLEANUP;
    }
    if (BytesRead != sizeof(STAGE_HEADER)) {
        fprintf(stderr, "%ws: Read %d bytes, not %d\n",
                StagePath,
                BytesRead,
                sizeof(STAGE_HEADER));
        goto CLEANUP;
    }
    printf("Stage Header:\n");
    printf("\tName       : %ws\n",  Header.ChangeOrderCommand.FileName);
    printf("\tMajor      : %08x\n", Header.Major);
    printf("\tMinor      : %08x\n", Header.Minor);
    printf("\tDataHigh   : %08x\n", Header.DataHigh);
    printf("\tDataLow    : %08x\n", Header.DataLow);
    printf("\tCompression: %08x\n", Header.Compression);
    printf("\tAttributes : %08x\n", Header.Attributes.FileAttributes);

    //
    // Don't understand this header format
    //
    if (Header.Major != NTFRS_MAJOR) {
        fprintf(stderr, "%ws: Major %d != NtFrsMajor %d\n",
                StagePath,
                Header.Major,
                NTFRS_MAJOR);
        goto CLEANUP;
    }

    if (!TargetPath) {
        goto CLEANUP;
    }

    //
    // INSTALL STAGE FILE
    //
    //
    // Open the file
    //
    printf("Target path: %ws\n", TargetPath);
    IsDir = Header.Attributes.FileAttributes & FILE_ATTRIBUTE_DIRECTORY;
    TargetHandle = CreateFile(TargetPath,
                              RESTORE_ACCESS,
                              0,
                              NULL,
                              OPEN_ALWAYS,
                              OPEN_OPTIONS,
                              NULL);
    if (TargetHandle == INVALID_HANDLE_VALUE) {
        Win32ToMsg(TargetPath, GetLastError());
        Win32ToMsg(L"CreateFile(TargetPath)", GetLastError());
        goto CLEANUP;
    }

    //
    // Truncate the file if not a directory
    //
    if (!IsDir && !SetEndOfFile(TargetHandle)) {
        Win32ToMsg(TargetPath, GetLastError());
        goto CLEANUP;
    }

    //
    // Set compression mode
    //
    if (!FrsSetCompression(TargetPath,
                           TargetHandle,
                           Header.Compression)) {
        goto CLEANUP;
    }

    //
    // Set attributes
    //
    if (!FrsSetFileAttributes(TargetPath,
                              TargetHandle,
                              Header.Attributes.FileAttributes &
                              ~NOREPL_ATTRIBUTES)) {
        goto CLEANUP;
    }


    //
    // Seek to the first byte of data in the stage file
    //
    if (FrsSetFilePointer(StagePath,
                          StageHandle,
                          Header.DataHigh,
                          Header.DataLow) != ERROR_SUCCESS) {
        goto CLEANUP;
    }
    FileOffset = Header.DataLow;


    //
    // Restore the stage file into the temporary file
    //
    RestoreBuf = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, IOSIZE);

    do {
        //
        // read stage
        //
        printf("Reading %d bytes at %08x\n", IOSIZE, FileOffset);
        if (!StuReadFile(StagePath,
                         StageHandle,
                         RestoreBuf,
                         IOSIZE,
                         &ToRestore)) {
            goto CLEANUP;
        }
        printf("Read %d bytes at %08x\n", ToRestore, FileOffset);
        FileOffset += ToRestore;

        if (ToRestore == 0) {
            break;
        }

        //
        // Dump stream heads in first restore buffer
        // Increase buffer size to catch all heads OR
        // enhance code to remember stream head offsets
        // across restore bufs.
        //
        if (StreamId == NULL) {
            RestoreStreamOffset = 0;
            while (RestoreStreamOffset < ToRestore) {
                StreamId = (WIN32_STREAM_ID *)(RestoreBuf + RestoreStreamOffset);
                printf("StreamId: %08x %d (%08x)\n", StreamId, RestoreStreamOffset);
                printf("dwStreamId: %d\n", StreamId->dwStreamId);
                printf("dwStreamAttributes: %08x\n", StreamId->dwStreamAttributes);
                printf("Size High: %08x\n", StreamId->Size.HighPart);
                printf("Size Low: %08x\n", StreamId->Size.LowPart);
                printf("dwStreamNameSize: %d\n", StreamId->dwStreamNameSize);
                RestoreStreamOffset += (sizeof(WIN32_STREAM_ID) - 4);
                RestoreStreamOffset += StreamId->dwStreamNameSize;
                RestoreStreamOffset += StreamId->Size.LowPart;
            }
        }

        if (!BackupWrite(TargetHandle,
                         RestoreBuf,
                         ToRestore,
                         &Restored,
                         FALSE,
                         TRUE,
                         &RestoreContext)) {
            WStatus = GetLastError();
            printf("BackupWrite(%08x, %d) returned %d\n",
                   RestoreContext,
                   ToRestore,
                   WStatus);
            if (IsDir && WStatus == ERROR_ALREADY_EXISTS) {
                fprintf(stderr, "%ws: WStatus %d IGNORED; dirs and altstreams\n",
                        TargetPath,
                        WStatus);
            }
            //
            // Uknown stream header or couldn't apply object id
            //
            if (WStatus == ERROR_INVALID_DATA ||
                WStatus == ERROR_DUP_NAME     ||
                (IsDir && WStatus == ERROR_ALREADY_EXISTS)) {
                //
                // Seek to the next stream. Stop if there are none.
                //
                printf("BackupWrite() returned %d; try to seek past bad data\n", WStatus);
                BackupSeek(TargetHandle,
                           -1,
                           -1,
                           &Low,
                           &High,
                           &RestoreContext);
                if (Low == 0 && High == 0) {
                    printf("BackupSeek failed; abort\n");
                    break;
                }
                fprintf(stderr, "%ws: WStatus %d IGNORED; BackupSeek() okay\n",
                        TargetPath,
                        WStatus);
            } else {
                //
                // Unknown error; abort
                //
                Win32ToMsg(TargetPath, GetLastError());
                goto CLEANUP;
            }
        } else {
            printf("BackupWrite(%08x, %d) okay\n", RestoreContext, ToRestore);
        }
    } while (TRUE);

#if 0
    //
    // Insure the correct object ID is on the file.
    //
    FRS_ASSERT(!memcmp(Header->FileObjId.ObjectId, &Coc->FileGuid, sizeof(GUID)));
    bugbug("do we have to write the extend OID data here???")
    WStatus = FrsGetOrSetFileObjectId(DstHandle,
                                      Coc->FileName,
                                      TRUE,
                                      &Header->FileObjId);
    if (WStatus == ERROR_DUP_NAME) {
        DPRINT2(0, "Stealing object id for %ws; WStatus %d\n",
                Coc->FileName,
                WStatus);
        ZeroMemory(&FileObjID, sizeof(FileObjID));
        FrsUuidCreate((GUID *)(&FileObjID.ObjectId[0]));

        ExistingOid = FALSE;
        WStatus = ChgOrdHammerObjectId(Coc->FileName,
                                       &Coc->FileGuid,
                                       OBJECT_ID_LENGTH,
                                       Coc->NewReplica->pVme,
                                       TRUE,
                                       NULL,
                                       &FileObjID,
                                       &ExistingOid);
        if (WIN_SUCCESS(WStatus)) {
            WStatus = FrsGetOrSetFileObjectId(DstHandle,
                                              Coc->FileName,
                                              TRUE,
                                              &Header->FileObjId);
        }
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT2(0, "Retry install of %ws because of object id; WStatus %d\n",
                    Coc->FileName,
                    WStatus);
            WStatus = ERROR_RETRY;
        }
    }
    if (!WIN_SUCCESS(WStatus)) {
        goto out;
    }
#endif 0

    //
    // Set times
    //
    if (!FrsSetFileTime(TargetPath,
                        TargetHandle,
                        (PFILETIME)&Header.Attributes.CreationTime.QuadPart,
                        (PFILETIME)&Header.Attributes.LastAccessTime.QuadPart,
                        (PFILETIME)&Header.Attributes.LastWriteTime.QuadPart)) {
        goto CLEANUP;
    }

    //
    // Set final attributes
    //
    if (!FrsSetFileAttributes(TargetPath,
                              TargetHandle,
                              Header.Attributes.FileAttributes)) {
        goto CLEANUP;
    }

    //
    // Make sure all of the data is on disk. We don't want to lose
    // it across reboots
    //
    if (!FlushFileBuffers(TargetHandle)) {
        Win32ToMsg(TargetPath, GetLastError());
        goto CLEANUP;
    }

CLEANUP:
    //
    // Free up the restore context before we close TmpHandle (just in case)
    //
    if (RestoreContext) {
        printf("Discard BackupWrite(%08x)\n", RestoreContext);
        BackupWrite(TargetHandle,
                    NULL,
                    0,
                    NULL,
                    TRUE,
                    TRUE,
                    &RestoreContext);
    }
    if (StageHandle && StageHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(StageHandle);
    }
    if (TargetHandle && TargetHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(TargetHandle);
    }
    FREE(RestoreBuf);
    printf("Install of %ws into %ws complete\n",
           StagePath,
           TargetPath);
}
// ----------------


VOID _cdecl
main(
    IN DWORD argc,
    IN PCHAR *argv
    )
/*++
Routine Description:
    Process the command line.

Arguments:
    argc
    argv

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    PWCHAR  *Argv;

    //
    // Print usage and exit
    //
    if (argc == 1) {
        Usage(0);
    }

    //
    // Use wide char parameters
    //
    Argv = ConvertArgv(argc, argv);

    //
    // Find the subcommand
    //
    if (!wcscmp(Argv[1], L"poll")) {
        ProcessPoll(argc, Argv);
    } else if (!_wcsicmp(Argv[1], L"promote")) {
        ProcessPromote(argc, Argv);
    } else if (!_wcsicmp(Argv[1], L"promoteabort")) {
        ProcessPromoteAbort(argc, Argv);
    } else if (!_wcsicmp(Argv[1], L"promotesysvols")) {
        ProcessPromoteSysVols(argc, Argv);
    } else if (!_wcsicmp(Argv[1], L"demote")) {
        ProcessDemote(argc, Argv);
    } else if (!_wcsicmp(Argv[1], L"demoteabort")) {
        ProcessDemoteAbort(argc, Argv);
    } else if (!_wcsicmp(Argv[1], L"demotesysvols")) {
        ProcessDemoteSysVols(argc, Argv);
    } else if (!_wcsicmp(Argv[1], L"version")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_VERSION);
    } else if (!_wcsicmp(Argv[1], L"sets")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_SETS);
    } else if (!_wcsicmp(Argv[1], L"ds")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_DS);
    } else if (!_wcsicmp(Argv[1], L"memory")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_MEMORY);
    } else if (!_wcsicmp(Argv[1], L"idtable")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_IDTABLE);
    } else if (!_wcsicmp(Argv[1], L"inlog")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_INLOG);
    } else if (!_wcsicmp(Argv[1], L"outlog")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_OUTLOG);
    } else if (!_wcsicmp(Argv[1], L"threads")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_THREADS);
    } else if (!_wcsicmp(Argv[1], L"stage")) {
        ProcessDump(argc, Argv, NTFRSAPI_INFO_TYPE_STAGE);
    } else if (!_wcsicmp(Argv[1], L"install")) {
        ProcessInstall(argc, Argv);
    } else if (!_wcsicmp(Argv[1], L"restore")) {
        ProcessBackupRestore(argc, Argv, NTFRSAPI_BUR_FLAGS_RESTORE);
    } else if (!_wcsicmp(Argv[1], L"backup")) {
        ProcessBackupRestore(argc, Argv, NTFRSAPI_BUR_FLAGS_BACKUP);
    } else if (!_wcsicmp(Argv[1], L"comm")) {
        // Not implemented
        // ProcessComm(argc, Argv, NTFRSAPI_COMM_COMMAND_TEST);
    } else {
        fprintf(stderr, "Don't understand %ws\n", Argv[1]);
        Usage(1);
    }
    exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\test\frscompress\frscompress.c ===
#include <ntreppch.h>
#pragma  hdrstop

#include <frs.h>
#include <tablefcn.h>
#include <perrepsr.h>
#define INITGUID
#include "frstrace.h"
/////////////////////////////////FROM MAIN.c ////////////////////////////////////

PCHAR LatestChanges[] = {

    "Latest changes:",
    "  RC3-Q1: 432553, 436070, 432549",
    "  WMI Perf Tracing",
    "  Allow all junction points",
    "  Automatic trigger of non-auth restore on WRAP_ERROR",
    "  Allow changing replica root path",
    "  03/18/00 - sudarc - checkin",
    "  03/15/00 - 32/64 Comm fix.",
    "  03/20    - merge with sudarc.",
    "  03/30/00 - sudarc - checkin - volatile connection cleanup.",
    "  04/14/00 - sudarc - checkin - bugbug, memleak, and poll summary eventlog.",

    NULL
};

HANDLE  ShutDownEvent;
HANDLE  ShutDownComplete;
HANDLE  DataBaseEvent;
HANDLE  JournalEvent;
HANDLE  ChgOrdEvent;
HANDLE  ReplicaEvent;
HANDLE  CommEvent;
HANDLE  DsPollEvent;
HANDLE  DsShutDownComplete;
PWCHAR  ServerPrincName;
BOOL    IsAMember               = FALSE;
BOOL    IsADc                   = FALSE;
BOOL    IsAPrimaryDc            = FALSE;
BOOL    EventLogIsRunning       = FALSE;
BOOL    RpcssIsRunning          = FALSE;
BOOL    RunningAsAService       = TRUE;
BOOL    NoDs                    = FALSE;
BOOL    FrsIsShuttingDown       = FALSE;
BOOL    FrsIsAsserting          = FALSE;

//
// Require mutual authentication
//
BOOL    MutualAuthenticationIsEnabled;

//
// Directory and file filter lists from registry.
//
PWCHAR  RegistryFileExclFilterList;
PWCHAR  RegistryFileInclFilterList;

PWCHAR  RegistryDirExclFilterList;
PWCHAR  RegistryDirInclFilterList;

//
// Synchronize the shutdown thread with the service controller
//
CRITICAL_SECTION    ServiceLock;

//
// Synchronize initialization
//
CRITICAL_SECTION    MainInitLock;

//
// Convert the ANSI ArgV into a UNICODE ArgV
//
PWCHAR  *WideArgV;

//
// Process Handle
//
HANDLE  ProcessHandle;

//
// Working path / DB Log path
//
PWCHAR  WorkingPath;
PWCHAR  DbLogPath;

//
// Database directories (UNICODE and ASCII)
//
PWCHAR  JetPath;
PWCHAR  JetFile;
PWCHAR  JetFileCompact;
PWCHAR  JetSys;
PWCHAR  JetTemp;
PWCHAR  JetLog;

PCHAR   JetPathA;
PCHAR   JetFileA;
PCHAR   JetFileCompactA;
PCHAR   JetSysA;
PCHAR   JetTempA;
PCHAR   JetLogA;

//
// Limit the amount of staging area used (in kilobytes). This is
// a soft limit, the actual usage may be higher.
//
DWORD StagingLimitInKb;
//
// Max number replica sets and Jet Sessions allowed.
//
ULONG MaxNumberReplicaSets;
ULONG MaxNumberJetSessions;

//
// Maximum number of outbound changeorders allowed outstanding per connection.
//
ULONG MaxOutLogCoQuota;
//
// If TRUE then try to preserve existing file OIDs whenever possible.
//  -- See Bug 352250 for why this is a risky thing to do.
//
BOOL  PreserveFileOID;

//
// Major/minor  (see frs.h)
//
ULONG   NtFrsMajor      = NTFRS_MAJOR;
ULONG   NtFrsMinor      = NTFRS_MINOR;

ULONG   NtFrsStageMajor = NTFRS_STAGE_MAJOR;
ULONG   NtFrsStageMinor = NTFRS_STAGE_MINOR_1;

ULONG   NtFrsCommMinor  = NTFRS_COMM_MINOR_3;

PCHAR   NtFrsModule     = __FILE__;
PCHAR   NtFrsDate       = __DATE__;
PCHAR   NtFrsTime       = __TIME__;

//
// Shutdown timeout
//

ULONG   ShutDownTimeOut = DEFAULT_SHUTDOWN_TIMEOUT;

//
// A useful thing to have around
//
WCHAR   ComputerName[MAX_COMPUTERNAME_LENGTH + 2];
PWCHAR  ComputerDnsName;
PWCHAR  ServiceLongName;

//
// The rpc server may reference this table as soon as the rpc interface
// is registered. Make sure it is setup.
//
extern PGEN_TABLE ReplicasByGuid;

//
// The staging area table is references early in the startup process
//
extern PGEN_TABLE   StagingAreaTable;

PGEN_TABLE   CompressionTable;

//
// Size of buffer to use when enumerating directories. Actual memory
// usage will be #levels * SizeOfBuffer.
//
LONG    EnumerateDirectorySizeInBytes;




BOOL    MainInitHasRun;

//
// Do not accept stop control unless the service is in SERVICE_RUNNING state.
// This prevents the service from getting confused when a stop is called
// while the service is starting.
//
SERVICE_STATUS  ServiceStatus = {
        SERVICE_WIN32_OWN_PROCESS,
        SERVICE_START_PENDING,
//        SERVICE_ACCEPT_STOP |
            // SERVICE_ACCEPT_PAUSE_CONTINUE |
        SERVICE_ACCEPT_SHUTDOWN,
        0,
        0,
        0,
        60*1000
};

//
// Supported compression formats.
//

//
// This is the compression format for uncompressed data.
//
DEFINE_GUID ( /* 00000000-0000-0000-0000-000000000000 */
    FrsGuidCompressionFormatNone,
    0x00000000,
    0x0000,
    0x0000,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  );

//
// This is the compression format for data compressed using NTFS's LZNT1 compression
// routines.
//
DEFINE_GUID ( /* 64d2f7d2-2695-436d-8830-8d3c58701e15 */
    FrsGuidCompressionFormatLZNT1,
    0x64d2f7d2,
    0x2695,
    0x436d,
    0x88, 0x30, 0x8d, 0x3c, 0x58, 0x70, 0x1e, 0x15
  );

//
// Fixed guid for the dummy cxtion (aka GhostCxtion) assigned to orphan remote
// change orders whose inbound cxtion has been deleted from the DS but they
// have already past the fetching state and can finish without the real cxtion
// coming back. No authentication checks are made for this dummy cxtion.
//
DEFINE_GUID ( /* b9d307a7-a140-4405-991e-281033f03309 */
    FrsGuidGhostCxtion,
    0xb9d307a7,
    0xa140,
    0x4405,
    0x99, 0x1e, 0x28, 0x10, 0x33, 0xf0, 0x33, 0x09
  );

DEFINE_GUID ( /* 3fe2820f-3045-4932-97fe-00d10b746dbf */
    FrsGhostJoinGuid,
    0x3fe2820f,
    0x3045,
    0x4932,
    0x97, 0xfe, 0x00, 0xd1, 0x0b, 0x74, 0x6d, 0xbf
  );

//
// Static Ghost cxtion structure. This cxtion is assigned to orphan remote change
// orders in the inbound log whose cxtion is deleted from the DS but who have already
// past the fetching state and do not need the cxtion to complete processing. No
// authentication checks are made for this dummy cxtion.
//
PCXTION  FrsGhostCxtion;

SERVICE_STATUS_HANDLE   ServiceStatusHandle = NULL;

VOID
InitializeEventLog(
    VOID
    );

DWORD
FrsSetServiceFailureAction(
    VOID
    );

VOID
FrsRpcInitializeAccessChecks(
    VOID
    );

BOOL
FrsSetupPrivileges (
    VOID
    );

VOID
CfgRegAdjustTuningDefaults(
    VOID
    );

VOID
CommInitializeCommSubsystem(
    VOID
    );

VOID
SndCsInitialize(
    VOID
    );


// FRS Capacity Planning
//
#define RESOURCE_NAME       L"MofResourceName"
#define IMAGE_PATH          L"ntfrs.exe"

DWORD       FrsWmiEventTraceFlag          = FALSE;
TRACEHANDLE FrsWmiTraceRegistrationHandle = (TRACEHANDLE) 0;
TRACEHANDLE FrsWmiTraceLoggerHandle       = (TRACEHANDLE) 0;

// This is the FRS control Guid for the group of Guids traced below
//
DEFINE_GUID ( /* 78a8f0b1-290e-4c4c-9720-c7f1ef68ce21 */
    FrsControlGuid,
    0x78a8f0b1,
    0x290e,
    0x4c4c,
    0x97, 0x20, 0xc7, 0xf1, 0xef, 0x68, 0xce, 0x21
  );

// Traceable Guids start here
//
DEFINE_GUID ( /* 2eee6bbf-6665-44cf-8ed7-ceea1d306085 */
    FrsTransGuid,
    0x2eee6bbf,
    0x6665,
    0x44cf,
    0x8e, 0xd7, 0xce, 0xea, 0x1d, 0x30, 0x60, 0x85
  );

TRACE_GUID_REGISTRATION FrsTraceGuids[] =
{
    { & FrsTransGuid, NULL }
};

#define FrsGuidCount (sizeof(FrsTraceGuids) / sizeof(TRACE_GUID_REGISTRATION))

//
// Trace initialization / shutdown routines
//


VOID
MainInit(
    VOID
    )
/*++
Routine Description:
    Initialize anything necessary to run the service

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "MainInit:"

    EnterCriticalSection(&MainInitLock);
    //
    // No need to initialize twice
    //
    if (MainInitHasRun) {
        LeaveCriticalSection(&MainInitLock);
        return;
    }

    //
    // SETUP THE INFRASTRUCTURE
    //
//    DEBUG_INIT();

    //
    // Fetch the staging file limit
    //

    CfgRegReadDWord(FKC_STAGING_LIMIT, NULL, 0, &StagingLimitInKb);
    DPRINT1(4, ":S: Staging limit is: %d KB\n", StagingLimitInKb);

    //
    // Put the default value in registry if there is no key present.
    //
    CfgRegWriteDWord(FKC_STAGING_LIMIT,
                     NULL,
                     FRS_RKF_FORCE_DEFAULT_VALUE | FRS_RKF_KEEP_EXISTING_VALUE,
                     0);

    //
    // Get Max number of replica sets allowed.
    //
    CfgRegReadDWord(FKC_MAX_NUMBER_REPLICA_SETS, NULL, 0, &MaxNumberReplicaSets);

    //
    // Get outstanding CO qutoa limit on outbound connections.
    //
    CfgRegReadDWord(FKC_OUT_LOG_CO_QUOTA, NULL, 0, &MaxOutLogCoQuota);

    //
    // Get boolean to tell us to preserve file object IDs
    //  -- See Bug 352250 for why this is a risky thing to do.
    CfgRegReadDWord(FKC_PRESERVE_FILE_OID, NULL, 0, &PreserveFileOID);

    //
    // Get the service long name for use in error messages.
    //
    ServiceLongName = FrsGetResourceStr(IDS_SERVICE_LONG_NAME);

    //
    // Initialize the Delayed command server. This command server
    // is really a timeout queue that the other command servers use
    // to retry or check the state of previously issued commands that
    // have an indeterminate completion time.
    //
    // WARN: MUST BE FIRST -- Some command servers may use this
    // command server during their initialization.
    //
    WaitInitialize();
    FrsDelCsInitialize();

    //
    // SETUP THE COMM LAYER
    //

    //
    // Initialize the low level comm subsystem
    //
    CommInitializeCommSubsystem();

    //
    // Initialize the Send command server. The receive command server
    // starts when we register our RPC interface.
    //
    SndCsInitialize();

    //
    // SETUP THE SUPPORT COMMAND SERVERS
    //

    //
    // Staging file fetcher
    //
    FrsFetchCsInitialize();

    //
    // Staging file installer
    //
    FrsInstallCsInitialize();

    //
    // Staging file generator
    //
    FrsStageCsInitialize();

    //
    // outbound log processor
    //
    OutLogInitialize();

    //
    // LAST, KICK OFF REPLICATION
    //

    //
    // MUST PRECEED DATABASE AND DS INITIALIZATION
    //
    // The DS command server and the Database command server depend on
    // the replica control initialization.
    //
    // Initialize the replica control command server
    //
    RcsInitializeReplicaCmdServer();

    //
    // Actually, we can start the database at any time after the delayed
    // command server and the replica control command server. But its
    // a good idea to fail sooner than later to make cleanup more predictable.
    //
    DbsInitialize();

    //
    // Free up memory by reducing our working set size
    //
    SetProcessWorkingSetSize(ProcessHandle, (SIZE_T)-1, (SIZE_T)-1);

    MainInitHasRun = TRUE;
    LeaveCriticalSection(&MainInitLock);
}

////////////////////////////////////FROM MAIN.C////////////////////////////////////


#define FREE(_p) \
if (_p) free(_p);


PWCHAR *
MainConvertArgV(
    DWORD ArgC,
    PCHAR *ArgV
    )
/*++
Routine Description:
    Convert short char ArgV into wide char ArgV

Arguments:
    ArgC    - From main
    ArgV    - From main

Return Value:
    Address of the new ArgV
--*/
{
#undef DEBSUB
#define DEBSUB "MainConvertArgV:"

    PWCHAR  *wideArgV;

    wideArgV = (PWCHAR*)malloc((ArgC + 1) * sizeof(PWCHAR));
    wideArgV[ArgC] = NULL;

    while (ArgC-- >= 1) {
        wideArgV[ArgC] = (PWCHAR)malloc((strlen(ArgV[ArgC]) + 1) * sizeof(WCHAR));
        wsprintf(wideArgV[ArgC], L"%hs", ArgV[ArgC]);

        if (wideArgV[ArgC]) {
            _wcslwr(wideArgV[ArgC]);
        }
    }
    return wideArgV;
}

#define STAGEING_IOSIZE  (64 * 1024)

DWORD
FrsGetReparseTag(
    IN  HANDLE  Handle,
    OUT ULONG   *ReparseTag
    );


BOOL CompressionEnabled = TRUE;
//
//  Local data structures
//

//
//  The compressed chunk header is the structure that starts every
//  new chunk in the compressed data stream.  In our definition here
//  we union it with a ushort to make setting and retrieving the chunk
//  header easier.  The header stores the size of the compressed chunk,
//  its signature, and if the data stored in the chunk is compressed or
//  not.
//
//  Compressed Chunk Size:
//
//      The actual size of a compressed chunk ranges from 4 bytes (2 byte
//      header, 1 flag byte, and 1 literal byte) to 4098 bytes (2 byte
//      header, and 4096 bytes of uncompressed data).  The size is encoded
//      in a 12 bit field biased by 3.  A value of 1 corresponds to a chunk
//      size of 4, 2 => 5, ..., 4095 => 4098.  A value of zero is special
//      because it denotes the ending chunk header.
//
//  Chunk Signature:
//
//      The only valid signature value is 3.  This denotes a 4KB uncompressed
//      chunk using with the 4/12 to 12/4 sliding offset/length encoding.
//
//  Is Chunk Compressed:
//
//      If the data in the chunk is compressed this field is 1 otherwise
//      the data is uncompressed and this field is 0.
//
//  The ending chunk header in a compressed buffer contains the a value of
//  zero (space permitting).
//

typedef union _COMPRESSED_CHUNK_HEADER {

    struct {

        USHORT CompressedChunkSizeMinus3 : 12;
        USHORT ChunkSignature            :  3;
        USHORT IsChunkCompressed         :  1;

    } Chunk;

    USHORT Short;

} COMPRESSED_CHUNK_HEADER, *PCOMPRESSED_CHUNK_HEADER;

#define FRS_MAX_CHUNKS_TOUNCOMPRESS 16


DWORD
StuNewGenerateStage(
    PWCHAR  SrcFile,
    PWCHAR  DestFile
    )
/*++
Routine Description:
    Create and populate the staging file.  Currently there are four cases
    of interest based on the state of Coe, FromPreExisting and Md5:

    Coe   FromPreExisting  Md5

    NULL     FALSE       NULL         Fetch on demand or outlog trimmed so stage file must be regenerated
    NULL     FALSE       non-null     Fetch of pre-existing file by downstream partner.  check MD5.
    NULL     TRUE        NULL         doesn't occur
    NULL     TRUE        non-null     doesn't occur
    non-NULL FALSE       NULL         Generate stage file for local CO
    non-NULL FALSE       non-null     doesn't occur -- MD5 only generated for preexisting files
    non-NULL TRUE        NULL         doesn't occur -- MD5 always generated for preexisting files.
    non-NULL TRUE        non-null     Generate stage file from pre-existing file and send MD5 upstream to check for a match.

Arguments:

    Coc -- ptr to change order command.  NULL on incoming fetch requests from downstream partners.

    Coe -- ptr to change order entry.  NULL when regenerating the staging file for fetch

    FromPreExisting -- TRUE if this staging file is being generated from a
                       preexisting file.

    Md5 -- Generate the MD5 digest for the caller and return it if Non-NULL

    SizeOfFileGenerated - Valid when the size generated is needed, otherwise NULL

Return Value:
    WIN32 STATUS

--*/
{
#undef DEBSUB
#define DEBSUB  "StuNewGenerateStage:"


    OVERLAPPED      OpLockOverLap;
    LONGLONG        StreamBytesLeft;
    LONG            BuffBytesLeft;


    DWORD           WStatus;
    DWORD           NumBackupDataBytes;
    ULONG           ReparseTag;
    ULONG           OpenOptions;
    WORD            OldSecurityControl;
    WORD            NewSecurityControl;
    WORD            *SecurityControl;
    BOOL            FirstBuffer     = TRUE;
    BOOL            Regenerating    = FALSE;
    BOOL            SkipCo          = FALSE;
    BOOL            FirstOpen       = TRUE;
    BOOL            StartOfStream   = TRUE;

    PWCHAR          StagePath       = NULL;
    PWCHAR          FinalPath       = NULL;
    PUCHAR          BackupBuf       = NULL;
    PVOID           BackupContext   = NULL;

    HANDLE          OpLockEvent     = NULL;
    HANDLE          SrcHandle       = INVALID_HANDLE_VALUE;
    HANDLE          StageHandle     = INVALID_HANDLE_VALUE;
    HANDLE          OpLockHandle    = INVALID_HANDLE_VALUE;

    WIN32_STREAM_ID *StreamId;

    PSTAGE_HEADER   Header          = NULL;
    STAGE_HEADER    StageHeaderMemory;
    ULONG           Length;
    PREPLICA        NewReplica      = NULL;
    WCHAR           TStr[100];

    DWORD           NtStatus;
    PUCHAR          CompressedBuf   = NULL;
    DWORD           CompressedSize;
    PVOID           WorkSpace       = NULL;
    DWORD           WorkSpaceSize   = 0;
    DWORD           FragmentWorkSpaceSize   = 0;
    DWORD           UnCompressedFileSize    = 0;
    DWORD           CompressedFileSize      = 0;

    OpenOptions = OPEN_OPTIONS;

    //
    // The header is located at the beginning of the newly created staging file
    //
    // Fill in the header with info from the src file
    //      Compression type
    //      Change order
    //      Attributes
    //
    Header = &StageHeaderMemory;
    ZeroMemory(Header, sizeof(STAGE_HEADER));

    Header->Attributes.FileAttributes = GetFileAttributes(SrcFile);

RETRY_OPEN:

    WStatus = FrsOpenSourceFileW(&SrcHandle,
                                    SrcFile,
                                    READ_ACCESS,
                                    OpenOptions);
    if (!WIN_SUCCESS(WStatus)) {
        goto out;
    }

    //
    // What type of reparse is it?
    //
    if (FirstOpen &&
        (Header->Attributes.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)) {
        FirstOpen = FALSE;

        //
        // reparse tag
        //
        WStatus = FrsGetReparseTag(SrcHandle, &ReparseTag);
        if (!WIN_SUCCESS(WStatus)) {
            goto out;
        }

        //
        // We only accept operations on files with SIS and HSM reparse points.
        // For example a rename of a SIS file into a replica tree needs to prop
        // a create CO.
        //
        if ((ReparseTag != IO_REPARSE_TAG_HSM) &&
            (ReparseTag != IO_REPARSE_TAG_SIS)) {

            WIN_SET_FAIL(WStatus);
            goto out;
        }

        //
        // We hit a file with a known reparse tag type.
        // Close and reopen the file without the FILE_OPEN_REPARSE_POINT
        // option so backup read will get the underlying data.
        //
        FRS_CLOSE(SrcHandle);

        ClearFlag(OpenOptions, FILE_OPEN_REPARSE_POINT);
        goto RETRY_OPEN;

    }


    //
    // Assume retriable errors for the silly boolean functions
    //
    WIN_SET_RETRY(WStatus);

    //
    // Default to no compression if we can't get the compression state
    //
    if (!FrsGetCompression(SrcFile, SrcHandle, &Header->Compression)) {
        Header->Compression = COMPRESSION_FORMAT_NONE;
    }

    //
    // The backup data begins at the first 32 byte boundary following the header
    //
    Header->DataLow = QuadQuadAlignSize(sizeof(STAGE_HEADER));

    //
    // Major/minor
    //
    Header->Major = NtFrsStageMajor;
    Header->Minor = NtFrsStageMinor;

    //
    // Create the local staging name
    //
    StagePath = FrsWcsDup(DestFile);

    //
    // Create the staging file
    //
    StageHandle = StuCreateFile(StagePath);
    if (!HANDLE_IS_VALID(StageHandle)) {
        goto out;
    }

    //
    // Approximate size of the staging file
    //
    if (ERROR_SUCCESS != FrsSetFilePointer(StagePath, StageHandle,
                           Header->Attributes.EndOfFile.HighPart,
                           Header->Attributes.EndOfFile.LowPart)) {
        goto out;
    }

    if (!FrsSetEndOfFile(StagePath, StageHandle)) {
        goto out;
    }

    //
    // Rewind the file, write the header, and set the file pointer
    // to the next 32 byte boundary
    //
    if (ERROR_SUCCESS != FrsSetFilePointer(StagePath, StageHandle, 0, 0)) {
        goto out;
    }
    if (!StuWriteFile(StagePath, StageHandle, Header, sizeof(STAGE_HEADER))) {
        goto out;
    }
    if (ERROR_SUCCESS != FrsSetFilePointer(StagePath, StageHandle, 0, Header->DataLow)) {
        goto out;
    }

    UnCompressedFileSize = Header->DataLow;
    CompressedFileSize = Header->DataLow;

    //
    // Backup the src file into the staging file
    //
    BackupBuf = FrsAlloc(STAGEING_IOSIZE);
    CompressedBuf = FrsAlloc(STAGEING_IOSIZE * 2);
    StreamBytesLeft = 0;

    NtStatus = RtlGetCompressionWorkSpaceSize(COMPRESSION_FORMAT_LZNT1,
                                              &WorkSpaceSize,
                                              &FragmentWorkSpaceSize);

    WStatus = FrsSetLastNTError(NtStatus);

    if (!WIN_SUCCESS(WStatus)) {
        goto out;
    }
//    printf("WorkSpaceSize = %d, FragmentWorkSpaceSize = %d\n", WorkSpaceSize, FragmentWorkSpaceSize);

    WorkSpace = FrsAlloc(WorkSpaceSize);

    while (TRUE) {
        //
        // read source
        //
        if (!BackupRead(SrcHandle,
                        BackupBuf,
                        STAGEING_IOSIZE,
                        &NumBackupDataBytes,
                        FALSE,
                        TRUE,
                        &BackupContext)) {
            goto out;
        }

        //
        // No more data; Backup done
        //
        if (NumBackupDataBytes == 0) {
            break;
        }

        UnCompressedFileSize += NumBackupDataBytes;

        //
        // write the staging file
        //

        NtStatus = RtlCompressBuffer(COMPRESSION_FORMAT_LZNT1,           //  compression engine
                                     BackupBuf,                          //  input
                                     NumBackupDataBytes,                 //  length of input
                                     CompressedBuf,                      //  output
                                     STAGEING_IOSIZE * 2,                    //  length of output
                                     4096,                               //  chunking that occurs in buffer
                                     &CompressedSize,                    //  result size
                                     WorkSpace);                         //  I have no clue

        //
        // STATUS_BUFFER_ALL_ZEROS means the compression worked without a hitch
        // and in addition the input buffer was all zeros.
        //
        if (NtStatus == STATUS_BUFFER_ALL_ZEROS) {
            NtStatus = STATUS_SUCCESS;
        }
        WStatus = FrsSetLastNTError(NtStatus);

//        printf("Original Size = %d :: Compressed Size = %d\n", NumBackupDataBytes, CompressedSize);

        if (!WIN_SUCCESS(WStatus)) {
        printf("Error : Original Size = %d :: Compressed Size = %d\n", NumBackupDataBytes, CompressedSize);
            goto out;
        }

//        printf("Original Size = %d :: Compressed Size = %d\n", NumBackupDataBytes, CompressedSize);

        CompressedFileSize += CompressedSize;

        if (!StuWriteFile(StagePath, StageHandle, CompressedBuf, CompressedSize)) {
//        if (!StuWriteFile(StagePath, StageHandle, BackupBuf, NumBackupDataBytes)) {
            goto out;
        }

    }

    //
    // Release handles as soon as possible
    //
    FRS_CLOSE(SrcHandle);

    //
    // Make sure all of the data is on disk. We don't want to lose
    // it across reboots
    //
    if (!FrsFlushFile(StagePath, StageHandle)) {
        goto out;
    }

    //
    // Done with the staging file handle
    //
    if (BackupContext) {
        BackupRead(StageHandle, NULL, 0, NULL, TRUE, TRUE, &BackupContext);
    }

    FRS_CLOSE(StageHandle);
    BackupContext = NULL;


    printf("%ws Orig= %d, Comp= %d, Percentage_Comp= %5.2f\n", SrcFile, UnCompressedFileSize, CompressedFileSize,
           ((UnCompressedFileSize - CompressedFileSize)/(float)UnCompressedFileSize) * 100);

    WStatus = ERROR_SUCCESS;

out:
    //
    // Release resources
    //
    FRS_CLOSE(SrcHandle);

    if (BackupContext) {
        BackupRead(StageHandle, NULL, 0, NULL, TRUE, TRUE, &BackupContext);
    }

    FRS_CLOSE(StageHandle);

    FrsFree(BackupBuf);
    FrsFree(CompressedBuf);
    FrsFree(WorkSpace);
    FrsFree(StagePath);
    FrsFree(FinalPath);

    return WStatus;
}


ULONG
StuNewExecuteInstall(
    IN PWCHAR   SrcFile,
    IN PWCHAR   DestFile
    )
/*++
Routine Description:
    Install a staging file by restoring it to a temporary file in the
    same directory as the file to be replaced and then renaming it
    to its final destination.

Arguments:
    Coe

Return Value:

    Win32 status -
    ERROR_SUCCESS -  All installed or aborted. Don't retry.
    ERROR_GEN_FAILURE - Couldn't install bag it.
    ERROR_SHARING_VIOLATION - Couldn't open the target file.  retry later.
    ERROR_DISK_FULL - Couldn't allocate the target file.  retry later.
    ERROR_HANDLE_DISK_FULL - ?? retry later.

--*/
{
#undef DEBSUB
#define DEBSUB  "StuNewExecuteInstall:"
    DWORD           WStatus;
    DWORD           BytesRead;
    ULONG           Restored;
    ULONG           ToRestore;
    ULONG           High;
    ULONG           Low;
    ULONG           Flags;
    BOOL            AttributeMissmatch;
    ULONG           CreateDisposition;
    ULONG           OpenOptions;
    BOOL            IsDir;
    BOOL            IsReparsePoint;
    ULONG           SizeHigh;
    ULONG           SizeLow;
    BOOL            ExistingOid;
    PVOID           RestoreContext       = NULL;
    PWCHAR          StagePath            = NULL;
    PSTAGE_HEADER   Header               = NULL;
    HANDLE          DstHandle            = INVALID_HANDLE_VALUE;
    HANDLE          StageHandle          = INVALID_HANDLE_VALUE;
    PUCHAR          RestoreBuf           = NULL;
    FILE_OBJECTID_BUFFER    FileObjID;
    STAGE_HEADER    StageHeaderMemory;

    DWORD           NtStatus;
    PUCHAR          UnCompressedBuf      = NULL;
    DWORD           UnCompressedBufLen   = 0;
    DWORD           ActUnCompressedSize  = 0;
    COMPRESSED_CHUNK_HEADER ChunkHeader;
    DWORD           RestoreBufIndex      = 0;
    DWORD           RestoreBufSize       = 0;
    LONG            LenOfPartialChunk    = 0;
    DWORD           NoOfChunks           = 0;


    //
    // PROCESS STAGING FILE
    //
    StagePath = FrsWcsDup(SrcFile);

    //
    // Open the stage file for shared, sequential reads
    //
    StageHandle = StuOpenFile(StagePath, GENERIC_READ);
    if (!HANDLE_IS_VALID(StageHandle)) {
        goto CLEANUP;
    }

    //
    // Read the header
    //
    Header = &StageHeaderMemory;
    ZeroMemory(Header, sizeof(STAGE_HEADER));

    if (!StuReadFile(StagePath, StageHandle, Header, sizeof(STAGE_HEADER), &BytesRead)) {
        printf("Can't read file %ws. Error %d", StagePath, GetLastError());
    }

    //
    // Don't understand this header format
    //
    if (Header->Major != NtFrsStageMajor) {
        printf("Stage Header Major Version (%d) not supported.  Current Service Version is %d\n",
                Header->Major, NtFrsStageMajor);
        goto CLEANUP;
    }

    //
    // Minor version NTFRS_STAGE_MINOR_1 had the change order extension in the
    // header.
    //
    if (Header->Minor >= NTFRS_STAGE_MINOR_0) {

    } else {
        //
        // This is an older stage file.  No CO Extension in the header.
        //
        Header->ChangeOrderCommand.Extension = NULL;
    }

    //
    // PROCESS TEMPORARY FILE
    //
    IsDir = Header->Attributes.FileAttributes & FILE_ATTRIBUTE_DIRECTORY;
    IsReparsePoint = Header->Attributes.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT;

    CreateDisposition = FILE_OPEN;
    if (!IsDir) {
        //
        // In case this is an HSM file don't force the data to be read from
        // tape since the remote co is just going to overwrite all the data anyway.
        //
        // Setting CreateDisposition to FILE_OVERWRITE seems to cause a regression
        // Failure with an ACL Test where we set a deny all ACL and then the
        // open fails.  This is a mystery for now so don't do it.
        // In addtion overwrite fails if RO attribute is set on file.
        //
        //CreateDisposition = FILE_OVERWRITE;
        printf("Target is a file\n");
    } else {
        printf("Target is a directory\n");
    }

    //
    // In case this is a SIS or HSM file open the underlying file not the
    // reparse point.  For HSM, need to clear FILE_OPEN_NO_RECALL to write it.
    //
    OpenOptions = OPEN_OPTIONS;

    DstHandle = StuCreateFile(DestFile);
    if (!HANDLE_IS_VALID(DstHandle)) {
        goto CLEANUP;
    }

    //
    // Truncate the file if not a directory
    //
    if (!IsDir && !SetEndOfFile(DstHandle)) {
        printf("++ WARN - SetEndOfFile(%ws);", DestFile, GetLastError());
    }

    //
    // For the silly functions that don't return a win status
    //
    WIN_SET_FAIL(WStatus);

    //
    // Set compression mode
    //
    if (!FrsSetCompression(DestFile, DstHandle, Header->Compression)) {
        goto CLEANUP;
    }
    //
    // Set attributes
    //
    if (!FrsSetFileAttributes(DestFile,
                              DstHandle,
                              Header->Attributes.FileAttributes &
                              ~NOREPL_ATTRIBUTES)) {
        goto CLEANUP;
    }

    //
    // Seek to the first byte of data in the stage file
    //
    if (ERROR_SUCCESS != FrsSetFilePointer(StagePath, StageHandle,
                           Header->DataHigh, Header->DataLow)) {
        goto CLEANUP;
    }

    //
    // Restore the stage file into the temporary file
    //
    RestoreBuf = FrsAlloc(STAGEING_IOSIZE);
    UnCompressedBuf = 0;
    UnCompressedBufLen = 0;

    do {
        //
        // read stage
        //

        if (!StuReadFile(StagePath, StageHandle, RestoreBuf, STAGEING_IOSIZE, &ToRestore)) {
            goto CLEANUP;
        }

        if (ToRestore == 0) {
            break;
        }

        RestoreBufIndex = 0;
        RestoreBufSize = 0;
        NoOfChunks = 0;
        while ((RestoreBufIndex <= ToRestore) && (NoOfChunks < FRS_MAX_CHUNKS_TOUNCOMPRESS)) {
            memcpy(&ChunkHeader, RestoreBuf + RestoreBufIndex,sizeof(COMPRESSED_CHUNK_HEADER));
//            printf("Chunck size is 0x%x\n", ChunkHeader.Chunk.CompressedChunkSizeMinus3);
            RestoreBufSize = RestoreBufIndex;
            ++NoOfChunks;
            RestoreBufIndex+=ChunkHeader.Chunk.CompressedChunkSizeMinus3+3;
        }

        //
        // Check if the uncompressed buffer is enough to hold the data.
        // A uncomressed chunk can not be bigger than the chunk size specified
        // during compression (4096)
        //

        if ((NoOfChunks * 4096) > UnCompressedBufLen) {
//            printf("Allocating UnCompressedBuf 0x%x\n", NoOfChunks * 4096);
            UnCompressedBuf = FrsAlloc(NoOfChunks * 4096);
            UnCompressedBufLen = NoOfChunks * 4096;
        }

        //
        // Rewind the file pointer so we can read the remaining chunck at the next read.
        //

        LenOfPartialChunk = ((LONG)RestoreBufSize - (LONG)ToRestore);

        LenOfPartialChunk = SetFilePointer(StageHandle, LenOfPartialChunk, NULL, FILE_CURRENT);

        if (LenOfPartialChunk == 0xFFFFFFFF && GetLastError() != NO_ERROR) {
//            FrsErrorCodeMsg1(FRS_ERROR_SET_FILE_POINTER, GetLastError(), StagePath);
            goto CLEANUP;;
        }

//        printf("Passing : UnCompressedBufLen = 0x%x, RestoreBufSize = 0x%x, NoOfChunks = %d\n",
//                UnCompressedBufLen, RestoreBufSize, NoOfChunks);

        NtStatus = RtlDecompressBuffer(COMPRESSION_FORMAT_LZNT1,           //  compression engine
                                       UnCompressedBuf,                    //  input
                                       UnCompressedBufLen,                 //  length of input
                                       RestoreBuf,                         //  output
                                       RestoreBufSize,                     //
                                       &ActUnCompressedSize);                 //  result size

        WStatus = FrsSetLastNTError(NtStatus);

        if (!WIN_SUCCESS(WStatus)) {
            printf("Error decompressing. WStatus = %d. ActUnCompressedSize = 0x%x\n", WStatus, ActUnCompressedSize);
            goto CLEANUP;
        }
//        printf("Decompressed buf size = 0x%x\n", ActUnCompressedSize);
        //
        // restore temporary
        //
//        if (!BackupWrite(DstHandle, RestoreBuf, ToRestore, &Restored, FALSE, TRUE, &RestoreContext)) {
        if (!BackupWrite(DstHandle, UnCompressedBuf, ActUnCompressedSize, &Restored, FALSE, TRUE, &RestoreContext)) {

            WStatus = GetLastError();
            if (IsDir && WIN_ALREADY_EXISTS(WStatus)) {
                printf("++ ERROR - IGNORED for %ws; Directories and Alternate Data Streams!\n",DestFile);
            }
            //
            // Uknown stream header or couldn't apply object id
            //
            if (WStatus == ERROR_INVALID_DATA ||
                WStatus == ERROR_DUP_NAME     ||
                (IsDir && WIN_ALREADY_EXISTS(WStatus))) {
                //
                // Seek to the next stream. Stop if there are none.
                //
                BackupSeek(DstHandle, -1, -1, &Low, &High, &RestoreContext);
                if (Low == 0 && High == 0) {
                    break;
                }
            } else {
                //
                // Unknown error; abort
                //
                goto CLEANUP;
            }
        }
    } while (TRUE);

    //
    // Set times
    //
    if (!FrsSetFileTime(DestFile,
                        DstHandle,
                        (PFILETIME)&Header->Attributes.CreationTime.QuadPart,
                        (PFILETIME)&Header->Attributes.LastAccessTime.QuadPart,
                        (PFILETIME)&Header->Attributes.LastWriteTime.QuadPart)) {
        goto CLEANUP;
    }



    //
    // Set final attributes (which could make the file Read Only)
    // Clear the offline attrbute flag since we just wrote the file.
    //
    ClearFlag(Header->Attributes.FileAttributes, FILE_ATTRIBUTE_OFFLINE);
    if (!FrsSetFileAttributes(DestFile,
                              DstHandle,
                              Header->Attributes.FileAttributes)) {
        goto CLEANUP;
    }

    //
    // Make sure all of the data is on disk. We don't want to lose
    // it across reboots
    //
    if (!FlushFileBuffers(DstHandle)) {
        goto CLEANUP;
    }


    //
    // Return success
    //
    WStatus = ERROR_SUCCESS;

CLEANUP:
    //
    // Release resources in optimal order
    //
    // Leave the file lying around for a retry operation. We don't want
    // to assign a new fid by deleting and recreating the file -- that
    // would confuse the IDTable.
    //
    //
    // Free up the restore context before we close TmpHandle (just in case)
    //
    if (RestoreContext) {
        BackupWrite(DstHandle, NULL, 0, NULL, TRUE, TRUE, &RestoreContext);
    }
    //
    // Close the Dst handle
    //
    if (HANDLE_IS_VALID(DstHandle)) {
        //
        // Truncate a partial install
        //
        if (!WIN_SUCCESS(WStatus)) {
            if (!IsDir) {
                SizeHigh = 0;
                SizeLow = 0;
                SizeLow = SetFilePointer(DstHandle, SizeLow, &SizeHigh, FILE_BEGIN);

                if (SizeLow == 0xFFFFFFFF && GetLastError() != NO_ERROR) {
                } else if (!SetEndOfFile(DstHandle)) {
                }
            }
        }
        FRS_CLOSE(DstHandle);
    }

    FRS_CLOSE(StageHandle);

    //
    // Free the buffers in descending order by size
    //
    FrsFree(RestoreBuf);
    FrsFree(StagePath);

    //
    // DONE
    //
    return WStatus;
}


DWORD
FrsCompressFile(
    PWCHAR SrcFile,
    PWCHAR DestFile
    )
/*++
Routine Description:
    Compresses the file.

Arguments:
    SrcFile  - Source file.
    DestFile - Destination file.

Return Value:
    WStatus.
--*/
{
    DWORD   WStatus = ERROR_SUCCESS;

    WStatus = StuNewGenerateStage(SrcFile, DestFile);

    if (!WIN_SUCCESS(WStatus)) {
        return WStatus;
    }

    return WStatus;
}


DWORD
FrsDeCompressFile(
    PWCHAR SrcFile,
    PWCHAR DestFile
    )
/*++
Routine Description:
    DeCompresses the file.

Arguments:
    SrcFile  - Source file.
    DestFile - Destination file.

Return Value:
    WStatus.
--*/
{
    DWORD   WStatus = ERROR_SUCCESS;

    WStatus = StuNewExecuteInstall(SrcFile, DestFile);

    if (!WIN_SUCCESS(WStatus)) {
        return WStatus;
    }

    return WStatus;
}


VOID
Usage(
    PWCHAR *Argv
    )
/*++
Routine Description:
    Usage messages.

Arguments:
    None.

Return Value:
    None.
--*/
{
    printf("This tool is used to the compress and decompress files.\n\n");
    printf(" /?                            : This help screen is displayed.\n");
    printf(" /c SourceFile DestinationFile : Compress Source File and write to Destination File.\n");
    printf(" /d SourceFile DestinationFile : DeCompress Source File and write to Destination File.\n");
    fflush(stdout);
}


int
__cdecl main (int argc, char *argv[])
{
    PWCHAR            *Argv             = NULL;
    WCHAR             SrcFile[MAX_PATH];
    WCHAR             DestFile[MAX_PATH];
    DWORD             OptLen            = 0;
    BOOL              bCompress         = FALSE;
    BOOL              bDeCompress       = FALSE;
    int               i;
    DWORD             WStatus           = ERROR_SUCCESS;

    if (argc < 2 ) {
        Usage(Argv);
        return 0;
    }

    Argv = MainConvertArgV(argc,argv);
    for (i = 1; i < argc; ++i) {
        OptLen = wcslen(Argv[i]);
        if (OptLen == 2 &&
            ((wcsstr(Argv[i], L"/?") == Argv[i]) ||
             (wcsstr(Argv[i], L"-?") == Argv[i]))) {
            Usage(Argv);
            return 0;
        } else if (OptLen == 2 &&
                ((wcsstr(Argv[i], L"/c") == Argv[i]) ||
                 (wcsstr(Argv[i], L"-c") == Argv[i]))) {
            if (i + 2 >= argc) {
                Usage(Argv);
                return 0;
            }
            bCompress = TRUE;
            wcscpy(SrcFile, Argv[i+1]);
            wcscpy(DestFile, Argv[i+2]);
            i+=2;
        } else if (OptLen == 2 &&
                ((wcsstr(Argv[i], L"/d") == Argv[i]) ||
                 (wcsstr(Argv[i], L"-d") == Argv[i]))) {
            if (i + 2 >= argc) {
                Usage(Argv);
                return 0;
            }
            bDeCompress = TRUE;
            wcscpy(SrcFile, Argv[i+1]);
            wcscpy(DestFile, Argv[i+2]);
            i+=2;
        } else {
            Usage(Argv);
            return 0;
        }
    }

    DebugInfo.Disabled = TRUE;

    if ((bCompress & bDeCompress) || (!bCompress & !bDeCompress)) {
        Usage(Argv);
        return 0;
    }

    if (bCompress) {
        WStatus = FrsCompressFile(SrcFile, DestFile);
        if (WStatus != ERROR_SUCCESS) {
            printf("Error compressing file %ws. WStatus = %d\n",SrcFile, WStatus);
            return 1;
        }
    } else if (bDeCompress) {
        WStatus = FrsDeCompressFile(SrcFile, DestFile);
        if (WStatus != ERROR_SUCCESS) {
            printf("Error decompressing file %ws. WStatus = %d\n",SrcFile, WStatus);
            return 1;
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\test\frsexts\frsexts.h ===
/*++

    Copyright (c) 1997 Microsoft Corporation

    Module Name:

        frsexts.h

    Abstract:

        Macros for ntfrs debugger extension.

    Author:

        Sudarshan Chitre (sudarc)

    Revision History:

        Sudarc  12-May 1999

--*/

#ifndef _FRSEXTS_H_
#define _FRSEXTS_H_

#include <ntreppch.h>
#include <frs.h>
#include <wdbgexts.h>
#include <ntverp.h>

#define MY_DECLARE_API(_x_) \
    DECLARE_API( _x_ )\
    {\
    ULONG_PTR dwAddr;\
    INIT_DPRINTF();\
    dwAddr = GetExpression(lpArgumentString);\
    if ( !dwAddr ) {\
        dprintf("Error: Failure to get address\n");\
        return;\
    }\
    do_##_x_(dwAddr);\
    return;}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\test\frsexts\frsexts.cxx ===
/*++

Module Name:

    frsexts.cxx

Abstract:



Author:

    Sudarshan Chitre (sudarc)  12-May-1999

Revision History:

     12-May-1999     sudarc


--*/
#include "frsexts.h"
WINDBG_EXTENSION_APIS ExtensionApis;
HANDLE ProcessHandle = 0;
BOOL fKD = 0;

#define MAX_ARGS 4


//
// stuff not common to kernel-mode and user-mode DLLs
//
#undef DECLARE_API

#define DECLARE_API(s)                              \
        VOID                                        \
        s(                                          \
            HANDLE               hCurrentProcess,   \
            HANDLE               hCurrentThread,    \
            DWORD                dwCurrentPc,       \
            PWINDBG_EXTENSION_APIS pExtensionApis,  \
            LPSTR                lpArgumentString   \
            )

#define INIT_DPRINTF()    { if (!fKD) ExtensionApis = *pExtensionApis; ProcessHandle = hCurrentProcess; }
#define MIN(x, y) ((x) < (y)) ? x:y

// define our own operators new and delete, so that we do not have to include the crt

void * __cdecl
::operator new(size_t dwBytes)
{
    void *p;
    p = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwBytes);
    return (p);
}


void __cdecl
::operator delete (void *p)
{
    HeapFree(GetProcessHeap(), 0, p);
}

BOOL
GetData(IN ULONG_PTR dwAddress,  IN LPVOID ptr, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count;

    if (fKD == 0)
        {
        return ReadProcessMemory(ProcessHandle, (LPVOID) dwAddress, ptr, size, 0);
        }

    while( size > 0 )
        {
        count = MIN( size, 3000 );

        b = ReadMemory((ULONG) dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count )
            {
            if (NULL == type)
                {
                type = "unspecified" ;
                }
            return FALSE;
            }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG_PTR)ptr + count);
        }

    return TRUE;
}

char *Days[] =
{
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
};

char *Months[] =
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};

VOID
FileTimeToString(
    FILETIME *FileTime,
    PCHAR     Buffer
    )
/*++

Routine Description:

    Convert a FileTime (UTC time) to an ANSI date/time string in the
    local time zone.

Arguments:

    Time - ptr to a FILETIME
    Str  - a string of at least TIME_STRING_LENGTH bytes to receive the time.

Return Value:

    None

--*/
{

    FILETIME LocalFileTime;
    SYSTEMTIME SystemTime;

    Buffer[0] = '\0';
    strcpy(Buffer, "Time???");
    if (FileTime->dwHighDateTime != 0 || FileTime->dwLowDateTime != 0)
    {
        if (!FileTimeToLocalFileTime(FileTime, &LocalFileTime) ||
            !FileTimeToSystemTime(&LocalFileTime, &SystemTime))
        {
            return;
        }
        sprintf(
            Buffer,
            "%s %s %2d, %4d %02d:%02d:%02d",
            Days[SystemTime.wDayOfWeek],
            Months[SystemTime.wMonth - 1],
            SystemTime.wDay,
            SystemTime.wYear,
            SystemTime.wHour,
            SystemTime.wMinute,
            SystemTime.wSecond);
    }
    return;
}

#define DMPGUID(_TEXT_,_Guid_)            \
        {                                  \
            dprintf((_TEXT_));             \
            dprintf("%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\n",   \
                   (_Guid_).Data1,                          \
                   (_Guid_).Data2,                          \
                   (_Guid_).Data3,                          \
                   (_Guid_).Data4[0],                       \
                   (_Guid_).Data4[1],                       \
                   (_Guid_).Data4[2],                       \
                   (_Guid_).Data4[3],                       \
                   (_Guid_).Data4[4],                       \
                   (_Guid_).Data4[5],                       \
                   (_Guid_).Data4[6],                       \
                   (_Guid_).Data4[7]);                      \
        }

#define DMPPGUID(_TEXT_,_pGuid_)            \
        {                                  \
            BOOL bDmpGuid;                 \
            BYTE bufDmpGuid[sizeof(GUID)]; \
            dprintf((_TEXT_));             \
            bDmpGuid = GetData((ULONG)(_pGuid_), &bufDmpGuid, sizeof(bufDmpGuid), NULL);\
            if ( !bDmpGuid ) {                                                 \
                dprintf("<Error reading memory>\n");                             \
            } else {                                                           \
                dprintf("%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\n",   \
                       ((GUID *)(bufDmpGuid))->Data1,                          \
                       ((GUID *)(bufDmpGuid))->Data2,                          \
                       ((GUID *)(bufDmpGuid))->Data3,                          \
                       ((GUID *)(bufDmpGuid))->Data4[0],                       \
                       ((GUID *)(bufDmpGuid))->Data4[1],                       \
                       ((GUID *)(bufDmpGuid))->Data4[2],                       \
                       ((GUID *)(bufDmpGuid))->Data4[3],                       \
                       ((GUID *)(bufDmpGuid))->Data4[4],                       \
                       ((GUID *)(bufDmpGuid))->Data4[5],                       \
                       ((GUID *)(bufDmpGuid))->Data4[6],                       \
                       ((GUID *)(bufDmpGuid))->Data4[7]);                      \
                                                                               \
            }                                                                  \
        }

#define DMPGNAME(_TEXT_,_pGname_)               \
        {                                       \
            BOOL     bDmpGname;                 \
            BYTE     bufDmpGname[sizeof(GNAME)];\
            BYTE     DmpName[MAX_PATH * 2];         \
            UINT     count = 0;                 \
            bDmpGname = GetData((ULONG)(_pGname_), &bufDmpGname, sizeof(bufDmpGname), NULL);\
            if ( !bDmpGname ) {                                                             \
                dprintf((_TEXT_));                                                          \
                dprintf("<Error reading memory>\n");                                        \
            } else {                                                                        \
                DMPPGUID((_TEXT_),((GNAME *)bufDmpGname)->Guid);                             \
                dprintf((_TEXT_));                                                          \
                if (((GNAME *)bufDmpGname)->Name == NULL) {                                 \
                    dprintf("<null>\n");                                                    \
                } else {                                                                    \
                    while (count < MAX_PATH * 2 && bDmpGname) {                             \
                        bDmpGname = GetData((ULONG)(((GNAME *)bufDmpGname)->Name) + count, &DmpName[count], sizeof(BYTE), NULL);\
                        count++;                                                            \
                    }                                                                       \
                                                                                            \
                    dprintf("%ws\n",(WCHAR *)DmpName);                                      \
                }                                                                           \
            }                                                                               \
        }

#define DMPQUAD(_TEXT_,_Fid_)                                               \
        {                                                                   \
            dprintf((_TEXT_));                                              \
            dprintf("%08x %08x\n",(ULONG)((_Fid_)>>32) ,(ULONG)(_Fid_));    \
        }

#define DMPTIME(_TEXT_,_Time_)                                              \
        {                                                                   \
            CHAR TimeStr[TIME_STRING_LENGTH];                               \
            FileTimeToString((FILETIME *)&(_Time_),TimeStr);                \
            dprintf((_TEXT_));                                              \
            dprintf("%s\n",TimeStr);                                        \
        }

#define DMPSTRW(_TEXT_,_pStr_)                                              \
        {                                                                   \
            UINT count = 0;                                                 \
            BOOL bDmpStrW = TRUE;                                           \
            BYTE DmpStr[MAX_PATH * 2];                                      \
            while (count < MAX_PATH * 2 && bDmpStrW) {                      \
                bDmpStrW = GetData((ULONG)(_pStr_) + count, &DmpStr[count], sizeof(BYTE), NULL);\
                count++;                                                    \
            }                                                               \
            dprintf((_TEXT_));                                              \
            dprintf("%ws\n",(WCHAR *)DmpStr);                               \
        }
//
// Common print functions for all the data structures.
//

VOID
do_coe(
    PCHANGE_ORDER_ENTRY ChangeOrder
    )
/*
typedef struct _CHANGE_ORDER_ENTRY_ {
    GENERIC_HASH_ENTRY_HEADER  HashEntryHeader;   // Change Order hash Table support

    UNICODE_STRING   UFileName;           // Used in renames to make file name bigger
    ULONG            EntryFlags;          // misc state flags. See below.
    ULONG            CoMorphGenCount;     // for debugging.
    //
    // Change order process list management.
    //
    LIST_ENTRY        ProcessList;        // Link on the change order process list.
    ULONG             TimeToRun;          // Time to process the change order.
    ULONG             EntryCreateTime;    // Tick Count at entry create time.
    SINGLE_LIST_ENTRY DupCoList;          // Duplicate change order list.
    //
    //
    ULONG     DirNestingLevel;            // Number levels file is down in tree.
    ULONGLONG FileReferenceNumber;        // File's FID
    ULONGLONG ParentFileReferenceNumber;  // File's parent FID

    ULONGLONG OriginalParentFid;          // For rename processing
    ULONGLONG NewParentFid;               // For rename processing
    ULONGLONG NameConflictHashValue;      // Key value for NameConflict table cleanup.

    ULONG     StreamLastMergeSeqNum;      // Stream seq num of last Usn record merged with this CO.
    PREPLICA_THREAD_CTX  RtCtx;           // For DB access during CO processing.
    GUID                *pParentGuid;     // ptr to the File's parent Guid in CoCmd.
    //
    // The joinguid is a cxtion's session id and, in this case,
    // is used to retry change orders that were accepted by
    // the change order accept thread for a cxtion that has since
    // unjoined from its partner. The change orders for previous
    // sessions are retried because they are out-of-order wrt the
    // change orders for the current session id. In other words,
    // order is maintained per session by coordinating the partners
    // at join time.
    GUID                JoinGuid;         // Cxtion's session id
                                          // undefined if local co

    //
    // Remote and control change orders are associated with a cxtion.
    // If this field is non-null, then the field
    // ChangeOrderCount has been incremente for this change
    // order. The count should be decremented when the
    // change order is freed in ChgOrdIssueCleanup().
    //
    PCXTION             Cxtion;           // NULL if local co
    //
    // Issue cleanup flags -- As a change order is processed it acquires
    // various resources that must be released when it retires or goes thru
    // retry.  The ISCU flag bits below are used to set these bits.  Note:
    // Not all bits may be set here.  Some may get set just before the CO goes
    // thru cleanup.
    //
    ULONG               IssueCleanup;

    //
    // Needed to dampen basic info changes (e.g., resetting the archive bit)
    // Copied from the idtable entry when the change order is created and
    // used to update the change order when the change order is retired.
    //
    ULONG           FileAttributes;
    LARGE_INTEGER   FileCreateTime;
    LARGE_INTEGER   FileWriteTime;

    //
    // Change order command parameters.
    // (must be last since it ends with FileName)
    //
    CHANGE_ORDER_COMMAND Cmd;

} CHANGE_ORDER_ENTRY, *PCHANGE_ORDER_ENTRY;

*/
{
    PWCHAR           FileName    = NULL;

    dprintf("Dumping  CHANGE_ORDER_ENTRY.\n\n");
    dprintf("HashEntryHeader           : Address( 0x%x )\n",ChangeOrder->HashEntryHeader);

    dprintf("FileNameLength            : %d\n",ChangeOrder->UFileName.Length);

    FileName = new WCHAR((ChangeOrder->UFileName.Length)/2 + 1);

    GetData((ULONG)(ChangeOrder->UFileName.Buffer),(BYTE*)FileName,ChangeOrder->UFileName.Length,NULL);
    FileName[(ChangeOrder->UFileName.Length)/2] = L'\0';

    dprintf("FileName                  : Address( 0x%x )\n",ChangeOrder->UFileName.Buffer);
    dprintf("FileName                  : %ws\n",FileName);
    delete FileName;
    dprintf("EntryFlags                : 0x%x\n",ChangeOrder->EntryFlags);
    dprintf("CoMorphGenCount           : %d\n",ChangeOrder->CoMorphGenCount);
    dprintf("ProcessList               : Address( 0x%x )\n",ChangeOrder->ProcessList);
    dprintf("TimeToRun                 : %d\n",ChangeOrder->TimeToRun);
    dprintf("EntryCreateTime           : %d\n",ChangeOrder->EntryCreateTime);
    dprintf("DupCoList                 : Address( 0x%x )\n",ChangeOrder->DupCoList);
    dprintf("DirNestingLevel           : %d\n",ChangeOrder->DirNestingLevel);
    DMPQUAD("FileReferenceNumber       : ",ChangeOrder->FileReferenceNumber);
    DMPQUAD("ParentFileReferenceNumber : ",ChangeOrder->ParentFileReferenceNumber);
    DMPQUAD("OriginalParentFid         : ",ChangeOrder->OriginalParentFid);
    DMPQUAD("NewParentFid              : ",ChangeOrder->NewParentFid);
    DMPQUAD("NameConflictHashValue     : ",ChangeOrder->NameConflictHashValue);
    dprintf("StreamLastMergeSeqNum     : %d\n",ChangeOrder->StreamLastMergeSeqNum);
    dprintf("RtCtx                     : Address( 0x%x )\n",ChangeOrder->RtCtx);
    DMPPGUID("pParentGuid               : ",ChangeOrder->pParentGuid);
    DMPGUID("JoinGuid                  : ",ChangeOrder->JoinGuid);
    dprintf("Cxtion                    : Address( 0x%x )\n",ChangeOrder->Cxtion);
    dprintf("IssueCleanup              : 0x%x\n",ChangeOrder->IssueCleanup);
    dprintf("FileAttributes            : 0x%x\n",ChangeOrder->FileAttributes);
    DMPTIME("FileCreateTime            : ",ChangeOrder->FileCreateTime);
    DMPTIME("FileWriteTime             : ",ChangeOrder->FileWriteTime);
    dprintf("Cmd                       : Address( 0x%x )\n",ChangeOrder->Cmd);
}

VOID
do_coc(
    PCHANGE_ORDER_COMMAND Cmd
    )
/*
typedef struct _CHANGE_ORDER_RECORD_ {
    ULONG     SequenceNumber;        // Unique sequence number for change order.
    ULONG     Flags;                 // Change order flags
    ULONG     IFlags;                // These flags can ONLY be updated with interlocked exchange.
    ULONG     State;                 // State is sep DWORD to avoid locking.
    ULONG     ContentCmd;            // File content changes from UsnReason

    union {
        ULONG           LocationCmd;
        CO_LOCATION_CMD Field;       // File Location command
    } Lcmd;

    ULONG     FileAttributes;
    ULONG     FileVersionNumber;     // The file version number, inc on each close.
    ULONG     PartnerAckSeqNumber;   // Save seq number for Partner Ack.

    ULONGLONG FileSize;
    ULONGLONG FileOffset;            // The current committed progress for staging file.
    ULONGLONG FrsVsn;                // Originator Volume sequence number
    bugbug("perf: FileUsn and JrnlUsn can probably be combined")
    USN       FileUsn;               // The USN of the file must match on the Fetch request.
    USN       JrnlUsn;               // USN of last journal record contributing to this CO.
    USN       JrnlFirstUsn;          // USN of first journal record contributing to this CO.

    struct _REPLICA *OriginalReplica; // Contains Replica ID when in DB
    struct _REPLICA *NewReplica;      // Contains Replica ID when in DB

    GUID      ChangeOrderGuid;       // Guid that identifies the change order everywhere.
    GUID      OriginatorGuid;        // The GUID of the originating member
    GUID      FileGuid;              // The obj ID of the file
    GUID      OldParentGuid;         // The Obj ID of the file's original parent directory
    GUID      NewParentGuid;         // The Obj ID of the file's current parent directory
    GUID      CxtionGuid;            // The obj ID of remote CO connection.

    ULONGLONG Spare1Ull;
    ULONGLONG Spare2Ull;
    GUID      Spare1Guid;
    GUID      Spare2Guid;
    PWCHAR    Spare1Wcs;
    PWCHAR    Spare2Wcs;
    PVOID     Spare1Bin;
    PVOID     Spare2Bin;

    LARGE_INTEGER EventTime;         // The USN Journal Entry Timestamp.
    USHORT    FileNameLength;
    WCHAR     FileName[MAX_PATH+1];  // The file name. (Must be Last)

} CHANGE_ORDER_COMMAND, *PCHANGE_ORDER_COMMAND,
*/
{
    PWCHAR           FileName    = NULL;

    dprintf("Dumping  CHANGE_ORDER_COMMAND.\n\n");
    dprintf("SequenceNumber            : %d\n",Cmd->SequenceNumber);
    dprintf("Flags                     : 0x%x\n",Cmd->Flags);
    dprintf("IFlags                    : 0x%x\n",Cmd->IFlags);
    dprintf("State                     : %d\n",Cmd->State);
    dprintf("ContentCmd                : 0x%x\n",Cmd->ContentCmd);
    dprintf("LocationCmd               : 0x%x\n",Cmd->Lcmd.LocationCmd);
    dprintf("FileAttributes            : 0x%x\n",Cmd->FileAttributes);
    dprintf("FileVersionNumber         : %d\n",Cmd->FileVersionNumber);
    dprintf("PartnerAckSeqNumber       : %d\n",Cmd->PartnerAckSeqNumber);
    DMPQUAD("FileSize                  : ",Cmd->FileSize);
    DMPQUAD("FileOffset                : ",Cmd->FileOffset);
    DMPQUAD("FrsVsn                    : ",Cmd->FrsVsn);
    DMPQUAD("FileUsn                   : ",Cmd->FileUsn);
    DMPQUAD("JrnlUsn                   : ",Cmd->JrnlUsn);
    DMPQUAD("JrnlFirstUsn              : ",Cmd->JrnlFirstUsn);
    dprintf("OriginalReplicaNum        : %d\n",Cmd->OriginalReplicaNum);
    dprintf("NewReplicaNum             : %d\n",Cmd->NewReplicaNum);
    DMPGUID("ChangeOrderGuid           : ",Cmd->ChangeOrderGuid);
    DMPGUID("OriginatorGuid            : ",Cmd->OriginatorGuid);
    DMPGUID("FileGuid                  : ",Cmd->FileGuid);
    DMPGUID("OldParentGuid             : ",Cmd->OldParentGuid);
    DMPGUID("NewParentGuid             : ",Cmd->NewParentGuid);
    DMPGUID("CxtionGuid                : ",Cmd->CxtionGuid);
    DMPTIME("EventTime                 : ",Cmd->EventTime);
    dprintf("FileNameLength            : %d\n",Cmd->FileNameLength);
    dprintf("FileName                  : %ws\n",Cmd->FileName);
}

VOID
do_cxt(
    PCXTION pCxtion
    )
/*
typedef struct _CXTION  CXTION, *PCXTION;
struct _CXTION {
    FRS_NODE_HEADER Header;     // memory management
    ULONG           State;      // Incore state
    ULONG           Flags;      // misc flags
    BOOL            Inbound;    // TRUE if inbound cxtion        *
    BOOL            JrnlCxtion; // TRUE if this Cxtion struct is for the local NTFS Journal
    PGNAME          Name;       // Cxtion name/guid from the DS  *
    PGNAME          Partner;    // Partner's name/guid from the DS    *
    PWCHAR          PartnerDnsName;     // partner's DNS name from the DS *
    PWCHAR          PartnerPrincName;   // partner's server principle name *
    PWCHAR          PartnerSid;         // partner's sid (string) *
    PWCHAR          PartSrvName;        // Partner's server name
    ULONG           PartnerAuthLevel;   // Authentication level  *
    PGEN_TABLE      VVector;            // partner's version vector
    PSCHEDULE       Schedule;           // schedule                      *
    ULONG           TerminationCoSeqNum;// The Seq Num of most recent Termination CO inserted.
    PCOMMAND_SERVER VvJoinCs;           // command server for vvjoins
    struct _COMMAND_PACKET  *JoinCmd;   // check join status; rejoin if needed
                                        // NULL == no delayed cmd outstanding
    ULONGLONG       LastJoinTime;       // The time of the last successful join on this cxtion.
    GUID            JoinGuid;           // Unique id for this join
    GUID            ReplicaVersionGuid; // partner's originator guid
    DWORD           CommQueueIndex;     // Comm layer queue for sending pkts
    DWORD           ChangeOrderCount;   // remote/control change orders pending
    PGEN_TABLE      CoeTable;           // table of idle change orders
    struct _COMMAND_PACKET *CommTimeoutCmd; // Timeout (waitable timer) packet
    DWORD           UnjoinTrigger;      // DBG force unjoin in # remote cos
    DWORD           UnjoinReset;        // reset force unjoin trigger
    PFRS_QUEUE      CoProcessQueue;     // If non-null then Unidle the queue when
                                        // JOIN succeeds or fails.
    ULONG           CommPkts;           // Number of comm pkts
    ULONG           Penalty;            // Penalty in Milliseconds
    PCOMM_PACKET    ActiveJoinCommPkt;  // Don't flood Q w/many join pkts
    ULONG           PartnerMajor;       // From comm packet
    ULONG           PartnerMinor;       // From comm packet
    struct _OUT_LOG_PARTNER_ *OLCtx;    // Outbound Log Context for this connection.

    struct _HASHTABLEDATA_REPLICACONN *PerfRepConnData; // PERFMON counter data structure
};
*/
{
    dprintf("Dumping  CXTION.\n\n");
    dprintf("Header                    : Address ( 0x%x )\n",pCxtion->Header);
    dprintf("State                     : %d\n",pCxtion->State);
    dprintf("Flags                     : 0x%x\n",pCxtion->Flags);
    dprintf("Inbound                   : %d\n",pCxtion->Inbound);
    dprintf("JrnlCxtion                : %d\n",pCxtion->JrnlCxtion);
    DMPGNAME("Name                      : ",pCxtion->Name);
    DMPGNAME("Partner                   : ",pCxtion->Partner);
    dprintf("PartnerDnsName            : %ws\n",pCxtion->PartnerDnsName);
    dprintf("PartnerPrincName          : %ws\n",pCxtion->PartnerPrincName);
    dprintf("PartnerSid                : %ws\n",pCxtion->PartnerSid);
    dprintf("PartSrvName               : %ws\n",pCxtion->PartSrvName);
    dprintf("PartnerAuthLevel          : %d\n",pCxtion->PartnerAuthLevel);
    dprintf("VVector                   : Address ( 0x%x )\n",pCxtion->VVector);
    dprintf("Schedule                  : Address ( 0x%x )\n",pCxtion->Schedule);
    dprintf("TerminationCoSeqNum       : %d\n",pCxtion->TerminationCoSeqNum);
    dprintf("VvJoinCs                  : Address ( 0x%x )\n",pCxtion->VvJoinCs);
    dprintf("JoinCmd                   : Address ( 0x%x )\n",pCxtion->JoinCmd);
    DMPTIME("LastJoinTime              : ",pCxtion->LastJoinTime);
    DMPGUID("JoinGuid                  : ",pCxtion->JoinGuid);
    DMPGUID("ReplicaVersionGuid        : ",pCxtion->ReplicaVersionGuid);
    dprintf("CommQueueIndex            : %d\n",pCxtion->CommQueueIndex);
    dprintf("ChangeOrderCount          : %d\n",pCxtion->ChangeOrderCount);
    dprintf("CoeTable                  : Address ( 0x%x )\n",pCxtion->CoeTable);
    dprintf("CommTimeoutCmd            : Address ( 0x%x )\n",pCxtion->CommTimeoutCmd);
    dprintf("UnjoinTrigger             : %d\n",pCxtion->UnjoinTrigger);
    dprintf("UnjoinReset               : %d\n",pCxtion->UnjoinReset);
    dprintf("CoProcessQueue            : Address ( 0x%x )\n",pCxtion->CoProcessQueue);
    dprintf("CommPkts                  : %d\n",pCxtion->CommPkts);
    dprintf("Penalty                   : %d\n",pCxtion->Penalty);
    dprintf("ActiveJoinCommPkt         : Address ( 0x%x )\n",pCxtion->ActiveJoinCommPkt);
    dprintf("PartnerMajor              : %d\n",pCxtion->PartnerMajor);
    dprintf("PartnerMinor              : %d\n",pCxtion->PartnerMinor);
    dprintf("OLCtx                     : Address ( 0x%x )\n",pCxtion->OLCtx);
    dprintf("PerfRepConnData           : Address ( 0x%x )\n",pCxtion->PerfRepConnData);
}

VOID
do_olp(
    POUT_LOG_PARTNER pOlp
    )
/*
typedef struct _OUT_LOG_PARTNER_ {
    FRS_NODE_HEADER  Header;    // Memory alloc
    LIST_ENTRY List;            // Link on the change order set list. (DONT MOVE)

    ULONG    Flags;             // misc state flags.  see below.
    ULONG    State;             // Current state of this outbound partner.
    SINGLE_LIST_ENTRY SaveList; // The link for the DB save list.
    ULONG    COLxRestart;       // Restart point for Leading change order index.
    ULONG    COLxVVJoinDone;    // COLx where VVJoin Finished and was rolled back.
    ULONG    COLx;              // Leading change order index / sequence number.
    ULONG    COTx;              // Trailing change order index / sequence number.
    ULONG    COTxLastSaved;     // COTx value last saved in DB.
    ULONG    COTxNormalModeSave;// Saved Normal Mode COTx while in VV Join Mode.
    ULONG    COTslot;           // Slot in Ack Vector corresponding to COTx.
    ULONG    OutstandingCos;    // The current number of change orders outstanding.
    ULONG    OutstandingQuota;  // The maximum number of COs outstanding.

    ULONG    AckVector[ACK_VECTOR_LONGS];  // The partner ack vector.

    PCXTION  Cxtion;            // The partner connection.  Has Guid and VVector.

} OUT_LOG_PARTNER, *POUT_LOG_PARTNER;
*/
{
    dprintf("Dumping OUT_LOG_PARTNER.\n\n");
    dprintf("Header                    : Address ( 0x%x )\n",pOlp->Header);
    dprintf("List                      : Address ( 0x%x )\n",pOlp->List);
    dprintf("Flags                     : 0x%x\n",pOlp->Flags);
    dprintf("State                     : %d\n",pOlp->State);
    dprintf("SaveList                  : Address ( 0x%x )\n",pOlp->SaveList);
    dprintf("COLxRestart               : %d\n",pOlp->COLxRestart);
    dprintf("COLxVVJoinDone            : %d\n",pOlp->COLxVVJoinDone);
    dprintf("COLx                      : %d\n",pOlp->COLx);
    dprintf("COTx                      : %d\n",pOlp->COTx);
    dprintf("COTxLastSaved             : %d\n",pOlp->COTxLastSaved);
    dprintf("COTxNormalModeSave        : %d\n",pOlp->COTxNormalModeSave);
    dprintf("COTslot                   : %d\n",pOlp->COTslot);
    dprintf("OutstandingCos            : %d\n",pOlp->OutstandingCos);
    dprintf("OutstandingQuota          : %d\n",pOlp->OutstandingQuota);
}

VOID
do_rep(
    PREPLICA pReplica
    )
/*
typedef struct _REPLICA {
    FRS_NODE_HEADER     Header;           // memory management
    CRITICAL_SECTION    ReplicaLock;      // protects filter list (for now)
    ULONG               ReferenceCount;
    ULONG               CnfFlags;         // From the config record
    ULONG               ReplicaSetType;   // Type of replica set
    BOOL                Consistent;       // replica is consistent
    BOOL                IsOpen;           // database table is open
    BOOL                IsJournaling;     // journal has been started
    BOOL                IsAccepting;      // accepting comm requests
    BOOL                NeedsUpdate;      // needs updating in the database
    BOOL                IsSeeding;        // Seeding thread is deployed
    BOOL                IsSysvolReady;    // SysvolReady is set to 1
    LIST_ENTRY          ReplicaList;      // Link all replicas together
    ULONG               ServiceState;     // stop, started, ...
    FRS_ERROR_CODE      FStatus;          // error
    PFRS_QUEUE          Queue;            // controlled by the command server
    PGNAME              ReplicaName;      // Set name/Server guid from the DS
    ULONG               ReplicaNumber;    // Internal id (name)
    PGNAME              MemberName;       // Member name/guid from the DS
    PGNAME              SetName;          // Set/guid name from the DS
    GUID                *ReplicaRootGuid; // guid assigned to Root dir
    GUID                ReplicaVersionGuid; // originator guid for version vector
    PSCHEDULE           Schedule;         // schedule
    PGEN_TABLE          VVector;          // Version vector
    PGEN_TABLE          Cxtions;          // in/outbound cxtions
    PWCHAR              Root;             // Root path
    PWCHAR              Stage;            // Staging path
    PWCHAR              NewStage;         // This maps to the current staging path in the
                                          // DS. NewStage will be the one written to
                                          // the config record but Stage will be used until
                                          // next reboot.
    PWCHAR              Volume;           // Volume??? bugbug
    ULONGLONG           MembershipExpires;// membership tombstone
    ULONGLONG           PreInstallFid;    // For journal filtering.
    TABLE_CTX           ConfigTable;      // Db table context
    FRS_LIST            ReplicaCtxListHead; // Links all open contexts on this replica set.
    PWCHAR              FileFilterList;     // Raw file filter
    PWCHAR              DirFilterList;      // Raw directory filter
    LIST_ENTRY          FileNameFilterHead; // Head of file name filter list.
    LIST_ENTRY          DirNameFilterHead;  // Head of directory name filter list.
    PQHASH_TABLE        NameConflictTable;  // Sequence COs using the same file name.

    LONG                InLogRetryCount;  // Count of number CO needing a Retry.
    ULONG               InLogSeqNumber;   // The last sequence number used in Inlog
    //
    //
    // The inlog retry table tracks which retry change orders are currently
    // active so we don't reissue the same change order until current
    // invocation completes.  This can happen when the system gets backed up
    // and the change order retry thread kicks off again to issue retry COs
    // before the last batch are able to finish.  This state could be kept in
    // the Inlog record but then it means extra writes to the DB.
    // The sequence number is used to detect changes in the table when we don't
    // have the lock.  It is per-replica because it uses the change order
    // sequence number of the inlog record and they aren't unique across
    // replicas.
    //
    PQHASH_TABLE        ActiveInlogRetryTable;
    union {
        struct {
            ULONG       AIRSequenceNum;
            ULONG       AIRSequenceNumSample;
        };
        ULONGLONG QuadChunkA;
    };

    //
    // Status of sysvol seeding.
    // Returned for NtFrsApi_Rpc_PromotionStatusW().
    //
    DWORD               NtFrsApi_ServiceState;
    DWORD               NtFrsApi_ServiceWStatus;
#ifndef NOVVJOINHACK
    DWORD               NtFrsApi_HackCount;         // temporary hack
#endif NOVVJOINHACK
    PWCHAR              NtFrsApi_ServiceDisplay;

    //
    // The Outbound log process state for this replica.
    //
    CRITICAL_SECTION    OutLogLock;       // protects the OutLog state
    LIST_ENTRY          OutLogEligible;   // Eligible outbound log partners
    LIST_ENTRY          OutLogStandBy;    // Partners ready to join eligible list
    LIST_ENTRY          OutLogActive;     // Active outbound log partners
    LIST_ENTRY          OutLogInActive;   // Inactive outbound log partners

    PQHASH_TABLE        OutLogRecordLock; // Sync access to outlog records.
    ULONG               OutLogSeqNumber;  // The last sequence number used in Outlog
    ULONG               OutLogJLx;        // The Joint Leading Index
    ULONG               OutLogJTx;        // The Joint Trailing Index
    ULONG               OutLogCOMax;      // The index of the Max change order in the log.
    ULONG               OutLogWorkState;  // The output log current processing state.
    struct _COMMAND_PACKET *OutLogCmdPkt; // Cmd pkt to queue when idle and have work.
    PTABLE_CTX          OutLogTableCtx;   // Output Log Table context.
    ULONG               OutLogCountVVJoins; // Count of number of VVJoins in progress.
    BOOL                OutLogDoCleanup;  // True means give log cleanup a run.

    //
    // The handle to the preinstall directory
    //
    HANDLE              PreInstallHandle;

    //
    // The volume journal state for this replica.
    //
    GUID                JrnlCxtionGuid;    // Used as the Cxtion Guid for Local Cos
    USN                 InlogCommitUsn;    // Our current USN Journal commit point.
    //USN                 JournalUsn;      // The Journal USN for this replica.
    USN                 JrnlRecoveryStart; // Point to start recovery.
    USN                 JrnlRecoveryEnd;   // Point where recovery is complete.
    LIST_ENTRY          RecoveryRefreshList; // List of file refresh req change orders.
    LIST_ENTRY          VolReplicaList;    // Links all REPLICA structs on volume together.
    USN                 LastUsnRecordProcessed; // Current Journal subsystem read USN.
    LONG                LocalCoQueueCount; // Count of number local COs in process queue

    struct _VOLUME_MONITOR_ENTRY  *pVme;  // Ref to the VME for this Replica.
    struct _HASHTABLEDATA_REPLICASET *PerfRepSetData;  // PERFMON counter data structure
} REPLICA, *PREPLICA;
*/
{
    dprintf("Dumping REPLICA.\n\n");
    dprintf("Header                    : Address ( 0x%x )\n",pReplica->Header);
    dprintf("ReplicaLock               : Address ( 0x%x )\n",pReplica->ReplicaLock);
    dprintf("ReferenceCount            : %d\n",pReplica->ReferenceCount);
    dprintf("CnfFlags                  : 0x%x\n",pReplica->CnfFlags);
    dprintf("ReplicaSetType            : %d\n",pReplica->ReplicaSetType);
    dprintf("Consistent                : %d\n",pReplica->Consistent);
    dprintf("IsOpen                    : %d\n",pReplica->IsOpen);
    dprintf("IsJournaling              : %d\n",pReplica->IsJournaling);
    dprintf("IsAccepting               : %d\n",pReplica->IsAccepting);
    dprintf("NeedsUpdate               : %d\n",pReplica->NeedsUpdate);
    dprintf("IsSeeding                 : %d\n",pReplica->IsSeeding);
    dprintf("IsSysvolReady             : %d\n",pReplica->IsSysvolReady);
    dprintf("ReplicaList               : Address ( 0x%x )\n",pReplica->ReplicaList);
    dprintf("ServiceState              : %d\n",pReplica->ServiceState);
    dprintf("FStatus                   : %d\n",pReplica->FStatus);
    dprintf("Queue                     : Address ( 0x%x )\n",pReplica->Queue);
    DMPGNAME("ReplicaName               : ",pReplica->ReplicaName);
    dprintf("ReplicaNumber             : %d\n",pReplica->ReplicaNumber);
    DMPGNAME("MemberName                : ",pReplica->MemberName);
    DMPGNAME("SetName                   : ",pReplica->SetName);
    DMPPGUID("ReplicaRootGuid           : ",pReplica->ReplicaRootGuid);
    DMPGUID("ReplicaVersionGuid        : ",pReplica->ReplicaVersionGuid);
    dprintf("Schedule                  : Address ( 0x%x )\n",pReplica->Schedule);
    dprintf("VVector                   : Address ( 0x%x )\n",pReplica->VVector);
    dprintf("Cxtions                   : Address ( 0x%x )\n",pReplica->Cxtions);
    DMPSTRW("Root                      : ",pReplica->Root);
    DMPSTRW("Stage                     : ",pReplica->Stage);
    DMPSTRW("NewStage                  : ",pReplica->NewStage);
    DMPSTRW("Volume                    : ",pReplica->Volume);
    DMPTIME("MembershipExpires         : ",pReplica->MembershipExpires);
    DMPQUAD("PreInstallFid             : ",pReplica->PreInstallFid);
    dprintf("ConfigTable               : Address ( 0x%x )\n",pReplica->ConfigTable);
    dprintf("ReplicaCtxListHead        : Address ( 0x%x )\n",pReplica->ReplicaCtxListHead);
    DMPSTRW("FileFilterList            : ",pReplica->FileFilterList);
    DMPSTRW("DirFilterList             : ",pReplica->DirFilterList);
    dprintf("FileNameFilterHead        : Address ( 0x%x )\n",pReplica->FileNameFilterHead);
    dprintf("DirNameFilterHead         : Address ( 0x%x )\n",pReplica->DirNameFilterHead);
    dprintf("NameConflictTable         : Address ( 0x%x )\n",pReplica->NameConflictTable);
    dprintf("InLogRetryCount           : %d\n",pReplica->InLogRetryCount);
    dprintf("InLogSeqNumber            : %d\n",pReplica->InLogSeqNumber);
    dprintf("ActiveInlogRetryTable     : Address ( 0x%x )\n",pReplica->ActiveInlogRetryTable);
    dprintf("NtFrsApi_ServiceState     : %d\n",pReplica->NtFrsApi_ServiceState);
    dprintf("NtFrsApi_ServiceWStatus   : %d\n",pReplica->NtFrsApi_ServiceWStatus);
    DMPSTRW("NtFrsApi_ServiceDisplay   : ",pReplica->NtFrsApi_ServiceDisplay);
    dprintf("OutLogLock                : Address ( 0x%x )\n",pReplica->OutLogLock);
    dprintf("OutLogEligible            : Address ( 0x%x )\n",pReplica->OutLogEligible);
    dprintf("OutLogStandBy             : Address ( 0x%x )\n",pReplica->OutLogStandBy);
    dprintf("OutLogActive              : Address ( 0x%x )\n",pReplica->OutLogActive);
    dprintf("OutLogInActive            : Address ( 0x%x )\n",pReplica->OutLogInActive);
    dprintf("OutLogRecordLock          : Address ( 0x%x )\n",pReplica->OutLogRecordLock);
    dprintf("OutLogSeqNumber           : %d\n",pReplica->OutLogSeqNumber);
    dprintf("OutLogJLx                 : %d\n",pReplica->OutLogJLx);
    dprintf("OutLogJTx                 : %d\n",pReplica->OutLogJTx);
    dprintf("OutLogCOMax               : %d\n",pReplica->OutLogCOMax);
    dprintf("OutLogWorkState           : %d\n",pReplica->OutLogWorkState);
    dprintf("OutLogCmdPkt              : Address ( 0x%x )\n",pReplica->OutLogCmdPkt);
    dprintf("OutLogTableCtx            : Address ( 0x%x )\n",pReplica->OutLogTableCtx);
    dprintf("OutLogCountVVJoins        : %d\n",pReplica->OutLogCountVVJoins);
    dprintf("OutLogDoCleanup           : %d\n",pReplica->OutLogDoCleanup);
    dprintf("PreInstallHandle          : Address ( 0x%x )\n",pReplica->PreInstallHandle);
    DMPGUID("JrnlCxtionGuid            : ",pReplica->JrnlCxtionGuid);
    DMPQUAD("InlogCommitUsn            : ",pReplica->InlogCommitUsn);
    DMPQUAD("JrnlRecoveryStart         : ",pReplica->JrnlRecoveryStart);
    DMPQUAD("JrnlRecoveryEnd           : ",pReplica->JrnlRecoveryEnd);
    dprintf("RecoveryRefreshList       : Address ( 0x%x )\n",pReplica->RecoveryRefreshList);
    dprintf("VolReplicaList            : Address ( 0x%x )\n",pReplica->VolReplicaList);
    DMPQUAD("LastUsnRecordProcessed    : ",pReplica->LastUsnRecordProcessed);
    dprintf("LocalCoQueueCount         : %d\n",pReplica->LocalCoQueueCount);
    dprintf("pVme                      : Address ( 0x%x )\n",pReplica->pVme);
    dprintf("PerfRepSetData            : Address ( 0x%x )\n",pReplica->PerfRepSetData);
}



VOID
do_vme(
    PVOLUME_MONITOR_ENTRY pVme
    )
/*
typedef struct _VOLUME_MONITOR_ENTRY {
    FRS_NODE_HEADER      Header;
    LIST_ENTRY           ListEntry;       // MUST FOLLOW HEADER

    //
    // This is the list head for all replica sets on the this volume.  It links
    // the REPLICA structs together.
    //
    FRS_LIST  ReplicaListHead;     // List of Replica Sets on Vol.
    //
    // The following USNs are for managing the NTFS USN journal on the volume.
    //
    USN    JrnlRecoveryEnd;        // Point where recovery is complete.

    USN    CurrentUsnRecord;       // USN of record currently being processed.
    USN    CurrentUsnRecordDone;   // USN of most recent record done processing.

    USN    LastUsnSavePoint;       // USN of last vol wide save.
    USN    MonitorMaxProgressUsn;  // Farthest progress made in this journal.

    USN    JrnlReadPoint;          // The current active read point for journal.

    USN_JOURNAL_DATA UsnJournalData; // FSCTL_QUERY_USN_JOURNAL data at journal open.

    USN    MonitorProgressUsn;     // Start journal from here after pause.
    USN    ReplayUsn;              // Start journal here after replica startup request
    BOOL   ReplayUsnValid;         // above has valid data.
    //
    // The FrsVsn is a USN kept by FRS and exported by all replica sets on the
    // volume.  It is unaffected by disk reformats and is saved in the config
    // record of each replica set.  At startup we use the maximum value for all
    // replica sets on a given volume. The only time they might differ is when
    // service on a given replica set is not started.
    //
    ULONGLONG            FrsVsn;          // Private FRS volume seq num.
    CRITICAL_SECTION     Lock;            // To sync access to VME.
    CRITICAL_SECTION     QuadWriteLock;   // To sync updates to quadwords.

    OVERLAPPED           CancelOverlap;   // Overlap struct for cancel req
    ULONG                WStatus;         // Win32 status on error
    ULONG                ActiveReplicas;  // Num replica sets active on journal
    HANDLE               Event;           // Event handle for pause journal.
    HANDLE               VolumeHandle;    // The vol handle for journal.
    WCHAR                DriveLetter[4];  // Drive letter for this volume.

    //
    // A change order table is kept on each volume to track the pending
    // change orders.  Tracking it for each replica set would be nice but
    // that approach has a problem with renames that move files or dirs
    // across replica sets on the volume.  If there are prior change orders
    // outstanding on a parent dir (MOVEOUT) in RS-A followed by a MOVEIN on
    // a child file X to RS-B we must be sure the MOVEOUT on the parent happens
    // before the MOVEIN on X.  Similar problems arise with a MOVEOUT of file X
    // followed by a MOVEIN to a different R.S. on the same volume.  We need to
    // locate the pending MOVEOUT change order on the volume or ensure it is
    // processed first.  One list per volume solves these problems.
    //
    PGENERIC_HASH_TABLE  ChangeOrderTable;// The Replica Change Order table.
    FRS_QUEUE            ChangeOrderList; // Change order processing list head.
    LIST_ENTRY           UpdateList;      // Link for the Replica Update Process Queue.
    ULONG                InitTime;        // Time reference for the ChangeOrderList.

    //
    // THe Active Inbound Change Order table holds the change order structs
    // indexed by File ID.  An entry in the table means that we have an
    // inbound (either local or remote) change order active on this file.
    //
    PGENERIC_HASH_TABLE  ActiveInboundChangeOrderTable;
    //
    // The ActiveChildren hash table is used to record the parent FID of each
    // active change order.  This is used to prevent a change order from starting
    // on the parent while a change order is active on one or more children.
    // For example if the child change order was a create and the parent change
    // order was an ACL change to prevent further creates, we must ensure the
    // child completes before starting the parent change order.  Each entry has
    // a count of the number of active children and a flag that is set if the
    // change order process queue is blocked because of a pending change order
    // on the parent.  When the count goes to zero the queue is unblocked.
    //
    PQHASH_TABLE  ActiveChildren;
    //
    // The Parent Table is a simple hash table used to keep the parent File ID
    // for each file and dir in any Replica Set on the volume.  It is used in
    // renames to find the old parent.
    //
    PQHASH_TABLE  ParentFidTable;
    //
    // The FRS Write Filter table filters out journal entries caused
    // by file system write from the File Replication Service (Us) when we
    // install files in the replica tree.
    //
    PQHASH_TABLE  FrsWriteFilter;
    //
    // The Recovery Conflict Table contains the FIDs of files that were in
    // the inbound log when we crashed.  At the start of recovery the inbound
    // log for the given replica set is scanned and the FIDs are entered into
    // the table.  During journal processing any USN records with a matching
    // FID are deemed to caused by FRS so we skip the record.  (This is because
    // the FrsWriteFilter table was lost in the crash).
    PQHASH_TABLE  RecoveryConflictTable;

    //
    // The name space table controls the merging of USN records into COs
    // that use the same file name.  If a name usage conflict exists in the
    // USN record stream then we can't merge the USN record into a previous
    // change order on the same file.
    //
    PQHASH_TABLE  NameSpaceTable;
    ULONG StreamSequenceNumberFetched;
    ULONG StreamSequenceNumberClean;
    ULONG StreamSequenceNumber;

    //
    // The Filter Table contains an entry for each direcctory that is within a
    // replica set on this volume.  It is used to filter out Journal records for
    // files/dirs that are not in a Replica set.  For those Journal records that
    // are in a replica set, a lookup on the parent FileId tells us which one.
    //
    PGENERIC_HASH_TABLE  FilterTable;     // THe directory filter table.
    BOOL                 StopIo;          // True means StopIo requested.
    BOOL                 IoActive;        // True means I/O active on volume.
    ULONG                JournalState;    // Current journal state.
    ULONG                ReferenceCount;  // Free all hash tables when it hits 0.
    LONG                 ActiveIoRequests;// Number of Journal reads currently outstanding.
    FILE_OBJECTID_BUFFER RootDirObjectId; // Object ID for volume

    FILE_FS_VOLUME_INFORMATION    FSVolInfo;       // NT volume info.
    CHAR                          FSVolLabel[MAXIMUM_VOLUME_LABEL_LENGTH];

} VOLUME_MONITOR_ENTRY, *PVOLUME_MONITOR_ENTRY;
*/
{
    dprintf("Dumping OUT_LOG_PARTNER.\n\n");
    dprintf("Header                     : Address ( 0x%x )\n",pVme->Header);
    dprintf("ListEntry                  : Address ( 0x%x )\n",pVme->ListEntry);
    dprintf("WStatus                    : 0x%x\n",pVme->WStatus);
    dprintf("ActiveReplicas             : %d\n"  ,pVme->ActiveReplicas);
    dprintf("Event Handle for pause     : 0x%x\n",pVme->Event);
    dprintf("VolumeHandle               : 0x%x\n",pVme->VolumeHandle);
    dprintf("DriveLetter                : %ws\n" ,pVme->DriveLetter);
    dprintf("StopIo  (bool)             : 0x%x\n",pVme->StopIo);
    dprintf("IoActive (bool)            : 0x%x\n",pVme->IoActive);
    dprintf("JournalState               : 0x%x\n",pVme->JournalState);
    dprintf("ReferenceCount             : %d\n"  ,pVme->ReferenceCount);
    dprintf("ActiveIoRequests           : %d\n"  ,pVme->ActiveIoRequests);
    dprintf("FSVolLabel                 : %s\n"  ,pVme->FSVolLabel);


}



//
// Version info
//
#if DBG
USHORT SavedMajorVersion = 0x0c;
#else
USHORT SavedMajorVersion;
#endif
EXT_API_VERSION ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
USHORT SavedMinorVersion = VER_PRODUCTBUILD;
BOOL   ChkTarget;            // is debuggee a CHK build?


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    fKD = 1;
    ExtensionApis = *lpExtensionApis ;
    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}

DECLARE_API( help )
{
    INIT_DPRINTF();

    if (lpArgumentString[0] == '\0') {
        dprintf("\n");
        dprintf("FRS Debugger extensions help:\n\n");
        dprintf("%20s - CHANGE_ORDER_ENTRY\n","coe");
        dprintf("%20s - CHANGE_ORDER_COMMAND\n","coc");
        dprintf("%20s - CXTION\n","cxt");
        dprintf("%20s - OUT_LOG_PARTNER\n","olp");
        dprintf("%20s - REPLICA\n","rep");
        dprintf("%20s - VME\n","vme");
        dprintf("\n");
    }
}

DECLARE_API( version )
{
    INIT_DPRINTF();

    if (fKD)
        {
        dprintf(
                "FRS Extension dll for Build %d debugging %s kernel for Build %d\n",
                VER_PRODUCTBUILD,
                SavedMajorVersion == 0x0c ? "Checked" : "Free",
                SavedMinorVersion
                );
        }
    else
        {
        dprintf(
                "FRS Extension dll for Build %d\n",
                VER_PRODUCTBUILD
                );
        }
}

DECLARE_API( coe )
{
    ULONG_PTR dwAddr;

    INIT_DPRINTF();

    dwAddr = GetExpression(lpArgumentString);
    if ( !dwAddr ) {
        dprintf("Error: can't evaluate '%s'\n", lpArgumentString);
        return;
    }

    BOOL b;
    char block[sizeof(CHANGE_ORDER_ENTRY)];

    b = GetData(dwAddr, &block, sizeof(block), NULL);
    if ( !b ) {
        dprintf("can't read %p, error 0x%lx\n", dwAddr, GetLastError());
        return;
    }

    do_coe((CHANGE_ORDER_ENTRY *) block);
}

DECLARE_API( coc )
{
    ULONG_PTR dwAddr;

    INIT_DPRINTF();

    dwAddr = GetExpression(lpArgumentString);
    if ( !dwAddr ) {
        dprintf("Error: can't evaluate '%s'\n", lpArgumentString);
        return;
    }

    BOOL b;
    char block[sizeof(CHANGE_ORDER_COMMAND)];

    b = GetData(dwAddr, &block, sizeof(block), NULL);
    if ( !b ) {
        dprintf("can't read %p, error 0x%lx\n", dwAddr, GetLastError());
        return;
    }

    do_coc((CHANGE_ORDER_COMMAND *) block);
}

DECLARE_API( cxt )
{
    ULONG_PTR dwAddr;

    INIT_DPRINTF();

    dwAddr = GetExpression(lpArgumentString);
    if ( !dwAddr ) {
        dprintf("Error: can't evaluate '%s'\n", lpArgumentString);
        return;
    }

    BOOL b;
    char block[sizeof(CXTION)];

    b = GetData(dwAddr, &block, sizeof(block), NULL);
    if ( !b ) {
        dprintf("can't read %p, error 0x%lx\n", dwAddr, GetLastError());
        return;
    }

    do_cxt((CXTION *) block);
}

DECLARE_API( olp )
{
    ULONG_PTR dwAddr;

    INIT_DPRINTF();

    dwAddr = GetExpression(lpArgumentString);
    if ( !dwAddr ) {
        dprintf("Error: can't evaluate '%s'\n", lpArgumentString);
        return;
    }

    BOOL b;
    char block[sizeof(OUT_LOG_PARTNER)];

    b = GetData(dwAddr, &block, sizeof(block), NULL);
    if ( !b ) {
        dprintf("can't read %p, error 0x%lx\n", dwAddr, GetLastError());
        return;
    }

    do_olp((OUT_LOG_PARTNER *) block);
}

DECLARE_API( vme )
{
    ULONG_PTR dwAddr;

    INIT_DPRINTF();

    dwAddr = GetExpression(lpArgumentString);
    if ( !dwAddr ) {
        dprintf("Error: can't evaluate '%s'\n", lpArgumentString);
        return;
    }

    BOOL b;
    char block[sizeof(VOLUME_MONITOR_ENTRY)];

    b = GetData(dwAddr, &block, sizeof(block), NULL);
    if ( !b ) {
        dprintf("can't read %p, error 0x%lx\n", dwAddr, GetLastError());
        return;
    }

    do_vme((VOLUME_MONITOR_ENTRY *) block);
}

DECLARE_API( rep )
{
    ULONG_PTR dwAddr;

    INIT_DPRINTF();

    dwAddr = GetExpression(lpArgumentString);
    if ( !dwAddr ) {
        dprintf("Error: can't evaluate '%s'\n", lpArgumentString);
        return;
    }

    BOOL b;
    char block[sizeof(REPLICA)];

    b = GetData(dwAddr, &block, sizeof(block), NULL);
    if ( !b ) {
        dprintf("can't read %p, error 0x%lx\n", dwAddr, GetLastError());
        return;
    }

    do_rep((REPLICA *) block);
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\test\frsconv\frsconv.cxx ===
extern "C" {
#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#include    <ntioapi.h>
#include    <windows.h>
#include    <stdlib.h>
#include    <stdio.h>
#include    <lm.h>
#include    <netcan.h>
#include    <icanon.h>
#include    <dsgetdc.h>
#include    <dsrole.h>
}

/*
 * This program performs the steps necessary to configure NTFRS on a DC, prepared
 * to support the system and enterprise volumes.
 *
 * It was created as an interim tool to support the initialization of NTFRS on a DC
 *  which was running NT5 generation software before NTFRS was available.  After upgrading
 *  that DC with the latest NT5 version, this tool must be manually run to complete the
 *  initialization of NTFRS and system volumes.
 */


WCHAR SysVolShare[] = L"SYSVOL";
WCHAR SysVolRemark[] = L"System Volume Share (Migrated)";
WCHAR FRSSysvol[] = L"System\\CurrentControlSet\\Services\\NtFrs\\Parameters\\Sysvol";

#define DSROLEP_FRS_COMMAND     L"Replica Set Command"
#define DSROLEP_FRS_NAME        L"Replica Set Name"
#define DSROLEP_FRS_TYPE        L"Replica Set Type"
#define DSROLEP_FRS_PRIMARY     L"Replica Set Primary"
#define DSROLEP_FRS_STAGE       L"Replica Set Stage"
#define DSROLEP_FRS_ROOT        L"Replica Set Root"
#define DSROLEP_FRS_CREATE      L"Create"
#define DSROLEP_FRS_DELETE      L"Delete"
#define DSROLEP_FRS_COMMITTED   L"SysVol Information is Committed"
#define DSROLEP_FRS_LONG_NAME   L"Microsoft File Replication Service"
#define DSROLEP_FRS_SHORT_NAME  L"NtFrs"

//
// These are the static directories created within a system volume share
//
LPWSTR StaticSysvolDirs[] = {
    L"sysvol",
    L"domain",
    L"enterprise",
    L"staging",
    L"staging areas",

    L"sysvol\\enterprise",
    L"staging\\domain",
    L"staging\\enterprise",
    0
};

//
// Print out the usage message
//
void
Usage( int argc, char *argv[] )
{
    fprintf( stderr, "Usage: %s [-D] [-E] sysvol\n\n", argv[0] );
    fprintf( stderr, "       -D  this is the first upgraded DC in this domain\n\n" );
    fprintf( stderr, "       -E  this is the first upgraded DC in this enterprise\n\n" );
    fprintf( stderr, "       sysvol is the path for the system volume share.\n" );
    fprintf( stderr, "         The system volume must reside on NTFS version 5\n" );
}

//
// Print 'text' and render 'code' into an error message
//
void
errmsg( char *text, ULONG code )
{
    int i;
    char msg[ 100 ];

    i = FormatMessageA( FORMAT_MESSAGE_FROM_SYSTEM | sizeof( msg ),
               NULL,
               code,
               0,
               msg,
               sizeof(msg),
               NULL );

    if( i )
        fprintf( stderr, "%s: %s\n", text ? text : "", msg );
    else
        fprintf( stderr, "%s: error %d\n", text ? text : "", code );
}

//
// Print unicode 'text' and render 'code' into an error message
//
void
errmsg( LPWSTR text, ULONG code )
{
    int i;
    WCHAR msg[ 100 ];

    i = FormatMessageW( FORMAT_MESSAGE_FROM_SYSTEM | sizeof( msg ),
               NULL,
               code,
               0,
               msg,
               sizeof(msg),
               NULL );

    if( i )
        fprintf( stderr, "%ws: %ws\n", text ? text : L"", msg );
    else
        fprintf( stderr, "%ws: error %d\n", text ? text : L"", code );
}

//
// Write a string value to the registry
//
BOOLEAN
WriteRegistry( LPWSTR KeyName, LPWSTR ValueName, LPWSTR Value )
{
    HKEY hKey;
    DWORD disposition;
    LONG retval;

    //
    // First ensure that 'keyname' exists in the registry
    //

    retval = RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,
                    KeyName,
                    NULL,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKey,
                    &disposition
                   );

    if( retval != ERROR_SUCCESS ) {
        errmsg( KeyName, retval );
        return FALSE;
    }

    if( ARGUMENT_PRESENT( ValueName ) ) {

        retval = RegSetValueEx(
                    hKey,
                    ValueName,
                    0,
                    REG_SZ,
                    (BYTE *)Value,
                    (wcslen( Value ) + 1) * sizeof( WCHAR )
                 );

        if( retval != ERROR_SUCCESS ) {
            errmsg( ValueName, retval );
            RegCloseKey( hKey );
            return FALSE;
        }
    }

    RegCloseKey( hKey );
    return TRUE;
}

//
// Write a DWORD value to the registry
//
BOOLEAN
WriteRegistry( LPWSTR KeyName, LPWSTR ValueName, DWORD Value )
{
    HKEY hKey;
    DWORD disposition;
    LONG retval;

    //
    // First ensure that 'keyname' exists in the registry
    //

    retval = RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,
                    KeyName,
                    NULL,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKey,
                    &disposition
                   );

    if( retval != ERROR_SUCCESS ) {
        errmsg( KeyName, retval );
        return FALSE;
    }

    if( ARGUMENT_PRESENT( ValueName ) ) {

        retval = RegSetValueEx(
                    hKey,
                    ValueName,
                    0,
                    REG_DWORD,
                    (BYTE *)&Value,
                    sizeof( Value )
                 );

        if( retval != ERROR_SUCCESS ) {
            errmsg( ValueName, retval );
            RegCloseKey( hKey );
            return FALSE;
        }
    }

    RegCloseKey( hKey );
    return TRUE;
}

//
// Make sure that 'DirName' exists.  Create it if it doesn't
//
BOOLEAN
EnsureDirectoryExists( LPWSTR DirName )
{
    DWORD retval;

    retval = GetFileAttributes( DirName );

    if( retval == 0xFFFFFFFF ) {
        printf( "    Create directory: %ws\n", DirName );
        if( !CreateDirectory( DirName, NULL ) ) {
            retval = GetLastError();
            errmsg( DirName, GetLastError() );
            return FALSE;
        }
    } else if( !(retval & FILE_ATTRIBUTE_DIRECTORY) ) {
        fprintf( stderr, "Not a directory: %ws\n", DirName );
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
LinkAToB( LPWSTR DirA, LPWSTR DirB )
{
    NTSTATUS Status;
    HANDLE Handle;
    UNICODE_STRING UnicodeNameB;
    UNICODE_STRING DosNameB;
    IO_STATUS_BLOCK IoStatusBlock;
    PREPARSE_DATA_BUFFER ReparseBufferHeader;
    PCHAR ReparseBuffer;
    USHORT ReparseDataLength;

    if( !EnsureDirectoryExists( DirA ) ||
        !EnsureDirectoryExists( DirB ) ) {

        return FALSE;
    }

    Handle = CreateFile( DirA,
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,
                        NULL
                        );

    if( Handle == INVALID_HANDLE_VALUE ) {
        fprintf( stderr, "Unable to open %ws", DirA );
        errmsg( (LPWSTR)NULL, GetLastError() );
        return FALSE;
    }

    //
    // Get the NT path name of the directory to which we want to link
    //
    if( !RtlDosPathNameToNtPathName_U(
                            DirB,
                            &UnicodeNameB,
                            NULL,
                            NULL
                            )) {
        errmsg( DirB, GetLastError() );
        return FALSE;
    }
    RtlInitUnicodeString( &DosNameB, DirB);

    //
    //  Set the reparse point with mount point or symbolic link tag and determine
    //  the appropriate length of the buffer.
    //

    ReparseDataLength = (FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer) -
                        REPARSE_DATA_BUFFER_HEADER_SIZE) +
                        UnicodeNameB.Length + sizeof(UNICODE_NULL) +
                        DosNameB.Length + sizeof(UNICODE_NULL);

    //
    //  Allocate a buffer to set the reparse point.
    //

    ReparseBufferHeader = (PREPARSE_DATA_BUFFER)LocalAlloc(  LPTR,
                                                    REPARSE_DATA_BUFFER_HEADER_SIZE +
                                                    ReparseDataLength
                                                    );

    if (ReparseBufferHeader == NULL) {
        CloseHandle( Handle );
        errmsg( "Unable to allocate reparse buffer", GetLastError() );
        return FALSE;
    }

    ReparseBufferHeader->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
    ReparseBufferHeader->ReparseDataLength = (USHORT)ReparseDataLength;
    ReparseBufferHeader->Reserved = 0;

    ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameOffset = 0;
    ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameLength = UnicodeNameB.Length;
    ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameOffset = UnicodeNameB.Length + sizeof( UNICODE_NULL );
    ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameLength = DosNameB.Length;
    RtlCopyMemory(
        ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer,
        UnicodeNameB.Buffer,
        UnicodeNameB.Length
        );
    RtlCopyMemory(
        (PCHAR)(ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer)+
        UnicodeNameB.Length + sizeof(UNICODE_NULL),
        DosNameB.Buffer,
        DosNameB.Length
        );

    Status = NtFsControlFile(
                 Handle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 FSCTL_SET_REPARSE_POINT,
                 ReparseBufferHeader,
                 REPARSE_DATA_BUFFER_HEADER_SIZE + ReparseBufferHeader->ReparseDataLength,
                 NULL,                // no output buffer
                 0                    // output buffer length
                 );

    LocalFree( (HLOCAL)ReparseBufferHeader );

    CloseHandle( Handle );

    if (!NT_SUCCESS(Status)) {

        switch( Status ) {
        case STATUS_VOLUME_NOT_UPGRADED:
        case STATUS_INVALID_DEVICE_REQUEST:
            printf( "%ws must be on an NT5 NTFS volume.\n", DirA );
            break;

        default:
            printf( "Unable to set reparse point data, status %X", Status );
            break;
        }

        return FALSE;
    }

    return TRUE;
}

//
// Create the system volume subtree
//
BOOLEAN
CreateSysVolTree( LPWSTR SysVolPath, BOOLEAN IsFirstDCInDomain , PWCHAR domainName)
{
    DWORD i;
    WCHAR bufA[ MAX_PATH ];
    WCHAR bufB[ MAX_PATH ];

    printf( "Checking %ws subtree at %ws\n", SysVolShare, SysVolPath );

    if( !EnsureDirectoryExists( SysVolPath) ) {
        return FALSE;
    }

    //
    // First create the static system volume directories
    //
    for( i = 0; StaticSysvolDirs[i]; i++ ) {
        wcscpy( bufA, SysVolPath );
        wcscat( bufA, L"\\" );
        wcscat( bufA, StaticSysvolDirs[i]  );

        if( !EnsureDirectoryExists( bufA ) ) {
            return FALSE;
        }
    }

    //
    // Create the DNS domain link for the sysvol share
    //
    wcscpy( bufA, SysVolPath );
    wcscat( bufA, L"\\sysvol\\" );
    wcscat( bufA, domainName );

    wcscpy( bufB, SysVolPath );
    wcscat( bufB, L"\\domain" );

    if( !LinkAToB( bufA, bufB ) ) {
        return FALSE;
    }

    //
    // Create the enterprise link for the sysvol share
    //
    wcscpy( bufA, SysVolPath );
    wcscat( bufA, L"\\sysvol\\enterprise" );

    wcscpy( bufB, SysVolPath );
    wcscat( bufB, L"\\enterprise" );

    if( !LinkAToB( bufA, bufB ) ) {
        return FALSE;
    }

    //
    // Create the DNS domain link in the staging area
    //
    wcscpy( bufA, SysVolPath );
    wcscat( bufA, L"\\staging areas\\" );
    wcscat( bufA, domainName );

    wcscpy( bufB, SysVolPath );
    wcscat( bufB, L"\\staging\\domain" );

    if( !LinkAToB( bufA, bufB ) ) {
        return FALSE;
    }

    //
    // Create the enterprise link in the staging area
    //
    wcscpy( bufA, SysVolPath );
    wcscat( bufA, L"\\staging areas\\enterprise" );

    wcscpy( bufB, SysVolPath );
    wcscat( bufB, L"\\staging\\enterprise" );

    if( !LinkAToB( bufA, bufB ) ) {
        return FALSE;
    }

    //
    // Finally, if we are the first DC initialized in this domain,
    //  we need to create the scripts directory
    //
    if( IsFirstDCInDomain ) {

        wcscpy( bufA, SysVolPath );
        wcscat( bufA, L"\\domain\\scripts" );

        if( !EnsureDirectoryExists( bufA ) ) {
            return FALSE;
        }
    }

    return TRUE;
}

//
// Create the system volume share.
//
BOOLEAN
CreateSysVolShare( LPWSTR SysVolPath )
{
    DWORD dwType, retval;
    SHARE_INFO_2 si2, *psi2;

    printf( "Creating system volume share:\n" );

    //
    // Blow away the current sysvol share if it exists
    //
    retval = NetShareGetInfo( NULL, SysVolShare, 2, (LPBYTE *)&psi2 );

    if( retval == NO_ERROR ) {
        if( psi2->shi2_type != STYPE_DISKTREE ) {
            fprintf( stderr, "%ws is shared, but is not a disk share!\n" );
            return FALSE;
        }

        printf( "    Delete current share: %ws=%ws\n", psi2->shi2_netname, psi2->shi2_path );

        NetApiBufferFree( psi2 );

        //
        // Try to delete this share
        //
        retval = NetShareDel( NULL, SysVolShare, 0 );
        if( retval != NO_ERROR ) {
            errmsg( "Unable to delete sysvol share", retval );
            return FALSE;
        }
    }

    //
    // Add the new sysvol share
    //
    si2.shi2_netname = SysVolShare;
    si2.shi2_type = STYPE_DISKTREE;
    si2.shi2_remark = SysVolRemark;
    si2.shi2_permissions = 0;
    si2.shi2_max_uses = (DWORD)-1;
    si2.shi2_current_uses = 0;
    si2.shi2_path = SysVolPath;
    si2.shi2_passwd = 0;

    printf( "    Add share: %ws=%ws\n", SysVolShare, SysVolPath );
    retval = NetShareAdd( NULL, 2, (LPBYTE)&si2, &dwType );

    if( retval != NO_ERROR ) {
        errmsg( "Unable to share new sysvol share", retval );
        return FALSE;
    }

    //
    // Add the registry key telling netlogon to share this out as the system volume share
    //
    printf( "    Add netlogon sysvol registry key\n" );

    return WriteRegistry( L"System\\CurrentControlSet\\Services\\Netlogon\\Parameters",
                          L"SysVol",
                          SysVolPath
                        );
}

//
// Add the registry keys needed for NTFRS.  Do what DcPromo would have done
//
BOOLEAN
AddRegKeys(
    IN PWCHAR   ReplicaSetName,
    IN PWCHAR   ReplicaSetType,
    IN DWORD    ReplicaSetPrimary,
    IN PWCHAR   ReplicaSetStage,
    IN PWCHAR   ReplicaSetRoot )
{
    WCHAR   KeyName[512];

    //
    // Make sure the NTFRS section is there
    //
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs", 0, (DWORD)0 );
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs\\Parameters", 0, (DWORD)0 );
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs\\Parameters\\Sysvol", 0, (DWORD)0 );

    //
    // Sysvol key + values
    //
    wcscpy( KeyName, L"System\\CurrentControlSet\\services\\NtFrs\\Parameters\\Sysvol\\" );
    wcscat( KeyName, ReplicaSetName );
    WriteRegistry( KeyName, DSROLEP_FRS_COMMAND, DSROLEP_FRS_CREATE );
    WriteRegistry( KeyName, DSROLEP_FRS_NAME, ReplicaSetName );
    WriteRegistry( KeyName, DSROLEP_FRS_TYPE, ReplicaSetType );
    WriteRegistry( KeyName, DSROLEP_FRS_PRIMARY, (DWORD)ReplicaSetPrimary );
    WriteRegistry( KeyName, DSROLEP_FRS_ROOT, ReplicaSetRoot );
    WriteRegistry( KeyName, DSROLEP_FRS_STAGE, ReplicaSetStage );

    return TRUE;
}

//
// Commit the registry keys so that if NtFrs is running it can now
// pick up a consistent set of values.
//
BOOLEAN
CommitRegKeys(
    VOID )
{
    //
    // Make sure the NTFRS section is there
    //
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs", 0, (DWORD)0 );
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs\\Parameters", 0, (DWORD)0 );
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs\\Parameters\\Sysvol", 0, (DWORD)0 );

    //
    // Commit both sysvols
    //
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs\\Parameters\\Sysvol",
                  DSROLEP_FRS_COMMITTED, (DWORD)1 );
    return TRUE;
}

//
// Commit the registry keys so that if NtFrs is running it can now
// pick up a consistent set of values.
//
BOOLEAN
DeleteRegKeys(
    VOID )
{
    DWORD WStatus;
    HKEY  HKey = 0;
    WCHAR KeyBuf[MAX_PATH + 1];

    printf("Delete registry keys.\n");

    //
    // Make sure the NTFRS section is there
    //
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs", 0, (DWORD)0 );
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs\\Parameters", 0, (DWORD)0 );
    WriteRegistry( L"System\\CurrentControlSet\\services\\NtFrs\\Parameters\\Sysvol", 0, (DWORD)0 );

    WStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           L"System\\CurrentControlSet\\services\\NtFrs\\Parameters\\Sysvol",
                           0,
                           KEY_ALL_ACCESS,
                           &HKey);
    if (WStatus != ERROR_SUCCESS) {
        errmsg("Cannot open registry", WStatus);
        return FALSE;
    }
    WStatus = RegDeleteValue(HKey, DSROLEP_FRS_COMMITTED);
    if (WStatus != ERROR_SUCCESS && WStatus != ERROR_FILE_NOT_FOUND) {
        errmsg("Cannot delete registry value", WStatus);
        return FALSE;
    }
    //
    // Delete the subkeys
    //
    do {
        WStatus = RegEnumKey(HKey, 0, KeyBuf, MAX_PATH + 1);
        if (WStatus == ERROR_SUCCESS) {
            WStatus = RegDeleteKey(HKey, KeyBuf);
        }
    } while (WStatus == ERROR_SUCCESS);
    if (WStatus != ERROR_NO_MORE_ITEMS) {
        errmsg("Cannot delete registry key", WStatus);
        return FALSE;
    }
    RegCloseKey(HKey);
    return TRUE;
}

//
// Set FRS to auto start
//
BOOLEAN
SetFRSAutoStart( void )
{
    SC_HANDLE   ServiceHandle;
    SC_HANDLE   SCMHandle;

    printf( "Set NTFRS to Auto Start\n" );

    //
    // Contact the SC manager.
    //
    SCMHandle = OpenSCManager(NULL,
                              NULL,
                              SC_MANAGER_CONNECT);
    if (SCMHandle == NULL) {
        errmsg("Can't set NtFrs to Auto Start", GetLastError());
        return FALSE;
    }

    //
    // Contact the NtFrs service.
    //
    ServiceHandle = OpenService(SCMHandle,
                                DSROLEP_FRS_SHORT_NAME,
                                   SERVICE_INTERROGATE |
                                   SERVICE_PAUSE_CONTINUE |
                                   SERVICE_QUERY_STATUS |
                                   SERVICE_START |
                                   SERVICE_STOP |
                                   SERVICE_CHANGE_CONFIG);
    if (ServiceHandle == NULL) {
        errmsg("Can't set NtFrs to Auto Start", GetLastError());
        return FALSE;
    }
    CloseServiceHandle(SCMHandle);

    //
    // Service starts automatically at startup
    //
    if (!ChangeServiceConfig(ServiceHandle,
                             SERVICE_NO_CHANGE,
                             SERVICE_AUTO_START,
                             SERVICE_NO_CHANGE,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             DSROLEP_FRS_LONG_NAME)) {
        errmsg("Can't set NtFrs to Auto Start", GetLastError());
        return FALSE;
    }
    CloseServiceHandle(ServiceHandle);
    return TRUE;
}

//
// Start FRS
//
BOOLEAN
StartFRS( void )
{
    DWORD           WStatus;
    SC_HANDLE       ServiceHandle;
    SC_HANDLE       SCMHandle;
    SERVICE_STATUS  ServiceStatus;

    printf( "Start NTFRS\n" );

    //
    // Contact the SC manager.
    //
    SCMHandle = OpenSCManager(NULL,
                              NULL,
                              SC_MANAGER_CONNECT);
    if (SCMHandle == NULL) {
        errmsg("Can't start NtFrs", GetLastError());
        return FALSE;
    }

    //
    // Contact the NtFrs service.
    //
    ServiceHandle = OpenService(SCMHandle,
                                DSROLEP_FRS_SHORT_NAME,
                                   SERVICE_INTERROGATE |
                                   SERVICE_PAUSE_CONTINUE |
                                   SERVICE_QUERY_STATUS |
                                   SERVICE_START |
                                   SERVICE_STOP |
                                   SERVICE_CHANGE_CONFIG);
    if (ServiceHandle == NULL) {
        errmsg("Can't start NtFrs", GetLastError());
        return FALSE;
    }
    CloseServiceHandle(SCMHandle);

    //
    // stop the service
    //
    ControlService(ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus);

    //
    // Start the service
    //
    if (!StartService(ServiceHandle, 0, NULL)) {
        //
        // May be shutting down; retry in a bit
        //
        Sleep(3 * 1000);
        if (!StartService(ServiceHandle, 0, NULL)) {
            WStatus = GetLastError();
            if (WStatus != ERROR_SERVICE_ALREADY_RUNNING) {
                errmsg("Can't start NtFrs", WStatus);
                return FALSE;
            }
        }
    }
    CloseServiceHandle(ServiceHandle);
    return TRUE;
}

BOOLEAN
IsThisADC(
    IN PWCHAR domainName )
{
    DWORD   WStatus;
    PWCHAR  p;
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC *DsRole;

    //
    // Is this a domain controller?
    //
    WStatus = DsRoleGetPrimaryDomainInformation(NULL,
                                                DsRolePrimaryDomainInfoBasic,
                                                (PBYTE *)&DsRole);
    if (WStatus != ERROR_SUCCESS) {
        errmsg("Can't get primary domain information", WStatus);
        return FALSE;
    }

    //
    // Domain Controller (DC)
    //
    if (DsRole->MachineRole == DsRole_RoleBackupDomainController ||
        DsRole->MachineRole == DsRole_RolePrimaryDomainController) {
        if (!DsRole->DomainNameDns) {
            errmsg( "Unable to get domain name", ERROR_PATH_NOT_FOUND );
            return FALSE;
        }
        wcscpy(domainName, DsRole->DomainNameDns);
        DsRoleFreeMemory(DsRole);
        for( p = domainName; *p != L'\0'; p++ );
        if( *(p-1) == L'.' ) {
            *(p-1) = L'\0';
        }
        return TRUE;
    }
    DsRoleFreeMemory(DsRole);
    return FALSE;
}

/*
 * Make it so NTFRS will run on this DC
 */
__cdecl
main( int argc, char *argv[] )
{
    DWORD i;
    LONG retval;
    BOOLEAN IsFirstDCInDomain = FALSE;
    BOOLEAN IsFirstDCInEnterprise = FALSE;
    WCHAR SysVolPath[ MAX_PATH ], stage[ MAX_PATH ], root[ MAX_PATH ];
    DWORD pathType;
    WCHAR domainName[512];

    SysVolPath[0] = 0;

    if( IsThisADC( domainName ) == FALSE ) {
        fprintf( stderr, "This program can only be run on a DC!\n" );
        return 1;
    }

    for( i = 1; i < (DWORD)argc; i++ ) {
        switch( argv[i][0] ) {
        case '/':
        case '-':
                switch( argv[i][1] ) {
                case 'D':
                case 'd':
                    IsFirstDCInDomain = TRUE;
                    break;
                case 'E':
                case 'e':
                    IsFirstDCInEnterprise = TRUE;
                    IsFirstDCInDomain = TRUE;
                    break;
                default:
                    fprintf( stderr, "Unrecognized option: %c\n\n", argv[i][1] );
                    Usage( argc, argv );
                    return 1;
                }
                break;
        default:

            if( SysVolPath[0] != 0 ) {
                fprintf( stderr, "Too many 'sysvol' paths!  Need quotes?\n\n" );
                Usage( argc, argv );
                return 1;
            }

            mbstowcs( SysVolPath, argv[i], sizeof( SysVolPath ) );

            //
            // Make sure the system volume path is reasonable
            //
            retval = NetpPathType( NULL, SysVolPath, &pathType, 0 );

            if( retval != NO_ERROR || pathType != ITYPE_PATH_ABSD ) {
                fprintf( stderr, "Invalid system volume path.  Must be an absolute path.\n" );
                return 1;
            }

            break;
        }
    }

    if( SysVolPath[0] == 0 ) {
        Usage( argc, argv );
        return 1;
    }

    printf( "Initializing the NT MultiMaster File Replication Service:\n" );
    printf( "    Domain: %ws\n", domainName );

    if( IsFirstDCInDomain ) {
        printf( "    First DC in the domain\n" );
    }
    if( IsFirstDCInEnterprise ) {
        printf( "    First DC in the enterprise\n" );
    }
    printf( "    System Volume: %ws\n", SysVolPath );

    //
    // Create the sysvol tree and share it out
    //
    if( !CreateSysVolTree( SysVolPath, IsFirstDCInDomain, domainName ) ||
        !CreateSysVolShare( SysVolPath ) ) {

        return 1;
    }

    //
    // Add the registry keys for the NTFRS enterprise volume
    //
    wcscpy( stage, SysVolPath );
    wcscat( stage, L"\\staging areas\\enterprise" );

    wcscpy( root, SysVolPath );
    wcscat( root, L"\\sysvol\\enterprise" );

    if( !AddRegKeys( L"enterprise",
                     L"enterprise",
                     IsFirstDCInEnterprise,
                     stage,
                     root ) ) {
        goto errout;
    }

    //
    // Add the registry keys for the NTFRS domain volume
    //
    wcscpy( stage, SysVolPath );
    wcscat( stage, L"\\staging areas\\" );
    wcscat( stage, domainName );

    wcscpy( root, SysVolPath );
    wcscat( root, L"\\sysvol\\" );
    wcscat( root, domainName );

    if( !AddRegKeys( domainName,
                     L"domain",
                     IsFirstDCInDomain,
                     stage,
                     root ) ) {
        goto errout;
    }

    //
    // Commit the keys only after all of the values are set without error.
    // Otherwise, a running NtFrs might pick up the keys while they are in
    // an incomplete state.
    //
    if( !CommitRegKeys()) {
        goto errout;
    }

    //
    // Now ensure that the replication service is running, and will run at each boot
    //
    if( !SetFRSAutoStart() || !StartFRS() ) {
        goto errout;
    }

    printf( "Success!\n" );

    return 0;

errout:
    fprintf( stderr, "Warning: SYSVOL share path may have been changed.\n" );
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\test\jetwalk\jetwalk.cxx ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    JetWalk.cxx

Abstract:

    Dumps a Jet database

Author:

    Rajivendra Nath (RajNath) 18-Aug-1989

Revision History:

    David Orbits (davidor) 6-March-1997
       Revised for NTFRS database and major rework.

--*/


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <esent.h>

#define BUFFER_SIZE                     1024


JET_ERR DbStats( JET_SESID jsesid, char * szDbName );
void TblStats( JET_SESID jsesid, JET_DBID jdbid, int iTable, char *szTblName, unsigned long *pcPages );
void DumpAttributes( JET_SESID jsesid, JET_COLUMNLIST colinfo );
void DumpIndex( JET_SESID jsesid, JET_INDEXLIST colinfo );
void DBDumpTable( JET_SESID jsesid,JET_TABLEID jtid, char* rgb);
void DBDumpRecord( JET_SESID jsesid,JET_TABLEID jtid);

typedef char* SZ;
typedef ULONG CCH;

typedef struct
{
    char           AttribName[64];
    JET_COLUMNID   colid;
    JET_COLTYP     coltyp;
    JET_GRBIT      grbit;
    BOOL           Display;

}ATTRIBLIST;

typedef struct
{
    char           AttribName[64];
    char           key[256];
    JET_COLUMNID   colid;
    JET_COLTYP     coltyp;
    JET_GRBIT      grbit;
    BOOL           Display;

}INDEXLIST;


DWORD      List[1024];
ATTRIBLIST AList[1024];
DWORD      AListUsed;


INDEXLIST  IList[1024];
DWORD      IListUsed;
BOOL NeedShutdown = FALSE;



char *JetColumnTypeNames[] = {
"coltypNil         ",
"coltypBit         ",
"coltypUnsignedByte",
"coltypShort       ",
"coltypLong        ",
"coltypCurrency    ",
"coltypIEEESingle  ",
"coltypIEEEDouble  ",
"coltypDateTime    ",
"coltypBinary      ",
"coltypText        ",
"coltypLongBinary  ",
"coltypLongText    ",
"coltypMax         "};


#define TIMECALL(CallX)                     \
{                                           \
    DWORD start,end;                        \
    start = GetTickCount();                 \
    CallX;                                  \
    end   = GetTickCount();                 \
    printf("[%5d MilliSec] <<%s>> \n",end-start,#CallX);\
}


void
ReadSzFromRegKey(SZ szKey, SZ szValue, SZ szBuf, CCH cchBuf)
{
    HKEY            hkey = NULL;

    // User specified that we use the regular registry variables.
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        DWORD           dwType;
        ULONG           cb;

        cb = cchBuf;
        if ((RegQueryValueEx(hkey, szValue, 0, &dwType, (LPBYTE) szBuf, &cb)
                                        == ERROR_SUCCESS)
                        && cb > 0 && (dwType == REG_SZ || dwType == REG_EXPAND_SZ))
        {
                return;
        }
    }

    printf("Couldn't read value %s from registry key %s.", szValue, szKey);
    exit(1);
}

BOOL fDumpRecords=FALSE;
BOOL fDumpAll=FALSE;
BOOL fDumpColId=FALSE;

ULONG
_cdecl
main(
    IN INT      argc,
    IN PCHAR    argv[]
    )

{
    JET_ERR                 jerr;
    JET_INSTANCE    jinstance;
    JET_SESID               jsesid;
    char                    szBuffer[BUFFER_SIZE];

    char *                  szUserName = "admin";
    char *                  szPassword = "password";



    int nTotalLen;



    jerr = JetSetSystemParameter(&jinstance, 0, JET_paramRecovery, 0, "off");

    if (jerr != JET_errSuccess) {
        printf( "jetwalk: JetSetSystemParameter returned %d\n", jerr );
        return jerr;
    }


    //
    // Open JET session
    //
    TIMECALL(jerr = JetInit(&jinstance));

    if (jerr != JET_errSuccess) {
        printf("JetInit error: %d\n", jerr);
        return jerr;
    }

    //
    // If we fail after here, our caller should go through full shutdown
    // so JetTerm will be called to release any file locks
    //
    NeedShutdown = TRUE;

    if ((jerr = JetBeginSession(jinstance, &jsesid, NULL, NULL))
        != JET_errSuccess) {
        printf("JetBeginSession error: %d\n", jerr);
        return jerr;
    }



    if (argc<2) {
        printf("Usage:%0 [/R] <JetDataBaseName>");
    }

    char* FileName="e:\\ntfrs.jdb";
    for (int i=1;i<argc;i++) {
        if (argv[i][0]=='/') {
            switch(tolower(argv[i][1])) {
                case 'r': fDumpRecords= TRUE; if (isupper(argv[i][1])) fDumpAll=TRUE; break;
                case 'c': fDumpColId=TRUE;break;
            }
        }
        else
        {
            FileName=argv[i];
        }

    }


    printf( "-------------------------------------\n" );
    printf( "DATABASE: %s\n", FileName );
    printf( "-------------------------------------\n" );

    // Attach database
    jerr = JetAttachDatabase(jsesid, FileName, 0);
    if (jerr == JET_errSuccess) {

        // Dump  the database

        jerr = DbStats(jsesid, FileName);

        jerr = JetDetachDatabase(jsesid, FileName );
        if (jerr != JET_errSuccess) {
            printf( "jetwalk: JetDetachDatabase returned %d\n", jerr );
        }

    } else {
        printf("jetwalk: JetAttachDatabase (%s) returned %d\n", FileName, jerr);
    }



    TIMECALL(jerr = JetEndSession(jsesid, 0 ));
    if (jerr != JET_errSuccess) {
        printf( "jetwalk: JetEndSession returned %d\n", jerr );
    }


    jerr = JetTerm( jinstance );
    if (jerr != JET_errSuccess) {
        printf( "jetwalk: JetTerm returned %d\n", jerr );
    }

    return jerr;
}


JET_ERR DbStats( JET_SESID jsesid, char * szDbName )
{
    JET_ERR         jerr;
    JET_DBID        jdbid;
    JET_OBJECTLIST  jobjectlist;
    unsigned long   iTable;
    unsigned long   cTotalPages = 0;
    unsigned long   cPages;

    //
    // Open database
    //
    jerr = JetOpenDatabase( jsesid, szDbName, "", &jdbid, JET_bitDbReadOnly );
    if (jerr != JET_errSuccess) {
        printf( "jetwalk: JetOpenDatabase returned %d\n", jerr );
        goto CLOSEDB;
    }

    jerr = JetGetObjectInfo(
        jsesid,
        jdbid,
        JET_objtypTable,
        NULL,
        NULL,
        &jobjectlist,
        sizeof(jobjectlist),
        JET_ObjInfoListNoStats );

    if (jerr != JET_errSuccess) {
        printf( "jetwalk: JetGetObjectInfo returned %d\n", jerr );
        goto CLOSEDB;
    }

    printf( "Database contains %d tables\n", jobjectlist.cRecord );

    iTable = 1;
    jerr = JetMove( jsesid, jobjectlist.tableid, JET_MoveFirst, 0 );
    while( jerr == JET_errSuccess ) {
        unsigned long   cb;
        unsigned char   rgb[1024];

        jerr = JetRetrieveColumn(
            jsesid,
            jobjectlist.tableid,
            jobjectlist.columnidobjectname,
            rgb,
            sizeof(rgb),
            &cb,
            0, NULL );

        if (jerr != JET_errSuccess) {
            printf( "jetwalk: JetMove returned %d\n", jerr );
            goto CLOSEDB;
        }
        rgb[cb] = '\0';

        TblStats( jsesid, jdbid, iTable++, (char *)rgb, &cPages );

        if (fDumpRecords) {
            DBDumpTable(jsesid,jdbid,(char *)rgb);
        }


        cTotalPages += cPages;

        jerr = JetMove( jsesid, jobjectlist.tableid, JET_MoveNext, 0 );
    }

    if (jerr != JET_errNoCurrentRecord) {
        printf( "jetwalk: JetMove returned %d\n", jerr );
        goto CLOSEDB;
    }

    if ( iTable != jobjectlist.cRecord+1 ) {
        printf( "jetwalk: # of rows didn't match what JET said there were" );
        goto CLOSEDB;
    }

    printf( "Total pages owned in database = %d\n", cTotalPages );


CLOSEDB:
    jerr = JetCloseDatabase( jsesid, jdbid, 0 );
    if (jerr != JET_errSuccess) {
        printf( "jetwalk: JetCloseDatabase returned %d\n", jerr );
    }

    return jerr;
}



void TblStats(
    JET_SESID jsesid,
    JET_DBID jdbid,
    int iTable,
    char *szTblName,
    unsigned long *pcPages
    )
{
        JET_ERR                 jerr;
        JET_TABLEID             jtableid;
        JET_OBJECTINFO  jobjectinfo;
        JET_COLUMNLIST  jcolumnlist;
        JET_INDEXLIST   jindexlist;
        unsigned char   rgb[4096];
        unsigned long   *pul = (unsigned long *)rgb;

        printf( "-------------------------------------\n" );
        printf( "Table #%d: %s\n", iTable, szTblName );
        printf( "-------------------------------------\n" );

        jerr = JetOpenTable( jsesid, jdbid, szTblName, NULL, 0, JET_bitTableReadOnly, &jtableid );
        if (jerr != JET_errSuccess) {
                printf( "jetwalk: JetOpenTable returned %d\n", jerr );
                goto CLOSE_TABLE;
        }

        jerr = JetComputeStats( jsesid, jtableid );
        if (jerr != JET_errSuccess) {
                printf( "jetwalk: JetComputeStats returned %d\n", jerr );
//workaround    goto CLOSE_TABLE;
        }

        jerr = JetGetTableInfo( jsesid, jtableid, &jobjectinfo, sizeof(jobjectinfo), JET_TblInfo );
        if (jerr != JET_errSuccess) {
                printf( "jetwalk: JetGetTableInfo returned %d\n", jerr );
                goto CLOSE_TABLE;
        }

        printf( "cRecord = %d\n", jobjectinfo.cRecord );
        printf( "cPage = %d\n", jobjectinfo.cPage );

        //
        // bugbug - result seems wrong -- check the call.
        //
        jerr = JetGetTableInfo( jsesid, jtableid, rgb, sizeof(rgb), JET_TblInfoSpaceUsage );
        if (jerr != JET_errSuccess) {
                printf( "jetwalk: JetGetTableInfo returned %d\n", jerr );
                goto CLOSE_TABLE;
        }

        printf( "cTotalPagesOwned = %d\n", pul[0] );
        printf( "cTotalPagesAvail = %d\n", pul[1] );

        *pcPages = pul[0];

        jerr = JetGetTableColumnInfo( jsesid, jtableid, NULL, &jcolumnlist, sizeof(jcolumnlist), JET_ColInfoList );
        if (jerr != JET_errSuccess) {
                printf( "jetwalk: JetGetTableColumnInfo returned %d\n", jerr );
                goto CLOSE_TABLE;
        }

        DumpAttributes( jsesid, jcolumnlist);

        jerr = JetCloseTable( jsesid, jcolumnlist.tableid );
        if (jerr != JET_errSuccess) {
                printf( "jetwalk: JetCloseTable returned %d\n", jerr );
                goto CLOSE_TABLE;
        }


        jerr = JetGetTableIndexInfo( jsesid, jtableid, NULL, &jindexlist, sizeof(jindexlist), JET_IdxInfoList );
        if (jerr != JET_errSuccess) {
                printf( "jetwalk: JetGetTableIndexInfo returned %d\n", jerr );
                goto CLOSE_TABLE;
        }

        DumpIndex( jsesid, jindexlist);

        jerr = JetCloseTable( jsesid, jindexlist.tableid );
        if (jerr != JET_errSuccess) {
                printf( "jetwalk: JetCloseTable returned %d\n", jerr );
                goto CLOSE_TABLE;
        }


CLOSE_TABLE:

        jerr = JetCloseTable( jsesid, jtableid );
        if (jerr != JET_errSuccess) {
                printf( "jetwalk: JetCloseTable returned %d\n", jerr );
        }
}




void
DumpIndex(
    JET_SESID jsesid,
    JET_INDEXLIST colinfo
    )
{
    JET_ERR  jerr;
    unsigned long   iRecord;
    JET_RETRIEVECOLUMN rcarray[5];
    DWORD i=0;

/*

typedef struct
        {
        unsigned long   cbStruct;
        JET_TABLEID             tableid;
        unsigned long   cRecord;
        JET_COLUMNID    columnidPresentationOrder;
        JET_COLUMNID    columnidcolumnname;
        JET_COLUMNID    columnidcolumnid;
        JET_COLUMNID    columnidcoltyp;
        JET_COLUMNID    columnidCountry;
        JET_COLUMNID    columnidLangid;
        JET_COLUMNID    columnidCp;
        JET_COLUMNID    columnidCollate;
        JET_COLUMNID    columnidcbMax;
        JET_COLUMNID    columnidgrbit;
        JET_COLUMNID    columnidDefault;
        JET_COLUMNID    columnidBaseTableName;
        JET_COLUMNID    columnidBaseColumnName;
        JET_COLUMNID    columnidDefinitionName;
        } JET_COLUMNLIST;

*/

/*
typedef struct
        {
        unsigned long   cbStruct;
        JET_TABLEID             tableid;
        unsigned long   cRecord;
        JET_COLUMNID    columnidindexname;
        JET_COLUMNID    columnidgrbitIndex;
        JET_COLUMNID    columnidcKey;
        JET_COLUMNID    columnidcEntry;
        JET_COLUMNID    columnidcPage;
        JET_COLUMNID    columnidcColumn;
        JET_COLUMNID    columnidiColumn;
        JET_COLUMNID    columnidcolumnid;
        JET_COLUMNID    columnidcoltyp;
        JET_COLUMNID    columnidCountry;
        JET_COLUMNID    columnidLangid;
        JET_COLUMNID    columnidCp;
        JET_COLUMNID    columnidCollate;
        JET_COLUMNID    columnidgrbitColumn;
        JET_COLUMNID    columnidcolumnname;
        } JET_INDEXLIST;
*/

    printf("-------------------\n   INDEXES \n-------------------\n");

    jerr = JetMove( jsesid, colinfo.tableid, JET_MoveFirst, 0 );

    IListUsed = 0;
    while( jerr == JET_errSuccess ) {

        unsigned long   cb;

        ZeroMemory(rcarray, sizeof(rcarray));

        rcarray[4].pvData   = IList[IListUsed].AttribName;
        rcarray[4].cbData   = sizeof(IList[0].AttribName);
        rcarray[4].columnid = colinfo.columnidindexname;
        rcarray[4].itagSequence = 1;

        rcarray[1].pvData   = &IList[IListUsed].colid;
        rcarray[1].cbData   = sizeof(IList[0].colid);
        rcarray[1].columnid = colinfo.columnidcolumnid;
        rcarray[1].itagSequence = 1;

        rcarray[2].pvData   = &IList[IListUsed].coltyp;
        rcarray[2].cbData   = sizeof(IList[0].coltyp);
        rcarray[2].columnid = colinfo.columnidcoltyp;
        rcarray[2].itagSequence = 1;

        rcarray[3].pvData   = &IList[IListUsed].grbit;
        rcarray[3].cbData   = sizeof(IList[0].grbit);
        rcarray[3].columnid = colinfo.columnidgrbitIndex;
        rcarray[3].itagSequence = 1;

        rcarray[0].pvData   = &IList[IListUsed].key;
        rcarray[0].cbData   = sizeof(IList[0].key);
        rcarray[0].columnid = colinfo.columnidcKey;
        rcarray[0].itagSequence = 1;

        jerr = JetRetrieveColumns(jsesid, colinfo.tableid, rcarray, 5 );

        jerr = JetMove( jsesid, colinfo.tableid, JET_MoveNext, 0 );
        IListUsed++;
    }

    for (i=0;i<IListUsed;i++) {
        printf("%25s %s %08x %3d\n",
               IList[i].AttribName,
               JetColumnTypeNames[IList[i].coltyp],
               IList[i].grbit,
               fDumpColId?IList[i].colid:0);
    }
}



void
DumpAttributes(
    JET_SESID jsesid,
    JET_COLUMNLIST colinfo
    )
{
    JET_ERR  jerr;
    unsigned long  iRecord;
    JET_RETRIEVECOLUMN rcarray[4];
    DWORD i=0;
    unsigned long   cb;

/*

typedef struct
        {
        unsigned long   cbStruct;
        JET_TABLEID             tableid;
        unsigned long   cRecord;
        JET_COLUMNID    columnidPresentationOrder;
        JET_COLUMNID    columnidcolumnname;
        JET_COLUMNID    columnidcolumnid;
        JET_COLUMNID    columnidcoltyp;
        JET_COLUMNID    columnidCountry;
        JET_COLUMNID    columnidLangid;
        JET_COLUMNID    columnidCp;
        JET_COLUMNID    columnidCollate;
        JET_COLUMNID    columnidcbMax;
        JET_COLUMNID    columnidgrbit;
        JET_COLUMNID    columnidDefault;
        JET_COLUMNID    columnidBaseTableName;
        JET_COLUMNID    columnidBaseColumnName;
        JET_COLUMNID    columnidDefinitionName;
        } JET_COLUMNLIST;

*/


    jerr = JetMove( jsesid, colinfo.tableid, JET_MoveFirst, 0 );

    AListUsed = 0;
        while( jerr == JET_errSuccess ) {


        ZeroMemory(rcarray, sizeof(rcarray));

        rcarray[0].pvData   = AList[AListUsed].AttribName;
        rcarray[0].cbData   = sizeof(AList[0].AttribName);
        rcarray[0].columnid = colinfo.columnidcolumnname;
        rcarray[0].itagSequence = 1;

        rcarray[1].pvData   = &AList[AListUsed].colid;
        rcarray[1].cbData   = sizeof(AList[0].colid);
        rcarray[1].columnid = colinfo.columnidcolumnid;
        rcarray[1].itagSequence = 1;

        rcarray[2].pvData   = &AList[AListUsed].coltyp;
        rcarray[2].cbData   = sizeof(AList[0].coltyp);
        rcarray[2].columnid = colinfo.columnidcoltyp;
        rcarray[2].itagSequence = 1;

        rcarray[3].pvData   = &AList[AListUsed].grbit;
        rcarray[3].cbData   = sizeof(AList[0].grbit);
        rcarray[3].columnid = colinfo.columnidgrbit;
        rcarray[3].itagSequence = 1;

        jerr = JetRetrieveColumns(jsesid, colinfo.tableid, rcarray, 4);

        jerr = JetMove( jsesid, colinfo.tableid, JET_MoveNext, 0 );
        AListUsed++;
    }


    int next=0;
    for (i=0;i<AListUsed;i++)
    {
        printf("%25s %s %08x %3d\n",
               AList[i].AttribName,
               JetColumnTypeNames[AList[i].coltyp],
               AList[i].grbit,
               fDumpColId?AList[i].colid:0);

        List[next]=i;
        AList[i].Display=TRUE;

        //
        // If it's a favorite stick it out first in the record dump.
        //
        if (strcmp(AList[i].AttribName,"FileName")==0) {
            List[next] = List[0];  List[0] = i;
        }
        else if (strcmp(AList[i].AttribName,"VersionNumber")==0) {
            List[next] = List[1];  List[1]=i;
        }
        else if (strcmp(AList[i].AttribName,"FileGuid")==0) {
            List[next] = List[2];  List[2]=i;
        }
        else if (strcmp(AList[i].AttribName,"FileID")==0) {
            List[next] = List[3];  List[3]=i;
        }
        else if (strcmp(AList[i].AttribName,"EventTime")==0) {
            List[next] = List[4];  List[4]=i;
        }
        else if (strcmp(AList[i].AttribName,"FileWriteTime")==0) {
            List[next] = List[5];  List[5]=i;
        }
        else if (strcmp(AList[i].AttribName,"ParentGuid")==0) {
            List[next] = List[6];  List[6]=i;
        }
        else if (strcmp(AList[i].AttribName,"ParentFileID")==0) {
            List[next] = List[7];  List[7]=i;
        }

        next += 1;

    }
}


void DBDumpTable(
    JET_SESID jsesid,
    JET_DBID jdbid,
    char * szTbName
    )
{
    JET_ERR jerr;
    JET_TABLEID jtid;

    jerr = JetOpenTable(jsesid, jdbid, szTbName, NULL, 0, 0, &jtid);
    if (jerr != JET_errSuccess) {
        printf( "DBDumpTable: JetOpenTable returned %d\n", jerr );
        goto CLOSE_TABLE;
    }

    jerr = JetMove( jsesid, jtid, JET_MoveFirst, 0 );

    while (!jerr) {
        DBDumpRecord( jsesid,jtid);
        jerr = JetMove( jsesid, jtid, JET_MoveNext, 0 );
    }

CLOSE_TABLE:

    jerr = JetCloseTable( jsesid, jtid );
    if (jerr != JET_errSuccess) {
        printf( "DBDumpTable: JetCloseTable returned %d\n", jerr );
    }

    return;
}


char*
PVoidToStr(
    PVOID obuff,
    JET_COLTYP coltyp,
    DWORD cbActual
    )
{
    static char buff[512];
    ULONG data;
    LONGLONG lidata;

    ZeroMemory(buff,sizeof(buff));

    switch (coltyp) {

        case JET_coltypNil:
            sprintf(buff,"%s","NULL ");
            break;

        case JET_coltypBit:
            data = (ULONG) *(PCHAR)obuff;
            sprintf(buff," %d ", data);
            break;

        case JET_coltypUnsignedByte:
            sprintf(buff," %d ", *(DWORD*)obuff);
            break;

        case JET_coltypShort:
            sprintf(buff," %d ", *(DWORD*)obuff);
            break;

        case JET_coltypLong:
            sprintf(buff," %d ", *( DWORD *) obuff);
            break;

        case JET_coltypCurrency:
            CopyMemory(&lidata, obuff, 8);
            sprintf(buff," %12Ld ", lidata);
            break;

        case JET_coltypIEEESingle:
            sprintf(buff," %s ", "???");
            break;

        case JET_coltypIEEEDouble:
            sprintf(buff," %s ", "???");
            break;

        case JET_coltypDateTime:
            CopyMemory(&lidata, obuff, 8);
            sprintf(buff," %12Ld ", lidata);
            break;

        case JET_coltypBinary:
            sprintf(buff," %s ", "???");
            break;

    case JET_coltypText:
            sprintf(buff," %*.*ws ",cbActual, cbActual, ( WCHAR *) obuff);
            //sprintf(buff," %25ws ", (WCHAR*)obuff);
            break;

        case JET_coltypLongBinary:
            sprintf(buff," %25ws ", "???");
            break;

        case JET_coltypLongText:
            sprintf(buff," %25ws ", (WCHAR*)obuff);
            break;

        case JET_coltypMax:
            sprintf(buff," %s ", "???");
            break;

        default:
            sprintf(buff,"UNKNOWN %d ", coltyp);
   }

   return buff;
}


void DBDumpRecord( JET_SESID jsesid,JET_TABLEID jtid)
{
    JET_RETINFO ri;

    DWORD i;
    char obuff[2048];
    JET_ERR jerr;
    DWORD cbActual;
    char recbuff[2048];
    char* ptr=recbuff;

    ZeroMemory(&ri,sizeof(ri));

    for (i=0;i<AListUsed;i++)
    {
        if (!fDumpAll && !AList[List[i]].Display) {
            continue;
        }

        jerr = JetRetrieveColumn (
            jsesid,
            jtid,
            AList[List[i]].colid,
            obuff,
            sizeof(obuff),
            &cbActual,
            0,
            NULL);

        if (jerr != 0) {
            continue;
        }

        ptr += sprintf(ptr,"%s = %s",
                       AList[List[i]].AttribName,
                       PVoidToStr(obuff,AList[List[i]].coltyp,cbActual));
    }

    *ptr='\0';

    printf(">>%s\n",recbuff);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\util\config.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    config.c

Abstract:

    GetConfigParam reads a configuration keyword from the registry.

Author:

    David Orbits - June-1999  Complete Rewrite to make table driven.

Environment:


Revision History:

--*/

#include <ntreppch.h>
#pragma  hdrstop

#include <ctype.h>
#include <frs.h>
#include <ntfrsapi.h>

#define FULL_KEY_BUFF_SIZE  8192

VOID
FrsRegPostEventLog(
    IN  PFRS_REGISTRY_KEY KeyCtx,
    IN  PWCHAR            KeyArg1,
    IN  ULONG             Flags,
    IN  LONG              IDScode
);

//
// Possible errors are:
//      required key not present
//      required value not present
//      value out of range

//
// **** NOTE:  Also use this for FRS tuning parameters to select between
// workstation and server operation modes.  Create a table with a list of the
// parameter codes and override values for the min, max and defaults.
// Apply during startup to reduce server footprint.
//


typedef struct _FRS_REG_KEY_REVISIONS {

    LONG            FrsKeyCode;      // Frs code name for this key.

    DWORD           ValueMin;        // Minimum data value, or string len
    DWORD           ValueMax;        // Maximum Data value, or string len
    DWORD           ValueDefault;    // Default data value if not present.
} FRS_REG_KEY_REVISIONS, *PFRS_REG_KEY_REVISIONS;


FRS_REG_KEY_REVISIONS FrsRegKeyRevisionTable[] = {

    {FKC_DEBUG_LOG_FILES        , 0     , 8,        2          },
    {FKC_DEBUG_LOG_SEVERITY     , 0     , 5,        0          },
    {FKC_DEBUG_MAX_LOG          , 0     , MAXULONG, 10000      },
    {FKC_MAX_REPLICA_THREADS    , 2     , 10,       2          },
    {FKC_MAX_RPC_SERVER_THREADS , 2     , 10,       2          },
    {FKC_MAX_INSTALLCS_THREADS  , 2     , 10,       2          },
    {FKC_MAX_STAGE_GENCS_THREADS, 2     , 10,       2          },
    {FKC_MAX_STAGE_FETCHCS_THREADS, 2   , 10,       2          },
    {FKC_MAX_INITSYNCCS_THREADS,  2     , 10,       2          },
    {FKC_SNDCS_MAXTHREADS_PAR   , 2     , 10,       2          },
    {FKC_STAGING_LIMIT          , 2*1024, 64*1024,  16*1024    },
    {FKC_NTFS_JRNL_SIZE         , 1     , 128,      8          },
    {FKC_MAX_NUMBER_REPLICA_SETS, 1     , 30,       5          },
    {FKC_MAX_NUMBER_JET_SESSIONS, 1     , 50,       50         },

    {FKC_END_OF_TABLE, 0, 0, 0 }
};

//
// See sdk\inc\ntconfig.h if more registry data types are added.
//

#define NUMBER_OF_REG_DATATYPES 12

PWCHAR RegDataTypeNames[NUMBER_OF_REG_DATATYPES] = {

L"REG_NONE"                       , // ( 0 )   No value type
L"REG_SZ"                         , // ( 1 )   Unicode nul terminated string
L"REG_EXPAND_SZ"                  , // ( 2 )   Unicode nul terminated string (with environment variable references)
L"REG_BINARY"                     , // ( 3 )   Free form binary
L"REG_DWORD"                      , // ( 4 )   32-bit number
L"REG_DWORD_BIG_ENDIAN"           , // ( 5 )   32-bit number
L"REG_LINK"                       , // ( 6 )   Symbolic Link (unicode)
L"REG_MULTI_SZ"                   , // ( 7 )   Multiple Unicode strings
L"REG_RESOURCE_LIST"              , // ( 8 )   Resource list in the resource map
L"REG_FULL_RESOURCE_DESCRIPTOR"   , // ( 9 )   Resource list in the hardware description
L"REG_RESOURCE_REQUIREMENTS_LIST" , // ( 10 )
L"REG_QWORD"                        // ( 11 )  64-bit number
};

#define REG_DT_NAME(_code_)                                                \
    (((_code_) < NUMBER_OF_REG_DATATYPES) ?                                \
         RegDataTypeNames[(_code_)] : RegDataTypeNames[0])

//
//
// If a range check fails the event EVENT_FRS_PARAM_OUT_OF_RANGE is logged if
// FRS_RKF_LOG_EVENT is set.
//
// If a syntax check fails the event EVENT_FRS_PARAM_INVALID_SYNTAX is logged if
// FRS_RKF_LOG_EVENT is set.
//
// If a required parameter is missing the event EVENT_FRS_PARAM_MISSING is logged
// if FRS_RKF_LOG_EVENT is set.
//

BOOL Win2kPro;


FLAG_NAME_TABLE RkfFlagNameTable[] = {
    {FRS_RKF_KEY_PRESENT            , "KeyPresent "         },
    {FRS_RKF_VALUE_PRESENT          , "ValuePresent "       },
    {FRS_RKF_DISPLAY_ERROR          , "ShowErrorMsg "       },
    {FRS_RKF_LOG_EVENT              , "ShowEventMsg "       },

    {FRS_RKF_READ_AT_START          , "ReadAtStart "        },
    {FRS_RKF_READ_AT_POLL           , "ReadAtPoll "         },
    {FRS_RKF_RANGE_CHECK            , "RangeCheck "         },
    {FRS_RKF_SYNTAX_CHECK           , "SyntaxCheck "        },

    {FRS_RKF_KEY_MUST_BE_PRESENT    , "KeyMustBePresent "   },
    {FRS_RKF_VALUE_MUST_BE_PRESENT  , "ValueMustBePresent " },
    {FRS_RKF_OK_TO_USE_DEFAULT      , "DefaultOK "          },
    {FRS_RKF_FORCE_DEFAULT_VALUE    , "ForceDefault "       },

    {FRS_RKF_DEBUG_MODE_ONLY        , "DebugMode "          },
    {FRS_RKF_TEST_MODE_ONLY         , "TestMode "           },
    {FRS_RKF_API_ACCESS_CHECK_KEY   , "DoAPIAccessChk "     },
    {FRS_RKF_CREATE_KEY             , "CreateKey "          },

    {FRS_RKF_KEEP_EXISTING_VALUE    , "KeepExistingValue "  },
    {FRS_RKF_KEY_ACCCHK_READ        , "DoReadAccessChk "    },
    {FRS_RKF_KEY_ACCCHK_WRITE       , "DoWriteAccessChk "   },
    {FRS_RKF_RANGE_SATURATE         , "RangeSaturate "      },

    {FRS_RKF_DEBUG_PARAM            , "DisplayAsDebugPar "  },

    {0, NULL}
};


//
// The following describes the registry keys used by FRS.
//      KeyName  ValueName DataUnits
//      RegValueType   DataValueType  Min  Max  Default  EventCode
//            FrsKeyCode  Flags
//
//
// Notation for keyName field.  Multiple key components separated by commas.
// Break on commas.  Open leading key then create/open each successive component.
// ARG1 means substitute the Arg1 PWSTR parameter passed to the function for this
// key component.  Most often this is a stringized guid.  The string FRS_RKEY_SET_N
// below will end up opening/creating the following key:
//
// "System\\CurrentControlSet\\Services\\NtFrs\\Parameters\\Replica Sets\\27d6d1c4-d6b8-480b-9f18b5ea390a0178"
// assuming the argument passed in was "27d6d1c4-d6b8-480b-9f18b5ea390a0178"
//
// see FrsRegOpenKey() for details.
//

FRS_REGISTRY_KEY FrsRegistryKeyTable[] = {


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                S e r v i c e   D e b u g   K e y s                        **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/


    //   Number of assert files
    {FRS_CONFIG_SECTION,  L"Debug Assert Files",       UNITS_NONE,
        REG_DWORD, DT_ULONG, 0, 1000, 5, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DEBUG_ASSERT_FILES,     FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //   Force an assert after N seconds (0 == don't assert)
    {FRS_CONFIG_SECTION,  L"Debug Force Assert in N Seconds",     UNITS_SECONDS,
        REG_DWORD, DT_ULONG, 0, 1000, 0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DEBUG_ASSERT_SECONDS,   FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT |
                                        FRS_RKF_TEST_MODE_ONLY},


    //   Share for copying log/assert files
    {FRS_CONFIG_SECTION,  L"Debug Share for Assert Files",       UNITS_NONE,
        REG_SZ, DT_UNICODE, 0, 0, 0, EVENT_FRS_NONE, NULL,
            FKC_DEBUG_ASSERT_SHARE,     FRS_RKF_READ_AT_START     |
                                        FRS_RKF_DEBUG_PARAM},


    //   If TRUE, Break into the debugger, if present
    {FRS_CONFIG_SECTION,  L"Debug Break",              UNITS_NONE,
        REG_DWORD, DT_BOOL, FALSE, TRUE, FALSE,   EVENT_FRS_NONE, NULL,
            FKC_DEBUG_BREAK,            FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_TEST_MODE_ONLY    |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //   If TRUE, copy log files into assert share
    {FRS_CONFIG_SECTION,  L"Debug Copy Log Files into Assert Share",     UNITS_NONE,
        REG_DWORD, DT_BOOL, FALSE, TRUE, FALSE,   EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DEBUG_COPY_LOG_FILES,   FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //   Force real out of disk space errors on database operations
    {FRS_CONFIG_SECTION,  L"Debug Dbs Out Of Space",   UNITS_NONE,
        REG_DWORD, DT_ULONG, 0, DBG_DBS_OUT_OF_SPACE_OP_MAX,  0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DEBUG_DBS_OUT_OF_SPACE,  FRS_RKF_READ_AT_START     |
                                         FRS_RKF_LOG_EVENT         |
                                         FRS_RKF_READ_AT_POLL      |
                                         FRS_RKF_TEST_MODE_ONLY    |
                                         FRS_RKF_RANGE_CHECK       |
                                         FRS_RKF_DEBUG_PARAM       |
                                         FRS_RKF_OK_TO_USE_DEFAULT},


    //   Force Jet Err simulated out of disk space errors on database operations
    {FRS_CONFIG_SECTION,  L"Debug Dbs Out Of Space Trigger",   UNITS_NONE,
        REG_DWORD, DT_ULONG, 0, MAXULONG,  0,   EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DEBUG_DBS_OUT_OF_SPACE_TRIGGER, FRS_RKF_READ_AT_START     |
                                                FRS_RKF_LOG_EVENT         |
                                                FRS_RKF_READ_AT_POLL      |
                                                FRS_RKF_TEST_MODE_ONLY    |
                                                FRS_RKF_DEBUG_PARAM       |
                                                FRS_RKF_OK_TO_USE_DEFAULT},


    //   If TRUE, debug log file generation (DPRINTS and CO Trace output) is off.
    {FRS_CONFIG_SECTION,  L"Debug Disable",            UNITS_NONE,
        REG_DWORD, DT_BOOL, FALSE, TRUE, FALSE,   EVENT_FRS_NONE, NULL,
            FKC_DEBUG_DISABLE,          FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //   The directory path for the FRS debug logs.
    {FRS_CONFIG_SECTION,  L"Debug Log File",           UNITS_NONE,
        REG_EXPAND_SZ, DT_UNICODE, 0, 0, 0, EVENT_FRS_BAD_REG_DATA,
        L"%SystemRoot%\\debug",
            FKC_DEBUG_LOG_FILE,         FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_SYNTAX_CHECK      |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //   Number of debug log files to keep as history
    {FRS_CONFIG_SECTION,  L"Debug Log Files",          UNITS_NONE,
        REG_DWORD, DT_ULONG, 0, 300, 5, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DEBUG_LOG_FILES,        FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //   Number of debug log records written between file flushes.
    //   btw:  Severity 0 log records always force a log file flush.
    {FRS_CONFIG_SECTION,  L"Debug Log Flush Interval",       UNITS_NONE,
        REG_DWORD, DT_LONG, 1, MAXLONG, 20000, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DEBUG_LOG_FLUSH_INTERVAL, FRS_RKF_READ_AT_START     |
                                          FRS_RKF_LOG_EVENT         |
                                          FRS_RKF_RANGE_CHECK       |
                                          FRS_RKF_DEBUG_PARAM       |
                                          FRS_RKF_OK_TO_USE_DEFAULT},


    //   Print debug msgs with severity level LE DEBUG_LOG_SEVERITY to debug log.
    // 0 - Most severe, eg. fatal inconsistency, mem alloc fail. Least noisey.
    // 1 - Important info, eg. Key config parameters, unexpected conditions
    // 2 - File tracking records.
    // 3 - Change Order Process trace records.
    // 4 - Status results, e.g. table lookup failures, new entry inserted
    // 5 - Information level messages to show flow.  Noisest level. Maybe in a loop
    // see also DEBUG_SEVERITY.
    {FRS_CONFIG_SECTION,  L"Debug Log Severity",       UNITS_NONE,
        REG_DWORD, DT_ULONG, 0, 5,      2, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DEBUG_LOG_SEVERITY,     FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //   Max number of debug log messages output before opening a new log file.
    {FRS_CONFIG_SECTION,  L"Debug Maximum Log Messages",            UNITS_NONE,
        REG_DWORD, DT_ULONG, 0, MAXULONG, 20000, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DEBUG_MAX_LOG,          FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //   If >0, then track and check all mem alloc / dealloc.  (slow)
    //     1 - checks allocs and frees and prints stack of unalloced mem at exit
    //     2 - checks for mem alloc region overwrite on each alloc/free - very slow.
    //
    {FRS_CONFIG_SECTION,  L"Debug Mem",                UNITS_NONE,
        REG_DWORD, DT_ULONG, 0,      4,      0,   EVENT_FRS_NONE, NULL,
            FKC_DEBUG_MEM,              FRS_RKF_READ_AT_START     |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_TEST_MODE_ONLY    |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //   If TRUE, then call HeapCompact(GetProcessHeap(), 0) on mem dealloc.  (slower)
    {FRS_CONFIG_SECTION,  L"Debug Mem Compact",        UNITS_NONE,
        REG_DWORD, DT_BOOL, FALSE, TRUE, FALSE,   EVENT_FRS_NONE, NULL,
            FKC_DEBUG_MEM_COMPACT,      FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_TEST_MODE_ONLY    |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //   Mail profile for sending mail notifications.  (future)
    {FRS_CONFIG_SECTION,  L"Debug Profile",           UNITS_NONE,
        REG_SZ, DT_UNICODE, 0, 0, 0, EVENT_FRS_NONE, NULL,
            FKC_DEBUG_PROFILE,          FRS_RKF_READ_AT_START     |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_READ_AT_POLL},


    //   If TRUE, then check consistency of command queues on each queue op.  (slow)
    {FRS_CONFIG_SECTION,  L"Debug Queues",            UNITS_NONE,
        REG_DWORD, DT_BOOL, FALSE, TRUE, FALSE,   EVENT_FRS_NONE, NULL,
            FKC_DEBUG_QUEUES,           FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_TEST_MODE_ONLY    |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //   Mail recipients for sending mail notifications.  (future)
    {FRS_CONFIG_SECTION,  L"Debug Recipients",        UNITS_NONE,
        REG_EXPAND_SZ, DT_UNICODE, 0, 0, 0, EVENT_FRS_NONE, NULL,
            FKC_DEBUG_RECIPIENTS,       FRS_RKF_READ_AT_START     |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_READ_AT_POLL},


    // Restart the service after an assertion failure iff the service was able
    // to run for at least DEBUG_RESTART_SECONDS before the assert hit.
    {FRS_CONFIG_SECTION,  L"Debug Restart if Assert after N Seconds",   UNITS_SECONDS,
        REG_DWORD, DT_ULONG, 0, MAXULONG, 600, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DEBUG_RESTART_SECONDS,  FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Print debug msgs with severity level LE DEBUG_SEVERITY to
    // stdout if running as -notservice.
    // see also DEBUG_LOG_SEVERITY.
    {FRS_CONFIG_SECTION,  L"Debug Severity",          UNITS_NONE,
        REG_DWORD, DT_ULONG, 0, 5,      0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DEBUG_SEVERITY,         FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // If FALSE, Print debug msgs with severity level LE DEBUG_SEVERITY to
    // an attached debugger.                                 (slow)
    // see also DEBUG_LOG_SEVERITY.
    {FRS_CONFIG_SECTION,  L"Debug Suppress",          UNITS_NONE,
        REG_DWORD, DT_BOOL, FALSE, TRUE, TRUE,   EVENT_FRS_NONE, NULL,
            FKC_DEBUG_SUPPRESS,         FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //  Suppress debug prints from components in the DEBUG_SYSTEMS list.
    //  default is all components print.
    {FRS_CONFIG_SECTION,  L"Debug Systems",         UNITS_NONE,
        REG_EXPAND_SZ, DT_UNICODE, 0, 0, 0, EVENT_FRS_NONE, NULL,
            FKC_DEBUG_SYSTEMS,          FRS_RKF_READ_AT_START     |
                                        FRS_RKF_DEBUG_PARAM       |
                                        FRS_RKF_READ_AT_POLL},


    // hklm\software\microsoft\windows nt\current version\buildlab
    {FRS_CURRENT_VER_SECTION,  L"buildlab",         UNITS_NONE,
        REG_SZ,  DT_UNICODE, 0, 0, 0,   EVENT_FRS_NONE, NULL,
            FKC_DEBUG_BUILDLAB,         FRS_RKF_READ_AT_START     |
                                        FRS_RKF_DEBUG_PARAM},


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **               S e r v i c e   C o n f i g   K e y s                       **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

#define FRS_MUTUAL_AUTHENTICATION_IS  \
    L"Mutual authentication is [" FRS_IS_ENABLED L" or " FRS_IS_DISABLED L"]"



    //  Comm Timeout In Milliseconds
    // Unjoin the cxtion if the partner doesn't respond soon enough
    {FRS_CONFIG_SECTION,    L"Comm Timeout In Milliseconds",    UNITS_MILLISEC,
        REG_DWORD, DT_ULONG, 0, MAXULONG, (5 * 60 * 1000),  EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_COMM_TIMEOUT,           FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //  The directory filter exclusion list.   Default:  None
    //  Don't supply a default here.  See FRS_DS_COMPOSE_FILTER_LIST for why.
    {FRS_CONFIG_SECTION,    L"Directory Exclusion Filter List",   UNITS_NONE,
        REG_SZ, DT_FILE_LIST, 0, 0, 0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DIR_EXCL_FILTER_LIST,   FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_SYNTAX_CHECK      |
                                        FRS_RKF_READ_AT_POLL},


    //  The directory filter inclusion list.         Default:  None
    {FRS_CONFIG_SECTION,    L"Directory Inclusion Filter List",     UNITS_NONE,
        REG_SZ, DT_FILE_LIST, 0, 0, 0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DIR_INCL_FILTER_LIST,   FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_SYNTAX_CHECK      |
                                        FRS_RKF_CREATE_KEY        |
                                        FRS_RKF_OK_TO_USE_DEFAULT |
                                        FRS_RKF_READ_AT_POLL},


    //  Minutes between polls of the DS when data does not appear to be changing.
    {FRS_CONFIG_SECTION,   L"DS Polling Long Interval in Minutes", UNITS_MINUTES,
        REG_DWORD, DT_ULONG, NTFRSAPI_MIN_INTERVAL, NTFRSAPI_MAX_INTERVAL,
                             NTFRSAPI_DEFAULT_LONG_INTERVAL, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DS_POLLING_LONG_INTERVAL, FRS_RKF_READ_AT_START     |
                                          FRS_RKF_READ_AT_POLL      |
                                          FRS_RKF_LOG_EVENT         |
                                          FRS_RKF_RANGE_CHECK       |
                                          FRS_RKF_OK_TO_USE_DEFAULT},


    //  Minutes between polls of the DS when data does appear to be changing.
    //  If no data in the DS has changed after 8 (DS_POLLING_MAX_SHORTS) short
    //  polling intervals then we fall back to DS_POLLING_LONG_INTERVAL.
    //  Note: if FRS is running on a DC always use the short interval.
    {FRS_CONFIG_SECTION,   L"DS Polling Short Interval in Minutes", UNITS_MINUTES,
        REG_DWORD, DT_ULONG, NTFRSAPI_MIN_INTERVAL, NTFRSAPI_MAX_INTERVAL,
                             NTFRSAPI_DEFAULT_SHORT_INTERVAL, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DS_POLLING_SHORT_INTERVAL, FRS_RKF_READ_AT_START     |
                                           FRS_RKF_READ_AT_POLL      |
                                           FRS_RKF_LOG_EVENT         |
                                           FRS_RKF_RANGE_CHECK       |
                                           FRS_RKF_OK_TO_USE_DEFAULT},


    //  Enumerate Directory Buffer Size in Bytes  (WHY DO WE NEED THIS???)
    {FRS_CONFIG_SECTION, L"Enumerate Directory Buffer Size in Bytes", UNITS_BYTES,
        REG_DWORD, DT_ULONG, MINIMUM_ENUMERATE_DIRECTORY_SIZE, 1024*1024, 4*1024, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_ENUMERATE_DIRECTORY_SIZE, FRS_RKF_READ_AT_START     |
                                          FRS_RKF_READ_AT_POLL      |
                                          FRS_RKF_LOG_EVENT         |
                                          FRS_RKF_RANGE_CHECK       |
                                          FRS_RKF_OK_TO_USE_DEFAULT},


    //  The file filter exclusion list.
    //  Don't supply a default here.  See FRS_DS_COMPOSE_FILTER_LIST for why.
    {FRS_CONFIG_SECTION,    L"File Exclusion Filter List",    UNITS_NONE,
        REG_SZ, DT_FILE_LIST, 0, 0, 0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_FILE_EXCL_FILTER_LIST,  FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_READ_AT_POLL},


    //  The file filter inclusion list.            Default:  L""
    {FRS_CONFIG_SECTION,    L"File Inclusion Filter List",     UNITS_NONE,
        REG_SZ, DT_FILE_LIST, 0, 0, 0, EVENT_FRS_BAD_REG_DATA,  L"",
            FKC_FILE_INCL_FILTER_LIST,  FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_SYNTAX_CHECK      |
                                        FRS_RKF_CREATE_KEY        |
                                        FRS_RKF_OK_TO_USE_DEFAULT |
                                        FRS_RKF_READ_AT_POLL},


    //  The name of the FRS eventlog message file.
    //      Default value: "%SystemRoot%\system32\ntfrsres.dll"
    // WHY DO WE NEED TO BE ABLE TO CHANGE THIS???
    {FRS_CONFIG_SECTION,    L"Message File Path",        UNITS_NONE,
        REG_EXPAND_SZ, DT_UNICODE, 2, 0, 0, EVENT_FRS_NONE,
        DEFAULT_MESSAGE_FILE_PATH,
            FKC_FRS_MESSAGE_FILE_PATH,  FRS_RKF_READ_AT_START     |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    //  Mutual authentication is [Enabled or Disabled]
    {FRS_CONFIG_SECTION,   FRS_MUTUAL_AUTHENTICATION_IS,       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 200, 0, EVENT_FRS_NONE,
        FRS_IS_DEFAULT_ENABLED,
            FKC_FRS_MUTUAL_AUTHENTICATION_IS,  FRS_RKF_READ_AT_START         |
                                               FRS_RKF_RANGE_CHECK           |
                                               FRS_RKF_VALUE_MUST_BE_PRESENT},


    // Maximum Join Retry time In MilliSeconds             Default: 1 hr.
    {FRS_CONFIG_SECTION,  L"Maximum Join Retry In MilliSeconds",  UNITS_MILLISEC,
        REG_DWORD, DT_ULONG, 30*1000, 10*3600*1000, (60 * 60 * 1000), EVENT_FRS_NONE, NULL,
            FKC_MAX_JOIN_RETRY,         FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Maximum Replica Command Server Threads              Default:  16
    // The replica command server services commands for configuration changes
    // and replication.
    {FRS_CONFIG_SECTION,  L"Maximum Replica Command Server Threads",  UNITS_NONE,
        REG_DWORD, DT_ULONG, 2, 200, (16), EVENT_FRS_NONE, NULL,
            FKC_MAX_REPLICA_THREADS,    FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Max Rpc Server Threads                              Default:  16
    // Maximum number of concurrent RPC calls
    {FRS_CONFIG_SECTION,   L"Max Rpc Server Threads",    UNITS_NONE,
        REG_DWORD, DT_ULONG, 2, 200, (16), EVENT_FRS_NONE, NULL,
            FKC_MAX_RPC_SERVER_THREADS, FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Maximum Install Command Server Threads              Default:  4
    {FRS_CONFIG_SECTION,    L"Maximum Install Command Server Threads",  UNITS_NONE,
        REG_DWORD, DT_ULONG, 2, 200, (4), EVENT_FRS_NONE, NULL,
            FKC_MAX_INSTALLCS_THREADS,  FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Maximum Stage Gen Command Server Threads              Default:  4
    {FRS_CONFIG_SECTION,    L"Maximum Stage Gen Command Server Threads",  UNITS_NONE,
        REG_DWORD, DT_ULONG, 2, 200, (4), EVENT_FRS_NONE, NULL,
            FKC_MAX_STAGE_GENCS_THREADS,  FRS_RKF_READ_AT_START     |
                                          FRS_RKF_READ_AT_POLL      |
                                          FRS_RKF_RANGE_CHECK       |
                                          FRS_RKF_OK_TO_USE_DEFAULT},


    // Maximum Stage Fetch Command Server Threads            Default:  4
    {FRS_CONFIG_SECTION,    L"Maximum Stage Fetch Command Server Threads",  UNITS_NONE,
        REG_DWORD, DT_ULONG, 2, 200, (4), EVENT_FRS_NONE, NULL,
            FKC_MAX_STAGE_FETCHCS_THREADS,  FRS_RKF_READ_AT_START     |
                                            FRS_RKF_READ_AT_POLL      |
                                            FRS_RKF_RANGE_CHECK       |
                                            FRS_RKF_OK_TO_USE_DEFAULT},


    // Maximum Initial SYnc Command Server Threads            Default:  4
    {FRS_CONFIG_SECTION,    L"Maximum Initial Sync Command Server Threads",  UNITS_NONE,
        REG_DWORD, DT_ULONG, 2, 200, (4), EVENT_FRS_NONE, NULL,
            FKC_MAX_INITSYNCCS_THREADS,  FRS_RKF_READ_AT_START     |
                                            FRS_RKF_READ_AT_POLL      |
                                            FRS_RKF_RANGE_CHECK       |
                                            FRS_RKF_OK_TO_USE_DEFAULT},


    // Minimum Join Retry time In MilliSeconds             Default:  10 sec.
    // Retry a join every MinJoinRetry milliseconds, doubling the interval
    // every retry. Stop retrying when the interval is greater than MaxJoinRetry.
    {FRS_CONFIG_SECTION,  L"Minimum Join Retry In MilliSeconds", UNITS_MILLISEC,
        REG_DWORD, DT_ULONG, 500, 10*3600*1000, (10 * 1000),   EVENT_FRS_NONE, NULL,
            FKC_MIN_JOIN_RETRY,         FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Partner Clock Skew In Minutes                       Default:  30 min.
    // Partners are not allowed to join if their clocks are out-of-sync
    {FRS_CONFIG_SECTION,  L"Partner Clock Skew In Minutes",     UNITS_MINUTES,
        REG_DWORD, DT_ULONG, 1, 10*60, 30,      EVENT_FRS_NONE, NULL,
            FKC_PARTNER_CLOCK_SKEW,     FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // ChangeOrder Reconcile Event Time Window In Minutes   Default:  30 min.
    {FRS_CONFIG_SECTION,  L"Reconcile Time Window In Minutes", UNITS_MINUTES,
        REG_DWORD, DT_ULONG, 1, 120, 30,      EVENT_FRS_NONE, NULL,
            FKC_RECONCILE_WINDOW,       FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // ChangeOrder Inlog retry interval in seconds   Default:  60 sec.
    {FRS_CONFIG_SECTION,  L"Inlog Retry Time In Seconds", UNITS_SECONDS,
        REG_DWORD, DT_ULONG, 1, 24*3600, 60,  EVENT_FRS_NONE, NULL,
            FKC_INLOG_RETRY_TIME,       FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // ChangeOrder Aging Delay in seconds   Default:  3 sec.
    // Should be a min of 3 sec to allow file system tunnel cache info to propagate.
    {FRS_CONFIG_SECTION,  L"Changeorder Aging Delay In Seconds", UNITS_SECONDS,
        REG_DWORD, DT_ULONG, 3, 30*60, 3,     EVENT_FRS_NONE, NULL,
            FKC_CO_AGING_DELAY,         FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Outlog File Repeat Interval In Seconds   Default:  30 sec.
    // A CO update for a given file will not be sent out more frequently than this.
    // Set to zero to disable the Outlog dominant file update optimization.
    {FRS_CONFIG_SECTION,  L"Outlog File Repeat Interval In Seconds", UNITS_SECONDS,
        REG_DWORD, DT_ULONG, 0, 24*3600, 30,  EVENT_FRS_NONE, NULL,
            FKC_OUTLOG_REPEAT_INTERVAL, FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Sysvol Promotion Timeout In Milliseconds            Default:  10 min.
    {FRS_CONFIG_SECTION,  L"Sysvol Promotion Timeout In Milliseconds",  UNITS_MILLISEC,
        REG_DWORD, DT_ULONG, 0, 3600*1000, (10 * 60 * 1000),   EVENT_FRS_NONE, NULL,
            FKC_PROMOTION_TIMEOUT,      FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Replica Start Timeout In MilliSeconds   Default:  0 means can't start without DS.
    // Start replication even if the DS could not be accessed
    //     0: no DS == no start replicas
    //     N: start replicas in N milliseconds
    {FRS_CONFIG_SECTION,   L"Replica Start Timeout In MilliSeconds", UNITS_MILLISEC,
        REG_DWORD, DT_ULONG, 0, 3600*1000, (0),   EVENT_FRS_NONE, NULL,
            FKC_REPLICA_START_TIMEOUT,  FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Replica Tombstone in Days              Default:  32
    // The length of time we will hold onto the database state for a replica
    // set after we see our membership in the DS has been deleted.  Since
    // delete is not explicit (except for DC Demote) it may just be that the
    // DC is missing our objects or an admin erroneously deleted our subscriber
    // or member object.  Once this time has lapsed we will delete the tables
    // from the database.
    {FRS_CONFIG_SECTION,   L"Replica Tombstone in Days",      UNITS_DAYS,
        REG_DWORD, DT_ULONG, 3, MAXULONG, (32),   EVENT_FRS_NONE, NULL,
            FKC_REPLICA_TOMBSTONE,      FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Shutdown Timeout in Seconds                     Default:  90 sec.
    // The max time FRS main will wait for all threads to exit during shutdown.
    {FRS_CONFIG_SECTION,   L"Shutdown Timeout in Seconds",    UNITS_SECONDS,
        REG_DWORD, DT_ULONG, 30, 24*60*60, DEFAULT_SHUTDOWN_TIMEOUT, EVENT_FRS_NONE, NULL,
            FKC_SHUTDOWN_TIMEOUT,       FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Maximum Send Command Server Threads              Default:  16
    {FRS_CONFIG_SECTION,    L"Maximum Send Command Server Threads",  UNITS_NONE,
        REG_DWORD, DT_ULONG, 2, 200, (16), EVENT_FRS_NONE, NULL,
            FKC_SNDCS_MAXTHREADS_PAR,   FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Staging Space Limit in KB                        Default:  660 MB
    {FRS_CONFIG_SECTION,    L"Staging Space Limit in KB",   UNITS_KBYTES,
        REG_DWORD,   DT_ULONG,   10*1024,  MAXULONG,  (660 * 1024),  EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_STAGING_LIMIT,          FRS_RKF_READ_AT_START     |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT |
                                        FRS_RKF_LOG_EVENT},


    // VvJoin Limit in Change Orders                    Default:  16 ChangeOrders
    // Max number of VVJoin gened COs to prevent flooding.
    {FRS_CONFIG_SECTION,   L"VvJoin Limit in Change Orders",  UNITS_NONE,
        REG_DWORD, DT_ULONG, 2, 128, (16), EVENT_FRS_NONE, NULL,
            FKC_VVJOIN_LIMIT,           FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // VVJoin Outbound Log Throttle Timeout            Default:  1 sec.
    // The time FRS VVJoin thread waits after generating VVJOIN_LIMIT COs.
    {FRS_CONFIG_SECTION,    L"VvJoin Timeout in Milliseconds", UNITS_MILLISEC,
        REG_DWORD, DT_ULONG, 100, 10*60*1000, (1000), EVENT_FRS_NONE, NULL,
            FKC_VVJOIN_TIMEOUT,         FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // The FRS working dir is where the Jet (ESENT) database is created.
    // If this dir does not exist or can't be created FRS will fail to startup.
    {FRS_CONFIG_SECTION,    L"Working Directory",             UNITS_NONE,
        REG_SZ,      DT_DIR_PATH,   4,  10*(MAX_PATH+1), 4, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_WORKING_DIRECTORY,      FRS_RKF_READ_AT_START         |
                                        FRS_RKF_RANGE_CHECK           |
                                        FRS_RKF_VALUE_MUST_BE_PRESENT |
                                        FRS_RKF_SYNTAX_CHECK          |
                                        FRS_RKF_LOG_EVENT },


    // The FRS Log File Directory allows the Jet Logs to created on a different volume.
    // By default they are placed in a Log subdir under the "Working Directory".
    // If this dir does not exist or can't be created FRS will fail to startup.
    {FRS_CONFIG_SECTION,    L"DB Log File Directory",          UNITS_NONE,
        REG_SZ,      DT_DIR_PATH,   4,  10*(MAX_PATH+1), 4, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_DBLOG_DIRECTORY,        FRS_RKF_READ_AT_START         |
                                        FRS_RKF_RANGE_CHECK           |
                                        FRS_RKF_SYNTAX_CHECK          |
                                        FRS_RKF_LOG_EVENT },


    // Ntfs Journal size in MB                     Default:  32 Meg
    {FRS_CONFIG_SECTION,    L"Ntfs Journal size in MB",   UNITS_MBYTES,
        REG_DWORD, DT_ULONG, 4, 128, (32), EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_NTFS_JRNL_SIZE,         FRS_RKF_READ_AT_START     |
                                        FRS_RKF_LOG_EVENT         |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},


    // Maximum Number of Replica Sets             Default:  200.
    {FRS_CONFIG_SECTION,    L"Maximum Number of Replica Sets", UNITS_NONE,
        REG_DWORD, DT_ULONG, 1, 5000, (200), EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_MAX_NUMBER_REPLICA_SETS, FRS_RKF_READ_AT_START     |
                                         FRS_RKF_LOG_EVENT         |
                                         FRS_RKF_RANGE_CHECK       |
                                         FRS_RKF_OK_TO_USE_DEFAULT},


    // Maximum Number of Jet Sessions             Default:  128.
    {FRS_CONFIG_SECTION,    L"Maximum Number of Jet Sessions", UNITS_NONE,
        REG_DWORD, DT_ULONG, 1, 5000, (128), EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_MAX_NUMBER_JET_SESSIONS, FRS_RKF_READ_AT_START     |
                                         FRS_RKF_LOG_EVENT         |
                                         FRS_RKF_RANGE_CHECK       |
                                         FRS_RKF_OK_TO_USE_DEFAULT},


    // Maximum Number of outstanding CO's per outbound connection.  Default:  8.
    {FRS_CONFIG_SECTION,    L"Max Num Outbound COs Per Connection", UNITS_NONE,
        REG_DWORD, DT_ULONG, 1, 100, (8), EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_OUT_LOG_CO_QUOTA,        FRS_RKF_READ_AT_START     |
                                         FRS_RKF_LOG_EVENT         |
                                         FRS_RKF_RANGE_CHECK       |
                                         FRS_RKF_OK_TO_USE_DEFAULT},


    //   If TRUE, Preserve OIDs on files whenever possible   Default: False
    //  -- See Bug 352250 for why this is a risky thing to do.
    {FRS_CONFIG_SECTION,  L"Preserve File OID", UNITS_NONE,
        REG_DWORD, DT_BOOL, FALSE, TRUE, (FALSE),   EVENT_FRS_NONE, NULL,
            FKC_PRESERVE_FILE_OID,      FRS_RKF_READ_AT_START     |
                                        FRS_RKF_READ_AT_POLL      |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},
    //
    // Disable compression support. Need a non-auth restore to
    // make sure we don't have any old compressed staging files
    // when this key is turned on.
    //
    {FRS_CONFIG_SECTION,  L"Debug Disable Compression", UNITS_NONE,
        REG_DWORD, DT_BOOL, FALSE, TRUE, (FALSE),   EVENT_FRS_NONE, NULL,
            FKC_DEBUG_DISABLE_COMPRESSION,      FRS_RKF_READ_AT_START     |
                                        FRS_RKF_RANGE_CHECK       |
                                        FRS_RKF_OK_TO_USE_DEFAULT},

    //
    // Compress staging files for local changes.  Set to FALSE to disable.
    // This member will continue to install and propagate compressed files.
    // This is useful if the customer has content that originates on this member
    // which is either already compressed or doesn't compress well.
    //
    {FRS_CONFIG_SECTION,  L"Compress Staging Files",         UNITS_NONE,
        REG_DWORD, DT_BOOL, FALSE, TRUE, (TRUE),    EVENT_FRS_NONE, NULL,
            FKC_COMPRESS_STAGING_FILES,   FRS_RKF_READ_AT_START     |
                                          FRS_RKF_RANGE_CHECK       |
                                          FRS_RKF_OK_TO_USE_DEFAULT},

    //
    // Disable compression of staging files for local changes.
    // This member will continue to install and send compressed files
    // unless compression support it explicilt turned off by the
    // Debug Disable Compression key.
    //      OBSOLETE -- WILL BE REMOVED.
    //
    {FRS_CONFIG_SECTION,  L"Disable Compression of Staging Files", UNITS_NONE,
        REG_DWORD, DT_BOOL, FALSE, TRUE, (FALSE),   EVENT_FRS_NONE, NULL,
            FKC_DISABLE_COMPRESSION_STAGING_FILE,   FRS_RKF_READ_AT_START     |
                                                    FRS_RKF_RANGE_CHECK       |
                                                    FRS_RKF_OK_TO_USE_DEFAULT},

    //
    // Client side ldap search timeout value. Default is 10 minutes.
    //
    {FRS_CONFIG_SECTION,    L"Ldap Search Timeout In Minutes", UNITS_NONE,
        REG_DWORD, DT_ULONG, 1, 120, (10), EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_LDAP_SEARCH_TIMEOUT_IN_MINUTES, FRS_RKF_READ_AT_START     |
                                         FRS_RKF_LOG_EVENT         |
                                         FRS_RKF_RANGE_CHECK       |
                                         FRS_RKF_OK_TO_USE_DEFAULT},
    //
    // Client side ldap_connect timeout value. Default is 30 seconds.
    //
    {FRS_CONFIG_SECTION,    L"Ldap Bind Timeout In Seconds", UNITS_NONE,
        REG_DWORD, DT_ULONG, 2, MAXULONG, (30), EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_LDAP_BIND_TIMEOUT_IN_SECONDS, FRS_RKF_READ_AT_START     |
                                         FRS_RKF_LOG_EVENT         |
                                         FRS_RKF_RANGE_CHECK       |
                                         FRS_RKF_OK_TO_USE_DEFAULT},
    // add ReplDirLevelLimit as a reg key
    // add code support for the following

        //FKC_SET_N_DIR_EXCL_FILTER_LIST,
        //FKC_SET_N_DIR_INCL_FILTER_LIST,
        //FKC_SET_N_FILE_EXCL_FILTER_LIST,
        //FKC_SET_N_FILE_INCL_FILTER_LIST,

        //FKC_SET_N_SYSVOL_DIR_EXCL_FILTER_LIST,
        //FKC_SET_N_SYSVOL_DIR_INCL_FILTER_LIST,
        //FKC_SET_N_SYSVOL_FILE_EXCL_FILTER_LIST,
        //FKC_SET_N_SYSVOL_FILE_INCL_FILTER_LIST,


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                P e r - R e p l i c a   S e t   K e y s                    **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/


#define FRS_RKEY_SETS_SECTION    FRS_CONFIG_SECTION L",Replica Sets"

#define FRS_RKEY_SET_N           FRS_CONFIG_SECTION L",Replica Sets,ARG1"

#define FRS_RKEY_CUM_SET_N       FRS_CONFIG_SECTION L",Cumulative Replica Sets,ARG1"

#define FRS_RKEY_CUM_SET_SECTION FRS_CONFIG_SECTION L",Cumulative Replica Sets"

    //
    // FRS Sets parameter data.  Lives in
    // "System\\CurrentControlSet\\Services\\NtFrs\\Parameters\\Replica Sets\\[RS-guid]"
    // Used for sysvols currently.
    //
    // No event log messages are generated for these keys since currently
    // they are only created by the service or NTFRSAPI so if they get
    // fouled up there is nothing the USER can do to correct the problem.
    //


    // The FRS working dir is where the Jet (ESENT) database is created.
    // Replica Sets\Database Directory
    {FRS_RKEY_SETS_SECTION,        JET_PATH,         UNITS_NONE,
        REG_SZ,      DT_DIR_PATH,   4,  10*1024, 4, EVENT_FRS_NONE, NULL,
            FKC_SETS_JET_PATH,          FRS_RKF_READ_AT_START         |
                                        FRS_RKF_RANGE_CHECK           |
                                        FRS_RKF_VALUE_MUST_BE_PRESENT |
                                        FRS_RKF_SYNTAX_CHECK},


    // Replica Sets\Guid\Replica Set Name
    {FRS_RKEY_SET_N,        REPLICA_SET_NAME,       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   4,  512, 0, EVENT_FRS_NONE, NULL,
            FKC_SET_N_REPLICA_SET_NAME, FRS_RKF_READ_AT_START         |
                                        FRS_RKF_RANGE_CHECK           |
                                        FRS_RKF_VALUE_MUST_BE_PRESENT},


    // The root of the replica tree.
    // Replica Sets\Guid\Replica Set Root
    {FRS_RKEY_SET_N,        REPLICA_SET_ROOT,       UNITS_NONE,
        REG_SZ,      DT_DIR_PATH,   4,  10*1024, 4, EVENT_FRS_NONE, NULL,
            FKC_SET_N_REPLICA_SET_ROOT, FRS_RKF_READ_AT_START         |
                                        FRS_RKF_RANGE_CHECK           |
                                        FRS_RKF_VALUE_MUST_BE_PRESENT |
                                        FRS_RKF_SYNTAX_CHECK},


    // The staging area for this replica set.
    // Replica Sets\Guid\Replica Set Stage
    {FRS_RKEY_SET_N,        REPLICA_SET_STAGE,       UNITS_NONE,
        REG_SZ,      DT_DIR_PATH,   4,  10*1024, 4, EVENT_FRS_NONE, NULL,
            FKC_SET_N_REPLICA_SET_STAGE, FRS_RKF_READ_AT_START         |
                                         FRS_RKF_RANGE_CHECK           |
                                         FRS_RKF_VALUE_MUST_BE_PRESENT |
                                         FRS_RKF_SYNTAX_CHECK},


    // The replica set type code. ( SYSVOL, DFS, ...)
    // Replica Sets\Guid\Replica Set Type
    {FRS_RKEY_SET_N,        REPLICA_SET_TYPE,       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 1024, 0, EVENT_FRS_NONE, NULL,
            FKC_SET_N_REPLICA_SET_TYPE, FRS_RKF_READ_AT_START         |
                                        FRS_RKF_RANGE_CHECK           |
                                        FRS_RKF_VALUE_MUST_BE_PRESENT},


    //  The directory filter exclusion list.   Default:  None
    //  Don't supply a default here.  See FRS_DS_COMPOSE_FILTER_LIST for why.
    {FRS_RKEY_SET_N,    L"Directory Exclusion Filter List",   UNITS_NONE,
        REG_SZ, DT_FILE_LIST, 0, 0, 0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_SET_N_DIR_EXCL_FILTER_LIST,   FRS_RKF_READ_AT_START     |
                                              FRS_RKF_LOG_EVENT         |
                                              FRS_RKF_SYNTAX_CHECK      |
                                              FRS_RKF_READ_AT_POLL},


    //  The directory filter inclusion list.         Default:  None
    {FRS_RKEY_SET_N,    L"Directory Inclusion Filter List",     UNITS_NONE,
        REG_SZ, DT_FILE_LIST, 0, 0, 0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_SET_N_DIR_INCL_FILTER_LIST,   FRS_RKF_READ_AT_START     |
                                              FRS_RKF_LOG_EVENT         |
                                              FRS_RKF_SYNTAX_CHECK      |
                                              FRS_RKF_CREATE_KEY        |
                                              FRS_RKF_OK_TO_USE_DEFAULT |
                                              FRS_RKF_READ_AT_POLL},


    //  The file filter exclusion list.
    //  Don't supply a default here.  See FRS_DS_COMPOSE_FILTER_LIST for why.
    {FRS_RKEY_SET_N,    L"File Exclusion Filter List",    UNITS_NONE,
        REG_SZ, DT_FILE_LIST, 0, 0, 0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_SET_N_FILE_EXCL_FILTER_LIST,  FRS_RKF_READ_AT_START     |
                                              FRS_RKF_LOG_EVENT         |
                                              FRS_RKF_READ_AT_POLL},


    //  The file filter inclusion list.            Default:  ~clbcatq.*
    {FRS_RKEY_SET_N,    L"File Inclusion Filter List",     UNITS_NONE,
        REG_SZ, DT_FILE_LIST, 0, 0, 0, EVENT_FRS_BAD_REG_DATA,
        L"~clbcatq.*",
            FKC_SET_N_FILE_INCL_FILTER_LIST,  FRS_RKF_READ_AT_START     |
                                              FRS_RKF_LOG_EVENT         |
                                              FRS_RKF_SYNTAX_CHECK      |
                                              FRS_RKF_CREATE_KEY        |
                                              FRS_RKF_OK_TO_USE_DEFAULT |
                                              FRS_RKF_READ_AT_POLL},


    // The tombstone state of this replica set.
    // Replica Sets\Guid\Replica Set Tombstoned
    {FRS_RKEY_SET_N,        REPLICA_SET_TOMBSTONED,       UNITS_NONE,
        REG_DWORD,      DT_BOOL,   0, 1, 0, EVENT_FRS_NONE, NULL,
            FKC_SET_N_REPLICA_SET_TOMBSTONED, FRS_RKF_READ_AT_START         |
                                              FRS_RKF_RANGE_CHECK           |
                                              FRS_RKF_VALUE_MUST_BE_PRESENT},


    // The operation to perform on the replica set.
    // Replica Sets\Guid\Replica Set Command
    {FRS_RKEY_SET_N,        REPLICA_SET_COMMAND,       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 1024, 0, EVENT_FRS_NONE, NULL,
            FKC_SET_N_REPLICA_SET_COMMAND,    FRS_RKF_READ_AT_START         |
                                              FRS_RKF_RANGE_CHECK           |
                                              FRS_RKF_VALUE_MUST_BE_PRESENT},


    // If TRUE this is the first member of a replica set and we init the DB
    // with the contents of the replica tree.
    // Replica Sets\Guid\Replica Set Primary
    {FRS_RKEY_SET_N,        REPLICA_SET_PRIMARY,       UNITS_NONE,
        REG_DWORD,      DT_BOOL,   0, 1, 0, EVENT_FRS_NONE, NULL,
            FKC_SET_N_REPLICA_SET_PRIMARY,    FRS_RKF_READ_AT_START         |
                                              FRS_RKF_RANGE_CHECK           |
                                              FRS_RKF_VALUE_MUST_BE_PRESENT},


    // LDAP error Status return if we have a problem creating sysvol.
    // Replica Sets\Guid\Replica Set Status
    {FRS_RKEY_SET_N,        REPLICA_SET_STATUS,       UNITS_NONE,
        REG_DWORD,      DT_ULONG,   0, MAXULONG, 0, EVENT_FRS_NONE, NULL,
            FKC_SET_N_REPLICA_SET_STATUS,     FRS_RKF_READ_AT_START},


    // Cumulative Replica Sets         *NOTE* This is a key def only.
    {FRS_RKEY_CUM_SET_SECTION,  L"*KeyOnly*",                  UNITS_NONE,
        REG_SZ,        DT_UNICODE,   0, MAXULONG, 0, EVENT_FRS_NONE, NULL,
            FKC_CUMSET_SECTION_KEY,              0},


    // Number of inbound and outbound partners for this replica set.
    // Cumulative Replica Sets\Guid\Number Of Partners
    {FRS_RKEY_CUM_SET_N,  L"Number Of Partners",       UNITS_NONE,
        REG_DWORD,      DT_ULONG,   0, MAXULONG, 0, EVENT_FRS_NONE, NULL,
            FKC_CUMSET_N_NUMBER_OF_PARTNERS,     FRS_RKF_READ_AT_START},


    // Backup / Restore flags for this replica set.
    // Cumulative Replica Sets\Guid\BurFlags
    {FRS_RKEY_CUM_SET_N,  FRS_VALUE_BURFLAGS,       UNITS_NONE,
        REG_DWORD,      DT_ULONG,   0, MAXULONG, 0, EVENT_FRS_NONE, NULL,
            FKC_CUMSET_N_BURFLAGS,     FRS_RKF_READ_AT_START},



 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **       S y s t e m   V o l u m e   R e l a t e d   K e y s                 **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/


#define FRS_RKEY_SYSVOL_SET_N           FRS_CONFIG_SECTION L",SysVol,ARG1"
#define FRS_RKEY_SYSVOL_SEED_N          FRS_CONFIG_SECTION L",SysVol Seeding,ARG1"
#define FRS_RKEY_SYSVOL_SEEDING_SECTION FRS_CONFIG_SECTION L",SysVol Seeding"


    //
    // No event log messages are generated for these keys since currently
    // they are only created by the service or NTFRSAPI so if they get
    // fouled up there is nothing the USER can do to correct the problem.
    //


    // TRUE if sysvol is ready.  Notifies NetLogon to publish computer as a DC.
    // Netlogon\\Parameters\SysvolReady
    {NETLOGON_SECTION,        SYSVOL_READY,       UNITS_NONE,
        REG_DWORD,      DT_BOOL,   0, 1, 0, EVENT_FRS_NONE, NULL,
            FKC_SYSVOL_READY,             FRS_RKF_READ_AT_START},


    // SysVol Section        *NOTE* THis is a key only.  It has no value.
    {FRS_SYSVOL_SECTION,         L"*KeyOnly*",       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 10*1024, 0, EVENT_FRS_NONE, NULL,
            FKC_SYSVOL_SECTION_KEY,                               0},


    // TRUE if sysvol data is all present in registry.
    // Tells us that DCPromo completed.
    // Netlogon\\Parameters\SysVol Information is Committed
    {FRS_SYSVOL_SECTION,        SYSVOL_INFO_IS_COMMITTED,       UNITS_NONE,
        REG_DWORD,      DT_BOOL,   0, 1, 0, EVENT_FRS_NONE, NULL,
            FKC_SYSVOL_INFO_COMMITTED,     FRS_RKF_READ_AT_START         |
                                           FRS_RKF_RANGE_CHECK           |
                                           FRS_RKF_VALUE_MUST_BE_PRESENT},

    //
    //  Note that the following keys are a repeat of those in the "Per-Replica
    //  set" section above except the Key location in the registry is
    //    FRS_CONFIG_SECTION\SysVol instead of FRS_CONFIG_SECTION\Replica Sets
    //  unfortunate but something more to clean up later perhaps with a
    //  second parameter (ARG2).
    //

    // SysVol\<Guid>\Replica Set Name
    {FRS_RKEY_SYSVOL_SET_N,        REPLICA_SET_NAME,       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   4,  512, 0, EVENT_FRS_NONE, NULL,
            FKC_SET_N_SYSVOL_NAME,      FRS_RKF_READ_AT_START         |
                                        FRS_RKF_RANGE_CHECK           |
                                        FRS_RKF_VALUE_MUST_BE_PRESENT},


    // The root of the replica tree.
    // SysVol\<Guid>\Replica Set Root
    {FRS_RKEY_SYSVOL_SET_N,        REPLICA_SET_ROOT,       UNITS_NONE,
        REG_SZ,      DT_DIR_PATH,   4,  10*1024, 4, EVENT_FRS_NONE, NULL,
            FKC_SET_N_SYSVOL_ROOT,      FRS_RKF_READ_AT_START         |
                                        FRS_RKF_RANGE_CHECK           |
                                        FRS_RKF_VALUE_MUST_BE_PRESENT |
                                        FRS_RKF_SYNTAX_CHECK},


    // The staging area for this replica set.
    // SysVol\<Guid>\Replica Set Stage
    {FRS_RKEY_SYSVOL_SET_N,        REPLICA_SET_STAGE,       UNITS_NONE,
        REG_SZ,      DT_DIR_PATH,   4,  10*1024, 4, EVENT_FRS_NONE, NULL,
            FKC_SET_N_SYSVOL_STAGE,      FRS_RKF_READ_AT_START         |
                                         FRS_RKF_RANGE_CHECK           |
                                         FRS_RKF_VALUE_MUST_BE_PRESENT |
                                         FRS_RKF_SYNTAX_CHECK},


    // The replica set type code. ( SYSVOL, DFS, ...)
    // SysVol\<Guid>\Replica Set Type
    {FRS_RKEY_SYSVOL_SET_N,        REPLICA_SET_TYPE,       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 1024, 0, EVENT_FRS_NONE, NULL,
            FKC_SET_N_SYSVOL_TYPE,      FRS_RKF_READ_AT_START         |
                                        FRS_RKF_RANGE_CHECK           |
                                        FRS_RKF_VALUE_MUST_BE_PRESENT},


    //  The directory filter exclusion list.   Default:  None
    //  Don't supply a default here.  See FRS_DS_COMPOSE_FILTER_LIST for why.
    {FRS_RKEY_SYSVOL_SET_N,    L"Directory Exclusion Filter List",   UNITS_NONE,
        REG_SZ, DT_FILE_LIST, 0, 0, 0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_SET_N_SYSVOL_DIR_EXCL_FILTER_LIST,   FRS_RKF_READ_AT_START     |
                                                     FRS_RKF_LOG_EVENT         |
                                                     FRS_RKF_SYNTAX_CHECK      |
                                                     FRS_RKF_READ_AT_POLL},


    //  The directory filter inclusion list.         Default:  None
    {FRS_RKEY_SYSVOL_SET_N,    L"Directory Inclusion Filter List",     UNITS_NONE,
        REG_SZ, DT_FILE_LIST, 0, 0, 0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_SET_N_SYSVOL_DIR_INCL_FILTER_LIST,   FRS_RKF_READ_AT_START     |
                                                     FRS_RKF_LOG_EVENT         |
                                                     FRS_RKF_SYNTAX_CHECK      |
                                                     FRS_RKF_CREATE_KEY        |
                                                     FRS_RKF_OK_TO_USE_DEFAULT |
                                                     FRS_RKF_READ_AT_POLL},


    //  The file filter exclusion list.
    //  Don't supply a default here.  See FRS_DS_COMPOSE_FILTER_LIST for why.
    {FRS_RKEY_SYSVOL_SET_N,    L"File Exclusion Filter List",    UNITS_NONE,
        REG_SZ, DT_FILE_LIST, 0, 0, 0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_SET_N_SYSVOL_FILE_EXCL_FILTER_LIST,  FRS_RKF_READ_AT_START     |
                                                     FRS_RKF_LOG_EVENT         |
                                                     FRS_RKF_READ_AT_POLL},


    //  The file filter inclusion list.            Default:  ~clbcatq.*
    {FRS_RKEY_SYSVOL_SET_N,    L"File Inclusion Filter List",     UNITS_NONE,
        REG_SZ, DT_FILE_LIST, 0, 0, 0, EVENT_FRS_BAD_REG_DATA,
        L"~clbcatq.*",
            FKC_SET_N_SYSVOL_FILE_INCL_FILTER_LIST,  FRS_RKF_READ_AT_START     |
                                                     FRS_RKF_LOG_EVENT         |
                                                     FRS_RKF_SYNTAX_CHECK      |
                                                     FRS_RKF_CREATE_KEY        |
                                                     FRS_RKF_OK_TO_USE_DEFAULT |
                                                     FRS_RKF_READ_AT_POLL},


    // The operation to perform on the replica set.
    // SysVol\<Guid>\Replica Set Command
    {FRS_RKEY_SYSVOL_SET_N,        REPLICA_SET_COMMAND,       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 1024, 0, EVENT_FRS_NONE, NULL,
            FKC_SET_N_SYSVOL_COMMAND,   FRS_RKF_READ_AT_START         |
                                        FRS_RKF_RANGE_CHECK           |
                                        FRS_RKF_VALUE_MUST_BE_PRESENT},


    // The RPC binding string for the parent computer to seed from.
    // SysVol\<Guid>\Replica Set Parent
    {FRS_RKEY_SYSVOL_SET_N,        REPLICA_SET_PARENT,       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 10*1024, 0, EVENT_FRS_NONE, NULL,
            FKC_SET_N_SYSVOL_PARENT,      FRS_RKF_READ_AT_START         |
                                          FRS_RKF_RANGE_CHECK           |
                                          FRS_RKF_VALUE_MUST_BE_PRESENT},


    // If TRUE this is the first member of a replica set and we init the DB
    // with the contents of the replica tree.
    // SysVol\<Guid>\Replica Set Primary
    {FRS_RKEY_SYSVOL_SET_N,        REPLICA_SET_PRIMARY,       UNITS_NONE,
        REG_DWORD,      DT_BOOL,   0, 1, 0,   EVENT_FRS_NONE, NULL,
            FKC_SET_N_SYSVOL_PRIMARY,         FRS_RKF_READ_AT_START         |
                                              FRS_RKF_RANGE_CHECK           |
                                              FRS_RKF_VALUE_MUST_BE_PRESENT},


    // LDAP error Status return if we have a problem creating sysvol.
    // SysVol\<Guid>\Replica Set Status
    {FRS_RKEY_SYSVOL_SET_N,        REPLICA_SET_STATUS,       UNITS_NONE,
        REG_DWORD,      DT_ULONG,   0, MAXULONG, 0, EVENT_FRS_NONE, NULL,
            FKC_SET_N_SYSVOL_STATUS,          FRS_RKF_READ_AT_START},



    // The RPC binding string for the parent computer to seed from.
    // SysVol Seeding\ReplicaSetName(ARG1)\Replica Set Parent
    {FRS_RKEY_SYSVOL_SEED_N,    REPLICA_SET_PARENT,       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 10*1024, 0, EVENT_FRS_NONE, NULL,
            FKC_SYSVOL_SEEDING_N_PARENT,  FRS_RKF_READ_AT_START         |
                                          FRS_RKF_RANGE_CHECK           |
                                          FRS_RKF_VALUE_MUST_BE_PRESENT},


    // SysVol Seeding\ReplicaSetName(ARG1)\Replica Set Name
    {FRS_RKEY_SYSVOL_SEED_N,    REPLICA_SET_NAME,       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 10*1024, 0, EVENT_FRS_NONE, NULL,
            FKC_SYSVOL_SEEDING_N_RSNAME,  FRS_RKF_READ_AT_START         |
                                          FRS_RKF_RANGE_CHECK           |
                                          FRS_RKF_VALUE_MUST_BE_PRESENT},


    // SysVol Seeding        *NOTE* THis is a key only.  It has no value.
    {FRS_RKEY_SYSVOL_SEEDING_SECTION,    L"*KeyOnly*",       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 10*1024, 0, EVENT_FRS_NONE, NULL,
            FKC_SYSVOL_SEEDING_SECTION_KEY,               0},




 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **       E v e n t   L o g g i n g    C o n f i g   K e y s                  **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

#define FRS_RKEY_EVENTLOG         EVENTLOG_ROOT L",ARG1"

#define FRS_RKEY_EVENTLOG_SOURCE  EVENTLOG_ROOT L"," SERVICE_LONG_NAME L",ARG1"

    // EventLog\File Replication Service\File
    {FRS_RKEY_EVENTLOG,        L"File",       UNITS_NONE,
        REG_EXPAND_SZ,      DT_FILENAME,   4, 0, 0, EVENT_FRS_NONE,
        L"%SystemRoot%\\system32\\config\\NtFrs.Evt",
            FKC_EVENTLOG_FILE,            FRS_RKF_READ_AT_START         |
                                          FRS_RKF_CREATE_KEY            |
                                          FRS_RKF_SYNTAX_CHECK          |
                                          FRS_RKF_OK_TO_USE_DEFAULT},


    // EventLog\File Replication Service\DisplayNameFile
    {FRS_RKEY_EVENTLOG,        L"DisplayNameFile",       UNITS_NONE,
        REG_EXPAND_SZ,      DT_FILENAME,   4, 0, 0, EVENT_FRS_NONE,
        L"%SystemRoot%\\system32\\els.dll",
            FKC_EVENTLOG_DISPLAY_FILENAME,FRS_RKF_READ_AT_START         |
                                          FRS_RKF_CREATE_KEY            |
                                          FRS_RKF_SYNTAX_CHECK          |
                                          FRS_RKF_OK_TO_USE_DEFAULT},


    // EventLog\File Replication Service\EventMessageFile
    // EventLog\NTFRS\EventMessageFile
    //      Default value: "%SystemRoot%\system32\ntfrsres.dll"
    {FRS_RKEY_EVENTLOG_SOURCE, L"EventMessageFile",       UNITS_NONE,
        REG_EXPAND_SZ,      DT_FILENAME,   4, 0, 0, EVENT_FRS_NONE,
        DEFAULT_MESSAGE_FILE_PATH,
            FKC_EVENTLOG_EVENT_MSG_FILE,  FRS_RKF_READ_AT_START         |
                                          FRS_RKF_CREATE_KEY            |
                                          FRS_RKF_SYNTAX_CHECK          |
                                          FRS_RKF_OK_TO_USE_DEFAULT},


    // EventLog\File Replication Service\Sources
    {FRS_RKEY_EVENTLOG,        L"Sources",       UNITS_NONE,
        REG_MULTI_SZ,      DT_UNICODE,   4, 0, 0, EVENT_FRS_NONE,
        (SERVICE_NAME L"\0" SERVICE_LONG_NAME L"\0"),
            FKC_EVENTLOG_SOURCES,         FRS_RKF_READ_AT_START         |
                                          FRS_RKF_CREATE_KEY            |
                                          FRS_RKF_OK_TO_USE_DEFAULT},


    // EventLog\File Replication Service\Retention
    {FRS_RKEY_EVENTLOG,        L"Retention",       UNITS_NONE,
        REG_DWORD,         DT_ULONG,   0, MAXULONG, 0, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_EVENTLOG_RETENTION,       FRS_RKF_READ_AT_START         |
                                          FRS_RKF_LOG_EVENT             |
                                          FRS_RKF_CREATE_KEY            |
                                          FRS_RKF_OK_TO_USE_DEFAULT},


    // EventLog\File Replication Service\MaxSize
    {FRS_RKEY_EVENTLOG,        L"MaxSize",       UNITS_NONE,
        REG_DWORD,         DT_ULONG,   0, MAXULONG, 0x80000, EVENT_FRS_BAD_REG_DATA, NULL,
            FKC_EVENTLOG_MAXSIZE,         FRS_RKF_READ_AT_START         |
                                          FRS_RKF_LOG_EVENT             |
                                          FRS_RKF_CREATE_KEY            |
                                          FRS_RKF_OK_TO_USE_DEFAULT},


    // EventLog\File Replication Service\DisplayNameID
    {FRS_RKEY_EVENTLOG,        L"DisplayNameID",       UNITS_NONE,
        REG_DWORD,         DT_ULONG,   0, MAXULONG, 259, EVENT_FRS_NONE, NULL,
            FKC_EVENTLOG_DISPLAY_NAMEID,  FRS_RKF_READ_AT_START         |
                                          FRS_RKF_CREATE_KEY            |
                                          FRS_RKF_OK_TO_USE_DEFAULT},


    // EventLog\File Replication Service\TypesSupported
    {FRS_RKEY_EVENTLOG_SOURCE,  L"TypesSupported",       UNITS_NONE,
        REG_DWORD,         DT_ULONG,   0, MAXULONG, FRS_EVENT_TYPES, EVENT_FRS_NONE, NULL,
            FKC_EVENTLOG_TYPES_SUPPORTED, FRS_RKF_READ_AT_START         |
                                          FRS_RKF_CREATE_KEY            |
                                          FRS_RKF_OK_TO_USE_DEFAULT},


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **       F R S   A P I   A c c e s s   C h e c k   K e y s                   **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/


#define  FRS_RKEY_ACCCHK_PERFMON  \
    FRS_CONFIG_SECTION  L",Access Checks,"  ACK_COLLECT_PERFMON_DATA

    // Access Checks\Get Perfmon Data\Access checks are [Enabled or Disabled]
    {FRS_RKEY_ACCCHK_PERFMON,   ACCESS_CHECKS_ARE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_ARE_DEFAULT_ENABLED,
            FKC_ACCCHK_PERFMON_ENABLE,  FRS_RKF_READ_AT_START         |
                                        FRS_RKF_LOG_EVENT             |
                                        FRS_RKF_CREATE_KEY            |
                                        FRS_RKF_SYNTAX_CHECK          |
                                        FRS_RKF_RANGE_CHECK},


    // Access Checks\Get Perfmon Data\Access checks require [Full Control or Read]
    {FRS_RKEY_ACCCHK_PERFMON,   ACCESS_CHECKS_REQUIRE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_REQUIRE_DEFAULT_READ,
            FKC_ACCCHK_PERFMON_RIGHTS,  FRS_RKF_READ_AT_START         |
                                        FRS_RKF_LOG_EVENT             |
                                        FRS_RKF_CREATE_KEY            |
                                        FRS_RKF_SYNTAX_CHECK          |
                                        FRS_RKF_RANGE_CHECK},


#define  FRS_RKEY_ACCCHK_GETDS_POLL  \
    FRS_CONFIG_SECTION  L",Access Checks," ACK_GET_DS_POLL

    // Access Checks\Get Ds Polling Interval\Access checks are [Enabled or Disabled]
    {FRS_RKEY_ACCCHK_GETDS_POLL,   ACCESS_CHECKS_ARE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_ARE_DEFAULT_ENABLED,
            FKC_ACCCHK_GETDS_POLL_ENABLE,   FRS_RKF_READ_AT_START         |
                                            FRS_RKF_LOG_EVENT             |
                                            FRS_RKF_CREATE_KEY            |
                                            FRS_RKF_SYNTAX_CHECK          |
                                            FRS_RKF_RANGE_CHECK},


    // Access Checks\Get Ds Polling Interval\Access checks require [Full Control or Read]
    {FRS_RKEY_ACCCHK_GETDS_POLL,   ACCESS_CHECKS_REQUIRE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_REQUIRE_DEFAULT_READ,
            FKC_ACCCHK_GETDS_POLL_RIGHTS,   FRS_RKF_READ_AT_START         |
                                            FRS_RKF_LOG_EVENT             |
                                            FRS_RKF_CREATE_KEY            |
                                            FRS_RKF_SYNTAX_CHECK          |
                                            FRS_RKF_RANGE_CHECK},



#define  FRS_RKEY_ACCCHK_GET_INFO  \
    FRS_CONFIG_SECTION  L",Access Checks," ACK_INTERNAL_INFO

    // Access Checks\Get Internal Information\Access checks are [Enabled or Disabled]
    {FRS_RKEY_ACCCHK_GET_INFO,   ACCESS_CHECKS_ARE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_ARE_DEFAULT_ENABLED,
            FKC_ACCCHK_GET_INFO_ENABLE,     FRS_RKF_READ_AT_START         |
                                            FRS_RKF_LOG_EVENT             |
                                            FRS_RKF_CREATE_KEY            |
                                            FRS_RKF_SYNTAX_CHECK          |
                                            FRS_RKF_RANGE_CHECK},


    // Access Checks\Get Internal Information\Access checks require [Full Control or Read]
    {FRS_RKEY_ACCCHK_GET_INFO,   ACCESS_CHECKS_REQUIRE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_REQUIRE_DEFAULT_WRITE,
            FKC_ACCCHK_GET_INFO_RIGHTS,     FRS_RKF_READ_AT_START         |
                                            FRS_RKF_LOG_EVENT             |
                                            FRS_RKF_CREATE_KEY            |
                                            FRS_RKF_SYNTAX_CHECK          |
                                            FRS_RKF_RANGE_CHECK},



#define  FRS_RKEY_ACCCHK_SETDS_POLL    \
    FRS_CONFIG_SECTION  L",Access Checks,"  ACK_SET_DS_POLL

    // Access Checks\set Ds Polling Interval\Access checks are [Enabled or Disabled]
    {FRS_RKEY_ACCCHK_SETDS_POLL,   ACCESS_CHECKS_ARE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_ARE_DEFAULT_ENABLED,
            FKC_ACCCHK_SETDS_POLL_ENABLE,   FRS_RKF_READ_AT_START         |
                                            FRS_RKF_LOG_EVENT             |
                                            FRS_RKF_CREATE_KEY            |
                                            FRS_RKF_SYNTAX_CHECK          |
                                            FRS_RKF_RANGE_CHECK},


    // Access Checks\Set Ds Polling Interval\Access checks require [Full Control or Read]
    {FRS_RKEY_ACCCHK_SETDS_POLL,   ACCESS_CHECKS_REQUIRE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_REQUIRE_DEFAULT_WRITE,
            FKC_ACCCHK_SETDS_POLL_RIGHTS,   FRS_RKF_READ_AT_START         |
                                            FRS_RKF_LOG_EVENT             |
                                            FRS_RKF_CREATE_KEY            |
                                            FRS_RKF_SYNTAX_CHECK          |
                                            FRS_RKF_RANGE_CHECK},




#define  FRS_RKEY_ACCCHK_STARTDS_POLL  \
    FRS_CONFIG_SECTION  L",Access Checks,"  ACK_START_DS_POLL

    // Access Checks\Start Ds Polling\Access checks are [Enabled or Disabled]
    {FRS_RKEY_ACCCHK_STARTDS_POLL,   ACCESS_CHECKS_ARE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_ARE_DEFAULT_ENABLED,
            FKC_ACCCHK_STARTDS_POLL_ENABLE,  FRS_RKF_READ_AT_START         |
                                             FRS_RKF_LOG_EVENT             |
                                             FRS_RKF_CREATE_KEY            |
                                             FRS_RKF_SYNTAX_CHECK          |
                                             FRS_RKF_RANGE_CHECK},


    // Access Checks\Start Ds Polling\Access checks require [Full Control or Read]
    {FRS_RKEY_ACCCHK_STARTDS_POLL,   ACCESS_CHECKS_REQUIRE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_REQUIRE_DEFAULT_READ,
            FKC_ACCCHK_STARTDS_POLL_RIGHTS,  FRS_RKF_READ_AT_START         |
                                             FRS_RKF_LOG_EVENT             |
                                             FRS_RKF_CREATE_KEY            |
                                             FRS_RKF_SYNTAX_CHECK          |
                                             FRS_RKF_RANGE_CHECK},




#define  FRS_RKEY_ACCCHK_DCPROMO  \
    FRS_CONFIG_SECTION  L",Access Checks,"  ACK_DCPROMO

    // Access Checks\dcpromo\Access checks are [Enabled or Disabled]
    {FRS_RKEY_ACCCHK_DCPROMO,   ACCESS_CHECKS_ARE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_ARE_DEFAULT_ENABLED,
            FKC_ACCESS_CHK_DCPROMO_ENABLE,  FRS_RKF_READ_AT_START         |
                                            FRS_RKF_LOG_EVENT             |
                                            FRS_RKF_CREATE_KEY            |
                                            FRS_RKF_SYNTAX_CHECK          |
                                            FRS_RKF_RANGE_CHECK},


    // Access Checks\dcpromo\Access checks require [Full Control or Read]
    {FRS_RKEY_ACCCHK_DCPROMO,   ACCESS_CHECKS_REQUIRE,       UNITS_NONE,
        REG_SZ,      DT_ACCESS_CHK,   2, 200, 0, EVENT_FRS_BAD_REG_DATA,
        ACCESS_CHECKS_REQUIRE_DEFAULT_WRITE,
            FKC_ACCESS_CHK_DCPROMO_RIGHTS,  FRS_RKF_READ_AT_START         |
                                            FRS_RKF_LOG_EVENT             |
                                            FRS_RKF_CREATE_KEY            |
                                            FRS_RKF_SYNTAX_CHECK          |
                                            FRS_RKF_RANGE_CHECK},



 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **       F R S   B a c k u p   /   R e s t o r e   R e l a t e d   K e y s   **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/


    //
    // No event log messages are generated for these keys since currently
    // they are only created by the service or NTFRSAPI so if they get
    // fouled up there is nothing the USER can do to correct the problem.
    //

#define FRS_RKEY_BACKUP_STARTUP_SET_N_SECTION   FRS_BACKUP_RESTORE_MV_SETS_SECTION L",ARG1"

/*
Used in NtfrsApi.c to pass to backup/restore.

#define FRS_NEW_FILES_NOT_TO_BACKUP L"SYSTEM\\CurrentControlSet\\Control\\BackupRestore\\FilesNotToBackup"
FRS_NEW_FILES_NOT_TO_BACKUP    REG_MULTI_SZ key


#define FRS_OLD_FILES_NOT_TO_BACKUP L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FilesNotToBackup"
FRS_OLD_FILES_NOT_TO_BACKUP    REG_MULTI_SZ key

*/


    // Backup/Restore
    //     *NOTE* THis is a key only.  It has no value.
    {FRS_BACKUP_RESTORE_SECTION,    L"*KeyOnly*",       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 10*1024, 0, EVENT_FRS_NONE, NULL,
            FKC_BKUP_SECTION_KEY,                0},


    // Backup/Restore\\Stop NtFrs from Starting
    //     *NOTE* THis is a key only.  It has no value.
    {FRS_BACKUP_RESTORE_STOP_SECTION,    L"*KeyOnly*",       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 10*1024, 0, EVENT_FRS_NONE, NULL,
            FKC_BKUP_STOP_SECTION_KEY,           0},


    // Backup/Restore\Process at Startup\Replica Sets
    //     *NOTE* THis is a key only.  It has no value.
    {FRS_BACKUP_RESTORE_MV_SETS_SECTION,       L"*KeyOnly*",       UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 10*1024, 0, EVENT_FRS_NONE, NULL,
            FKC_BKUP_MV_SETS_SECTION_KEY,           0},


    // Backup/Restore\Process at Startup\Cumulative Replica Sets
    //     *NOTE* THis is a key only.  It has no value.
    {FRS_BACKUP_RESTORE_MV_CUMULATIVE_SETS_SECTION,   L"*KeyOnly*",  UNITS_NONE,
        REG_SZ,      DT_UNICODE,   2, 10*1024, 0, EVENT_FRS_NONE, NULL,
            FKC_BKUP_MV_CUMSETS_SECTION_KEY,           0},


    // Global Backup / Restore flags.
    // backup/restore\Process at Startup\BurFlags
    {FRS_BACKUP_RESTORE_MV_SECTION,  FRS_VALUE_BURFLAGS,       UNITS_NONE,
        REG_DWORD, DT_ULONG, 0, MAXULONG, NTFRSAPI_BUR_FLAGS_NONE, EVENT_FRS_NONE, NULL,
            FKC_BKUP_STARTUP_GLOBAL_BURFLAGS,   FRS_RKF_READ_AT_START      |
                                                FRS_RKF_OK_TO_USE_DEFAULT},


    // Backup / Restore flags for this replica set in "Process at Startup"
    // backup/restore\Process at Startup\Replica Sets\<guid>\BurFlags
    {FRS_RKEY_BACKUP_STARTUP_SET_N_SECTION,  FRS_VALUE_BURFLAGS, UNITS_NONE,
        REG_DWORD,      DT_ULONG,   0, MAXULONG, 0, EVENT_FRS_NONE, NULL,
            FKC_BKUP_STARTUP_SET_N_BURFLAGS,     FRS_RKF_READ_AT_START},



 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **               F R S   P E R F M O N   R e l a t e d   K e y s             **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

    //
    // No event log messages are generated for these keys since currently
    // they are only created by the service so if they get
    // fouled up there is nothing the USER can do to correct the problem.
    //

    //
    // Note: We can't really use thes yet since some of them are in the DLL
    // which doesn't link with this module.  Also some are MULTI_SZ which
    // needs more work in CfgRegReadString and writestring.

#define FRS_RKEY_REPLICA_SET_PERFMON  \
    L"SYSTEM\\CurrentControlSet\\Services\\FileReplicaSet\\Performance"

#define FRS_RKEY_REPLICA_SET_PERF_LINKAGE  \
    L"SYSTEM\\CurrentControlSet\\Services\\FileReplicaSet\\Linkage"

#define FRS_RKEY_CXTION_PERFMON  \
    L"SYSTEM\\CurrentControlSet\\Services\\FileReplicaConn\\Performance"


#define FRS_RKEY_CXTION_PERF_LINKAGE  \
    L"SYSTEM\\CurrentControlSet\\Services\\FileReplicaConn\\Linkage"



    // FileReplicaSet\\Performance\First Counter
    {FRS_RKEY_REPLICA_SET_PERFMON,       L"First Counter",       UNITS_NONE,
        REG_DWORD,      DT_ULONG,   0, MAXULONG, 0, EVENT_FRS_NONE, NULL,
            FKC_REPLICA_SET_FIRST_CTR,        FRS_RKF_READ_AT_START},


    // FileReplicaSet\\Performance\First Help
    {FRS_RKEY_REPLICA_SET_PERFMON,       L"First Help",       UNITS_NONE,
        REG_DWORD,      DT_ULONG,   0, MAXULONG, 0, EVENT_FRS_NONE, NULL,
            FKC_REPLICA_SET_FIRST_HELP,        FRS_RKF_READ_AT_START},


    // FileReplicaSet\\Linkage\Export
    {FRS_RKEY_REPLICA_SET_PERF_LINKAGE,   L"Export",       UNITS_NONE,
        REG_MULTI_SZ,    DT_UNICODE,   0, MAXULONG, 0, EVENT_FRS_NONE, NULL,
            FKC_REPLICA_SET_LINKAGE_EXPORT,    FRS_RKF_READ_AT_START},


    // FileReplicaConn\\Performance\First Counter
    {FRS_RKEY_CXTION_PERFMON,         L"First Counter",      UNITS_NONE,
        REG_DWORD,      DT_ULONG,   0, MAXULONG, 0, EVENT_FRS_NONE, NULL,
            FKC_REPLICA_CXTION_FIRST_CTR,        FRS_RKF_READ_AT_START},


    // FileReplicaConn\\Performance\First Help
    {FRS_RKEY_CXTION_PERFMON,         L"First Help",      UNITS_NONE,
        REG_DWORD,      DT_ULONG,   0, MAXULONG, 0, EVENT_FRS_NONE, NULL,
            FKC_REPLICA_CXTION_FIRST_HELP,        FRS_RKF_READ_AT_START},

    // FileReplicaConn\\Linkage\Export
    {FRS_RKEY_CXTION_PERF_LINKAGE,    L"Export",       UNITS_NONE,
        REG_MULTI_SZ,    DT_UNICODE,   0, MAXULONG, 0, EVENT_FRS_NONE, NULL,
            FKC_REPLICA_CXTION_LINKAGE_EXPORT,    FRS_RKF_READ_AT_START},





    {L"End of table",           NULL,                      UNITS_NONE,
        REG_SZ,      DT_UNSPECIFIED,   0,  0, 0,           EVENT_FRS_NONE, NULL,
            FKC_END_OF_TABLE,           0}


};  // End of FrsRegistryKeyTable



PFRS_REGISTRY_KEY
FrsRegFindKeyContext(
    IN  FRS_REG_KEY_CODE KeyIndex
)
{
/*++

Routine Description:

    This function takes an FRS Registry Key code and returns a pointer to
    the associated key context data.

Arguments:

    KeyIndex   - An entry from the FRS_REG_KEY_CODE enum

Return Value:

    Ptr to the matching Key context entry or NULL if not found.

--*/
#undef DEBSUB
#define  DEBSUB  "FrsRegFindKeyContext:"

    PFRS_REGISTRY_KEY KeyCtx;

//DPRINT(0, "function entry\n");

    FRS_ASSERT((KeyIndex > 0) && (KeyIndex < FRS_REG_KEY_CODE_MAX));

    if (KeyIndex >= FRS_REG_KEY_CODE_MAX) {
        return NULL;
    }

    KeyCtx = FrsRegistryKeyTable;


    while (KeyCtx->FrsKeyCode > FKC_END_OF_TABLE) {
        if (KeyIndex == KeyCtx->FrsKeyCode) {
            //
            // Found it.
            //
            return KeyCtx;
        }
        KeyCtx += 1;
    }

    //
    // Not found.
    //
    return NULL;

}





PWCHAR
CfgRegGetValueName(
    IN  FRS_REG_KEY_CODE KeyIndex
)
{
/*++

Routine Description:

    This function returns a ptr to the value name string in the key context.
    This is NOT a ptr to an allocated string so it should NOT be freed.

Arguments:

    KeyIndex   - An entry from the FRS_REG_KEY_CODE enum


Return Value:

    Ptr to value name string.  NULL if KeyIndex lookup fails.

--*/
#undef DEBSUB
#define  DEBSUB  "CfgRegGetValueName:"


    PFRS_REGISTRY_KEY KeyCtx;

    //
    // Find the key context assoicated with the supplied index.
    //
    KeyCtx = FrsRegFindKeyContext(KeyIndex);
    if (KeyCtx == NULL) {
        DPRINT1(0, ":FK: ERROR - Key contxt not found for key code number %d\n", KeyIndex);
        return L"<null>";
    }

    return KeyCtx->ValueName;

}


DWORD
FrsRegExpandKeyStr(
    IN  PFRS_REGISTRY_KEY Kc,
    IN  PWCHAR            KeyArg1,
    IN  ULONG             Flags,
    OUT PWCHAR            *FullKeyStr
)
{
/*++

Routine Description:

    This function only expands a key field in the given KeyContext and
    returns the result in FullKeyStr.  This is used primarily for error
    messages but is also used to open registry access check keys.

    The syntax for the the key field in the KeyContext consists of multiple
    key components separated by commas.  This function splits the key field on
    the commas.  It then opens the leading key followed by either a create or
    open of each successive component.  If a component matches the string
    L"ARG1" then we substitute the KeyArg1 parameter passed to this function
    for this key component.  Most often this is a stringized guid.  For
    example, the string FRS_RKEY_SET_N is defined as:

    FRS_CONFIG_SECTION L",Replica Sets,ARG1"

    This will end up opening/creating the following key:

    "System\\CurrentControlSet\\Services\\NtFrs\\Parameters\\
        Replica Sets\\
            27d6d1c4-d6b8-480b-9f18b5ea390a0178"

    assuming the argument passed in was "27d6d1c4-d6b8-480b-9f18b5ea390a0178".

Arguments:

    Kc   - A ptr to the key context struct for the desired reg key.

    KeyArg1 - An optional caller supplied key component.  NULL if not provided.

    Flags - Modifer flags

    FullKeyStr - ptr to return buffer for expanded key string.
        NOTE:  The buffer is allocated here.  Caller must free it.

Return Value:

    Win32 status of the result of the operation.
    FullKeyStr is returned NULL if operation fails.

--*/
#undef DEBSUB
#define  DEBSUB  "FrsRegExpandKeyStr:"

    UNICODE_STRING TempUStr, FirstArg;

    PWCHAR FullKey = NULL;
    ULONG  Len, FullKeyLen;
    WCHAR  KeyStr[MAX_PATH];


//DPRINT(0, "function entry\n");

    *FullKeyStr = NULL;


    FullKey = FrsAlloc(FULL_KEY_BUFF_SIZE*sizeof(WCHAR));
    FullKey[0] = UNICODE_NULL;
    FullKeyLen = 1;

    //
    // If there are any commas in this key then we need to do a nested
    // key open (perhaps creating nested keys as we go).  If the key
    // component matches the string L"ARG1" then we use KeyArg1 supplied by
    // the caller.
    //
    RtlInitUnicodeString(&TempUStr, Kc->KeyName);

    //
    // Parse the comma list.
    //
    while (FrsDissectCommaList(TempUStr, &FirstArg, &TempUStr)) {

        if ((FirstArg.Length == 0) || (FirstArg.Length >= sizeof(KeyStr))) {
            DPRINT1(0, ":FK: ERROR - Bad keyName in Key contxt %ws\n", Kc->KeyName);
            goto ERROR_RETURN;
        }

        //
        // null terminate the key component string.
        //
        CopyMemory(KeyStr, FirstArg.Buffer, FirstArg.Length);
        KeyStr[FirstArg.Length/sizeof(WCHAR)] = UNICODE_NULL;

        //
        // Check the Key Component for a match on ARG1 and substitute.
        //
        if (wcscmp(KeyStr, L"ARG1") == 0) {

            if (wcslen(KeyArg1)*sizeof(WCHAR) > sizeof(KeyStr)) {
                DPRINT1(0, ":FK: ERROR - ARG1 too big %ws\n", KeyArg1);
                goto ERROR_RETURN;
            }
            wcscpy(KeyStr, KeyArg1);
        }

        Len = wcslen(KeyStr);
        if (FullKeyLen + Len + 1 > FULL_KEY_BUFF_SIZE) {
            goto ERROR_RETURN;
        }

        if (FullKeyLen > 1) {
            wcscat(FullKey, L"\\");
            FullKeyLen += 1;
        }

        wcscat(FullKey, KeyStr);
        FullKeyLen += Len;

    }   // end while()


    if (FullKeyLen <= 1) {
        goto ERROR_RETURN;
    }

    DPRINT1(4, ":FK: Expanded key name is \"%ws\"\n", FullKey);

    //
    // Return the expanded key to the caller.
    //
    *FullKeyStr = FullKey;

    return ERROR_SUCCESS;


ERROR_RETURN:

    DPRINT1(0, ":FK: ERROR - FrsRegExpandKeyStr Failed on %ws", Kc->KeyName);

    FrsFree(FullKey);

    return ERROR_INVALID_PARAMETER;

}

DWORD
FrsRegOpenKey(
    IN  PFRS_REGISTRY_KEY Kc,
    IN  PWCHAR            KeyArg1,
    IN  ULONG             Flags,
    OUT PHKEY             hKeyRet
)
{
/*++

Routine Description:

    This function opens a registry key and returns a handle.

    See FrsRegExpandKeyStr() for a description of the key field syntax.

Arguments:

    Kc   - A ptr to the key context struct for the desired reg key.

    KeyArg1 - An optional caller supplied key component.  NULL if not provided.

    Flags - Modifer flags
            FRS_RKF_KEY_ACCCHK_READ means only do a read access check on the key.
            FRS_RKF_KEY_ACCCHK_WRITE means only do a KEY_ALL_ACCESS access check on the key.

            if FRS_RKF_CREATE_KEY is set and FRS_RKF_KEY_MUST_BE_PRESENT is clear
            and the given key component is not found, this function creates it.

    hKeyRet - ptr to HKEY for returned key handle.

Return Value:

    Win32 status of the result of the registry operation.
    hKeyRet is returned only on a success.

--*/
#undef DEBSUB
#define  DEBSUB  "FrsRegOpenKey:"

    UNICODE_STRING TempUStr, FirstArg;
    ULONG  WStatus;
    PWCHAR FullKey = NULL;

    HKEY   hKey = HKEY_LOCAL_MACHINE;
    HKEY   hKeyParent = INVALID_HANDLE_VALUE;

    ULONG  AccessRights;
    PCHAR  AccessName;
    WCHAR  KeyStr[MAX_PATH];



    FrsFlagsToStr(Flags, RkfFlagNameTable, sizeof(KeyStr), (PCHAR)KeyStr);
    DPRINT2(4, ":FK: %ws Caller Flags [%s]\n", Kc->ValueName, (PCHAR)KeyStr);
    FrsFlagsToStr(Kc->Flags, RkfFlagNameTable, sizeof(KeyStr), (PCHAR)KeyStr);
    DPRINT2(4, ":FK: %ws KeyCtx Flags [%s]\n", Kc->ValueName, (PCHAR)KeyStr);

//DPRINT(0, "function entry\n");

    //
    // If this is a call to make a read or write access check then we must
    // first build the entire key string and then try the open.  The
    // caller has done an impersonation.
    //
    if (BooleanFlagOn(Flags | Kc->Flags, FRS_RKF_KEY_ACCCHK_READ |
                                         FRS_RKF_KEY_ACCCHK_WRITE)) {

        AccessRights = KEY_READ;
        AccessName = "KEY_READ";

        if (BooleanFlagOn(Flags | Kc->Flags, FRS_RKF_KEY_ACCCHK_WRITE)) {
            AccessRights = KEY_ALL_ACCESS;
            AccessName = "KEY_ALL_ACCESS";
        }

        //
        // Expand the key string.
        //
        FrsRegExpandKeyStr(Kc, KeyArg1, Flags, &FullKey);
        if (FullKey == NULL) {
            return ERROR_INVALID_PARAMETER;
        }

        DPRINT2(4, ":FK: Doing Access Check (%s) on key \"%ws\"\n",
                AccessName, FullKey);

        WStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, FullKey, 0, AccessRights, &hKey);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT1_WS(0, ":FK: ERROR - Access Check failed on %ws;", FullKey, WStatus);
            FrsFree(FullKey);
            return WStatus;
        }

        //
        // Return the key handle to the caller.
        //
        *hKeyRet = hKey;

        FrsFree(FullKey);
        return ERROR_SUCCESS;
    }

    //
    // Not a key access check.  Do normal key open processing.
    //

    //
    // If there are any commas in this key then we need to do a nested
    // key open (perhaps creating nested keys as we go).  If the key
    // component matches the string L"ARG1" then we use KeyArg1 supplied by
    // the caller.
    //
    RtlInitUnicodeString(&TempUStr, Kc->KeyName);

    //
    // Parse the comma list.
    //
    while (FrsDissectCommaList(TempUStr, &FirstArg, &TempUStr)) {

        if ((FirstArg.Length == 0) || (FirstArg.Length >= sizeof(KeyStr))) {
            DPRINT1(0, ":FK: ERROR - Bad keyName in Key contxt %ws\n", Kc->KeyName);
            WStatus = ERROR_INVALID_PARAMETER;
            goto RETURN;
        }

        //
        // null terminate the key component string.
        //
        CopyMemory(KeyStr, FirstArg.Buffer, FirstArg.Length);
        KeyStr[FirstArg.Length/sizeof(WCHAR)] = UNICODE_NULL;

        hKeyParent = hKey;
        hKey = INVALID_HANDLE_VALUE;

        //
        // Check the Key Component for a match on ARG1 and substitute.
        //
        if (wcscmp(KeyStr, L"ARG1") == 0) {

            if (wcslen(KeyArg1)*sizeof(WCHAR) > sizeof(KeyStr)) {
                DPRINT1(0, ":FK: ERROR - ARG1 too big %ws\n", KeyArg1);
                WStatus = ERROR_INVALID_PARAMETER;
                goto RETURN;
            }
            wcscpy(KeyStr, KeyArg1);
        }

        //
        // Open the next key component.
        //
        DPRINT1(5, ":FK: Opening next key component [%ws]\n", KeyStr);
        WStatus = RegOpenKeyEx(hKeyParent, KeyStr, 0, KEY_ALL_ACCESS, &hKey);
        if (!WIN_SUCCESS(WStatus)) {

            //
            // If the key is supposed to be there then return error to caller.
            //
            if (BooleanFlagOn(Flags | Kc->Flags, FRS_RKF_KEY_MUST_BE_PRESENT)) {
                DPRINT1_WS(0, ":FK: Could not open key component [%ws].", KeyStr, WStatus);

                FrsRegPostEventLog(Kc, KeyArg1, Flags, IDS_REG_KEY_NOT_FOUND);
                goto RETURN;
            }

            if (BooleanFlagOn(Flags | Kc->Flags, FRS_RKF_CREATE_KEY)) {
                //
                // Try to create the key.
                //
                DPRINT1(4, ":FK: Creating key component [%ws]\n", KeyStr);
                WStatus = RegCreateKeyW(hKeyParent, KeyStr, &hKey);
                CLEANUP1_WS(0, ":FK: Could not create key component [%ws].",
                            KeyStr, WStatus, RETURN);
            } else {
                //
                // Key not there and not supposed to create it.  Let caller know.
                //
                goto RETURN;
            }
        }


        if (hKeyParent != HKEY_LOCAL_MACHINE) {
            RegCloseKey(hKeyParent);
            hKeyParent = INVALID_HANDLE_VALUE;
        }
    }   // end while()



    //
    // Return the key handle to the caller.
    //
    *hKeyRet = hKey;
    WStatus = ERROR_SUCCESS;


RETURN:

    if ((hKeyParent != HKEY_LOCAL_MACHINE) && HANDLE_IS_VALID(hKeyParent)) {
        RegCloseKey(hKeyParent);
    }

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT_WS(5, "ERROR - FrsRegOpenKey Failed.", WStatus);

        if ((hKey != HKEY_LOCAL_MACHINE) && HANDLE_IS_VALID(hKey)) {
            RegCloseKey(hKey);
        }
    }


    return WStatus;

}



DWORD
CfgRegReadDWord(
    IN  FRS_REG_KEY_CODE KeyIndex,
    IN  PWCHAR           KeyArg1,
    IN  ULONG            Flags,
    OUT PULONG           DataRet
)
{
/*++

Routine Description:

    This function reads a keyword value from the registry.

Arguments:

    KeyIndex   - An entry from the FRS_REG_KEY_CODE enum

    KeyArg1 - An optional caller supplied key component.  NULL if not provided.

    Flags - Modifer flags

    DataRet - ptr to DWORD for returned result.

Return Value:

    Win32 status of the result of the registry operation.
    Data is returned only on a success.

--*/
#undef DEBSUB
#define  DEBSUB  "CfgRegReadDWord:"


    DWORD   WStatus;
    HKEY    hKey = INVALID_HANDLE_VALUE;
    DWORD   Type;
    DWORD   Len;
    DWORD   Data;
    BOOL    DefaultValueUseOk;
    PFRS_REGISTRY_KEY KeyCtx;

//DPRINT(0, "function entry\n");

    //
    // Find the key context assoicated with the supplied index.
    //
    KeyCtx = FrsRegFindKeyContext(KeyIndex);
    if (KeyCtx == NULL) {
        DPRINT1(0, ":FK: ERROR - Key contxt not found for key code number %d\n", KeyIndex);
        return ERROR_INVALID_PARAMETER;
    }


    DefaultValueUseOk = BooleanFlagOn(Flags | KeyCtx->Flags,
                                      FRS_RKF_OK_TO_USE_DEFAULT);

    FRS_ASSERT(KeyCtx->ValueName != NULL);

    DPRINT2(4, ":FK: Reading parameter [%ws] \"%ws\" \n",
            KeyCtx->KeyName, KeyCtx->ValueName);


    //
    // Table entry better be REG_DWORD.
    //
    if  (KeyCtx->RegValueType != REG_DWORD) {
        DPRINT3(4, ":FK: Mismatch on KeyCtx->RegValueType for [%ws] \"%ws\".  Expected REG_DWORD, Found type: %d\n",
             KeyCtx->KeyName, KeyCtx->ValueName, KeyCtx->RegValueType);

        FRS_ASSERT(!"Mismatch on KeyCtx->RegValueType, Expected REG_DWORD");
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Open the key.
    //
    WStatus = FrsRegOpenKey(KeyCtx, KeyArg1, Flags, &hKey);

    if (!WIN_SUCCESS(WStatus)) {
        goto RETURN;
    }

    //
    // Read the value
    //
    Len = sizeof(Data);
    Type = REG_DWORD;
    WStatus = RegQueryValueEx(hKey, KeyCtx->ValueName, NULL, &Type, (PUCHAR)&Data, &Len);

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT_WS(5, "ERROR - RegQueryValueEx Failed.", WStatus);

        if (WStatus == ERROR_FILE_NOT_FOUND) {
            //
            // If the value is supposed to be there then return error to caller.
            //
            if (BooleanFlagOn(Flags | KeyCtx->Flags, FRS_RKF_VALUE_MUST_BE_PRESENT)) {
                DPRINT2_WS(0, ":FK: Value not found  [%ws] \"%ws\".",
                           KeyCtx->KeyName, KeyCtx->ValueName, WStatus);
                FrsRegPostEventLog(KeyCtx, KeyArg1, Flags, IDS_REG_VALUE_NOT_FOUND);
                goto RETURN;
            }
        } else {
            //
            // Check for expected registry datatype if we found a value.
            // Check for buffer size OK.  4 bytes for DWORDs.
            //
            if (WIN_BUF_TOO_SMALL(WStatus) || (Type != REG_DWORD)) {
                DPRINT4(0, ":FK: Invalid registry data type for [%ws] \"%ws\".  Found Type %d, Expecting Type %d\n",
                        KeyCtx->KeyName, KeyCtx->ValueName, Type, REG_DWORD);
                FrsRegPostEventLog(KeyCtx, KeyArg1, Flags, IDS_REG_VALUE_WRONG_TYPE);
            }
        }

        WStatus = ERROR_INVALID_PARAMETER;
    } else {

        //
        // Found a value, Check type.  If wrong, use default.
        //
        if (Type != REG_DWORD) {
            DPRINT4(0, ":FK: Invalid registry data type for [%ws] \"%ws\".  Found Type %d, Expecting Type %d\n",
                    KeyCtx->KeyName, KeyCtx->ValueName, Type, REG_DWORD);
            FrsRegPostEventLog(KeyCtx, KeyArg1, Flags, IDS_REG_VALUE_WRONG_TYPE);
            WStatus = ERROR_INVALID_PARAMETER;
        }
    }


    if (!WIN_SUCCESS(WStatus) && DefaultValueUseOk) {
        //
        // Not found or wrong type but Ok to use the default value from key context.
        //
        Type = KeyCtx->RegValueType;
        Data = KeyCtx->ValueDefault;
        WStatus = ERROR_SUCCESS;
        DPRINT2(4, ":FK: Using internal default value for [%ws] \"%ws\".\n",
                KeyCtx->KeyName, KeyCtx->ValueName);
        //
        // Only use it once though.
        //
        DefaultValueUseOk = FALSE;
    }


    if (WIN_SUCCESS(WStatus)) {
        //
        // Perform syntax check based on data type in KeyCtx->DataValueType?
        //
        if (BooleanFlagOn(Flags | KeyCtx->Flags, FRS_RKF_SYNTAX_CHECK)) {
            NOTHING;
        }

        //
        // Perform Range check?    (Applies to default value too)
        //
        if (BooleanFlagOn(Flags | KeyCtx->Flags, FRS_RKF_RANGE_CHECK)) {


            if ((Data < KeyCtx->ValueMin) || ( Data > KeyCtx->ValueMax)) {

                DPRINT5(0, ":FK: Value out of range for [%ws] \"%ws\".  Found %d, must be between %d and %d\n",
                        KeyCtx->KeyName, KeyCtx->ValueName, Data,
                        KeyCtx->ValueMin, KeyCtx->ValueMax);

                FrsRegPostEventLog(KeyCtx, KeyArg1, Flags, IDS_REG_VALUE_RANGE_ERROR);

                if (DefaultValueUseOk) {
                    //
                    // out of range but Ok to use the default value from key context.
                    //
                    DPRINT2(4, ":FK: Using internal default value for [%ws] \"%ws\".\n",
                            KeyCtx->KeyName, KeyCtx->ValueName);
                    Type = KeyCtx->RegValueType;
                    Data = KeyCtx->ValueDefault;
                    WStatus = ERROR_SUCCESS;

                    //
                    // Recheck the range.
                    //
                    if ((Data < KeyCtx->ValueMin) || ( Data > KeyCtx->ValueMax)) {
                        DPRINT5(0, ":FK: Default Value out of range for [%ws] \"%ws\".  Found %d, must be between %d and %d\n",
                                KeyCtx->KeyName, KeyCtx->ValueName, Data,
                                KeyCtx->ValueMin, KeyCtx->ValueMax);
                        WStatus = ERROR_INVALID_PARAMETER;
                        goto RETURN;
                    }

                } else {
                    WStatus = ERROR_INVALID_PARAMETER;
                    goto RETURN;
                }
            }
        }

        //
        // Data valid and in range.  Return it and save it.
        //
        *DataRet = Data;

        DPRINT3(3, ":FK:   [%ws] \"%ws\" = %d\n",
                KeyCtx->KeyName, KeyCtx->ValueName, Data);
    }


RETURN:

    if ((hKey != HKEY_LOCAL_MACHINE) && HANDLE_IS_VALID(hKey)) {
        RegCloseKey(hKey);
    }

    return WStatus;

}

DWORD
CfgRegReadString(
    IN  FRS_REG_KEY_CODE KeyIndex,
    IN  PWCHAR           KeyArg1,
    IN  ULONG            Flags,
    OUT PWSTR            *pStrRet
)
{
/*++

Routine Description:

    This function reads a keyword string value from the registry.  The return
    buffer is allocated here with FrsAlloc().  Caller must free.

Arguments:

    KeyIndex   - An entry from the FRS_REG_KEY_CODE enum

    KeyArg1 - An optional caller supplied key component.  NULL if not provided.

    Flags - Modifer flags

    pStrRet - ptr to address of string buffer for returned result else NULL.

    NOTE: The return buffer is allocated here, caller must free it.

Return Value:

    Win32 status of the result of the registry operation.
    Data is returned only on a success.

--*/
#undef DEBSUB
#define  DEBSUB  "CfgRegReadString:"

    DWORD   WStatus;
    HKEY    hKey = INVALID_HANDLE_VALUE;
    DWORD   Type;
    DWORD   Len, NewLen;
    PWCHAR  Data, NewData;
    BOOL    DefaultValueUseOk;
    PFRS_REGISTRY_KEY KeyCtx;
    WCHAR TStr[4];

    // add support or new func for REG_MULTI_SZ?

//DPRINT(0, "function entry\n");

    Data = NULL;

    //
    // Find the key context assoicated with the supplied index.
    //
    KeyCtx = FrsRegFindKeyContext(KeyIndex);
    if (KeyCtx == NULL) {
        DPRINT1(0, ":FK: ERROR - Key contxt not found for key code number %d\n", KeyIndex);
        *pStrRet = NULL;
        return ERROR_INVALID_PARAMETER;
    }


    DefaultValueUseOk = BooleanFlagOn(Flags | KeyCtx->Flags,
                                      FRS_RKF_OK_TO_USE_DEFAULT);

    FRS_ASSERT(KeyCtx->ValueName != NULL);

    DPRINT2(4, ":FK: Reading parameter [%ws] \"%ws\" \n",
            KeyCtx->KeyName, KeyCtx->ValueName);

    //
    // Table entry better be some kind of string.
    //
    if  ((KeyCtx->RegValueType != REG_SZ) &&
         (KeyCtx->RegValueType != REG_EXPAND_SZ)) {
        DPRINT3(0, ":FK: Mismatch on KeyCtx->RegValueType for [%ws] \"%ws\".  Expected REG_SZ or REG_EXPAND_SZ, Found type: %d\n",
             KeyCtx->KeyName, KeyCtx->ValueName, KeyCtx->RegValueType);
        // don't return a null ptr since calling parameter may be wrong size.
        FRS_ASSERT(!"Mismatch on KeyCtx->RegValueType, Expected REG_SZ or REG_EXPAND_SZ");
        return ERROR_INVALID_PARAMETER;
    }

    *pStrRet = NULL;

    //
    // Open the key.
    //
    WStatus = FrsRegOpenKey(KeyCtx, KeyArg1, Flags, &hKey);

    if (!WIN_SUCCESS(WStatus)) {
        goto RETURN;
    }

    //
    // Get the size and type for the value.
    //
    WStatus = RegQueryValueEx(hKey, KeyCtx->ValueName, NULL, &Type, NULL, &Len);

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(5, ":FK: RegQueryValueEx(%ws);", KeyCtx->ValueName, WStatus);
        Len = 0;
    }

    //
    // If the value is supposed to be there then return error to caller.
    //
    if ((Len == 0) &&
        BooleanFlagOn(Flags | KeyCtx->Flags, FRS_RKF_VALUE_MUST_BE_PRESENT)) {
        DPRINT2_WS(0, ":FK: Value not found  [%ws] \"%ws\".",
                   KeyCtx->KeyName, KeyCtx->ValueName, WStatus);
        FrsRegPostEventLog(KeyCtx, KeyArg1, Flags, IDS_REG_VALUE_NOT_FOUND);
        goto RETURN;
    }

    if (WIN_SUCCESS(WStatus)) {

        //
        // Should be a string.
        //
        if ((Type != REG_SZ) && (Type != REG_EXPAND_SZ)) {
            DPRINT4(0, ":FK: Invalid registry data type for [%ws] \"%ws\".  Found Type %d, Expecting Type %d\n",
                 KeyCtx->KeyName, KeyCtx->ValueName, Type, KeyCtx->RegValueType);
            WStatus = ERROR_INVALID_PARAMETER;
            FrsRegPostEventLog(KeyCtx, KeyArg1, Flags, IDS_REG_VALUE_WRONG_TYPE);
            goto CHECK_DEFAULT;
        }

        //
        // If the string is too long or too short then complain and use default.
        // If KeyCtx->ValueMax is zero then no maximum length check.
        //
        if (BooleanFlagOn(Flags | KeyCtx->Flags, FRS_RKF_RANGE_CHECK) &&
            (Len < KeyCtx->ValueMin*sizeof(WCHAR)) ||
            ((KeyCtx->ValueMax != 0) && (Len > KeyCtx->ValueMax*sizeof(WCHAR)))) {
            DPRINT4(0, ":FK: String size out of range for [%ws] \"%ws\".  Min: %d  Max: %d\n",
                    KeyCtx->KeyName, KeyCtx->ValueName, KeyCtx->ValueMin, KeyCtx->ValueMax);
            WStatus = ERROR_INVALID_PARAMETER;
            FrsRegPostEventLog(KeyCtx, KeyArg1, Flags, IDS_REG_VALUE_RANGE_ERROR);
            goto CHECK_DEFAULT;
        }

        //
        //  Alloc the return buffer and read the data.
        //
        Data = (PWCHAR) FrsAlloc ((Len+1) * sizeof(WCHAR));
        WStatus = RegQueryValueEx(hKey, KeyCtx->ValueName, NULL, &Type, (PUCHAR)Data, &Len);

        if (!WIN_SUCCESS(WStatus)) {
            DPRINT2(0, ":FK: RegQueryValueEx(%ws); WStatus %s\n", KeyCtx->ValueName, ErrLabelW32(WStatus));
            Data = (PWCHAR) FrsFree(Data);
            goto RETURN;
        }
    }


CHECK_DEFAULT:

    if (!WIN_SUCCESS(WStatus) && DefaultValueUseOk) {
        //
        // Not found or wrong type but Ok to use the default value from key context.
        //
        Data = (PWCHAR) FrsFree(Data);
        if (KeyCtx->StringDefault == NULL) {
            DPRINT2(4, ":FK: Using internal default value for [%ws] \"%ws\" = NULL\n",
                    KeyCtx->KeyName, KeyCtx->ValueName);
            goto RETURN;
        }
        Type = KeyCtx->RegValueType;
        Data = FrsWcsDup(KeyCtx->StringDefault);

        WStatus = ERROR_SUCCESS;
        DPRINT3(4, ":FK: Using internal default value for [%ws] \"%ws\" = %ws\n",
                KeyCtx->KeyName, KeyCtx->ValueName, Data);
    }


    if (WIN_SUCCESS(WStatus) && (Data != NULL)) {
        //
        // Perform syntax check based on data type in KeyCtx->DataValueType?
        //
        if (BooleanFlagOn(Flags | KeyCtx->Flags, FRS_RKF_SYNTAX_CHECK)) {
            NOTHING;
        }

        DPRINT3(4, ":FK:   [%ws] \"%ws\" = \"%ws\"\n",
                KeyCtx->KeyName, KeyCtx->ValueName, Data);

        //
        // Expand system strings if needed
        //
        if (Type == REG_EXPAND_SZ) {

            NewLen = ExpandEnvironmentStrings(Data, TStr, 0);

            while (TRUE) {
                NewData = (PWCHAR) FrsAlloc ((NewLen+1) * sizeof(WCHAR));

                Len = ExpandEnvironmentStrings(Data, NewData, NewLen);
                if (Len == 0) {
                    WStatus = GetLastError();
                    DPRINT2_WS(5, ":FK: [%ws] \"%ws\" Param not expanded.",
                               KeyCtx->KeyName, KeyCtx->ValueName, WStatus);
                    Data = FrsFree(Data);
                    NewData = FrsFree(NewData);
                    break;
                }

                if (Len <= NewLen) {
                    //
                    // Free the original buffer and set to return expanded string.
                    //
                    FrsFree(Data);
                    Data = NewData;
                    Len = NewLen;
                    WStatus = ERROR_SUCCESS;
                    break;
                }

                //
                // Get a bigger buffer.
                //
                NewData = (PWCHAR) FrsFree(NewData);
                NewLen = Len;
            }
        }


        //
        //  Return ptr to buffer and save a copy for debug printouts.
        //
        *pStrRet = Data;

        DPRINT3(3, ":FK:   [%ws] \"%ws\" = \"%ws\"\n",
                KeyCtx->KeyName, KeyCtx->ValueName,
                (Data != NULL) ? Data : L"<null>");
    }

    //
    //  Close the handle if one was opened.
    //
RETURN:


    if ((hKey != HKEY_LOCAL_MACHINE) && HANDLE_IS_VALID(hKey)) {
        RegCloseKey(hKey);
    }

    return WStatus;
}

#if 0
// multisz example)
void
RegQueryMULTISZ(
    HKEY  hkey,
    LPSTR szSubKey,
    LPSTR szValue
    )

/*++

Routine Description:

    This function queries MULTISZ value in the registry using the
    hkey and szSubKey as the registry key info.  If the value is not
    found in the registry, it is added with a zero value.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string

Return Value:

    registry value

--*/

{
    DWORD   rc;
    DWORD   len;
    DWORD   dwType;
    char    buf[1024];

    len = sizeof(buf);
    rc = RegQueryValueEx( hkey, szSubKey, 0, &dwType, (LPBYTE)buf, &len );
    if (!WIN_SUCCESS(rc)) {
        if (rc == ERROR_FILE_NOT_FOUND) {
            buf[0] = 0;
            buf[1] = 0;
            len = 2;
            RegSetMULTISZ( hkey, szSubKey, buf );
        }
    }

    CopyMemory( szValue, buf, len );
}
#endif



DWORD
CfgRegWriteDWord(
    IN  FRS_REG_KEY_CODE KeyIndex,
    IN  PWCHAR           KeyArg1,
    IN  ULONG            Flags,
    IN  ULONG            NewData
)
{
/*++

Routine Description:

    This function reads a keyword value from the registry.

Arguments:

    KeyIndex   - An entry from the FRS_REG_KEY_CODE enum

    KeyArg1 - An optional caller supplied key component.  NULL if not provided.

    Flags - Modifer flags
        FRS_RKF_FORCE_DEFAULT_VALUE - if set then ignore NewData and write the
        default key value from the keyCtx into the registry.

    NewData -  DWORD to write to registry.

Return Value:

    Win32 status of the result of the registry operation.

--*/
#undef DEBSUB
#define  DEBSUB  "CfgRegWriteDWord:"


    DWORD   WStatus;
    HKEY    hKey = INVALID_HANDLE_VALUE;
    DWORD   Len;
    PFRS_REGISTRY_KEY KeyCtx;

//DPRINT(0, "function entry\n");
    //
    // Find the key context assoicated with the supplied index.
    //
    KeyCtx = FrsRegFindKeyContext(KeyIndex);
    if (KeyCtx == NULL) {
        DPRINT1(0, ":FK: ERROR - Key contxt not found for key code number %d\n", KeyIndex);
        return ERROR_INVALID_PARAMETER;
    }

    FRS_ASSERT(KeyCtx->ValueName != NULL);


    //
    // Table entry better be REG_DWORD.
    //
    if  (KeyCtx->RegValueType != REG_DWORD) {
        DPRINT3(0, ":FK: Mismatch on KeyCtx->RegValueType for [%ws] \"%ws\".  Expected REG_DWORD, Found type: %d\n",
             KeyCtx->KeyName, KeyCtx->ValueName, KeyCtx->RegValueType);
        FRS_ASSERT(!"Mismatch on KeyCtx->RegValueType, Expected REG_DWORD");
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Open the key.
    //
    WStatus = FrsRegOpenKey(KeyCtx, KeyArg1, Flags, &hKey);

    if (!WIN_SUCCESS(WStatus)) {
        goto RETURN;
    }

    //
    // Keep existing value if caller says so.
    //
    if (BooleanFlagOn(Flags, FRS_RKF_KEEP_EXISTING_VALUE)) {
        WStatus = RegQueryValueEx(hKey, KeyCtx->ValueName, NULL, NULL, NULL, NULL);
        if (WIN_SUCCESS(WStatus)) {
            DPRINT2(4, ":FK: Retaining existing value for parameter [%ws] \"%ws\"\n",
                    KeyCtx->KeyName, KeyCtx->ValueName);
            goto RETURN;
        }
    }

    //
    // Check if we are writing the default value to the registry.
    //
    if (BooleanFlagOn(Flags, FRS_RKF_FORCE_DEFAULT_VALUE)) {

        NewData = KeyCtx->ValueDefault;
        DPRINT1(4, ":FK: Using internal default value = %d\n", NewData);
    }

    //
    // Perform Range check?    (Applies to default value too)
    //
    if (BooleanFlagOn(Flags | KeyCtx->Flags,
                      FRS_RKF_RANGE_CHECK | FRS_RKF_RANGE_SATURATE)) {

        if ((NewData < KeyCtx->ValueMin) || ( NewData > KeyCtx->ValueMax)) {

            DPRINT5(0, ":FK: Value out of range for [%ws] \"%ws\".  Found %d, must be between %d and %d\n",
                    KeyCtx->KeyName, KeyCtx->ValueName, NewData,
                    KeyCtx->ValueMin, KeyCtx->ValueMax);


            if (!BooleanFlagOn(Flags | KeyCtx->Flags, FRS_RKF_RANGE_SATURATE)) {
                WStatus = ERROR_INVALID_PARAMETER;
                FrsRegPostEventLog(KeyCtx, KeyArg1, Flags, IDS_REG_VALUE_RANGE_ERROR);
                goto RETURN;
            }

            //
            // Set the value to either the min or max of the allowed range.
            // WARNING:  The only current use of this flag is in setting the
            // DS polling interval.  This flag should be used with caution
            // since if a user miss-specifies a parameter and we jam
            // it to the min or max value the resulting effect could be
            // VERY UNDESIREABLE.
            //
            if (NewData < KeyCtx->ValueMin) {
                DPRINT2(4, ":FK: Value (%d) below of range.  Using Min value (%d)\n",
                        NewData, KeyCtx->ValueMin);
                NewData = KeyCtx->ValueMin;
            } else

            if (NewData > KeyCtx->ValueMax) {
                DPRINT2(4, ":FK: Value (%d) above of range.  Using Max value (%d)\n",
                        NewData, KeyCtx->ValueMax);
                NewData = KeyCtx->ValueMax;
            }

        }
    }

    //
    // Write the value and save it.
    //
    Len = sizeof(NewData);
    WStatus = RegSetValueEx(hKey, KeyCtx->ValueName, 0, REG_DWORD, (PCHAR)&NewData, Len);

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT_WS(0, ":FK: ERROR - RegSetValueEx Failed.", WStatus);
    } else {
        DPRINT3(3, ":FK:   [%ws] \"%ws\" = %d\n",
                KeyCtx->KeyName, KeyCtx->ValueName, NewData);
    }


RETURN:

    if ((hKey != HKEY_LOCAL_MACHINE) && HANDLE_IS_VALID(hKey)) {
        RegCloseKey(hKey);
    }

    return WStatus;

}



DWORD
CfgRegWriteString(
    IN  FRS_REG_KEY_CODE KeyIndex,
    IN  PWCHAR           KeyArg1,
    IN  ULONG            Flags,
    IN  PWSTR            NewStr
)
{
/*++

Routine Description:

    This function reads a keyword string value from the registry.  The return
    buffer is allocated here with FrsAlloc().  Caller must free.

Arguments:

    KeyIndex   - An entry from the FRS_REG_KEY_CODE enum

    KeyArg1 - An optional caller supplied key component.  NULL if not provided.

    Flags - Modifer flags
        FRS_RKF_FORCE_DEFAULT_VALUE - if set then ignore NewStr and write the
        default key value from the keyCtx into the registry.

    NewStr - ptr to buffer for new string data.


Return Value:

    Win32 status of the result of the registry operation.

--*/
#undef DEBSUB
#define  DEBSUB  "CfgRegWriteString:"

    DWORD   WStatus;
    HKEY    hKey = INVALID_HANDLE_VALUE;
    DWORD   Type;
    DWORD   Len, NewLen;
    PFRS_REGISTRY_KEY KeyCtx;

    // add support or new func for REG_MULTI_SZ

//DPRINT(0, "function entry\n");

    //
    // Find the key context assoicated with the supplied index.
    //
    KeyCtx = FrsRegFindKeyContext(KeyIndex);
    if (KeyCtx == NULL) {
        DPRINT1(0, ":FK: ERROR - Key contxt not found for key code number %d\n", KeyIndex);
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Table entry better be some kind of string.
    //
    if  ((KeyCtx->RegValueType != REG_SZ) &&
      // (KeyCtx->RegValueType != REG_MULTI_SZ) &&
         (KeyCtx->RegValueType != REG_EXPAND_SZ)) {
        DPRINT3(0, ":FK: Mismatch on KeyCtx->RegValueType for [%ws] \"%ws\".  Expected REG_SZ or REG_EXPAND_SZ, Found type: %d\n",
             KeyCtx->KeyName, KeyCtx->ValueName, KeyCtx->RegValueType);
        FRS_ASSERT(!"Mismatch on KeyCtx->RegValueType, Expected REG_SZ or REG_EXPAND_SZ");
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Open the key.
    //
    WStatus = FrsRegOpenKey(KeyCtx, KeyArg1, Flags, &hKey);
    if (!WIN_SUCCESS(WStatus)) {
        goto RETURN;
    }

    FRS_ASSERT(KeyCtx->ValueName != NULL);

    //
    // Keep existing value if caller says so.
    //
    if (BooleanFlagOn(Flags, FRS_RKF_KEEP_EXISTING_VALUE)) {
        WStatus = RegQueryValueEx(hKey, KeyCtx->ValueName, NULL, NULL, NULL, NULL);
        if (WIN_SUCCESS(WStatus)) {
            DPRINT2(4, ":FK: Retaining existing value for parameter [%ws] \"%ws\"\n",
                    KeyCtx->KeyName, KeyCtx->ValueName);
            goto RETURN;
        }
    }

    //
    // Check if we are writing the default value to the registry.
    //
    if (BooleanFlagOn(Flags, FRS_RKF_FORCE_DEFAULT_VALUE)) {
        if (KeyCtx->StringDefault == NULL) {
            DPRINT2(0, ":FK: ERROR - Key contxt has no default value for [%ws] \"%ws\" \n",
                    KeyCtx->KeyName, KeyCtx->ValueName);
            WStatus = ERROR_INVALID_PARAMETER;
            FRS_ASSERT(!"Key contxt has no default value");
            goto RETURN;
        }

        NewStr = KeyCtx->StringDefault;
        DPRINT1(4, ":FK: Using internal default value = \"%ws\" \n", NewStr);
    }

    //
    // Perform Range check?    (Applies to default value too)
    // If the string is too long or too short then complain and use default.
    // If KeyCtx->ValueMax is zero then no maximum length check.
    //
    // Note: for REG_MULTI_SZ we need to look for double null at end of str
    //       or use a unique symbol for the string separator and cvt to \0 before write.

    Len = (wcslen(NewStr) + 1) * sizeof(WCHAR);
    if (BooleanFlagOn(Flags | KeyCtx->Flags, FRS_RKF_RANGE_CHECK) &&
        (Len < KeyCtx->ValueMin*sizeof(WCHAR)) ||
        ((KeyCtx->ValueMax != 0) && (Len > KeyCtx->ValueMax*sizeof(WCHAR)))) {
        DPRINT4(0, ":FK: String size out of range for [%ws] \"%ws\".  Min: %d  Max: %d\n",
                KeyCtx->KeyName, KeyCtx->ValueName, KeyCtx->ValueMin, KeyCtx->ValueMax);
        WStatus = ERROR_INVALID_PARAMETER;
        FrsRegPostEventLog(KeyCtx, KeyArg1, Flags, IDS_REG_VALUE_RANGE_ERROR);
        goto RETURN;
    }

    WStatus = RegSetValueEx(hKey,
                            KeyCtx->ValueName,
                            0,
                            KeyCtx->RegValueType,
                            (PCHAR)NewStr,
                            Len);

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT_WS(0, ":FK: ERROR - RegSetValueEx Failed.", WStatus);
    } else {

        // note: won't work for MULTI_SZ
        DPRINT3(3, ":FK:   [%ws] \"%ws\" = %ws\n",
                KeyCtx->KeyName, KeyCtx->ValueName,
                (NewStr != NULL) ? NewStr : L"<null>");
    }

#if 0
    // Multi_Sz example
    //
    // Event Message File
    //
//    WStatus = RegSetValueEx(FrsEventLogKey,
//                            L"Sources",
//                            0,
//                            REG_MULTI_SZ,
//                            (PCHAR)(SERVICE_NAME L"\0"
//                                    SERVICE_LONG_NAME L"\0"),
//                            (wcslen(SERVICE_NAME) +
//                             wcslen(SERVICE_LONG_NAME) +
//                             3) * sizeof(WCHAR));
    //
    // Another example
    //
    void
RegSetMULTISZ(
    HKEY hkey,
    LPSTR szSubKey,
    LPSTR szValue
    )

/*++

Routine Description:

    This function changes a Multi_SZ value in the registry using the
    hkey and szSubKey as the registry key info.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string
    szValue       - new registry value

Return Value:

    None.

--*/

{
    ULONG i = 1;
    ULONG j = 0;
    LPSTR p = szValue;
    while( TRUE ) {
        j = strlen( p ) + 1;
        i += j;
        p += j;
        if (!*p) {
            break;
        }
    }
    RegSetValueEx( hkey, szSubKey, 0, REG_MULTI_SZ, (PUCHAR)szValue, i );
}

#endif


    //
    //  Close the handle if one was opened.
    //
RETURN:

    if ((hKey != HKEY_LOCAL_MACHINE) && HANDLE_IS_VALID(hKey)) {
        RegCloseKey(hKey);
    }

    return WStatus;
}





DWORD
CfgRegDeleteValue(
    IN  FRS_REG_KEY_CODE KeyIndex,
    IN  PWCHAR           KeyArg1,
    IN  ULONG            Flags
)
{
/*++

Routine Description:

    This function deletes a keyword value from the registry.

Arguments:

    KeyIndex   - An entry from the FRS_REG_KEY_CODE enum

    KeyArg1 - An optional caller supplied key component.  NULL if not provided.

    Flags - Modifer flags


Return Value:

    Win32 status of the result of the registry operation.

--*/
#undef DEBSUB
#define  DEBSUB  "CfgRegDeleteValue:"


    DWORD   WStatus;
    HKEY    hKey = INVALID_HANDLE_VALUE;
    PFRS_REGISTRY_KEY KeyCtx;

//DPRINT(0, "function entry\n");
    //
    // Find the key context assoicated with the supplied index.
    //
    KeyCtx = FrsRegFindKeyContext(KeyIndex);
    if (KeyCtx == NULL) {
        DPRINT1(0, ":FK: ERROR - Key contxt not found for key code number %d\n", KeyIndex);
        return ERROR_INVALID_PARAMETER;
    }


    FRS_ASSERT(KeyCtx->ValueName != NULL);

    //
    // Open the key.
    //
    WStatus = FrsRegOpenKey(KeyCtx, KeyArg1, Flags, &hKey);
    if (!WIN_SUCCESS(WStatus)) {
        goto RETURN;
    }


    DPRINT2(3, ":FK: Deleting parameter [%ws] \"%ws\" \n",
            KeyCtx->KeyName, KeyCtx->ValueName);

    //
    // Delete the value.
    //
    WStatus = RegDeleteValue(hKey, KeyCtx->ValueName);
    DPRINT2_WS(0, ":FK: WARN - Cannot delete key for [%ws] \"%ws\";",
               KeyCtx->KeyName, KeyCtx->ValueName, WStatus);


RETURN:

    if ((hKey != HKEY_LOCAL_MACHINE) && HANDLE_IS_VALID(hKey)) {
        RegCloseKey(hKey);
    }

    return WStatus;

}





DWORD
CfgRegOpenKey(
    IN  FRS_REG_KEY_CODE KeyIndex,
    IN  PWCHAR           KeyArg1,
    IN  ULONG            Flags,
    OUT HKEY             *RethKey
)
{
/*++

Routine Description:

    This function Opens the key associated with the entry from the FRS registry
    key context table.  It performs the normal substitution, key component
    creation, etc.

Arguments:

    KeyIndex   - An entry from the FRS_REG_KEY_CODE enum

    KeyArg1 - An optional caller supplied key component.  NULL if not provided.

    Flags - Modifer flags

    RethKey -- ptr to HKEY to return the key handle.   Caller must close the
               key with RegCloseKey().


Return Value:

    Win32 status of the result of the registry operation.

--*/
#undef DEBSUB
#define  DEBSUB  "CfgRegOpenKey:"


    DWORD   WStatus;
    HKEY    hKey = INVALID_HANDLE_VALUE;
    PFRS_REGISTRY_KEY KeyCtx;


//DPRINT(0, "function entry\n");
    FRS_ASSERT(RethKey != NULL);

    *RethKey =  INVALID_HANDLE_VALUE;

    //
    // Find the key context assoicated with the supplied index.
    //
    KeyCtx = FrsRegFindKeyContext(KeyIndex);
    if (KeyCtx == NULL) {
        DPRINT1(0, ":FK: ERROR - Key contxt not found for key code number %d\n", KeyIndex);
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Open the key.
    //
    WStatus = FrsRegOpenKey(KeyCtx, KeyArg1, Flags, &hKey);
    if (!WIN_SUCCESS(WStatus)) {
        return WStatus;
    }


    DPRINT1(4, ":FK: Registry key opened [%ws]\n", KeyCtx->KeyName);


    *RethKey =  hKey;

    return ERROR_SUCCESS;

}



DWORD
CfgRegCheckEnable(
    IN  FRS_REG_KEY_CODE KeyIndex,
    IN  PWCHAR           KeyArg1,
    IN  ULONG            Flags,
    OUT PBOOL            Enabled
)
/*++

Routine Description:

    This function Opens the key associated with the entry from the FRS registry
    key context table.  It performs the normal substitution, key component
    creation, etc.  It then checks to see if the data value is "Enabled"
    or "Disabled" and returns the boolean result.

Arguments:

    KeyIndex   - An entry from the FRS_REG_KEY_CODE enum

    KeyArg1 - An optional caller supplied key component.  NULL if not provided.

    Flags - Modifer flags

    Enabled -- ptr to BOOL to return the Enable / Disable state of the key.


Return Value:

    Win32 status of the result of the registry operation.

--*/
#undef DEBSUB
#define  DEBSUB  "CfgRegCheckEnable:"
{

    ULONG WStatus;
    PWCHAR WStr = NULL;

//DPRINT(0, "function entry\n");

    WStatus = CfgRegReadString(KeyIndex, KeyArg1, Flags, &WStr);

    if ((WStr == NULL) ||
        WSTR_EQ(WStr, FRS_IS_DEFAULT_DISABLED)||
        WSTR_EQ(WStr, FRS_IS_DEFAULT_ENABLED)) {
        //
        // The key is in the default state so we can clobber it with a
        // new default.
        //
        WStatus = CfgRegWriteString(KeyIndex,
                                    KeyArg1,
                                    FRS_RKF_FORCE_DEFAULT_VALUE,
                                    NULL);
        DPRINT1_WS(0, ":FK: WARN - Cannot create Enable key [%ws];",
                    CfgRegGetValueName(KeyIndex), WStatus);

        //
        // Now reread the key for the new default.
        //
        WStr = FrsFree(WStr);
        WStatus = CfgRegReadString(KeyIndex, KeyArg1, Flags, &WStr);
    }

    if ((WStr != NULL) &&
        (WSTR_EQ(WStr, FRS_IS_ENABLED) ||
         WSTR_EQ(WStr, FRS_IS_DEFAULT_ENABLED))) {
         *Enabled = TRUE;
         DPRINT1(4, ":FK: %ws is enabled\n", CfgRegGetValueName(KeyIndex));
    } else {
        *Enabled = FALSE;
        DPRINT1_WS(0, ":FK: WARN - %ws is not enabled.",
                   CfgRegGetValueName(KeyIndex), WStatus);
    }

    WStr = FrsFree(WStr);

    return WStatus;

}



BOOL
IsWin2KPro (
    VOID
)
/*++

Routine Description:

    Check OS version for Win 2000 Professional (aka NT Workstation).

Arguments:

    None.

Return Value:

    True if running on win 2K professional.

--*/
#undef DEBSUB
#define  DEBSUB  "IsWin2KPro:"
{
    OSVERSIONINFOEX Osvi;
    DWORDLONG       ConditionMask = 0;

    //
    // Initialize the OSVERSIONINFOEX structure.
    //
    ZeroMemory(&Osvi, sizeof(OSVERSIONINFOEX));
    Osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    Osvi.dwMajorVersion = 5;
    Osvi.wProductType   = VER_NT_WORKSTATION;

    //
    // Initialize the condition mask.
    //
    VER_SET_CONDITION( ConditionMask, VER_MAJORVERSION, VER_GREATER_EQUAL );
    VER_SET_CONDITION( ConditionMask, VER_PRODUCT_TYPE, VER_EQUAL );

    //
    // Perform the test.
    //
    return VerifyVersionInfo(&Osvi, VER_MAJORVERSION | VER_PRODUCT_TYPE, ConditionMask);
}



VOID
CfgRegAdjustTuningDefaults(
    VOID
    )
/*++

Routine Description:

    This function walks thru the FrsRegKeyRevisionTable and applies new
    min, max and default values to the specified keys.  The objective is
    to reduce the footprint of FRS on the workstation.

Arguments:

    None.

Return Value:

    None.

--*/
#undef DEBSUB
#define  DEBSUB  "CfgRegAdjustTuningDefaults:"
{

    PFRS_REG_KEY_REVISIONS  Rev;
    PFRS_REGISTRY_KEY      KeyCtx;

    Win2kPro = IsWin2KPro();

    if (!Win2kPro) {
        //
        // Only adjust tunables on a workstation.
        //
        return;
    }

    Rev = FrsRegKeyRevisionTable;

    while (Rev->FrsKeyCode != FKC_END_OF_TABLE) {

        KeyCtx = FrsRegFindKeyContext(Rev->FrsKeyCode);
        if (KeyCtx == NULL) {
            DPRINT1(0, ":FK: ERROR - Key contxt not found for key code number %d\n",
                    Rev->FrsKeyCode);
            continue;
        }

        //
        // Table entry better be REG_DWORD.
        //
        if  (KeyCtx->RegValueType != REG_DWORD) {
            DPRINT3(0, ":FK: Mismatch on KeyCtx->RegValueType for [%ws] \"%ws\".  Expected REG_DWORD, Found type: %d\n",
                 KeyCtx->KeyName, KeyCtx->ValueName, KeyCtx->RegValueType);
            continue;
        }

        //
        // Apply the new range and default values from the table.
        //
        KeyCtx->ValueMin = Rev->ValueMin;
        KeyCtx->ValueMax = Rev->ValueMax;
        KeyCtx->ValueDefault = Rev->ValueDefault;

        Rev += 1;
    }
}



#define BACKUP_STAR     L"*"
#define BACKUP_APPEND   L"\\* /s"
VOID
CfgFilesNotToBackup(
    IN PGEN_TABLE   Replicas
    )
/*++

Routine Description:

    Set the backup registry key to prevent backing up the jet
    database, staging directories, preinstall directories, ...

    Set the restore registry key KeysNotToRestore so that
    NtBackup will retain the ntfrs restore keys by moving
    them into the final restored registry.

Arguments:

    Table of replicas

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "CfgFilesNotToBackup:"
    DWORD       WStatus;
    PVOID       Key;
    PREPLICA    Replica;
    PWCHAR      MStr = NULL;
    DWORD       Size = 0;
    DWORD       Idx = 0;
    HKEY        HOldBackupKey = 0;
    HKEY        HNewBackupKey = 0;
    HKEY        HKeysNotToRestore = 0;

//DPRINT(0, "function entry\n");
    //
    // "<Jetpath>\* /s"
    //
    FrsAddToMultiString(JetPath, &Size, &Idx, &MStr);
    FrsCatToMultiString(BACKUP_APPEND, &Size, &Idx, &MStr);

    //
    // "<DebugInfo.LogFile>\NtFrs*"  Default: "%SystemRoot%\debug\NtFrs*"
    //
    FrsAddToMultiString(DebugInfo.LogFile, &Size, &Idx, &MStr);
    FrsCatToMultiString(NTFRS_DBG_LOG_FILE, &Size, &Idx, &MStr);
    FrsCatToMultiString(BACKUP_STAR, &Size, &Idx, &MStr);

    GTabLockTable(Replicas);
    Key = NULL;
    while (Replica = GTabNextDatumNoLock(Replicas, &Key)) {
        //
        // Ignore tombstoned sets
        //
        if (!IS_TIME_ZERO(Replica->MembershipExpires)) {
            continue;
        }

        //
        // Preinstall directories
        //
        if (Replica->Root) {
            FrsAddToMultiString(Replica->Root, &Size, &Idx, &MStr);
            FrsCatToMultiString(L"\\",         &Size, &Idx, &MStr);
            FrsCatToMultiString(NTFRS_PREINSTALL_DIRECTORY, &Size, &Idx, &MStr);
            FrsCatToMultiString(BACKUP_APPEND, &Size, &Idx, &MStr);
        }
        //
        // Preexisting directories
        //
        if (Replica->Root) {
            FrsAddToMultiString(Replica->Root, &Size, &Idx, &MStr);
            FrsCatToMultiString(L"\\",         &Size, &Idx, &MStr);
            FrsCatToMultiString(NTFRS_PREEXISTING_DIRECTORY, &Size, &Idx, &MStr);
            FrsCatToMultiString(BACKUP_APPEND, &Size, &Idx, &MStr);
        }
        //
        // Staging directories
        //
        if (Replica->Stage) {
            FrsAddToMultiString(Replica->Stage, &Size, &Idx, &MStr);
            FrsCatToMultiString(L"\\",          &Size, &Idx, &MStr);
            FrsCatToMultiString(GENERIC_PREFIX, &Size, &Idx, &MStr);
            FrsCatToMultiString(BACKUP_STAR,    &Size, &Idx, &MStr);
        }
    }
    GTabUnLockTable(Replicas);

    // Note: remove old_files_not_to_backup once existance of new key
    //       has been verified.
    //
    // FilesNotToBackup
    // "SOFTWARE\Microsoft\Windows NT\CurrentVersion\FilesNotToBackup"
    //
    WStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           FRS_OLD_FILES_NOT_TO_BACKUP,
                           0,
                           KEY_SET_VALUE,
                           &HOldBackupKey);
    CLEANUP1_WS(4, ":FK: WARN - RegOpenKeyEx(%ws);",
                FRS_OLD_FILES_NOT_TO_BACKUP, WStatus, NEW_FILES_NOT_TO_BACKUP);

    //
    // Set the ntfrs multistring value
    //
    WStatus = RegSetValueEx(HOldBackupKey,
                            SERVICE_NAME,
                            0,
                            REG_MULTI_SZ,
                            (PCHAR)MStr,
                            (Idx + 1) * sizeof(WCHAR));
    CLEANUP2_WS(4, ":FK: ERROR - RegSetValueEx(%ws\\%ws);",
                FRS_OLD_FILES_NOT_TO_BACKUP, SERVICE_NAME, WStatus, NEW_FILES_NOT_TO_BACKUP);

NEW_FILES_NOT_TO_BACKUP:
    //
    // FilesNotToBackup
    //  "SYSTEM\CurrentControlSet\Control\BackupRestore\FilesNotToBackup"
    //
    WStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           FRS_NEW_FILES_NOT_TO_BACKUP,
                           0,
                           KEY_SET_VALUE,
                           &HNewBackupKey);
    CLEANUP1_WS(4, ":FK: WARN - RegOpenKeyEx(%ws);",
                FRS_NEW_FILES_NOT_TO_BACKUP, WStatus, CLEANUP);

    //
    // Set the ntfrs multistring value
    //
    WStatus = RegSetValueEx(HNewBackupKey,
                            SERVICE_NAME,
                            0,
                            REG_MULTI_SZ,
                            (PCHAR)MStr,
                            (Idx + 1) * sizeof(WCHAR));
    CLEANUP2_WS(4, ":FK: ERROR - RegSetValueEx(%ws\\%ws);",
                FRS_NEW_FILES_NOT_TO_BACKUP, SERVICE_NAME, WStatus, CLEANUP);

    //
    // KeysNotToRestore
    //
    // Set the restore registry key KeysNotToRestore so that NtBackup will
    // retain the ntfrs restore keys by moving them into the final restored
    // registry.
    //
    //  CurrentControlSet\Services\<SERVICE_NAME>\Parameters\Backup/Restore\Process at Startup\"
    //

    MStr = FrsFree(MStr);
    Size = 0;
    Idx = 0;
    FrsAddToMultiString(FRS_VALUE_FOR_KEYS_NOT_TO_RESTORE, &Size, &Idx, &MStr);

    //
    // KeysNotToRestore
    // "SYSTEM\CurrentControlSet\Control\BackupRestore\KeysNotToRestore"
    //
    WStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           FRS_KEYS_NOT_TO_RESTORE,
                           0,
                           KEY_SET_VALUE,
                           &HKeysNotToRestore);
    CLEANUP1_WS(4, ":FK: WARN - RegOpenKeyEx(%ws);",
                FRS_KEYS_NOT_TO_RESTORE, WStatus, CLEANUP);

    //
    // Set the ntfrs multistring value
    //
    WStatus = RegSetValueEx(HKeysNotToRestore,
                            SERVICE_NAME,
                            0,
                            REG_MULTI_SZ,
                            (PCHAR)MStr,
                            (Idx + 1) * sizeof(WCHAR));
    CLEANUP2_WS(4, ":FK: ERROR - RegSetValueEx(%ws\\%ws);",
                FRS_KEYS_NOT_TO_RESTORE, SERVICE_NAME, WStatus, CLEANUP);

    //
    // DONE
    //
    WStatus = ERROR_SUCCESS;

CLEANUP:
    if (HOldBackupKey) {
        RegCloseKey(HOldBackupKey);
    }
    if (HNewBackupKey) {
        RegCloseKey(HNewBackupKey);
    }
    if (HKeysNotToRestore) {
        RegCloseKey(HKeysNotToRestore);
    }
    FrsFree(MStr);
}



VOID
FrsRegPostEventLog(
    IN  PFRS_REGISTRY_KEY KeyCtx,
    IN  PWCHAR            KeyArg1,
    IN  ULONG             Flags,
    IN  LONG              IDScode
)
/*++

Routine Description:

    This Posts an event log message for a problem with a registry key.

Arguments:

    KeyCtx  - Ptr to the Key Context struct for this key.

    KeyArg1 - An optional caller supplied key component.  NULL if not provided.

    Flags   - Modifer flags

    IDSCode - the error message code for a resource string to put in the message.

Return Value:

    None.

--*/
#undef DEBSUB
#define  DEBSUB  "FrsRegPostEventLog:"
{

    #define LEN_DEFAULT_VALUE 48
    #define LEN_RANGE_STR    256

    PWCHAR ErrorStr, UnitsStr, RangeStrFmt, ValStr, FullKeyStr;
    WCHAR  RangeStr[LEN_RANGE_STR];

//DPRINT(0, "function entry\n");
    //
    // Are we posting an event log message for this key?
    //
    if (!BooleanFlagOn(Flags | KeyCtx->Flags, FRS_RKF_LOG_EVENT) ||
        (KeyCtx->EventCode == EVENT_FRS_NONE)) {
        return;
    }

    //
    // Post Eventlog message.  Include KeyString, ValueName,
    // MustBePresent, Expected Type, TypeMismatch or not,
    // Value out of range (with range allowed), Default Value Used,
    // regedit instrs to fix the problem,
    //
    UnitsStr = FrsGetResourceStr(XLATE_IDS_UNITS(KeyCtx->Units));
    ErrorStr = FrsGetResourceStr(IDScode);


    if (KeyCtx->RegValueType == REG_DWORD) {

        //
        // Get the range format string from the string resource.
        //
        RangeStrFmt = FrsGetResourceStr(IDS_RANGE_DWORD);
        //
        // Show default value used if default is ok.
        //
        if (BooleanFlagOn(Flags | KeyCtx->Flags, FRS_RKF_OK_TO_USE_DEFAULT)) {
            ValStr = FrsAlloc(LEN_DEFAULT_VALUE * sizeof(WCHAR));
            _snwprintf(ValStr, LEN_DEFAULT_VALUE, L"%d", KeyCtx->ValueDefault);
        } else {
            ValStr = FrsGetResourceStr(IDS_NO_DEFAULT);
        }
    } else {
        //
        // No default allowed.
        //
        RangeStrFmt = FrsGetResourceStr(IDS_RANGE_STRING);
        ValStr = FrsGetResourceStr(IDS_NO_DEFAULT);
    }

    //
    // Build the range string.
    //
    _snwprintf(RangeStr, LEN_RANGE_STR, RangeStrFmt, KeyCtx->ValueMin, KeyCtx->ValueMax);
    RangeStr[LEN_RANGE_STR-1] = UNICODE_NULL;

    //
    // Expand the key string.
    //
    FrsRegExpandKeyStr(KeyCtx, KeyArg1, Flags, &FullKeyStr);
    if (FullKeyStr == NULL) {
        FullKeyStr = FrsWcsDup(KeyCtx->KeyName);
    }

    //
    // Post the event log message using the keycode in the KeyContext and cleanup.
    //
    if (KeyCtx->EventCode == EVENT_FRS_BAD_REG_DATA) {
    EPRINT9(KeyCtx->EventCode,
            ErrorStr,                           // %1
            FullKeyStr,                         // %2
            KeyCtx->ValueName,                  // %3
            REG_DT_NAME(KeyCtx->RegValueType),  // %4
            RangeStr,                           // %5
            UnitsStr,                           // %6
            ValStr,                             // %7
            FullKeyStr,                         // %8
            KeyCtx->ValueName);                 // %9
    } else {
        //
        // Don't know this event code but put out something.
        //
        DPRINT1(0, ":FK: ERROR - Unexpected EventCode number (%d). Cannot post message.\n",
                KeyCtx->EventCode);
    }


    DPRINT1(0, ":FK:    EventCode number  : %d\n" , (KeyCtx->EventCode & 0xFFFF));
    DPRINT1(0, ":FK:    Error String      : %ws\n", ErrorStr);
    DPRINT1(0, ":FK:    Key String        : %ws\n", FullKeyStr);
    DPRINT1(0, ":FK:    Value Name        : %ws\n", KeyCtx->ValueName);
    DPRINT1(0, ":FK:    Expected Reg Type : %ws\n", REG_DT_NAME(KeyCtx->RegValueType));
    DPRINT1(0, ":FK:    Parameter Range   : %ws\n", RangeStr);
    DPRINT1(0, ":FK:    Parameter units   : %ws\n", UnitsStr);

    FrsFree(ErrorStr);
    FrsFree(RangeStrFmt);
    FrsFree(UnitsStr);
    FrsFree(ValStr);
    FrsFree(FullKeyStr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\util\debug.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This routine reads input from STDIN and initializes the debug structure.
    It reads a list of subsystems to debug and a severity level.

Author:

    Billy Fuller

Environment

    User mode, winnt32
*/
#include <ntreppch.h>
#pragma  hdrstop

#include "debug.h"

// #include <imagehlp.h>
#include <dbghelp.h>
#include <frs.h>
#include <winbase.h>
#include <mapi.h>
#include <ntfrsapi.h>
#include <info.h>


extern PCHAR LatestChanges[];

//
// Track the thread IDs of known threads for the debug log header.
//
typedef struct _KNOWN_THREAD {
    PWCHAR   Name;                    // print Name of thread.
    DWORD    Id;                      // Id returned by CreateThread()
    PTHREAD_START_ROUTINE EntryPoint; // entry point
} KNOWN_THREAD, *PKNOWN_THREAD;

KNOWN_THREAD KnownThreadArray[20];

//
// Send mail will not work if the Default User is unable to send
// mail on this machine.
//
MapiRecipDesc Recips =
    {0, MAPI_TO, 0, 0, 0, NULL};

MapiMessage Message =
    { 0, 0, 0, NULL, NULL, NULL, 0, 0, 1, &Recips, 0, 0 };

LPMAPILOGON     MailLogon;
LPMAPILOGOFF    MailLogoff;
LPMAPISENDMAIL  MailSend;
HANDLE          MailLib;
LHANDLE         MailSession;



WCHAR   DbgExePathW[MAX_PATH+1];
CHAR    DbgExePathA[MAX_PATH+1];
CHAR    DbgSearchPath[MAX_PATH+1];

//
// Flush the trace log every so many lines.
//
LONG    DbgFlushInterval = 100000;

#define DEFAULT_DEBUG_MAX_LOG           (20000)

LONG  StackTraceCount = 100;
LONG  DbgRaiseCount = 50;


OSVERSIONINFOEXW  OsInfo;
SYSTEM_INFO  SystemInfo;
PCHAR ProcessorArchName[10] = {"INTEL", "MIPS", "Alpha", "PPC", "SHX",
                               "ARM", "IA64", "Alpha64", "MSIL", "???"};

//
// Suffixes for saved log files and saved assertion files
//      E.g., (ntfrs_0005.log)
//            (DebugInfo.LogFile, DebugInfo.LogFiles, LOG_FILE_SUFFIX)
//
#define LOG_FILE_FORMAT     L"%ws_%04d%ws"
#define LOG_FILE_SUFFIX     L".log"
#define ASSERT_FILE_SUFFIX  L"_assert.log"


//
// Disable the generation of compressed staging files for any local changes.
//
BOOL DisableCompressionStageFiles;
ULONG GOutLogRepeatInterval;

//
// Client side ldap search timeout in minutes. Reg value "Ldap Search Timeout In Minutes". Default is 10 minutes.
//
DWORD LdapSearchTimeoutInMinutes;

//
// Client side ldap_connect timeout in seconds. Reg value "Ldap Bind Timeout In Seconds". Default is 30 seconds.
//
DWORD LdapBindTimeoutInSeconds;

SC_HANDLE
FrsOpenServiceHandle(
    IN PTCHAR  MachineName,
    IN PTCHAR  ServiceName
    );


VOID
FrsPrintRpcStats(
    IN ULONG            Severity,
    IN PNTFRSAPI_INFO   Info,        OPTIONAL
    IN DWORD            Tabs
    );

#if DBG

//
// Collection of debug info from the registry and the CLI
//
DEBUGARG DebugInfo;

//
// allow multiple servers on one machine
//
PWCHAR  ServerName = NULL;
PWCHAR  IniFileName = NULL;
GUID    *ServerGuid = NULL;



VOID
DbgLogDisable(
    VOID
    )
/*++
Routine Description:
    Disable DPRINT log.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgLogDisable:"

    DebLock();
    if (DebugInfo.LogFILE) {
        fflush(DebugInfo.LogFILE);
        DbgFlushInterval = DebugInfo.LogFlushInterval;
        fclose(DebugInfo.LogFILE);
    }
    DebugInfo.LogFILE = NULL;
    DebUnLock();
}





VOID
DbgOpenLogFile(
    VOID
    )
/*++
Routine Description:
    Open the log file by creating names like ntfrs0001.log.
    NumFiles as a 4 digit decimal number and Suffix is like ".log".

    DebLock() must be held (DO NOT CALL DPRINT IN THIS FUNCTION!)

Arguments:
    Base
    Suffix
    NumFiles

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgOpenLogFile:"

    WCHAR LogPath[MAX_PATH + 1];

    if (DebugInfo.Disabled) {
        DebugInfo.LogFILE = NULL;
        return;
    }

    if (_snwprintf(LogPath, MAX_PATH, LOG_FILE_FORMAT, DebugInfo.LogFile,
                   DebugInfo.LogFiles, LOG_FILE_SUFFIX) < 0) {

        DebugInfo.LogFILE = NULL;
        return;
    }

    DebugInfo.LogFILE = _wfopen(LogPath, L"wc");
}


VOID
DbgShiftLogFiles(
    IN PWCHAR   Base,
    IN PWCHAR   Suffix,
    IN PWCHAR   RemoteBase,
    IN ULONG    NumFiles
    )
/*++
Routine Description:
    Shift the files through the range of log/assert file names
    (Base_5_Suffix -> Base_4_Suffix -> ... Base_0_Suffix

    DebLock() must be held (DO NOT CALL DPRINT IN THIS FUNCTION!)

Arguments:
    Base
    Suffix
    NumFiles

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgShiftLogFiles:"

    ULONG       i;
    WCHAR       FromPath[MAX_PATH + 1];
    WCHAR       ToPath[MAX_PATH + 1];
    ULONGLONG   Now;

    //
    // No history
    //
    if ((NumFiles < 2) || DebugInfo.Disabled) {
        return;
    }

    //
    // Save the log file as an assert file
    //
    for (i = 2; i <= NumFiles; ++i) {
        if (_snwprintf(ToPath, MAX_PATH, LOG_FILE_FORMAT, Base, i-1, Suffix) > 0) {
            if (_snwprintf(FromPath, MAX_PATH, LOG_FILE_FORMAT, Base, i, Suffix) > 0) {
                MoveFileEx(FromPath, ToPath, MOVEFILE_REPLACE_EXISTING |
                                             MOVEFILE_WRITE_THROUGH);
            }
        }
    }

    //
    // Copy the last log file to a remote share
    //      WARN - the system time is used to create a unique file
    //             name. This means that the remote share can
    //             fill up!
    //
    if (!RemoteBase) {
        return;
    }

    GetSystemTimeAsFileTime((FILETIME *)&Now);


    if (_snwprintf(FromPath, MAX_PATH, LOG_FILE_FORMAT, Base, NumFiles-1, Suffix) > 0) {
        if (_snwprintf(ToPath,
                       MAX_PATH,
                       L"%ws%ws%08x%_%08x",
                       RemoteBase,
                       Suffix,
                       PRINTQUAD(Now)) > 0) {
            CopyFileEx(FromPath, ToPath, NULL, NULL, FALSE, 0);
        }
    }
}



VOID
DbgSendMail(
    IN PCHAR    Subject,
    IN PCHAR    Content
    )
/*++
Routine Description:
    Send mail as the default user.

Arguments:
    Subject
    Message

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgSendMail:"

    DWORD   MStatus;

    //
    // Nobody to send mail to
    //
    if (!DebugInfo.Recipients) {
        return;
    }

    //
    // Load the mail library and find our entry points
    //
    MailLib = LoadLibrary(L"mapi32.dll");
    if(!HANDLE_IS_VALID(MailLib)) {
        DPRINT_WS(0, ":S: Load mapi32.dll failed;", GetLastError());
        return;
    }
    MailLogon = (LPMAPILOGON)GetProcAddress(MailLib, "MAPILogon");
    MailLogoff = (LPMAPILOGOFF)GetProcAddress(MailLib, "MAPILogoff");
    MailSend = (LPMAPISENDMAIL)GetProcAddress(MailLib, "MAPISendMail");

    if (!MailLogon || !MailLogoff || !MailSend) {
        DPRINT(0, ":S: ERROR - Could not find mail symbols in mapi32.dll\n");
        FreeLibrary(MailLib);
        return;
    }

    //
    // Log on with the specified profile
    //
    MStatus = MailLogon(0, DebugInfo.Profile, 0, 0, 0, &MailSession);
    if(MStatus) {
        DPRINT1_WS(0, ":S: ERROR - MailLogon failed; MStatus %d;",
                   MStatus, GetLastError());
        FreeLibrary(MailLib);
        return;
    }

    //
    // Send the mail
    //
    Recips.lpszName = DebugInfo.Recipients;
    Message.lpszSubject = Subject;
    Message.lpszNoteText = Content;
    MStatus = MailSend(MailSession, 0, &Message, 0, 0);

    if(MStatus) {
        DPRINT1_WS(0, ":S: ERROR - MailSend failed MStatus %d;", MStatus, GetLastError());
    }

    //
    // Log off and free the library
    //
    MailLogoff(MailSession, 0, 0, 0);
    FreeLibrary(MailLib);
}


VOID
DbgSymbolPrint(
    IN ULONG        Severity,
    IN PCHAR        Debsub,
    IN UINT         LineNo,
    IN ULONG_PTR    Addr
    )
/*++
Routine Description:
    Print a symbol

Arguments:
    Addr

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgSymbolPrint:"

    ULONG_PTR Displacement = 0;

    struct MyMymbol {
        IMAGEHLP_SYMBOL Symbol;
        char Path[MAX_PATH];
    } MySymbol;


    try {
        ZeroMemory(&MySymbol, sizeof(MySymbol));
        MySymbol.Symbol.SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
        MySymbol.Symbol.MaxNameLength = MAX_PATH;

        if (!SymGetSymFromAddr(ProcessHandle, Addr, &Displacement, &MySymbol.Symbol)) {
            DebPrint(Severity, "++ \t   0x%08x: Unknown Symbol (WStatus %s)\n",
                    Debsub, LineNo, Addr, ErrLabelW32(GetLastError()));
        } else
            DebPrint(Severity, "++ \t   0x%08x: %s\n",
                    Debsub, LineNo, Addr, MySymbol.Symbol.Name);

    } except (EXCEPTION_EXECUTE_HANDLER) {
          DebPrint(Severity, "++ \t   0x%08x: Unknown Symbol (WStatus %s)\n",
                  Debsub, LineNo, Addr, ErrLabelW32(GetExceptionCode()));
        /* FALL THROUGH */
    }
}


VOID
DbgModulePrint(
    IN PWCHAR   Prepense,
    IN ULONG    Addr
    )
/*++
Routine Description:
    Print info about a module containing Addr

Arguments:
    Prepense    - prettypring; printed at the beginning of each line
    Addr

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgModulePrint:"

    IMAGEHLP_MODULE mi;

    try {
        ZeroMemory(&mi, sizeof(mi));
        mi.SizeOfStruct = sizeof(IMAGEHLP_MODULE);

        if (!SymGetModuleInfo(ProcessHandle, Addr, &mi)) {
            DPRINT1_WS(0, "++ %ws <unknown module;", Prepense, GetLastError());
        } else
            DPRINT2(0, "++ %ws Module is %ws\n", Prepense, mi.ModuleName);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        /* FALL THROUGH */
    }
}


VOID
DbgStackPrint(
    IN ULONG        Severity,
    IN PCHAR        Debsub,
    IN UINT         LineNo,
    IN PULONG_PTR   Stack,
    IN ULONG        Depth
    )
/*++
Routine Description:
    Print the previously acquired stack trace.

Arguments:
    Prepense    - prettypring; printed at the beginning of each line
    Stack       - "return PC" from each frame
    Depth       - Only this many frames

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgStackPrint:"

    ULONG  i;

    try {
        for (i = 0; i < Depth && *Stack; ++i, ++Stack) {
            DbgSymbolPrint(Severity, Debsub, LineNo, *Stack);
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        /* FALL THROUGH */
    }
}



VOID
DbgStackTrace(
    IN PULONG_PTR   Stack,
    IN ULONG    Depth
    )
/*++
Routine Description:
    Trace the stack back up to Depth frames. The current frame is included.

Arguments:
    Stack   - Saves the "return PC" from each frame
    Depth   - Only this many frames

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgStackTrace:"

    ULONG       WStatus;
    HANDLE      ThreadHandle;
    STACKFRAME  Frame;
    ULONG       i = 0;
    CONTEXT     Context;
    ULONG       FrameAddr;

    //
    // I don't know how to generate a stack for an alpha, yet. So, just
    // to get into the build, disable the stack trace on alphas.
    //
    if (Stack) {
        *Stack = 0;
    }
#if ALPHA
    return;
#elif IA64

    //
    // Need stack dump init for IA64.
    //

    return;

#else

    //
    // init
    //

    ZeroMemory(&Context, sizeof(Context));
    ThreadHandle = GetCurrentThread();

    try { try {
        Context.ContextFlags = CONTEXT_FULL;
        if (!GetThreadContext(ThreadHandle, &Context)) {
            DPRINT_WS(0, "++ Can't get context;", GetLastError());
        }

        //
        // let's start clean
        //
        ZeroMemory(&Frame, sizeof(STACKFRAME));

        //
        // from  nt\private\windows\screg\winreg\server\stkwalk.c
        //
        Frame.AddrPC.Segment = 0;
        Frame.AddrPC.Mode = AddrModeFlat;

#ifdef _M_IX86
        Frame.AddrFrame.Offset = Context.Ebp;
        Frame.AddrFrame.Mode = AddrModeFlat;

        Frame.AddrStack.Offset = Context.Esp;
        Frame.AddrStack.Mode = AddrModeFlat;

        Frame.AddrPC.Offset = (DWORD)Context.Eip;
#elif defined(_M_MRX000)
        Frame.AddrPC.Offset = (DWORD)Context.Fir;
#elif defined(_M_ALPHA)
        Frame.AddrPC.Offset = (DWORD)Context.Fir;
#endif



#if 0
        //
        // setup the program counter
        //
        Frame.AddrPC.Mode = AddrModeFlat;
        Frame.AddrPC.Segment = (WORD)Context.SegCs;
        Frame.AddrPC.Offset = (ULONG)Context.Eip;

        //
        // setup the frame pointer
        //
        Frame.AddrFrame.Mode = AddrModeFlat;
        Frame.AddrFrame.Segment = (WORD)Context.SegSs;
        Frame.AddrFrame.Offset = (ULONG)Context.Ebp;

        //
        // setup the stack pointer
        //
        Frame.AddrStack.Mode = AddrModeFlat;
        Frame.AddrStack.Segment = (WORD)Context.SegSs;
        Frame.AddrStack.Offset = (ULONG)Context.Esp;

#endif

        for (i = 0; i < (Depth - 1); ++i) {
            if (!StackWalk(
                IMAGE_FILE_MACHINE_I386,  // DWORD                          MachineType
                ProcessHandle,            // HANDLE                         hProcess
                ThreadHandle,             // HANDLE                         hThread
                &Frame,                   // LPSTACKFRAME                   StackFrame
                NULL, //(PVOID)&Context,          // PVOID                          ContextRecord
                NULL,                     // PREAD_PROCESS_MEMORY_ROUTINE   ReadMemoryRoutine
                SymFunctionTableAccess,   // PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine
                SymGetModuleBase,         // PGET_MODULE_BASE_ROUTINE       GetModuleBaseRoutine
                NULL)) {                  // PTRANSLATE_ADDRESS_ROUTINE     TranslateAddress

                WStatus = GetLastError();

                //DPRINT1_WS(0, "++ Can't get stack address for level %d;", i, WStatus);
                break;
            }
            if (StackTraceCount-- > 0) {
                DPRINT1(5, "++ Frame.AddrReturn.Offset: %08x \n", Frame.AddrReturn.Offset);
                DbgSymbolPrint(5, DEBSUB, __LINE__, Frame.AddrReturn.Offset);
                //DPRINT1(5, "++ Frame.AddrPC.Offset: %08x \n", Frame.AddrPC.Offset);
                //DbgSymbolPrint(5, DEBSUB, __LINE__, Frame.AddrPC.Offset);
            }

            *Stack++ = Frame.AddrReturn.Offset;
            *Stack = 0;
            //
            // Base of stack?
            //
            if (!Frame.AddrReturn.Offset) {
                break;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        /* FALL THROUGH */
    } } finally {
        FRS_CLOSE(ThreadHandle);
    }
    return;
#endif ALPHA
}


VOID
DbgPrintStackTrace(
    IN ULONG    Severity,
    IN PCHAR    Debsub,
    IN UINT     LineNo
    )
/*++
Routine Description:
    Acquire and print the stack

Arguments:
    Severity
    Debsub

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgPrintStackTrace:"

    ULONG_PTR   Stack[32];

    DbgStackTrace(Stack, ARRAY_SZ(Stack) );
    DbgStackPrint(Severity, Debsub, LineNo, Stack, ARRAY_SZ(Stack) );
}


VOID
DbgStackInit(
    VOID
    )
/*++
Routine Description:
    Initialize anything necessary to get a stack trace

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgStackInit:"

    //
    // Initialize the symbol subsystem
    //
    if (!SymInitialize(ProcessHandle, NULL, FALSE)) {
        DPRINT_WS(0, ":S: Could not initialize symbol subsystem (imagehlp)" ,GetLastError());
    }

    //
    // Load our symbols
    //
    if (!SymLoadModule(ProcessHandle, NULL, DbgExePathA, "FRS", 0, 0)) {
        DPRINT1_WS(0, ":S: Could not load symbols for %s", DbgExePathA ,GetLastError());
    }

    //
    // Search path
    //
    if (!SymGetSearchPath(ProcessHandle, DbgSearchPath, MAX_PATH)) {
        DPRINT_WS(0, ":S: Can't get search path; error %s", GetLastError());
    } else {
        DPRINT1(0, ":S: Symbol search path is %s\n", DbgSearchPath);
    }

}


void
DbgShowConfig(
    VOID
    )
/*++
Routine Description:
    Display the OS Version info and the Processor Architecture info.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgShowConfig:"


    ULONG ProductType;
    ULONG Arch;

    if (DebugInfo.BuildLab != NULL) {
        DPRINT1(0, ":H:  BuildLab : %s\n",  DebugInfo.BuildLab);
    }

    DPRINT4(0, ":H:  OS Version %d.%d (%d) - %w\n",
            OsInfo.dwMajorVersion,OsInfo.dwMinorVersion,OsInfo.dwBuildNumber,OsInfo.szCSDVersion);

    ProductType = (ULONG) OsInfo.wProductType;
    DPRINT4(0, ":H:  SP (%hd.%hd) SM: 0x%04hx  PT: 0x%02x\n",
            OsInfo.wServicePackMajor,OsInfo.wServicePackMinor,OsInfo.wSuiteMask, ProductType);

    Arch = SystemInfo.wProcessorArchitecture;
    if (Arch >= ARRAY_SZ(ProcessorArchName)) {
        Arch = ARRAY_SZ(ProcessorArchName)-1;
    }

    DPRINT5(0, ":H:  Processor: %s  Level: 0x%04hx  Revision: 0x%04hx  Processor num/mask: %d/%08x\n",
           ProcessorArchName[Arch], SystemInfo.wProcessorLevel,
           SystemInfo.wProcessorRevision, SystemInfo.dwNumberOfProcessors,
           SystemInfo.dwActiveProcessorMask);

}



VOID
DbgCaptureThreadInfo(
    PWCHAR   ArgName,
    PTHREAD_START_ROUTINE EntryPoint
    )
/*++
Routine Description:
    Search the KnownThreadArray for an entry with a matching name.  If not found,
    Search the FRS Thread list for the thread with the matching entry point.
    If found make an entry in the KnownThreadArray so it is available when
    printing out the debug log header.

Arguments:
    ArgName -- Printable name of thread.
    Main  --  Entry point of thread.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgCaptureThreadInfo:"

    PFRS_THREAD FrsThread;
    ULONG i;

    if (ArgName == NULL) {
        return;
    }

    for (i = 0; i < ARRAY_SZ(KnownThreadArray); i++) {
        //
        // Any room left?
        //
        if ((KnownThreadArray[i].Name == NULL) ||
            (WSTR_EQ(ArgName, KnownThreadArray[i].Name))) {

            FrsThread = ThSupGetThread(EntryPoint);
            if (FrsThread == NULL) {
                return;
            }

            KnownThreadArray[i].EntryPoint = FrsThread->Main;
            KnownThreadArray[i].Id = FrsThread->Id;
            KnownThreadArray[i].Name = ArgName;

            ThSupReleaseRef(FrsThread);
            break;
        }
    }
}



VOID
DbgCaptureThreadInfo2(
    PWCHAR   ArgName,
    PTHREAD_START_ROUTINE EntryPoint,
    ULONG    ThreadId
    )
/*++
Routine Description:
    Search the KnownThreadArray for an entry with a matching name.
    If found make an entry in the KnownThreadArray so it is available when
    printing out the debug log header.

Arguments:
    ArgName -- Printable name of thread.
    Main  --  Entry point of thread.
    ThreadId - Thread ID of the thread to add to the list.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgCaptureThreadInfo2:"

    ULONG i;

    if (ArgName == NULL) {
        return;
    }

    for (i = 0; i < ARRAY_SZ(KnownThreadArray); i++) {
        //
        // Any room left or
        // See if we already have this one and update the thread ID if so.
        // If it was a cmd server thread it may have exited after timeout.
        //
        if ((KnownThreadArray[i].Name == NULL) ||
            (WSTR_EQ(ArgName, KnownThreadArray[i].Name))) {
            KnownThreadArray[i].EntryPoint = EntryPoint;
            KnownThreadArray[i].Id = ThreadId;
            KnownThreadArray[i].Name = ArgName;
            break;
        }
    }
}




VOID
DbgPrintThreadIds(
    IN ULONG Severity
    )
/*++
Routine Description:
    Print the known thread IDs.

Arguments:
    Severity

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgPrintThreadIds:"

    ULONG i;

    DPRINT(Severity, ":H: Known thread IDs -\n");

    //
    // Dump the known thread IDs.
    //
    for (i = 0; i < ARRAY_SZ(KnownThreadArray); i++) {
        if (KnownThreadArray[i].Name != NULL) {
            DPRINT2(Severity, ":H: %-20ws : %d\n",
                    KnownThreadArray[i].Name, KnownThreadArray[i].Id);
        }
    }
}



VOID
DbgPrintInfo(
    IN ULONG Severity
    )
/*++
Routine Description:
    Print the debug info struct

Arguments:
    Severity

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgPrintInfo:"

    WCHAR   TimeBuf[MAX_PATH];
    WCHAR   Uname[MAX_PATH + 1];
    ULONG   Unamesize = MAX_PATH + 1;
    ULONG   i;

    //
    // Username
    //
    if (!GetUserName(Uname, &Unamesize)) {
        Uname[0] = L'\0';
    }

    TimeBuf[0] = L'\0';
    GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, NULL, NULL, TimeBuf, MAX_PATH);

    DPRINT3(Severity, ":H: Service running on %ws as %ws at %ws\n",
            ComputerName, Uname, TimeBuf);

    DPRINT(Severity, "\n");
    DPRINT(Severity, ":H: ***** COMPILE INFORMATION:\n");
    DPRINT1(Severity, ":H: \tModule         %s\n", NtFrsModule);
    DPRINT2(Severity, ":H: \tCompile Date   %s %s\n", NtFrsDate, NtFrsTime);

    i = 0;
    while (LatestChanges[i] != NULL) {
        DPRINT1(Severity, ":H:   %s\n", LatestChanges[i]);
        i++;
    }

    DPRINT(Severity, "\n");
    DbgShowConfig();

    DPRINT(Severity, "\n");
    DPRINT(Severity, ":H: ***** DEBUG INFORMATION:\n");
    DPRINT1(Severity, ":H:  Total Log Lines: %d\n",  DebugInfo.TotalLogLines);
    DPRINT1(Severity, ":H:  Severity       : %d\n",  DebugInfo.Severity);
    DPRINT1(Severity, ":H:  Log Severity   : %d\n",  DebugInfo.LogSeverity);
    DPRINT1(Severity, ":H:  Log Flush Int. : %d\n",  DebugInfo.LogFlushInterval);
    DPRINT1(Severity, ":H:  Systems        : %ws\n", DebugInfo.Systems);
    DPRINT1(Severity, ":H:  Thread Id      : %d\n",  DebugInfo.ThreadId);
    DPRINT1(Severity, ":H:  Disabled       : %s\n",  (DebugInfo.Disabled) ? "TRUE" : "FALSE");
    DPRINT1(Severity, ":H:  Suppress       : %s\n",  (DebugInfo.Suppress) ? "TRUE" : "FALSE");
    DPRINT1(Severity, ":H:  Log File       : %ws\n", DebugInfo.LogFile);
    DPRINT1(Severity, ":H:  Max Log Lines  : %d\n",  DebugInfo.MaxLogLines);
    DPRINT1(Severity, ":H:  Log Lines      : %d\n",  DebugInfo.LogLines);
    DPRINT1(Severity, ":H:  Interval       : %d\n",  DebugInfo.Interval);
    DPRINT1(Severity, ":H:  TestFid        : %d\n",  DebugInfo.TestFid);
    DPRINT1(Severity, ":H:  Recipients     : %s\n",  DebugInfo.Recipients);
    DPRINT1(Severity, ":H:  Profile        : %s\n",  DebugInfo.Profile);
    DPRINT1(Severity, ":H:  Assert Share   : %ws\n", DebugInfo.AssertShare);
    DPRINT1(Severity, ":H:  Copy Logs      : %s\n",  (DebugInfo.CopyLogs) ? "TRUE" : "FALSE");
    DPRINT1(Severity, ":H:  Assert Files   : %d\n",  DebugInfo.AssertFiles);
    DPRINT1(Severity, ":H:  Log Files      : %d\n",  DebugInfo.LogFiles);
    DPRINT1(Severity, ":H:  UnjoinTrigger  : %d\n",  DebugInfo.UnjoinTrigger);
    DPRINT1(Severity, ":H:  Force VvJoin   : %s\n",  (DebugInfo.ForceVvJoin) ? "TRUE" : "FALSE");
    DPRINT1(Severity, ":H:  Check Mem      : %s\n",  (DebugInfo.Mem) ? "TRUE" : "FALSE");
    DPRINT1(Severity, ":H:  Compact Mem    : %s\n",  (DebugInfo.MemCompact) ? "TRUE" : "FALSE");
    DPRINT1(Severity, ":H:  Check Queues   : %s\n",  (DebugInfo.Queues) ? "TRUE" : "FALSE");
    if (DebugInfo.AssertSeconds) {
        DPRINT1(Severity, ":H:  Assert Seconds : Assert after %d seconds\n",
                DebugInfo.AssertSeconds);
    } else {
        DPRINT(Severity, ":H:  Assert Seconds : Don't force an assert\n");
    }
    if (DebugInfo.RestartSeconds) {
        DPRINT1(Severity, ":H:  Restart Seconds: Restart if assert after "
                "%d seconds\n",  DebugInfo.RestartSeconds);
    } else {
        DPRINT(Severity, ":H:  Restart Seconds: Don't Restart\n");
    }
    DPRINT1(Severity, ":H:  Restart        : %s\n",  (DebugInfo.Restart) ? "TRUE" : "FALSE");
    DPRINT1(Severity, ":H:  VvJoinTests    : %s\n",  (DebugInfo.VvJoinTests) ? "TRUE" : "FALSE");
    // DPRINT1(Severity, ":H:  Command Line   : %ws\n", DebugInfo.CommandLine);
    DPRINT1(Severity, ":H:  FetchRetryTrigger  : %d\n",  DebugInfo.FetchRetryTrigger);
    DPRINT1(Severity, ":H:  FetchRetryReset    : %d\n",  DebugInfo.FetchRetryReset);
    DPRINT1(Severity, ":H:  FetchRetryResetInc : %d\n",  DebugInfo.FetchRetryInc);
    DPRINT(Severity, "\n");

    DbgPrintThreadIds(Severity);

    DEBUG_FLUSH();
}



VOID
DbgPrintAllStats(
    VOID
    )
/*++
Routine Description:
    Print the stats we know about

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgPrintAllStats:"

    DbgPrintInfo(DebugInfo.LogSeverity);
    FrsPrintAllocStats(DebugInfo.LogSeverity, NULL, 0);
    FrsPrintRpcStats(DebugInfo.LogSeverity, NULL, 0);
}


VOID
DbgFlush(
    VOID
    )
/*++
Routine Description:
    Flush the output buffers

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgFlush:"

    DebLock();
    if (DebugInfo.LogFILE) {
        fflush(DebugInfo.LogFILE);
        DbgFlushInterval = DebugInfo.LogFlushInterval;
    }
    DebUnLock();
}


VOID
DbgStartService(
    IN PWCHAR   ServiceName
    )
/*++
Routine Description:
    Start a service on this machine.

Arguments:
    ServiceName - the service to start

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgStartService:"

    SC_HANDLE   ServiceHandle;

    //
    // Open the service.
    //
    ServiceHandle = FrsOpenServiceHandle(NULL, ServiceName);
    if (!HANDLE_IS_VALID(ServiceHandle)) {
        DPRINT1(0, ":S: Couldn't open service %ws\n", ServiceName);
        return;
    }
    //
    // Start the service
    //
    if (!StartService(ServiceHandle, 0, NULL)) {
        DPRINT1_WS(0, ":S: Couldn't start %ws;", ServiceName, GetLastError());
        CloseServiceHandle(ServiceHandle);
        return;
    }
    CloseServiceHandle(ServiceHandle);
    DPRINT1(4, ":S: Started %ws\n", ServiceName);
}


VOID
DbgStopService(
    IN PWCHAR  ServiceName
    )
/*++
Routine Description:
    Stop a service on this machine.

Arguments:
    ServiceName - the service to stop

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgStopService:"


    BOOL            Status;
    SC_HANDLE       ServiceHandle;
    SERVICE_STATUS  ServiceStatus;

    //
    // Open the service.
    //
    ServiceHandle = FrsOpenServiceHandle(NULL, ServiceName);
    if (!HANDLE_IS_VALID(ServiceHandle)) {
        DPRINT1(0, ":S: Couldn't stop service %ws\n", ServiceName);
        return;
    }

    //
    // Stop the service
    //
    Status = ControlService(ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus);
    if (!WIN_SUCCESS(Status)) {
        DPRINT1_WS(0, ":S: Couldn't stop %ws;", ServiceName, GetLastError());
        CloseServiceHandle(ServiceHandle);
        return;
    }
    CloseServiceHandle(ServiceHandle);
    DPRINT1(4, ":S: Stopped %ws\n", ServiceName);
}



ULONG
DbgForceAssert(
    IN PVOID Ignored
    )
/*++
Routine Description:
    Force an assert after some seconds

Arguments:
    Ignored

Return Value:
    ERROR_SUCCESS
--*/
{
#undef DEBSUB
#define DEBSUB "DbgForceAssert:"

    BOOL    ForcingAssert = TRUE;

    //
    // Wait for a shutdown event
    //
    WaitForSingleObject(ShutDownEvent, DebugInfo.AssertSeconds * 1000);
    if (!FrsIsShuttingDown) {
        DPRINT(0, ":S: FORCING ASSERT\n");
        FRS_ASSERT(!ForcingAssert);
    }
    return STATUS_SUCCESS;
}


VOID
DbgQueryLogParams(
    )
/*++
Routine Description:

    Read the registry for new values for the logging params.

Arguments:

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgQueryLogParams:"

    PWCHAR  WStr, WStr1;
    PCHAR   AStr;
    PWCHAR  NewLogDirStr = NULL;
    PWCHAR  File;
    DWORD   WStatus;
    DWORD   NewDisabled;
    BOOL    OpenNewLog = FALSE;
    ULARGE_INTEGER FreeBytes;
    ULARGE_INTEGER TotalBytes;

    //
    //  Get new state before taking debug lock since function does DPRINTs.
    //
    CfgRegReadDWord(FKC_DEBUG_DISABLE, NULL, 0, &NewDisabled);

    //
    //  Check for a change in Disable Debug
    //
    DebLock();
    if ((BOOL)NewDisabled != DebugInfo.Disabled) {

        DebugInfo.Disabled = NewDisabled;

        if (DebugInfo.Disabled) {
            //
            // Stop logging.
            //
            if (DebugInfo.LogFILE) {
                fflush(DebugInfo.LogFILE);
                DbgFlushInterval = DebugInfo.LogFlushInterval;
                fclose(DebugInfo.LogFILE);
            }
            DebugInfo.LogFILE = NULL;

        } else {
            //
            // Start logging.
            //
            OpenNewLog = TRUE;
        }
    }

    DebUnLock();

    //
    // Quit now if logging is disabled.
    //
    if (DebugInfo.Disabled) {
        return;
    }

    //
    //   Log File Directory  (only if not running multiple servers on one machine)
    //
    if (ServerName == NULL) {
        CfgRegReadString(FKC_DEBUG_LOG_FILE, NULL, 0, &NewLogDirStr);
        if (NewLogDirStr != NULL) {
            if ((DebugInfo.LogDir == NULL) ||
                 WSTR_NE(NewLogDirStr, DebugInfo.LogDir)) {
                OpenNewLog = TRUE;
            } else {
                NewLogDirStr = FrsFree(NewLogDirStr);
            }
        }
    }

    //
    //   Number of log files
    //
    CfgRegReadDWord(FKC_DEBUG_LOG_FILES, NULL, 0, &DebugInfo.LogFiles);

    //
    //   Flush the trace log after every n lines.
    //
    CfgRegReadDWord(FKC_DEBUG_LOG_FLUSH_INTERVAL, NULL, 0, &DebugInfo.LogFlushInterval);

    //
    //   Severity for console print.
    //
    CfgRegReadDWord(FKC_DEBUG_SEVERITY, NULL, 0, &DebugInfo.Severity);

    //
    //   Log Severity
    //
    CfgRegReadDWord(FKC_DEBUG_LOG_SEVERITY, NULL, 0, &DebugInfo.LogSeverity);

    //
    //   Systems - selected list of functions to trace.  trace all if NULL.
    //
    CfgRegReadString(FKC_DEBUG_SYSTEMS, NULL, 0, &WStr);
    if (WStr != NULL) {
        AStr = DebugInfo.Systems;
        DebLock();
        DebugInfo.Systems = (wcslen(WStr)) ? FrsWtoA(WStr) : NULL;
        DebUnLock();
        WStr = FrsFree(WStr);
        AStr = FrsFree(AStr);
    }

    //
    //   Maximum Log Messages
    //
    CfgRegReadDWord(FKC_DEBUG_MAX_LOG,  NULL, 0, &DebugInfo.MaxLogLines);

    //
    //   Debugger serial line Print  (assume suppress so no dprints leak out)
    //
    DebugInfo.Suppress = TRUE;
    CfgRegReadDWord(FKC_DEBUG_SUPPRESS, NULL, 0, &DebugInfo.Suppress);

    //
    //   Enable break into debugger if present.
    //
    CfgRegReadDWord(FKC_DEBUG_BREAK,  NULL, 0, &DebugInfo.Break);

    //
    // Open a new log if logging was just turned on or if we were.
    // having trouble logging due to errors like out of disk space.
    // Save old log files and open a new log file.
    //
    if ((OpenNewLog || DebugInfo.LogFILE == NULL) &&
        ((DebugInfo.LogFile != NULL) || (NewLogDirStr != NULL))) {

        WStr = DebugInfo.LogFile;
        WStr1 = DebugInfo.LogDir;
        DebLock();

        if (NewLogDirStr != NULL) {
            //
            // Add the filename prefix to the end of the dir path.
            //
            DebugInfo.LogDir = NewLogDirStr;
            DebugInfo.LogFile = FrsWcsCat(NewLogDirStr, NTFRS_DBG_LOG_FILE);
        }

        //
        // Create new debug directory
        //
        if (!CreateDirectory(DebugInfo.LogDir, NULL)) {
            WStatus = GetLastError();

            if (!WIN_ALREADY_EXISTS(WStatus)) {
                DebugInfo.LogFile = FrsFree(DebugInfo.LogFile);
                DebugInfo.LogDir = FrsFree(DebugInfo.LogDir);
            }
        }

        if (DebugInfo.LogFile != NULL) {
            if (DebugInfo.LogFILE) {
                fclose(DebugInfo.LogFILE);
            }

            DbgShiftLogFiles(DebugInfo.LogFile,
                             LOG_FILE_SUFFIX,
                             (DebugInfo.CopyLogs) ? DebugInfo.AssertShare : NULL,
                             DebugInfo.LogFiles);
            DbgOpenLogFile();
        }

        DebUnLock();

        if (NewLogDirStr != NULL) {
            WStr = FrsFree(WStr);
            WStr1 = FrsFree(WStr1);
        }
    }

    //
    // Raise a eventlog message if there isn't enough disk space on the logging volume
    // to accomodate all the log files.
    //
    if (DebugInfo.LogDir != NULL) {
        FreeBytes.QuadPart = QUADZERO;
        TotalBytes.QuadPart = QUADZERO;
        if (GetDiskFreeSpaceEx(DebugInfo.LogDir,
                           &FreeBytes,
                           &TotalBytes,
                           NULL)) {
            //
            // Complain if we have less than 10 MB free.
            //
            if (FreeBytes.QuadPart < (10 * 1000 * 1000)) {
                EPRINT1(EVENT_FRS_LOG_SPACE, DebugInfo.LogDir);
            }
        }
    }


}



VOID
DbgQueryDynamicConfigParams(
    )
/*++
Routine Description:

    Read the registry for new values for config params that can change
    while service is running.

Arguments:

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgQueryDynamicConfigParams:"

    DWORD CompressStagingFiles = 1;


    //
    // Pick up new debug logging related parameters.
    //
    DbgQueryLogParams();

    //
    // Read the new value for the compression parameter.
    //
    CfgRegReadDWord(FKC_DISABLE_COMPRESSION_STAGING_FILE, NULL, 0, &DisableCompressionStageFiles);
    CfgRegReadDWord(FKC_COMPRESS_STAGING_FILES, NULL, 0, &CompressStagingFiles);
    //
    // Note:  The key FKC_DISABLE_COMPRESSION_STAGING_FILE will be removed and
    // replaced by FKC_COMPRESS_STAGING_FILES.  For now look at both and use the
    // new key as an override.
    //
    if (CompressStagingFiles != 0) {
        DisableCompressionStageFiles = FALSE;
    } else {
        DisableCompressionStageFiles = TRUE;
    }

    //
    // Pick up the Outlog file repeat interval.
    //
    CfgRegReadDWord(FKC_OUTLOG_REPEAT_INTERVAL, NULL, 0, &GOutLogRepeatInterval);

}


VOID
DbgInitLogTraceFile(
    IN LONG    argc,
    IN PWCHAR  *argv
    )
/*++
Routine Description:

    Initialize enough of the debug subsystem to start the log file.
    The rest can wait until we have synced up with the service controller.

Arguments:
    argc    - from main
    argv    - from main; in wide char format

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgInitLogTraceFile:"

    PWCHAR  WStr;
    PWCHAR  File;
    DWORD   WStatus;


    InitializeCriticalSection(&DebugInfo.Lock);
    InitializeCriticalSection(&DebugInfo.DbsOutOfSpaceLock);

    //
    // Configure initial debug params until we read registry.
    //
    DebugInfo.AssertSeconds = 0;
    DebugInfo.RestartSeconds = 0;
    DebugInfo.Queues = 0;
    DebugInfo.DbsOutOfSpace = DBG_DBS_OUT_OF_SPACE_OP_NONE;
    DebugInfo.DbsOutOfSpaceTrigger = 0;

    //
    // Get the logging config params.
    // Registry overrides defaults and CLI overrides registry.
    //

    //
    //   Disable Debug
    //
    CfgRegReadDWord(FKC_DEBUG_DISABLE, NULL, 0, &DebugInfo.Disabled);
    if (FrsSearchArgv(argc, argv, L"disabledebug", NULL)) {
        DebugInfo.Disabled = TRUE;
    }

    //
    //   Log File (really the dir containing the log files)
    //
    FrsSearchArgv(argc, argv, L"logfile", &DebugInfo.LogDir);
    if (DebugInfo.LogDir == NULL) {
        CfgRegReadString(FKC_DEBUG_LOG_FILE, NULL, 0, &DebugInfo.LogDir);
    }

    if (DebugInfo.LogDir != NULL) {
        //
        // Add the filename prefix to the end of the dir path.
        //
        DebugInfo.LogFile = FrsWcsCat(DebugInfo.LogDir, NTFRS_DBG_LOG_FILE);
    } else {
        DebugInfo.LogFile = NULL;
    }


    //
    //   Share for copying log/assert files
    //
    FrsSearchArgv(argc, argv, L"assertshare", &DebugInfo.AssertShare);
    if (DebugInfo.AssertShare == NULL) {
        CfgRegReadString(FKC_DEBUG_ASSERT_SHARE, NULL, 0, &DebugInfo.AssertShare);
    }

    //
    //   Copy log files into assert share
    //
    CfgRegReadDWord(FKC_DEBUG_COPY_LOG_FILES, NULL, 0, &DebugInfo.CopyLogs);

    //
    //   Number of assert files
    //
    if (!FrsSearchArgvDWord(argc, argv, L"assertfiles", &DebugInfo.AssertFiles)) {
        CfgRegReadDWord(FKC_DEBUG_ASSERT_FILES, NULL, 0, &DebugInfo.AssertFiles);
    }

    //
    //   Number of log files
    //
    if (!FrsSearchArgvDWord(argc, argv, L"logfiles", &DebugInfo.LogFiles)) {
        CfgRegReadDWord(FKC_DEBUG_LOG_FILES, NULL, 0, &DebugInfo.LogFiles);
    }

    //
    //   Flush the trace log after every n lines.
    //
    if (!FrsSearchArgvDWord(argc, argv, L"logflushinterval", &DebugInfo.LogFlushInterval)) {
        CfgRegReadDWord(FKC_DEBUG_LOG_FLUSH_INTERVAL, NULL, 0, &DebugInfo.LogFlushInterval);
    }

    //
    // Create the dir path to the share where Assert Logs are copied.
    //
    if ((DebugInfo.AssertShare != NULL) &&
         wcslen(DebugInfo.AssertShare) && wcslen(ComputerName)) {

        WStr = FrsWcsCat3(DebugInfo.AssertShare, L"\\", ComputerName);
        FrsFree(DebugInfo.AssertShare);
        DebugInfo.AssertShare = WStr;
        WStr = NULL;
    }

    //
    //   Severity for console print.
    //
    if (!FrsSearchArgvDWord(argc, argv, L"severity", &DebugInfo.Severity)) {
        CfgRegReadDWord(FKC_DEBUG_SEVERITY, NULL, 0, &DebugInfo.Severity);
    }

    //
    //   Log Severity
    //
    if (!FrsSearchArgvDWord(argc, argv, L"logseverity", &DebugInfo.LogSeverity)) {
        CfgRegReadDWord(FKC_DEBUG_LOG_SEVERITY, NULL, 0, &DebugInfo.LogSeverity);
    }

    //
    //   Systems - selected list of functions to trace.  trace all if NULL.
    //
    DebugInfo.Systems = NULL;
    if (!FrsSearchArgv(argc, argv, L"systems", &WStr)) {
        CfgRegReadString(FKC_DEBUG_SYSTEMS, NULL, 0, &WStr);
    }
    if (WStr != NULL) {
        DebugInfo.Systems = (wcslen(WStr)) ? FrsWtoA(WStr) : NULL;
        WStr = FrsFree(WStr);
    }

    //
    //   Maximum Log Messages
    //
    DebugInfo.MaxLogLines = DEFAULT_DEBUG_MAX_LOG;
    if (!FrsSearchArgvDWord(argc, argv, L"maxloglines", &DebugInfo.MaxLogLines)) {
        CfgRegReadDWord(FKC_DEBUG_MAX_LOG,  NULL, 0, &DebugInfo.MaxLogLines);
    }

    //
    //   Debugger serial line Print  (assume suppress so no dprints leak out)
    //
    DebugInfo.Suppress = TRUE;
    if (!FrsSearchArgv(argc, argv, L"debuggerprint", NULL)) {
        CfgRegReadDWord(FKC_DEBUG_SUPPRESS, NULL, 0, &DebugInfo.Suppress);
    } else {
        DebugInfo.Suppress = FALSE;
    }

    //
    //   Enable break into debugger if present.
    //
    DebugInfo.Break = TRUE;
    if (!FrsSearchArgv(argc, argv, L"break", NULL)) {
        CfgRegReadDWord(FKC_DEBUG_BREAK,  NULL, 0, &DebugInfo.Break);
    }

    //
    // Turn on debug log if desired.
    // Save old log files and open a new log file.
    //
    if (DebugInfo.LogFile != NULL) {
        //
        // Create the debug directory
        //
        if (!CreateDirectory(DebugInfo.LogDir, NULL)) {
            WStatus = GetLastError();

            if (!WIN_ALREADY_EXISTS(WStatus)) {
                //
                // Need some way to report the following.
                //
                //DPRINT1_WS(0, ":S: CreateDirectory(Logfile) %ws -- failed;",
                //           DebugInfo.LogFile, WStatus);
                DebugInfo.LogFile = FrsFree(DebugInfo.LogFile);
                DebugInfo.LogDir = FrsFree(DebugInfo.LogDir);
            }
        }

        if (DebugInfo.LogFile != NULL) {
            DbgShiftLogFiles(DebugInfo.LogFile,
                             LOG_FILE_SUFFIX,
                            (DebugInfo.CopyLogs) ? DebugInfo.AssertShare : NULL,
                             DebugInfo.LogFiles);
            DbgOpenLogFile();
        }
    }

    //
    // Executable's full path for symbols.
    //
    DbgExePathW[0] = L'\0';
    if (GetFullPathNameW(argv[0], MAX_PATH-4, DbgExePathW, &File) == 0) {
        DPRINT1(0, ":S: Could not get the full pathname for %ws\n", argv[0]);
    }

    if (!wcsstr(DbgExePathW, L".exe")) {
        wcscat(DbgExePathW, L".exe");
    }
    DPRINT1(0, ":S: Full pathname for %ws\n", DbgExePathW);

    if (_snprintf(DbgExePathA, MAX_PATH, "%ws", DbgExePathW) < 0) {
        DPRINT1(0, ":S: Image path too long to get symbols for traceback: %ws\n", DbgExePathW);
        return;
    }

    //
    // Init the symbol support for stack traceback if we are tracking mem allocs.
    //      Don't use the memory subsystem until symbols are enabled
    //
    if (DebugInfo.Mem) {
        DbgStackInit();
    }

}


VOID
DbgMustInit(
    IN LONG    argc,
    IN PWCHAR  *argv
    )
/*++
Routine Description:
    Initialize the debug subsystem

Arguments:
    argc    - from main
    argv    - from main; in wide char format

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgMustInit:"

    ULONG   Len;
    LONG    i;
    PWCHAR  Wcs;
    PWCHAR  WStr;
    DWORD   WStatus;

    //
    // Init the known thread array.
    //
    for (i = 0; i < ARRAY_SZ(KnownThreadArray); i++) {
        KnownThreadArray[i].Name = NULL;
    }
    DbgCaptureThreadInfo2(L"First", NULL, GetCurrentThreadId());

    //
    // Get some config info for the debug log header.
    //
    OsInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);
    GetVersionExW((POSVERSIONINFOW) &OsInfo);

    GetSystemInfo(&SystemInfo);

    //
    // When not running as a service, the exe will restart itself
    // after an assertion failure. When running as a service, the
    // service controller will restart the service.
    //
    // Rebuild the command line for restart.
    //
    if (!RunningAsAService) {
        #define RESTART_PARAM L" /restart"

        Len = wcslen(RESTART_PARAM) + (2 * sizeof(WCHAR));
        for (i = 0; i < argc; ++i) {
            Len += wcslen(argv[i]) + sizeof(WCHAR);
        }
        DebugInfo.CommandLine = FrsAlloc(Len * sizeof(WCHAR));

        for (i = 0; i < argc; ++i) {
            //
            // Give our parent process time to die so that it will
            // release its handles on the journal, database, ...
            //
            if (wcsstr(argv[i], L"restart")) {
                Sleep(5 * 1000);
                continue;
            }
            wcscat(DebugInfo.CommandLine, argv[i]);
            wcscat(DebugInfo.CommandLine, L" ");
        }
        wcscat(DebugInfo.CommandLine, RESTART_PARAM);
    }

    //
    //   Get rest of config params.  Command line takes precedence over registrr.
    //
    //
    //   Restart the service iff it has asserted and has run at least this long
    //   to avoid assert loops.
    //
    if (!FrsSearchArgvDWord(argc, argv, L"restartseconds", &DebugInfo.RestartSeconds)) {
        CfgRegReadDWord(FKC_DEBUG_RESTART_SECONDS,  NULL, 0, &DebugInfo.RestartSeconds);
    }

    //
    //   Sendmail recipient (future)
    //
    DebugInfo.Recipients = NULL;
    CfgRegReadString(FKC_DEBUG_RECIPIENTS, NULL, 0, &WStr);
    if (WStr != NULL) {
        DebugInfo.Recipients = (wcslen(WStr)) ? FrsWtoA(WStr) : NULL;
        WStr = FrsFree(WStr);
    }

    //
    //   Sendmail Profile (future)
    //
    DebugInfo.Profile = NULL;
    CfgRegReadString(FKC_DEBUG_PROFILE, NULL, 0, &WStr);
    if (WStr != NULL) {
        DebugInfo.Profile = (wcslen(WStr)) ? FrsWtoA(WStr) : NULL;
        WStr = FrsFree(WStr);
    }

    //
    //   Buildlab info
    //
    DebugInfo.BuildLab = NULL;
    CfgRegReadString(FKC_DEBUG_BUILDLAB, NULL, 0, &WStr);
    if (WStr != NULL) {
        DebugInfo.BuildLab = (wcslen(WStr)) ? FrsWtoA(WStr) : NULL;
        WStr = FrsFree(WStr);
    }

    //
    // Use the hardwired config file if there is no Directory Service.
    //
    if (FrsSearchArgv(argc, argv, L"nods", &WStr)) {
        NoDs = TRUE;
        if (WStr != NULL) {
            IniFileName = wcslen(WStr) ? WStr : NULL;
        }
    }

    //
    // Single machine is pretending to be several machines
    //
    if (FrsSearchArgv(argc, argv, L"server", &WStr)) {
        if ((WStr != NULL) && (wcslen(WStr) > 0)) {
            NoDs = TRUE;
            ServerName = WStr;
        }
    }

    //
    //  The following parameters are testing / debugging.
    //

    //
    //   Check queues
    //
    DebugInfo.Queues = TRUE;
    if (!FrsSearchArgv(argc, argv, L"queues", NULL)) {
        CfgRegReadDWord(FKC_DEBUG_QUEUES, NULL, 0, &DebugInfo.Queues);
    }

    //
    //   Enable VvJoin Tests
    //
    DebugInfo.VvJoinTests = FrsSearchArgv(argc, argv, L"vvjointests", NULL);

    //
    //   forcevvjoin on every join
    //
    DebugInfo.ForceVvJoin = FrsSearchArgv(argc, argv, L"vvjoin", NULL);

    //
    //   Enable rename fid test
    //
    DebugInfo.TestFid = FrsSearchArgv(argc, argv, L"testfid", NULL);

    //
    //   forceunjoin on one cxtion after N remote co's
    //
    DebugInfo.UnjoinTrigger = 0;
    FrsSearchArgvDWord(argc, argv, L"unjoin", &DebugInfo.UnjoinTrigger);

    //
    //   forceunjoin on one cxtion after N remote co's
    //
    DebugInfo.FetchRetryReset = 0;
    if (!FrsSearchArgvDWord(argc, argv, L"fetchretry", &DebugInfo.FetchRetryReset)) {
    }
    DebugInfo.FetchRetryTrigger = DebugInfo.FetchRetryReset;
    DebugInfo.FetchRetryInc     = DebugInfo.FetchRetryReset;

    //
    // Set interval for toggling the schedule
    //
    FrsSearchArgvDWord(argc, argv, L"interval", &DebugInfo.Interval);

    //
    //   Force an assert after N seconds (0 == don't assert)
    //
    DebugInfo.AssertSeconds = 0;
    if (!FrsSearchArgvDWord(argc, argv, L"assertseconds", &DebugInfo.AssertSeconds)) {
        CfgRegReadDWord(FKC_DEBUG_ASSERT_SECONDS, NULL, 0, &DebugInfo.AssertSeconds);
    }

    //
    //   Force REAL out of space errors on database operations
    //
    DebugInfo.DbsOutOfSpace = 0;
    if (!FrsSearchArgvDWord(argc, argv, L"dbsoutOfSpace", &DebugInfo.DbsOutOfSpace)) {
        CfgRegReadDWord(FKC_DEBUG_DBS_OUT_OF_SPACE, NULL, 0, &DebugInfo.DbsOutOfSpace);
    }

    //
    //   Trigger phoney out of space errors on database operations
    //
    DebugInfo.DbsOutOfSpaceTrigger = 0;
    if (!FrsSearchArgvDWord(argc, argv, L"outofspacetrigger", &DebugInfo.DbsOutOfSpaceTrigger)) {
        CfgRegReadDWord(FKC_DEBUG_DBS_OUT_OF_SPACE_TRIGGER, NULL, 0, &DebugInfo.DbsOutOfSpaceTrigger);
    }

    //
    // Enable compression. Default will be on.
    //
    CfgRegReadDWord(FKC_DEBUG_DISABLE_COMPRESSION, NULL, 0, &DebugInfo.DisableCompression);

    //
    // Ldap Search timeout. Default is 10 minutes.
    //
    CfgRegReadDWord(FKC_LDAP_SEARCH_TIMEOUT_IN_MINUTES, NULL, 0, &LdapSearchTimeoutInMinutes);

    //
    // Ldap Bind timeout. Default is 30 seconds.
    //
    CfgRegReadDWord(FKC_LDAP_BIND_TIMEOUT_IN_SECONDS, NULL, 0, &LdapBindTimeoutInSeconds);

    //
    // Display the debug parameters.
    //
    DbgPrintInfo(0);



    //
    // Remember our start time (in minutes)
    //
    // 100-nsecs / (10 (microsecs) * 1000 (msecs) * 1000 (secs) * 60 (min)
    //
    GetSystemTimeAsFileTime((FILETIME *)&DebugInfo.StartSeconds);
    DebugInfo.StartSeconds /= (10 * 1000 * 1000);

}


VOID
DbgMinimumInit(
    VOID
    )
/*++
Routine Description:
    Called at the beginning of MainMinimumInit()

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgMinimumInit:"

    HANDLE  ThreadHandle;
    DWORD   ThreadId;
    //
    // This thread forces an assert after DebugInfo.AssertSeconds
    //
    if (DebugInfo.AssertSeconds) {
        ThreadHandle = (HANDLE)CreateThread(NULL,
                                            10000,
                                            DbgForceAssert,
                                            NULL,
                                            0,
                                            &ThreadId);

        FRS_ASSERT(HANDLE_IS_VALID(ThreadHandle));

        DbgCaptureThreadInfo2(L"ForceAssert", DbgForceAssert, ThreadId);
        FRS_CLOSE(ThreadHandle);
    }
}


BOOL
DoDebug(
    IN ULONG Sev,
    IN UCHAR *DebSub
    )
/*++
Routine Description:
    Should we print this line

Arguments:
    sev
    debsub

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DoDebug:"

    //
    // Debugging has been disabled
    //
    if (DebugInfo.Disabled) {
        return FALSE;
    }

    //
    // Not important enough
    //
    if (Sev > DebugInfo.Severity && Sev > DebugInfo.LogSeverity) {
        return FALSE;
    }

    //
    // Not tracing this subsystem
    //
    if (DebSub &&
        DebugInfo.Systems &&
        (strstr(DebugInfo.Systems, DebSub) == NULL)) {
        return FALSE;
    }
    //
    // Not tracing this thread
    //
    if (DebugInfo.ThreadId &&
        GetCurrentThreadId() != DebugInfo.ThreadId) {
        return FALSE;
    }

    return TRUE;
}


VOID
DebPrintLine(
    IN ULONG    Sev,
    IN PCHAR    Line
    )
/*++
Routine Description:
    Print a line of debug output to various combinations
    of standard out, debugger, kernel debugger, and a log file.

Arguments:
    Sev
    Line

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DebPrintLine:"

    //
    // stdout
    //
    if ((Sev <= DebugInfo.Severity) && !RunningAsAService) {
        printf("%s", Line);
    }

    //
    // log file
    //
    if (DebugInfo.LogFILE && Sev <= DebugInfo.LogSeverity) {
        //
        // Number of messages exceeded; save the old file and
        // start afresh. The existing old file is deleted.
        //
        if (DebugInfo.LogLines > DebugInfo.MaxLogLines) {
            fflush(DebugInfo.LogFILE);
            DbgFlushInterval = DebugInfo.LogFlushInterval;
            fclose(DebugInfo.LogFILE);

            DbgShiftLogFiles(DebugInfo.LogFile,
                             LOG_FILE_SUFFIX,
                             (DebugInfo.CopyLogs) ? DebugInfo.AssertShare : NULL,
                             DebugInfo.LogFiles);

            DbgOpenLogFile();
            DebugInfo.LogLines = 0;
            DebugInfo.PrintStats = TRUE;
        }

        if (DebugInfo.LogFILE) {
            fprintf(DebugInfo.LogFILE, "%s", Line);
            //
            // Flush the log file every DebugInfo.LogFlushInterval lines and on
            // every severity 0 message.
            //
            if ((--DbgFlushInterval < 0) || (Sev ==0)) {
                if (fflush(DebugInfo.LogFILE) == EOF) {
                    fclose(DebugInfo.LogFILE);
                    DebugInfo.LogFILE = NULL;
                }
                DbgFlushInterval = DebugInfo.LogFlushInterval;
            }
        }
    }

    //
    // debugger
    //
    if ((Sev <= DebugInfo.Severity) && !DebugInfo.Suppress) {
        OutputDebugStringA(Line);
    }
}


BOOL
DebFormatLine(
    IN ULONG    Sev,
    IN BOOL     Format,
    IN PCHAR    DebSub,
    IN UINT     LineNo,
    IN PCHAR    Line,
    IN ULONG    LineSize,
    IN PUCHAR   Str,
    IN va_list  argptr
    )
/*++
Routine Description:
    Format the line of output

Arguments:
    DebSub
    LineNo
    Line
    LineSize
    Str

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DebFormatLine:"

    ULONG       LineUsed;
    SYSTEMTIME  SystemTime;
    BOOL        Ret = TRUE;

    try {
        if (Format) {
            //
            // Increment the line count here to prevent counting
            // the several DPRINTs that don't have a newline.
            //
            ++DebugInfo.LogLines;
            ++DebugInfo.TotalLogLines;
            GetLocalTime(&SystemTime);

            if (_snprintf(Line,
                          LineSize,
                          "<%-31s%4u: %5u: S%1u: %02d:%02d:%02d> ",
                          (DebSub) ? DebSub : "NoName",
                          GetCurrentThreadId(),
                          LineNo,
                          Sev,
                          SystemTime.wHour,
                          SystemTime.wMinute,
                          SystemTime.wSecond) < 0) {
                Ret = FALSE;
            } else {
                LineUsed = strlen(Line);
            }

        } else {
            LineUsed = 0;
        }

        if (Ret) {
            if (((LineUsed + 1) >= LineSize) ||
                (_vsnprintf(Line + LineUsed, LineSize - LineUsed, Str, argptr) < 0)) {
                Ret = FALSE;
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Ret = FALSE;
    }

    return Ret;
}



BOOL
DebFormatTrackingLine(
    IN PCHAR    Line,
    IN ULONG    LineSize,
    IN PUCHAR   Str,
    IN va_list  argptr
    )
/*++
Routine Description:
    Format the line of output

Arguments:
    Line
    LineSize
    Str

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DebFormatTrackingLine:"

    ULONG       LineUsed = 0;
    SYSTEMTIME  SystemTime;
    BOOL        Ret = TRUE;

    try {
            //
            // Increment the line count here to prevent counting
            // the several DPRINTs that don't have a newline.
            //
            ++DebugInfo.LogLines;
            ++DebugInfo.TotalLogLines;
            GetLocalTime(&SystemTime);

            if (_snprintf(Line,
                          LineSize,
                          "%2d/%2d-%02d:%02d:%02d ",
                          SystemTime.wMonth,
                          SystemTime.wDay,
                          SystemTime.wHour,
                          SystemTime.wMinute,
                          SystemTime.wSecond) < 0) {
                Ret = FALSE;
            } else {
                LineUsed = strlen(Line);
            }


        if (Ret) {
            if (((LineUsed + 1) >= LineSize) ||
                (_vsnprintf(Line + LineUsed, LineSize - LineUsed, Str, argptr) < 0)) {
                Ret = FALSE;
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Ret = FALSE;
    }

    return Ret;
}


VOID
DebPrintTrackingNoLock(
    IN ULONG   Sev,
    IN PUCHAR  Str,
    IN ... )
/*++
Routine Description:
    Format and print a line of tracking output to various combinations
    of standard out, debugger, kernel debugger, and a log file. The
    debug print lock is held and the caller filtered lines that
    shouldn't be printed.

Arguments:
    Sev     - severity level
    Str     - printf format

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DebPrintTrackingNoLock:"


    CHAR    Buf[512];
    DWORD   BufUsed = 0;

    //
    // varargs stuff
    //
    va_list argptr;
    va_start(argptr, Str);

    //
    // Print the line to some combination of stdout, file, and debugger
    //
    if (DebFormatTrackingLine(Buf, sizeof(Buf), Str, argptr)) {
        DebPrintLine(Sev, Buf);
    }

    va_end(argptr);
}


VOID
DebLock(
    VOID
    )
/*++
Routine Description:
    Acquire the print lock

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DebLock:"

    EnterCriticalSection(&DebugInfo.Lock);
}




VOID
DebUnLock(
    VOID
    )
/*++
Routine Description:
    Release the print lock

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DebUnLock:"

    BOOL    PrintStats;

    //
    // Print summary stats close to the beginning of each
    // log file. The stats may show up a few lines into
    // the new log file when callers hold the DebLock() across
    // several lines.
    //
    // Be careful not to recurse if MaxLogLines is smaller
    // than the number of lines in the stats.
    //
    if (DebugInfo.PrintStats) {
        if (DebugInfo.PrintingStats) {
            DebugInfo.PrintStats = FALSE;
        } else {
            DebugInfo.PrintingStats = TRUE;
        }
    }
    PrintStats = DebugInfo.PrintStats;
    LeaveCriticalSection(&DebugInfo.Lock);

    if (PrintStats) {
        DbgPrintAllStats();
        EnterCriticalSection(&DebugInfo.Lock);
        DebugInfo.PrintingStats = FALSE;
        LeaveCriticalSection(&DebugInfo.Lock);
    }
}


VOID
DebPrintNoLock(
    IN ULONG   Sev,
    IN BOOL    Format,
    IN PUCHAR  Str,
    IN PCHAR   DebSub,
    IN UINT    LineNo,
    IN ... )
/*++
Routine Description:
    Format and print a line of debug output to various combinations
    of standard out, debugger, kernel debugger, and a log file. The
    debug print lock is held and the caller filtered lines that
    shouldn't be printed.

Arguments:
    Sev     - severity filter
    Format  - Add format info?
    Str     - printf format
    DebSub  - module name
    LineNo

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DebPrintNoLock:"


    CHAR    Buf[512];
    DWORD   BufUsed = 0;

    //
    // varargs stuff
    //
    va_list argptr;
    va_start(argptr, LineNo);

    //
    // Print the line to some combination of stdout, file, and debugger
    //
    if (DebFormatLine(Sev, Format, DebSub, LineNo, Buf, sizeof(Buf), Str, argptr)) {
        DebPrintLine(Sev, Buf);
    }

    va_end(argptr);
}


VOID
DebPrint(
    IN ULONG   Sev,
    IN PUCHAR  Str,
    IN PCHAR   DebSub,
    IN UINT    LineNo,
    IN ... )
/*++
Routine Description:
    Format and print a line of debug output to various combinations
    of standard out, debugger, kernel debugger, and a log file.

Arguments:
    sev     - severity filter
    str     - printf format
    debsub  - module name
    LineNo

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DebPrint:"


    CHAR    Buf[512];
    DWORD   BufUsed = 0;

    //
    // varargs stuff
    //
    va_list argptr;
    va_start(argptr, LineNo);

    //
    // Don't print this
    //
    if (!DoDebug(Sev, DebSub)) {
        return;
    }

    //
    // Print the line to some combination of stdout, file, and debugger
    //
    DebLock();
    if (DebFormatLine(Sev, TRUE, DebSub, LineNo, Buf, sizeof(Buf), Str, argptr)) {
        DebPrintLine(Sev, Buf);
    }

    DebUnLock();
    va_end(argptr);

#if 0

static int                      failedload                  = FALSE;
static TRANSMITSPECIALFRAME_FN  lpfnTransmitSpecialFrame    = NULL;
        //
        //  Calling nal.dll from inside lsa causes a deadlock during startup
        //
        if ( /* (!RunningAsAService) &&*/  // davidor - lets try it.
            (NmDebugTest(sev, DebSub)))
        {
            if (failedload == FALSE) {

                //
                //  Only try to load the NetMon trace routine once.
                //

                if (!lpfnTransmitSpecialFrame) {
                    HINSTANCE hInst;

                    hInst = LoadLibrary (L"NAL.DLL" );
                    if (hInst) {
                    lpfnTransmitSpecialFrame =
                        (TRANSMITSPECIALFRAME_FN)GetProcAddress ( hInst, "TransmitSpecialFrame" );
                    }
                }

                if (lpfnTransmitSpecialFrame) {
                    int length;
                    int length2;
                    unsigned char buff[256];

                    if (DebSub) {
                        length = _snprintf(buff, sizeof(buff), "<%s%u:%u> ", DebSub, tid, uLineNo);
                    } else {
                        length = 0;
                    }

                    length2 = _vsnprintf(buff + length, sizeof(buff) - length, str, argptr );

                    lpfnTransmitSpecialFrame(FRAME_TYPE_COMMENT,
                                             0,
                                             buff,
                                             length + length2 + 1 );
                } else {
                    failedload = TRUE;  // that was our one and only try to load the routine.
                }
            }
        }
#endif 0
}


VOID
DbgDoAssert(
    IN PCHAR    Exp,
    IN UINT     Line,
    IN PCHAR    Debsub
    )
/*++
Routine Description:
    Assertion failure; print a message and exit after allowing some
    time for shutdown.

Arguments:
    Exp     - failing assertion expression
    Line    - line number of failing expression
    Debsub  - module name of failing expression

Return Value:
    Doesn't return
--*/
{
#undef DEBSUB
#define DEBSUB "DbgDoAssert:"


    PWCHAR  ExpW;
    PWCHAR  DebsubW;
    WCHAR   LineW[32];

    //
    // Inform the world
    //
    FrsIsAsserting = TRUE;


    ExpW = FrsAtoW(Exp);
    DebsubW = FrsAtoW(Debsub);
    _snwprintf(LineW, 32, L"%d", Line);

    //
    // Post an error log entry followed by recovery steps.
    //
    EPRINT3(EVENT_FRS_ASSERT, DebsubW, LineW, ExpW);
    EPRINT1(EVENT_FRS_IN_ERROR_STATE, JetPath);
    FrsFree(ExpW);
    FrsFree(DebsubW);

    //
    // Stack trace
    //
    if (!DebugInfo.Mem) {
        //
        // Init the symbols here since mem alloc tracing is off.
        //
        DbgStackInit();
    }
    DbgPrintStackTrace(0, Debsub, Line);

    //
    // Failing expression
    //
    DebPrint(0, ":S: ASSERTION FAILURE: %s\n", Debsub, Line, Exp);

    //
    // Save the log file as an assert file
    //
#if 0
    // disable saving assert logs under separate name; too confusing
    //
    if (DebugInfo.LogFILE) {
        DebLock();
        fflush(DebugInfo.LogFILE);
        DbgFlushInterval = DebugInfo.LogFlushInterval;
        fclose(DebugInfo.LogFILE);
        DbgShiftLogFiles(DebugInfo.LogFile,
                         ASSERT_FILE_SUFFIX,
                         DebugInfo.AssertShare,
                         DebugInfo.AssertFiles);

        DebugInfo.LogFILE = _wfopen(DebugInfo.LogFile, L"wc");
        DebugInfo.LogLines = 0;
        DebugInfo.PrintStats = TRUE;
        DebUnLock();
    }
#endif 0

    DEBUG_FLUSH();


    //
    // Break into the debugger, if any
    //
    if (DebugInfo.Break && IsDebuggerPresent()) {
        DebugBreak();
    }

    //
    // Shutting down during an assert seldom completes; a critical thread
    // is usually the thread that has asserted. One can't simply return
    // from an assert. So exit the process and trust jet and ntfrs to
    // recover at start up.
    //
    // FrsIsShuttingDown = TRUE;
    // SetEvent(ShutDownEvent);
    // ExitThread(1);

    //
    // Raise an exception.
    //
    if (--DbgRaiseCount <= 0) {
        exit(1);
    }

    XRAISEGENEXCEPTION( ERROR_OPERATION_ABORTED );

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\test\privs\privs.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    frs.c

Abstract:
    This module is a development tool. It exercises the dcpromo and poke
    APIs.

Author:
    Billy J. Fuller 12-Dec-1997

Environment
    User mode winnt

--*/

#define FREE(_x_)        { if (_x_) LocalFree(_x_); _x_ = NULL; }
#define WIN_SUCCESS(_x_) ((_x_) == ERROR_SUCCESS)

//
// Is a handle valid?
//      Some functions set the handle to NULL and some to
//      INVALID_HANDLE_VALUE (-1). This define handles both
//      cases.
//
#define HANDLE_IS_VALID(_Handle)    ((_Handle) && \
                                     ((_Handle) != INVALID_HANDLE_VALUE))

//
// NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// UNICODE or ANSI compilation
//
#include <tchar.h>

//
// Windows Headers
//
#include <windows.h>
#include <rpc.h>


//
// C-Runtime Header
//
#include <malloc.h>
#include <memory.h>
#include <process.h>
#include <signal.h>
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <excpt.h>
#include <conio.h>
#include <sys\types.h>
#include <errno.h>
#include <sys\stat.h>
#include <ctype.h>
#include <winsvc.h>


DWORD
UtilGetTokenInformation(
    IN HANDLE                   TokenHandle,
    IN TOKEN_INFORMATION_CLASS  TokenInformationClass,
    IN DWORD                    InitialTokenBufSize,
    OUT DWORD                   *OutTokenBufSize,
    OUT PVOID                   *OutTokenBuf
    )
/*++

Routine Description:

    Retries GetTokenInformation() with larger buffers.

Arguments:
    TokenHandle             - From OpenCurrentProcess/Thread()
    TokenInformationClass   - E.g., TokenUser
    InitialTokenBufSize     - Initial buffer size; 0 = default
    OutTokenBufSize         - Resultant returned buf size
    OutTokenBuf             - free with with FrsFree()


Return Value:

    OutTokenBufSize - Size of returned info (NOT THE BUFFER SIZE!)
    OutTokenBuf - info of type TokenInformationClass. Free with FrsFree().

--*/
{
#undef DEBSUB
#define DEBSUB "UtilGetTokenInformation:"
    DWORD               WStatus;

    *OutTokenBuf = NULL;
    *OutTokenBufSize = 0;

    //
    // Check inputs
    //
    if (!HANDLE_IS_VALID(TokenHandle)) {
        return ERROR_INVALID_PARAMETER;
    }

    if (InitialTokenBufSize == 0 ||
        InitialTokenBufSize > (1024 * 1024)) {
        InitialTokenBufSize = 1024;
    }

    //
    // Retry if buffer is too small
    //
    *OutTokenBufSize = InitialTokenBufSize;
AGAIN:
    *OutTokenBuf = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                              *OutTokenBufSize);
    WStatus = ERROR_SUCCESS;
    if (!GetTokenInformation(TokenHandle,
                             TokenInformationClass,
                             *OutTokenBuf,
                             *OutTokenBufSize,
                             OutTokenBufSize)) {
        WStatus = GetLastError();
        printf("GetTokenInformation(Info %d, Size %d); WStatus %d\n",
                TokenInformationClass,
                *OutTokenBufSize,
                WStatus);
        FREE(*OutTokenBuf);
        if (WStatus == ERROR_INSUFFICIENT_BUFFER) {
            goto AGAIN;
        }
    }
    return WStatus;
}


VOID
PrintUserName(
    VOID
    )
/*++
Routine Description:
    Print our user name

Arguments:
    None.

Return Value:
    None.
--*/
{
    WCHAR   Uname[MAX_PATH + 1];
    ULONG   Unamesize = MAX_PATH + 1;

    if (GetUserName(Uname, &Unamesize)) {
        printf("User name is %ws\n", Uname);
    } else {
        printf("ERROR - Getting user name; WStatus %d\n",
               GetLastError());
    }
}


#define PRIV_BUF_LENGTH    (1024)
VOID
PrintInfo(
    )
/*++
Routine Description:
    Check if the caller is a member of Groups

Arguments:
    ServerHandle
    Groups

Return Value:
    Win32 Status
--*/
{
    DWORD               i;
    TOKEN_PRIVILEGES    *Tp;
    TOKEN_SOURCE        *Ts;
    DWORD               ComputerLen;
    WCHAR               ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD               WStatus;
    DWORD               TokenBufSize;
    PVOID               TokenBuf = NULL;
    HANDLE              TokenHandle = NULL;
    HANDLE              IdHandle = NULL;
    DWORD               PrivLen;
    WCHAR               PrivName[MAX_PATH + 1];
    CHAR                SourceName[sizeof(Ts->SourceName) + 1];

    ComputerLen = MAX_COMPUTERNAME_LENGTH;
    ComputerName[0] = L'\0';
    if (!GetComputerName(ComputerName, &ComputerLen)) {
        printf("GetComputerName(); WStatus %d\n",
               GetLastError());
        return;
    }
    printf("Computer name is %ws\n", ComputerName);
    PrintUserName();

    //
    // For this process
    //
    IdHandle = GetCurrentProcess();
    if (!OpenProcessToken(IdHandle,
                          TOKEN_QUERY | TOKEN_QUERY_SOURCE,
                          &TokenHandle)) {
        WStatus = GetLastError();
        printf("Can't open process token; WStatus %d\n", WStatus);
        goto CLEANUP;
    }

    //
    // Get the Token privileges from the access token for this thread or process
    //
    WStatus = UtilGetTokenInformation(TokenHandle,
                                      TokenPrivileges,
                                      0,
                                      &TokenBufSize,
                                      &TokenBuf);
    if (!WIN_SUCCESS(WStatus)) {
        printf("UtilGetTokenInformation(TokenPrivileges); WStatus %d\n",
               WStatus);
        goto CLEANUP;
    }

    Tp = (TOKEN_PRIVILEGES *)TokenBuf;
    for (i = 0; i < Tp->PrivilegeCount; ++i) {
        PrivLen = MAX_PATH + 1;
        if (!LookupPrivilegeName(NULL,
                                 &Tp->Privileges[i].Luid,
                                 PrivName,
                                 &PrivLen)) {
            printf("lookuppriv error %d\n", GetLastError());
            exit(0);
        }
        printf("Priv %2d is %ws :%s:%s:%s:\n",
               i,
               PrivName,
               (Tp->Privileges[i].Attributes &  SE_PRIVILEGE_ENABLED_BY_DEFAULT) ? "Enabled by default" : "",
               (Tp->Privileges[i].Attributes &  SE_PRIVILEGE_ENABLED) ? "Enabled" : "",
               (Tp->Privileges[i].Attributes &  SE_PRIVILEGE_USED_FOR_ACCESS) ? "Used" : "");
    }
    FREE(TokenBuf);

    //
    // Source
    //
    //
    // Get the Token privileges from the access token for this thread or process
    //
    WStatus = UtilGetTokenInformation(TokenHandle,
                                      TokenSource,
                                      0,
                                      &TokenBufSize,
                                      &TokenBuf);
    if (!WIN_SUCCESS(WStatus)) {
        printf("UtilGetTokenInformation(TokenSource); WStatus %d\n",
               WStatus);
        goto CLEANUP;
    }
    Ts = (TOKEN_SOURCE *)TokenBuf;
    CopyMemory(SourceName, Ts->SourceName, sizeof(Ts->SourceName));
    SourceName[sizeof(Ts->SourceName)] = '\0';
    printf("Source: %s\n", SourceName);
    FREE(TokenBuf);

CLEANUP:
    if (HANDLE_IS_VALID(TokenHandle)) {
        CloseHandle(TokenHandle);
    }
    if (HANDLE_IS_VALID(IdHandle)) {
        CloseHandle(IdHandle);
    }
    FREE(TokenBuf);
}


VOID _cdecl
main(
    IN DWORD argc,
    IN PCHAR *argv
    )
/*++
Routine Description:
    Process the command line.

Arguments:
    argc
    argv

Return Value:
    Exits with 0 if everything went okay. Otherwise, 1.
--*/
{
    PrintInfo();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\util\frsalloc.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    frsalloc.c

Abstract:

    Routines for allocating and freeing memory structures in the
    NT File Replication Service.

Author:

    David Orbits (davidor) - 3-Mar-1997

Revision History:

--*/

#include <ntreppch.h>
#pragma  hdrstop

#undef DEBSUB
#define  DEBSUB  "FRSALLOC:"

#include <frs.h>
#include <ntfrsapi.h>
#include <info.h>
#include <perrepsr.h>

#pragma warning( disable:4102)  // unreferenced label

//
// Check for allocation problems
//
#define DBG_NUM_MEM_STACK       (8)
#define MAX_MEM_ON_FREE_LIST    (1024)
#define MAX_MEM_INDEX           (1024)


#define FRS_DEB_PRINT(_f, _d) \
        DebPrintNoLock(Severity, TRUE, _f, Debsub, uLineNo, _d)

#define FRS_DEB_PRINT2(_f, _d1, _d2) \
        DebPrintNoLock(Severity, TRUE, _f, Debsub, uLineNo, _d1, _d2)

#define FRS_DEB_PRINT3(_f, _d1, _d2, _d3) \
        DebPrintNoLock(Severity, TRUE, _f, Debsub, uLineNo, _d1, _d2, _d3)


CRITICAL_SECTION    MemLock;

typedef struct _MEM MEM, *PMEM;

struct _MEM {
    PMEM    Next;
    ULONG_PTR   *Begin;
    ULONG_PTR   *End;
    DWORD   OrigSize;
    ULONG_PTR   Stack[DBG_NUM_MEM_STACK];
};

PMEM    MemList;
PMEM    FreeMemList;
DWORD   MemOnFreeList;
DWORD   TotalAlloced;
DWORD   TotalAllocCalls;
DWORD   TotalFreed;
DWORD   TotalFreeCalls;
DWORD   TotalDelta;
DWORD   TotalDeltaMax;
DWORD   TotalTrigger = 10000;

ULONG   TypesAllocatedCount[NODE_TYPE_MAX];
ULONG   TypesAllocatedMax[NODE_TYPE_MAX];
ULONG   TypesAllocated[NODE_TYPE_MAX];

ULONG   SizesAllocatedCount[MAX_MEM_INDEX];
ULONG   SizesAllocatedMax[MAX_MEM_INDEX];
ULONG   SizesAllocated[MAX_MEM_INDEX];

ULONG   DbgBreakSize        = 2;
LONG    DbgBreakTrigger     = 1;
LONG    DbgBreakReset       = 1;
LONG    DbgBreakResetInc    = 0;

PULONG_PTR   MaxAllocAddr;
PULONG_PTR   MinAllocAddr;
DWORD   ReAllocs;
DWORD   NewAllocs;

//
// Keep these in the same order as the Node Type ENUM.
//
PCHAR NodeTypeNames[]= {
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
    "THREAD_CONTEXT_TYPE",
    "REPLICA_TYPE",
    "REPLICA_THREAD_TYPE",
    "CONFIG_NODE_TYPE",
    "CXTION_TYPE",
    "GUID/RPC HANDLE",
    "THREAD_TYPE",
    "GEN_TABLE_TYPE",
    "JBUFFER_TYPE",
    "VOLUME_MONITOR_ENTRY_TYPE",
    "COMMAND_PACKET_TYPE",
    "GENERIC_HASH_TABLE_TYPE",
    "CHANGE_ORDER_ENTRY_TYPE",
    "FILTER_TABLE_ENTRY_TYPE",
    "QHASH_TABLE_TYPE",
    "OUT_LOG_PARTNER_TYPE",
    "WILDCARD_FILTER_ENTRY_TYPE",
    "NODE_TYPE_MAX"
    };

extern PCHAR CoLocationNames[];

extern FLAG_NAME_TABLE StageFlagNameTable[];
extern FLAG_NAME_TABLE OlpFlagNameTable[];

extern PCHAR OLPartnerStateNames[];
extern PWCHAR DsConfigTypeName[];

extern PGEN_TABLE            VolSerialNumberToDriveTable;

VOID
FrsDisplayUsnReason(
    ULONG ReasonMask,
    PCHAR Buffer,
    LONG MaxLength
    );


PFRS_THREAD
ThSupEnumThreads(
    PFRS_THREAD     FrsThread
    );

VOID
DbgPrintThreadIds(
    IN ULONG Severity
    );

VOID
DbsDataInitCocExtension(
    IN PCHANGE_ORDER_RECORD_EXTENSION CocExt
    );

VOID
SndCsDestroyCxtion(
    IN PCXTION  Cxtion,
    IN DWORD    CxtionFlags
    );


VOID
FrsInitializeMemAlloc(
    VOID
    )
/*++
Routine Description:
    Initialize the memory allocation subsystem

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsInitializeMemAlloc:"


    InitializeCriticalSection(&MemLock);

    //
    // Get Debugmem and DebugMemCompact from ntfrs config section in the registry
    //
    CfgRegReadDWord(FKC_DEBUG_MEM,         NULL, 0, &DebugInfo.Mem);
    CfgRegReadDWord(FKC_DEBUG_MEM_COMPACT, NULL, 0, &DebugInfo.MemCompact);

}


VOID
FrsPrintAllocStats(
    IN ULONG            Severity,
    IN PNTFRSAPI_INFO   Info,        OPTIONAL
    IN DWORD            Tabs
    )
/*++
Routine Description:
    Print the memory stats into the info buffer or using DPRINT (Info == NULL).

Arguments:
    Severity    - for DPRINT
    Info        - for IPRINT (use DPRINT if NULL)
    Tabs        - indentation for prettyprint

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsPrintAllocStats:"
    ULONG           i;
    WCHAR           TabW[MAX_TAB_WCHARS + 1];

    InfoTabs(Tabs, TabW);

    IDPRINT0(Severity, Info, "\n");
    IDPRINT1(Severity, Info, "%wsNTFRS MEMORY USAGE:\n", TabW);
    IDPRINT2(Severity, Info, "%ws   ENABLE STATS   : %s\n",
             TabW,
             (DebugInfo.Mem) ? "TRUE" : "FALSE");
    IDPRINT3(Severity, Info, "%ws   Alloced        : %6d KB (%d calls)\n",
             TabW,
             TotalAlloced / 1024,
             TotalAllocCalls);
    IDPRINT3(Severity, Info, "%ws   Freed          : %6d KB (%d calls)\n",
             TabW,
             TotalFreed / 1024,
             TotalFreeCalls);
    IDPRINT2(Severity, Info, "%ws   Delta          : %6d KB\n",
             TabW,
             TotalDelta / 1024);
    IDPRINT2(Severity, Info, "%ws   Max delta      : %6d KB\n",
             TabW,
             TotalDeltaMax / 1024);
    IDPRINT2(Severity, Info, "%ws   Addr Range     : %6d KB\n",
             TabW,
             (((PCHAR)MaxAllocAddr) - ((PCHAR)MinAllocAddr)) / 1024);
    IDPRINT2(Severity, Info, "%ws   OnFreeList     : %d\n", TabW, MemOnFreeList);
    IDPRINT2(Severity, Info, "%ws   ReAllocs       : %d\n", TabW, ReAllocs);
    IDPRINT2(Severity, Info, "%ws   NewAllocs      : %d\n", TabW, NewAllocs);
    IDPRINT2(Severity, Info, "%ws   MinAddr        : 0x%08x\n", TabW, MinAllocAddr);
    IDPRINT2(Severity, Info, "%ws   MaxAddr        : 0x%08x\n", TabW, MaxAllocAddr);

    for (i = 0; i < NODE_TYPE_MAX; ++i) {
        if (!TypesAllocatedCount[i]) {
            continue;
        }
        IDPRINT5(Severity, Info, "%ws      %-26s: %6d Calls, %6d Max, %6d busy\n",
                 TabW, NodeTypeNames[i], TypesAllocatedCount[i],
                 TypesAllocatedMax[i], TypesAllocated[i]);
    }
    IDPRINT0(Severity, Info, "\n");

    for (i = 0; i < MAX_MEM_INDEX; ++i) {
        if (!SizesAllocatedCount[i]) {
            continue;
        }
        IDPRINT6(Severity, Info, "%ws      %6d to %6d : %6d Calls, %6d Max, %6d busy\n",
                 TabW, i << 4, ((i + 1) << 4) - 1,
                 SizesAllocatedCount[i], SizesAllocatedMax[i], SizesAllocated[i]);
    }
    IDPRINT0(Severity, Info, "\n");
}


VOID
FrsPrintThreadStats(
    IN ULONG            Severity,
    IN PNTFRSAPI_INFO   Info,        OPTIONAL
    IN DWORD            Tabs
    )
/*++
Routine Description:
    Print the thread stats into the info buffer or using DPRINT (Info == NULL).

Arguments:
    Severity    - for DPRINT
    Info        - for IPRINT (use DPRINT if NULL)
    Tabs        - indentation for prettyprint

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsPrintThreadStats:"
    ULONGLONG       CreateTime;
    ULONGLONG       ExitTime;
    ULONGLONG       KernelTime;
    ULONGLONG       UserTime;
    PFRS_THREAD     FrsThread;
    WCHAR           TabW[MAX_TAB_WCHARS + 1];

    InfoTabs(Tabs, TabW);

    IDPRINT0(Severity, Info, "\n");
    IDPRINT1(Severity, Info, "%wsNTFRS THREAD USAGE:\n", TabW);

    //
    // Thread CPU Times
    //
    FrsThread = NULL;
    while (FrsThread = ThSupEnumThreads(FrsThread)) {
        if (HANDLE_IS_VALID(FrsThread->Handle)) {
            if (GetThreadTimes(FrsThread->Handle,
                               (PFILETIME)&CreateTime,
                               (PFILETIME)&ExitTime,
                               (PFILETIME)&KernelTime,
                               (PFILETIME)&UserTime)) {
                //
                // Hasn't exited, yet
                //
                if (ExitTime < CreateTime) {
                    ExitTime = CreateTime;
                }
                IDPRINT5(Severity, Info, "%ws   %-15ws: %8d CPU Seconds (%d kernel, %d elapsed)\n",
                         TabW,
                         FrsThread->Name,
                         (DWORD)((KernelTime + UserTime) / (10 * 1000 * 1000)),
                         (DWORD)((KernelTime) / (10 * 1000 * 1000)),
                         (DWORD)((ExitTime - CreateTime) / (10 * 1000 * 1000)));
            }
        }
    }

    //
    // Process CPU Times
    //
    if (GetProcessTimes(ProcessHandle,
                       (PFILETIME)&CreateTime,
                       (PFILETIME)&ExitTime,
                       (PFILETIME)&KernelTime,
                       (PFILETIME)&UserTime)) {
        //
        // Hasn't exited, yet
        //
        if (ExitTime < CreateTime) {
            ExitTime = CreateTime;
        }
        IDPRINT5(Severity, Info, "%ws   %-15ws: %8d CPU Seconds (%d kernel, %d elapsed)\n",
                 TabW,
                 L"PROCESS",
                 (DWORD)((KernelTime + UserTime) / (10 * 1000 * 1000)),
                 (DWORD)((KernelTime) / (10 * 1000 * 1000)),
                 (DWORD)((ExitTime - CreateTime) / (10 * 1000 * 1000)));
    }
    IDPRINT0(Severity, Info, "\n");
}


VOID
FrsPrintStageStats(
    IN ULONG            Severity,
    IN PNTFRSAPI_INFO   Info,        OPTIONAL
    IN DWORD            Tabs
    )
/*++
Routine Description:
    Print the staging area  stats into the info buffer or
    using DPRINT (Info == NULL).

Arguments:
    Severity    - for DPRINT
    Info        - for IPRINT (use DPRINT if NULL)
    Tabs        - indentation for prettyprint

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsPrintStageStats:"
    PVOID               Key;
    PSTAGE_ENTRY        SEntry;
    DWORD               SizeInKb;
    WCHAR               TabW[MAX_TAB_WCHARS + 1];
    CHAR                Guid[GUID_CHAR_LEN + 1];
    extern DWORD        StagingAreaAllocated;
    extern PGEN_TABLE   StagingAreaTable;

    InfoTabs(Tabs, TabW);

    try {
        GTabLockTable(StagingAreaTable);
        IDPRINT0(Severity, Info, "\n");
        IDPRINT3(Severity, Info, "%wsNTFRS STAGE USAGE: %d KB of %d KB allocated\n",
                 TabW, StagingAreaAllocated, StagingLimitInKb);
        SizeInKb = 0;
        Key = NULL;

        while (SEntry = GTabNextDatumNoLock(StagingAreaTable, &Key)) {
            GuidToStr(&SEntry->FileOrCoGuid, Guid);
            IDPRINT2(Severity, Info, "%ws   %s\n", TabW, Guid);
            IDPRINT2(Severity, Info, "%ws      Flags: %08x\n", TabW, SEntry->Flags);
            IDPRINT2(Severity, Info, "%ws      Size : %d\n", TabW, SEntry->FileSizeInKb);
            SizeInKb += SEntry->FileSizeInKb;
        }

        IDPRINT2(Severity, Info, "%ws   Calculated Usage is %d KB\n", TabW, SizeInKb);
        IDPRINT0(Severity, Info, "\n");

    } finally {
        GTabUnLockTable(StagingAreaTable);
    }
}


VOID
MyDbgBreak(
    VOID
    )
{
}




VOID
DbgCheck(
    IN PMEM Mem
    )
/*++
Routine Description:
    Check a memory block. Memory lock must be held.

Arguments:
    Mem - memory block

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgCheck:"
    PULONG_PTR  pDWord;
    ULONG_PTR   Pattern;

    //
    // Begins at first byte at the end of the user's allocation
    //
    Pattern = (ULONG_PTR)(Mem->End) | (Mem->OrigSize << 24);

    //
    // Check for overwritten memory
    //
    if ( (ULONG_PTR)*Mem->Begin != (ULONG_PTR)Mem->Begin ) {
        DPRINT2(0, "Begin Memory @ 0x%08x has been overwritten with 0x%08x\n",
                Mem->Begin, *Mem->Begin);

    } else if (memcmp(((PCHAR)Mem->Begin) + Mem->OrigSize + 8,
                      (PCHAR)&Pattern, sizeof(Pattern))) {

        DPRINT1(0, "End Memory @ 0x%08x has been overwritten\n",
                ((PCHAR)Mem->Begin) + Mem->OrigSize + 8);
    } else {
        return;
    }

    DPRINT(0, "Memory's stack trace\n");
    STACK_PRINT(0, Mem->Stack, DBG_NUM_MEM_STACK);

    DPRINT(0, "Caller's stack trace\n");
    STACK_TRACE_AND_PRINT(0);

    DPRINT(0, "Corrupted block of memory\n");
    for (pDWord = Mem->Begin; pDWord != Mem->End; ++pDWord) {
        DPRINT2(0, "0x%08x: 0x%08x\n", pDWord, *pDWord);
    }
    exit(1);
}


VOID
DbgCheckAll(
    VOID
    )
/*++
Routine Description:
    Check all memory blocks.

Arguments:
    Mem - memory block

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgCheckAll:"
    PMEM    Mem;

    //
    // Don't check the entire list of allocated memory blocks
    //
    if (DebugInfo.Mem < 2) {
        return;
    }

    EnterCriticalSection(&MemLock);
    for (Mem = MemList; Mem; Mem = Mem->Next) {
        //
        // Check for overwritten memory
        //
        DbgCheck(Mem);
    }
    LeaveCriticalSection(&MemLock);
}


VOID
FrsUnInitializeMemAlloc(
    VOID
    )
/*++
Routine Description:
    Initialize the memory allocation subsystem

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsUnInitializeMemAlloc:"
    PMEM    Mem;

    EnterCriticalSection(&MemLock);
    for (Mem = MemList; Mem; Mem = Mem->Next) {
        //
        // Check for overwritten memory
        //
        DbgCheck(Mem);

        DPRINT2(1, "\t%d bytes @ 0x%08x\n",
                ((PCHAR)Mem->End) - ((PCHAR)Mem->Begin), Mem->Begin);
        STACK_PRINT(1, Mem->Stack, DBG_NUM_MEM_STACK);
    }
    LeaveCriticalSection(&MemLock);
}


PMEM
DbgAlloc(
    IN ULONG_PTR    *Begin,
    IN ULONG_PTR    *End,
    IN DWORD    OrigSize
    )
/*++
Routine Description:
    Add a new allocation to our list of allocated memory after
    checking for overlaps.

Arguments:
    Begin       - beginning of newly allocated memory
    End         - end of same
    OrigSize    - Size requested by caller

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgAlloc:"
    PMEM    *PMem;
    PMEM    Mem;
    ULONG   Calls;
    ULONG_PTR   Pattern;
    DWORD   MemIndex;

    //
    // Approximate stats
    //
    if (!DebugInfo.Mem) {
        //
        // Memory stats
        //
        Calls = ++TotalAllocCalls;
        TotalAlloced += (DWORD)((PUCHAR)End - (PUCHAR)Begin);
        if (Begin > MaxAllocAddr) {
            ++NewAllocs;
            MaxAllocAddr = Begin;
        } else {
            if (!MinAllocAddr) {
                MinAllocAddr = Begin;
            }
            ++ReAllocs;
        }

        //
        // Tracking memory sizes
        //
        MemIndex = OrigSize >> 4;
        if (MemIndex >= MAX_MEM_INDEX) {
            MemIndex = (MAX_MEM_INDEX - 1);
        }
        SizesAllocatedCount[MemIndex]++;
        //
        // Print memory stats every so often
        //
        if (!(Calls % TotalTrigger)) {
            DbgPrintThreadIds(DebugInfo.LogSeverity);
            FrsPrintAllocStats(DebugInfo.LogSeverity, NULL, 0);
        }
        return NULL;
    }

    //
    // Verify heap consistency
    //
    DbgCheckAll();
    EnterCriticalSection(&MemLock);
    PMem = &MemList;
    for (Mem = *PMem; Mem; Mem = *PMem) {
        //
        // Check for overwritten memory
        //
        DbgCheck(Mem);

        //
        // Check for overlap
        //
        if ((Begin >= Mem->Begin && Begin < Mem->End) ||
            (Mem->Begin >= Begin && Mem->Begin < End) ||
            (Mem->End > Begin && Mem->End < End) ||
            (End > Mem->Begin && End < Mem->End)) {
            //
            // DUP ALLOCATION (OVERLAP DETECTED)
            //      Release lock in case DPRINT calls allocation routines
            //
            LeaveCriticalSection(&MemLock);
            DPRINT4(0, "ERROR -- DUP ALLOC: 0x%x to 0x%x is already allocated to 0x%x to 0x%x; EXITING\n",
                Begin, End, Mem->Begin, Mem->End);
            FRS_ASSERT(!"Duplicate memory allocation");
        }
        //
        // This memory should be linked later in the sorted memory list
        //
        if (Begin > Mem->Begin) {
            PMem = &Mem->Next;
            continue;
        }
        //
        // This memory should be linked here in the sorted memory list
        //
        break;
    }
    //
    // Allocate a memory block header
    //
    Mem = FreeMemList;
    if (Mem) {
        --MemOnFreeList;
        FreeMemList = Mem->Next;
    } else {
        Mem = (PVOID)malloc(sizeof(MEM));
        if (Mem == NULL) {
            RaiseException(ERROR_OUTOFMEMORY, 0, 0, NULL);
        }
        ZeroMemory(Mem, sizeof(MEM));
    }

    //
    // Initialize the header and the header/trailer for memory overrun detection.
    //
    Mem->OrigSize = OrigSize;
    Mem->End = End;
    Mem->Begin = Begin;

    //
    // Initialize the header/trailer for memory overrun detection.
    //
    *Mem->Begin = (ULONG_PTR)Begin;
    *(Mem->Begin + 1) = OrigSize;
    Pattern = (ULONG_PTR)(Mem->End) | (Mem->OrigSize << 24);
    CopyMemory(((PCHAR)Begin) + Mem->OrigSize + 8, (PCHAR)&Pattern, sizeof(Pattern));

    //
    // Add to sorted list
    //
    Mem->Next = *PMem;
    *PMem = Mem;
    //
    // Note: stackwalk won't work from here; see frsalloctype()
    //
    // DbgStackTrace(Mem->Stack, DBG_NUM_MEM_STACK)

    //
    // Memory stats
    //
    Calls = ++TotalAllocCalls;
    TotalAlloced += (DWORD)((PUCHAR)End - (PUCHAR)Begin);
    TotalDelta = TotalAlloced - TotalFreed;
    if (TotalDelta > TotalDeltaMax) {
        TotalDeltaMax = TotalDelta;
    }
    if (Begin > MaxAllocAddr) {
        ++NewAllocs;
        MaxAllocAddr = Begin;
    } else {
        if (!MinAllocAddr) {
            MinAllocAddr = Begin;
        }
        ++ReAllocs;
    }

    //
    // Tracking memory sizes
    //
    MemIndex = OrigSize >> 4;
    if (MemIndex >= MAX_MEM_INDEX) {
        MemIndex = (MAX_MEM_INDEX - 1);
    }
    SizesAllocated[MemIndex]++;
    SizesAllocatedCount[MemIndex]++;
    if (SizesAllocated[MemIndex] > SizesAllocatedMax[MemIndex]) {
        SizesAllocatedMax[MemIndex] = SizesAllocated[MemIndex];
    }

    //
    // Done
    //
    LeaveCriticalSection(&MemLock);

    //
    // Print memory stats every so often
    //
    if (!(Calls % TotalTrigger)) {
        DbgPrintThreadIds(DebugInfo.LogSeverity);
        FrsPrintAllocStats(DebugInfo.LogSeverity, NULL, 0);
    }
    DbgCheckAll();
    return Mem;
}


VOID
DbgFree(
    IN PULONG_PTR Begin
    )
/*++
Routine Description:
    Remove allocated memory from list

Arguments:
    Begin - allocated (maybe) memory

Return Value:
    TRUE    - found it
    FALSE   - didn't find it
--*/
{
#undef DEBSUB
#define DEBSUB "DbgFree:"
    PMEM    *PMem;
    PMEM    Mem;
    DWORD   MemIndex;

    //
    // Freeing NULL pointer is allowed
    //
    if (Begin == NULL || !DebugInfo.Mem) {
        return;
    }

    DbgCheckAll();
    EnterCriticalSection(&MemLock);
    PMem = &MemList;
    for (Mem = *PMem; Mem; Mem = *PMem) {
        //
        // Check for overwritten memory
        //
        DbgCheck(Mem);

        //
        // Not the right one
        //
        if (Begin > Mem->Begin) {
            PMem = &Mem->Next;
            continue;
        }
        if (Begin != Mem->Begin) {
            break;
        }
        //
        // Found it; remove from list and free it
        //
        ++TotalFreeCalls;
        TotalFreed += (DWORD)((PUCHAR)Mem->End - (PUCHAR)Mem->Begin);
        TotalDelta = TotalAlloced - TotalFreed;

        MemIndex = Mem->OrigSize >> 4;
        if (MemIndex >= MAX_MEM_INDEX) {
            MemIndex = (MAX_MEM_INDEX - 1);
        }
        SizesAllocated[MemIndex]--;

        *PMem = Mem->Next;
        if (MemOnFreeList > MAX_MEM_ON_FREE_LIST) {
            free(Mem);
        } else {
            ++MemOnFreeList;
            Mem->Next = FreeMemList;
            FreeMemList = Mem;
        }
        LeaveCriticalSection(&MemLock);
        DbgCheckAll();
        return;
    }
    LeaveCriticalSection(&MemLock);
    DPRINT1(0, "ERROR -- Memory @ 0x%x is not allocated\n", Begin);
    FRS_ASSERT(!"Memory free error, not allocated");
}


BOOL
DbgIsAlloc(
    IN PULONG_PTR Begin
    )
/*++
Routine Description:
    Is Begin alloced?

Arguments:
    Begin - allocated (maybe) memory

Return Value:
    TRUE    - found it
    FALSE   - didn't find it
--*/
{
#undef DEBSUB
#define DEBSUB "DbgIsAlloc:"
    PMEM    *PMem;
    PMEM    Mem;

    if (!DebugInfo.Mem) {
        return TRUE;
    }

    //
    // NULL pointer is always alloced
    //
    if (Begin == NULL) {
        return TRUE;
    }

    DbgCheckAll();
    EnterCriticalSection(&MemLock);
    PMem = &MemList;
    for (Mem = *PMem; Mem; Mem = *PMem) {
        //
        // Check for overwritten memory
        //
        DbgCheck(Mem);

        //
        // Not the right one
        //
        if (Begin > Mem->Begin) {
            PMem = &Mem->Next;
            continue;
        }

        if (Begin != Mem->Begin) {
            break;
        }
        LeaveCriticalSection(&MemLock);
        DbgCheckAll();
        return TRUE;
    }
    LeaveCriticalSection(&MemLock);
    DbgCheckAll();
    return FALSE;
}



PVOID
FrsAlloc(
    IN DWORD OrigSize
    )
/*++
Routine Description:
        Allocate memory. Raise an exception if there is no memory.

Arguments:
        Size    - size of the memory request

Return Value:
        Allocated memory.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsAlloc:"
    PVOID   Node;
    DWORD   Size;
    PMEM    Mem;

    //
    // FRS_ASSERT is added here to satisfy prefix. The return value from FrsAlloc is not checked anywhere
    // in the code.
    //

    FRS_ASSERT(OrigSize != 0);

    Size = OrigSize;

    if (DebugInfo.Mem) {
        //
        // Check for debug break
        //
        if (OrigSize == DbgBreakSize) {
            if (DbgBreakTrigger) {
                if (--DbgBreakTrigger <= 0) {
                    DbgBreakTrigger = DbgBreakReset;
                    DbgBreakReset += DbgBreakResetInc;
                    MyDbgBreak();
                }
            }
        }
        //
        // Adjust size for header/trailer
        //
        Size = (((OrigSize + 7) >> 3) << 3) + 16;
    }

    //
    // Raise an exception if there is no memory
    //
    Node = (PVOID)malloc(Size);
    if (Node == NULL) {
        RaiseException(ERROR_OUTOFMEMORY, 0, 0, NULL);
    }
    ZeroMemory(Node, Size);

    //
    // Even with mem alloc tracing off call DbgAlloc to capture mem alloc stats.
    //
    Mem = DbgAlloc(Node, (PULONG_PTR)(((PCHAR)Node) + Size), OrigSize);

    //
    // Note: should be in dbgalloc(); but stackwalk won't work
    //
    if (DebugInfo.Mem) {
        DbgStackTrace(Mem->Stack, DBG_NUM_MEM_STACK);
        ((PCHAR)Node) += 8;
    }

    return Node;
}


PVOID
FrsRealloc(
    PVOID OldNode,
    DWORD OrigSize
    )
/*++
Routine Description:
    Reallocate memory. Raise an exception if there is no memory.

Arguments:
    Size    - size of the memory request

Return Value:
    Reallocated memory.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsRealloc:"
    PVOID   Node;
    DWORD   Size;
    PMEM    Mem;

    if (!OldNode) {

        //
        // Need to check if OrigSize == 0 as FrsAlloc asserts if called with 0 as the first parameter (prefix fix).
        //

        if (OrigSize == 0) {
            return NULL;
        }

        return FrsAlloc(OrigSize);
    }

    Size = OrigSize;

    if (DebugInfo.Mem) {
        ((PCHAR)OldNode) -= 8;
        DbgFree(OldNode);
        //
        // Adjust size for header/trailer
        //
        Size = (((OrigSize + 7) >> 3) << 3) + 16;
    }
    //
    // Raise an exception if there is no memory
    //
    Node = (PVOID)realloc(OldNode, Size);
    if (Node == NULL) {
        RaiseException(ERROR_OUTOFMEMORY, 0, 0, NULL);
    }

    //
    // Even with mem alloc tracing off call DbgAlloc to capture mem alloc stats.
    //
    Mem = DbgAlloc(Node, (PULONG_PTR)(((PCHAR)Node) + Size), OrigSize);

    //
    // Note: should be in dbgalloc(); but stackwalk won't work
    //
    if (DebugInfo.Mem) {
        DbgStackTrace(Mem->Stack, DBG_NUM_MEM_STACK);
        ((PCHAR)Node) += 8;
    }

    return Node;
}


PVOID
FrsFree(
    PVOID   Node
    )
/*++
Routine Description:
    Free memory allocated with FrsAlloc

Arguments:
    Node    - memory allocated with FrsAlloc

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsFree:"

    if (!Node) {
        return NULL;
    }

    if (DebugInfo.Mem) {
        ((PCHAR)Node) -= 8;
        DbgFree(Node);
    }

    free(Node);

    if (DebugInfo.MemCompact) {
        HeapCompact(GetProcessHeap(), 0);
    }

    return NULL;
}


PCHAR
FrsWtoA(
    PWCHAR Wstr
    )
/*++
Routine Description:
    Translate a wide char string into a newly allocated char string.

Arguments:
    Wstr - wide char string

Return Value:
    Duplicated string. Free with FrsFree().
--*/
{
#undef DEBSUB
#define DEBSUB "FrsWtoA:"
    PCHAR   Astr;

    //
    // E.g., when duplicating NodePartner when none exists
    //
    if (Wstr == NULL)
        return NULL;

    Astr = FrsAlloc(wcslen(Wstr) + 1);
    sprintf(Astr, "%ws", Wstr);

    return Astr;
}




PWCHAR
FrsWcsTrim(
    PWCHAR Wstr,
    WCHAR  Trim
    )
/*++
Routine Description:

    Remove the Trim char from the trailing end of the string by replacing
    any occurance with a L'\0'.
    Skip over any leading Trim chars and return a ptr to the first non-TRIM
    char found.  If we hit the end of the string return the pointer to
    the terminating null.

Arguments:

    Wstr - wide char string
    Trim - Char to trim.

Return Value:

    ptr to first non Trim char.
--*/
{

#undef DEBSUB
#define DEBSUB "FrsWcsTrim:"

    LONG Len, Index;

    if (Wstr == NULL)
        return NULL;

    //
    //
    Len = wcslen(Wstr);
    Index = Len - 1;

    while (Index >= 0) {
        if (Wstr[Index] != Trim) {
            break;
        }
        Index--;
    }

    Wstr[++Index] = UNICODE_NULL;

    Len = Index;
    Index = 0;
    while (Index < Len) {
        if (Wstr[Index] != Trim) {
            break;
        }
        Index++;
    }

    return Wstr + Index;

}



PWCHAR
FrsAtoW(
    PCHAR Astr
    )
/*++
Routine Description:
    Translate a wide char string into a newly allocated char string.

Arguments:
    Wstr - wide char string

Return Value:
    Duplicated string. Free with FrsFree().
--*/
{
    PWCHAR   Wstr;

    //
    // E.g., when duplicating NodePartner when none exists
    //
    if (Astr == NULL) {
        return NULL;
    }

    Wstr = FrsAlloc((strlen(Astr) + 1) * sizeof(WCHAR));
    swprintf(Wstr, L"%hs", Astr);

    return Wstr;
}


PWCHAR
FrsWcsDup(
    PWCHAR OldStr
    )
/*++
Routine Description:
    Duplicate a string using our memory allocater

Arguments:
    OldArg  - string to duplicate

Return Value:
    Duplicated string. Free with FrsFree().
--*/
{
#undef DEBSUB
#define DEBSUB "FrsWcsDup:"

    PWCHAR  NewStr;

    //
    // E.g., when duplicating NodePartner when none exists
    //
    if (OldStr == NULL) {
        return NULL;
    }

    NewStr = FrsAlloc((wcslen(OldStr) + 1) * sizeof(WCHAR));
    wcscpy(NewStr, OldStr);

    return NewStr;
}


VOID
FrsBuildVolSerialNumberToDriveTable(
    VOID
    )
/*++
Routine Description:
    New way to get the current configuration from the DS and merge it with
    the active replicas.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsBuildVolSerialNumberToDriveTable:"

    ULONG                           MaxFileNameLen;
    DWORD                           FileSystemFlags;
    PWCHAR                          DrivePtr = NULL;
    DWORD                           WStatus;
    PVOLUME_INFO_NODE               VolumeInfoNode;
    UINT                            DriveType;
    ULONG                           VolumeSerialNumber = 0;
    WCHAR                           LogicalDrives[MAX_PATH];
    WCHAR                           VolumeGuidName[MAX_PATH];

    //
    // Initialize the VolSerialNumberToDriveTable.
    //
    if (VolSerialNumberToDriveTable == NULL) {
        VolSerialNumberToDriveTable = GTabAllocNumberTable();
    }

    //
    // Get the logical drive strings.
    //
    if (!GetLogicalDriveStrings(MAX_PATH, LogicalDrives) || (VolSerialNumberToDriveTable == NULL)) {
        DPRINT_WS(1, "WARN - Getting logical drives. It may not be possible to start on this server.", GetLastError());
        return;
    }

    //
    // Lock the table during rebuild to synchronize with the many callers of
    // FrsWcsVolume() in other threads.
    //
    GTabLockTable(VolSerialNumberToDriveTable);

    GTabEmptyTableNoLock(VolSerialNumberToDriveTable, FrsFree);

    DrivePtr = LogicalDrives;
    while (wcscmp(DrivePtr,L"")) {

        DriveType = GetDriveType(DrivePtr);
        //
        // Skip remote drives and CDROM drives.
        //
        if ((DriveType == DRIVE_REMOTE) || (DriveType == DRIVE_CDROM)) {
            DPRINT1(4, "Skipping Drive %ws. Invalid drive type.\n", DrivePtr);
            DrivePtr = DrivePtr + wcslen(DrivePtr) + 1;
            continue;
        }

        if (!GetVolumeInformation(DrivePtr,
                                  VolumeGuidName,
                                  MAX_PATH,
                                  &VolumeSerialNumber,
                                  &MaxFileNameLen,
                                  &FileSystemFlags,
                                  NULL,
                                  0)){

           DPRINT1_WS(1,"WARN - GetvolumeInformation for %ws;", DrivePtr, GetLastError());
           DrivePtr = DrivePtr + wcslen(DrivePtr) + 1;
           continue;
       }

       VolumeInfoNode = FrsAlloc(sizeof(VOLUME_INFO_NODE));
       wcscpy(VolumeInfoNode->DriveName, L"\\\\.\\");
       wcscat(VolumeInfoNode->DriveName, DrivePtr);

       //
       // Remove the trailing back slash.
       //
       VolumeInfoNode->DriveName[wcslen(VolumeInfoNode->DriveName) - 1] = L'\0';

       VolumeInfoNode->VolumeSerialNumber = VolumeSerialNumber;

       GTabInsertEntryNoLock(VolSerialNumberToDriveTable, VolumeInfoNode, &(VolumeInfoNode->VolumeSerialNumber), NULL);

       DrivePtr = DrivePtr + wcslen(DrivePtr) + 1;
    }

    GTabUnLockTable(VolSerialNumberToDriveTable);

    return;
}


PWCHAR
FrsWcsVolume(
    PWCHAR Path
    )
/*++
Routine Description:
    Get the drive from the VolSerialNumberToDriveTable.  The volume serial
    number is used to locate the drive since a mount point can take us to
    another drive.

Arguments:
    Path

Return Value:
    Duplicated string containing drive:\ from Path or NULL.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsWcsVolume:"
    PWCHAR                       Volume = NULL;
    HANDLE                       DirHandle;
    DWORD                        WStatus;
    NTSTATUS                     Status;
    IO_STATUS_BLOCK              IoStatusBlock;
    DWORD                        VolumeInfoLength;
    PFILE_FS_VOLUME_INFORMATION  VolumeInfo;
    PVOLUME_INFO_NODE            VolumeInfoNode;

    //
    // Get the volume Guid for the path.
    //
    // Always open the path by masking off the FILE_OPEN_REPARSE_POINT flag
    // because we want to open the destination dir not the junction if the root
    // happens to be a mount point.
    //
    WStatus = FrsOpenSourceFileW(&DirHandle,
                                 Path,
                                 GENERIC_READ,
                                 FILE_OPEN_FOR_BACKUP_INTENT);
    CLEANUP1_WS(4,"ERROR - Could not open %ws;", Path, WStatus, RETURN);

    VolumeInfoLength = sizeof(FILE_FS_VOLUME_INFORMATION) +
                       MAXIMUM_VOLUME_LABEL_LENGTH;

    VolumeInfo = FrsAlloc(VolumeInfoLength);

    Status = NtQueryVolumeInformationFile(DirHandle,
                                          &IoStatusBlock,
                                          VolumeInfo,
                                          VolumeInfoLength,
                                          FileFsVolumeInformation);
    NtClose(DirHandle);

    if (NT_SUCCESS(Status)) {
        //
        // Build the table if it does not yet exist. This table is rebuilt at the
        // start of each DS poll cycle so we have updated information about
        // the volumes on the machine.
        //
        if (VolSerialNumberToDriveTable == NULL) {
            FrsBuildVolSerialNumberToDriveTable();
        }

        VolumeInfoNode = GTabLookup(VolSerialNumberToDriveTable, &(VolumeInfo->VolumeSerialNumber), NULL);
        if (VolumeInfoNode) {
            Volume = FrsWcsDup(VolumeInfoNode->DriveName);
        }
    } else {
        DPRINT1_NT(1,"WARN - NtQueryVolumeInformationFile failed for %ws;", Path, Status);
    }

    VolumeInfo = FrsFree(VolumeInfo);

RETURN:
    return Volume;
}


PWCHAR
FrsWcsCat3(
    PWCHAR  First,
    PWCHAR  Second,
    PWCHAR  Third
    )
/*++
Routine Description:
    Concatenate three strings into a new string using our memory allocater

Arguments:
    First   - First string in the concat
    Second  - Second string in the concat
    Third   - Third string in the concat

Return Value:
    Return concatenated string. Free with FrsFree().
--*/
{
#undef DEBSUB
#define DEBSUB "FrsWcscat3:"

    PCHAR  New;
    DWORD   BytesFirst;
    DWORD   BytesSecond;
    DWORD   BytesThird;

    if (!First || !Second || !Third) {
        return NULL;
    }

    //
    // Allocate a buffer for the concatentated string
    //
    BytesFirst = wcslen(First) * sizeof(WCHAR);
    BytesSecond = wcslen(Second) * sizeof(WCHAR);
    BytesThird = (wcslen(Third) + 1) * sizeof(WCHAR);

    New = (PCHAR)FrsAlloc(BytesFirst + BytesSecond + BytesThird);

    CopyMemory(&New[0], First, BytesFirst);
    CopyMemory(&New[BytesFirst], Second, BytesSecond);
    CopyMemory(&New[BytesFirst + BytesSecond], Third, BytesThird);

    return (PWCHAR)New;
}


PWCHAR
FrsWcsCat(
    PWCHAR First,
    PWCHAR Second
    )
/*++
Routine Description:
    Concatenate two strings into a new string using our memory allocater

Arguments:
    First   - First string in the concat
    Second  - Second string in the concat

Return Value:
    Duplicated and concatentated string. Free with FrsFree().
--*/
{
#undef DEBSUB
#define DEBSUB "FrsWcscat:"

    DWORD   Bytes;
    PWCHAR  New;

    FRS_ASSERT(First != NULL && Second != NULL);

    // size of new string
    Bytes = (wcslen(First) + wcslen(Second) + 1) * sizeof(WCHAR);
    New = (PWCHAR)FrsAlloc(Bytes);

    // Not as efficient as I would like but this routine is seldom used
    wcscpy(New, First);
    wcscat(New, Second);

    return New;
}


PCHAR
FrsCsCat(
    PCHAR First,
    PCHAR Second
    )
/*++
Routine Description:
    Concatenate two strings into a new string using our memory allocater

Arguments:
    First   - First string in the concat
    Second  - Second string in the concat

Return Value:
    Duplicated and concatentated string. Free with FrsFree().
--*/
{
#undef DEBSUB
#define DEBSUB "FrsCscat:"

    DWORD   Bytes;
    PCHAR  New;

    FRS_ASSERT(First != NULL && Second != NULL);

    // size of new string
    Bytes = strlen(First) + strlen(Second) + 1;
    New = (PCHAR)FrsAlloc(Bytes);

    // Not as efficient as I would like but this routine is seldom used
    strcpy(New, First);
    strcat(New, Second);

    return New;
}


PWCHAR
FrsWcsPath(
    PWCHAR First,
    PWCHAR Second
    )
/*++
Routine Description:
    Concatenate two strings into a pathname

Arguments:
    First   - First string in the concat
    Second  - Second string in the concat

Return Value:
    Dup of First\Second. Free with FrsFree();
--*/
{
#undef DEBSUB
#define DEBSUB "FrsWcsPath:"
    return FrsWcsCat3(First, L"\\", Second);
}


PCHAR
FrsCsPath(
    PCHAR First,
    PCHAR Second
    )
/*++
Routine Description:
    Concatenate two strings into a pathname

Arguments:
    First   - First string in the concat
    Second  - Second string in the concat

Return Value:
    Duplicated and concatentated string. Free with FrsFree().
--*/
{
#undef DEBSUB
#define DEBSUB "FrsCsPath:"
    PCHAR  TmpPath;
    PCHAR  FinalPath;

    //
    // Very inefficient but seldom called
    //
    TmpPath = FrsCsCat(First, "\\");
    FinalPath = FrsCsCat(TmpPath, Second);
    FrsFree(TmpPath);
    return FinalPath;
}


PVOID
FrsAllocTypeSize(
    IN NODE_TYPE NodeType,
    IN ULONG SizeDelta
    )
/*++

Routine Description:

    This routine allocates memory for the given node type and performs any
    node specific initialization/allocation.  The node is zeroed and the
    size/type fields are filled in.

Arguments:

    NodeType - The type of node to allocate.

    SizeDelta - The amount of storage to allocate in ADDITION to the base type.

Return Value:

    The node address is returned here. An exception is raised if
        memory could not be allocated.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsAllocTypeSize:"

    PVOID                  Node;
    ULONG                  NodeSize;
    PREPLICA               Replica;
    PREPLICA_THREAD_CTX    RtCtx;
    PTHREAD_CTX            ThreadCtx;
    PTABLE_CTX             TableCtx;
    ULONG                  i;
    PJBUFFER               Jbuffer;
    PVOLUME_MONITOR_ENTRY  pVme;
    PFILTER_TABLE_ENTRY    FilterEntry;
    PQHASH_TABLE           QhashTable;
    PCXTION                Cxtion;
    PCONFIG_NODE           ConfigNode;
    PCHANGE_ORDER_ENTRY    ChangeOrder;
    PGHANDLE               GHandle;
    PWILDCARD_FILTER_ENTRY WildcardEntry;

    switch (NodeType) {

    //
    // Allocate a Thread Context struct
    //
    case THREAD_CONTEXT_TYPE:
        NodeSize = sizeof(THREAD_CTX);
        Node = FrsAlloc(NodeSize);

        //
        // No session or DB open yet.
        //
        ThreadCtx = (PTHREAD_CTX) Node;
        ThreadCtx->JSesid = JET_sesidNil;
        ThreadCtx->JDbid = JET_dbidNil;
        ThreadCtx->JInstance  = GJetInstance;

        FrsRtlInitializeList(&ThreadCtx->ThreadCtxListHead);
        break;

    //
    // Allocate a Replica struct and the config table ctx struct.
    //
    case REPLICA_TYPE:
        NodeSize = sizeof(REPLICA);
        Node = FrsAlloc(NodeSize);

        Replica = (PREPLICA) Node;

        //
        // Config record flags (CONFIG_FLAG_... in schema.h)
        //
        SetFlag(Replica->CnfFlags, CONFIG_FLAG_MULTIMASTER);

        InitializeCriticalSection(&Replica->ReplicaLock);
        FrsRtlInitializeList(&Replica->ReplicaCtxListHead);

        InitializeListHead(&Replica->FileNameFilterHead);
        InitializeListHead(&Replica->FileNameInclFilterHead);
        InitializeListHead(&Replica->DirNameFilterHead);
        InitializeListHead(&Replica->DirNameInclFilterHead);

        Replica->ConfigTable.TableType = TABLE_TYPE_INVALID;
        DbsAllocTableCtx(ConfigTablex, &Replica->ConfigTable);

        Replica->VVector = GTabAllocTable();
        Replica->Cxtions = GTabAllocTable();
        Replica->FStatus = FrsErrorSuccess;
        Replica->Consistent = TRUE;

        InitializeCriticalSection(&Replica->OutLogLock);
        InitializeListHead(&Replica->OutLogEligible);
        InitializeListHead(&Replica->OutLogStandBy);
        InitializeListHead(&Replica->OutLogActive);
        InitializeListHead(&Replica->OutLogInActive);
        Replica->OutLogWorkState = OL_REPLICA_INITIALIZING;

        Replica->ServiceState = REPLICA_STATE_ALLOCATED;
        Replica->OutLogJLx = 1;

        //
        // No preinstall directory, yet
        //
        Replica->PreInstallHandle = INVALID_HANDLE_VALUE;

        //
        // Initialize the NewStage fiend.
        //
        Replica->NewStage = NULL;

        //
        // Initialize InitSyncCxtionsMasterList and InitSyncCxtionsWorkingList.
        //
        Replica->InitSyncCxtionsMasterList = NULL;
        Replica->InitSyncCxtionsWorkingList = NULL;
        Replica->InitSyncQueue = NULL;

        //
        // Add memory for the counter data structure, set the back pointer
        // and bump ref count.
        //
        Replica->PerfRepSetData =
              (PHT_REPLICA_SET_DATA) FrsAlloc (sizeof(HT_REPLICA_SET_DATA));
        Replica->PerfRepSetData->RepBackPtr = Replica;
        InterlockedIncrement(&Replica->ReferenceCount);

        break;

    //
    // Allocate a Replica Thread Context struct and the table context structs.
    //
    case REPLICA_THREAD_TYPE:
        NodeSize = sizeof(REPLICA_THREAD_CTX);
        Node = FrsAlloc(NodeSize);

        //
        // Get the base of the array of TableCtx structs from the replica thread
        // context struct and the base of the table create structs.
        //
        RtCtx = (PREPLICA_THREAD_CTX) Node;
        TableCtx = RtCtx->RtCtxTables;

        //
        // Open the initial set of tables for the replica set.
        //
        for (i=0; i<TABLE_TYPE_MAX; ++i, ++TableCtx) {
                //
                // Marking the TableType as INVALID causes DbsAllocTableCtx()
                // to allocate the DB support structs on the first call.
                //
                TableCtx->TableType = TABLE_TYPE_INVALID;

                //
                // If the SizeDelta parameter is non-zero then do not allocate
                // the TableCtx internal structs.  The caller will do it.
                //
                if (SizeDelta == 0) {
                    DbsAllocTableCtx(i, TableCtx);
                } else {
                    //
                    // Mark table as not open by a session yet.
                    //
                    TableCtx->Tid   = JET_tableidNil;
                    TableCtx->Sesid = JET_sesidNil;
                    TableCtx->ReplicaNumber = FRS_UNDEFINED_REPLICA_NUMBER;
                }
        }

        break;

    //
    // Allocate a topology node
    //
    case CONFIG_NODE_TYPE:
        NodeSize = sizeof(CONFIG_NODE);
        Node = FrsAlloc(NodeSize);

        ConfigNode = (PCONFIG_NODE) Node;
        ConfigNode->Consistent = TRUE;

        break;

    //
    // Allocate a connection
    //
    case CXTION_TYPE:
        NodeSize = sizeof(CXTION);
        Node = FrsAlloc(NodeSize);
        Cxtion = Node;
        Cxtion->CoeTable = GTabAllocTable();
        //
        // Allocate memory for the counter data structure
        //
        Cxtion->PerfRepConnData =
            (PHT_REPLICA_CONN_DATA) FrsAlloc (sizeof(HT_REPLICA_CONN_DATA));

        break;

    //
    // Allocate a list of bound rpc handles indexed by server guid
    //
    case GHANDLE_TYPE:
        NodeSize = sizeof(GHANDLE);
        Node = FrsAlloc(NodeSize);
        GHandle = Node;
        InitializeCriticalSection(&GHandle->Lock);

        break;

    //
    // Allocate a generic table
    //
    case GEN_TABLE_TYPE:
        NodeSize = sizeof(GEN_TABLE);
        Node = FrsAlloc(NodeSize);

        break;

    //
    // Allocate a generic thread context
    //
    case THREAD_TYPE:
        NodeSize = sizeof(FRS_THREAD);
        Node = FrsAlloc(NodeSize);

        break;

    //
    // Allocate a journal read buffer.
    //
    case JBUFFER_TYPE:
        NodeSize = SizeOfJournalBuffer;
        Node = FrsAlloc(NodeSize);

        //
        // Init the data buffer size and start address.
        //
        Jbuffer = (PJBUFFER) Node;
        Jbuffer->BufferSize = NodeSize - SizeOfJournalBufferDesc;
        Jbuffer->DataBuffer = &Jbuffer->Buffer[0];

        break;

    //
    // Allocate a journal volume monitor entry.
    //
    case VOLUME_MONITOR_ENTRY_TYPE:

        NodeSize = sizeof(VOLUME_MONITOR_ENTRY);
        Node = FrsAlloc(NodeSize);

        pVme = (PVOLUME_MONITOR_ENTRY) Node;
        FrsRtlInitializeList(&pVme->ReplicaListHead);
        InitializeCriticalSection(&pVme->Lock);
        InitializeCriticalSection(&pVme->QuadWriteLock);
        pVme->Event = CreateEvent(NULL, TRUE, FALSE, NULL);
        pVme->JournalState = JRNL_STATE_ALLOCATED;
        break;

    //
    // Allocate a command packet.
    //
    case COMMAND_PACKET_TYPE:

        NodeSize = sizeof(COMMAND_PACKET);
        Node = FrsAlloc(NodeSize + SizeDelta);

        break;

    //
    // Allocate a generic hash table struct.
    //
    case GENERIC_HASH_TABLE_TYPE:

        NodeSize = sizeof(GENERIC_HASH_TABLE);
        Node = FrsAlloc(NodeSize);

        break;

    //
    // Allocate a Change Order Entry struct.  Caller allocates Extension as necc.
    //
    case CHANGE_ORDER_ENTRY_TYPE:

        NodeSize = sizeof(CHANGE_ORDER_ENTRY);
        Node = FrsAlloc(NodeSize + SizeDelta);
        ChangeOrder = (PCHANGE_ORDER_ENTRY)Node;

        //
        // Init the unicode filename string to point to internal alloc.
        //
        ChangeOrder->UFileName.Buffer = ChangeOrder->Cmd.FileName;
        ChangeOrder->UFileName.MaximumLength = (USHORT)
            (SIZEOF(CHANGE_ORDER_ENTRY, Cmd.FileName) + SizeDelta);
        ChangeOrder->UFileName.Length = 0;

        break;

    //
    // Allocate a Filter Table Entry struct.
    //
    case FILTER_TABLE_ENTRY_TYPE:

        NodeSize = sizeof(FILTER_TABLE_ENTRY);
        Node = FrsAlloc(NodeSize + SizeDelta);
        FilterEntry = (PFILTER_TABLE_ENTRY)Node;
        //
        // Init the unicode filename string to point to internal alloc.
        //
        FilterEntry->UFileName.Buffer = FilterEntry->DFileName;
        FilterEntry->UFileName.MaximumLength = (USHORT)SizeDelta + sizeof(WCHAR);
        FilterEntry->UFileName.Length = 0;

        InitializeListHead(&FilterEntry->ChildHead);

        break;

    //
    // Allocate a QHASH table struct.  Just alloc the
    // base table.  An extension is allocated on the first collision.
    // *NOTE* caller specifies the size of the actual hash table and
    // the extension.  Caller also must store an address to a hash calc
    // function.
    //
    case QHASH_TABLE_TYPE:

        NodeSize = sizeof(QHASH_TABLE);
        Node = FrsAlloc(NodeSize + SizeDelta);
        QhashTable = (PQHASH_TABLE)Node;

        InitializeCriticalSection(&QhashTable->Lock);
        InitializeListHead(&QhashTable->ExtensionListHead);

        QhashTable->BaseAllocSize = NodeSize + SizeDelta;
        QhashTable->NumberEntries = SizeDelta / sizeof(QHASH_ENTRY);

        if (SizeDelta <= QHASH_EXTENSION_MAX) {
            QhashTable->ExtensionAllocSize = sizeof(LIST_ENTRY) + SizeDelta;
        } else {
            QhashTable->ExtensionAllocSize = sizeof(LIST_ENTRY) + QHASH_EXTENSION_MAX;
        }

        QhashTable->HashRowBase = (PQHASH_ENTRY) (QhashTable + 1);

        SET_QHASH_TABLE_HASH_CALC(QhashTable, NULL);

        QhashTable->FreeList.Next = NULL;

        break;

    //
    // Allocate an Output Log Partner struct.
    // This is ultimately hooked to a Connection struct which provides the
    // Guid and version vector.
    //
    case OUT_LOG_PARTNER_TYPE:
        NodeSize = sizeof(OUT_LOG_PARTNER);
        Node = FrsAlloc(NodeSize);

        break;

    //
    // Allocate a WildcardEntry filter Entry struct.
    //
    case WILDCARD_FILTER_ENTRY_TYPE:

        NodeSize = sizeof(WILDCARD_FILTER_ENTRY);
        Node = FrsAlloc(NodeSize + SizeDelta);
        WildcardEntry = (PWILDCARD_FILTER_ENTRY)Node;
        //
        // Init the unicode filename string to point to internal alloc.
        //
        WildcardEntry->UFileName.Buffer = WildcardEntry->FileName;
        WildcardEntry->UFileName.MaximumLength = (USHORT)SizeDelta;
        WildcardEntry->UFileName.Length = 0;

        break;

    //
    // Invalid Node Type
    //
    default:
        Node = NULL;
        DPRINT1(0, "Internal error - invalid node type - %d\n", NodeType);
        XRAISEGENEXCEPTION(FrsErrorInternalError);
    }

    //
    // Set up the header for later checking in FrsFreeType
    //
    ((PFRS_NODE_HEADER) Node)->Type = (USHORT) NodeType;
    ((PFRS_NODE_HEADER) Node)->Size = (USHORT) NodeSize;

    //
    // Tracking memory expansion
    //
    EnterCriticalSection(&MemLock);
    TypesAllocated[NodeType]++;
    TypesAllocatedCount[NodeType]++;
    if (TypesAllocated[NodeType] > TypesAllocatedMax[NodeType]) {
        TypesAllocatedMax[NodeType] = TypesAllocated[NodeType];
    }
    LeaveCriticalSection(&MemLock);

    //
    // Return node address to caller.
    //
    return Node;
}


PVOID
FrsFreeType(
    IN PVOID Node
    )
/*++

Routine Description:

    This routine frees memory for the given node, performing any node specific
    cleanup.  It marks the freed memory with the hex string 0xDEADBEnn where
    the low byte (nn) is set to the node type being freed to catch users of
    stale pointers.

Arguments:

    Node - The address of the node to free.

Return Value:

    NULL.  Typical call is:  ptr = FrsFreeType(ptr) to catch errors.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsFreeType:"

    ULONG                  NodeSize;
    ULONG                  NodeType;
    ULONG                  Marker;
    PREPLICA               Replica;
    PREPLICA_THREAD_CTX    RtCtx;
    PTABLE_CTX             TableCtx;
    PTHREAD_CTX            ThreadCtx;
    ULONG                  i;
    PVOLUME_MONITOR_ENTRY  pVme;
    PFILTER_TABLE_ENTRY    FilterEntry;
    PQHASH_TABLE           QhashTable;
    PLIST_ENTRY            Entry;
    PCXTION                Cxtion;
    PCONFIG_NODE           ConfigNode;
    PCHANGE_ORDER_ENTRY    ChangeOrder;
    PGHANDLE               GHandle;
    PHANDLE_LIST           HandleList;
    PWILDCARD_FILTER_ENTRY WildcardEntry;
    POUT_LOG_PARTNER       OutLogPartner;


    if (Node == NULL) {
        return NULL;
    }

    NodeType = (ULONG) (((PFRS_NODE_HEADER) Node)->Type);
    NodeSize = (ULONG) (((PFRS_NODE_HEADER) Node)->Size);

    switch (NodeType) {
    //
    // Free a Thread Context struct
    //
    case THREAD_CONTEXT_TYPE:
        if (NodeSize != sizeof(THREAD_CTX)) {
            DPRINT1(0, "FrsFree - Bad node size %d for THREAD_CONTEXT\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }

        ThreadCtx = (PTHREAD_CTX) Node;
        FrsRtlDeleteList(&ThreadCtx->ThreadCtxListHead);

        break;

    //
    // Free a Replica struct
    //
    case REPLICA_TYPE:
        if (NodeSize != sizeof(REPLICA)) {
            DPRINT1(0, "FrsFree - Bad node size %d for REPLICA\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }
        Replica = (PREPLICA) Node;
        //
        // Free the config table context.
        //
        DbsFreeTableCtx(&Replica->ConfigTable, NodeType);
        FrsRtlDeleteList(&Replica->ReplicaCtxListHead);

        //
        // Empty the file and directory filter lists
        //
        FrsEmptyNameFilter(&Replica->FileNameFilterHead);
        FrsEmptyNameFilter(&Replica->FileNameInclFilterHead);
        FrsEmptyNameFilter(&Replica->DirNameFilterHead);
        FrsEmptyNameFilter(&Replica->DirNameInclFilterHead);
        FrsFree(Replica->FileFilterList);
        FrsFree(Replica->FileInclFilterList);
        FrsFree(Replica->DirFilterList);
        FrsFree(Replica->DirInclFilterList);


        DeleteCriticalSection(&Replica->ReplicaLock);
        DeleteCriticalSection(&Replica->OutLogLock);
        if (Replica->OutLogRecordLock != NULL) {
            //
            // Free the record lock table.
            //
            Replica->OutLogRecordLock = FrsFreeType(Replica->OutLogRecordLock);
        }

        //
        // queue
        //
        if (Replica->Queue) {
            FrsRtlDeleteQueue(Replica->Queue);
            FrsFree(Replica->Queue);
        }

        //
        // free the initsync queue.
        //
        if (Replica->InitSyncQueue) {
            FrsRtlDeleteQueue(Replica->InitSyncQueue);
            Replica->InitSyncQueue = FrsFree(Replica->InitSyncQueue);
        }

        //
        // Names
        //
        FrsFree(Replica->Root);
        FrsFree(Replica->Stage);
        FrsFree(Replica->NewStage);
        FrsFree(Replica->Volume);
        FrsFreeGName(Replica->ReplicaName);
        FrsFreeGName(Replica->SetName);
        FrsFreeGName(Replica->MemberName);

        //
        // Root Guid
        //
        FrsFree(Replica->ReplicaRootGuid);

        //
        // Status of sysvol seeding
        //
        FrsFree(Replica->NtFrsApi_ServiceDisplay);

        //
        // Schedule
        //
        FrsFree(Replica->Schedule);
        //
        // VVector
        //
        VVFree(Replica->VVector);
        //
        // Cxtions
        //
        GTabFreeTable(Replica->Cxtions, FrsFreeType);

        //
        // Preinstall directory
        //
        FRS_CLOSE(Replica->PreInstallHandle);

        //
        // Free the counter data structure memory
        //
        if (Replica->PerfRepSetData != NULL) {
            if (Replica->PerfRepSetData->oid != NULL) {
                if (Replica->PerfRepSetData->oid->name != NULL) {
                    Replica->PerfRepSetData->oid->name =
                        FrsFree(Replica->PerfRepSetData->oid->name);
                }
                Replica->PerfRepSetData->oid =
                    FrsFree(Replica->PerfRepSetData->oid);
            }
            Replica->PerfRepSetData = FrsFree(Replica->PerfRepSetData);
        }

        break;

    //
    // Free a Replica Thread Context struct
    //
    case REPLICA_THREAD_TYPE:
        if (NodeSize != sizeof(REPLICA_THREAD_CTX)) {
            DPRINT1(0, "FrsFree - Bad node size %d for REPLICA_THREAD_CTX\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }

        RtCtx = (PREPLICA_THREAD_CTX) Node;

        //
        // Get the base of the array of TableCtx structs from the replica thread
        // context struct.
        //
        TableCtx = RtCtx->RtCtxTables;

        //
        // Release the memory for each table context struct.
        //
        for (i=0; i<TABLE_TYPE_MAX; ++i, ++TableCtx)
            DbsFreeTableCtx(TableCtx, NodeType);

        break;

    //
    // Free a topology node
    //
    case CONFIG_NODE_TYPE:
        if (NodeSize != sizeof(CONFIG_NODE)) {
            DPRINT1(0, "FrsFree - Bad node size %d for CONFIG_NODE\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }
        ConfigNode = (PCONFIG_NODE) Node;
        FrsFreeGName(ConfigNode->Name);
        FrsFreeGName(ConfigNode->PartnerName);
        FrsFree(ConfigNode->Root);
        FrsFree(ConfigNode->Stage);
        FrsFree(ConfigNode->Schedule);
        FrsFree(ConfigNode->Dn);
        FrsFree(ConfigNode->PrincName);
        FrsFree(ConfigNode->PartnerDn);
        FrsFree(ConfigNode->PartnerCoDn);
        FrsFree(ConfigNode->SettingsDn);
        FrsFree(ConfigNode->ComputerDn);
        FrsFree(ConfigNode->MemberDn);
        FrsFree(ConfigNode->Working);
        FrsFree(ConfigNode->SetType);
        FrsFree(ConfigNode->FileFilterList);
        FrsFree(ConfigNode->DirFilterList);
        FrsFree(ConfigNode->UsnChanged);
        FrsFree(ConfigNode->DnsName);
        FrsFree(ConfigNode->PartnerDnsName);
        FrsFree(ConfigNode->Sid);
        FrsFree(ConfigNode->PartnerSid);
        FrsFree(ConfigNode->EnabledCxtion);
        break;

    //
    // Free a connection
    //
    case CXTION_TYPE:
        if (NodeSize != sizeof(CXTION)) {
            DPRINT1(0, "FrsFree - Bad node size %d for CXTION\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }
        Cxtion = (PCXTION) Node;
        VVFreeOutbound(Cxtion->VVector);

        //
        // Free the CompressionTable that was build for the outbound partner.
        //
        GTabFreeTable(Cxtion->CompressionTable, FrsFree);

        //
        // Free the OutLogPartner context.
        //
        FrsFreeType(Cxtion->OLCtx);

        SndCsDestroyCxtion(Cxtion, CXTION_FLAGS_UNJOIN_GUID_VALID);
        if (Cxtion->CommTimeoutCmd) {
            //
            // Try to catch the case where a Comm Time Out wait command is
            // getting freed while it is still on the timeout queue.  This is
            // related to a bug where we get into a comm timeout loop with an
            // invalid command code.
            //
            FRS_ASSERT(!CxtionFlagIs(Cxtion, CXTION_FLAGS_TIMEOUT_SET));

            FRS_ASSERT(!CmdWaitFlagIs(Cxtion->CommTimeoutCmd, CMD_PKT_WAIT_FLAGS_ONLIST));

            FrsFreeType(Cxtion->CommTimeoutCmd);
        }
        //
        // A cxtion doesn't actually "own" the join command packet; it
        // only maintains a reference to prevent extraneous join commands
        // from flooding the replica's queue.
        //
        Cxtion->JoinCmd = NULL;

        //
        // VvJoin Command Server (1 per cxtion)
        //
        if (Cxtion->VvJoinCs) {
            FrsRunDownCommandServer(Cxtion->VvJoinCs,
                                    &Cxtion->VvJoinCs->Queue);
            FrsDeleteCommandServer(Cxtion->VvJoinCs);
            FrsFree(Cxtion->VvJoinCs);
        }

        if (!Cxtion->ChangeOrderCount) {
            GTabFreeTable(Cxtion->CoeTable, NULL);
        }
        FrsFreeGName(Cxtion->Name);
        FrsFreeGName(Cxtion->Partner);
        FrsFree(Cxtion->PartnerPrincName);
        FrsFree(Cxtion->Schedule);
        FrsFree(Cxtion->PartSrvName);
        FrsFree(Cxtion->PartnerDnsName);
        FrsFree(Cxtion->PartnerSid);

        //
        // Delete the connection from the perfmon tables.
        // Free the counter data structure memory
        //
        if (Cxtion->PerfRepConnData != NULL) {
            if (Cxtion->PerfRepConnData->oid != NULL) {
                DeletePerfmonInstance(REPLICACONN, Cxtion->PerfRepConnData);
            }
            Cxtion->PerfRepConnData = FrsFree(Cxtion->PerfRepConnData);
        }

        break;

    //
    // Free a guid/rpc handle
    //
    case GHANDLE_TYPE:
        if (NodeSize != sizeof(GHANDLE)) {
            DPRINT2(0, "FrsFree - Bad node size %d (%d) for GHANDLE\n",
                    NodeSize, sizeof(GHANDLE));
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }
        GHandle = (PGHANDLE)Node;
        while (HandleList = GHandle->HandleList) {
            GHandle->HandleList = HandleList->Next;
            FrsRpcUnBindFromServer(&HandleList->RpcHandle);
            FrsFree(HandleList);
        }
        DeleteCriticalSection(&GHandle->Lock);

        break;

    //
    // Free a generic table
    //
    case GEN_TABLE_TYPE:
        if (NodeSize != sizeof(GEN_TABLE)) {
            DPRINT1(0, "FrsFree - Bad node size %d for GEN_TABLE\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }

        break;

    //
    // Free a generic thread context
    //
    case THREAD_TYPE:
        if (NodeSize != sizeof(FRS_THREAD)) {
            DPRINT1(0, "FrsFree - Bad node size %d for FRS_THREAD\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }

        break;

    //
    // Free a journal read buffer.
    //
    case JBUFFER_TYPE:
        if (NodeSize != SizeOfJournalBuffer) {
            DPRINT1(0, "FrsFree - Bad node size %d for JBUFFER\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }

        break;

    //
    // Free a journal volume monitor entry.
    //
    case VOLUME_MONITOR_ENTRY_TYPE:
        if (NodeSize != sizeof(VOLUME_MONITOR_ENTRY)) {
            DPRINT1(0, "FrsFree - Bad node size %d for VOLUME_MONITOR_ENTRY\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }

        pVme = (PVOLUME_MONITOR_ENTRY) Node;

        FrsRtlDeleteList(&pVme->ReplicaListHead);
        DeleteCriticalSection(&pVme->Lock);
        DeleteCriticalSection(&pVme->QuadWriteLock);
        FRS_CLOSE(pVme->Event);

        //
        // Release the change order hash table.
        //
        GhtDestroyTable(pVme->ChangeOrderTable);
        //
        // Release the Filter Hash Table.
        //
        GhtDestroyTable(pVme->FilterTable);

        break;


    //
    // Free a command packet.
    //
    case COMMAND_PACKET_TYPE:
        if (NodeSize != sizeof(COMMAND_PACKET)) {
            DPRINT1(0, "FrsFree - Bad node size %d for COMMAND_PACKET\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }
        break;

    //
    // Free a generic hash table struct.
    //
    case GENERIC_HASH_TABLE_TYPE:
        if (NodeSize != sizeof(GENERIC_HASH_TABLE)) {
            DPRINT1(0, "FrsFree - Bad node size %d for GENERIC_HASH_TABLE\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }
        break;

    //
    // Free a Change Order Entry struct.
    //
    case CHANGE_ORDER_ENTRY_TYPE:
        if (NodeSize != sizeof(CHANGE_ORDER_ENTRY)) {
            DPRINT1(0, "FrsFree - Bad node size %d for CHANGE_ORDER_ENTRY\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }

        ChangeOrder = (PCHANGE_ORDER_ENTRY)Node;

        //
        // If we allocated a new name string then free it.
        //
        if (ChangeOrder->UFileName.Buffer != ChangeOrder->Cmd.FileName) {
            FrsFree(ChangeOrder->UFileName.Buffer);
        }

        //
        // Free the change order extenstion.
        //
        if (ChangeOrder->Cmd.Extension != NULL) {
            FrsFree(ChangeOrder->Cmd.Extension);
        }

        break;

    //
    // Free a Filter Table Entry struct.
    //
    case FILTER_TABLE_ENTRY_TYPE:
        if (NodeSize != sizeof(FILTER_TABLE_ENTRY)) {
            DPRINT1(0, "FrsFree - Bad node size %d for FILTER_TABLE_ENTRY\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }

        FilterEntry = (PFILTER_TABLE_ENTRY)Node;

        //
        // If we allocated a new name string then free it.
        //
        if (FilterEntry->UFileName.Buffer != FilterEntry->DFileName) {
            FrsFree(FilterEntry->UFileName.Buffer);
        }

        break;


    //
    // Free a QHASH table struct.
    //
    case QHASH_TABLE_TYPE:
        if (NodeSize != sizeof(QHASH_TABLE)) {
            DPRINT1(0, "FrsFree - Bad node size %d for QHASH_TABLE\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }
        QhashTable = (PQHASH_TABLE)Node;

        QHashEmptyLargeKeyTable(QhashTable);
        //
        // Free up all the extensions we allocated.
        //
        while (!IsListEmpty(&QhashTable->ExtensionListHead)) {
            Entry = GetListHead(&QhashTable->ExtensionListHead);
            FrsRemoveEntryList(Entry);
            FrsFree(Entry);
        }

        DeleteCriticalSection(&QhashTable->Lock);
        break;

    //
    // Free an Output Log Partner struct.
    //
    case OUT_LOG_PARTNER_TYPE:
        if (NodeSize != sizeof(OUT_LOG_PARTNER)) {
            DPRINT1(0, "FrsFree - Bad node size %d for OUT_LOG_PARTNER\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }
        OutLogPartner = (POUT_LOG_PARTNER)Node;
        //
        // Free the Must send QHash Table.
        //
        OutLogPartner->MustSendTable = FrsFreeType(OutLogPartner->MustSendTable);
        break;

    //
    // Free a Wildcard file filter Entry struct.
    //
    case WILDCARD_FILTER_ENTRY_TYPE:
        if (NodeSize != sizeof(WILDCARD_FILTER_ENTRY)) {
            DPRINT1(0, "FrsFree - Bad node size %d for WILDCARD_FILTER_ENTRY\n", NodeSize);
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }

        WildcardEntry = (PWILDCARD_FILTER_ENTRY)Node;

        //
        // Free the name buffer if it no longer points at the initial alloc.
        //
        if (WildcardEntry->UFileName.Buffer != WildcardEntry->FileName) {
            FrsFree(WildcardEntry->UFileName.Buffer);
        }

        break;

    //
    // Invalid Node Type
    //
    default:
        Node = NULL;
        DPRINT1(0, "Internal error - invalid node type - %d\n", NodeType);
        XRAISEGENEXCEPTION(FrsErrorInternalError);
    }

    EnterCriticalSection(&MemLock);
    TypesAllocated[NodeType]--;
    LeaveCriticalSection(&MemLock);

    //
    // Fill the node with a marker then free it.
    //
    Marker = (ULONG) 0xDEADBE00 + NodeType;
    FillMemory(Node, NodeSize, (BYTE)Marker);
    return FrsFree(Node);
}



VOID
FrsFreeTypeList(
    PLIST_ENTRY Head
    )
/*++

Routine Description:

    Free all the "typed" entries on the specified list.

    Note:  This routine requires that the LIST_ENTRY struct in each
    list entry immediately follow the FRS_NODE_HEADER and of course that
    the list entry is actually linked through that LIST_ENTRY struct.

Arguments:

    Head -- ptr to the list head.

Thread Return Value:

    None.

--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsFreeTypeList:"

    PLIST_ENTRY Entry;
    PFRS_NODE_HEADER Header;

    Entry = RemoveHeadList(Head);

    while (Entry != Head) {
        Header = (PFRS_NODE_HEADER) CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
        if ((Header->Type >= NODE_TYPE_MIN) &&
            (Header->Type < NODE_TYPE_MAX)) {
            FrsFreeType(Header);
        } else {
            DPRINT(0, "Node type out of range.  Not freed.\n");
        }
        Entry = RemoveHeadList(Head);
    }
}


VOID
FrsPrintGNameForNode(
    IN ULONG    Severity,
    IN PGNAME   GName,
    IN PWCHAR   Indent,
    IN PWCHAR   Id,
    IN PCHAR    Debsub,
    IN ULONG    uLineNo
    )
/*++

Routine Description:

    Pretty print a gname for FrsPrintNode()

Arguments:

    Severity -- Severity level for print.  (See debug.c, debug.h)

    GName - The address of the GName to print.

    Indent - line indentation

    Id - identifies the gname

    Debsub -- Name of calling subroutine.

    uLineno -- Line number of caller

Return Value:

    none.

--*/
{
    CHAR    GuidStr[GUID_CHAR_LEN];

    if (GName) {
        if (GName->Name) {
            FRS_DEB_PRINT3("%ws%ws: %ws\n", Indent, Id, GName->Name);
        } else {
            FRS_DEB_PRINT3("%wsNO %ws->NAME for %08x\n", Indent, Id, GName);
        }
        if (GName->Guid) {
            GuidToStr(GName->Guid, GuidStr);
            FRS_DEB_PRINT3("%ws%wsGuid: %s\n", Indent, Id, GuidStr);
        } else {
            FRS_DEB_PRINT3("%wsNO %ws->GUID for %08x\n", Indent, Id, GName);
        }
    } else {
        FRS_DEB_PRINT3("%wsNO %ws for %08x\n", Indent, Id, GName);
    }
}


VOID
FrsPrintTypeSchedule(
    IN ULONG            Severity,   OPTIONAL
    IN PNTFRSAPI_INFO   Info,       OPTIONAL
    IN DWORD            Tabs,       OPTIONAL
    IN PSCHEDULE        Schedule,
    IN PCHAR            Debsub,     OPTIONAL
    IN ULONG            uLineNo     OPTIONAL
    )
/*++
Routine Description:
    Print a schedule.

Arguments:
    Severity    - for DPRINTs
    Info        - RPC output buffer
    Tabs        - prettyprint
    Schedule    - schedule blob
    Debsub      - for DPRINTs
    uLineNo     - for DPRINTs

Return Value:
    None.
--*/
{
    ULONG   i;
    ULONG   Day;
    ULONG   Hour;
    ULONG   LineLen;
    PUCHAR  ScheduleData;
    CHAR    Line[256];
    WCHAR   TabW[MAX_TAB_WCHARS + 1];

    if (!Schedule) {
        return;
    }

    InfoTabs(Tabs, TabW);

    for (i = 0; i < Schedule->NumberOfSchedules; ++i) {
        ScheduleData = ((PUCHAR)Schedule) + Schedule->Schedules[i].Offset;
        if (Schedule->Schedules[i].Type != SCHEDULE_INTERVAL) {
            continue;
        }
        for (Day = 0; Day < 7; ++Day) {
            _snprintf(Line, sizeof(Line), "%wsDay %1d: ", TabW, Day + 1);
            for (Hour = 0; Hour < 24; ++Hour) {
                LineLen = strlen(Line);
                _snprintf(&Line[LineLen],
                          sizeof(Line) - LineLen,
                          "%1x",
                          *(ScheduleData + (Day * 24) + Hour) & 0x0F);
            }
            ITPRINT1("%s\n", Line);
        }
    }
}


VOID
FrsPrintTypeVv(
    IN ULONG            Severity,   OPTIONAL
    IN PNTFRSAPI_INFO   Info,       OPTIONAL
    IN DWORD            Tabs,       OPTIONAL
    IN PGEN_TABLE       Vv,
    IN PCHAR            Debsub,     OPTIONAL
    IN ULONG            uLineNo     OPTIONAL
    )
/*++
Routine Description:
    Print a version vector

Arguments:
    Severity    - for DPRINTs
    Info        - RPC output buffer
    Tabs        - prettyprint
    Vv          - Version vector table
    Debsub      - for DPRINTs
    uLineNo     - for DPRINTs

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsPrintTypeVv:"
    PVOID       Key;
    PVV_ENTRY   MasterVVEntry;
    WCHAR       TabW[MAX_TAB_WCHARS + 1];
    CHAR        Guid[GUID_CHAR_LEN + 1];

    if (!Vv) {
        return;
    }
    InfoTabs(Tabs, TabW);

    Key = NULL;
    while (MasterVVEntry = GTabNextDatum(Vv, &Key)) {
        if (!Info) {
            DebLock();
        }
        GuidToStr(&MasterVVEntry->GVsn.Guid, Guid);
        ITPRINT3("%wsVvEntry: %s = %08x %08x\n",
                 TabW, Guid, PRINTQUAD(MasterVVEntry->GVsn.Vsn));
        if (!Info) {
            DebUnLock();
        }
    }
}


VOID
FrsPrintTypeOutLogAVToStr(
    POUT_LOG_PARTNER OutLogPartner,
    ULONG RetireCOx,
    PCHAR *OutStr1,
    PCHAR *OutStr2,
    PCHAR *OutStr3
    )
{
#undef DEBSUB
#define DEBSUB "FrsPrintTypeOutLogAVToStr:"
    PCHAR Str, Str2, Str3;
    ULONG j, Slotx, MaxSlotx, COx, Fill, Scan;
    //
    // Caller frees strings with FrsFree(Str).
    //
    Str  = FrsAlloc(3*(ACK_VECTOR_SIZE+4));
    Str2 = Str  + (ACK_VECTOR_SIZE+4);
    Str3 = Str2 + (ACK_VECTOR_SIZE+4);

    COx = OutLogPartner->COTx;
    Slotx = AVSlot(OutLogPartner->COTx, OutLogPartner);

    MaxSlotx = Slotx + ACK_VECTOR_SIZE;
    while (Slotx < MaxSlotx) {
        j = Slotx & (ACK_VECTOR_SIZE-1);
        if (ReadAVBitBySlot(Slotx, OutLogPartner) == 0) {
            Str[j] = '.';
        } else {
            Str[j] = '1';
        }

        if (COx == OutLogPartner->COTx) {
            Str2[j] = 'T';
        } else
        if (COx == OutLogPartner->COLx) {
            Str2[j] = 'L';
        } else {
            Str2[j] = '_';
        }

        if (COx == RetireCOx) {
            Str3[j] = '^';
        } else {
            Str3[j] = ' ';
        }

        COx += 1;
        Slotx += 1;
    }
    Str[ACK_VECTOR_SIZE] = '\0';
    Str2[ACK_VECTOR_SIZE] = '\0';
    Str3[ACK_VECTOR_SIZE] = '\0';

    //
    // Compress out blocks of 8
    //
    Fill = 0;
    Scan = 0;
    while (Scan < ACK_VECTOR_SIZE) {
        for (j=Scan; j < Scan+8; j++) {
            if ((Str[j] != '.') || (Str2[j] != '_')  || (Str3[j] != ' ')) {
                break;
            }
        }

        if (j == Scan+8) {
            // Compress out this block
            Str[Fill] = Str2[Fill] = Str3[Fill] = '-';
            Fill += 1;
        } else {
            // Copy this block to fill point of strings.
            for (j=Scan; j < Scan+8; j++) {
                Str[Fill] = Str[j];
                Str2[Fill] = Str2[j];
                Str3[Fill] = Str3[j];
                Fill += 1;
            }
        }
        Scan += 8;
    }

    Str[Fill] = Str2[Fill] = Str3[Fill] = '\0';

    *OutStr1 = Str;
    *OutStr2 = Str2;
    *OutStr3 = Str3;

    return;
}


VOID
FrsPrintTypeOutLogPartner(
    IN ULONG            Severity,   OPTIONAL
    IN PNTFRSAPI_INFO   Info,       OPTIONAL
    IN DWORD            Tabs,       OPTIONAL
    IN POUT_LOG_PARTNER Olp,
    IN ULONG            RetireCox,
    IN PCHAR            Description,
    IN PCHAR            Debsub,     OPTIONAL
    IN ULONG            uLineNo     OPTIONAL
    )
/*++
Routine Description:
    Print an outlog partner

Arguments:
    Severity    - for DPRINTs
    Info        - RPC output buffer
    Tabs        - prettyprint
    Olp         - Out log partner struct
    RetireCox   - change order index for ack vector
    Description - description of caller
    Debsub      - for DPRINTs
    uLineNo     - for DPRINTs

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsPrintTypeOutLogPartner:"
    PCHAR   OutStr1, OutStr2, OutStr3;
    CHAR    FBuf[120];
    CHAR    TimeStr[TIME_STRING_LENGTH];
    WCHAR   TabW[MAX_TAB_WCHARS + 1];

    InfoTabs(Tabs, TabW);

    if (!Info) {
        DebLock();
    }

    ITPRINT2("%wsOutLogPartner   : %s\n", TabW, Description);

    if (Olp->Cxtion && Olp->Cxtion->Name) {
        ITPRINT2( "%wsCxtion          : %ws\n",
                 TabW,
                 Olp->Cxtion->Name->Name);
        if (Olp->Cxtion->Partner && Olp->Cxtion->Partner->Name) {
            ITPRINT2( "%wsPartner         : %ws\n",
                     TabW,
                     Olp->Cxtion->Partner->Name);
        }
    }


    FrsFlagsToStr(Olp->Flags, OlpFlagNameTable, sizeof(FBuf), FBuf);
    ITPRINT3("%wsFlags           : %08x Flags [%s]\n", TabW, Olp->Flags, FBuf);

    ITPRINT2("%wsState           : %s\n",  TabW, OLPartnerStateNames[Olp->State]);
    ITPRINT2("%wsCoTx            : %8d\n", TabW, Olp->COTx);
    ITPRINT2("%wsCoLx            : %8d\n", TabW, Olp->COLx);
    ITPRINT2("%wsCOLxRestart     : %8d\n", TabW, Olp->COLxRestart);
    ITPRINT2("%wsCOLxVVJoinDone  : %8d\n", TabW, Olp->COLxVVJoinDone);
    ITPRINT2("%wsCoTxSave        : %8d\n", TabW, Olp->COTxNormalModeSave);
    ITPRINT2("%wsCoTslot         : %8d\n", TabW, Olp->COTslot);
    ITPRINT2("%wsOutstandingCos  : %8d\n", TabW, Olp->OutstandingCos);
    ITPRINT2("%wsOutstandingQuota: %8d\n", TabW, Olp->OutstandingQuota);

    FileTimeToString((PFILETIME) &Olp->AckVersion, TimeStr);
    ITPRINT2("%wsAckVersion      : %s\n" , TabW, TimeStr);

    if (RetireCox != -1) {
        ITPRINT2("%wsRetireCox       : %8d\n", TabW, RetireCox);
    }

    FrsPrintTypeOutLogAVToStr(Olp, RetireCox, &OutStr1, &OutStr2, &OutStr3);

    //
    // keep output together.
    //
    ITPRINT2("%wsAck: |%s|\n", TabW, OutStr1);
    ITPRINT2("%wsAck: |%s|\n", TabW, OutStr2);
    ITPRINT2("%wsAck: |%s|\n", TabW, OutStr3);
    FrsFree(OutStr1);
    if (!Info) {
        DebUnLock();
    }
}


VOID
FrsPrintTypeCxtion(
    IN ULONG            Severity,   OPTIONAL
    IN PNTFRSAPI_INFO   Info,       OPTIONAL
    IN DWORD            Tabs,       OPTIONAL
    IN PCXTION          Cxtion,
    IN PCHAR            Debsub,     OPTIONAL
    IN ULONG            uLineNo     OPTIONAL
    )
/*++
Routine Description:
    Print a cxtion

Arguments:
    Severity    - for DPRINTs
    Info        - RPC output buffer
    Tabs        - prettyprint
    Cxtion
    Debsub      - for DPRINTs
    uLineNo     - for DPRINTs

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsPrintTypeCxtion:"
    WCHAR   TabW[MAX_TAB_WCHARS + 1];
    CHAR    Guid[GUID_CHAR_LEN + 1];
    CHAR    TimeStr[TIME_STRING_LENGTH];
    CHAR    FlagBuffer[120];

    if (!Cxtion) {
        return;
    }

    //
    // Prettyprint indentation
    //
    InfoTabs(Tabs, TabW);

    if (!Info) {
        DebLock();
    }
    ITPRINT0("\n");
    ITPRINTGNAME(Cxtion->Name,
                "%ws   Cxtion: %ws (%s)\n");
    ITPRINTGNAME(Cxtion->Partner,
                 "%ws      Partner      : %ws (%s)\n");
    ITPRINT2("%ws      PartDnsName  : %ws\n", TabW, Cxtion->PartnerDnsName);
    ITPRINT2("%ws      PartSrvName  : %ws\n", TabW, Cxtion->PartSrvName);
    ITPRINT2("%ws      PartPrincName: %ws\n", TabW, Cxtion->PartnerPrincName);
    ITPRINT2("%ws      PartSid      : %ws\n", TabW, Cxtion->PartnerSid);
    ITPRINTGUID(&Cxtion->ReplicaVersionGuid, "%ws      OrigGuid     : %s\n");
    ITPRINT2("%ws      State        : %d\n", TabW, Cxtion->State);

    FrsFlagsToStr(Cxtion->Flags, CxtionFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
    ITPRINT3("%ws      Flags        : %08x Flags [%s]\n", TabW, Cxtion->Flags, FlagBuffer);

    ITPRINT2("%ws      Inbound      : %s\n", TabW, (Cxtion->Inbound) ? "TRUE" : "FALSE");
    ITPRINT2("%ws      JrnlCxtion   : %s\n", TabW, (Cxtion->JrnlCxtion) ? "TRUE" : "FALSE");
    ITPRINT2("%ws      Options      : 0x%08x\n", TabW, Cxtion->Options);
    ITPRINT2("%ws      PartnerAuth  : %d\n", TabW, Cxtion->PartnerAuthLevel);
    ITPRINT2("%ws      TermCoSn     : %d\n", TabW, Cxtion->TerminationCoSeqNum);
    ITPRINT2("%ws      JoinCmd      : 0x%08x\n", TabW, Cxtion->JoinCmd);
    ITPRINT2("%ws      CoCount      : %d\n", TabW, Cxtion->ChangeOrderCount);
    ITPRINT2("%ws      CommQueue    : %d\n", TabW, Cxtion->CommQueueIndex);
    ITPRINT2("%ws      CoPQ         : %08x\n", TabW, Cxtion->CoProcessQueue);
    ITPRINT2("%ws      UnjoinTrigger: %d\n", TabW, Cxtion->UnjoinTrigger);
    ITPRINT2("%ws      UnjoinReset  : %d\n", TabW, Cxtion->UnjoinReset);
    ITPRINT2("%ws      Comm Packets : %d\n", TabW, Cxtion->CommPkts);
    ITPRINT2("%ws      PartnerMajor : %d\n", TabW, Cxtion->PartnerMajor);
    ITPRINT2("%ws      PartnerMinor : %d\n", TabW, Cxtion->PartnerMinor);
    //
    // Don't print the join guid in the logs; they may be readable
    // by anyone. An Info-RPC is secure so return the join guid in
    // case it is needed for debugging.
    //
    if (Info) {
        ITPRINTGUID(&Cxtion->JoinGuid, "%ws      JoinGuid     : %s\n");
        FileTimeToString((PFILETIME) &Cxtion->LastJoinTime, TimeStr);
        ITPRINT2("%ws      LastJoinTime : %s\n" , TabW, TimeStr);
    }

    if (Cxtion->Schedule) {
        ITPRINT1("%ws      Schedule\n", TabW);
        FrsPrintTypeSchedule(Severity, Info, Tabs + 3, Cxtion->Schedule, Debsub, uLineNo);
    }

    if (Cxtion->VVector) {
        ITPRINT1("%ws      Version Vector\n", TabW);
    }

    if (!Info) {
        DebUnLock();
    }

    if (Cxtion->VVector) {
        FrsPrintTypeVv(Severity, Info, Tabs + 3, Cxtion->VVector, Debsub, uLineNo);
    }
    if (Cxtion->OLCtx) {
        if (!Info) {
            DebLock();
        }
        ITPRINT1("%ws      OutLog Partner\n", TabW);
        if (!Info) {
            DebUnLock();
        }
        FrsPrintTypeOutLogPartner(Severity, Info, Tabs + 3, Cxtion->OLCtx,
                                  -1, "FrsPrintType", Debsub, uLineNo);
    }
}


VOID
FrsPrintTypeCxtions(
    IN ULONG            Severity,   OPTIONAL
    IN PNTFRSAPI_INFO   Info,       OPTIONAL
    IN DWORD            Tabs,       OPTIONAL
    IN PGEN_TABLE       Cxtions,
    IN PCHAR            Debsub,     OPTIONAL
    IN ULONG            uLineNo     OPTIONAL
    )
/*++
Routine Description:
    Print a table of cxtions

Arguments:
    Severity    - for DPRINTs
    Info        - RPC output buffer
    Tabs        - prettyprint
    Cxtions     - Cxtion table
    Debsub      - for DPRINTs
    uLineNo     - for DPRINTs

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsPrintTypeCxtions:"
    PVOID   Key;
    PCXTION Cxtion;
    WCHAR   TabW[MAX_TAB_WCHARS + 1];
    CHAR    Guid[GUID_CHAR_LEN + 1];

    if (!Cxtions) {
        return;
    }

    //
    // Prettyprint indentation
    //
    InfoTabs(Tabs, TabW);

    Key = NULL;
    while (Cxtion = GTabNextDatum(Cxtions, &Key)) {
        FrsPrintTypeCxtion(Severity, Info, Tabs, Cxtion, Debsub, uLineNo);
    }
}


VOID
FrsPrintTypeReplica(
    IN ULONG            Severity,   OPTIONAL
    IN PNTFRSAPI_INFO   Info,       OPTIONAL
    IN DWORD            Tabs,       OPTIONAL
    IN PREPLICA         Replica,
    IN PCHAR            Debsub,     OPTIONAL
    IN ULONG            uLineNo     OPTIONAL
    )
/*++

Routine Description:

    Print a replica and its cxtions.

Arguments:

    Severity -- Severity level for print.  (See debug.c, debug.h)

    Info - Text buffer

    Tabs - Prettyprint prepense

    Replica - Replica struct

    Debsub -- Name of calling subroutine.

    uLineno -- Line number of caller

MACRO:  FRS_PRINT_TYPE

Return Value:

    none.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsPrintTypeReplica:"
    CHAR  Guid[GUID_CHAR_LEN + 1];
    WCHAR TabW[MAX_TAB_WCHARS + 1];
    CHAR  FlagBuffer[120];

    if (!Replica) {
        return;
    }

    InfoTabs(Tabs, TabW);

    if (!Info) {
        DebLock();
    }
    ITPRINTGNAME(Replica->SetName,            "%ws   Replica: %ws (%s)\n");
    ITPRINTGNAME(Replica->MemberName,         "%ws      Member      : %ws (%s)\n");
    ITPRINTGNAME(Replica->ReplicaName,        "%ws      Name        : %ws (%s)\n");

    ITPRINTGUID(Replica->ReplicaRootGuid,     "%ws      RootGuid    : %s\n");
    ITPRINTGUID(&Replica->ReplicaVersionGuid, "%ws      OrigGuid    : %s\n");

    ITPRINT2("%ws      Reference     : %d\n", TabW, Replica->ReferenceCount);

    FrsFlagsToStr(Replica->CnfFlags, ConfigFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
    ITPRINT3("%ws      CnfFlags      : %08x Flags [%s]\n", TabW,
             Replica->CnfFlags, FlagBuffer);

    ITPRINT2("%ws      SetType       : %d\n", TabW, Replica->ReplicaSetType);
    ITPRINT2("%ws      Consistent    : %d\n", TabW, Replica->Consistent);
    ITPRINT2("%ws      IsOpen        : %d\n", TabW, Replica->IsOpen);
    ITPRINT2("%ws      IsJournaling  : %d\n", TabW, Replica->IsJournaling);
    ITPRINT2("%ws      IsAccepting   : %d\n", TabW, Replica->IsAccepting);
    ITPRINT2("%ws      IsSeeding     : %d\n", TabW, Replica->IsSeeding);
    ITPRINT2("%ws      NeedsUpdate   : %d\n", TabW, Replica->NeedsUpdate);

    ITPRINT3("%ws      ServiceState  : %d  (%s)\n", TabW,
             Replica->ServiceState, RSS_NAME(Replica->ServiceState));

    ITPRINT2("%ws      FStatus       : %s\n", TabW, ErrLabelFrs(Replica->FStatus));
    ITPRINT2("%ws      Number        : %d\n", TabW, Replica->ReplicaNumber);
    ITPRINT2("%ws      Root          : %ws\n", TabW, Replica->Root);
    ITPRINT2("%ws      Stage         : %ws\n", TabW, Replica->Stage);
    ITPRINT2("%ws      Volume        : %ws\n", TabW, Replica->Volume);
    ITPRINT2("%ws      FileFilter    : %ws\n", TabW, Replica->FileFilterList);
    ITPRINT2("%ws      DirFilter     : %ws\n", TabW, Replica->DirFilterList);
    ITPRINT2("%ws      Expires       : %08x %08x\n", TabW,
            PRINTQUAD(Replica->MembershipExpires));
    ITPRINT2("%ws      InLogRetry    : %d\n", TabW, Replica->InLogRetryCount);
    ITPRINT2("%ws      InLogSeq      : %d\n", TabW, Replica->InLogSeqNumber);
    ITPRINT2("%ws      InLogSeq      : %d\n", TabW, Replica->InLogSeqNumber);
    ITPRINT2("%ws      ApiState      : %d\n", TabW, Replica->NtFrsApi_ServiceState);
    ITPRINT2("%ws      ApiStatus     : %d\n", TabW, Replica->NtFrsApi_ServiceWStatus);
    ITPRINT2("%ws      ApiHack       : %d\n", TabW, Replica->NtFrsApi_HackCount);
    ITPRINT2("%ws      OutLogSeq     : %d\n", TabW, Replica->OutLogSeqNumber);
    ITPRINT2("%ws      OutLogJLx     : %d\n", TabW, Replica->OutLogJLx);
    ITPRINT2("%ws      OutLogJTx     : %d\n", TabW, Replica->OutLogJTx);
    ITPRINT2("%ws      OutLogMax     : %d\n", TabW, Replica->OutLogCOMax);
    ITPRINT2("%ws      OutLogState   : %d\n", TabW, Replica->OutLogWorkState);
    ITPRINT2("%ws      OutLogVV's    : %d\n", TabW, Replica->OutLogCountVVJoins);
    ITPRINT2("%ws      OutLogClean   : %d\n", TabW, Replica->OutLogDoCleanup);

    ITPRINT2("%ws      PreinstallFID : %08x %08x\n", TabW,
            PRINTQUAD(Replica->PreInstallFid));

    ITPRINT2("%ws      InLogCommit   : %08x %08x\n", TabW,
            PRINTQUAD(Replica->InlogCommitUsn));

    ITPRINT2("%ws      JrnlStart     : %08x %08x\n", TabW,
            PRINTQUAD(Replica->JrnlRecoveryStart));

    ITPRINT2("%ws      JrnlEnd       : %08x %08x\n", TabW,
            PRINTQUAD(Replica->JrnlRecoveryEnd));

    ITPRINT2("%ws      LastUsn       : %08x %08x\n", TabW,
            PRINTQUAD(Replica->LastUsnRecordProcessed));

    if (Replica->Schedule) {
        ITPRINT1("%ws      Schedule\n", TabW);
        FrsPrintTypeSchedule(Severity, Info, Tabs + 3,  Replica->Schedule, Debsub, uLineNo);
    }

    if (Replica->VVector) {
        ITPRINT1("%ws      Version Vector\n", TabW);
    }

    if (!Info) {
        DebUnLock();
    }

    FrsPrintTypeVv(Severity, Info, Tabs + 3, Replica->VVector, Debsub, uLineNo);

    FrsPrintTypeCxtions(Severity, Info, Tabs + 1, Replica->Cxtions, Debsub, uLineNo);
}


VOID
FrsPrintType(
    IN ULONG Severity,
    IN PVOID Node,
    IN PCHAR Debsub,
    IN ULONG uLineNo
    )
/*++

Routine Description:

    This routine prints out the contents of a given node,
    performing any node specific interpretation.

Arguments:

    Severity -- Severity level for print.  (See debug.c, debug.h)

    Node - The address of the node to print.

    Debsub -- Name of calling subroutine.

    uLineno -- Line number of caller

MACRO:  FRS_PRINT_TYPE

Return Value:

    none.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsPrintType:"

    ULONG                 NodeSize;
    ULONG                 NodeType;
    ULONG                 Marker;
    PREPLICA              Replica;
    PREPLICA_THREAD_CTX   RtCtx;
    PTABLE_CTX            TableCtx;
    PTHREAD_CTX           ThreadCtx;
    ULONG                 i;
    PVOLUME_MONITOR_ENTRY pVme;
    PFILTER_TABLE_ENTRY   FilterEntry;
    PQHASH_TABLE          QhashTable;
    PLIST_ENTRY           Entry;
    PCXTION               Cxtion;
    SYSTEMTIME            ST;
    PWILDCARD_FILTER_ENTRY WildcardEntry;
    POUT_LOG_PARTNER      Olp;
    PCONFIG_NODE          ConfigNode;
    PULONG                pULong;


    PCHANGE_ORDER_ENTRY   CoEntry;
    PCHANGE_ORDER_COMMAND CoCmd;
    CHAR                  GuidStr[GUID_CHAR_LEN];
    CHAR                  TimeStr[TIME_STRING_LENGTH];
    CHAR                  FlagBuffer[160];


    if (!DoDebug(Severity, Debsub)) {
        return;
    }
    //
    // Get debug lock so our output stays in one piece.
    //
    DebLock();

    if (Node != NULL) {
        NodeType = (ULONG) (((PFRS_NODE_HEADER) Node)->Type);
        NodeSize = (ULONG) (((PFRS_NODE_HEADER) Node)->Size);
        FRS_DEB_PRINT("Display for Node: ...%s...   ===   ===   ===   ===\n",
                       NodeTypeNames[NodeType]);
    } else {
        FRS_DEB_PRINT("Display for Node: ...<null>...   ===   ===   ===   ===\n\n",
                       NULL);

        DebUnLock();
        return;
    }


    switch (NodeType) {
    //
    // Print a Thread Context struct
    //
    case THREAD_CONTEXT_TYPE:
        if (NodeSize != sizeof(THREAD_CTX)) {
            FRS_DEB_PRINT("FrsPrintType - Bad node size %d for THREAD_CONTEXT\n",
                           NodeSize);
            break;
        }
        FRS_DEB_PRINT("Address %08x\n", Node);

        ThreadCtx = (PTHREAD_CTX) Node;

        break;

    //
    // Print a Replica struct
    //
    case REPLICA_TYPE:
        if (NodeSize != sizeof(REPLICA)) {
            FRS_DEB_PRINT("FrsPrintType - Bad node size %d for REPLICA\n", NodeSize);
            break;
        }
        DebUnLock();
        FrsPrintTypeReplica(Severity, NULL, 0, (PREPLICA) Node, Debsub, uLineNo);
        DebLock();
        break;

    //
    // Print a Replica Thread Context struct
    //
    case REPLICA_THREAD_TYPE:
        if (NodeSize != sizeof(REPLICA_THREAD_CTX)) {
            FRS_DEB_PRINT("FrsPrintType - Bad node size %d for REPLICA_THREAD_CTX\n",
                           NodeSize);
            break;
        }
        FRS_DEB_PRINT("Address %08x\n", Node);

        RtCtx = (PREPLICA_THREAD_CTX) Node;

        //
        // Get the base of the array of TableCtx structs from the replica thread
        // context struct.
        //
        TableCtx = RtCtx->RtCtxTables;

        //
        // Release the memory for each table context struct.
        //
        //for (i=0; i<TABLE_TYPE_MAX; ++i, ++TableCtx) {
        //}

        break;

    //
    // Print a topology node
    //
    case CONFIG_NODE_TYPE:
        if (NodeSize != sizeof(CONFIG_NODE)) {
            FRS_DEB_PRINT("FrsPrintType - Bad node size %d for CONFIG_NODE\n",
                          NodeSize);
            break;
        }
        ConfigNode = Node;
        FRS_DEB_PRINT("CONFIG NODE Address %08x\n", ConfigNode);

        FrsPrintGNameForNode(Severity, ConfigNode->Name, L"\t", L"Node",
                             Debsub, uLineNo);

        FrsPrintGNameForNode(Severity, ConfigNode->PartnerName, L"\t", L"Partner",
                             Debsub, uLineNo);

        FRS_DEB_PRINT("\tDsObjectType    %ws\n", DsConfigTypeName[ConfigNode->DsObjectType]);
        FRS_DEB_PRINT("\tConsistent      %s\n", (ConfigNode->Consistent) ? "TRUE" : "FALSE");
        FRS_DEB_PRINT("\tInbound         %s\n", (ConfigNode->Inbound) ? "TRUE" : "FALSE");
        FRS_DEB_PRINT("\tThisComputer    %s\n", (ConfigNode->ThisComputer) ? "TRUE" : "FALSE");
        FRS_DEB_PRINT("\tUsnChanged      %ws\n", ConfigNode->UsnChanged);
        FRS_DEB_PRINT("\tDn              %ws\n", ConfigNode->Dn);
        FRS_DEB_PRINT("\tPrincName       %ws\n", ConfigNode->PrincName);
        FRS_DEB_PRINT("\tDnsName         %ws\n", ConfigNode->DnsName);
        FRS_DEB_PRINT("\tPartnerDnsName  %ws\n", ConfigNode->PartnerDnsName);
        FRS_DEB_PRINT("\tSid             %ws\n", ConfigNode->Sid);
        FRS_DEB_PRINT("\tPartnerSid      %ws\n", ConfigNode->PartnerSid);
        FRS_DEB_PRINT("\tPartnerDn       %ws\n", ConfigNode->PartnerDn);
        FRS_DEB_PRINT("\tPartnerCoDn     %ws\n", ConfigNode->PartnerCoDn);
        FRS_DEB_PRINT("\tSettingsDn      %ws\n", ConfigNode->SettingsDn);
        FRS_DEB_PRINT("\tComputerDn      %ws\n", ConfigNode->ComputerDn);
        FRS_DEB_PRINT("\tMemberDn        %ws\n", ConfigNode->MemberDn);
        FRS_DEB_PRINT("\tSetType         %ws\n", ConfigNode->SetType);
        FRS_DEB_PRINT("\tRoot            %ws\n", ConfigNode->Root);
        FRS_DEB_PRINT("\tStage           %ws\n", ConfigNode->Stage);
        FRS_DEB_PRINT("\tWorking         %ws\n", ConfigNode->Working);
        FRS_DEB_PRINT("\tFileFilterList  %ws\n", ConfigNode->FileFilterList);
        FRS_DEB_PRINT("\tDirFilterList   %ws\n", ConfigNode->DirFilterList);
        FRS_DEB_PRINT("\tSchedule        %08x\n",ConfigNode->Schedule);
        FRS_DEB_PRINT("\tScheduleLength  %d\n",  ConfigNode->ScheduleLength);
        FRS_DEB_PRINT("\tUsnChanged      %ws\n", ConfigNode->UsnChanged);
        FRS_DEB_PRINT("\tSameSite        %s\n", (ConfigNode->SameSite) ? "TRUE" : "FALSE");
        FRS_DEB_PRINT("\tEnabledCxtion   %ws\n", ConfigNode->EnabledCxtion);
        FRS_DEB_PRINT("\tVerifiedOverlap %s\n", (ConfigNode->VerifiedOverlap) ? "TRUE" : "FALSE");
        break;

    //
    // Print a connection
    //
    case CXTION_TYPE:
        if (NodeSize != sizeof(CXTION)) {
            FRS_DEB_PRINT("FrsPrintType - Bad node size %d for CXTION\n",
                          NodeSize);
            break;
        }
        DebUnLock();
        FrsPrintTypeCxtion(Severity, NULL, 0, (PCXTION)Node, Debsub, uLineNo);
        DebLock();
        break;

    //
    // Print a guid/rpc handle
    //
    case GHANDLE_TYPE:
        if (NodeSize != sizeof(GHANDLE)) {
            FRS_DEB_PRINT("FrsPrintType - Bad node size %d for GHANDLE\n",
                          NodeSize);
            break;
        }

        GuidToStr(&(((PGHANDLE)Node)->Guid), GuidStr);
        FRS_DEB_PRINT2("Address %08x, Cxtion Guid : %s\n", Node, GuidStr);

        break;

    //
    // Print a generic table
    //
    case GEN_TABLE_TYPE:
        if (NodeSize != sizeof(GEN_TABLE)) {
            FRS_DEB_PRINT("FrsPrintType - Bad node size %d for GEN_TABLE\n",
                          NodeSize);
            break;
        }
        FRS_DEB_PRINT("Address %08x\n", Node);

        break;

    //
    // Print a generic thread context
    //
    case THREAD_TYPE:
        if (NodeSize != sizeof(FRS_THREAD)) {
            FRS_DEB_PRINT("FrsPrintType - Bad node size %d for FRS_THREAD\n",
                           NodeSize);
            break;
        }
        FRS_DEB_PRINT("Address %08x\n", Node);

        break;

    //
    // Print a journal read buffer.
    //
    case JBUFFER_TYPE:
        if (NodeSize != SizeOfJournalBuffer) {
            FRS_DEB_PRINT("FrsPrintType - Bad node size %d for JBUFFER\n",
                          NodeSize);
            break;
        }
        FRS_DEB_PRINT("Address %08x\n", Node);

        break;

    //
    // Print a journal volume monitor entry.
    //
    case VOLUME_MONITOR_ENTRY_TYPE:
        if (NodeSize != sizeof(VOLUME_MONITOR_ENTRY)) {
            FRS_DEB_PRINT("FrsPrintType - Bad node size %d for VOLUME_MONITOR_ENTRY\n",
                          NodeSize);
            break;
        }
        FRS_DEB_PRINT("Address %08x\n", Node);

        pVme = (PVOLUME_MONITOR_ENTRY) Node;




        break;


    //
    // Print a command packet.
    //
    case COMMAND_PACKET_TYPE:
        if (NodeSize != sizeof(COMMAND_PACKET)) {
            FRS_DEB_PRINT("FrsPrintType - Bad node size %d for COMMAND_PACKET\n",
                          NodeSize);
            break;
        }
        FRS_DEB_PRINT("Address %08x\n",  Node);
        break;

    //
    // Print a generic hash table struct.
    //
    case GENERIC_HASH_TABLE_TYPE:
        if (NodeSize != sizeof(GENERIC_HASH_TABLE)) {
            FRS_DEB_PRINT("FrsPrintType - Bad node size %d for GENERIC_HASH_TABLE\n",
                          NodeSize);
            break;
        }
        FRS_DEB_PRINT("Address %08x\n", Node);
        break;


    //
    // Print a Change Order Entry struct.
    //
    case CHANGE_ORDER_ENTRY_TYPE:
        if (NodeSize != sizeof(CHANGE_ORDER_ENTRY)) {
            FRS_DEB_PRINT("FrsPrintType - Bad node size %d for CHANGE_ORDER_ENTRY\n",
                          NodeSize);
            break;
        }

        CoEntry = (PCHANGE_ORDER_ENTRY)Node;
        CoCmd = &CoEntry->Cmd;

        GuidToStr(&CoCmd->ChangeOrderGuid, GuidStr);
        FRS_DEB_PRINT3("Address %08x  ***%s CO*** - %s\n",
                       CoEntry,
                       (CO_FLAG_ON(CoEntry, CO_FLAG_LOCALCO)) ? "LOCAL" : "REMOTE",
                       GuidStr);

        FRS_DEB_PRINT3("Node Addr: %08x,  HashValue: %08x  RC: %d\n",
                       CoEntry,
                       CoEntry->HashEntryHeader.HashValue,
                       CoEntry->HashEntryHeader.ReferenceCount);

        FRS_DEB_PRINT2("List Entry - %08x,  %08x\n",
                       CoEntry->HashEntryHeader.ListEntry.Flink,
                       CoEntry->HashEntryHeader.ListEntry.Blink);


        FRS_DEB_PRINT2("FileRef: %08lx %08lx, ParentRef: %08lx %08lx\n",
                       PRINTQUAD(CoEntry->FileReferenceNumber),
                       PRINTQUAD(CoEntry->ParentFileReferenceNumber));

        FRS_DEB_PRINT("\n", NULL);
        FRS_DEB_PRINT("STATE: %s\n", PRINT_CO_STATE(CoEntry));

        FrsFlagsToStr(CoEntry->EntryFlags, CoeFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
        FRS_DEB_PRINT2("EntryFlags: %08x, Flags [%s]\n", CoEntry->EntryFlags, FlagBuffer);

        FrsFlagsToStr(CoEntry->IssueCleanup, IscuFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
        FRS_DEB_PRINT2("ISCU Flags: %08x, Flags [%s]\n", CoEntry->IssueCleanup, FlagBuffer);

        FRS_DEB_PRINT("\n", NULL);

        GuidToStr(&CoCmd->OriginatorGuid, GuidStr);
        FRS_DEB_PRINT("OrigGuid  : %s\n", GuidStr);

        GuidToStr(&CoCmd->FileGuid, GuidStr);
        FRS_DEB_PRINT("FileGuid  : %s\n", GuidStr);

        GuidToStr(&CoCmd->OldParentGuid, GuidStr);
        FRS_DEB_PRINT("OParGuid  : %s\n",GuidStr);

        GuidToStr(&CoCmd->NewParentGuid, GuidStr);
        FRS_DEB_PRINT("NParGuid  : %s\n", GuidStr);

        GuidToStr(&CoCmd->CxtionGuid, GuidStr);
        FRS_DEB_PRINT2("CxtionGuid: %s  (%08x)\n", GuidStr, CoEntry->Cxtion);

        FileTimeToString((PFILETIME) &CoCmd->AckVersion, TimeStr);
        FRS_DEB_PRINT("AckVersion: %s\n", TimeStr);

        FRS_DEB_PRINT("\n", NULL);

        FRS_DEB_PRINT2("FileName: %ws, Length: %d\n", CoEntry->UFileName.Buffer,
                       CoCmd->FileNameLength);

        FrsFlagsToStr(CoCmd->ContentCmd, UsnReasonNameTable, sizeof(FlagBuffer), FlagBuffer);
        FRS_DEB_PRINT2("ContentCmd: %08x, Flags [%s]\n", CoCmd->ContentCmd, FlagBuffer);

        FRS_DEB_PRINT("\n", NULL);

        FrsFlagsToStr(CoCmd->Flags, CoFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
        FRS_DEB_PRINT2("CoFlags: %08x, Flags [%s]\n", CoCmd->Flags, FlagBuffer);

        FrsFlagsToStr(CoCmd->IFlags, CoIFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
        DebPrintNoLock(Severity, TRUE,
                       "IFlags: %08x, Flags [%s]  TimeToRun: %7d,  EntryCreateTime: %7d\n",
                       Debsub, uLineNo,
                       CoCmd->IFlags, FlagBuffer,
                       CoEntry->TimeToRun,
                       CoEntry->EntryCreateTime);

        DebPrintNoLock(Severity, TRUE,
                       "LocationCmd: %s (%d), CO STATE:  %s   File/Dir: %d\n",
                       Debsub, uLineNo,
                       CoLocationNames[GET_CO_LOCATION_CMD(CoEntry->Cmd, Command)],
                       GET_CO_LOCATION_CMD(CoEntry->Cmd, Command),
                       PRINT_CO_STATE(CoEntry),
                       GET_CO_LOCATION_CMD(CoEntry->Cmd, DirOrFile));

        FRS_DEB_PRINT("\n", NULL);
        FRS_DEB_PRINT2("OriginalParentFid: %08lx %08lx, NewParentFid: %08lx %08lx\n",
                       PRINTQUAD(CoEntry->OriginalParentFid),
                       PRINTQUAD(CoEntry->NewParentFid));

        DebPrintNoLock(Severity, TRUE,
                       "OriginalReplica: %ws (%d), NewReplica: %ws (%d)\n",
                       Debsub, uLineNo,
                       CoEntry->OriginalReplica->ReplicaName->Name,
                       CoCmd->OriginalReplicaNum,
                       CoEntry->NewReplica->ReplicaName->Name,
                       CoCmd->NewReplicaNum);

        if (CoCmd->Extension != NULL) {
            pULong = (PULONG) CoCmd->Extension;
            DebPrintNoLock(Severity, TRUE,
                       "CO Extension: (%08x) %08x %08x %08x %08x %08x %08x %08x %08x\n",
                       Debsub, uLineNo, pULong,
                       *(pULong+0), *(pULong+1), *(pULong+2), *(pULong+3),
                       *(pULong+4), *(pULong+5), *(pULong+6), *(pULong+7));
        } else {
            FRS_DEB_PRINT("CO Extension: Null\n", NULL);
        }

        FRS_DEB_PRINT("\n", NULL);
        FRS_DEB_PRINT3("File Attributes: %08x, SeqNum: %08x, FileSize: %08x %08x\n",
                       CoCmd->FileAttributes,
                       CoCmd->SequenceNumber,
                       PRINTQUAD(CoCmd->FileSize));

        FRS_DEB_PRINT("FrsVsn: %08x %08x\n", PRINTQUAD(CoCmd->FrsVsn));

        FRS_DEB_PRINT3("Usn:    %08x %08x   CoFileUsn: %08x %08x   JrnlFirstUsn: %08x %08x\n",
                       PRINTQUAD(CoCmd->JrnlUsn),
                       PRINTQUAD(CoCmd->FileUsn),
                       PRINTQUAD(CoCmd->JrnlFirstUsn));


        FRS_DEB_PRINT("Version: %08x   ", CoCmd->FileVersionNumber);

        FileTimeToString((PFILETIME) &CoCmd->EventTime.QuadPart, TimeStr);
        DebPrintNoLock(Severity, FALSE, "EventTime: %s\n", Debsub, uLineNo, TimeStr);

        break;

    //
    // Print a Filter Table Entry struct.
    //
    case FILTER_TABLE_ENTRY_TYPE:
        if (NodeSize != sizeof(FILTER_TABLE_ENTRY)) {
            FRS_DEB_PRINT("FrsPrintType - Bad node size %d for FILTER_TABLE_ENTRY\n",
                          NodeSize);
            break;
        }
        FRS_DEB_PRINT("Address %08x\n", Node);

        FilterEntry = (PFILTER_TABLE_ENTRY)Node;

        break;

    //
    // Print a QHASH table struct.
    //
    case QHASH_TABLE_TYPE:

        QhashTable = (PQHASH_TABLE)Node;
        if (NodeSize != QhashTable->BaseAllocSize) {
            FRS_DEB_PRINT("FrsPrintType - Bad node size %d for QHASH_TABLE\n",
                          NodeSize);
            break;
        }

        FRS_DEB_PRINT("Table Address      : %08x\n", QhashTable);
        FRS_DEB_PRINT("BaseAllocSize      : %8d\n",  QhashTable->BaseAllocSize);
        FRS_DEB_PRINT("ExtensionAllocSize : %8d\n",  QhashTable->ExtensionAllocSize);
        FRS_DEB_PRINT("ExtensionListHead  : %08x\n", QhashTable->ExtensionListHead);
        FRS_DEB_PRINT("FreeList           : %08x\n", QhashTable->FreeList);
        FRS_DEB_PRINT("Lock               : %08x\n", QhashTable->Lock);
        FRS_DEB_PRINT("HeapHandle         : %08x\n", QhashTable->HeapHandle);
        FRS_DEB_PRINT("HashCalc           : %08x\n", QhashTable->HashCalc);
        FRS_DEB_PRINT("NumberEntries      : %8d\n",  QhashTable->NumberEntries);
        FRS_DEB_PRINT("HashRowBase        : %08x\n", QhashTable->HashRowBase);

        break;

    //
    // Print an Output Log Partner struct.
    //
    case OUT_LOG_PARTNER_TYPE:
        if (NodeSize != sizeof(OUT_LOG_PARTNER)) {
            FRS_DEB_PRINT("FrsPrintType - Bad node size %d for OUT_LOG_PARTNER\n",
                          NodeSize);
            break;
        }
        DebUnLock();
        FrsPrintTypeOutLogPartner(Severity, NULL, 0, (POUT_LOG_PARTNER)Node,
                                  -1, "FrsPrintType", Debsub, uLineNo);
        DebLock();
        break;


    //
    // Print a Wildcard file filter Entry struct.
    //
    case WILDCARD_FILTER_ENTRY_TYPE:
        if (NodeSize != sizeof(WILDCARD_FILTER_ENTRY)) {
            FRS_DEB_PRINT("FrsPrintType - Bad node size %d for WILDCARD_FILTER_ENTRY\n",
                           NodeSize);
            break;
        }
        FRS_DEB_PRINT( "Address %08x\n", Node);

        WildcardEntry = (PWILDCARD_FILTER_ENTRY)Node;


        DebPrintNoLock(Severity, TRUE,
                       "Flags: %08x,  Wildcard FileName: %ws, Length: %d\n",
                       Debsub, uLineNo,
                       WildcardEntry->Flags,
                       WildcardEntry->UFileName.Buffer,
                       (ULONG)WildcardEntry->UFileName.Length);
        break;


    //
    // Invalid Node Type
    //
    default:
        Node = NULL;
        DebPrintNoLock(0, TRUE,
                       "Internal error - invalid node type - %d\n",
                       Debsub, uLineNo, NodeType);
    }


    FRS_DEB_PRINT("-----------------------\n", NULL);

    DebUnLock();
}




VOID
FrsAllocUnicodeString(
    PUNICODE_STRING Ustr,
    PWCHAR          InternalBuffer,
    PWCHAR          Wstr,
    USHORT          WstrLength
    )
/*++

Routine Description:

    Initialize a unicode string with the contents of Wstr if the two are
    not already the same.  If the length of the new string is greater than
    the buffer space currently allocated in Ustr then allocate a new
    buffer for Ustr.  In some structures the initial Ustr buffer allocation
    is allocated as part of the initial structure allocation.  The address
    of this internal buffer is passed so it can be compared with the address
    in Ustr->Buffer.  If they match then no free memory call is made on
    the Ustr->Buffer address.

Arguments:

    Ustr           -- The UNICODE_STRING to init.

    InternalBuffer -- A ptr to the internal buffer address that was preallocated
                      with the containing struct.   If there was no internal
                      buffer pass NULL.

    Wstr           -- The new WCHAR string.

    WstrLength     -- The length of the new string in bytes not including the
                       trailing UNICODE_NULL.

Return Value:

    None.


--*/

{
#undef DEBSUB
#define  DEBSUB  "FrsAllocUnicodeString:"
    //
    // See if the name part changed and if so save it.
    //
    if ((Ustr->Length != WstrLength) ||
        (wcsncmp(Ustr->Buffer, Wstr, Ustr->Length/sizeof(WCHAR)) != 0)) {
        //
        // If string to big (including space for a NULL), alloc new buffer.
        //
        if (WstrLength >= Ustr->MaximumLength) {
            //
            // Alloc room for new one, freeing the old one if not internal alloc.
            //
            if ((Ustr->Buffer != InternalBuffer) && (Ustr->Buffer != NULL)) {
                FrsFree(Ustr->Buffer);
            }
            Ustr->MaximumLength = WstrLength+2;
            Ustr->Buffer = FrsAlloc(WstrLength+2);
        }

        //
        // Copy in new name. Length does not include the trailing NULL at end.
        //
        CopyMemory(Ustr->Buffer, Wstr, WstrLength);
        Ustr->Buffer[WstrLength/2] = UNICODE_NULL;
        Ustr->Length = WstrLength;
    }

}





#define  CO_TRACE_FORMAT       ":: CoG %08x, CxtG %08x, FV %5d, FID %08x %08x, FN: %-15ws, [%s]\n"
#define  REPLICA_TRACE_FORMAT  ":S:Adr %08x, Cmd  %04x, Flg %04x, %ws (%d),  %s, Err %d [%s]\n"
#define  REPLICA_TRACE_FORMAT2 ":S:Adr %08x,                      %ws (%d),  %s,        [%s]\n"
#define  CXTION_TRACE_FORMAT   ":X: %08x, Nam %ws, Sta %s%s, %ws (%d),  %s, Err %d [%s]\n"

VOID
ChgOrdTraceCoe(
    IN ULONG Severity,
    IN PCHAR Debsub,
    IN ULONG uLineNo,
    IN PCHANGE_ORDER_ENTRY Coe,
    IN PCHAR  Text
    )

/*++

Routine Description:

    Print a change order trace record using the change order entry and the
    Text string.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdTraceCoe:"

    ULONGLONG  FileRef;

    FileRef = (Coe != NULL) ? Coe->FileReferenceNumber : QUADZERO;

    DebPrint(Severity,
             (PUCHAR) CO_TRACE_FORMAT,
             Debsub,
             uLineNo,
             (Coe != NULL) ? Coe->Cmd.ChangeOrderGuid.Data1 : 0,
             (Coe != NULL) ? Coe->Cmd.CxtionGuid.Data1 : 0,
             (Coe != NULL) ? Coe->Cmd.FileVersionNumber : 0,
             PRINTQUAD(FileRef),
             (Coe != NULL) ? Coe->Cmd.FileName : L"<Null Coe>",
             Text);

}


VOID
ChgOrdTraceCoeW(
    IN ULONG Severity,
    IN PCHAR Debsub,
    IN ULONG uLineNo,
    IN PCHANGE_ORDER_ENTRY Coe,
    IN PCHAR  Text,
    IN ULONG  WStatus
    )

/*++

Routine Description:

    Print a change order trace record using the change order entry and the
    Text string and Win32 status.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdTraceCoeW:"


    CHAR Tstr[256];

    _snprintf(Tstr, sizeof(Tstr), "%s (%s)", Text, ErrLabelW32(WStatus));
    Tstr[sizeof(Tstr)-1] = '\0';


    ChgOrdTraceCoe(Severity, Debsub, uLineNo, Coe, Tstr);

}


VOID
ChgOrdTraceCoeF(
    IN ULONG Severity,
    IN PCHAR Debsub,
    IN ULONG uLineNo,
    IN PCHANGE_ORDER_ENTRY Coe,
    IN PCHAR  Text,
    IN ULONG  FStatus
    )

/*++

Routine Description:

    Print a change order trace record using the change order entry and the
    Text string and Frs Error status.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdTraceCoeF:"


    CHAR Tstr[128];

    _snprintf(Tstr, sizeof(Tstr), "%s (%s)", Text, ErrLabelFrs(FStatus));
    Tstr[sizeof(Tstr)-1] = '\0';


    ChgOrdTraceCoe(Severity, Debsub, uLineNo, Coe, Tstr);

}



VOID
ChgOrdTraceCoeX(
    IN ULONG Severity,
    IN PCHAR Debsub,
    IN ULONG uLineNo,
    IN PCHANGE_ORDER_ENTRY Coe,
    IN PCHAR  Text,
    IN ULONG  Data
    )

/*++

Routine Description:

    Print a change order trace record using the change order entry and the
    Text string and Win32 status.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdTraceCoeX:"


    CHAR Tstr[256];

    _snprintf(Tstr, sizeof(Tstr), "%s (%08x)", Text, Data);
    Tstr[sizeof(Tstr)-1] = '\0';


    ChgOrdTraceCoe(Severity, Debsub, uLineNo, Coe, Tstr);

}


VOID
ChgOrdTraceCoc(
    IN ULONG Severity,
    IN PCHAR Debsub,
    IN ULONG uLineNo,
    IN PCHANGE_ORDER_COMMAND Coc,
    IN PCHAR  Text
    )

/*++

Routine Description:

    Print a change order trace record using the change order command and the
    Text string.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdTraceCoc:"


    ULONGLONG  FileRef = QUADZERO;

    DebPrint(Severity,
             (PUCHAR) CO_TRACE_FORMAT,
             Debsub,
             uLineNo,
             (Coc != NULL) ? Coc->ChangeOrderGuid.Data1 : 0,
             (Coc != NULL) ? Coc->CxtionGuid.Data1 : 0,
             (Coc != NULL) ? Coc->FileVersionNumber : 0,
             PRINTQUAD(FileRef),
             (Coc != NULL) ? Coc->FileName : L"<Null Coc>",
             Text);

}



VOID
ChgOrdTraceCocW(
    IN ULONG Severity,
    IN PCHAR Debsub,
    IN ULONG uLineNo,
    IN PCHANGE_ORDER_COMMAND Coc,
    IN PCHAR  Text,
    IN ULONG  WStatus
    )

/*++

Routine Description:

    Print a change order trace record using the change order command and the
    Text string and Win32 status.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdTraceCocW:"


    CHAR Tstr[256];

    _snprintf(Tstr, sizeof(Tstr), "%s (%s)", Text, ErrLabelW32(WStatus));
    Tstr[sizeof(Tstr)-1] = '\0';


    ChgOrdTraceCoc(Severity, Debsub, uLineNo, Coc, Tstr);

}




VOID
ReplicaStateTrace(
    IN ULONG           Severity,
    IN PCHAR           Debsub,
    IN ULONG           uLineNo,
    IN PCOMMAND_PACKET Cmd,
    IN PREPLICA        Replica,
    IN ULONG           Status,
    IN PCHAR           Text
    )

/*++

Routine Description:

    Print a replica state trace record using the command packet and the
    status and Text string.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "ReplicaStateTrace:"


    PWSTR ReplicaName;

    if ((Replica != NULL)  &&
        (Replica->ReplicaName != NULL) &&
        (Replica->ReplicaName->Name != NULL)) {
        ReplicaName = Replica->ReplicaName->Name;
    } else {
        ReplicaName = L"<null>";
    }

    DebPrint(Severity,
             (PUCHAR) REPLICA_TRACE_FORMAT,
             Debsub,
             uLineNo,
             PtrToUlong(Cmd),
             (Cmd != NULL) ? Cmd->Command : 0xFFFF,
             (Cmd != NULL) ? Cmd->Flags   : 0xFFFF,
             ReplicaName,
             ReplicaAddrToId(Replica),
             (Replica != NULL) ? RSS_NAME(Replica->ServiceState) : "<null>",
             Status,
             Text);
}




VOID
ReplicaStateTrace2(
    IN ULONG           Severity,
    IN PCHAR           Debsub,
    IN ULONG           uLineNo,
    IN PREPLICA        Replica,
    IN PCHAR           Text
    )

/*++

Routine Description:

    Print a cxtion table access trace record for the replica using the
    Text string.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "ReplicaStateTrace2:"


    PWSTR ReplicaName;

    if ((Replica != NULL)  &&
        (Replica->ReplicaName != NULL) &&
        (Replica->ReplicaName->Name != NULL)) {
        ReplicaName = Replica->ReplicaName->Name;
    } else {
        ReplicaName = L"<null>";
    }

    DebPrint(Severity,
             (PUCHAR) REPLICA_TRACE_FORMAT2,
             Debsub,
             uLineNo,
             PtrToUlong(Replica),
             ReplicaName,
             ReplicaAddrToId(Replica),
             (Replica != NULL) ? RSS_NAME(Replica->ServiceState) : "<null>",
             Text);
}




VOID
CxtionStateTrace(
    IN ULONG    Severity,
    IN PCHAR    Debsub,
    IN ULONG    uLineNo,
    IN PCXTION  Cxtion,
    IN PREPLICA Replica,
    IN ULONG    Status,
    IN PCHAR    Text
    )

/*++

Routine Description:

    Print a connection state trace record using the cxtion and the
    status and Text string.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "CxtionStateTrace:"


    PWSTR ReplicaName = L"<null>";
    PWSTR  CxtName = L"<null>";
    PCHAR  CxtState = "<null>";
    ULONG  Ctxg = 0, Flags = 0;
    PCHAR  CxtDirection = "?-";

    CHAR   FBuf[120];


    if ((Replica != NULL)  &&
        (Replica->ReplicaName != NULL) &&
        (Replica->ReplicaName->Name != NULL)) {
        ReplicaName = Replica->ReplicaName->Name;
    }


    if (Cxtion != NULL) {
        Flags = Cxtion->Flags;
        CxtState = CxtionStateNames[GetCxtionState(Cxtion)];
        CxtDirection = Cxtion->Inbound ? "I-" : "O-";

        if (Cxtion->Name != NULL) {
            if (Cxtion->Name->Name != NULL) {
                CxtName = Cxtion->Name->Name;
            }
            if (Cxtion->Name->Guid != NULL) {
                Ctxg = Cxtion->Name->Guid->Data1;
            }
        }
    }


    DebPrint(Severity,
             (PUCHAR) CXTION_TRACE_FORMAT,
             Debsub,
             uLineNo,
             Ctxg,
             CxtName,
             CxtDirection,
             CxtState,
             ReplicaName,
             ReplicaAddrToId(Replica),
             (Replica != NULL) ? RSS_NAME(Replica->ServiceState) : "<null>",
             Status,
             Text);


    FrsFlagsToStr(Flags, CxtionFlagNameTable, sizeof(FBuf), FBuf);

    DebPrint(Severity, (PUCHAR) ":X: %08x, Flags [%s]\n", Debsub, uLineNo, Ctxg, FBuf);


}



VOID
CmdPktTrace(
    IN ULONG    Severity,
    IN PCHAR    Debsub,
    IN ULONG    uLineNo,
    IN PCOMMAND_PACKET Cmd,
    IN PCHAR    Text
    )

/*++

Routine Description:

    Print a command packet trace record using the Cmd and Text string.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "CmdPktTrace:"

    ULONG CmdCode = 0, Flags = 0, Ctrl = 0, Tout = 0, TQ = 0, Err = 0;

    if (Cmd != NULL) {
        CmdCode = (ULONG) Cmd->Command;
        Flags   = (ULONG) Cmd->Flags;
        Ctrl    = (ULONG) Cmd->Control;
        Tout    = Cmd->Timeout;
        TQ      = PtrToUlong(Cmd->TargetQueue);
        Err     = Cmd->ErrorStatus;
    }

    DebPrint(Severity,
             (PUCHAR) ":Cd: %08x, Cmd %04x, Flg %04x, Ctrl %04x, Tout %08x, TQ %08x, Err %d [%s]\n",
             Debsub,
             uLineNo,
             PtrToUlong(Cmd),     CmdCode,  Flags,    Ctrl,      Tout,      TQ,      Err,   Text);

}



VOID
SendCmdTrace(
    IN ULONG    Severity,
    IN PCHAR    Debsub,
    IN ULONG    uLineNo,
    IN PCOMMAND_PACKET Cmd,
    IN ULONG    WStatus,
    IN PCHAR    Text
    )

/*++

Routine Description:

    Print a send command packet trace record using the Cmd and the
    status and Text string.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "SendCmdTrace:"


    PCXTION  Cxtion;
    PWSTR  CxtTo = L"<null>";
    ULONG  Ctxg = 0, PktLen = 0;


    if (Cmd != NULL) {
        Cxtion = SRCxtion(Cmd);

        if ((Cxtion != NULL) &&
            (Cxtion->Name != NULL) &&
            (Cxtion->Name->Guid != NULL)) {

            Ctxg = Cxtion->Name->Guid->Data1;
        }

        if (SRCommPkt(Cmd) != NULL) {
            PktLen = SRCommPkt(Cmd)->PktLen;
        }

        if ((SRTo(Cmd) != NULL) && (SRTo(Cmd)->Name != NULL)) {
            CxtTo = SRTo(Cmd)->Name;
        }

    }

    DebPrint(Severity,
             (PUCHAR)  ":SR: Cmd %08x, CxtG %08x, WS %s, To   %ws Len:  (%3d) [%s]\n",
             Debsub,
             uLineNo,
             PtrToUlong(Cmd),          Ctxg,     ErrLabelW32(WStatus), CxtTo,  PktLen,     Text);

}




VOID
ReceiveCmdTrace(
    IN ULONG    Severity,
    IN PCHAR    Debsub,
    IN ULONG    uLineNo,
    IN PCOMMAND_PACKET Cmd,
    IN PCXTION  Cxtion,
    IN ULONG    WStatus,
    IN PCHAR    Text
    )

/*++

Routine Description:

    Print a rcv command packet trace record using the Cmd and the
    status and Text string.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "ReceiveCmdTrace:"


    PWSTR  CxtFrom = L"<null>";
    ULONG  Ctxg = 0, PktLen = 0, CmdCode = 0;


    if (Cmd != NULL) {
        CmdCode = (ULONG) Cmd->Command;


        if (Cxtion != NULL) {
            CxtFrom = Cxtion->PartnerDnsName;

            if ((Cxtion->Name != NULL) && (Cxtion->Name->Guid != NULL)) {
                Ctxg = Cxtion->Name->Guid->Data1;
            }
        }
    }

    DebPrint(Severity,
             (PUCHAR)  ":SR: Cmd %08x, CxtG %08x, WS %s, From %ws CCod: (%03x) [%s]\n",
             Debsub,
             uLineNo,
             PtrToUlong(Cmd),          Ctxg,  ErrLabelW32(WStatus), CxtFrom, CmdCode, Text);


}



VOID
StageFileTrace(
    IN ULONG      Severity,
    IN PCHAR      Debsub,
    IN ULONG      uLineNo,
    IN GUID       *CoGuid,
    IN PWCHAR     FileName,
    IN PULONGLONG pFileSize,
    IN PULONG     pFlags,
    IN PCHAR      Text
    )

/*++

Routine Description:

    Print a stage file acquire/release trace record.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "StageFileTrace:"


    ULONGLONG  FileSize = QUADZERO;
    ULONG  Flags = 0, CoGuidData = 0;
    CHAR   FBuf[120];

    Flags = (pFlags != NULL) ? *pFlags : 0;
    CoGuidData = (CoGuid != NULL) ? CoGuid->Data1 : 0;
    pFileSize = (pFileSize == NULL) ? &FileSize : pFileSize;

    DebPrint(Severity,
             (PUCHAR)  ":: CoG %08x, Flgs %08x,    %5d, Siz %08x %08x, FN: %-15ws, [%s]\n",
             Debsub,
             uLineNo,
             CoGuidData,
             Flags,
             0,
             PRINTQUAD(*pFileSize),
             FileName,
             Text);


    FrsFlagsToStr(Flags, StageFlagNameTable, sizeof(FBuf), FBuf);

    DebPrint(Severity,
             (PUCHAR) ":: CoG %08x, Flags [%s]\n",
             Debsub,
             uLineNo,
             CoGuidData,
             FBuf);


}



VOID
SetCxtionStateTrace(
    IN ULONG    Severity,
    IN PCHAR    Debsub,
    IN ULONG    uLineNo,
    IN PCXTION  Cxtion,
    IN ULONG    NewState
    )
/*++

Routine Description:

    Print a change to cxtion state trace record using the Cxtion and the NewState.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "SetCxtionStateTrace:"

    PWSTR  CxtName     = L"<null>";
    PWSTR  PartnerName = L"<null>";
    PWSTR  PartSrvName = L"<null>";

    PCHAR  CxtionState = "<null>";
    ULONG  Ctxg = 0;

    PCHAR  CxtDirection = "?-";


    if (Cxtion != NULL) {
        CxtionState = CxtionStateNames[Cxtion->State];


        if (Cxtion->Name != NULL) {

            if (Cxtion->Name->Guid != NULL) {
                Ctxg = Cxtion->Name->Guid->Data1;
            }

            if (Cxtion->Name->Name != NULL) {
                CxtName = Cxtion->Name->Name;
            }
        }

        CxtDirection = Cxtion->Inbound ? "<-" : "->";

        if ((Cxtion->Partner != NULL) && (Cxtion->Partner->Name != NULL)) {
            PartnerName = Cxtion->Partner->Name;
        }

        if (Cxtion->PartSrvName != NULL) {
            PartSrvName = Cxtion->PartSrvName;
        }
    }

    DebPrint(Severity,
             (PUCHAR)  ":X: %08x, state change from %s to %s for %ws %s %ws\\%ws\n",
             Debsub,
             uLineNo,
             Ctxg,
             CxtionState,
             CxtionStateNames[NewState],
             CxtName,
             CxtDirection,
             PartnerName,
             PartSrvName);

}


#define  FRS_TRACK_FORMAT_1     ":T: CoG: %08x  CxtG: %08x    [%-15s]  Name: %ws\n"
#define  FRS_TRACK_FORMAT_2     ":T: EventTime: %-40s Ver:  %d\n"
#define  FRS_TRACK_FORMAT_3     ":T: FileG:     %-40s FID:  %08x %08x\n"
#define  FRS_TRACK_FORMAT_4     ":T: ParentG:   %-40s Size: %08x %08x\n"
#define  FRS_TRACK_FORMAT_5     ":T: OrigG:     %-40s Attr: %08x\n"
#define  FRS_TRACK_FORMAT_6     ":T: LocnCmd:   %-8s State: %-24s ReplicaName: %ws (%d)\n"
#define  FRS_TRACK_FORMAT_7     ":T: CoFlags:   %08x   [%s]\n"
#define  FRS_TRACK_FORMAT_8     ":T: UsnReason: %08x   [%s]\n"

VOID
FrsTrackRecord(
    IN ULONG Severity,
    IN PCHAR Debsub,
    IN ULONG uLineNo,
    IN PCHANGE_ORDER_ENTRY Coe,
    IN PCHAR  Text
    )

/*++

Routine Description:

    Print a change order file update tracking record using the change order
    entry and Text string.

 7/29-13:40:58 :T: CoG: 779800ea  CxtG: 000001bb    [RemCo         ]   Name: Thous_5555_988
 7/29-13:40:58 :T: EventTime: Sat Jul 29, 2000 12:05:57                Ver:  0
 7/29-13:40:58 :T: FileG:     b49362c3-216d-4ff4-a2d067fd031e436f      FID   00050000 0000144e
 7/29-13:40:58 :T: ParG:      8d60157a-7dc6-4dfc-acf3eca3c6e4d5d8      Size: 00000000 00000030
 7/29-13:40:58 :T: OrigG:     8071d94a-a659-4ff7-a9467d8d6ad18aec      Attr: 00000020
 7/29-13:40:58 :T: LocnCmd:   Create   State: IBCO_INSTALL_DEL_RETRY   ReplicaName: Replica-A (1)
 7/29-13:40:58 :T: COFlags
 7/29-13:40:58 :T: UsnReason: 00000002   [DatExt ]

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "FrsTrackRecord:"

    PCHANGE_ORDER_COMMAND CoCmd;
    CHAR                  FlagBuffer[160];
    CHAR                  GuidStr1[GUID_CHAR_LEN];
    CHAR                  TimeStr[TIME_STRING_LENGTH];


    if (!DoDebug(Severity, Debsub) || (Coe == NULL) || (Text == NULL)) {
        return;
    }
    //
    // Get debug lock so our output stays in one piece.
    //
    DebLock();

    CoCmd = &Coe->Cmd;

    DebPrintTrackingNoLock(Severity, (PUCHAR) FRS_TRACK_FORMAT_1,
                           CoCmd->ChangeOrderGuid.Data1, CoCmd->CxtionGuid.Data1,
                           Text, CoCmd->FileName);

    FileTimeToString((PFILETIME) &CoCmd->EventTime.QuadPart, TimeStr);
    DebPrintTrackingNoLock(Severity, (PUCHAR) FRS_TRACK_FORMAT_2,
                           TimeStr, CoCmd->FileVersionNumber);

    GuidToStr(&CoCmd->FileGuid, GuidStr1);
    DebPrintTrackingNoLock(Severity, (PUCHAR) FRS_TRACK_FORMAT_3,
                           GuidStr1, PRINTQUAD(Coe->FileReferenceNumber));

    GuidToStr(&CoCmd->NewParentGuid, GuidStr1);
    DebPrintTrackingNoLock(Severity, (PUCHAR) FRS_TRACK_FORMAT_4,
                           GuidStr1, PRINTQUAD(CoCmd->FileSize));

    GuidToStr(&CoCmd->OriginatorGuid, GuidStr1);
    DebPrintTrackingNoLock(Severity, (PUCHAR) FRS_TRACK_FORMAT_5,
                           GuidStr1, CoCmd->FileAttributes);

    DebPrintTrackingNoLock(Severity, (PUCHAR) FRS_TRACK_FORMAT_6,
                           CoLocationNames[GET_CO_LOCATION_CMD(Coe->Cmd, Command)],
                           PRINT_CO_STATE(Coe), Coe->NewReplica->ReplicaName->Name,
                           CoCmd->NewReplicaNum);

    FrsFlagsToStr(CoCmd->Flags, CoFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
    DebPrintTrackingNoLock(Severity, (PUCHAR) FRS_TRACK_FORMAT_7,
                           CoCmd->Flags, FlagBuffer);

    FrsFlagsToStr(CoCmd->ContentCmd, UsnReasonNameTable, sizeof(FlagBuffer), FlagBuffer);
    DebPrintTrackingNoLock(Severity, (PUCHAR) FRS_TRACK_FORMAT_8,
                           CoCmd->ContentCmd, FlagBuffer);


#if 0

    FrsFlagsToStr(CoEntry->EntryFlags, CoeFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
    FRS_DEB_PRINT2("EntryFlags: %08x, Flags [%s]\n", CoEntry->EntryFlags, FlagBuffer);

    FrsFlagsToStr(CoEntry->IssueCleanup, IscuFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
    FRS_DEB_PRINT2("ISCU Flags: %08x, Flags [%s]\n", CoEntry->IssueCleanup, FlagBuffer);

    FrsFlagsToStr(CoCmd->IFlags, CoIFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
    DebPrintNoLock(Severity, TRUE,
                   "IFlags: %08x, Flags [%s]  TimeToRun: %7d,  EntryCreateTime: %7d\n",
                   Debsub, uLineNo,
                   CoCmd->IFlags, FlagBuffer,
                   CoEntry->TimeToRun,
                   CoEntry->EntryCreateTime);

    if (CoCmd->Extension != NULL) {
        pULong = (PULONG) CoCmd->Extension;
        DebPrintNoLock(Severity, TRUE,
                   "CO Extension: (%08x) %08x %08x %08x %08x %08x %08x %08x %08x\n",
                   Debsub, uLineNo, pULong,
                   *(pULong+0), *(pULong+1), *(pULong+2), *(pULong+3),
                   *(pULong+4), *(pULong+5), *(pULong+6), *(pULong+7));
    } else {
        FRS_DEB_PRINT("CO Extension: Null\n", NULL);
    }

    FRS_DEB_PRINT("FrsVsn: %08x %08x\n", PRINTQUAD(CoCmd->FrsVsn));

    FRS_DEB_PRINT3("Usn:    %08x %08x   CoFileUsn: %08x %08x   JrnlFirstUsn: %08x %08x\n",
                   PRINTQUAD(CoCmd->JrnlUsn),
                   PRINTQUAD(CoCmd->FileUsn),
                   PRINTQUAD(CoCmd->JrnlFirstUsn));

#endif


    DebUnLock();

}


VOID
FrsPrintLongUStr(
    IN ULONG Severity,
    IN PCHAR Debsub,
    IN ULONG uLineNo,
    IN PWCHAR  UStr
    )

/*++

Routine Description:

    Print a long unicode string on multiple lines.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "FrsPrintLongUStr:"

    ULONG  i, j, Len;
    WCHAR  Usave;

    if (!DoDebug(Severity, Debsub) || (UStr == NULL)) {
        return;
    }

    //
    // Get debug lock so our output stays in one piece.
    //
    DebLock();

    Len = wcslen(UStr);
    i = 0;
    j = 0;

    while (i < Len) {
        i += 60;

        if (i > Len) {
            i = Len;
        }

        Usave = UStr[i];
        UStr[i] = UNICODE_NULL;
        FRS_DEB_PRINT("++ %ws\n", &UStr[j]);
        UStr[i] = Usave;

        j = i;
    }

    DebUnLock();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\util\frstable.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    frstable.c

Abstract:
    These routines manage the tables used by the FRS.

Author:
    Billy J. Fuller 19-Apr-1997

Environment
    User mode winnt

--*/


#include <ntreppch.h>
#pragma  hdrstop

#define DEBSUB  "FRSTABLE:"

#include <frs.h>


PVOID
GTabAllocTableMem(
    IN PRTL_GENERIC_TABLE   Table,
    IN DWORD                NodeSize
    )
/*++
Routine Description:
    Allocate space for a table entry. The entry includes the user-defined
    struct and some overhead used by the generic table routines. The
    generic table routines call this function when they need memory.

Arguments:
    Table       - Address of the table (not used).
    NodeSize    - Bytes to allocate

Return Value:
    Address of newly allocated memory.
--*/
{
    return FrsAlloc(NodeSize);
}




VOID
GTabFreeTableMem(
    IN PRTL_GENERIC_TABLE   Table,
    IN PVOID                Buffer
    )
/*++
Routine Description:
    Free the space allocated by GTAlloc(). The generic table
    routines call this function to free memory.

Arguments:
    Table   - Address of the table (not used).
    Buffer  - Address of previously allocated memory

Return Value:
    None.
--*/
{
    FrsFree(Buffer);
}


RTL_GENERIC_COMPARE_RESULTS
GTabCmpTableEntry(
    IN PRTL_GENERIC_TABLE   Table,
    IN PVOID                TableEntry1,
    IN PVOID                TableEntry2
    )
/*++
Routine Description:
    Compare two entries in the table for guid/names.

Arguments:
    Table   - Address of the table (not used).
    Entry1  - PGEN_ENTRY
    Entry2  - PGEN_ENTRY

Return Value:
    <0      First < Second
    =0      First == Second
    >0      First > Second
--*/
{
    INT             Cmp;
    PGEN_ENTRY      Entry1  = (PGEN_ENTRY)TableEntry1;
    PGEN_ENTRY      Entry2  = (PGEN_ENTRY)TableEntry2;

    //
    // Primary key must be present
    //
    FRS_ASSERT(Entry1->Key1 && Entry2->Key1);

    //
    // Compare primary keys
    //
    Cmp = memcmp(Entry1->Key1, Entry2->Key1, sizeof(GUID));
    if (Cmp < 0) {
        return (GenericLessThan);
    }
    if (Cmp > 0) {
        return (GenericGreaterThan);
    }

    //
    // No second key; done
    //
    if (!Entry1->Key2 || !Entry2->Key2)
        return GenericEqual;

    //
    // Compare secondary keys
    //
    Cmp = _wcsicmp(Entry1->Key2, Entry2->Key2);
    if (Cmp < 0) {
        return (GenericLessThan);
    }
    if (Cmp > 0){
        return (GenericGreaterThan);
    }

    return (GenericEqual);
}


RTL_GENERIC_COMPARE_RESULTS
GTabCmpTableNumberEntry(
    IN PRTL_GENERIC_TABLE   Table,
    IN PVOID                TableEntry1,
    IN PVOID                TableEntry2
    )
/*++
Routine Description:
    Compare two entries in the table for number

Arguments:
    Table   - Address of the table (not used).
    Entry1  - PGEN_ENTRY
    Entry2  - PGEN_ENTRY

Return Value:
    <0      First < Second
    =0      First == Second
    >0      First > Second
--*/
{
    INT             Cmp;
    PGEN_ENTRY      Entry1  = (PGEN_ENTRY)TableEntry1;
    PGEN_ENTRY      Entry2  = (PGEN_ENTRY)TableEntry2;

    //
    // Primary key must be present
    //
    FRS_ASSERT(Entry1->Key1 && Entry2->Key1);

    //
    // Compare primary keys
    //
    Cmp = memcmp(Entry1->Key1, Entry2->Key1, sizeof(ULONG));
    if (Cmp < 0) {
        return (GenericLessThan);
    }
    if (Cmp > 0){
        return (GenericGreaterThan);
    }

    return GenericEqual;
}


RTL_GENERIC_COMPARE_RESULTS
GTabCmpTableStringAndBoolEntry(
    IN PRTL_GENERIC_TABLE   Table,
    IN PVOID                TableEntry1,
    IN PVOID                TableEntry2
    )
/*++
Routine Description:
    Compare two entries in the table for data with strings used as key.

Arguments:
    Table   - Address of the table (not used).
    Entry1  - PGEN_ENTRY
    Entry2  - PGEN_ENTRY

Return Value:
    <0      First < Second
    =0      First == Second
    >0      First > Second
--*/
{
    INT             Cmp;
    PGEN_ENTRY      Entry1  = (PGEN_ENTRY)TableEntry1;
    PGEN_ENTRY      Entry2  = (PGEN_ENTRY)TableEntry2;

    //
    // Primary key must be present
    //
    FRS_ASSERT(Entry1->Key1 && Entry2->Key1);

    //
    // Compare primary keys
    //
    Cmp = _wcsicmp((PWCHAR)(Entry1->Key1), (PWCHAR)(Entry2->Key1));
    if (Cmp < 0) {
        return (GenericLessThan);
    }
    if (Cmp > 0){
        return (GenericGreaterThan);
    }

    //
    // Compare secondary keys if they exist.
    //

    if ((Entry1->Key2 == NULL) || (Entry2->Key2 == NULL)) {
        return GenericEqual;
    }

    if (*(Entry1->Key2) == *(Entry2->Key2)) {
        return GenericEqual;
    } else if (*(Entry1->Key2) == FALSE) {
        return GenericLessThan;
    }

    return GenericGreaterThan;
}


RTL_GENERIC_COMPARE_RESULTS
GTabCmpTableStringEntry(
    IN PRTL_GENERIC_TABLE   Table,
    IN PVOID                TableEntry1,
    IN PVOID                TableEntry2
    )
/*++
Routine Description:
    Compare two entries in the table for data with strings used as key.

Arguments:
    Table   - Address of the table (not used).
    Entry1  - PGEN_ENTRY
    Entry2  - PGEN_ENTRY

Return Value:
    <0      First < Second
    =0      First == Second
    >0      First > Second
--*/
{
    INT             Cmp;
    PGEN_ENTRY      Entry1  = (PGEN_ENTRY)TableEntry1;
    PGEN_ENTRY      Entry2  = (PGEN_ENTRY)TableEntry2;

    //
    // Primary key must be present
    //
    FRS_ASSERT(Entry1->Key1 && Entry2->Key1);

    //
    // Compare primary keys
    //
    Cmp = _wcsicmp((PWCHAR)(Entry1->Key1), (PWCHAR)(Entry2->Key1));
    if (Cmp < 0) {
        return (GenericLessThan);
    }
    if (Cmp > 0){
        return (GenericGreaterThan);
    }

    //
    // Compare secondary keys if they exist.
    //

    if ((Entry1->Key2 == NULL) || (Entry2->Key2 == NULL)) {
        return GenericEqual;
    }

    Cmp = _wcsicmp(Entry1->Key2, Entry2->Key2);
    if (Cmp < 0) {
        return (GenericLessThan);
    }
    if (Cmp > 0){
        return (GenericGreaterThan);
    }

    return GenericEqual;
}


VOID
GTabLockTable(
    PGEN_TABLE  GTable
    )
/*++
Routine Description:
    Lock the table

Arguments:
    GTable  - frs generic table

Return Value:
    None.
--*/
{
    EnterCriticalSection(&GTable->Critical);
}


VOID
GTabUnLockTable(
    PGEN_TABLE  GTable
    )
/*++
Routine Description:
    Unlock the table

Arguments:
    GTable  - frs generic table

Return Value:
    None.
--*/
{
    LeaveCriticalSection(&GTable->Critical);
}


PGEN_TABLE
GTabAllocNumberTable(
    VOID
    )
/*++
Routine Description:
    Initialize a generic table + lock for numbers.

Arguments:
    None.

Return Value:
    None.
--*/
{
    PGEN_TABLE  GTable;

    GTable = FrsAllocType(GEN_TABLE_TYPE);
    InitializeCriticalSection(&GTable->Critical);
    RtlInitializeGenericTable(&GTable->Table,
                              GTabCmpTableNumberEntry,
                              GTabAllocTableMem,
                              GTabFreeTableMem,
                              NULL);
    return GTable;
}


PGEN_TABLE
GTabAllocStringTable(
    VOID
    )
/*++
Routine Description:
    Initialize a generic table + lock for data with strings
    used as a key.

Arguments:
    None.

Return Value:
    None.
--*/
{
    PGEN_TABLE  GTable;

    GTable = FrsAllocType(GEN_TABLE_TYPE);
    InitializeCriticalSection(&GTable->Critical);
    RtlInitializeGenericTable(&GTable->Table,
                              GTabCmpTableStringEntry,
                              GTabAllocTableMem,
                              GTabFreeTableMem,
                              NULL);
    return GTable;
}


PGEN_TABLE
GTabAllocStringAndBoolTable(
    VOID
    )
/*++
Routine Description:
    Initialize a generic table + lock for data with a string and bool
    used as a key.

Arguments:
    None.

Return Value:
    None.
--*/
{
    PGEN_TABLE  GTable;

    GTable = FrsAllocType(GEN_TABLE_TYPE);
    InitializeCriticalSection(&GTable->Critical);
    RtlInitializeGenericTable(&GTable->Table,
                              GTabCmpTableStringAndBoolEntry,
                              GTabAllocTableMem,
                              GTabFreeTableMem,
                              NULL);
    return GTable;
}


PGEN_TABLE
GTabAllocTable(
    VOID
    )
/*++
Routine Description:
    Initialize a generic table + lock.

Arguments:
    None.

Return Value:
    None.
--*/
{
    PGEN_TABLE  GTable;

    GTable = FrsAllocType(GEN_TABLE_TYPE);
    InitializeCriticalSection(&GTable->Critical);
    RtlInitializeGenericTable(&GTable->Table,
                              GTabCmpTableEntry,
                              GTabAllocTableMem,
                              GTabFreeTableMem,
                              NULL);
    return GTable;
}


VOID
GTabEmptyTableNoLock(
    IN PGEN_TABLE   GTable,
    IN PVOID        (*CallerFree)(PVOID)
    )
/*++
Routine Description:
    Free every entry in the frs generic table.  Caller has acquired the table lock.

Arguments:

    GTable   - frs generic table
    CallerFree - The free routine to use to free up the callers datum (optional)

Return Value:
    None.
--*/
{
    PGEN_ENTRY  Entry;  // Next entry in table
    PGEN_ENTRY  Dup;    // Next entry in table
    PVOID       Data;

    //
    // For every entry in the table
    //
    while (Entry = RtlEnumerateGenericTable(&GTable->Table, TRUE)) {
        //
        // Delete the dups
        //
        while (Dup = Entry->Dups) {
            Entry->Dups = Dup->Dups;
            if (CallerFree) {
                //
                // Free up the callers Datum
                //
                (*CallerFree)(Dup->Data);
            }
            Dup = FrsFree(Dup);
        }

        //
        // Delete the entry from the table
        //
        Data = Entry->Data;
        RtlDeleteElementGenericTable(&GTable->Table, Entry);
        if (CallerFree) {
            //
            // Free up the callers Datum
            //
            (*CallerFree)(Data);
        }
    }
}



VOID
GTabEmptyTable(
    IN PGEN_TABLE   GTable,
    IN PVOID        (*CallerFree)(PVOID)
    )
/*++
Routine Description:
    Free every entry in the frs generic table.

Arguments:

    GTable   - frs generic table
    CallerFree - The free routine to use to free up the callers datum (optional)

Return Value:
    None.
--*/
{
    GTabLockTable(GTable);

    GTabEmptyTableNoLock(GTable, CallerFree);

    GTabUnLockTable(GTable);
}




PVOID
GTabFreeTable(
    IN PGEN_TABLE   GTable,
    IN PVOID        (*CallerFree)(PVOID)
    )
/*++
Routine Description:
    Undo the work done by GenTableInitialize.

Arguments:
    GTTable - Address of the gen table.
    CallerFree - The free routine to use to free up the callers datum (optional)

Return Value:
    None.
--*/
{
    if (GTable == NULL) {
        return NULL;
    }

    //
    // Empty the table
    //
    GTabEmptyTable(GTable, CallerFree);

    DeleteCriticalSection(&GTable->Critical);
    return FrsFreeType(GTable);
}

PVOID
GTabLookupNoLock(
    IN PGEN_TABLE   GTable,
    IN GUID         *Key1,
    IN PWCHAR       Key2
    )
/*++
Routine Description:
    Find the entry in the table.

Arguments:
    GTable  - frs generic table
    Key1    - primary key
    Key2    - secondary key (may be NULL)

Return Value:
    Data for an entry or NULL
--*/
{
    PVOID           Data;
    PGEN_ENTRY      Entry;  // entry in table
    GEN_ENTRY       Key;    // Search key

    FRS_ASSERT(Key1);

    //
    // Set up a search key that is suitable for any table
    //
    Key.Key1 = Key1;
    Key.Key2 = Key2;

    //
    // Search the table
    //
    Entry = (PVOID)RtlLookupElementGenericTable(&GTable->Table, &Key);
    Data = (Entry) ? Entry->Data : NULL;
    return Data;
}






PVOID
GTabLookup(
    IN PGEN_TABLE   GTable,
    IN GUID         *Key1,
    IN PWCHAR       Key2
    )
/*++
Routine Description:
    Find the data for an entry in the table.

Arguments:
    GTable  - frs generic table
    Key1    - primary key
    Key2    - secondary key (may be NULL)

Return Value:
    Data for an entry or NULL
--*/
{
    PVOID           Data;
    PGEN_ENTRY      Entry;  // entry in table
    GEN_ENTRY       Key;    // Search key

    FRS_ASSERT(Key1);

    //
    // Set up a search key that is suitable for any table
    //
    Key.Key1 = Key1;
    Key.Key2 = Key2;

    //
    // Search the table
    //
    GTabLockTable(GTable);
    Entry = (PVOID)RtlLookupElementGenericTable(&GTable->Table, &Key);
    Data = (Entry) ? Entry->Data : NULL;
    GTabUnLockTable(GTable);
    return Data;
}


BOOL
GTabIsEntryPresent(
    IN PGEN_TABLE   GTable,
    IN GUID         *Key1,
    IN PWCHAR       Key2
    )
/*++
Routine Description:
    Find the entry in the table and return TRUE if found.

Arguments:
    GTable  - frs generic table
    Key1    - primary key
    Key2    - secondary key (may be NULL)

Return Value:
    Boolean
--*/
{
    PVOID           Data;
    PGEN_ENTRY      Entry;  // entry in table
    GEN_ENTRY       Key;    // Search key

    FRS_ASSERT(Key1);

    //
    // Set up a search key that is suitable for any table
    //
    Key.Key1 = Key1;
    Key.Key2 = Key2;

    //
    // Search the table
    //
    GTabLockTable(GTable);
    Entry = (PVOID)RtlLookupElementGenericTable(&GTable->Table, &Key);
    GTabUnLockTable(GTable);
    return (Entry != NULL);
}


PVOID
GTabLookupTableString(
    IN PGEN_TABLE   GTable,
    IN PWCHAR       Key1,
    IN PWCHAR       Key2
    )
/*++
Routine Description:
    Find the data for an entry in the table that is indexed by string.

Arguments:
    GTable  - frs generic table
    Key1    - primary key
    Key2    - secondary key (may be NULL)

Return Value:
    Data for an entry or NULL
--*/
{
    PVOID           Data;
    PGEN_ENTRY      Entry;  // entry in table
    GEN_ENTRY       Key;    // Search key

    FRS_ASSERT(Key1);

    //
    // Set up a search key that is suitable for any table
    //
    Key.Key1 = (GUID *)Key1;
    Key.Key2 = Key2;

    //
    // Search the table
    //
    GTabLockTable(GTable);
    Entry = (PVOID)RtlLookupElementGenericTable(&GTable->Table, &Key);
    Data = (Entry) ? Entry->Data : NULL;
    GTabUnLockTable(GTable);
    return Data;
}


PGEN_ENTRY
GTabLookupEntryNoLock(
    IN PGEN_TABLE   GTable,
    IN GUID         *Key1,
    IN PWCHAR       Key2
    )
/*++
Routine Description:
    Find the data for an entry in the table.

Arguments:
    GTable  - frs generic table
    Key1    - primary key
    Key2    - secondary key (may be NULL)

Return Value:
    Data for an entry or NULL
--*/
{
    PGEN_ENTRY      Entry;  // entry in table
    GEN_ENTRY       Key;    // Search key

    FRS_ASSERT(Key1);

    //
    // Set up a search key that is suitable for any table
    //
    Key.Key1 = Key1;
    Key.Key2 = Key2;

    //
    // Search the table
    //
    Entry = (PVOID)RtlLookupElementGenericTable(&GTable->Table, &Key);
    return Entry;
}





PGEN_ENTRY
GTabNextEntryNoLock(
    PGEN_TABLE  GTable,
    PVOID       *Key
    )
/*++
Routine Description:
    Return the entry for Key in GTable. The caller is responsible for
    insuring synchronization.

Arguments:
    GTable  - frs generic table
    Key     - NULL on first call

Return Value:
    The address of an entry in the table or NULL.
--*/
{
    PGEN_ENTRY  Entry;
    //
    // Return the entry's address
    //
    Entry = (PVOID)RtlEnumerateGenericTableWithoutSplaying(&GTable->Table, Key);
    return Entry;
}


PVOID
GTabNextDatumNoLock(
    PGEN_TABLE  GTable,
    PVOID       *Key
    )
/*++
Routine Description:
    Return the data for the entry for Key in GTable.
    Caller acquires the table lock.

Arguments:
    GTable  - frs generic table
    Key     - NULL on first call
    GetData - return the entry or the data for the entry

Return Value:
    The address of an entry in the table or NULL.
--*/
{
    PVOID       Data;
    PGEN_ENTRY  Entry;

    //
    // Return the address of the entry's data
    //
    Entry = GTabNextEntryNoLock(GTable, Key);
    Data = (Entry) ? Entry->Data : NULL;
    return Data;
}





PVOID
GTabNextDatum(
    PGEN_TABLE  GTable,
    PVOID       *Key
    )
/*++
Routine Description:
    Return the data for the entry for Key in GTable.

Arguments:
    GTable  - frs generic table
    Key     - NULL on first call
    GetData - return the entry or the data for the entry

Return Value:
    The address of an entry in the table or NULL.
--*/
{
    PVOID       Data;
    PGEN_ENTRY  Entry;

    //
    // Return the address of the entry's data
    //
    GTabLockTable(GTable);
    Entry = GTabNextEntryNoLock(GTable, Key);
    Data = (Entry) ? Entry->Data : NULL;
    GTabUnLockTable(GTable);
    return Data;
}






DWORD
GTabNumberInTable(
    PGEN_TABLE  GTable
    )
/*++
Routine Description:
    Return the number of entries in a table.

Arguments:
    GTable  - frs generic table

Return Value:
    Number of entries in the table.
--*/
{
    if (GTable) {
        return RtlNumberGenericTableElements(&GTable->Table);
    } else {
        return 0;
    }
}


PVOID
GTabInsertUniqueEntry(
    IN PGEN_TABLE   GTable,
    IN PVOID        NewData,
    IN PVOID        Key1,
    IN PVOID        Key2
    )
/*++
Routine Description:
    Insert an entry into the table. If a duplicate is found then
    return the original entry. Do not insert in that case.

Arguments:
    GTable  - frs generic table
    NewData - data for the entry to insert
    Key1    - primary key
    Key2    - secondary key (may be NULL)

Return Value:
    NULL if the entry was successfully inserted in the table.
    Pointer to the data from old entry if a collision is found.
--*/
{
    PGEN_ENTRY  OldEntry;   // Existing entry in the table
    BOOLEAN     IsNew;      // TRUE if insert found existing entry
    GEN_ENTRY   NewEntry;   // new entry to insert.
    PGEN_ENTRY  DupEntry;   // Newly allocated table entry for duplicate.

    //
    // Init the new entry. Have to typecast here becasue the GEN_ENTRY expects a GUID* and PWCHAR.
    //
    NewEntry.Data = NewData;
    NewEntry.Key1 = (GUID*)Key1;
    NewEntry.Key2 = (PWCHAR)Key2;
    NewEntry.Dups = NULL;

    //
    // Lock the table and Insert the entry
    //
    GTabLockTable(GTable);
    OldEntry = RtlInsertElementGenericTable(&GTable->Table,
                                            &NewEntry,
                                            sizeof(NewEntry),
                                            &IsNew);

    GTabUnLockTable(GTable);

    if (!IsNew) {
        return OldEntry;
    }

    return NULL;

}


VOID
GTabInsertEntry(
    IN PGEN_TABLE   GTable,
    IN PVOID        NewData,
    IN GUID         *Key1,
    IN PWCHAR       Key2
    )
/*++
Routine Description:
    Insert an entry into the table. Duplicates are simply linked
    to the current entry.

Arguments:
    GTable  - frs generic table
    NewData - data for the entry to insert
    Key1    - primary key
    Key2    - secondary key (may be NULL)

Return Value:
    None.
--*/
{
    PGEN_ENTRY  OldEntry;   // Existing entry in the table
    BOOLEAN     IsNew;      // TRUE if insert found existing entry
    GEN_ENTRY   NewEntry;   // new entry to insert.
    PGEN_ENTRY  DupEntry;   // Newly allocated table entry for duplicate.

    //
    // Init the new entry.
    //
    NewEntry.Data = NewData;
    NewEntry.Key1 = Key1;
    NewEntry.Key2 = Key2;
    NewEntry.Dups = NULL;

    //
    // Lock the table and Insert the entry
    //
    GTabLockTable(GTable);
    OldEntry = RtlInsertElementGenericTable(&GTable->Table,
                                            &NewEntry,
                                            sizeof(NewEntry),
                                            &IsNew);
    if (!IsNew) {
        //
        // Duplicate entry; add to list
        //
        DupEntry = FrsAlloc(sizeof(GEN_ENTRY));
        CopyMemory(DupEntry, &NewEntry, sizeof(NewEntry));
        DupEntry->Dups = OldEntry->Dups;
        OldEntry->Dups = DupEntry;
    }
    GTabUnLockTable(GTable);
}


VOID
GTabInsertEntryNoLock(
    IN PGEN_TABLE   GTable,
    IN PVOID        NewData,
    IN GUID         *Key1,
    IN PWCHAR       Key2
    )
/*++
Routine Description:
    Insert an entry into the table. Duplicates are simply linked
    to the current entry.

    Caller acquires the table lock.

Arguments:
    GTable  - frs generic table
    NewData - data for the entry to insert
    Key1    - primary key
    Key2    - secondary key (may be NULL)

Return Value:
    None.
--*/
{
    PGEN_ENTRY  OldEntry;   // Existing entry in the table
    BOOLEAN     IsNew;      // TRUE if insert found existing entry
    GEN_ENTRY   NewEntry;   // new entry to insert.
    PGEN_ENTRY  DupEntry;   // Newly allocated table entry for duplicate.

    //
    // Init the new entry.
    //
    NewEntry.Data = NewData;
    NewEntry.Key1 = Key1;
    NewEntry.Key2 = Key2;
    NewEntry.Dups = NULL;

    //
    // Lock the table and Insert the entry
    //
    OldEntry = RtlInsertElementGenericTable(&GTable->Table,
                                            &NewEntry,
                                            sizeof(NewEntry),
                                            &IsNew);
    if (!IsNew) {
        //
        // Duplicate entry; add to list
        //
        DupEntry = FrsAlloc(sizeof(GEN_ENTRY));
        CopyMemory(DupEntry, &NewEntry, sizeof(NewEntry));
        DupEntry->Dups = OldEntry->Dups;
        OldEntry->Dups = DupEntry;
    }
}


VOID
GTabDelete(
    IN PGEN_TABLE   GTable,
    IN GUID         *Key1,
    IN PWCHAR       Key2,
    IN PVOID        (*CallerFree)(PVOID)
    )
/*++
Routine Description:
    Delete the entry in the table.

Arguments:
    GTable  - frs generic table
    Key1    - primary key
    Key2    - secondary key (may be NULL)
    CallerFree - The free routine to use to free up the callers datum (optional)

Return Value:
    None.
--*/
{
    GEN_ENTRY   Key;    // Search key
    PGEN_ENTRY  Entry;  // entry in table
    PGEN_ENTRY  Dup;    // dup entry in table
    PVOID       Data;

    FRS_ASSERT(Key1);

    //
    // Set up a search key that is suitable for either table
    //
    Key.Key1 = Key1;
    Key.Key2 = Key2;

    //
    // Find the entry
    //
    GTabLockTable(GTable);
    Entry = (PVOID)RtlLookupElementGenericTable(&GTable->Table, &Key);
    if (Entry == NULL) {
        goto out;
    }

    //
    // Delete the dups
    //
    while (Dup = Entry->Dups) {
        Entry->Dups = Dup->Dups;
        if (CallerFree) {
            //
            // Free up the callers Datum
            //
            (*CallerFree)(Dup->Data);
        }
        Dup = FrsFree(Dup);
    }

    //
    // Delete entry
    //
    Data = Entry->Data;
    RtlDeleteElementGenericTable(&GTable->Table, Entry);
    if (CallerFree) {
        //
        // Free up the callers Datum
        //
        (*CallerFree)(Data);
    }

out:
    GTabUnLockTable(GTable);
}


VOID
GTabDeleteNoLock(
    IN PGEN_TABLE   GTable,
    IN GUID         *Key1,
    IN PWCHAR       Key2,
    IN PVOID        (*CallerFree)(PVOID)
    )
/*++
Routine Description:
    Delete the entry in the table.

Arguments:
    GTable  - frs generic table
    Key1    - primary key
    Key2    - secondary key (may be NULL)
    CallerFree - The free routine to use to free up the callers datum (optional)

Return Value:
    None.
--*/
{
    GEN_ENTRY   Key;    // Search key
    PGEN_ENTRY  Entry;  // entry in table
    PGEN_ENTRY  Dup;    // dup entry in table
    PVOID       Data;

    FRS_ASSERT(Key1);

    //
    // Set up a search key that is suitable for either table
    //
    Key.Key1 = Key1;
    Key.Key2 = Key2;

    //
    // Find the entry
    //
    Entry = (PVOID)RtlLookupElementGenericTable(&GTable->Table, &Key);
    if (Entry == NULL) {
        return;
    }

    //
    // Delete the dups
    //
    while (Dup = Entry->Dups) {
        Entry->Dups = Dup->Dups;
        if (CallerFree) {
            //
            // Free up the callers Datum
            //
            (*CallerFree)(Dup->Data);
        }
        Dup = FrsFree(Dup);
    }

    //
    // Delete entry
    //
    Data = Entry->Data;
    RtlDeleteElementGenericTable(&GTable->Table, Entry);
    if (CallerFree) {
        //
        // Free up the callers Datum
        //
        (*CallerFree)(Data);
    }
}


VOID
GTabPrintTable(
    IN PGEN_TABLE   GTable
    )
/*++
Routine Description:
    Print the table and all of its dups.

Arguments:
    GTable  - frs generic table

Return Value:
    None.
--*/
{
    PGEN_ENTRY  Entry;
    PGEN_ENTRY  Dup;
    PVOID       Key;
    CHAR        Guid[GUID_CHAR_LEN + 1];

    //
    // print the entries
    //
    GTabLockTable(GTable);
    Key = NULL;

    while (Entry = GTabNextEntryNoLock(GTable, &Key)) {

        GuidToStr(Entry->Key1, &Guid[0]);
        if (Entry->Key2) {
            DPRINT3(0, "\t0x%x %s %ws\n", Entry->Data, Guid, Entry->Key2);
        } else {
            DPRINT2(0, "\t0x%x %s NULL\n", Entry->Data, Guid);
        }

        for (Dup = Entry->Dups; Dup; Dup = Dup->Dups) {

            GuidToStr(Entry->Key1, &Guid[0]);
            if (Dup->Key2) {
                DPRINT3(0, "\t0x%x %s %ws\n", Dup->Data, Guid, Dup->Key2);
            } else {
                DPRINT2(0, "\t0x%x %s NULL\n", Dup->Data, Guid);
            }
        }
    }

    GTabUnLockTable(GTable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\util\frssrvc.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    service.c

Abstract:
    Routines that talk to the service controller.

Author:
    Billy J. Fuller 11-Apr-1997

Environment
    User mode winnt
--*/

#include <ntreppch.h>
#pragma  hdrstop


#include <frs.h>


extern SERVICE_STATUS           ServiceStatus;
extern CRITICAL_SECTION         ServiceLock;
extern SERVICE_STATUS_HANDLE    ServiceStatusHandle;

//
// This is a lookup table of legal/illegal service state transitions. FrsSetServiceStatus API
// uses this table to validate the input transition requested and takes appropriate action.
//

DWORD StateTransitionLookup[FRS_SVC_TRANSITION_TABLE_SIZE][FRS_SVC_TRANSITION_TABLE_SIZE] = {
    {0,                    SERVICE_STOPPED,         SERVICE_START_PENDING,     SERVICE_STOP_PENDING,      SERVICE_RUNNING           },
    {SERVICE_STOPPED,      FRS_SVC_TRANSITION_NOOP, FRS_SVC_TRANSITION_NOOP,   FRS_SVC_TRANSITION_ILLEGAL,FRS_SVC_TRANSITION_ILLEGAL},
    {SERVICE_START_PENDING,FRS_SVC_TRANSITION_LEGAL,FRS_SVC_TRANSITION_LEGAL,  FRS_SVC_TRANSITION_LEGAL,  FRS_SVC_TRANSITION_LEGAL  },
    {SERVICE_STOP_PENDING, FRS_SVC_TRANSITION_LEGAL,FRS_SVC_TRANSITION_ILLEGAL,FRS_SVC_TRANSITION_LEGAL,  FRS_SVC_TRANSITION_ILLEGAL},
    {SERVICE_RUNNING,      FRS_SVC_TRANSITION_LEGAL,FRS_SVC_TRANSITION_ILLEGAL,FRS_SVC_TRANSITION_LEGAL,  FRS_SVC_TRANSITION_NOOP   }
};


SC_HANDLE
FrsOpenServiceHandle(
    IN PTCHAR  MachineName,
    IN PTCHAR  ServiceName
    )
/*++
Routine Description:
    Open a service on a machine.

Arguments:
    MachineName - the name of the machine to contact
    ServiceName - the service to open

Return Value:
    The service's handle or NULL.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsOpenServiceHandle:"

    SC_HANDLE       SCMHandle;
    SC_HANDLE       ServiceHandle;
    ULONG           WStatus;

    //
    // Attempt to contact the SC manager.
    //
    SCMHandle = OpenSCManager(MachineName, NULL, SC_MANAGER_CONNECT);
    if (!HANDLE_IS_VALID(SCMHandle)) {
        WStatus = GetLastError();

        DPRINT1_WS(0, ":SC: Couldn't open service control manager on machine %ws;",
                   MachineName, WStatus);
        return NULL;
    }

    //
    // Contact the service.
    //
    ServiceHandle = OpenService(SCMHandle, ServiceName, SERVICE_ALL_ACCESS);
    if (!HANDLE_IS_VALID(ServiceHandle)) {
        WStatus = GetLastError();

        DPRINT2_WS(0, ":SC: Couldn't open service control manager for service (%ws) on machine %ws;",
                  ServiceName, MachineName, WStatus);
        ServiceHandle = NULL;
    }

    CloseServiceHandle(SCMHandle);

    return ServiceHandle;
}


DWORD
FrsGetServiceState(
    IN PWCHAR   MachineName,
    IN PWCHAR   ServiceName
    )
/*++
Routine Description:
    Return the service's state

Arguments:
    MachineName - the name of the machine to contact
    ServiceName - the service to check

Return Value:
    The service's state or 0 if the state could not be obtained.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsGetServiceState:"

    SC_HANDLE       ServiceHandle;
    SERVICE_STATUS  ServiceStatus;

    //
    // Open the service.
    //
    ServiceHandle = FrsOpenServiceHandle(MachineName, ServiceName);
    if (!HANDLE_IS_VALID(ServiceHandle)) {
        return 0;
    }

    //
    // Get the service's status
    //
    if (!QueryServiceStatus(ServiceHandle, &ServiceStatus)) {
        DPRINT3(0, ":SC: WARN - QueryServiceStatus(%ws, %ws) returned %d\n",
                MachineName, ServiceName, GetLastError());
        CloseServiceHandle(ServiceHandle);
        return 0;
    }

    CloseServiceHandle(ServiceHandle);

    //
    // Successfully retrieved service status; check state
    //
    return ServiceStatus.dwCurrentState;
}





BOOL
FrsIsServiceRunning(
    IN PWCHAR  MachineName,
    IN PWCHAR  ServiceName
    )
/*++
Routine Description:
    Is a service running on a machine.

Arguments:
    MachineName - the name of the machine to contact
    ServiceName - the service to check

Return Value:
    TRUE    - Service is running.
    FALSE   - Service is not running.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsIsServiceRunning:"

    DWORD   State;

    State = FrsGetServiceState(MachineName, ServiceName);
    return (State == SERVICE_RUNNING);
}


DWORD
FrsSetServiceFailureAction(
    VOID
    )
/*++

Routine Description:

    If unset, initialize the service's failure actions.

Arguments:


Return Value:

    WIN32 STATUS

--*/
{
#undef DEBSUB
#define DEBSUB "FrsSetServiceFailureAction:"


#define NUM_ACTIONS                     (3)
#define SERVICE_RESTART_MILLISECONDS    (30 * 60 * 1000)

    SC_HANDLE               ServiceHandle;
    DWORD                   BufSize, BytesNeeded;
    SC_ACTION               *Actions;
    SERVICE_FAILURE_ACTIONS *FailureActions;
    ULONG                   WStatus = ERROR_SUCCESS, i;


    if (!RunningAsAService || !HANDLE_IS_VALID(ServiceStatusHandle)) {
        return ERROR_SUCCESS;
    }

    BufSize = sizeof(SERVICE_FAILURE_ACTIONS) + sizeof(SC_ACTION) * NUM_ACTIONS;
    FailureActions = FrsAlloc(BufSize);

    EnterCriticalSection(&ServiceLock);

    //
    // Retrieve the current failure actions for the service NtFrs
    //
    ServiceHandle = FrsOpenServiceHandle(NULL, SERVICE_NAME);
    if (!HANDLE_IS_VALID(ServiceHandle)) {
        LeaveCriticalSection(&ServiceLock);
        FailureActions = FrsFree(FailureActions);
        DPRINT(0, ":SC: Failed to open service handle.\n");
        return ERROR_OPEN_FAILED;
    }

    if (!QueryServiceConfig2(ServiceHandle,
                             SERVICE_CONFIG_FAILURE_ACTIONS,
                             (PVOID)FailureActions,
                             BufSize,
                             &BytesNeeded)) {
        WStatus = GetLastError();

        CloseServiceHandle(ServiceHandle);
        LeaveCriticalSection(&ServiceLock);

        if (WIN_BUF_TOO_SMALL(WStatus)) {
            DPRINT(0, ":SC: Restart actions for service are already set.\n");
            WStatus = ERROR_SUCCESS;
        } else {
            DPRINT_WS(0, ":SC: Could not query service for restart action;", WStatus);
        }

        FailureActions = FrsFree(FailureActions);

        return WStatus;
    }

    //
    // Check if failure action already set.  E.g. by the User.
    //
    if (FailureActions->cActions) {

        CloseServiceHandle(ServiceHandle);

        LeaveCriticalSection(&ServiceLock);

        DPRINT(0, ":SC: Restart actions for service are already set.\n");
        FailureActions = FrsFree(FailureActions);

        return ERROR_SUCCESS;
    }

    //
    // Service failure actions are unset; initialize them
    //
    WStatus = ERROR_SUCCESS;
    Actions = (SC_ACTION *)(((PUCHAR)FailureActions) +
                             sizeof(SERVICE_FAILURE_ACTIONS));

    for (i = 0; i < NUM_ACTIONS; ++i) {
        Actions[i].Type = SC_ACTION_RESTART;
        Actions[i].Delay = SERVICE_RESTART_MILLISECONDS;
    }

    FailureActions->cActions = NUM_ACTIONS;
    FailureActions->lpsaActions = Actions;

    if (!ChangeServiceConfig2(ServiceHandle,
                              SERVICE_CONFIG_FAILURE_ACTIONS,
                              (PVOID)FailureActions)) {

        WStatus = GetLastError();
    }

    CloseServiceHandle(ServiceHandle);
    LeaveCriticalSection(&ServiceLock);

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT_WS(0, ":SC: Could not set restart actions;", WStatus);
    } else {
        DPRINT(4, ":SC: Success setting restart actions for service.\n");
    }

    FailureActions = FrsFree(FailureActions);

    return WStatus;

}



BOOL
FrsWaitService(
    IN PWCHAR   MachineName,
    IN PWCHAR   ServiceName,
    IN INT      IntervalMS,
    IN INT      TotalMS
    )
/*++
Routine Description:
    This routine determines if the specified NT service is in a running
    state or not. This function will sleep and retry once if the service
    is not yet running.

Arguments:
    MachineName     - machine to contact
    ServiceName     - Name of the NT service to interrogate.
    IntervalMS      - Check every IntervalMS milliseconds.
    TotalMS         - Stop checking after this long.

Return Value:
    TRUE    - Service is running.
    FALSE   - Service state cannot be determined.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsWaitService:"

    do {
        if (FrsIsServiceRunning(MachineName, ServiceName)) {
            return TRUE;
        }

        if (FrsIsShuttingDown) {
            break;
        }

        Sleep(IntervalMS);

    } while ((TotalMS -= IntervalMS) > 0);

    DPRINT2(0, ":SC: %ws is not running on %ws\n", ServiceName, ComputerName);

    return FALSE;
}





DWORD
FrsSetServiceStatus(
    IN DWORD    State,
    IN DWORD    CheckPoint,
    IN DWORD    Hint,
    IN DWORD    ExitCode
    )
/*++

Routine Description:

    Acquire the service lock, ServiceLock, and set the service's state
    using the global service handle and service status set in main.c.
    Check if this is a valid state transition using the lookup table.
    This will prevent the service from making any invalid state transitions.

Arguments:

    Status      - Set the state to this value
    Hint        - Suggested timeout for the service controller
    ExitCode    - For SERVICE_STOPPED;

Return Value:

    WIN32 STATUS

--*/
{
#undef DEBSUB
#define DEBSUB "FrsSetServiceStatus:"

    DWORD   WStatus = ERROR_SUCCESS;
    BOOL    Ret;
    DWORD   FromState,ToState;
    DWORD   TransitionCheck = FRS_SVC_TRANSITION_ILLEGAL;

    //
    // Set the service's status after acquiring the lock
    //
    if (RunningAsAService && HANDLE_IS_VALID(ServiceStatusHandle)) {

        EnterCriticalSection(&ServiceLock);
        //
        // Check if this is a valid service state transition.
        //
        for (FromState = 0 ; FromState < FRS_SVC_TRANSITION_TABLE_SIZE ; ++FromState) {
            for (ToState = 0 ; ToState < FRS_SVC_TRANSITION_TABLE_SIZE ; ++ToState) {
                if (StateTransitionLookup[FromState][0] == ServiceStatus.dwCurrentState &&
                    StateTransitionLookup[0][ToState] == State) {
                    TransitionCheck = StateTransitionLookup[FromState][ToState];
                    break;
                }
            }
        }

        if (TransitionCheck == FRS_SVC_TRANSITION_LEGAL) {
            DPRINT2(4,":SC: Current State = %d, Moving to %d\n", ServiceStatus.dwCurrentState, State);
            ServiceStatus.dwCurrentState = State;
            ServiceStatus.dwCheckPoint = CheckPoint;
            ServiceStatus.dwWaitHint = Hint;
            ServiceStatus.dwWin32ExitCode = ExitCode;
            //
            // Do not accept stop control unless the service is in SERVICE_RUNNING state.
            // This prevents the service from getting confused when a stop is called
            // while the service is starting.
            //
            if (ServiceStatus.dwCurrentState == SERVICE_RUNNING) {
                ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
            } else {
                ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_SHUTDOWN;
            }
            Ret = SetServiceStatus(ServiceStatusHandle, &ServiceStatus);

            if (!Ret) {
                WStatus = GetLastError();
                DPRINT1_WS(0, ":SC: ERROR - SetServiceStatus(%d);", ServiceStatus, WStatus);
            } else {
                DPRINT4(0, ":SC: SetServiceStatus(State %d, CheckPoint %d, Hint %d, ExitCode %d) succeeded\n",
                        State, CheckPoint, Hint, ExitCode);
            }
        } else if (TransitionCheck == FRS_SVC_TRANSITION_ILLEGAL) {
            DPRINT2(0,":SC: Error - Illegal service state transition request. From State = %d, To %d\n", ServiceStatus.dwCurrentState, State);
            WStatus = ERROR_INVALID_PARAMETER;
        }
        LeaveCriticalSection(&ServiceLock);
    }
    return WStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\util\eventlog.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    eventlog.c

Abstract:

    This module provides common eventlog services for the File Replication  service
    Stolen from the routine of the same name in the cluster service.

Author:

    John Vert (jvert) 9/13/1996
    RohanK  - Added Filter
    Davidor - Rewrite init using FrsRegistryKeyTable and CfgReg read/write functions.

Revision History:

--*/
#include <ntreppch.h>
#pragma  hdrstop

#include <frs.h>
#include <debug.h>

//
// Event Log Sources (NULL Terminated)
//

WORD FrsMessageIdToEventType[] = {
    EVENTLOG_SUCCESS,
    EVENTLOG_INFORMATION_TYPE,
    EVENTLOG_WARNING_TYPE,
    EVENTLOG_ERROR_TYPE
};


#define MESSAGEID_TO_EVENTTYPE(_id_) (FrsMessageIdToEventType[_id_ >> 30])


BOOL  EventLogRunning = FALSE;


DWORD
ELHashFunction (
    IN PVOID Qkey,
    IN ULONG len
    )

/*++

Routine Description:

    This is the hashing function used by the functions that Lookup,
    Add or Delete entries from the Hash Tables. The Key is a 64 bit
    number and the hashing function casts it to a 32 bit number and
    returns it as the hash value.

Arguments:

    QKey - Pointer to the Key to be hashed.
    len - Length of QKey (unused here).

Return Value:

    The hashed value of the Key.

--*/

{
#undef DEBSUB
#define DEBSUB "ELHashFunction:"

    ULONG key;    // hashed key value to be returned
    PULONGLONG p; // hash the key to PULONGLONG

    p = (PULONGLONG)Qkey;
    key = (ULONG)*p;
    return (key);
}



BOOL
FrsEventLogFilter(
    IN DWORD    EventMessageId,
    IN PWCHAR   *ArrOfPtrToArgs,
    IN DWORD    NumOfArgs
    )
/*++

Routine Description:

    This function is used to filter out eventlogs messages
    which have been already written to the EventLog in the
    last EVENTLOG_FILTER_TIME sec.
    This is done so that the eventlog does not get filled
    up with noisy similar messages.

Arguments:

    EventMessageId      -   Supplies the message ID to be logged.
    ArrOfPtrToArgs      -   Array of pointers to Arguments passed
                            in to the FrsEventLogx functions.
    NumOfArgs           -   The number of elements in the above
                            array

Return Value:

    TRUE          -   Print the entry in the eventlog
    FALSE         -   Do not print the entry

--*/

{
#undef DEBSUB
#define DEBSUB "FrsEventLogFilter:"

    DWORD i, j, sc = 0; // sc = shiftcount while calc the hash value
    ULONGLONG QKey = 0; // The hash key value
    ULONGLONG QVal = 0;
    DWORD GStatus;
    ULONGLONG Data;
    ULONG_PTR Flags;
    FILETIME CurrentTime;
    LARGE_INTEGER CT;
    LONGLONG TimeDiff = 0;

    DPRINT2(5, "ELOG:Filter Request came in with %08x args and an ID value of %08x\n",
            NumOfArgs, EventMessageId);

    //
    // Quit if event log not yet initialized.
    //
    if (!EventLogRunning) {
        return FALSE;
    }

    //
    // Calculate the hash key using the arguments that came in.
    // Assign the Id value to the QKey to start with.
    //
    QKey = EventMessageId;
    //
    // To calculate the value of QKey, every character of every argument
    // is taken, cast to a ULONGLONG left shifted by (0, 4, 8....60) and then
    // added to the value of QKey
    //
    for (i = 0; i < NumOfArgs; i++) {
        if (ArrOfPtrToArgs[i]) {
            for (j = 0; ArrOfPtrToArgs[i][j] != L'\0'; j++) {

                QVal = (ULONGLONG)ArrOfPtrToArgs[i][j];
                QVal = QVal << sc;
                sc += 4;

                if (sc >= 60) {
                    sc = 0;
                }

                QKey += QVal;
            }
        }
    }

    //
    // QKey should never be zero
    //
    if (QKey == 0) {
        QKey = EventMessageId;
    }

    //
    // Lookup this entry in the table.  If it exists, get the time associated
    // with this entry.  If the difference between the current time and the
    // time associated with the entry is greater than EVENTLOG_FILTER_TIME
    // sec, update the entry and return TRUE, otherwise return FALSE If the
    // entry for this key does not exist in the hash table, then this is the
    // first time this key is being written to the eventlog.  In this case,
    // add the entry to the hash table, associate the current time with it and
    // return TRUE
    //
    GStatus = QHashLookup(HTEventLogTimes, &(QKey), &Data, &Flags);
    if (GStatus == GHT_STATUS_SUCCESS) {
        //
        // Key exists, now compare the time values
        //
        GetSystemTimeAsFileTime(&CurrentTime);
        CT.LowPart = CurrentTime.dwLowDateTime;
        CT.HighPart = CurrentTime.dwHighDateTime;
        TimeDiff = ((((LONGLONG)CT.QuadPart) / (LONGLONG)CONVERTTOSEC) - (LONGLONG)Data);

        DPRINT1(5, "ELOG:The value of TimeDiff is %08x %08x\n", PRINTQUAD(TimeDiff));

        if (TimeDiff > EVENTLOG_FILTER_TIME) {
            //
            // UpDate the hash table entry. GetSystemTimeAsFileTime
            // retuns the time in 100 nano (100 * 10^9) sec units. Hence
            // to get it in sec we need to divide by (10^7)
            //
            Data = (((ULONGLONG)CT.QuadPart) / (ULONGLONG)CONVERTTOSEC);
            GStatus = QHashUpdate(HTEventLogTimes, &(QKey), &Data, Flags);
            if (GStatus == GHT_STATUS_FAILURE) {
                DPRINT2(5, "ELOG:QHashUpdate failed while updating ID %08x with QKey %08x %08x\n",
                   EventMessageId, PRINTQUAD(QKey));
            } else {
                DPRINT2(5, "ELOG:Update was successful for eventlog entry with ID %08x and QKey %08x %08x\n",
                        EventMessageId, PRINTQUAD(QKey));
            }
            return TRUE;
        }
        else {
            //
            // This event log entry should not be written
            //
            DPRINT2(5, "ELOG: Did not add the ID %08x with QKey %08x %08x to the EventLog\n",
                    EventMessageId, PRINTQUAD(QKey));
            return FALSE;
        }

    } else {
        //
        // Key does not exist
        // Create a new entry for it
        //
        DPRINT2(5, "ELOG:Got a new eventlog entry with ID %08x and QKey %08x %08x\n",
                EventMessageId, PRINTQUAD(QKey));
        //
        // Get the current system time
        //
        GetSystemTimeAsFileTime(&CurrentTime);
        CT.LowPart = CurrentTime.dwLowDateTime;
        CT.HighPart = CurrentTime.dwHighDateTime;
        //
        // GetSystemTimeAsFileTime retuns the time in 100 nano
        // (100 * 10^9) sec units. Hence to get it in sec we need to
        // divide by (10^7)
        //
        Data = (((ULONGLONG)CT.QuadPart) / (ULONGLONG)CONVERTTOSEC);
        //
        // Insert the new entry into the hash table
        //
        GStatus = QHashInsert(HTEventLogTimes, &QKey, &Data, 0, FALSE);
        if (GStatus == GHT_STATUS_FAILURE) {
            DPRINT2(5, "ELOG:QHashInsert failed while Inserting ID %08x with QKey %08x %08x\n",
                   EventMessageId, PRINTQUAD(QKey));
        } else {
            DPRINT2(5, "ELOG:Insert was successful for eventlog entry with ID %08x and QKey %08x %08x\n",
                    EventMessageId, PRINTQUAD(QKey));
        }
        return TRUE;
    }
}



VOID
InitializeEventLog(
    VOID
    )
/*++

Routine Description:

    Create the event log entry and setup the event log handle.

Arguments:

    None.

Return Value:

    None.

--*/

{
#undef DEBSUB
#define DEBSUB "InitializeEventLog:"

    DWORD   WStatus;
    PWCHAR  Path = NULL;
    HANDLE  hEventLog;
    HKEY    EventLogKey = 0;
    HKEY    FrsEventLogKey = 0;
    HKEY    FrsSourceKey = 0;

    //
    // create the hash table and assign the hash function.  The table
    // is used for storing eventlog times of similar messages. These
    // values of time are used in filtering these similar messages
    //
    HTEventLogTimes = FrsAllocTypeSize(QHASH_TABLE_TYPE, ELHASHTABLESIZE);
    SET_QHASH_TABLE_HASH_CALC(HTEventLogTimes, ELHashFunction);

    //
    // EventLog Key   -  <SERVICE_ROOT>\EventLog
    //
    WStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           EVENTLOG_ROOT,
                           0,
                           KEY_ALL_ACCESS,
                           &EventLogKey);
    CLEANUP1_WS(0, "WARN - Cannot open %ws;", EVENTLOG_ROOT, WStatus, CLEANUP);

    //
    // Set new eventlog source in the registry
    //
    WStatus = RegCreateKey(EventLogKey, SERVICE_LONG_NAME, &FrsEventLogKey);
    CLEANUP1_WS(0, "WARN - Cannot create %ws;", FRS_EVENTLOG_SECTION, WStatus, CLEANUP);

    //
    // Add the following values to the Reg key HKLM.....\EventLog\File Replication Service
    // 1. File 2. Retention 3. MaxSize
    //
    // If the values already exist then preserve them.
    //

    //
    // Event log file name  -- "%SystemRoot%\system32\config\NtFrs.Evt"
    //
    CfgRegWriteString(FKC_EVENTLOG_FILE,
                     SERVICE_LONG_NAME,
                     FRS_RKF_FORCE_DEFAULT_VALUE | FRS_RKF_KEEP_EXISTING_VALUE,
                     0);
    //
    // Retention
    //
    CfgRegWriteDWord(FKC_EVENTLOG_RETENTION,
                     SERVICE_LONG_NAME,
                     FRS_RKF_FORCE_DEFAULT_VALUE | FRS_RKF_KEEP_EXISTING_VALUE,
                     0);
    //
    // MaxSize
    //
    CfgRegWriteDWord(FKC_EVENTLOG_MAXSIZE,
                     SERVICE_LONG_NAME,
                     FRS_RKF_FORCE_DEFAULT_VALUE | FRS_RKF_KEEP_EXISTING_VALUE,
                     0);

    //
    // DisplayNameID
    //
    CfgRegWriteDWord(FKC_EVENTLOG_DISPLAY_NAMEID,
                     SERVICE_LONG_NAME,
                     FRS_RKF_FORCE_DEFAULT_VALUE | FRS_RKF_KEEP_EXISTING_VALUE,
                     0);

    //
    // DisplayNameFile
    //
    CfgRegWriteString(FKC_EVENTLOG_DISPLAY_FILENAME,
                      SERVICE_LONG_NAME,
                      FRS_RKF_FORCE_DEFAULT_VALUE | FRS_RKF_KEEP_EXISTING_VALUE,
                      NULL);

    //
    // Event Message File
    //
    WStatus = RegSetValueEx(FrsEventLogKey,
                            L"Sources",
                            0,
                            REG_MULTI_SZ,
                            (PCHAR)(SERVICE_NAME L"\0"
                                    SERVICE_LONG_NAME L"\0"),
                            (wcslen(SERVICE_NAME) +
                             wcslen(SERVICE_LONG_NAME) +
                             3) * sizeof(WCHAR));
    CLEANUP1_WS(0, "WARN - Cannot set event log value Sources for %ws;",
                SERVICE_LONG_NAME, WStatus, CLEANUP);

    //
    // Get the message file path. (expanding any environment vars).
    //
    CfgRegReadString(FKC_FRS_MESSAGE_FILE_PATH, NULL, 0, &Path);

    //
    // Add values for message file and event types for each event log source.
    //
    CfgRegWriteString(FKC_EVENTLOG_EVENT_MSG_FILE, SERVICE_NAME, 0, Path);

    CfgRegWriteString(FKC_EVENTLOG_EVENT_MSG_FILE, SERVICE_LONG_NAME, 0, Path);


    CfgRegWriteDWord(FKC_EVENTLOG_TYPES_SUPPORTED,
                     SERVICE_NAME,
                     FRS_RKF_FORCE_DEFAULT_VALUE,
                     0);

    CfgRegWriteDWord(FKC_EVENTLOG_TYPES_SUPPORTED,
                     SERVICE_LONG_NAME,
                     FRS_RKF_FORCE_DEFAULT_VALUE,
                     0);

    //
    // Unfortunately, this call will succeed with the Application log file
    // instead of the File Replication Log file if the EventLog service has not
    // yet reacted to the change notify of the updated registry keys above.
    // Hence, the source will be re-registered for each event so that ntfrs
    // events eventually show up in the file replication service log.  The
    // register/deregister pair allows EventLog some extra time so that MAYBE
    // the first event will show up in the right log.
    //
    // The eventlog folk may someday supply an interface to see if
    // the register was kicked into Application.
    //
    hEventLog = RegisterEventSource(NULL, SERVICE_NAME);
    if (hEventLog) {
        DeregisterEventSource(hEventLog);
    }

    WStatus = ERROR_SUCCESS;
    EventLogRunning = TRUE;
    DPRINT(0, "Event Log is running\n");

CLEANUP:
    DPRINT_WS(0, "ERROR - Cannot start event logging;", WStatus);

    if (EventLogKey) {
        RegCloseKey(EventLogKey);
    }
    if (FrsEventLogKey) {
        RegCloseKey(FrsEventLogKey);
    }
    FrsFree(Path);
}


DWORD
FrsReportEvent(
    IN DWORD    EventMessageId,
    IN PWCHAR  *ArgArray,
    IN DWORD    NumOfArgs
)
/*++

Routine Description:

    This function is used to register the event source and post the event.

    WARNING -- this function may be called from inside of DPRINTs. So
               do not call DPRINT (or any function referenced by
               DPRINT) from this function.

Arguments:

    EventMessageId      -   Supplies the message ID to be logged.
    ArgArray            -   Array of pointers to Arguments passed
                            in to the FrsEventLogx functions.
    NumOfArgs           -   The number of elements in the above
                            array

Return Value:

    Win32 Status.

--*/

{
#undef DEBSUB
#define DEBSUB "FrsReportEvent:"

    DWORD WStatus = ERROR_SUCCESS;
    HANDLE  hEventLog;
    UINT i;
    PWCHAR ResStr;

    WORD EventType;


    hEventLog = RegisterEventSource(NULL, SERVICE_NAME);

    if (!HANDLE_IS_VALID(hEventLog)) {
        WStatus = GetLastError();
        //DPRINT_WS(0, "WARN - Cannot register event source;", WStatus);
        return WStatus;
    }

    //
    // Check if any argument exceeds the 32K size limit. If it does then truncate it
    // and indicate that the event log message size has been exceeded.
    //
    for (i=0;i<NumOfArgs;++i) {
        if (wcslen(ArgArray[i]) > 32000/sizeof(WCHAR)) { //Each string has a limit of 32K bytes.
            ResStr = FrsGetResourceStr(IDS_EVENT_LOG_MSG_SIZE_EXCEEDED);
            wcscpy(&ArgArray[i][32000/sizeof(WCHAR) - 500], ResStr);
            FrsFree(ResStr);
        }
    }

    //
    //
    // The Event Type is is part of the message and should be one of the following:
    // EVENTLOG_ERROR_TYPE          Error event
    // EVENTLOG_WARNING_TYPE        Warning event
    // EVENTLOG_INFORMATION_TYPE    Information event
    // EVENTLOG_AUDIT_SUCCESS       Success Audit event
    // EVENTLOG_AUDIT_FAILURE       Failure Audit event
    //
    EventType = MESSAGEID_TO_EVENTTYPE(EventMessageId);

    //
    // Report the event.
    //
    if (!ReportEvent(hEventLog,         // handle returned by RegisterEventSource
                     EventType,         // event type to log
                     0,                 // event category
                     EventMessageId,    // event identifier
                     NULL,              // user security identifier (optional)
                     (WORD) NumOfArgs,  // number of strings to merge with message
                     0,                 // size of binary data, in bytes
                     ArgArray,          // array of strings to merge with message
                     NULL)) {           // address of binary data
        WStatus = GetLastError();
    }


    DeregisterEventSource(hEventLog);

    //DPRINT_WS(0, "Failed to report event log message. ID = %d (0x%08x).",
    //       EventMessageId, EventMessageId, WStatus);

    return WStatus;
}




/*++

Routine Description:

    The following functions Log an event to the event log with
    from zero to six insertion strings.

    WARNING -- these functions may be called from inside of DPRINTs. So
               do not call DPRINT (or any function referenced by
               DPRINT) from this function.

Arguments:

    EventMessageId      - Supplies the message ID to be logged.

    EventMessage1..6    - Insertion strings

Return Value:

    None.

--*/


VOID
FrsEventLog0(
    IN DWORD    EventMessageId
    )
{
#undef DEBSUB
#define DEBSUB "FrsEventLog0:"

    //
    // Check to see if this eventlog request can be filtered.
    //
    if (FrsEventLogFilter(EventMessageId, NULL, 0)) {
        FrsReportEvent(EventMessageId, NULL, 0);
    }
}





VOID
FrsEventLog1(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1
    )
{
#undef DEBSUB
#define DEBSUB "FrsEventLog1:"

    PWCHAR  ArgArray[1];


    //
    // Check to see if this eventlog request can be filtered.
    //
    ArgArray[0] = EventMessage1;
    if (FrsEventLogFilter(EventMessageId, ArgArray, 1)) {
        FrsReportEvent(EventMessageId, ArgArray, 1);
    }
}




VOID
FrsEventLog2(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1,
    IN PWCHAR   EventMessage2
    )
{
#undef DEBSUB
#define DEBSUB "FrsEventLog2:"

    PWCHAR  ArgArray[2];

    //
    // Check to see if this eventlog request can be filtered.
    //
    ArgArray[0] = EventMessage1;
    ArgArray[1] = EventMessage2;
    if (FrsEventLogFilter(EventMessageId, ArgArray, 2)) {
        FrsReportEvent(EventMessageId, ArgArray, 2);
    }
}




VOID
FrsEventLog3(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1,
    IN PWCHAR   EventMessage2,
    IN PWCHAR   EventMessage3
    )
{
#undef DEBSUB
#define DEBSUB "FrsEventLog3:"

    PWCHAR  ArgArray[3];

    //
    // Check to see if this eventlog request can be filtered.
    //
    ArgArray[0] = EventMessage1;
    ArgArray[1] = EventMessage2;
    ArgArray[2] = EventMessage3;

    if (FrsEventLogFilter(EventMessageId, ArgArray, 3)) {
        FrsReportEvent(EventMessageId, ArgArray, 3);
    }
}



VOID
FrsEventLog4(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1,
    IN PWCHAR   EventMessage2,
    IN PWCHAR   EventMessage3,
    IN PWCHAR   EventMessage4
    )
{
#undef DEBSUB
#define DEBSUB "FrsEventLog4:"

    PWCHAR  ArgArray[4];


    //
    // Check to see if this eventlog request can be filtered.
    //
    ArgArray[0] = EventMessage1;
    ArgArray[1] = EventMessage2;
    ArgArray[2] = EventMessage3;
    ArgArray[3] = EventMessage4;
    if (FrsEventLogFilter(EventMessageId, ArgArray, 4)) {
        FrsReportEvent(EventMessageId, ArgArray, 4);
    }
}





VOID
FrsEventLog5(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1,
    IN PWCHAR   EventMessage2,
    IN PWCHAR   EventMessage3,
    IN PWCHAR   EventMessage4,
    IN PWCHAR   EventMessage5
    )
{
#undef DEBSUB
#define DEBSUB "FrsEventLog5:"

    PWCHAR  ArgArray[5];


    //
    // Check to see if this eventlog request can be filtered.
    //
    ArgArray[0] = EventMessage1;
    ArgArray[1] = EventMessage2;
    ArgArray[2] = EventMessage3;
    ArgArray[3] = EventMessage4;
    ArgArray[4] = EventMessage5;
    if (FrsEventLogFilter(EventMessageId, ArgArray, 5)) {
        FrsReportEvent(EventMessageId, ArgArray, 5);
    }
}





VOID
FrsEventLog6(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1,
    IN PWCHAR   EventMessage2,
    IN PWCHAR   EventMessage3,
    IN PWCHAR   EventMessage4,
    IN PWCHAR   EventMessage5,
    IN PWCHAR   EventMessage6
    )

{
#undef DEBSUB
#define DEBSUB "FrsEventLog6:"

    PWCHAR  ArgArray[6];

    //
    // Check to see if this eventlog request can be filtered.
    //
    ArgArray[0] = EventMessage1;
    ArgArray[1] = EventMessage2;
    ArgArray[2] = EventMessage3;
    ArgArray[3] = EventMessage4;
    ArgArray[4] = EventMessage5;
    ArgArray[5] = EventMessage6;
    if (FrsEventLogFilter(EventMessageId, ArgArray, 6)) {
        FrsReportEvent(EventMessageId, ArgArray, 6);
    }
}




VOID
FrsEventLog7(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1,
    IN PWCHAR   EventMessage2,
    IN PWCHAR   EventMessage3,
    IN PWCHAR   EventMessage4,
    IN PWCHAR   EventMessage5,
    IN PWCHAR   EventMessage6,
    IN PWCHAR   EventMessage7
    )

{
#undef DEBSUB
#define DEBSUB "FrsEventLog7:"

    PWCHAR  ArgArray[7];

    //
    // Check to see if this eventlog request can be filtered.
    //
    ArgArray[0] = EventMessage1;
    ArgArray[1] = EventMessage2;
    ArgArray[2] = EventMessage3;
    ArgArray[3] = EventMessage4;
    ArgArray[4] = EventMessage5;
    ArgArray[5] = EventMessage6;
    ArgArray[6] = EventMessage7;
    if (FrsEventLogFilter(EventMessageId, ArgArray, 7)) {
        FrsReportEvent(EventMessageId, ArgArray, 7);
    }
}




VOID
FrsEventLog8(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1,
    IN PWCHAR   EventMessage2,
    IN PWCHAR   EventMessage3,
    IN PWCHAR   EventMessage4,
    IN PWCHAR   EventMessage5,
    IN PWCHAR   EventMessage6,
    IN PWCHAR   EventMessage7,
    IN PWCHAR   EventMessage8
    )

{
#undef DEBSUB
#define DEBSUB "FrsEventLog8:"

    PWCHAR  ArgArray[8];

    //
    // Check to see if this eventlog request can be filtered.
    //
    ArgArray[0] = EventMessage1;
    ArgArray[1] = EventMessage2;
    ArgArray[2] = EventMessage3;
    ArgArray[3] = EventMessage4;
    ArgArray[4] = EventMessage5;
    ArgArray[5] = EventMessage6;
    ArgArray[6] = EventMessage7;
    ArgArray[7] = EventMessage8;

    if (FrsEventLogFilter(EventMessageId, ArgArray, 8)) {
        FrsReportEvent(EventMessageId, ArgArray, 8);
    }
}



VOID
FrsEventLog9(
    IN DWORD    EventMessageId,
    IN PWCHAR   EventMessage1,
    IN PWCHAR   EventMessage2,
    IN PWCHAR   EventMessage3,
    IN PWCHAR   EventMessage4,
    IN PWCHAR   EventMessage5,
    IN PWCHAR   EventMessage6,
    IN PWCHAR   EventMessage7,
    IN PWCHAR   EventMessage8,
    IN PWCHAR   EventMessage9
    )

{
#undef DEBSUB
#define DEBSUB "FrsEventLog9:"

    PWCHAR  ArgArray[9];

    //
    // Check to see if this eventlog request can be filtered.
    //
    ArgArray[0] = EventMessage1;
    ArgArray[1] = EventMessage2;
    ArgArray[2] = EventMessage3;
    ArgArray[3] = EventMessage4;
    ArgArray[4] = EventMessage5;
    ArgArray[5] = EventMessage6;
    ArgArray[6] = EventMessage7;
    ArgArray[7] = EventMessage8;
    ArgArray[8] = EventMessage9;

    if (FrsEventLogFilter(EventMessageId, ArgArray, 9)) {
        FrsReportEvent(EventMessageId, ArgArray, 9);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\util\genhash.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    genhash.c

Abstract:

Generic Hash Table routines.  Each hash table is an array of FRS_LIST entries
that provide interlocked access to each row of the hash table.  Each table
is managed by a GENERIC_HASH_TABLE struct which holds function entry points for
freeing an entry, comparing keys, performing a hash calculation, printing
an entry and dumping the table.


Note:  All hash entries must be prefixed with GENERIC_HASH_ROW_ENTRY at the
beginning of the structure.

Author:

    David Orbits          [davidor]   22-Apr-1997

Environment:

    User Mode Service

Revision History:


--*/

#include <ntreppch.h>
#pragma  hdrstop

#include <frs.h>
#include <genhash.h>
#include <tablefcn.h>


#pragma warning( disable:4102)  // unreferenced label




PGENERIC_HASH_TABLE
GhtCreateTable(
    PCHAR ArgName,
    ULONG NumberRows,
    ULONG KeyOffset,
    ULONG KeyLength,
    PGENERIC_HASH_FREE_ROUTINE     GhtFree,
    PGENERIC_HASH_COMPARE_ROUTINE  GhtCompare,
    PGENERIC_HASH_CALC_ROUTINE     GhtHashCalc,
    PGENERIC_HASH_PRINT_ROUTINE    GhtPrint
    )
/*++

Routine Description:

    Allocate and initialize a hash table.

Arguments:

    ArgName     -- The table name.  [16 byte max]
    NumberRows  -- The number of rows in the table.
    KeyOffset   -- The byte offset to the key value in each table entry.
    KeyLength   -- The byte length of the key value in each table entry.
    GhtFree     -- function to call to free an entry.
    GhtCompare  -- function to comoare two keys.
    GhtHashCalc -- function to calculate the ULONG hash value on a key.
    GhtPrint    -- Function to print out a table entry.
    GhtDump     -- Function to call to dump all table entries.

Return Value:

    ptr to a GENERIC_HASH_TABLE struct or NULL if failure.
    use GetLastError for the error status.

--*/

{
#undef DEBSUB
#define  DEBSUB  "GhtCreateTable:"

    PGENERIC_HASH_TABLE HashTable;
    PGENERIC_HASH_ROW_ENTRY RowBase, HashRowEntry;
    ULONG NameLen;
    ULONG WStatus;
    ULONG i;


    HashTable = (PGENERIC_HASH_TABLE) FrsAllocType(GENERIC_HASH_TABLE_TYPE);

    RowBase = (PGENERIC_HASH_ROW_ENTRY) FrsAlloc(
        NumberRows * sizeof(GENERIC_HASH_ROW_ENTRY));

    NameLen = min(strlen(ArgName), 15);
    CopyMemory(HashTable->Name, ArgName, NameLen);
    HashTable->Name[NameLen] = '\0';

    HashTable->NumberRows      = NumberRows;
    HashTable->GhtFree         = GhtFree;
    HashTable->GhtCompare      = GhtCompare;
    HashTable->GhtHashCalc     = GhtHashCalc;
    HashTable->GhtPrint        = GhtPrint;
    HashTable->KeyOffset       = KeyOffset;
    HashTable->KeyLength       = KeyLength;
    HashTable->RowLockEnabled  = TRUE;
    HashTable->RefCountEnabled = TRUE;
    HashTable->HeapHandle      = NULL;
    HashTable->UseOffsets      = FALSE;
    HashTable->OffsetBase      = 0;
    HashTable->HashRowBase     = RowBase;
    HashTable->LockTimeout     = 10000;       // milliseconds

    //
    // Initialize all the hash table rows.  Each has a critical section and
    // an event to wait on.
    //
    HashRowEntry = RowBase;

    for (i=0; i<NumberRows; i++) {
        //
        // Create the event first so if we fail GhtDestroyTable sees a null handle.
        //
        //HashRowEntry->Event = CreateEvent(NULL, TRUE, FALSE, NULL);

        WStatus = FrsRtlInitializeList(&HashRowEntry->HashRow);
        if (WStatus != ERROR_SUCCESS) {
            goto CLEANUP;
        }

        //if (HashRowEntry->Event == NULL) {
        //    WStatus = GetLastError();
        //    goto CLEANUP;
        //}

        HashRowEntry += 1;
    }

    return HashTable;


CLEANUP:

    HashTable->NumberRows = i+1;
    GhtDestroyTable(HashTable);
    SetLastError(WStatus);
    return NULL;

}


VOID
GhtDestroyTable(
    PGENERIC_HASH_TABLE HashTable
    )
/*++

Routine Description:

    Free all the memory for a hash table.
    This includes any data elements left in the table.
    No locks are acquired.

Arguments:

    HashTable  --  ptr to a GENERIC_HASH_TABLE struct.

Return Value:

    None.

--*/

{
#undef DEBSUB
#define  DEBSUB  "GhtDestroyTable:"

    PGENERIC_HASH_ROW_ENTRY RowEntry;
    ULONG i;

    if (HashTable == NULL) {
        return;
    }

    RowEntry = HashTable->HashRowBase;
    DPRINT1(5, "GhtDestroyTable for %s\n", HashTable->Name);

    //
    // Loop through all the Hash table rows and delete any entries still on
    // each row.
    //
    for (i=0; i<HashTable->NumberRows; i++, RowEntry++) {
        if (RowEntry->HashRow.Count != 0) {
            //DPRINT2(5, "HashRow: %d, RowCount %d\n",i, RowEntry->HashRow.Count);
        }

        ForEachListEntryLock(&RowEntry->HashRow, GENERIC_HASH_ENTRY_HEADER, ListEntry,

            FrsRtlRemoveEntryListLock(&RowEntry->HashRow, &pE->ListEntry);

            //DPRINT4(5, "    Deleteing entry: %08x, Hval %08x, Index %d, refcnt %d\n",
            //       pE, pE->HashValue, i, pE->ReferenceCount);

            (HashTable->GhtFree)(HashTable, pE);
        );

        FrsRtlDeleteList(&RowEntry->HashRow);
        //if (RowEntry->Event != NULL) {
        //    FRS_CLOSE(RowEntry->Event);
        //}
    }

    FrsFree(HashTable->HashRowBase);
    FrsFreeType(HashTable);
    return;
}


ULONG
GhtCleanTableByFilter(
    PGENERIC_HASH_TABLE HashTable,
    IN PGENERIC_HASH_ENUM_ROUTINE Function,
    PVOID Context
    )
/*++

Routine Description:

    Free the elements in the hash table for which the predicate function
    returns TRUE.

Arguments:

    HashTable  --  ptr to a GENERIC_HASH_TABLE struct.
    Function - The function to call for each record in the table.  It is of
               of type PGENERIC_HASH_FILTER_ROUTINE.
               Return TRUE to delete the entry in the table.
    Context -- Arg to pass thru to the filter function.

Return Value:

    The number of entries deleted.

--*/

{
#undef DEBSUB
#define  DEBSUB  "GhtCleanTableByFilter:"

    PGENERIC_HASH_ROW_ENTRY RowEntry;
    ULONG i;
    ULONG Count = 0;

    if (HashTable == NULL) {
        return Count;
    }

    RowEntry = HashTable->HashRowBase;

    //
    // Loop through all the Hash table rows and delete any entries still on
    // each row.
    //
    for (i=0; i<HashTable->NumberRows; i++, RowEntry++) {
        if (RowEntry->HashRow.Count != 0) {
            //DPRINT2(4, "HashRow: %d, RowCount %d\n", i, RowEntry->HashRow.Count);
        }

        ForEachListEntry(&RowEntry->HashRow, GENERIC_HASH_ENTRY_HEADER, ListEntry,
            //
            // The iterator pE is of type GENERIC_HASH_ENTRY_HEADER.
            // Call predicate to see if we should do the delete.
            //
            if ((Function)(HashTable, pE, Context)) {

                FrsRtlRemoveEntryListLock(&RowEntry->HashRow, &pE->ListEntry);

                //DPRINT4(4, "Deleting entry: %08x, Hval %08x, Index %d, refcnt %d\n",
                //        pE, pE->HashValue, i, pE->ReferenceCount);

                (HashTable->GhtFree)(HashTable, pE);

                Count += 1;
            }
        );
    }

    return Count;
}



#if DBG
VOID
GhtDumpTable(
    ULONG Sev,
    PGENERIC_HASH_TABLE HashTable
    )
/*++

Routine Description:

    Call the print routine for each element in the table.

Arguments:

    Sev  -- DPRINT severity level.
    HashTable  --  ptr to a GENERIC_HASH_TABLE struct.

Return Value:

    None.

--*/

{
#undef DEBSUB
#define  DEBSUB  "GhtDumpTable:"

    PGENERIC_HASH_ROW_ENTRY HashRowEntry;
    ULONG i;

    HashRowEntry = HashTable->HashRowBase;
    DPRINT(Sev,"----------------------------------------------\n");
    DPRINT(Sev,"----------------------------------------------\n");
    DPRINT1(Sev, "GhtDumpTable for %s\n", HashTable->Name);
    DPRINT(Sev,"----------------------------------------------\n");
    DPRINT(Sev,"----------------------------------------------\n");

    //
    // Loop through all the Hash table rows and call the print function for
    // each element.
    //
    for (i=0; i<HashTable->NumberRows; i++) {
        if (HashRowEntry->HashRow.Count != 0) {
            DPRINT(Sev, " \n");
            DPRINT(Sev,"----------------------------------------------\n");
            DPRINT2(Sev, "HashRow: %d, RowCount %d\n",
                    i, HashRowEntry->HashRow.Count);
            DPRINT5(Sev, "Inserts: %d,  Removes: %d,  Compares: %d,  Lookups: %d,  Lookupfails: %d \n",
                     HashRowEntry->RowInserts,
                     HashRowEntry->RowRemoves,
                     HashRowEntry->RowCompares,
                     HashRowEntry->RowLookups,
                     HashRowEntry->RowLookupFails);
        }

        ForEachListEntry(&HashRowEntry->HashRow, GENERIC_HASH_ENTRY_HEADER, ListEntry,
            (HashTable->GhtPrint)(HashTable, pE);
        );

        HashRowEntry += 1;
    }
}
#endif DBG


ULONG_PTR
GhtEnumerateTable(
    IN PGENERIC_HASH_TABLE HashTable,
    IN PGENERIC_HASH_ENUM_ROUTINE Function,
    IN PVOID         Context
    )
/*++

Routine Description:

    This routine walks through the entries in a generic hash table and
    calls the function provided with the entry address and the context.
    No locks are taken by this function so the called function can make
    calls to other GHT routines to lookup or insert new entries.

    THis routine increments the ref count on each entry before it makes the
    call to ensure the entry does not vanish.  It keeps a pointer to the
    entry that tells it where to continue the scan.  If the argument function
    inserts an entry that is earlier in the table the enumeration will not
    pick it up.

Arguments:

    HashTable - The context of the Hash Table to enumerate.
    Function - The function to call for each record in the table.  It is of
               of type PGENERIC_HASH_ENUM_ROUTINE.  Return FALSE to abort the
               enumeration else true.
    Context - A context ptr to pass through to the RecordFunction.

Return Value:

    The status code from the argument function.

--*/

{
#undef DEBSUB
#define DEBSUB "GhtEnumerateTable:"


    PGENERIC_HASH_ROW_ENTRY RowEntry;
    ULONG i;
    ULONG_PTR WStatus;

    RowEntry = HashTable->HashRowBase;

    DPRINT(5,"----------------------------------------------\n");
    DPRINT(5,"----------------------------------------------\n");
    DPRINT1(5, "GhtEnumerateTable for %s\n", HashTable->Name);
    DPRINT(5,"----------------------------------------------\n");
    DPRINT(5,"----------------------------------------------\n");

    //
    // Loop through all the Hash table rows and call the print function for
    // each element.
    //
    for (i=0; i<HashTable->NumberRows; i++) {
        if (RowEntry->HashRow.Count != 0) {
            DPRINT(5, " \n");
            DPRINT(5,"----------------------------------------------\n");
            DPRINT2(5, "HashRow: %d, RowCount %d\n",
                    i, RowEntry->HashRow.Count);
        }

        ForEachListEntryLock(&RowEntry->HashRow, GENERIC_HASH_ENTRY_HEADER, ListEntry,

            InterlockedIncrement(&pE->ReferenceCount);
            DPRINT2(5, "inc ref: %08x, %d\n", pE, pE->ReferenceCount);

            WStatus = (Function)(HashTable, pE, Context);

            InterlockedDecrement(&pE->ReferenceCount);
            DPRINT2(5, "dec ref: %08x, %d\n", pE, pE->ReferenceCount);

            // Note: If caller needs this we should add code to check for
            // zero ref count and call the delete function.

            if( WStatus != 0 ) {
                return WStatus;
            }
        );

        RowEntry += 1;
    }

    return ERROR_SUCCESS;

}



ULONG_PTR
GhtEnumerateTableNoRef(
    IN PGENERIC_HASH_TABLE HashTable,
    IN PGENERIC_HASH_ENUM_ROUTINE Function,
    IN PVOID         Context
    )
/*++

Routine Description:

    This routine walks through the entries in a generic hash table and
    calls the function provided with the entry address and the context.
    No locks are taken by this function so the called function can make
    calls to other GHT routines to lookup or insert new entries.

    THis routine does not take a ref count out on the entry.
    It keeps a pointer to the next entry that tells it where to continue
    the scan if the argument function deletes the entry. If the argument function
    inserts an entry that is earlier in the table the enumeration will not
    pick it up.

Arguments:

    HashTable - The context of the Hash Table to enumerate.
    Function - The function to call for each record in the table.  It is of
               of type PGENERIC_HASH_ENUM_ROUTINE.  Return FALSE to abort the
               enumeration else true.
    Context - A context ptr to pass through to the RecordFunction.

Return Value:

    The status code from the argument function.

--*/

{
#undef DEBSUB
#define DEBSUB "GhtEnumerateTableNoRef:"


    PGENERIC_HASH_ROW_ENTRY RowEntry;
    ULONG i;
    ULONG_PTR WStatus;

    RowEntry = HashTable->HashRowBase;

    DPRINT1(5, "GhtEnumerateTableNoRef for %s\n", HashTable->Name);

    //
    // Loop through all the Hash table rows and call the print function for
    // each element.
    //
    for (i=0; i<HashTable->NumberRows; i++) {
        if (RowEntry->HashRow.Count != 0) {
            DPRINT(5, " \n");
            DPRINT(5,"----------------------------------------------\n");
            DPRINT2(5, "HashRow: %d, RowCount %d\n",
                    i, RowEntry->HashRow.Count);
        }

        ForEachListEntryLock(&RowEntry->HashRow, GENERIC_HASH_ENTRY_HEADER, ListEntry,

            WStatus = (Function)(HashTable, pE, Context);

            if (WStatus != 0) {
                return WStatus;
            }
        );

        RowEntry += 1;
    }

    return (ULONG_PTR)0;
}




PGENERIC_HASH_ENTRY_HEADER
GhtGetNextEntry(
    IN PGENERIC_HASH_TABLE HashTable,
    PGENERIC_HASH_ENTRY_HEADER HashEntry
    )
/*++

Routine Description:

    This routine returns the next entry in the table that follows the HashEntry
    argument.  If the HashEntry is NULL it returns the first entry.

    It gets the row lock containing the current entry, decrements the
    ref count on the entry.  It scans forward to the next entry in the table
    getting its row lock if needed, increments its ref count and returns the
    pointer.  If the end of table is reached NULL is returned.

    If an entry is inserted earlier in the table the enumeration will not
    pick it up.

Arguments:

    HashTable - The context of the Hash Table to enumerate.

    HashEntry - The current entry we are looking at.  Used to get the next entry
                If null start scan at beginning of table.

Return Value:

    The status code from the argument function.

--*/

{
#undef DEBSUB
#define DEBSUB "GhtGetNextEntry:"


    PGENERIC_HASH_ROW_ENTRY LastRow;
    ULONG Hval, HvalIndex;
    PGENERIC_HASH_ROW_ENTRY RowEntry;
    PLIST_ENTRY Entry;
    RowEntry = HashTable->HashRowBase;


    //
    // Get the hash value for the element and compute the index and RowEntry
    // address.  Then get the row lock.
    //
    if (HashEntry != NULL) {
        Hval = HashEntry->HashValue;
        HvalIndex = Hval % HashTable->NumberRows;
        RowEntry += HvalIndex;

        //
        // Get the row lock and decrement the ref count.
        // (could delete if it hits zero)
        //
        FrsRtlAcquireListLock(&RowEntry->HashRow);
        InterlockedDecrement(&HashEntry->ReferenceCount);
        //
        // look for next entry in same row.
        // if found, bump ref count, drop lock, return entry.
        //
        Entry = GetListNext(&HashEntry->ListEntry);
        if (Entry != &RowEntry->HashRow.ListHead) {
            goto FOUND;
        }
        //
        // if not found drop row lock and  execute scan code below
        // starting from next row entry.
        //
        FrsRtlReleaseListLock(&RowEntry->HashRow);
        RowEntry += 1;
    }

    //
    // Scan the rest of the table for a non-empty row.
    //
    LastRow = HashTable->HashRowBase + HashTable->NumberRows;

    while (RowEntry < LastRow) {

        if (RowEntry->HashRow.Count != 0) {
            //
            // Found one.  Get the row lock and recheck the count incase
            // someone beat us too it.
            //
            FrsRtlAcquireListLock(&RowEntry->HashRow);
            if (RowEntry->HashRow.Count == 0) {
                //
                // Too bad.  Continue scan.
                //
                FrsRtlReleaseListLock(&RowEntry->HashRow);
                RowEntry += 1;
                continue;
            }
            //
            // We got one. Get the entry address, bump the ref count, drop lock.
            //
            FRS_ASSERT(!IsListEmpty(&RowEntry->HashRow.ListHead));

            Entry = GetListHead(&RowEntry->HashRow.ListHead);
            goto FOUND;
        }

        RowEntry += 1;
    }

    return NULL;

FOUND:
    HashEntry = CONTAINING_RECORD(Entry, GENERIC_HASH_ENTRY_HEADER, ListEntry);
    InterlockedIncrement(&HashEntry->ReferenceCount);
    FrsRtlReleaseListLock(&RowEntry->HashRow);
    return HashEntry;

}


ULONG
GhtCountEntries(
    IN PGENERIC_HASH_TABLE HashTable
    )
/*++

Routine Description:

    This routine walks through the rows in a generic hash table and
    adds up the entry count.  It takes no locks so the count is approx.
    Caller must know the table can't go away.

Arguments:

    HashTable - The context of the Hash Table to count.

Return Value:

    The count.

--*/

{
#undef DEBSUB
#define DEBSUB "GhtCountEntries:"


    ULONG Total = 0;
    PGENERIC_HASH_ROW_ENTRY LastRow, RowEntry = HashTable->HashRowBase;

    //
    // Loop through all the Hash table rows and add counts.
    //

    LastRow = RowEntry + HashTable->NumberRows;

    while (RowEntry < LastRow) {
        Total += RowEntry->HashRow.Count;
        RowEntry += 1;
    }

    return Total;

}


PGENERIC_HASH_ENTRY_HEADER
GhtGetEntryNumber(
    IN PGENERIC_HASH_TABLE HashTable,
    IN LONG EntryNumber
    )
/*++

Routine Description:

    This routine walks through the rows in a generic hash table
    counting entries as it goes.  It returns the requested entry (by number)
    from the table.  Note this will not be the same entry from call to call
    because of intervening inserts and deletes.  It takes no locks until it
    gets to the row of the table that contains the entry.
    The ref count on the entry is incremented.

Arguments:

    HashTable - The context of the Hash Table to enumerate.

    EntryNumber - The ordinal number of the entry in the table.
                  zero is the first entry.

Return Value:

    The address of the entry.

--*/

{
#undef DEBSUB
#define DEBSUB "GhtGetEntryNumber:"


    PGENERIC_HASH_ROW_ENTRY LastRow, RowEntry = HashTable->HashRowBase;
    ULONG Rcount;
    PLIST_ENTRY Entry;
    PGENERIC_HASH_ENTRY_HEADER HashEntry;

    FRS_ASSERT(EntryNumber >= 0);

    //
    // Loop through Hash table rows looking for the row with the entry.
    //
    LastRow = RowEntry + HashTable->NumberRows;

    while (RowEntry < LastRow) {

        Rcount = RowEntry->HashRow.Count;

        if (Rcount > 0) {
            EntryNumber -= Rcount;
            if (EntryNumber < 0) {
                //
                // Should be in this row.  Get the row lock and recheck
                // the count incase someone beat us too it.
                //
                FrsRtlAcquireListLock(&RowEntry->HashRow);
                if (RowEntry->HashRow.Count < Rcount) {
                    //
                    // Too bad. It got shorter, Retry test.
                    //
                    FrsRtlReleaseListLock(&RowEntry->HashRow);
                    EntryNumber += Rcount;
                    continue;
                }

                //
                // We got one. Get the entry address, bump the ref count, drop lock.
                //
                EntryNumber += Rcount;
                Entry = GetListHead(&RowEntry->HashRow.ListHead);
                while (EntryNumber-- > 0) {
                    FRS_ASSERT(Entry != &RowEntry->HashRow.ListHead);
                    Entry = GetListNext(Entry);
                }

                HashEntry = CONTAINING_RECORD(Entry, GENERIC_HASH_ENTRY_HEADER, ListEntry);
                InterlockedIncrement(&HashEntry->ReferenceCount);
                FrsRtlReleaseListLock(&RowEntry->HashRow);
                return HashEntry;

            }
        }
        RowEntry += 1;
    }

    return NULL;

}



PGENERIC_HASH_ENTRY_HEADER
GhtQuickCheck(
    PGENERIC_HASH_TABLE HashTable,
    PGENERIC_HASH_ROW_ENTRY RowEntry,
    PGENERIC_HASH_ENTRY_HEADER HashEntry,
    ULONG Hval
    )
/*++

Routine Description:

    Internal function to do a quick scan of a row to find an entry.
    Used in debug code to check that an entry is actually in the table.


    Assumes caller has the row lock.

Arguments:

    HashTable  --  ptr to a GENERIC_HASH_TABLE struct.
    RowEntry -- ptr to the ROW_ENTRY struct.
    HashEntry -- ptr to the hash entry we are looking for.
    Hval -- hash value we are looking for.

Return Value:

    ptr to entry if we find it.
    NULL if we don't.

--*/
{
    PCHAR pKeyValue;

    pKeyValue = ((PCHAR)HashEntry) + HashTable->KeyOffset;

    ForEachListEntryLock(&RowEntry->HashRow, GENERIC_HASH_ENTRY_HEADER, ListEntry,
        //
        // The iterator pE is of type PGENERIC_HASH_ENTRY_HEADER.
        //
        if (pE->HashValue == Hval) {
            if ((HashTable->GhtCompare)(pKeyValue,
                                        ((PCHAR)pE) + HashTable->KeyOffset,
                                        HashTable->KeyLength)) {
                //
                // Found it.
                //
                return pE;
            }
        }
    );

    return NULL;
}


GHT_STATUS
GhtLookup2(
    PGENERIC_HASH_TABLE HashTable,
    PVOID pKeyValue,
    BOOL WaitIfLocked,
    PVOID *RetHashEntry,
    ULONG DupIndex
    )
/*++

Routine Description:

Takes the KeyValue and calls the hash function which returns a ULONG.  Then
calculate the index of HashValue Mod TableLenth.  With the index find the hash
row header and acquire the row lock.  It then walks the list looking for a hash
value match on the KeyValue.  The entires are kept in ascending order so the
lookup stops as soon as new entry value is < the list entry value.  Then call
the compare routine to see if the key data in the entry (entry+key offset)
matches the keyValue passed in.  If it matches, the ref count in the entry is
bumped and the address is returned.

If there are duplicate entries then the ptr to the nth oldest duplicate is
returned where n is supplied by DupIndex.  A value of 0 for DupIndex means
return the last duplicate in the list.  This is the most recent duplicate
inserted since insert puts new entries at the end of the duplicate group.  A
value of one returns the oldest duplicate as determined by time of insert.


TBI -
If the row is locked and WaitIfLocked is TRUE then we wait on the row event.
If the row is locked and WaitIfLocked is FALSE then return status
GHT_STATUS_LOCKCONFLICT.  In this case you can't tell if the entry is in
the table.

Arguments:

    HashTable  --  ptr to a GENERIC_HASH_TABLE struct.
    pKeyValue  -- ptr to the keyValue we are looking for.
    WaitIfLocked  -- True means wait if the row is locked.
    RetHashEntry -- Returned ptr if found or NULL.
    DupIndex -- return the nth duplicate, if 0 return last duplicate in list.

Return Value:

    GHT_STATUS_NOT_FOUND -- if not found.
    GHT_STATUS_SUCCESS -- if found.

--*/

{
#undef DEBSUB
#define  DEBSUB  "GhtLookup2:"

    ULONG GStatus;
    ULONG Hval, HvalIndex;
    PGENERIC_HASH_ROW_ENTRY RowEntry;
    PGENERIC_HASH_ENTRY_HEADER LastFoundpE = NULL;

    // Note: Get lock earlier if table resize support is added.

    if (pKeyValue == NULL) {
        *RetHashEntry = NULL;
        return GHT_STATUS_NOT_FOUND;
    }
    //
    // Compute the hash index and calculate the row pointer.
    //
    Hval = (HashTable->GhtHashCalc)(pKeyValue, HashTable->KeyLength);
    HvalIndex = Hval % HashTable->NumberRows;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    if (FrsRtlCountList(&RowEntry->HashRow) == 0) {
        *RetHashEntry = NULL;
        RowEntry->RowLookupFails += 1;
        return GHT_STATUS_NOT_FOUND;
    }

    if (DupIndex == 0) {
        DupIndex = 0xFFFFFFFF;
    }


    FrsRtlAcquireListLock(&RowEntry->HashRow);
    //
    // Walk the list looking for a match on the
    // the hash value then try and match the KeyValue.
    //
    ForEachListEntryLock(&RowEntry->HashRow, GENERIC_HASH_ENTRY_HEADER, ListEntry,
        //
        // The iterator pE is of type PGENERIC_HASH_ENTRY_HEADER.
        //
        RowEntry->RowCompares += 1;
        if (Hval < pE->HashValue) {
            //
            // Not on the list.
            //
            break;
        }

        if (pE->HashValue == Hval) {
            if ((HashTable->GhtCompare)(pKeyValue,
                                        ((PCHAR)pE) + HashTable->KeyOffset,
                                        HashTable->KeyLength)) {
                //
                // Found it.  Check DupIndex count.
                //
                RowEntry->RowLookups += 1;
                LastFoundpE = pE;
                if (--DupIndex == 0) {
                    break;
                }
            }
        }
    );


    if (LastFoundpE != NULL) {
        //
        // Found one.  Bump ref count, release the lock, return success.
        //
        InterlockedIncrement(&LastFoundpE->ReferenceCount);
        DPRINT2(5, ":: inc ref: %08x, %d\n", LastFoundpE, LastFoundpE->ReferenceCount);
        GStatus = GHT_STATUS_SUCCESS;
    } else {
        RowEntry->RowLookupFails += 1;
        GStatus = GHT_STATUS_NOT_FOUND;
    }

    ReleaseListLock(&RowEntry->HashRow);
    *RetHashEntry = LastFoundpE;
    return GStatus;
}



GHT_STATUS
GhtInsert(
    PGENERIC_HASH_TABLE HashTable,
    PVOID HashEntryArg,
    BOOL WaitIfLocked,
    BOOL DuplicatesOk
    )
/*++

Routine Description:

Inserts a HashEntry into the HashTable.  It calls the hash function with a ptr
to the key data (HashEntry+key offset) which returns a ULONG that is stored in
HashEntry.HashValue.  Insert then calculates the index of HashValue Mod
TableLenth.  With the index it finds the hash row header and acquires the row
lock.  It then walks the list looking for a hash value match.  The entires are
kept in ascending order so the lookup stops as soon as new entry value is < the
list entry value.  It then inserts the entry in the table, updates the counts in
the row header, releases the lock and returns.  If it finds a match it calls the
user compare function with HashEntry+offset and ListEntry+offset to validate the
match.  The validate returns true if it matches and false if it fails (i.e.
continue walking the list).  Duplicates are allowed when DuplicatesOk is True.
Insert returns GHT_STATUS_SUCCESS if the entry was inserted and
GHT_STATUS_FAILURE if this is a duplicate node and DuplicatesOk is False (the
compare function returned TRUE).  The refcount is incremented if the node was
inserted.


Note:  All hash entries must be prefixed with GENERIC_HASH_ROW_ENTRY at the
beginning of the structure.

TBI -
If the row is locked and WaitIfLocked is FALSE then return status
GHT_STATUS_LOCKCONFLICT else wait on the row.

Arguments:

    HashTable  --  ptr to a GENERIC_HASH_TABLE struct.
    HashEntryArg -- ptr to new entry to insert.
    WaitIfLocked  -- True means wait if the row is locked.
    DuplicatesOk  -- True means duplicate entries are ok.  They are placed at
                     the end of the list of duplicates.

Return Value:

    GHT_STATUS_FAILURE -- Conflicting entry is in table already.
    GHT_STATUS_SUCCESS -- Insert was successful.


--*/

{
#undef DEBSUB
#define  DEBSUB  "GhtInsert:"

    ULONG Hval, HvalIndex;
    PGENERIC_HASH_ROW_ENTRY RowEntry;
    PVOID pKeyValue;
    PLIST_ENTRY BeforeEntry;
    PGENERIC_HASH_ENTRY_HEADER HashEntry =
        (PGENERIC_HASH_ENTRY_HEADER)HashEntryArg;


    //
    // Compute the hash value on the key in the entry.
    //
    pKeyValue = ((PCHAR)HashEntry) + HashTable->KeyOffset;
    Hval = (HashTable->GhtHashCalc)(pKeyValue, HashTable->KeyLength);
    HashEntry->HashValue = Hval;

    //
    // Compute the index and calculate the row pointer.
    //

    HvalIndex = Hval % HashTable->NumberRows;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    FrsRtlAcquireListLock(&RowEntry->HashRow);

    BeforeEntry = &RowEntry->HashRow.ListHead;   // incase of empty list.

    //
    // Walk the list with the lock looking for a match on the
    // the hash value then try and match the KeyValue.
    //
    ForEachListEntryLock(&RowEntry->HashRow, GENERIC_HASH_ENTRY_HEADER, ListEntry,

        RowEntry->RowCompares += 1;
        if (Hval < pE->HashValue) {
            //
            // Not on the list.  Put new entry before this one.
            //
            BeforeEntry = &pE->ListEntry;
            break;
        }

        if (pE->HashValue == Hval) {
            if ((HashTable->GhtCompare)(pKeyValue,
                                        ((PCHAR)pE) + HashTable->KeyOffset,
                                        HashTable->KeyLength)) {
                //
                // Found it.  Release the lock and return failure if no
                // duplicates are allowed.
                //
                if (!DuplicatesOk) {
                    FrsRtlReleaseListLock(&RowEntry->HashRow);
                    return GHT_STATUS_FAILURE;
                }
            }
        }
    );

    //
    // Put new entry on the list in front of 'BeforeEntry'.
    //
    InterlockedIncrement(&HashEntry->ReferenceCount);
    DPRINT2(5, ":: inc ref: %08x, %d\n", HashEntry, HashEntry->ReferenceCount);
    RowEntry->RowInserts += 1;

    FrsRtlInsertBeforeEntryListLock( &RowEntry->HashRow,
                                     BeforeEntry,
                                     &HashEntry->ListEntry);

    FrsRtlReleaseListLock(&RowEntry->HashRow);
    return GHT_STATUS_SUCCESS;

}


GHT_STATUS
GhtDeleteEntryByAddress(
    PGENERIC_HASH_TABLE HashTable,
    PVOID HashEntryArg,
    BOOL WaitIfLocked
    )
/*++

Routine Description:

Takes HashEntry address and fetches the hash value to acquire the row lock.
Decrement the reference count and if it is one (the count for being in the
table) remove the entry from the row and call the memory free function to
release the entries memory.  Drop the row lock.  Return GHT_STATUS_SUCCESS if we
deleted the entry.

TBI -
Return GHT_STATUS_LOCKCONFLICT if we failed to get the lock and
WaitIfLocked was FALSE.

Note: This function is only safe if you have a reference on the entry otherwise
another thread could have already deleted the entry and your entry address is
pointing at freed memory.

Arguments:

    HashTable  --  ptr to a GENERIC_HASH_TABLE struct.
    HashEntryArg -- ptr to entry to delete.
    WaitIfLocked  -- True means wait if the row is locked.



Return Value:

    GHT_STATUS_FAILURE -- Entry was not deleted.
    GHT_STATUS_SUCCESS -- Entry was deleted.

--*/

{
#undef DEBSUB
#define  DEBSUB  "GhtDeleteEntryByAddress:"

    ULONG Hval, HvalIndex;
    PGENERIC_HASH_ROW_ENTRY RowEntry;
    BOOL Found;
    ULONG GhtStatus;
    LONG  NewCount;
    PGENERIC_HASH_ENTRY_HEADER HashEntry =
        (PGENERIC_HASH_ENTRY_HEADER)HashEntryArg;


    GhtStatus = GHT_STATUS_FAILURE;

    //
    // Get the hash value for the element and compute the index and RowEntry
    // address.  Then get the row lock.
    //
    Hval = HashEntry->HashValue;
    HvalIndex = Hval % HashTable->NumberRows;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    FrsRtlAcquireListLock(&RowEntry->HashRow);


#if DBG
    //
    // check if the entry is actually on the List.
    //
    // Walk the list with the lock looking for a match on the
    // the hash value then try and match the KeyValue.
    //
    Found = GhtQuickCheck(HashTable, RowEntry, HashEntry, Hval) != NULL;
    if (!Found) {
        DPRINT4(0, "GhtDeleteEntryByAddress - entry not on list %08x, %08x, %d, %s\n",
                HashEntry, Hval, HvalIndex, HashTable->Name);
        FRS_ASSERT(!"entry not on list");
        FrsRtlReleaseListLock(&RowEntry->HashRow);
        return GHT_STATUS_FAILURE;
    }
#endif


    //
    // Decrement the ref count.
    //
    NewCount = InterlockedDecrement(&HashEntry->ReferenceCount);
    DPRINT2(5, ":: dec ref: %08x, %d\n", HashEntry, HashEntry->ReferenceCount);

    if (NewCount <= 0) {
        DPRINT4(0, "GhtDeleteEntryByAddress - ref count equal zero: %08x, %08x, %d, %s\n",
                HashEntry, Hval, HvalIndex, HashTable->Name);
        FRS_ASSERT(!"ref count <= zero");
        FrsRtlReleaseListLock(&RowEntry->HashRow);
        return GHT_STATUS_FAILURE;
    }

    if (NewCount == 1) {
        //
        // Ref count zero.  Remove and free the entry.
        //
        FrsRtlRemoveEntryListLock(&RowEntry->HashRow, &HashEntry->ListEntry);
        (HashTable->GhtFree)(HashTable, HashEntry);
        GhtStatus = GHT_STATUS_SUCCESS;
    }


    FrsRtlReleaseListLock(&RowEntry->HashRow);

    return GhtStatus;
}



GHT_STATUS
GhtRemoveEntryByAddress(
    PGENERIC_HASH_TABLE HashTable,
    PVOID HashEntryArg,
    BOOL WaitIfLocked
    )
/*++

Routine Description:

Takes HashEntry address and fetches the hash value to acquire the row lock.
Remove the entry from the table.  The reference count is decremented.

Return GHT_STATUS_SUCCESS.

TBI -
Return GHT_STATUS_LOCKCONFLICT if we failed to get the lock and
WaitIfLocked was FALSE.

Note: This function is only safe if you have a reference on the entry otherwise
another thread could have already deleted the entry and your entry address is
pointing at freed memory.

Also Note:  The caller must have a lock that prevents other threads from
changing the entry.  In addition removing an entry from one hash table and
inserting it on another will confuse another thread that may be accessing the
entry so the caller better be sure that no other thread assumes the hash
table can't change while it has a reference to the entry.

Arguments:

    HashTable  --  ptr to a GENERIC_HASH_TABLE struct.
    HashEntryArg -- ptr to entry to delete.
    WaitIfLocked  -- True means wait if the row is locked.



Return Value:

    GHT_STATUS_SUCCESS -- if the entry was removed successfully.
    GHT_STATUS_FAILURE -- if the entry was not on the list.

--*/

{
#undef DEBSUB
#define  DEBSUB  "GhtRemoveEntryByAddress:"

    ULONG Hval, HvalIndex;
    PGENERIC_HASH_ROW_ENTRY RowEntry;
    BOOL Found;
    LONG NewCount;
    PGENERIC_HASH_ENTRY_HEADER HashEntry =
        (PGENERIC_HASH_ENTRY_HEADER)HashEntryArg;


    //
    // Get the hash value for the element and compute the index and RowEntry
    // address.  Then get the row lock.
    //
    Hval = HashEntry->HashValue;
    HvalIndex = Hval % HashTable->NumberRows;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    FrsRtlAcquireListLock(&RowEntry->HashRow);


#if DBG
    //
    // check if the entry is actually on the List.
    //
    // Walk the list with the lock looking for a match on the
    // the hash value then try and match the KeyValue.
    //
    Found = GhtQuickCheck(HashTable, RowEntry, HashEntry, Hval) != NULL;
    if (!Found) {
        DPRINT4(0, "GhtRemoveEntryByAddress - entry not on list %08x, %08x, %d, %s\n",
                HashEntry, Hval, HvalIndex, HashTable->Name);
        FRS_ASSERT(!"entry not on list-2");
        FrsRtlReleaseListLock(&RowEntry->HashRow);
        return GHT_STATUS_FAILURE;
    }
#endif


    //
    // Decrement the ref count.
    //
    NewCount = InterlockedDecrement(&HashEntry->ReferenceCount);
    DPRINT2(5, ":: dec ref: %08x, %d\n", HashEntry, HashEntry->ReferenceCount);

    if (NewCount < 0) {
        DPRINT4(0, ":: ERROR- GhtRemoveEntryByAddress - ref count less than zero: %08x, %08x, %d, %s\n",
                HashEntry, Hval, HvalIndex, HashTable->Name);
        FRS_ASSERT(!"ref count less than zero-2");
        FrsRtlReleaseListLock(&RowEntry->HashRow);
        return GHT_STATUS_FAILURE;
    }

    if (NewCount > 1) {
        //
        // Other Refs than the caller's exist.  Print a warning.
        //
        DPRINT5(1, ":: WARNING- GhtRemoveEntryByAddress - ref count(%d) > 1: %08x, %08x, %d, %s\n",
                NewCount, HashEntry, Hval, HvalIndex, HashTable->Name);
    }

    FrsRtlRemoveEntryListLock(&RowEntry->HashRow, &HashEntry->ListEntry);

    FrsRtlReleaseListLock(&RowEntry->HashRow);

    return GHT_STATUS_SUCCESS;
}



GHT_STATUS
GhtReferenceEntryByAddress(
    PGENERIC_HASH_TABLE HashTable,
    PVOID HashEntryArg,
    BOOL WaitIfLocked
    )
/*++

Routine Description:

Takes HashEntry address and fetches the hash value to acquire the row lock.
Increment the reference count.  Drop the row lock.

TBI -
Return GHT_STATUS_LOCKCONFLICT if we failed to get the lock and
WaitIfLocked was FALSE.

Note: This function is only safe if you have a reference on the entry otherwise
another thread could have already deleted the entry and your entry address is
pointing at freed memory.  A Lookup which gave you the address bumps the
reference count.  An insert in which you kept the address does NOT bump
the reference count.

Arguments:

    HashTable  --  ptr to a GENERIC_HASH_TABLE struct.
    HashEntryArg -- ptr to entry to reference.
    WaitIfLocked  -- True means wait if the row is locked.

Return Value:

    GHT_STATUS_SUCCESS

--*/

{
#undef DEBSUB
#define  DEBSUB  "GhtReferenceEntryByAddress:"

    ULONG Hval, HvalIndex;
    PGENERIC_HASH_ROW_ENTRY RowEntry;
    BOOL Found;
    PGENERIC_HASH_ENTRY_HEADER HashEntry =
        (PGENERIC_HASH_ENTRY_HEADER)HashEntryArg;

    //
    // Get the hash value for the element and compute the index and RowEntry
    // address.  Then get the row lock.
    //
    Hval = HashEntry->HashValue;
    HvalIndex = Hval % HashTable->NumberRows;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    FrsRtlAcquireListLock(&RowEntry->HashRow);


#if DBG
    //
    // check if the entry is actually on the List.
    //
    // Walk the list with the lock looking for a match on the
    // the hash value then try and match the KeyValue.
    //
    Found = GhtQuickCheck(HashTable, RowEntry, HashEntry, Hval) != NULL;
    if (!Found) {
        DPRINT4(0, "GhtReferenceEntryByAddress - entry not on list %08x, %08x, %d, %s\n",
                HashEntry, Hval, HvalIndex, HashTable->Name);
        FRS_ASSERT(!"entry not on list-3");
        FrsRtlReleaseListLock(&RowEntry->HashRow);
        return GHT_STATUS_FAILURE;
    }
#endif


    //
    // Increment the ref count.
    //
    InterlockedIncrement(&HashEntry->ReferenceCount);
    DPRINT2(5, ":: inc ref: %08x, %d\n", HashEntry, HashEntry->ReferenceCount);

    FrsRtlReleaseListLock(&RowEntry->HashRow);

    return GHT_STATUS_SUCCESS;
}



GHT_STATUS
GhtDereferenceEntryByAddress(
    PGENERIC_HASH_TABLE HashTable,
    PVOID HashEntryArg,
    BOOL WaitIfLocked
    )
/*++

Routine Description:

Takes HashEntry address and fetches the hash value to acquire the row lock.
Decrement the reference count.  Drop the row lock.

TBI -
Return GHT_STATUS_LOCKCONFLICT if we failed to get the lock and
WaitIfLocked was FALSE.

Note: This function is only safe if you have a reference on the entry otherwise
another thread could have already deleted the entry and your entry address is
pointing at freed memory.  A Lookup which gave you the address bumps the
reference count.  An insert in which you kept the address does NOT bump
the reference count.

Arguments:

    HashTable  --  ptr to a GENERIC_HASH_TABLE struct.
    HashEntryArg -- ptr to entry to reference.
    WaitIfLocked  -- True means wait if the row is locked.

Return Value:

    GHT_STATUS_SUCCESS

--*/
{
#undef DEBSUB
#define  DEBSUB  "GhtDereferenceEntryByAddress:"

    ULONG Hval, HvalIndex;
    PGENERIC_HASH_ROW_ENTRY RowEntry;
    BOOL Found;
    LONG NewCount;
    PGENERIC_HASH_ENTRY_HEADER HashEntry =
        (PGENERIC_HASH_ENTRY_HEADER)HashEntryArg;


    //
    // Get the hash value for the element and compute the index and RowEntry
    // address.  Then get the row lock.
    //
    Hval = HashEntry->HashValue;
    HvalIndex = Hval % HashTable->NumberRows;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    FrsRtlAcquireListLock(&RowEntry->HashRow);


#if DBG
    //
    // check if the entry is actually on the List.
    //
    // Walk the list with the lock looking for a match on the
    // the hash value then try and match the KeyValue.
    //
    Found = GhtQuickCheck(HashTable, RowEntry, HashEntry, Hval) != NULL;
    if (!Found) {
        DPRINT4(0, "GhtDereferenceEntryByAddress - entry not on list %08x, %08x, %d, %s\n",
                HashEntry, Hval, HvalIndex, HashTable->Name);
        FRS_ASSERT(!"entry not on list-4");
        FrsRtlReleaseListLock(&RowEntry->HashRow);
        return GHT_STATUS_FAILURE;
    }
#endif


    //
    // Decrement the ref count.
    //
    NewCount = InterlockedDecrement(&HashEntry->ReferenceCount);
    DPRINT2(5, ":: dec ref: %08x, %d\n", HashEntry, HashEntry->ReferenceCount);

    if (NewCount <= 0) {
        DPRINT4(0, "GhtDereferenceEntryByAddress - ref count now zero: %08x, %08x, %d, %s\n",
                HashEntry, Hval, HvalIndex, HashTable->Name);
        FRS_ASSERT(!"ref count now zero-4");
        FrsRtlReleaseListLock(&RowEntry->HashRow);
        return GHT_STATUS_FAILURE;
    }

    FrsRtlReleaseListLock(&RowEntry->HashRow);

    return GHT_STATUS_SUCCESS;
}




GHT_STATUS
GhtAdjustRefCountByKey(
    PGENERIC_HASH_TABLE HashTable,
    PVOID pKeyValue,
    LONG Delta,
    ULONG ActionIfZero,
    BOOL WaitIfLocked,
    PVOID *RetHashEntry
    )
/*++

Routine Description:

Takes keyvalue, finds the HashEntry address and adds Delta to
the reference count.  Drop the row lock.

** WARNING **
If you allow duplicate entries in the hash table this routine will not work
because you can't guarantee that you will adjust a given entry.

TBI -
Return GHT_STATUS_LOCKCONFLICT if we failed to get the lock and
WaitIfLocked was FALSE.

Arguments:

    HashTable     -- ptr to a GENERIC_HASH_TABLE struct.
    pKeyValue     -- ptr to a datavalue for the key.
    Delta         -- The amount of the ref count adjustment.
    ActionIfZero  -- If RC is zero Choice of nothing, remove, remove and delete.
    WaitIfLocked  -- True means wait if the row is locked.
    RetHashEntry  -- If GHT_ACTION_REMOVE requested, the hash entry
                     address is returned if element removed else NULL returned.

Return Value:

    GHT_STATUS_SUCCESS
    GHT_STATUS_NOT_FOUND

--*/
{
#undef DEBSUB
#define  DEBSUB  "GhtDecrementRefCountByKey:"


    ULONG Hval, HvalIndex;
    PGENERIC_HASH_ROW_ENTRY RowEntry;
    LONG NewCount;

    if (ActionIfZero == GHT_ACTION_REMOVE) {
        *RetHashEntry = NULL;
    }

    // Note: Get lock earlier if table resize support is added.
    //
    // Compute the hash index and calculate the row pointer.
    //
    Hval = (HashTable->GhtHashCalc)(pKeyValue, HashTable->KeyLength);
    HvalIndex = Hval % HashTable->NumberRows;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    if (FrsRtlCountList(&RowEntry->HashRow) == 0) {
        RowEntry->RowLookupFails += 1;
        return GHT_STATUS_NOT_FOUND;
    }

    //
    // Walk the list with the lock looking for a match on the
    // the hash value then try and match the KeyValue.
    //
    ForEachListEntry(&RowEntry->HashRow, GENERIC_HASH_ENTRY_HEADER, ListEntry,
        //
        // pE is iterator of type GENERIC_HASH_ENTRY_HEADER.
        //
        RowEntry->RowCompares += 1;
        if (pE->HashValue == Hval) {
            if ((HashTable->GhtCompare)(pKeyValue,
                                        ((PCHAR)pE) + HashTable->KeyOffset,
                                        HashTable->KeyLength)) {
                //
                // Found it.  Adjust ref count,
                //
                NewCount = InterlockedExchangeAdd(&pE->ReferenceCount, Delta);
                DPRINT2(5, ":: adj ref: %08x, %d\n", pE, pE->ReferenceCount);
                RowEntry->RowLookups += 1;
                if (NewCount <= 0) {
                    if (NewCount < 0) {
                        DPRINT4(0, "GhtDecrementRefCountByKey - ref count neg: %08x, %08x, %d, %s\n",
                                pE, Hval, HvalIndex, HashTable->Name);
                        FRS_ASSERT(!"ref count neg-5");
                        ReleaseListLock(&RowEntry->HashRow);
                        return GHT_STATUS_FAILURE;
                    }

                    //
                    // Ref count zero.  Optionally remove and free the entry.
                    //
                    if (ActionIfZero == GHT_ACTION_REMOVE) {
                        *RetHashEntry = pE;
                        FrsRtlRemoveEntryListLock(&RowEntry->HashRow, &pE->ListEntry);
                    } else

                    if (ActionIfZero == GHT_ACTION_DELETE) {
                        (HashTable->GhtFree)(HashTable, pE);
                    } else {

                        //
                        // Not good.  Action was noop so refcount expected to
                        // be > 0.
                        //
                        DPRINT4(0, "GhtDecrementRefCountByKey - ref count zero with Noop Action: %08x, %08x, %d, %s\n",
                                pE, Hval, HvalIndex, HashTable->Name);
                        FRS_ASSERT(!"ref count zero-6");
                        ReleaseListLock(&RowEntry->HashRow);
                        return GHT_STATUS_FAILURE;
                    }
                }

                ReleaseListLock(&RowEntry->HashRow);
                return GHT_STATUS_SUCCESS;
            }
        }
    );

    RowEntry->RowLookupFails += 1;
    return GHT_STATUS_NOT_FOUND;

}




GHT_STATUS
GhtSwapEntryByAddress(
    PGENERIC_HASH_TABLE HashTable,
    PVOID OldHashEntryArg,
    PVOID NewHashEntryArg,
    BOOL WaitIfLocked
    )
/*++

Routine Description:

This routine replaces an existing old hash entry with a new entry.
It verifies tha the old hash entry is still in the table.
It assumes that the key value of the new entry is the same as the old entry.
NO CHECK IS MADE.

The expected use is when the caller needs to reallocate an entry with
more storage.

NOTE ALSO:  The reference count is copied from the old entry to the new one.
Using this routine means that the caller is using  GhtDecrementRefCountByKey()
and GhtIncrementRefCountByKey() to access the ref counts on any element in the
table since the entry could get swapped making the pointer invalid.

TBI -
Return GHT_STATUS_LOCKCONFLICT if we failed to get the lock and
WaitIfLocked was FALSE.

Note: This function is only safe if you have a reference on the entry otherwise
another thread could have already deleted the entry and your entry address is
pointing at freed memory.  A Lookup which gave you the address bumps the
reference count.  An insert in which you kept the address does NOT bump
the reference count.

Arguments:

    HashTable  --  ptr to a GENERIC_HASH_TABLE struct.
    OldHashEntry -- ptr to entry to swap out of table.
    NewHashEntry -- ptr to entry to swap in to table.
    WaitIfLocked  -- True means wait if the row is locked.

Return Value:

    GHT_STATUS_SUCCESS if swap ok.
    GHT_STATUS_NOT_FOUND if old entry not in table.


--*/
// Note:  TBD if necc, implement GhtIncrementRefCountByKey.

{
#undef DEBSUB
#define  DEBSUB  "GhtSwapEntryByAddress:"

    ULONG Hval, HvalIndex;
    PGENERIC_HASH_ROW_ENTRY RowEntry;
    PLIST_ENTRY BeforeEntry;
    BOOL Found;
    PGENERIC_HASH_ENTRY_HEADER Entry;
    PGENERIC_HASH_ENTRY_HEADER NewHashEntry =
        (PGENERIC_HASH_ENTRY_HEADER)NewHashEntryArg;
    PGENERIC_HASH_ENTRY_HEADER OldHashEntry =
        (PGENERIC_HASH_ENTRY_HEADER)OldHashEntryArg;

    //
    // Get the hash value for the element and compute the index and RowEntry
    // address.  Then get the row lock.
    //
    Hval = OldHashEntry->HashValue;
    HvalIndex = Hval % HashTable->NumberRows;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    FrsRtlAcquireListLock(&RowEntry->HashRow);

    //
    // check if the entry is actually on the List.
    //
    // Walk the list with the lock looking for a match on the
    // the hash value then try and match the KeyValue.
    //
    Entry = GhtQuickCheck(HashTable, RowEntry, OldHashEntry, Hval);
    if (Entry != OldHashEntry) {
        DPRINT4(0, "GhtSwapEntryByAddress - entry not on list %08x, %08x, %d, %s\n",
                OldHashEntry, Hval, HvalIndex, HashTable->Name);

        FrsRtlReleaseListLock(&RowEntry->HashRow);
        return GHT_STATUS_NOT_FOUND;
    }

    //
    // Copy the ref count and hash value from the old entry to the new one.
    //
    NewHashEntry->ReferenceCount = OldHashEntry->ReferenceCount;
    NewHashEntry->HashValue = OldHashEntry->HashValue;

    //
    // Pull the old entry out and replace with the new entry.
    // List counts do not change so do list juggling here.
    //
    BeforeEntry = OldHashEntry->ListEntry.Flink;
    FrsRemoveEntryList(&OldHashEntry->ListEntry);
    InsertTailList(BeforeEntry, &NewHashEntry->ListEntry);

    FrsRtlReleaseListLock(&RowEntry->HashRow);

    return GHT_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\util\info.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    info.c

Abstract:

    Support the RPC interface that provides internal info to the caller.

Author:

    Billy J Fuller 27-Mar-1998

Environment

    User mode, winnt32

--*/

#include <ntreppch.h>
#pragma  hdrstop

#undef DEBSUB
#define DEBSUB  "Info:"

#include <frs.h>
#include <ntdsapi.h>
#include <ntdsapip.h>   // ms internal flags for DsCrackNames()
#include <ntfrsapi.h>
#include <info.h>
#include <tablefcn.h>
#include <lmaccess.h>
#include <lmapibuf.h>

#ifdef SECURITY_WIN32
#include <security.h>
#else
#define SECURITY_WIN32
#include <security.h>
#undef SECURITY_WIN32
#endif



extern PCHAR LatestChanges[];
extern PCHAR CoLocationNames[];

//
// Useful macros
//
#define IPRINTGNAME(_I_, _G_, _F_, _GUID_, _P_) \
{ \
    if (_G_) { \
        GuidToStr(_G_->Guid, _GUID_); \
        IPRINT3(_I_, _F_, _P_, _G_->Name, _GUID_); \
    } \
}



#define INFO_DN_LEN (80)


extern OSVERSIONINFOEX  OsInfo;
extern SYSTEM_INFO  SystemInfo;
extern PCHAR ProcessorArchName[10];


//
// DC name for LDAP binding
//
WCHAR  InfoDcName[MAX_PATH + 1];

//
// Member Subscriber Links
//
typedef struct _INFO_DN  INFO_DN, *PINFO_DN;
struct _INFO_DN  {
    PINFO_DN   Next;
    PWCHAR     Dn;
    PWCHAR     SetType;
};






VOID
DbsDisplayRecordIPrint(
    IN PTABLE_CTX  TableCtx,
    IN PINFO_TABLE InfoTable,
    IN BOOL        Read,
    IN PULONG      RecordFieldx,
    IN ULONG       FieldCount
    );

//
// From frs\ds.c
//
PVOID *
FrsDsFindValues(
    IN PLDAP        ldap,
    IN PLDAPMessage Entry,
    IN PWCHAR       DesiredAttr,
    IN BOOL         DoBerVals
    );

PWCHAR
FrsDsExtendDn(
    IN PWCHAR Dn,
    IN PWCHAR Cn
    );

PWCHAR
FrsDsExtendDnOu(
    IN PWCHAR Dn,
    IN PWCHAR Ou
    );

PWCHAR
FrsDsFindValue(
    IN PLDAP        ldap,
    IN PLDAPMessage Entry,
    IN PWCHAR       DesiredAttr
    );

GUID *
FrsDsFindGuid(
    IN PLDAP        Ldap,
    IN PLDAPMessage LdapEntry
    );

PWCHAR
FrsDsMakeRdn(
    IN PWCHAR DN
    );

PWCHAR
FrsDsConvertToSettingsDn(
    IN PWCHAR   Dn
    );

PSCHEDULE
FrsDsFindSchedule(
    IN  PLDAP        Ldap,
    IN  PLDAPMessage LdapEntry,
    OUT PULONG       Len
    );

VOID
FrsPrintRpcStats(
    IN ULONG            Severity,
    IN PNTFRSAPI_INFO   Info,        OPTIONAL
    IN DWORD            Tabs
    );

VOID
FrsPrintThreadStats(
    IN ULONG            Severity,
    IN PNTFRSAPI_INFO   Info,        OPTIONAL
    IN DWORD            Tabs
    );


VOID
InfoPrint(
    IN PNTFRSAPI_INFO   Info,
    IN PCHAR            Format,
    IN ... )
/*++
Routine Description:
    Format and print a line of information output into the info buffer.

Arguments:
    Info    - Info buffer
    Format  - printf format

Return Value:
    None.
--*/
{
    PCHAR   Line;
    ULONG   LineLen;
    LONG    LineSize;

    //
    // varargs stuff
    //
    va_list argptr;
    va_start(argptr, Format);

    //
    // Print the line into the info buffer
    //
    try {
        if (!FlagOn(Info->Flags, NTFRSAPI_INFO_FLAGS_FULL)) {
            Line = ((PCHAR)Info) + Info->OffsetToFree;
            LineSize = (Info->SizeInChars - (ULONG)(Line - (PCHAR)Info)) - 1;
            if (LineSize <= 0 ||
                _vsnprintf(Line, LineSize, Format, argptr) < 0) {
                SetFlag(Info->Flags, NTFRSAPI_INFO_FLAGS_FULL);
            } else {
                LineLen = strlen(Line) + 1;
                if (Info->CharsToSkip) {
                    if (LineLen > Info->CharsToSkip) {
                        Info->CharsToSkip = 0;
                    } else {
                        Info->CharsToSkip -= LineLen;
                    }
                } else {
                    Info->OffsetToFree += LineLen;
                    Info->TotalChars += LineLen;
                }
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }
    va_end(argptr);
}


#define Tab L"   "
VOID
InfoTabs(
    IN DWORD    Tabs,
    IN PWCHAR   TabW
    )
/*++
Routine Description:
    Create a string of tabs for prettyprint

Arguments:
    Tabs    - number of tabs
    TabW    - preallocated string to receive tabs

Return Value:
    Win32 Status
--*/
{
    DWORD   i;

    //
    // Adjust indentation
    //
    Tabs = (Tabs >= MAX_TABS) ? MAX_TABS : Tabs;
    for (TabW[0] = L'\0', i = 0; i < Tabs; ++i) {
        wcscat(TabW, Tab);
    }
}


PWCHAR
InfoDup(
    IN PWCHAR   StrW,
    IN DWORD    DesiredLen
    )
/*++
Routine Description:
    Duplicate up to DesiredLen chars of StrW. DesiredLen includes
    the terminating \0.

Arguments:
    StrW        - original string (untouched)
    DesiredLen  - Maximum length to duplicate (including terminating \0)

Return Value:
    Win32 Status
--*/
{
    DWORD   Len;
    PWCHAR  NewStrW;

    if (!StrW) {
        return NULL;
    }

    Len = wcslen(StrW) + 1;
    if (Len <= DesiredLen) {
        return FrsWcsDup(StrW);
    }
    NewStrW = FrsAlloc(DesiredLen * sizeof(WCHAR));
    wcsncpy(NewStrW, StrW, DesiredLen);
    NewStrW[DesiredLen - 1] = L'\0';
    if (DesiredLen > 4) {
        NewStrW[DesiredLen - 2] = L'.';
        NewStrW[DesiredLen - 3] = L'.';
        NewStrW[DesiredLen - 4] = L'.';
    }
    return NewStrW;
}



DWORD
InfoPrintDbSets(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs
    )
/*++
Routine Description:
    Return internal info on replica sets (see private\net\inc\ntfrsapi.h).

Arguments:
    Info    - RPC output buffer
    Tabs

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintDbSets:"
    PVOID       Key;
    PREPLICA    Replica;
    CHAR        Guid[GUID_CHAR_LEN + 1];
    WCHAR       TabW[MAX_TAB_WCHARS + 1];
    extern PGEN_TABLE   ReplicasByGuid;
    extern PGEN_TABLE   DeletedReplicas;

    InfoTabs(Tabs, TabW);
    IPRINT1(Info, "%wsACTIVE REPLICA SETS\n", TabW);
    Key = NULL;
    while (Replica = GTabNextDatum(ReplicasByGuid, &Key)) {
        if (REPLICA_IS_ACTIVE(Replica)) {
            FrsPrintTypeReplica(0, Info, Tabs, Replica, NULL, 0);
        } else {
            //
            // If the replica set is not active, one or more of the GNames
            // could have freed guid pointers (feeefeee, bug 319600) so
            // don't print the replica set in this case, just the name and state.
            //
            if (Replica->SetName) {
                IPRINT3(Info, "%ws   %ws in state %s\n",
                        TabW, Replica->SetName->Name, RSS_NAME(Replica->ServiceState));
            }
        }
    }

    IPRINT0(Info, "\nDELETED REPLICA SETS\n");
    Key = NULL;
    if (DeletedReplicas) {
        while (Replica = GTabNextDatum(DeletedReplicas, &Key)) {
            if (Replica->SetName) {
                IPRINT2(Info, "%ws   %ws\n", TabW, Replica->SetName->Name);
            }
        }
    }

    return ERROR_SUCCESS;
}




BOOL
InfoSearch(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs,
    IN PLDAP            Ldap,
    IN PWCHAR           Base,
    IN ULONG            Scope,
    IN PWCHAR           Filter,
    IN PWCHAR           Attrs[],
    IN ULONG            AttrsOnly,
    IN LDAPMessage      **Res
    )
/*++
Routine Description:
    Perform ldap_search_s

Arguments:
    Info        - RPC output buffer
    Tabs        - number of tabs
    Ldap        - bound ldap handle
    .
    .
    .

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoSearch:"
    DWORD           LStatus;
    PWCHAR          ShortName;
    WCHAR           TabW[MAX_TAB_WCHARS + 1];

    InfoTabs(Tabs, TabW);
    LStatus = ldap_search_s(Ldap, Base, Scope, Filter, Attrs, AttrsOnly, Res);

    if (LStatus != LDAP_SUCCESS) {
        ShortName = InfoDup(Base, 20);
        IPRINT5(Info, "%wsWARN - ldap_search_s(%ws, %d, %ws); %ws\n",
                TabW, Base, Scope, ComputerName, ldap_err2string(LStatus));
        return FALSE;
    }
    return TRUE;
}


PCONFIG_NODE
InfoAllocBasicNode(
    IN PNTFRSAPI_INFO   Info,
    IN PWCHAR           TabW,
    IN PWCHAR           NodeType,
    IN PWCHAR           ParentDn,
    IN PWCHAR           Filter,
    IN BOOL             *FirstError,
    IN PLDAP            Ldap,
    IN PLDAPMessage     LdapEntry
    )
/*++
Routine Description:
    Allocate a node and fill in the basic info (dn and name)

Arguments:
    Info        - text buffer
    TabW        - Prettyprint
    NodeType    - Prettyprint
    Ldap        - openned, bound ldap
    LdapEntry   - returned from ldap_first/next_entry()

Return Value:
    NULL if basic info is not available.
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoAllocBasicNode:"
    PCONFIG_NODE    Node      = NULL;
    PWCHAR          ShortName = NULL;
    CHAR            Guid[GUID_CHAR_LEN + 1];


    //
    // Fetch values from the DS
    //
    Node = FrsAllocType(CONFIG_NODE_TYPE);
    Node->Dn = FrsDsFindValue(Ldap, LdapEntry, ATTR_DN);
    FRS_WCSLWR(Node->Dn);

    //
    // Name
    //
    Node->Name = FrsBuildGName(FrsDsFindGuid(Ldap, LdapEntry),
                               FrsDsMakeRdn(Node->Dn));
    if (!Node->Dn || !Node->Name->Name || !Node->Name->Guid) {
        IPRINT5(Info, "\n%ws%ws: ERROR - The object returned by the DS"
                " lacks a dn (%08x), Rdn (%08x), or Guid(%08x)\n",
                TabW, NodeType, Node->Dn, Node->Name->Name, Node->Name->Guid);
        if (*FirstError) {
            *FirstError = FALSE;
            IPRINT5(Info, "%ws%ws: ERROR - Using ldp, bind to %ws and search the "
                    "container %ws using the filter "
                    "%ws for more information.\n",
                    TabW, NodeType, &InfoDcName[2], ParentDn, Filter);
        }
        return FrsFreeType(Node);
    }
    IPRINT3(Info, "\n%ws%ws: %ws\n", TabW, NodeType, Node->Name->Name);

    ShortName = InfoDup(Node->Dn, INFO_DN_LEN);
    IPRINT2(Info, "%ws   DN   : %ws\n", TabW, ShortName);
    ShortName = FrsFree(ShortName);
    GuidToStr(Node->Name->Guid, Guid);
    IPRINT2(Info, "%ws   Guid : %s\n", TabW, Guid);

    return Node;
}


VOID
InfoPrintDsCxtions(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs,
    IN PLDAP            Ldap,
    IN PWCHAR           Base,
    IN BOOL             IsSysVol
    )
/*++
Routine Description:
    Print the cxtions from the DS.

Arguments:
    ldap        - opened and bound ldap connection
    Base        - Name of object or container in DS

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintDsCxtions:"
    PWCHAR          Attrs[7];
    PLDAPMessage    LdapEntry;
    PLDAPMessage    LdapMsg    = NULL;
    PCONFIG_NODE    Node       = NULL;
    PWCHAR          ShortName  = NULL;
    BOOL            FirstError = TRUE;
    WCHAR           TabW[MAX_TAB_WCHARS + 1];
    PWCHAR          CxtionOptionsWStr = NULL;

    //
    // Adjust indentation
    //
    InfoTabs(Tabs, TabW);

    //
    // Search the DS for cxtions
    //
    Attrs[0] = ATTR_DN;
    Attrs[1] = ATTR_SCHEDULE;
    Attrs[2] = ATTR_FROM_SERVER;
    Attrs[3] = ATTR_OBJECT_GUID;
    Attrs[4] = ATTR_USN_CHANGED;
    Attrs[5] = ATTR_ENABLED_CXTION;
    Attrs[6] = ATTR_OPTIONS;
    Attrs[7] = NULL;
    if (!InfoSearch(Info, Tabs, Ldap, Base, LDAP_SCOPE_ONELEVEL,
                    CATEGORY_CXTION, Attrs, 0, &LdapMsg)) {
        goto cleanup;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
         LdapEntry != NULL;
         LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {

        //
        // Basic info (dn, rdn, and guid)
        //
        Node = InfoAllocBasicNode(Info, TabW, L"CXTION", Base,
                                  CATEGORY_CXTION, &FirstError, Ldap, LdapEntry);
        if (!Node) {
            continue;
        }

        //
        // Node's partner's name
        //
        Node->PartnerDn = FrsDsFindValue(Ldap, LdapEntry, ATTR_FROM_SERVER);
        FRS_WCSLWR(Node->PartnerDn);
        ShortName = InfoDup(Node->PartnerDn, INFO_DN_LEN);
        IPRINT2(Info, "%ws   Partner Dn   : %ws\n", TabW, ShortName);
        ShortName = FrsFree(ShortName);
        Node->PartnerName = FrsBuildGName(NULL, FrsDsMakeRdn(Node->PartnerDn));
        IPRINT2(Info, "%ws   Partner Rdn  : %ws\n", TabW, Node->PartnerName->Name);

        //
        // Enabled
        //
        Node->EnabledCxtion = FrsDsFindValue(Ldap, LdapEntry, ATTR_ENABLED_CXTION);
        IPRINT2(Info, "%ws   Enabled      : %ws\n", TabW, Node->EnabledCxtion);

        //
        // Options
        //
        CxtionOptionsWStr = FrsDsFindValue(Ldap, LdapEntry, ATTR_OPTIONS);
        if (CxtionOptionsWStr != NULL) {
            Node->CxtionOptions = _wtoi(CxtionOptionsWStr);
            CxtionOptionsWStr = FrsFree(CxtionOptionsWStr);
        } else {
            Node->CxtionOptions = 0;
        }
        IPRINT2(Info, "%ws   Options      : 0x%08x\n", TabW, Node->CxtionOptions);

        //
        // Schedule, if any
        //
        Node->Schedule = FrsDsFindSchedule(Ldap, LdapEntry, &Node->ScheduleLength);
        if (Node->Schedule) {
            if (IsSysVol) {
                IPRINT1(Info, "%ws   IGNORED Schedule\n", TabW);
            } else {
                IPRINT1(Info, "%ws   Schedule\n", TabW);
            }
            FrsPrintTypeSchedule(0, Info, Tabs + 1, Node->Schedule, NULL, 0);
        }
        Node = FrsFreeType(Node);
    }
cleanup:
    LDAP_FREE_MSG(LdapMsg);
    FrsFreeType(Node);
    FrsFree(ShortName);
}


VOID
InfoCrack(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs,
    IN PWCHAR           Dn,
    IN HANDLE           Handle,
    IN PWCHAR           DomainDnsName,
    IN DWORD            DesiredFormat
    )
/*++
Routine Description:
    Find the NT4 account name for Dn. Dn should be the Dn
    of a computer object.

Arguments:
    Dn            - Of computer object
    Handle        - From DsBind
    DomainDnsName - If !NULL, produce new local handle
    DesiredFormat - DS_NT4_ACCOUNT_NAME or DS_STRING_SID_NAME

Return Value:
    NT4 Account Name or NULL
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoCrack:"
    DWORD           WStatus;
    DS_NAME_RESULT  *Cracked;
    WCHAR           TabW[MAX_TAB_WCHARS + 1];
    PWCHAR          ShortName = NULL;
    HANDLE          LocalHandle = NULL;

    //
    // Adjust indentation
    //
    InfoTabs(Tabs, TabW);

    //
    // Computer's Dn not available
    //
    if (!Dn) {
        return;
    }

    //
    // Need something to go on!
    //
    if (!HANDLE_IS_VALID(Handle) && !DomainDnsName) {
        return;
    }

    //
    // Bind to Ds
    //
    if (DomainDnsName) {
        WStatus = DsBind(NULL, DomainDnsName, &LocalHandle);
        if (!WIN_SUCCESS(WStatus)) {
            IPRINT4(Info, "%ws   ERROR - DsBind(%ws, %08x); WStatus %s\n",
                    TabW, DomainDnsName, DesiredFormat, ErrLabelW32(WStatus));
            return;
        }
        Handle = LocalHandle;
    }

    //
    // Crack the computer's distinguished name into its NT4 Account Name
    //
    WStatus = DsCrackNames(Handle,              // in   hDS,
                           DS_NAME_NO_FLAGS,    // in   flags,
                           DS_FQDN_1779_NAME,   // in   formatOffered,
                           DesiredFormat,       // in   formatDesired,
                           1,                   // in   cNames,
                           &Dn,                 // in   *rpNames,
                           &Cracked);           // out  *ppResult
    if (!WIN_SUCCESS(WStatus)) {
        ShortName = InfoDup(Dn, INFO_DN_LEN);
        IPRINT4(Info, "%ws   ERROR - DsCrackNames(%ws, %08x); WStatus %s\n",
                TabW, ShortName, DesiredFormat, ErrLabelW32(WStatus));
        ShortName = FrsFree(ShortName);
        //
        // What else can we do?
        //
        if (HANDLE_IS_VALID(LocalHandle)) {
            DsUnBind(&LocalHandle);
        }
        return;
    }

    //
    // Might have it
    //
    if (Cracked && Cracked->cItems && Cracked->rItems) {
        //
        // Got it!
        //
        if (Cracked->rItems->status == DS_NAME_NO_ERROR) {
            IPRINT2(Info, "%ws   Cracked Domain : %ws\n",
                    TabW, Cracked->rItems->pDomain);
            IPRINT3(Info, "%ws   Cracked Name   : %08x %ws\n",
                    TabW, DesiredFormat, Cracked->rItems->pName);
        //
        // Only got the domain; rebind and try again
        //
        } else if (Cracked->rItems->status == DS_NAME_ERROR_DOMAIN_ONLY) {
            InfoCrack(Info, Tabs, Dn, NULL, Cracked->rItems->pDomain, DesiredFormat);
        } else {
            ShortName = InfoDup(Dn, INFO_DN_LEN);
            IPRINT4(Info, "%ws   ERROR - DsCrackNames(%ws, %08x); internal status %d\n",
                    TabW, ShortName, DesiredFormat, Cracked->rItems->status);
            ShortName = FrsFree(ShortName);
        }
        DsFreeNameResult(Cracked);
    } else {
        ShortName = InfoDup(Dn, INFO_DN_LEN);
        IPRINT3(Info, "%ws   ERROR - DsCrackNames(%ws, %08x); no status\n",
                TabW, ShortName, DesiredFormat);
        ShortName = FrsFree(ShortName);
    }
    if (HANDLE_IS_VALID(LocalHandle)) {
        DsUnBind(&LocalHandle);
    }
}


VOID
InfoCrackDns(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs,
    IN PLDAP            Ldap,
    IN PWCHAR           Base
    )
/*++
Routine Description:
    Find the DNS name for Base. Base should be the Dn
    of a computer object.

Arguments:
    Info
    Tabs
    Ldap
    Base

Return Value:
    Prints a message into Info.
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoCrackDns:"
    PWCHAR          Attrs[2];
    WCHAR           TabW[MAX_TAB_WCHARS + 1];
    PLDAPMessage    LdapEntry;
    PLDAPMessage    LdapMsg    = NULL;
    PWCHAR          DnsName     = NULL;

    //
    // Adjust indentation
    //
    InfoTabs(Tabs, TabW);

    //
    // Computer's Dn not available
    //
    if (!Base) {
        return;
    }

    //
    // Search the DS for the DNS attribute of Base
    //
    Attrs[0] = ATTR_DNS_HOST_NAME;
    Attrs[1] = NULL;
    if (!InfoSearch(Info, Tabs, Ldap, Base, LDAP_SCOPE_BASE,
                    CATEGORY_ANY, Attrs, 0, &LdapMsg)) {
        goto cleanup;
    }
    LdapEntry = ldap_first_entry(Ldap, LdapMsg);
    if (!LdapEntry) {
        IPRINT2(Info, "%ws   ERROR - No LdapEntry for Dns name on %ws\n", TabW, Base);
        goto cleanup;
    }

    DnsName = FrsDsFindValue(Ldap, LdapEntry, ATTR_DNS_HOST_NAME);
    if (!DnsName) {
        IPRINT2(Info, "%ws   ERROR - No DNS name on %ws\n", TabW, Base);
        goto cleanup;
    }

    //
    // Got it!
    //
    IPRINT2(Info, "%ws   Computer's DNS : %ws\n", TabW, DnsName);

cleanup:
    LDAP_FREE_MSG(LdapMsg);
    FrsFree(DnsName);
}


VOID
InfoPrintMembers(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs,
    IN PLDAP            Ldap,
    IN BOOL             IsSysVol,
    IN PWCHAR           Base,
    IN HANDLE           DsHandle
    )
/*++
Routine Description:
    Print the members

Arguments:
    ldap    - opened and bound ldap connection
    Base    - Name of object or container in DS

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintMembers:"
    PWCHAR          Attrs[7];
    PLDAPMessage    LdapEntry;
    PLDAPMessage    LdapMsg    = NULL;
    PCONFIG_NODE    Node       = NULL;
    PWCHAR          ShortName  = NULL;
    BOOL            FirstError = TRUE;
    WCHAR           TabW[MAX_TAB_WCHARS + 1];

    //
    // Adjust indentation
    //
    InfoTabs(Tabs, TabW);

    //
    // Search the DS for members
    //
    Attrs[0] = ATTR_OBJECT_GUID;
    Attrs[1] = ATTR_DN;
    Attrs[2] = ATTR_SCHEDULE;
    Attrs[3] = ATTR_USN_CHANGED;
    Attrs[4] = ATTR_SERVER_REF;
    Attrs[5] = ATTR_COMPUTER_REF;
    Attrs[6] = NULL;
    if (!InfoSearch(Info, Tabs, Ldap, Base, LDAP_SCOPE_ONELEVEL,
                    CATEGORY_MEMBER, Attrs, 0, &LdapMsg)) {
        goto cleanup;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
         LdapEntry != NULL;
         LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {

        //
        // Basic info (dn, rdn, and guid)
        //
        Node = InfoAllocBasicNode(Info, TabW, L"MEMBER", Base,
                                  CATEGORY_MEMBER, &FirstError, Ldap, LdapEntry);
        if (!Node) {
            continue;
        }

        //
        // NTDS Settings (DSA) Reference
        //
        Node->SettingsDn = FrsDsFindValue(Ldap, LdapEntry, ATTR_SERVER_REF);
        ShortName = InfoDup(Node->SettingsDn, INFO_DN_LEN);
        IPRINT2(Info, "%ws   Server Ref     : %ws\n", TabW, ShortName);
        ShortName = FrsFree(ShortName);

        //
        // Computer Reference
        //
        Node->ComputerDn = FrsDsFindValue(Ldap, LdapEntry, ATTR_COMPUTER_REF);
        FRS_WCSLWR(Node->ComputerDn);
        ShortName = InfoDup(Node->ComputerDn, INFO_DN_LEN);
        IPRINT2(Info, "%ws   Computer Ref   : %ws\n", TabW, ShortName);
        ShortName = FrsFree(ShortName);

        InfoCrack(Info, Tabs, Node->ComputerDn, DsHandle, NULL, DS_NT4_ACCOUNT_NAME);
        InfoCrack(Info, Tabs, Node->ComputerDn, DsHandle, NULL, DS_STRING_SID_NAME);
        InfoCrackDns(Info, Tabs, Ldap, Node->ComputerDn);

        //
        // Schedule, if any
        //
        Node->Schedule = FrsDsFindSchedule(Ldap, LdapEntry, &Node->ScheduleLength);
        if (Node->Schedule) {
            IPRINT1(Info, "%ws   Schedule\n", TabW);
            FrsPrintTypeSchedule(0, Info, Tabs + 1, Node->Schedule, NULL, 0);
        }
        //
        // Get the inbound cxtions
        //
        InfoPrintDsCxtions(Info, Tabs + 1, Ldap, Node->Dn, FALSE);
        if (IsSysVol) {
            if (Node->SettingsDn) {
                InfoPrintDsCxtions(Info, Tabs + 1, Ldap, Node->SettingsDn, TRUE);
            } else {
                IPRINT2(Info, "%ws   WARN - %ws lacks a settings reference\n",
                        TabW, Node->Name->Name);
            }
        }
        Node = FrsFreeType(Node);
    }
cleanup:
    LDAP_FREE_MSG(LdapMsg);
    FrsFreeType(Node);
    FrsFree(ShortName);
}


VOID
InfoPrintDsSets(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs,
    IN PLDAP            Ldap,
    IN PWCHAR           SetDnAddr,
    IN HANDLE           DsHandle,
    IN OUT PINFO_DN     *InfoSets
    )
/*++
Routine Description:
    Print replica sets from the ds

Arguments:
    ldap        - opened and bound ldap connection
    Base        - Name of object or container in DS

Return Value:
    None
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintDsSets:"
    PWCHAR          Attrs[9];
    DWORD           i;
    PINFO_DN        InfoSet;
    PLDAPMessage    LdapEntry;
    PLDAPMessage    LdapMsg    = NULL;
    PCONFIG_NODE    Node       = NULL;
    PWCHAR          ShortName  = NULL;
    BOOL            FirstError = TRUE;
    WCHAR           TabW[MAX_TAB_WCHARS + 1];

    //
    // Adjust indentation
    //
    InfoTabs(Tabs, TabW);

    //
    // Have we processed this settings before?
    //
    for (InfoSet = *InfoSets; InfoSet; InfoSet = InfoSet->Next) {
        if (WSTR_EQ(InfoSet->Dn, SetDnAddr)) {
            IPRINT2(Info, "%ws   %ws processed previously\n", TabW, SetDnAddr);
            break;
        }
    }
    //
    // Yep; get the sets
    //
    if (InfoSet) {
        //
        // Recurse to the next level in the DS hierarchy
        //
        InfoPrintMembers(Info,
                         Tabs + 1,
                         Ldap,
                         FRS_RSTYPE_IS_SYSVOLW(InfoSet->SetType),
                         InfoSet->Dn,
                         DsHandle);
        goto cleanup;
    }

    //
    // Search the DS beginning at Base for sets
    //
    Attrs[0] = ATTR_OBJECT_GUID;
    Attrs[1] = ATTR_DN;
    Attrs[2] = ATTR_SCHEDULE;
    Attrs[3] = ATTR_USN_CHANGED;
    Attrs[4] = ATTR_SET_TYPE;
    Attrs[5] = ATTR_PRIMARY_MEMBER;
    Attrs[6] = ATTR_FILE_FILTER;
    Attrs[7] = ATTR_DIRECTORY_FILTER;
    Attrs[8] = NULL;
    if (!InfoSearch(Info, Tabs, Ldap, SetDnAddr, LDAP_SCOPE_BASE,
                    CATEGORY_REPLICA_SET, Attrs, 0, &LdapMsg)) {
        goto cleanup;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
         LdapEntry != NULL;
         LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {

        //
        // Basic info (dn, rdn, and guid)
        //
        Node = InfoAllocBasicNode(Info, TabW, L"SET", SetDnAddr,
                                  CATEGORY_REPLICA_SET, &FirstError, Ldap, LdapEntry);
        if (!Node) {
            continue;
        }

        //
        // Replica set type
        //
        Node->SetType = FrsDsFindValue(Ldap, LdapEntry, ATTR_SET_TYPE);
        IPRINT2(Info, "%ws   Type          : %ws\n", TabW, Node->SetType);

        //
        // Primary member
        //
        Node->MemberDn = FrsDsFindValue(Ldap, LdapEntry, ATTR_PRIMARY_MEMBER);
        ShortName = InfoDup(Node->MemberDn, INFO_DN_LEN);
        IPRINT2(Info, "%ws   Primary Member: %ws\n", TabW, ShortName);
        ShortName = FrsFree(ShortName);

        //
        // File filter
        //
        Node->FileFilterList = FrsDsFindValue(Ldap, LdapEntry, ATTR_FILE_FILTER);
        IPRINT2(Info, "%ws   File Filter   : %ws\n", TabW, Node->FileFilterList);

        //
        // Directory filter
        //
        Node->DirFilterList = FrsDsFindValue(Ldap, LdapEntry, ATTR_DIRECTORY_FILTER);
        IPRINT2(Info, "%ws   Dir  Filter   : %ws\n", TabW, Node->DirFilterList);

        //
        // Schedule, if any
        //
        Node->Schedule = FrsDsFindSchedule(Ldap, LdapEntry, &Node->ScheduleLength);
        if (Node->Schedule) {
            IPRINT1(Info, "%ws   Schedule\n", TabW);
            FrsPrintTypeSchedule(0, Info, Tabs + 1, Node->Schedule, NULL, 0);
        }

        InfoSet = FrsAlloc(sizeof(INFO_DN));
        InfoSet->Dn = FrsWcsDup(Node->Dn);
        InfoSet->SetType = FrsWcsDup(Node->SetType);
        InfoSet->Next = *InfoSets;
        *InfoSets = InfoSet;

        //
        // Recurse to the next level in the DS hierarchy
        //
        InfoPrintMembers(Info,
                         Tabs + 1,
                         Ldap,
                         FRS_RSTYPE_IS_SYSVOLW(Node->SetType),
                         Node->Dn,
                         DsHandle);
        Node = FrsFreeType(Node);
    }
cleanup:
    LDAP_FREE_MSG(LdapMsg);
    FrsFreeType(Node);
    FrsFree(ShortName);
}


VOID
InfoPrintSettings(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs,
    IN PLDAP            Ldap,
    IN PWCHAR           MemberDn,
    IN HANDLE           DsHandle,
    IN OUT PINFO_DN     *InfoSettings,
    IN OUT PINFO_DN     *InfoSets
    )
/*++
Routine Description:
    Scan the DS tree for NTFRS-Settings

Arguments:
    ldap    - opened and bound ldap connection
    Base    - Name of object or container in DS

Return Value:
    WIN32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintSettings:"
    PWCHAR          Attrs[5];
    PLDAPMessage    LdapEntry;
    PWCHAR          MemberDnAddr;
    PWCHAR          SetDnAddr;
    PWCHAR          SettingsDnAddr;
    PINFO_DN        InfoSetting;
    PLDAPMessage    LdapMsg    = NULL;
    PCONFIG_NODE    Node       = NULL;
    PWCHAR          ShortName  = NULL;
    BOOL            FirstError = TRUE;
    WCHAR           TabW[MAX_TAB_WCHARS + 1];

    //
    // Adjust indentation
    //
    InfoTabs(Tabs, TabW);

    //
    // Find the member component
    //
    MemberDnAddr = wcsstr(MemberDn, L"cn=");
    if (!MemberDnAddr) {
        IPRINT2(Info, "%ws   ERROR - No MemberDnAddr in %ws\n", TabW, MemberDn);
        goto cleanup;
    }
    //
    // Find the set component
    //
    SetDnAddr = wcsstr(MemberDnAddr + 3, L"cn=");
    if (!SetDnAddr) {
        IPRINT2(Info, "%ws   ERROR - No SetDnAddr in %ws\n", TabW, MemberDn);
        goto cleanup;
    }
    //
    // Find the settings component
    //
    SettingsDnAddr = wcsstr(SetDnAddr + 3, L"cn=");
    if (!SettingsDnAddr) {
        IPRINT2(Info, "%ws   ERROR - No SettingsDnAddr in %ws\n", TabW, MemberDn);
        goto cleanup;
    }

    //
    // Have we processed this settings before?
    //
    for (InfoSetting = *InfoSettings; InfoSetting; InfoSetting = InfoSetting->Next) {
        if (WSTR_EQ(InfoSetting->Dn, SettingsDnAddr)) {
            IPRINT2(Info, "%ws   %ws processed previously\n", TabW, SettingsDnAddr);
            break;
        }
    }
    //
    // Yep; get the sets
    //
    if (InfoSetting) {
        InfoPrintDsSets(Info, Tabs + 1, Ldap, SetDnAddr, DsHandle, InfoSets);
        goto cleanup;
    }

    //
    // Search the DS beginning at Base for settings
    //
    Attrs[0] = ATTR_OBJECT_GUID;
    Attrs[1] = ATTR_DN;
    Attrs[2] = ATTR_SCHEDULE;
    Attrs[3] = ATTR_USN_CHANGED;
    Attrs[4] = NULL;
    if (!InfoSearch(Info, Tabs, Ldap, SettingsDnAddr, LDAP_SCOPE_BASE,
                    CATEGORY_NTFRS_SETTINGS, Attrs,  0, &LdapMsg)) {
        goto cleanup;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
         LdapEntry != NULL;
         LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {

        //
        // Basic info (dn, rdn, and guid)
        //
        Node = InfoAllocBasicNode(Info, TabW, L"SETTINGS", SettingsDnAddr,
                                  CATEGORY_NTFRS_SETTINGS, &FirstError, Ldap, LdapEntry);
        if (!Node) {
            continue;
        }

        //
        // Schedule, if any
        //
        Node->Schedule = FrsDsFindSchedule(Ldap, LdapEntry, &Node->ScheduleLength);
        if (Node->Schedule) {
            IPRINT1(Info, "%ws   Schedule\n", TabW);
            FrsPrintTypeSchedule(0, Info, Tabs + 1, Node->Schedule, NULL, 0);
        }

        InfoSetting = FrsAlloc(sizeof(INFO_DN));
        InfoSetting->Dn = FrsWcsDup(Node->Dn);
        InfoSetting->Next = *InfoSettings;
        *InfoSettings = InfoSetting;

        //
        // Recurse to the next level in the DS hierarchy
        //
        InfoPrintDsSets(Info, Tabs + 1, Ldap, SetDnAddr, DsHandle, InfoSets);
        Node = FrsFreeType(Node);
    }
cleanup:
    LDAP_FREE_MSG(LdapMsg);
    FrsFreeType(Node);
    FrsFree(ShortName);
}


VOID
InfoPrintSubscribers(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs,
    IN PLDAP            Ldap,
    IN PWCHAR           SubscriptionDn,
    IN PINFO_DN         *InfoSubs
    )
/*++
Routine Description:
    Print subscribers

Arguments:
    Ldap            - opened and bound ldap connection
    SubscriptionDn  - distininguished name of subscriptions object

Return Value:
    WIN32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintSubscribers:"
    PWCHAR          Attrs[8];
    PLDAPMessage    LdapEntry;
    PINFO_DN        InfoSub;
    PLDAPMessage    LdapMsg    = NULL;
    PCONFIG_NODE    Node       = NULL;
    PWCHAR          ShortName  = NULL;
    BOOL            FirstError = TRUE;
    WCHAR           TabW[MAX_TAB_WCHARS + 1];

    //
    // Adjust indentation
    //
    InfoTabs(Tabs, TabW);

    //
    // Search the DS beginning at Base for the entries of class "Filter"
    //
    Attrs[0] = ATTR_OBJECT_GUID;
    Attrs[1] = ATTR_DN;
    Attrs[2] = ATTR_SCHEDULE;
    Attrs[3] = ATTR_USN_CHANGED;
    Attrs[4] = ATTR_REPLICA_ROOT;
    Attrs[5] = ATTR_REPLICA_STAGE;
    Attrs[6] = ATTR_MEMBER_REF;
    Attrs[7] = NULL;
    if (!InfoSearch(Info, Tabs, Ldap, SubscriptionDn, LDAP_SCOPE_ONELEVEL,
                    CATEGORY_SUBSCRIBER, Attrs, 0, &LdapMsg)) {
        goto cleanup;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
         LdapEntry != NULL;
         LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {

        //
        // Basic info (dn, rdn, and guid)
        //
        Node = InfoAllocBasicNode(Info, TabW, L"SUBSCRIBER", SubscriptionDn,
                                  CATEGORY_SUBSCRIBER, &FirstError, Ldap, LdapEntry);
        if (!Node) {
            continue;
        }

        //
        // Member reference
        //
        Node->MemberDn = FrsDsFindValue(Ldap, LdapEntry, ATTR_MEMBER_REF);
        ShortName = InfoDup(Node->MemberDn, INFO_DN_LEN);
        IPRINT2(Info, "%ws   Member Ref: %ws\n", TabW, ShortName);
        ShortName = FrsFree(ShortName);

        if (Node->MemberDn) {
            InfoSub = FrsAlloc(sizeof(INFO_DN ));
            InfoSub->Dn = FrsWcsDup(Node->MemberDn);
            InfoSub->Next = *InfoSubs;
            *InfoSubs = InfoSub;
        }

        //
        // Root pathname
        //
        Node->Root = FrsDsFindValue(Ldap, LdapEntry, ATTR_REPLICA_ROOT);
        FRS_WCSLWR(Node->Root);
        IPRINT2(Info, "%ws   Root      : %ws\n", TabW, Node->Root);

        //
        // Staging pathname
        //
        Node->Stage = FrsDsFindValue(Ldap, LdapEntry, ATTR_REPLICA_STAGE);
        FRS_WCSLWR(Node->Stage);
        IPRINT2(Info, "%ws   Stage     : %ws\n", TabW, Node->Stage);

        //
        // Schedule, if any
        //
        Node->Schedule = FrsDsFindSchedule(Ldap, LdapEntry, &Node->ScheduleLength);
        if (Node->Schedule) {
            IPRINT1(Info, "%ws   Schedule\n", TabW);
            FrsPrintTypeSchedule(0, Info, Tabs + 1, Node->Schedule, NULL, 0);
        }

        Node = FrsFreeType(Node);
    }
cleanup:
    LDAP_FREE_MSG(LdapMsg);
    FrsFreeType(Node);
    FrsFree(ShortName);
}


VOID
InfoPrintSubscriptions(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs,
    IN PLDAP            Ldap,
    IN PWCHAR           ComputerDn,
    IN PINFO_DN         *InfoSubs
    )
/*++
Routine Description:
    Recursively scan the DS tree beginning at computer

Arguments:
    Info
    Tabs
    Ldap
    ComputerDn

Return Value:
    WIN32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintSubscriptions:"
    PWCHAR          Attrs[6];
    PLDAPMessage    LdapEntry;
    PLDAPMessage    LdapMsg    = NULL;
    PCONFIG_NODE    Node       = NULL;
    PWCHAR          ShortName  = NULL;
    BOOL            FirstError = TRUE;
    WCHAR           TabW[MAX_TAB_WCHARS + 1];

    //
    // Adjust indentation
    //
    InfoTabs(Tabs, TabW);

    //
    // Search the DS beginning at Base for the entries of class "Filter"
    //
    Attrs[0] = ATTR_OBJECT_GUID;
    Attrs[1] = ATTR_DN;
    Attrs[2] = ATTR_SCHEDULE;
    Attrs[3] = ATTR_USN_CHANGED;
    Attrs[4] = ATTR_WORKING;
    Attrs[5] = NULL;
    if (!InfoSearch(Info, Tabs + 1, Ldap, ComputerDn, LDAP_SCOPE_SUBTREE,
                    CATEGORY_SUBSCRIPTIONS, Attrs, 0, &LdapMsg)) {
        goto cleanup;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
         LdapEntry != NULL;
         LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {

        //
        // Basic info (dn, rdn, and guid)
        //
        Node = InfoAllocBasicNode(Info, TabW, L"SUBSCRIPTION", ComputerDn,
                                  CATEGORY_SUBSCRIPTIONS, &FirstError, Ldap, LdapEntry);
        if (!Node) {
            continue;
        }

        //
        // Working Directory
        //
        Node->Working = FrsDsFindValue(Ldap, LdapEntry, ATTR_WORKING);
        IPRINT2(Info, "%ws   Working       : %ws\n", TabW, Node->Working);
        IPRINT2(Info, "%ws   Actual Working: %ws\n", TabW, WorkingPath);

        //
        // Schedule, if any
        //
        Node->Schedule = FrsDsFindSchedule(Ldap, LdapEntry, &Node->ScheduleLength);
        if (Node->Schedule) {
            IPRINT1(Info, "%ws   Schedule\n", TabW);
            FrsPrintTypeSchedule(0, Info, Tabs + 1, Node->Schedule, NULL, 0);
        }

        //
        // Recurse to the next level in the DS hierarchy
        //
        InfoPrintSubscribers(Info, Tabs + 1, Ldap, Node->Dn, InfoSubs);

        Node = FrsFreeType(Node);
    }
cleanup:
    LDAP_FREE_MSG(LdapMsg);
    FrsFreeType(Node);
    FrsFree(ShortName);
}


BOOL
InfoPrintComputer(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs,
    IN PLDAP            Ldap,
    IN  PWCHAR          FindDn,
    IN  PWCHAR          ObjectCategory,
    IN  ULONG           Scope,
    OUT PINFO_DN        *InfoSubs
    )
/*++
Routine Description:
    Return internal info on DS computer objects.

Arguments:
    Info        - RPC output buffer
    Tabs        - number of tabs
    Ldap        - bound ldap handle
    DefaultNcDn - DN of the DCs default naming context
    FindDn         - Base Dn for search
    ObjectCategory - Object class (computer or user)
                     A user object serves the same purpose as the computer
                     object *sometimes* following a NT4 to NT5 upgrade.
    Scope          - Scope of search (currently BASE or SUBTREE)

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintComputer:"
    DWORD           i;
    DWORD           LStatus;
    PLDAPMessage    LdapEntry;
    PWCHAR          UserAccountControl;
    DWORD           NumVals;
    PINFO_DN        InfoSub;
    BOOL            FoundAComputer = FALSE;
    PWCHAR          ShortName   = NULL;
    PCONFIG_NODE    Node        = NULL;
    PLDAPMessage    LdapMsg     = NULL;
    PWCHAR          *Values     = NULL;
    DWORD           WStatus     = ERROR_SUCCESS;
    BOOL            FirstError  = TRUE;
    WCHAR           TabW[MAX_TAB_WCHARS + 1];
    WCHAR           Filter[MAX_PATH + 1];
    WCHAR           ComputerFqdn[MAX_PATH + 1];
    DWORD           ComputerFqdnLen;
    PWCHAR          Attrs[10];

    //
    // Initialize return value
    //
    *InfoSubs = NULL;

    //
    // Adjust indentation
    //
    InfoTabs(Tabs, TabW);

    //
    // Filter that locates our computer object
    //
    swprintf(Filter, L"(&%s(sAMAccountName=%s$))", ObjectCategory, ComputerName);

    //
    // Search the DS beginning at Base for the entries of class "Filter"
    //
    Attrs[0] = ATTR_OBJECT_GUID;
    Attrs[1] = ATTR_DN;
    Attrs[2] = ATTR_SCHEDULE;
    Attrs[3] = ATTR_COMPUTER_REF_BL;
    Attrs[4] = ATTR_SERVER_REF;
    Attrs[5] = ATTR_SERVER_REF_BL;
    Attrs[6] = ATTR_USER_ACCOUNT_CONTROL;
    Attrs[7] = ATTR_DNS_HOST_NAME;
    Attrs[8] = NULL;
    InfoSearch(Info,
               Tabs + 1,
               Ldap,
               FindDn,
               Scope,
               Filter,
               Attrs,
               0,
               &LdapMsg);

    if (!LdapMsg) {
        goto CLEANUP;
    }
    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
         LdapEntry != NULL && WIN_SUCCESS(WStatus);
         LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
        FoundAComputer = TRUE;

        //
        // Basic info (dn, rdn, and guid)
        //
        Node = InfoAllocBasicNode(Info,
                                  TabW,
                                  L"COMPUTER",
                                  FindDn,
                                  Filter,
                                  &FirstError,
                                  Ldap,
                                  LdapEntry);
        if (!Node) {
            continue;
        }
        UserAccountControl = FrsDsFindValue(Ldap, LdapEntry, ATTR_USER_ACCOUNT_CONTROL);
        if (UserAccountControl) {
            IPRINT2(Info, "%ws   UAC  : 0x%08x\n",
                    TabW, wcstoul(UserAccountControl, NULL, 10));
            UserAccountControl = FrsFree(UserAccountControl);
        }

        //
        // Server reference
        //
        Node->SettingsDn = FrsDsFindValue(Ldap, LdapEntry, ATTR_SERVER_REF_BL);
        ShortName = InfoDup(Node->SettingsDn, INFO_DN_LEN);
        IPRINT2(Info, "%ws   Server BL : %ws\n", TabW, ShortName);
        ShortName = FrsFree(ShortName);
        if (!Node->SettingsDn) {
            Node->SettingsDn = FrsDsFindValue(Ldap, LdapEntry, ATTR_SERVER_REF);
            ShortName = InfoDup(Node->SettingsDn, INFO_DN_LEN);
            IPRINT2(Info, "%ws   Server Ref: %ws\n", TabW, ShortName);
            ShortName = FrsFree(ShortName);
        }
        //
        // Make sure it references the settings; not the server
        //
        Node->SettingsDn = FrsDsConvertToSettingsDn(Node->SettingsDn);
        ShortName = InfoDup(Node->SettingsDn, INFO_DN_LEN);
        IPRINT2(Info, "%ws   Settings  : %ws\n", TabW, ShortName);
        ShortName = FrsFree(ShortName);

        //
        // DNS Host Name
        //
        Node->DnsName = FrsDsFindValue(Ldap, LdapEntry, ATTR_DNS_HOST_NAME);
        IPRINT2(Info, "%ws   DNS Name  : %ws\n", TabW, Node->DnsName);

        //
        // Schedule, if any
        //
        Node->Schedule = FrsDsFindSchedule(Ldap, LdapEntry, &Node->ScheduleLength);
        if (Node->Schedule) {
            IPRINT1(Info, "%ws   Schedule\n", TabW);
            FrsPrintTypeSchedule(0, Info, Tabs + 1, Node->Schedule, NULL, 0);
        }

        InfoPrintSubscriptions(Info, Tabs + 1, Ldap, Node->Dn, InfoSubs);

        //
        // Subscriber Member Bls
        //
        if (!*InfoSubs) {
            IPRINT2(Info, "%ws   %ws IS NOT A MEMBER OF ANY SET!\n",
                    TabW, ComputerName);
        } else {
            IPRINT1(Info, "%ws   Subscriber Member Back Links:\n", TabW);
            for (InfoSub = *InfoSubs; InfoSub; InfoSub = InfoSub->Next) {
                FRS_WCSLWR(InfoSub->Dn);
                ShortName = InfoDup(InfoSub->Dn, INFO_DN_LEN);
                IPRINT2(Info, "%ws      %ws\n", TabW, ShortName);
                ShortName = FrsFree(ShortName);
            }
        }

        //
        // Next computer
        //
        Node = FrsFreeType(Node);
    }

CLEANUP:
    LDAP_FREE_MSG(LdapMsg);
    FrsFreeType(Node);
    FrsFree(ShortName);
    return FoundAComputer;
}


DWORD
InfoPrintDs(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs
    )
/*++
Routine Description:
    Return internal info on DS (see private\net\inc\ntfrsapi.h).

Arguments:
    Info    - RPC output buffer
    Tabs    - number of tabs

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintDs:"
    DWORD           WStatus;
    DWORD           LStatus;
    DWORD           i;
    PWCHAR          DcAddr;
    PWCHAR          DcName;
    PWCHAR          DcDnsName;
    DWORD           NumVals;
    PWCHAR          Config;
    PLDAPMessage    LdapEntry;
    BOOL            PrintedComputers;
    PINFO_DN        InfoSub;
    PINFO_DN        InfoSetting;
    PINFO_DN        InfoSet;
    PINFO_DN        InfoSubs        = NULL;
    PINFO_DN        InfoSettings    = NULL;
    PINFO_DN        InfoSets        = NULL;
    PWCHAR          ShortName       = NULL;
    PWCHAR          SitesDn         = NULL;
    PWCHAR          ServicesDn      = NULL;
    PWCHAR          DefaultNcDn     = NULL;
    PWCHAR          ComputersDn     = NULL;
    PWCHAR          DomainControllersDn = NULL;
    PLDAPMessage    LdapMsg         = NULL;
    PWCHAR          *Values         = NULL;
    PLDAP           Ldap            = NULL;
    HANDLE          DsHandle        = INVALID_HANDLE_VALUE;
    WCHAR           ComputerFqdn[MAX_PATH + 1];
    DWORD           ComputerFqdnLen;
    WCHAR           TabW[MAX_TAB_WCHARS + 1];
    CHAR            Guid[GUID_CHAR_LEN + 1];
    PWCHAR          Attrs[3];
    PDOMAIN_CONTROLLER_INFO DcInfo = NULL;
    struct l_timeval Timeout;

    DWORD           InfoFlags;
    CHAR            FlagBuffer[220];
    ULONG           ulOptions;

    extern PWCHAR DsDomainControllerName;
    extern FLAG_NAME_TABLE DsGetDcInfoFlagNameTable[];
    //
    // Client side ldap_connect timeout in seconds. Reg value "Ldap Bind Timeout In Seconds". Default is 30 seconds.
    //
    extern DWORD LdapBindTimeoutInSeconds;

    //
    // Adjust indentation
    //
    InfoTabs(Tabs, TabW);
    IPRINT1(Info, "%wsNTFRS CONFIGURATION IN THE DS\n", TabW);

    Ldap = NULL;
    if (IsADc) {
        DcAddr = NULL;
        DcName = ComputerName;
        DcDnsName = ComputerDnsName;
        IPRINT1(Info, "%wsSUBSTITUTE DCINFO FOR DC\n", TabW);
        IPRINT2(Info, "%ws   FRS  DomainControllerName: %ws\n", TabW, DsDomainControllerName);
        IPRINT2(Info, "%ws   Computer Name            : %ws\n", TabW, DcName);
        IPRINT2(Info, "%ws   Computer DNS Name        : %ws\n", TabW, DcDnsName);
    } else {
        //
        // Domain Controller
        //
        WStatus = DsGetDcName(NULL,
                              NULL,
                              NULL,
                              NULL,
                              DS_DIRECTORY_SERVICE_REQUIRED |
                              DS_WRITABLE_REQUIRED          |
                              DS_BACKGROUND_ONLY,
                              &DcInfo);
        if (!WIN_SUCCESS(WStatus)) {
            DcInfo = NULL;
            IPRINT2(Info, "%wsWARN - DsGetDcName WStatus %s; Flushing cache...\n",
                    TabW, ErrLabelW32(WStatus));
            WStatus = DsGetDcName(NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  DS_DIRECTORY_SERVICE_REQUIRED |
                                  DS_WRITABLE_REQUIRED          |
                                  DS_FORCE_REDISCOVERY,
                                  &DcInfo);
        }
        //
        // Report the error and retry for any DC
        //
        if (!WIN_SUCCESS(WStatus)) {
            DcInfo = NULL;
            IPRINT3(Info, "%wsERROR - DsGetDcName(%ws); WStatus %s\n",
                    TabW, ComputerName, ErrLabelW32(WStatus));
            goto cleanup;
        }

        //
        // Dump dcinfo
        //
        IPRINT1(Info, "%wsDCINFO\n", TabW);
        IPRINT2(Info, "%ws   LAST DomainControllerName: %ws\n", TabW, DsDomainControllerName);
        IPRINT2(Info, "%ws   DomainControllerName     : %ws\n", TabW, DcInfo->DomainControllerName);
        IPRINT2(Info, "%ws   DomainControllerAddress  : %ws\n", TabW, DcInfo->DomainControllerAddress);
        IPRINT2(Info, "%ws   DomainControllerType     : %08x\n",TabW, DcInfo->DomainControllerAddressType);
        IPRINT2(Info, "%ws   DomainName               : %ws\n", TabW, DcInfo->DomainName);
        IPRINT2(Info, "%ws   DnsForestName            : %ws\n", TabW, DcInfo->DnsForestName);
        IPRINT2(Info, "%ws   DcSiteName               : %ws\n", TabW, DcInfo->DcSiteName);
        IPRINT2(Info, "%ws   ClientSiteName           : %ws\n", TabW, DcInfo->ClientSiteName);

        InfoFlags = DcInfo->Flags;
        FrsFlagsToStr(InfoFlags, DsGetDcInfoFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
        IPRINT3(Info, "%ws   Flags                    : %08x [%s]\n",TabW, InfoFlags, FlagBuffer);


        if (!DsDomainControllerName ||
            !DcInfo->DomainControllerName ||
             WSTR_NE(DsDomainControllerName, DcInfo->DomainControllerName)) {
            IPRINT3(Info, "%wsWARN - Using DC %ws; not %ws\n",
                    TabW, DcInfo->DomainControllerName, DsDomainControllerName);
        }

        //
        // Binding address
        //
        DcAddr = DcInfo->DomainControllerAddress;
        DcDnsName = DcInfo->DomainControllerName;
    }
    wcsncpy(InfoDcName, DcDnsName, ARRAY_SZ(InfoDcName)-1);
    //
    // BIND to the DS
    //
    IPRINT1(Info, "\n%wsBINDING TO THE DS:\n", TabW);

    //
    // if ldap_open is called with a server name the api will call DsGetDcName 
    // passing the server name as the domainname parm...bad, because 
    // DsGetDcName will make a load of DNS queries based on the server name, 
    // it is designed to construct these queries from a domain name...so all 
    // these queries will be bogus, meaning they will waste network bandwidth,
    // time to fail, and worst case cause expensive on demand links to come up 
    // as referrals/forwarders are contacted to attempt to resolve the bogus 
    // names.  By setting LDAP_OPT_AREC_EXCLUSIVE to on using ldap_set_option 
    // after the ldap_init but before any other operation using the ldap 
    // handle from ldap_init, the delayed connection setup will not call 
    // DsGetDcName, just gethostbyname, or if an IP is passed, the ldap client 
    // will detect that and use the address directly.
    //

    //
    // Remove the leading \\ if they exist.
    //
    FRS_TRIM_LEADING_2SLASH(DcDnsName);
    FRS_TRIM_LEADING_2SLASH(DcAddr);

    ulOptions = PtrToUlong(LDAP_OPT_ON);
    Timeout.tv_sec = LdapBindTimeoutInSeconds;
    Timeout.tv_usec = 0;

    //
    // Try using DcDnsName first.
    //
    if ((Ldap == NULL) && (DcDnsName != NULL)) {

        Ldap = ldap_init(DcDnsName, LDAP_PORT);
        if (Ldap != NULL) {
            ldap_set_option(Ldap, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions);
            LStatus = ldap_connect(Ldap, &Timeout);
            if (LStatus != LDAP_SUCCESS) {
                IPRINT4(Info, "%ws   WARN - ldap_connect(%ws); (ldap error %08x = %ws)\n",
                        TabW, DcDnsName, LStatus, ldap_err2string(LStatus));
                ldap_unbind_s(Ldap);
                Ldap = NULL;
            } else {
                IPRINT2(Info, "%ws   ldap_connect     : %ws\n", TabW, DcDnsName);
            }
        }
    }

    //
    // Try using DcAddr next.
    //
    if ((Ldap == NULL) && (DcAddr != NULL)) {

        Ldap = ldap_init(DcAddr, LDAP_PORT);
        if (Ldap != NULL) {
            ldap_set_option(Ldap, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions);
            LStatus = ldap_connect(Ldap, &Timeout);
            if (LStatus != LDAP_SUCCESS) {
                IPRINT4(Info, "%ws   WARN - ldap_connect(%ws); (ldap error %08x = %ws)\n",
                        TabW, DcAddr, LStatus, ldap_err2string(LStatus));
                ldap_unbind_s(Ldap);
                Ldap = NULL;
            } else {
                IPRINT2(Info, "%ws   ldap_connect     : %ws\n", TabW, DcAddr);
            }
        }
    }

    //
    // Try using DcName finally.
    //
    if ((Ldap == NULL) && (DcName != NULL)) {

        Ldap = ldap_init(DcName, LDAP_PORT);
        if (Ldap != NULL) {
            ldap_set_option(Ldap, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions);
            LStatus = ldap_connect(Ldap, &Timeout);
            if (LStatus != LDAP_SUCCESS) {
                IPRINT4(Info, "%ws   WARN - ldap_connect(%ws); (ldap error %08x = %ws)\n",
                        TabW, DcName, LStatus, ldap_err2string(LStatus));
                ldap_unbind_s(Ldap);
                Ldap = NULL;
            } else {
                IPRINT2(Info, "%ws   ldap_connect     : %ws\n", TabW, DcName);
            }
        }
    }

    //
    // Whatever it is, we can't find it.
    //
    if (!Ldap) {
        IPRINT6(Info, "%ws   ERROR - ldap_connect(DNS %ws, BIOS %ws, IP %ws); (ldap error %08x = %ws)\n",
                TabW, DcDnsName, DcName, DcAddr, LStatus, ldap_err2string(LStatus));
        goto cleanup;
    }

    //
    // Bind to the ldap server
    //
    LStatus = ldap_bind_s(Ldap, NULL, NULL, LDAP_AUTH_NEGOTIATE);

    //
    // No luck; report error and carry on
    //
    if (LStatus != LDAP_SUCCESS) {
        IPRINT4(Info, "%ws   ERROR - ldap_bind_s(%ws); (ldap error %08x = %ws)\n",
                TabW, ComputerName, LStatus, ldap_err2string(LStatus));
        goto cleanup;
    }

    //
    // Bind to the Ds (for various Ds calls such as DsCrackName())
    //
    //
    // DC's Dns Name
    //
    WStatus = ERROR_RETRY;
    if (!WIN_SUCCESS(WStatus) && DcDnsName) {
        WStatus = DsBind(DcDnsName, NULL, &DsHandle);
        if (!WIN_SUCCESS(WStatus)) {
            DsHandle = NULL;
            IPRINT3(Info, "%ws   WARN - DsBind(DcDnsName %ws); WStatus %s\n",
                    TabW, DcDnsName, ErrLabelW32(WStatus));
        } else {
            IPRINT2(Info, "%ws   DsBind     : %ws\n", TabW, DcDnsName);
        }
    }

    //
    // DC's Computer Name
    //
    if (!WIN_SUCCESS(WStatus) && DcName) {
        WStatus = DsBind(DcName, NULL, &DsHandle);
        if (!WIN_SUCCESS(WStatus)) {
            DsHandle = NULL;
            IPRINT3(Info, "%ws   WARN - DsBind(DcName %ws); WStatus %s\n",
                    TabW, DcName, ErrLabelW32(WStatus));
        } else {
            IPRINT2(Info, "%ws   DsBind     : %ws\n", TabW, DcName);
        }
    }

    //
    // DC's IP Address
    //
    if (!WIN_SUCCESS(WStatus) && DcAddr) {
        WStatus = DsBind(DcAddr, NULL, &DsHandle);
        if (!WIN_SUCCESS(WStatus)) {
            DsHandle = NULL;
            IPRINT3(Info, "%ws   WARN - DsBind(DcAddr %ws); WStatus %s\n",
                    TabW, DcAddr, ErrLabelW32(WStatus));
        } else {
            IPRINT2(Info, "%ws   DsBind     : %ws\n", TabW, DcAddr);
        }
    }

    //
    // Whatever it is, we can't find it
    //
    if (!WIN_SUCCESS(WStatus)) {
        IPRINT5(Info, "%ws   ERROR - DsBind(DNS %ws, BIOS %ws, IP %ws); WStatus %s\n",
                TabW, DcDnsName, DcName, DcAddr, ErrLabelW32(WStatus));
        goto cleanup;
    }

    //
    // NAMING CONTEXTS
    //
    IPRINT1(Info, "\n%wsNAMING CONTEXTS:\n", TabW);

    //
    // Find the naming contexts and the default naming context
    //
    Attrs[0] = ATTR_NAMING_CONTEXTS;
    Attrs[1] = ATTR_DEFAULT_NAMING_CONTEXT;
    Attrs[2] = NULL;
    if (!InfoSearch(Info, Tabs + 1, Ldap, CN_ROOT, LDAP_SCOPE_BASE, CATEGORY_ANY,
                    Attrs, 0, &LdapMsg)) {
        goto cleanup;
    }

    LdapEntry = ldap_first_entry(Ldap, LdapMsg);
    if (!LdapEntry) {
        IPRINT2(Info, "%ws   ERROR - ldap_first_entry(contexts, %ws) no entry\n",
                TabW, ComputerName);
        goto cleanup;
    }
    Values = (PWCHAR *)FrsDsFindValues(Ldap, LdapEntry, ATTR_NAMING_CONTEXTS, FALSE);
    if (!Values) {
        IPRINT2(Info, "%ws   ERROR - FrsDsFindValues(contexts, %ws) no entry\n",
                TabW, ComputerName);
        goto cleanup;
    }

    //
    // Now, find the naming context that begins with "CN=configuration"
    //
    NumVals = ldap_count_values(Values);
    while (NumVals--) {
        FRS_WCSLWR(Values[NumVals]);
        Config = wcsstr(Values[NumVals], CONFIG_NAMING_CONTEXT);
        if (Config && Config == Values[NumVals]) {
            //
            // Build the pathname for "configuration\sites & services"
            //
            SitesDn = FrsDsExtendDn(Config, CN_SITES);
            ServicesDn = FrsDsExtendDn(Config, CN_SERVICES);
            break;
        }
    }
    LDAP_FREE_VALUES(Values);

    //
    // Finally, find the default naming context
    //
    Values = (PWCHAR *)FrsDsFindValues(Ldap,
                                  LdapEntry,
                                  ATTR_DEFAULT_NAMING_CONTEXT,
                                  FALSE);
    if (!Values) {
        IPRINT2(Info, "%ws   ERROR - FrsDsFindValues(default naming context, %ws) no entry\n",
                TabW, ComputerName);
        goto cleanup;
    }

    DefaultNcDn = FrsWcsDup(Values[0]);
    ComputersDn = FrsDsExtendDn(DefaultNcDn, CN_COMPUTERS);
    DomainControllersDn = FrsDsExtendDnOu(DefaultNcDn, CN_DOMAIN_CONTROLLERS);
    LDAP_FREE_VALUES(Values);

    ShortName = InfoDup(SitesDn, INFO_DN_LEN);
    IPRINT2(Info, "%ws   SitesDn    : %ws\n", TabW, ShortName);
    ShortName = FrsFree(ShortName);
    ShortName = InfoDup(ServicesDn, INFO_DN_LEN);
    IPRINT2(Info, "%ws   ServicesDn : %ws\n", TabW, ShortName);
    ShortName = FrsFree(ShortName);
    ShortName = InfoDup(DefaultNcDn, INFO_DN_LEN);
    IPRINT2(Info, "%ws   DefaultNcDn: %ws\n", TabW, ShortName);
    ShortName = FrsFree(ShortName);
    ShortName = InfoDup(ComputersDn, INFO_DN_LEN);
    IPRINT2(Info, "%ws   ComputersDn: %ws\n", TabW, ShortName);
    ShortName = FrsFree(ShortName);
    ShortName = InfoDup(DomainControllersDn, INFO_DN_LEN);
    IPRINT2(Info, "%ws   DomainCtlDn: %ws\n", TabW, ShortName);
    ShortName = FrsFree(ShortName);

    //
    // Retrieve the computer's fully qualified Dn
    //
    ComputerFqdnLen = MAX_PATH;
    if (!GetComputerObjectName(NameFullyQualifiedDN, ComputerFqdn, &ComputerFqdnLen)) {
        IPRINT4(Info, "%ws   ERROR - GetComputerObjectName(%ws); Len %d, WStatus %s\n",
                TabW, ComputerName, ComputerFqdnLen, ErrLabelW32(GetLastError()));
        ComputerFqdn[0] = L'\0';
    } else {
        ShortName = InfoDup(ComputerFqdn, INFO_DN_LEN);
        IPRINT2(Info, "%ws   Fqdn       : %ws\n", TabW, ShortName);
        ShortName = FrsFree(ShortName);
    }

    //
    // Find and print the computer info
    //
    PrintedComputers = FALSE;
    if (!PrintedComputers && ComputerFqdn[0]) {
        IPRINT1(Info, "%ws   Searching  : Fqdn\n", TabW);
        PrintedComputers = InfoPrintComputer(Info, Tabs, Ldap, ComputerFqdn,
                               CATEGORY_COMPUTER, LDAP_SCOPE_BASE, &InfoSubs);
    }
    if (!PrintedComputers && ComputersDn) {
        IPRINT1(Info, "%ws   Searching  : Computers\n", TabW);
        PrintedComputers = InfoPrintComputer(Info, Tabs, Ldap, ComputersDn,
                               CATEGORY_COMPUTER, LDAP_SCOPE_SUBTREE, &InfoSubs);
    }
    if (!PrintedComputers && DomainControllersDn) {
        IPRINT1(Info, "%ws   Searching  : Domain Controllers\n", TabW);
        PrintedComputers = InfoPrintComputer(Info, Tabs, Ldap, DomainControllersDn,
                               CATEGORY_COMPUTER, LDAP_SCOPE_SUBTREE, &InfoSubs);
    }
    if (!PrintedComputers && DefaultNcDn) {
        IPRINT1(Info, "%ws   Searching  : Default Naming Context\n", TabW);
        PrintedComputers = InfoPrintComputer(Info, Tabs, Ldap, DefaultNcDn,
                               CATEGORY_COMPUTER, LDAP_SCOPE_SUBTREE, &InfoSubs);
    }
    if (!PrintedComputers && DefaultNcDn) {
        IPRINT1(Info, "%ws   Searching  : Default Naming Context for USER\n", TabW);
        PrintedComputers = InfoPrintComputer(Info, Tabs, Ldap, DefaultNcDn,
                               CATEGORY_USER, LDAP_SCOPE_SUBTREE, &InfoSubs);
    }

    for (InfoSub = InfoSubs; InfoSub; InfoSub = InfoSub->Next) {
        InfoPrintSettings(Info, Tabs, Ldap, InfoSub->Dn, DsHandle, &InfoSettings,
                          &InfoSets);
    }

cleanup:
    //
    // Cleanup
    //
    LDAP_FREE_VALUES(Values);
    LDAP_FREE_MSG(LdapMsg);
    if (DcInfo) {
        NetApiBufferFree(DcInfo);
        DcInfo = NULL;
    }
    if (Ldap) {
        ldap_unbind_s(Ldap);
    }
    if (HANDLE_IS_VALID(DsHandle)) {
        DsUnBind(&DsHandle);
    }
    FrsFree(SitesDn);
    FrsFree(ServicesDn);
    FrsFree(DefaultNcDn);
    FrsFree(ComputersDn);
    FrsFree(DomainControllersDn);
    FrsFree(ShortName);

    while (InfoSub = InfoSubs) {
        InfoSubs = InfoSub->Next;
        FrsFree(InfoSub->Dn);
        FrsFree(InfoSub->SetType);
        FrsFree(InfoSub);
    }
    while (InfoSetting = InfoSettings) {
        InfoSettings = InfoSetting->Next;
        FrsFree(InfoSetting->Dn);
        FrsFree(InfoSetting->SetType);
        FrsFree(InfoSetting);
    }
    while (InfoSet = InfoSets) {
        InfoSets = InfoSet->Next;
        FrsFree(InfoSet->Dn);
        FrsFree(InfoSet->SetType);
        FrsFree(InfoSet);
    }

    //
    // Real error messages are in the info buffer
    //
    return ERROR_SUCCESS;
}


PVOID
InfoFreeInfoTable(
    IN PINFO_TABLE      InfoTable,
    IN PNTFRSAPI_INFO   Info
    )
/*++
Routine Description:
    Free the info IDTable

Arguments:
    InfoTable
    Info

Return Value:
    NULL
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoFreeInfoTable:"
    JET_ERR jerr;

    if (!InfoTable) {
        return NULL;
    }
    if (InfoTable->TableCtx) {
        DbsFreeTableContext(InfoTable->TableCtx, InfoTable->ThreadCtx->JSesid);
    }
    if (InfoTable->ThreadCtx) {
        jerr = DbsCloseJetSession(InfoTable->ThreadCtx);
        if (!JET_SUCCESS(jerr)) {
            IPRINT1(Info, "DbsCloseJetSession jet error = %s\n", ErrLabelJet(jerr));
        }

        InfoTable->ThreadCtx = FrsFreeType(InfoTable->ThreadCtx);
    }

    return FrsFree(InfoTable);

}


JET_ERR
InfoConfigTableWorker(
    IN PTHREAD_CTX           ThreadCtx,
    IN PTABLE_CTX            TableCtx,
    IN PCONFIG_TABLE_RECORD  ConfigRecord,
    IN PINFO_TABLE           InfoTable
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it prints an entry into the info buffer.

Arguments:

    ThreadCtx   - Needed to access Jet.
    TableCtx    - A ptr to an ConfigTable context struct.
    ConfigRecord  - A ptr to a config table record.
    InfoTable

Thread Return Value:

    A Jet error status.  Success means call us with the next record.
    Failure means don't call again and pass our status back to the
    caller of FrsEnumerateTable().

--*/
{
#undef DEBSUB
#define DEBSUB "InfoConfigTableWorker:"


    if (FlagOn(InfoTable->Info->Flags, NTFRSAPI_INFO_FLAGS_FULL)) {
        return JET_errNoCurrentRecord;
    }


    IPRINT0(InfoTable->Info, "\n\n");

    DbsDisplayRecordIPrint(TableCtx, InfoTable, TRUE, NULL, 0);

    return JET_errSuccess;
}


JET_ERR
InfoIDTableWorker(
    IN PTHREAD_CTX      ThreadCtx,
    IN PTABLE_CTX       TableCtx,
    IN PIDTABLE_RECORD  IDTableRec,
    IN PINFO_TABLE      InfoTable
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it prints an entry into the info buffer.

Arguments:

    ThreadCtx   - Needed to access Jet.
    TableCtx    - A ptr to an IDTable context struct.
    IDTableRec  - A ptr to a IDTable record.
    InfoTable

Thread Return Value:

    A Jet error status.  Success means call us with the next record.
    Failure means don't call again and pass our status back to the
    caller of FrsEnumerateTable().

--*/
{
#undef DEBSUB
#define DEBSUB "InfoIDTableWorker:"

    CHAR    FlagBuffer[120];
    WCHAR   TabW[MAX_TAB_WCHARS + 1];
    CHAR    TimeStr[TIME_STRING_LENGTH];
    CHAR    Guid[GUID_CHAR_LEN + 1];


    if (FlagOn(InfoTable->Info->Flags, NTFRSAPI_INFO_FLAGS_FULL)) {
        return JET_errNoCurrentRecord;
    }


    //
    // Table Descriptor
    //
    IPRINT1(InfoTable->Info, "\nTable Type: ID Table for %ws\n",
            InfoTable->Replica->ReplicaName->Name);

    DbsDisplayRecordIPrint(TableCtx, InfoTable, TRUE, NULL, 0);


    return JET_errSuccess;


}


JET_ERR
InfoInOutLogTableWorker(
    IN PTHREAD_CTX              ThreadCtx,
    IN PTABLE_CTX               TableCtx,
    IN PCHANGE_ORDER_COMMAND    Coc,
    IN PINFO_TABLE              InfoTable,
    IN PWCHAR                   TableDescriptor
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it prints an entry into the info buffer.

Arguments:

    ThreadCtx   - Needed to access Jet.
    TableCtx    - A ptr to an IDTable context struct.
    Coc         - A ptr to a inbound log record (change order)
    InfoTable
    TableDescriptor

Thread Return Value:

    A Jet error status.  Success means call us with the next record.
    Failure means don't call again and pass our status back to the
    caller of FrsEnumerateTable().

--*/
{
#undef DEBSUB
#define DEBSUB "InfoInOutLogTableWorker:"

    PREPLICA Replica;

    PCXTION Cxtion = NULL;
    PWSTR   CxtName     = L"<null>";
    PWSTR   PartnerName = L"<null>";
    PWSTR   PartSrvName = L"<null>";
    PCHAR   CxtionState = "<null>";
    BOOL    PrintCxtion;


    if (FlagOn(InfoTable->Info->Flags, NTFRSAPI_INFO_FLAGS_FULL)) {
        return JET_errNoCurrentRecord;
    }

    //
    // Table Descriptor
    //
    IPRINT2(InfoTable->Info, "\nTable Type: %ws for %ws\n",
            TableDescriptor, InfoTable->Replica->ReplicaName->Name);

    //
    // Dump the change order record.
    //
    DbsDisplayRecordIPrint(TableCtx, InfoTable, TRUE, NULL, 0);


    Replica = InfoTable->Replica;
    //
    // Find the cxtion for this CO
    //
    LOCK_CXTION_TABLE(Replica);

    Cxtion = GTabLookupNoLock(Replica->Cxtions, &Coc->CxtionGuid, NULL);

    PrintCxtion = (Cxtion != NULL) && (Cxtion->Inbound);

    if (PrintCxtion) {
        CxtionState = CxtionStateNames[Cxtion->State];

        if (Cxtion->Name != NULL) {

            if (Cxtion->Name->Name != NULL) {
                CxtName = Cxtion->Name->Name;
            }
        }

        if ((Cxtion->Partner != NULL) && (Cxtion->Partner->Name != NULL)) {
            PartnerName = Cxtion->Partner->Name;
        }

        if (Cxtion->PartSrvName != NULL) {
            PartSrvName = Cxtion->PartSrvName;
        }
    }
    UNLOCK_CXTION_TABLE(Replica);

    if (PrintCxtion) {
        IPRINT3(InfoTable->Info, "Cxtion Name                  : %ws <- %ws\\%ws\n",
                 CxtName, PartnerName, PartSrvName);

        IPRINT1(InfoTable->Info, "Cxtion State                 : %s\n", CxtionState);
    }

    return JET_errSuccess;

}


JET_ERR
InfoInLogTableWorker(
    IN PTHREAD_CTX              ThreadCtx,
    IN PTABLE_CTX               TableCtx,
    IN PCHANGE_ORDER_COMMAND    Coc,
    IN PINFO_TABLE              InfoTable
    )
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it prints an entry into the info buffer.

Arguments:

    ThreadCtx   - Needed to access Jet.
    TableCtx    - A ptr to an IDTable context struct.
    Coc         - A ptr to a inbound log record (change order)
    InfoTable

Thread Return Value:

    A Jet error status.  Success means call us with the next record.
    Failure means don't call again and pass our status back to the
    caller of FrsEnumerateTable().

--*/
{
    return InfoInOutLogTableWorker(ThreadCtx, TableCtx, Coc, InfoTable,
                                   L"Inbound Log Table");
}







JET_ERR
InfoOutLogTableWorker(
    IN PTHREAD_CTX              ThreadCtx,
    IN PTABLE_CTX               TableCtx,
    IN PCHANGE_ORDER_COMMAND    Coc,
    IN PINFO_TABLE              InfoTable
    )
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it prints an entry into the info buffer.

Arguments:

    ThreadCtx   - Needed to access Jet.
    TableCtx    - A ptr to an IDTable context struct.
    Coc         - A ptr to a inbound log record (change order)
    InfoTable

Thread Return Value:

    A Jet error status.  Success means call us with the next record.
    Failure means don't call again and pass our status back to the
    caller of FrsEnumerateTable().

--*/
{
    return InfoInOutLogTableWorker(ThreadCtx, TableCtx, Coc, InfoTable,
                                   L"Outbound Log Table");
}


DWORD
InfoPrintSingleTable(
    IN PNTFRSAPI_INFO   Info,
    IN PWCHAR           TableName,
    IN TABLE_TYPE       TableType,
    IN PREPLICA         Replica,
    IN ULONG            InfoIndexx,
    IN PENUMERATE_TABLE_ROUTINE InfoTableWorker
    )
/*++
Routine Description:

    Display data for the specified table using the InfoPrint interface.

Arguments:
    Info - ptr to the API Info ctx.
    TableName - The name of the table
    TableType - the Type code for the table.
    Replica, -- ptr to the replica struct for the replica set.
    InfoIndexx -- The ID of the index to use when enumerating the table.
    InfoTableWorker -- The function to call to display each record.

Return Value:
    jet error Status

--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintSingleTable:"

    JET_ERR             jerr = JET_errSuccess;
    PINFO_TABLE         InfoTable = NULL;


    InfoTable = FrsAlloc(sizeof(*InfoTable));
    InfoTable->ThreadCtx = FrsAllocType(THREAD_CONTEXT_TYPE);
    InfoTable->TableCtx = DbsCreateTableContext(TableType);
    InfoTable->Info = Info;
    InfoTable->Tabs = 0;   /* Tabs + 1*/   // Pitch this tabs stuff.

    IPRINT1(Info, "\n***** %ws\n", TableName);
    //
    // Setup a Jet Session (returning the session ID in ThreadCtx).
    //
    jerr = DbsCreateJetSession(InfoTable->ThreadCtx);
    if (!JET_SUCCESS(jerr)) {
        IPRINT2(Info,"ERROR - %ws: DbsCreateJetSession jet error %s.\n",
                TableName, ErrLabelJet(jerr));
        goto RETURN;
    }
    //
    // Init the table context and open the ID table.
    //
    jerr = DbsOpenTable(InfoTable->ThreadCtx,
                        InfoTable->TableCtx,
                        ReplicaAddrToId(Replica),
                        TableType,
                        NULL);
    if (!JET_SUCCESS(jerr)) {
        IPRINT2(Info,"ERROR - %ws: DbsOpenTable jet error %s.\n",
                TableName, ErrLabelJet(jerr));
        goto RETURN;
    }

    //
    // Replica
    //
    InfoTable->Replica = Replica;

    //
    // Scan thru the Table
    //
    jerr = FrsEnumerateTable(InfoTable->ThreadCtx,
                             InfoTable->TableCtx,
                             InfoIndexx,
                             InfoTableWorker,
                             InfoTable);
    //
    // We're done.  Return success if we made it to the end
    //
    if (jerr != JET_errNoCurrentRecord &&
        jerr != JET_wrnTableEmpty) {
        IPRINT2(Info,"ERROR - %ws: FrsEnumerateTable jet error %s.\n",
                TableName, ErrLabelJet(jerr));
    }

RETURN:
    //
    // Done
    //
    InfoTable = InfoFreeInfoTable(InfoTable, Info);

    return jerr;
}


DWORD
InfoPrintTables(
    IN PNTFRSAPI_INFO   Info,
    IN PWCHAR           TableDescriptor,
    IN TABLE_TYPE       TableType,
    IN ULONG            InfoIndexx,
    IN PENUMERATE_TABLE_ROUTINE InfoTableWorker
    )
/*++
Routine Description:
    Return internal info on a DB Table (see private\net\inc\ntfrsapi.h).

Arguments:
    Info    - RPC output buffer
    TableDescriptor - Text string for output
    TableType - Table type code (from schema.h)
    InfoIndexx - Table index to use for enumeration (from schema.h)

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintTables:"
    PVOID               Key;
    PREPLICA            Replica = NULL;
    extern PGEN_TABLE   ReplicasByGuid;


    //
    // Check for single instance tables.
    //
    if ((TableType == ConfigTablex) ||
        (TableType == ServiceTablex)) {

        InfoPrintSingleTable(Info,
                             TableDescriptor,
                             TableType,
                             Replica,
                             InfoIndexx,
                             InfoTableWorker);
        return ERROR_SUCCESS;
    }

    //
    // For the given table type, dump info for all replica sets.
    //
    IPRINT1(Info, "NTFRS %ws\n", TableDescriptor);

    Key = NULL;
    while (Replica = GTabNextDatum(ReplicasByGuid, &Key)) {

       InfoPrintSingleTable(Info,
                            Replica->ReplicaName->Name,
                            TableType,
                            Replica,
                            InfoIndexx,
                            InfoTableWorker);
    }

    return ERROR_SUCCESS;
}



DWORD
InfoPrintMemory(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs
    )
/*++
Routine Description:
    Return internal info on memory usage (see private\net\inc\ntfrsapi.h).

Arguments:
    Info    - RPC output buffer
    Tabs    - number of tabs

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintMemory:"
    FrsPrintAllocStats(0, Info, Tabs);
    FrsPrintRpcStats(0, Info, Tabs);
    return ERROR_SUCCESS;
}





DWORD
InfoPrintThreads(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs
    )
/*++
Routine Description:
    Return internal info on thread usage (see private\net\inc\ntfrsapi.h).

Arguments:
    Info    - RPC output buffer
    Tabs    - number of tabs

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintThreads:"
    FrsPrintThreadStats(0, Info, Tabs);
    return ERROR_SUCCESS;
}


VOID
FrsPrintStageStats(
    IN ULONG            Severity,
    IN PNTFRSAPI_INFO   Info,        OPTIONAL
    IN DWORD            Tabs
    );
DWORD
InfoPrintStage(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs
    )
/*++
Routine Description:
    Return internal info on thread usage (see private\net\inc\ntfrsapi.h).

Arguments:
    Info    - RPC output buffer
    Tabs    - number of tabs

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintStage:"
    FrsPrintStageStats(0, Info, Tabs);
    return ERROR_SUCCESS;
}


DWORD
InfoVerify(
    IN ULONG        BlobSize,
    IN OUT PBYTE    Blob
    )
/*++
Routine Description:
    Verify the consistency of the blob.

Arguments:
    BlobSize    - total bytes of Blob
    Blob        - details desired info and provides buffer for info

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoVerify:"
    DWORD   WStatus;
    PBYTE   EoB;
    PBYTE   EoI;
    PBYTE   BoL;
    PBYTE   BoF;
    PNTFRSAPI_INFO  Info = (PNTFRSAPI_INFO)Blob;

    //
    // Assume success
    //
    WStatus = ERROR_SUCCESS;

    //
    // Not a valid blob
    //
    if (BlobSize < NTFRSAPI_INFO_HEADER_SIZE) {
        WStatus = FRS_ERR_INVALID_SERVICE_PARAMETER;
        goto CLEANUP;
    }

    //
    // BlobSize must include the entire Blob
    //
    if (BlobSize != Info->SizeInChars) {
        WStatus = FRS_ERR_INVALID_SERVICE_PARAMETER;
        goto CLEANUP;
    }

    //
    // Return our info version
    //
    Info->NtFrsMajor = NTFRS_MAJOR;
    Info->NtFrsMinor = NTFRS_MINOR;
    SetFlag(Info->Flags, NTFRSAPI_INFO_FLAGS_VERSION);

    //
    // Bad major
    //
    if (Info->Major != Info->NtFrsMajor) {
        WStatus = FRS_ERR_INVALID_SERVICE_PARAMETER;
        goto CLEANUP;
    }
    //
    // Bad minor
    //
    if (Info->Minor != Info->NtFrsMinor) {
        WStatus = FRS_ERR_INVALID_SERVICE_PARAMETER;
        goto CLEANUP;
    }

    //
    // Not large enough to verify internal consistency
    //
    if (Info->SizeInChars < sizeof(NTFRSAPI_INFO)) {
        WStatus = FRS_ERR_INVALID_SERVICE_PARAMETER;
        goto CLEANUP;
    }

    //
    // Buffer full; done
    //
    if (FlagOn(Info->Flags, NTFRSAPI_INFO_FLAGS_FULL)) {
        goto CLEANUP;
    }

    //
    // Verify internal offsets
    //
    // make this into a subroutine (table driven?)
    //
    EoB = Blob + BlobSize;
    EoI = ((PBYTE)Info) + (Info->SizeInChars);
    BoL = (PBYTE)(((PCHAR)Info) + Info->OffsetToLines);
    BoF = (PBYTE)(((PCHAR)Info) + Info->OffsetToFree);
    if (EoI > EoB ||
        BoL > EoB ||
        BoF > EoB ||
        EoI < Blob ||
        BoL < Blob ||
        BoF < Blob) {
        WStatus = FRS_ERR_INVALID_SERVICE_PARAMETER;
        goto CLEANUP;
    }

    //
    // No free space in buffer; done
    //
    if (BoF == EoB) {
        SetFlag(Info->Flags, NTFRSAPI_INFO_FLAGS_FULL);
        goto CLEANUP;
    }
CLEANUP:
    return WStatus;
}


DWORD
Info(
    IN ULONG        BlobSize,
    IN OUT PBYTE    Blob
    )
/*++
Routine Description:
    Return internal info (see private\net\inc\ntfrsapi.h).

Arguments:
    BlobSize    - total bytes of Blob
    Blob        - details desired info and provides buffer for info

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "Info:"
    DWORD   WStatus;
    PBYTE   EoB;
    PBYTE   EoI;
    PBYTE   BoL;
    PBYTE   BoF;
    ULONG   i;
    PNTFRSAPI_INFO  Info = (PNTFRSAPI_INFO)Blob;
    ULONG ProductType;
    ULONG Arch;


    try {
        //
        // Verify the blob
        //
        WStatus = InfoVerify(BlobSize, Blob);
        if (!WIN_SUCCESS(WStatus)) {
            goto cleanup;
        }

        //
        // Full buffer; done
        //
        if (FlagOn(Info->Flags, NTFRSAPI_INFO_FLAGS_FULL)) {
            goto cleanup;
        }

        if (Info->TypeOfInfo == NTFRSAPI_INFO_TYPE_VERSION) {
            IPRINT0(Info, "NtFrs Version Information\n");
            IPRINT1(Info, "   NtFrs Major        : %d\n", NtFrsMajor);
            IPRINT1(Info, "   NtFrs Minor        : %d\n", NtFrsMinor);
            // IPRINT1(Info, "   NtFrs Module       : %s\n", NtFrsModule);
            IPRINT2(Info, "   NtFrs Compiled on  : %s %s\n", NtFrsDate, NtFrsTime);
#if    NTFRS_TEST
            IPRINT0(Info, "   NTFRS_TEST Enabled\n");
#else  NTFRS_TEST
            IPRINT0(Info, "   NTFRS_TEST Disabled\n");
#endif NTFRS_TEST

            i = 0;
            while (LatestChanges[i] != NULL) {
                IPRINT1(Info, "   %s\n", LatestChanges[i]);
                i++;
            }


            IPRINT4(Info, "OS Version %d.%d (%d) - %w\n",
                    OsInfo.dwMajorVersion, OsInfo.dwMinorVersion,
                    OsInfo.dwBuildNumber, OsInfo.szCSDVersion);

            ProductType = (ULONG) OsInfo.wProductType;
            IPRINT4(Info, "SP (%hd.%hd) SM: 0x%04hx  PT: 0x%02x\n",
                    OsInfo.wServicePackMajor, OsInfo.wServicePackMinor,
                    OsInfo.wSuiteMask, ProductType);

            Arch = SystemInfo.wProcessorArchitecture;
            if (Arch >= ARRAY_SZ(ProcessorArchName)) {
                Arch = ARRAY_SZ(ProcessorArchName)-1;
            }

            IPRINT5(Info, "Processor:  %s Level: 0x%04hx  Revision: 0x%04hx  Processor num/mask: %d/%08x\n",
                   ProcessorArchName[Arch], SystemInfo.wProcessorLevel,
                   SystemInfo.wProcessorRevision, SystemInfo.dwNumberOfProcessors,
                   SystemInfo.dwActiveProcessorMask);

            goto cleanup;

        } else if (Info->TypeOfInfo == NTFRSAPI_INFO_TYPE_SETS) {
            WStatus = InfoPrintDbSets(Info, 0);

        } else if (Info->TypeOfInfo == NTFRSAPI_INFO_TYPE_DS) {
            WStatus = InfoPrintDs(Info, 0);

        } else if (Info->TypeOfInfo == NTFRSAPI_INFO_TYPE_MEMORY) {
            WStatus = InfoPrintMemory(Info, 0);

        } else if (Info->TypeOfInfo == NTFRSAPI_INFO_TYPE_IDTABLE) {
            WStatus = InfoPrintTables(Info,
                                      L"ID TABLES",
                                      IDTablex,
                                      GuidIndexx,
                                      InfoIDTableWorker);

        } else if (Info->TypeOfInfo == NTFRSAPI_INFO_TYPE_INLOG) {
            WStatus = InfoPrintTables(Info,
                                      L"INLOG TABLES",
                                      INLOGTablex,
                                      ILSequenceNumberIndexx,
                                      InfoInLogTableWorker);

        } else if (Info->TypeOfInfo == NTFRSAPI_INFO_TYPE_OUTLOG) {
            WStatus = InfoPrintTables(Info,
                                      L"OUTLOG TABLES",
                                      OUTLOGTablex,
                                      OLSequenceNumberIndexx,
                                      InfoOutLogTableWorker);

        } else if (Info->TypeOfInfo == NTFRSAPI_INFO_TYPE_CONFIGTABLE) {
            WStatus = InfoPrintTables(Info,
                                      L"CONFIG TABLE",
                                      ConfigTablex,
                                      ReplicaSetNameIndexx,
                                      InfoConfigTableWorker);

        } else if (Info->TypeOfInfo == NTFRSAPI_INFO_TYPE_THREADS) {
            WStatus = InfoPrintThreads(Info, 0);

        } else if (Info->TypeOfInfo == NTFRSAPI_INFO_TYPE_STAGE) {
            WStatus = InfoPrintStage(Info, 0);

        } else {
            IPRINT1(Info, "NtFrs Doesn't understand TypeOfInfo %d\n",
                    Info->TypeOfInfo);
        }
cleanup:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }
    //
    // Clean up any handles, events, memory, ...
    //
    try {
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }
    return WStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\util\ntutils.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    ntutils.c

Abstract:

    This module contains various tools from NT land. Made a separate
    file because of the use of various nt headers.


--*/

#include <ntreppch.h>
#pragma  hdrstop

#include <frs.h>

#include <ntdddisk.h>

BOOL
FrsIsDiskWriteCacheEnabled(
    IN PWCHAR Path
    )
/*++

Description:

    Determines if the disk has enabled write caching.

Arguments:

    Path    - Fully qualified path of a file or directory

Return value:

    TRUE if write cache is enabled, FALSE otherwise.

--*/
{
#undef DEBSUB
#define DEBSUB  "FrsIsDiskWriteCacheEnabled:"
    DWORD               WStatus;
    ULONG               bytesTransferred;
    PWCHAR              Volume = NULL;
    HANDLE              driveHandle = INVALID_HANDLE_VALUE;

    DISK_CACHE_INFORMATION cacheInfo;
    cacheInfo.WriteCacheEnabled = FALSE;

    try {
        //
        // Extract the volume from Path
        //
        Volume = FrsWcsVolume(Path);
        if (!Volume) {
            goto CLEANUP;
        }

        //
        // Open handle to the PhysicalDrive
        //
        DPRINT1(4, ":S: Checking the write cache state on %ws\n", Volume);
        driveHandle = CreateFile(Volume,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_EXISTING,
                                 0,
                                 NULL);

        if (!HANDLE_IS_VALID(driveHandle)) {
            WStatus = GetLastError();
            DPRINT1_WS(4, ":S: WARN - Could not open drive %ws;", Volume, WStatus);
            goto CLEANUP;
        }


        //
        // Get cache info - IOCTL_DISK_GET_CACHE_INFORMATION
        //
        if (!DeviceIoControl(driveHandle,
                             IOCTL_DISK_GET_CACHE_INFORMATION,
                             NULL,
                             0,
                             &cacheInfo,
                             sizeof(DISK_CACHE_INFORMATION),
                             &bytesTransferred,
                             NULL))   {
            WStatus = GetLastError();
            DPRINT1_WS(4, ":S: WARN - DeviceIoControl(%ws);", Volume, WStatus);
            goto CLEANUP;
        }

        DPRINT2(4, ":S: NEW IOCTL: Write cache on %ws is %s\n",
                Volume, (cacheInfo.WriteCacheEnabled) ? "Enabled (WARNING)" : "Disabled");

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
        DPRINT_WS(0, "ERROR - Exception.", WStatus);
    }
    //
    // Cleanup handles, memory, ...
    //
    try {
        FRS_CLOSE(driveHandle );
        FrsFree(Volume);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
        DPRINT_WS(0, "ERROR - Cleanup Exception.", WStatus);
    }

    return cacheInfo.WriteCacheEnabled;

} // IsDiskWriteCacheEnabled
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\util\name.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Name.c

NOTE: The code is copied here from FsRtl because it called the pool allocator.
      The function prefixes were changed to avoid confusion.

Abstract:

    The unicode name support package is for manipulating unicode strings
    The routines allow the caller to dissect and compare strings.

    The following routines are provided by this package:

      o  FrsDissectName - This routine takes a path name string and breaks
         into two parts.  The first name in the string and the remainder.
         It also checks that the first name is valid for an NT file.

      o  FrsColateNames - This routine is used to colate directories
         according to lexical ordering.  Lexical ordering is strict unicode
         numerical oerdering.

      o  FrsDoesNameContainsWildCards - This routine tells the caller if
         a string contains any wildcard characters.

      o  FrsIsNameInExpression - This routine is used to compare a string
         against a template (possibly containing wildcards) to sees if the
         string is in the language denoted by the template.

Author:

    Gary Kimura     [GaryKi]    5-Feb-1990

Revision History:

--*/

#include <ntreppch.h>
#pragma  hdrstop

#define DEBSUB  "NAME:"

#include <frs.h>

//
//  Local support routine prototypes
//

BOOLEAN
FrsIsNameInExpressionPrivate (
    IN PUNICODE_STRING Expression,
    IN PUNICODE_STRING Name,
    IN BOOLEAN IgnoreCase,
    IN PWCH UpcaseTable
    );



VOID
FrsDissectName (
    IN UNICODE_STRING Path,
    OUT PUNICODE_STRING FirstName,
    OUT PUNICODE_STRING RemainingName
    )

/*++

Routine Description:

    This routine cracks a path.  It picks off the first element in the
    given path name and provides both it and the remaining part.  A path
    is a set of file names separated by backslashes.  If a name begins
    with a backslash, the FirstName is the string immediately following
    the backslash.  Here are some examples:

        Path           FirstName    RemainingName
        ----           ---------    -------------
        empty          empty        empty

        \              empty        empty

        A              A            empty

        \A             A            empty

        A\B\C\D\E      A            B\C\D\E

        *A?            *A?          empty


    Note that both output strings use the same string buffer memory of the
    input string, and are not necessarily null terminated.

    Also, this routine makes no judgement as to the legality of each
    file name componant.  This must be done separatly when each file name
    is extracted.

Arguments:

    Path - The full path name to crack.

    FirstName - The first name in the path.  Don't allocate a buffer for
        this string.

    RemainingName - The rest of the path.  Don't allocate a buffer for this
        string.

Return Value:

    None.

--*/

{
    ULONG i = 0;
    ULONG PathLength;
    ULONG FirstNameStart;

    //
    //  Make both output strings empty for now
    //

    FRS_ASSERT( ValueIsMultOf2(Path.Length) );

    FirstName->Length = 0;
    FirstName->MaximumLength = 0;
    FirstName->Buffer = NULL;

    RemainingName->Length = 0;
    RemainingName->MaximumLength = 0;
    RemainingName->Buffer = NULL;

    PathLength = Path.Length / sizeof(WCHAR);

    //
    //  Check for an empty input string
    //

    if (PathLength == 0) {

        return;
    }

    //
    //  Skip over a starting backslash, and make sure there is more.
    //

    if ( Path.Buffer[0] == L'\\' ) {

        i = 1;
    }

    //
    //  Now run down the input string until we hit a backslash or the end
    //  of the string, remembering where we started;
    //

    for ( FirstNameStart = i;
          (i < PathLength) && (Path.Buffer[i] != L'\\');
          i += 1 ) {

        NOTHING;
    }

    //
    //  At this point all characters up to (but not including) i are
    //  in the first part.   So setup the first name
    //

    FirstName->Length = (USHORT)((i - FirstNameStart) * sizeof(WCHAR));
    FirstName->MaximumLength = FirstName->Length;
    FirstName->Buffer = &Path.Buffer[FirstNameStart];

    //
    //  Now the remaining part needs a string only if the first part didn't
    //  exhaust the entire input string.  We know that if anything is left
    //  that is must start with a backslash.  Note that if there is only
    //  a trailing backslash, the length will get correctly set to zero.
    //

    if (i < PathLength) {

        RemainingName->Length = (USHORT)((PathLength - (i + 1)) * sizeof(WCHAR));
        RemainingName->MaximumLength = RemainingName->Length;
        RemainingName->Buffer = &Path.Buffer[i + 1];
    }

    //
    //  And return to our caller
    //

    return;
}

BOOLEAN
FrsDoesNameContainWildCards (
    IN PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine simply scans the input Name string looking for any Nt
    wild card characters.

Arguments:

    Name - The string to check.

Return Value:

    BOOLEAN - TRUE if one or more wild card characters was found.

--*/
{
    PUSHORT p;

    FRS_ASSERT( ValueIsMultOf2(Name->Length) );

    //
    //  Check each character in the name to see if it's a wildcard
    //  character.
    //

    if( Name->Length ) {
        for( p = Name->Buffer + (Name->Length / sizeof(WCHAR)) - 1;
             p >= Name->Buffer && *p != L'\\' ;
             p-- ) {

            //
            //  check for a wild card character
            //

            if (FrsIsUnicodeCharacterWild( *p )) {

                //
                //  Tell caller that this name contains wild cards
                //

                return TRUE;
            }
        }
    }

    //
    //  No wildcard characters were found, so return to our caller
    //

    return FALSE;
}


BOOLEAN
FrsAreNamesEqual (
    IN PUNICODE_STRING ConstantNameA,
    IN PUNICODE_STRING ConstantNameB,
    IN BOOLEAN IgnoreCase,
    IN PCWCH UpcaseTable OPTIONAL
    )

/*++

Routine Description:

    This routine simple returns whether the two names are exactly equal.
    If the two names are known to be constant, this routine is much
    faster than FrsIsNameInExpression.

Arguments:

    ConstantNameA - Constant name.

    ConstantNameB - Constant name.

    IgnoreCase - TRUE if the Names should be Upcased before comparing.

    UpcaseTable - If supplied, use this table for case insensitive compares,
        otherwise, use the default system upcase table.

Return Value:

    BOOLEAN - TRUE if the two names are lexically equal.

--*/

{
    ULONG Index;
    ULONG NameLength;
    BOOLEAN FreeStrings = FALSE;

    UNICODE_STRING LocalNameA;
    UNICODE_STRING LocalNameB;


    FRS_ASSERT( ValueIsMultOf2(ConstantNameA->Length) );
    FRS_ASSERT( ValueIsMultOf2(ConstantNameB->Length) );

    //
    // If the names aren't even the same size, then return FALSE right away.
    //

    if ( ConstantNameA->Length != ConstantNameB->Length ) {

        return FALSE;
    }

    NameLength = ConstantNameA->Length / sizeof(WCHAR);

    //
    //  If we weren't given an upcase table, we have to upcase the names
    //  ourselves.
    //

    if ( IgnoreCase && !ARGUMENT_PRESENT(UpcaseTable) ) {

        NTSTATUS Status;

        Status = RtlUpcaseUnicodeString( &LocalNameA, ConstantNameA, TRUE );
        if ( !NT_SUCCESS(Status) ) {
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }

        Status = RtlUpcaseUnicodeString( &LocalNameB, ConstantNameB, TRUE );
        if ( !NT_SUCCESS(Status) ) {
            RtlFreeUnicodeString( &LocalNameA );
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }

        ConstantNameA = &LocalNameA;
        ConstantNameB = &LocalNameB;

        IgnoreCase = FALSE;
        FreeStrings = TRUE;
    }

    //
    //  Do either case sensitive or insensitive compare.
    //

    if ( !IgnoreCase ) {

        BOOLEAN BytesEqual;

        BytesEqual = (BOOLEAN) RtlEqualMemory( ConstantNameA->Buffer,
                                               ConstantNameB->Buffer,
                                               ConstantNameA->Length );

        if ( FreeStrings ) {

            RtlFreeUnicodeString( &LocalNameA );
            RtlFreeUnicodeString( &LocalNameB );
        }

        return BytesEqual;

    } else {

        for (Index = 0; Index < NameLength; Index += 1) {

            if ( UpcaseTable[ConstantNameA->Buffer[Index]] !=
                 UpcaseTable[ConstantNameB->Buffer[Index]] ) {

                return FALSE;
            }
        }

        return TRUE;
    }
}


//
//  The following routine is just a wrapper around
//  FrsIsNameInExpressionPrivate to make a last minute fix a bit safer.
//

BOOLEAN
FrsIsNameInExpression (
    IN PUNICODE_STRING Expression,
    IN PUNICODE_STRING Name,
    IN BOOLEAN IgnoreCase,
    IN PWCH UpcaseTable OPTIONAL
    )

{
    BOOLEAN Result;
    UNICODE_STRING LocalName;


    FRS_ASSERT( ValueIsMultOf2(Expression->Length) );
    FRS_ASSERT( ValueIsMultOf2(Name->Length) );

    //
    //  If we weren't given an upcase table, we have to upcase the names
    //  ourselves.
    //

    if ( IgnoreCase && !ARGUMENT_PRESENT(UpcaseTable) ) {

        NTSTATUS Status;

        Status = RtlUpcaseUnicodeString( &LocalName, Name, TRUE );

        if ( !NT_SUCCESS(Status) ) {
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }

        Name = &LocalName;

        IgnoreCase = FALSE;

    } else {

        LocalName.Buffer = NULL;
    }

    //
    //  Now call the main routine, remembering to free the upcased string
    //  if we allocated one.
    //

    try {

        Result = FrsIsNameInExpressionPrivate( Expression,
                                                 Name,
                                                 IgnoreCase,
                                                 UpcaseTable );

    } finally {

        if (LocalName.Buffer != NULL) {

            RtlFreeUnicodeString( &LocalName );
        }
    }

    return Result;
}


#define MATCHES_ARRAY_SIZE 16

//
//  Local support routine prototypes
//

BOOLEAN
FrsIsNameInExpressionPrivate (
    IN PUNICODE_STRING Expression,
    IN PUNICODE_STRING Name,
    IN BOOLEAN IgnoreCase,
    IN PWCH UpcaseTable
    )

/*++

Routine Description:

    This routine compares a Dbcs name and an expression and tells the caller
    if the name is in the language defined by the expression.  The input name
    cannot contain wildcards, while the expression may contain wildcards.

    Expression wild cards are evaluated as shown in the nondeterministic
    finite automatons below.  Note that ~* and ~? are DOS_STAR and DOS_QM.


             ~* is DOS_STAR, ~? is DOS_QM, and ~. is DOS_DOT


                                       S
                                    <-----<
                                 X  |     |  e       Y
             X * Y ==       (0)----->-(1)->-----(2)-----(3)


                                      S-.
                                    <-----<
                                 X  |     |  e       Y
             X ~* Y ==      (0)----->-(1)->-----(2)-----(3)



                                X     S     S     Y
             X ?? Y ==      (0)---(1)---(2)---(3)---(4)



                                X     .        .      Y
             X ~.~. Y ==    (0)---(1)----(2)------(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^


                                X     S-.     S-.     Y
             X ~?~? Y ==    (0)---(1)-----(2)-----(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^



         where S is any single character

               S-. is any single character except the final .

               e is a null character transition

               EOF is the end of the name string

    In words:

        * matches 0 or more characters.

        ? matches exactly 1 character.

        DOS_STAR matches 0 or more characters until encountering and matching
            the final . in the name.

        DOS_QM matches any single character, or upon encountering a period or
            end of name string, advances the expression to the end of the
            set of contiguous DOS_QMs.

        DOS_DOT matches either a . or zero characters beyond name string.

Arguments:

    Expression - Supplies the input expression to check against
        (Caller must already upcase if passing CaseInsensitive TRUE.)

    Name - Supplies the input name to check for.

    IgnoreCase - TRUE if Name should be Upcased before comparing.

    UpcaseTable - UpCase table to use if Ingoring Case.

Return Value:

    BOOLEAN - TRUE if Name is an element in the set of strings denoted
        by the input Expression and FALSE otherwise.

--*/

{
    USHORT NameOffset;
    USHORT ExprOffset;

    ULONG SrcCount;
    ULONG DestCount;
    ULONG PreviousDestCount;
    ULONG MatchesCount;

    WCHAR NameChar, ExprChar;

    USHORT LocalBuffer[MATCHES_ARRAY_SIZE * 2];

    USHORT *AuxBuffer = NULL;
    USHORT *PreviousMatches;
    USHORT *CurrentMatches;

    USHORT MaxState;
    USHORT CurrentState;

    BOOLEAN NameFinished = FALSE;

    //
    //  The idea behind the algorithm is pretty simple.  We keep track of
    //  all possible locations in the regular expression that are matching
    //  the name.  If when the name has been exhausted one of the locations
    //  in the expression is also just exhausted, the name is in the language
    //  defined by the regular expression.
    //

    FRS_ASSERT( Name->Length != 0 );
    FRS_ASSERT( ValueIsMultOf2(Name->Length) );

    FRS_ASSERT( Expression->Length != 0 );
    FRS_ASSERT( ValueIsMultOf2(Expression->Length) );

    //
    //  If one string is empty return FALSE.  If both are empty return TRUE.
    //

    if ( (Name->Length == 0) || (Expression->Length == 0) ) {

        return (BOOLEAN)(!(Name->Length + Expression->Length));
    }

    //
    //  Special case by far the most common wild card search of *
    //

    if ((Expression->Length == 2) && (Expression->Buffer[0] == L'*')) {

        return TRUE;
    }

    FRS_ASSERT( FrsDoesNameContainWildCards( Expression ) );

    FRS_ASSERT( !IgnoreCase || ARGUMENT_PRESENT(UpcaseTable) );

    //
    //  Also special case expressions of the form *X.  With this and the prior
    //  case we have covered virtually all normal queries.
    //

    if (Expression->Buffer[0] == L'*') {

        UNICODE_STRING LocalExpression;

        LocalExpression = *Expression;

        LocalExpression.Buffer += 1;
        LocalExpression.Length -= 2;

        //
        //  Only special case an expression with a single *
        //

        if ( !FrsDoesNameContainWildCards( &LocalExpression ) ) {

            ULONG StartingNameOffset;

            if (Name->Length < (USHORT)(Expression->Length - sizeof(WCHAR))) {

                return FALSE;
            }

            StartingNameOffset = ( Name->Length -
                                   LocalExpression.Length ) / sizeof(WCHAR);

            //
            //  Do a simple memory compare if case sensitive, otherwise
            //  we have got to check this one character at a time.
            //

            if ( !IgnoreCase ) {

                return (BOOLEAN) RtlEqualMemory( LocalExpression.Buffer,
                                                 Name->Buffer + StartingNameOffset,
                                                 LocalExpression.Length );

            } else {

                for ( ExprOffset = 0;
                      ExprOffset < (USHORT)(LocalExpression.Length / sizeof(WCHAR));
                      ExprOffset += 1 ) {

                    NameChar = Name->Buffer[StartingNameOffset + ExprOffset];
                    NameChar = UpcaseTable[NameChar];

                    ExprChar = LocalExpression.Buffer[ExprOffset];

                    FRS_ASSERT( ExprChar == UpcaseTable[ExprChar] );

                    if ( NameChar != ExprChar ) {

                        return FALSE;
                    }
                }

                return TRUE;
            }
        }
    }

    //
    //  Walk through the name string, picking off characters.  We go one
    //  character beyond the end because some wild cards are able to match
    //  zero characters beyond the end of the string.
    //
    //  With each new name character we determine a new set of states that
    //  match the name so far.  We use two arrays that we swap back and forth
    //  for this purpose.  One array lists the possible expression states for
    //  all name characters up to but not including the current one, and other
    //  array is used to build up the list of states considering the current
    //  name character as well.  The arrays are then switched and the process
    //  repeated.
    //
    //  There is not a one-to-one correspondence between state number and
    //  offset into the expression.  This is evident from the NFAs in the
    //  initial comment to this function.  State numbering is not continuous.
    //  This allows a simple conversion between state number and expression
    //  offset.  Each character in the expression can represent one or two
    //  states.  * and DOS_STAR generate two states: ExprOffset*2 and
    //  ExprOffset*2 + 1.  All other expreesion characters can produce only
    //  a single state.  Thus ExprOffset = State/2.
    //
    //
    //  Here is a short description of the variables involved:
    //
    //  NameOffset  - The offset of the current name char being processed.
    //
    //  ExprOffset  - The offset of the current expression char being processed.
    //
    //  SrcCount    - Prior match being investigated with current name char
    //
    //  DestCount   - Next location to put a matching assuming current name char
    //
    //  NameFinished - Allows one more itteration through the Matches array
    //                 after the name is exhusted (to come *s for example)
    //
    //  PreviousDestCount - This is used to prevent entry duplication, see coment
    //
    //  PreviousMatches   - Holds the previous set of matches (the Src array)
    //
    //  CurrentMatches    - Holds the current set of matches (the Dest array)
    //
    //  AuxBuffer, LocalBuffer - the storage for the Matches arrays
    //

    //
    //  Set up the initial variables
    //

    PreviousMatches = &LocalBuffer[0];
    CurrentMatches = &LocalBuffer[MATCHES_ARRAY_SIZE];

    PreviousMatches[0] = 0;
    MatchesCount = 1;

    NameOffset = 0;

    MaxState = (USHORT)(Expression->Length * 2);

    while ( !NameFinished ) {

        if ( NameOffset < Name->Length ) {

            NameChar = Name->Buffer[NameOffset / sizeof(WCHAR)];

            NameOffset += sizeof(WCHAR);;

        } else {

            NameFinished = TRUE;

            //
            //  if we have already exhasted the expression, cool.  Don't
            //  continue.
            //

            if ( PreviousMatches[MatchesCount-1] == MaxState ) {

                break;
            }
        }


        //
        //  Now, for each of the previous stored expression matches, see what
        //  we can do with this name character.
        //

        SrcCount = 0;
        DestCount = 0;
        PreviousDestCount = 0;

        while ( SrcCount < MatchesCount ) {

            USHORT Length;

            //
            //  We have to carry on our expression analysis as far as possible
            //  for each character of name, so we loop here until the
            //  expression stops matching.  A clue here is that expression
            //  cases that can match zero or more characters end with a
            //  continue, while those that can accept only a single character
            //  end with a break.
            //

            ExprOffset = (USHORT)((PreviousMatches[SrcCount++] + 1) / 2);


            Length = 0;

            while ( TRUE ) {

                if ( ExprOffset == Expression->Length ) {

                    break;
                }

                //
                //  The first time through the loop we don't want
                //  to increment ExprOffset.
                //

                ExprOffset += Length;
                Length = sizeof(WCHAR);

                CurrentState = (USHORT)(ExprOffset * 2);

                if ( ExprOffset == Expression->Length ) {

                    CurrentMatches[DestCount++] = MaxState;
                    break;
                }

                ExprChar = Expression->Buffer[ExprOffset / sizeof(WCHAR)];

                FRS_ASSERT( !IgnoreCase || !((ExprChar >= L'a') && (ExprChar <= L'z')) );

                //
                //  Before we get started, we have to check for something
                //  really gross.  We may be about to exhaust the local
                //  space for ExpressionMatches[][], so we have to allocate
                //  some memory if this is the case.  Yuk!
                //

                if ( (DestCount >= MATCHES_ARRAY_SIZE - 2) &&
                     (AuxBuffer == NULL) ) {

                    ULONG ExpressionChars;

                    ExpressionChars = Expression->Length / sizeof(WCHAR);

                    AuxBuffer = FrsAlloc((ExpressionChars+1)*sizeof(USHORT)*2*2);

                    CopyMemory(AuxBuffer, CurrentMatches, MATCHES_ARRAY_SIZE * sizeof(USHORT) );

                    CurrentMatches = AuxBuffer;

                    CopyMemory(AuxBuffer + (ExpressionChars+1)*2, PreviousMatches,
                                   MATCHES_ARRAY_SIZE * sizeof(USHORT) );

                    PreviousMatches = AuxBuffer + (ExpressionChars+1)*2;
                }

                //
                //  * matches any character zero or more times.
                //

                if (ExprChar == L'*') {

                    CurrentMatches[DestCount++] = CurrentState;
                    CurrentMatches[DestCount++] = CurrentState + 3;
                    continue;
                }

                //
                //  DOS_STAR matches any character except . zero or more times.
                //

                if (ExprChar == DOS_STAR) {

                    BOOLEAN ICanEatADot = FALSE;

                    //
                    //  If we are at a period, determine if we are allowed to
                    //  consume it, ie. make sure it is not the last one.
                    //

                    if ( !NameFinished && (NameChar == '.') ) {

                        USHORT Offset;

                        for ( Offset = NameOffset;
                              Offset < Name->Length;
                              Offset += Length ) {

                            if (Name->Buffer[Offset / sizeof(WCHAR)] == L'.') {

                                ICanEatADot = TRUE;
                                break;
                            }
                        }
                    }

                    if (NameFinished || (NameChar != L'.') || ICanEatADot) {

                        CurrentMatches[DestCount++] = CurrentState;
                        CurrentMatches[DestCount++] = CurrentState + 3;
                        continue;

                    } else {

                        //
                        //  We are at a period.  We can only match zero
                        //  characters (ie. the epsilon transition).
                        //

                        CurrentMatches[DestCount++] = CurrentState + 3;
                        continue;
                    }
                }

                //
                //  The following expreesion characters all match by consuming
                //  a character, thus force the expression, and thus state
                //  forward.
                //

                CurrentState += (USHORT)(sizeof(WCHAR) * 2);

                //
                //  DOS_QM is the most complicated.  If the name is finished,
                //  we can match zero characters.  If this name is a '.', we
                //  don't match, but look at the next expression.  Otherwise
                //  we match a single character.
                //

                if ( ExprChar == DOS_QM ) {

                    if ( NameFinished || (NameChar == L'.') ) {

                        continue;
                    }

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  A DOS_DOT can match either a period, or zero characters
                //  beyond the end of name.
                //

                if (ExprChar == DOS_DOT) {

                    if ( NameFinished ) {

                        continue;
                    }

                    if (NameChar == L'.') {

                        CurrentMatches[DestCount++] = CurrentState;
                        break;
                    }
                }

                //
                //  From this point on a name character is required to even
                //  continue, let alone make a match.
                //

                if ( NameFinished ) {

                    break;
                }

                //
                //  If this expression was a '?' we can match it once.
                //

                if (ExprChar == L'?') {

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  Finally, check if the expression char matches the name char
                //

                if (ExprChar == (WCHAR)(IgnoreCase ?
                                        UpcaseTable[NameChar] : NameChar)) {

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  The expression didn't match so go look at the next
                //  previous match.
                //

                break;
            }


            //
            //  Prevent duplication in the destination array.
            //
            //  Each of the arrays is montonically increasing and non-
            //  duplicating, thus we skip over any source element in the src
            //  array if we just added the same element to the destination
            //  array.  This guarentees non-duplication in the dest. array.
            //

            if ((SrcCount < MatchesCount) &&
                (PreviousDestCount < DestCount) ) {

                while (PreviousDestCount < DestCount) {

                    while ( PreviousMatches[SrcCount] <
                         CurrentMatches[PreviousDestCount] ) {

                        SrcCount += 1;
                    }

                    PreviousDestCount += 1;
                }
            }
        }

        //
        //  If we found no matches in the just finished itteration, it's time
        //  to bail.
        //

        if ( DestCount == 0 ) {

            if (AuxBuffer != NULL) { FrsFree( AuxBuffer ); }

            return FALSE;
        }

        //
        //  Swap the meaning the two arrays
        //

        {
            USHORT *Tmp;

            Tmp = PreviousMatches;

            PreviousMatches = CurrentMatches;

            CurrentMatches = Tmp;
        }

        MatchesCount = DestCount;
    }


    CurrentState = PreviousMatches[MatchesCount-1];

    if (AuxBuffer != NULL) { FrsFree( AuxBuffer ); }


    return (BOOLEAN)(CurrentState == MaxState);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\util\staging.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    staging.c

Abstract:

    This module implements staging support routines for FRS

Author:

    Billy Fuller 26-Jun-1997

    David Orbits Aug-99:  Move utility funcs to util.c, fix func name prefixes.

Revision History:

--*/

#include <ntreppch.h>
#pragma  hdrstop


#include <frs.h>
#include <tablefcn.h>
#include <perrepsr.h>
// #include <md5.h>
#include <winbase.h>

#define STAGEING_IOSIZE  (64 * 1024)

#define STAGING_RESET_SE    (SE_OWNER_DEFAULTED | \
                             SE_GROUP_DEFAULTED | \
                             SE_DACL_DEFAULTED  | \
                             SE_DACL_AUTO_INHERITED | \
                             SE_SACL_AUTO_INHERITED | \
                             SE_SACL_DEFAULTED)


#define CB_NAMELESSHEADER    FIELD_OFFSET(WIN32_STREAM_ID, cStreamName)

DWORD
FrsDeleteById(
    IN PWCHAR                   VolumeName,
    IN PWCHAR                   Name,
    IN PVOLUME_MONITOR_ENTRY    pVme,
    IN  PVOID                   Id,
    IN  DWORD                   IdLen
    );

DWORD
FrsGetFileInternalInfoByHandle(
    IN HANDLE Handle,
    OUT PFILE_INTERNAL_INFORMATION  InternalFileInfo
    );

DWORD
FrsGetReparseTag(
    IN  HANDLE  Handle,
    OUT ULONG   *ReparseTag
    );

PWCHAR
FrsGetTrueFileNameByHandle(
    IN PWCHAR   Name,
    IN HANDLE   Handle,
    OUT PLONGLONG DirFileID
    );

DWORD
FrsGetCompressionRoutine(
    IN  PWCHAR   FileName,
    IN  HANDLE   FileHandle,
    OUT DWORD    (**ppFrsCompressBuffer)(IN UnCompressedBuf, IN UnCompressedBufLen, CompressedBuf, CompressedBufLen, CompressedSize),
    OUT GUID     *pCompressionFormatGuid
    );

DWORD
FrsGetDecompressionRoutine(
    IN  PCHANGE_ORDER_COMMAND Coc,
    IN  PSTAGE_HEADER         StageHeader,
    OUT DWORD (**ppFrsDecompressBuffer)(OUT DecompressedBuf, IN DecompressedBufLen, IN CompressedBuf, IN CompressedBufLen, OUT DecompressedSize, OUT BytesProcessed),
    OUT PVOID (**ppFrsFreeDecompressContext)(IN pDecompressContext)
    );

DWORD
FrsGetDecompressionRoutineByGuid(
    IN  GUID  *CompressionFormatGuid,
    OUT DWORD (**ppFrsDecompressBuffer)(OUT DecompressedBuf, IN DecompressedBufLen, IN CompressedBuf, IN CompressedBufLen, OUT DecompressedSize, OUT BytesProcessed),
    OUT PVOID (**ppFrsFreeDecompressContext)(IN pDecompressContext)
    );


extern PGEN_TABLE   CompressionTable;


DWORD
StuOpenFile(
    IN  PWCHAR   Name,
    IN  DWORD    Access,
    OUT PHANDLE  pHandle
    )
/*++
Routine Description:
    open a file

Arguments:
    Name
    Access
    pHandle

Return Value:
    WStatus
--*/
{
#undef DEBSUB
#define DEBSUB  "StuOpenFile:"

    DWORD WStatus = ERROR_SUCCESS;

    if (pHandle == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *pHandle = INVALID_HANDLE_VALUE;

    //
    // Open the file
    //
    *pHandle = CreateFile(Name,
                        Access,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_SEQUENTIAL_SCAN |
                        FILE_FLAG_BACKUP_SEMANTICS,
                        NULL);

    if (!HANDLE_IS_VALID(*pHandle)) {
        WStatus = GetLastError();
        DPRINT1_WS(0, "Can't open file %ws;", Name, WStatus);
    }

    return WStatus;
}






DWORD
StuWriteFile(
    IN PWCHAR   Name,
    IN HANDLE   Handle,
    IN PVOID    Buf,
    IN DWORD    BytesToWrite
    )
/*++
Routine Description:
    Write data into a file

Arguments:
    Name
    Handle
    Buf
    BytesToWrite

Return Value:
    WStatus
--*/
{
#undef DEBSUB
#define DEBSUB  "StuWriteFile:"
    DWORD   BytesWritten;
    BOOL    DidWrite;
    DWORD   WStatus = ERROR_SUCCESS;

    if (!BytesToWrite) {
        return ERROR_SUCCESS;
    }

    //
    // Write the file's name into the file
    //
    DidWrite = WriteFile(Handle, Buf, BytesToWrite, &BytesWritten, NULL);

    //
    // Write error
    //
    if (!DidWrite || BytesWritten != BytesToWrite) {
        WStatus = GetLastError();
        DPRINT1_WS(0, "++ Can't write file %ws;", Name, WStatus);
        return WStatus;
    }
    //
    // Done
    //
    return WStatus;
}


DWORD
StuReadFile(
    IN  PWCHAR  Name,
    IN  HANDLE  Handle,
    IN  PVOID   Buf,
    IN  DWORD   BytesToRead,
    OUT PDWORD  BytesRead
    )
/*++
Routine Description:
    Read data from a file

Arguments:
    Name -- File name for error message.
    Handle -- Open handle to file.
    Buf - Buffer for read data.
    BytesToRead  -- Number of bytes to read from the current file posn.
    BytesRead -- Actual number of bytes read.

Return Value:
    WStatus
--*/
{
#undef DEBSUB
#define DEBSUB  "StuReadFile:"

    BOOL    DidRead;
    DWORD   WStatus = ERROR_SUCCESS;


    DidRead = ReadFile(Handle, Buf, BytesToRead, BytesRead, NULL);

    //
    // Read error
    //
    if (!DidRead) {
        WStatus = GetLastError();
        DPRINT1_WS(0, "Can't read file %ws;", Name, WStatus);
        return WStatus;
    }

    //
    // Done
    //
    return WStatus;
}




BOOL
StuReadBlockFile(
    IN  PWCHAR  Name,
    IN  HANDLE  Handle,
    IN  PVOID   Buf,
    IN  DWORD   BytesToRead
    )
/*++
Routine Description:
    Read a block of data from a file

Arguments:
    Name -- File name for error message.
    Handle -- Open handle to file.
    Buf - Buffer for read data.
    BytesToRead  -- Number of bytes to read from the current file posn.

Return Value:

    TRUE    - no problem
    FALSE   - couldn't read
--*/
{
#undef DEBSUB
#define DEBSUB  "StuReadBlockFile:"

    ULONG    BytesRead;
    DWORD    WStatus    = ERROR_SUCCESS;


    WStatus = StuReadFile(Name, Handle, Buf, BytesToRead, &BytesRead);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, "Can't read file %ws;", Name, WStatus);
        return FALSE;
    }

    //
    // Read error
    //
    if (BytesRead != BytesToRead) {
        DPRINT1_WS(0, "Can't read file %ws;", Name, WStatus);
        return FALSE;
    }

    //
    // Done
    //
    return TRUE;
}



DWORD
StuCreateFile(
    IN  PWCHAR Name,
    OUT PHANDLE pHandle
    )
/*++
Routine Description:
    Create or overwrite a hidden, sequential file and open it with
    backup semantics and sharing disabled.

Arguments:
    Name
    pHandle Handle to return.

Return Value:
    WStatus
--*/
{
#undef DEBSUB
#define DEBSUB  "StuCreateFile:"

    DWORD  WStatus = ERROR_SUCCESS;

    //
    // Create the file
    //
    DPRINT1(4, "++ Creating %ws\n", Name);

    //
    // CREATE_ALWAYS - Always create the file.  If the file already
    //    exists, then it is overwritten.  The attributes for the new
    //    file are what is specified in the dwFlagsAndAttributes
    //    parameter or'd with FILE_ATTRIBUTE_ARCHIVE.  If the
    //    hTemplateFile is specified, then any extended attributes
    //    associated with that file are propogated to the new file.
    //

    *pHandle = INVALID_HANDLE_VALUE;

    *pHandle = CreateFile(Name,
                        GENERIC_READ | GENERIC_WRITE | DELETE | WRITE_DAC | WRITE_OWNER,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN |
                                                     FILE_ATTRIBUTE_HIDDEN,
                        NULL);

   if (!HANDLE_IS_VALID(*pHandle)) {
       WStatus = GetLastError();
       DPRINT1_WS(0, "++ Can't create file %ws;", Name, WStatus);
   }

   return WStatus;
}





PWCHAR
StuCreStgPath(
    IN PWCHAR   DirPath,
    IN GUID     *Guid,
    IN PWCHAR   Prefix
    )
/*++
Routine Description:
    Convert the change order guid into a staging path name (Replica->Stage\S_Guid).

Arguments:
    DirPath
    Guid
    Prefix

Return Value:
    Pathname for staging file
--*/
{
#undef DEBSUB
#define DEBSUB  "StuCreStgPath:"
    PWCHAR      StageName;
    PWCHAR      StagePath;

    //
    // Staging file name
    //
    StageName = FrsCreateGuidName(Guid, Prefix);

    //
    // Create the staging file path (StagingDirectory\S_Guid)
    //
    StagePath = FrsWcsPath(DirPath, StageName);

    //
    // Free the file name
    //
    FrsFree(StageName);

    return StagePath;
}



BOOL
StuCmpUsn(
    IN HANDLE   Handle,
    IN PCHANGE_ORDER_ENTRY Coe,
    IN USN     *TestUsn
    )
/*++
Routine Description:
    Check that the usn on the file identified by Handle matches
    the supplied USN.

Arguments:
    Handle
    Coe
    TestUsn   -- The Usn to test against.  Generally the caller will pass either
                 the ptr to the FileUsn if the CO has come from a downstream
                 partner as part of a fetch request, or the ptr to the JrnlUsn
                 if this is a local change order.

Return Value:
    TRUE    - Usn's match or the file or the usn don't exist
    FALSE   - Usn's don't match
--*/
{
#undef DEBSUB
#define DEBSUB  "StuCmpUsn:"
    ULONG   Status;
    ULONG   GStatus;
    USN     CurrentFileUsn;
    ULONGLONG  UnusedULongLong;
    ULONG_PTR UnusedFlags;
    PREPLICA   Replica;
    PCHANGE_ORDER_COMMAND Coc = &Coe->Cmd;

    if (!HANDLE_IS_VALID(Handle)) {
        return TRUE;
    }

    //
    // Directory creates must always propagate
    //
    if (CoCmdIsDirectory(Coc) &&
        (CO_NEW_FILE(GET_CO_LOCATION_CMD(*Coc, Command)))) {
            return TRUE;
    }

    //
    // If the Usn changed during the install then we don't want
    // to overwrite the current updated file with this data. The
    // new changes are "more recent". Discard the change order.
    //
    Status = FrsReadFileUsnData(Handle, &CurrentFileUsn);
    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    if (CurrentFileUsn == *TestUsn) {
        return TRUE;
    }
    //
    // Usn can't move backwards.
    //
    FRS_ASSERT(CurrentFileUsn > *TestUsn);

    CHANGE_ORDER_COMMAND_TRACE(3, Coc, "Usn changed");
    //
    // It is possible that the USN change to the file is caused by our
    // own writing of the object ID on a new file.  To determine if this has
    // happened check the dampening cache for one of our OID close entries
    // using the USN we got from the file.  If the file USN is greater than
    // the value in the dampening cache then a more recent update has occurred
    // and we abort because another change order will be coming.
    //
    Replica = CO_REPLICA(Coe);
    FRS_ASSERT(Replica != NULL);

    GStatus = QHashLookup(Replica->pVme->FrsWriteFilter,
                          &CurrentFileUsn,
                          &UnusedULongLong,  // unused result
                          &UnusedFlags); // unused result

    if (GStatus == GHT_STATUS_SUCCESS) {
        DPRINT1(1, "++ USN Write filter cache hit on %08x %08x\n",
                PRINTQUAD(CurrentFileUsn));
        return TRUE;
    }

    //
    // There must be an update to the file that is after our last write (if any)
    // so it's nogo.
    //
    return FALSE;
}


DWORD
StuDeleteEmptyDirectory(
    IN HANDLE               DirectoryHandle,
    IN PCHANGE_ORDER_ENTRY  Coe,
    IN DWORD                InWStatus
    )
/*++
Routine Description:
    Empty a directory of non-replicating files and dirs if this is
    an ERROR_DIR_NOT_EMPTY and this is a retry change order for a
    directory delete.

Arguments:
    DirectoryHandle - Handle of directory that could not be deleted
    Coe             - change order entry
    InWStatus       - Error from FrsDeleteByHandle()

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define DEBSUB  "StuDeleteEmptyDirectory:"
    DWORD   WStatus;
    PCHANGE_ORDER_COMMAND Coc = &Coe->Cmd;

    //
    // Empty the directory iff this is a retry change order for
    // a failed directory delete.
    //
    if (InWStatus != ERROR_DIR_NOT_EMPTY ||
        !CoCmdIsDirectory(Coc) ||
        !COC_FLAG_ON(Coc, CO_FLAG_RETRY)) {
        return InWStatus;
    }

    WStatus = FrsEnumerateDirectory(DirectoryHandle,
                                    Coc->FileName,
                                    0,
                                    ENUMERATE_DIRECTORY_FLAGS_NONE,
                                    NULL,
                                    FrsEnumerateDirectoryDeleteWorker);
    return WStatus;
}


DWORD
StuDelete(
    IN PCHANGE_ORDER_ENTRY  Coe
    )
/*++
Routine Description:
    Delete a file

Arguments:
    Coe

Return Value:
    Win Status
--*/
{
#undef DEBSUB
#define DEBSUB  "StuDelete:"
    DWORD   WStatus;
    HANDLE  Handle  = INVALID_HANDLE_VALUE;
    PCHANGE_ORDER_COMMAND Coc = &Coe->Cmd;

    //
    // Open the file
    //
    WStatus = FrsOpenBaseNameForInstall(Coe, &Handle);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(4, "++ Couldn't open file %ws for delete; ", Coc->FileName, WStatus);
        //
        // File has already been deleted; done
        //
        if (WIN_NOT_FOUND(WStatus)) {
            DPRINT1(4, "++ %ws is already deleted\n", Coc->FileName);
            WStatus = ERROR_SUCCESS;
        }

        goto out;
    }

    //
    // Handles can be marked so that any usn records resulting from
    // operations on the handle will have the same "mark". In this
    // case, the mark is a bit in the SourceInfo field of the usn
    // record. The mark tells NtFrs to ignore the usn record during
    // recovery because this was a NtFrs generated change.
    //
    // Billyf: other code may depend on undampened deletes (parent filter entry?)
    // Historically, deletes were undampened because the close-with-usn-dampening
    // of a handle with delete-disposition set generates two usn records.
    // A CL usn record (w/o SourceInfo set, oddly enough) followed by
    // a DEL usn record (w/SourceInfo set). Code has been implemented
    // over the years to handle the undampened delete. So, don't mark
    // the handle because this code may be critical
    //
    // DAO - Start marking the handles for delete.  The journal code can decide
    // how it wants to handle a delete CO on a dir with USN_SOURCE_REPLICATION_MANAGEMENT
    // set in the sourceinfo field.
    //
    WStatus = FrsMarkHandle(Coe->NewReplica->pVme->VolumeHandle, Handle);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, "++ WARN - FrsMarkHandle(%ws); ", Coc->FileName, WStatus);
        WStatus = ERROR_SUCCESS;
    }

    //
    // Don't delete the file if the file has changed recently but go
    // ahead and retire the change order as if the delete had occured.
    // Since this is a remote CO the value in Coc->FileUsn actually came
    // from the IDTable when the change order was processed.
    //
    // Note: Problem with aborting the RmtCo delete if a local change to the file occurs.
    // If the local file change was an Archive bit or last access time updtate
    // then we want the delete to win.  If the local change was anything else
    // then we want to keep the file and let the local CO win.  Since we can't
    // tell what happened to the file until the Local Co is processed we will
    // let the rmt delete win.  This is only a "problem" during the small window
    // between Issuing the Remote Co and the point in time where the delete is
    // actually performed.  If the local update had been processed before the
    // this remote co delete then Reconcile would have rejected the remote CO.
    // This also means that when the local co update is processed and the
    // IDTable shows the file has been deleted then we reject the local CO update.
    //
#if 0
    if (!StuCmpUsn(Handle, Coe, &Coc->FileUsn)) {
        //
        // Returning fail status causes the CO to be aborted and the IDTable
        // is not updated.  If it was remote our partner is still notified.
        //
        WIN_SET_FAIL(WStatus);
        goto out;
    }
#endif
    //
    // Reset the attributes that prevent deletion
    //
    WStatus = FrsResetAttributesForReplication(Coc->FileName, Handle);
    if (!WIN_SUCCESS(WStatus)) {
        goto out;
    }
    //
    // Mark the file for delete
    //
    WStatus = FrsDeleteByHandle(Coc->FileName, Handle);
    if (!WIN_SUCCESS(WStatus)) {
        //
        // Empty the dir so we can delete it.  This will only happen for
        // retry COs so the caller must check that there are no valid
        // children before coming back here with a retry co.
        //
        StuDeleteEmptyDirectory(Handle, Coe, WStatus);
        WStatus = FrsDeleteByHandle(Coc->FileName, Handle);
    }

    CLEANUP1_WS(0, "++ Could not delete %ws;", Coc->FileName, WStatus, out);

out:


    if (WIN_SUCCESS(WStatus)) {
        CHANGE_ORDER_TRACE(3, Coe, "Delete success");
        CLEAR_COE_FLAG(Coe, COE_FLAG_NEED_DELETE);
    } else {
        //
        // Set delete still needed flag in the CO.
        //
        CHANGE_ORDER_TRACEW(3, Coe, "Delete failed", WStatus);
        SET_COE_FLAG(Coe, COE_FLAG_NEED_DELETE);
    }

    //
    // If the file was marked for delete, this close will delete it
    //
#if 0
    //
    // WARN - Even though we marked the handle above we are not seeing the source
    // info data in the USN journal.  The following may be affecting it.
    // SP1:
    // In any case the following does not work because the Journal thread
    // can process the close record before this thread is able to update the
    // Write Filter.  The net effect is that we could end up processing
    // an install as a local CO update and re-replicate the file.
    //
    FrsCloseWithUsnDampening(Coc->FileName,
                             &Handle,
                             Coe->NewReplica->pVme->FrsWriteFilter,
                             &Coc->FileUsn);
#endif
    // Not the USN of the close record but.. whatever.
    FrsReadFileUsnData(Handle, &Coc->FileUsn);
    FRS_CLOSE(Handle);


    return WStatus;
}


DWORD
StuInstallRename(
    IN PCHANGE_ORDER_ENTRY  Coe,
    IN BOOL                 ReplaceIfExists,
    IN BOOL                 Dampen
    )
/*++
Routine Description:
    Rename files. Replace the target file if ReplaceIfExists is TRUE.
    Don't bother dampening the rename if Dampen is FALSE.

Arguments:
    Coe
    ReplaceIfExists
    Dampen

Return Value:
    Win Status
--*/
{
#undef DEBSUB
#define DEBSUB  "StuInstallRename:"
    DWORD   WStatus;
    HANDLE  Handle          = INVALID_HANDLE_VALUE;
    HANDLE  DstHandle       = INVALID_HANDLE_VALUE;
    HANDLE  TargetHandle    = INVALID_HANDLE_VALUE;
    HANDLE  VolumeHandle;
    PCHANGE_ORDER_COMMAND Coc = &Coe->Cmd;

    VolumeHandle = Coe->NewReplica->pVme->VolumeHandle;

    //
    // Open the target directory
    //
    WStatus = FrsOpenSourceFileById(&TargetHandle,
                                    NULL,
                                    NULL,
                                    VolumeHandle,
                                    &Coc->NewParentGuid,
                                    OBJECT_ID_LENGTH,
//                                    READ_ACCESS,
                                    READ_ATTRIB_ACCESS,
                                    ID_OPTIONS,
                                    SHARE_ALL,
                                    FILE_OPEN);
    if (!WIN_SUCCESS(WStatus)) {
        CHANGE_ORDER_TRACEW(3, Coe, "Parent dir open failed", WStatus);
        goto out;
    }

    //
    // Open the file using the FID, then get the name and re-open using the
    // name so we can do either a rename or a delete.
    //

    WStatus = FrsOpenBaseNameForInstall(Coe, &Handle);
    if (!WIN_SUCCESS(WStatus)) {
        //
        // File has been deleted; done
        //
        if (WIN_NOT_FOUND(WStatus)) {
            WStatus = ERROR_FILE_NOT_FOUND;
        }
        goto out;
    }

    //
    // Handles can be marked so that any usn records resulting from
    // operations on the handle will have the same "mark". In this
    // case, the mark is a bit in the SourceInfo field of the usn
    // record. The mark tells NtFrs to ignore the usn record during
    // recovery because this was a NtFrs generated change.
    //
    if (Dampen) {
        WStatus = FrsMarkHandle(VolumeHandle, Handle);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT1_WS(0, "++ WARN - FrsMarkHandle(%ws);", Coc->FileName, WStatus);
            WStatus = ERROR_SUCCESS;
        }
    }

    //
    // ENSURE ACCESS TO THE DESTINATION FILE (IF IT EXISTS). Clear ReadOnly Attr.
    //
    // Open the destination file, if it exists
    //
    if (ReplaceIfExists) {
        WStatus = FrsCreateFileRelativeById(&DstHandle,
                                            VolumeHandle,
                                            &Coc->NewParentGuid,
                                            OBJECT_ID_LENGTH,
                                            0,
                                            Coc->FileName,
                                            Coc->FileNameLength,
                                            NULL,
                                            FILE_OPEN,
                                            READ_ATTRIB_ACCESS | WRITE_ATTRIB_ACCESS);
        if (WIN_SUCCESS(WStatus)) {
            //
            // The mark tells NtFrs to ignore the usn record during
            // recovery because this was a NtFrs generated change.
            //
            WStatus = FrsMarkHandle(VolumeHandle, DstHandle);
            if (!WIN_SUCCESS(WStatus)) {
                DPRINT1_WS(0, "++ WARN - FrsMarkHandle(%ws);", Coc->FileName, WStatus);
                WStatus = ERROR_SUCCESS;
            }

            //
            // Ensure rename access
            //
            WStatus = FrsResetAttributesForReplication(Coc->FileName, DstHandle);
            if (!WIN_SUCCESS(WStatus)) {
                DPRINT1_WS(0, "++ ERROR - FrsResetAttributesForReplication(%ws);", Coc->FileName, WStatus);
                FRS_CLOSE(DstHandle);
                goto out;
            }

            //
            // Close the dest so rename can be done.
            //
            FRS_CLOSE(DstHandle);
        }
    }

    //
    // RENAME
    //
    WStatus = FrsRenameByHandle(Coc->FileName,
                                Coc->FileNameLength,
                                Handle,
                                TargetHandle,
                                ReplaceIfExists);
    if (!WIN_SUCCESS(WStatus)) {
        CHANGE_ORDER_TRACEW(3, Coe, "Rename failed", WStatus);
    }

out:

    FRS_CLOSE(Handle);
    FRS_CLOSE(TargetHandle);

    CHANGE_ORDER_TRACEW(3, Coe, (WIN_SUCCESS(WStatus)) ? "Rename Success" : "Rename Failed", WStatus);

    return WStatus;
}


DWORD
StuPreInstallRename(
    IN PCHANGE_ORDER_ENTRY  Coe
    )
/*++

Routine Description:

    Rename file into its final directory from the pre-install dir.
    Don't bother dampening the rename if Dampen is FALSE.

    Note: If use of the standard pre-install name (NTFRS_<CO_GUID>) fails
    then Use the fid to find the file since it is possible (in the case of
    pre-install files) that the file name (based on CO Guid) when the
    pre-install file was first created was done by a different CO than this CO
    which is doing the final reaname.  E.g.  the first CO creates pre-install
    and then goes into the fetch retry state when the connection unjoins.  A
    later CO arrives for the same file but with a different CO Guid via a
    different connection.  Bug 367113 was a case like this.


Arguments:
    Coe

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define DEBSUB  "StuPreInstallRename:"

    DWORD   WStatus;
    PWCHAR  PreInstallName      = NULL;
    HANDLE  PreInstallHandle    = INVALID_HANDLE_VALUE;
    HANDLE  TargetHandle        = INVALID_HANDLE_VALUE;
    HANDLE  VolumeHandle;
    HANDLE  Handle              = INVALID_HANDLE_VALUE;
    PWCHAR  TrueFileName        = NULL;
    PCHANGE_ORDER_COMMAND Coc   = &Coe->Cmd;

    VolumeHandle = Coe->NewReplica->pVme->VolumeHandle;

    //
    // Open the target parent directory
    //
    WStatus = FrsOpenSourceFileById(&TargetHandle,
                                    NULL,
                                    NULL,
                                    VolumeHandle,
                                    &Coc->NewParentGuid,
                                    OBJECT_ID_LENGTH,
//                                    READ_ACCESS,
                                    READ_ATTRIB_ACCESS,
                                    ID_OPTIONS,
                                    SHARE_ALL,
                                    FILE_OPEN);
    if (!WIN_SUCCESS(WStatus)) {
        CHANGE_ORDER_TRACEW(3, Coe, "Parent dir open failed", WStatus);
        //
        // Perhaps the parent is in retry and will show up soon. Or
        // perhaps a delete will show up for this co. In any case, retry.
        //
        WStatus = ERROR_RETRY;
        goto cleanup;
    }

    //
    // Open the preinstall file *relative* so that the rename will work
    //
    PreInstallName = FrsCreateGuidName(&Coc->ChangeOrderGuid, PRE_INSTALL_PREFIX);

RETRY:
    WStatus = FrsCreateFileRelativeById(&PreInstallHandle,
                                        Coe->NewReplica->PreInstallHandle,
                                        NULL,
                                        0,
                                        0,
                                        PreInstallName,
                                        (USHORT)(wcslen(PreInstallName) *
                                                 sizeof(WCHAR)),
                                        NULL,
                                        FILE_OPEN,
//                                        READ_ACCESS | DELETE);
                                        DELETE | SYNCHRONIZE);

    if (!WIN_SUCCESS(WStatus)) {

        if (WIN_NOT_FOUND(WStatus) && (TrueFileName == NULL)) {
            //
            // Could be a case of CO that did initial create had a different
            // CO Guid from the current one doing the rename.  Get the true
            // name of the file using the FID and try again.
            //
            //
            // Open the source file and get the current "True" File name.
            //
            WStatus = FrsOpenSourceFileById(&Handle,
                                            NULL,
                                            NULL,
                                            VolumeHandle,
                                            &Coe->FileReferenceNumber,
                                            FILE_ID_LENGTH,
//                                            READ_ACCESS,
                                            READ_ATTRIB_ACCESS,
                                            ID_OPTIONS,
                                            SHARE_ALL,
                                            FILE_OPEN);
            if (!WIN_SUCCESS(WStatus)) {
                CHANGE_ORDER_TRACEW(3, Coe, "File open failed", WStatus);
                goto cleanup;
            }

            TrueFileName = FrsGetTrueFileNameByHandle(PreInstallName, Handle, NULL);
            FRS_CLOSE(Handle);

            FrsFree(PreInstallName);
            PreInstallName = TrueFileName;

            if ((PreInstallName == NULL) || (wcslen(PreInstallName) == 0)) {
                CHANGE_ORDER_TRACE(3, Coe, "Failed to get base filename");
                WStatus = ERROR_FILE_NOT_FOUND;
                goto cleanup;
            }
            DPRINT1(4, "++ True file name is %ws\n", PreInstallName);

            CHANGE_ORDER_TRACE(3, Coe, "Retry open with TrueFileName");
            goto RETRY;
        }

        CHANGE_ORDER_TRACEW(3, Coe, "File open failed", WStatus);
        goto cleanup;
    }

    //
    // Handles can be marked so that any usn records resulting from
    // operations on the handle will have the same "mark". In this
    // case, the mark is a bit in the SourceInfo field of the usn
    // record. The mark tells NtFrs to ignore the usn record during
    // recovery because this was a NtFrs generated change.
    //
    WStatus = FrsMarkHandle(VolumeHandle, PreInstallHandle);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, "++ WARN - FrsMarkHandle(%ws);", PreInstallName, WStatus);
        WStatus = ERROR_SUCCESS;
    }

    //
    // RENAME
    //
    WStatus = FrsRenameByHandle(Coc->FileName,
                                Coc->FileNameLength,
                                PreInstallHandle,
                                TargetHandle,
                                FALSE);
    if (!WIN_SUCCESS(WStatus)) {
        CHANGE_ORDER_TRACEW(3, Coe, "Rename failed", WStatus);
        CLEANUP2_WS(0, "++ ERROR - Failed to rename pre-install file %ws for %ws",
                    PreInstallName, Coc->FileName, WStatus, cleanup);
    }

cleanup:

    //
    // close the renamed file and get the USN of the last write to the file.
    //
    if (HANDLE_IS_VALID(PreInstallHandle)) {
        // Not the USN of the close record but.. whatever.
        FrsReadFileUsnData(PreInstallHandle, &Coc->FileUsn);
        FRS_CLOSE(PreInstallHandle);
    }

    FRS_CLOSE(TargetHandle);

    CHANGE_ORDER_TRACE(3, Coe, (WIN_SUCCESS(WStatus)) ? "Rename Success" : "Rename Failed");

    FrsFree(PreInstallName);

    return WStatus;
}



ULONG
StuOpenDestinationFile(
    IN PCHANGE_ORDER_ENTRY Coe,
    ULONG                  FileAttributes,
    PHANDLE                ReadHandle,
    PHANDLE                WriteHandle
    )
/*++
Routine Description:

    Open the destination file.  The code below actually does two opens.  The
    first one is by ID and the second one is by filename.  This is because
    open by ID will not trigger any Directory Change Notify requests that
    have been posted to the file system by either local or remote (via SMB server)
    applications.  The IIS server uses change notify to tell it when an ASP
    page has changed so it can refresh/invalidate its cache.

    If the target file has read-only attribute set then we clear it here,
    do the open and reset the attributes back before returning.

    Note: The access modes and the sharing modes are carefully arranged to
    to make the two opens work without conflicting with each other and to
    make the second open with both read and write access.  This is needed because
    the API that sets the compression mode of the file needs both read and write
    access.

Arguments:
    Coe -- The change order entry struct.
    FileAttributes -- the file attributes from the staging file header.
    ReadHandle -- Returned read handle.   Caller must close even on error path.
    WriteHandle -- Returned write handle. Caller must close even on error path.

Return Value:

    Win32 status -

--*/
{
#undef DEBSUB
#define DEBSUB  "StuOpenDestinationFile:"

    DWORD           WStatus, WStatus1;
    BOOL            IsDir;
    NTSTATUS        NtStatus;

    ULONG           CreateDisposition;
    ULONG           OpenOptions;
    PWCHAR          Path = NULL;
    PWCHAR          FullPath = NULL;
    PCHANGE_ORDER_COMMAND   Coc = &Coe->Cmd;

    IO_STATUS_BLOCK         IoStatusBlock;
    FILE_ATTRIBUTE_TAG_INFORMATION  FileInfo;


    IsDir = FileAttributes & FILE_ATTRIBUTE_DIRECTORY;

    CreateDisposition = FILE_OPEN;
    if (!IsDir) {
        //
        // In case this is an HSM file don't force the data to be read from
        // tape since the remote co is just going to overwrite all the data anyway.
        //
        // Setting CreateDisposition to FILE_OVERWRITE seems to cause a regression
        // Failure with an ACL Test where we set a deny all ACL and then the
        // open fails.  This is a mystery for now so don't do it.
        // In addtion overwrite fails if RO attribute is set on file.
        //
        //CreateDisposition = FILE_OVERWRITE;
    }

    //
    // In case this is a SIS or HSM file open the underlying file not the
    // reparse point.  For HSM, need to clear FILE_OPEN_NO_RECALL to write it.
    //
    OpenOptions = ID_OPTIONS & ~(FILE_OPEN_REPARSE_POINT |
                                 FILE_OPEN_NO_RECALL);

    WStatus = FrsForceOpenId( ReadHandle,
                              NULL,
                              Coe->NewReplica->pVme,
                              &Coe->FileReferenceNumber,
                              FILE_ID_LENGTH,
                              DELETE | READ_ATTRIB_ACCESS | FILE_WRITE_ATTRIBUTES,
                              OpenOptions,
                              FILE_SHARE_WRITE | FILE_SHARE_READ,
                              CreateDisposition);

    if (!WIN_SUCCESS(WStatus)) {
        CHANGE_ORDER_TRACEW(0, Coe, "FrsForceOpenId failed.", WStatus);
        //
        // Open by file ID fails with invalid parameter status if the file has
        // been deleted.  Fix up the error return so the caller can tell the
        // target file was not found.  This could be an update to an existing
        // file that has been deleted out from under us by the user.
        //
        if (WStatus == ERROR_INVALID_PARAMETER) {
            WStatus = ERROR_FILE_NOT_FOUND;
        }
        goto CLEANUP;
    }

    //
    // Note to the unwary.  If this mark handle is placed after the
    // set attributes call then the source info field on the resulting
    // USN record does not set.  Mark handle must be done before the
    // first modification operation on the file.
    // Also, since the close of the Read handle may occur before the
    // write handle we mark the handle here to avoid loss of source info
    // when the write handle is later closed.  The Source Info field is
    // the intersection of the values used in all the open handles.
    //
    WStatus1 = FrsMarkHandle(Coe->NewReplica->pVme->VolumeHandle, *ReadHandle);
    DPRINT1_WS(0, "++ WARN - FrsMarkHandle(%ws)", Coc->FileName, WStatus1);

    //
    // Get the file's attributes and turn off any access attributes
    // that prevent deletion and write.
    //
    ZeroMemory(&FileInfo, sizeof(FileInfo));
    NtStatus = NtQueryInformationFile(*ReadHandle,
                                      &IoStatusBlock,
                                      &FileInfo,
                                      sizeof(FileInfo),
                                      FileAttributeTagInformation);


    if (NT_SUCCESS(NtStatus)) {
        if ((FileInfo.FileAttributes & NOREPL_ATTRIBUTES) != 0) {

            DPRINT1(4, "++ Resetting attributes for %ws\n", Coc->FileName);
            WStatus1 = FrsSetFileAttributes(Coc->FileName, *ReadHandle,
                                      FileInfo.FileAttributes & ~NOREPL_ATTRIBUTES);
            DPRINT1_WS(4, "++ Can't reset attributes for %ws:",
                       Coc->FileName, WStatus1);

            DPRINT1(4, "++ Attributes for %ws now allow replication\n", Coc->FileName);
        }
    }

    //
    // The open by ID is done.  Now go get the full path name and open for
    // write access using the name.  This will trigger any posted directory
    // change notify requests in NTFS.
    //
    Path = FrsGetFullPathByHandle(Coc->FileName, *ReadHandle);
    if (Path) {
        FullPath = FrsWcsCat(Coe->NewReplica->Volume, Path);
    }

    if (FullPath == NULL) {
        WStatus = ERROR_NOT_ENOUGH_MEMORY;
        DPRINT1_WS(0, "++ WARN - FrsGetFullPathByHandle(%ws)", Coc->FileName, WStatus);
        goto CLEANUP;
    }

    //
    // The volume path above is in the form of \\.\E: which is necessary to
    // open a volume handle (( check this )).  But we need \\?\E: here to
    // allow long path names to work.  See CreateFile API description in SDK.
    //
    if (FullPath[2] == L'.') {
        FullPath[2] = L'?';
    }

    DPRINT1(4, "++ FrsGetFullPathByHandle(%ws -> \n", Coc->FileName);
    FrsPrintLongUStr(4, DEBSUB, __LINE__, FullPath);
    //
    // In case this is a SIS or HSM file open the underlying file not the
    // reparse point.  For HSM, need to clear FILE_OPEN_NO_RECALL to write it.
    // WriteHandleSharingMode should be a non-conflicting sharing mode established
    // above based on how the read handle was opened.
    //
    OpenOptions = OPEN_OPTIONS & ~(FILE_OPEN_REPARSE_POINT |
//                                   FILE_OPEN_NO_RECALL | FILE_SYNCHRONOUS_IO_NONALERT);
                                   FILE_OPEN_NO_RECALL);

    //
    // Open the file relative to the parent using the true filename. Use special access
    // for encrypted files.
    //
    if (FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
        WStatus = FrsOpenSourceFile2W(WriteHandle,
                                      FullPath,
                                      FILE_WRITE_ATTRIBUTES | WRITE_DAC | WRITE_OWNER | ACCESS_SYSTEM_SECURITY | SYNCHRONIZE,
                                      OpenOptions,
                                      FILE_SHARE_DELETE);
    } else {
        WStatus = FrsOpenSourceFile2W(WriteHandle,
                                      FullPath,
                                      RESTORE_ACCESS,
                                      OpenOptions,
                                      FILE_SHARE_DELETE);
    }
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, "++ ERROR - FrsOpenSourceFile2W(%ws -> ", Coc->FileName, WStatus);
        FrsPrintLongUStr(4, DEBSUB, __LINE__, FullPath);

        //
        // Retry dir opens with lesser restrictive sharing mode. (Bug # 120508)
        // This is a case where the explorer has the dir open with Read Access
        // and share all.  If try to open with deny read then we get a sharing
        // violation with the Explorer's open for read handle.
        //
        if (IsDir) {
            DPRINT1(0, "++ Retrying %ws with less restrictive sharing mode.\n", Coc->FileName);

            //
            // Use special access for encrypted files.
            //
            if (FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
                WStatus = FrsOpenSourceFile2W(WriteHandle,
                                              FullPath,
                                              FILE_WRITE_ATTRIBUTES | WRITE_DAC | WRITE_OWNER | ACCESS_SYSTEM_SECURITY | SYNCHRONIZE,
                                              OpenOptions,
                                              FILE_SHARE_DELETE | FILE_SHARE_READ);
            } else {
                WStatus = FrsOpenSourceFile2W(WriteHandle,
                                              FullPath,
                                              RESTORE_ACCESS,
                                              OpenOptions,
                                              FILE_SHARE_DELETE | FILE_SHARE_READ);
            }
        }

        if (!WIN_SUCCESS(WStatus)) {
            CHANGE_ORDER_TRACEW(0, Coe, "FrsOpenSourceFile2W failed.", WStatus);
            goto CLEANUP;
        }
    }

    //
    // Handles can be marked so that any usn records resulting from operations
    // on the handle will have the same "mark".  In this case, the mark is a bit
    // in the SourceInfo field of the usn record.  The mark tells NtFrs to ignore
    // the usn record during recovery because this was a NtFrs generated change.
    //
    WStatus = FrsMarkHandle(Coe->NewReplica->pVme->VolumeHandle, *WriteHandle);
    DPRINT1_WS(4, "++ FrsMarkHandle(%ws)", Coc->FileName, WStatus);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, "++ WARN - FrsMarkHandle(%ws)", Coc->FileName, WStatus);
        WStatus = ERROR_SUCCESS;
    }


CLEANUP:

    FrsFree(Path);
    FrsFree(FullPath);

    return  WStatus;
}


DWORD
StuWriteEncryptedFileRaw(
    PBYTE pbData,
    PVOID pvCallbackContext,
    PULONG ulLength
    )

/*++
Routine Description:
    This is a Callback function passed to WriteEncryptedFileRaw(). EFS calls this
    to get a new chunk of data to write to the encrypted file. This function
    reads the staging file and returns the next chunk of raw encrypted data in
    the pbData parameter and also sets the length in the ulLength parameter.
    When there is no more data to return it returns ERROR_SUCCESS and sets ulLength
    to 0.
    The pvCallbackContext is a structure of the type FRS_ENCRYPT_DATA_CONTEXT. It has
    the handle and the name of the staging file from which the data is read.

Arguments:

    pbData : Buffer to return the next chunk of raw encrypted data in.
    pvCallbackContext : Structure of type FRS_ENCRYPT_DATA_CONTEXT which
        has the handle and the name of the staging file and the bytes of
        raw encrypted data.

    ulLength : Size of data requested.

Return Value:
    WStatus

--*/
{
#undef DEBSUB
#define DEBSUB  "StuWriteEncryptedFileRaw:"

    PFRS_ENCRYPT_DATA_CONTEXT FrsEncryptDataContext = (PFRS_ENCRYPT_DATA_CONTEXT)pvCallbackContext;
    LARGE_INTEGER Length;
    DWORD WStatus = ERROR_SUCCESS;

    Length.LowPart = *ulLength;
    Length.HighPart = 0;

    if (Length.QuadPart > FrsEncryptDataContext->RawEncryptedBytes.QuadPart) {
        *ulLength = FrsEncryptDataContext->RawEncryptedBytes.LowPart;
    } else if (FrsEncryptDataContext->RawEncryptedBytes.LowPart == 0) {
        return ERROR_NO_DATA;
    }

    WStatus = StuReadFile(FrsEncryptDataContext->StagePath, FrsEncryptDataContext->StageHandle, pbData, *ulLength, ulLength);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, "++ Error reading staging file(%ws).", FrsEncryptDataContext->StagePath, WStatus);
        return ERROR_NO_DATA;
    } else {

        DPRINT1(5, "RawEncryptedBytes = %d\n", FrsEncryptDataContext->RawEncryptedBytes.LowPart);

        Length.LowPart = *ulLength;

        FrsEncryptDataContext->RawEncryptedBytes.QuadPart -= Length.QuadPart;
    }
    return ERROR_SUCCESS;
}


ULONG
StuExecuteInstall(
    IN PCHANGE_ORDER_ENTRY Coe
    )
/*++
Routine Description:

    Install the staging file to the target file.  If this is a new file create
    then the target file is a temporary file in the Pre-install directory.
    Otherwise it is the actual target file so the FID remains unchanged.

Arguments:
    Coe -- The change order entry struct.

Return Value:

    Win32 status -
    ERROR_SUCCESS -  All installed or aborted. Don't retry.
    ERROR_GEN_FAILURE - Couldn't install bag it.
    ERROR_SHARING_VIOLATION - Couldn't open the target file.  retry later.
    ERROR_DISK_FULL - Couldn't allocate the target file.  retry later.
    ERROR_HANDLE_DISK_FULL - ?? retry later.

--*/
{
#undef DEBSUB
#define DEBSUB  "StuExecuteInstall:"
    DWORD           WStatus, WStatus1;
    DWORD           BytesRead;
    ULONG           Restored;
    ULONG           ToRestore;
    ULONG           High;
    ULONG           Low;
    ULONG           Flags;
    BOOL            AttributeMissmatch;
    ULONG           FileAttributes;
    BOOL            IsDir;
    BOOL            ExistingOid;
    PVOID           RestoreContext  = NULL;
    PWCHAR          StagePath       = NULL;
    PSTAGE_HEADER   Header          = NULL;
    HANDLE          DstHandle       = INVALID_HANDLE_VALUE;
    HANDLE          ReadHandle      = INVALID_HANDLE_VALUE;
    HANDLE          StageHandle     = INVALID_HANDLE_VALUE;
    PUCHAR          RestoreBuf      = NULL;
    PCHANGE_ORDER_COMMAND   Coc = &Coe->Cmd;
    FILE_OBJECTID_BUFFER    FileObjID;

    DWORD           DecompressStatus     = ERROR_SUCCESS;
    PUCHAR          DecompressedBuf      = NULL;
    DWORD           DecompressedBufLen   = 0;
    DWORD           DecompressedSize     = 0;
    LONG            LenOfPartialChunk    = 0;
    DWORD           BytesProcessed       = 0;
    PVOID           DecompressContext    = NULL;

    DWORD (*pFrsDecompressBuffer)(OUT DecompressedBuf, IN DecompressedBufLen, IN CompressedBuf, IN CompressedBufLen, OUT DecompressedSize, OUT BytesProcessed);
    PVOID (*pFrsFreeDecompressContext)(IN pDecompressContext);
    FRS_COMPRESSED_CHUNK_HEADER ChunkHeader;

    STAGE_HEADER    StageHeaderMemory;
    CHAR            GuidStr[GUID_CHAR_LEN + 1];

    PVOID           pEncryptContext      = NULL;
    PVOID           pFrsEncryptContext   = NULL;
    FRS_ENCRYPT_DATA_CONTEXT FrsEncryptDataContext;
    HANDLE          DestHandle           = INVALID_HANDLE_VALUE;
    PWCHAR          Path                 = NULL;
    PWCHAR          DestFile             = NULL;

#ifndef NOVVJOINHACK
Coe->NewReplica->NtFrsApi_HackCount++;
#endif NOVVJOINHACK

    //
    // Acquire shared access to the staging file, install it, and
    // then release access. If the install succeeded, mark the
    // file as "installed" so that the garbage collector can
    // delete the file if necessary.
    //
    Flags = 0;
    WStatus = StageAcquire(&Coc->ChangeOrderGuid, Coc->FileName, QUADZERO, &Flags, NULL);
    if (!WIN_SUCCESS(WStatus)) {
        return WStatus;
    }

    //
    // Consider the case of dynamic membership change. A local create CO is sent to
    // the oubound partner. Not all outbound partners are availabel so the staging file
    // stay in the staging table. Later this member is removed and re-added to the
    // replica set. At this time it gets the same CO from its inbound partner. This
    // new member has a new originator guid so the CO is not dampened. This CO is
    // treated as  a remote CO but because it was already in the staging table it
    // gets picked up with the old flags. STAGE_FLAG_INSTALLED is set which caused
    // the following assert to hit. So make this assertion check only if the
    // originator guid from the CO is same as the current originator guid.
    //
    if (GUIDS_EQUAL(&Coe->NewReplica->ReplicaVersionGuid, &Coc->OriginatorGuid)) {
        FRS_ASSERT((Flags & STAGE_FLAG_INSTALLING) &&
                   (Flags & STAGE_FLAG_CREATED));
    }

    //
    // For the functions that don't return a win status
    //
    WIN_SET_FAIL(WStatus);

    //
    // Create the local staging name. Append a different prefix depending
    // on whether the staging file was sent compressed or uncompressed.
    //
    if (COC_FLAG_ON(Coc, CO_FLAG_COMPRESSED_STAGE)) {
        StagePath = StuCreStgPath(Coe->NewReplica->Stage, &Coc->ChangeOrderGuid, STAGE_FINAL_COMPRESSED_PREFIX);
    } else {
        StagePath = StuCreStgPath(Coe->NewReplica->Stage, &Coc->ChangeOrderGuid, STAGE_FINAL_PREFIX);
    }

    //
    // StagePath can be NULL is any of the above three parameters are NULL (prefix fix).
    //
    if (StagePath == NULL) {
        goto CLEANUP;
    }

    //
    // Open the stage file for shared, sequential reads
    //
    WStatus = StuOpenFile(StagePath, GENERIC_READ, &StageHandle);

    if (!HANDLE_IS_VALID(StageHandle) || !WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }

    //
    // Read the header
    //
    Header = &StageHeaderMemory;
    ZeroMemory(Header, sizeof(STAGE_HEADER));

    WStatus = StuReadFile(StagePath, StageHandle, Header, sizeof(STAGE_HEADER), &BytesRead);
    CLEANUP1_WS(0, "Can't read file %ws;", StagePath, WStatus, CLEANUP);

    //
    // Don't understand this header format
    //
    if (Header->Major != NtFrsStageMajor) {
        DPRINT2(0, "Stage Header Major Version (%d) not supported.  Current Service Version is %d\n",
                Header->Major, NtFrsStageMajor);
        goto CLEANUP;
    }

    //
    // Minor version NTFRS_STAGE_MINOR_1 has change order extension in the header.
    //
    ClearFlag(Header->ChangeOrderCommand.Flags, CO_FLAG_COMPRESSED_STAGE);
    if (Header->Minor >= NTFRS_STAGE_MINOR_1) {
        //
        // The CO extension is provided.
        //
        Header->ChangeOrderCommand.Extension = &Header->CocExt;
        //
        // NTFRS_STAGE_MINOR_2 has a compression guid in the stage file.
        //
        if (Header->Minor >= NTFRS_STAGE_MINOR_2) {
            //
            // Test the compression guid as one we understand.
            // A zero guid or Minor version < NTFRS_STAGE_MINOR_2 means uncompressed.
            //
            if (!IS_GUID_ZERO(&Header->CompressionGuid)) {
                GuidToStr(&Header->CompressionGuid, GuidStr);

                if (GTabIsEntryPresent(CompressionTable, &Header->CompressionGuid, NULL)) {
                    DPRINT1(4, "Compression guid valid: %s\n", GuidStr);
                    SetFlag(Header->ChangeOrderCommand.Flags, CO_FLAG_COMPRESSED_STAGE);
                } else {
                    DPRINT1(0, "WARNING - Compression guid invalid: %s\n", GuidStr);
                    goto CLEANUP;
                }
            } else {
                DPRINT(4, "Compression guid zero\n");
            }
        }

    } else {
        //
        // This is an older stage file.  No CO Extension in the header.
        //
        Header->ChangeOrderCommand.Extension = NULL;
    }

    //
    // Get file attributes from stage header and open the destination file.
    //
    FileAttributes = Header->Attributes.FileAttributes;
    IsDir = FileAttributes & FILE_ATTRIBUTE_DIRECTORY;

    if (FileAttributes & FILE_ATTRIBUTE_ENCRYPTED ) {

        //
        // This is an encrypted file so first write all the encrypted data
        // by calling the RAW encrypt file APIS.
        //

        //
        // OpenEncryptedFileRaw API needs a path to open the file. Get the path
        // from the handle.
        //

        WStatus = FrsForceOpenId(&DestHandle,
                                 NULL,
                                 Coe->NewReplica->pVme,
                                 &Coe->FileReferenceNumber,
                                 FILE_ID_LENGTH,
                                 READ_ATTRIB_ACCESS,
//                                 READ_ACCESS,
                                 ID_OPTIONS & ~(FILE_OPEN_REPARSE_POINT | FILE_OPEN_NO_RECALL),
                                 SHARE_ALL,
                                 FILE_OPEN);

        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP;
        }

        //
        // The open by ID is done.  Now go get the full path name.
        //
        Path = FrsGetFullPathByHandle(Coc->FileName, DestHandle);
        if (Path) {
            DestFile = FrsWcsCat(Coe->NewReplica->Volume, Path);
        }

        if (DestFile == NULL) {
            WStatus = ERROR_NOT_ENOUGH_MEMORY;
            CLEANUP1_WS(0, "++ WARN - FrsGetFullPathByHandle(%ws)", Coc->FileName, WStatus, CLEANUP);
        }

        //
        // The volume path above is in the form of \\.\E: which is necessary to
        // open a volume handle (( check this )).  But we need \\?\E: here to
        // allow long path names to work.  See CreateFile API description in SDK.
        //
        if (DestFile[2] == L'.') {
            DestFile[2] = L'?';
        }

        DPRINT1(4, "++ FrsGetFullPathByHandle(%ws -> \n", Coc->FileName);
        FrsPrintLongUStr(4, DEBSUB, __LINE__, DestFile);

        if (Header->Attributes.FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            WStatus = OpenEncryptedFileRaw(DestFile,
                                           CREATE_FOR_IMPORT |
                                           CREATE_FOR_DIR,
                                           &pEncryptContext);
        } else {
            WStatus = OpenEncryptedFileRaw(DestFile, CREATE_FOR_IMPORT,
                                           &pEncryptContext);
        }

        CLEANUP1_WS(0, "++ ERROR - OpenEncryptedFileRaw(%ws)", DestFile, WStatus, CLEANUP);

        //
        // Seek to the first byte of encrypted data in the stage file
        //
        if (ERROR_SUCCESS != FrsSetFilePointer(StagePath, StageHandle,
                               Header->EncryptedDataHigh, Header->EncryptedDataLow)) {
            goto CLEANUP;
        }

        FrsEncryptDataContext.StagePath = StagePath;
        FrsEncryptDataContext.StageHandle = StageHandle;
        FrsEncryptDataContext.RawEncryptedBytes.QuadPart = Header->EncryptedDataSize.QuadPart;

        WStatus = WriteEncryptedFileRaw(StuWriteEncryptedFileRaw, &FrsEncryptDataContext, pEncryptContext);

        CloseEncryptedFileRaw(pEncryptContext);

        //
        //  There are conditions e.g. a stream create by backupwrite,
        //  where we will lose the source info data on the USN Journal Close record.
        //  Until that problem is fixed we need to continue using the WriteFilter Table.
        //
        FrsCloseWithUsnDampening(Coc->FileName,
                                 &DestHandle,
                                 Coe->NewReplica->pVme->FrsWriteFilter,
                                 &Coc->FileUsn);

        CLEANUP1_WS(0, "++ ERROR - WriteEncryptedFileRaw(%ws)", DestFile, WStatus, CLEANUP);
    }

    WStatus = StuOpenDestinationFile(Coe, FileAttributes, &ReadHandle,  &DstHandle);
    CLEANUP_WS(1, "WARN - StuOpenDestinationFile failed.", WStatus, CLEANUP);

    //
    // Close the Read Handle now since it conflicts with backup write
    // creating or writing to a file sub-stream.
    //
    FRS_CLOSE(ReadHandle);

    if (!(FileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {
        //
        // Truncate the file if not a directory. Can not truncate encrypted files.
        //
        if (!IsDir && !SetEndOfFile(DstHandle)) {
            DPRINT1_WS(0, "++ WARN - SetEndOfFile(%ws);", Coc->FileName, GetLastError());
        }

        //
        // Set compression mode and attributes
        // Seek to the first byte of data in the stage file
        // File can not be encrypted and compressed at the same time.
        //
        WStatus = FrsSetCompression(Coc->FileName, DstHandle, Header->Compression);
        CLEANUP1_WS(1, "ERROR - Failed to set compression for %ws.", Coc->FileName, WStatus, CLEANUP);

    }

    WStatus = FrsSetFileAttributes(Coc->FileName, DstHandle, FileAttributes & ~NOREPL_ATTRIBUTES);
    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }

    WStatus = FrsSetFilePointer(StagePath, StageHandle,
                                Header->DataHigh, Header->DataLow);
    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }

    //
    // if Compression is enabled. Get the routine to use to compress the data.
    //
    if (!DebugInfo.DisableCompression && COC_FLAG_ON(Coc, CO_FLAG_COMPRESSED_STAGE)) {

        WStatus = FrsGetDecompressionRoutine(Coc, Header, &pFrsDecompressBuffer, &pFrsFreeDecompressContext);
        if (!WIN_SUCCESS(WStatus)) {
            //
            // No suitable decompression routine was found for this file.
            //
            DPRINT1(0, "ERROR - Decompression routine was not found for file %ws\n", Coc->FileName);
            FRS_ASSERT(!"Decompression routine was not found for file.");

        } else if (pFrsDecompressBuffer == NULL) {
            //
            // The function returned success but did not return a routine to decompress.
            // the file with. It means the file is already decompressed.
            //
            CLEAR_COC_FLAG(Coc, CO_FLAG_COMPRESSED_STAGE);
        }
    }


    //
    // Restore the stage file into the target install file.
    //
    RestoreBuf = FrsAlloc(STAGEING_IOSIZE);

    do {
#ifndef NOVVJOINHACK
Coe->NewReplica->NtFrsApi_HackCount++;
#endif NOVVJOINHACK
        //
        // read stage
        //
        WStatus = StuReadFile(StagePath, StageHandle, RestoreBuf, STAGEING_IOSIZE, &ToRestore);
        CLEANUP1_WS(0, "Can't read file %ws;", StagePath, WStatus, CLEANUP);

        if (ToRestore == 0) {
            break;
        }

        //
        // Increment the bytes of files installed counter
        //
        PM_INC_CTR_REPSET(Coe->NewReplica, FInstalledB, ToRestore);

        //
        // If Compression is enabled. Decompress data before installing.
        //
        if (!DebugInfo.DisableCompression && COC_FLAG_ON(Coc, CO_FLAG_COMPRESSED_STAGE)) {

            BytesProcessed = 0;
            DecompressContext = NULL;
            if (DecompressedBuf == NULL) {
                DecompressedBuf = FrsAlloc(STAGEING_IOSIZE);
                DecompressedBufLen = STAGEING_IOSIZE;
            }

            //
            // Loop over all the chunks of decompressed data.
            //
            do {
                DecompressStatus = (*pFrsDecompressBuffer)(DecompressedBuf,
                                                           DecompressedBufLen,
                                                           RestoreBuf,
                                                           ToRestore,
                                                           &DecompressedSize,
                                                           &BytesProcessed,
                                                           &DecompressContext);

                if (!WIN_SUCCESS(DecompressStatus) && DecompressStatus != ERROR_MORE_DATA) {
                    DPRINT1(0,"Error - Decompressing. WStatus = 0x%x\n", DecompressStatus);
                    WStatus = DecompressStatus;
                    goto CLEANUP;
                }

                if (DecompressedSize == 0) {
                    break;
                }

                if (!BackupWrite(DstHandle, DecompressedBuf, DecompressedSize, &Restored, FALSE, TRUE, &RestoreContext)) {

                    WStatus = GetLastError();
                    if (IsDir && WIN_ALREADY_EXISTS(WStatus)) {
                        DPRINT1(1, "++ ERROR - IGNORED for %ws; Directories and Alternate Data Streams!\n",
                                Coc->FileName);
                    }
                    //
                    // Uknown stream header or couldn't apply object id
                    //
                    if (WStatus == ERROR_INVALID_DATA ||
                        WStatus == ERROR_DUP_NAME     ||
                        (IsDir && WIN_ALREADY_EXISTS(WStatus))) {
                        //
                        // Seek to the next stream. Stop if there are none.
                        //
                        BackupSeek(DstHandle, -1, -1, &Low, &High, &RestoreContext);
                        if (Low == 0 && High == 0) {
                            break;
                        }
                    } else {
                        //
                        // Unknown error; abort
                        //
                        CHANGE_ORDER_TRACEW(0, Coe, "BackupWrite failed", WStatus);
                        goto CLEANUP;
                    }
                }

            } while (DecompressStatus == ERROR_MORE_DATA);

            //
            // Free the Decompress context if used.
            //
            if (DecompressContext != NULL) {
                pFrsFreeDecompressContext(&DecompressContext);
            }

            //
            // Rewind the file pointer so we can read the remaining chunck at the next read.
            //
            LenOfPartialChunk = ((LONG)BytesProcessed - (LONG)ToRestore);

            LenOfPartialChunk = SetFilePointer(StageHandle, LenOfPartialChunk, NULL, FILE_CURRENT);
            if (LenOfPartialChunk == INVALID_SET_FILE_POINTER) {
                WStatus = GetLastError();
                CLEANUP1_WS(0, "++ Can't set file pointer for %ws;", StagePath, WStatus, CLEANUP);
            }

        } else {
            //
            // Stage file is not compressed.  Update the target install file.
            //
            if (!BackupWrite(DstHandle, RestoreBuf, ToRestore, &Restored, FALSE, TRUE, &RestoreContext)) {

                WStatus = GetLastError();
                if (IsDir && WIN_ALREADY_EXISTS(WStatus)) {
                    DPRINT1(1, "++ ERROR - IGNORED for %ws; Directories and Alternate Data Streams!\n",
                            Coc->FileName);
                }
                //
                // Uknown stream header or couldn't apply object id
                //
                if (WStatus == ERROR_INVALID_DATA ||
                    WStatus == ERROR_DUP_NAME     ||
                    (IsDir && WIN_ALREADY_EXISTS(WStatus))) {
                    //
                    // Seek to the next stream. Stop if there are none.
                    //
                    BackupSeek(DstHandle, -1, -1, &Low, &High, &RestoreContext);
                    if ((Low == 0) && (High == 0)) {
                        break;
                    }
                } else {
                    //
                    // Unknown error; abort
                    //
                    CHANGE_ORDER_TRACEW(0, Coe, "BackupWrite failed", WStatus);
                    goto CLEANUP;
                }
            }
        }
    } while (TRUE);   // End of data restore loop.


    //
    // Ensure the correct object ID is on the file.
    //
    FRS_ASSERT(!memcmp(Header->FileObjId.ObjectId, &Coc->FileGuid, sizeof(GUID)));

    //
    // Clear the extended info for the link tracking tool on replicated files.
    // Old Ntraid Bug 195322.
    //
    ZeroMemory(Header->FileObjId.ExtendedInfo,
               sizeof(Header->FileObjId.ExtendedInfo));

    WStatus = FrsGetOrSetFileObjectId(DstHandle, Coc->FileName, TRUE, &Header->FileObjId);

    if (WStatus == ERROR_DUP_NAME) {
        //
        // Note:  Need to make sure that the file we are deleting is not in
        // in another replica set on the volume.  This is currently not a
        // problem since every new file that comes into a replica set gets
        // assigned a new object ID.  This breaks link tracking but was done
        // to deal with the case.
        //
        CHANGE_ORDER_TRACEW(0, Coe, "Deleting conflicting file", WStatus);
        WStatus = FrsDeleteById(Coe->NewReplica->Volume,
                                Coc->FileName,
                                Coe->NewReplica->pVme,
                                &Coc->FileGuid,
                                OBJECT_ID_LENGTH);
        if (!WIN_SUCCESS(WStatus)) {

            CHANGE_ORDER_TRACEW(0, Coe, "Stealing object id", WStatus);

            ZeroMemory(&FileObjID, sizeof(FileObjID));
            FrsUuidCreate((GUID *)(&FileObjID.ObjectId[0]));

            ExistingOid = FALSE;
            WStatus = ChgOrdHammerObjectId(Coc->FileName,
                                           &Coc->FileGuid,
                                           OBJECT_ID_LENGTH,
                                           Coe->NewReplica->pVme,
                                           TRUE,
                                           NULL,
                                           &FileObjID,
                                           &ExistingOid);
            if (WIN_SUCCESS(WStatus)) {
                WStatus = FrsGetOrSetFileObjectId(DstHandle,
                                                  Coc->FileName,
                                                  TRUE,
                                                  &Header->FileObjId);
            }
            if (!WIN_SUCCESS(WStatus)) {
                CHANGE_ORDER_TRACEW(0, Coe, "Retry install cuz of object id", WStatus);
                WStatus = ERROR_RETRY;
            }
        } else {
            CHANGE_ORDER_TRACEW(0, Coe, "Deleted conflicting file", WStatus);
            WStatus = FrsGetOrSetFileObjectId(DstHandle,
                                              Coc->FileName,
                                              TRUE,
                                              &Header->FileObjId);
            CHANGE_ORDER_TRACEW(4, Coe, "Set object id", WStatus);
        }
    }
    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }

    //
    // If the staging file was created from a file that had the reparse
    // point attribute set then delete the reparse point.  Note this assumes
    // that backup write restored the reparse point info.  So keep going
    // on an error.
    //
    if (BooleanFlagOn(FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT)) {
        WStatus = FrsDeleteReparsePoint(DstHandle);
        if (!WIN_SUCCESS(WStatus)) {
            CHANGE_ORDER_TRACEW(0, Coe, "FrsDeleteReparsePoint", WStatus);
        }
    }

    //
    // Set times
    //
    WStatus = FrsSetFileTime(Coc->FileName,
                        DstHandle,
                        (PFILETIME)&Header->Attributes.CreationTime.QuadPart,
                        (PFILETIME)&Header->Attributes.LastAccessTime.QuadPart,
                        (PFILETIME)&Header->Attributes.LastWriteTime.QuadPart);
    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }

    //
    // Set final attributes (which could make the file Read Only)
    // Clear the offline attrbute flag since we just wrote the file.
    //
    ClearFlag(FileAttributes, FILE_ATTRIBUTE_OFFLINE);
    WStatus = FrsSetFileAttributes(Coc->FileName, DstHandle, FileAttributes);
    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }

    if (!(FileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {
        //
        // Make sure all of the data is on disk. We don't want to lose
        // it across reboots
        // Can not flush encrypted files.
        //
        WStatus = FrsFlushFile(Coc->FileName, DstHandle);
        CLEANUP1_WS(0, "++ FlushFileBuffers failed on %ws;", Coc->FileName, WStatus, CLEANUP);
    }

    //
    // The Idtable record should reflect these attributes of the staging
    // file we generated.  These fields will be used to update the idtable
    // record when the change order is retired.
    //
    Coe->FileCreateTime.QuadPart = Header->Attributes.CreationTime.QuadPart;
    Coe->FileWriteTime.QuadPart  = Header->Attributes.LastWriteTime.QuadPart;

    AttributeMissmatch = ((Coc->FileAttributes ^ FileAttributes) &
                              FILE_ATTRIBUTE_DIRECTORY) != 0;

    if (AttributeMissmatch) {
        DPRINT2(0, "++ ERROR: Attribute missmatch between CO (%08x) and File (%08x)\n",
                Coc->FileAttributes, FileAttributes);
        FRS_ASSERT(!"Attribute missmatch between CO and File");
    }

    Coc->FileAttributes = FileAttributes;

    //
    // Return success
    //
    WStatus = ERROR_SUCCESS;


CLEANUP:
    //
    // Release resources in optimal order
    //
    // Leave the file lying around for a retry operation. We don't want
    // to assign a new fid by deleting and recreating the file -- that
    // would confuse the IDTable.
    //
    //
    // Free up the restore context before we close TmpHandle (just in case)
    //
    if (RestoreContext) {
        BackupWrite(DstHandle, NULL, 0, NULL, TRUE, TRUE, &RestoreContext);
    }
    //
    // Close both target file handles.
    //

    //
    // Handles can be marked so that any usn records resulting from operations
    // on the handle will have the same "mark".  In this case, the mark is a bit
    // in the SourceInfo field of the usn record.  The mark tells NtFrs to ignore
    // the usn record during recovery because this was a NtFrs generated change.
    //
    //WStatus1 = FrsMarkHandle(Coe->NewReplica->pVme->VolumeHandle, ReadHandle);
    //DPRINT1_WS(4, "++ FrsMarkHandle(%ws)", Coc->FileName, WStatus1);

    FRS_CLOSE(ReadHandle);

    if (HANDLE_IS_VALID(DstHandle)) {
        //
        // Truncate a partial install
        //
        if (!WIN_SUCCESS(WStatus)) {
            if (!IsDir && !(FileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {
                ULONG  SizeHigh = 0, SizeLow = 0;

                WStatus1 = FrsSetFilePointer(Coc->FileName, DstHandle, SizeHigh, SizeLow);

                if (!WIN_SUCCESS(WStatus1)) {
                    CHANGE_ORDER_TRACEW(0, Coe, "WARN SetFilePointer", WStatus1);
                } else {
                    WStatus1 = FrsSetEndOfFile(Coc->FileName, DstHandle);
                    if (!WIN_SUCCESS(WStatus1)) {
                        CHANGE_ORDER_TRACEW(0, Coe, "WARN SetEndOfFile", WStatus1);
                    }
                }
            }
        }


        //
        //  There are conditions e.g. a stream create by backupwrite,
        //  where we will lose the source info data on the USN Journal Close record.
        //  Until that problem is fixed we need to continue using the WriteFilter Table.
        //
        FrsCloseWithUsnDampening(Coc->FileName,
                                 &DstHandle,
                                 Coe->NewReplica->pVme->FrsWriteFilter,
                                 &Coc->FileUsn);

#if 0
        //  Put this back when the FrsCloseWithUsnDampening() is no longer needed.
        //
        // Capture the current USN on the file.
        // Not the USN of the close record but.. whatever.
        //
        FrsReadFileUsnData(DstHandle, &Coc->FileUsn);

        //
        // Handles can be marked so that any usn records resulting from operations
        // on the handle will have the same "mark".  In this case, the mark is a bit
        // in the SourceInfo field of the usn record.  The mark tells NtFrs to ignore
        // the usn record during recovery because this was a NtFrs generated change.
        //
        //WStatus1 = FrsMarkHandle(Coe->NewReplica->pVme->VolumeHandle, DstHandle);
        //DPRINT1_WS(4, "++ FrsMarkHandle(%ws)", Coc->FileName, WStatus1);

        FRS_CLOSE(DstHandle);
#endif
    }

    FRS_CLOSE(StageHandle);

    //
    // Free the buffers in descending order by size and release our lock on the
    // staging file.
    //
    FrsFree(RestoreBuf);
    FrsFree(StagePath);
    FrsFree(DecompressedBuf);

    //
    // Used to install encrypted files.
    //
    FrsFree(DestFile);
    FrsFree(Path);
    FRS_CLOSE(DestHandle);

    if (WIN_SUCCESS(WStatus)) {
        StageRelease(&Coc->ChangeOrderGuid, Coc->FileName, STAGE_FLAG_INSTALLED, NULL, NULL);
    } else {
        StageRelease(&Coc->ChangeOrderGuid, Coc->FileName, 0, NULL, NULL);
    }

    //
    // DONE
    //
    return WStatus;
}


DWORD
StuInstallStage(
    IN PCHANGE_ORDER_ENTRY Coe
    )
/*++
Routine Description:
    Install a staging file by parsing the change order and performing
    the necessary operations. Not all installations require a staging
    file (e.g., deletes).

Arguments:
    Coe

Return Value:
    Win32 status:
    ERROR_SUCCESS    - All installed
    ERROR_GEN_FAILURE   - Partially installed; temp files are deleted
    ERROR_SHARING_VIOLATION - Couldn't open the target file.  retry later.
    ERROR_DISK_FULL - Couldn't allocate the target file.  retry later.
    ERROR_HANDLE_DISK_FULL - ?? retry later.

--*/
{
#undef DEBSUB
#define DEBSUB  "StuInstallStage:"
    DWORD                   WStatus = ERROR_SUCCESS;
    PCHANGE_ORDER_COMMAND   Coc = &Coe->Cmd;

    //
    // Perform the indicated location operation (with or without staging)
    //
    if (CO_FLAG_ON(Coe, CO_FLAG_LOCATION_CMD)) {
        switch (GET_CO_LOCATION_CMD(*Coc, Command)) {
            case CO_LOCATION_CREATE:
            case CO_LOCATION_MOVEIN:
            case CO_LOCATION_MOVEIN2:
                //
                // Install the entire staging file
                //
                return (StuExecuteInstall(Coe));

            case CO_LOCATION_DELETE:
            case CO_LOCATION_MOVEOUT:
                //
                // Just delete the existing file
                //
                return StuDelete(Coe);

            case CO_LOCATION_MOVERS:
            case CO_LOCATION_MOVEDIR:
                //
                // First, rename the file
                //
                WStatus = StuInstallRename(Coe, TRUE, TRUE);
                if (WIN_SUCCESS(WStatus)) {
                    //
                    // Second, check for a staging file with content changes
                    //
                    if (CO_FLAG_ON(Coe, CO_FLAG_CONTENT_CMD) &&
                        Coc->ContentCmd & CO_CONTENT_NEED_STAGE) {
                        WStatus = StuExecuteInstall(Coe);
                    }
                }
                return WStatus;

            default:
                break;
        }
    }
    //
    // Perform the indicated content operation (with or without staging)
    //
    if (WIN_SUCCESS(WStatus) && CO_FLAG_ON(Coe, CO_FLAG_CONTENT_CMD)) {
        //
        // Rename within the same directory
        //
        if (Coc->ContentCmd & USN_REASON_RENAME_NEW_NAME) {
            WStatus = StuInstallRename(Coe, TRUE, TRUE);
        }
        //
        // Data or attribute changes to an existing file
        //
        if (WIN_SUCCESS(WStatus) &&
            Coc->ContentCmd & CO_CONTENT_NEED_STAGE) {
            WStatus = StuExecuteInstall(Coe);
        }
    }

    //
    // Informational packet; ignore
    //
    return WStatus;
}


DWORD
StuCreatePreInstallFile(
    IN PCHANGE_ORDER_ENTRY Coe
    )
/*++
Routine Description:
    Create the pre-install file in the pre-install directory and return that fid.
    The pre-install file is renamed to the target file and dir, and stamped
    with the appropriate object id once the staging file has been
    installed.

    The parent fids were set to the correct values prior to this call.

Arguments:
    Coe

Return Value:
    Win32 Status

--*/
{
#undef DEBSUB
#define DEBSUB  "StuCreatePreInstallFile:"

    LARGE_INTEGER             FileSize;
    FILE_INTERNAL_INFORMATION FileInternalInfo;
    PCHANGE_ORDER_COMMAND     Coc = &Coe->Cmd;
    DWORD                     WStatus;
    HANDLE                    Handle;
    PWCHAR                    Name = NULL;
    ULONG                     CreateAttributes;


    //
    // Create the file name of the pre-install file. It will match the
    // name of the staging file since it uses the same heuristic (the
    // change order guid)
    //
    Name = FrsCreateGuidName(&Coc->ChangeOrderGuid, PRE_INSTALL_PREFIX);

    //
    // Create the temporary (hidden) file in the Pre-install directory.
    // Clear the readonly flag for // now cuz if we come thru here again during
    // recovery we will get access denied when we try to open the pre-exisitng
    // file.  The Install code will set the readonly flag on the file later if necc.
    //
    CreateAttributes = Coc->FileAttributes | FILE_ATTRIBUTE_HIDDEN;
    ClearFlag(CreateAttributes , FILE_ATTRIBUTE_READONLY);

    FileSize.QuadPart = Coc->FileSize;
    if (Coc->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {

        ClearFlag(CreateAttributes , FILE_ATTRIBUTE_ENCRYPTED);
        ClearFlag(CreateAttributes , FILE_ATTRIBUTE_HIDDEN);
    }

    WStatus = FrsCreateFileRelativeById(&Handle,
                                        Coe->NewReplica->PreInstallHandle,
                                        NULL,
                                        0,
                                        CreateAttributes,
                                        Name,
                                        (USHORT)(wcslen(Name) * sizeof(WCHAR)),
                                        &FileSize,
                                        FILE_OPEN_IF,
                                        RESTORE_ACCESS);

    if (!WIN_SUCCESS(WStatus)) {
        CHANGE_ORDER_TRACEW(0, Coe, "Preinstall file create failed", WStatus);
        goto CLEANUP;
    }

    //
    // Handles can be marked so that any usn records resulting from
    // operations on the handle will have the same "mark". In this
    // case, the mark is a bit in the SourceInfo field of the usn
    // record. The mark tells NtFrs to ignore the usn record during
    // recovery because this was a NtFrs generated change.
    //
    WStatus = FrsMarkHandle(Coe->NewReplica->pVme->VolumeHandle, Handle);
    DPRINT1_WS(4, "++ FrsMarkHandle(%ws);", Coc->FileName, WStatus);
    if (!WIN_SUCCESS(WStatus)) {
        CHANGE_ORDER_TRACEW(0, Coe, "WARN - FrsMarkHandle", WStatus);
        WStatus = ERROR_SUCCESS;
    }

    //
    // Get the file's fid and update the change order.
    //
    WStatus = FrsGetFileInternalInfoByHandle(Handle, &FileInternalInfo);

    //
    // Return the close USN in the change order so we can detect a change
    // if it gets modified locally before we complete the fetch and install.
    //
    // Not the USN of the close record but.. whatever.
    FrsReadFileUsnData(Handle, &Coc->FileUsn);
    FRS_CLOSE(Handle);

    //
    // Update the change order.
    //
    if (WIN_SUCCESS(WStatus)) {
        //
        // If we have passed the fetch retry state then the FID on the
        // target file better not be changing.  There was a bug where the
        // pre-install file was inadvertantly deleted while the change order
        // was in the IBCO_INSTALL_REN_RETRY state and we never noticed
        // because the above is happy to recreate it.  So we end up with an
        // empty file.
        //
        if (!CO_STATE_IS_LE(Coe, IBCO_INSTALL_INITIATED) &&
            !CO_STATE_IS(Coe, IBCO_INSTALL_WAIT) &&
            !CO_STATE_IS(Coe, IBCO_INSTALL_RETRY)) {
            FRS_ASSERT((LONGLONG)Coe->FileReferenceNumber ==
                                 FileInternalInfo.IndexNumber.QuadPart);
        }

        Coe->FileReferenceNumber = FileInternalInfo.IndexNumber.QuadPart;
        //
        // Remember we created a pre-install file for this CO.
        //
        SET_COE_FLAG(Coe, COE_FLAG_PREINSTALL_CRE);
    }

CLEANUP:
    FrsFree(Name);
    return WStatus;
}


VOID
StuCockOpLock(
    IN  PCHANGE_ORDER_COMMAND   Coc,
    OUT PHANDLE                 Handle,
    OUT OVERLAPPED              *OverLap
    )
/*++
Routine Description:
    If possible, cock an oplock for the source file. Otherwise,
    allow the staging operation to continue if it can acquire
    read access to the file.

Arguments:
    Coc
    Handle
    OverLap

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "StuCockOpLock:"
    PREPLICA NewReplica = ReplicaIdToAddr(Coc->NewReplicaNum);

    //
    // Can't oplock a directory
    //
    if ((NewReplica == NULL) || CoCmdIsDirectory(Coc)) {
        *Handle = INVALID_HANDLE_VALUE;
        OverLap->hEvent = NULL;
        return;
    }

    //
    // Reserve an oplock filter
    //
    FrsOpenSourceFileById(Handle,
                          NULL,
                          OverLap,
                          NewReplica->pVme->VolumeHandle,
                          &Coc->FileGuid,
                          sizeof(GUID),
                          OPLOCK_ACCESS,
                          ID_OPLOCK_OPTIONS,
                          SHARE_ALL,
                          FILE_OPEN);
}


VOID
StuStagingDumpBackup(
    IN PWCHAR   Name,
    IN PUCHAR   BackupBuf,
    IN DWORD    NumBackupDataBytes
    )
/*++
Routine Description:
    Dump the first buffer of a backup formatted file

Arguments:

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "StuStagingDumpBackup:"
    WIN32_STREAM_ID *Id;
    WIN32_STREAM_ID *FirstId;
    WIN32_STREAM_ID *LastId;
    DWORD           Total;
    DWORD           *pWord;
    DWORD           i;
    DWORD           j;
    DWORD           NWords;
    CHAR            Line[256];

    Id = (WIN32_STREAM_ID *)BackupBuf;
    FirstId = Id;
    LastId = (WIN32_STREAM_ID *)(BackupBuf + NumBackupDataBytes);

    while (Id < LastId) {
        if (Id != FirstId) {
            DPRINT(0, "\n");
        }
        DPRINT2(0, "%ws StreamId   : %08x\n", Name, Id->dwStreamId);
        DPRINT2(0, "%ws StreamAttrs: %08x\n", Name, Id->dwStreamAttributes);
        DPRINT2(0, "%ws Size       : %08x\n", Name, Id->Size.LowPart);
        DPRINT2(0, "%ws NameSize   : %08x\n", Name, Id->dwStreamNameSize);
        if (Id->dwStreamNameSize) {
            DPRINT2(0, "%ws Name       : %ws\n", Name, Id->cStreamName);
        }
        pWord = (PVOID)((PCHAR)&Id->cStreamName[0] + Id->dwStreamNameSize);
        NWords = Id->Size.LowPart / sizeof(DWORD);
        sprintf(Line, "%ws ", Name);

        for (Total = j = i = 0; i < NWords; ++i, ++pWord) {
            Total += *pWord;
            sprintf(&Line[strlen(Line)], "%08x ", *pWord);
            if (++j == 2) {
                DPRINT1(0, "%s\n", Line);
                sprintf(Line, "%ws ", Name);
                j = 0;
            }
        }

        if (j) {
            DPRINT1(0, "%s\n", Line);
        }

        DPRINT2(0, "%ws Total %08x\n", Name, Total);
        Id = (PVOID)((PCHAR)Id +
                     (((PCHAR)&Id->cStreamName[0] - (PCHAR)Id) +
                     Id->Size.QuadPart + Id->dwStreamNameSize));
    }
}


DWORD
StuReadEncryptedFileRaw(
    PBYTE pbData,
    PVOID pvCallbackContext,
    ULONG ulLength
    )

/*++
Routine Description:
    This is a Callback function passed to ReadEncryptedFileRaw(). EFS calls this
    function with a new chunk of raw encrypted data everytime until all the
    data is read. This function writes the raw data into the staging file.

    The pvCallbackContext is a structure of the type FRS_ENCRYPT_DATA_CONTEXT. It has
    the handle and the name of the staging file from which the data is read.

Arguments:

    pbData : Buffer containing chunk of raw encrypted data.
    pvCallbackContext : Structure of type FRS_ENCRYPT_DATA_CONTEXT which
        has the handle and the name of the staging file and the bytes of
        raw encrypted data.

    ulLength : Size of data.

Return Value:
    WStatus

--*/
{
#undef DEBSUB
#define DEBSUB  "StuReadEncryptedFileRaw:"

    DWORD WStatus = ERROR_SUCCESS;
    PFRS_ENCRYPT_DATA_CONTEXT FrsEncryptDataContext = (PFRS_ENCRYPT_DATA_CONTEXT)pvCallbackContext;

    WStatus = StuWriteFile(FrsEncryptDataContext->StagePath, FrsEncryptDataContext->StageHandle, pbData, ulLength);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, "++ Error writing raw encrypted data to staging file(%ws),", FrsEncryptDataContext->StagePath,WStatus);
    } else {
        DPRINT1(5, "RawEncryptedBytes = %d\n", FrsEncryptDataContext->RawEncryptedBytes);
        FrsEncryptDataContext->RawEncryptedBytes.QuadPart += ulLength;
    }
    return ERROR_SUCCESS;
}


DWORD
StuGenerateStage(
    IN PCHANGE_ORDER_COMMAND    Coc,
    IN PCHANGE_ORDER_ENTRY      Coe,
    IN BOOL                     FromPreExisting,
    IN MD5_CTX                  *Md5,
    OUT PULONGLONG              SizeOfFileGenerated,
    OUT GUID                    *CompressionFormatUsed
    )
/*++
Routine Description:
    Create and populate the staging file.  Currently there are four cases
    of interest based on the state of Coe, FromPreExisting and Md5:

    Coe   FromPreExisting  Md5

    NULL     FALSE       NULL         Fetch on demand or outlog trimmed so stage file must be regenerated
    NULL     FALSE       non-null     Fetch of pre-existing file by downstream partner.  check MD5.
    NULL     TRUE        NULL         doesn't occur
    NULL     TRUE        non-null     doesn't occur
    non-NULL FALSE       NULL         Generate stage file for local CO
    non-NULL FALSE       non-null     doesn't occur -- MD5 only generated for preexisting files
    non-NULL TRUE        NULL         doesn't occur -- MD5 always generated for preexisting files.
    non-NULL TRUE        non-null     Generate stage file from pre-existing file and send MD5 upstream to check for a match.

Arguments:

    Coc -- ptr to change order command.  NULL on incoming fetch requests from downstream partners.

    Coe -- ptr to change order entry.  NULL when regenerating the staging file for fetch

    FromPreExisting -- TRUE if this staging file is being generated from a
                       preexisting file.

    Md5 -- Generate the MD5 digest for the caller and return it if Non-NULL

    SizeOfFileGenerated - Valid when the size generated is needed, otherwise NULL

    CompressionFormatUsed - Returned guid for the compression format used to construct
                            this staging file.

Return Value:
    WIN32 STATUS

--*/
{
#undef DEBSUB
#define DEBSUB  "StuGenerateStage:"


    OVERLAPPED      OpLockOverLap;
    LONGLONG        StreamBytesLeft;
    LONG            BuffBytesLeft;


    DWORD           WStatus;
    DWORD           NumBackupDataBytes;
    ULONG           ReparseTag;
    ULONG           OpenOptions;
    WORD            OldSecurityControl;
    WORD            NewSecurityControl;
    WORD            *SecurityControl;
    BOOL            FirstBuffer       = TRUE;
    BOOL            Regenerating      = FALSE;
    BOOL            SkipCo            = FALSE;
    BOOL            FirstOpen         = TRUE;
    BOOL            StartOfStream     = TRUE;

    PWCHAR          StagePath         = NULL;
    PWCHAR          FinalPath         = NULL;
    PUCHAR          BackupBuf         = NULL;
    PVOID           BackupContext     = NULL;

    HANDLE          OpLockEvent       = NULL;
    HANDLE          SrcHandle         = INVALID_HANDLE_VALUE;
    HANDLE          StageHandle       = INVALID_HANDLE_VALUE;
    HANDLE          OpLockHandle      = INVALID_HANDLE_VALUE;

    WIN32_STREAM_ID *StreamId;

    PSTAGE_HEADER   Header          = NULL;
    STAGE_HEADER    StageHeaderMemory;
    ULONG           Length;
    PREPLICA        NewReplica = NULL;
    WCHAR           TStr[100];

    PUCHAR          CompressedBuf     = NULL;
    DWORD           CompressedBufLen  = 0;
    DWORD           ActCompressedSize = 0;
    DWORD           (*pFrsCompressBuffer)(IN UnCompressedBuf, IN UnCompressedBufLen, CompressedBuf, CompressedBufLen, CompressedSize);

    LARGE_INTEGER   DataOffset;
    PVOID           pEncryptContext   = NULL;
    FRS_ENCRYPT_DATA_CONTEXT FrsEncryptDataContext;
    PWCHAR          SrcFile           = NULL;
    PWCHAR          Path              = NULL;

    //
    // Initialize the SizeOfFileGenerated to zero
    //
    if (SizeOfFileGenerated != NULL) {
        *SizeOfFileGenerated = 0;
    }

    //
    // Generate a checksum on the staging file + attributes
    //
    if (Md5) {
        ZeroMemory(Md5, sizeof(*Md5));
        MD5Init(Md5);
    }

    //
    // The staging file may be deleted if the outbound partner takes too long
    // to fetch it.  When this happened, the staging file is regenerated.  The
    // inbound change order entry may be deleted by now and the outbound
    // change order entries are not kept in core.  Hence, the Coe is null when
    // called for re-generation.
    //
    Regenerating = (Coe == NULL);

    //
    // Some basic info changes aren't worth replicating
    //
    if (!Regenerating && !FromPreExisting) {
        WStatus = ChgOrdSkipBasicInfoChange(Coe, &SkipCo);
        if (!WIN_SUCCESS(WStatus)) {
            goto out;
        }
    }

    //
    // Changes aren't important, skip the change order
    //
    if (SkipCo) {
        WIN_SET_FAIL(WStatus);
        goto out;
    }


    OpenOptions = ID_OPTIONS;

RETRY_OPEN:

    //
    // Go ahead and attempt a staging operation even if we can't
    // cock an oplock for the source file.
    //
    StuCockOpLock(Coc, &OpLockHandle, &OpLockOverLap);
    OpLockEvent = OpLockOverLap.hEvent;

    //
    // The header is located at the beginning of the newly created staging file
    //
    // Fill in the header with info from the src file
    //      Compression type
    //      Change order
    //      Attributes
    //
    Header = &StageHeaderMemory;
    ZeroMemory(Header, sizeof(STAGE_HEADER));

    //
    // Open the original file for shared, sequential reads and
    // snapshot the file's "state" for comparison with the "state"
    // following the copy.
    //
    NewReplica = ReplicaIdToAddr(Coc->NewReplicaNum);
    if (NewReplica == NULL) {
        WIN_SET_FAIL(WStatus);
        goto out;
    }

    //
    // Special case opens for encrypted files.
    //

    if ((Coc != NULL) ? (Coc->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) :
        ((Coe != NULL) ? (Coe->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) : FALSE)) {

        //
        // The following open hangs if a oplock exists on a encrypted file.
        // Close the oplock and proceed ahead.
        //
        FRS_CLOSE(OpLockHandle);
        FRS_CLOSE(OpLockEvent);

        WStatus = FrsOpenSourceFileById(&SrcHandle,
                                        &Header->Attributes,
                                        NULL,
                                        NewReplica->pVme->VolumeHandle,
                                        &Coc->FileGuid,
                                        sizeof(GUID),
                                        STANDARD_RIGHTS_READ | FILE_READ_ATTRIBUTES | ACCESS_SYSTEM_SECURITY | SYNCHRONIZE,
                                        OpenOptions,
                                        SHARE_ALL,
                                        FILE_OPEN);
    } else {
        WStatus = FrsOpenSourceFileById(&SrcHandle,
                                        &Header->Attributes,
                                        NULL,
                                        NewReplica->pVme->VolumeHandle,
                                        &Coc->FileGuid,
                                        sizeof(GUID),
                                        READ_ACCESS,
                                        OpenOptions,
                                        SHARE_ALL,
                                        FILE_OPEN);
    }

    if (!WIN_SUCCESS(WStatus)) {
        goto out;
    }
    //
    // Keep the file size as accurate as possible for both the reconcile
    // checks when deciding whether to accept the change order and for the
    // code that uses the file size to pre-allocate space.  The file size is
    // updated in the idtable entry when the change order is retired.
    //
    if (!FromPreExisting) {
        Coc->FileSize = Header->Attributes.AllocationSize.QuadPart;
    }

    //
    // Get the object id buffer
    //
    WStatus = FrsGetObjectId(SrcHandle, &Header->FileObjId);
    if (!WIN_SUCCESS(WStatus)) {
        WIN_SET_RETRY(WStatus);
        goto out;
    }

    //
    // What type of reparse is it?
    //
    if (FirstOpen &&
        (Header->Attributes.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)) {
        FirstOpen = FALSE;

        if (!FromPreExisting) {
            //
            //
            Coc->FileAttributes |= FILE_ATTRIBUTE_REPARSE_POINT;
        }

        //
        // reparse tag
        //
        WStatus = FrsGetReparseTag(SrcHandle, &ReparseTag);
        if (!WIN_SUCCESS(WStatus)) {
            goto out;
        }

        //
        // We only accept operations on files with SIS and HSM reparse points.
        // For example a rename of a SIS file into a replica tree needs to prop
        // a create CO.
        //
        if ((ReparseTag != IO_REPARSE_TAG_HSM) &&
            (ReparseTag != IO_REPARSE_TAG_SIS)) {
            CHANGE_ORDER_COMMAND_TRACE(3, Coc, "Unknown Reparse Tag");
            DPRINT3(3, "++ %ws (FGuid %08x) has reparse tag %08x, unsupported.\n",
                    Coc->FileName, Coc->FileGuid.Data1, ReparseTag);

            WIN_SET_FAIL(WStatus);
            goto out;
        }

        //
        // We hit a file with a known reparse tag type.
        // Close and reopen the file without the FILE_OPEN_REPARSE_POINT
        // option so backup read will get the underlying data.
        //
        FRS_CLOSE(SrcHandle);
        FRS_CLOSE(OpLockHandle);
        FRS_CLOSE(OpLockEvent);

        ClearFlag(OpenOptions, FILE_OPEN_REPARSE_POINT);
        goto RETRY_OPEN;

    }


    //
    // Assume retriable errors for the boolean functions
    //
    WIN_SET_RETRY(WStatus);

    //
    // Default to no compression if we can't get the compression state
    //
    if (ERROR_SUCCESS != FrsGetCompression(Coc->FileName, SrcHandle, &Header->Compression)) {
        Header->Compression = COMPRESSION_FORMAT_NONE;
    }

    if (!DebugInfo.DisableCompression) {
        //
        // Compression is enabled. Get the routine to use to compress the data.
        //
        WStatus = FrsGetCompressionRoutine(Coc->FileName, SrcHandle, &pFrsCompressBuffer, &Header->CompressionGuid);

        if (WIN_SUCCESS(WStatus) && pFrsCompressBuffer != NULL ) {

            SetFlag(Coc->Flags, CO_FLAG_COMPRESSED_STAGE);
        } else {
            //
            // No suitable compression routine was found for this file.
            // Send this file uncompressed.
            //
            pFrsCompressBuffer = NULL;
        }
    }

    //
    // Return the guid of the compression for that was used to compress this staging
    // file. This will be stored in the STAGE_ENTRY structure for this staging
    // file so it can be accessed easily when a downstream partner is fetching
    // the file. Note if the above call does not return a valid guid then then it
    // should leave it as all zeroes. All zeroes means that the file is uncompressed.
    //
    COPY_GUID(CompressionFormatUsed, &Header->CompressionGuid);

    //
    // insert the change order command.
    //
    CopyMemory(&Header->ChangeOrderCommand, Coc, sizeof(CHANGE_ORDER_COMMAND));
    Header->ChangeOrderCommand.Extension = NULL;
    //
    // Change Order Command Extension.
    //   1. Generating stage file for local co then Coc's chksum is stale.
    //   2. Generating stage file for ondemand fetch, Coc chksum may not match
    //   3. Generating stage file for MD5 check request then Coc chksum may not match.
    //   4. Generating stage file for pre-existing file then Coc doesn't have chksum.
    // At this point the Coc checksum is not useful so leave extension ptr Null
    // and maybe update the Extension in the header once it is computed.
    //
    //if (Coc->Extension != NULL) {
    //    CopyMemory(&Header->CocExt, Coc->Extension, sizeof(CHANGE_ORDER_RECORD_EXTENSION));
        bugbug("if MD5 generated below is different from what is in CO then we need to rewrite the extension");
    //}

    //
    // The backup data begins at the first 32 byte boundary following the header
    //
    Header->DataLow = QuadQuadAlignSize(sizeof(STAGE_HEADER));

    //
    // Major/minor
    //
    Header->Major = NtFrsStageMajor;
    Header->Minor = NtFrsStageMinor;

    //
    // Create the local staging name. Use a different prefix for compressed files.
    //
    if (!DebugInfo.DisableCompression && pFrsCompressBuffer != NULL) {
        StagePath = StuCreStgPath(NewReplica->Stage, &Coc->ChangeOrderGuid, STAGE_GENERATE_COMPRESSED_PREFIX);
    } else {
        StagePath = StuCreStgPath(NewReplica->Stage, &Coc->ChangeOrderGuid, STAGE_GENERATE_PREFIX);
    }

    //
    // The file USN in the CO is not valid until the file is installed but the
    // CO can be propagated as soon as the Staging File is Fetched from our
    // inbound partner.  If this CO went out before the install completed then
    // we assume the data is still current and send it on.
    //
    if (Regenerating) {
        //
        // This is a fetch request from an outbound partner.  If it isn't
        // a demand refresh then check if the file USN has changed since we
        // sent out the CO.
        //
        // This still doesn't work because a non-replicating basic info
        // change could have changed the USN on the file.
        // In addition if the install of the file was delayed when the
        // CO was inserted in the outlog, then the USN on the file is
        // still more recent than in the CO, so it still won't match.  Sigh!
        //
        if (0 && !BooleanFlagOn(Coc->Flags, CO_FLAG_DEMAND_REFRESH) &&
            !StuCmpUsn(SrcHandle, Coe  /*  NOTE:  COE is NULL HERE */, &Coc->JrnlUsn)) {
            DPRINT(4, "++ Stage File Creation for fetch failed due to FileUSN change.\n");
            DPRINT1(4, "++ Coc->JrnlUsn is: %08x %08x\n", PRINTQUAD(Coc->JrnlUsn));
            DPRINT2(4, "++ Filename: %ws   Vsn: %08x %08x\n", Coc->FileName, PRINTQUAD(Coc->FrsVsn));
            WIN_SET_FAIL(WStatus);
            goto out;
        }
    } else {
        //
        // This is a stage request for a local CO.  Check to see if the file
        // USN has changed.  Note:  If this local CO was sent thru retry, due to a
        // previous sharing viol say, and then a basic info change was made
        // to the file then the USN value in the change order would not match
        // the USN on the file when the CO is later retried.  To solve this, test
        // if this is a retry CO and if so then generate the stage file anyway.
        // Even if this CO didn't go thru retry a basic info change could still
        // have been done to the file and before we got the first change order
        // here.  So the file USN still wouldn't match.
        //
        // Currently the Coc flag CO_FLAG_FILE_USN_VALID is never set.
        // The code in createdb is commented out because a test for a valid
        // file on a fetch can be bogus.
        //
        if (0 && BooleanFlagOn(Coc->Flags, CO_FLAG_FILE_USN_VALID) &&
            !BooleanFlagOn(Coc->Flags, CO_FLAG_RETRY) &&
            !StuCmpUsn(SrcHandle, Coe, &Coc->FileUsn)) {
            //
            // Don't retry; the file has changed on us.
            //
            DPRINT(4, "++ Stage File Creation failed due to FileUSN change.\n");
            DPRINT1(4, "++ Coc->FileUsn is: %08x %08x\n", PRINTQUAD(Coc->FileUsn));
            DPRINT2(4, "++ Filename: %ws   Vsn: %08x %08x\n", Coc->FileName, PRINTQUAD(Coc->FrsVsn));
            WIN_SET_FAIL(WStatus);
            goto out;
        }
    }

    //
    // Create the staging file
    //
    WStatus = StuCreateFile(StagePath, &StageHandle);
    if (!HANDLE_IS_VALID(StageHandle) || !WIN_SUCCESS(WStatus)) {
        goto out;
    }
/*
    //
    // Approximate size of the staging file
    //
    if (!WIN_SUCCESS(FrsSetFilePointer(StagePath, StageHandle,
                           Header->Attributes.EndOfFile.HighPart,
                           Header->Attributes.EndOfFile.LowPart))) {
        goto out;
    }

    if (!FrsSetEndOfFile(StagePath, StageHandle)) {
        DPRINT2(0, "++ ERROR - %ws: Cannot set EOF to %08x %08x\n",
                StagePath, PRINTQUAD(Header->Attributes.EndOfFile.QuadPart));
        goto out;
    }
*/
    //
    // To generate a staging file from an encrypted file the "Raw File" APIs needs
    // to get called to get the raw encrypted data. This raw encrypted data does
    // not contain the file information like the filename, file times, object id,
    // security information, and other non-encrypted streams if present. After all
    // the encrypted data is stored in the staging file, BackupRead needs to be
    // called to collect the remaining file data. The offset and size of the
    // encrypted data needs to be added to the stage header so the encrypted
    // data can be extracted on the destination server.
    //
    if (Header->Attributes.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {


        //
        // OpenEncryptedFileRaw API needs a path to open the file. Get the path
        // from the handle.
        //
        // The open by ID is done.  Now go get the full path name.
        //
        Path = FrsGetFullPathByHandle(Coc->FileName, SrcHandle);
        if (Path) {
            SrcFile = FrsWcsCat(NewReplica->Volume, Path);
        }

        if (SrcFile == NULL) {
            WStatus = ERROR_NOT_ENOUGH_MEMORY;
            CLEANUP1_WS(0, "++ WARN - FrsGetFullPathByHandle(%ws)", Coc->FileName, WStatus, out);
        }

        //
        // The volume path above is in the form of \\.\E: which is necessary to
        // open a volume handle (( check this )).  But we need \\?\E: here to
        // allow long path names to work.  See CreateFile API description in SDK.
        //
        if (SrcFile[2] == L'.') {
            SrcFile[2] = L'?';
        }

        DPRINT1(4, "++ FrsGetFullPathByHandle(%ws -> \n", Coc->FileName);
        FrsPrintLongUStr(4, DEBSUB, __LINE__, SrcFile);



        if (Header->Attributes.FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            WStatus = OpenEncryptedFileRaw(SrcFile, CREATE_FOR_DIR, &pEncryptContext);
        } else {
            WStatus = OpenEncryptedFileRaw(SrcFile, 0, &pEncryptContext);
        }

        CLEANUP1_WS(0, "++ OpenEncryptedFileRaw failed on %ws;", SrcFile, WStatus, out);

        WStatus = FrsSetFilePointer(StagePath, StageHandle, Header->DataHigh, Header->DataLow);
        CLEANUP1_WS(0, "++ Set file pointer failed on %ws;", StagePath, WStatus, out);

        FrsEncryptDataContext.StagePath = StagePath;
        FrsEncryptDataContext.StageHandle = StageHandle;
        FrsEncryptDataContext.RawEncryptedBytes.QuadPart = 0;

        WStatus = ReadEncryptedFileRaw(StuReadEncryptedFileRaw, &FrsEncryptDataContext, pEncryptContext);

        CloseEncryptedFileRaw(pEncryptContext);

        CLEANUP1_WS(0, "++ ReadEncryptedFileRaw  failed on %ws;", SrcFile, WStatus, out);

        //
        // The encrypted bytes are stored right after the stage header. The other
        // BackupRead data is stored following it.
        //
        Header->EncryptedDataLow = QuadQuadAlignSize(sizeof(STAGE_HEADER));
        Header->EncryptedDataSize.QuadPart = FrsEncryptDataContext.RawEncryptedBytes.QuadPart;

        DataOffset.LowPart = Header->DataLow;
        DataOffset.HighPart = Header->DataHigh;

        DataOffset.QuadPart += Header->EncryptedDataSize.QuadPart;

        Header->DataLow = DataOffset.LowPart;
        Header->DataHigh = DataOffset.HighPart;

    }

    //
    // Rewind the file, write the header, and set the file pointer
    // to the next 32 byte boundary
    //
    WStatus = FrsSetFilePointer(StagePath, StageHandle, 0, 0);
    CLEANUP1_WS(0, "++ Rewind failed on %ws;", StagePath, WStatus, out);

    WStatus = StuWriteFile(StagePath, StageHandle, Header, sizeof(STAGE_HEADER));
    CLEANUP1_WS(0, "++ WriteFile failed on %ws;", StagePath, WStatus, out);

    WStatus = FrsSetFilePointer(StagePath, StageHandle, Header->DataHigh, Header->DataLow);
    CLEANUP1_WS(0, "++ SetFilePointer failed on %ws;", StagePath, WStatus, out);

    //
    // Increment the SizeOfFileGenerated if it has been asked
    //
    if (SizeOfFileGenerated != NULL) {
        *SizeOfFileGenerated += Header->DataLow;
    }

    //
    // Backup the src file into the staging file
    //
    BackupBuf = FrsAlloc(STAGEING_IOSIZE);
    StreamBytesLeft = 0;

    while (TRUE) {
        //
        // Check for a triggered oplock
        //
        if (HANDLE_IS_VALID(OpLockEvent)) {
            if (WaitForSingleObject(OpLockEvent, 0) != WAIT_TIMEOUT) {
                goto out;
            }
        }

        //
        // read source
        //
        if (!BackupRead(SrcHandle,
                        BackupBuf,
                        STAGEING_IOSIZE,
                        &NumBackupDataBytes,
                        FALSE,
                        TRUE,
                        &BackupContext)) {
            WStatus = GetLastError();
            CHANGE_ORDER_TRACEW(0, Coe, "ERROR - BackupRead", WStatus);
            //
            // This will cause us to retry for all errors returned by BackupRead.
            // Do we want to retry in all cases?
            WIN_SET_RETRY(WStatus);
            goto out;
        }

        //
        // No more data; Backup done
        //
        if (NumBackupDataBytes == 0) {
            break;
        }

#define __V51_FIND_REPARSE_STREAM__  0
#if __V51_FIND_REPARSE_STREAM__
        //
        // If this is the start of a new backup stream then dump out the
        // WIN32_STREAM_ID structure.
        //

        BuffBytesLeft = (LONG) NumBackupDataBytes;

        while (BuffBytesLeft > 0) {
            //
            // Is a stream header next?
            //
            DPRINT1(4, "++ New StreamBytesLeft: %Ld\n", StreamBytesLeft);
            DPRINT1(4, "++ New BuffBytesLeft: %d\n", BuffBytesLeft);

            if (StreamBytesLeft <= 0) {
                StreamId = (WIN32_STREAM_ID *)
                    ((PCHAR)BackupBuf + (NumBackupDataBytes - (DWORD)BuffBytesLeft));

                Length = StreamId->dwStreamNameSize;

                //
                // header plus name plus data.
                //
                StreamBytesLeft = StreamId->Size.QuadPart + Length
                                + CB_NAMELESSHEADER;

                if (Length > 0) {
                    if (Length > (sizeof(TStr)-sizeof(WCHAR))) {
                        Length = (sizeof(TStr)-sizeof(WCHAR));
                    }
                    CopyMemory(TStr, StreamId->cStreamName, Length);
                    TStr[Length/sizeof(WCHAR)] = UNICODE_NULL;
                } else {
                    wcscpy(TStr, L"<Null>");
                }

                if (StreamId->dwStreamId == BACKUP_REPARSE_DATA) {
                    DPRINT(4, "++ BACKUP_REPARSE_DATA Stream\n");
                }

                DPRINT1(4, "++ Stream Name: %ws\n", TStr);

                DPRINT4(4, "++ ID: %d, Attr: %08x, Size: %Ld, NameSize: %d\n",
                        StreamId->dwStreamId, StreamId->dwStreamAttributes,
                        StreamId->Size.QuadPart, Length);
            }

            //
            // Have we run out of buffer?
            //
            if (StreamBytesLeft > (LONGLONG) BuffBytesLeft) {
                StreamBytesLeft -= (LONGLONG) BuffBytesLeft;
                DPRINT1(4, "++ New StreamBytesLeft: %Ld\n", StreamBytesLeft);
                DPRINT1(4, "++ New BuffBytesLeft: %d\n", BuffBytesLeft);
                break;
            }

            //
            // Reduce buffer bytes by bytes left in stream.
            //
            BuffBytesLeft -= (LONG) StreamBytesLeft;
            StreamBytesLeft = 0;
        }


#endif __V51_FIND_REPARSE_STREAM__

        //
        // The security section contains machine specific info. Get rid
        // of it when computing Md5.
        //
        // Note: Code assumes security section is first in backup file.
        //
        if (Md5) {
            //
            // Is the first buffer large enough to hold a stream header?
            //
            if (FirstBuffer && NumBackupDataBytes >= sizeof(WIN32_STREAM_ID)) {
                //
                // Is the first stream the security info? If so, is it
                // large enough to include an extra dword?
                //
                StreamId = (WIN32_STREAM_ID *)BackupBuf;
                if (StreamId->dwStreamId == BACKUP_SECURITY_DATA &&
                    NumBackupDataBytes >= sizeof(WIN32_STREAM_ID) +
                                          StreamId->dwStreamNameSize +
                                          sizeof(WORD) +
                                          sizeof(WORD)) {
                    //
                    // Assume second word contains the per-machine info.
                    // AND out the machine specific info, computer md5,
                    // put the word back to its original state.
                    //
                    SecurityControl = (PVOID)((PCHAR)&StreamId->cStreamName[0] +
                                               StreamId->dwStreamNameSize +
                                               sizeof(WORD));

                    CopyMemory(&OldSecurityControl, SecurityControl, sizeof(WORD));

                    NewSecurityControl = OldSecurityControl & ~((WORD)STAGING_RESET_SE);
                    CopyMemory(SecurityControl, &NewSecurityControl, sizeof(WORD));

                    MD5Update(Md5, BackupBuf, NumBackupDataBytes);
                    CopyMemory(SecurityControl, &OldSecurityControl, sizeof(WORD));
                }
            } else {
                MD5Update(Md5, BackupBuf, NumBackupDataBytes);
            }
            //
            // Stream id is not alwasy at the top of later buffers
            //
            FirstBuffer = FALSE;
        }

        //
        // Increment the value of the Bytes of Staging generated counter
        // or the staging regenerated counter depending on whether the
        // Regenerating value is FALSE or TRUE
        //
        if (!Regenerating) {
            PM_INC_CTR_REPSET(NewReplica, SFGeneratedB, NumBackupDataBytes);
        } else {
            PM_INC_CTR_REPSET(NewReplica, SFReGeneratedB, NumBackupDataBytes);
        }

        if (!DebugInfo.DisableCompression && pFrsCompressBuffer != NULL) {
            //
            // Compression is enabled. Compress the data before writing to the staging file.
            //
            if (CompressedBuf == NULL) {
                CompressedBuf = FrsAlloc(STAGEING_IOSIZE);
                CompressedBufLen = STAGEING_IOSIZE;
            }

            do {
                WStatus = (*pFrsCompressBuffer)(BackupBuf,                          //  input
                                                NumBackupDataBytes,                 //  length of input
                                                CompressedBuf,                      //  output
                                                CompressedBufLen,                   //  length of output
                                                &ActCompressedSize);                //  result size

                if (WStatus == ERROR_MORE_DATA) {
                    DPRINT2(5, "Compressed data is more than %d bytes, increasing buffer to %d bytes and retrying.\n",
                            CompressedBufLen, CompressedBufLen*2);
                    CompressedBuf = FrsFree(CompressedBuf);
                    CompressedBufLen = CompressedBufLen*2;
                    CompressedBuf = FrsAlloc(CompressedBufLen);
                    continue;
                } else {
                    break;
                }

                //
                // Keep increasing the buffer upto 256K. We fail for
                // files whose size increases more than 4 times after
                // compression.
                //
            } while (CompressedBufLen <= STAGEING_IOSIZE*4);

            if (!WIN_SUCCESS(WStatus)) {
                DPRINT1(0,"ERROR compressing data. WStatus = 0x%x\n", WStatus);

                goto out;
            }

            //
            // write the staging file
            //
            WStatus = StuWriteFile(StagePath, StageHandle, CompressedBuf, ActCompressedSize);
            CLEANUP1_WS(0, "++ WriteFile failed on %ws;", StagePath, WStatus, out);

        } else {
            //
            // write the staging file
            //
            WStatus = StuWriteFile(StagePath, StageHandle, BackupBuf, NumBackupDataBytes);
            CLEANUP1_WS(0, "++ WriteFile failed on %ws;", StagePath, WStatus, out);
        }

    }

    //
    // Release handles as soon as possible
    //
    FRS_CLOSE(SrcHandle);
    FRS_CLOSE(OpLockHandle);
    FRS_CLOSE(OpLockEvent);

    //
    // Make sure all of the data is on disk. We don't want to lose
    // it across reboots
    //
    WStatus = FrsFlushFile(StagePath, StageHandle);
    CLEANUP1_WS(0, "++ FlushFileBuffers failed on %ws;", StagePath, WStatus, out);

    //
    // Increment the SizeOfFileGenerated is if has been asked
    //
    if (SizeOfFileGenerated != NULL) {
        GetFileSizeEx(StageHandle, (PLARGE_INTEGER)SizeOfFileGenerated);
    }

    //
    // Done with the staging file handle
    //
    if (BackupContext) {
        BackupRead(StageHandle, NULL, 0, NULL, TRUE, TRUE, &BackupContext);
    }

    FRS_CLOSE(StageHandle);
    BackupContext = NULL;

    //
    // Move the staging file into its final location.  Unless this happens to
    // be generating a staging file for a preexisting file on the downstream
    // partner.  The upstream partner completes the generation of the staging
    // file because it own the "correct" copy.  The downstream partner's
    // staging file may be incorrect.  We won't know for sure until the
    // upstream partner compares the md5 checksum.  The staging file isn't
    // finalized because a shutdown will cause the incorrect staging file to
    // be treated as the correct copy.
    //
    if (!FromPreExisting) {
        if (!DebugInfo.DisableCompression && pFrsCompressBuffer != NULL) {
            FinalPath = StuCreStgPath(NewReplica->Stage, &Coc->ChangeOrderGuid, STAGE_FINAL_COMPRESSED_PREFIX);
        } else {
            FinalPath = StuCreStgPath(NewReplica->Stage, &Coc->ChangeOrderGuid, STAGE_FINAL_PREFIX);
        }
        if (!MoveFileEx(StagePath,
                        FinalPath,
                        MOVEFILE_WRITE_THROUGH | MOVEFILE_REPLACE_EXISTING)) {
            WStatus = GetLastError();
            goto out;
        }
    }

    //
    // The Idtable record should reflect these attributes of the staging file
    // we generated.  These fields will be used to update the idtable record
    // when the change order is retired.
    //
    if (!Regenerating && !FromPreExisting) {
        BOOL AttributeMissmatch;
        Coe->FileCreateTime.QuadPart = Header->Attributes.CreationTime.QuadPart;
        Coe->FileWriteTime.QuadPart  = Header->Attributes.LastWriteTime.QuadPart;

        AttributeMissmatch = ((Coc->FileAttributes ^
                               Header->Attributes.FileAttributes) &
                                  FILE_ATTRIBUTE_DIRECTORY) != 0;

        if (AttributeMissmatch) {
            DPRINT2(0, "++ ERROR: Attribute missmatch between CO (%08x) and File (%08x)\n",
                    Coc->FileAttributes, Header->Attributes.FileAttributes);
            FRS_ASSERT(!"Attribute missmatch between CO and File");
        }

        Coc->FileAttributes = Header->Attributes.FileAttributes;
    }

    WStatus = ERROR_SUCCESS;

out:
    //
    // Release resources
    //
    FRS_CLOSE(SrcHandle);
    FRS_CLOSE(OpLockHandle);
    FRS_CLOSE(OpLockEvent);

    if (BackupContext) {
        BackupRead(StageHandle, NULL, 0, NULL, TRUE, TRUE, &BackupContext);
    }

    FRS_CLOSE(StageHandle);

    FrsFree(Path);
    FrsFree(SrcFile);
    FrsFree(BackupBuf);
    FrsFree(StagePath);
    FrsFree(FinalPath);

    //
    //######################### COMPRESSION OF STAGING FILE STARTS ###############
    //
    FrsFree(CompressedBuf);
    //
    //######################### COMPRESSION OF STAGING FILE ENDS ###############
    //

    if (Md5) {
        MD5Final(Md5);
        bugbug("if MD5 generated above is different from what is in CO then we need to rewrite the extension");
        bugmor("Do we need to call MD5Final before we have a valid checksum?")
    }

    return WStatus;
}


DWORD
StuGenerateDecompressedStage(
    IN PWCHAR   StageDir,
    IN GUID     *CoGuid,
    IN GUID     *CompressionFormatUsed
    )
/*++
Routine Description:
    Converts a compressed staging file to uncompressed staging file.

Arguments:

    StageDir              : Path to the staging dir.
    CoGuid                : Pointer to the CO guid.
    CompressionFormatUsed : Compression format to use to decompress the
                            staging file.

Return Value:
    WIN32 STATUS

--*/
{
#undef DEBSUB
#define DEBSUB  "StuGenerateDecompressedStage:"

    PWCHAR  SrcStagePath        = NULL;
    PWCHAR  DestStagePath       = NULL;
    PWCHAR  FinalStagePath      = NULL;
    HANDLE  SrcStageHandle      = INVALID_HANDLE_VALUE;
    HANDLE  DestStageHandle     = INVALID_HANDLE_VALUE;
    DWORD   WStatus             = ERROR_SUCCESS;
    PUCHAR  CompressedBuf       = NULL;
    ULONG   ToDecompress        = 0;
    STAGE_HEADER Header;

    DWORD   DecompressStatus    = ERROR_SUCCESS;
    PUCHAR  DecompressedBuf     = NULL;
    DWORD   DecompressedBufLen  = 0;
    DWORD   DecompressedSize    = 0;
    FRS_COMPRESSED_CHUNK_HEADER ChunkHeader;
    LONG    LenOfPartialChunk   = 0;
    DWORD   BytesProcessed      = 0;
    PVOID   DecompressContext   = NULL;
    DWORD (*pFrsDecompressBuffer)(OUT DecompressedBuf, IN DecompressedBufLen, IN CompressedBuf, IN CompressedBufLen, OUT DecompressedSize, OUT BytesProcessed);
    PVOID (*pFrsFreeDecompressContext)(IN pDecompressContext);

    //
    // Get the decompression routines by using the guid passed in.
    //
    if (IS_GUID_ZERO(CompressionFormatUsed)) {
        WStatus = ERROR_INVALID_PARAMETER;
        goto CLEANUP;
    }

    WStatus = FrsGetDecompressionRoutineByGuid(CompressionFormatUsed,
                                               &pFrsDecompressBuffer,
                                               &pFrsFreeDecompressContext);
    if (!WIN_SUCCESS(WStatus)) {
        //
        // No suitable decompression routine was found for this file.
        //
        DPRINT(0, "ERROR - No suitable decompression routine was found \n");
        FRS_ASSERT(TRUE);
    }

    SrcStagePath = StuCreStgPath(StageDir, CoGuid, STAGE_FINAL_COMPRESSED_PREFIX);
    //
    // SrcStagePath can be NULL is any of the above three parameters are NULL (prefix fix).
    //
    if (SrcStagePath == NULL) {
        goto CLEANUP;
    }

    DestStagePath = StuCreStgPath(StageDir, CoGuid, STAGE_GENERATE_PREFIX);
    //
    // DestStagePath can be NULL is any of the above three parameters are NULL (prefix fix).
    //
    if (DestStagePath == NULL) {
        goto CLEANUP;
    }

    //
    // Open the stage file for shared, sequential reads
    //
    WStatus = StuOpenFile(SrcStagePath, GENERIC_READ, &SrcStageHandle);
    if (!HANDLE_IS_VALID(SrcStageHandle) || !WIN_SUCCESS(WStatus)) {
        DPRINT2(0,"Error opening %ws. WStatus = %d\n", SrcStagePath, WStatus);
        goto CLEANUP;
    }

    //
    // Delete the dest file if it exits.
    //
    WStatus = FrsDeleteFile(DestStagePath);
    CLEANUP1_WS(0, "Error deleting %ws;", DestStagePath, WStatus, CLEANUP);

    //
    // Create the decompressed staging file.
    //
    WStatus = StuCreateFile(DestStagePath, &DestStageHandle);
    if (!HANDLE_IS_VALID(DestStageHandle) || !WIN_SUCCESS(WStatus)) {
        DPRINT2(0,"Error opening %ws. WStatus = %d\n", DestStagePath, WStatus);
        goto CLEANUP;
    }

    //
    // First copy the stage header.
    //
    //
    // read stage header.
    //
    WStatus = StuReadFile(SrcStagePath, SrcStageHandle, &Header, sizeof(STAGE_HEADER), &ToDecompress);
    CLEANUP1_WS(0, "Can't read file %ws;", SrcStagePath, WStatus, CLEANUP);

    if (ToDecompress == 0) {
        goto CLEANUP;
    }

    //
    // Zero off the compression guid from the header. This down level partner
    // could later on send this staging file to an uplevel partner.
    //
    ZeroMemory(&Header.CompressionGuid, sizeof(GUID));

    //
    // Write the stage header.
    //
    WStatus = StuWriteFile(DestStagePath, DestStageHandle, &Header, sizeof(STAGE_HEADER));
    CLEANUP1_WS(0, "++ WriteFile failed on %ws;", DestStagePath, WStatus, CLEANUP);

    //
    // Set the stage file pointers to point to the start of stage data.
    //
    WStatus = FrsSetFilePointer(SrcStagePath, SrcStageHandle, Header.DataHigh, Header.DataLow);
    CLEANUP1_WS(0, "++ SetFilePointer failed on src %ws;", SrcStagePath, WStatus, CLEANUP);

    WStatus = FrsSetFilePointer(DestStagePath, DestStageHandle, Header.DataHigh, Header.DataLow);
    CLEANUP1_WS(0, "++ SetFilePointer failed on dest %ws;", DestStagePath, WStatus, CLEANUP);


    //
    // Restore the stage file into the temporary file
    //
    CompressedBuf = FrsAlloc(STAGEING_IOSIZE);

    do {
        //
        // read stage
        //
        WStatus = StuReadFile(SrcStagePath, SrcStageHandle, CompressedBuf, STAGEING_IOSIZE, &ToDecompress);
        CLEANUP1_WS(0, "Can't read file %ws;", SrcStagePath, WStatus, CLEANUP);

        if (ToDecompress == 0) {
            break;
        }

        //
        // Compression is enabled. Decompress data before installing.
        //
        BytesProcessed = 0;
        DecompressContext = NULL;
        if (DecompressedBuf == NULL) {
            DecompressedBuf = FrsAlloc(STAGEING_IOSIZE);
            DecompressedBufLen = STAGEING_IOSIZE;
        }
        do {

            DecompressStatus = (*pFrsDecompressBuffer)(DecompressedBuf,
                                                       DecompressedBufLen,
                                                       CompressedBuf,
                                                       ToDecompress,
                                                       &DecompressedSize,
                                                       &BytesProcessed,
                                                       &DecompressContext);

            if (!WIN_SUCCESS(DecompressStatus) && DecompressStatus != ERROR_MORE_DATA) {
                DPRINT1(0,"Error - Decompressing. WStatus = 0x%x\n", DecompressStatus);
                WStatus = DecompressStatus;
                goto CLEANUP;
            }

            if (DecompressedSize == 0) {
                break;
            }

            //
            // Write the decompressed staging file.
            //
            WStatus = StuWriteFile(DestStagePath, DestStageHandle, DecompressedBuf, DecompressedSize);
            CLEANUP1_WS(0, "++ WriteFile failed on %ws;", DestStagePath, WStatus, CLEANUP);

        } while (DecompressStatus == ERROR_MORE_DATA);

        //
        // Free the Decompress context if used.
        //
        if (DecompressContext != NULL) {
            pFrsFreeDecompressContext(&DecompressContext);
        }
        //
        // Rewind the file pointer so we can read the remaining chunck at the next read.
        //

        LenOfPartialChunk = ((LONG)BytesProcessed - (LONG)ToDecompress);

        LenOfPartialChunk = SetFilePointer(SrcStageHandle, LenOfPartialChunk, NULL, FILE_CURRENT);
        if (LenOfPartialChunk == INVALID_SET_FILE_POINTER) {
            WStatus = GetLastError();
            CLEANUP1_WS(0, "++ Can't set file pointer for %ws;", SrcStagePath, WStatus, CLEANUP);
        }

    } while (TRUE);

    FRS_CLOSE(SrcStageHandle);
    FRS_CLOSE(DestStageHandle);

    //
    // Do the final rename.
    //

    FinalStagePath = StuCreStgPath(StageDir, CoGuid, STAGE_FINAL_PREFIX);
    //
    // DestStagePath can be NULL is any of the above three parameters are NULL (prefix fix).
    //
    if (FinalStagePath == NULL) {
        goto CLEANUP;
    }

    if (!MoveFileEx(DestStagePath,
                    FinalStagePath,
                    MOVEFILE_WRITE_THROUGH | MOVEFILE_REPLACE_EXISTING)) {
        WStatus = GetLastError();
        DPRINT3(0,"Error moving %ws to %ws. WStatus = %d\n", DestStagePath, FinalStagePath, WStatus);
        goto CLEANUP;
    }

    WStatus = ERROR_SUCCESS;

CLEANUP:

    FrsFree(SrcStagePath);
    FrsFree(DestStagePath);
    FrsFree(CompressedBuf);
    FrsFree(DecompressedBuf);

    FRS_CLOSE(SrcStageHandle);
    FRS_CLOSE(DestStageHandle);
    return WStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\util\qhash.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    qhash.c

Abstract:

Quick Hash Table routines.  Unlike the Genhash table functions these routines
use a fixed size node (QHASH_ENTRY) and the data fields are passed as
parameters and copied into the node.  The generic hash functions include a
link entry in the users struct to link the node onto a hash chain.  The genhash
functions also include reference counts for the nodes.

The generic hash functions have a lock per hash row where a Qhash table
has only a single lock for the table.

The PQHASH_TABLE struct is a typed struc allocated with FrsAllocTypeSize().

QHASH tables can be used in two ways, for fixed size QuadWord keys and for
more complex non-Quadword keys.

For QHASH tables with QuadWord keys:

    The macro SET_QHASH_TABLE_HASH_CALC() is used to specify the hash function
    to use for the table.  The key is supplied as a quadword and each entry has
    longword flags and a quadword data field for the callers info.

For QHASH tables with Large keys:

    When the QHASH table is created you specify it as a large key table (i.e.
    not a simple Quadword Key) by doing:

    SET_QHASH_TABLE_FLAG(HashTable, QHASH_FLAG_LARGE_KEY);

    For large key tables the QHASH_ENTRY Flags ULONG_PTR and the Flags argument
    to QHashInsert() are expected to point at a caller defined data node with
    the large key value for the node at offset zero.  On lookups the HashCalc2
    function set by SET_QHASH_TABLE_HASH_CALC2() is used to calculate both the
    quadword key for the hashtable entry and the hash value used for indexing
    the main array.  In addition the caller specifies an exact key match
    function via SET_QHASH_TABLE_KEY_MATCH() to be used after the initial
    quadword key matches.  This key match function is passed both the lookup
    argument key and the node address that was saved in the QHASH_ENTRY Flags
    ULONG_PTR so it can perform the complete key match.

The macros QHashAcquireLock(_Table_) and QHashReleaseLock(_Table_) can
be used to lock the table over multiple operations.

The number of entries in the hash table array is specified by the allocation size
when the table is allocated.  When a collision occurs additional entries
are allocated and placed on a free list for use in the collision lists.

The storage for the base hash array and the collision entries are released
when the table is freed by calling FrsFreeType(Table).

An example of allocating a Qhash table with 100 entries in the base hash array:

//PQHASH_TABLE FrsWriteFilter;
//#define FRS_WRITE_FILTER_SIZE       sizeof(QHASH_ENTRY)*100

//    FrsWriteFilter = FrsAllocTypeSize(QHASH_TABLE_TYPE, FRS_WRITE_FILTER_SIZE);
//    SET_QHASH_TABLE_HASH_CALC(FrsWriteFilter, JrnlHashCalcUsn);


Author:

    David Orbits          [davidor]   22-Apr-1997

Environment:

    User Mode Service

Revision History:


--*/

#include <ntreppch.h>
#pragma  hdrstop

#include <frs.h>


ULONG
QHashDump (
    PQHASH_TABLE Table,
    PQHASH_ENTRY BeforeNode,
    PQHASH_ENTRY TargetNode,
    PVOID Context
    )
/*++

Routine Description:

    This function is called thru QHashEnumerateTable() to dump an entry.

Arguments:

    Table - the hash table being enumerated
    BeforeNode  -- ptr to the QhashEntry before the node of interest.
    TargetNode  -- ptr to the QhashEntry of interest.
    Context - Unused.

Return Value:

    FrsErrorStatus

--*/

{
#undef DEBSUB
#define DEBSUB  "QHashDump:"

    DPRINT4(5, "Link: %08x, Flags: %08x, Tag: %08x %08x, Data: %08x %08x\n",
           TargetNode->NextEntry,
           TargetNode->Flags,
           PRINTQUAD(TargetNode->QKey),
           PRINTQUAD(TargetNode->QData));

    return FrsErrorSuccess;
}



VOID
QHashExtendTable(
    IN PQHASH_TABLE HashTable
    )
 /*++

 Routine Description:

 Extend the number of entries in the hash table by allocating an
 extension block of up to QHASH_EXTENSION_MAX entries.

 The caller has the table lock.

 Arguments:

     HashTable  --  ptr to a PQHASH_TABLE struct.

 Return Value:

     None.

--*/

{
#undef DEBSUB
#define DEBSUB  "QHashExtendTable:"

    ULONG i, NumberExtEntries;
    PQHASH_ENTRY Ext;

    //
    // Allocate a block of memory.
    //
    Ext = FrsAlloc(HashTable->ExtensionAllocSize);
    InsertTailList(&HashTable->ExtensionListHead, (PLIST_ENTRY)Ext);
    NumberExtEntries = (HashTable->ExtensionAllocSize - sizeof(LIST_ENTRY)) /
                       sizeof(QHASH_ENTRY);

    //
    // Put the entries on the free list.
    //
    (PCHAR) Ext = (PCHAR)Ext + sizeof(LIST_ENTRY);

    HashTable->FreeList.Next = &Ext->NextEntry;

    for (i=0; i<NumberExtEntries; i++) {
        Ext->NextEntry.Next = &((Ext+1)->NextEntry);
        Ext++;
    }
    Ext -= 1;
    Ext->NextEntry.Next = NULL;
}


ULONG
QHashEnumerateTable(
    IN PQHASH_TABLE HashTable,
    IN PQHASH_ENUM_ROUTINE Function,
    IN PVOID         Context
    )
/*++

Routine Description:

    This routine walks through the entries in the QHash table
    and calls the function provided with the entry address and the context.
    The table lock is acquired and released here.

Arguments:

    HashTable - The context of the Hash Table to enumerate.
    Function - The function to call for each record in the table.  It is of
               of type PQHASH_ENUM_ROUTINE.  Return FALSE to abort the
               enumeration else true.
    Context - A context ptr to pass through to the RecordFunction.

Return Value:

    The FrsErrorStatus code from the argument function.

--*/

{
#undef DEBSUB
#define DEBSUB "QHashEnumerateTable:"

    PQHASH_ENTRY HashRowEntry;
    PQHASH_ENTRY BeforeEntry;
    ULONG i, FStatus;

    if (HashTable == NULL) {
        return FrsErrorSuccess;
    }

    HashRowEntry = HashTable->HashRowBase;

    //
    // Loop through all the Hash table rows and call the function for
    // each element.
    //

    QHashAcquireLock(HashTable);

    for (i=0; i<HashTable->NumberEntries; i++, HashRowEntry++) {

        if (HashRowEntry->QKey != QUADZERO) {

            FStatus = (Function)(HashTable, NULL, HashRowEntry, Context);
            if (FStatus == FrsErrorDeleteRequested) {
                HashRowEntry->QKey = QUADZERO;
            }
            else
            if (FStatus != FrsErrorSuccess) {
                QHashReleaseLock(HashTable);
                return FStatus;
            }
        }

        //
        // Enumerate collision list if present.
        //
        if (HashRowEntry->NextEntry.Next == NULL) {
            continue;
        }

        BeforeEntry = HashRowEntry;
        ForEachSingleListEntry(&HashRowEntry->NextEntry, QHASH_ENTRY, NextEntry,
            // Enumerator pE is of type PQHASH_ENTRY
            FStatus = (Function)(HashTable, BeforeEntry, pE, Context);

            if (FStatus == FrsErrorDeleteRequested) {
                RemoveSingleListEntry(UNUSED);
                PushEntryList(&HashTable->FreeList, &pE->NextEntry);
                pE = PreviousSingleListEntry(QHASH_ENTRY, NextEntry);
            }
            else

            if (FStatus != FrsErrorSuccess) {
                QHashReleaseLock(HashTable);
                return FStatus;
            }
            BeforeEntry = pE;
        );
    }


    QHashReleaseLock(HashTable);

    return FStatus;

}




GHT_STATUS
QHashLookup(
    IN PQHASH_TABLE HashTable,
    IN PVOID        ArgQKey,
    OUT PULONGLONG  QData,
    OUT PULONG_PTR  Flags
    )
/*++

Routine Description:

Lookup the Quadword Key in the hash table and if found, return the Qdata
and the flags DWORD.

The table lock is acquired and released here.

 Note: A zero value for QKey is an error because a zero is used
       to denote an empty hash table slot.

Arguments:

    HashTable  --  ptr to a PQHASH_TABLE struct.
    ArgQKey  -- ptr to the Key we are looking for.
    QData  -- If found this is the returned quadword data. (NULL if unused)
    Flags  -- If found this is the returned flags word.

Return Value:

    GHT_STATUS_NOT_FOUND -- if not found.
    GHT_STATUS_SUCCESS -- if found.

--*/

{
#undef DEBSUB
#define DEBSUB  "QHashLookup:"

    ULONGLONG QKey;
    ULONG GStatus;
    ULONG Hval, HvalIndex;
    PQHASH_ENTRY RowEntry;
    PQHASH_ENTRY LastFoundpE = NULL;

    if (IS_QHASH_LARGE_KEY(HashTable)) {
        Hval = (HashTable->HashCalc2)(ArgQKey, &QKey);
        DPRINT3(5, "QHashLookup (%08x): Hval: %08x  QKey: %08lx %08lx\n",
             HashTable, Hval, PRINTQUAD(QKey));
    } else {
        CopyMemory(&QKey, ArgQKey, 8);
        Hval = (HashTable->HashCalc)(&QKey, 8);
    }

    FRS_ASSERT(QKey != QUADZERO);

    //
    // Compute the hash index and calculate the row pointer.
    //
    HvalIndex = Hval % HashTable->NumberEntries;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    QHashAcquireLock(HashTable);

    if (RowEntry->QKey == QKey) {
        if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, RowEntry->Flags)) {

            //
            // Match.  Return quadword data and flags.
            //
            if (QData != NULL) {
                *QData = RowEntry->QData;
            }
            *Flags = RowEntry->Flags;
            DPRINT5(5, "QHash Lookup (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
                 HashTable, RowEntry, PRINTQUAD(RowEntry->QKey), PRINTQUAD(RowEntry->QData), RowEntry->Flags);
            QHashReleaseLock(HashTable);
            return GHT_STATUS_SUCCESS;
        }
    }


    if (RowEntry->NextEntry.Next == NULL) {
        QHashReleaseLock(HashTable);
        return GHT_STATUS_NOT_FOUND;
    }

    //
    // Scan the collision list.
    //
    ForEachSingleListEntry(&RowEntry->NextEntry, QHASH_ENTRY, NextEntry,
        //
        // The iterator pE is of type PQHASH_ENTRY.
        //
        if (QKey < pE->QKey) {
            //
            // Not on the list.
            //
            break;
        }
        if (pE->QKey == QKey) {
            if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, pE->Flags)) {
                //
                // Found it.
                //
                if (QData != NULL) {
                    *QData = pE->QData;
                }
                *Flags = pE->Flags;
                DPRINT5(5, "QHash Lookup (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
                     HashTable, pE, PRINTQUAD(pE->QKey), PRINTQUAD(pE->QData), pE->Flags);
                QHashReleaseLock(HashTable);
                return GHT_STATUS_SUCCESS;
            }
        }
    );

    QHashReleaseLock(HashTable);
    return GHT_STATUS_NOT_FOUND;
}



PQHASH_ENTRY
QHashLookupLock(
    IN PQHASH_TABLE HashTable,
    IN PVOID        ArgQKey
    )
/*++

Routine Description:

Lookup the Quadword Key in the hash table and if found, return the pointer to
the entry. The table lock is acquired and released by the caller.

Restriction:

    Once the caller drops the table lock no further ref to the QHASH_ENTRY
    is allowed since another thread could delete/update it.

 Note: A zero value for the key is an error because a zero is used
       to denote an empty hash table slot.

Arguments:

    HashTable  --  ptr to a PQHASH_TABLE struct.
    ArgQKey  -- ptr to the Key we are looking for.

Return Value:

    Pointer to QHashEntry, Null if not found.

--*/

{
#undef DEBSUB
#define DEBSUB  "QHashLookupLock:"

    ULONGLONG QKey;
    ULONG Hval, HvalIndex;
    PQHASH_ENTRY RowEntry;

    if (IS_QHASH_LARGE_KEY(HashTable)) {
        Hval = (HashTable->HashCalc2)(ArgQKey, &QKey);
        DPRINT3(5, "QHash lookuplock (%08x): Hval: %08x  QKey: %08lx %08lx\n",
             HashTable, Hval, PRINTQUAD(QKey));
    } else {
        CopyMemory(&QKey, ArgQKey, 8);
        Hval = (HashTable->HashCalc)(&QKey, 8);
    }

    FRS_ASSERT(QKey != QUADZERO);

    //
    // Compute the hash index and calculate the row pointer.
    //
    HvalIndex = Hval % HashTable->NumberEntries;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    if (RowEntry->QKey == QKey) {
        if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, RowEntry->Flags)) {
            DPRINT5(5, "QHash Lookup (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
                 HashTable, RowEntry, PRINTQUAD(RowEntry->QKey), PRINTQUAD(RowEntry->QData), RowEntry->Flags);
            return RowEntry;
        }
    }

    if (RowEntry->NextEntry.Next == NULL) {
        return NULL;
    }

    //
    // Scan the collision list.
    //
    ForEachSingleListEntry(&RowEntry->NextEntry, QHASH_ENTRY, NextEntry,
        //
        // The iterator pE is of type PQHASH_ENTRY.
        // Check for early terminate and then for a match.
        //
        if (QKey < pE->QKey) {
            return NULL;
        }
        if (pE->QKey == QKey) {
            if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, pE->Flags)) {
                DPRINT5(5, "QHash Lookup (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
                     HashTable, pE, PRINTQUAD(pE->QKey), PRINTQUAD(pE->QData), pE->Flags);
                return pE;
            }
        }
    );

    return NULL;
}




GHT_STATUS
QHashInsert(
    IN PQHASH_TABLE HashTable,
    IN PVOID      ArgQKey,
    IN PULONGLONG QData,
    IN ULONG_PTR Flags,
    IN BOOL HaveLock
    )

 /*++

 Routine Description:

 Insert the Quadword Key in the hash table and if found, return the data
 and the flags DWORD.  The keys are in numerically increasing order on the
 collision chains.

 The table lock is acquired and released here.

 Note: A zero value for the key is an error because a zero is used
       to denote an empty hash table slot.

 Arguments:

     HashTable  --  ptr to a PQHASH_TABLE struct.
     ArgQKey  -- ptr to the Key we are inserting.
     QData  -- This is ptr to the quadword data. (NULL if unused).
     Flags  -- This is the flags word data.  For large Key QHASH tables this
               is the ptr to the data node.  Note that we assume the large
               Key is at a zero offset in the node when doing lookups.
     HaveLock -- True means the caller has taken the lock else we take it.

 Return Value:

    GHT_STATUS_FAILURE -- Conflicting entry is in table already.
    GHT_STATUS_SUCCESS -- Insert was successful.


--*/

{
#undef DEBSUB
#define DEBSUB  "QHashInsert:"

    ULONGLONG QKey;
    ULONG Hval, HvalIndex;
    PQHASH_ENTRY RowEntry, AfterEntry;
    PQHASH_ENTRY pNew;
    PSINGLE_LIST_ENTRY NewEntry;

    if (IS_QHASH_LARGE_KEY(HashTable)) {
        Hval = (HashTable->HashCalc2)(ArgQKey, &QKey);
        DPRINT3(5, "QHashInsert (%08x): Hval: %08x  QKey: %08lx %08lx\n",
             HashTable, Hval, PRINTQUAD(QKey));

    } else {
        CopyMemory(&QKey, ArgQKey, 8);
        Hval = (HashTable->HashCalc)(&QKey, 8);
    }

    FRS_ASSERT(QKey != QUADZERO);

    //
    // Compute the hash index and calculate the row pointer.
    //
    HvalIndex = Hval % HashTable->NumberEntries;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    if (!HaveLock) {QHashAcquireLock(HashTable);}

    if (RowEntry->QKey == QUADZERO) {
        pNew = RowEntry;
        goto INSERT_ENTRY;
    }


    if (RowEntry->QKey == QKey) {
        if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, RowEntry->Flags)) {
            if (!HaveLock) {QHashReleaseLock(HashTable);}
            return GHT_STATUS_FAILURE;
        }
    }
    AfterEntry  = RowEntry;

    //
    // Scan the collision list.
    //
    ForEachSingleListEntry(&RowEntry->NextEntry, QHASH_ENTRY, NextEntry,
        //
        // The iterator pE is of type PQHASH_ENTRY.
        //
        if (QKey < pE->QKey) {
            //
            // Not on the list.
            //
            break;
        }

        if (pE->QKey == QKey) {
            if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, pE->Flags)) {
                //
                // Found it, collision.
                //
                if (!HaveLock) {QHashReleaseLock(HashTable);}
                return GHT_STATUS_FAILURE;
            }
        }
        AfterEntry = pE;
    );

    //
    // Not found.  Allocate a new entry and put it in the list.
    //
    NewEntry = PopEntryList(&HashTable->FreeList);
    if (NewEntry == NULL) {
        //
        // Allocate a table extension block.
        //
        QHashExtendTable(HashTable);
        NewEntry = PopEntryList(&HashTable->FreeList);
    }
    //
    // Insert entry in the list.
    //
    pNew = CONTAINING_RECORD(NewEntry, QHASH_ENTRY, NextEntry);
    PushEntryList( &AfterEntry->NextEntry, &pNew->NextEntry);

    //
    // Insert the data and drop the lock.
    //
INSERT_ENTRY:
    pNew->QKey = QKey;
    pNew->Flags = Flags;
    if (QData != NULL) {
        pNew->QData = *QData;
    } else {
        pNew->QData = QUADZERO;
    }

    DPRINT5(5, "QHash Insert (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
         HashTable, pNew, PRINTQUAD(pNew->QKey), PRINTQUAD(pNew->QData), pNew->Flags);

    if (!HaveLock) {QHashReleaseLock(HashTable);}
    return GHT_STATUS_SUCCESS;
}



PQHASH_ENTRY
QHashInsertLock(
    IN PQHASH_TABLE HashTable,
    IN PVOID        ArgQKey,
    IN PULONGLONG   QData,
    IN ULONG_PTR    Flags
    )

 /*++

 Routine Description:

 Insert the quadword key in the hash table.  Return the pointer to the entry.
 The caller has acquired the table lock and will release it.

 Arguments:

     HashTable  --  ptr to a PQHASH_TABLE struct.
     ArgQKey  -- ptr to the Key we are inserting.
     QData  -- This is ptr to the quadword data. (NULL if unused)
     Flags  -- This is the flags word data.  For large Key QHASH tables this
               is the ptr to the data node.  Note that we assume the large
               Key is at a zero offset in the node when doing lookups.

 Return Value:

    The ptr to the inserted entry or the existing entry if already in the table.

--*/

{
#undef DEBSUB
#define DEBSUB  "QHashInsertLock:"

    ULONGLONG QKey;
    ULONG Hval, HvalIndex;
    PQHASH_ENTRY RowEntry, AfterEntry;
    PQHASH_ENTRY pNew;
    PSINGLE_LIST_ENTRY NewEntry;

    if (IS_QHASH_LARGE_KEY(HashTable)) {
        Hval = (HashTable->HashCalc2)(ArgQKey, &QKey);
        DPRINT3(5, "QHashInsertLock (%08x): Hval: %08x  QKey: %08lx %08lx\n",
             HashTable, Hval, PRINTQUAD(QKey));
    } else {
        CopyMemory(&QKey, ArgQKey, 8);
        Hval = (HashTable->HashCalc)(&QKey, 8);
    }

    FRS_ASSERT(QKey != QUADZERO);
    //
    // Compute the hash index and calculate the row pointer.
    //
    HvalIndex = Hval % HashTable->NumberEntries;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    if (RowEntry->QKey == QUADZERO) {
        pNew = RowEntry;
        goto INSERT_ENTRY;
    }

    if (RowEntry->QKey == QKey) {
        if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, RowEntry->Flags)) {
            return RowEntry;
        }
    }
    AfterEntry  = RowEntry;

    //
    // Scan the collision list.
    //
    ForEachSingleListEntry(&RowEntry->NextEntry, QHASH_ENTRY, NextEntry,
        //
        // The iterator pE is of type PQHASH_ENTRY.  Check for early termination.
        //
        if (QKey < pE->QKey) {
            break;
        }

        if (pE->QKey == QKey) {
            if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, pE->Flags)) {
                //
                // Found it, return the pointer.
                //
                return pE;
            }
        }
        AfterEntry = pE;
    );

    //
    // Not found.  Allocate a new entry and put it in the list.
    //
    NewEntry = PopEntryList(&HashTable->FreeList);
    if (NewEntry == NULL) {
        //
        // Allocate a table extension block.
        //
        QHashExtendTable(HashTable);
        NewEntry = PopEntryList(&HashTable->FreeList);
    }
    //
    // Insert entry in the list.
    //
    pNew = CONTAINING_RECORD(NewEntry, QHASH_ENTRY, NextEntry);
    PushEntryList( &AfterEntry->NextEntry, &pNew->NextEntry);

    //
    // Insert the data.
    //
INSERT_ENTRY:
    pNew->QKey = QKey;
    pNew->Flags = Flags;

    if (QData != NULL) {
        pNew->QData = *QData;
    } else {
        pNew->QData = QUADZERO;
    }


    DPRINT5(5, "QHash Insert (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
         HashTable, pNew, PRINTQUAD(pNew->QKey), PRINTQUAD(pNew->QData), pNew->Flags);

    return pNew;
}




GHT_STATUS
QHashUpdate(
    IN PQHASH_TABLE HashTable,
    IN PVOID        ArgQKey,
    IN PULONGLONG   QData,
    IN ULONG_PTR    Flags
    )
/*++

Routine Description:

Lookup the Quadword key in the hash table and if found, update the entry.

The table lock is acquired and released here.

 Arguments:

     HashTable  --  ptr to a PQHASH_TABLE struct.
     ArgQKey  -- ptr to the Key we are updating.
     QData  -- This is ptr to the quadword data. (NULL if unused)
     Flags  -- This is the flags word data.  For large Key QHASH tables this
               is the ptr to the data node.  Note that we assume the large
               Key is at a zero offset in the node when doing lookups.

 Return Value:

    GHT_STATUS_FAILURE -- Entry not in table already.
    GHT_STATUS_SUCCESS -- Update was successful.

--*/

{
#undef DEBSUB
#define DEBSUB  "QHashUpdate:"

    ULONGLONG QKey;
    ULONG GStatus;
    ULONG Hval, HvalIndex;
    PQHASH_ENTRY RowEntry;
    PQHASH_ENTRY LastFoundpE = NULL;

    if (IS_QHASH_LARGE_KEY(HashTable)) {
        Hval = (HashTable->HashCalc2)(ArgQKey, &QKey);
        DPRINT3(5, "QHashupdate (%08x): Hval: %08x  QKey: %08lx %08lx\n",
             HashTable, Hval, PRINTQUAD(QKey));
    } else {
        CopyMemory(&QKey, ArgQKey, 8);
        Hval = (HashTable->HashCalc)(&QKey, 8);
    }

    FRS_ASSERT(QKey != QUADZERO);
    //
    // Compute the hash index and calculate the row pointer.
    //
    HvalIndex = Hval % HashTable->NumberEntries;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    QHashAcquireLock(HashTable);

    if (RowEntry->QKey == QKey) {
        if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, RowEntry->Flags)) {

            if (QData != NULL) {
                RowEntry->QData = *QData;
            }
            RowEntry->Flags = Flags;
            DPRINT5(5, "QHash Update (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
                 HashTable, RowEntry, PRINTQUAD(RowEntry->QKey), PRINTQUAD(RowEntry->QData), RowEntry->Flags);
            QHashReleaseLock(HashTable);
            return GHT_STATUS_SUCCESS;
        }
    }

    if (RowEntry->NextEntry.Next == NULL) {
        QHashReleaseLock(HashTable);
        return GHT_STATUS_NOT_FOUND;
    }

    //
    // Scan the collision list.
    //
    ForEachSingleListEntry(&RowEntry->NextEntry, QHASH_ENTRY, NextEntry,
        //
        // The iterator pE is of type PQHASH_ENTRY.
        //
        if (QKey < pE->QKey) {
            //
            // Not on the list.
            //
            QHashReleaseLock(HashTable);
            return GHT_STATUS_NOT_FOUND;
        }
        if (pE->QKey == QKey) {
            if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, pE->Flags)) {
                //
                // Found it.
                //
                if (QData != NULL) {
                    pE->QData = *QData;
                }
                pE->Flags = Flags;

                DPRINT5(5, "QHash Update (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
                     HashTable, pE, PRINTQUAD(pE->QKey), PRINTQUAD(pE->QData), pE->Flags);

                QHashReleaseLock(HashTable);
                return GHT_STATUS_SUCCESS;
            }
        }
    );

    QHashReleaseLock(HashTable);
    return GHT_STATUS_NOT_FOUND;
}



GHT_STATUS
QHashDelete(
    IN PQHASH_TABLE HashTable,
    IN PVOID        ArgQKey
    )
/*++

Routine Description:

Lookup the Key in the hash table and if found remove it and put it on the
free list.

The table lock is acquired and released here.

Arguments:

    HashTable  --  ptr to a PQHASH_TABLE struct.
    ArgQKey  -- ptr to the Key we are looking for.

Return Value:

    GHT_STATUS_NOT_FOUND -- if not found.
    GHT_STATUS_SUCCESS -- if found and deleted.

--*/

{
#undef DEBSUB
#define DEBSUB  "QHashDelete:"

    ULONGLONG QKey;
    ULONG GStatus;
    ULONG Hval, HvalIndex;
    PQHASH_ENTRY RowEntry;
    PQHASH_ENTRY LastFoundpE = NULL;

    if (IS_QHASH_LARGE_KEY(HashTable)) {
        Hval = (HashTable->HashCalc2)(ArgQKey, &QKey);
    } else {
        CopyMemory(&QKey, ArgQKey, 8);
        Hval = (HashTable->HashCalc)(&QKey, 8);
    }

    FRS_ASSERT(QKey != QUADZERO);
    //
    // Compute the hash index and calculate the row pointer.
    //
    HvalIndex = Hval % HashTable->NumberEntries;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    QHashAcquireLock(HashTable);


    if (RowEntry->QKey == QKey) {

        if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, RowEntry->Flags)) {
            DPRINT5(5, "QHash Delete (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
                 HashTable, RowEntry, PRINTQUAD(RowEntry->QKey), PRINTQUAD(RowEntry->QData), RowEntry->Flags);

            if (IS_QHASH_LARGE_KEY(HashTable) && ((PVOID) RowEntry->Flags != NULL)) {
                (HashTable->HashFree)((PVOID) (RowEntry->Flags));
            }

            RowEntry->QKey = QUADZERO;
            RowEntry->Flags = 0;
            QHashReleaseLock(HashTable);
            return GHT_STATUS_SUCCESS;
        }
    }


    if (RowEntry->NextEntry.Next == NULL) {
        QHashReleaseLock(HashTable);
        return GHT_STATUS_NOT_FOUND;
    }

    //
    // Scan the collision list.
    //
    ForEachSingleListEntry(&RowEntry->NextEntry, QHASH_ENTRY, NextEntry,
        //
        // The iterator pE is of type PQHASH_ENTRY.
        //
        if (QKey < pE->QKey) {
            //
            // Not on the list.
            //
            break;
        }
        if (pE->QKey == QKey) {
            if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, pE->Flags)) {
                //
                // Found it. Remove from list and put on free list.
                //
                DPRINT5(5, "QHash Delete (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
                     HashTable, pE, PRINTQUAD(pE->QKey), PRINTQUAD(pE->QData), pE->Flags);

                if (IS_QHASH_LARGE_KEY(HashTable) && ((PVOID) pE->Flags != NULL)) {
                    (HashTable->HashFree)((PVOID) (pE->Flags));
                }
                pE->Flags = 0;
                RemoveSingleListEntry(NOT_USED);
                PushEntryList(&HashTable->FreeList, &pE->NextEntry);

                QHashReleaseLock(HashTable);

                return GHT_STATUS_SUCCESS;
            }
        }
    );

    QHashReleaseLock(HashTable);
    return GHT_STATUS_NOT_FOUND;
}



VOID
QHashDeleteLock(
    IN PQHASH_TABLE HashTable,
    IN PVOID        ArgQKey
    )
/*++

Routine Description:

Delete the entry in the hash table.  Assumes the caller has the lock on the
table and has not dropped the lock since doing the QHashLookupLock() call.

Arguments:

    HashTable  --  ptr to a PQHASH_TABLE struct.
    ArgQKey  -- ptr to the Key we are looking for.

Return Value:

--*/

{
#undef DEBSUB
#define DEBSUB  "QHashDeleteLock:"

    ULONGLONG QKey;
    ULONG Hval, HvalIndex;
    PQHASH_ENTRY RowEntry;

    if (IS_QHASH_LARGE_KEY(HashTable)) {
        Hval = (HashTable->HashCalc2)(ArgQKey, &QKey);
    } else {
        CopyMemory(&QKey, ArgQKey, 8);
        Hval = (HashTable->HashCalc)(&QKey, 8);
    }

    FRS_ASSERT(QKey != QUADZERO);
    //
    // Compute the hash index and calculate the row pointer.
    //
    HvalIndex = Hval % HashTable->NumberEntries;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    if (RowEntry->QKey == QKey) {
        if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, RowEntry->Flags)) {
            DPRINT5(5, "QHash Delete (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
                 HashTable, RowEntry, PRINTQUAD(RowEntry->QKey), PRINTQUAD(RowEntry->QData), RowEntry->Flags);

            if (IS_QHASH_LARGE_KEY(HashTable) && ((PVOID) RowEntry->Flags != NULL)) {
                (HashTable->HashFree)((PVOID) (RowEntry->Flags));
            }

            RowEntry->QKey = QUADZERO;
            RowEntry->Flags = 0;
            return;
        }
    }

    if (RowEntry->NextEntry.Next == NULL) {
        return;
    }

    //
    // Scan the collision list.
    //
    ForEachSingleListEntry(&RowEntry->NextEntry, QHASH_ENTRY, NextEntry,
        //
        // The iterator pE is of type PQHASH_ENTRY.
        // Check for early termination.
        //
        if (QKey < pE->QKey) {
            break;
        }
        if (pE->QKey == QKey) {
            if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, pE->Flags)) {
                //
                // Found it. Remove from list and put on free list.
                //
                DPRINT5(5, "QHash Delete (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
                     HashTable, pE, PRINTQUAD(pE->QKey), PRINTQUAD(pE->QData), pE->Flags);

                if (IS_QHASH_LARGE_KEY(HashTable) && ((PVOID) pE->Flags != NULL)) {
                    (HashTable->HashFree)((PVOID) (pE->Flags));
                }

                pE->Flags = 0;
                RemoveSingleListEntry(NOT_USED);
                PushEntryList(&HashTable->FreeList, &pE->NextEntry);
                return;
            }
        }
    );

    return;
}



#if 0
    ////// Currently Unused //////
VOID
QHashDeleteNodeLock(
    IN PQHASH_TABLE HashTable,
    IN PQHASH_ENTRY BeforeNode,
    IN PQHASH_ENTRY TargetNode
    )
/*++

Routine Description:

Delete the TargetNode entry in the hash table.  This is a singly linked list
so Before Node has to be adjusted.  If BeforeNode is NULL then the TargetNode
is head of the collision chain and is not deleted, instead the key is set to 0.

Assumes the caller has the lock on the table and has not dropped the lock
since getting the Node addresses.

Arguments:

    HashTable  --  ptr to a PQHASH_TABLE struct.
    BeforeNode  -- ptr to the QhashEntry before the node to be deleted.
    TargetNode  -- ptr to the QhashEntry to delete.

Return Value:

    None.

--*/

{
#undef DEBSUB
#define DEBSUB  "QHashDeleteNodeLock:"

    FRS_ASSERT(TargetNode != NULL);

    //
    // Special case for node that is part of the main hash vector.
    //
    if (BeforeNode == NULL) {
        TargetNode->QKey = QUADZERO;
        TargetNode->Flags = 0;
        return;
    }

    //
    // Unlink the target entry and put on the free list.
    //
    BeforeNode->NextEntry.Next = TargetNode->NextEntry.Next;
    TargetNode->NextEntry.Next = NULL;
    TargetNode->Flags = 0;

    PushEntryList(&HashTable->FreeList, &TargetNode->NextEntry);

    return;
}
#endif // 0



VOID
QHashDeleteByFlags(
    IN PQHASH_TABLE HashTable,
    IN ULONG_PTR Flags
    )
/*++

Routine Description:

Delete all entries in the hash table that match the given Flags argument.

The table lock is acquired and released here.

Arguments:

    HashTable  --  ptr to a PQHASH_TABLE struct.
    Flags -- Match key to select elements to delete.

Return Value:

    None.

--*/

{
#undef DEBSUB
#define DEBSUB  "QHashDeleteByFlags:"

    PQHASH_ENTRY RowEntry;
    ULONG i;


    FRS_ASSERT(!IS_QHASH_LARGE_KEY(HashTable));

    RowEntry = HashTable->HashRowBase;

    //
    // Loop through all the Hash table rows and delete each matching element.
    //

    QHashAcquireLock(HashTable);

    for (i=0; i<HashTable->NumberEntries; i++, RowEntry++) {

        if (RowEntry->Flags == Flags) {
            DPRINT5(5, "QHash DeleteByFlags (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
                 HashTable, RowEntry, PRINTQUAD(RowEntry->QKey), PRINTQUAD(RowEntry->QData), RowEntry->Flags);
            RowEntry->QKey = QUADZERO;
            RowEntry->Flags = 0;
        }


        if (RowEntry->NextEntry.Next == NULL) {
            continue;
        }

        //
        // Scan the collision list.
        //
        ForEachSingleListEntry(&RowEntry->NextEntry, QHASH_ENTRY, NextEntry,
            //
            // The iterator pE is of type PQHASH_ENTRY.
            // Check for match. Remove from list and put on free list.
            //
            if (pE->Flags == Flags) {

                DPRINT5(5, "QHash DeleteByFlags (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
                     HashTable, pE, PRINTQUAD(pE->QKey), PRINTQUAD(pE->QData), pE->Flags);

                pE->Flags = 0;
                RemoveSingleListEntry(NOT_USED);
                PushEntryList(&HashTable->FreeList, &pE->NextEntry);
            }
        );
    }

    QHashReleaseLock(HashTable);

    return;
}



VOID
QHashEmptyLargeKeyTable(
    IN PQHASH_TABLE HashTable
    )
/*++

Routine Description:

Delete all the large key nodes in the QHash table.
Put all collision entries on the free list.

The table lock is acquired and released here.

Arguments:

    HashTable  --  ptr to a PQHASH_TABLE struct.

Return Value:

    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "QHashEmptyLargeKeyTable:"

    PQHASH_ENTRY RowEntry;
    ULONG i;

    //
    // No work if not a large key table.
    //
    if (!IS_QHASH_LARGE_KEY(HashTable)) {
        return;
    }

    RowEntry = HashTable->HashRowBase;

    //
    // Loop through all the Hash table rows and delete each matching element.
    //
    QHashAcquireLock(HashTable);

    for (i=0; i<HashTable->NumberEntries; i++, RowEntry++) {

        if ((PVOID)RowEntry->Flags != NULL) {
            (HashTable->HashFree)((PVOID) (RowEntry->Flags));
        }
        RowEntry->QKey = QUADZERO;
        RowEntry->Flags = 0;

        if (RowEntry->NextEntry.Next == NULL) {
            continue;
        }

        //
        // Scan the collision list.
        // Free the large key node and put qhash collision entries on free list.
        //
        ForEachSingleListEntry(&RowEntry->NextEntry, QHASH_ENTRY, NextEntry,
            //
            // The iterator pE is of type PQHASH_ENTRY.
            //
            if ((PVOID)RowEntry->Flags != NULL) {
                (HashTable->HashFree)((PVOID) (pE->Flags));
            }
            pE->Flags = 0;
            RemoveSingleListEntry(NOT_USED);
            PushEntryList(&HashTable->FreeList, &pE->NextEntry);
        );
    }

    QHashReleaseLock(HashTable);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\util\guidname.c ===
/*++
Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    frsguid.c

Abstract:
    These routines temporarily supply guids for replica sets and
    servers.

Author:
    Billy J. Fuller 06-May-1997

Environment
    User mode winnt

--*/
#include <ntreppch.h>
#pragma  hdrstop

#define DEBSUB  "FRSGNAME:"

#include <frs.h>


PVOID
FrsFreeGName(
    IN PVOID    Arg
    )
/*++
Routine Description:
    Free a gname entry in a table

Arguments:
    Arg - entry in table points to this value

Return Value:
    None.
--*/
{
    PGNAME  GName = Arg;

    if (GName) {
        FrsFree(GName->Guid);
        FrsFree(GName->Name);
        FrsFree(GName);
    }
    return NULL;
}

PGNAME
FrsBuildGName(
    IN OPTIONAL GUID     *Guid,
    IN OPTIONAL PWCHAR   Name
    )
/*++
Routine Description:
    Build a GName

Arguments:
    Guid    - address of a binary guid
    Name    - printable name

Return Value:
    Address of a GName that points to Guid and Name.
--*/
{
    PGNAME GName;

    GName = FrsAlloc(sizeof(GNAME));
    GName->Guid = Guid;
    GName->Name = Name;

    return GName;
}

PGVSN
FrsBuildGVsn(
    IN OPTIONAL GUID       *Guid,
    IN          ULONGLONG   Vsn
    )
/*++
Routine Description:
    Build a gusn

Arguments:
    Guid
    Vsn

Return Value:
    Address of a gusn
--*/
{
    PGVSN GVsn;

    GVsn = FrsAlloc(sizeof(GVSN));
    COPY_GUID(&GVsn->Guid, Guid);
    GVsn->Vsn = Vsn;

    return GVsn;
}

PGNAME
FrsDupGName(
    IN PGNAME SrcGName
    )
/*++
Routine Description:
    Duplicate a gstring

Arguments:
    OrigGName

Return Value:
    None.
--*/
{
    PGNAME  GName;

    //
    // nothing to do
    //
    if (!SrcGName)
        return NULL;

    GName = FrsAlloc(sizeof(GNAME));

    //
    // guid
    //
    if (SrcGName->Guid) {
        GName->Guid = FrsAlloc(sizeof(GUID));
        COPY_GUID(GName->Guid, SrcGName->Guid);
    }
    //
    // name
    //
    if (SrcGName->Name)
        GName->Name = FrsWcsDup(SrcGName->Name);
    //
    // done
    //
    return GName;
}

GUID *
FrsDupGuid(
    IN GUID *Guid
    )
/*++
Routine Description:
    Duplicate a guid

Arguments:
    Guid

Return Value:
    None.
--*/
{
    GUID *NewGuid;

    //
    // nothing to do
    //
    if (!Guid)
        return NULL;

    NewGuid = FrsAlloc(sizeof(GUID));
    COPY_GUID(NewGuid, Guid);

    //
    // done
    //
    return NewGuid;
}

PGNAME
FrsCopyGName(
    IN GUID     *Guid,
    IN PWCHAR   Name
    )
/*++
Routine Description:
    Allocate a gname and duplicate the guid and name into it

Arguments:
    Guid
    Name

Return Value:
    None.
--*/
{
    PGNAME GName;

    GName = FrsAlloc(sizeof(GNAME));

    //
    // guid
    //
    if (Guid) {
        GName->Guid = FrsAlloc(sizeof(GUID));
        COPY_GUID(GName->Guid, Guid);
    }
    //
    // name
    //
    if (Name)
        GName->Name = FrsWcsDup(Name);
    //
    // done
    //
    return GName;
}

VOID
FrsPrintGName(
    IN PGNAME GName
    )
/*++
Routine Description:
    Print a gname

Arguments:
    GName

Return Value:
    None.
--*/
{
    CHAR        Guid[GUID_CHAR_LEN + 1];

    //
    // print the GName
    //
    GuidToStr(GName->Guid, &Guid[0]);
    DPRINT2(0, "%ws %s\n", GName->Name, Guid);
}

VOID
FrsPrintGuid(
    IN GUID *Guid
    )
/*++
Routine Description:
    Print a guid

Arguments:
    Guid

Return Value:
    None.
--*/
{
    CHAR PGuid[GUID_CHAR_LEN + 1];
    //
    // print the GName
    //
    GuidToStr(Guid, &PGuid[0]);
    DPRINT1(0, "%s\n", PGuid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\util\queue.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    queue.c

Abstract:

    Generic efficient queue package.

Author:

    John Vert (jvert) 12-Jan-1996

Revision History:

    David Orbits (davidor) 23-Apr-1997
        Added command packet routines.
        Added interlocked list routines.

Introduction
A striped queue is really just a list of queues that are managed as a single
queue.  When a caller request a queue entry, the first entry for the queue at
the head of the list is returned and that queue is moved to the tail of the
list to prevent starvation of the other queues on the list.  Callers sleep when
none of the queues have entries.  The caller must be ready to accept an entry
from any queue.  Striped queues allow a caller to serialize access to a
sub-queue.

Structures
The same structure is used for both the queue and the controlling queue.
A controlling queue plus its component queues are termed a striped queue.
There is no striped queue structure. The struct contains the following:

-   critical section for locking
-   List head for entries
-   Address of the controlling queue
-   List head for Full queues
-   List head for Empty queues
-   List head for Idled queues
-   Count of the number of entries on a queue
-   Count of the number of entries on all controlled queues

Initializing
A non-striped (regular) queue is created with:
    FrsRtlInitializeQueue(Queue, Queue)

A striped queue controlled by ControlQueue and composed of QueueA and QueueB
is created with:
    FrsRtlInitializeQueue(ControlQueue, ControlQueue)
    FrsRtlInitializeQueue(QueueA, ControlQueue)
    FrsRtlInitializeQueue(QueueB, ControlQueue)

Queues can be added and deleted from the stripe at any time.

Idling Queues
The controlling queue for a striped queue maintains a list of Full queues,
Empty queues, and Idled queues. A striped queue allows a caller to serialize
access to a queue by "idling" the queue. No other thread is allowed to pull
an entry from the queue until the caller "UnIdles" the queue:

Entry = FrsRtlRemoveHeadTimeoutIdled(Queue, 0, &IdledQueue)
        Process Entry
    FrsRtlUnIdledQueue(IdledQueue);

Entries can be inserted to an idled queue and they can be removed with
FrsRtlRemoveQueueEntry().

Non-Striped queues do not support the serializing "idling" feature. The
IdledQueue parameter is ignored.

Inserting Entries
Use the normal queue insertion routines for queues, striped queues, and idled
queues. DO NOT insert into the controlling queue if this is a striped queue.

Removing Entries
Use the normal queue removal routines for queues, striped queues, and idled
queues. Removals from a striped queue will return an entry from any of the
sub-queues except for idled sub-queues. The FrsRtlRemoveQueueEntry() function
will remove an entry from even an idled queue.

Functions
DbgCheckLinkage                    - Checks all of the linkage in a queue
FrsRtlInitializeQueue              - Initializes any queue
FrsRtlDeleteQueue                  - Cleans up any queue
FrsRtlRundownQueue                 - Aborts the queue and returns a list of entries
FrsRtlUnIdledQueue                 - Moves a queue from the idle to one of the active lists
FrsRtlRemoveHeadQueue              - Remove the head of the queue
FrsRtlRemoveHeadQueueTimeout       - Remove the head of the queue
FrsRtlRemoveHeadQueueTimeoutIdled  - Remove the head of the queue
FrsRtlRemoveEntryQueueLock         - Remove entry from locked queue
FrsRtlInsertTailQueue              - Insert entry into queue at tail
FrsRtlInsertTailQueueLock          - Insert entry into locked queue at head
FrsRtlInsertHeadQueue              - Insert entry into queue at tail
FrsRtlInsertHeadQueueLock          - Insert entry into locked queue at head
FrsRtlWaitForQueueFull             - wait for an entry to appear on the queue

Rundown
Calling rundown on the controlling queue is NOT supported. Don't do that
Running down a component queue does not rundown the controlling queue.
The abort event is set in the controlling queue when the last component
queue is rundown.

--*/
#include <ntreppch.h>
#pragma  hdrstop

#include <frs.h>

VOID
FrsCompleteSynchronousCmdPkt(
    IN PCOMMAND_PACKET CmdPkt,
    IN PVOID           CompletionArg
    );

//
// This is the command packet schedule queue. It is used when you need to
// queue a command packet to be processed in the future.
//
FRS_QUEUE FrsScheduleQueue;



// #define PRINT_QUEUE(_S_, _Q_)   PrintQueue(_S_, _Q_)
#define PRINT_QUEUE(_S_, _Q_)
VOID
PrintQueue(
    IN ULONG        Sev,
    IN PFRS_QUEUE  Queue
    )
/*++

Routine Description:

    Print the queue

Arguments:

    Sev     - dprint severity
    Queue   - Supplies a pointer to a queue structure to check

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "PrintQueue:"
    DWORD       Count;
    DWORD       ControlCount;
    BOOL        FoundFull;
    BOOL        FoundEmpty;
    BOOL        FoundIdled;
    PLIST_ENTRY Entry;
    PLIST_ENTRY OtherEntry;
    PFRS_QUEUE  OtherQueue;
    PFRS_QUEUE  Control;

    DPRINT1(0, "***** Print Queue %08x *****\n", Queue);

    Control = Queue->Control;
    if (Queue == Control) {
        DPRINT1(Sev, "\tQueue       : %08x\n", Queue);
        DPRINT1(Sev, "\tCount       : %8d\n", Queue->Count);
        DPRINT1(Sev, "\tControlCount: %8d\n", Queue->ControlCount);
        DPRINT1(Sev, "\tRundown     : %s\n", (Queue->IsRunDown) ? "TRUE" : "FALSE");
        DPRINT1(Sev, "\tIdled       : %s\n", (Queue->IsIdled) ? "TRUE" : "FALSE");
        return;
    }
    DPRINT2(Sev, "\tControl     : %08x for %08x\n", Control, Queue);
    DPRINT1(Sev, "\tCount       : %8d\n", Control->Count);
    DPRINT1(Sev, "\tControlCount: %8d\n", Control->ControlCount);
    DPRINT1(Sev, "\tRundown     : %s\n", (Control->IsRunDown) ? "TRUE" : "FALSE");
    DPRINT1(Sev, "\tIdled       : %s\n", (Control->IsIdled) ? "TRUE" : "FALSE");

    //
    // Full list
    //
    DPRINT(Sev, "\tFULL\n");
    for (Entry = GetListNext(&Control->Full);
         Entry != &Control->Full;
         Entry = GetListNext(Entry)) {
        OtherQueue = CONTAINING_RECORD(Entry, FRS_QUEUE, Full);
        if (OtherQueue == Queue) {
            DPRINT(Sev, "\t\tTHIS QUEUE\n");
        }
        DPRINT1(Sev, "\t\tQueue       : %08x\n", OtherQueue);
        DPRINT1(Sev, "\t\tCount       : %8d\n", OtherQueue->Count);
        DPRINT1(Sev, "\t\tControlCount: %8d\n", OtherQueue->ControlCount);
        DPRINT1(Sev, "\t\tRundown     : %s\n", (OtherQueue->IsRunDown) ? "TRUE" : "FALSE");
        DPRINT1(Sev, "\t\tIdled       : %s\n", (OtherQueue->IsIdled) ? "TRUE" : "FALSE");
    }

    //
    // Empty list
    //
    DPRINT(Sev, "\tEMPTY\n");
    for (Entry = GetListNext(&Control->Empty);
         Entry != &Control->Empty;
         Entry = GetListNext(Entry)) {
        OtherQueue = CONTAINING_RECORD(Entry, FRS_QUEUE, Empty);
        if (OtherQueue == Queue) {
            DPRINT(Sev, "\t\tTHIS QUEUE\n");
        }
        DPRINT1(Sev, "\t\tQueue       : %08x\n", OtherQueue);
        DPRINT1(Sev, "\t\tCount       : %8d\n", OtherQueue->Count);
        DPRINT1(Sev, "\t\tControlCount: %8d\n", OtherQueue->ControlCount);
        DPRINT1(Sev, "\t\tRundown     : %s\n", (OtherQueue->IsRunDown) ? "TRUE" : "FALSE");
        DPRINT1(Sev, "\t\tIdled       : %s\n", (OtherQueue->IsIdled) ? "TRUE" : "FALSE");
    }

    //
    // Idle list
    //
    DPRINT(Sev, "\tIDLE\n");
    for (Entry = GetListNext(&Control->Idled);
         Entry != &Control->Idled;
         Entry = GetListNext(Entry)) {
        OtherQueue = CONTAINING_RECORD(Entry, FRS_QUEUE, Idled);
        if (OtherQueue == Queue) {
            DPRINT(Sev, "\t\tTHIS QUEUE\n");
        }
        DPRINT1(Sev, "\t\tQueue       : %08x\n", OtherQueue);
        DPRINT1(Sev, "\t\tCount       : %8d\n", OtherQueue->Count);
        DPRINT1(Sev, "\t\tControlCount: %8d\n", OtherQueue->ControlCount);
        DPRINT1(Sev, "\t\tRundown     : %s\n", (OtherQueue->IsRunDown) ? "TRUE" : "FALSE");
        DPRINT1(Sev, "\t\tIdled       : %s\n", (OtherQueue->IsIdled) ? "TRUE" : "FALSE");
    }
}


BOOL
DbgCheckQueue(
    PFRS_QUEUE  Queue
    )
/*++

Routine Description:

    Check the consistency of the queue

Arguments:

    Queue   - Supplies a pointer to a queue structure to check

Return Value:
    TRUE    - everything is okay
    Assert  - assert error
--*/
{
#undef DEBSUB
#define DEBSUB  "DbgCheckQueue:"
    DWORD       Count;
    DWORD       ControlCount;
    BOOL        FoundFull;
    BOOL        FoundEmpty;
    BOOL        FoundIdled;
    PLIST_ENTRY Entry;
    PLIST_ENTRY OtherEntry;
    PFRS_QUEUE  OtherQueue;
    PFRS_QUEUE  Control;

    if (!DebugInfo.Queues) {
        return TRUE;
    }

    FRS_ASSERT(Queue);
    Control = Queue->Control;
    FRS_ASSERT(Control);

    if (Control->IsRunDown) {
        FRS_ASSERT(Control->ControlCount == 0);
        FRS_ASSERT(Queue->IsRunDown);
        FRS_ASSERT(IsListEmpty(&Control->Full));
        FRS_ASSERT(IsListEmpty(&Control->Empty));
        FRS_ASSERT(IsListEmpty(&Control->Idled));
    }
    if (Queue->IsRunDown) {
        FRS_ASSERT(Queue->Count == 0);
        FRS_ASSERT(IsListEmpty(&Queue->Full));
        FRS_ASSERT(IsListEmpty(&Queue->Empty));
        FRS_ASSERT(IsListEmpty(&Queue->Idled));
    }

    FRS_ASSERT(!Control->IsIdled);

    //
    // Check Full list
    //
    ControlCount = 0;
    FoundFull = FALSE;
    Entry = &Control->Full;
    do {
        Entry = GetListNext(Entry);
        OtherQueue = CONTAINING_RECORD(Entry, FRS_QUEUE, Full);
        if (OtherQueue == Queue) {
            FoundFull = TRUE;
        }
        FRS_ASSERT(Control == OtherQueue ||
               (!OtherQueue->IsRunDown && !OtherQueue->IsIdled));
        Count = 0;
        if (!IsListEmpty(&OtherQueue->ListHead)) {
            OtherEntry = GetListNext(&OtherQueue->ListHead);
            do {
                ++Count;
                ++ControlCount;
                OtherEntry = GetListNext(OtherEntry);
            } while (OtherEntry != &OtherQueue->ListHead);
        }
        FRS_ASSERT(Count == OtherQueue->Count);
    } while (OtherQueue != Control);
    FRS_ASSERT(ControlCount == Control->ControlCount ||
           (Control == Queue && Control->ControlCount == 0));

    //
    // Check Empty list
    //
    ControlCount = 0;
    FoundEmpty = FALSE;
    Entry = &Control->Empty;
    do {
        Entry = GetListNext(Entry);
        OtherQueue = CONTAINING_RECORD(Entry, FRS_QUEUE, Empty);
        if (OtherQueue == Queue) {
            FoundEmpty = TRUE;
        }
        FRS_ASSERT(Control == OtherQueue ||
               (!OtherQueue->IsRunDown && !OtherQueue->IsIdled));
        Count = 0;
        if (!IsListEmpty(&OtherQueue->ListHead)) {
            OtherEntry = GetListNext(&OtherQueue->ListHead);
            do {
                ++Count;
                ++ControlCount;
                OtherEntry = GetListNext(OtherEntry);
            } while (OtherEntry != &OtherQueue->ListHead);
        }
        FRS_ASSERT(Count == OtherQueue->Count);
    } while (OtherQueue != Control);

    //
    // Check Idled list
    //
    FoundIdled = FALSE;
    Entry = &Control->Idled;
    do {
        Entry = GetListNext(Entry);
        OtherQueue = CONTAINING_RECORD(Entry, FRS_QUEUE, Idled);
        if (OtherQueue == Queue) {
            FoundIdled = TRUE;
        }
        FRS_ASSERT(Control == OtherQueue || OtherQueue->IsIdled);
        Count = 0;
        if (!IsListEmpty(&OtherQueue->ListHead)) {
            OtherEntry = GetListNext(&OtherQueue->ListHead);
            do {
                ++Count;
                OtherEntry = GetListNext(OtherEntry);
            } while (OtherEntry != &OtherQueue->ListHead);
        }
        FRS_ASSERT(Count == OtherQueue->Count);
    } while (OtherQueue != Control);

    //
    // Verify state
    //
    FRS_ASSERT((Queue->Count && !IsListEmpty(&Queue->ListHead)) ||
           (!Queue->Count && IsListEmpty(&Queue->ListHead)));
    if (Control == Queue) {
        //
        // We are our own controlling queue
        //
        FRS_ASSERT(FoundFull && FoundEmpty && FoundIdled);
    } else {
        //
        // Controlled by a separate queue
        //
        if (Queue->IsRunDown) {
            FRS_ASSERT(!FoundFull && !FoundEmpty && !FoundIdled && !Queue->Count);
        } else {
            FRS_ASSERT(FoundFull || FoundEmpty || FoundIdled);
        }

        if (FoundFull) {
            FRS_ASSERT(!FoundEmpty && !FoundIdled && Queue->Count);
        } else if (FoundEmpty) {
            FRS_ASSERT(!FoundFull && !FoundIdled && !Queue->Count);
        } else if (FoundIdled) {
            FRS_ASSERT(!FoundFull && !FoundEmpty);
        }
    }

    return TRUE;
}


VOID
FrsInitializeQueue(
    PFRS_QUEUE Queue,
    PFRS_QUEUE Control
    )
/*++

Routine Description:

    Initializes a queue for use.

Arguments:

    Queue - Supplies a pointer to a queue structure to initialize

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
#undef DEBSUB
#define DEBSUB  "FrsInitializeQueue:"

    ZeroMemory(Queue, sizeof(FRS_QUEUE));

    InitializeListHead(&Queue->ListHead);
    InitializeListHead(&Queue->Full);
    InitializeListHead(&Queue->Empty);
    InitializeListHead(&Queue->Idled);

    InitializeCriticalSection(&Queue->Lock);

    Queue->IsRunDown = FALSE;
    Queue->IsIdled = FALSE;
    Queue->Control = Control;
    Queue->InitTime = GetTickCount();

    if (Control->IsRunDown) {
        Queue->IsRunDown = TRUE;
        return;
    }

    //
    // Begin life on the empty queue
    //
    FrsRtlAcquireQueueLock(Queue);

    InsertTailList(&Control->Empty, &Queue->Empty);
    FRS_ASSERT(DbgCheckQueue(Queue));

    FrsRtlReleaseQueueLock(Queue);


    //
    // The controlling queue supplies the events so there is no
    // need to create extraneous events.
    //
    if (Queue == Control) {
        Queue->Event = FrsCreateEvent(TRUE, FALSE);
        Queue->RunDown = FrsCreateEvent(TRUE, FALSE);
    }
}


VOID
FrsRtlDeleteQueue(
    IN PFRS_QUEUE Queue
    )
/*++

Routine Description:

    Releases all resources used by a queue.

Arguments:

    Queue - supplies the queue to be deleted

Return Value:

    None.

--*/

{
#undef DEBSUB
#define DEBSUB  "FrsRtlDeleteQueue:"

    PFRS_QUEUE  Control;

    Control = Queue->Control;

    if (Queue == Control) {
        FRS_ASSERT(IsListEmpty(&Queue->Full)  &&
                   IsListEmpty(&Queue->Empty) &&
                   IsListEmpty(&Queue->Idled));
    } else {
        FRS_ASSERT(IsListEmpty(&Queue->ListHead));
    }

    EnterCriticalSection(&Control->Lock);

    FRS_ASSERT(DbgCheckQueue(Queue));
    RemoveEntryListB(&Queue->Full);
    RemoveEntryListB(&Queue->Empty);
    RemoveEntryListB(&Queue->Idled);
    Control->ControlCount -= Queue->Count;
    FRS_ASSERT(DbgCheckQueue(Queue));

    LeaveCriticalSection(&Control->Lock);

    DeleteCriticalSection(&Queue->Lock);

    //
    // Only the controlling queue has valid handles
    //
    if (Queue == Control) {
        FRS_CLOSE(Queue->Event);
        FRS_CLOSE(Queue->RunDown);
    }

    //
    // Zero the memory in order to cause grief for those who
    // use a deleted queue.
    //
    ZeroMemory(Queue, sizeof(FRS_QUEUE));
}


VOID
FrsRtlRunDownQueue(
    IN PFRS_QUEUE Queue,
    OUT PLIST_ENTRY ListHead
    )
/*++

Routine Description:

    Runs down a queue that is about to be destroyed. Any threads currently
    waiting on the queue are unwaited (FrsRtlRemoveHeadQueue will return NULL)
    and the contents of the queue (if any) are returned to the caller for
    cleanup.

Arguments:

    Queue - supplies the queue to be rundown

    ListHead - returns the list of items currently in the queue.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB  "FrsRtlRunDownQueue:"

    PFRS_QUEUE  Control = Queue->Control;
    PLIST_ENTRY Entry;
    PLIST_ENTRY First;
    PLIST_ENTRY Last;

    EnterCriticalSection(&Control->Lock);

    //
    // Running down a controlling queue is not allowed unless they
    // are the same queue.
    //
    if (Control == Queue) {
        FRS_ASSERT(IsListEmpty(&Control->Full)  &&
                   IsListEmpty(&Control->Empty) &&
                   IsListEmpty(&Control->Idled));
    } else {
        FRS_ASSERT(!IsListEmpty(&Control->Full)  ||
                   !IsListEmpty(&Control->Empty) ||
                   !IsListEmpty(&Control->Idled) ||
                   Control->IsRunDown);
    }

/*
    FRS_ASSERT((Control == Queue &&
                IsListEmpty(&Control->Full) &&
                IsListEmpty(&Control->Empty) &&
                IsListEmpty(&Control->Idled)
               )
               ||
               (Control != Queue &&
                   (!IsListEmpty(&Control->Full) ||
                    !IsListEmpty(&Control->Empty) ||
                    !IsListEmpty(&Control->Idled) ||
                    Control->IsRunDown
                   )
               )
              )
*/

    FRS_ASSERT(DbgCheckQueue(Queue));

    Queue->IsRunDown = TRUE;

    //
    // return the list of entries
    //
    if (IsListEmpty(&Queue->ListHead)) {
        InitializeListHead(ListHead);
    } else {
        *ListHead = Queue->ListHead;
        ListHead->Flink->Blink = ListHead;
        ListHead->Blink->Flink = ListHead;
    }
    InitializeListHead(&Queue->ListHead);
    //
    // Don't update counters if the queue is idled
    //
    if (!Queue->IsIdled) {
        Control->ControlCount -= Queue->Count;
        if (Control->ControlCount == 0) {
            ResetEvent(Control->Event);
        }
    }
    Queue->Count = 0;
    RemoveEntryListB(&Queue->Full);
    RemoveEntryListB(&Queue->Empty);
    RemoveEntryListB(&Queue->Idled);
    FRS_ASSERT(DbgCheckQueue(Queue));

    //
    // Set the aborted event to awaken any threads currently
    // blocked on the queue if the controlling queue has no
    // more queues.
    //
    DPRINT2(4, "Rundown for queue - %08x,  Control - %08x\n", Queue, Control);
    DPRINT1(4, "Control->Full queue %s empty.\n",
            IsListEmpty(&Control->Full) ? "is" : "is not");

    DPRINT1(4, "Control->Empty queue %s empty.\n",
            IsListEmpty(&Control->Empty) ? "is" : "is not");

    DPRINT1(4, "Control->Idled queue %s empty.\n",
            IsListEmpty(&Control->Idled) ? "is" : "is not");


    if (IsListEmpty(&Control->Full)  &&
        IsListEmpty(&Control->Empty) &&
        IsListEmpty(&Control->Idled)) {
        Control->IsRunDown = TRUE;
        SetEvent(Control->RunDown);
        DPRINT(4, "Setting Control->RunDown event.\n");
    }

    FRS_ASSERT(DbgCheckQueue(Control));
    LeaveCriticalSection(&Control->Lock);
}


VOID
FrsRtlCancelQueue(
    IN PFRS_QUEUE   Queue,
    OUT PLIST_ENTRY ListHead
    )
/*++

Routine Description:

    Returns the entries on Queue for cancelling.

Arguments:

    Queue - supplies the queue to be rundown
    ListHead - returns the list of items currently in the queue.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB  "FrsRtlCancelQueue:"

    PFRS_QUEUE  Control = Queue->Control;
    PLIST_ENTRY Entry;
    PLIST_ENTRY First;
    PLIST_ENTRY Last;

    EnterCriticalSection(&Control->Lock);

    FRS_ASSERT(DbgCheckQueue(Queue));
    //
    // return the list of entries
    //
    if (IsListEmpty(&Queue->ListHead)) {
        InitializeListHead(ListHead);
    } else {
        *ListHead = Queue->ListHead;
        ListHead->Flink->Blink = ListHead;
        ListHead->Blink->Flink = ListHead;
    }
    InitializeListHead(&Queue->ListHead);
    //
    // Don't update counters if the queue is idled
    //
    if (!Queue->IsIdled) {
        Control->ControlCount -= Queue->Count;
        if (Control->ControlCount == 0) {
            ResetEvent(Control->Event);
        }
    }
    Queue->Count = 0;

    RemoveEntryListB(&Queue->Full);
    RemoveEntryListB(&Queue->Empty);
    RemoveEntryListB(&Queue->Idled);

    FRS_ASSERT(DbgCheckQueue(Queue));
    FRS_ASSERT(DbgCheckQueue(Control));

    LeaveCriticalSection(&Control->Lock);
}



VOID
FrsRtlIdleQueue(
    IN PFRS_QUEUE Queue
    )
{
#undef DEBSUB
#define DEBSUB  "FrsRtlIdleQueue:"

/*++

Routine Description:

    Idle a queue

Arguments:

    Queue - queue to idle

Return Value:
    None.

--*/

    PFRS_QUEUE  Control = Queue->Control;

    //
    // Queues that don't have a separate controlling queue can't
    // support "idling" themselves
    //
    if (Control == Queue) {
        return;
    }

    //
    // Lock the controlling queue
    //
    EnterCriticalSection(&Control->Lock);

    FrsRtlIdleQueueLock(Queue);

    LeaveCriticalSection(&Control->Lock);
}




VOID
FrsRtlIdleQueueLock(
    IN PFRS_QUEUE Queue
    )
{
#undef DEBSUB
#define DEBSUB  "FrsRtlIdleQueueLock:"

/*++

Routine Description:

    Idle a queue.  Caller has the lock already.

Arguments:

    Queue - queue to idle

Return Value:
    None.

--*/

    PFRS_QUEUE  Control = Queue->Control;

    //
    // Queues that don't have a separate controlling queue can't
    // support "idling" themselves
    //
    if (Control == Queue) {
        return;
    }
    PRINT_QUEUE(5, Queue);

    FRS_ASSERT(DbgCheckQueue(Queue));

    //
    // Stop, this queue has been aborted (rundown)
    //
    if (Queue->IsRunDown || Queue->IsIdled) {
        goto out;
    }

    if (Queue->Count == 0) {
        RemoveEntryListB(&Queue->Empty);
    } else {
        RemoveEntryListB(&Queue->Full);
    }

    FRS_ASSERT(IsListEmpty(&Queue->Idled));

    InsertTailList(&Control->Idled, &Queue->Idled);
    Queue->IsIdled = TRUE;
    Control->ControlCount -= Queue->Count;

    FRS_ASSERT(DbgCheckQueue(Queue));

    if (Control->ControlCount == 0) {
        ResetEvent(Control->Event);
    }
out:
    //
    // Done
    //
    FRS_ASSERT(DbgCheckQueue(Queue));
}




VOID
FrsRtlUnIdledQueue(
    IN PFRS_QUEUE   IdledQueue
    )
{
#undef DEBSUB
#define DEBSUB  "FrsRtlUnIdledQueue:"

/*++

Routine Description:

    Removes the queue from the "idled" list and puts it back on the
    full or empty lists. The controlling queue is updated accordingly.

Arguments:

    IdledQueue - Supplies the queue to remove an item from.

Return Value:
    None.

--*/

    DWORD       OldControlCount;
    PFRS_QUEUE  Control = IdledQueue->Control;

    //
    // Queues that don't have a separate controlling queue can't
    // support "idling" themselves
    //
    if (Control == IdledQueue) {
        return;
    }

    //
    // Lock the controlling queue
    //
    EnterCriticalSection(&Control->Lock);

    FrsRtlUnIdledQueueLock(IdledQueue);

    LeaveCriticalSection(&Control->Lock);
}



VOID
FrsRtlUnIdledQueueLock(
    IN PFRS_QUEUE   IdledQueue
    )
{
#undef DEBSUB
#define DEBSUB  "FrsRtlUnIdledQueueLock:"

/*++

Routine Description:

    Removes the queue from the "idled" list and puts it back on the
    full or empty lists. The controlling queue is updated accordingly.

    Caller has lock on controlling queue.

Arguments:

    IdledQueue - Supplies the queue to remove an item from.

Return Value:
    None.

--*/

    DWORD       OldControlCount;
    PFRS_QUEUE  Control = IdledQueue->Control;

    //
    // Queues that don't have a separate controlling queue can't
    // support "idling" themselves
    //
    if (Control == IdledQueue) {
        return;
    }

    PRINT_QUEUE(5, IdledQueue);

    FRS_ASSERT(DbgCheckQueue(IdledQueue));

    //
    // Stop, this queue has been aborted (rundown)
    //
    if (IdledQueue->IsRunDown) {
        goto out;
    }

    //
    // Remove from idled list
    //
    FRS_ASSERT(IdledQueue->IsIdled);
    RemoveEntryListB(&IdledQueue->Idled);
    IdledQueue->IsIdled = FALSE;

    //
    // Put onto full or empty list
    //
    if (IdledQueue->Count) {
        InsertTailList(&Control->Full, &IdledQueue->Full);
    } else {
        InsertTailList(&Control->Empty, &IdledQueue->Empty);
    }

    //
    // Wakeup sleepers if count is now > 0
    //
    OldControlCount = Control->ControlCount;
    Control->ControlCount += IdledQueue->Count;
    if (Control->ControlCount && OldControlCount == 0) {
        SetEvent(Control->Event);
    }

    //
    // Done
    //
out:
    FRS_ASSERT(DbgCheckQueue(IdledQueue));
}


PLIST_ENTRY
FrsRtlRemoveHeadQueueTimeoutIdled(
    IN PFRS_QUEUE   Queue,
    IN DWORD        dwMilliseconds,
    OUT PFRS_QUEUE  *IdledQueue
    )
/*++

Routine Description:

    Removes the item at the head of the queue. If the queue is empty,
    blocks until an item is inserted into the queue.

Arguments:

    Queue - Supplies the queue to remove an item from.

    Timeout - Supplies a timeout value that specifies the relative
        time, in milliseconds, over which the wait is to be completed.

    IdledQueue - If non-NULL then on return this will be the address
        of the queue from which the entry was retrieved. Or NULL if
        the returned entry is NULL. No other thread will be allowed
        to pull an entry from the returned queue until that queue is
        released with FrsRtlUnIdledQueue(*IdledQueue).

Return Value:

    Pointer to list entry removed from the head of the queue.

    NULL if the wait times out or the queue is run down. If this
        routine returns NULL, GetLastError will return either
        ERROR_INVALID_HANDLE (if the queue has been rundown) or
        WAIT_TIMEOUT (to indicate a timeout has occurred)

    IdledQueue - If non-NULL then on return this will be the address
        of the queue from which the entry was retrieved. Or NULL if
        the returned entry is NULL. No other thread will be allowed
        to pull an entry from the returned queue until that queue is
        released with FrsRtlUnIdledQueue(*IdledQueue).

--*/

{
#undef DEBSUB
#define DEBSUB  "FrsRtlRemoveHeadQueueTimeoutIdled:"

    DWORD       Status;
    PLIST_ENTRY Entry;
    HANDLE      WaitArray[2];
    PFRS_QUEUE  Control = Queue->Control;

    //
    // No idled queue at this time
    //
    if (IdledQueue) {
        *IdledQueue = NULL;
    }

Retry:
    if (Control->ControlCount == 0) {
        //
        // Block until something is inserted on the queue
        //
        WaitArray[0] = Control->RunDown;
        WaitArray[1] = Control->Event;
        Status = WaitForMultipleObjects(2, WaitArray, FALSE, dwMilliseconds);
        if (Status == 0) {
            //
            // The queue has been rundown, return NULL immediately.
            //
            SetLastError(ERROR_INVALID_HANDLE);
            return(NULL);
        } else if (Status == WAIT_TIMEOUT) {
            SetLastError(WAIT_TIMEOUT);
            return(NULL);
        }
        FRS_ASSERT(Status == 1);
    }

    //
    // Lock the queue and try to remove something
    //
    EnterCriticalSection(&Control->Lock);

    PRINT_QUEUE(5, Queue);

    if (Control->ControlCount == 0) {
        //
        // Somebody got here before we did, drop the lock and retry
        //
        LeaveCriticalSection(&Control->Lock);
        goto Retry;
    }
    FRS_ASSERT(DbgCheckQueue(Queue));

    Entry = GetListNext(&Control->Full);
    RemoveEntryListB(Entry);
    Queue = CONTAINING_RECORD(Entry, FRS_QUEUE, Full);
    Entry = RemoveHeadList(&Queue->ListHead);

    //
    // update counters
    //
    --Queue->Count;
    --Control->ControlCount;

    //
    // A separate controlling queue is required for idling
    //
    if (IdledQueue && Queue != Control) {
        //
        // Idle the queue
        //
        FRS_ASSERT(IsListEmpty(&Queue->Idled));
        FRS_ASSERT(!Queue->IsIdled);
        InsertTailList(&Control->Idled, &Queue->Idled);
        Queue->IsIdled = TRUE;
        Control->ControlCount -= Queue->Count;
        *IdledQueue = Queue;
    } else if (Queue->Count) {
        //
        // Queue still has entries
        //
        InsertTailList(&Control->Full, &Queue->Full);
    } else {
        //
        // Queue is empty
        //
        InsertTailList(&Control->Empty, &Queue->Empty);
    }

    //
    // Queues are empty (or idled)
    //
    if (Control->ControlCount == 0) {
        ResetEvent(Control->Event);
    }

    PRINT_QUEUE(5, Queue);
    FRS_ASSERT(DbgCheckQueue(Queue));
    LeaveCriticalSection(&Control->Lock);

    return(Entry);
}


PLIST_ENTRY
FrsRtlRemoveHeadQueue(
    IN PFRS_QUEUE Queue
    )
/*++

Routine Description:

    Removes the item at the head of the queue. If the queue is empty,
    blocks until an item is inserted into the queue.

Arguments:

    Queue - Supplies the queue to remove an item from.

Return Value:

    Pointer to list entry removed from the head of the queue.

--*/

{
    return(FrsRtlRemoveHeadQueueTimeoutIdled(Queue, INFINITE, NULL));
}


PLIST_ENTRY
FrsRtlRemoveHeadQueueTimeout(
    IN PFRS_QUEUE Queue,
    IN DWORD dwMilliseconds
    )
/*++

Routine Description:

    Removes the item at the head of the queue. If the queue is empty,
    blocks until an item is inserted into the queue.

Arguments:

    Queue - Supplies the queue to remove an item from.

    Timeout - Supplies a timeout value that specifies the relative
        time, in milliseconds, over which the wait is to be completed.

Return Value:

    Pointer to list entry removed from the head of the queue.

    NULL if the wait times out or the queue is run down. If this
        routine returns NULL, GetLastError will return either
        ERROR_INVALID_HANDLE (if the queue has been rundown) or
        WAIT_TIMEOUT (to indicate a timeout has occurred)


--*/

{
    return(FrsRtlRemoveHeadQueueTimeoutIdled(Queue, dwMilliseconds, NULL));
}



VOID
FrsRtlRemoveEntryQueue(
    IN PFRS_QUEUE Queue,
    IN PLIST_ENTRY Entry
    )
/*++

Routine Description:

    Removes the entry from the queue. The entry is assumed to be on the
    queue since we derement the queue count.

Arguments:

    Queue - Supplies the queue to remove an item from.

    Entry - pointer to the entry to remove.

Return Value:

    none.

--*/

{
    FrsRtlAcquireQueueLock(Queue);
    FrsRtlRemoveEntryQueueLock(Queue, Entry);
    FrsRtlReleaseQueueLock(Queue);
}


VOID
FrsRtlRemoveEntryQueueLock(
    IN PFRS_QUEUE Queue,
    IN PLIST_ENTRY Entry
    )
/*++

Routine Description:

    Removes the entry from the queue. The entry is assumed to be on the
    queue since we derement the queue count.  We also assume the caller
    has acquired the queue lock since this was needed to scan the queue
    in the first place to find the entry in question.

    The LOCK suffix means the caller has already acquired the lock.

Arguments:

    Queue - Supplies the queue to remove an item from.

    Entry - pointer to the entry to remove.

Return Value:

    none.

--*/

{
#undef DEBSUB
#define DEBSUB  "FrsRtlRemoveEntryQueueLock:"

    PFRS_QUEUE  Control = Queue->Control;

    FRS_ASSERT(Queue->Count != 0);
    FRS_ASSERT(!IsListEmpty(&Queue->ListHead));

    PRINT_QUEUE(5, Queue);

    FRS_ASSERT(DbgCheckQueue(Queue));

    RemoveEntryListB(Entry);

    //
    // If the queue is idled then just update the count
    //
    --Queue->Count;
    if (!Queue->IsIdled) {
        //
        // Queue is empty; remove from full list
        //
        if (Queue->Count == 0) {
            RemoveEntryListB(&Queue->Full);
            InsertTailList(&Control->Empty, &Queue->Empty);
        }
        //
        // Control queue is empty
        //
        if (--Control->ControlCount == 0) {
            ResetEvent(Control->Event);
        }
    }

    PRINT_QUEUE(5, Queue);
    FRS_ASSERT(DbgCheckQueue(Queue));

    return;
}


DWORD
FrsRtlInsertTailQueue(
    IN PFRS_QUEUE Queue,
    IN PLIST_ENTRY Item
    )
/*++
Routine Description:
    Inserts a new entry on the tail of the queue.

Arguments:
    Queue - Supplies the queue to add the entry to.
    Item - Supplies the entry to be added to the queue.

Return Value:
    ERROR_SUCCESS and the item is queueed. Otherwise, the item
    is not queued.
--*/
{
    DWORD   Status;

    FrsRtlAcquireQueueLock(Queue);
    Status = FrsRtlInsertTailQueueLock(Queue, Item);
    FrsRtlReleaseQueueLock(Queue);
    return Status;
}

DWORD
FrsRtlInsertTailQueueLock(
    IN PFRS_QUEUE Queue,
    IN PLIST_ENTRY Item
    )
/*++
Routine Description:
    Inserts a new entry on the tail of the queue.  Caller already has the
    queue lock.

Arguments:
    Queue - Supplies the queue to add the entry to.
    Item - Supplies the entry to be added to the queue.

Return Value:
    ERROR_SUCCESS and the item is queueed. Otherwise, the item
    is not queued.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsRtlInsertTailQueueLock:"

    PFRS_QUEUE  Control = Queue->Control;

    PRINT_QUEUE(5, Queue);
    FRS_ASSERT(DbgCheckQueue(Queue));
    if (Queue->IsRunDown) {
        return ERROR_ACCESS_DENIED;
    }
    InsertTailList(&Queue->ListHead, Item);

    //
    // If the queue is idled then just update the count
    //
    if (Queue->IsIdled) {
        ++Queue->Count;
    } else {
        //
        // Queue is transitioning from empty to full
        //
        if (++Queue->Count == 1) {
            RemoveEntryListB(&Queue->Empty);
            InsertTailList(&Control->Full, &Queue->Full);
        }
        //
        // Controlling queue is transitioning from empty to full
        //
        if (++Control->ControlCount == 1) {
            SetEvent(Control->Event);
        }
    }
    PRINT_QUEUE(5, Queue);
    FRS_ASSERT(DbgCheckQueue(Queue));
    return ERROR_SUCCESS;
}


DWORD
FrsRtlInsertHeadQueue(
    IN PFRS_QUEUE Queue,
    IN PLIST_ENTRY Item
    )
/*++
Routine Description:
    Inserts a new entry on the tail of the queue.

Arguments:
    Queue - Supplies the queue to add the entry to.
    Item - Supplies the entry to be added to the queue.

Return Value:
    ERROR_SUCCESS and the item is queueed. Otherwise, the item
    is not queued.
--*/
{
    DWORD   Status;

    FrsRtlAcquireQueueLock(Queue);
    Status = FrsRtlInsertHeadQueueLock(Queue, Item);
    FrsRtlReleaseQueueLock(Queue);
    return Status;
}


DWORD
FrsRtlInsertHeadQueueLock(
    IN PFRS_QUEUE Queue,
    IN PLIST_ENTRY Item
    )
/*++
Routine Description:
    Inserts a new entry on the head of the queue.
    Caller already has the queue lock.

Arguments:
    Queue - Supplies the queue to add the entry to.
    Item - Supplies the entry to be added to the queue.

Return Value:
    ERROR_SUCCESS and the item is queueed. Otherwise, the item
    is not queued.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsRtlInsertHeadQueueLock:"

    PFRS_QUEUE  Control = Queue->Control;

    PRINT_QUEUE(5, Queue);
    FRS_ASSERT(DbgCheckQueue(Queue));
    if (Queue->IsRunDown) {
        return ERROR_ACCESS_DENIED;
    }
    InsertHeadList(&Queue->ListHead, Item);

    //
    // If the queue is idled then just update the count
    //
    if (Queue->IsIdled) {
        ++Queue->Count;
    } else {
        //
        // Queue is transitioning from empty to full
        //
        if (++Queue->Count == 1) {
            RemoveEntryListB(&Queue->Empty);
            InsertTailList(&Control->Full, &Queue->Full);
        }
        //
        // Controlling queue is transitioning from empty to full
        //
        if (++Control->ControlCount == 1) {
            SetEvent(Control->Event);
        }
    }
    PRINT_QUEUE(5, Queue);
    FRS_ASSERT(DbgCheckQueue(Queue));
    return ERROR_SUCCESS;
}


DWORD
FrsRtlWaitForQueueFull(
    IN PFRS_QUEUE Queue,
    IN DWORD dwMilliseconds
    )
/*++
Routine Description:
    Waits until the queue is non-empty.  Returns immediately if queue is
    non-empty else wait on insert or timeout.

Arguments:
    Queue - Supplies the queue to wait on.
    Timeout - Supplies a timeout value that specifies the relative
        time, in milliseconds, over which the wait is to be completed.

Return Value:
    Win32 Status:
        ERROR_SUCCESS if queue is now non-empty.
        ERROR_INVALID_HANDLE if the queue has been rundown.
        WAIT_TIMEOUT to indicate a timeout has occurred.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsRtlWaitForQueueFull:"

    DWORD Status;
    HANDLE WaitArray[2];
    PFRS_QUEUE Control = Queue->Control;

Retry:
    if (Control->ControlCount == 0) {
        //
        // Block until something is inserted on the queue
        //
        WaitArray[0] = Control->RunDown;
        WaitArray[1] = Control->Event;
        Status = WaitForMultipleObjects(2, WaitArray, FALSE, dwMilliseconds);

        if (Status == 0) {
            //
            // The queue has been rundown, return immediately.
            //
            return(ERROR_INVALID_HANDLE);
        }

        if (Status == WAIT_TIMEOUT) {
            return(WAIT_TIMEOUT);
        }

        FRS_ASSERT(Status == 1);
    }

    //
    // Lock the queue and check again.
    //
    EnterCriticalSection(&Control->Lock);
    if (Control->ControlCount == 0) {
        //
        // Somebody got here before we did, drop the lock and retry
        //
        LeaveCriticalSection(&Control->Lock);
        goto Retry;
    }

    LeaveCriticalSection(&Control->Lock);

    return(ERROR_SUCCESS);
}


VOID
FrsSubmitCommand(
    IN PCOMMAND_PACKET  CmdPkt,
    IN BOOL             Headwise
    )
/*++
Routine Description:
    Insert the command packet on the command's target queue.
    If the time delay parameter is non-zero the command is instead
    queued to the scheduler thread to initiate at the specified time.
    FrsCompleteCommand(Status) is called if the packet could not be
    queued.

Arguments:
    CmdPkt
    Headwise    - Queue at the head (high priority)

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsSubmitCommand:"

    DWORD           WStatus;

    //
    // Queue to the target
    //
    if (Headwise) {
        WStatus = FrsRtlInsertHeadQueue(CmdPkt->TargetQueue, &CmdPkt->ListEntry);
    } else {
        WStatus = FrsRtlInsertTailQueue(CmdPkt->TargetQueue, &CmdPkt->ListEntry);
    }

    if (!WIN_SUCCESS(WStatus)) {
        FrsCompleteCommand(CmdPkt, WStatus);
    }
}


ULONG
FrsSubmitCommandAndWait(
    IN PCOMMAND_PACKET  Cmd,
    IN BOOL             Headwise,
    IN ULONG            Timeout
    )
/*++
Routine Description:
    Create or Reset the event, Submit the command and wait for the return.

Arguments:
    Cmd - command packet to queue
    Timeout - Wait Timeout
    Headwise - if True, insert to head.

Return Value:
    Win32 status
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsSubmitCommandAndWait:"

    DWORD WStatus;

    //
    // Set the synchronous flag in the command packet.
    //
    FrsSetCommandSynchronous(Cmd);

    if (!HANDLE_IS_VALID(Cmd->WaitEvent)){
        Cmd->WaitEvent = FrsCreateEvent(TRUE, FALSE);
    } else {
        ResetEvent(Cmd->WaitEvent);
    }

    //
    // Save the callers completion routine and replace it with a function
    // that signals the event.  It does not delete the packet so we can
    // return the command status to the caller.
    //
    Cmd->SavedCompletionRoutine = Cmd->CompletionRoutine;
    Cmd->CompletionRoutine = FrsCompleteSynchronousCmdPkt;

    //
    // Queue the command and create a thread if needed.
    //
    FrsSubmitCommand(Cmd, Headwise);

    //
    // Wait for the command to complete.
    //
    WStatus = WaitForSingleObject(Cmd->WaitEvent, Timeout);

    CHECK_WAIT_ERRORS(3, WStatus, 1, ACTION_RETURN);

    //
    // Return the command error status.
    //
    WStatus = Cmd->ErrorStatus;

    //
    // Restore and call the caller's completion routine.  This may free the
    // the packet.  We don't call FrsCompleteCommand() here because it was
    // already called when the server finished the packet and there is no
    // point in setting the wait event twice.
    //
    Cmd->CompletionRoutine = Cmd->SavedCompletionRoutine;

    FRS_ASSERT(Cmd->CompletionRoutine != NULL);

    (Cmd->CompletionRoutine)(Cmd, Cmd->CompletionArg);

    return WStatus;

}


#define HEADWISE    TRUE
VOID
FrsUnSubmitCommand(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Put the entry back on the head of the queue.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
    FrsSubmitCommand(Cmd, HEADWISE);
}


VOID
FrsCompleteCommand(
    IN PCOMMAND_PACKET CmdPkt,
    IN DWORD           ErrorStatus
    )
/*++
Routine Description:
     Retire the command packet based on what the original requestor specified
     in the packet.  The ErrorStatus is returned in the packet.

     The completion routine is called for clean up and propagation.

Arguments:
    CmdPkt  -- A ptr to the command packet.
    ErrorStatus -- Status to store in returned command packet.

Return Value:
    None.
--*/
{
    //
    // Set the error status and call the completion routine
    //
    CmdPkt->ErrorStatus = ErrorStatus;

    FRS_ASSERT(CmdPkt->CompletionRoutine != NULL);

    (CmdPkt->CompletionRoutine)(CmdPkt, CmdPkt->CompletionArg);
}


VOID
FrsInitializeCommandServer(
    IN PCOMMAND_SERVER  Cs,
    IN DWORD            MaxThreads,
    IN PWCHAR           Name,
    IN DWORD            (*Main)(PVOID)
    )
/*++
Routine Description:
    Initialize a command server

Arguments:
    Cs          - command server
    MaxThreads  - Max # of threads to kick off
    Name        - Printable name for thread
    Main        - Thread starts here

Return Value:
    None.
--*/
{
    ZeroMemory(Cs, sizeof(COMMAND_SERVER));
    FrsInitializeQueue(&Cs->Control, &Cs->Control);
    FrsInitializeQueue(&Cs->Queue, &Cs->Control);
    Cs->Main = Main;
    Cs->Name = Name;
    Cs->MaxThreads = MaxThreads;
    Cs->Idle = FrsCreateEvent(TRUE, TRUE);
}


VOID
FrsDeleteCommandServer(
    IN PCOMMAND_SERVER  Cs
    )
/*++
Routine Description:
    Undo the work of FrsInitializeCommandServer(). This function
    assumes the queue and its control queue are inactive (whatever
    that means). Queues and command servers are normally only
    deleted at the very end of MainFrsShutDown() when all other threads
    have exited and the RPC servers aren't listening for new requests.

    The caller is responsible for handling all of the other queues
    that may be being controlled by the control queue in the command
    server struct, Cs.

Arguments:
    Cs          - command server

Return Value:
    None.
--*/
{
    if (Cs) {
        FrsRtlDeleteQueue(&Cs->Queue);
        FrsRtlDeleteQueue(&Cs->Control);
        ZeroMemory(Cs, sizeof(COMMAND_SERVER));
    }
}


PCOMMAND_PACKET
FrsAllocCommand(
    IN PFRS_QUEUE   TargetQueue,
    IN USHORT       Command
    )
/*++
Routine Description:
     Allocate a command packet and initialize the most common fields.

Arguments:
    TargetQueue
    Command

Return Value:
    Address of allocated, initialized COMMAND_PACKET. Call
    FrsCompleteCommand() when done.

--*/
{
    PCOMMAND_PACKET Cmd;

    Cmd = FrsAllocType(COMMAND_PACKET_TYPE);
    Cmd->TargetQueue = TargetQueue;
    FrsSetCompletionRoutine(Cmd, FrsFreeCommand, NULL);
    Cmd->Command = Command;

    return Cmd;
}


PCOMMAND_PACKET
FrsAllocCommandEx(
    IN PFRS_QUEUE   TargetQueue,
    IN USHORT       Command,
    IN ULONG        Size
    )
/*++
Routine Description:
     Allocate a command packet with some extra space
     and initialize the most common fields.

Arguments:
    TargetQueue
    Command

Return Value:
    Address of allocated, initialized COMMAND_PACKET. Call
    FrsCompleteCommand() when done.

--*/
{
    PCOMMAND_PACKET Cmd;

    Cmd = FrsAllocTypeSize(COMMAND_PACKET_TYPE, Size);
    Cmd->TargetQueue = TargetQueue;
    Cmd->CompletionRoutine = FrsFreeCommand;
    Cmd->Command = Command;



    return Cmd;
}


VOID
FrsFreeCommand(
    IN PCOMMAND_PACKET  Cmd,
    IN PVOID            CompletionArg
    )
/*++
Routine Description:
     Free a command packet

Arguments:
    Cmd - command packet allocated with FrsAllocCommand().

Return Value:
    NULL
--*/
{
    ULONG                   WStatus;

    if (((Cmd->Flags & CMD_PKT_FLAGS_SYNC) != 0) &&
         (HANDLE_IS_VALID(Cmd->WaitEvent))){

        //
        // Close the event handle.  The command complete function should have
        // already set the event.
        //
        if (!CloseHandle(Cmd->WaitEvent)) {
            WStatus = GetLastError();
            DPRINT_WS(0, "ERROR: Close event handle failed", WStatus);
            // Don't free the packet if the close handle failed.
            return;
        }
        Cmd->WaitEvent = NULL;
    }

    FrsFreeType(Cmd);
}


VOID
FrsExitCommandServer(
    IN PCOMMAND_SERVER  Cs,
    IN PFRS_THREAD      FrsThread
    )
/*++
Routine Description:
    Exit the calling command server thread.

Arguments:
    Cs      - command server
    Thread  - calling thread

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsExitCommandServer:"

    PFRS_QUEUE  Queue = &Cs->Queue;

    //
    // If there is work to be done
    //
    FrsRtlAcquireQueueLock(Queue);
    --Cs->FrsThreads;
    if (FrsRtlCountQueue(Queue) && Cs->Waiters == 0 && Cs->FrsThreads == 0) {
        //
        // and no one to do it; don't exit
        //
        ++Cs->FrsThreads;
        FrsRtlReleaseQueueLock(Queue);
        return;
    }
    //
    // Set the idle event if all threads are waiting, there are no entries
    // on the queue, and there are no idled queues
    //
    if (Cs->Waiters == Cs->FrsThreads) {
        if (FrsRtlCountQueue(&Cs->Queue) == 0) {
            if (FrsRtlNoIdledQueues(&Cs->Queue)) {
                SetEvent(Cs->Idle);
            }
        }
    }
    FrsRtlReleaseQueueLock(Queue);
    //
    // The thread command server (ThQs) will "wait" on this thread's exit
    // and drop the reference on its thread struct.
    //
    ThSupSubmitThreadExitCleanup(FrsThread);

    //
    // Exit
    //
    ExitThread(ERROR_SUCCESS);
}


#define TAILWISE    FALSE
VOID
FrsSubmitCommandServer(
    IN PCOMMAND_SERVER  Cs,
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    If needed, create a thread for the command queue

Arguments:
    Cs  - command server

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsSubmitCommandServer:"
    //
    // Enqueue the command and make sure there are threads running
    //
    FRS_ASSERT(Cmd && Cmd->TargetQueue && Cs &&
               Cmd->TargetQueue->Control == &Cs->Control);
    FrsSubmitCommand(Cmd, TAILWISE);
    FrsKickCommandServer(Cs);
}


ULONG
FrsSubmitCommandServerAndWait(
    IN PCOMMAND_SERVER  Cs,
    IN PCOMMAND_PACKET  Cmd,
    IN ULONG            Timeout
    )
/*++
Routine Description:
    Create or Reset the event, Submit the command and wait for the return.
    If needed, create a thread for the command queue.

Arguments:
    Cs  - command server
    Cmd - command packet to queue
    Timeout - Wait Timeout

Return Value:
    Win32 status
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsSubmitCommandServerAndWait:"
    DWORD WStatus;

    //
    // Enqueue the command and make sure there are threads running
    //
    FRS_ASSERT(Cmd && Cmd->TargetQueue && Cs &&
               Cmd->TargetQueue->Control == &Cs->Control);

    //
    // Set the synchronous flag in the command packet.
    //
    FrsSetCommandSynchronous(Cmd);

    if (!HANDLE_IS_VALID(Cmd->WaitEvent)){
        Cmd->WaitEvent = FrsCreateEvent(TRUE, FALSE);
    } else {
        ResetEvent(Cmd->WaitEvent);
    }

    //
    // Save the callers completion routine and replace it with a function
    // that signals the event.  It does not delete the packet so we can
    // return the command status to the caller.
    //
    Cmd->SavedCompletionRoutine = Cmd->CompletionRoutine;
    Cmd->CompletionRoutine = FrsCompleteSynchronousCmdPkt;

    //
    // Queue the command and create a thread if needed.
    //
    FrsSubmitCommand(Cmd, TAILWISE);
    FrsKickCommandServer(Cs);

    //
    // Wait for the command to complete.
    //
    WStatus = WaitForSingleObject(Cmd->WaitEvent, Timeout);

    CHECK_WAIT_ERRORS(3, WStatus, 1, ACTION_RETURN);

    //
    // Return the command error status.
    //
    WStatus = Cmd->ErrorStatus;

    //
    // Restore and call the caller's completion routine.  This may free the
    // the packet.  We don't call FrsCompleteCommand() here because it was
    // already called when the server finished the packet and there is no
    // point in setting the wait event twice.
    //
    Cmd->CompletionRoutine = Cmd->SavedCompletionRoutine;

    FRS_ASSERT(Cmd->CompletionRoutine != NULL);

    (Cmd->CompletionRoutine)(Cmd, Cmd->CompletionArg);

    return WStatus;

}



#define THREAD_CREATE_RETRY (10 * 1000) // 10 seconds
VOID
FrsKickCommandServer(
    IN PCOMMAND_SERVER  Cs
    )
/*++
Routine Description:
    If needed, create a thread for the command queue

Arguments:
    Cs  - command server

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsKickCommandServer:"

    PFRS_QUEUE  Queue   = &Cs->Queue;

    //
    // Kick off more threads if no one is waiting for this command
    // and the number of threads serving this command queue is less
    // than the maximum.
    //
    // If the thread cannot be created and there are no threads
    // processing the command queue then put this command on the
    // delayed queue and try again later
    //
    FrsRtlAcquireQueueLock(Queue);
    //
    // There are entries on the queue
    //
    if (FrsRtlCountQueue(Queue)) {
        //
        // But there are no threads to process the entries
        //
        if (Cs->Waiters == 0 && Cs->FrsThreads < Cs->MaxThreads) {
            //
            // First thread; reset idle
            //
            if (Cs->FrsThreads == 0) {
                ResetEvent(Cs->Idle);
            }
            if (ThSupCreateThread(Cs->Name, Cs, Cs->Main, ThSupExitThreadNOP)) {
                //
                // Created a new thread
                //
                ++Cs->FrsThreads;
            } else if (Cs->FrsThreads == 0) {
                //
                // Thread could not be created and there are no other
                // threads to process this entry. Put it on the delayed
                // queue and try again in a few seconds.
                //
                FrsDelCsSubmitKick(Cs, &Cs->Queue, THREAD_CREATE_RETRY);
            }
        }
    }
    FrsRtlReleaseQueueLock(Queue);
}


PCOMMAND_PACKET
FrsGetCommandIdled(
    IN PFRS_QUEUE   Queue,
    IN DWORD        MilliSeconds,
    IN PFRS_QUEUE   *IdledQueue
    )
/*++
Routine Description:
    Get the next command from the queue; idling the queue if requested.

Arguments:
    Queue
    MilliSeconds
    IdledQueue

Return Value:
    COMMAND_PACKET or NULL.
    If non-NULL, IdledQueue is set
--*/
{
    PLIST_ENTRY Entry;

    Entry = FrsRtlRemoveHeadQueueTimeoutIdled(Queue, MilliSeconds, IdledQueue);
    if (Entry == NULL) {
        return NULL;
    }
    //
    // Return the command packet
    //
    return CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
}


PCOMMAND_PACKET
FrsGetCommand(
    IN PFRS_QUEUE   Queue,
    IN DWORD        MilliSeconds
    )
/*++
Routine Description:
    Get the next command from the queue.

Arguments:
    Queue
    MilliSeconds

Return Value:
    COMMAND_PACKET or NULL.
--*/
{
    return FrsGetCommandIdled(Queue, MilliSeconds, NULL);
}


PCOMMAND_PACKET
FrsGetCommandServerTimeoutIdled(
    IN  PCOMMAND_SERVER  Cs,
    IN  ULONG            Timeout,
    OUT PFRS_QUEUE       *IdledQueue,
    OUT PBOOL            IsRunDown
    )
/*++
Routine Description:
    Get the next command from the queue for the command server.
    If nothing appears on the queue in the specified time, then
    return NULL and set IsRunDown.

Arguments:
    Cs          - command server
    Timeout
    IdledQueue  - Idled queue
    IsRunDown

Return Value:
    COMMAND_PACKET or NULL. If NULL, IsRunDown indicates whether
    the NULL was caused by a rundown queue or a simple timeout.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsGetCommandServerTimeoutIdled:"

    PCOMMAND_PACKET Cmd;

    //
    // Pull off the next entry (wait at most 5 minutes)
    //
    FrsRtlAcquireQueueLock(&Cs->Queue);
    ++Cs->Waiters;
    //
    // Set the idle event if all threads are waiting, there are no entries
    // on the queue, and there are no idled queues
    //
    if (Cs->Waiters == Cs->FrsThreads) {
        if (FrsRtlCountQueue(&Cs->Queue) == 0) {
            if (FrsRtlNoIdledQueues(&Cs->Queue)) {
                SetEvent(Cs->Idle);
            }
        }
    }
    FrsRtlReleaseQueueLock(&Cs->Queue);
    //
    // Get the next command
    //
    Cmd = FrsGetCommandIdled(&Cs->Control, Timeout, IdledQueue);

    FrsRtlAcquireQueueLock(&Cs->Queue);
    //
    // Reset the Idle event if there is any chance it might have been set
    //
    if (Cs->Waiters == Cs->FrsThreads) {
        ResetEvent(Cs->Idle);
    }
    --Cs->Waiters;
    if (IsRunDown) {
        *IsRunDown = Cs->Queue.IsRunDown;
    }
    FrsRtlReleaseQueueLock(&Cs->Queue);
    return Cmd;
}


#define COMMAND_SERVER_TIMEOUT  (5 * 60 * 1000) // 5 minutes
DWORD   FrsCommandServerTimeout = COMMAND_SERVER_TIMEOUT;

PCOMMAND_PACKET
FrsGetCommandServerIdled(
    IN PCOMMAND_SERVER  Cs,
    IN PFRS_QUEUE       *IdledQueue
    )
/*++
Routine Description:
    Get the next command from the queue. If nothing appears on the queue
    for 5 minutes, return NULL. The caller will exit. Idle the queue.

Arguments:
    Cs          - command server
    IdledQueue  - Idled queue

Return Value:
    COMMAND_PACKET or NULL. Caller should exit on NULL.
    If non-NULL, IdledQueue is set
--*/
{
    return FrsGetCommandServerTimeoutIdled(Cs,
                                           FrsCommandServerTimeout,
                                           IdledQueue,
                                           NULL);
}


PCOMMAND_PACKET
FrsGetCommandServerTimeout(
    IN  PCOMMAND_SERVER  Cs,
    IN  ULONG            Timeout,
    OUT PBOOL            IsRunDown
    )
/*++
Routine Description:
    Get the next command from the queue. If nothing appears on the queue
    in the specified timeout, return NULL and an indication of the
    queue's rundown status.

Arguments:
    Cs          - command server
    Timeout
    IsRunDown

Return Value:
    COMMAND_PACKET or NULL. IsRunDown is only valid if COMMAND_PACKET
    is NULL. Use IsRunDown to check if the NULL return is because of
    a rundown'ed queue or simply a timeout.
--*/
{
    return FrsGetCommandServerTimeoutIdled(Cs, Timeout, NULL, IsRunDown);
}


DWORD
FrsWaitForCommandServer(
    IN PCOMMAND_SERVER  Cs,
    IN DWORD            MilliSeconds
    )
/*++
Routine Description:
    Wait until all of the threads are idle, there are no entries on the
    queue, and there are no idled queues.

Arguments:
    Cs              - command server
    MilliSeconds    - Timeout

Return Value:
    Status from WaitForSingleObject()
--*/
{
    return WaitForSingleObject(Cs->Idle, MilliSeconds);
}


PCOMMAND_PACKET
FrsGetCommandServer(
    IN PCOMMAND_SERVER  Cs
    )
/*++
Routine Description:
    Get the next command from the queue. If nothing appears on the queue
    for 5 minutes, return NULL. The caller will exit.

Arguments:
    Cs  - command server

Return Value:
    COMMAND_PACKET or NULL. Caller should exit on NULL.
--*/
{
    //
    // Pull off the next entry (wait at most 5 minutes)
    //
    return FrsGetCommandServerIdled(Cs, NULL);
}


VOID
FrsRunDownCommand(
    IN PFRS_QUEUE Queue
    )
/*++
Routine Description:
    Rundown a queue of command packets

Arguments:
    Queue   - queue to rundown

Return Value:
    None.
--*/
{
    LIST_ENTRY      RunDown;
    PLIST_ENTRY     Entry;
    PCOMMAND_PACKET Cmd;

    if (!Queue) {
        return;
    }

    //
    // RunDown the queue and retrieve the current entries
    //
    FrsRtlRunDownQueue(Queue, &RunDown);

    //
    // Free up the commands
    //
    while (!IsListEmpty(&RunDown)) {
        Entry = RemoveHeadList(&RunDown);
        Cmd = CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
        FrsCompleteCommand(Cmd, ERROR_ACCESS_DENIED);
    }
}


VOID
FrsRunDownCommandServer(
    IN PCOMMAND_SERVER  Cs,
    IN PFRS_QUEUE       Queue
    )
/*++
Routine Description:
    Rundown a queue of a command server

Arguments:
    Cs      - command server
    Queue   - queue to abort

Return Value:
    None.
--*/
{
    FrsRunDownCommand(Queue);
}


VOID
FrsCancelCommandServer(
    IN PCOMMAND_SERVER  Cs,
    IN PFRS_QUEUE       Queue
    )
/*++
Routine Description:
    Cancels the current commands on Queue.

Arguments:
    Cs      - command server
    Queue   - queue to abort

Return Value:
    None.
--*/
{
    LIST_ENTRY      Cancel;
    PLIST_ENTRY     Entry;
    PCOMMAND_PACKET Cmd;

    //
    // RunDown the queue and retrieve the current entries
    //
    FrsRtlCancelQueue(Queue, &Cancel);

    //
    // Free up the commands
    //
    while (!IsListEmpty(&Cancel)) {
        Entry = RemoveHeadList(&Cancel);
        Cmd = CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
        FrsCompleteCommand(Cmd, ERROR_CANCELLED);
    }
}



VOID
FrsCompleteRequestCount(
    IN PCOMMAND_PACKET CmdPkt,
    IN PFRS_REQUEST_COUNT RequestCount
    )
/*++

Routine Description:

     This is an Frs Command packet completion routine that takes
     an FRS_REQUEST_COUNT struct.  It decrements the count and signals
     the event when the count goes to zero. The ErrorStatus is
     merged into the Status field of the request count struct.

     It then frees the command packet.

Arguments:

    CmdPkt  -- A ptr to the command packet.
    RequestCount - Supplies a pointer to a RequestCount structure to initialize

Return Value:

    None.
--*/
{
    //
    // Decrement count and signal waiter.  merge error status from packet
    // into RequestCount->Status.
    //
    FrsDecrementRequestCount(RequestCount, CmdPkt->ErrorStatus);
    FrsSetCompletionRoutine(CmdPkt, FrsFreeCommand, NULL);
    FrsCompleteCommand(CmdPkt, CmdPkt->ErrorStatus);
}



VOID
FrsCompleteRequestCountKeepPkt(
    IN PCOMMAND_PACKET CmdPkt,
    IN PFRS_REQUEST_COUNT RequestCount
    )
/*++

Routine Description:

     This is an Frs Command packet completion routine that takes
     an FRS_REQUEST_COUNT struct.  It decrements the count and signals
     the event when the count goes to zero. The ErrorStatus is
     merged into the Status field of the request count struct.

     It does not free the command packet so the caller can retreive results
     or reuse it.

Arguments:

    CmdPkt  -- A ptr to the command packet.
    RequestCount - Supplies a pointer to a RequestCount structure to initialize

Return Value:

    None.
--*/
{
    // Decrement count and signal waiter.  merge error status from packet
    // into RequestCount->Status.
    //
    FrsDecrementRequestCount(RequestCount, CmdPkt->ErrorStatus);
}


VOID
FrsCompleteKeepPkt(
    IN PCOMMAND_PACKET CmdPkt,
    IN PVOID           CompletionArg
    )
/*++

Routine Description:

     This is an Frs Command packet completion routine that
     leaves the CmdPkt alone so the caller can reuse it.

Arguments:

    CmdPkt  -- A ptr to the command packet.
    CompletionArg - Unused.

Return Value:

    None.
--*/
{
    return;
}


VOID
FrsCompleteSynchronousCmdPkt(
    IN PCOMMAND_PACKET CmdPkt,
    IN PVOID           CompletionArg
    )
/*++

Routine Description:

     This is an Frs Command packet completion routine that
     Signals the Wait Event for a synchronous cmd request.
     It leaves the CmdPkt alone so the caller can reuse it.

Arguments:

    CmdPkt  -- A ptr to the command packet.
    CompletionArg - Unused.

Return Value:

    None.
--*/
{

    FRS_ASSERT(HANDLE_IS_VALID(CmdPkt->WaitEvent));

    SetEvent(CmdPkt->WaitEvent);
    //
    // A ctx switch to the waiter could occur at this point.  The waiter could
    // free the packet.  So no further refs to the packet are allowed.
    //
    return;
}



VOID
FrsInitializeRequestCount(
    IN PFRS_REQUEST_COUNT RequestCount
    )
/*++

Routine Description:

    Initializes a RequestCount for use.

Arguments:

    RequestCount - Supplies a pointer to a RequestCount structure to initialize

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/
{
    ULONG Status;

    RequestCount->Count = 0;
    RequestCount->Status = 0;

    InitializeCriticalSection(&RequestCount->Lock);

    RequestCount->Event = FrsCreateEvent(TRUE, FALSE);
}


VOID
FrsDeleteRequestCount(
    IN PFRS_REQUEST_COUNT RequestCount
    )
/*++

Routine Description:

    Releases resources used by a RequestCount.

Arguments:

    RequestCount - Supplies a pointer to a RequestCount structure to delete

Return Value:

    None.

--*/
{
    ULONG WStatus;

    if (RequestCount != NULL) {
        if (HANDLE_IS_VALID(RequestCount->Event)) {
            if (!CloseHandle(RequestCount->Event)) {
                WStatus = GetLastError();
                DPRINT_WS(0, "ERROR: Close event handle failed", WStatus);
                DeleteCriticalSection(&RequestCount->Lock);
                return;
            }

            DeleteCriticalSection(&RequestCount->Lock);
        }
        //
        // Zero memory to catch errors.
        //
        ZeroMemory(RequestCount, sizeof(FRS_REQUEST_COUNT));
    }
}



ULONG
FrsWaitOnRequestCount(
    IN PFRS_REQUEST_COUNT RequestCount,
    IN ULONG Timeout
    )
{
    DWORD WStatus;

Retry:

    if (RequestCount->Count > 0) {

        WStatus = WaitForSingleObject(RequestCount->Event, Timeout);

        CHECK_WAIT_ERRORS(3, WStatus, 1, ACTION_RETURN);
    }

    //
    // Lock the queue and check again.
    //
    EnterCriticalSection(&RequestCount->Lock);
    if (RequestCount->Count > 0) {
        //
        // Somebody got here before we did, drop the lock and retry
        //
        LeaveCriticalSection(&RequestCount->Lock);
        goto Retry;
    }

    LeaveCriticalSection(&RequestCount->Lock);

    return(ERROR_SUCCESS);

}




DWORD
FrsRtlInitializeList(
    PFRS_LIST List
    )
/*++

Routine Description:

    Initializes an interlocked list for use.

Arguments:

    List - Supplies a pointer to an FRS_LIST structure to initialize

Return Value:

    ERROR_SUCCESS if successful

--*/

{
    DWORD Status;

    InitializeListHead(&List->ListHead);
    InitializeCriticalSection(&List->Lock);
    List->Count = 0;
    List->ControlCount = 0;
    List->Control = List;

    return(ERROR_SUCCESS);

}



VOID
FrsRtlDeleteList(
    PFRS_LIST List
    )
/*++

Routine Description:

    Releases all resources used by an interlocked list.

Arguments:

    List - supplies the List to be deleted

Return Value:

    None.

--*/

{

    DeleteCriticalSection(&List->Lock);

    //
    // Zero the memory in order to cause grief to people who try
    // and use a deleted list.
    //
    ZeroMemory(List, sizeof(FRS_LIST));
}



PLIST_ENTRY
FrsRtlRemoveHeadList(
    IN PFRS_LIST List
    )
/*++

Routine Description:

    Removes the item at the head of the interlocked list.

Arguments:

    List - Supplies the list to remove an item from.

Return Value:

    Pointer to list entry removed from the head of the list.

    NULL if the list is empty.

--*/

{
#undef DEBSUB
#define DEBSUB  "FrsRtlRemoveHeadList:"

    PLIST_ENTRY Entry;
    PFRS_LIST Control = List->Control;

    if (List->ControlCount == 0) {
        return NULL;
    }

    //
    // Lock the list and try to remove something
    //
    EnterCriticalSection(&Control->Lock);
    if (Control->ControlCount == 0) {
        //
        // Somebody got here before we did, drop the lock and return null
        //
        LeaveCriticalSection(&Control->Lock);
        return NULL;
    }

    FRS_ASSERT(!IsListEmpty(&List->ListHead));
    Entry = RemoveHeadList(&List->ListHead);

    //
    // Decrement count.
    //
    List->Count--;
    Control->ControlCount--;

    LeaveCriticalSection(&Control->Lock);

    return(Entry);
}



VOID
FrsRtlInsertHeadList(
    IN PFRS_LIST List,
    IN PLIST_ENTRY Entry
    )
/*++

Routine Description:

    Inserts the item at the head of the interlocked list.

Arguments:

    List - Supplies the list to insert the item on.

    Entry - The entry to insert.

Return Value:

    None.

--*/

{
    PFRS_LIST Control = List->Control;

    //
    // Lock the list and insert at head.
    //
    EnterCriticalSection(&Control->Lock);
    FrsRtlInsertHeadListLock(List, Entry);
    LeaveCriticalSection(&Control->Lock);

    return;
}

PLIST_ENTRY
FrsRtlRemoveTailList(
    IN PFRS_LIST List
    )
/*++

Routine Description:

    Removes the item at the tail of the interlocked list.

Arguments:

    List - Supplies the list to remove an item from.

Return Value:

    Pointer to list entry removed from the tail of the list.

    NULL if the list is empty.

--*/

{
#undef DEBSUB
#define DEBSUB  "FrsRtlRemoveTailList:"

    PLIST_ENTRY Entry;
    PFRS_LIST Control = List->Control;

    if (Control->ControlCount == 0) {
        return NULL;
    }

    //
    // Lock the list and try to remove something
    //
    EnterCriticalSection(&Control->Lock);
    if (Control->ControlCount == 0) {
        //
        // Somebody got here before we did, drop the lock and return null
        //
        LeaveCriticalSection(&Control->Lock);
        return NULL;
    }

    FRS_ASSERT(!IsListEmpty(&List->ListHead));
    Entry = RemoveTailList(&List->ListHead);

    //
    // Decrement count.
    //
    List->Count--;
    Control->ControlCount--;

    LeaveCriticalSection(&Control->Lock);

    return(Entry);
}


VOID
FrsRtlInsertTailList(
    IN PFRS_LIST List,
    IN PLIST_ENTRY Entry
    )
/*++

Routine Description:

    Inserts the item at the tail of the interlocked list.

Arguments:

    List - Supplies the list to insert the item on.

    Entry - The entry to insert.

Return Value:

    None.

--*/

{
    PFRS_LIST Control = List->Control;

    //
    // Lock the list and insert at tail.
    //
    EnterCriticalSection(&Control->Lock);
    FrsRtlInsertTailListLock(List, Entry);
    LeaveCriticalSection(&Control->Lock);

    return;
}


VOID
FrsRtlRemoveEntryList(
    IN PFRS_LIST List,
    IN PLIST_ENTRY Entry
    )
/*++

Routine Description:

    Removes the entry from the interlocked list.  The entry must be on the
    given list since we use the lock in the FRS_LIST to synchronize access.

Arguments:

    List - Supplies the list to remove an item from.

    Entry - The entry to remove.

Return Value:

    None.

--*/

{
    PFRS_LIST Control = List->Control;

    //
    // Lock the list and try to remove entry
    //
    EnterCriticalSection(&Control->Lock);
    FrsRtlRemoveEntryListLock(List, Entry);
    LeaveCriticalSection(&Control->Lock);

    return;
}


VOID
FrsRtlRemoveEntryListLock(
    IN PFRS_LIST List,
    IN PLIST_ENTRY Entry
    )
/*++

Routine Description:

    Removes the entry from the interlocked list.  The entry must be on the
    given list.

    The caller already has the list lock.

Arguments:

    List - Supplies the list to remove an item from.

    Entry - The entry to remove.

Return Value:

    None.

--*/

{
    PFRS_LIST Control = List->Control;

    //
    // List better not be empty.
    //
    FRS_ASSERT(!IsListEmpty(&List->ListHead));
    RemoveEntryListB(Entry);

    //
    // Decrement count.
    //
    List->Count--;
    Control->ControlCount--;

    return;
}


VOID
FrsRtlInsertHeadListLock(
    IN PFRS_LIST List,
    IN PLIST_ENTRY Entry
    )
/*++

Routine Description:

    Inserts the item at the head of the interlocked list.
    The caller has acquired the lock.

Arguments:

    List - Supplies the list to insert the item on.

    Entry - The entry to insert.

Return Value:

    None.

--*/

{
    PFRS_LIST Control = List->Control;

    InsertHeadList(&List->ListHead, Entry);

    List->Count++;
    Control->ControlCount++;

    return;
}


VOID
FrsRtlInsertTailListLock(
    IN PFRS_LIST List,
    IN PLIST_ENTRY Entry
    )
/*++

Routine Description:

    Inserts the item at the tail of the interlocked list.
    The caller has acquired the lock.

Arguments:

    List - Supplies the list to insert the item on.

    Entry - The entry to insert.

Return Value:

    None.

--*/

{
    PFRS_LIST Control = List->Control;

    InsertTailList(&List->ListHead, Entry);

    List->Count++;
    Control->ControlCount++;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\util\util.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module contains support routines for the NT File Replication Service.

Author:

    David A. Orbits (davidor)  25-Mar-1997

Environment:

    User Mode Service

Revision History:

--*/
#include <ntreppch.h>
#pragma  hdrstop

#include <frs.h>
#include <tablefcn.h>
#include <ntfrsapi.h>
#include <info.h>
#include <sddl.h>
#ifdef SECURITY_WIN32
#include <security.h>
#else
#define SECURITY_WIN32
#include <security.h>
#undef SECURITY_WIN32
#endif

#include "stdarg.h"

#include <accctrl.h>
#include <aclapi.h>


BOOL
JrnlIsChangeOrderInReplica(
    IN PCHANGE_ORDER_ENTRY  ChangeOrder,
    IN PLONGLONG            DirFileID
);



LPTSTR
FrsSupInitPath(
    OUT LPTSTR OutPath,
    IN LPTSTR InPath,
    IN ULONG MaxOutPath
    )
/*++

Routine Description:

    Initialize a directory path string.  Add a backslash as needed and
    return a pointer to the start of the file part of the output string.
    Return NULL if the Output path string is too small.
    If InPath is NULL, OutPath is set to NULL and no slash.

Arguments:

    OutPath - The output string with the initialized path.

    InPath - The supplied input path.

    MaxOutPath - The maximum number of charaters that fit in OutPath.

Return Value:

    Pointer to the start of the filename part of the output string.
    NULL if output string is too small.

--*/
    //
    // Capture the directory path and add a backslash if necc.
    //
{
#undef DEBSUB
#define DEBSUB "FrsSupInitPath:"


    ULONG Length;


    Length = wcslen(InPath);
    if (Length > MaxOutPath) {
        return NULL;
    }

    wcscpy(OutPath, InPath);
    if (Length > 0) {
        if (OutPath[Length - 1] != COLON_CHAR &&
            OutPath[Length - 1] != BACKSLASH_CHAR) {
            wcscat(OutPath, L"\\");
            Length += 1;
        }
    }

    return &OutPath[Length];
}


LONG
FrsIsParent(
    IN PWCHAR   Directory,
    IN PWCHAR   Path
    )
/*++

Routine Description:

    Is Path a child of Directory or is the Directory a child of the path.
    In other words, is the directory represented by Path beneath
    the directory hierarchy represented by Directory (or vice-versa).

    E.g., c:\a\b is a child of c:\a.

    In the case of an exact match, Path is considered a child of
    Directory. This routine can be easily spoofed; a better check
    using FIDs and volume IDs should be implemented.

Arguments:

    Directory
    Path

Return Value:
    -1  = Path is a child of Directory or Path is the same as Directory
     0  = No relationship
     1  = Directory is a child of Path

--*/
{
#undef DEBSUB
#define DEBSUB "FrsIsParent:"

    PWCHAR  D;
    PWCHAR  P;
    LONG    Result = 0;
    PWCHAR  IndexPtrDir   = NULL;
    PWCHAR  IndexPtrPath   = NULL;
    DWORD   Colon      = 0;
    DWORD   CloseBrace = 0;
    DWORD   WStatus;
    HANDLE  Handle     = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK Iosb;
    PFILE_FS_VOLUME_INFORMATION   VolumeInfoDir   = NULL;
    PFILE_FS_VOLUME_INFORMATION   VolumeInfoPath  = NULL;
    DWORD   VolumeInfoLength;
    NTSTATUS NtStatus;
    OBJECT_ATTRIBUTES             Obja;
    UNICODE_STRING          FileName;
    ULONG                   FileAttributes;
    ULONG                   CreateDisposition;
    ULONG             ShareMode;

    //
    // Note: This is easily spoofed into giving false negatives.
    // Need to improve it to uses FIDs and voluem IDs
    //
    //
    // Defensive; NULL strings or empty strings can't be children/parents
    //
    if (!Directory || !Path || !*Directory || !*Path) {
        return Result;
    }

    //
    // If both the paths are on different volumes then they can not overlap.
    //
    //
    // Open the target symlink. If this is a dos type path name then
    // convert it to NtPathName or else use it as it is.
    //

    if (wcscspn(Directory, L":") == 1) {
        WStatus = FrsOpenSourceFileW(&Handle,
                                     Directory,
                                     GENERIC_READ,
                                     FILE_OPEN_FOR_BACKUP_INTENT);
        CLEANUP1_WS(4, "++ Could not open %ws; ", Directory, WStatus, RETURN);

    } else {
        //
        // The path already in Nt style. Use it as it is.
        //
        FileName.Buffer = Directory;
        FileName.Length = (USHORT)(wcslen(Directory) * sizeof(WCHAR));
        FileName.MaximumLength = (USHORT)(wcslen(Directory) * sizeof(WCHAR));

        InitializeObjectAttributes(&Obja,
                                   &FileName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        CreateDisposition = FILE_OPEN;               // Open existing file

        ShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;

        FileAttributes = FILE_ATTRIBUTE_NORMAL;

        NtStatus = NtCreateFile(&Handle,
                              GENERIC_READ,
                              &Obja,
                              &Iosb,
                              NULL,              // Initial allocation size
                              FileAttributes,
                              ShareMode,
                              CreateDisposition,
                              FILE_OPEN_FOR_BACKUP_INTENT,
                              NULL, 0);

        WStatus = FrsSetLastNTError(NtStatus);
        CLEANUP1_WS(4, "++ Could not open %ws;", Directory, WStatus, RETURN);
    }

    //
    // Get the volume information.
    //
    VolumeInfoLength = sizeof(FILE_FS_VOLUME_INFORMATION) +
                       MAXIMUM_VOLUME_LABEL_LENGTH;

    VolumeInfoDir = FrsAlloc(VolumeInfoLength);

    NtStatus = NtQueryVolumeInformationFile(Handle,
                                          &Iosb,
                                          VolumeInfoDir,
                                          VolumeInfoLength,
                                          FileFsVolumeInformation);
    CloseHandle(Handle);
    WStatus = FrsSetLastNTError(NtStatus);
    CLEANUP1_WS(4,"ERROR - Getting  NtQueryVolumeInformationFile for %ws\n", Directory, WStatus, RETURN);

    // Open the target symlink. If this is a dos type path name then
    // convert it to NtPathName or else use it as it is.
    //

    if (wcscspn(Path, L":") == 1) {
        WStatus = FrsOpenSourceFileW(&Handle,
                                     Path,
                                     GENERIC_READ,
                                     FILE_OPEN_FOR_BACKUP_INTENT);
        CLEANUP1_WS(4, "++ Could not open %ws; ", Path, WStatus, RETURN);

    } else {
        //
        // The path already in Nt style. Use it as it is.
        //
        FileName.Buffer = Path;
        FileName.Length = (USHORT)(wcslen(Path) * sizeof(WCHAR));
        FileName.MaximumLength = (USHORT)(wcslen(Path) * sizeof(WCHAR));

        InitializeObjectAttributes(&Obja,
                                   &FileName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        CreateDisposition = FILE_OPEN;               // Open existing file

        ShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;

        FileAttributes = FILE_ATTRIBUTE_NORMAL;

        NtStatus = NtCreateFile(&Handle,
                              GENERIC_READ,
                              &Obja,
                              &Iosb,
                              NULL,              // Initial allocation size
                              FileAttributes,
                              ShareMode,
                              CreateDisposition,
                              FILE_OPEN_FOR_BACKUP_INTENT,
                              NULL, 0);

        WStatus = FrsSetLastNTError(NtStatus);
        CLEANUP1_WS(4, "++ Could not open %ws;", Path, WStatus, RETURN);
    }

    //
    // Get the volume information.
    //
    VolumeInfoLength = sizeof(FILE_FS_VOLUME_INFORMATION) +
                       MAXIMUM_VOLUME_LABEL_LENGTH;

    VolumeInfoPath = FrsAlloc(VolumeInfoLength);

    NtStatus = NtQueryVolumeInformationFile(Handle,
                                          &Iosb,
                                          VolumeInfoPath,
                                          VolumeInfoLength,
                                          FileFsVolumeInformation);
    WStatus = FrsSetLastNTError(NtStatus);
    CLEANUP1_WS(4,"ERROR - Getting  NtQueryVolumeInformationFile for %ws\n", Path, WStatus, RETURN);

    if (VolumeInfoDir->VolumeSerialNumber != VolumeInfoPath->VolumeSerialNumber) {
        goto RETURN;
    }

    //
    // Find the colon. Every path has to either have a colon followed by a '\'
    // or it should be of the form. "\??\Volume{60430005-ab47-11d3-8973-806d6172696f}\"
    //
    Colon = wcscspn(Directory, L":");

    if (Colon == wcslen(Directory)) {
        //
        // Path does not have a colon. It can be of the form
        // "\??\Volume{60430005-ab47-11d3-8973-806d6172696f}\"
        //
        CloseBrace = wcscspn(Directory, L"}");
        if (Directory[CloseBrace] != L'}' ||
            Directory[CloseBrace + 1] != L'\\') {
            Result = 0;
            goto RETURN;
        }
        //
        // Copy the path up to 1 past the closing brace as it is. It could be \??\Volume...
        // or \\.\Volume... or \\?\Volume.. or some other complex form.
        // Start looking for reparse points past the closing brace.
        //

        IndexPtrDir = &Directory[CloseBrace + 1];

    } else {
        if (Directory[Colon] != L':' ||
            Directory[Colon + 1] != L'\\') {
            Result = 0;
            goto RETURN;
        }
        //
        // Copy the path up to 1 past the colon as it is. It could be d:\
        // or \\.\d:\ or \??\d:\ or some other complex form.
        // Start looking for reparse points past the colon.
        //

        IndexPtrDir = &Directory[Colon + 1];

    }

    //
    // Find the colon. Every path has to either have a colon followed by a '\'
    // or it should be of the form. "\??\Volume{60430005-ab47-11d3-8973-806d6172696f}\"
    //
    Colon = wcscspn(Path, L":");

    if (Colon == wcslen(Path)) {
        //
        // Path does not have a colon. It can be of the form
        // "\??\Volume{60430005-ab47-11d3-8973-806d6172696f}\"
        //
        CloseBrace = wcscspn(Path, L"}");
        if (Path[CloseBrace] != L'}' ||
            Path[CloseBrace + 1] != L'\\') {
            Result = 0;
            goto RETURN;
        }
        //
        // Copy the path up to 1 past the closing brace as it is. It could be \??\Volume...
        // or \\.\Volume... or \\?\Volume.. or some other complex form.
        // Start looking for reparse points past the closing brace.
        //

        IndexPtrPath = &Path[CloseBrace + 1];

    } else {
        if (Path[Colon] != L':' ||
            Path[Colon + 1] != L'\\') {
            Result = 0;
            goto RETURN;
        }
        //
        // Copy the path up to 1 past the colon as it is. It could be d:\
        // or \\.\d:\ or \??\d:\ or some other complex form.
        // Start looking for reparse points past the colon.
        //

        IndexPtrPath = &Path[Colon + 1];

    }

    //
    // Break at the first non-matching wchar (collapse dup \s)
    //
    for (D = IndexPtrDir, P = IndexPtrPath; *P && *D; ++P, ++D) {
        //
        // Skip dup \s
        //
        while (*P == L'\\' && *(P + 1) == L'\\') {
            ++P;
        }
        while (*D == L'\\' && *(D + 1) == L'\\') {
            ++D;
        }
        if (towlower(*P) != towlower(*D)) {
            break;
        }
    }

    //
    // Exact match; consider Path a child of Directory
    //
    if (!*D && !*P) {
        Result = -1;
        goto RETURN;
    }

    //
    // Collapse dup \s
    //
    while (*P == L'\\' && *(P + 1) == L'\\') {
        ++P;
    }
    while (*D == L'\\' && *(D + 1) == L'\\') {
        ++D;
    }

    //
    // Path is a child of Directory
    //
    if ((!*D || (*D == L'\\' && !*(D + 1))) &&
        (!*P || *P == L'\\' || (P != Path && *(P - 1) == L'\\'))) {
        Result = -1;
        goto RETURN;
    }

    //
    // Directory is a child of Path
    //
    if ((!*P || (*P == L'\\' && !*(P + 1))) &&
        (!*D || *D == L'\\' || (D != Directory && *(D - 1) == L'\\'))) {
        Result = 1;
        goto RETURN;
    }

    //
    // no relationship
    //
RETURN:
    FRS_CLOSE(Handle);
    FrsFree(VolumeInfoDir);
    FrsFree(VolumeInfoPath);
    return Result;
}

#if 0

ULONG FrsSupMakeFullFileName(
    IN PREPLICA Replica,
    IN PTCHAR RelativeName,
    OUT PTCHAR FullName,
    IN ULONG MaxLength
    )
{
/*++

Routine Description:

    Build a full file name for a given data source with the supplied
    RelativeName.

Arguments:

    Replica  - The replica tree to provide the root path.

    RelativeName - The relative file name from the root of the data source.

    FullName - The returned full path name of the file.

    MaxLength - The maximum number of characters that fit in FullName.

Return Value:

    Status - ERROR_BAD_PATHNAME if the name is too long.

--*/
#undef DEBSUB
#define DEBSUB "FrsSupMakeFullFileName:"


    ULONG Length, TotalLength;
    PTCHAR pFilePart;

    PCONFIG_TABLE_RECORD ConfigRecord;

    ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);

    //
    // Init the file name string with the DataSource root path.
    //
    pFilePart = FrsSupInitPath( FullName, ConfigRecord->FSRootPath, MaxLength);
    if (pFilePart == NULL) {
        return ERROR_BAD_PATHNAME;
    }

    Length = wcslen(RelativeName);
    TotalLength = Length + wcslen(FullName);
    if (TotalLength > MaxLength) {
        return ERROR_BAD_PATHNAME;
    }
    //
    // Append the relative file name to the end of the base path.
    //
    wcscpy(pFilePart, RelativeName);

    return ERROR_SUCCESS;
}

#endif 0

ULONG
FrsForceDeleteFile(
    PTCHAR DestName
)
/*++

Routine Description:

    Support routine to delete File System Files.  Returns success if file
    is not there or if it was there and was deleted.

Arguments:

    DestName - The fully qualified file name.

Return Value:

    Win32 Status

--*/
{
#undef DEBSUB
#define DEBSUB "FrsForceDeleteFile:"

    ULONG WStatus = ERROR_SUCCESS;
    ULONG FileAttributes;

    if (!DeleteFile(DestName)) {

        WStatus = GetLastError();
        if ((WStatus == ERROR_FILE_NOT_FOUND) ||
            (WStatus == ERROR_PATH_NOT_FOUND)) {
            return ERROR_SUCCESS;
        }

        FileAttributes = GetFileAttributes(DestName);

        if ((FileAttributes != 0xFFFFFFFF) &&
            (FileAttributes & NOREPL_ATTRIBUTES)) {
            //
            // Reset file attributes to allow delete.
            //
            SetFileAttributes(DestName,
                              FILE_ATTRIBUTE_NORMAL |
                              (FileAttributes & ~NOREPL_ATTRIBUTES));
        }

        if (!DeleteFile(DestName)) {
            WStatus = GetLastError();
            DPRINT1_WS(4, "++ WARN - cannot delete %ws;", DestName, WStatus);
        }
    }

    return WStatus;
}


HANDLE
FrsCreateEvent(
    IN  BOOL    ManualReset,
    IN  BOOL    InitialState
)
/*++

Routine Description:

    Support routine to create an event.

Arguments:

    ManualReset     - TRUE if ResetEvent is required
    InitialState    - TRUE if signaled

Return Value:

    Address of the created event handle.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsCreateEvent:"
    HANDLE  Handle;

    Handle = CreateEvent(NULL, ManualReset, InitialState, NULL);
    if (!HANDLE_IS_VALID(Handle)) {
        RaiseException(ERROR_INVALID_HANDLE, 0, 0, NULL);
    }
    return Handle;
}


HANDLE
FrsCreateWaitableTimer(
    IN  BOOL    ManualReset
)
/*++

Routine Description:

    Support routine to create a waitable timer.

Arguments:

    ManualReset - TRUE if not synchronization timer

Return Value:

    Address of the created waitable timer handle.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsCreateWaitableTimer:"
    HANDLE  Handle;

    Handle = CreateWaitableTimer(NULL, ManualReset, NULL);
    if (!HANDLE_IS_VALID(Handle)) {
        RaiseException(ERROR_INVALID_HANDLE, 0, 0, NULL);
    }
    return Handle;
}


ULONG
FrsUuidCreate(
    OUT GUID *Guid
    )
/*++

Routine Description:

    Frs wrapper on UuidCreate() to generate an exception if we fail
    to get correctly formed Guid.  In particular UuidCreate can have
    problems getting the network address.


        RPC_S_OK - The operation completed successfully.

        RPC_S_UUID_NO_ADDRESS - We were unable to obtain the ethernet or
            token ring address for this machine.

        RPC_S_UUID_LOCAL_ONLY - On NT & Chicago if we can't get a
            network address.  This is a warning to the user, the
            UUID is still valid, it just may not be unique on other machines.

        RPC_S_OUT_OF_MEMORY - Returned as needed.

Arguments:

    Guid - Pointer to returned guid.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "FrsUuidCreate:"
    DWORD       MsgBufSize;
    WCHAR       MsgBuf[MAX_PATH + 1];
    RPC_STATUS  RpcStatusFromUuidCreate;

    RpcStatusFromUuidCreate = UuidCreate(Guid);
    if (RpcStatusFromUuidCreate == RPC_S_OK) {
        return FrsErrorSuccess;
    }

    DPRINT_WS(0, "ERROR - Failed to get GUID.", RpcStatusFromUuidCreate);

    if (RpcStatusFromUuidCreate == RPC_S_UUID_NO_ADDRESS) {
        DPRINT(0, "++ UuidCreate() returned RPC_S_UUID_NO_ADDRESS.\n");
    } else
    if (RpcStatusFromUuidCreate == RPC_S_UUID_LOCAL_ONLY) {
        DPRINT(0, "++ UuidCreate() returned RPC_S_UUID_LOCAL_ONLY.\n");
    } else
    if (RpcStatusFromUuidCreate == RPC_S_OUT_OF_MEMORY) {
        DPRINT(0, "++ UuidCreate() returned RPC_S_OUT_OF_MEMORY.\n");
    }

    //
    // Format the error code
    //
    MsgBufSize = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |
                               FORMAT_MESSAGE_MAX_WIDTH_MASK,
                               NULL,
                               RpcStatusFromUuidCreate,
                               0,
                               MsgBuf,
                               MAX_PATH + 1,
                               NULL);
    //
    // No message; use the status code
    //
    if (!MsgBufSize) {
        swprintf(MsgBuf, L"%d (0x%08x)", RpcStatusFromUuidCreate, RpcStatusFromUuidCreate);
    }

    //
    // This is very bad.  Any member that can't generate proper GUIDs is
    // busted.
    //
    // Shutdown with an event log message
    //
    EPRINT2(EVENT_FRS_CANNOT_CREATE_UUID, ComputerName, MsgBuf);

    //
    // EXIT BECAUSE THE CALLERS CANNOT HANDLE THIS ERROR.
    //
    DPRINT(0, ":S: NTFRS IS EXITING W/O CLEANUP! SERVICE CONTROLLER RESTART EXPECTED.\n");
    DEBUG_FLUSH();
    exit(RpcStatusFromUuidCreate);

    return FrsErrorInvalidGuid;
}


LONG
FrsGuidCompare (
    IN GUID *Guid1,
    IN GUID *Guid2
    )

/*++

Routine Description:

    Do a simple, straight unsigned compare of two GUIDs.
    UuidCompare doesn't do this.  I don't know what kind of comparison it
    does.

Arguments:

    Guid1 - The first Guid
    Guid2 - The second Guid.

Return Value:

    Result:  -1 if Guid1 < Guid2
              0 if Guid1 = Guid2
             +1 if Guid1 > Guid2
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsGuidCompare:"

    PULONG p1 = (PULONG) Guid1;
    PULONG p2 = (PULONG) Guid2;

    p1 += 4;
    p2 += 4;

    while (p1 != (PVOID) Guid1) {
        p1 -= 1;
        p2 -= 1;

        if (*p1 > *p2) {
            return 1;
        }

        if (*p1 < *p2) {
            return -1;
        }
    }

    return 0;
}


VOID
FrsNowAsFileTime(
    IN  PLONGLONG   Now
)
/*++

Routine Description:

    Return the current time as a filetime in longlong format.

Arguments:

    Now - address of longlong to receive current time.

Return Value:

    Fill in Now with current file time

--*/
{
#undef DEBSUB
#define DEBSUB "FrsNowAsFileTime:"
    FILETIME    FileTime;

    GetSystemTimeAsFileTime(&FileTime);
    COPY_TIME(Now, &FileTime);
}


char *Days[] =
{
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
};

char *Months[] =
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};

VOID
FileTimeToString(
    IN FILETIME *FileTime,
    OUT PCHAR     Buffer
    )
/*++

Routine Description:

    Convert a FileTime (UTC time) to an ANSI date/time string in the
    local time zone.

Arguments:

    Time - ptr to a FILETIME
    Str  - a string of at least TIME_STRING_LENGTH bytes to receive the time.

Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "FileTimeToString:"

    FILETIME LocalFileTime;
    SYSTEMTIME SystemTime;

    Buffer[0] = '\0';
    if (FileTime->dwHighDateTime != 0 || FileTime->dwLowDateTime != 0)
    {
        if (!FileTimeToLocalFileTime(FileTime, &LocalFileTime) ||
            !FileTimeToSystemTime(&LocalFileTime, &SystemTime))
        {
            strcpy(Buffer, "Time???");
            return;
        }
        sprintf(
            Buffer,
            "%s %s %2d, %4d %02d:%02d:%02d",
            Days[SystemTime.wDayOfWeek],
            Months[SystemTime.wMonth - 1],
            SystemTime.wDay,
            SystemTime.wYear,
            SystemTime.wHour,
            SystemTime.wMinute,
            SystemTime.wSecond);
    }
    return;
}


VOID
FileTimeToStringClockTime(
    IN FILETIME *FileTime,
    OUT PCHAR     Buffer
    )
/*++

Routine Description:

    Convert a FileTime (UTC time) to an ANSI time string in the
    local time zone.

Arguments:

    Time - ptr to a FILETIME
    Str  - a string to hold hh:mm:ss\0.  (9 bytes min.)

Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "FileTimeToStringClockTime:"

    FILETIME LocalFileTime;
    SYSTEMTIME SystemTime;

    Buffer[0] = '\0';

    if (FileTime->dwHighDateTime == 0 && FileTime->dwLowDateTime == 0) {
        strcpy(Buffer, "??:??:??");
        return;
    }
    if (!FileTimeToLocalFileTime(FileTime, &LocalFileTime) ||
        !FileTimeToSystemTime(&LocalFileTime, &SystemTime)) {
        strcpy(Buffer, "??:??:??");
        return;
    }

    _snprintf(Buffer, 9, "%02d:%02d:%02d",
            SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
}


VOID
GuidToStr(
    IN GUID  *pGuid,
    OUT PCHAR  s
    )
/*++

Routine Description:

    Convert a GUID to a string.

    Based on code from Mac McLain.

Arguments:

    pGuid - ptr to the GUID.

    s - The output character buffer.
        Must be at least GUID_CHAR_LEN (36 bytes) long.

Function Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "GuidToStr:"

    if (pGuid != NULL) {
        sprintf(s, "%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x",
               pGuid->Data1,
               pGuid->Data2,
               pGuid->Data3,
               pGuid->Data4[0],
               pGuid->Data4[1],
               pGuid->Data4[2],
               pGuid->Data4[3],
               pGuid->Data4[4],
               pGuid->Data4[5],
               pGuid->Data4[6],
               pGuid->Data4[7]);
    } else {
        sprintf(s, "<ptr-null>");
    }
}


VOID
GuidToStrW(
    IN GUID  *pGuid,
    OUT PWCHAR  ws
    )
/*++

Routine Description:

    Convert a GUID to a wide string.

Arguments:

    pGuid - ptr to the GUID.

    ws - The output character buffer.
        Must be at least GUID_CHAR_LEN (36 wchars) long.

Function Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "GuidToStrW:"

    if (pGuid) {
        swprintf(ws, L"%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x",
               pGuid->Data1,
               pGuid->Data2,
               pGuid->Data3,
               pGuid->Data4[0],
               pGuid->Data4[1],
               pGuid->Data4[2],
               pGuid->Data4[3],
               pGuid->Data4[4],
               pGuid->Data4[5],
               pGuid->Data4[6],
               pGuid->Data4[7]);
    } else {
        swprintf(ws, L"<ptr-null>");
    }
}


BOOL
StrWToGuid(
    IN  PWCHAR ws,
    OUT GUID  *pGuid
    )
/*++

Routine Description:

    Convert a wide string into a GUID. The wide string was created with
    GuidToStrW().

Arguments:

    pGuid - ptr to the output GUID.

    ws - The character buffer.

Function Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "StrWToGuid:"
    DWORD   Fields;
    UCHAR   Guid[sizeof(GUID) + sizeof(DWORD)]; // 3 byte overflow
    GUID    *lGuid = (GUID *)Guid;

    FRS_ASSERT(ws && pGuid);

    Fields = swscanf(ws, L"%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x",
                     &lGuid->Data1,
                     &lGuid->Data2,
                     &lGuid->Data3,
                     &lGuid->Data4[0],
                     &lGuid->Data4[1],
                     &lGuid->Data4[2],
                     &lGuid->Data4[3],
                     &lGuid->Data4[4],
                     &lGuid->Data4[5],
                     &lGuid->Data4[6],
                     &lGuid->Data4[7]);
    COPY_GUID(pGuid, lGuid);
    return (Fields == 11);
}


VOID
StrToGuid(
    IN PCHAR  s,
    OUT GUID  *pGuid
    )
/*++

Routine Description:

    Convert a string in GUID display format to an object ID that
    can be used to lookup a file.

    based on a routine by Mac McLain

Arguments:

    pGuid - ptr to the output GUID.

    s - The input character buffer in display guid format.
        e.g.:  b81b486b-c338-11d0-ba4f0000f80007df

        Must be at least GUID_CHAR_LEN (35 bytes) long.

Function Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "StrToGuid:"
    UCHAR   Guid[sizeof(GUID) + sizeof(DWORD)]; // 3 byte overflow
    GUID    *lGuid = (GUID *)Guid;

    FRS_ASSERT(s && pGuid);

    sscanf(s, "%08lx-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x",
           &lGuid->Data1,
           &lGuid->Data2,
           &lGuid->Data3,
           &lGuid->Data4[0],
           &lGuid->Data4[1],
           &lGuid->Data4[2],
           &lGuid->Data4[3],
           &lGuid->Data4[4],
           &lGuid->Data4[5],
           &lGuid->Data4[6],
           &lGuid->Data4[7]);
    COPY_GUID(pGuid, lGuid);
}





NTSTATUS
SetupOnePrivilege (
    ULONG Privilege,
    PUCHAR PrivilegeName
    )
{

#undef DEBSUB
#define DEBSUB "SetupOnePrivilege:"

    BOOLEAN PreviousPrivilegeState;
    NTSTATUS Status;

    Status = RtlAdjustPrivilege(Privilege, TRUE, FALSE, &PreviousPrivilegeState);

    if (!NT_SUCCESS(Status)) {
        DPRINT1(0, ":S: Your login does not have `%s' privilege.\n", PrivilegeName);

        if (Status != STATUS_PRIVILEGE_NOT_HELD) {
            DPRINT_NT(0, ":S: RtlAdjustPrivilege failed :", Status);
        }
        DPRINT(0, ":S: Update your: User Manager -> Policies -> User Rights.\n");

    }

    DPRINT2(4, ":S: Added `%s' privilege (previous: %s)\n",
           PrivilegeName, (PreviousPrivilegeState ? "Enabled" : "Disabled"));

    return Status;
}




PWCHAR
FrsGetResourceStr(
    LONG  Id
)
/*++

Routine Description:

    This routine Loads the specified resource string.
    It allocates a buffer and returns the ptr.

Arguments:

    Id - An FRS_IDS_xxx identifier.

Return Value:

    Ptr to allocated string.
    The caller must free the buffer with a call to FrsFree().

--*/
#undef DEBSUB
#define DEBSUB "FrsGetResourceStr:"
{

    LONG  N = 0;
    WCHAR WStr[200];
    HINSTANCE hInst = NULL;
    PWCHAR MessageFile = NULL;

    //
    // ID Must be Valid.
    //
    if ((Id <= IDS_TABLE_START) || (Id > IDS_TABLE_END)) {
      DPRINT1(0, "++ Resource string ID is out of range - %d\n", Id);
      Id = IDS_MISSING_STRING;
    }

    WStr[0] = UNICODE_NULL;

    CfgRegReadString(FKC_FRS_MESSAGE_FILE_PATH, NULL, 0, &MessageFile);

    hInst = LoadLibrary(MessageFile);

    if (hInst != NULL) {
        N = LoadString(hInst, Id, WStr, ARRAY_SZ(WStr));

        if (N == 0) {
          DPRINT_WS(0, "ERROR - Failed to get resource string.", GetLastError());
        }

       FreeLibrary(hInst);
    } else {

        DPRINT_WS(0, "ERROR - Failed to LoadLibrary.", GetLastError());
    }


    FrsFree(MessageFile);
    return FrsWcsDup(WStr);
}



DWORD
FrsOpenSourceFileW(
    OUT PHANDLE     Handle,
    IN  LPCWSTR     lpFileName,
    IN  ACCESS_MASK DesiredAccess,
    IN  ULONG       CreateOptions
    )
/*++

Routine Description:

    This function opens the specified file with backup intent for
    reading all the files attributes, ...

Arguments:

    Handle - A pointer to a handle to return an open handle.

    lpFileName - Represents the name of the file or directory to be opened.

    DesiredAccess

    CreateOptions

Return Value:

    Win32 Error status.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsOpenSourceFileW:"

    NTSTATUS          Status;
    DWORD             WStatus = ERROR_SUCCESS;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING    FileName;
    IO_STATUS_BLOCK   IoStatusBlock;
    BOOLEAN           b;
    RTL_RELATIVE_NAME RelativeName;
    PVOID             FreeBuffer;
    ULONG             FileAttributes;
    ULONG             CreateDisposition;
    ULONG             ShareMode;


    //
    // Convert the Dos name to an NT name.
    //
    b = RtlDosPathNameToNtPathName_U(lpFileName, &FileName, NULL, &RelativeName);
    if ( !b ) {
        return ERROR_INVALID_NAME;
    }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
    } else {
        RelativeName.ContainingDirectory = NULL;
    }

    InitializeObjectAttributes(&Obja,
                               &FileName,
                               OBJ_CASE_INSENSITIVE,
                               RelativeName.ContainingDirectory,
                               NULL);

    CreateDisposition = FILE_OPEN;               // Open existing file

    ShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;

    FileAttributes = FILE_ATTRIBUTE_NORMAL;

    Status = NtCreateFile(Handle,
                          DesiredAccess,
                          &Obja,
                          &IoStatusBlock,
                          NULL,              // Initial allocation size
                          FileAttributes,
                          ShareMode,
                          CreateDisposition,
                          CreateOptions,
                          NULL, 0);

    if (!NT_SUCCESS(Status)) {
        *Handle = INVALID_HANDLE_VALUE;
        //
        // Get a Win32 status.
        //
        WStatus = FrsSetLastNTError(Status);

        DPRINT_NT(0, "NtCreateFile failed :", Status);

        if ( Status == STATUS_OBJECT_NAME_COLLISION ) {
            //
            // Standard Win32 mapping for this is ERROR_ALREADY_EXISTS.
            // Change it.
            //
            WStatus = ERROR_FILE_EXISTS;
            SetLastError(ERROR_FILE_EXISTS);
        }

        DPRINT1_WS(0, "++ CreateFile failed on file %ws;", FileName.Buffer, WStatus);
    }

    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    return WStatus;
}



DWORD
FrsOpenSourceFile2W(
    OUT PHANDLE     Handle,
    IN  LPCWSTR     lpFileName,
    IN  ACCESS_MASK DesiredAccess,
    IN  ULONG       CreateOptions,
    IN  ULONG       ShareMode
    )
/*++

Routine Description:

    This function opens the specified file with backup intent for
    reading all the files attributes, ...
    Like  FrsOpenSourceFileW but also accepts the sharing mode parameter.

Arguments:

    Handle - A pointer to a handle to return an open handle.

    lpFileName - Represents the name of the file or directory to be opened.

    DesiredAccess

    CreateOptions

    ShareMode -  File sharing mode for NtCreateFile.

Return Value:

    Win32 Error status.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsOpenSourceFile2W:"

    NTSTATUS          Status;
    DWORD             WStatus = ERROR_SUCCESS;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING    FileName;
    IO_STATUS_BLOCK   IoStatusBlock;
    BOOLEAN           b;
    RTL_RELATIVE_NAME RelativeName;
    PVOID             FreeBuffer;
    ULONG             FileAttributes;
    ULONG             CreateDisposition;


    //
    // Convert the Dos name to an NT name.
    //
    b = RtlDosPathNameToNtPathName_U(lpFileName, &FileName, NULL, &RelativeName);
    if ( !b ) {
        return ERROR_INVALID_NAME;
    }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
    } else {
        RelativeName.ContainingDirectory = NULL;
    }

    InitializeObjectAttributes(&Obja,
                               &FileName,
                               OBJ_CASE_INSENSITIVE,
                               RelativeName.ContainingDirectory,
                               NULL);

    CreateDisposition = FILE_OPEN;               // Open existing file

    FileAttributes = FILE_ATTRIBUTE_NORMAL;

    Status = NtCreateFile(Handle,
                          DesiredAccess,
                          &Obja,
                          &IoStatusBlock,
                          NULL,              // Initial allocation size
                          FileAttributes,
                          ShareMode,
                          CreateDisposition,
                          CreateOptions,
                          NULL, 0);

    if (!NT_SUCCESS(Status)) {
        *Handle = INVALID_HANDLE_VALUE;
        //
        // Get a Win32 status.
        //
        WStatus = FrsSetLastNTError(Status);

        DPRINT_NT(0, "NtCreateFile failed :", Status);

        if ( Status == STATUS_OBJECT_NAME_COLLISION ) {
            //
            // Standard Win32 mapping for this is ERROR_ALREADY_EXISTS.
            // Change it.
            //
            WStatus = ERROR_FILE_EXISTS;
            SetLastError(ERROR_FILE_EXISTS);
        }

        DPRINT1_WS(0, "++ CreateFile failed on file %ws;", FileName.Buffer, WStatus);
    }

    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    return WStatus;
}


BOOL
FrsGetFileInfoByHandle(
    IN PWCHAR Name,
    IN HANDLE Handle,
    OUT PFILE_NETWORK_OPEN_INFORMATION  FileOpenInfo
    )
/*++

Routine Description:

    Return the network file info for the specified handle.

Arguments:

    Name - File's name for printing error messages

    Handle - Open file handle

    FileOpenInfo - Returns the file FILE_NETWORK_OPEN_INFORMATION data.

Return Value:

    TRUE  - FileOpenInfo contains the file's info
    FALSE - Contents of FileOpenInfo is undefined

--*/
{
#undef DEBSUB
#define DEBSUB "FrsGetFileInfoByHandle:"
    NTSTATUS        Status;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Return some file info
    //
    Status = NtQueryInformationFile(Handle,
                                    &IoStatusBlock,
                                    FileOpenInfo,
                                    sizeof(FILE_NETWORK_OPEN_INFORMATION),
                                    FileNetworkOpenInformation);
    if (!NT_SUCCESS(Status)) {
        DPRINT_NT(0, "NtQueryInformationFile failed :", Status);
        return FALSE;
    }
    return TRUE;
}


DWORD
FrsGetFileInternalInfoByHandle(
    IN HANDLE Handle,
    OUT PFILE_INTERNAL_INFORMATION  InternalFileInfo
    )
/*++

Routine Description:

    Return the internal file info for the specified handle.

Arguments:

    Handle - Open file handle

    InternalFileInfo - Basically, file's reference number (fid)

Return Value:

    Win32 Status

--*/
{
#undef DEBSUB
#define DEBSUB "FrsGetFileInternalInfoByHandle:"
    NTSTATUS        Status;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Return some file info
    //
    Status = NtQueryInformationFile(Handle,
                                    &IoStatusBlock,
                                    InternalFileInfo,
                                    sizeof(FILE_INTERNAL_INFORMATION),
                                    FileInternalInformation);
    return FrsSetLastNTError(Status);
}



DWORD
FrsReadFileDetails(
    IN     HANDLE                         Handle,
    IN     LPCWSTR                        FileName,
    OUT    PFILE_OBJECTID_BUFFER          ObjectIdBuffer,
    OUT    PLONGLONG                      FileIdBuffer,
    OUT    PFILE_NETWORK_OPEN_INFORMATION FileNetworkOpenInfo,
    IN OUT BOOL                           *ExistingOid
    )
/*++

Routine Description:

    This routine reads the object ID.  If there is no
    object ID on the file we put one on it.


Arguments:

    Handle -- The file handle of an opened file.

    FileName -- The name of the file.  For error messages only.

    ObjectIdBuffer -- The output buffer to hold the object ID.

    FileIdBuffer -- Returns the NTFS FileReference (FileId).

    FileNetworkOpenInfo -- returns FILE_NETWORK_OPEN_INFORMATION

    ExistingOid -- INPUT:  TRUE means use existing File OID if found.
                   RETURN:  TRUE means an existing File OID was used.

Return Value:

    Returns the Win Status of the last error found, or success.

--*/
{

#undef DEBSUB
#define DEBSUB "FrsReadFileDetails:"


    FILE_INTERNAL_INFORMATION FileReference;

    NTSTATUS        Status;
    IO_STATUS_BLOCK Iosb;
    LONG            Loop;
    BOOL            CallerSupplied = FALSE;

    CHAR GuidStr[GUID_CHAR_LEN];

    //
    // Get the file ID.
    //
    Status = NtQueryInformationFile(Handle,
                                    &Iosb,
                                    FileIdBuffer,
                                    sizeof(FILE_INTERNAL_INFORMATION),
                                    FileInternalInformation);

    if (!NT_SUCCESS(Status)) {
        DPRINT_NT(0, "++ ERROR - QueryInfoFile FileID failed :", Status);
        FrsSetLastNTError(Status);
    }

    //
    // Get file times, size, attributes.
    //
    Status = NtQueryInformationFile(Handle,
                                    &Iosb,
                                    FileNetworkOpenInfo,
                                    sizeof(FILE_NETWORK_OPEN_INFORMATION),
                                    FileNetworkOpenInformation);

    if (!NT_SUCCESS(Status)) {
        DPRINT_NT(0, "++ ERROR - QueryInfoFile FileNetworkOpenInformation failed :", Status);
        FrsSetLastNTError(Status);
    }


    if (!*ExistingOid) {
        //
        // Set up to slam a new OID on the file.
        //
        CallerSupplied = TRUE;
        ZeroMemory(ObjectIdBuffer, sizeof(FILE_OBJECTID_BUFFER));
        FrsUuidCreate((GUID *)ObjectIdBuffer->ObjectId);
    }

    return FrsGetOrSetFileObjectId(Handle, FileName, CallerSupplied, ObjectIdBuffer);

}



#if 0
    // This may not be needed.

ULONG
FrsReadFileSecurity(
    IN HANDLE Handle,
    IN OUT PTABLE_CTX TableCtx,
    IN PWCHAR FileName
    )
/*++

Routine Description:

    This routine gets the security descriptor from the file.  The returned data
    is stored into the security descriptor field in the data record allocated
    with the table context.  If the default buffer is not large enough
    a larger buffer is allocated.

Arguments:

    Handle    -- Handle to open file from which to extract the security desc.
    TableCtx  -- The table context struct where the security descriptor is
                 to be written.  It must be an IDTable.
    FileName  -- The full filename.  For error messages only.

Return Value:

    Returns the WIN32 STATUS error status.

    Note: In the event that GetFileSecurity returns ERROR_NO_SECURITY_ON_OBJECT
    we release the buffer, setting the length to zero, and return ERROR_SUCCESS.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsReadFileSecurity:"

    ULONG WStatus;
    NTSTATUS Status;
    ULONG BufLen;
    PSECURITY_DESCRIPTOR Buffer;
    ULONG BufNeeded;
    ULONG ActualLen;
    JET_ERR             jerr;
    PJET_SETCOLUMN      JSetColumn;

    //
    // Check the table type is an IDTable.
    //
    if (TableCtx->TableType != IDTablex) {
        DPRINT1(0, "++ ERROR - Invalid Table Type: %d\n", TableCtx->TableType);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get ptrs to the Jet SetColumn array and the buffer address & length
    //
    JSetColumn = TableCtx->pJetSetCol;

    Buffer = (PSECURITY_DESCRIPTOR) JSetColumn[SecDescx].pvData;
    BufLen = JSetColumn[SecDescx].cbData;

    //
    // The security descriptor is a variable length binary field that
    // must have a type/size prefix.
    //
    ((PFRS_NODE_HEADER) Buffer)->Size = (USHORT) BufLen;
    ((PFRS_NODE_HEADER) Buffer)->Type = 0;
    BufNeeded = 0;

    //
    // Check that the security descriptor buffer looks reasonable.
    //
    if (Buffer == NULL) {
        DPRINT2(0, "++ ERROR - Invalid SD buffer. Buffer Addr: %08x, Len: %d\n",
                Buffer, BufLen);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Now go get all the security information.
    //
    while (TRUE) {
        BufLen -= sizeof(FRS_NODE_HEADER);  // for type / size prefix.
        (PCHAR)Buffer += sizeof(FRS_NODE_HEADER);

        Status = NtQuerySecurityObject(
            Handle,
            SACL_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION |
            GROUP_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION,
            Buffer,
            BufLen,
            &BufNeeded);

        if (NT_SUCCESS(Status)) {

            ActualLen = GetSecurityDescriptorLength(Buffer) + sizeof(FRS_NODE_HEADER);
            BufLen += sizeof(FRS_NODE_HEADER);

            DPRINT3(5, "++ GetFileSecurity-1 Buflen: %d, Bufneeded: %d, ActualLen: %d\n",
                    BufLen, BufNeeded, ActualLen);
            //
            // If current buffer size is more than 16 bytes larger than needed AND
            // also more than 5% greater than needed then shrink the buffer but
            // keep the data.
            //

            if (((BufLen-ActualLen) > 16) &&
                (BufLen > (ActualLen + ActualLen/20))) {

                DPRINT3(5, "++ GetFileSecurity-2 Reducing buffer, Buflen: %d, Bufneeded: %d, ActualLen: %d\n",
                        BufLen, BufNeeded, ActualLen);
                //
                // Unused space in field buffer is greater than 6%.
                // Reduce the buffer size but keep the data.
                //
                jerr = DbsReallocateFieldBuffer(TableCtx, SecDescx, ActualLen, TRUE);
                if (!JET_SUCCESS(jerr)) {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
                Buffer = (PSECURITY_DESCRIPTOR) JSetColumn[SecDescx].pvData;
                ((PFRS_NODE_HEADER) Buffer)->Size = (USHORT) ActualLen;
                ((PFRS_NODE_HEADER) Buffer)->Type = 0;
            }
            return ERROR_SUCCESS;
        }

        //
        // Set the win32 error code and message string.
        //
        WStatus = FrsSetLastNTError(Status);

        //
        // If not enough buffer reallocate larger buffer.
        //
        if (WStatus == ERROR_INSUFFICIENT_BUFFER) {

            //
            // Reallocate the buffer for the security descriptor.
            //
            jerr = DbsReallocateFieldBuffer(TableCtx, SecDescx, BufNeeded, FALSE);

            if (!JET_SUCCESS(jerr)) {
                DPRINT_JS(0, "++ ERROR - DbsReallocateFieldBuffer failed.", jerr);
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            Buffer = (PSECURITY_DESCRIPTOR) JSetColumn[SecDescx].pvData;
            ((PFRS_NODE_HEADER) Buffer)->Size = (USHORT) BufNeeded;
            ((PFRS_NODE_HEADER) Buffer)->Type = 0;
            //
            // Get new buffer params and try again to get security information.
            //
            BufLen = BufNeeded;
            continue;
        }

        //
        // Check for ERROR_NO_SECURITY_ON_OBJECT and release the buffer so we
        // don't waste space in the database.
        //
        if (WStatus == ERROR_NO_SECURITY_ON_OBJECT) {
            DPRINT2(0, "++ ERROR - GetFileSecurity-3 (NO_SEC) Buflen: %d, Bufneeded: %d\n", BufLen, BufNeeded);

            //
            // Free the buffer and set the length to zero.
            //
            DbsReallocateFieldBuffer(TableCtx, SecDescx, 0, FALSE);

            return ERROR_SUCCESS;
        }

        //
        // Some other error.
        //
        DPRINT_WS(0, "++ ERROR - GetFileSecurity-4;", WStatus);
        return WStatus;
    }
}
#endif



PWCHAR
FrsGetFullPathByHandle(
    IN PWCHAR   Name,
    IN HANDLE   Handle
    )
/*++
Routine Description:
    Return a copy of the handle's full pathname. Free with FrsFree().

Arguments:
    Name
    Handle

Return Value:
    Return a copy of the handle's full pathname. Free with FrsFree().
--*/
{
#undef DEBSUB
#define DEBSUB "FrsGetFullPathByHandle"

    NTSTATUS          Status;
    IO_STATUS_BLOCK   IoStatusBlock;
    DWORD             BufferSize;
    PCHAR             Buffer;
    PWCHAR            RetFileName = NULL;
    CHAR              NameBuffer[sizeof(ULONG) + (sizeof(WCHAR)*(MAX_PATH+1))];
    PFILE_NAME_INFORMATION    FileName;

    if (!HANDLE_IS_VALID(Handle)) {
        return NULL;
    }

    BufferSize = sizeof(NameBuffer);
    Buffer = NameBuffer;

again:
    FileName = (PFILE_NAME_INFORMATION) Buffer;
    FileName->FileNameLength = BufferSize - (sizeof(ULONG) + sizeof(WCHAR));
    Status = NtQueryInformationFile(Handle,
                                    &IoStatusBlock,
                                    FileName,
                                    BufferSize - sizeof(WCHAR),
                                    FileNameInformation);
    if (NT_SUCCESS(Status) ) {
        FileName->FileName[FileName->FileNameLength/2] = UNICODE_NULL;
        RetFileName = FrsWcsDup(FileName->FileName);
    } else {
        //
        // Try a larger buffer
        //
        if (Status == STATUS_BUFFER_OVERFLOW) {
            DPRINT2(4, "++ Buffer size %d was too small for %ws\n",
                    BufferSize, Name);
            BufferSize = FileName->FileNameLength + sizeof(ULONG) + sizeof(WCHAR);
            if (Buffer != NameBuffer) {
                FrsFree(Buffer);
            }
            Buffer = FrsAlloc(BufferSize);
            DPRINT2(4, "++ Retrying with buffer size %d for %ws\n",
                    BufferSize, Name);
            goto again;
        }
        DPRINT1_NT(0, "++ NtQueryInformationFile - FileNameInformation failed.",
                   Name, Status);
    }

    //
    // A large buffer was allocated if the file's full
    // name could not fit into MAX_PATH chars.
    //
    if (Buffer != NameBuffer) {
        FrsFree(Buffer);
    }
    return RetFileName;
}


PWCHAR
FrsGetTrueFileNameByHandle(
    IN PWCHAR   Name,
    IN HANDLE   Handle,
    OUT PLONGLONG DirFileID
    )
/*++
Routine Description:
    Return a copy of the filename part associated with this handle.
    Free with FrsFree().

Arguments:
    Name
    Handle
    DirFileID - If non-null, return the parent File ID.

Return Value:
    Return a copy of the filename part associated with this handle.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsGetTrueFileNameByHandle"
    PWCHAR  Path;
    PWCHAR  File;
    ULONG   Len;

    Path = FrsGetFullPathByHandle(Name, Handle);
    if (!Path) {
        return NULL;
    }
    for (Len = wcslen(Path); Len && Path[Len] != L'\\'; --Len);
    File = FrsWcsDup(&Path[Len + 1]);
    FrsFree(Path);


    if (DirFileID != NULL) {
        FrsReadFileParentFid(Handle, DirFileID);
    }

    return File;
}




DWORD
FrsOpenFileRelativeByName(
    IN  HANDLE     VolumeHandle,
    IN  PULONGLONG FileReferenceNumber,
    IN  PWCHAR     FileName,
    IN  GUID       *ParentGuid,
    IN  GUID       *FileGuid,
    OUT HANDLE     *Handle
    )
/*++
Routine Description:

    Open the file specified by its true name using the FID for either
    a rename or delete installation. If the FID is null then use the
    Filename as given.

    FrsOpenFileRelativeByName(Coe->NewReplica->pVme->VolumeHandle,
                              &Coe->FileReferenceNumber, // or NULL
                              Coc->FileName,
                              &Coc->OldParentGuid,
                              &Coc->FileGuid
                              &Handle);
Arguments:

    VolumeHandle,        - handle to root of the drive
    FileReferenceNumber  - FID for the file in question (NULL if supplied
                           filename is valid)
    FileName,            - Filename
    *ParentGuid,         - ptr to the object ID for the file's parent dir.
    *FileGuid,           - ptr to the object ID for the file (for checking,
                           NULL if no check needed).
    *Handle              - Returned handle for open file.

Return Value:

    Handle and win32 status

--*/
{
#undef DEBSUB
#define DEBSUB "FrsOpenFileRelativeByName"

    PWCHAR                  TrueFileName;
    DWORD                   WStatus;

    *Handle = INVALID_HANDLE_VALUE;

    if (FileReferenceNumber != NULL) {
        //
        // Open the source file and get the current "True" File name.
        //
        WStatus = FrsOpenSourceFileById(Handle,
                                        NULL,
                                        NULL,
                                        VolumeHandle,
                                        FileReferenceNumber,
                                        FILE_ID_LENGTH,
//                                        READ_ACCESS,
                                        READ_ATTRIB_ACCESS,
                                        ID_OPTIONS,
                                        SHARE_ALL,
                                        FILE_OPEN);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT1_WS(4, "++ Couldn't open file %ws;", FileName, WStatus);
            return WStatus;
        }

        //
        // File's TrueFileName
        //
        TrueFileName = FrsGetTrueFileNameByHandle(FileName, *Handle, NULL);
        FRS_CLOSE(*Handle);

        if (TrueFileName == NULL) {
            DPRINT1(4, "++ Couldn't get base name for %ws\n", FileName);
            WIN_SET_FAIL(WStatus);
            return WStatus;
        }
    } else {
        TrueFileName = FileName;
    }

    //
    // Open the file relative to the parent using the true filename.
    //
    WStatus = FrsCreateFileRelativeById(Handle,
                                        VolumeHandle,
                                        ParentGuid,
                                        OBJECT_ID_LENGTH,
                                        FILE_ATTRIBUTE_NORMAL,
                                        TrueFileName,
                                        (USHORT)(wcslen(TrueFileName) * sizeof(WCHAR)),
                                        NULL,
                                        FILE_OPEN,
//                                        DELETE | READ_ACCESS | FILE_WRITE_ATTRIBUTES);
                                        DELETE | READ_ATTRIB_ACCESS | FILE_WRITE_ATTRIBUTES | FILE_LIST_DIRECTORY);


    if (FileReferenceNumber != NULL) {
        FrsFree(TrueFileName);
    }

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(4, "++ Couldn't open relative file %ws;", FileName, WStatus);
        return WStatus;
    }

    //
    // Get the file's oid and check it against the value supplied.
    //
    if (FileGuid != NULL) {
        WStatus = FrsCheckObjectId(FileName, *Handle, FileGuid);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT1_WS(0, "++ Object id mismatch for file %ws;", FileName, WStatus);
            FRS_CLOSE(*Handle);
        }
    }

    return WStatus;
}


DWORD
FrsDeleteFileRelativeByName(
    IN  HANDLE       VolumeHandle,
    IN  GUID         *ParentGuid,
    IN  PWCHAR       FileName,
    IN  PQHASH_TABLE FrsWriteFilter
    )
/*++
Routine Description:

    Delete the file or dir subtree specified by its name relative to
    the parent dir specified by its object ID (guid).

Arguments:

    VolumeHandle,  - handle to root of the drive
    *ParentGuid,   - ptr to the object ID for the file's parent dir.
    FileName,      - Filename
    FrsWriteFilter - Write filter to use for dampening (NULL if undampened).
                     e.g. Coe->NewReplica->pVme->FrsWriteFilter

Return Value:

    Win32 status

--*/
{
#undef DEBSUB
#define DEBSUB "FrsDeleteFileRelativeByName"

    DWORD   WStatus;
    HANDLE  Handle  = INVALID_HANDLE_VALUE;

    //
    // Open the file
    //
    WStatus = FrsOpenFileRelativeByName(VolumeHandle,
                                        NULL,
                                        FileName,
                                        ParentGuid,
                                        NULL,
                                        &Handle);

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(4, "++ Couldn't open file %ws for delete;", FileName, WStatus);
        //
        // File has already been deleted; done
        //
        if (WIN_NOT_FOUND(WStatus)) {
            DPRINT1(4, "++ %ws is already deleted\n", FileName);
            WStatus = ERROR_SUCCESS;
        }
        goto out;
    }
    //
    // Handles can be marked so that any usn records resulting from
    // operations on the handle will have the same "mark". In this
    // case, the mark is a bit in the SourceInfo field of the usn
    // record. The mark tells NtFrs to ignore the usn record during
    // recovery because this was a NtFrs generated change.
    //
    if (FrsWriteFilter) {
        WStatus = FrsMarkHandle(VolumeHandle, Handle);
        DPRINT1_WS(0, "++ WARN - FrsMarkHandle(%ws);", FileName, WStatus);
    }

    //
    // Reset the attributes that prevent deletion
    //
    WStatus = FrsResetAttributesForReplication(FileName, Handle);
    if (!WIN_SUCCESS(WStatus)) {
        goto out;
    }

    //
    // Mark the file for delete
    //
    WStatus = FrsDeleteByHandle(FileName, Handle);

    if (!WIN_SUCCESS(WStatus)) {
        //
        // If this was a non-empty dir then delete the subtree.
        //
        if (WStatus == ERROR_DIR_NOT_EMPTY) {

            WStatus = FrsEnumerateDirectory(Handle,
                                            FileName,
                                            0,
                                            ENUMERATE_DIRECTORY_FLAGS_NONE,
                                            NULL,
                                            FrsEnumerateDirectoryDeleteWorker);
        }

        WStatus = FrsDeleteByHandle(FileName, Handle);
    }

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, "++ Could not delete %ws;", FileName, WStatus);
        goto out;
    }

out:
    DPRINT2(5, "++ %s deleting %ws\n", (WIN_SUCCESS(WStatus)) ? "Success" : "Failure",
           FileName);

    //
    // If the file was marked for delete, this close will delete it
    //
    if (HANDLE_IS_VALID(Handle)) {
        if (FrsWriteFilter != NULL) {
            FrsCloseWithUsnDampening(FileName, &Handle, FrsWriteFilter, NULL);
        } else {
            FRS_CLOSE(Handle);
        }
    }
    return WStatus;
}


DWORD
FrsDeletePath(
    IN  PWCHAR  Path,
    IN  DWORD   DirectoryFlags
    )
/*++
Routine Description:

    Delete the file or dir subtree specified by its path

    WARN: Does not dampen the operations. To be safe, the replica
    set should not exist or the directory should be filtered.
    Otherwise, the deletes might replicate.

Arguments:

    Path            - Path of file system object
    DirectoryFlags  - See tablefcn.h, ENUMERATE_DIRECTORY_FLAGS_

Return Value:

    Win32 status

--*/
{
#undef DEBSUB
#define DEBSUB "FrsDeletePath"
    DWORD       WStatus;
    HANDLE      Handle  = INVALID_HANDLE_VALUE;
    FILE_NETWORK_OPEN_INFORMATION FileInfo;

    //
    // Open the file
    //
    WStatus = FrsOpenSourceFileW(&Handle,
                                 Path,
//                                 DELETE | READ_ACCESS | FILE_WRITE_ATTRIBUTES,
                                 DELETE | READ_ATTRIB_ACCESS | FILE_WRITE_ATTRIBUTES | FILE_LIST_DIRECTORY,
                                 OPEN_OPTIONS);
    if (WIN_NOT_FOUND(WStatus)) {
        CLEANUP1_WS(1, "++ WARN - FrsOpenSourceFile(%ws); (IGNORED);",
                   Path, WStatus, RETURN_SUCCESS);
    }

    CLEANUP1_WS(0, "++ ERROR - FrsOpenSourceFile(%ws);", Path, WStatus, CLEANUP);

    //
    // Get the file's attributes
    //
    if (!FrsGetFileInfoByHandle(Path, Handle, &FileInfo)) {
        DPRINT1(1, "++ WARN - Can't get attributes for %ws\n", Path);
        WIN_SET_FAIL(WStatus);
        goto CLEANUP;
    }

    //
    // Don't delete the file if DIRECTORIES_ONLY is set
    //
    if (DirectoryFlags & ENUMERATE_DIRECTORY_FLAGS_DIRECTORIES_ONLY &&
        !(FileInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        WStatus = ERROR_DIRECTORY;
        goto CLEANUP;
    }

    //
    // Reset the attributes that prevent deletion
    //
    if (FileInfo.FileAttributes & NOREPL_ATTRIBUTES) {
        DPRINT1(5, "++ Reseting attributes for %ws for delete\n", Path);
        WStatus = FrsSetFileAttributes(Path, Handle,
                                       FileInfo.FileAttributes &
                                       ~NOREPL_ATTRIBUTES);
        CLEANUP1_WS(0, "++ ERROR: - Can't reset attributes for %ws for delete", Path, WStatus, CLEANUP);

        DPRINT1(5, "++ Attributes for %ws now allow deletion\n", Path);
    }

    //
    // Mark the file for delete
    //
    WStatus = FrsDeleteByHandle(Path, Handle);

    if (!WIN_SUCCESS(WStatus)) {
        //
        // If this was a non-empty dir then delete the subtree.
        //
        if (WStatus == ERROR_DIR_NOT_EMPTY) {
            WStatus = FrsEnumerateDirectory(Handle,
                                            Path,
                                            0,
                                            DirectoryFlags,
                                            NULL,
                                            FrsEnumerateDirectoryDeleteWorker);
        }

        WStatus = FrsDeleteByHandle(Path, Handle);
    }

    DPRINT1_WS(0, "++ ERROR - Could not delete %ws;", Path, WStatus);

CLEANUP:
    DPRINT2(5, "++ %s deleting %ws\n",
           (WIN_SUCCESS(WStatus)) ? "Success" : "Failure", Path);

    FRS_CLOSE(Handle);
    return WStatus;

RETURN_SUCCESS:
    WStatus = ERROR_SUCCESS;
    goto CLEANUP;
}


DWORD
FrsDeleteDirectoryContents(
    IN  PWCHAR  Path,
    IN DWORD    DirectoryFlags
    )
/*++
Routine Description:

    Delete the contents of the directory Path

Arguments:

    Path            - Path of file system object
    DirectoryFlags  - See tablefcn.h, ENUMERATE_DIRECTORY_FLAGS_

Return Value:

    Win32 status

--*/
{
#undef DEBSUB
#define DEBSUB "FrsDeleteDirectoryContents"
    DWORD       WStatus;
    HANDLE      Handle  = INVALID_HANDLE_VALUE;

    //
    // Open the file
    //
    WStatus = FrsOpenSourceFileW(&Handle, Path,
//                                 READ_ACCESS,
                                 READ_ATTRIB_ACCESS | FILE_LIST_DIRECTORY,
                                 OPEN_OPTIONS);
    if (WIN_NOT_FOUND(WStatus)) {
        CLEANUP1_WS(1, "++ WARN - FrsOpenSourceFile(%ws); (IGNORED);",
                   Path, WStatus, RETURN_SUCCESS);
    }
    CLEANUP1_WS(0, "++ ERROR - FrsOpenSourceFile(%ws);", Path, WStatus, CLEANUP);

    WStatus = FrsEnumerateDirectory(Handle,
                                    Path,
                                    0,
                                    DirectoryFlags,
                                    NULL,
                                    FrsEnumerateDirectoryDeleteWorker);

    CLEANUP1_WS(0, "++ ERROR - Could not delete contents of %ws;",
                Path, WStatus, CLEANUP);

CLEANUP:
    DPRINT2(5, "++ %s deleting contents of %ws\n",
           (WIN_SUCCESS(WStatus)) ? "Success" : "Failure", Path);

    FRS_CLOSE(Handle);
    return WStatus;

RETURN_SUCCESS:
    WStatus = ERROR_SUCCESS;
    goto CLEANUP;
}


DWORD
FrsOpenBaseNameForInstall(
    IN  PCHANGE_ORDER_ENTRY Coe,
    OUT HANDLE              *Handle
    )
/*++
Routine Description:

    Open the file specified by Coe by its relative name for either
    a rename or delete installation.

    Note that it is possible for the file to have been moved to a new parent
    dir by a previous remote CO or a local CO, making the OldParentGuid in the
    Change Order invalid.  First we try to find the file under the OldParentGuid
    in the CO and then we try by the parent Guid in the IDTable.  We check for
    a match by comparing with the file GUID in the change order.

    It is also possible that the file has been renamed to a point outside the
    replica tree so even if we find it by FID we still can't do anything to it.
    When we fail to find the file in either of the above directories we force this
    CO thru retry, expecting another CO behind us to get processed and update
    the parent guid in the IDTable or maybe mark the file as deleted.

Arguments:
    Coe
    Handle

Return Value:
    Handle and win status
--*/
{
#undef DEBSUB
#define DEBSUB "FrsOpenBaseNameForInstall"

    LONGLONG                ParentFid;
    PWCHAR                  FileName;
    DWORD                   WStatus;
    PCHANGE_ORDER_COMMAND   Coc = &Coe->Cmd;
    PIDTABLE_RECORD         IDTableRec;
    BOOLEAN                 UseActualLocation = FALSE;


    ParentFid = QUADZERO;
    *Handle = INVALID_HANDLE_VALUE;

    //
    // Open the source file
    //
    WStatus = FrsOpenSourceFileById(Handle,
                                    NULL,
                                    NULL,
                                    Coe->NewReplica->pVme->VolumeHandle,
                                    &Coe->FileReferenceNumber,
                                    FILE_ID_LENGTH,
//                                    READ_ACCESS,
                                    READ_ATTRIB_ACCESS,
                                    ID_OPTIONS,
                                    SHARE_ALL,
                                    FILE_OPEN);
    if (!WIN_SUCCESS(WStatus)) {
        CHANGE_ORDER_TRACEW(3, Coe, "File open by FID failed", WStatus);
        return WStatus;
    }

    //
    // Get the File's true on-disk filename and the true parent FID.
    //
    FileName = FrsGetTrueFileNameByHandle(Coc->FileName, *Handle, &ParentFid);
    FRS_CLOSE(*Handle);

    if (FileName == NULL) {
        CHANGE_ORDER_TRACE(3, Coe, "Failed to get file base name");
        return ERROR_FILE_NOT_FOUND;
    }

    //
    // Open the file relative to the parent using the true filename.
    //
    WStatus = FrsCreateFileRelativeById(Handle,
                                        Coe->NewReplica->pVme->VolumeHandle,
                                        &Coc->OldParentGuid,
                                        OBJECT_ID_LENGTH,
                                        FILE_ATTRIBUTE_NORMAL,
                                        FileName,
                                        (USHORT)(wcslen(FileName) * sizeof(WCHAR)),
                                        NULL,
                                        FILE_OPEN,
//                                        DELETE | READ_ACCESS | FILE_WRITE_ATTRIBUTES);
                                        DELETE | READ_ATTRIB_ACCESS | FILE_WRITE_ATTRIBUTES | FILE_LIST_DIRECTORY);

    if (WIN_SUCCESS(WStatus)) {
        //
        // Get the file's oid and check it against the change order.  Need to
        // do this to cover the case of a rename of the file to a different
        // parent dir followed by a create of a file with the same name.
        // If this occurred the above open would succeed.
        //
        WStatus = FrsCheckObjectId(Coc->FileName, *Handle, &Coc->FileGuid);
        if (WIN_SUCCESS(WStatus)) {
            goto RETURN;
        }

        CHANGE_ORDER_TRACE(3, Coe, "File OID mismatch CO, after Coc->OldParentGuid open");

        FRS_CLOSE(*Handle);
    } else {
        CHANGE_ORDER_TRACEW(3, Coe, "File open failed under Coc->OldParentGuid", WStatus);
    }

    //
    // We did not find the file using the True Name from the file and the
    // Old parent Guid from the change order.  The file may have been moved
    // by a previous remote CO or a Local CO.  Try the Parent Guid in the
    // IDTable record.
    //
    FRS_ASSERT(Coe->RtCtx != NULL);
    FRS_ASSERT(IS_ID_TABLE(&Coe->RtCtx->IDTable));

    IDTableRec = Coe->RtCtx->IDTable.pDataRecord;
    FRS_ASSERT(IDTableRec != NULL);

    WStatus = FrsCreateFileRelativeById(Handle,
                                        Coe->NewReplica->pVme->VolumeHandle,
                                        &IDTableRec->ParentGuid,
                                        OBJECT_ID_LENGTH,
                                        FILE_ATTRIBUTE_NORMAL,
                                        FileName,
                                        (USHORT)(wcslen(FileName) * sizeof(WCHAR)),
                                        NULL,
                                        FILE_OPEN,
//                                        DELETE | READ_ACCESS | FILE_WRITE_ATTRIBUTES);
                                        DELETE | READ_ATTRIB_ACCESS | FILE_WRITE_ATTRIBUTES | FILE_LIST_DIRECTORY);

    if (WIN_SUCCESS(WStatus)) {
        //
        // Get the file's oid and check it against the change order.
        //
        WStatus = FrsCheckObjectId(Coc->FileName, *Handle, &Coc->FileGuid);
        if (WIN_SUCCESS(WStatus)) {
            goto RETURN;
        }

        CHANGE_ORDER_TRACE(3, Coe, "File OID mismatch CO, after IDTableRec->ParentGuid");

        FRS_CLOSE(*Handle);
    } else {
        CHANGE_ORDER_TRACEW(3, Coe, "File open failed under IDTableRec->ParentGuid", WStatus);
    }

    //
    // If this is a delete change order then we may have a problem if the file
    // has been moved to a different parent dir by a local file operation.
    // The local change order that did this can be rejected if the remote
    // CO delete is processed first so the local co fails reconcile. But the
    // ondisk rename has been completed and when the remote CO delete tries to
    // delete the file it may not be in either the parent dir from the remote
    // CO or the parent dir from the IDTable.  To cover this case we find the
    // TRUE parent dir and check to see if the file is still in the replica tree.
    // If it is then we delete it using the TRUE parent dir.  IF it isn't then
    // return success since the file is already outside the tree.
    // Note that a sharing conflict on the target file can block the delete
    // for an extended period of time so the timing window in which this can
    // occur can be pretty wide.
    //

    //
    // We also need to deal with the case where a new file is still sitting in 
    // the preinstall directory (and the CO is in install_rename_retry.)
    // In that case we will have failed to find the file under the old parent from 
    // the CO or under the parent listed in the IDTable.
    //
    
    if (DOES_CO_DELETE_FILE_NAME(Coc)) {
        if (JrnlIsChangeOrderInReplica(Coe, &ParentFid)) {
	    UseActualLocation = TRUE;
	} else {
	    //
	    // File not in the replica tree any more so tell the caller.
	    //
	    WStatus = ERROR_FILE_NOT_FOUND;
	    goto RETURN;
	}
    }

    if(ParentFid == Coe->NewReplica->PreInstallFid) {
	UseActualLocation = TRUE;
    }
    
    if (UseActualLocation) {

	WStatus = FrsCreateFileRelativeById(Handle,
					    Coe->NewReplica->pVme->VolumeHandle,
					    &ParentFid,
					    FILE_ID_LENGTH,
					    FILE_ATTRIBUTE_NORMAL,
					    FileName,
					    (USHORT)(wcslen(FileName) * sizeof(WCHAR)),
					    NULL,
					    FILE_OPEN,
//                                                DELETE | READ_ACCESS | FILE_WRITE_ATTRIBUTES);
					    DELETE | READ_ATTRIB_ACCESS | FILE_WRITE_ATTRIBUTES | FILE_LIST_DIRECTORY);
	if (WIN_SUCCESS(WStatus)) {
	    //
	    // Get the file's oid and check it against the change order.
	    //
	    WStatus = FrsCheckObjectId(Coc->FileName, *Handle, &Coc->FileGuid);
	    if (WIN_SUCCESS(WStatus)) {
		goto RETURN;
	    }

	    CHANGE_ORDER_TRACE(3, Coe, "File OID mismatch with CO after TRUE ParentFid open");

	    FRS_CLOSE(*Handle);
	} else {
	    CHANGE_ORDER_TRACEW(3, Coe, "File open failed under True Parent FID", WStatus);
	}
    }

    //
    // The file is there but not where we expected it to be so send this CO
    // through retry to let a subsequent Local CO get processed and update the
    // IDTable.
    //
    WStatus = ERROR_RETRY;


RETURN:


    CHANGE_ORDER_TRACEW(3, Coe, "Base File open", WStatus);

    FrsFree(FileName);

    return WStatus;
}


DWORD
FrsDeleteById(
    IN PWCHAR                   VolumeName,
    IN PWCHAR                   Name,
    IN PVOLUME_MONITOR_ENTRY    pVme,
    IN  PVOID                   Id,
    IN  DWORD                   IdLen
    )
/*++
Routine Description:
    Delete the file represented by Id

Arguments:
    VolumeName - corresponding to pVme

    Name - For error messages

    pVme - volume entry

    Id - Represents the name of the file or directory to be opened.

    IdLen - length of Id (Fid or Oid)

Return Value:
    Handle and win status
--*/
{
#undef DEBSUB
#define DEBSUB "FrsDeleteById"
    DWORD   WStatus;
    HANDLE  Handle = INVALID_HANDLE_VALUE;
    PWCHAR  Path = NULL;
    PWCHAR  FullPath = NULL;

    DPRINT1(5, "++ Deleting %ws by id\n", Name);

    //
    // Open the source file
    //
    WStatus = FrsOpenSourceFileById(&Handle,
                                    NULL,
                                    NULL,
                                    pVme->VolumeHandle,
                                    Id,
                                    IdLen,
//                                    READ_ACCESS,
                                    READ_ATTRIB_ACCESS,
                                    ID_OPTIONS,
                                    SHARE_ALL,
                                    FILE_OPEN);
    CLEANUP1_WS(4, "++ ERROR - FrsOpenSourceFileById(%ws);", Name, WStatus, CLEANUP);

    //
    // File's relative pathname
    //
    Path = FrsGetFullPathByHandle(Name, Handle);
    if (Path) {
        FullPath = FrsWcsCat(VolumeName, Path);
    }
    FRS_CLOSE(Handle);

    if (FullPath == NULL) {
        DPRINT1(4, "++ ERROR - FrsGetFullPathByHandle(%ws)\n", Name);
        WIN_SET_FAIL(WStatus);
        goto CLEANUP;
    }

    //
    // Open the file relative to the parent using the true filename.
    //
    WStatus = FrsOpenSourceFileW(&Handle,
                                FullPath,
//                                DELETE | READ_ACCESS | FILE_WRITE_ATTRIBUTES,
                                DELETE | READ_ATTRIB_ACCESS | FILE_WRITE_ATTRIBUTES,
                                OPEN_OPTIONS);
    CLEANUP2_WS(4, "++ ERROR - FrsOpenSourceFile(%ws -> %ws);",
                Name, FullPath, WStatus, CLEANUP);

    //
    // Handles can be marked so that any usn records resulting from
    // operations on the handle will have the same "mark". In this
    // case, the mark is a bit in the SourceInfo field of the usn
    // record. The mark tells NtFrs to ignore the usn record during
    // recovery because this was a NtFrs generated change.
    //
    WStatus = FrsMarkHandle(pVme->VolumeHandle, Handle);
    CLEANUP1_WS(0, "++ WARN - FrsMarkHandle(%ws);", Name, WStatus, RETURN_SUCCESS);

    //
    // Get the file's oid and check it against the id
    //
    if (IdLen == OBJECT_ID_LENGTH) {
        WStatus = FrsCheckObjectId(Name, Handle, Id);
        CLEANUP1_WS(4, "++ ERROR - FrsCheckObjectId(%ws);", Name, WStatus, CLEANUP);
    }

    WStatus = FrsResetAttributesForReplication(FullPath, Handle);
    DPRINT1_WS(4, "++ ERROR - FrsResetAttributesForReplication(%ws):", FullPath, WStatus);

    WStatus = FrsDeleteByHandle(Name, Handle);
    FrsCloseWithUsnDampening(Name, &Handle, pVme->FrsWriteFilter, NULL);
    CLEANUP1_WS(4, "++ ERROR - FrsDeleteByHandle(%ws);", Name, WStatus, CLEANUP);


CLEANUP:
    FRS_CLOSE(Handle);

    FrsFree(Path);
    FrsFree(FullPath);

    return WStatus;

RETURN_SUCCESS:
    WStatus = ERROR_SUCCESS;
    goto CLEANUP;
}


BOOL
FrsCloseWithUsnDampening(
    IN     PWCHAR       Name,
    IN OUT PHANDLE      Handle,
    IN     PQHASH_TABLE FrsWriteFilter,
    OUT    USN          *RetUsn
    )
/*++

Routine Description:

    Close the handle after insuring that any modifications made to the
    file will not generate change orders.

Arguments:

    Name - File name for error messages.

    Handle - Handle to the replica set file file being closed. Nop if
             INVALID_HANDLE_VALUE.

    Replica - ptr to Replica struct where this file was written.
              This gets us to the volume write filter table to record the USN.

    RetUsn - ptr to return location for the close USN.  NULL if not requested.

Return Value:
    TRUE  - handle is closed and any changes where dampened
    FALSE - handle is closed but replication was *not* dampened
--*/
{
#undef DEBSUB
#define DEBSUB "FrsCloseWithUsnDampening"

    DWORD   BytesReturned = 0;
    USN     Usn = 0;
    ULONG   GStatus;
    BOOL    RetStatus;

    RetStatus = TRUE;

    if (!HANDLE_IS_VALID(*Handle)) {
        return TRUE;
    }

    //
    // Get the lock on the Usn Write Filter table.
    // We have to get this before the FSCTL_WRITE_USN_CLOSE_RECORD call
    // which will generate the journal close record. THis closes the
    // race between our subsequent update of the WriteFilter below
    // and the journal thread that processes the USN close record.
    //
    QHashAcquireLock(FrsWriteFilter);

    //
    // Close the file and force out the journal close record now.  This
    // call returns the USN of the generated close record so we can filter
    // it out of the journal record stream.
    //
    if (!DeviceIoControl(*Handle,
                         FSCTL_WRITE_USN_CLOSE_RECORD,
                         NULL, 0,
                         &Usn, sizeof(USN),
                         &BytesReturned, NULL)) {
        //
        // Access denied is returned if there is another open
        //
        if (GetLastError() != ERROR_ACCESS_DENIED) {
            DPRINT1_WS(0, "++ Can't dampen replication on %ws;", Name, GetLastError());
        } else {
            DPRINT1(0, "++ Can't dampen %ws; access denied\n", Name);
        }
        RetStatus = FALSE;
    }

    RetStatus = RetStatus && (BytesReturned == sizeof(USN));

    if (RetStatus) {
        //
        // Put the USN in the FrsWriteFilter table for the replica so we
        // can ignore it and the drop the lock on the table.
        //
        GStatus = QHashInsert(FrsWriteFilter, &Usn, &Usn, 0, TRUE);
        QHashReleaseLock(FrsWriteFilter);

        if (GStatus != GHT_STATUS_SUCCESS ) {
            DPRINT1(0, "++ QHashInsert error: %d\n", GStatus);
            RetStatus = FALSE;
        }

    } else {
        QHashReleaseLock(FrsWriteFilter);
    }

    //
    // Return the close USN.
    //
    if (RetUsn != NULL) {
        *RetUsn = Usn;
    }

    //
    // Now do the normal close to release the handle.  NTFS completed its
    // close work above.
    //
    FRS_CLOSE(*Handle);

    DPRINT2(5, "++ Dampening %s on %ws\n", (RetStatus) ? "Succeeded" : "Failed", Name);

    return RetStatus;
}


VOID
ProcessOpenByIdStatus(
    IN HANDLE   Handle,
    IN ULONG    NtStatus,
    IN PVOID    ObjectId,
    IN ULONG    Length
    )
/*++

Routine Description:

    Print the results of an open-by-id.

Arguments:

    NtStatus
    ObjectId
    Length

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "ProcessOpenByIdStatus:"

    CHAR              GuidStr[GUID_CHAR_LEN];
    PWCHAR            Path;

    if (!NT_SUCCESS(NtStatus)) {
        //
        // Note:  The following call seems to generate intermittant AVs in the
        // symbol lookup code.  Only include it for testing.
        //
        //STACK_TRACE_AND_PRINT(2);

        if (Length == FILE_ID_LENGTH) {
            DPRINT2_NT(1, "++ %08X %08X Fid Open failed;",
                       *((PULONG)ObjectId+1), *(PULONG)ObjectId, NtStatus);
        } else {
            GuidToStr((GUID *) ObjectId, GuidStr);
            DPRINT1_NT(1, "++ %s ObjectId Open failed;", GuidStr, NtStatus);
        }

        return;
    }

    //
    // Open succeeded.
    //
    if (Length == FILE_ID_LENGTH) {
        DPRINT2(4,"++ %08X %08X Fid Opened succesfully\n",
                *((PULONG)ObjectId+1), *((PULONG)ObjectId));
    } else {
        GuidToStr((GUID *) ObjectId, GuidStr);
        DPRINT1(4, "++ %s ObjectId Opened succesfully\n", GuidStr);
    }

    if (DoDebug(4, DEBSUB)) {
        Path = FrsGetFullPathByHandle(L"Unknown", Handle);
        if (Path) {
            DPRINT1(4, "++ Filename is: %ws\n", Path);
        }
        FrsFree(Path);
    }
}


DWORD
FrsForceOpenId(
    OUT PHANDLE                 Handle,
    IN OUT OVERLAPPED           *OpLock, OPTIONAL
    IN  PVOLUME_MONITOR_ENTRY   pVme,
    IN  PVOID                   Id,
    IN  DWORD                   IdLen,
    IN  ACCESS_MASK             DesiredAccess,
    IN  ULONG                   CreateOptions,
    IN  ULONG                   ShareMode,
    IN  ULONG                   CreateDisposition
    )
/*++

Routine Description:

    Open the file for the desired access. If the open fails, reset
    the readonly/system/hidden attributes and retry. In any case,
    make sure the attributes are reset to their original value
    before returning.

Arguments:

    Handle - Returns the file handle.

    OpLock - Overlapped struct for an oplock (optional).

    pVme - volume entry

    Id - Represents the name of the file or directory to be opened.

    IdLen - length of Id (Fid or Oid)

    DesiredAccess - see replutil.h for defined access modes (xxx_ACCESS)

    CreateOptions - see replutil.h for defined options (xxx_OPTIONS

    ShareMode   - standard share modes defined in sdk

    CreateDisposition - E.g., FILE_OPEN or FILE_OVERWRITE

Return Value:

    Win error status.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsForceOpenId:"

    HANDLE      AttrHandle;
    ULONG       WStatus, WStatus1;
    ULONG       AttrWStatus;
    FILE_NETWORK_OPEN_INFORMATION  FileNetworkOpenInfo;

    DPRINT2(5, "++ Attempting to force open Id %08x %08x (%d bytes)\n",
            PRINTQUAD((*(PULONGLONG)Id)), IdLen);

    //
    // Open the file
    //
    WStatus = FrsOpenSourceFileById(Handle,
                                    NULL,
                                    OpLock,
                                    pVme->VolumeHandle,
                                    Id,
                                    IdLen,
                                    DesiredAccess,
                                    CreateOptions,
                                    ShareMode,
                                    CreateDisposition);
    //
    // File has been opened successfully
    //
    if (WIN_SUCCESS(WStatus)) {
        DPRINT2(5, "++ Successfully opened Id %08x %08x (%d)\n",
                PRINTQUAD((*(PULONGLONG)Id)), IdLen);
        return WStatus;
    }

    //
    // File has been deleted; done
    //
    if (WIN_NOT_FOUND(WStatus)) {
        DPRINT2(4, "++ Id %08x %08x (%d) not found\n",
                PRINTQUAD((*(PULONGLONG)Id)), IdLen);
        return WStatus;
    }

    //
    // Not an attribute problem
    //
    if (!WIN_ACCESS_DENIED(WStatus)) {
        DPRINT2_WS(4, "++ Open Id %08x %08x (%d) failed;",
               PRINTQUAD((*(PULONGLONG)Id)), IdLen, WStatus);
        return WStatus;
    }

    //
    // Attempt to reset attributes (e.g., reset readonly)
    //
    AttrWStatus = FrsOpenSourceFileById(&AttrHandle,
                                        &FileNetworkOpenInfo,
                                        NULL,
                                        pVme->VolumeHandle,
                                        Id,
                                        IdLen,
//                                        READ_ACCESS | FILE_WRITE_ATTRIBUTES,
//                                        STANDARD_RIGHTS_READ | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | ACCESS_SYSTEM_SECURITY | SYNCHRONIZE,
                                        READ_ATTRIB_ACCESS | WRITE_ATTRIB_ACCESS,
                                        CreateOptions,
                                        SHARE_ALL,
                                        FILE_OPEN);
    //
    // Couldn't open the file for write-attribute access
    //
    if (!WIN_SUCCESS(AttrWStatus)) {
        DPRINT2_WS(4, "++ Open Id %08x %08x (%d) for minimal access failed;",
                   PRINTQUAD((*(PULONGLONG)Id)), IdLen, WStatus);
        return WStatus;
    }
    //
    // Handles can be marked so that any usn records resulting from
    // operations on the handle will have the same "mark". In this
    // case, the mark is a bit in the SourceInfo field of the usn
    // record. The mark tells NtFrs to ignore the usn record during
    // recovery because this was a NtFrs generated change.
    //
    WStatus1 = FrsMarkHandle(pVme->VolumeHandle, AttrHandle);
    DPRINT1_WS(0, "++ WARN - FrsMarkHandle(%08x %08x);",
               PRINTQUAD((*(PULONGLONG)Id)), WStatus1);

    //
    // The file's attributes are not preventing the open; done
    //
    if (!(FileNetworkOpenInfo.FileAttributes & NOREPL_ATTRIBUTES)) {
        DPRINT2_WS(4, "++ Id %08x %08x (%d)attributes not preventing open;",
                   PRINTQUAD((*(PULONGLONG)Id)), IdLen, WStatus);
        FRS_CLOSE(AttrHandle);
        return WStatus;
    }

    //
    // Reset the attributes
    //
    WStatus1 = FrsSetFileAttributes(L"<unknown>",
                              AttrHandle,
                              FileNetworkOpenInfo.FileAttributes &
                              ~NOREPL_ATTRIBUTES);
    if (!WIN_SUCCESS(WStatus1)) {
        DPRINT2_WS(4, "++ Can't reset attributes for Id %08x %08x (%d);",
                   PRINTQUAD((*(PULONGLONG)Id)), IdLen, WStatus1);
        FRS_CLOSE(AttrHandle);
        return WStatus1;
    }
    //
    // Try to open the file again
    //
    WStatus = FrsOpenSourceFileById(Handle,
                                    NULL,
                                    NULL,
                                    pVme->VolumeHandle,
                                    Id,
                                    IdLen,
                                    DesiredAccess,
                                    CreateOptions,
                                    SHARE_ALL,
                                    CreateDisposition);
    //
    // Reset the original attributes
    //
    WStatus1 = FrsSetFileAttributes(L"<unknown>",
                              AttrHandle,
                              FileNetworkOpenInfo.FileAttributes);
    if (!WIN_SUCCESS(WStatus1)) {
        DPRINT2_WS(0, "++ ERROR - Can't set attributes for Id %08x %08x (%d);",
                   PRINTQUAD((*(PULONGLONG)Id)), IdLen, WStatus1);
    }
    //
    // Close the handle that we used to set and reset attributes
    //

    FRS_CLOSE(AttrHandle);


    DPRINT3(4, "++ Force open %08x %08x (%d) %s WITH SHARE ALL!\n",
            PRINTQUAD((*(PULONGLONG)Id)), IdLen,
            WIN_SUCCESS(WStatus) ? "Succeeded" : "Failed");

    return (WStatus);
}


DWORD
FrsOpenSourceFileById(
    OUT PHANDLE Handle,
    OUT PFILE_NETWORK_OPEN_INFORMATION  FileOpenInfo,
    OUT OVERLAPPED  *OpLock,
    IN  HANDLE      VolumeHandle,
    IN  PVOID       ObjectId,
    IN  ULONG       Length,
    IN  ACCESS_MASK DesiredAccess,
    IN  ULONG       CreateOptions,
    IN  ULONG       ShareMode,
    IN  ULONG       CreateDisposition
    )
/*++

Routine Description:

    This function opens the specified file by File ID or Object ID.
    If the length is 8 perform a relative open using the file ID and the
    volume handle passed in the VolumeHandle arg.  If the length is 16
    perform an object ID relative open using the volume handle.

Arguments:

    Handle - Returns the file handle.

    FileOpenInfo - If non-NULL, returns the FILE_NETWORK_OPEN_INFORMATION data.

    OpLock - If non-NULL, the caller desires an oplock

    VolumeHandle - The handle for a FileID based relative open.

    ObjectId - Represents the name of the file or directory to be opened.

    Length -  8 for file IDs and 16 for object IDs.

    DesiredAccess - see replutil.h for defined access modes (xxx_ACCESS)

    CreateOptions - see replutil.h for defined options (xxx_OPTIONS

    ShareMode   - standard share modes defined in sdk

    CreateDisposition - E.g., FILE_OPEN or FILE_OVERWRITE

Return Value:

    Win error status.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsOpenSourceFileById:"

    ULONG               Ignored;
    NTSTATUS            NtStatus;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    UNICODE_STRING      str;

    FRS_ASSERT(HANDLE_IS_VALID(VolumeHandle));
    FRS_ASSERT(Length == OBJECT_ID_LENGTH || Length == FILE_ID_LENGTH);

    *Handle = INVALID_HANDLE_VALUE;

    //
    // Object attributes (e.g., the file's fid or oid
    //
    str.Length = (USHORT)Length;
    str.MaximumLength = (USHORT)Length;
    str.Buffer = ObjectId;
    InitializeObjectAttributes(&ObjectAttributes,
                               &str,
                               OBJ_CASE_INSENSITIVE,
                               VolumeHandle,
                               NULL);
    //
    // Optional oplock
    //
    if (OpLock != NULL) {
        ZeroMemory(OpLock, sizeof(OVERLAPPED));
        OpLock->hEvent = FrsCreateEvent(TRUE, FALSE);
        CreateOptions &= ~FILE_SYNCHRONOUS_IO_NONALERT;
    }

    NtStatus = NtCreateFile(Handle,
                            DesiredAccess,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            NULL,
                            FILE_ATTRIBUTE_NORMAL,
                            ShareMode,
                            CreateDisposition,
                            CreateOptions,
                            NULL,
                            0);
    //
    // Apply oplock if requested
    //
    if (NT_SUCCESS(NtStatus) && OpLock) {
        if (!DeviceIoControl(*Handle,
                             FSCTL_REQUEST_FILTER_OPLOCK,
                             NULL,
                             0,
                             NULL,
                             0,
                             &Ignored,
                             OpLock)) {
            if (GetLastError() != ERROR_IO_PENDING) {
                DPRINT_WS(3, "++ WARN: Can't get oplock;", GetLastError());
                //
                // Cleanup the handles
                //
                FRS_CLOSE(OpLock->hEvent);
            }
        }
    }

    //
    // Report status
    //
    ProcessOpenByIdStatus(*Handle, NtStatus, ObjectId, Length);

    //
    // Couldn't open; return status
    //
    if (!NT_SUCCESS(NtStatus) ) {
        *Handle = INVALID_HANDLE_VALUE;
        DPRINT_NT(0, "++ ERROR - NtCreateFile failed :", NtStatus);
        return FrsSetLastNTError(NtStatus);
    }

    //
    // Return some file info and the file handle.
    //
    if (FileOpenInfo) {
        NtStatus = NtQueryInformationFile(*Handle,
                                          &IoStatusBlock,
                                          FileOpenInfo,
                                          sizeof(FILE_NETWORK_OPEN_INFORMATION),
                                          FileNetworkOpenInformation);
        if (!NT_SUCCESS(NtStatus) ) {
            //
            // Cleanup the handles
            //
            DPRINT_NT(0, "++ NtQueryInformationFile - FileNetworkOpenInformation failed:", NtStatus);
            FRS_CLOSE(*Handle);
            if (OpLock != NULL) {
                FRS_CLOSE(OpLock->hEvent);
            }

            return FrsSetLastNTError(NtStatus);
        }
    }
    return FrsSetLastNTError(NtStatus);
}



DWORD
FrsCreateFileRelativeById(
    OUT PHANDLE         Handle,
    IN  HANDLE          VolumeHandle,
    IN  PVOID           ParentObjectId,
    IN  ULONG           OidLength,
    IN  ULONG           FileCreateAttributes,
    IN  PWCHAR          BaseFileName,
    IN  USHORT          FileNameLen,
    IN  PLARGE_INTEGER  AllocationSize,
    IN  ULONG           CreateDisposition,
    IN  ACCESS_MASK     DesiredAccess
    )
/*++

Routine Description:

    This function creates a new file in the directory specified by the parent
    file object ID. It does a replative open of the parent using the volume
    handle provided.  Then it does a relative open of the target file using
    the parent handle and the file name.

    If the length is 8 perform a relative open using the file ID and the
    volume handle passed in the VolumeHandle arg.  If the length is 16
    perform an object ID relative open using the volume handle.

    The file attributes parameter is used to decide if the create is a
    file or a directory.

Arguments:

    Handle - Returns the file handle.

    VolumeHandle - The handle for a ID based relative open.

    ParentObjectId - The object or file id of the parent directory.  If NULL
                     open the file relative to the Volume Handle.

    OidLength -  8 for file IDs and 16 for object IDs. (len of parent oid)

    FileCreateAttributes - Initial File Create Attributes

    BaseFileName - ptr to NULL terminated file name

    FileNameLen - File name length (not incl the null) in bytes.

    AllocationSize - The allocation size for the file.

    CreateDisposition - E.g., FILE_CREATE or FILE_OPEN

    DesiredAccess - Access rights

Return Value:

    WIN32 error status.  Use GetLastError() to get the win32 error code.


    If the file already exsists the Win32 error return is ERROR_ALREADY_EXISTS.
    The NT error status is STATUS_OBJECT_NAME_COLLISION.


--*/
{
#undef DEBSUB
#define DEBSUB "FrsCreateFileRelativeById:"


    UNICODE_STRING    UStr;

    DWORD             WStatus;
    NTSTATUS          NtStatus;
    NTSTATUS          NtStatus2;
    HANDLE            File, DirHandle;
    ULONG             ShareMode;
    ULONG             CreateOptions;
    ULONG             EaSize;

    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;

    PFILE_FULL_EA_INFORMATION EaBuffer;
    PFILE_NAME_INFORMATION    FileName;

    CHAR              GuidStr[GUID_CHAR_LEN];
    CHAR              NameBuffer[sizeof(ULONG) + (sizeof(WCHAR)*(MAX_PATH+1))];

    *Handle = INVALID_HANDLE_VALUE;

    //
    // Open the parent directory using the object ID provided.
    //
    if (ParentObjectId != NULL) {
        WStatus = FrsOpenSourceFileById(&DirHandle,
                                        NULL,
                                        NULL,
                                        VolumeHandle,
                                        ParentObjectId,
                                        OidLength,
//                                        READ_ACCESS,
                                        READ_ATTRIB_ACCESS | FILE_LIST_DIRECTORY,
                                        ID_OPTIONS,
                                        SHARE_ALL,
                                        FILE_OPEN);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT_WS(1, "++ ERROR - Open on parent dir failed;", WStatus);
            return WStatus;
        }
    } else {
        DirHandle = VolumeHandle;
        OidLength = 0;
    }

    //
    // Create the target file.
    //
    FrsSetUnicodeStringFromRawString(&UStr, FileNameLen, BaseFileName, FileNameLen);

    InitializeObjectAttributes( &ObjectAttributes,
                                &UStr,
                                OBJ_CASE_INSENSITIVE,
                                DirHandle,
                                NULL );
    //
    // Mask off the junk that may have come in from the journal
    //
    FileCreateAttributes &= FILE_ATTRIBUTE_VALID_FLAGS;

    //
    // Set create options depending on file or dir.
    //
    CreateOptions = FILE_OPEN_FOR_BACKUP_INTENT     // FILE_FLAG_BACKUP_SEMANTICS
                  | FILE_OPEN_REPARSE_POINT
                  | FILE_OPEN_NO_RECALL             // Don't migrate data for HSM
                  | FILE_SEQUENTIAL_ONLY
                  | FILE_SYNCHRONOUS_IO_NONALERT;

    if (CreateDisposition == FILE_CREATE || CreateDisposition == FILE_OPEN_IF) {
        if (FileCreateAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            CreateOptions |= FILE_DIRECTORY_FILE;
            CreateOptions &= ~(FILE_SEQUENTIAL_ONLY | FILE_OPEN_NO_RECALL);
        } else {
            CreateOptions |= FILE_NON_DIRECTORY_FILE;
        }
    }

    EaBuffer = NULL;
    EaSize = 0;
//    ShareMode = 0;                               // no sharing
    //
    // Fix for Bug 186880
    //
    ShareMode = FILE_SHARE_READ;                   // share for read.

    //
    // Do the relative open.
    //

    DPRINT1(5, "++ DesiredAccess:         %08x\n", DesiredAccess);
    if (AllocationSize != NULL) {
        DPRINT2(5, "++ AllocationSize:        %08x %08x\n", AllocationSize->HighPart, AllocationSize->LowPart);
    }
    DPRINT1(5, "++ FileCreateAttributes:  %08x\n", FileCreateAttributes);
    DPRINT1(5, "++ ShareMode:             %08x\n", ShareMode);
    DPRINT1(5, "++ CreateDisposition:     %08x\n", CreateDisposition);
    DPRINT1(5, "++ CreateOptions:         %08x\n", CreateOptions);
    if (OidLength == 16) {
        GuidToStr((GUID *) ParentObjectId, GuidStr);
        DPRINT1(5, "++ Parent ObjectId:       %s\n", GuidStr);
    }

    NtStatus = NtCreateFile(&File,
                            DesiredAccess,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            AllocationSize,        // Initial allocation size
                            FileCreateAttributes,
                            ShareMode,
                            CreateDisposition,
                            CreateOptions,
                            EaBuffer,
                            EaSize);

    if (ParentObjectId != NULL) {
        FRS_CLOSE(DirHandle);
    }

    if (!NT_SUCCESS(NtStatus)) {
        DPRINT1_NT(5, "++ ERROR - CreateFile failed on %ws.", BaseFileName, NtStatus);
        DPRINT1(5, "++ DesiredAccess:         %08x\n", DesiredAccess);
        if (AllocationSize != NULL) {
            DPRINT2(5, "++ AllocationSize:        %08x %08x\n", AllocationSize->HighPart, AllocationSize->LowPart);
        }
        DPRINT1(5, "++ FileCreateAttributes:  %08x\n", FileCreateAttributes);
        DPRINT1(5, "++ ShareMode:             %08x\n", ShareMode);
        DPRINT1(5, "++ CreateDisposition:     %08x\n", CreateDisposition);
        DPRINT1(5, "++ CreateOptions:         %08x\n", CreateOptions);
        if (OidLength == 16) {
            GuidToStr((GUID *) ParentObjectId, GuidStr);
            DPRINT1(5, "++ Parent ObjectId:       %s\n", GuidStr);
        }

        if (NtStatus == STATUS_INVALID_PARAMETER) {
            DPRINT(5, "++ Invalid parameter on open by ID likely means file not found.\n");
            return ERROR_FILE_NOT_FOUND;
        }

        return FrsSetLastNTError(NtStatus);
    }


    if (DoDebug(5, DEBSUB)) {
        FileName = (PFILE_NAME_INFORMATION) &NameBuffer[0];
        FileName->FileNameLength = sizeof(NameBuffer) - sizeof(ULONG);

        NtStatus2 = NtQueryInformationFile(File,
                                           &IoStatusBlock,
                                           FileName,
                                           sizeof(NameBuffer),
                                           FileNameInformation );


        if (!NT_SUCCESS(NtStatus2)) {
            DPRINT_NT(1, "++ NtQueryInformationFile - FileNameInformation failed:",
                      NtStatus2);
        } else {
            FileName->FileName[FileName->FileNameLength/2] = UNICODE_NULL;
            DPRINT1(5, "++ Name of created file is: %ws\n", FileName->FileName);               //
        }
    }

    //
    // Return the file handle.
    //
    *Handle = File;

    return FrsSetLastNTError(NtStatus);
}


DWORD
FrsDeleteFile(
    IN PWCHAR   Name
    )
/*++
Routine Description:
    Delete the file

Arguments:
    Name

Return Value:
    WStatus.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsDeleteFile:"

    DWORD  WStatus = ERROR_SUCCESS;
    //
    // Delete file
    //
    DPRINT1(4, "++ Deleting %ws\n", Name);

    if (!DeleteFile(Name)) {
        WStatus = GetLastError();
        if (WStatus != ERROR_FILE_NOT_FOUND &&
            WStatus != ERROR_PATH_NOT_FOUND) {
            DPRINT1_WS(0, "++ Can't delete file %ws;", Name, WStatus);
        } else {
            WStatus = ERROR_SUCCESS;
        }
    }

    return WStatus;
}










DWORD
FrsCreateDirectory(
    IN PWCHAR   Name
    )
/*++
Routine Description:
    Create a directory

Arguments:
    Name

Return Value:
    Win32 Error Status

--*/
{
#undef DEBSUB
#define DEBSUB  "FrsCreateDirectory:"
    ULONG   WStatus;

    //
    // Create the directory
    //
    if (!CreateDirectory(Name, NULL)) {
        WStatus = GetLastError();
        if (!WIN_ALREADY_EXISTS(WStatus)) {
            DPRINT1_WS(0, "Can't create directory %ws;", Name, WStatus);
            return WStatus;
        }
    }
    return ERROR_SUCCESS;
}


DWORD
FrsVerifyVolume(
    IN PWCHAR   Path,
    IN PWCHAR   SetName,
    IN ULONG    Flags
    )
/*++
Routine Description:
    Does the volume exist and is it NTFS?  If not generate an event log entry
    and return non success.

Arguments:
    Path  --  A path string with a volume component.
    SetName -- the Replica set name for event log messages.
    Flags  -- The file system flags that must be set.  The currently valid
           set are:
            FILE_CASE_SENSITIVE_SEARCH
            FILE_CASE_PRESERVED_NAMES
            FILE_UNICODE_ON_DISK
            FILE_PERSISTENT_ACLS
            FILE_FILE_COMPRESSION
            FILE_VOLUME_QUOTAS
            FILE_SUPPORTS_SPARSE_FILES
            FILE_SUPPORTS_REPARSE_POINTS
            FILE_SUPPORTS_REMOTE_STORAGE
            FILE_VOLUME_IS_COMPRESSED
            FILE_SUPPORTS_OBJECT_IDS
            FILE_SUPPORTS_ENCRYPTION
            FILE_NAMED_STREAMS

Return Value:
    WIN32 Status
--*/

{
#undef DEBSUB
#define DEBSUB  "FrsVerifyVolume:"

    DWORD                          WStatus                = ERROR_SUCCESS;
    PWCHAR                         VolumeName             = NULL;
    ULONG                          FsAttributeInfoLength;
    IO_STATUS_BLOCK                Iosb;
    NTSTATUS                       Status;
    PFILE_FS_ATTRIBUTE_INFORMATION FsAttributeInfo        = NULL;
    HANDLE                         PathHandle             = INVALID_HANDLE_VALUE;


    if ((Path == NULL) || (wcslen(Path) == 0)) {
        WStatus = ERROR_INVALID_PARAMETER;
        goto RETURN;
    }

    //
    // Always open the path by masking off the FILE_OPEN_REPARSE_POINT flag
    // because we want to open the destination dir not the junction if the root
    // happens to be a mount point.
    //
    WStatus = FrsOpenSourceFileW(&PathHandle,
                                 Path,
                                 GENERIC_READ,
                                 FILE_OPEN_FOR_BACKUP_INTENT);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, "ERROR - Unable to open root path %ws. Retry at next poll.",
                   Path, WStatus);
        goto RETURN;
    }

    //
    // Get the volume information.
    //
    FsAttributeInfoLength = sizeof(FILE_FS_ATTRIBUTE_INFORMATION) +
                       MAXIMUM_VOLUME_LABEL_LENGTH;

    FsAttributeInfo = FrsAlloc(FsAttributeInfoLength);

    Status = NtQueryVolumeInformationFile(PathHandle,
                                          &Iosb,
                                          FsAttributeInfo,
                                          FsAttributeInfoLength,
                                          FileFsAttributeInformation);
    if (!NT_SUCCESS(Status)) {

        DPRINT2(0,"ERROR - Getting  NtQueryVolumeInformationFile for %ws. NtStatus = %08x\n",
                Path, Status);

        goto RETURN;
    }

    if ((FsAttributeInfo->FileSystemAttributes & Flags) != Flags) {
        DPRINT3(0, "++ Error - Required filesystem not present for %ws.  Needed %08x,  Found %08x\n",
                Path, Flags, FsAttributeInfo->FileSystemAttributes);
        WStatus = ERROR_INVALID_PARAMETER;
        goto RETURN;
    }

    WStatus = ERROR_SUCCESS;



RETURN:

    if (!WIN_SUCCESS(WStatus)) {
        if (WStatus == ERROR_INVALID_PARAMETER) {
            //
            // Generate an event log message.
            //
            VolumeName = FrsWcsVolume(Path);
            EPRINT4(EVENT_FRS_VOLUME_NOT_SUPPORTED,
                    SetName,
                    ComputerName,
                    ((Path == NULL)       ? L"<null>" : Path),
                    ((VolumeName == NULL) ? L"<null>" : VolumeName));
        } else {
            //
            // The Path is probably not accessible.
            //
            EPRINT1(EVENT_FRS_ROOT_NOT_VALID, Path);
        }
    }

    FrsFree(FsAttributeInfo);
    FRS_CLOSE(PathHandle);
    FrsFree(VolumeName);

    return WStatus;

}


DWORD
FrsCheckForNoReparsePoint(
    IN PWCHAR   Name
    )
/*++
Routine Description:
    Does the path reside on the same volume at the prefix drive name?
    It won't exist on the same volume if any element of the path
    is a reparse point pointing to a directory on another volume.

Arguments:
    Name

Return Value:
    WIN32 Status
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsCheckForNoReparsePoint:"
    DWORD                        WStatus;
    NTSTATUS                     Status;
    PWCHAR                       Volume            = NULL;
    PWCHAR                       Temp              = NULL;
    HANDLE                       FileHandlePath;
    HANDLE                       FileHandleDrive;
    IO_STATUS_BLOCK              Iosb;
    PFILE_FS_VOLUME_INFORMATION  VolumeInfoPath    = NULL;
    PFILE_FS_VOLUME_INFORMATION  VolumeInfoDrive   = NULL;
    ULONG                        VolumeInfoLength;

    if (!Name) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get the handle to the path passed in.
    //
    WStatus = FrsOpenSourceFileW(&FileHandlePath,
                                 Name,
//                                 READ_ACCESS,
                                 READ_ATTRIB_ACCESS,
                                 OPEN_OPTIONS & ~FILE_OPEN_REPARSE_POINT);
    CLEANUP1_WS(4, "++ ERROR - FrsOpenSourceFile(%ws);", Name, WStatus, CLEANUP);

    //
    // Get the volume information for this handle.
    //
    VolumeInfoPath = FrsAlloc(sizeof(FILE_FS_VOLUME_INFORMATION) + MAXIMUM_VOLUME_LABEL_LENGTH);
    VolumeInfoLength = sizeof(*VolumeInfoPath) + MAXIMUM_VOLUME_LABEL_LENGTH;

    Status = NtQueryVolumeInformationFile(FileHandlePath,
                                          &Iosb,
                                          VolumeInfoPath,
                                          VolumeInfoLength,
                                          FileFsVolumeInformation);
    NtClose(FileHandlePath);
    if (!NT_SUCCESS(Status)) {
        WStatus = FrsSetLastNTError(Status);
        CLEANUP1_NT(4, "++ ERROR - NtQueryVolumeInformationFile(%ws);",
                    Name, Status, CLEANUP);
    }

    //
    // Get the volume part of the absolute path.
    //
    Temp = FrsWcsVolume(Name);

    if (!Temp || (wcslen(Temp) == 0)) {
        WStatus = ERROR_FILE_NOT_FOUND;
        goto CLEANUP;
    }

    Volume = FrsWcsCat(Temp, L"\\");

    //
    // Get the handle to the prefix drive of the path passed in.
    //
    WStatus = FrsOpenSourceFileW(&FileHandleDrive, Volume,
//                                 READ_ACCESS,
                                 READ_ATTRIB_ACCESS,
                                 OPEN_OPTIONS);
    CLEANUP1_WS(4, "++ ERROR - opening volume %ws ;", Volume, WStatus, CLEANUP);

    //
    // Get the volume information for this handle.
    //
    VolumeInfoDrive = FrsAlloc(sizeof(FILE_FS_VOLUME_INFORMATION) + MAXIMUM_VOLUME_LABEL_LENGTH);
    VolumeInfoLength = sizeof(*VolumeInfoDrive) + MAXIMUM_VOLUME_LABEL_LENGTH;

    Status = NtQueryVolumeInformationFile(FileHandleDrive,
                                          &Iosb,
                                          VolumeInfoDrive,
                                          VolumeInfoLength,
                                          FileFsVolumeInformation);
    NtClose(FileHandleDrive);
    if (!NT_SUCCESS(Status)) {
        WStatus = FrsSetLastNTError(Status);
        CLEANUP1_NT(4, "++ ERROR - NtQueryVolumeInformationFile(%ws);",
                    Volume, Status, CLEANUP);
    }

    //
    // Now compare the VolumeSerialNumber acquired from the above two queries.
    // If it is the same then there are no reparse points in the path that
    // redirect the path to a different volume.
    //
    if (VolumeInfoPath->VolumeSerialNumber != VolumeInfoDrive->VolumeSerialNumber) {
        WStatus = ERROR_GEN_FAILURE;
        DPRINT2(0, "++ Error - VolumeSerialNumber mismatch %x != %x\n",
                VolumeInfoPath->VolumeSerialNumber,
                VolumeInfoDrive->VolumeSerialNumber);
        DPRINT2(0, "++ Error - Root path (%ws) is not on %ws. Invalid replica root path.\n",
                Name,Volume);
        goto CLEANUP;
    }

CLEANUP:
    //
    // Cleanup
    //
    FrsFree(VolumeInfoPath);
    FrsFree(Volume);
    FrsFree(Temp);
    FrsFree(VolumeInfoDrive);
    return WStatus;
}


DWORD
FrsDoesDirectoryExist(
    IN  PWCHAR   Name,
    OUT PDWORD   pAttributes
    )
/*++
Routine Description:
    Does the directory Name exist?

Arguments:
    Name
    pAttributes - return the attributes on the file/dir if it exits.

Return Value:
    WIN32 Status
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsDoesDirectoryExist:"
    DWORD   WStatus;

    //
    // Can't get attributes
    //
    *pAttributes = GetFileAttributes(Name);

    if (*pAttributes == 0xFFFFFFFF) {
        WStatus = GetLastError();
        DPRINT1_WS(4, "++ GetFileAttributes(%ws); ", Name, WStatus);
        return WStatus;
    }

    //
    // Not a directory
    //
    if (!(*pAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        DPRINT1(4, "++ %ws is not a directory\n", Name);
        return ERROR_DIRECTORY;
    }


    return ERROR_SUCCESS;

}







DWORD
FrsDoesFileExist(
    IN PWCHAR   Name
    )
/*++
Routine Description:
    Does the file Name exist?

Arguments:
    Name

Return Value:
    WIN32 Status
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsDoesFileExist:"
    DWORD   WStatus;
    DWORD   Attributes;

    //
    // Can't get attributes
    //
    Attributes = GetFileAttributes(Name);
    if (Attributes == 0xFFFFFFFF) {
        WStatus = GetLastError();
        DPRINT1_WS(4, "++ GetFileAttributes(%ws); ", Name, WStatus);
        return WStatus;
    }
    //
    // Not a directory
    //
    if (Attributes & FILE_ATTRIBUTE_DIRECTORY) {
        DPRINT1(4, "++ %ws is not a file\n", Name);
        return ERROR_DIRECTORY;
    }
    return ERROR_SUCCESS;
}



DWORD
FrsSetFilePointer(
    IN PWCHAR       Name,
    IN HANDLE       Handle,
    IN ULONG        High,
    IN ULONG        Low
    )
/*++
Routine Description:
    Position file pointer

Arguments:
    Handle
    Name
    High
    Low

Return Value:
    Win32 Error Status

--*/
{
#undef DEBSUB
#define DEBSUB  "FrsSetFilePointer:"

    DWORD WStatus  = ERROR_SUCCESS;

    Low = SetFilePointer(Handle, Low, &High, FILE_BEGIN);

    if (Low == INVALID_SET_FILE_POINTER) {
        WStatus = GetLastError();
        if (WStatus != NO_ERROR) {
            DPRINT1_WS(0, "++ Can't set file pointer for %ws;", Name, WStatus);
        }
    }

    return WStatus;
}







DWORD
FrsSetFileTime(
    IN PWCHAR       Name,
    IN HANDLE       Handle,
    IN FILETIME     *CreateTime,
    IN FILETIME     *AccessTime,
    IN FILETIME     *WriteTime
    )
/*++
Routine Description:
    Position file pointer

Arguments:
    Name
    Handle
    Attributes
    CreateTime
    AccessTime
    WriteTime

Return Value:
    WStatus.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsSetFileTime:"

   DWORD    WStatus  = ERROR_SUCCESS;

   if (!SetFileTime(Handle, CreateTime, AccessTime, WriteTime)) {
       WStatus = GetLastError();
       DPRINT1_WS(0, "++ Can't set file times for %ws;", Name, WStatus);
   }
   return WStatus;
}


DWORD
FrsSetEndOfFile(
    IN PWCHAR       Name,
    IN HANDLE       Handle
    )
/*++
Routine Description:
    Set end of file at current file position

Arguments:
    Handle
    Name

Return Value:
    WStatus.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsSetEndOfFile:"

   DWORD    WStatus  = ERROR_SUCCESS;

   if (!SetEndOfFile(Handle)) {
       WStatus = GetLastError();
       DPRINT1_WS(0, "++ ERROR - Setting EOF for %ws;", Name, WStatus);
   }

   return WStatus;
}









DWORD
FrsFlushFile(
    IN PWCHAR   Name,
    IN HANDLE   Handle
    )
/*++
Routine Description:
    Flush the file's data to disk

Arguments:
    Handle
    Name

Return Value:
    WStatus
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsFlushFile:"

    DWORD    WStatus  = ERROR_SUCCESS;

    if (HANDLE_IS_VALID(Handle)) {
        if (!FlushFileBuffers(Handle)) {
            WStatus = GetLastError();
            DPRINT1_WS(0, "++ Can't flush file for %ws;", Name, WStatus);
        }
    }

    return WStatus;
}



DWORD
FrsSetCompression(
    IN PWCHAR   Name,
    IN HANDLE   Handle,
    IN USHORT   TypeOfCompression
    )
/*++
Routine Description:
    Enable compression on Handle.

Arguments:
    Name
    Handle
    TypeOfCompression

Return Value:
    WStatus
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsSetCompression:"
    DWORD   BytesReturned;
    DWORD   WStatus  = ERROR_SUCCESS;

    if (!DeviceIoControl(Handle,
                         FSCTL_SET_COMPRESSION,
                         &TypeOfCompression, sizeof(TypeOfCompression),
                         NULL, 0, &BytesReturned, NULL)) {
        WStatus = GetLastError();
        DPRINT1_WS(0, "++ Can't set compression on %ws;", Name, WStatus);
    }
    return WStatus;
}






DWORD
FrsGetCompression(
    IN PWCHAR   Name,
    IN HANDLE   Handle,
    IN PUSHORT  TypeOfCompression
    )
/*++
Routine Description:
    Enable compression on Handle.

Arguments:
    Handle
    Name
    TypeOfCompression

Return Value:
    WStatus
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsGetCompression:"
    DWORD   BytesReturned;
    DWORD   WStatus  = ERROR_SUCCESS;

    if (!DeviceIoControl(Handle,
                         FSCTL_GET_COMPRESSION,
                         NULL, 0,
                         TypeOfCompression, sizeof(TypeOfCompression),
                         &BytesReturned, NULL)) {
        WStatus = GetLastError();
        DPRINT1_WS(0, "++ Can't get compression for %ws;", Name, WStatus);
    }
    return WStatus;
}



DWORD
FrsRenameByHandle(
    IN PWCHAR  Name,
    IN ULONG   NameLen,
    IN HANDLE  Handle,
    IN HANDLE  TargetHandle,
    IN BOOL    ReplaceIfExists
    )
/*++
Routine Description:
    Rename the file

Arguments:
    Name - New name
    NameLen - length of Name
    Handle - file handle
    TargetHandle - Target directory
    ReplaceIfExists

Return Value:
    Win Status
--*/
{
#undef DEBSUB
#define DEBSUB "FrsRenameByHandle:"
    PFILE_RENAME_INFORMATION RenameInfo;
    IO_STATUS_BLOCK          IoStatus;
    ULONG                    NtStatus;

    //
    // Rename the file; deleting any destination file if requested
    //
    RenameInfo = FrsAlloc(sizeof(FILE_RENAME_INFORMATION) + NameLen);
    RenameInfo->ReplaceIfExists = (ReplaceIfExists != 0);
    RenameInfo->RootDirectory = TargetHandle;
    RenameInfo->FileNameLength = NameLen;
    CopyMemory(RenameInfo->FileName, Name, NameLen);
    NtStatus = NtSetInformationFile(Handle,
                                    &IoStatus,
                                    RenameInfo,
                                        sizeof(FILE_RENAME_INFORMATION)
                                        + NameLen,
                                    FileRenameInformation);
    FrsFree(RenameInfo);

    DPRINT1_NT(5, "++ INFO - Renaming %ws failed; ", Name, NtStatus);
    return FrsSetLastNTError(NtStatus);
}



DWORD
FrsCheckObjectId(
    IN PWCHAR   Name,
    IN HANDLE   Handle,
    IN GUID     *Guid
    )
/*++
Routine Description:
    Check that the GUID on the file is the same.

Arguments:
    Name    - for error messages
    Handle  - Supplies a handle to the file
    Guid    - guid to check

Return Value:
    Win Status
--*/
{
#undef DEBSUB
#define DEBSUB "FrsCheckObjectId:"
    DWORD                 WStatus;
    FILE_OBJECTID_BUFFER  ObjectIdBuffer;

    //
    // Get the file's object id and check it
    //
    WStatus = FrsGetObjectId(Handle, &ObjectIdBuffer);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(4, "++ No object id for file %ws;", Name, WStatus);
    } else {
        //
        // Same file, no morph needed. (must have been renamed sometime before)
        //
        if (memcmp(ObjectIdBuffer.ObjectId, Guid, sizeof(GUID))) {
            DPRINT1(4, "++ Object ids don't match for file %ws\n", Name);
            WStatus = ERROR_FILE_NOT_FOUND;
        }
    }
    return WStatus;
}


PWCHAR
FrsCreateGuidName(
    IN GUID     *Guid,
    IN PWCHAR   Prefix
    )
/*++
Routine Description:
    Convert the guid into a file name

Arguments:
    Guid
    Prefix

Return Value:
    Character string
--*/
{
#undef DEBSUB
#define DEBSUB "FrsCreateGuidName:"
    WCHAR       WGuid[GUID_CHAR_LEN + 1];

    //
    // Translate the guid into a string
    //
    GuidToStrW(Guid, WGuid);

    //
    // Create the file name <prefix>Guid
    //
    return FrsWcsCat(Prefix, WGuid);
}


DWORD
FrsGetObjectId(
    IN  HANDLE Handle,
    OUT PFILE_OBJECTID_BUFFER ObjectIdBuffer
    )
/*++

Routine Description:

    This routine reads the object ID.

Arguments:

    Handle -- The file handle of an opened file.

    ObjectIdBuffer -- The output buffer to hold the object ID.

Return Value:

    Returns the Win Status of the last error found, or success.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsGetObjectId:"

    NTSTATUS        NtStatus;
    IO_STATUS_BLOCK Iosb;
    CHAR            GuidStr[GUID_CHAR_LEN];

    //
    // zero the buffer in case the data that comes back is short.
    //
    ZeroMemory(ObjectIdBuffer, sizeof(FILE_OBJECTID_BUFFER));

    //
    // Get the Object ID
    //
    NtStatus = NtFsControlFile(Handle,                          // file handle
                               NULL,                            // event
                               NULL,                            // apc routine
                               NULL,                            // apc context
                               &Iosb,                           // iosb
                               FSCTL_GET_OBJECT_ID,             // FsControlCode
                               &Handle,                         // input buffer
                               sizeof(HANDLE),                  // input buffer length
                               ObjectIdBuffer,                  // OutputBuffer for data from the FS
                               sizeof(FILE_OBJECTID_BUFFER));   // OutputBuffer Length

    if (NT_SUCCESS(NtStatus)) {
        GuidToStr((GUID *)ObjectIdBuffer->ObjectId, GuidStr);
        DPRINT1(4, "++ Existing oid for this file is %s\n", GuidStr );
    }
    return FrsSetLastNTError(NtStatus);
}


DWORD
FrsGetOrSetFileObjectId(
    IN  HANDLE Handle,
    IN  LPCWSTR FileName,
    IN  BOOL CallerSupplied,
    OUT PFILE_OBJECTID_BUFFER ObjectIdBuffer
    )
/*++

Routine Description:

    This routine reads the object ID.  If there is no
    object ID on the file we put one on it.  If the CallerSupplied flag is
    TRUE then we delete the current object ID on the file (if any) and
    stamp the object ID provided on the file.

    Note:  This function does not preserve the 48 byte extended info in the
    object ID.  Currently this is not a problem but could be a link tracking
    issue in the future.

Arguments:

    Handle -- The file handle of an opened file.

    FileName -- The name of the file.  For error messages only.

    CallerSupplied -- TRUE if caller supplies new OID to override ANY
                      OID currently on the file.

    ObjectIdBuffer -- The output buffer to hold the object ID.

Return Value:

    Returns the Win Status of the last error found, or success.

--*/
{

#undef DEBSUB
#define DEBSUB "FrsGetOrSetFileObjectId:"

    DWORD           WStatus = ERROR_SUCCESS;
    NTSTATUS        NtStatus;
    ULONG           ObjectIdBufferSize;
    IO_STATUS_BLOCK Iosb;
    CHAR            GuidStr[GUID_CHAR_LEN];
    LONG            Loop;

    ObjectIdBufferSize = sizeof(FILE_OBJECTID_BUFFER);

    if (!CallerSupplied) {
        WStatus = FrsGetObjectId(Handle, ObjectIdBuffer);
        if (WIN_SUCCESS(WStatus)) {
            return WStatus;
        }
        //
        // Clear the extra bits past the object id
        //
        ZeroMemory(ObjectIdBuffer, sizeof(FILE_OBJECTID_BUFFER));
    }

    if (WIN_OID_NOT_PRESENT(WStatus) || CallerSupplied) {
        //
        // No object ID on the file. Create one.  Just in case, try 15 times
        // to get a unique one. Don't let the kernel create the object ID
        // using FSCTL_CREATE_OR_GET_OBJECT_ID since it currently (April 97)
        // doesn't add the net card address.
        //
        Loop = 0;

        do {
            if (!CallerSupplied) {
                FrsUuidCreate((GUID *)ObjectIdBuffer->ObjectId);
            }

            if (Loop > 0) {
                DPRINT2(1, "++ Failed to assign Object ID %s (dup_name, retrying) to the file: %ws\n",
                        GuidStr, FileName);
            }
            GuidToStr((GUID *)ObjectIdBuffer->ObjectId, GuidStr);

            //
            // If this object ID is caller supplied then there might already
            // be one on the file so delete it first.
            //
            NtStatus = NtFsControlFile(
                Handle,                      // file handle
                NULL,                        // event
                NULL,                        // apc routine
                NULL,                        // apc context
                &Iosb,                       // iosb
                FSCTL_DELETE_OBJECT_ID,      // FsControlCode
                NULL,                        // input buffer
                0,                           // input buffer length
                NULL,                        // OutputBuffer for data from the FS
                0);                          // OutputBuffer Length


            NtStatus = NtFsControlFile(
                Handle,                      // file handle
                NULL,                        // event
                NULL,                        // apc routine
                NULL,                        // apc context
                &Iosb,                       // iosb
                FSCTL_SET_OBJECT_ID,         // FsControlCode
                ObjectIdBuffer,              // input buffer
                ObjectIdBufferSize,          // input buffer length
                NULL,                        // OutputBuffer for data from the FS
                0);                          // OutputBuffer Length

        } while ((NtStatus == STATUS_DUPLICATE_NAME) &&
                 (++Loop < 16) &&
                 (!CallerSupplied));

        if (!NT_SUCCESS(NtStatus)) {
            DPRINT1_NT(1, "++ ERROR - Set oid failed on file %ws;", FileName, NtStatus);
        } else {
            GuidToStr((GUID *)ObjectIdBuffer->ObjectId, GuidStr);
            DPRINT2(4, "++ Assigned Object ID %s (success) to the file: %ws\n",
                    GuidStr, FileName);
        }

        return FrsSetLastNTError(NtStatus);
    }
    return WStatus;
}


DWORD
FrsDeleteFileObjectId(
    IN  HANDLE Handle,
    IN  LPCWSTR FileName
    )
/*++

Routine Description:

    Delete object id (if it exists)

Arguments:

    Handle -- The file handle of an opened file.

    FileName -- The name of the file.  For error messages only.

Return Value:

    Returns the Win Status of the last error found, or success.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsDeleteFileObjectId:"

    NTSTATUS NtStatus;
    DWORD    WStatus;
    IO_STATUS_BLOCK Iosb;

    //
    // Remove the object id from the file
    //
    NtStatus = NtFsControlFile(Handle,                      // file handle
                               NULL,                        // event
                               NULL,                        // apc routine
                               NULL,                        // apc context
                               &Iosb,                       // iosb
                               FSCTL_DELETE_OBJECT_ID,      // FsControlCode
                               NULL,                        // input buffer
                               0,                           // input buffer length
                               NULL,                        // OutputBuffer for data from the FS
                               0);                          // OutputBuffer Length

    WStatus = FrsSetLastNTError(NtStatus);

    if (WIN_NOT_IMPLEMENTED(WStatus)) {
        DPRINT1_WS(0, "++ Could not delete object id for %ws (not implemented);", FileName, WStatus);
    } else

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, "++ Could not delete object id for %ws;", FileName, WStatus);
    } else {
        DPRINT1(4, "++ Deleted object id from %ws.\n", FileName);
    }

    return WStatus;
}



DWORD
FrsReadFileUsnData(
    IN  HANDLE Handle,
    OUT USN *UsnBuffer
    )
/*++

Routine Description:

    This routine reads the USN of the last modify operation to a file.

Arguments:

    Handle -- The file handle of an opened file.

    UsnBuffer -- The output buffer to hold the object ID.

Return Value:

    Returns the NTSTATUS of the last error found, or success.

--*/
{

#undef DEBSUB
#define DEBSUB "FrsReadFileUsnData:"

    ULONG           NtStatus;
    IO_STATUS_BLOCK Iosb;

    ULONGLONG Buffer[(sizeof(USN_RECORD) + MAX_PATH*2 + 7)/8];


    //
    // Go get the USN record for the file.
    //
    NtStatus = NtFsControlFile(
        Handle,                          // file handle
        NULL,                            // event
        NULL,                            // apc routine
        NULL,                            // apc context
        &Iosb,                           // iosb
        FSCTL_READ_FILE_USN_DATA,        // FsControlCode
        &Handle,                         // input buffer
        sizeof(HANDLE),                  // input buffer length
        Buffer,                          // OutputBuffer for USNRecord
        sizeof(Buffer));                 // OutputBuffer Length


    if (!NT_SUCCESS(NtStatus)) {
        if (NtStatus == STATUS_INVALID_DEVICE_STATE) {
            DPRINT(0, "++ FSCTL_READ_FILE_USN_DATA failed.  No journal on volume\n");
        }
        DPRINT_NT(0, "++ FSCTL_READ_FILE_USN_DATA failed. ", NtStatus);
        return FrsSetLastNTError(NtStatus);
    }
    //
    // Return the last USN on the file.
    //
    *UsnBuffer = ((PUSN_RECORD) (Buffer))->Usn;

    DUMP_USN_RECORD(4, (PUSN_RECORD)(Buffer));

    return ERROR_SUCCESS;
}



DWORD
FrsReadFileParentFid(
    IN  HANDLE Handle,
    OUT ULONGLONG *ParentFid
    )
/*++

Routine Description:

    This routine reads the parent FID for the file.

    *** WARNING ***
    Note with multiple links to a file there could be multiple parents.
    NTFS gives us one of them.

Arguments:

    Handle -- The file handle of an opened file.

    ParentFid -- The output buffer to hold the parent file ID.

Return Value:

    Returns the NTSTATUS of the last error found, or success.

--*/
{

#undef DEBSUB
#define DEBSUB "FrsReadFileParentFid:"

    ULONG           NtStatus;
    IO_STATUS_BLOCK Iosb;


    ULONGLONG Buffer[(sizeof(USN_RECORD) + MAX_PATH*2 + 7)/8];



    //
    // Go get the USN record for the file.
    //
    NtStatus = NtFsControlFile(
        Handle,                          // file handle
        NULL,                            // event
        NULL,                            // apc routine
        NULL,                            // apc context
        &Iosb,                           // iosb
        FSCTL_READ_FILE_USN_DATA,        // FsControlCode
        &Handle,                         // input buffer
        sizeof(HANDLE),                  // input buffer length
        Buffer,                          // OutputBuffer for USNRecord
        sizeof(Buffer));                 // OutputBuffer Length


    if (!NT_SUCCESS(NtStatus)) {
        if (NtStatus == STATUS_INVALID_DEVICE_STATE) {
            DPRINT(0, "++ FSCTL_READ_FILE_USN_DATA failed.  No journal on volume\n");
        }
        DPRINT_NT(0, "++ FSCTL_READ_FILE_USN_DATA failed.", NtStatus);
        *ParentFid = ZERO_FID;

        return FrsSetLastNTError(NtStatus);
    }
    //
    // Return a parent FID for the file.  (could be more than one with links)
    //
    *ParentFid = ((PUSN_RECORD) (Buffer))->ParentFileReferenceNumber;

    DUMP_USN_RECORD(4, (PUSN_RECORD)(Buffer));

    return ERROR_SUCCESS;
}


DWORD
FrsGetReparseTag(
    IN  HANDLE  Handle,
    OUT ULONG   *ReparseTag
    )
/*++

Routine Description:

    Return the value of the reparse tag.

Arguments:

    Handle - Handle for a reparse point

    ReparseTag - returned reparse tag if ERROR_SUCCESS

Return Value:

    Win32 Status

--*/
{
#undef DEBSUB
#define DEBSUB "FrsGetReparseTag:"
    NTSTATUS    NtStatus;
    DWORD       ReparseDataLength;
    PCHAR       ReparseBuffer;
    IO_STATUS_BLOCK         IoStatusBlock;
    PREPARSE_DATA_BUFFER    ReparseBufferHeader;

    //
    //  Allocate a buffer and get the information.
    //
    ReparseDataLength = MAXIMUM_REPARSE_DATA_BUFFER_SIZE;
    ReparseBuffer = FrsAlloc(ReparseDataLength);

    //
    //  Query the reparse point.
    //
    NtStatus = NtFsControlFile(Handle,
                               NULL,
                               NULL,
                               NULL,
                               &IoStatusBlock,
                               FSCTL_GET_REPARSE_POINT,
                               NULL,
                               0,
                               (PVOID)ReparseBuffer,
                               ReparseDataLength
                               );

    if (!NT_SUCCESS(NtStatus)) {
        DPRINT_NT(4, "++ Could not get reparse point;", NtStatus);
        FrsFree(ReparseBuffer);
        return FrsSetLastNTError(NtStatus);
    }
    ReparseBufferHeader = (PREPARSE_DATA_BUFFER)ReparseBuffer;
    *ReparseTag = ReparseBufferHeader->ReparseTag;
    FrsFree(ReparseBuffer);
    return ERROR_SUCCESS;
}


DWORD
FrsCheckReparse(
    IN     PWCHAR Name,
    IN     PVOID  Id,
    IN     DWORD  IdLen,
    IN     HANDLE VolumeHandle
    )
/*++
Routine Description:

    Check that the reparse point is allowed

Arguments:
    Name            - File name for error messages
    Id              - Fid or Oid
    VolumeHandle    - open handle to the volume root.

Thread Return Value:

    Win32 Status

--*/
{
#undef DEBSUB
#define DEBSUB  "FrsCheckReparse:"
    DWORD       WStatus;
    HANDLE      Handle;
    ULONG       ReparseTag;

    //
    // For proper cleanup in the event of failure
    //
    Handle = INVALID_HANDLE_VALUE;

    //
    // Open the file for read access
    WStatus = FrsOpenSourceFileById(&Handle,
                                    NULL,
                                    NULL,
                                    VolumeHandle,
                                    Id,
                                    IdLen,
//                                    READ_ACCESS,
                                    READ_ATTRIB_ACCESS,
                                    ID_OPTIONS,
                                    SHARE_ALL,
                                    FILE_OPEN);
    //
    // File has been deleted; done
    //
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT2_WS(4, "++ %ws (Id %08x %08x) could not open for reparse;",
                   Name, PRINTQUAD(*((PULONGLONG)Id)), WStatus);
        return WStatus;
    }
    //
    // What type of reparse is it?
    //
    WStatus = FrsGetReparseTag(Handle, &ReparseTag);
    FRS_CLOSE(Handle);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT2_WS(4, "++ %ws (Id %08x %08x) could not get reparse tag;",
                   Name, PRINTQUAD(*((PULONGLONG)Id)), WStatus);
        return WStatus;
    }

    //
    // We only accept operations on files with SIS and HSM reparse points.
    // For example a rename of a SIS file into a replica tree needs to prop
    // a create CO.
    //
    if ((ReparseTag != IO_REPARSE_TAG_HSM) &&
        (ReparseTag != IO_REPARSE_TAG_SIS)) {
        DPRINT3(4, "++ %ws (Id %08x %08x) is reparse tag %08x is unsupported.\n",
                Name, PRINTQUAD(*((PULONGLONG)Id)), ReparseTag);

        return ERROR_OPERATION_ABORTED;
    }

    return ERROR_SUCCESS;
}



DWORD
FrsDeleteReparsePoint(
    IN  HANDLE  Handle
    )
/*++

Routine Description:

    Delete the reparse point on the opened file.

Arguments:

    Handle - Handle for a reparse point

Return Value:

    Win32 Status

--*/
{
#undef DEBSUB
#define DEBSUB "FrsDeleteReparsePoint:"

    ULONG       WStatus = ERROR_SUCCESS;
    DWORD       ReparseDataLength;
    ULONG       ReparseTag;
    PCHAR       ReparseData;
    PREPARSE_DATA_BUFFER    ReparseBufferHeader;
    ULONG       ActualSize;

    //
    //  Allocate a buffer and get the information.
    //
    ReparseDataLength = MAXIMUM_REPARSE_DATA_BUFFER_SIZE;
    ReparseData = FrsAlloc(ReparseDataLength);

    //
    //  Need the reparse tag in order to do the delete.
    //
    if (!DeviceIoControl(Handle,
                         FSCTL_GET_REPARSE_POINT,
                         (LPVOID) NULL,
                         (DWORD)  0,
                         (LPVOID) ReparseData,
                         ReparseDataLength,
                         &ActualSize,
                         (LPOVERLAPPED) NULL )) {
        WStatus = GetLastError();
        CLEANUP_WS(0, "++ FrsDeleteReparsePoint - FSCTL_GET_REPARSE_POINT failed,",
                   WStatus, RETURN);
    }

    ReparseBufferHeader = (PREPARSE_DATA_BUFFER)ReparseData;
    ReparseTag = ReparseBufferHeader->ReparseTag;

    DPRINT1(3, "++ FrsDeleteReparsePoint - Tag: 08x\n", ReparseTag);

    //
    // Delete the reparse point.
    //
    ZeroMemory(ReparseBufferHeader, sizeof(REPARSE_DATA_BUFFER_HEADER_SIZE));
    ReparseBufferHeader->ReparseTag = ReparseTag;
    ReparseBufferHeader->ReparseDataLength = 0;

    if (!DeviceIoControl(Handle,
                         FSCTL_DELETE_REPARSE_POINT,
                         (LPVOID) ReparseData,
                         REPARSE_DATA_BUFFER_HEADER_SIZE,
                         (LPVOID) NULL,
                         (DWORD)  0,
                         &ActualSize,
                         (LPOVERLAPPED) NULL )) {
        WStatus = GetLastError();
        CLEANUP_WS(0, "++ FrsDeleteReparsePoint - FSCTL_DELETE_REPARSE_POINT failed,",
                   WStatus, RETURN);
    }


RETURN:

    FrsFree(ReparseData);

    return WStatus;
}


DWORD
FrsChaseSymbolicLink(
    IN  PWCHAR  SymLink,
    OUT PWCHAR  *OutPrintName,
    OUT PWCHAR  *OutSubstituteName
    )
/*++

Routine Description:

    This function opens the specified file with backup intent for
    reading all the files attributes, ...

Arguments:

    Handle - A pointer to a handle to return an open handle.

    lpFileName - Represents the name of the file or directory to be opened.

    DesiredAccess

    CreateOptions

Return Value:

    Winstatus.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsChaseSymbolicLink:"
    NTSTATUS    NtStatus;
    DWORD       WStatus;
    HANDLE      Handle;
    DWORD       ReparseDataLength;
    PCHAR       ReparseBuffer;
    DWORD       SubLen;
    DWORD       PrintLen;
    PWCHAR      SubName;
    PWCHAR      PrintName;
    IO_STATUS_BLOCK         IoStatusBlock;
    PREPARSE_DATA_BUFFER    ReparseBufferHeader;
    OBJECT_ATTRIBUTES       Obja;
    UNICODE_STRING          FileName;
    ULONG             FileAttributes;
    ULONG             CreateDisposition;
    ULONG             ShareMode;
    ULONG             Colon;

    if ((OutPrintName == NULL) || (OutSubstituteName == NULL)) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Assume no symlink
    //
    *OutPrintName = FrsWcsDup(SymLink);
    *OutSubstituteName = FrsWcsDup(SymLink);

    //
    //  Allocate a buffer and get the information.
    //
    ReparseDataLength = MAXIMUM_REPARSE_DATA_BUFFER_SIZE;
    ReparseBuffer = FrsAlloc(ReparseDataLength);

NEXT_LINK:
    //
    // Open the target symlink. If this is a dos type path name then
    // convert it to NtPathName or else use it as it is.
    //
    Colon = wcscspn(*OutSubstituteName, L":");

    if (Colon == 1 ||
        (wcsncmp(*OutSubstituteName, L"\\\\?\\", wcslen(L"\\\\?\\")) == 0 )) {
        WStatus = FrsOpenSourceFileW(&Handle,
                                     *OutSubstituteName,
                                     GENERIC_READ,
                                     FILE_OPEN_FOR_BACKUP_INTENT |
                                     FILE_OPEN_REPARSE_POINT);
        CLEANUP1_WS(4, "++ Could not open %ws; ", *OutSubstituteName, WStatus, CLEANUP);

    } else {
        //
        // The path already in Nt style. Use it as it is.
        //
        FileName.Buffer = *OutSubstituteName;
        FileName.Length = (USHORT)(wcslen(*OutSubstituteName) * sizeof(WCHAR));
        FileName.MaximumLength = (USHORT)(wcslen(*OutSubstituteName) * sizeof(WCHAR));

        InitializeObjectAttributes(&Obja,
                                   &FileName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        CreateDisposition = FILE_OPEN;               // Open existing file

        ShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;

        FileAttributes = FILE_ATTRIBUTE_NORMAL;

        NtStatus = NtCreateFile(&Handle,
                              GENERIC_READ,
                              &Obja,
                              &IoStatusBlock,
                              NULL,              // Initial allocation size
                              FileAttributes,
                              ShareMode,
                              CreateDisposition,
                              FILE_OPEN_FOR_BACKUP_INTENT |
                              FILE_OPEN_REPARSE_POINT,
                              NULL, 0);

        WStatus = FrsSetLastNTError(NtStatus);
        CLEANUP1_WS(4, "++ Could not open %ws;", *OutSubstituteName, WStatus, CLEANUP);
    }

    //
    //  Query the reparse point.
    //
    //  Now go and get the data.
    //
    NtStatus = NtFsControlFile(Handle,
                               NULL,
                               NULL,
                               NULL,
                               &IoStatusBlock,
                               FSCTL_GET_REPARSE_POINT,
                               NULL,
                               0,
                               (PVOID)ReparseBuffer,
                               ReparseDataLength
                               );

    FRS_CLOSE(Handle);
    if (NtStatus == STATUS_NOT_A_REPARSE_POINT) {
        FrsFree(ReparseBuffer);
        return ERROR_SUCCESS;
    }

    WStatus = FrsSetLastNTError(NtStatus);
    CLEANUP1_WS(4, "++ Could not fsctl %ws;", *OutSubstituteName, WStatus, CLEANUP);

    //
    //  Display the buffer.
    //

    ReparseBufferHeader = (PREPARSE_DATA_BUFFER)ReparseBuffer;
    if ((ReparseBufferHeader->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT) ||
        (ReparseBufferHeader->ReparseTag == IO_REPARSE_TAG_SYMBOLIC_LINK)) {

        SubName   = &ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer[0];
        SubLen    = ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameLength;
        PrintName = &ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer[(SubLen + sizeof(UNICODE_NULL))/sizeof(WCHAR)];
        PrintLen  = ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameLength;
        SubName[SubLen / sizeof(WCHAR)] = L'\0';
        PrintName[PrintLen / sizeof(WCHAR)] = L'\0';

        DPRINT2(4, "++ %ws -> (print) %ws\n", *OutPrintName, PrintName);
        DPRINT2(4, "++ %ws -> (substitute) %ws\n", *OutSubstituteName, SubName);

        FrsFree(*OutPrintName);
        FrsFree(*OutSubstituteName);

        //
        // We need to return both print name and substitute name.
        //
        *OutPrintName = FrsWcsDup(PrintName);
        *OutSubstituteName = FrsWcsDup(SubName);
        goto NEXT_LINK;
    }

    return ERROR_SUCCESS;

CLEANUP:
    FRS_CLOSE(Handle);
    FrsFree(ReparseBuffer);
    *OutPrintName = FrsFree(*OutPrintName);
    *OutSubstituteName = FrsFree(*OutSubstituteName);
    return WStatus;
}


DWORD
FrsTraverseReparsePoints(
    IN  PWCHAR  SuppliedPath,
    OUT PWCHAR  *RealPath
    )
/*++

Routine Description:

    This function steps through each element of the path
    and maps all reparse points to actual paths. In the end the
    path returned has no reparse points of the form
    IO_REPARSE_TAG_MOUNT_POINT and IO_REPARSE_TAG_SYMBOLIC_LINK.

Arguments:

    Supplied - Input path. May or may not have any reparse points.

    RealPath - Path without any reparse points or NULL if there is an error
               reading reparse data.

Return Value:

    Winstatus.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsTraverseReparsePoints:"
    PWCHAR  TempStr           = NULL;
    PWCHAR  IndexPtr          = NULL;
    PWCHAR  BackSlashPtr      = NULL;
    PWCHAR  TempPath          = NULL;
    PWCHAR  PrintablePath     = NULL;
    DWORD   Colon             = 0;
    DWORD   CloseBrace        = 0;
    DWORD   LoopBreaker       = 0;
    DWORD   WStatus           = ERROR_SUCCESS;
    ULONG   FileAttributes    = 0;
    BOOL    ReparsePointFound = FALSE;

    if (!SuppliedPath) {
        WStatus = ERROR_INVALID_PARAMETER;
        goto CLEANUP;
    }
    TempStr = FrsAlloc((wcslen(SuppliedPath) + 1) * sizeof(WCHAR));
    wcscpy(TempStr,SuppliedPath);


    //
    // Repeat the procedure until you have a clean path without any
    // reparse points.
    // e.g.
    // f:\c -> d:\destination
    // e:\a\b -> f:\c\d (which is actually d:\destination\d)
    // Given path is e:\a\b\c
    // FIrst time through the loop we will have f:\c\d\c
    // Second time we will translate the reparse point at f:\c
    // and get the correct answer d:\destination\d\c
    //
    do {
        *RealPath = NULL;
        ReparsePointFound = FALSE;
        //
        // Find the colon. Every path has to either have a colon followed by a '\'
        // or it should be of the form. "\??\Volume{60430005-ab47-11d3-8973-806d6172696f}\"
        //
        Colon = wcscspn(TempStr, L":");

        if (Colon == wcslen(TempStr)) {
            //
            // Path does not have a colon. It can be of the form
            // "\??\Volume{60430005-ab47-11d3-8973-806d6172696f}\"
            //
            CloseBrace = wcscspn(TempStr, L"}");
            if (TempStr[CloseBrace] != L'}' ||
                TempStr[CloseBrace + 1] != L'\\') {
                WStatus = ERROR_INVALID_PARAMETER;
                goto CLEANUP;
            }
            //
            // Copy the path up to 1 past the closing brace as it is. It could be \??\Volume...
            // or \\.\Volume... or \\?\Volume.. or some other complex form.
            // Start looking for reparse points past the closing brace.
            //

            *RealPath = FrsAlloc((CloseBrace + 3)* sizeof(WCHAR));
            wcsncpy(*RealPath,TempStr,CloseBrace + 2);
            (*RealPath)[CloseBrace + 2] = L'\0';
            IndexPtr = &TempStr[CloseBrace + 1];

        } else {
            if (TempStr[Colon] != L':' ||
                TempStr[Colon + 1] != L'\\') {
                WStatus = ERROR_INVALID_PARAMETER;
                goto CLEANUP;
            }
            //
            // Copy the path up to 1 past the colon as it is. It could be d:\
            // or \\.\d:\ or \??\d:\ or some other complex form.
            // Start looking for reparse points past the colon.
            //

            *RealPath = FrsAlloc((Colon + 3)* sizeof(WCHAR));
            wcsncpy(*RealPath,TempStr,Colon + 2);
            (*RealPath)[Colon + 2] = L'\0';
            IndexPtr = &TempStr[Colon + 1];

        }

        BackSlashPtr = wcstok(IndexPtr,L"\\");
        if (BackSlashPtr == NULL) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }

        do {
            if ((*RealPath)[wcslen(*RealPath) - 1] == L'\\') {
                TempPath = FrsAlloc((wcslen(*RealPath) + wcslen(BackSlashPtr) + 1)* sizeof(WCHAR));
                wcscpy(TempPath,*RealPath);
            } else {
                TempPath = FrsAlloc((wcslen(*RealPath) + wcslen(BackSlashPtr) + wcslen(L"\\") + 1)* sizeof(WCHAR));
                wcscpy(TempPath,*RealPath);
                wcscat(TempPath,L"\\");
            }
            wcscat(TempPath,BackSlashPtr);
            FrsFree(*RealPath);
            *RealPath = TempPath;
            TempPath = NULL;

            //
            //
            //
            //
            // FrsChaseSymbolicLink returns both then PrintName and the SubstituteName.
            // We use the SubstituteName as it is always guaranteed to be there.
            // PrintName is ignored.
            //
            WStatus = FrsChaseSymbolicLink(*RealPath, &PrintablePath, &TempPath);
            PrintablePath = FrsFree(PrintablePath);
            if (!WIN_SUCCESS(WStatus)) {
                DPRINT1(0,"ERROR reading reparse point data WStatus = %d\n",WStatus);
                FrsFree(TempPath);
                goto CLEANUP;

            //
            // We are only looking for reparse points that are
            // either IO_REPARSE_TAG_MOUNT_POINT or IO_REPARSE_TAG_SYMBOLIC_LINK.
            // Check if the path returned by FrsChaseSymbolicLink is same as the
            // path passed to it. If it is then we haven't hit a reparse point.
            //
            } else if (wcscmp(*RealPath,TempPath)) {
                ReparsePointFound = TRUE;
                FrsFree(*RealPath);
                *RealPath = TempPath;
                TempPath = NULL;
            } else {
                TempPath = FrsFree(TempPath);
            }
        } while ( (BackSlashPtr = wcstok(NULL,L"\\")) != NULL);

        if (SuppliedPath[wcslen(SuppliedPath) - 1] == L'\\') {
            TempPath = FrsAlloc((wcslen(*RealPath) + wcslen(L"\\") + 1)* sizeof(WCHAR));
            wcscpy(TempPath,*RealPath);
            wcscat(TempPath,L"\\");
            FrsFree(*RealPath);
            *RealPath = TempPath;
            TempPath = NULL;
        }
        FrsFree(TempStr);
        TempStr = *RealPath;
        //
        // Break out of the loop if there is a junction point loop.
        // If we have traversed the path 100 times and still can't
        // get to the destination then we probably have a loop
        // in the path.
        //
        ++LoopBreaker;
    } while ( ReparsePointFound && LoopBreaker < 100);

    //
    // Path has loops in it. Return error.
    //
    if (LoopBreaker >= 100) {
        WStatus = ERROR_INVALID_PARAMETER;
        goto CLEANUP;
    }
CLEANUP:
    DPRINT2(5,"Supplied Path = %ws, Traversed Path = %ws\n",SuppliedPath,(*RealPath)?*RealPath:L"<null>");

    //
    // If we are returning error then return NULL as the real path.
    //
    if (!WIN_SUCCESS(WStatus)) {
        FrsFree(TempStr);
        *RealPath = FrsFree(*RealPath);
    }
    return WStatus;
}


BOOL
FrsSearchArgv(
    IN LONG     ArgC,
    IN PWCHAR  *ArgV,
    IN PWCHAR   ArgKey,
    OUT PWCHAR *ArgValue
    )

/*++

Routine Description:

    This routine searches an ArgV vector for the keyword in ArgKey.
    If found it looks for an equals sign and returns a copy of the right
    hand side in ArgValue.  The caller must free the returned string.

Arguments:

    ArgC - The number of entries in the ArgV vector.

    ArgV - The vector of PWCHARS to search.

    ArgKey - The key to search for.  MUST BE LOWERCASE TO MATCH.

    ArgValue - return location for the buffer ptr.  Caller must free.
               if NULL no right hand side is returned.

Return Value:

    TRUE if ArgKey is found.

--*/

{

#undef DEBSUB
#define DEBSUB "FrsSearchArgv:"
    LONG    i, n, Len;
    PWCHAR  TestStr;
    PWCHAR  Wcs;

    if (ArgValue != NULL) {
        *ArgValue = NULL;
    }

    //
    // Are we running as a service? We need to know prior
    // to calling the first DPRINT.
    //
    for (n = 0; n < ArgC; ++n) {
        TestStr = ArgV[n];
        Len = wcslen(TestStr);

        if (Len <= 0) {
            continue;
        }

        //
        // Skip -,/
        //
        if (TestStr[0] == L'-' || TestStr[0] == L'/') {
            TestStr++;
            Len--;
        }

        //
        //  Skip over leading spaces and tabs.
        //
        while ((TestStr[0] == UNICODE_SPACE) || (TestStr[0] == UNICODE_TAB) ) {
            TestStr++;
            Len--;
        }


        if (Len <= 0) {
            continue;
        }


        _wcslwr(TestStr);

        if (wcsstr(TestStr, ArgKey) != TestStr) {
            continue;
        }

        //
        // Found a match.  Look for a value.
        //
        if (ArgValue != NULL) {

            DPRINT2(5, "match on ArgV[%d] = %ws\n", n, TestStr);
            Wcs = wcschr(TestStr, L'=');
            if (Wcs) {

                //
                //  Trim trailing leading spaces and tabs.
                //
                while ((TestStr[Len-1] == UNICODE_SPACE) ||
                       (TestStr[Len-1] == UNICODE_TAB  )) {
                    Len--;
                }

                FRS_ASSERT(&TestStr[Len-1] >= Wcs);

                TestStr[Len] = UNICODE_NULL;

                *ArgValue = FrsWcsDup(Wcs+1);
                DPRINT1(5, "++ return value = %ws\n", *ArgValue);
            }
        }

        return TRUE;

    }

    DPRINT1(5, "++ No match for ArgKey = %ws\n", ArgKey);
    return FALSE;

}


BOOL
FrsSearchArgvDWord(
    IN LONG     ArgC,
    IN PWCHAR  *ArgV,
    IN PWCHAR   ArgKey,
    OUT PDWORD  ArgValue
    )

/*++

Routine Description:

    This routine searches an ArgV vector for the keyword in ArgKey.
    If found it looks for an equals sign and returns the right
    hand side in ArgValue as a base 10 number.

Arguments:

    ArgC - The number of entries in the ArgV vector.

    ArgV - The vector of PWCHARS to search.

    ArgKey - The key to search for.  MUST BE LOWERCASE TO MATCH.

    ArgValue - return location for the DWORD right hand side.
               if ArgKey not found no right hand side is returned.

Return Value:

    TRUE if ArgKey is found.

--*/

{

#undef DEBSUB
#define DEBSUB "FrsSearchArgvDWord:"
    ULONG    Len;
    PWCHAR  WStr;


    if (FrsSearchArgv(ArgC, ArgV, ArgKey, &WStr)) {
        //
        // Found ArgKey
        //
        if (WStr != NULL) {
            //
            // Found rhs.
            //
            Len = wcslen(WStr);
            if ((Len > 0) && (wcsspn(WStr, L"0123456789") == Len)){
                *ArgValue = wcstoul(WStr, NULL, 10);
                FrsFree(WStr);
                return TRUE;
            } else {
                DPRINT2(0, "++ ERROR - Invalid decimal string '%ws' for %ws\n",
                        WStr, ArgKey);
                FrsFree(WStr);
            }
        }
    }

    return FALSE;
}


BOOL
FrsDissectCommaList (
    IN UNICODE_STRING RawArg,
    OUT PUNICODE_STRING FirstArg,
    OUT PUNICODE_STRING RemainingArg
    )
/*++

Routine Description:

    This routine parses a comma (or semicolon) separated string.
    It picks off the first element in the given RawArg and provides both it and
    the remaining part.  Leading blanks and tabs are ignored.  FirstArg is
    returned zero length when there is either a leading comma or embedded
    double comma.  However the buffer address in FirstArg still points to where
    the arg started so the caller can tell how much of the string has been
    processed.  The function returns FALSE when the input string is empty.  It
    returns TRUE when the FirstArg is valid, even if it is null.

    Here are some examples:

        RawArg         FirstArg     RemainingArg       Result
        ----           ---------    -------------      ------
        empty          empty        empty              FALSE

        ,              empty        empty              TRUE

        ,,             empty        ,                  TRUE

        A              A            empty              TRUE

        A,             A            empty              TRUE

        ,A             empty        A                  TRUE

        "A  ,B,C,D"    A            "  B,C,D"          TRUE

        *A?            *A?          empty      