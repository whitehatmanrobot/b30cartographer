l users
                status = NetSessionEnum(NULL, NULL, m_userName, 1, &buff,
                                WSB_BUFF_SIZE, &numEnt, &totalEnt, &res);

                if (status != 0) {
                    status = NetSessionEnum(NULL, NULL, NULL, 1, &buff,
                                    WSB_BUFF_SIZE, &numEnt, &totalEnt, &res);
                }
            } else {
                status = NetSessionEnum( NULL, NULL, NULL, 1, &buff,
                    WSB_BUFF_SIZE, &numEnt, &totalEnt, &res );
            }

            if ((status == NERR_Success) || (status == ERROR_MORE_DATA)) {

                WsbTrace(OLESTR("CHsmFilterClient::IdentifyThread: NetSessionEnum output: Total entries=%ls , Read entries=%ls \n"),
                        WsbLongAsString(totalEnt), WsbLongAsString(numEnt));

                if (status != ERROR_MORE_DATA) {
                    done = TRUE;
                }

                sess = (SESSION_INFO_1  *) buff;

                while ( numEnt != 0 ) {
                    //
                    // If the request was made from the user GUEST then 
                    // we enumerate all sessions and send the           
                    // identification request to all the machines with  
                    // sessions marked as GUEST.  This is because the   
                    // session may have some other user name but the    
                    // request could still have GUEST access.           
                    //
                    if (((guestUser) && (sess->sesi1_user_flags & SESS_GUEST)) ||
                         (!guestUser)) {

                        //
                        // Send the identify request message 
                        //

                        WsbTrace(OLESTR("CFsaFilterClient::IdentifyThread - Sending identify request to %ls (local machine = %ls)\n"),
                                sess->sesi1_cname, (WCHAR *) pipePath);

                        hr = GetNotifyClientInterface ( sess->sesi1_cname, &pRecallClient );
                        if ( SUCCEEDED ( hr ) ) {

                            hr = pRecallClient->IdentifyWithServer( pipePath );
                            if (hr != S_OK) {
                                WsbTrace(OLESTR("CFsaFilterClient::IdentifyThread - error Identifing (%ls)\n"),
                                    WsbHrAsString(hr));
                            }
                        } else {
                            WsbTrace(OLESTR("CFsaFilterClient::IdentifyThread - error getting notify client interface hr = %ls (%x)\n"),
                                WsbHrAsString( hr ), hr);
                        }
                        hr = S_OK;
                        pRecallClient.Release ( );
                    }

                    sess++;
                    numEnt--;
                }

                NetApiBufferFree(buff);
                buff = NULL;
            } else {
                done = TRUE;
            }
        }
    
#ifdef MAC_SUPPORT
        //
        // Done with LAN manager scan, now do a MAC scan.
        //
        if ( (FsaMacSupportInstalled) && ((pAfpAdminConnect)(NULL, &macHandle) == NO_ERROR) ) {
            //
            // We have connected to the MAC service - do a session enumeration
            //
            macResume = 0;
            done = FALSE;   
            while (done == FALSE) {
                result = (pAfpAdminSessionEnum)(macHandle, &macBuff, -1,
                        &macTotalRead, &macTotalEntries, &macResume);

                if ((result == NO_ERROR) || (result == ERROR_MORE_DATA)) {
                        //
                        // Read some entries - send the message to each one 
                        //
                        if (macTotalRead == macTotalEntries) {
                            done = TRUE;
                        }

                        macInfo = (PAFP_SESSION_INFO) macBuff;
                        while ( macTotalRead != 0 ) {
                            //
                            // Send to each matching user
                            //
                            if ( ( NULL != macInfo->afpsess_ws_name ) &&
                                 ( _wcsicmp(m_userName, macInfo->afpsess_username ) == 0 ) ) {

                                WsbTrace(OLESTR("CHsmFilterClient::IdentifyThread: Send Identify to MAC %ls.\n"),
                                    macInfo->afpsess_ws_name);

                                //
                                // Send the identify request message 
                                //
            
                                hr = GetNotifyClientInterface ( sess->sesi1_cname, &pRecallClient );
                                if ( SUCCEEDED ( hr ) ) {
                                    pRecallClient->IdentifyWithServer ( pipePath );
                                }

                                hr = S_OK;
                                pRecallClient.Release ( );
                            }
                        macInfo++;
                        macTotalRead--;
                        }

                        (pAfpAdminBufferFree)(macBuff);
                        macBuff = NULL;
                } else {
                    done = TRUE;
                }
            (pAfpAdminDisconnect)(macHandle);
            macHandle = 0;
            }
        }
#endif
        
    } WsbCatch(hr);

    if (buff != NULL) {
        NetApiBufferFree(buff);
    }

#ifdef MAC_SUPPORT
    
    if (FsaMacSupportInstalled) {
        if (macBuff != NULL) {
            (pAfpAdminBufferFree)(macBuff);
        }
        if (macHandle != 0) {
            (pAfpAdminDisconnect)(macHandle);
        }
    }
#endif

    CloseHandle(m_identifyThread);
    m_identifyThread = NULL;

    WsbTraceOut(OLESTR("CFsaFilterClient::IdentifyThread"), OLESTR("hr = %ls"), WsbHrAsString(hr));
    return(hr);
}



HRESULT
CFsaFilterClient::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterClient::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // No persistence.
        hr = E_NOTIMPL;

    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CFsaFilterClient::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterClient::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistStream> pPersistStream;

    WsbTraceIn(OLESTR("CFsaFilterClient::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // No persistence.
        hr = E_NOTIMPL;

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterClient::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterClient::SendRecallInfo(
    IFsaFilterRecall *pRecall,
    BOOL             starting,
    HRESULT          rHr
    )

/*++

Implements:

  CFsaFilterClient::SendRecallInfo

--*/
{
    HRESULT hr = E_FAIL;

    if( ! m_identified && ( m_identifyThread != NULL ) ) {

        //
        // Wait for up to 10 seconds for identify thread to complete if
        // Client not yet identified
        //
        WaitForMultipleObjects( 1, &m_identifyThread, FALSE, 10000 );
    }

    //
    // Let the client know that the recall is starting or is finished
    //

    if ( m_identified ) {
    
        try {
            WsbTrace(OLESTR("CFsaFilterClient::SendRecallInfo - Client (%ls) is being notified of recall status (starting = %u hr = %x).\n"),
                        (WCHAR *) m_machineName, starting, rHr);
    
            //
            // Create intermediate server object which will be the client's
            // connection back to the service. This object acts as a middle
            // man to overcome the admin-only access into the FSA service.
            //
            CComPtr<IFsaRecallNotifyServer> pRecallServer;
            WsbAffirmHr(CoCreateInstance(CLSID_CFsaRecallNotifyServer, 0, CLSCTX_NO_FAILURE_LOG | CLSCTX_ALL, IID_IFsaRecallNotifyServer, (void**)&pRecallServer));
            WsbAffirmHr(pRecallServer->Init(pRecall));

            CComPtr<IFsaRecallNotifyClient> pRecallClient;
            hr = GetNotifyClientInterface ( m_machineName, &pRecallClient );
            if ( SUCCEEDED( hr ) ) {
                if (starting) {
                    hr = pRecallClient->OnRecallStarted ( pRecallServer );
                } else {
                    hr = pRecallClient->OnRecallFinished ( pRecallServer, rHr );
                }
                if (hr != S_OK) {
                    WsbTrace(OLESTR("CFsaFilterClient::SendRecallInfo - Got the interface but failed in OnRecall... (%ls)\n"), 
                        WsbHrAsString(hr));
                }
            } else {
                WsbTrace(OLESTR("CFsaFilterClient::SendRecallInfo - error getting notify client interface hr = %ls (%x)\n"),
                    WsbHrAsString( hr ), hr);
            }
        } WsbCatchAndDo(hr, 
            WsbTrace(OLESTR("CFsaFilterClient::SendRecallInfo - hr = %ls\n"),
                WsbHrAsString(hr));
            );
    }

    return(hr);

}



HRESULT
CFsaFilterClient::SetAuthenticationId(
    IN LONG luidHigh,
    IN ULONG luidLow
    )

/*++

Implements:

  IFsaFilterClient::SetAuthenticationId().

--*/
{
    m_luidHigh = luidHigh;
    m_luidLow = luidLow;

    return(S_OK);
}


HRESULT
CFsaFilterClient::SetDomainName(
    IN OLECHAR* name
    )

/*++

Implements:

  IFsaFilterClient::SetDomainName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        m_domainName = name;
        WsbAssert(m_domainName != 0, E_UNEXPECTED);

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterClient::SetIsAdmin(
    IN BOOLEAN isAdmin
    )

/*++

Implements:

  IFsaFilterClient::SetIsAdmin().

--*/
{
    m_isAdmin = isAdmin;

    return(S_OK);
}


HRESULT
CFsaFilterClient::SetLastRecallTime(
    IN FILETIME time
    )

/*++

Implements:

  IFsaFilterClient::SetLastRecallTime().

--*/
{
    m_lastRecallTime = time;

    return(S_OK);
}


HRESULT
CFsaFilterClient::SetMachineName(
    IN OLECHAR* name
    )

/*++

Implements:

  IFsaFilterClient::SetMachineName().

--*/
{
    HRESULT         hr = S_OK;

    try {
        WsbAssert(name != 0, E_UNEXPECTED);

        m_machineName = name;
        m_identified = TRUE;

        WsbTrace(OLESTR("CFsaFilterClient::SetMachineName Flag: %x  Client ID: %x:%x Source: %ls == %ls\n"), 
            m_identified, m_luidLow, m_luidHigh, (WCHAR *) m_tokenSource, (WCHAR *) m_machineName);


    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterClient::SetRecallCount(
    IN ULONG count
    )

/*++

Implements:

  IFsaFilterClient::SetRecallCount().

--*/
{
    m_recallCount = count;

    return(S_OK);
}


HRESULT
CFsaFilterClient::SetUserName(
    IN OLECHAR* name
    )

/*++

Implements:

  IFsaFilterClient::SetUserName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        m_userName = _wcsupr(name);
        WsbAssert(m_userName != 0, E_UNEXPECTED);

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterClient::SetHasRecallDisabled(
    IN BOOL     hasBeen
    )

/*++

Implements:

  IFsaFilterClient::SetHasRecallDisabled().

--*/
{
    m_hasRecallDisabled = hasBeen;

    return(S_OK);
}


HRESULT
CFsaFilterClient::SetHitRecallLimit(
    IN BOOL     hasBeen
    )

/*++

Implements:

  IFsaFilterClient::SetHitRecallLimit().

--*/
{
    m_hitRecallLimit = hasBeen;

    return(S_OK);
}




HRESULT
CFsaFilterClient::SetTokenSource(
    IN CHAR     *source
    )

/*++

Implements:

  IFsaFilterClient::SetTokenSource()

--*/
{
OLECHAR tSource[TOKEN_SOURCE_LENGTH + 1];


    mbstowcs((WCHAR *) tSource, source, TOKEN_SOURCE_LENGTH);   
    m_tokenSource = tSource;
    return(S_OK);
}


HRESULT
CFsaFilterClient::StartIdentify(
    void
    )

/*++

Implements:

  CFsaFilterClient::StartIdentify().

--*/
{
#define WSB_BUFF_SIZE           1024

    HRESULT             hr = S_OK;
    DWORD                   tid;


    WsbTraceIn(OLESTR("CFsaFilterClient::StartIdentify"), OLESTR(""));

    try {
        WsbTrace(OLESTR("CFsaFilterClient::StartIdentify Flag: %x  Client ID: %x:%x Source: %ls\n"), 
            m_identified, m_luidHigh, m_luidLow, (WCHAR *) m_tokenSource);

        //
        // If already identified then we bail out here.
        //
        WsbAffirm(m_identified == FALSE, S_OK);
        //
        // If the request is from User32 then it is local 
        //

        if (_wcsicmp(m_tokenSource, L"User32") == 0) {

            //
            // Identified as the local machine.
            // Set the name and bail out with S_OK
            //
            WsbGetComputerName( m_machineName );
            m_identified = TRUE;

            WsbTrace(OLESTR("CHsmFilterClient::StartIdentify: Identified as %ls.\n"),
                    (WCHAR *) m_machineName);

            WsbThrow( S_OK );
        } else {
            //
            // Start the identification thread
            //
            if (NULL == m_identifyThread) {
                WsbTrace(OLESTR("CHsmFilterClient::StartIdentify: Starting ID thread.\n"));

                WsbAffirm((m_identifyThread = CreateThread(0, 0, FsaIdentifyThread, (void*) this, 0, &tid)) != 0, HRESULT_FROM_WIN32(GetLastError()));
 
                if (m_identifyThread == NULL) {           
                    WsbAssertHr(E_FAIL);  // TBD What error to return here??
                }
            }
        }

        
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFsaFilterClient::StartIdentify"), OLESTR("hr = %ls"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CFsaFilterClient::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsaftrcl.h ===
#ifndef _FSAFTRCL_
#define _FSAFTRCL_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsaftrcl.h

Abstract:

    This class represents a filter initiated recall request that is still in-progress.

Author:

    Chuck Bardeen   [cbardeen]   12-Feb-1997

Revision History:

--*/

#include "resource.h"       // main symbols

#include "fsa.h"


/*++

Class Name:
    
    CFsaFilterRecall

Class Description:

    This class represents a filter initiated recall request that is still in-progress.

--*/

class CFsaFilterRecall : 
    public CWsbCollectable,
    public IFsaFilterRecall,
    public IFsaFilterRecallPriv,
    public CComCoClass<CFsaFilterRecall,&CLSID_CFsaFilterRecallNTFS>
{
public:
    CFsaFilterRecall() {}
BEGIN_COM_MAP(CFsaFilterRecall)
    COM_INTERFACE_ENTRY(IFsaFilterRecall)
    COM_INTERFACE_ENTRY(IFsaFilterRecallPriv)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_FsaFilterRecall)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void (FinalRelease)(void);
#ifdef FSA_RECALL_LEAK_TEST
    STDMETHOD_(unsigned long, InternalAddRef)(void);
    STDMETHOD_(unsigned long, InternalRelease)(void);
#endif
// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IFsaFilterRecall
public:
    STDMETHOD(CompareToIdentifier)(GUID id, SHORT* pResult);
    STDMETHOD(CompareToIRecall)(IFsaFilterRecall* pRecall, SHORT* pResult);
    STDMETHOD(CompareToDriversRecallId)(ULONGLONG id, SHORT* pResult);
    STDMETHOD(CompareToDriversContextId)(ULONGLONG id, SHORT* pResult);
    STDMETHOD(CompareBy)(FSA_RECALL_COMPARE by);
    STDMETHOD(GetIdentifier)(GUID* pId);
    STDMETHOD(GetMode)(ULONG* pMode);
    STDMETHOD(GetOffset)(LONGLONG* pOffset);
    STDMETHOD(GetPath)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetResource)(IFsaResource** ppResource);
    STDMETHOD(GetRecallFlags)(ULONG* recallFlags);
    STDMETHOD(GetSession)(IHsmSession** ppSession);
    STDMETHOD(GetSize)(LONGLONG* pSize);
    STDMETHOD(GetState)(HSM_JOB_STATE* pState);
    STDMETHOD(GetUserName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(HasCompleted)(HRESULT resultHr);
    STDMETHOD(WasCancelled)(void);
    STDMETHOD(CreateLocalStream)(IStream **ppStream);
    STDMETHOD(CheckRecallLimit)(DWORD minRecallInterval, DWORD maxRecalls, BOOLEAN exemptAdmin);
    STDMETHOD(AddClient)(IFsaFilterClient *pWaitingClient);

// IFsaFilterRecallPriv
public:
    STDMETHOD(Cancel)(void);
    STDMETHOD(CancelByDriver)(void);
    STDMETHOD(Delete)(void);
    STDMETHOD(GetClient)(IFsaFilterClient** ppClient);
    STDMETHOD(GetDriversRecallId)(ULONGLONG* pId);
    STDMETHOD(SetDriversRecallId)(ULONGLONG pId);
    STDMETHOD(SetThreadId)(DWORD id);
    STDMETHOD(GetPlaceholder)(FSA_PLACEHOLDER* pPlaceholder);
    STDMETHOD(Init)(IFsaFilterClient* pClient, ULONGLONG pDriversRecallId, IFsaResource* pResource, OLECHAR* path, LONGLONG fileId, LONGLONG offset, LONGLONG size, ULONG mode, FSA_PLACEHOLDER* pPlaceholder, IFsaFilterPriv* pFilterPriv);
    STDMETHOD(SetIdentifier)(GUID id);
    STDMETHOD(StartRecall)(ULONGLONG offset, ULONGLONG size);
    STDMETHOD(GetStream)(IStream **ppStream);
    STDMETHOD(LogComplete)(HRESULT hr);

protected:
    CComPtr<IFsaFilterClient>   m_pClient;          
    CComPtr<IWsbCollection>     m_pWaitingClients;          
    BOOL                        m_waitingClientsNotified;
    HANDLE                      m_waitingClientEvent;
    HANDLE                      m_notifyEvent;      // An event for signaling on recall notify
    IFsaFilterPriv*             m_pFilterPriv;      // Parent Pointer, Weak Reference
    ULONGLONG                   m_driversRecallId;
    ULONG                       m_mode;
    LONGLONG                    m_offset;
    LONGLONG                    m_size;
    LONGLONG                    m_fileId;
    GUID                        m_id;
    CWsbStringPtr               m_path;
    FSA_PLACEHOLDER             m_placeholder;
    CComPtr<IFsaResource>       m_pResource;
    CComPtr<IHsmSession>        m_pSession;
    HSM_JOB_STATE               m_state;
    BOOL                        m_wasCancelled;
    DWORD                       m_cookie;
    BOOL                        m_kernelCompletionSent;
    CComPtr<IDataMover>         m_pDataMover;
    CComPtr<IStream>            m_pStream;
    ULONG                       m_compareBy;
    FILETIME                    m_startTime;
    ULONG                       numRefs;
    ULONG                       m_recallFlags;
    DWORD                       m_threadId; //thread id of thread causing recall
};

#endif  // _FSAFTRCL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsaftclt.h ===
#ifndef _FSAFTCLT_
#define _FSAFTCLT_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsafltr.cpp

Abstract:

    This class represents a user who the filter has detected accessing a file with placeholder information.

Author:

    Chuck Bardeen   [cbardeen]   12-Feb-1997

Revision History:

--*/

#include "resource.h"       // main symbols

#include "fsa.h"


/*++

Class Name:
    
    CFsaFilterClient

Class Description:

    This class represents a user who the filter has detected accessing a file with placeholder information.

--*/

class CFsaFilterClient : 
    public CWsbCollectable,
    public IFsaFilterClient,
    public CComCoClass<CFsaFilterClient,&CLSID_CFsaFilterClientNTFS>
{
public:
    CFsaFilterClient() {}
BEGIN_COM_MAP(CFsaFilterClient)
    COM_INTERFACE_ENTRY(IFsaFilterClient)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_FsaFilterClient)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void (FinalRelease)(void);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IFsaFilterClient
public:
    STDMETHOD(CompareBy)(FSA_FILTERCLIENT_COMPARE by);
    STDMETHOD(CompareToAuthenticationId)(LONG luidHigh, ULONG luidLow, SHORT* pResult);
    STDMETHOD(CompareToIClient)(IFsaFilterClient* pClient, SHORT* pResult);
    STDMETHOD(CompareToMachineName)(OLECHAR* name, SHORT* pResult);
    STDMETHOD(GetAuthenticationId)(LONG* pLuidHigh, ULONG* pLuidLow);
    STDMETHOD(GetDomainName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetLastRecallTime)(FILETIME* pTime);
    STDMETHOD(GetMachineName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetRecallCount)(ULONG* pCount);
    STDMETHOD(GetUserName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(HasRecallDisabled)(void);
    STDMETHOD(HitRecallLimit)(void);
    STDMETHOD(SetAuthenticationId)(LONG luidHigh, ULONG luidLow);
    STDMETHOD(SetDomainName)(OLECHAR* pName);
    STDMETHOD(SetHasRecallDisabled)(BOOL isDisabled);
    STDMETHOD(SetHitRecallLimit)(BOOL hitLimit);
    STDMETHOD(SetLastRecallTime)(FILETIME time);
    STDMETHOD(SetMachineName)(OLECHAR* pName);
    STDMETHOD(SetRecallCount)(ULONG count);
    STDMETHOD(SetUserName)(OLECHAR* pName);
    STDMETHOD(StartIdentify)();
    STDMETHOD(SetTokenSource)(CHAR *source);
    STDMETHOD(SendRecallInfo)(IFsaFilterRecall *pRecall, BOOL starting, HRESULT rHr);
    STDMETHOD(IdentifyThread)(void);
    STDMETHOD(SetIsAdmin)(BOOLEAN isAdmin);
    STDMETHOD(GetIsAdmin)(BOOLEAN *isAdmin);
    STDMETHOD(CheckRecallLimit)(DWORD minRecallInterval, DWORD maxRecalls, BOOLEAN exemptAdmin);

protected:
    FSA_FILTERCLIENT_COMPARE    m_compareBy;
    LONG                        m_luidHigh;
    ULONG                       m_luidLow;
    CWsbStringPtr               m_domainName;
    BOOL                        m_hasRecallDisabled;
    BOOL                        m_hitRecallLimit;
    FILETIME                    m_lastRecallTime;
    CWsbStringPtr               m_machineName;
    ULONG                       m_recallCount;
    CWsbStringPtr               m_userName;
    BOOL                        m_identified;
    CWsbStringPtr               m_tokenSource;
    ULONG                       m_msgCounter;
    HANDLE                      m_identifyThread;
    BOOLEAN                     m_isAdmin;
    BOOLEAN                     m_loggedLimitError;
};

#endif  // _FSAFTCLT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsaftrcl.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    fsaftrcl.cpp

Abstract:

    This class represents a filter initiated recall request that is still in-progress.

Author:

    Chuck Bardeen   [cbardeen]   12-Feb-1997

Revision History:

--*/




#include "stdafx.h"
#include "devioctl.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_FSA

#include "wsb.h"
#include "fsa.h"
#include "job.h"
#include "fsaftrcl.h"
#include "rpdata.h"
#include "rpio.h"

static USHORT iCountFtrcl = 0;  // Count of existing objects


HRESULT
CFsaFilterRecall::Cancel(
    void
    )

/*++

Implements:

  IFsaFilterRecallPriv::Cancel().

--*/
{
    CComPtr<IFsaFilterClient>       pClient;
    CComPtr<IWsbEnum>               pEnum;
    HRESULT                         hr = S_OK, hr2;
    DWORD                           dwStatus;


    WsbTraceIn(OLESTR("CFsaFilterRecall::Cancel"), OLESTR("filter Id = %I64x"),
            m_driversRecallId);
    
    try {

        WsbAffirm(!m_wasCancelled, E_UNEXPECTED);

        try {
                
            //
            // Tell the  filter to fail the open of the file.
            //
            if (m_kernelCompletionSent == FALSE) {
                WsbAffirmHr(m_pFilterPriv->SendCancel((IFsaFilterRecallPriv *) this));
                m_kernelCompletionSent = TRUE;
                m_wasCancelled = TRUE;
            }
    
            if (m_pClient != 0) {
                // Reporting on recall end must be synchronized with the recall start notification, 
                // because such notification might be sent after the recall starts
                switch (WaitForSingleObject(m_notifyEvent, INFINITE)) {
                    case WAIT_OBJECT_0:
                        m_pClient->SendRecallInfo((IFsaFilterRecall *) this, FALSE, HRESULT_FROM_WIN32(ERROR_OPERATION_ABORTED));
                        SetEvent(m_notifyEvent);
                        break;

                    case WAIT_FAILED:
                    default:
                        WsbTrace(OLESTR("CFsaFilterRecall::Cancel: WaitForSingleObject returned error %lu\n"), GetLastError());

                        // Notify anyway
                        m_pClient->SendRecallInfo((IFsaFilterRecall *) this, FALSE, HRESULT_FROM_WIN32(ERROR_OPERATION_ABORTED));
                        break;
                }
            }

            dwStatus = WaitForSingleObject(m_waitingClientEvent, INFINITE);

            // Notify on recall end no matter what the status is
            if (m_pWaitingClients != 0) {
                // 
                // Send recall notifications to all clients waiting for 
                // the recall to finish
                //
                hr2 = m_pWaitingClients->Enum(&pEnum);
                if (S_OK == hr2) {
                    hr2 = pEnum->First(IID_IFsaFilterClient, (void**) &pClient);
                    while (S_OK == hr2) {
                        pClient->SendRecallInfo((IFsaFilterRecall *) this, FALSE, HRESULT_FROM_WIN32(ERROR_OPERATION_ABORTED));         
                        m_pWaitingClients->RemoveAndRelease(pClient);
                        pClient = NULL;
                        pEnum->Reset();
                        hr2 = pEnum->First(IID_IFsaFilterClient, (void**) &pClient);
                    }
                }
            }

            m_waitingClientsNotified = TRUE;

            switch (dwStatus) {
                case WAIT_OBJECT_0:
                    SetEvent(m_waitingClientEvent);
                    break;

                case WAIT_FAILED:
                default:
                    WsbTrace(OLESTR("CFsaFilterRecall::Cancel: WaitForSingleObject returned error %lu\n"), dwStatus);
                    break;
            }            
            
            //
            // Now get the engine to cancel it, if possible..
            //
            if (m_pSession != 0) {
                WsbAffirmHr(m_pSession->Cancel(HSM_JOB_PHASE_ALL));
            }

        } WsbCatch(hr);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterRecall::Cancel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterRecall::CancelByDriver(
    void
    )

/*++

Implements:

  IFsaFilterRecallPriv::CancelByDriver().

--*/
{
    HRESULT                 hr = S_OK;


    WsbTraceIn(OLESTR("CFsaFilterRecall::CancelByDriver"), OLESTR("filter Id = %I64x"),
            m_driversRecallId);
    
    try {

        WsbAffirm(!m_wasCancelled, E_UNEXPECTED);

        try {
            //
            // No need to tell the filter anymore - reset the flag.
            //
            m_kernelCompletionSent = TRUE;
            //
            // Now get the engine to cancel it, if possible..
            //
            if (m_pSession != 0) {
                WsbAffirmHr(m_pSession->Cancel(HSM_JOB_PHASE_ALL));
            }

        } WsbCatch(hr);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterRecall::CancelByDriver"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterRecall::CompareBy(
    IN FSA_RECALL_COMPARE by
    )

/*++

Implements:

  IWsbCollectable::CompareBy().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterRecall::CompareBy"), OLESTR("by = %ld"),
            static_cast<LONG>(by));
    
    try {
        m_compareBy = by;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterRecall::CompareBy"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterRecall::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IFsaFilterRecall>       pRecall;
    CComPtr<IFsaFilterRecallPriv>   pRecallPriv;
    ULONGLONG                       id;


    // WsbTraceIn(OLESTR("CFsaFilterRecall::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        if (m_compareBy == FSA_RECALL_COMPARE_IRECALL) {
            // We need the IFsaFilterRecall interface to get the value of the object.
            WsbAffirmHr(pUnknown->QueryInterface(IID_IFsaFilterRecall, (void**) &pRecall));
            // Compare the rules.
            hr = CompareToIRecall(pRecall, pResult);
        } else {
            // We need the IFsaFilterRecallPriv interface to get the value of the object.
            WsbAffirmHr(pUnknown->QueryInterface(IID_IFsaFilterRecallPriv, (void**) &pRecallPriv));
            WsbAffirmHr(pRecallPriv->GetDriversRecallId(&id));
            // Compare the driver id
            if (m_compareBy == FSA_RECALL_COMPARE_CONTEXT_ID) {
                hr = CompareToDriversContextId((id&0xFFFFFFFF), pResult);
            } else {
                hr = CompareToDriversRecallId(id, pResult);
           }
        }
    } WsbCatch(hr);

    // WsbTraceOut(OLESTR("CFsaFilterRecall::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CFsaFilterRecall::CompareToDriversRecallId(
    IN ULONGLONG id,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaFilterRecall::CompareToDriversRecallId().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult;

    // WsbTraceIn(OLESTR("CFsaFilterRecall::CompareToDriversRecallId"), OLESTR(""));

    try {
        
        if (m_driversRecallId == id)
            aResult = 0;
        else
            aResult = 1;

        if (0 != aResult) {
            hr = S_FALSE;
        }
        
        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    // WsbTraceOut(OLESTR("CFsaFilterRecall::CompareToDriversRecallId"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CFsaFilterRecall::CompareToDriversContextId(
    IN ULONGLONG id,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaFilterRecall::CompareToDriversContextId().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult;

    // WsbTraceIn(OLESTR("CFsaFilterRecall::CompareToDriversContextId"), OLESTR(""));

    try {
        
        if ((m_driversRecallId & 0xFFFFFFFF) == id)
            aResult = 0;
        else
            aResult = 1;

        if (0 != aResult) {
            hr = S_FALSE;
        }
        
        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    // WsbTraceOut(OLESTR("CFsaFilterRecall::CompareToDriversContextId"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CFsaFilterRecall::CompareToIdentifier(
    IN GUID id,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaFilterRecall::CompareToIdentifier().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult;

    // WsbTraceIn(OLESTR("CFsaFilterRecall::CompareToIdentifier"), OLESTR(""));

    try {

        aResult = WsbSign( memcmp(&m_id, &id, sizeof(GUID)) );

        if (0 != aResult) {
            hr = S_FALSE;
        }
        
        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    // WsbTraceOut(OLESTR("CFsaFilterRecall::CompareToIdentifier"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CFsaFilterRecall::CompareToIRecall(
    IN IFsaFilterRecall* pRecall,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaFilterRecall::CompareToIRecall().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   name;
    GUID            id;

    // WsbTraceIn(OLESTR("CFsaFilterRecall::CompareToIRecall"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pRecall, E_POINTER);

        WsbAffirmHr(pRecall->GetIdentifier(&id));
        hr = CompareToIdentifier(id, pResult);

    } WsbCatch(hr);

    // WsbTraceOut(OLESTR("CFsaFilterRecall::CompareToIRecall"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CFsaFilterRecall::CreateLocalStream(
    OUT IStream **ppStream
    )  

/*++

Implements:

  IFsaFilterRecall::CreateLocalStream().

--*/
{
    HRESULT         hr = S_OK;
    WCHAR           idString[50];
    CWsbStringPtr   pDrv;
    OLECHAR         volume[64];
    

    WsbTraceIn(OLESTR("CFsaFilterRecall::CreateLocalStream"), OLESTR("filter Id = %I64x"),
            m_driversRecallId);

    try {
        WsbAssert( 0 != ppStream, E_POINTER);

        swprintf(idString, L"%I64u", m_driversRecallId);
        
        WsbAffirmHr( CoCreateInstance( CLSID_CFilterIo, 0, CLSCTX_SERVER, IID_IDataMover, (void **)&m_pDataMover ) );
        WsbAssertHr( m_pDataMover->CreateLocalStream(
                idString, MVR_MODE_WRITE | MVR_FLAG_HSM_SEMANTICS | MVR_FLAG_POSIX_SEMANTICS, &m_pStream ) );
        //
        // Set the device name for  the mover which is used to recall the file.
        // This is the RsFilter's primary device object's name to which the 
        // the RP_PARTIAL_DATA msgs etc. will be sent
        // 
        WsbAffirmHr(m_pResource->GetPath(&pDrv,0));
        swprintf(volume, L"\\\\.\\%s", pDrv);
        //
        // strip trailing backslash if any
        //
        if (volume[wcslen(volume)-1] == L'\\') {
            volume[wcslen(volume)-1] = L'\0';
        }   
        WsbAssertHr( m_pDataMover->SetDeviceName(RS_FILTER_SYM_LINK,
                                                 volume));

        *ppStream = m_pStream;
        m_pStream->AddRef();


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterRecall::CreateLocalStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}



HRESULT
CFsaFilterRecall::Delete(
    void
    )

/*++

Implements:

  IFsaFilterRecallPriv::Delete().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterRecall::Delete"), OLESTR("filter Id = %I64x"),
            m_driversRecallId);
    
    try {
        //
        // Tell the kernel mode filter to fail the open of the file.
        //
        if (m_kernelCompletionSent == FALSE) {
            WsbAffirmHr(m_pFilterPriv->SendCancel((IFsaFilterRecallPriv *) this));
            m_kernelCompletionSent = TRUE;
            m_wasCancelled = TRUE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterRecall::Delete"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterRecall::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterRecall::FinalConstruct"), OLESTR(""));
    
    try {

        WsbAffirmHr(CWsbCollectable::FinalConstruct());

        m_notifyEvent = NULL;
        m_waitingClientEvent = NULL;
        m_driversRecallId = 0;
        memset(&m_placeholder, 0, sizeof(FSA_PLACEHOLDER));
        m_state = HSM_JOB_STATE_IDLE;
        m_wasCancelled = FALSE;
        m_kernelCompletionSent = FALSE;
        m_pDataMover = 0;
        m_pStream = 0;
        m_recallFlags = 0;
        m_compareBy = FSA_RECALL_COMPARE_IRECALL;
        WsbAffirmHr(CoCreateGuid(&m_id));
        numRefs = 0;
        m_waitingClientsNotified = FALSE;

        // Initialize notify synchronization event and waiting clients event
        WsbAffirmHandle((m_notifyEvent = CreateEvent(NULL, FALSE, TRUE, NULL)));
        WsbAffirmHandle((m_waitingClientEvent = CreateEvent(NULL, FALSE, TRUE, NULL)));
        
        // Create the waiting client collection.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_SERVER, IID_IWsbCollection, (void**) &m_pWaitingClients));
    
    } WsbCatch(hr);

    iCountFtrcl++;

    WsbTraceOut(OLESTR("CFsaFilterRecall::FinalConstruct"), OLESTR("hr = %ls, Count is <%d>"), WsbHrAsString(hr), iCountFtrcl);

    return(hr);
}


void
CFsaFilterRecall::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{

    WsbTraceIn(OLESTR("CFsaFilterRecall::FinalRelease"), OLESTR(""));
    
    CWsbCollectable::FinalRelease();

    // Free notify synchronization event and waiting client event 
    if (m_waitingClientEvent != NULL) {
        CloseHandle(m_waitingClientEvent);
        m_waitingClientEvent = NULL;
    }
    if (m_notifyEvent != NULL) {
        CloseHandle(m_notifyEvent);
        m_notifyEvent = NULL;
    }

    iCountFtrcl--;

    WsbTraceOut(OLESTR("CFsaFilterRecall::FinalRelease"), OLESTR("Count is <%d>"), iCountFtrcl);

}


#ifdef FSA_RECALL_LEAK_TEST



ULONG
CFsaFilterRecall::InternalAddRef(
    void
    )

/*++

Implements:

  CComObjectRoot::AddRef().

--*/
{

    numRefs++;  
    WsbTrace(OLESTR("CFsaFilterRecall::AddRef (%p) - Count = %u\n"), this, numRefs);
    return(CComObjectRoot::InternalAddRef());
}


ULONG
CFsaFilterRecall::InternalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::InternalRelease().

--*/
{
    
    WsbTrace(OLESTR("CFsaFilterRecall::Release (%p) - Count = %u\n"), this, numRefs);
    numRefs--;  
    return(CComObjectRoot::InternalRelease());
}

#endif



HRESULT
CFsaFilterRecall::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterRecall::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CFsaFilterRecallNTFS;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterRecall::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CFsaFilterRecall::GetClient(
    OUT IFsaFilterClient** ppClient
    )

/*++

Implements:

  IFsaFilterRecallPriv::GetClient().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != ppClient, E_POINTER);

        *ppClient = m_pClient;
        if (m_pClient != 0) {
            m_pClient->AddRef();
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::GetRecallFlags(
    OUT ULONG *pFlags
    )  

/*++

Implements:

  IFsaFilterRecall::GetRecallFlags()

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterRecall::GetRecallFlags"), OLESTR(""));
    try {
        WsbAssert( 0 != pFlags, E_POINTER);
        *pFlags = m_recallFlags;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterRecall::GetRecallFlags"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaFilterRecall::GetStream(
    OUT IStream **ppStream
    )  

/*++

Implements:

  IFsaFilterRecall::GetStream()

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterRecall::GetStream"), OLESTR(""));
    try {
        WsbAssert( 0 != ppStream, E_POINTER);
        if ((m_mode & FILE_OPEN_NO_RECALL) && (m_pStream != 0)) {
            *ppStream = m_pStream;
            m_pStream->AddRef();
        } else {
            *ppStream = 0;
            hr = WSB_E_NOTFOUND;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterRecall::GetStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}



HRESULT
CFsaFilterRecall::GetDriversRecallId(
    OUT ULONGLONG* pId
    )

/*++

Implements:

  IFsaFilterRecallPriv::GetDriversRecallId().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);

        *pId = m_driversRecallId;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::GetIdentifier(
    OUT GUID* pId
    )

/*++

Implements:

  IFsaFilterRecall::GetIdentifier().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);

        *pId = m_id;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::GetMode(
    OUT ULONG* pMode
    )

/*++

Implements:

  IFsaFilterRecall::GetMode().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pMode, E_POINTER);

        *pMode = m_mode;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::GetOffset(
    OUT LONGLONG* pOffset
    )

/*++

Implements:

  IFsaFilterRecall::GetOffset().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pOffset, E_POINTER);

        *pOffset = m_offset;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::GetPath(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaFilterRecall::GetPath().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pName, E_POINTER);

        WsbAffirmHr(tmpString.TakeFrom(*pName, bufferSize));

        try {
            WsbAffirmHr(m_pResource->GetUncPath(&tmpString, 0));
            WsbAffirmHr(tmpString.Append(m_path));
        } WsbCatch(hr);

        WsbAffirmHr(tmpString.GiveTo(pName));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::GetPlaceholder(
    OUT FSA_PLACEHOLDER* pPlaceholder
    )

/*++

Implements:

  IFsaFilterRecallPriv::GetPlaceholder().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pPlaceholder, E_POINTER); 
        *pPlaceholder = m_placeholder;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::GetResource(
    OUT IFsaResource** ppResource
    )

/*++

Implements:

  IFsaFilterRecall::GetResource().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != ppResource, E_POINTER);

        *ppResource = m_pResource;
        m_pResource->AddRef();

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::GetSession(
    OUT IHsmSession** ppSession
    )

/*++

Implements:

  IFsaFilterRecall::GetSession().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != ppSession, E_POINTER);

        *ppSession = m_pSession;
        m_pSession->AddRef();

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::GetSize(
    OUT LONGLONG* pSize
    )

/*++

Implements:

  IFsaFilterRecall::GetSize().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pSize, E_POINTER);

        *pSize = m_size;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                 hr = S_OK;


    WsbTraceIn(OLESTR("CFsaFilterRecall::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pSize, E_POINTER);
        pSize->QuadPart = 0;

        // WE don't need to persist these.
        hr = E_NOTIMPL;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterRecall::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CFsaFilterRecall::GetState(
    OUT HSM_JOB_STATE* pState
    )

/*++

Implements:

  IFsaFilterRecall::GetState().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pState, E_POINTER); 
        *pState = m_state;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::GetUserName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaFilterRecall::GetUserName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pName, E_POINTER);

        if (m_pClient != 0) {
            WsbAffirmHr(m_pClient->GetUserName(pName, bufferSize));
        } else {
            hr = WSB_E_NOTFOUND;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::HasCompleted(
    HRESULT     resultHr
    )

/*++

Implements:

  IFsaFilterRecall::HasCompleted().

--*/
{
    HRESULT                         hr = S_OK, hr2 = S_OK;
    CComPtr<IFsaFilterClient>       pClient;
    CComPtr<IWsbEnum>               pEnum;
    FILETIME                        now;
    BOOL                            bSendNotify = TRUE;
    DWORD                           dwStatus;
    

    WsbTraceIn(OLESTR("CFsaFilterRecall::HasCompleted"), 
            OLESTR("filter Id = %I64x, recall hr = <%ls>"), m_driversRecallId,
            WsbHrAsString(resultHr));

    try {

        // The job is complete, let the kernel mode filter know what happened.

        GetSystemTimeAsFileTime(&now);

        if (m_pClient != 0) {
            m_pClient->SetLastRecallTime(now);      // Not fatal if this fails
        }

        if (m_kernelCompletionSent == FALSE) {
            WsbAffirmHr(m_pFilterPriv->SendComplete((IFsaFilterRecallPriv *) this, resultHr));
            m_kernelCompletionSent = TRUE;
        }

        if (m_pClient != 0) {
            // Reporting on recall end must be synchronized with the recall start notification, 
            // because such notification might be sent after the recall starts
            switch (WaitForSingleObject(m_notifyEvent, INFINITE)) {
                case WAIT_OBJECT_0:
                    // Send recall notifications to the client that initiated the recall 
                    m_pClient->SendRecallInfo((IFsaFilterRecall *) this, FALSE, resultHr);
                    SetEvent(m_notifyEvent);
                    break;

                 case WAIT_FAILED:
                 default:
                    WsbTrace(OLESTR("CFsaFilterRecall::HasCompleted: WaitForSingleObject returned error %lu\n"), GetLastError());

                    // Notify anyway
                    m_pClient->SendRecallInfo((IFsaFilterRecall *) this, FALSE, resultHr);
                    break;
            }

            bSendNotify = FALSE;    
        }

        dwStatus = WaitForSingleObject(m_waitingClientEvent, INFINITE);

        // Notify on recall end no matter what the status is
        if (m_pWaitingClients != 0) {
            // 
            // Send recall notifications to all clients waiting for the recall 
            // to finish
            //
            hr2 = m_pWaitingClients->Enum(&pEnum);
            if (S_OK == hr2) {
                hr2 = pEnum->First(IID_IFsaFilterClient, (void**) &pClient);
                while (S_OK == hr2) {
                   pClient->SendRecallInfo((IFsaFilterRecall *) this, FALSE, resultHr);            
                   m_pWaitingClients->RemoveAndRelease(pClient);
                   pClient = NULL;
                   pEnum->Reset();
                   hr2 = pEnum->First(IID_IFsaFilterClient, (void**) &pClient);
                }
            }
        }

        m_waitingClientsNotified = TRUE;

        switch (dwStatus) {
            case WAIT_OBJECT_0:
                SetEvent(m_waitingClientEvent);
                break;

            case WAIT_FAILED:
            default:
                WsbTrace(OLESTR("CFsaFilterRecall::HasCompleted: WaitForSingleObject returned error %lu\n"), dwStatus);
                break;
        }            

        //
        // Detach the data mover stream
        //
        if (m_pDataMover != 0) {    
            WsbAffirmHr( m_pDataMover->CloseStream() );
        }

    } WsbCatchAndDo(hr,
        if ((m_pClient != 0) && bSendNotify) {
            m_pClient->SendRecallInfo((IFsaFilterRecall *) this, FALSE, resultHr);
            bSendNotify = FALSE;
        }
    );

    WsbTraceOut(OLESTR("CFsaFilterRecall::HasCompleted"), OLESTR("filter Id = %I64x, sent = <%ls>, hr = <%ls>"), 
            m_driversRecallId, WsbBoolAsString(m_kernelCompletionSent), 
            WsbHrAsString(hr));

    return(hr);
}



HRESULT
CFsaFilterRecall::CheckRecallLimit(
    IN DWORD   minRecallInterval,
    IN DWORD   maxRecalls,
    IN BOOLEAN exemptAdmin
    )

/*++

Implements:

  IFsaFilterRecall::CheckRecallLimit().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterRecall::CheckRecallLimit"), OLESTR("filter Id = %I64x"),
            m_driversRecallId);

    try {

        // Check the limit if we are not file open no recall
        if (!(m_mode & FILE_OPEN_NO_RECALL) && (m_pClient != NULL)) {
            WsbAffirmHr(m_pClient->CheckRecallLimit(minRecallInterval, maxRecalls, exemptAdmin));
        }

    } WsbCatch(hr);

    //
    //  Commenting the following out: we are reverting back to 
    //  denial of service when we hit the recall limit, not trunc-on-close
    //
    //  If we hit the recall limit then we start to truncate on close.
    //
    // if (hr == FSA_E_HIT_RECALL_LIMIT) {
    //    m_recallFlags |= RP_RECALL_ACTION_TRUNCATE;
    // }
    WsbTraceOut(OLESTR("CFsaFilterRecall::CheckRecallLimit"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterRecall::Init(
    IN IFsaFilterClient* pClient,
    IN ULONGLONG DriversRecallId,
    IN IFsaResource* pResource,
    IN OLECHAR* path,
    IN LONGLONG fileId,
    IN LONGLONG offset,
    IN LONGLONG size,
    IN ULONG mode,
    IN FSA_PLACEHOLDER* pPlaceholder,
    IN IFsaFilterPriv *pFilterPriv
    )

/*++

Implements:

  IFsaFilterRecallPriv::Init().

--*/
{
    HRESULT                             hr = S_OK;
    FILETIME                            now;
    CComPtr<IFsaResourcePriv>           pResourcePriv;

    WsbTraceIn(OLESTR("CFsaFilterRecall::Init"), OLESTR("filter ID = %I64x, offset = %I64u, size = %I64u"), 
            DriversRecallId, offset, size);

    try {
        m_pClient = pClient;
        m_driversRecallId = DriversRecallId;
        m_pResource = pResource;
        m_placeholder = *pPlaceholder;
        m_pFilterPriv = pFilterPriv;
        m_path = path;
        m_mode = mode;
        m_fileId = fileId;
        GetSystemTimeAsFileTime(&m_startTime);

        m_offset = offset;
        m_size = size;
        m_isDirty = TRUE;

        WsbAssert(m_path != 0, E_UNEXPECTED);
        //
        // Get the recall started with the engine
        // Start a session and ask it to advise us of state changes.
        // Tell the resource object that we got an open.
        //

        hr = S_OK;
        
    } WsbCatchAndDo(hr,
        // 
        // Something failed - send the kernel completion if it has not been sent already.
        //
        GetSystemTimeAsFileTime(&now);
        if (m_pClient != 0) {
            m_pClient->SetLastRecallTime(now);
        }
        if (m_kernelCompletionSent == FALSE) {
            m_pFilterPriv->SendComplete((IFsaFilterRecallPriv *) this, hr);
            m_kernelCompletionSent = TRUE;
        } else  {
            WsbLogEvent(FSA_MESSAGE_RECALL_FAILED, 0, NULL, (OLECHAR*) WsbAbbreviatePath(path, 120), WsbHrAsString(hr), NULL);
        }

        if (m_pClient != 0) {
            m_pClient->SendRecallInfo((IFsaFilterRecall *) this, FALSE, E_FAIL);  // Not fatal if this fails
        }

    );

    WsbTraceOut(OLESTR("CFsaFilterRecall::Init"), OLESTR("%ls"), WsbHrAsString(hr));

    return(hr);
}

    

HRESULT
CFsaFilterRecall::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaFilterRecall::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // No persistence.
        hr = E_NOTIMPL;

    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CFsaFilterRecall::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterRecall::LogComplete(
    IN HRESULT result
    )

/*++

Implements:

  IFsaFilterRecallPriv:LogComplete(HRESULT result)

--*/
{
    HRESULT                     hr = S_OK;
    FILETIME                    completeTime;
    LONGLONG                    recallTime;

    WsbTraceIn(OLESTR("CFsaFilterRecall::LogComplete"), OLESTR("filter Id = %I64x"),
            m_driversRecallId);

    try {
        // Calculate the time it took for this recall to complete
        GetSystemTimeAsFileTime(&completeTime);
        recallTime = WsbFTtoLL(WsbFtSubFt(completeTime, m_startTime));
        // If over 10 minutes then show time in minutes otherwise show in seconds
        if (recallTime >= (WSB_FT_TICKS_PER_MINUTE * (LONGLONG) 10)) {
            recallTime = recallTime / WSB_FT_TICKS_PER_MINUTE;
            WsbTrace(OLESTR("CFsaFilterRecall::LogComplete Recall of %ws completed in %I64u minutes. (%ws)\n"),
                WsbAbbreviatePath(m_path, 120), recallTime, WsbHrAsString(result));
            WsbLogEvent(FSA_MESSAGE_RECALL_TIMING_MINUTES, 0, NULL, 
                WsbAbbreviatePath(m_path, 120), WsbLonglongAsString(recallTime), WsbHrAsString(result), NULL);
        } else {
            recallTime = recallTime / WSB_FT_TICKS_PER_SECOND;
            WsbTrace(OLESTR("CFsaFilterRecall::LogComplete Recall of %ws completed in %I64u seconds. (%ws)\n"),
                WsbAbbreviatePath(m_path, 120), recallTime, WsbHrAsString(result));
            WsbLogEvent(FSA_MESSAGE_RECALL_TIMING_SECONDS, 0, NULL, 
                WsbAbbreviatePath(m_path, 120), WsbLonglongAsString(recallTime), WsbHrAsString(result), NULL);
        }

    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CFsaFilterRecall::LogComplete"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterRecall::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistStream> pPersistStream;

    WsbTraceIn(OLESTR("CFsaFilterRecall::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // No persistence.
        hr = E_NOTIMPL;

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaFilterRecall::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaFilterRecall::SetDriversRecallId(
    IN ULONGLONG pId
    )

/*++

Implements:

  IFsaFilterRecallPriv::SetDriversRecallId().

--*/
{
    HRESULT         hr = S_OK;

    try {

        m_driversRecallId = pId;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::SetThreadId(
    IN DWORD id
    )

/*++

Implements:

  IFsaFilterRecallPriv::SetThreadId().

--*/
{
    HRESULT         hr = S_OK;

    try {

        m_threadId = id;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::SetIdentifier(
    IN GUID id
    )

/*++

Implements:

  IFsaFilterRecallPriv::SetIdentifier().

--*/
{
    HRESULT         hr = S_OK;

    m_id = id;
    m_isDirty = TRUE;

    return(hr);
}



HRESULT
CFsaFilterRecall::StartRecall(
    IN ULONGLONG offset,
    IN ULONGLONG size
    )

/*++

Implements:

  IFsaFilterRecallPriv::StartRecall().

--*/
{
    HRESULT                             hr = S_OK;
    FILETIME                            now;
    CComPtr<IFsaResourcePriv>           pResourcePriv;
    CWsbStringPtr                       sessionName;
    ULONG                               tryLoop;
    BOOL                                bSentNotify = FALSE;


    WsbTraceIn(OLESTR("CFsaFilterRecall::StartRecall"), OLESTR("filter Id = %I64x"),
            m_driversRecallId);

    try {
        m_offset = offset;
        m_size = size;
        if (m_mode & FILE_OPEN_NO_RECALL) {
            if (m_offset >= m_placeholder.dataStreamSize) {
                //
                // Read beyond the end of file
                //
                hr = STATUS_END_OF_FILE;
                WsbAffirmHr(hr);
            } else if ( (m_offset + m_size) > (m_placeholder.dataStreamStart + m_placeholder.dataStreamSize) ) {
                //
                // They are asking for more than we have - adjust the read size
                //
                m_size -= (m_offset + m_size) - (m_placeholder.dataStreamStart + m_placeholder.dataStreamSize);
            }
        }

        m_isDirty = TRUE;

        WsbAssert(m_path != 0, E_UNEXPECTED);
        //
        // Get the recall started with the engine
        // Start a session and ask it to advise us of state changes.
        // Tell the resource object that we got an open.
        //
        WsbTrace(OLESTR("CFsaFilterRecall::StartRecall:  BeginSession\n"));

        // Get the string that we are using to describe the session.
        WsbAffirmHr(sessionName.LoadFromRsc(_Module.m_hInst, IDS_FSA_RECALL_NAME));

        WsbAffirmHr(m_pResource->BeginSession(sessionName, HSM_JOB_LOG_ITEMMOSTFAIL | HSM_JOB_LOG_HR, 1, 1, &m_pSession));

        WsbTrace(OLESTR("CFsaFilterRecall::StartRecall: Session is setup.\n"));
        WsbTrace(OLESTR("CFsaFilterRecall::StartRecall: Notify the client that the recall started.\n"));

        if (m_pClient != 0) {
            hr = m_pClient->SendRecallInfo((IFsaFilterRecall *) this, TRUE, S_OK);  // Not fatal if this fails
            if (hr != S_OK) {
                WsbTrace(OLESTR("CFsaFilterRecall::StartRecall: SendNotify returned %ls.\n"),
                    WsbHrAsString(hr));
            } else {
                bSentNotify = TRUE;
            }
        }
        hr = S_OK;
        
        //
        // Tell the resource to send the job to the engine.
        //
        WsbTrace(OLESTR("CFsaFilterRecall::StartRecall: Calling FilterSawOpen.\n"));

        WsbAffirmHr(m_pResource->QueryInterface(IID_IFsaResourcePriv, (void**) &pResourcePriv));

        if (m_mode & FILE_OPEN_NO_RECALL) {
            WsbAffirmHr(pResourcePriv->FilterSawOpen(m_pSession, 
                (IFsaFilterRecall*) this,
                m_path, 
                m_fileId,
                offset, 
                size,
                &m_placeholder, 
                m_mode, 
                FSA_RESULT_ACTION_NORECALL,
                m_threadId));
        } else {
            WsbAffirmHr(pResourcePriv->FilterSawOpen(m_pSession, 
                (IFsaFilterRecall*) this,
                m_path, 
                m_fileId,
                offset, 
                size, 
                &m_placeholder, 
                m_mode, 
                FSA_RESULT_ACTION_OPEN,
                m_threadId));
        }

        //
        // The work is now complete - terminate the session.
        //
        WsbTrace(OLESTR("CFsaFilterRecall::StartRecall: End Session.\n"));
        WsbAffirmHr(m_pResource->EndSession(m_pSession));

        //
        // Try the notification again if we have not sent it yet.
        // On the first recall from a remote client the identification usually does not
        // happen in time for the first attempt so we try again here.
        // We will try 5 times with a .1 second delay between.
        //

        WsbTrace(OLESTR("CFsaFilterRecall::StartRecall: m_pClient = %x sent = %u.\n"),
                    m_pClient, bSentNotify);

        if ((m_pClient != 0) && (!bSentNotify)) {
            tryLoop = 5;
            while ((tryLoop != 0) &&( !bSentNotify)) {

                // Reporting here is done after the recall is started.
                // Therefore, it must be synchronized with the recall end notification
                switch (WaitForSingleObject(m_notifyEvent, INFINITE)) {
                    case WAIT_OBJECT_0:
                        // Check if need to report (if recall did not end yet)
                        if (m_kernelCompletionSent == FALSE) {
                            // Recall end was not sent yet
                            hr = m_pClient->SendRecallInfo((IFsaFilterRecall *) this, TRUE, S_OK);  // Not fatal if this fails
                        }
                        SetEvent(m_notifyEvent);
                        break;

                    case WAIT_FAILED:
                    default:
                        WsbTrace(OLESTR("CFsaFilterRecall::StartRecall: WaitForSingleObject returned error %lu\n"), GetLastError());

                        // Just get out without notifying
                        hr = S_OK;
                        break;
                }

                if (hr != S_OK) {
                    WsbTrace(OLESTR("CFsaFilterRecall::StartRecall: Retried notify - %ls.\n"),
                        WsbHrAsString(hr));
                    if (tryLoop != 1) {
                        Sleep(100);     // Sleep .1 sec and try again
                    }
                } else {
                    bSentNotify = TRUE;
                }

            tryLoop--;
            }

        hr = S_OK;
        }

    } WsbCatchAndDo(hr,
        // 
        // Something failed - send the kernel completion if it has not been sent already.
        //
        GetSystemTimeAsFileTime(&now);
        if (m_pClient != 0) {
            m_pClient->SetLastRecallTime(now);
        }
        if (m_kernelCompletionSent == FALSE) {
            m_pFilterPriv->SendComplete((IFsaFilterRecallPriv *) this, hr);
            m_kernelCompletionSent = TRUE;
        } else  {
            //
            // STATUS_END_OF_FILE is not really an error - it just means they tried to read past the end - some apps do this and expect
            // this status to tell them when to stop reading.
            //
            if (hr != STATUS_END_OF_FILE) {
                WsbLogEvent(FSA_MESSAGE_RECALL_FAILED, 0, NULL, (OLECHAR*) WsbAbbreviatePath(m_path, 120), WsbHrAsString(hr), NULL);
            }
        }

        if (m_pClient != 0) {
            m_pClient->SendRecallInfo((IFsaFilterRecall *) this, FALSE, E_FAIL);  // Not fatal if this fails
        }

    );

    WsbTraceOut(OLESTR("CFsaFilterRecall::StartRecall"), OLESTR("%ls"), WsbHrAsString(hr));

    return(hr);
}


    

HRESULT
CFsaFilterRecall::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaFilterRecall::WasCancelled(
    void
    )

/*++

Implements:

  IFsaFilterRecall::WasCancelled().

--*/
{
    HRESULT                 hr = S_OK;

    if (!m_wasCancelled) {
        hr = S_FALSE;
    }

    return(hr);
}


HRESULT
CFsaFilterRecall::AddClient(
    IFsaFilterClient *pWaitingClient
    )
/*++

Implements:

    IFsaFilterRecall::AddClient    

--*/
{
    HRESULT hr = E_FAIL;
    
    switch (WaitForSingleObject(m_waitingClientEvent, INFINITE)) {
        case WAIT_OBJECT_0:
            if ((!m_waitingClientsNotified) && (m_pWaitingClients != 0)) {
                hr = m_pWaitingClients->Add(pWaitingClient);
                if (hr == S_OK) {
                    // Notify client only if it was added successfully to the collection
                    hr = pWaitingClient->SendRecallInfo((IFsaFilterRecall *) this, TRUE, S_OK);  // Not fatal if this fails
                    if (hr != S_OK) {
                        WsbTrace(OLESTR("CFsaFilterRecall::AddClient: SendNotify for start returned %ls.\n"), 
                                WsbHrAsString(hr));
                    } 
                }
            } 

            SetEvent(m_waitingClientEvent);
            break;

        case WAIT_FAILED:
        default:
            DWORD dwErr = GetLastError();
            WsbTrace(OLESTR("CFsaFilterRecall::AddClient: WaitForSingleObject returned error %lu\n"), dwErr);

            // Don't add waiting client
            hr = HRESULT_FROM_WIN32(dwErr);
            break;
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsaitemr.h ===
#ifndef _FSAITEMR_
#define _FSAITEMR_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    FsaItemR.h

Abstract:

    This header file defines special helper function needed for
    the reparse point data.

Author:

    Michael Lotz    [lotz]   3-Mar-1997

Revision History:

--*/


#ifdef __cplusplus
extern "C" {
#endif

// Helper Functions

extern HRESULT CopyRPDataToPlaceholder( IN CONST PRP_DATA pReparseData,
                                        OUT FSA_PLACEHOLDER *pPlaceholder );

extern HRESULT OpenDocView (
                   IN WCHAR const *pwszFile,
                   IN ULONG CreateOptions,
                   IN ULONG DesiredAccess,
                   IN ULONG ShareAccess,
                   IN ULONG CreateDisposition,
                   OUT IO_STATUS_BLOCK *IoStatusBlock,
                   OUT HANDLE *ObjectHandle 
                   );
    

#ifdef __cplusplus
}
#endif

#endif // _FSAITEMR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsaitem.h ===
#ifndef _FSAITEM_
#define _FSAITEM_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsaitem.cpp

Abstract:

    This class contains represents a scan item (i.e. file or directory) for NTFS 5.0.

Author:

    Chuck Bardeen   [cbardeen]   1-Dec-1996

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"
#include "job.h"
#include "mover.h"
#include "fsa.h"
#include "fsaprv.h"

/*++

Class Name:
    
    CFsaScanItem

Class Description:


--*/


class CFsaScanItem : 
    public CComObjectRoot,
    public IFsaScanItem,
    public IFsaScanItemPriv,
    public CComCoClass<CFsaScanItem,&CLSID_CFsaScanItemNTFS>
{
public:
    CFsaScanItem() {}
BEGIN_COM_MAP(CFsaScanItem)
    COM_INTERFACE_ENTRY(IFsaScanItem)
    COM_INTERFACE_ENTRY(IFsaScanItemPriv)
//  COM_INTERFACE_ENTRY(IWsbCollectable)
//  COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_FsaScanItem)

// CComObjectRoot
public:
    HRESULT FinalConstruct(void);
    void FinalRelease(void);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IFsaScanItemPriv
public:
    STDMETHOD(FindFirst)(IFsaResource* pResource, OLECHAR* path, IHsmSession* pSession);
    STDMETHOD(FindFirstInRPIndex)(IFsaResource* pResource, IHsmSession* pSession);
    STDMETHOD(FindFirstInDbIndex)(IFsaResource* pResource, IHsmSession* pSession);
    STDMETHOD(FindNext)(void);
    STDMETHOD(FindNextInRPIndex)(void);
    STDMETHOD(FindNextInDbIndex)(void);
    STDMETHOD(TruncateInternal)(LONGLONG offset, LONGLONG size);  
    STDMETHOD(VerifyInternal)(LONGLONG offset, LONGLONG size, LONGLONG usn1, LONGLONG usn2);

// IFsaScanItem
public:
    STDMETHOD(CheckIfSparse)(LONGLONG offset, LONGLONG size);  
    STDMETHOD(CompareToIScanItem)(IFsaScanItem* pScanItem, SHORT* pResult);
    STDMETHOD(CompareToPathAndName)(OLECHAR* path, OLECHAR* name, SHORT* pResult);
    STDMETHOD(Copy)(OLECHAR* dest, BOOL retainHierarcy, BOOL expandPlaceholders, BOOL overwriteExisting);  
    STDMETHOD(CreateLocalStream)(IStream **ppStream);
    STDMETHOD(CreatePlaceholder)(LONGLONG offset, LONGLONG size, FSA_PLACEHOLDER pPlaceholder, BOOL checkUsn, LONGLONG usn, LONGLONG *pUsn);
    STDMETHOD(Delete)(void);  
    STDMETHOD(DeletePlaceholder)(LONGLONG offset, LONGLONG size);  
    STDMETHOD(FindFirstPlaceholder)(LONGLONG* pOffset, LONGLONG* pSize, FSA_PLACEHOLDER* pPlaceholder);  
    STDMETHOD(FindNextPlaceholder)(LONGLONG* pOffset, LONGLONG* pSize, FSA_PLACEHOLDER* pPlaceholder);  
    STDMETHOD(GetAccessTime)(FILETIME* pTime);  
    STDMETHOD(GetFileId)(LONGLONG* pFileId);
    STDMETHOD(GetFileUsn)(LONGLONG* pFileUsn);
    STDMETHOD(GetFullPathAndName)(OLECHAR* prependix, OLECHAR *appendix, OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetGroup)(OLECHAR** pOwner, ULONG bufferSize);  
    STDMETHOD(GetLogicalSize)(LONGLONG* pSize);  
    STDMETHOD(GetModifyTime)(FILETIME* pTime);  
    STDMETHOD(GetOwner)(OLECHAR** pOwner, ULONG bufferSize);  
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetPath)(OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetPathForFind)(OLECHAR* searchName, OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetPathAndName)(OLECHAR* appendix, OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetPhysicalSize)(LONGLONG* pSize);
    STDMETHOD(GetPlaceholder)(LONGLONG offset, LONGLONG size, FSA_PLACEHOLDER* pPlaceholder);
    STDMETHOD(GetSession)(IHsmSession** ppSession);
    STDMETHOD(GetUncPathAndName)(OLECHAR* prependix, OLECHAR *appendix, OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetVersionId)(LONGLONG* pId);
    STDMETHOD(HasExtendedAttributes)(void); 
    STDMETHOD(IsALink)(void);  
    STDMETHOD(IsAParent)(void); 
    STDMETHOD(IsARelativeParent)(void); 
    STDMETHOD(IsCompressed)(void); 
    STDMETHOD(IsDeleteOK)(IFsaPostIt *pPostIt);
    STDMETHOD(IsEncrypted)(void); 
    STDMETHOD(IsHidden)(void); 
    STDMETHOD(IsGroupMemberOf)(OLECHAR* group);
    STDMETHOD(IsManageable)(LONGLONG offset, LONGLONG size);  
    STDMETHOD(IsManaged)(LONGLONG offset, LONGLONG size);  
    STDMETHOD(IsMbit)(void);  
    STDMETHOD(IsOffline)(void);  
    STDMETHOD(IsMigrateOK)(IFsaPostIt *pPostIt);
    STDMETHOD(IsOwnerMemberOf)(OLECHAR* group);
    STDMETHOD(IsPremigrated)(LONGLONG offset, LONGLONG size);  
    STDMETHOD(IsReadOnly)(void); 
    STDMETHOD(IsRecallOK)(IFsaPostIt *pPostIt);
    STDMETHOD(IsSparse)(void); 
    STDMETHOD(IsSystem)(void); 
    STDMETHOD(IsTotallySparse)(void); 
    STDMETHOD(IsTruncated)(LONGLONG offset, LONGLONG size);  
    STDMETHOD(Manage)(LONGLONG offset, LONGLONG size, GUID storagePoolId, BOOL truncate);  
    STDMETHOD(Move)(OLECHAR* dest, BOOL retainHierarcy, BOOL expandPlaceholders, BOOL overwriteExisting);  
    STDMETHOD(Recall)(LONGLONG offset, LONGLONG size, BOOL deletePlaceholder);  
    STDMETHOD(Recycle)(void);  
    STDMETHOD(Truncate)(LONGLONG offset, LONGLONG size);  
    STDMETHOD(Unmanage)(LONGLONG offset, LONGLONG size);  
    STDMETHOD(Validate)(LONGLONG offset, LONGLONG size);  
    STDMETHOD(PrepareForManage)(LONGLONG offset, LONGLONG size);  
    STDMETHOD(Verify)(LONGLONG offset, LONGLONG size);
    STDMETHOD(TruncateValidated)(LONGLONG offset, LONGLONG size);

//  Private functions
private:
    STDMETHOD(CheckUsnJournalForChanges)(LONGLONG StartUsn, LONGLONG StopUsn, BOOL *pChanged);
    STDMETHOD(GetPremigratedUsn)(LONGLONG* pFileUsn);
    STDMETHOD(GetFromRPIndex)(BOOL first);
    STDMETHOD(GetFromDbIndex)(BOOL first);
    STDMETHOD(CalculateCurrentCRCAndUSN)(LONGLONG offset,LONGLONG size, ULONG *pCurrentCRC, LONGLONG *pUsn);
    STDMETHOD(CalculateCurrentCRCInternal)(HANDLE handle, LONGLONG offset,LONGLONG size, ULONG *pCurrentCRC);
    STDMETHOD(MakeReadWrite)(void);  
    STDMETHOD(RestoreAttributes)(void);  

protected:
    CComPtr<IFsaResource>       m_pResource;
    CWsbStringPtr               m_path;
    CComPtr<IHsmSession>        m_pSession;
    HANDLE                      m_handle;
    WIN32_FIND_DATA             m_findData;
    BOOL                        m_gotPhysicalSize;
    ULARGE_INTEGER              m_physicalSize;
    BOOL                        m_gotPlaceholder;
    FSA_PLACEHOLDER             m_placeholder;
    BOOL                        m_changedAttributes;
    ULONG                       m_originalAttributes;
    CComPtr<IDataMover>         m_pDataMover;
    CComPtr<IStream>            m_pStream;

    //  Only used for Reparse Point Index scan:
    HANDLE                      m_handleRPI;

    //  Used by :Verify
    HANDLE                      m_handleVerify;

    // Only used for Database scan
    CComPtr<IFsaUnmanageDb>     m_pUnmanageDb;
    CComPtr<IFsaUnmanageRec>    m_pUnmanageRec;
    CComPtr<IWsbDbSession>      m_pDbSession;

};

#endif  // _FSAITEM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsaitem.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsaitem.cpp

Abstract:

    This class contains represents a scan item (i.e. file or directory) for NTFS 5.0.

Author:

    Chuck Bardeen    [cbardeen]   1-Dec-1996

Revision History:

--*/

#include "stdafx.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_FSA

#include "wsb.h"
#include "wsbtrak.h"
#include "fsa.h"
#include "mover.h"
#include "fsaitem.h"
#include "fsaprem.h"

static USHORT iCountItem = 0;  // Count of existing objects



HRESULT
CFsaScanItem::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT                  hr = S_OK;
    CComPtr<IFsaScanItem>    pScanItem;

    WsbTraceIn(OLESTR("CFsaScanItem::CompareTo"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        // We need the IWsbBool interface to get the value of the object.
        WsbAffirmHr(pUnknown->QueryInterface(IID_IFsaScanItem, (void**) &pScanItem));

        // Compare the rules.
        hr = CompareToIScanItem(pScanItem, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CFsaScanItem::CompareToIScanItem(
    IN IFsaScanItem* pScanItem,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaScanItem::CompareToIScanItem().

--*/
{
    HRESULT          hr = S_OK;
    CWsbStringPtr    path;
    CWsbStringPtr    name;

    WsbTraceIn(OLESTR("CFsaScanItem::CompareToIScanItem"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pScanItem, E_POINTER);

        // Either compare the name or the id.
           WsbAffirmHr(pScanItem->GetPath(&path, 0));
           WsbAffirmHr(pScanItem->GetName(&name, 0));
           hr = CompareToPathAndName(path, name, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::CompareToIScanItem"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CFsaScanItem::CompareToPathAndName(
    IN OLECHAR* path,
    IN OLECHAR* name,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaScanItem::CompareToPathAndName().

--*/
{
    HRESULT       hr = S_OK;
    SHORT         aResult = 0;

    WsbTraceIn(OLESTR("CFsaScanItem::CompareToPathAndName"), OLESTR(""));

    try {

        // Compare the path.
        aResult = (SHORT) _wcsicmp(m_path, path);

        // Compare the name.
        if (0 == aResult) {
            aResult = (SHORT) _wcsicmp(m_findData.cFileName, name);
        }

        if (0 != aResult) {
            hr = S_FALSE;
        }

        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::CompareToPathAndName"), OLESTR("hr = <%ls>, result = <%u>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CFsaScanItem::Copy(
    IN OLECHAR* dest,
    IN BOOL /*retainHierarcy*/,
    IN BOOL /*expandPlaceholders*/,
    IN BOOL overwriteExisting
    )

/*++

Implements:

  IFsaScanItem::Copy().

--*/
{
    HRESULT            hr = S_OK;

    try {

        // NOTE : This default behavior causes placeholders
        // to be expanded and probably doesn't retain the heirarchy.
        WsbAssert(0 != dest, E_POINTER);
        WsbAssert(CopyFile(m_findData.cFileName, dest, overwriteExisting), E_FAIL);

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::CreateLocalStream(
    OUT IStream **ppStream
    )

/*++

Implements:

  IFsaScanItem::CreateLocalStream().

--*/
{
    HRESULT          hr = S_OK;
    LARGE_INTEGER    fileSize;
    CWsbStringPtr    volName;

    WsbTraceIn(OLESTR("CFsaScanItem::CreateLocalStream"), OLESTR(""));
    try {
        CWsbStringPtr    localName;

        if ( !m_gotPlaceholder) {
            //
            // Get the placeholder info
            //
            fileSize.LowPart = m_findData.nFileSizeLow;
            fileSize.HighPart = m_findData.nFileSizeHigh;
            WsbAffirmHr(IsManaged(0, fileSize.QuadPart));
        }

        WsbAssert( 0 != ppStream, E_POINTER);
        WsbAffirmHr( CoCreateInstance( CLSID_CNtFileIo, 0, CLSCTX_SERVER, IID_IDataMover, (void **)&m_pDataMover ) );
        //
        // Set the device name for the mover so it can set the source infor for the USN journal.
        //
        WsbAffirmHr(m_pResource->GetPath(&volName, 0));
        WsbAffirmHr( m_pDataMover->SetDeviceName(volName));
        //WsbAffirmHr(GetFullPathAndName( NULL, 0, &localName, 0));
        WsbAffirmHr(GetFullPathAndName( OLESTR("\\\\?\\"), 0, &localName, 0));
        WsbAffirmHr( m_pDataMover->CreateLocalStream(
                localName, MVR_MODE_WRITE | MVR_FLAG_HSM_SEMANTICS | MVR_FLAG_POSIX_SEMANTICS, &m_pStream ) );

        LARGE_INTEGER seekTo;
        ULARGE_INTEGER pos;
        seekTo.QuadPart = m_placeholder.dataStreamStart;
        WsbAffirmHr( m_pStream->Seek( seekTo, STREAM_SEEK_SET, &pos ) );
        *ppStream = m_pStream;
        m_pStream->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::CreateLocalStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CFsaScanItem::Delete(
    void
    )

/*++

Implements:

  IFsaScanItem::Delete().

--*/
{
    HRESULT             hr = S_OK;
    CWsbStringPtr       tmpString;
    HANDLE              fileHandle;

    try {

        // This is the name of the file we want to delete.
        WsbAffirmHr(GetFullPathAndName(OLESTR("\\\\?\\"), 0, &tmpString, 0));

        // Since we want to be POSIX compliant, we can't use DeleteFile() and instead will
        // open with the delete on close flag. This doesn't handle read-only files, so we
        // have to change that ourselves.
        WsbAffirmHr(MakeReadWrite());

        fileHandle = CreateFile(tmpString, GENERIC_WRITE, 0, 0, OPEN_EXISTING, FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_POSIX_SEMANTICS | FILE_FLAG_DELETE_ON_CLOSE, 0);

        if (INVALID_HANDLE_VALUE == fileHandle) {
            WsbThrow(HRESULT_FROM_WIN32(GetLastError()));
        } else {
            if (!CloseHandle(fileHandle)) {
                WsbThrow(HRESULT_FROM_WIN32(GetLastError()));
            }
        }

    } WsbCatch(hr);

    return(hr);
}
#pragma optimize("g", off)

HRESULT
CFsaScanItem::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT        hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::FinalConstruct"), OLESTR(""));

    try {

        WsbAffirmHr(CComObjectRoot::FinalConstruct());

        m_handle = INVALID_HANDLE_VALUE;
        m_gotPhysicalSize = FALSE;
        m_physicalSize.QuadPart = 0;
        m_gotPlaceholder  = FALSE;
        m_changedAttributes = FALSE;
        m_handleRPI = 0;

        //  Add class to object table
        WSB_OBJECT_ADD(CLSID_CFsaScanItemNTFS, this);

    } WsbCatch(hr);

    iCountItem++;

    WsbTraceOut(OLESTR("CFsaScanItem::FinalConstruct"), OLESTR("hr = <%ls>, Count is <%d>"),
            WsbHrAsString(hr), iCountItem);

    return(hr);
}
#pragma optimize("", on)


void
CFsaScanItem::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    WsbTraceIn(OLESTR("CFsaScanItem::FinalRelease"), OLESTR(""));

    //  Subtract class from object table
    WSB_OBJECT_SUB(CLSID_CFsaScanItemNTFS, this);

    // Terminate the scan and free the path memory.
    if (INVALID_HANDLE_VALUE != m_handle) {
        FindClose(m_handle);
        m_handle = INVALID_HANDLE_VALUE;
    }
    if (0 != m_handleRPI) {
        CloseHandle(m_handleRPI);
        m_handleRPI = 0;
    }

    if (m_pUnmanageDb != NULL) {
        // Db must be open
        (void)m_pUnmanageDb->Close(m_pDbSession);
        m_pDbSession = 0;
        m_pUnmanageRec = 0;
    }

    if (TRUE == m_changedAttributes) {
        //
        // We changed it from read only to read/write - put it back.
        //
        RestoreAttributes();
    }

    //
    // Detach the data mover stream
    if (m_pDataMover != 0) {
        WsbAffirmHr( m_pDataMover->CloseStream() );
    }

    // Let the parent class do his thing.
    CComObjectRoot::FinalRelease();

    iCountItem--;
    WsbTraceOut(OLESTR("CFsaScanItem::FinalRelease"), OLESTR("Count is <%d>"), iCountItem);
}


HRESULT
CFsaScanItem::FindFirst(
    IN IFsaResource* pResource,
    IN OLECHAR* path,
    IN IHsmSession* pSession
    )

/*++

Implements:

  IFsaScanItem::FindFirst().

--*/
{
    HRESULT                  hr = S_OK;
    CWsbStringPtr            findPath;
    CWsbStringPtr            searchName;
    OLECHAR*                 slashPtr;
    DWORD                    lErr;

    WsbTraceIn(OLESTR("CFsaScanItem::FindFirst"), OLESTR("path = <%ls>"),
            path);

    try {

        WsbAssert(0 != pResource, E_POINTER);
        WsbAssert(0 != path, E_POINTER);

        // Store off some of the scan information.
        m_pResource = pResource;
        m_pSession = pSession;

        // Break up the incoming path into a path and a name.
        m_path = path;
        slashPtr = wcsrchr(m_path, L'\\');

        // We could try to support relative path stuff (i.e. current
        // directory, but I am not going to do it for now.
        WsbAffirm(slashPtr != 0, E_FAIL);
        searchName = &(slashPtr[1]);
        slashPtr[1] = 0;

        // Get a path that can be used by the find function.
        WsbAffirmHr(GetPathForFind(searchName, &findPath, 0));

        // Scan starting at the specified path.
        m_handle = FindFirstFileEx(findPath, FindExInfoStandard, &m_findData, FindExSearchNameMatch, 0, FIND_FIRST_EX_CASE_SENSITIVE);

        lErr = GetLastError();

        // If we found a file, then remember the scan handle and
        // return the scan item.
        WsbAffirm(INVALID_HANDLE_VALUE != m_handle, WSB_E_NOTFOUND);

        m_gotPhysicalSize = FALSE;
        m_physicalSize.QuadPart = 0;
        m_gotPlaceholder  = FALSE;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::FindFirst"), OLESTR("hr = <%ls>"),
            WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaScanItem::FindNext(
    void
    )

/*++

Implements:

  IFsaScanItem::FindNext().

--*/
{
    HRESULT                    hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::FindNext"), OLESTR(""));

    try {

        WsbAssert(INVALID_HANDLE_VALUE != m_handle, E_FAIL);

        if (TRUE == m_changedAttributes) {
            //
            // We changed it from read only to read/write - put it back.
            //
            RestoreAttributes();
        }

        // Continue the scan.
        WsbAffirm(FindNextFile(m_handle, &m_findData), WSB_E_NOTFOUND);

        m_gotPhysicalSize = FALSE;
        m_physicalSize.QuadPart = 0;
        m_gotPlaceholder  = FALSE;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::FindNext"), OLESTR("hr = <%ls>"),
            WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaScanItem::GetAccessTime(
    OUT FILETIME* pTime
    )

/*++

Implements:

  IFsaScanItem::GetAccessTime().

--*/
{
    HRESULT            hr = S_OK;

    try {

        WsbAssert(0 != pTime, E_POINTER);
        *pTime = m_findData.ftLastAccessTime;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::GetGroup(
    OUT OLECHAR** /*pGroup*/,
    IN ULONG /*bufferSize*/
    )

/*++

Implements:

  IFsaScanItem::GetGroup().

--*/
{
    HRESULT            hr = S_OK;

    try {

        hr = E_NOTIMPL;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::GetLogicalSize(
    OUT LONGLONG* pSize
    )

/*++

Implements:

  IFsaScanItem::GetLogicalSize().

--*/
{
    HRESULT            hr = S_OK;
    LARGE_INTEGER   logSize;

    try {

        WsbAssert(0 != pSize, E_POINTER);
        logSize.LowPart = m_findData.nFileSizeLow;
        logSize.HighPart = m_findData.nFileSizeHigh;
        *pSize = logSize.QuadPart;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::GetModifyTime(
    OUT FILETIME* pTime
    )

/*++

Implements:

  IFsaScanItem::GetModifyTime().

--*/
{
    HRESULT            hr = S_OK;

    try {

        WsbAssert(0 != pTime, E_POINTER);
        *pTime = m_findData.ftLastWriteTime;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::GetName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaScanItem::GetName().

--*/
{
    HRESULT            hr = S_OK;
    CWsbStringPtr    tmpString = m_findData.cFileName;

    try {

        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::GetOwner(
    OUT OLECHAR** /*pOwner*/,
    IN ULONG      /*bufferSize*/
    )

/*++

Implements:

  IFsaScanItem::GetOwner().

--*/
{
    HRESULT            hr = S_OK;

    try {

        hr = E_NOTIMPL;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::GetPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaScanItem::GetPath().

--*/
{
    HRESULT            hr = S_OK;

    try {

        WsbAssert(0 != pPath, E_POINTER);
        WsbAffirmHr(m_path.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::GetPathForFind(
    IN OLECHAR* searchName,
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaScanItem::GetPathForFind().

--*/
{
    HRESULT          hr = S_OK;
    CWsbStringPtr    tmpString;

    try {

        WsbAssert(0 != pPath, E_POINTER);

        // Get a buffer.
        WsbAffirmHr(tmpString.TakeFrom(*pPath, bufferSize));

        try {

            // Get the path to the resource of the resource.
            //
            WsbAffirmHr(m_pResource->GetPath(&tmpString, 0));
            WsbAffirmHr(tmpString.Prepend(OLESTR("\\\\?\\")));
            //WsbAffirmHr(tmpString.Append(OLESTR("\\")));

            // Copy in the path.
            //WsbAffirmHr(tmpString.Prepend(OLESTR("\\\\?\\")));
            WsbAffirmHr(tmpString.Append(&(m_path[1])));
            WsbAffirmHr(tmpString.Append(searchName));

        } WsbCatch(hr);

        WsbAffirmHr(tmpString.GiveTo(pPath));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::GetPathAndName(
    IN    OLECHAR* appendix,
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaScanItem::GetPathAndName().

--*/
{
    HRESULT          hr = S_OK;
    CWsbStringPtr    tmpString;

    try {

        WsbAssert(0 != pPath, E_POINTER);

        // Get a buffer.
        WsbAffirmHr(tmpString.TakeFrom(*pPath, bufferSize));

        try {

            tmpString = m_path;
            tmpString.Append(m_findData.cFileName);

            if (0 != appendix) {
                tmpString.Append(appendix);
            }

        } WsbCatch(hr);

        // Give responsibility for freeing the memory back to the caller.
        WsbAffirmHr(tmpString.GiveTo(pPath));

    } WsbCatch(hr);


    return(hr);
}


HRESULT
CFsaScanItem::GetFullPathAndName(
    IN    OLECHAR* prependix,
    IN    OLECHAR* appendix,
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaScanItem::GetFullPathAndName().

--*/
{
    HRESULT          hr = S_OK;
    CWsbStringPtr    tmpString;
    CWsbStringPtr    tmpString2;

    try {

        WsbAssert(0 != pPath, E_POINTER);

        // Get a buffer.
        WsbAffirmHr(tmpString.TakeFrom(*pPath, bufferSize));

        try {
            if (0 != prependix) {
                tmpString = prependix;
                // Get the path to the resource of the resource.
                WsbAffirmHr(m_pResource->GetPath(&tmpString2, 0));
                WsbAffirmHr(tmpString.Append(tmpString2));
            } else {
                WsbAffirmHr(m_pResource->GetPath(&tmpString, 0));
            }

            // Copy in the path.
            WsbAffirmHr(tmpString.Append(&(m_path[1])));
            WsbAffirmHr(tmpString.Append(m_findData.cFileName));
            if (0 != appendix) {
                WsbAffirmHr(tmpString.Append(appendix));
            }

        } WsbCatch(hr);

        // Give responsibility for freeing the memory back to the caller.
        WsbAffirmHr(tmpString.GiveTo(pPath));


    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::GetPhysicalSize(
    OUT LONGLONG* pSize
    )

/*++

Implements:

  IFsaScanItem::GetPhysicalSize().

--*/
{
    HRESULT          hr = S_OK;
    CWsbStringPtr    path;

    try {

        WsbAssert(0 != pSize, E_POINTER);

        //WsbAssertHr(GetFullPathAndName(NULL, 0, &path, 0));
        WsbAssertHr(GetFullPathAndName(OLESTR("\\\\?\\"), 0, &path, 0));

        // Only read this value in once, but wait until it is asked for
        // before reading it in (since this call takes time and many scans
        // won't need the information.
        if (!m_gotPhysicalSize) {
            m_physicalSize.LowPart = GetCompressedFileSize(path, &m_physicalSize.HighPart);
            if (MAXULONG == m_physicalSize.LowPart) {
                //  Have to check last error since  MAXULONG could be a valid
                //  value for the low part of the size.
                DWORD err = GetLastError();

                if (err != NO_ERROR) {
                    WsbTrace(OLESTR("CFsaScanItem::GetPhysicalSize of %ws Last error = %u\n"),
                        (WCHAR *) path, err);
                }

                WsbAffirm(NO_ERROR == err, E_FAIL);
            }
            m_gotPhysicalSize = TRUE;
        }

        *pSize = m_physicalSize.QuadPart;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::GetPremigratedUsn(
    OUT LONGLONG* pFileUsn
    )

/*++

Implements:

Routine Description:

    Get the USN Journal number for this file from the premigrated list.

Arguments:

    pFileUsn - Pointer to File USN to be returned.

Return Value:

    S_OK   - success

--*/
{
    HRESULT            hr = S_OK;

    try {
        CComPtr<IWsbDbSession>              pDbSession;
        CComPtr<IFsaPremigratedDb>          pPremDb;
        CComPtr<IFsaResourcePriv>            pResourcePriv;

        WsbAssert(pFileUsn, E_POINTER);

        //  Get the premigrated list DB
        WsbAffirmHr(m_pResource->QueryInterface(IID_IFsaResourcePriv,
                (void**) &pResourcePriv));
        WsbAffirmHr(pResourcePriv->GetPremigrated(IID_IFsaPremigratedDb,
                (void**) &pPremDb));

        //  Open the premigration list
        WsbAffirmHr(pPremDb->Open(&pDbSession));

        try {
            FSA_PLACEHOLDER                     PlaceHolder;
            CComPtr<IFsaPremigratedRec>         pPremRec;
            LONGLONG                            usn;

            //  Get a DB entity for the search
            WsbAffirmHr(pPremDb->GetEntity(pDbSession, PREMIGRATED_REC_TYPE,
                    IID_IFsaPremigratedRec, (void**) &pPremRec));
            WsbAffirmHr(pPremRec->UseKey(PREMIGRATED_BAGID_OFFSETS_KEY_TYPE));

            //  Find the record
            WsbAffirmHr(GetPlaceholder(0, 0, &PlaceHolder));
            WsbAffirmHr(pPremRec->SetBagId(PlaceHolder.bagId));
            WsbAffirmHr(pPremRec->SetBagOffset(PlaceHolder.fileStart));
            WsbAffirmHr(pPremRec->SetOffset(PlaceHolder.dataStreamStart));
            WsbAffirmHr(pPremRec->FindEQ());

            //  Get the stored USN
            WsbAffirmHr(pPremRec->GetFileUSN(&usn));
            *pFileUsn = usn;
        } WsbCatch(hr);

        //  Close the DB
        pPremDb->Close(pDbSession);

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::GetSession(
    OUT IHsmSession** ppSession
    )

/*++

Implements:

  IFsaScanItem::GetSession().

--*/
{
    HRESULT            hr = S_OK;

    try {

        WsbAssert(0 != ppSession, E_POINTER);

        *ppSession = m_pSession;
        m_pSession->AddRef();

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::GetUncPathAndName(
    IN    OLECHAR* prependix,
    IN    OLECHAR* appendix,
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaScanItem::GetUncPathAndName().

--*/
{
    HRESULT          hr = S_OK;
    CWsbStringPtr    tmpString;
    CWsbStringPtr    tmpString2;

    try {

        WsbAssert(0 != pPath, E_POINTER);

        // Get a buffer.
        WsbAffirmHr(tmpString.TakeFrom(*pPath, bufferSize));

        try {
            if (0 != prependix) {
                tmpString = prependix;
                // Get the path to the resource of the resource.
                WsbAffirmHr(m_pResource->GetUncPath(&tmpString2, 0));
                WsbAffirmHr(tmpString.Append(tmpString2));
            } else {
                WsbAffirmHr(m_pResource->GetPath(&tmpString, 0));
            }

            // Copy in the path.
            WsbAffirmHr(tmpString.Append(&(m_path[1])));
            WsbAffirmHr(tmpString.Append(m_findData.cFileName));
            if (0 != appendix) {
                WsbAffirmHr(tmpString.Append(appendix));
            }

        } WsbCatch(hr);

        // Give responsibility for freeing the memory back to the caller.
        WsbAffirmHr(tmpString.GiveTo(pPath));


    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::IsAParent(
    void
    )

/*++

Implements:

  IFsaScanItem::IsAParent().

--*/
{
    HRESULT            hr = S_FALSE;

    if ((m_findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) {
        hr = S_OK;
    }

    return(hr);
}


HRESULT
CFsaScanItem::IsARelativeParent(
    void
    )

/*++

Implements:

  IFsaScanItem::IsARelativeParent().

--*/
{
    HRESULT            hr = S_FALSE;

    if ((m_findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) {

        // looking for "."
        if (m_findData.cFileName[0] == L'.') {

            if (m_findData.cFileName[1] == 0) {
                hr = S_OK;
            }

            // looking for "."
            else if (m_findData.cFileName[1] == L'.') {

                if (m_findData.cFileName[2] == 0) {
                    hr = S_OK;
                }
            }
        }
    }

    return(hr);
}


HRESULT
CFsaScanItem::IsCompressed(
    void
    )

/*++

Implements:

  IFsaScanItem::IsCompressed().

--*/
{
    HRESULT            hr = S_FALSE;

    if ((m_findData.dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED) != 0) {
        hr = S_OK;
    }

    return(hr);
}


HRESULT
CFsaScanItem::IsEncrypted(
    void
    )

/*++

Implements:

  IFsaScanItem::IsEncrypted().

--*/
{
    HRESULT            hr = S_FALSE;

    if ((m_findData.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) != 0) {
        hr = S_OK;
    }

    return(hr);
}


HRESULT
CFsaScanItem::IsDeleteOK(
    IN IFsaPostIt *pPostIt
    )

/*++

Implements:

  IFsaScanItem::IsDeleteOK().

--*/
{
    HRESULT            hr = S_OK;
    WsbTraceIn(OLESTR("CFsaScanItem::IsDeleteOK"), OLESTR(""));

    try  {
        //
        // Get the version ID from the FSA Post it.  This is the
        // version of the file at the time of the migrate request
        //
        LONGLONG            workVersionId;
        WsbAffirmHr(pPostIt->GetFileVersionId(&workVersionId));

        //
        // Get the version of the file at the time of this scan
        //
        LONGLONG            scanVersionId;
        WsbAffirmHr(GetVersionId(&scanVersionId));

        //
        // See if the versions match
        //
        WsbTrace(OLESTR("CFsaScanItem::IsDeleteOK: workVersionId:<%I64u> scanVersionId:<%I64u>\n"),
            workVersionId, scanVersionId);

        if (workVersionId != scanVersionId)  {
            WsbTrace(OLESTR("CFsaScanItem::IsDeleteOK: File version has changed!\n"));
            WsbThrow(FSA_E_FILE_CHANGED);
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFsaScanItem::IsDeleteOk"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CFsaScanItem::IsGroupMemberOf(
    OLECHAR* /*group*/
    )

/*++

Implements:

  IFsaScanItem::IsGroupMemberOf().

--*/
{
    HRESULT            hr = S_FALSE;

    hr = E_NOTIMPL;

    return(hr);
}


HRESULT
CFsaScanItem::IsHidden(
    void
    )

/*++

Implements:

  IFsaScanItem::IsHidden().

--*/
{
    HRESULT            hr = S_FALSE;

    if ((m_findData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) != 0) {
        hr = S_OK;
    }

    return(hr);
}


HRESULT
CFsaScanItem::IsManageable(
    IN LONGLONG offset,
    IN LONGLONG size
    )

/*++

Implements:

  IFsaScanItem::IsManageable().

--*/
{
    HRESULT         hr = S_FALSE;
    HRESULT         hr2;
    LONGLONG        logicalSize;
    LONGLONG        managableSize;
    FILETIME        time;
    FILETIME        managableTime;
    BOOL            isRelative;

    //
    // Get some strings for logging and tracing
    //
    CWsbStringPtr    fileName;
    CWsbStringPtr    jobName;
    try  {
        WsbAffirmHr(GetFullPathAndName( 0, 0, &fileName, 0));
        WsbAffirmHr(m_pSession->GetName(&jobName, 0));
    } WsbCatch( hr );

    WsbTraceIn(OLESTR("CFsaScanItem::IsManageable"), OLESTR("<%ls>"), (OLECHAR *)fileName);
    try {

        // To be managable the item:
        //    - can't already be managed (premigratted or truncated)
        //  - can't be a link
        //  - can't be encrypted
        //  - can't be sparse
        //  - can't have extended attributes (reparse point limitation)
        //  - must have a size bigger than the resource's default size
        //  - must have a last access time older than the resource's default time

        // Managed?
        hr2 = IsManaged(offset, size);
        if (S_FALSE == hr2) {

            // A link?
            hr2 = IsALink();
            if (S_FALSE == hr2) {

                // Encrypted?
                hr2 = IsEncrypted();
                if (S_FALSE == hr2) {

                    // A sparse?
                    hr2 = IsSparse();
                    if (S_FALSE == hr2) {

                        // A sparse?
                        hr2 = HasExtendedAttributes();
                        if (S_FALSE == hr2) {

                            // Big enough?
                            WsbAffirmHr(GetLogicalSize(&logicalSize));
                            WsbAffirmHr(m_pResource->GetManageableItemLogicalSize(&managableSize));
                            if (logicalSize >= managableSize) {

                                // Old enough?
                                WsbAffirmHr(GetAccessTime(&time));
                                WsbAffirmHr(m_pResource->GetManageableItemAccessTime(&isRelative, &managableTime));
                                if (WsbCompareFileTimes(time, managableTime, isRelative, FALSE) >= 0) {

                                    // It can be managed!!
                                    hr = S_OK;
                                }  else  {
                                    WsbLogEvent(FSA_MESSAGE_FILESKIPPED_ISACCESSED, 0, NULL,  (OLECHAR*) jobName, WsbAbbreviatePath(fileName, 120), WsbHrAsString(hr), NULL);
                                }
                            } else  {
                                WsbLogEvent(FSA_MESSAGE_FILESKIPPED_ISTOOSMALL, 0, NULL, (OLECHAR*) jobName, WsbAbbreviatePath(fileName, 120), WsbHrAsString(hr), NULL);
                                WsbTrace( OLESTR("LogicalSize is %I64d; ManagableSize is %I64d\n"), logicalSize, managableSize);
                            }
                        } else  {
                            WsbLogEvent(FSA_MESSAGE_FILESKIPPED_HASEA, 0, NULL, (OLECHAR*) jobName, WsbAbbreviatePath(fileName, 120), WsbHrAsString(hr), NULL);
                        }
                    } else  {
                        WsbLogEvent(FSA_MESSAGE_FILESKIPPED_ISSPARSE, 0, NULL, (OLECHAR*) jobName, WsbAbbreviatePath(fileName, 120), WsbHrAsString(hr), NULL);
                    }
                } else  {
                       WsbLogEvent(FSA_MESSAGE_FILESKIPPED_ISENCRYPTED, 0, NULL, (OLECHAR*) jobName, WsbAbbreviatePath(fileName, 120), WsbHrAsString(hr), NULL);
                }
            } else  {
                WsbLogEvent(FSA_MESSAGE_FILESKIPPED_ISALINK, 0, NULL, (OLECHAR*) jobName, WsbAbbreviatePath(fileName, 120), WsbHrAsString(hr), NULL);
            }
        } else  {
            WsbLogEvent(FSA_MESSAGE_FILESKIPPED_ISMANAGED, 0, NULL, (OLECHAR*) jobName, WsbAbbreviatePath(fileName, 120), WsbHrAsString(hr), NULL);
        }


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::IsManageable"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CFsaScanItem::IsMigrateOK(
    IN IFsaPostIt *pPostIt
    )

/*++

Implements:

  IFsaScanItem::IsMigrateOK().

--*/
{
    HRESULT            hr = S_OK;
    WsbTraceIn(OLESTR("CFsaScanItem::IsMigrateOK"), OLESTR(""));

    try  {
        //
        // Make sure the file isn't already managed.  This could happen if two jobs were scanning
        // the same volume.
        //
        LONGLONG                    offset;
        LONGLONG                    size;

        WsbAffirmHr(pPostIt->GetRequestOffset(&offset));
        WsbAffirmHr(pPostIt->GetRequestSize(&size));
        if (IsManaged(offset, size) == S_OK)  {
            //
            // The file is already managed so skip it
            //
            WsbTrace(OLESTR("A manage request for an already managed file - skip it!\n"));
            WsbThrow(FSA_E_FILE_ALREADY_MANAGED);
        }

        //
        // Get the version ID from the FSA Post it.  This is the
        // version of the file at the time of the migrate request
        //
        LONGLONG            workVersionId;
        WsbAffirmHr(pPostIt->GetFileVersionId(&workVersionId));

        //
        // Get the version of the file at the time of this scan
        //
        LONGLONG            scanVersionId;
        WsbAffirmHr(GetVersionId(&scanVersionId));

        //
        // See if the versions match
        //
        WsbTrace(OLESTR("CFsaScanItem::IsMigrateOK: workVersionId:<%I64u> scanVersionId:<%I64u>\n"),
            workVersionId, scanVersionId);

        if (workVersionId != scanVersionId)  {
            WsbTrace(OLESTR("CFsaScanItem::IsMigrateOK: File version has changed!\n"));
            WsbThrow(FSA_E_FILE_CHANGED);
        }


    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFsaScanItem::IsMigrateOK"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaScanItem::IsMbit(
    void
    )

/*++

Implements:

  IFsaScanItem::IsMbit().

--*/
{
    HRESULT            hr = S_FALSE;

    if ((m_findData.dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE) != 0) {
        hr = S_OK;
    }

    return(hr);
}


HRESULT
CFsaScanItem::IsOffline(
    void
    )
/*++

Implements:

    IFsaScanItem::IsOffline().

--*/
{
    HRESULT             hr = S_FALSE;

    if ((m_findData.dwFileAttributes & FILE_ATTRIBUTE_OFFLINE) != 0) {
        hr = S_OK;
    }

    return(hr);
}


HRESULT
CFsaScanItem::IsOwnerMemberOf(
    OLECHAR* /*group*/
    )

/*++

Implements:

  IFsaScanItem::IsOwnerMemberOf().

--*/
{
    HRESULT            hr = S_FALSE;

    hr = E_NOTIMPL;

    return(hr);
}


HRESULT
CFsaScanItem::IsReadOnly(
    void
    )

/*++

Implements:

  IFsaScanItem::IsReadOnly().

--*/
{
    HRESULT            hr = S_FALSE;

    if ((m_findData.dwFileAttributes & FILE_ATTRIBUTE_READONLY) != 0) {
        hr = S_OK;
    }

    return(hr);
}


HRESULT
CFsaScanItem::IsRecallOK(
    IN IFsaPostIt *pPostIt
    )

/*++

Implements:

  IFsaScanItem::IsRecallOK().

--*/
{
    HRESULT            hr = S_OK;
    WsbTraceIn(OLESTR("CFsaScanItem::IsRecallOK"), OLESTR(""));

    try  {
        LONGLONG offset;
        LONGLONG size;
        //
        // Make sure the file is still truncated
        //
        WsbAffirmHr(pPostIt->GetRequestOffset(&offset));
        WsbAffirmHr(pPostIt->GetRequestSize(&size));
        hr = IsTruncated(offset, size);
        if (S_OK != hr)  {
            //
            // The file is not truncated, so skip it
            //
            WsbTrace(OLESTR("CFsaScanItem::IsRecallOK - file isn't truncated.\n"));
            WsbThrow(FSA_E_FILE_NOT_TRUNCATED);
        }

        // Get the version ID from the FSA Post it.  This is the
        // version of the file at the time of the migrate request
        //
        LONGLONG            workVersionId;
        WsbAffirmHr(pPostIt->GetFileVersionId(&workVersionId));

        //
        // Get the version of the file
        //
        LONGLONG            scanVersionId;
        WsbAffirmHr(GetVersionId(&scanVersionId));

        //
        // See if the versions match
        //
        WsbTrace(OLESTR("CFsaScanItem::IsRecallOK: workVersionId:<%I64u> scanVersionId:<%I64u>\n"),
            workVersionId, scanVersionId);

        if (workVersionId != scanVersionId)  {
            WsbTrace(OLESTR("CFsaScanItem::IsRecallOK: File version has changed!\n"));

            //
            // If the use has changed alternate data streams
            // the file version ID may have changed but it is
            // OK to recall the file.  So if the version ID's
            // don't match, then check to see if the truncated
            // part of the file is OK.  If so, allow the recall
            // to happen.
            //

            //
            // Check to see if the whole file is still sparse
            //
            if (IsTotallySparse() == S_OK)  {
                //
                // The file is OK so far to recall but we need
                // to make the last modify dates match
                //
                FSA_PLACEHOLDER     placeholder;
                WsbAffirmHr(pPostIt->GetPlaceholder(&placeholder));;
                placeholder.fileVersionId = scanVersionId;
                WsbAffirmHr(pPostIt->SetPlaceholder(&placeholder));
            } else  {
                //
                // The file has been changed, recalling data will
                // overwrite something that has been added since the
                // truncation occurred.  So don't do anything.
                //
                WsbTrace(OLESTR("File is no longer sparse.!\n"));
                WsbThrow(FSA_E_FILE_CHANGED);
            }


        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::IsRecallOK"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaScanItem::IsSparse(
    void
    )

/*++

Implements:

  IFsaScanItem::IsSparse().

--*/
{
    HRESULT         hr = S_FALSE;
    LONGLONG        size;

    WsbTraceIn(OLESTR("CFsaScanItem::IsSparse"), OLESTR(""));
       
    if ((m_findData.dwFileAttributes & FILE_ATTRIBUTE_SPARSE_FILE) != 0) {
        hr = GetLogicalSize( &size ) ;
        if ( S_OK == hr ) {
            hr = CheckIfSparse(0, size );
            if ( (FSA_E_FILE_IS_TOTALLY_SPARSE == hr) ||
                 (FSA_E_FILE_IS_PARTIALLY_SPARSE == hr) ) {
                hr = S_OK;
            } else {
                hr = S_FALSE;
            }
        }
    }
    WsbTraceOut(OLESTR("CFsaScanItem::IsSparse"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaScanItem::IsTotallySparse(
    void
    )

/*++

Implements:

  IFsaScanItem::IsTotallySparse().

--*/
{
    HRESULT         hr = S_FALSE;
    LONGLONG        size;

    WsbTraceIn(OLESTR("CFsaScanItem::IsTotallySparse"), OLESTR(""));
    if ((m_findData.dwFileAttributes & FILE_ATTRIBUTE_SPARSE_FILE) != 0) {
        hr = GetLogicalSize( &size ) ;
        if ( S_OK == hr ) {
            hr = CheckIfSparse(0, size );
            if (FSA_E_FILE_IS_TOTALLY_SPARSE == hr)  {
                    hr = S_OK;
            } else  {
                hr = S_FALSE;
            }
        }
    }

    WsbTraceOut(OLESTR("CFsaScanItem::IsTotallySparse"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CFsaScanItem::Manage(
    IN LONGLONG offset,
    IN LONGLONG size,
    IN GUID storagePoolId,
    IN BOOL truncate
    )

/*++

Implements:

  IFsaScanItem::Manage().

--*/
{
    HRESULT            hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::Manage"), OLESTR(""));

    try {

        WsbAssert(GUID_NULL != storagePoolId, E_INVALIDARG);
        WsbAffirmHr(m_pResource->Manage((IFsaScanItem*) this, offset, size, storagePoolId, truncate));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::Manage"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaScanItem::Move(
    OLECHAR* dest,
    BOOL /*retainHierarcy*/,
    BOOL /*expandPlaceholders*/,
    BOOL overwriteExisting
    )

/*++

Implements:

  IFsaScanItem::Move().

--*/
{
    HRESULT          hr = S_OK;
    DWORD            mode = MOVEFILE_COPY_ALLOWED;

    try {

        // NOTE : This default behavior causes placeholders
        // to be expanded when moving to another volume and probably doesn't
        // retain the heirarchy.
        WsbAssert(0 != dest, E_POINTER);

        if (overwriteExisting) {
            mode |= MOVEFILE_REPLACE_EXISTING;
        }

        WsbAssert(MoveFileEx(m_findData.cFileName, dest, mode), E_FAIL);

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::Recall(
    IN LONGLONG offset,
    IN LONGLONG size,
    IN BOOL deletePlaceholder
    )

/*++

Implements:

  IFsaScanItem::Recall().

--*/
{
    HRESULT            hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::Recall"), OLESTR(""));

    try {

        WsbAffirmHr(m_pResource->Recall((IFsaScanItem*) this, offset, size, deletePlaceholder));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::Recall"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaScanItem::Recycle(
    void
    )

/*++

Implements:

  IFsaScanItem::Recycle().

--*/
{
    HRESULT            hr = S_OK;

    try {

        // Probably need to look at SHFileOperation().

        hr = E_NOTIMPL;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::IsSystem(
    void
    )

/*++

Implements:

  IFsaScanItem::IsSystem().

--*/
{
    HRESULT            hr = S_FALSE;

    if ((m_findData.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM) != 0) {
        hr = S_OK;
    }

    return(hr);
}


HRESULT
CFsaScanItem::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT        hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaScanItem::Unmanage(
    IN LONGLONG offset,
    IN LONGLONG size
    )

/*++

Implements:

  IFsaScanItem::Unmanage().

--*/
{
    HRESULT            hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::Unmanage"), OLESTR("<%ls>"),
            WsbAbbreviatePath(m_path, 120));

    try {

        // We only need to worry about files that have placeholder information.
        if (IsManaged(offset, size) == S_OK) {

            // If the file is truncated, then we need to recall the data
            // before deleting the placeholder information.
            // NOTE: We set a flag on the Recall so the placeholder will
            // be deleted after the file is recalled.
            if (IsTruncated(offset, size) == S_OK) {
                WsbAffirmHr(Recall(offset, size, TRUE));
            } else {

                //  For disaster recovery, it would be better to delete the placeholder
                //  and THEN remove this file from the premigration list.  Unfortunately,
                //  after deleting the placeholder, the RemovePremigrated call fails
                //  because it needs to get some information from the placeholder (which
                //  is gone).  So we do it in this order.
                hr = m_pResource->RemovePremigrated((IFsaScanItem*) this, offset, size);
                if (WSB_E_NOTFOUND == hr) {
                    //  It's no tragedy if this file wasn't in the list since we were
                    //  going to delete it anyway (although it shouldn't happen) so
                    //  let's continue anyway
                    hr = S_OK;
                }
                WsbAffirmHr(hr);
                WsbAffirmHr(DeletePlaceholder(offset, size));
            }
        }

    } WsbCatch(hr);
    WsbTraceOut(OLESTR("CFsaScanItem::Unmanage"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaScanItem::Validate(
    IN LONGLONG offset,
    IN LONGLONG size
    )

/*++

Implements:

  IFsaScanItem::Validate().

--*/
{
    HRESULT         hr = S_OK;
    BOOL            fileIsTruncated = FALSE;
    LONGLONG        usn = 0;

    WsbTraceIn(OLESTR("CFsaScanItem::Validate"), OLESTR("offset = <%I64u>, size = <%I64u>"),
            offset, size);
    try {
        //
        // Do some local validation before calling the engine.
        //

        // We only need to worry about files that have placeholder information.
        if (IsManaged(offset, size) == S_OK) {
            //
            // If the file is marked as truncated, make sure it is still truncated.
            //
            if (IsTruncated(offset, size) == S_OK) {
                //
                // Check to see if the file is totally sparse to see if it is truncated.
                //
                if (IsTotallySparse() != S_OK)  {
                    //
                    // The file is marked as truncated but is not truncated
                    // Make it truncated.
                    //
                    WsbAffirmHr(Truncate(offset,size));
                    WsbLogEvent(FSA_MESSAGE_VALIDATE_TRUNCATED_FILE, 0, NULL,  WsbAbbreviatePath(m_path, 120), WsbHrAsString(hr), NULL);
                }
            fileIsTruncated = TRUE;
            }
        }

        //
        // The last modify date may be updated on a file if the named data streams
        // have been modified.  So check to see if the dates match.  If they don't,
        // if the file is trunctated, see if it is still truncated, if so, update the
        // modify date in the placeholder to the file's modify date.  If the file is
        // premigrated and the modify dates don't match, delete the placeholder.

        // Get the version ID from the file
        LONGLONG            scanVersionId;
        WsbAffirmHr(GetVersionId(&scanVersionId));

        // Get the version ID from the placeholder
        FSA_PLACEHOLDER     scanPlaceholder;
        WsbAffirmHr(GetPlaceholder(offset, size, &scanPlaceholder));

        if (TRUE == fileIsTruncated)  {

            // Check to see if the dates match
            if (scanPlaceholder.fileVersionId != scanVersionId)  {
                WsbTrace(OLESTR("CFsaScanItem::Validate - placeholer version ID = <%I64u>, file version Id = <%I64u>"),
                        scanPlaceholder.fileVersionId, scanVersionId);
                //
                // Update the placeholder information on the reparse point
                //
                LONGLONG afterPhUsn;
                scanPlaceholder.fileVersionId = scanVersionId;
                WsbAffirmHr(CreatePlaceholder(offset, size, scanPlaceholder, FALSE, 0, &afterPhUsn));
                WsbLogEvent(FSA_MESSAGE_VALIDATE_RESET_PH_MODIFY_TIME, 0, NULL,  WsbAbbreviatePath(m_path, 120), WsbHrAsString(hr), NULL);
            }
        } else {
            // The file is pre-migrated.  Verify that it has not changed since we managed it and if it has then unmanage it.
            if (Verify(offset, size) != S_OK) {
                WsbAffirmHr(Unmanage(offset, size));
                WsbLogEvent(FSA_MESSAGE_VALIDATE_UNMANAGED_FILE, 0, NULL,  WsbAbbreviatePath(m_path, 120), WsbHrAsString(hr), NULL);
            }
        }

        // Now that all of this stuff is OK, call the engine
        if (IsManaged(offset, size) == S_OK) {
            WsbAffirmHr(m_pResource->Validate((IFsaScanItem*) this, offset, size, usn));
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::Validate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CFsaScanItem::FindFirstInDbIndex(
    IN IFsaResource* pResource,
    IN IHsmSession* pSession
    )

/*++

Implements:

  IFsaScanItemPriv::FindFirstInDbIndex().

--*/
{
    HRESULT                  hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::FindFirstInDbIndex"), OLESTR(""));

    try {
        CComPtr<IFsaResourcePriv>   pResourcePriv;

        WsbAssert(0 != pResource, E_POINTER);

        // Store off some of the scan information.
        m_pResource = pResource;
        m_pSession = pSession;

        // If Db is already present (could happen if somebody calls First() twice in a row),
        // we close the Db and reopen since we cannot be sure that the resource is the same!
        if (m_pUnmanageDb != NULL) {
            // Db must be open
            (void)m_pUnmanageDb->Close(m_pDbSession);
            m_pDbSession = 0;
            m_pUnmanageRec = 0;
            m_pUnmanageDb = 0;
        }

        // Get and open the Unmanage db 
        // (Note: if this scanning is ever extended to use another DB, 
        // this method should get additional parameter for which DB to scan)
        WsbAffirmHr(m_pResource->QueryInterface(IID_IFsaResourcePriv,
                (void**) &pResourcePriv));
        hr = pResourcePriv->GetUnmanageDb(IID_IFsaUnmanageDb,
                (void**) &m_pUnmanageDb);
        if (WSB_E_RESOURCE_UNAVAILABLE == hr) {
            // Db was not created ==> no files to scan
            hr = WSB_E_NOTFOUND;
        }
        WsbAffirmHr(hr);

        hr = m_pUnmanageDb->Open(&m_pDbSession);
        if (S_OK != hr) {
            m_pUnmanageDb = NULL;
            WsbAffirmHr(hr);
        }

        // Get a record to traverse with and set for sequential traversing
        WsbAffirmHr(m_pUnmanageDb->GetEntity(m_pDbSession, UNMANAGE_REC_TYPE, IID_IFsaUnmanageRec,
                (void**)&m_pUnmanageRec));
        WsbAffirmHr(m_pUnmanageRec->SetSequentialScan());

        //  Get file information
        WsbAffirmHr(GetFromDbIndex(TRUE));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::FindFirstInDbIndex"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaScanItem::FindNextInDbIndex(
    void
    )

/*++

Implements:

  IFsaScanItemPriv::FindNextInDbIndex().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::FindNextInDbIndex"), OLESTR(""));

    try {
        WsbAssert(m_pUnmanageDb != NULL, E_FAIL);

        //  Get file information
        WsbAffirmHr(GetFromDbIndex(FALSE));

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaScanItem::FindNextInDbIndex"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaScanItem::GetFromDbIndex(
    BOOL first
    )

/*

Implements:

  CFsaScanItem::GetFromDbIndex().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::GetFromDbIndex"), OLESTR(""));

    try {
        IFsaScanItem*   pScanItem;
        HRESULT         hrFindFileId = S_OK;
        LONGLONG        fileId;
        BOOL            bCont;

        WsbAssert(m_pUnmanageDb != NULL, E_FAIL);
        WsbAssert(m_pUnmanageRec != NULL, E_FAIL);

        do {
            bCont = FALSE;

            // Get first/next record
            if (first) {
                hr = m_pUnmanageRec->First();
            } else {
                hr = m_pUnmanageRec->Next();
            }
            WsbAffirm(S_OK == hr, WSB_E_NOTFOUND);

            // Get file id
            WsbAffirmHr(m_pUnmanageRec->GetFileId(&fileId));
   
            //  Reset some items in case this isn't the first call to FindFileId 
            //  (FindFileId actually "attach" the object to a different file)
            if (INVALID_HANDLE_VALUE != m_handle) {
                FindClose(m_handle);
                m_handle = INVALID_HANDLE_VALUE;
            }
            if (TRUE == m_changedAttributes) {
                RestoreAttributes();
            }

            //  Find the file from the ID 
            pScanItem = this;
            hrFindFileId = m_pResource->FindFileId(fileId, m_pSession, &pScanItem);

            //  If the FindFileId failed, we just skip that item and get the 
            //  next one.  This is to keep the scan from just stopping on this
            //  item.  FindFileId could fail because the file has been deleted
            //  or open exclusively by somebody else
            if (!SUCCEEDED(hrFindFileId)) {
                WsbTrace(OLESTR("CFsaScanItem::GetFromDbIndex: file id %I64d skipped since FindFileId failed with hr = <%ls>\n"),
                    fileId, WsbHrAsString(hrFindFileId));
                first = FALSE;
                bCont = TRUE;
            } 
        } while (bCont);

        WsbAffirmHr(pScanItem->Release());  // Get rid of extra ref. count (we get extra ref count only when FindFileId succeeds)

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaScanItem::GetFromDbIndex"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsaitemr.cpp ===
/*++

(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsaitemr.cpp

Abstract:

    This class contains represents a scan item (i.e. file or directory) for NTFS 5.0.

Author:

    Chuck Bardeen   [cbardeen]   1-Dec-1996

Revision History:
    Michael Lotz    [lotz    ]  13-Jan-1997

--*/

#include "stdafx.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_FSA

#include "wsb.h"
#include "fsa.h"
#include "fsaitem.h"
#include "rpdata.h"
#include "rpio.h"
#include "rpguid.h"
#include "fsaitemr.h"


#define SHARE_FLAGS         (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE)
#define EXCLUSIVE_FLAG      ( 0 ) // exclusive open without sharing of the file

//
// Notice these two bits are NOT the same location????
//
#define BIT_FOR_TRUNCATED   FILE_ATTRIBUTE_OFFLINE
#define BIT_FOR_RP          FILE_ATTRIBUTE_REPARSE_POINT

//
// File extensions that are treated as special cases for truncate
//
#define EXT_FOR_EXE     L".exe"
#define EXT_FOR_DLL     L".dll"

//
// Macros and defines for exe and dll headers
//
#define SIZE_OF_NT_SIGNATURE    sizeof(DWORD)
//
// Macros
//
/* Offset to PE file signature                              */
#define NTSIGNATURE(a) ((LPVOID)((BYTE *)a                +  \
                        ((PIMAGE_DOS_HEADER)a)->e_lfanew))

/* MS-OS header identifies the NT PEFile signature dword;
   the PEFILE header exists just after that dword.           */
#define PEFHDROFFSET(a) ((LPVOID)((BYTE *)a               +  \
                         ((PIMAGE_DOS_HEADER)a)->e_lfanew +  \
                             SIZE_OF_NT_SIGNATURE))

/* PE optional header is immediately after PEFile header.    */
#define OPTHDROFFSET(a) ((LPVOID)((BYTE *)a               +  \
                         ((PIMAGE_DOS_HEADER)a)->e_lfanew +  \
                           SIZE_OF_NT_SIGNATURE           +  \
                           sizeof (IMAGE_FILE_HEADER)))

/* Section headers are immediately after PE optional header. */
#define SECHDROFFSET(a) ((LPVOID)((BYTE *)a               +  \
                         ((PIMAGE_DOS_HEADER)a)->e_lfanew +  \
                           SIZE_OF_NT_SIGNATURE           +  \
                           sizeof (IMAGE_FILE_HEADER)     +  \
                           sizeof (IMAGE_OPTIONAL_HEADER)))



HRESULT
OpenObject (
    IN WCHAR const *pwszFile,
    IN ULONG CreateOptions,
    IN ULONG DesiredAccess,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    OUT IO_STATUS_BLOCK *IoStatusBlock,
    OUT HANDLE *ObjectHandle 
    )
    
/*++

Implements: A wrapper function for NtCreateFile

  OpenObject

--*/
//
//  Simple wrapper for NtCreateFile
//

{
    HRESULT             hr = S_OK;
    NTSTATUS            ntStatus;
    BOOL                bStatus;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      str;
    RTL_RELATIVE_NAME   RelativeName;
    PVOID               RelativeBuffer = NULL;
    PVOID               StrBuffer = NULL;

    WsbTraceIn(OLESTR("OpenObject"), OLESTR(""));
    //
    // Null out the pointer so we know when it was allocated
    //
    str.Buffer = NULL;
    RelativeName.RelativeName.Buffer = NULL;
    
    try {
        //
        // Convert input name into special format with \??\
        //
        //bStatus = RtlDosPathNameToNtPathName_U( pwszFile,
        //                                        &str,
        //                                        NULL,
        //                                        NULL );
        //WsbAffirm( bStatus, E_FAIL);


        bStatus = RtlDosPathNameToNtPathName_U(
                                pwszFile,
                                &str,
                                NULL,
                                &RelativeName
                                );

        WsbAffirm( bStatus, E_FAIL);
        StrBuffer = str.Buffer;

        if ( RelativeName.RelativeName.Length ) {
            str = *(PUNICODE_STRING)&RelativeName.RelativeName;
        } else {
            RelativeName.ContainingDirectory = NULL;
        }

        RelativeBuffer = RelativeName.RelativeName.Buffer;

        InitializeObjectAttributes(
            &ObjectAttributes,
            &str,
            0,
            RelativeName.ContainingDirectory,
            NULL
            );


        ntStatus = NtCreateFile(
                    ObjectHandle,
                    DesiredAccess | SYNCHRONIZE,
                    &ObjectAttributes,
                    IoStatusBlock,
                    NULL,                    // pallocationsize (none!)
                    FILE_ATTRIBUTE_NORMAL,
                    ShareAccess,
                    CreateDisposition,
                    CreateOptions | FILE_OPEN_REPARSE_POINT | FILE_OPEN_FOR_BACKUP_INTENT | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,                    // EA buffer (none!)
                    0);
        //
        // Right now if the file is not a reparse point the above open
        // fails -- so now try it without the FILE_OPEN_REPARSE_POINT
        //
        if ( STATUS_NOT_A_REPARSE_POINT == ntStatus) {          
            WsbAffirmNtStatus(  NtCreateFile(
                        ObjectHandle,
                        DesiredAccess | SYNCHRONIZE,
                        &ObjectAttributes,
                        IoStatusBlock,
                        NULL,                    // pallocationsize (none!)
                        FILE_ATTRIBUTE_NORMAL,
                        ShareAccess,
                        CreateDisposition,
                        CreateOptions | FILE_OPEN_FOR_BACKUP_INTENT | FILE_SYNCHRONOUS_IO_NONALERT | FILE_FLAG_POSIX_SEMANTICS,
                        NULL,                    // EA buffer (none!)
                        0 ) );
        } else {
            WsbAffirmNtStatus( ntStatus );
        }

    } WsbCatch( hr );
 
    //
    // Clean up the memory if we allocated it
    //
    if (NULL != RelativeBuffer)
        RtlFreeHeap(RtlProcessHeap(), 0, RelativeBuffer);


    if (NULL != StrBuffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, StrBuffer);
    }

    //if( NULL == str.Buffer ) {
    //    bStatus = RtlFreeHeap( RtlProcessHeap(), 0, str.Buffer );
    //}
    
    WsbTraceOut(OLESTR("OpenObject"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return( hr );
}  // OpenObject


HRESULT
OpenDocView (
    IN WCHAR const *pwszFile,
    IN ULONG CreateOptions,
    IN ULONG DesiredAccess,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    OUT IO_STATUS_BLOCK *IoStatusBlock,
    OUT HANDLE *ObjectHandle 
    )
    
/*++

Implements: A wrapper function for NtCreateFile that gets a DOCVIEW of the file

  OpenDocView

--*/
//
//  Simple wrapper for NtCreateFile
//

{
    HRESULT             hr = S_OK;
    NTSTATUS            ntStatus;
    BOOL                bStatus;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      str;
    RTL_RELATIVE_NAME   RelativeName;
    PVOID               RelativeBuffer = NULL;
    PVOID               StrBuffer = NULL;

    WsbTraceIn(OLESTR("OpenDocView"), OLESTR(""));
    //
    // Null out the pointer so we know when it was allocated
    //
    str.Buffer = NULL;
    RelativeName.RelativeName.Buffer = NULL;
    
    try {
        //

        bStatus = RtlDosPathNameToNtPathName_U(
                                pwszFile,
                                &str,
                                NULL,
                                &RelativeName
                                );

        WsbAffirm( bStatus, E_FAIL);
        StrBuffer = str.Buffer;

        if ( RelativeName.RelativeName.Length ) {
            str = *(PUNICODE_STRING)&RelativeName.RelativeName;
        } else {
            RelativeName.ContainingDirectory = NULL;
        }

        RelativeBuffer = RelativeName.RelativeName.Buffer;

        InitializeObjectAttributes(
            &ObjectAttributes,
            &str,
            0,
            RelativeName.ContainingDirectory,
            NULL
            );


        ntStatus = NtCreateFile(
                    ObjectHandle,
                    DesiredAccess | SYNCHRONIZE,
                    &ObjectAttributes,
                    IoStatusBlock,
                    NULL,                    // pallocationsize (none!)
                    FILE_ATTRIBUTE_NORMAL,
                    ShareAccess,
                    CreateDisposition,
                    CreateOptions | FILE_OPEN_FOR_BACKUP_INTENT | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,                    // EA buffer (none!)
                    0);

        WsbAffirmNtStatus( ntStatus );

    } WsbCatch( hr );
 
    //
    // Clean up the memory if we allocated it
    //
    if (NULL != RelativeBuffer)
        RtlFreeHeap(RtlProcessHeap(), 0, RelativeBuffer);


    if (NULL != StrBuffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, StrBuffer);
    }

    
    WsbTraceOut(OLESTR("OpenDocView"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return( hr );
}  // OpenDocView





HRESULT
CopyPlaceholderToRP (
    IN CONST FSA_PLACEHOLDER *pPlaceholder,
    OUT PREPARSE_DATA_BUFFER pReparseBuffer,
    IN BOOL bTruncated
    )
    
/*++

Implements: A wrapper function for copying the placeholder data into the reparse point

  CopyPlaceholderToRP

--*/
//
//  Simple wrapper moving the data from the scan item in-memory 
//  placeholder information into a reparse point buffer
//

{
    HRESULT         hr = S_OK;
    PRP_DATA        pHsmData;
    
    WsbTraceIn(OLESTR("CopyPlaceholderToRP"), OLESTR(""));
    WsbTrace(OLESTR("  fileStart = %I64d, dataStart = %I64d, dataStreamStart = %I64d\n"),
            pPlaceholder->fileStart, pPlaceholder->dataStart, 
            pPlaceholder->dataStreamStart);
    WsbTrace(OLESTR("  fileSize = %I64d, dataSize = %I64d, dataStreamSize = %I64d\n"),
            pPlaceholder->fileSize, pPlaceholder->dataSize, 
            pPlaceholder->dataStreamSize);
    try {
        //
        // Validate the pointers passed in
        //
        WsbAssert( NULL != pPlaceholder, E_POINTER );
        WsbAssert( NULL != pReparseBuffer, E_POINTER );
        
        //
        // Setup the pointer to our hsm data
        //
        pHsmData = (PRP_DATA) &pReparseBuffer->GenericReparseBuffer.DataBuffer[0];

        //
        // Set the generic reparse point header information for the tag and size
        //
        pReparseBuffer->ReparseTag        = IO_REPARSE_TAG_HSM ;
        pReparseBuffer->ReparseDataLength = sizeof(RP_DATA);
        pReparseBuffer->Reserved          = 0 ;

        //
        // Set the private data that is the vendor id and version number
        //
        pHsmData->vendorId = RP_MSFT_VENDOR_ID;
        pHsmData->version  = RP_VERSION;
        
        //
        // Assume for now that there is only one placeholder
        // This needs to be updated
        //
        pHsmData->numPrivateData = 1;
        pHsmData->fileIdentifier = GUID_NULL;
        
        
        ZeroMemory(pHsmData->data.reserved, RP_RESV_SIZE);
        //
        // If the file is to indicate the file is truncated then set the bit
        // otherwise make sure it is off
        //
        RP_INIT_BITFLAG( pHsmData->data.bitFlags );
        if( bTruncated ) {
            RP_SET_TRUNCATED_BIT( pHsmData->data.bitFlags );
        } else {
            RP_CLEAR_TRUNCATED_BIT( pHsmData->data.bitFlags );
        }

        //
        // Set the truncate on close bit as needed
        //
        if( pPlaceholder->truncateOnClose ) {
            RP_SET_TRUNCATE_ON_CLOSE_BIT( pHsmData->data.bitFlags );
        } else {
            RP_CLEAR_TRUNCATE_ON_CLOSE_BIT( pHsmData->data.bitFlags );
        }

        //
        // Set the Premigrate on close bit as needed
        //
        if( pPlaceholder->premigrateOnClose ) {
            RP_SET_PREMIGRATE_ON_CLOSE_BIT( pHsmData->data.bitFlags );
        } else {
            RP_CLEAR_PREMIGRATE_ON_CLOSE_BIT( pHsmData->data.bitFlags );
        }

        //
        // Set the global bit flags based on the placeholder data
        // For now since we are assuming one placeholder then set
        // them the same.
        pHsmData->globalBitFlags = pHsmData->data.bitFlags;

        //
        // Move over the data parts of the information
        //
        pHsmData->data.migrationTime.QuadPart    = WsbFTtoLL( pPlaceholder->migrationTime );
        pHsmData->data.hsmId                     = pPlaceholder->hsmId;
        pHsmData->data.bagId                     = pPlaceholder->bagId;
        pHsmData->data.fileStart.QuadPart        = pPlaceholder->fileStart;
        pHsmData->data.fileSize.QuadPart         = pPlaceholder->fileSize;
        pHsmData->data.dataStart.QuadPart        = pPlaceholder->dataStart;
        pHsmData->data.dataSize.QuadPart         = pPlaceholder->dataSize;
        pHsmData->data.fileVersionId.QuadPart    = pPlaceholder->fileVersionId;
        pHsmData->data.verificationData.QuadPart = pPlaceholder->verificationData;
        pHsmData->data.verificationType          = pPlaceholder->verificationType;
        pHsmData->data.recallCount               = pPlaceholder->recallCount;
        pHsmData->data.recallTime.QuadPart       = WsbFTtoLL( pPlaceholder->recallTime );
        pHsmData->data.dataStreamStart.QuadPart  = pPlaceholder->dataStreamStart;
        pHsmData->data.dataStreamSize.QuadPart   = pPlaceholder->dataStreamSize;
        pHsmData->data.dataStream                = pPlaceholder->dataStream;

        pHsmData->data.dataStreamCRCType         = pPlaceholder->dataStreamCRCType;
        pHsmData->data.dataStreamCRC.QuadPart    = pPlaceholder->dataStreamCRC;
        //
        // Lastly generate the check sum
        //
        RP_GEN_QUALIFIER(pHsmData, pHsmData->qualifier);

        //
        // Now set the bit that tells the filter that it is us setting the reparse point.
        // This is not included in the qualifier checksum generation.
        //
        RP_SET_ORIGINATOR_BIT( pHsmData->data.bitFlags );

        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CopyPlaceholderToRP"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return( hr );
}





HRESULT
CopyRPDataToPlaceholder (
    IN CONST PRP_DATA pHsmData,
    OUT FSA_PLACEHOLDER *pPlaceholder
    )
    
/*++

Implements: A wrapper function for moving the Reparse Point into generic FSA_PLACEHOLDER format

  CopyRPDataToPlaceholder

--*/

{
    HRESULT         hr = S_OK;
    ULONG           qualifier;        // Used to checksum the data
    
    WsbTraceIn(OLESTR("CopyRPDataToPlaceholder"), OLESTR(""));
    WsbTrace(OLESTR("  fileStart = %I64d, dataStart = %I64d, dataStreamStart = %I64d\n"),
            pHsmData->data.fileStart.QuadPart, pHsmData->data.dataStart.QuadPart, 
            pHsmData->data.dataStreamStart.QuadPart);
    WsbTrace(OLESTR("  fileSize = %I64d, dataSize = %I64d, dataStreamSize = %I64d\n"),
            pHsmData->data.fileSize.QuadPart, pHsmData->data.dataSize.QuadPart, 
            pHsmData->data.dataStreamSize.QuadPart);
    //
    //  Simple wrapper moving the data from the reparse point buffer into the 
    //  generic placeholder information
    //
    try {
        //
        // Validate the pointers passed in
        //
        WsbAssert( NULL != pHsmData, E_POINTER );
        WsbAssert( NULL != pPlaceholder, E_POINTER );

        //
        // Just in case, we clear out the originator bit.
        //
        RP_CLEAR_ORIGINATOR_BIT( pHsmData->data.bitFlags );

        //
        // Verify the check sum and the key private fields
        //
        RP_GEN_QUALIFIER(pHsmData, qualifier);
        WsbAffirm( pHsmData->qualifier == qualifier, E_FAIL );
        WsbAffirm( RP_MSFT_VENDOR_ID   == pHsmData->vendorId, E_FAIL );
        WsbAffirm( RP_VERSION          == pHsmData->version, E_FAIL );
        
        //
        // Now that everything worked, save the values in our private data
        //
        pPlaceholder->migrationTime     = WsbLLtoFT( pHsmData->data.migrationTime.QuadPart );
        pPlaceholder->hsmId             = pHsmData->data.hsmId;
        pPlaceholder->bagId             = pHsmData->data.bagId;
        pPlaceholder->fileStart         = pHsmData->data.fileStart.QuadPart;
        pPlaceholder->fileSize          = pHsmData->data.fileSize.QuadPart;
        pPlaceholder->dataStart         = pHsmData->data.dataStart.QuadPart;
        pPlaceholder->dataSize          = pHsmData->data.dataSize.QuadPart;
        pPlaceholder->fileVersionId     = pHsmData->data.fileVersionId.QuadPart;
        pPlaceholder->verificationData  = pHsmData->data.verificationData.QuadPart;
        pPlaceholder->verificationType  = pHsmData->data.verificationType;
        pPlaceholder->recallCount       = pHsmData->data.recallCount;
        pPlaceholder->recallTime        = WsbLLtoFT( pHsmData->data.recallTime.QuadPart );
        pPlaceholder->dataStreamStart   = pHsmData->data.dataStreamStart.QuadPart;
        pPlaceholder->dataStreamSize    = pHsmData->data.dataStreamSize.QuadPart;
        pPlaceholder->dataStream        = pHsmData->data.dataStream;
        pPlaceholder->dataStreamCRCType = pHsmData->data.dataStreamCRCType;
        pPlaceholder->dataStreamCRC     = pHsmData->data.dataStreamCRC.QuadPart;

        //
        // Set placeholder bits
        //
        if( RP_FILE_IS_TRUNCATED( pHsmData->data.bitFlags ) ) {
            pPlaceholder->isTruncated = TRUE;
        } else {
            pPlaceholder->isTruncated = FALSE;
        }

        if( RP_FILE_DO_TRUNCATE_ON_CLOSE( pHsmData->data.bitFlags ) ) {
            pPlaceholder->truncateOnClose = TRUE;
        } else {
            pPlaceholder->truncateOnClose = FALSE;
        }

        if( RP_FILE_DO_PREMIGRATE_ON_CLOSE( pHsmData->data.bitFlags ) ) {
            pPlaceholder->premigrateOnClose = TRUE;
        } else {
            pPlaceholder->premigrateOnClose = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CopyRPDataToPlaceholder"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return( hr );
}

HRESULT
CopyRPToPlaceholder (
    IN CONST PREPARSE_DATA_BUFFER pReparseBuffer,
    OUT FSA_PLACEHOLDER *pPlaceholder
    )
    
/*++

Implements: A wrapper function for moving the Reparse Point into generic FSA_PLACEHOLDER format

  CopyRPToPlaceholder

--*/

{
    HRESULT         hr = S_OK;
    PRP_DATA        pHsmData;
    
    WsbTraceIn(OLESTR("CopyRPToPlaceholder"), OLESTR(""));
    //
    //  Simple wrapper moving the data from the reparse point buffer into the 
    //  generic placeholder information
    //
    try {
        //
        // Validate the pointers passed in
        //
        WsbAssert( NULL != pReparseBuffer, E_POINTER );
        WsbAssert( NULL != pPlaceholder, E_POINTER );

        //
        // Get the pointers setup correctly to this buffer because the 
        // type REPARSE_DATA_BUFFER actually doesn't have any space
        // allocated for the data and that is our own type, so get pointers
        // pointing into the real allocated space so we can use them
        //
        pHsmData = (PRP_DATA) &pReparseBuffer->GenericReparseBuffer.DataBuffer[0];

        //
        // Validate the key public fields to make sure it is data we 
        // understand
        //
        WsbAffirm( IO_REPARSE_TAG_HSM == pReparseBuffer->ReparseTag , S_FALSE );
        WsbAffirm( sizeof(RP_DATA) == pReparseBuffer->ReparseDataLength , S_FALSE );

        //
        // Copy over the RP_DATA information
        //
        WsbAffirmHr(CopyRPDataToPlaceholder(pHsmData, pPlaceholder));


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CopyRPToPlaceholder"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return( hr );
}



HRESULT 
CFsaScanItem::CalculateCurrentCRCAndUSN(
    IN LONGLONG offset,
    IN LONGLONG size,
    OUT ULONG *pCurrentCRC,
    OUT LONGLONG *pUsn
    )

{
    HRESULT                 hr = S_OK;
    HRESULT                 hrTest = S_OK;
    CWsbStringPtr           path;
    IO_STATUS_BLOCK         IoStatusBlock;
    HANDLE                  handle = INVALID_HANDLE_VALUE;
    FILE_BASIC_INFORMATION  basicInformation;

    try {
        WsbTraceIn(OLESTR("CFsaScanItem::CalculateCurrentCRCAndUSN"), OLESTR("offset = <%I64d>, size = <%I64d>"),
                offset, size);

        //
        // Create the real file name we need to open, under the covers this
        // allocates the buffer since the path pointer is null
        //
        WsbAffirmHr( GetFullPathAndName( OLESTR("\\\\?\\"), NULL, &path, 0));
        //WsbAffirmHr( GetFullPathAndName( NULL, NULL, &path, 0));
        WsbTrace(OLESTR("CFsaScanItem::CalculateCurrentCRCAndUSN for file <%ls>"), (OLECHAR *)path);
        
        // Open the file.   
        WsbAffirmHr( OpenObject( path, 
                                 FILE_NON_DIRECTORY_FILE,
                                 FILE_READ_DATA | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES,
                                 EXCLUSIVE_FLAG,
                                 FILE_OPEN,
                                 &IoStatusBlock,
                                 &handle ) );

        //
        // The open worked, our handle should be valid but we check to be
        // safe and sure 
        //
        WsbAssertHandle( handle );
        
        //
        // Get the current attributes of the file and the times
        //
        WsbAssertNtStatus( NtQueryInformationFile( handle,
                                                    &IoStatusBlock,
                                                    (PVOID)&basicInformation,
                                                    sizeof( basicInformation ),
                                                    FileBasicInformation ) );
        
        //
        // Set the time flags so that when we close the handle the
        // time are not updated on the file and the FileAttributes 
        //
        basicInformation.CreationTime.QuadPart = -1;
        basicInformation.LastAccessTime.QuadPart = -1;
        basicInformation.LastWriteTime.QuadPart = -1;
        basicInformation.ChangeTime.QuadPart = -1;
        WsbAssertNtStatus( NtSetInformationFile( handle,
                                                 &IoStatusBlock,
                                                 (PVOID)&basicInformation,
                                                 sizeof( basicInformation ),
                                                 FileBasicInformation ) );
        //
        // Calculate the CRC
        //                                         
        WsbAffirmHr(CalculateCurrentCRCInternal(handle, offset, size, pCurrentCRC));                                                 
        
        //
        // Calculate the USN
        //
        *pUsn = 0;
        hr = WsbGetUsnFromFileHandle(handle, FALSE, pUsn); 
        if (S_OK != hr)  {
            //
            // If we can't get the USN set it to 0 which is an invalid
            // USN and keep going.
            *pUsn = 0;
            hr = S_OK;
        }
        
        //
        // Close the file
        //
        NtClose( handle );
        handle = INVALID_HANDLE_VALUE;
        
    } WsbCatch( hr );
    
    //
    // Close the file for sure
    //
    if( INVALID_HANDLE_VALUE != handle) {
        NtClose( handle );
    }

    WsbTraceOut(OLESTR("CalculateCurrentCRCAndUSN"), OLESTR("hr = <%ls>, CRC is <%ls>, USN is <%ls>"), 
        WsbHrAsString(hr), WsbPtrToUlongAsString(pCurrentCRC), WsbPtrToLonglongAsString(pUsn));
    return(hr);
}

HRESULT 
CFsaScanItem::CalculateCurrentCRCInternal(
    IN HANDLE   handle,
    IN LONGLONG offset,
    IN LONGLONG size,
    ULONG *pCurrentCRC
    )

{
    HRESULT                 hr = S_OK;
    HRESULT                 hrTest = S_OK;
    register ULONG          crc32 = 0;
    LONGLONG                bytesRemaining;
    LONGLONG                bytesToRead;
    ULONG                   bufferSize;
    ULONG                   bytesRead;
    CHAR *                  pBuffer = 0;
    CHAR *                  pCurrent;
    IO_STATUS_BLOCK         IoStatusBlock;

    try {
        WsbTraceIn(OLESTR("CFsaScanItem::CalculateCurrentCRCInternal"), OLESTR("offset = <%I64d>, size = <%I64d>"),
                offset, size);

        
        // set initial value of CRC to 'pre-conditioning value'
        INITIALIZE_CRC(crc32);

        //
        // Set up to read where we want to start
        //
        LARGE_INTEGER startPoint;
        startPoint.QuadPart = offset;
        
        // Get the size of the file.
        bytesToRead = size;
        
        //
        // Figure out the size of the buffer to create
        //
        if (bytesToRead < 1024*1024) {
            //
            // Allocate one buffer the size of the file
            //
            bufferSize = (ULONG)bytesToRead;
        } else  {
            bufferSize = (1024 * 1024);
        }
        
        pBuffer = (CHAR *)malloc(bufferSize);
        if (0 == pBuffer) {
            //
            // Try again for half the space
            //
            bufferSize = bufferSize / 2;
            pBuffer = (CHAR *)malloc(bufferSize);
            if (0 == pBuffer)  {
                WsbThrow( E_OUTOFMEMORY );
            }
        }

        // Start calculating CRC by processing a 'chunk' of the file at a time.
        // While there are still chunks left, read that amount.  Otherwise read the amount left.
        for (bytesRemaining = bytesToRead; bytesRemaining > 0; bytesRemaining -= bytesRead) {

            // Read data from the file. 
            WsbAssertNtStatus(NtReadFile(handle, NULL, NULL, NULL, &IoStatusBlock, pBuffer, bufferSize, &startPoint, NULL));
            bytesRead = (DWORD)IoStatusBlock.Information;
            startPoint.QuadPart += bytesRead;

            // Each byte needs to be added into the CRC.
            for (pCurrent = pBuffer; (pCurrent < (pBuffer + bytesRead)) && (S_OK == hr); pCurrent++) {

                hrTest = WsbCRCReadFile((UCHAR *)pCurrent, &crc32);
                if (S_OK != hrTest) {
                    hr = S_FALSE;
                }
            }
        }
        
        // return ones-complement of the calc'd CRC value - this is the actual CRC
        FINIALIZE_CRC(crc32);
        *pCurrentCRC = crc32;

    } WsbCatch( hr );
    
    //
    // Make sure allocated memory is freed
    //
    if (0 != pBuffer)  {
        free(pBuffer);
    }    
    
    
    WsbTraceOut(OLESTR("CalculateCurrentCRCInternal"), OLESTR("hr = <%ls>, CRC is <%ls>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pCurrentCRC));
    return(hr);
}

HRESULT
CFsaScanItem::CreatePlaceholder(
    IN LONGLONG offset,
    IN LONGLONG size,
    IN FSA_PLACEHOLDER placeholder,
    IN BOOL checkUsn,
    IN LONGLONG usn,                    
    OUT LONGLONG *pUsn
    )  

/*++

Implements:

  IFsaScanItem::CreatePlaceholder().

--*/
{
    HRESULT                 hr = S_OK;
    CWsbStringPtr           path;
    HANDLE                  handle = INVALID_HANDLE_VALUE;
    ULONG                   DesiredAccess;
    IO_STATUS_BLOCK         IoStatusBlock;
    PREPARSE_DATA_BUFFER    pReparseBuffer;
    UCHAR                   ReparseBuffer[sizeof(REPARSE_DATA_BUFFER) + sizeof(RP_DATA) + 10];
    NTSTATUS                ntStatus;
    FILE_BASIC_INFORMATION  basicInformation;
    LONGLONG                lastWriteTime;
    LONGLONG                nowUsn = 0;
    CWsbStringPtr           volName;
    ULONG                   attributes;

    WsbTraceIn(OLESTR("CFsaScanItem::CreatePlaceholder"), OLESTR("offset = <%I64d>, size = <%I64d>, checkUsn = <%ls>, usn = <%I64d>"),
                        offset, size, WsbBoolAsString(checkUsn), usn);
    try {
        BOOL wasReadOnly = FALSE;
        
        //
        // Set the offset and size information
        //
        placeholder.dataStreamStart = offset;
        placeholder.dataStreamSize = size;
        
        //
        // Get the pointers setup correctly to this buffer because the 
        // type REPARSE_DATA_BUFFER actually doesn't have any space
        // allocated for the data and that is our own type, so get pointers
        // pointing into the real allocated space so we can use them
        //
        pReparseBuffer = (PREPARSE_DATA_BUFFER)ReparseBuffer;
        WsbAffirmHr( CopyPlaceholderToRP( &placeholder, pReparseBuffer, placeholder.isTruncated ) );
        
        //
        // Create the real file name we need to open, under the covers this
        // allocates the buffer since the path pointer is null
        //
        WsbAffirmHr( GetFullPathAndName( OLESTR("\\\\?\\"), NULL, &path, 0));
        //WsbAffirmHr( GetFullPathAndName( NULL, NULL, &path, 0));

        // Save whether this was readonly for later
        if (S_OK == IsReadOnly()) {
            wasReadOnly = TRUE;
        }
        
        //
        // Make sure the file is read/write
        WsbAffirmHr( MakeReadWrite() );
        
        //
        // Open the file to put the placeholder information in the reparse point
        //
        DesiredAccess = FILE_READ_DATA | FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES ;
        WsbAffirmHr( OpenObject( path, 
                                 FILE_NON_DIRECTORY_FILE | FILE_NO_INTERMEDIATE_BUFFERING,
                                 DesiredAccess,
                                 EXCLUSIVE_FLAG,
                                 FILE_OPEN,
                                 &IoStatusBlock,
                                 &handle ) );

        //
        // The open worked, our handle should be valid but we check to be
        // safe and sure 
        //
        WsbAssertHandle( handle );

        //
        // Tell the USN journal that we are the source of the changes.
        //
        WsbAffirmHr(m_pResource->GetPath(&volName, 0));
        WsbAffirmHr(WsbMarkUsnSource(handle, volName));

        
        //
        // Get the USN from the file now before any writes occur.  
        // Note:  NtSetInformationFile will not change the USN if you set the FileAttributes to 0
        // and the dates to -1.  Setting the attributes to 0 leaves them unchanged.
        // 
        // (For now we skip this check for read-only files because the call to MakeReadWrite
        // changes the USN. This needs to be fixed in the future.)
        //
        if (checkUsn && !wasReadOnly)  {
            //
            // Get the current USN for this file
            //
            hr = WsbGetUsnFromFileHandle(handle, FALSE, &nowUsn);
            if (S_OK != hr)  {
                nowUsn = 0;
                hr = S_OK;
            }
        }            
        
        //
        // Get the current attributes of the file and the times
        //
        WsbAssertNtStatus( NtQueryInformationFile( handle,
                                                    &IoStatusBlock,
                                                    (PVOID)&basicInformation,
                                                    sizeof( basicInformation ),
                                                    FileBasicInformation ) );
        
        lastWriteTime = basicInformation.LastWriteTime.QuadPart;
        
        //
        // Set the time flags so that when we close the handle the
        // time are not updated on the file and the FileAttributes 
        // indicate the file is offline.  You must do this AFTER you
        // get the USN because the NtSetInformationFile changes the USN
        //
        basicInformation.CreationTime.QuadPart = -1;
        basicInformation.LastAccessTime.QuadPart = -1;
        basicInformation.LastWriteTime.QuadPart = -1;
        basicInformation.ChangeTime.QuadPart = -1;
        //
        // Set the attributes to 0 to avoid the usn change (the file attributes will remain unchanged).
        //
        attributes = basicInformation.FileAttributes;
        basicInformation.FileAttributes = 0;               // No change to attributes

        WsbAssertNtStatus( NtSetInformationFile( handle,
                                                 &IoStatusBlock,
                                                 (PVOID)&basicInformation,
                                                 sizeof( basicInformation ),
                                                 FileBasicInformation ) );
        
        
        basicInformation.FileAttributes = attributes;

        //
        // Make sure that the modify time of the file matches that
        // of the placeholder data. 
        //
        if (lastWriteTime != placeholder.fileVersionId)  {
            //
            // The file has changed - don't put the reparse point on the file.
            //
            hr = FSA_E_REPARSE_NOT_WRITTEN_FILE_CHANGED;
            WsbLogEvent(FSA_MESSAGE_REPARSE_NOT_WRITTEN_FILE_CHANGED, 0, NULL,  WsbAbbreviatePath(path, 120), WsbHrAsString(hr), NULL);
            WsbThrow( hr );
        } else if (checkUsn)  {
            // 
            // If we are to check the USN do it now
            //
            
            //
            // Rember if a USN is 0, it is not useful information so we can't
            // rely on it
            //
            WsbTrace(OLESTR("CFsaScanItem::CreatePlaceholder premig usn = <%I64d>, current usn <%I64d>\n"),
                    usn, nowUsn);
            if ((0 != nowUsn) && (0  != usn) && (nowUsn != usn))  {
                //
                // The file has changed - don't put the reparse point on the file.
                //
                hr = FSA_E_REPARSE_NOT_WRITTEN_FILE_CHANGED;
                WsbLogEvent(FSA_MESSAGE_REPARSE_NOT_WRITTEN_FILE_CHANGED, 0, NULL,  WsbAbbreviatePath(path, 120), WsbHrAsString(hr), NULL);
                WsbThrow( hr );
            }
        }

        //
        // Make the file able to be a sparse file
        // Note we assert only if the error is not a disk full error because we can get STATUS_NO_DISK_SPACE from this call and we 
        // do not want to see the log for that error.  
        // This is because the file must be padded out to a 16 cluster boundry before being made sparse.
        //
        // Note that this call does not affect the files data.  It just enables "sparseness" for the file. 
        //
        ntStatus = NtFsControlFile( handle,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_SET_SPARSE,
                                NULL,
                                0,
                                NULL,
                                0 );


        if (!NT_SUCCESS(ntStatus)) {
            if (STATUS_DISK_FULL == ntStatus) {
                hr = FSA_E_REPARSE_NOT_CREATED_DISK_FULL;
            } else {
                hr = HRESULT_FROM_NT(ntStatus);
            }
            WsbLogEvent(FSA_MESSAGE_REPARSE_NOT_CREATED, 0, NULL,  
                    WsbAbbreviatePath(path, 120), WsbHrAsString(hr), NULL);
            WsbThrow(hr);
        }
        
                                                            
        //
        // Do the work of setting the Reparse Point
        //
        ntStatus = NtFsControlFile( handle,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &IoStatusBlock,
                                  FSCTL_SET_REPARSE_POINT,
                                  pReparseBuffer,
                                  FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer)
                                    + pReparseBuffer->ReparseDataLength,
                                  NULL,
                                  0 );
        
        //
        // Check the return code, if everything worked update the in memory flag
        //
        if (!NT_SUCCESS(ntStatus)) {
            if (STATUS_DISK_FULL == ntStatus) {
                hr = FSA_E_REPARSE_NOT_CREATED_DISK_FULL;
            } else {
                hr = HRESULT_FROM_NT(ntStatus);
            }
            WsbLogEvent(FSA_MESSAGE_REPARSE_NOT_CREATED, 0, NULL,  
                    WsbAbbreviatePath(path, 120), WsbHrAsString(hr), NULL);
            WsbThrow(hr);
        }
 
        //
        // Now that we change the bit, change the in memory flags for 
        // this scan item
        //
        m_findData.dwFileAttributes |= BIT_FOR_RP;
 
        //
        // Set the OFFLINE attribute to indicate the correct status of 
        // the file
        //
        if( placeholder.isTruncated ) {
            basicInformation.FileAttributes |= BIT_FOR_TRUNCATED;
        } else {
            basicInformation.FileAttributes &= ~BIT_FOR_TRUNCATED;
        }

        basicInformation.FileAttributes |= FILE_ATTRIBUTE_NORMAL;  // Just in case result was zero (then no attributes would be set)

        WsbAssertNtStatus( NtSetInformationFile( handle,
                                                 &IoStatusBlock,
                                                 (PVOID)&basicInformation,
                                                 sizeof( basicInformation ),
                                                 FileBasicInformation ) );
        
        //
        // Get the current attributes of the file and the times
        //
        WsbAssertNtStatus( NtQueryInformationFile( handle,
                                                    &IoStatusBlock,
                                                    (PVOID)&basicInformation,
                                                    sizeof( basicInformation ),
                                                    FileBasicInformation ) );
        
        //
        // Set the in memory copy of the attributes to the right values
        //
        m_findData.dwFileAttributes = basicInformation.FileAttributes;

        //
        // Restore original attributes if required (must be done before retrieving the USN
        // since changing attributes changes the USN as well)
        //
        if (TRUE == m_changedAttributes) {
            RestoreAttributes();
        }

        //
        // Before we close the file, get the USN to return to the caller
        // Writing the reparse information will change the USN.
        //
        hr = WsbGetUsnFromFileHandle(handle, TRUE, pUsn);
        if (S_OK != hr)  {
            *pUsn = 0;
            hr = S_OK;
        }
        
        //
        // Close the file since we are done with it and set the handle to invalid
        //
        WsbAssertNtStatus( NtClose( handle ) );
        handle =  INVALID_HANDLE_VALUE;

        //
        // Now that everything worked change the in memory flags for 
        // this scan item
        //
        m_placeholder    = placeholder;
        m_gotPlaceholder = TRUE;
        WsbTrace( OLESTR("(CreatePlaceholder) Reparse CRC <%ls>\n"), 
                            WsbLonglongAsString( m_placeholder.dataStreamCRC ) );
                                                                                

    } WsbCatch(hr);

    //
    // if we opened the file we need to close it
    //
    if( INVALID_HANDLE_VALUE != handle) {
        NtClose( handle );
    }

    WsbTraceOut(OLESTR("CFsaScanItem::CreatePlaceholder"), OLESTR("hr = <%ls>, usn = <%ls>"), 
                WsbHrAsString(hr), WsbPtrToLonglongAsString(pUsn));
    return(hr);
}


HRESULT
CFsaScanItem::DeletePlaceholder(
    IN LONGLONG /*offset*/,
    IN LONGLONG /*size*/
    )  

/*++

Implements:

  IFsaScanItem::DeletePlaceholder().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   path;
    HANDLE          handle = INVALID_HANDLE_VALUE;
    ULONG           DesiredAccess;
    IO_STATUS_BLOCK IoStatusBlock;
    PREPARSE_DATA_BUFFER    pReparseBuffer;
    UCHAR                   ReparseBuffer[sizeof(REPARSE_DATA_BUFFER) + sizeof(RP_DATA) + 10];
    NTSTATUS        ntStatus;
    FILE_BASIC_INFORMATION  basicInformation;

    WsbTraceIn(OLESTR("CFsaScanItem::DeletePlaceholder"), OLESTR(""));
    //
    // Remove the Reparse Point off the file
    //
    try {

        //
        // Create the real file name we need to open, under the covers this
        // allocates the buffer since the path pointer is null
        //
        WsbAffirmHr( GetFullPathAndName( OLESTR("\\\\?\\"), NULL, &path, 0));
        //WsbAffirmHr( GetFullPathAndName( NULL, NULL, &path, 0));

        // Make sure it is read/write
        WsbAffirmHr( MakeReadWrite() );
        //
        // Open the file to remove the placeholder information in the reparse point
        //
        DesiredAccess = FILE_READ_DATA | FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES ;
        WsbAffirmHr( OpenObject( path, 
                                 FILE_NON_DIRECTORY_FILE | FILE_NO_INTERMEDIATE_BUFFERING,
                                 DesiredAccess,
                                 EXCLUSIVE_FLAG,
                                 FILE_OPEN,
                                 &IoStatusBlock,
                                 &handle ) );

        //
        // The open worked, our handle should be valid but we check to be
        // safe and sure 
        //
        WsbAssertHandle( handle );
        
        //
        // Get the current attributes of the file and the times
        //
        WsbAssertNtStatus( NtQueryInformationFile( handle,
                                                    &IoStatusBlock,
                                                    (PVOID)&basicInformation,
                                                    sizeof( basicInformation ),
                                                    FileBasicInformation ) );
        
        //
        // Set the time flags so that when we close the handle the
        // time are not updated on the file and the FileAttributes 
        // indicate the file is offline
        //
        basicInformation.CreationTime.QuadPart = -1;
        basicInformation.LastAccessTime.QuadPart = -1;
        basicInformation.LastWriteTime.QuadPart = -1;
        basicInformation.ChangeTime.QuadPart = -1;
        basicInformation.FileAttributes &= ~BIT_FOR_TRUNCATED;
        basicInformation.FileAttributes |= FILE_ATTRIBUTE_NORMAL;  // Just in case result was zero (then no attributes would be set)

        WsbAssertNtStatus( NtSetInformationFile( handle,
                                                 &IoStatusBlock,
                                                 (PVOID)&basicInformation,
                                                 sizeof( basicInformation ),
                                                 FileBasicInformation ) );

        m_findData.dwFileAttributes &= ~BIT_FOR_TRUNCATED;
        m_originalAttributes &= ~BIT_FOR_TRUNCATED;
        
        //
        // Get the pointers setup correctly to this buffer because the 
        // type REPARSE_DATA_BUFFER actually doesn't have any space
        // allocated for the data and that is our own type, so get pointers
        // pointing into the real allocated space so we can use them
        //
        pReparseBuffer = (PREPARSE_DATA_BUFFER)ReparseBuffer;


        pReparseBuffer->ReparseTag        = IO_REPARSE_TAG_HSM ;
        pReparseBuffer->ReparseDataLength = 0 ;
        pReparseBuffer->Reserved          = 0 ;
        
        //
        // Do the work of deleting the Reparse Point
        //
        ntStatus = NtFsControlFile( handle,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &IoStatusBlock,
                                  FSCTL_DELETE_REPARSE_POINT,
                                  pReparseBuffer,
                                  FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer),
                                  NULL,
                                  0 );
        
        //
        // Check the return code - verify this is the correct way to check
        //
        WsbAssertNtStatus( ntStatus );
 
        //
        // Close the file since we are done with it and set the handle to invalid
        //
        WsbAssertNtStatus( NtClose( handle ) );
        handle =  INVALID_HANDLE_VALUE;

        
        //
        // Now that everything worked change the in memory flags for 
        // this scan item
        //
        m_findData.dwFileAttributes &= ~BIT_FOR_RP;
        m_gotPlaceholder = FALSE;

    } WsbCatch(hr);

    //
    // if we opened the file we need to close it
    //
    if( INVALID_HANDLE_VALUE != handle) {
        NtClose( handle );
    }
    
    WsbTraceOut(OLESTR("CFsaScanItem::DeletePlaceholder"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaScanItem::GetFromRPIndex(
    BOOL first
    )

/*

    Get file information from the Reparse Point Index

--*/
{
    HRESULT                 hr = S_OK;
    BOOLEAN                 bFirst;

    bFirst = (BOOLEAN)( first ? TRUE : FALSE );
    WsbTraceIn(OLESTR("CFsaScanItem::GetFromRPIndex"), OLESTR(""));

    try {
        HRESULT                        hrFindFileId;
        IO_STATUS_BLOCK                IoStatusBlock;
        IFsaScanItem *                 pScanItem;
        FILE_REPARSE_POINT_INFORMATION ReparsePointInfo;
        NTSTATUS                       Status;

        WsbAssert(0 != m_handleRPI, E_FAIL);

try_again:
        Status = NtQueryDirectoryFile(m_handleRPI,
                                   NULL,     //  Event 
                                   NULL,     //  ApcRoutine 
                                   NULL,     //  ApcContext 
                                   &IoStatusBlock,
                                   &ReparsePointInfo,
                                   sizeof(ReparsePointInfo),
                                   FileReparsePointInformation, 
                                   TRUE,     //  ReturnSingleEntry
                                   NULL,     //  FileName 
                                   bFirst );  //  RestartScan 
        if (Status != STATUS_SUCCESS) {
            WsbTrace(OLESTR("CFsaScanItem::GetFromRPIndex: CreateFileW failed, GetLastError = %ld\n"), 
                    GetLastError());
            WsbThrow(WSB_E_NOTFOUND);
        }

        //  Reset some items in case this isn't the first call to
        //  FindFileId
        if (INVALID_HANDLE_VALUE != m_handle) {
            FindClose(m_handle);
            m_handle = INVALID_HANDLE_VALUE;
        }
        if (TRUE == m_changedAttributes) {
            RestoreAttributes();
        }

        //  Find the file from the ID (not efficient or elegant, perhaps, but 
        //  the code is already there).
        pScanItem = this;
        hrFindFileId = m_pResource->FindFileId(ReparsePointInfo.FileReference,
                m_pSession, &pScanItem);

        //  If the FindFileId failed, we just skip that item and get the 
        //  next one.  This is to keep the scan from just stopping on this
        //  item.  FindFileId could fail because the file has been deleted
        //  already or the NT code could have a bug that prevents finding
        //  the file name from the ID when the ID ends with 0x5C.
        if (!SUCCEEDED(hrFindFileId)) {
            bFirst = FALSE;
            goto try_again;
        }
        WsbAffirmHr(pScanItem->Release());  // Get rid of extra ref. count

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaScanItem::GetFromRPIndex"), 
            OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaScanItem::CheckUsnJournalForChanges(
    LONGLONG StartUsn, 
    LONGLONG StopUsn,
    BOOL*    pChanged
)

/*

    Check the USN Journal for changes to the unnamed data stream for this
    file between the given USNs.

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::CheckUsnJournalForChanges"), OLESTR(""));

    *pChanged = FALSE;
    try {
        LONGLONG                fileId;
        CWsbStringPtr           volName;

        WsbAffirm(StartUsn <= StopUsn, E_UNEXPECTED);
        WsbAffirmHr(m_pResource->GetPath(&volName, 0));
        WsbAffirmHr(GetFileId(&fileId));
        WsbAffirmHr(WsbCheckUsnJournalForChanges(volName, fileId, StartUsn,
                StopUsn, pChanged));

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaScanItem::CheckUsnJournalForChanges"), 
            OLESTR("changed = %ls, hr = <%ls>"), WsbBoolAsString(*pChanged),
            WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaScanItem::FindFirstInRPIndex(
    IN IFsaResource* pResource,
    IN IHsmSession* pSession
    )

/*++

Implements:

  IFsaResource::FindFirstInRPIndex

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::FindFirstInRPIndex"), OLESTR(""));

    try {
        CWsbStringPtr     path;

        WsbAssert(0 != pResource, E_POINTER);

        // Store off some of the scan information.
        m_pResource = pResource;
        m_pSession = pSession;

        //  Generate the Reparse Point Index directory name for this volume
        WsbAffirmHr(pResource->GetPath(&path, 0));
        WsbAffirmHr(path.Prepend("\\\\?\\"));
        WsbAffirmHr(path.Append("$Extend\\$Reparse:$R:$INDEX_ALLOCATION"));

        WsbTrace(OLESTR("CFsaScanItem::FindFirstInRPIndex: path = <%ls>\n"),
            static_cast<WCHAR*>(path));

        //  Open the Reparse Point Index
        m_handleRPI = CreateFileW(static_cast<WCHAR*>(path),
                        GENERIC_READ,
                        FILE_SHARE_READ, 
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
                        NULL );
        if (INVALID_HANDLE_VALUE == m_handleRPI) {
            WsbTrace(OLESTR("CFsaScanItem::FindFirstInRPIndex: CreateFileW failed, GetLastError = %ld\n"), 
                    GetLastError());
            WsbThrow(WSB_E_NOTFOUND);
        }

        //  Get file information
        WsbAffirmHr(GetFromRPIndex(TRUE));

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaScanItem::FindFirstInRPIndex"), 
            OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaScanItem::FindFirstPlaceholder(
    IN OUT LONGLONG* pOffset,
    IN OUT LONGLONG* pSize,
    IN OUT FSA_PLACEHOLDER* pPlaceholder
    )
/*++

Implements:

  IFsaScanItem::FindFirstPlaceholder().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::FindFirstPlaceholder"), OLESTR(""));
    try {

        WsbAssert(0 != pOffset, E_POINTER);
        WsbAssert(0 != pSize, E_POINTER);
        WsbAssert(0 != pPlaceholder, E_POINTER);

        // Until these routines get rewritten, assume that the first placeholder is the one for the
        // who file that is returned by GetPlaceholder().
        *pOffset = 0;
        WsbAffirmHr(GetLogicalSize(pSize));

        // The code above assumes that a WSB_E_NOTFOUND error will be returned if there is no
        // reparse point.
        try {
            WsbAffirmHr(GetPlaceholder(*pOffset, *pSize, pPlaceholder));
        } WsbCatchAndDo(hr, if (E_UNEXPECTED == hr) {hr = WSB_E_NOTFOUND;});
        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::FindFirstPlaceholder"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaScanItem::FindNextInRPIndex(
    void
    )

/*++

Implements:

  IFsaResource::FindNextInRPIndex

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::FindNextInRPIndex"), OLESTR(""));

    try {

        WsbAssert(0 != m_handleRPI, E_FAIL);

        //  Get file information
        WsbAffirmHr(GetFromRPIndex(FALSE));

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaScanItem::FindNextInRPIndex"), 
            OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaScanItem::FindNextPlaceholder(
    IN OUT LONGLONG* pOffset,
    IN OUT LONGLONG* pSize,
    IN OUT FSA_PLACEHOLDER* pPlaceholder
    )
/*++

Implements:

  IFsaScanItem::FindNextPlaceholder().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::FindNext"), OLESTR(""));
    try {

        WsbAssert(0 != pOffset, E_POINTER);
        WsbAssert(0 != pSize, E_POINTER);
        WsbAssert(0 != pPlaceholder, E_POINTER);

        // Until these routines get rewritten, assume there is only one placeholder.
        hr = WSB_E_NOTFOUND;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::FindNextPlaceholder"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaScanItem::GetFileId(
    OUT LONGLONG* pFileId
    )

/*++

Implements:

  IFsaScanItem::GetFileId().

--*/
{
    HANDLE          handle = INVALID_HANDLE_VALUE;
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::GetFileId"), OLESTR(""));

    try {
        ULONG                     DesiredAccess;
        FILE_INTERNAL_INFORMATION iInfo;
        IO_STATUS_BLOCK           IoStatusBlock;
        CWsbStringPtr             path;

        WsbAssert(0 != pFileId, E_POINTER);

        //
        // Create the real file name we need to open, under the covers this
        // allocates the buffer since the path pointer is null
        //
        WsbAffirmHr( GetFullPathAndName( OLESTR("\\\\?\\"), NULL, &path, 0));
        //WsbAffirmHr( GetFullPathAndName( NULL, NULL, &path, 0));
        WsbTrace(OLESTR("CFsaScanItem::GetFileId, full Path = <%ls>\n"),
                    static_cast<WCHAR*>(path));

        //
        // Open the file
        //
        DesiredAccess = FILE_READ_ATTRIBUTES ;
        WsbAffirmHr( OpenObject( path, 
                                 FILE_NON_DIRECTORY_FILE,
                                 DesiredAccess,
                                 SHARE_FLAGS,
                                 FILE_OPEN,
                                 &IoStatusBlock,
                                 &handle ) );

        //
        // The open worked, our handle should be valid but we check to be
        // safe and sure 
        //
        WsbAssertHandle( handle );

        //  Get the internal information
        WsbAssertNtStatus( NtQueryInformationFile( handle,
                                                &IoStatusBlock,
                                                &iInfo,
                                                sizeof(FILE_INTERNAL_INFORMATION),
                                                FileInternalInformation ));

        //  Get the file id
        *pFileId = iInfo.IndexNumber.QuadPart;
 
        //
        // Close the file since we are done with it and set the handle to invalid
        //
        WsbAssertNtStatus( NtClose( handle ) );
        handle =  INVALID_HANDLE_VALUE;

    } WsbCatchAndDo(hr,
        WsbTrace(OLESTR("CFsaScanItem::GetFileId, GetLastError = %lx\n"),
            GetLastError());
    );

    //
    // if we opened the file we need to close it
    //
    if( INVALID_HANDLE_VALUE != handle) {
        NtClose( handle );
    }
    WsbTraceOut(OLESTR("CFsaScanItem::GetFileId"), OLESTR("Hr = <%ls>, FileId = %I64x"),
            WsbHrAsString(hr), *pFileId);

    return(hr);
}


HRESULT
CFsaScanItem::GetFileUsn(
    OUT LONGLONG* pFileUsn
    )

/*++

Routine Description:

    Get the current USN Journal number for this file.

Arguments:

    pFileUsn - Pointer to File USN to be returned.

Return Value:

    S_OK   - success

--*/
{
    HANDLE          handle = INVALID_HANDLE_VALUE;
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::GetFileUsn"), OLESTR(""));

    try {
        ULONG                     DesiredAccess;
        IO_STATUS_BLOCK           IoStatusBlock;
        CWsbStringPtr             path;

        WsbAssert(pFileUsn, E_POINTER);

        //
        // Create the real file name we need to open, under the covers this
        // allocates the buffer since the path pointer is null
        //
        WsbAffirmHr( GetFullPathAndName( OLESTR("\\\\?\\"), NULL, &path, 0));
        WsbTrace(OLESTR("CFsaScanItem::GetFileUsn, full Path = <%ls>\n"),
                    static_cast<WCHAR*>(path));

        //
        // Open the file
        //
        DesiredAccess = FILE_READ_ATTRIBUTES ;
        WsbAffirmHr( OpenObject( path, 
                                 FILE_NON_DIRECTORY_FILE | FILE_NO_INTERMEDIATE_BUFFERING,
                                 DesiredAccess,
                                 SHARE_FLAGS,
                                 FILE_OPEN,
                                 &IoStatusBlock,
                                 &handle ) );

        //
        // The open worked, our handle should be valid but we check to be
        // safe and sure 
        //
        WsbAssertHandle( handle );

        //  Get the internal information
        WsbAffirmHr(WsbGetUsnFromFileHandle(handle, FALSE, pFileUsn));
 
        //
        // Close the file since we are done with it and set the handle to invalid
        //
        WsbAssertNtStatus( NtClose( handle ) );
        handle =  INVALID_HANDLE_VALUE;

    } WsbCatchAndDo(hr,
        WsbTrace(OLESTR("CFsaScanItem::GetFileUsn, GetLastError = %lx\n"),
            GetLastError());
    );

    //
    // if we opened the file we need to close it
    //
    if( INVALID_HANDLE_VALUE != handle) {
        NtClose( handle );
    }
    WsbTraceOut(OLESTR("CFsaScanItem::GetFileUsn"), OLESTR("Hr = <%ls>, FileUsn = %I64d"),
            WsbHrAsString(hr), *pFileUsn);

    return(hr);
}


HRESULT
CFsaScanItem::GetPlaceholder(
    IN LONGLONG offset,
    IN LONGLONG size,
    OUT FSA_PLACEHOLDER* pPlaceholder
    )
/*++

Implements:

  IFsaScanItem::GetPlaceholder().

--*/
{
    WsbTraceIn(OLESTR("CFsaScanItem::GetPlaceholder"), OLESTR(""));
    HRESULT         hr = S_OK;

    //
    // If we already have the placeholder information just return it
    //
    try {

        //
        // Validate the file is managed. If it is the affirm will succeed.
        // If the file is not managed then we can only tell the caller the
        // problem.
        //
        WsbAffirmHr(hr = IsManaged(offset, size));
        
        //
        // Make sure the file is managed - will return S_OK
        //
        WsbAffirm( S_OK == hr, FSA_E_NOTMANAGED );
        
        //
        // Assert that the internal flag for the data is set, should
        // always be on if the hr was S_OK above
        //
        WsbAssert( m_gotPlaceholder, E_UNEXPECTED );
        
        //
        // Copy the data to the callers structure
        //
        *pPlaceholder = m_placeholder;
        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaScanItem::GetPlaceholder"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaScanItem::HasExtendedAttributes(
    void
    )

/*++

Implements:

  IFsaScanItem::HasExtendedAttributes().

--*/
{
    HRESULT                     hr = S_FALSE;
    HANDLE                      handle = INVALID_HANDLE_VALUE;
    CWsbStringPtr               path;
    ULONG                       desiredAccess;
    IO_STATUS_BLOCK             ioStatusBlock;
    FILE_EA_INFORMATION         eaInformation;
 
    try {

        // Create the real file name we need to open, under the covers this
        // allocates the buffer since the path pointer is null
        WsbAffirmHr(GetFullPathAndName(OLESTR("\\\\?\\"), NULL, &path, 0));
        //WsbAffirmHr(GetFullPathAndName(NULL, NULL, &path, 0));
    
        // Open the file to get the attributes
        desiredAccess = FILE_READ_ATTRIBUTES;
        WsbAffirmHr(OpenObject(path, FILE_NON_DIRECTORY_FILE | FILE_NO_INTERMEDIATE_BUFFERING, desiredAccess, SHARE_FLAGS,
                               FILE_OPEN, &ioStatusBlock, &handle));

        // The open worked, our handle should be valid but we check to be
        // safe and sure 
        WsbAssertHandle(handle);
    
        // Get the current attributes of the file.
        WsbAssertNtStatus(NtQueryInformationFile(handle, &ioStatusBlock, (VOID*) &eaInformation, sizeof(eaInformation ), FileEaInformation));
                                                    
        // Close the file since we are done with it and set the handle to invalid
        WsbAssertNtStatus(NtClose(handle));
        handle =  INVALID_HANDLE_VALUE;

        // Are there any EAs present?
        if (eaInformation.EaSize != 0) {
            hr = S_OK;
        }

    } WsbCatch(hr);
    
    // if we opened the file we need to close it
    if (INVALID_HANDLE_VALUE != handle) {
        NtClose(handle);
    }

    return(hr);
}


HRESULT
CFsaScanItem::IsALink(
    void
    )

/*++

Implements:

  IFsaScanItem::IsALink().

--*/
{
    HRESULT         hr = S_FALSE;
    LONGLONG        size;

    //
    // The file is a link if it is a reparse point and it is not our 
    // type. 
    //

    WsbAffirmHr(GetLogicalSize(&size));
    if (((m_findData.dwFileAttributes & BIT_FOR_RP) != 0) &&
        (!(IsManaged(0, size) == S_OK))) {

           hr = S_OK;
    } 

    return(hr);
}


HRESULT
CFsaScanItem::IsManaged(
    IN LONGLONG /*offset*/,
    IN LONGLONG /*size*/
    )

/*++

Implements:

  IFsaScanItem::IsManaged().

--*/
{
    HRESULT         hr = S_FALSE;
    CWsbStringPtr   path;
    HANDLE          handle = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK IoStatusBlock;
    UCHAR           ReparseBuffer[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];
    NTSTATUS        ntStatus;
    ULONG           DesiredAccess;
    BOOL            actualOfflineStatus = FALSE;
    BOOL            readReparseData = FALSE;      // Used to know if we got an error reading the reparse data
    BOOL            changeOfflineStatus = FALSE;
    FILE_BASIC_INFORMATION basicInformation;
    CWsbStringPtr           volName;
    HRESULT         saveHr;


    WsbTraceIn(OLESTR("CFsaScanItem::IsManaged"), OLESTR(""));
    //
    // If the file has a reparse point then we need to get the information
    // so we can tell if it is our type. Whether it is premigrated or
    // truncate is not for this function to care, if it is either then
    // the return is S_OK.
    //
    
    //
    // If we already know we manage this file and have the placeholder
    // information then tell caller
    //
    if ( m_gotPlaceholder) {
        hr = S_OK;
        actualOfflineStatus = m_placeholder.isTruncated;
        readReparseData = TRUE;

    //
    // We don't know the answer so lets first check the reparse point bit.
    // If it is not set then this is not managed by us
    //
    } else if ( (m_findData.dwFileAttributes & BIT_FOR_RP) == 0) {
        hr = S_FALSE;
        actualOfflineStatus = FALSE;
        readReparseData = TRUE;  
        
    //
    // So we know it has a reparse point but do not know what kind so 
    // lets get the data and fill in our global if we need
    //
    } else {
        
        try {
            //
            // If the reparse point is not our type we get out now.  This avoids a problem with SIS keeping 
            // the backing file open when one of their link files is open.  Once we open the link file the backing file is 
            // opened by their filter and held open.  If we attempt to migrate it later we get an error because it is open exclusive.
            // This bit of code prevents us from being the one to trigger this condition - there is nothing we can do if some other
            // process caused it to happen.
            //

            if (m_findData.dwReserved0 != IO_REPARSE_TAG_HSM) {
                readReparseData = TRUE;
                WsbThrow(S_FALSE);
            }

            //
            // Create the real file name we need to open, under the 
            // covers this allocates the buffer since the path pointer 
            // is null
            //
            WsbAffirmHr( GetFullPathAndName( OLESTR("\\\\?\\"), NULL, &path, 0));
            //WsbAffirmHr( GetFullPathAndName( NULL, NULL, &path, 0));
        
            //
            // Open the file to read the placeholder information in the reparse point
            //
            //DesiredAccess = FILE_READ_DATA | FILE_READ_ATTRIBUTES ;
            DesiredAccess = FILE_READ_ATTRIBUTES ;
            
            WsbAffirmHr( OpenObject( path, 
                                    FILE_NON_DIRECTORY_FILE | FILE_NO_INTERMEDIATE_BUFFERING,
                                    DesiredAccess,
                                    SHARE_FLAGS,
                                    FILE_OPEN,
                                    &IoStatusBlock,
                                    &handle ) );

            //
            // The open worked, our handle should be valid but we check to be
            // safe and sure 
            //
            WsbAssertHandle( handle );
        
            //
            // Read the placeholder information
            //
            ntStatus = NtFsControlFile( handle,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_GET_REPARSE_POINT,
                                    NULL,
                                    0,
                                    &ReparseBuffer,
                                    sizeof( ReparseBuffer ) );


            //
            // Verify that the get really worked. NOTE: If the reparse
            // point is not there, it could be that it has been deleted since
            // we last got the bits. We should just indicate that the file
            // is not managed.
            //
            if (STATUS_NOT_A_REPARSE_POINT == ntStatus) {
                readReparseData = TRUE;
                WsbThrow(S_FALSE);
            }
            WsbAssertNtStatus( ntStatus );
 
            //
            // Close the file since we are done with it
            //
            WsbAssertNtStatus( NtClose( handle ) );
            handle =  INVALID_HANDLE_VALUE;
        
            readReparseData = TRUE;

            //
            // Get the pointers setup correctly to this buffer because the 
            // type REPARSE_DATA_BUFFER actually doesn't have any space
            // allocated for the data and that is our own type, so get pointers
            // pointing into the real allocated space so we can use them
            //
            WsbAffirmHrOk( CopyRPToPlaceholder( (PREPARSE_DATA_BUFFER)ReparseBuffer, &m_placeholder ) );

            actualOfflineStatus = m_placeholder.isTruncated;

            //
            // Set flag indicating placeholder found and information in memory
            //
            m_gotPlaceholder = TRUE;
            hr = S_OK;


        } WsbCatch(hr);

        //
        // if we opened the file we need to close it
        //
        if( INVALID_HANDLE_VALUE != handle) {
            NtClose( handle );
        }
    }

    saveHr = hr;

    // Check the actual offline status against the offline bit and fix it if necessary.
    if (readReparseData) {   // If there was no error getting the reparse data

       WsbTrace(OLESTR("CFsaScanItem::IsManaged: Checking offline status %x - actual = %x\n"),
                    m_findData.dwFileAttributes & BIT_FOR_TRUNCATED, actualOfflineStatus );

       switch (actualOfflineStatus) {
           case TRUE:
              if (!(m_findData.dwFileAttributes & BIT_FOR_TRUNCATED)) {
                  // Offline bit is not set and should be - set it.
                  m_findData.dwFileAttributes |= BIT_FOR_TRUNCATED;
                  m_originalAttributes |= BIT_FOR_TRUNCATED;    // Just in case we have changed to read/write;
                  changeOfflineStatus = TRUE;
              } 
              break;
           case FALSE:
              if (m_findData.dwFileAttributes & BIT_FOR_TRUNCATED) {
                  // Offline bit is set and should not be - clear it.
                  m_findData.dwFileAttributes &= ~BIT_FOR_TRUNCATED;
                  m_originalAttributes &= ~BIT_FOR_TRUNCATED;    // Just in case we have changed to read/write;
                  changeOfflineStatus = TRUE;
              } 
              break;
       }

       if (changeOfflineStatus) {
          // Set the new attribute 
          WsbTrace(OLESTR("CFsaScanItem::IsManaged: Changing offline status %x - actual = %x\n"),
                    m_findData.dwFileAttributes & BIT_FOR_TRUNCATED, actualOfflineStatus );
   
          try {
              //
              // Create the real file name we need to open, under the 
              // covers this allocates the buffer since the path pointer 
              // is null
              //
              WsbAffirmHr( GetFullPathAndName( OLESTR("\\\\?\\"), NULL, &path, 0));
          
              //
              // Open the file to set attributes
              //
              DesiredAccess = FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES;
              
              WsbAffirmHr( OpenObject( path, 
                                      FILE_NON_DIRECTORY_FILE | FILE_NO_INTERMEDIATE_BUFFERING,
                                      DesiredAccess,
                                      SHARE_FLAGS,
                                      FILE_OPEN,
                                      &IoStatusBlock,
                                      &handle ) );
    
              //
              // The open worked, our handle should be valid but we check to be
              // safe and sure 
              //
              WsbAssertHandle( handle );
          
              WsbAffirmHr(m_pResource->GetPath(&volName, 0));
              WsbAffirmHr(WsbMarkUsnSource(handle, volName));
   
              // Set the time flags so that when we close the handle the
              // time are not updated on the file and the FileAttributes 
              basicInformation.CreationTime.QuadPart = -1;
              basicInformation.LastAccessTime.QuadPart = -1;
              basicInformation.LastWriteTime.QuadPart = -1;
              basicInformation.ChangeTime.QuadPart = -1;
              basicInformation.FileAttributes = m_findData.dwFileAttributes;
              
              WsbAffirmNtStatus(NtSetInformationFile(handle, &IoStatusBlock, (PVOID)&basicInformation, sizeof(basicInformation), FileBasicInformation));

              //
              // Close the file since we are done with it
              //
              WsbAssertNtStatus( NtClose( handle ) );
              handle =  INVALID_HANDLE_VALUE;
    
    
          } WsbCatch(hr);
    
          //
          // if we opened the file we need to close it
          //
          if( INVALID_HANDLE_VALUE != handle) {
              NtClose( handle );
          }
       }
    }

    hr = saveHr;
    WsbTraceOut(OLESTR("CFsaScanItem::IsManaged"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaScanItem::IsPremigrated(
    IN LONGLONG offset,
    IN LONGLONG size
    )

/*++

Implements:

  IFsaScanItem::IsPremigrated().

--*/
{
    HRESULT         hr = S_FALSE;
    HRESULT         hrTest = S_FALSE;

    WsbTraceIn(OLESTR("CFsaScanItem::IsPremigrated"), OLESTR(""));
    // We really need to look at the placeholder information to figure
    // this out (is offline, and is out type of HSM.

    //
    // If the file is NOT truncated AND is a reparse point and is a 
    // managed one then the file is a premigrated file
    //
//  if ( !(m_findData.dwFileAttributes & BIT_FOR_TRUNCATED) && 
//         m_findData.dwFileAttributes & BIT_FOR_RP         &&
//         IsManaged() == S_OK) {

    try  {
        
        if ( m_findData.dwFileAttributes & BIT_FOR_RP )  {
            WsbAffirmHr(hrTest = IsManaged(offset, size));
            if ((S_OK == hrTest) &&
                ( !m_placeholder.isTruncated )) {
                hr = S_OK;
            }
        }

    } WsbCatch (hr);

    WsbTraceOut(OLESTR("CFsaScanItem::IsPremigrated"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaScanItem::IsTruncated(
    IN LONGLONG offset,
    IN LONGLONG size
    )

/*++

Implements:

  IFsaScanItem::IsTruncated().

--*/
{
    HRESULT         hr = S_FALSE;
    HRESULT         hrTest = S_FALSE;

    WsbTraceIn(OLESTR("CFsaScanItem::IsTruncated"), OLESTR(""));
    // 
    // If the bit is on that indicates we have truncated the file AND
    // the file is a reparse point AND the reparse point is one of
    // our types (i.e. it really is our information stuffed away in
    // there the it really is a truncated file
    //
//  if ( // ???? m_findData.dwFileAttributes & BIT_FOR_TRUNCATED && 
//         m_findData.dwFileAttributes & BIT_FOR_RP        &&
//         IsManaged() == S_OK && RP_FILE_IS_TRUNCATED( m_placeholder.bitFlags ) ) {
    try  {
        
        if ( m_findData.dwFileAttributes & BIT_FOR_RP )  {
            WsbAffirmHr(hrTest = IsManaged(offset, size));
            if ((S_OK == hrTest) &&
                ( m_placeholder.isTruncated )) {
                hr = S_OK;
            }
        }

    } WsbCatch (hr);

    WsbTraceOut(OLESTR("CFsaScanItem::IsTruncated"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaScanItem::GetVersionId(
    LONGLONG *fileVersionId
    )  

/*++

Implements:

  IFsaScanItem::GetVersionId().

--*/
{
    HRESULT         hr = E_FAIL;
    HANDLE          handle = INVALID_HANDLE_VALUE;
    CWsbStringPtr   path;
    ULONG           DesiredAccess;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION       basicInformation;
 
    try {
        //
        // Create the real file name we need to open, under the covers this
        // allocates the buffer since the path pointer is null
        //
        WsbAffirmHr( GetFullPathAndName(  OLESTR("\\\\?\\"), NULL, &path, 0));
        //WsbAffirmHr( GetFullPathAndName(  NULL, NULL, &path, 0));
    
        //
        // Open the file to get the attributes
        //
        DesiredAccess = FILE_READ_ATTRIBUTES ;
        WsbAffirmHr( OpenObject( path, 
                                FILE_NON_DIRECTORY_FILE | FILE_NO_INTERMEDIATE_BUFFERING,
                                DesiredAccess,
                                SHARE_FLAGS,
                                FILE_OPEN,
                                &IoStatusBlock,
                                &handle ) );
        //
        // The open worked, our handle should be valid but we check to be
        // safe and sure 
        //
        WsbAssertHandle( handle );
    
        //
        // Get the current attributes of the file and the times
        //
        WsbAssertNtStatus( NtQueryInformationFile( handle,
                                                    &IoStatusBlock,
                                                    (PVOID)&basicInformation,
                                                    sizeof( basicInformation ),
                                                    FileBasicInformation ) );
                                                    
        //
        // Close the file since we are done with it and set the handle to invalid
        //
        WsbAssertNtStatus( NtClose( handle ) );
        handle =  INVALID_HANDLE_VALUE;

        *fileVersionId = basicInformation.LastWriteTime.QuadPart;
        hr = S_OK;
    } WsbCatch( hr );
    
    //
    // if we opened the file we need to close it
    //
    if( INVALID_HANDLE_VALUE != handle) {
        NtClose( handle );
    }

    return( hr );
}


HRESULT
CFsaScanItem::MakeReadWrite(
    )  

/*++

Routine Description:

    Make the file attributes read/write if they aren't already.

Arguments:

    pUsn - Pointer to File USN to check (if != 0) and to be returned after the change.

Return Value:

    S_OK   - success

--*/
{
    HRESULT                 hr = S_OK;
    CWsbStringPtr           path;
    IO_STATUS_BLOCK         IoStatusBlock;
    HANDLE                  handle = INVALID_HANDLE_VALUE;
    FILE_BASIC_INFORMATION  basicInformation;
 
    if (S_OK == IsReadOnly()) {
    
        try {
        
            // NOTE: MakeReadOnly(), IsReadOnly(), and RestoreAttributes() seem like dangerous implementations, since
            // the used cached information and reset all the attirbutes. It is also assuming that the
            // application wants the file reset to read only after FindNext() or the destructor. This
            // may not be true for a general purpose application. Unfortunately, it seems to risky to
            // try to change this implementation now.
        
            // Create the real file name we need to open, under the covers this
            // allocates the buffer since the path pointer is null
            WsbAffirmHr(GetFullPathAndName(OLESTR("\\\\?\\"), NULL, &path, 0));
            
            // Open the file.   
            WsbAffirmHr(OpenObject(path, FILE_NON_DIRECTORY_FILE, FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES, EXCLUSIVE_FLAG, FILE_OPEN, &IoStatusBlock, &handle));

            // The open worked, our handle should be valid but we check to be
            // safe and sure 
            WsbAffirmHandle(handle);
        
            // Get the current attributes of the file and the times
            WsbAffirmNtStatus(NtQueryInformationFile(handle, &IoStatusBlock, (PVOID)&basicInformation, sizeof(basicInformation), FileBasicInformation));
        
            // Make sure it is still read only.
            if ((basicInformation.FileAttributes & FILE_ATTRIBUTE_READONLY) != 0) {
            
                m_originalAttributes = basicInformation.FileAttributes;
                
                // Set the time flags so that when we close the handle the
                // time are not updated on the file and the FileAttributes 
                basicInformation.CreationTime.QuadPart = -1;
                basicInformation.LastAccessTime.QuadPart = -1;
                basicInformation.LastWriteTime.QuadPart = -1;
                basicInformation.ChangeTime.QuadPart = -1;
                basicInformation.FileAttributes &= ~FILE_ATTRIBUTE_READONLY;
                basicInformation.FileAttributes |= FILE_ATTRIBUTE_NORMAL;  // Just in case result was zero (then no attributes would be set)
                
                WsbAffirmNtStatus(NtSetInformationFile(handle, &IoStatusBlock, (PVOID)&basicInformation, sizeof(basicInformation), FileBasicInformation));
                
                m_changedAttributes = TRUE;
            }
            
            // Close the file
            NtClose(handle);
            handle = INVALID_HANDLE_VALUE;
            
        } WsbCatch(hr);

    
        // Close the file for sure
        if (INVALID_HANDLE_VALUE != handle) {
            NtClose(handle);
        }
    }   
    
    return(hr);
}



HRESULT
CFsaScanItem::PrepareForManage(
    IN LONGLONG offset,
    IN LONGLONG size
    )  

/*++

Implements:

  IFsaScanItem::PrepareForManage().

--*/
{
    UNREFERENCED_PARAMETER(offset);
    UNREFERENCED_PARAMETER(size);
    
    return S_OK;
}



HRESULT
CFsaScanItem::RestoreAttributes(
    )  

/*++

Implements:

  IFsaScanItem::RestoreAttributes

--*/
{
    HRESULT                 hr = E_FAIL;
    CWsbStringPtr           path;
    IO_STATUS_BLOCK         IoStatusBlock;
    HANDLE                  handle = INVALID_HANDLE_VALUE;
    FILE_BASIC_INFORMATION  basicInformation;
 
    try {
    
        // NOTE: MakeReadOnly(), IsReadOnly(), and RestoreAttributes() seem like dangerous implementations, since
        // the used cached information and reset all the attirbutes. It is also assuming that the
        // application wants the file reset to read only after FindNext() or the destructor. This
        // may not be true for a general purpose application. Unfortunately, it seems to risky to
        // try to change this implementation now.
        
    
        // Create the real file name we need to open, under the covers this
        // allocates the buffer since the path pointer is null
        WsbTrace(OLESTR("CFsaScanItem::RestoreAttributes - Restoring attributes to %x"), m_originalAttributes);
        WsbAffirmHr(GetFullPathAndName(  OLESTR("\\\\?\\"), NULL, &path, 0));
        
        
        // Open the file.   
        WsbAffirmHr(OpenObject(path, FILE_NON_DIRECTORY_FILE, FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES, EXCLUSIVE_FLAG, FILE_OPEN, &IoStatusBlock, &handle));

        // The open worked, our handle should be valid but we check to be
        // safe and sure 
        WsbAffirmHandle(handle);
    
        // Get the current attributes of the file and the times
        WsbAffirmNtStatus(NtQueryInformationFile(handle, &IoStatusBlock, (PVOID)&basicInformation, sizeof(basicInformation), FileBasicInformation));
    
        // Set the time flags so that when we close the handle the
        // time are not updated on the file and the FileAttributes 
        basicInformation.CreationTime.QuadPart = -1;
        basicInformation.LastAccessTime.QuadPart = -1;
        basicInformation.LastWriteTime.QuadPart = -1;
        basicInformation.ChangeTime.QuadPart = -1;
        basicInformation.FileAttributes = m_originalAttributes;
        
        WsbAffirmNtStatus(NtSetInformationFile(handle, &IoStatusBlock, (PVOID)&basicInformation, sizeof(basicInformation), FileBasicInformation));
            
        
        // Close the file
        NtClose(handle);
        handle = INVALID_HANDLE_VALUE;
        
        m_changedAttributes = FALSE;
                
    } WsbCatch(hr);
    
    // Close the file for sure
    if (INVALID_HANDLE_VALUE != handle) {
        NtClose(handle);
    }
        
    return(hr);
}


HRESULT
CFsaScanItem::Truncate(
    IN LONGLONG offset,
    IN LONGLONG size
    )  

/*++

Implements:

  IFsaScanItem::Truncate().

--*/
{
    HRESULT         hr = S_OK;
    BOOL            fileIsTruncated = FALSE;
    LONGLONG        usn = 0;

    WsbTraceIn(OLESTR("CFsaScanItem::Truncate"), OLESTR(""));
    try {

        // call the engine
        if (IsManaged(offset, size) == S_OK) {
            WsbAffirmHr(m_pResource->ValidateForTruncate((IFsaScanItem*) this, offset, size, usn));
        }    

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaScanItem::Truncate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaScanItem::TruncateValidated(
    IN LONGLONG offset,
    IN LONGLONG size
    )  

/*++

Implements:

  IFsaScanItem::TruncateValidated().

--*/
{
    HRESULT         hr = S_OK;
    HRESULT         truncateHr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanItem::TruncateValidated"), OLESTR(""));
    try {
        IFsaScanItem* pMe = this;

        truncateHr = TruncateInternal(offset, size);

        //
        // Note: Must check for S_OK since TruncateInternal may return FSA_E_ITEMCHANGED or FSA_E_ITEMINUSE
        // Both are "Success hr", but imply no truncation was done
        //
        if (S_OK == truncateHr) {
            WsbAffirmHr(m_pResource->RemovePremigrated(pMe, offset, size));
            WsbAffirmHr(m_pResource->AddTruncated(pMe, offset, size));
        }
    } WsbCatch(hr);

    // The important hr to return to the caller is the actual result of the truncation
    hr = truncateHr;
    
    WsbTraceOut(OLESTR("CFsaScanItem::TruncateValidated"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}




HRESULT
CFsaScanItem::TruncateInternal(
    IN LONGLONG offset,
    IN LONGLONG size
    )  

/*++

Implements:

  IFsaScanItem::TruncateInternal().

--*/
{
    HRESULT         hr = E_FAIL;
    CWsbStringPtr   path;
    ULONG           DesiredAccess;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS        ntStatus;
    FILE_END_OF_FILE_INFORMATION sizeInformation;
    FILE_BASIC_INFORMATION       basicInformation;
    PREPARSE_DATA_BUFFER    pReparseBuffer;
    UCHAR                   ReparseBuffer[sizeof(REPARSE_DATA_BUFFER) + sizeof(RP_DATA) + 10];
    CWsbStringPtr           fileName;
    CWsbStringPtr           jobName;
    LONGLONG                fileVersionId;
    ULONG                   i = 0;
    CWsbStringPtr           volName;


    WsbTraceIn(OLESTR("CFsaScanItem::TruncateInternal"), OLESTR(""));

// Putting these statistics in the registry is probably not the best
// place for them, but it's the easiest solution for now
#define TEMPORARY_TRUNCATE_STATISTICS 1
#if defined(TEMPORARY_TRUNCATE_STATISTICS)
    //  Try to increment the truncate-attempt count in the registry
    WsbIncRegistryValueDWORD(NULL, FSA_REGISTRY_PARMS,
            OLESTR("TruncateCalls"));
#endif
    
    // Get strings for tracing and error logging (ignore errors?!)
    GetFullPathAndName( 0, 0, &fileName, 0);
    m_pSession->GetName(&jobName, 0);

    m_handleVerify = INVALID_HANDLE_VALUE;
    
    try {
        LONGLONG    fileUsn1 = 0, fileUsn2 = 0;
        
        // If the file is not migrated, then we can't truncate it
        if (S_OK != IsPremigrated(offset, size)) {
            if (S_OK != IsManaged(offset, size)) {
                hr = FSA_E_NOTMANAGED;
                WsbLogEvent(FSA_MESSAGE_TRUNCSKIPPED_ISNOTMANAGED, 0, NULL,  
                        (OLECHAR*) jobName, WsbAbbreviatePath(fileName, 120), 
                        WsbHrAsString(hr), NULL);
                WsbThrow(hr);
            } else {
                //
                // Do not bother to log an event here as this should only 
                // happen if someone uses rstest or some other program 
                // to truncate a file that is already truncated.
                WsbThrow(FSA_E_FILE_ALREADY_MANAGED);
            }
        }

        WsbAssert( m_gotPlaceholder, E_UNEXPECTED );
        
        //
        // Setup the reparse point data with that which was on the file
        // with the bit in the data indicating it is truncated
        //
        pReparseBuffer = (PREPARSE_DATA_BUFFER)ReparseBuffer;
        WsbAffirmHr( CopyPlaceholderToRP( &m_placeholder, pReparseBuffer, TRUE ) );

        //
        // Create the real file name we need to open, under the covers this
        // allocates the buffer since the path pointer is null
        //
        WsbAffirmHr( GetFullPathAndName(  OLESTR("\\\\?\\"), NULL, &path, 0));

        //
        // Open the file exclusively for read-only so we can get the usn before and  after
        // making the file R/W, without letting anybody to make a "real" change in the middle
        //
        DesiredAccess = FILE_READ_DATA | FILE_READ_ATTRIBUTES;
        WsbAffirmHr( OpenObject( path, 
                                FILE_NON_DIRECTORY_FILE,
                                DesiredAccess,
                                EXCLUSIVE_FLAG,
                                FILE_OPEN,
                                &IoStatusBlock,
                                &m_handleVerify ) );

        WsbAssertHandle( m_handleVerify );

        //
        // Get usn before making R/W
        // This usn is used to compare with the usn which we kept in the premigrated list.
        // MakeReadWrite may chnage the usn so we need to get it before 
        //
        if (S_OK != WsbGetUsnFromFileHandle(m_handleVerify, FALSE, &fileUsn1))  {
            fileUsn1 = 0;
        }

        // Make sure it is read/write
        WsbAffirmHr( MakeReadWrite() );

        //
        // Get usn after making R/W
        // This usn will be use to compare with the usn of the file after we'll open it for R/W. We need
        // this comparison in order to ensure that nobody changed the file before we opened it again for R/W.
        //
        if (S_OK != WsbGetUsnFromFileHandle(m_handleVerify, TRUE, &fileUsn2))  {
            fileUsn2 = 0;
        }

        // Close the file
        NtClose( m_handleVerify );
        m_handleVerify = INVALID_HANDLE_VALUE;

        //
        // Open the file (for R/W)
        //
        DesiredAccess = FILE_READ_DATA | FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES ;
        WsbAffirmHr( OpenObject( path, 
                                FILE_NON_DIRECTORY_FILE | FILE_WRITE_THROUGH,
                                DesiredAccess,
                                EXCLUSIVE_FLAG,
                                FILE_OPEN,
                                &IoStatusBlock,
                                &m_handleVerify ) );

        //
        // The open worked, our handle should be valid but we check to be
        // safe and sure 
        //
        WsbAssertHandle( m_handleVerify );

        //
        // Tell the USN journal that we are the source of the changes.
        //
        WsbAffirmHr(m_pResource->GetPath(&volName, 0));
        WsbAffirmHr(WsbMarkUsnSource(m_handleVerify, volName));

        //
        // Get the current attributes of the file and the times
        //
        WsbAffirmNtStatus( NtQueryInformationFile( m_handleVerify,
                                                   &IoStatusBlock,
                                                   (PVOID)&basicInformation,
                                                   sizeof( basicInformation ),
                                                   FileBasicInformation ) );
        
        fileVersionId = basicInformation.LastWriteTime.QuadPart;

        //
        // Set the time flags so that when we close the handle the
        // times are not updated on the file and the FileAttributes 
        // indicate the file is offline
        //
        basicInformation.CreationTime.QuadPart = -1;
        basicInformation.LastAccessTime.QuadPart = -1;
        basicInformation.LastWriteTime.QuadPart = -1;
        basicInformation.ChangeTime.QuadPart = -1;
        basicInformation.FileAttributes = 0;   // Do not change attributes yet
        WsbAffirmNtStatus( NtSetInformationFile( m_handleVerify,
                                                 &IoStatusBlock,
                                                 (PVOID)&basicInformation,
                                                 sizeof( basicInformation ),
                                                 FileBasicInformation ) );

        //
        // Do the check to see if the file changed
        //
        hr = VerifyInternal(offset, size, fileUsn1, fileUsn2);

        //
        // Note: Must check for S_OK since VerifyInternal may return FSA_E_ITEMCHANGED or FSA_E_ITEMINUSE
        //       Both are "Success hr", but should cause no truncation !!
        //
        if (S_OK != hr) {
            WsbThrow(hr);
        }

        //
        // Change the in memory flags for this scan item
        //
        m_findData.dwFileAttributes |= BIT_FOR_TRUNCATED;
        
        //
        // Rewrite the reparse point with the new flag
        //
        ntStatus = NtFsControlFile( m_handleVerify,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_SET_REPARSE_POINT,
                                pReparseBuffer,
                                FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer)
                                    + pReparseBuffer->ReparseDataLength,
                                NULL,
                                0 );
    
        //
        // Check the return code
        //
        WsbAffirmNtStatus( ntStatus );

        //
        // It really happened so we need to flip the in memory copy of the
        // isTruncated flag so it reflects reality
        //
        m_placeholder.isTruncated = TRUE;
        
        //
        // Set the file size to zero to truncate the file
        sizeInformation.EndOfFile.QuadPart  = 0 ;
        WsbAffirmNtStatus( NtSetInformationFile( m_handleVerify, 
                              &IoStatusBlock, 
                              &sizeInformation,
                              sizeof( sizeInformation ),
                              FileEndOfFileInformation ) );

        //
        // Set the logical file size to the original size
        sizeInformation.EndOfFile.QuadPart  = m_placeholder.dataStreamSize;
        WsbAffirmNtStatus( NtSetInformationFile( m_handleVerify, 
                              &IoStatusBlock, 
                              &sizeInformation,
                              sizeof( sizeInformation ),
                              FileEndOfFileInformation ) );

        //
        // Now that the truncation is complete we set the OFFLINE attribute.  
        //
        basicInformation.CreationTime.QuadPart = -1;        // Make sure we do nothing with dates
        basicInformation.LastAccessTime.QuadPart = -1;
        basicInformation.LastWriteTime.QuadPart = -1;
        basicInformation.ChangeTime.QuadPart = -1;
        basicInformation.FileAttributes = m_findData.dwFileAttributes;
        WsbAffirmNtStatus(NtSetInformationFile( m_handleVerify,
                                                 &IoStatusBlock,
                                                 (PVOID)&basicInformation,
                                                 sizeof( basicInformation ),
                                                 FileBasicInformation ));

        // Since we have restored the original attributes we can reset the flag that was possibly set by MakeReadWrite
        m_changedAttributes = FALSE;
        

        hr = S_OK;
    } WsbCatch(hr);

    //
    // if we opened the file we need to close it
    //
    if( INVALID_HANDLE_VALUE != m_handleVerify) {
        NtClose( m_handleVerify );
        m_handleVerify = INVALID_HANDLE_VALUE;
    }

    // If the file data had changed (so we didn't truncate it) log event and 
    // remove placeholder info
    if (FSA_E_ITEMCHANGED == hr) {
        WsbLogEvent(FSA_MESSAGE_TRUNCSKIPPED_ISCHANGED, 0, NULL, 
                (OLECHAR*) jobName, WsbAbbreviatePath(fileName, 80), 
                WsbHrAsString(hr), NULL);
        
        DeletePlaceholder(offset, size);  
    }

    
    WsbTraceOut(OLESTR("CFsaScanItem::TruncateInternal"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}



HRESULT
CFsaScanItem::Verify(
    IN LONGLONG offset,
    IN LONGLONG size
    )  

/*++

Implements:

  IFsaScanItem::Verify().


--*/
{
    HRESULT         hr = E_FAIL;
    CWsbStringPtr   path;
    ULONG           DesiredAccess;
    IO_STATUS_BLOCK IoStatusBlock;


    WsbTraceIn(OLESTR("CFsaScanItem::Verify"), OLESTR(""));

    m_handleVerify = INVALID_HANDLE_VALUE;
    
    try {
        WsbAssert( m_gotPlaceholder, E_UNEXPECTED );
        
        //
        // Create the real file name we need to open, under the covers this
        // allocates the buffer since the path pointer is null
        //
        WsbAffirmHr( GetFullPathAndName(  OLESTR("\\\\?\\"), NULL, &path, 0));
    
        //
        // Open the file
        //
        DesiredAccess = FILE_READ_DATA | FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES ;
        WsbAffirmHr( OpenObject( path, 
                                FILE_NON_DIRECTORY_FILE | FILE_WRITE_THROUGH,
                                DesiredAccess,
                                EXCLUSIVE_FLAG,
                                FILE_OPEN,
                                &IoStatusBlock,
                                &m_handleVerify ) );

        //
        // The open worked, our handle should be valid but we check to be
        // safe and sure 
        //
        WsbAssertHandle( m_handleVerify );
    
        //
        // Do the check to see if the file changed
        // Note that it throws rather than affirms because FSA_E_ITEMCHANGED is a success 
        WsbThrow(VerifyInternal(offset, size, 0, 0));

    } WsbCatch(hr);

    //
    // if we opened the file we need to close it
    //
    if( INVALID_HANDLE_VALUE != m_handleVerify) {
        NtClose( m_handleVerify );
        m_handleVerify = INVALID_HANDLE_VALUE;
    }

    
    WsbTraceOut(OLESTR("CFsaScanItem::Verify"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}



HRESULT
CFsaScanItem::VerifyInternal(
    IN LONGLONG offset,
    IN LONGLONG size,
    IN LONGLONG compareUsn1,
    IN LONGLONG compareUsn2
    )  

/*++

Implements:

  IFsaScanItem::VerifyInternal().


   Note:  This requires that m_handleVerify is set up with a handle to the file being verified.

--*/
{
    HRESULT         hr = E_FAIL;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION       basicInformation;
    CWsbStringPtr           fileName;
    CWsbStringPtr           jobName;
    LONGLONG                fileVersionId;
    ULONG                   i = 0;
    CWsbStringPtr           volName;
    LONGLONG                realFileSize;
    RP_MSG                  in, out;
    DWORD                   outSize;


    WsbTraceIn(OLESTR("CFsaScanItem::VerifyInternal"), OLESTR(""));

    // Get strings for tracing and error logging (ignore errors?!)
    GetFullPathAndName( 0, 0, &fileName, 0);
    m_pSession->GetName(&jobName, 0);
    
    try {
        BOOL     DoCRC = FALSE;
        BOOL     DoUsnCheck = FALSE;
        LONGLONG premigListUsn;
        LONGLONG fileUsn;
        


        WsbAffirmHr(GetLogicalSize(&realFileSize));
        //
        // Currently, avoid offset and size verification:
        // - Since we are not doing partial file migration, offset is always 0.
        // - Size in Validate would always be the same since it is taken from GetLogicalSize as well.
        // - Size in case of auto-truncation is not reliable since it is taken from the premigrated db,
        //   where there could be bogus records from previous migrations of the file
        //
/***        if ( (realFileSize != size) || (offset != 0) ) {
            WsbThrow(FSA_E_ITEMCHANGED);
        }   ***/
        
        //
        WsbAssertHandle( m_handleVerify );
    
        //
        // Get the USN from the premigration list and the USN from the file.
        // We need to get the USN from the file now, before any NtSetInformationFile
        // is called because this changes the USN value.
        // If we have trouble getting the USN, just set them
        // to 0 and go on, we check for 0 as a special case.
        //
        if (S_OK != GetPremigratedUsn(&premigListUsn))  {
            premigListUsn = 0;
        }
        if (S_OK != WsbGetUsnFromFileHandle(m_handleVerify, FALSE, &fileUsn))  {
            fileUsn = 0;
        }
        
        WsbTrace(OLESTR("CFsaScanItem::VerifyInternal: premig USN <%I64d>, file USN <%I64d>\n"),
                    premigListUsn, fileUsn );
        WsbTrace(OLESTR("CFsaScanItem::VerifyInternal: Compare1 USN <%I64d>, Compare2 USN <%I64d>\n"),
                    compareUsn1, compareUsn2 );
        //
        // Get the current attributes of the file and the times
        //
        WsbAssertNtStatus( NtQueryInformationFile( m_handleVerify,
                                                   &IoStatusBlock,
                                                   (PVOID)&basicInformation,
                                                   sizeof( basicInformation ),
                                                   FileBasicInformation ) );
        
        fileVersionId = basicInformation.LastWriteTime.QuadPart;

        //
        // Verify that the modify date & time has not changed since we 
        // took the data
        //
        if( fileVersionId != m_placeholder.fileVersionId ) {
            WsbThrow(FSA_E_ITEMCHANGED);
        } 
        
        //
        // If the file is memory mapped by another process and the original handle was closed we
        // are still able to open it for exclusive access here.  We have to determine if the file
        // is mapped and if so we cannot truncate it.  The only way to do this is from kernel
        // mode so we call our filter to do the check.
        //
        in.inout.command = RP_CHECK_HANDLE;
        WsbAssertStatus(DeviceIoControl(m_handleVerify, FSCTL_HSM_MSG, &in,
                               sizeof(RP_MSG), &out, sizeof(RP_MSG), &outSize, NULL));
                               
        if (!out.msg.hRep.canTruncate) {
            hr = FSA_E_ITEMINUSE;
            WsbLogEvent(FSA_MESSAGE_TRUNCSKIPPED_ISMAPPED, 0, NULL,  (OLECHAR*) jobName, WsbAbbreviatePath(fileName, 120), WsbHrAsString(hr), NULL);
            WsbThrow(hr);
        }
        
        
        // If the USN's don't match, then we need to check the
        // journal for changes

        // premigListUsn: The usn of the file immediately after it was migrated
        // compareUsn1: If not 0, the usn of the file before we (possibly) removed a read-only attribute
        // compareUsn2: If not 0,  
        //

        if ((0 == fileUsn) || (0 == premigListUsn)) {
            //  We don't have USN Journal info so force a CRC comparison
            DoCRC = TRUE;
        } else if ((compareUsn1 != 0) && (compareUsn2 != 0))  {
            // Need to compare with these input usn instead of a direct compare
            if ((premigListUsn != compareUsn1) || (fileUsn != compareUsn2)) {
                DoUsnCheck = TRUE;
            }
        } else if (fileUsn != premigListUsn)  {
            DoUsnCheck = TRUE;
        }

        // Current usn indicates that file may have changed
        if (DoUsnCheck)  {
            BOOL     UsnChanged = FALSE;

            hr = CheckUsnJournalForChanges(premigListUsn, fileUsn, &UsnChanged);
            if (S_OK == hr) {
                if (UsnChanged) {
                    // File changed, skip it
                    WsbThrow(FSA_E_ITEMCHANGED);
                }
            } else {
                // Something failed, force a CRC comparison
                DoCRC = TRUE;
                WsbLogEvent(FSA_MESSAGE_USN_CHECK_FAILED, 0, NULL,  
                        WsbAbbreviatePath(fileName,120), 
                        WsbHrAsString(hr), NULL);
                hr = S_OK;
            }
        }
        
        // If the USNJ indicated a possible change, then we need to CRC 
        // the data.
        if (DoCRC)  {
            //
            // Check to be sure that the CRC in the placeholder matches 
            // that of the file
            //
            ULONG currentCRC;

#if defined(TEMPORARY_TRUNCATE_STATISTICS)
            //  Try to increment the truncate-CRC count in the registry
            WsbIncRegistryValueDWORD(NULL, FSA_REGISTRY_PARMS,
                    OLESTR("TruncateCRCs"));
#endif
            
            WsbAffirmHr(CalculateCurrentCRCInternal(m_handleVerify, offset, size, &currentCRC));
            WsbTrace(OLESTR("CFsaScanItem::VerifyInternal: Current CRC <%ul>, Reparse CRC <%ls>\n"),
                    currentCRC, WsbLonglongAsString( m_placeholder.dataStreamCRC ) );
            if (currentCRC != m_placeholder.dataStreamCRC)  {
                //
                // The file has changed since we migrated it so
                // don't truncate it.
                WsbThrow(FSA_E_ITEMCHANGED);
            }
        } 


        hr = S_OK;
    } WsbCatch(hr);


    // If the file data had changed (so we didn't truncate it) log event  
    // (cannot remove placeholder with DeletePlaceholder since the file is already opened exclusively
    if (FSA_E_ITEMCHANGED == hr) {
        WsbLogEvent(FSA_MESSAGE_TRUNCSKIPPED_ISCHANGED, 0, NULL, 
                (OLECHAR*) jobName, WsbAbbreviatePath(fileName, 120), 
                WsbHrAsString(hr), NULL);
    }

    
    WsbTraceOut(OLESTR("CFsaScanItem::VerifyInternal"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}




HRESULT
CFsaScanItem::CheckIfSparse(
    IN LONGLONG offset,
    IN LONGLONG size
    )  

/*++

Implements:

  IFsaScanItem::CheckIfSparse()

    Determines if the specified section is on disk or not (is sparse)
    FSA_E_FILE_IS_TOTALLY_SPARSE - There are no resident portions of the section
    FSA_E_FILE_IS_PARTIALLY_SPARSE - The section of the file has some resident/some sparse
                                     sections
    FSA_E_FILE_IS_NOT_SPARSE - The section is totally resident
    any others - error and we don't know the state of the file

--*/
{
    HRESULT                         hr = E_FAIL;
    HANDLE                          handle = INVALID_HANDLE_VALUE;
    CWsbStringPtr                   path;
    ULONG                           DesiredAccess;
    IO_STATUS_BLOCK                 IoStatusBlock;
    NTSTATUS                        ntStatus;
    FILE_ALLOCATED_RANGE_BUFFER     inRange;
#define NUM_RANGE 10
    FILE_ALLOCATED_RANGE_BUFFER     outRange[NUM_RANGE];
    PFILE_ALLOCATED_RANGE_BUFFER    cRange;
    int                             idx;

    WsbTraceIn(OLESTR("CFsaScanItem::CheckIfSparse"), OLESTR("offset = <%I64d>, size = <%I64d>"),
                    offset, size);
    //
    // If the file is really managed then we can check the allocation map
    // Otherwise we indicate that the data is all resident
    //
    try {
        //
        // Create the real file name we need to open, under the covers this
        // allocates the buffer since the path pointer is null
        //
        WsbAffirmHr( GetFullPathAndName(  OLESTR("\\\\?\\"), NULL, &path, 0));
        //WsbAffirmHr( GetFullPathAndName(  NULL, NULL, &path, 0));
        
            //
            // Open the file to check the allocation
            //
            DesiredAccess = FILE_READ_ATTRIBUTES | FILE_READ_DATA;
            WsbAffirmHr( OpenObject( path, 
                                    FILE_NON_DIRECTORY_FILE | FILE_NO_INTERMEDIATE_BUFFERING,
                                    DesiredAccess,
                                    SHARE_FLAGS,
                                    FILE_OPEN,
                                    &IoStatusBlock,
                                    &handle ) );

        //
        // The open worked, our handle should be valid but we check to be
        // safe and sure 
        //
        WsbAssertHandle( handle );
   
        memset(&outRange, 0, sizeof(FILE_ALLOCATED_RANGE_BUFFER) * NUM_RANGE);

        //
        // Check the allocation of the specified range
        //
        inRange.FileOffset.QuadPart = offset;
        inRange.Length.QuadPart = size;
        ntStatus = NtFsControlFile( handle,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   FSCTL_QUERY_ALLOCATED_RANGES,
                                   &inRange,
                                   sizeof(FILE_ALLOCATED_RANGE_BUFFER),
                                   &outRange,
                                   sizeof(FILE_ALLOCATED_RANGE_BUFFER) * NUM_RANGE);
   
        //
        // Check the return code but STATUS_SUCCESS or STATUS_BUFFER_OVERFLOW are valid
        //
        if ( STATUS_SUCCESS != ntStatus && STATUS_BUFFER_OVERFLOW != ntStatus ) {
            WsbAssertNtStatus( ntStatus );
        }

    
        cRange = (PFILE_ALLOCATED_RANGE_BUFFER) &outRange;
        for (idx = 0; idx < NUM_RANGE; idx++) {
            if (cRange->Length.QuadPart != 0) {
                WsbTrace(OLESTR("CFsaScanItem::CheckIfSparse - Resident range %u Offset: %I64u, length: %I64u\n"), 
                        idx, cRange->FileOffset.QuadPart, cRange->Length.QuadPart);
            }
            cRange++;
        }

        //
        // Close the file since we are done with it and set the handle to invalid
        //
        NtClose(handle);
        handle =  INVALID_HANDLE_VALUE;

        //
        // If the initial allocated range does begin where we said to start and the length of the
        // allocated area is equal to the length we asked about then none of the data is sparse 
        //
        if ( (outRange[0].FileOffset.QuadPart == offset) && (outRange[0].Length.QuadPart == size) ) {
            hr = FSA_E_FILE_IS_NOT_SPARSE;
        } else if  (outRange[0].Length.QuadPart == 0)  {
                hr = FSA_E_FILE_IS_TOTALLY_SPARSE;
        } else  {
                hr = FSA_E_FILE_IS_PARTIALLY_SPARSE;
        }

    } WsbCatch(hr);

    //
    // if we opened the file we need to close it
    //
    if( INVALID_HANDLE_VALUE != handle) {
        NtClose( handle );
    }
    
    WsbTraceOut(OLESTR("CFsaScanItem::CheckIfSparse"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsapost.h ===
#ifndef _FSAPOST_
#define _FSAPOST_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    FSAPOST.cpp

Abstract:

    This class contains represents a post it - a unit of work
    that is exchanged between the FSA and the HSM engine.

Author:

    Cat Brant   [cbrant]   1-Apr-1997

Revision History:

--*/

#include "resource.h"       // main symbols

#include "job.h"
#include "fsa.h"
#include "fsaprv.h"

/*++

Class Name:
    
    CFsaScanItem

Class Description:


--*/


class CFsaPostIt : 
    public CWsbObject,
    public IFsaPostIt,
    public CComCoClass<CFsaPostIt,&CLSID_CFsaPostIt>
{
public:
    CFsaPostIt() {}
BEGIN_COM_MAP(CFsaPostIt)
    COM_INTERFACE_ENTRY(IFsaPostIt)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_FsaPostIt)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IFsaPostItPriv
public:

// IFsaPostIt
public:
    STDMETHOD(CompareToIPostIt)(IFsaPostIt* pPostIt, SHORT* pResult);

    STDMETHOD(GetFileVersionId)(LONGLONG  *pFileVersionId);
    STDMETHOD(GetFilterRecall)(IFsaFilterRecall** ppRecall);            
    STDMETHOD(GetMode)(ULONG *pMode);
    STDMETHOD(GetPath)(OLECHAR ** pPath, ULONG bufferSize);             
    STDMETHOD(GetPlaceholder)(FSA_PLACEHOLDER *pPlaceholder);       
    STDMETHOD(GetRequestAction)(FSA_REQUEST_ACTION *pRequestAction);    
    STDMETHOD(GetRequestOffset)(LONGLONG  *pRequestOffset);
    STDMETHOD(GetRequestSize)(LONGLONG *pRequestSize);
    STDMETHOD(GetResult)(HRESULT *pHr);
    STDMETHOD(GetResultAction)(FSA_RESULT_ACTION *pResultAction);
    STDMETHOD(GetSession)(IHsmSession **pSession);          
    STDMETHOD(GetStoragePoolId)(GUID  *pStoragePoolId); 
    STDMETHOD(GetUSN)(LONGLONG  *pUsn); 
    STDMETHOD(GetThreadId)(DWORD *threadId);   

    STDMETHOD(SetFileVersionId)(LONGLONG  fileVersionId);
    STDMETHOD(SetFilterRecall)(IFsaFilterRecall* pRecall);          
    STDMETHOD(SetMode)(ULONG mode);
    STDMETHOD(SetPath)(OLECHAR * path);             
    STDMETHOD(SetPlaceholder)(FSA_PLACEHOLDER *pPlaceholder);       
    STDMETHOD(SetRequestAction)(FSA_REQUEST_ACTION requestAction);  
    STDMETHOD(SetRequestOffset)(LONGLONG  requestOffset);
    STDMETHOD(SetRequestSize)(LONGLONG requestSize);
    STDMETHOD(SetResult)(HRESULT hr);
    STDMETHOD(SetResultAction)(FSA_RESULT_ACTION pResultAction);
    STDMETHOD(SetSession)(IHsmSession *pSession);           
    STDMETHOD(SetStoragePoolId)(GUID  storagePoolId);   
    STDMETHOD(SetUSN)(LONGLONG  usn);   
    STDMETHOD(SetThreadId)(DWORD threadId);   

protected:
    CComPtr<IFsaFilterRecall>   m_pFilterRecall;     // FSA filter recall that is tracking this recall
    CComPtr<IHsmSession>        m_pSession;          // HSM session that generated the PostIt
    GUID                        m_storagePoolId;     // Storage pool to receive data (manage only)
    ULONG                       m_mode;              // File open mode (filter recall only)
    FSA_REQUEST_ACTION          m_requestAction;     // Action for engine to take
    FSA_RESULT_ACTION           m_resultAction;      // Action for FSA to take when engine is done
    LONGLONG                    m_fileVersionId;     // Version of the file (manage and recall)
    LONGLONG                    m_requestOffset;     // The starting offset of the section to be managed (manage and recall)
    LONGLONG                    m_requestSize;       // The length of the section to be managed (manage and recall)
    FSA_PLACEHOLDER             m_placeholder;       // File placeholder information
    CWsbStringPtr               m_path;              // Path of file name from root of resource, callee must free this memory
    HRESULT                     m_hr;                // Result of the FSA_REQUEST_ACTION
    LONGLONG                    m_usn;               // USN of the file
    DWORD                       m_threadId; // id of thread causing recall
};

#endif  // _FSAPOST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsaprem.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsaprem.h

Abstract:

    Header file for the premigrated list classes.

Author:

    Ron White   [ronw]   18-Feb-1997

Revision History:

--*/

#ifndef _FSAPREM_
#define _FSAPREM_


#include "resource.h"       // main symbols
#include "wsbdb.h"
#include "fsa.h"
#include "fsaprv.h"

#define PREMIGRATED_REC_TYPE                1
#define PREMIGRATED_BAGID_OFFSETS_KEY_TYPE  1
#define PREMIGRATED_ACCESS_TIME_KEY_TYPE    2
#define PREMIGRATED_SIZE_KEY_TYPE           3
#define RECOVERY_REC_TYPE                   2
#define RECOVERY_KEY_TYPE                   1

#define RECOVERY_KEY_SIZE  (IDB_MAX_KEY_SIZE - 1)

// This may be problem if longer path names are used:
#define PREMIGRATED_MAX_PATH_SIZE           65536

/////////////////////////////////////////////////////////////////////////////
// CFsaPremigratedDb

class CFsaPremigratedDb : 
    public IFsaPremigratedDb,
    public CWsbDb,
    public CComCoClass<CFsaPremigratedDb,&CLSID_CFsaPremigratedDb>
{
public:
    CFsaPremigratedDb() {}
BEGIN_COM_MAP(CFsaPremigratedDb)
    COM_INTERFACE_ENTRY(IFsaPremigratedDb)
    COM_INTERFACE_ENTRY2(IWsbDb, IFsaPremigratedDb)
    COM_INTERFACE_ENTRY(IWsbDbPriv)
    COM_INTERFACE_ENTRY(IPersistStream)
END_COM_MAP()

//DECLARE_NO_REGISTRY()
DECLARE_REGISTRY_RESOURCEID(IDR_FsaPremigratedDb)

DECLARE_PROTECT_FINAL_CONSTRUCT();

// IWsbDb
    WSB_FROM_CWSBDB;

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pclsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize) {
            return(CWsbDb::GetSizeMax(pSize)); }
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IFsaPremigrated
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);
    STDMETHOD(Init)(OLECHAR* name, IWsbDbSys* pDbSys, BOOL* pCreated);

private:
};                                                                           




/////////////////////////////////////////////////////////////////////////////
// CFsaPremigratedRec

class CFsaPremigratedRec : 
    public CWsbDbEntity,
    public IFsaPremigratedRec,
    public CComCoClass<CFsaPremigratedRec,&CLSID_CFsaPremigratedRec>
{
public:
    CFsaPremigratedRec() {}
BEGIN_COM_MAP(CFsaPremigratedRec)
    COM_INTERFACE_ENTRY(IFsaPremigratedRec)
    COM_INTERFACE_ENTRY2(IWsbDbEntity, CWsbDbEntity)
    COM_INTERFACE_ENTRY(IWsbDbEntityPriv)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
END_COM_MAP()

//DECLARE_NO_REGISTRY()
DECLARE_REGISTRY_RESOURCEID(IDR_FsaPremigratedRec)

// IFsaPremigratedRec
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbDbEntity
public:
    STDMETHOD(Print)(IStream* pStream);
    STDMETHOD(UpdateKey)(IWsbDbKey *pKey);
    WSB_FROM_CWSBDBENTITY;

// IWsbTestable
    STDMETHOD(Test)(USHORT* /*passed*/, USHORT* /*failed*/) {
        return(E_NOTIMPL); }

// IFsaPremigratedRec
public:
    STDMETHOD(GetAccessTime)(FILETIME* pAccessTime);
    STDMETHOD(GetBagId)(GUID* pId);
    STDMETHOD(GetBagOffset)(LONGLONG* pOffset);
    STDMETHOD(GetFileId)(LONGLONG* pFileId);
    STDMETHOD(GetFileUSN)(LONGLONG* pFileUSN);
    STDMETHOD(GetOffset)(LONGLONG* pOffset);
    STDMETHOD(GetPath)(OLECHAR** ppPath, ULONG bufferSize);
    STDMETHOD(GetRecallTime)(FILETIME* pTime);
    STDMETHOD(GetSize)(LONGLONG* pSize);
    STDMETHOD(IsWaitingForClose)(void);
    STDMETHOD(SetAccessTime)(FILETIME AccessTime);
    STDMETHOD(SetBagId)(GUID id);
    STDMETHOD(SetBagOffset)(LONGLONG offset);
    STDMETHOD(SetFileId)(LONGLONG FileId);
    STDMETHOD(SetFileUSN)(LONGLONG FileUSN);
    STDMETHOD(SetFromScanItem)(IFsaScanItem* pScanItem, LONGLONG offset, LONGLONG size, BOOL isWaitingForClose);
    STDMETHOD(SetIsWaitingForClose)(BOOL isWaiting);
    STDMETHOD(SetOffset)(LONGLONG offset);
    STDMETHOD(SetPath)(OLECHAR* pPath);
    STDMETHOD(SetRecallTime)(FILETIME Time);
    STDMETHOD(SetSize)(LONGLONG Size);

private:
    FILETIME        m_AccessTime;
    GUID            m_BagId;
    LONGLONG        m_BagOffset;         // fileStart in the placeholder
    LONGLONG        m_FileId;
    BOOL            m_IsWaitingForClose;
    LONGLONG        m_Offset;            // dataStreamStart in the placeholder
    CWsbStringPtr   m_Path;
    FILETIME        m_RecallTime;
    LONGLONG        m_Size;
    LONGLONG        m_FileUSN;  // USN Journal number
};

#endif  // _FSAPREM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsapost.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsapost.cpp

Abstract:

    This class contains represents a post it - a unit of work
    that is exchanged between the FSA and the HSM engine.

Author:

    Cat Brant   [cbrant]   1-Apr-1997

Revision History:

--*/

#include "stdafx.h"

#undef  WSB_TRACE_IS
#define WSB_TRACE_IS        WSB_TRACE_BIT_FSA

#include "wsb.h"
#include "fsa.h"
#include "fsapost.h"

//  Module data
static USHORT iCount = 0;  // Count of existing objects


HRESULT
CFsaPostIt::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IFsaPostIt> pPostIt;

    WsbTraceIn(OLESTR("CFsaPostIt::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        // We need the IFsaPostIt interface to get the value of the object.
        WsbAffirmHr(pUnknown->QueryInterface(IID_IFsaPostIt, (void**) &pPostIt));

        // Compare the rules.
        hr = CompareToIPostIt(pPostIt, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPostIt::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CFsaPostIt::CompareToIPostIt(
    IN IFsaPostIt* pPostIt,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaPostIt::CompareToIPostIt().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   path;
    CWsbStringPtr   name;

    WsbTraceIn(OLESTR("CFsaPostIt::CompareToIPostIt"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pPostIt, E_POINTER);
        
        //
        // Not used - not implemented
        //
        hr = E_NOTIMPL;

// Compare the PostIt

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::CompareToIPostIt"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CFsaPostIt::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::FinalConstruct"), OLESTR(""));
    
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_pSession           = 0;
        m_storagePoolId      = GUID_NULL;
        m_mode               = 0;
        m_requestAction      = FSA_REQUEST_ACTION_NONE;
        m_resultAction       = FSA_RESULT_ACTION_NONE;
        m_fileVersionId      = 0;
        m_requestOffset      = 0;
        memset (&m_placeholder, 0, sizeof(FSA_PLACEHOLDER));
        m_path               = OLESTR("");
        m_usn                = 0;
        m_hr                 = S_OK;

    } WsbCatch(hr);

    iCount++;
    WsbTraceOut(OLESTR("CFsaPostIt::FinalConstruct"),OLESTR("hr = <%ls>, Count is <%d>"),
                WsbHrAsString(hr), iCount);

    return(hr);
}


void
CFsaPostIt::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    WsbTraceIn(OLESTR("CFsaPostIt::FinalRelease"),OLESTR(""));

    // Let the parent class do his thing.   
    CWsbObject::FinalRelease();

    iCount--;
    WsbTraceOut(OLESTR("CFsaPostIt::FinalRelease"),OLESTR("Count is <%d>"), iCount);
}


HRESULT
CFsaPostIt::GetFileVersionId(
    OUT LONGLONG  *pFileVersionId
    )

/*++

Implements:

  IFsaPostIt::GetFileVersionId().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::GetFileVersionId"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pFileVersionId, E_POINTER);
        *pFileVersionId = m_fileVersionId;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetFileVersionId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaPostIt::GetFilterRecall(
    IFsaFilterRecall** ppRecall
    )

/*++

Implements:

  IFsaPostIt::GetFilterRecall().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::GetFilterRecall"), OLESTR(""));

    try {

        // Did they give us a valid item.
        WsbAssert(0 != ppRecall, E_POINTER);

        *ppRecall = m_pFilterRecall;
        m_pFilterRecall->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetFilterRecall"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::GetMode(
    OUT ULONG *pMode    
    )

/*++

Implements:

  IFsaPostIt::GetMode().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::GetMode"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pMode, E_POINTER);
        *pMode = m_mode;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetMode"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::GetPath(
    OLECHAR **pPath,
    IN ULONG bufferSize
    )           

/*++

Implements:

  IFsaPostIt::GetPath().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   path;

    WsbTraceIn(OLESTR("CFsaPostIt::GetPath"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pPath, E_POINTER);
        WsbAffirmHr(m_path.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetPath"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::GetPlaceholder(
    FSA_PLACEHOLDER  *pPlaceholder
    )

/*++

Implements:

  IFsaPostIt::GetPlaceholder().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::GetPlaceholder"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pPlaceholder, E_POINTER);
        memcpy(pPlaceholder, &m_placeholder, sizeof(FSA_PLACEHOLDER));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetPlaceholder"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaPostIt::GetRequestAction(
    FSA_REQUEST_ACTION  *pRequestAction
    )

/*++

Implements:

  IFsaPostIt::GetRequestAction().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::GetRequestAction"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pRequestAction, E_POINTER);
        *pRequestAction = m_requestAction;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetRequestAction"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::GetRequestOffset(
    LONGLONG  *pRequestOffset
    )

/*++

Implements:

  IFsaPostIt::GetRequestOffset().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   path;
    CWsbStringPtr   name;

    WsbTraceIn(OLESTR("CFsaPostIt::GetRequestOffset"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pRequestOffset, E_POINTER);
        *pRequestOffset = m_requestOffset;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetRequestOffset"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::GetRequestSize(
    LONGLONG  *pRequestSize
    )

/*++

Implements:

  IFsaPostIt::GetRequestSize().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   path;
    CWsbStringPtr   name;

    WsbTraceIn(OLESTR("CFsaPostIt::GetRequestSize"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pRequestSize, E_POINTER);
        *pRequestSize = m_requestSize;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetRequestSize"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::GetResult(
    HRESULT  *pHr
    )

/*++

Implements:

  IFsaPostIt::GetResult().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   path;
    CWsbStringPtr   name;

    WsbTraceIn(OLESTR("CFsaPostIt::GetResult"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pHr, E_POINTER);
        *pHr = m_hr;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetResultAction"), OLESTR("hr = <%ls>, result = <%ls>"), 
            WsbHrAsString(hr), WsbHrAsString(*pHr));

    return(hr);
}

HRESULT
CFsaPostIt::GetResultAction(
    FSA_RESULT_ACTION  *pResultAction
    )

/*++

Implements:

  IFsaPostIt::GetResultAction().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   path;
    CWsbStringPtr   name;

    WsbTraceIn(OLESTR("CFsaPostIt::GetResultAction"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pResultAction, E_POINTER);
        *pResultAction = m_resultAction;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetResultAction"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::GetSession(
    IHsmSession  **ppSession
    )

/*++

Implements:

  IFsaPostIt::GetSession().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   path;
    CWsbStringPtr   name;

    WsbTraceIn(OLESTR("CFsaPostIt::GetSession"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != ppSession, E_POINTER);
        *ppSession = m_pSession;
        m_pSession->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::GetStoragePoolId(
    GUID  *pStoragePoolId
    )

/*++

Implements:

  IFsaPostIt::GetStoragePoolId().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   path;
    CWsbStringPtr   name;

    WsbTraceIn(OLESTR("CFsaPostIt::GetStoragePoolId"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pStoragePoolId, E_POINTER);
        memcpy(pStoragePoolId, &m_storagePoolId, sizeof(GUID));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetStoragePoolId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaPostIt::GetUSN(
    LONGLONG  *pUsn
    )

/*++

Implements:

  IFsaPostIt::GetUSN().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   path;
    CWsbStringPtr   name;

    WsbTraceIn(OLESTR("CFsaPostIt::GetUSN"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUsn, E_POINTER);
        *pUsn = m_usn;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetUSN"), OLESTR("hr = <%ls>, USN = <%ls>"), 
            WsbHrAsString(hr), WsbPtrToLonglongAsString(pUsn));

    return(hr);
}


HRESULT
CFsaPostIt::GetThreadId(
    DWORD  *pThreadId
    )

/*++

Implements:

  IFsaPostIt::GetThreadId().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::GetThreadId"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pThreadId, E_POINTER);
        *pThreadId = m_threadId;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetThreadId"), OLESTR("hr = <%ls>, threadId = <%ls>"), 
            WsbHrAsString(hr), WsbPtrToLongAsString((PLONG)pThreadId));

    return(hr);
}

HRESULT
CFsaPostIt::SetFileVersionId(
    LONGLONG  fileVersionId
    )

/*++

Implements:

  IFsaPostIt::SetFileVersionId().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetFileVersionId"), OLESTR(""));

    m_fileVersionId = fileVersionId;

    WsbTraceOut(OLESTR("CFsaPostIt::SetFileVersionId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::SetFilterRecall(
    IN IFsaFilterRecall*    pRecall
    )

/*++

Implements:

  IFsaPostIt::SetFilterRecall().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetFilterRecall"), OLESTR(""));

    m_pFilterRecall = pRecall;

    WsbTraceOut(OLESTR("CFsaPostIt::SetFilterRecall"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::SetMode(
    ULONG mode
    )

/*++

Implements:

  IFsaPostIt::SetMode().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetMode"), OLESTR(""));

    m_mode = mode;

    WsbTraceOut(OLESTR("CFsaPostIt::SetMode"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
                                                                         
    return(hr);
}


HRESULT
CFsaPostIt::SetPath(
    OLECHAR *path
    )

/*++

Implements:

  IFsaPostIt::SetPath().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetPath"), OLESTR(""));

    m_path = path;

    WsbTraceOut(OLESTR("CFsaPostIt::SetPath"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::SetPlaceholder(
    FSA_PLACEHOLDER *pPlaceholder
    )

/*++

Implements:

  IFsaPostIt::SetPlaceholder().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetPlaceholder"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        memcpy(&m_placeholder, pPlaceholder, sizeof(FSA_PLACEHOLDER));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::SetPlaceholder"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::SetRequestAction(
    FSA_REQUEST_ACTION requestAction
    )

/*++

Implements:

  IFsaPostIt::SetRequestAction().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetRequestAction"), OLESTR(""));

    m_requestAction = requestAction;

    WsbTraceOut(OLESTR("CFsaPostIt::SetRequestAction"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::SetRequestOffset(
    LONGLONG  requestOffset
    )

/*++

Implements:

  IFsaPostIt::SetRequestOffset().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetRequestOffset"), OLESTR(""));

    m_requestOffset = requestOffset;

    WsbTraceOut(OLESTR("CFsaPostIt::SetRequestOffset"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::SetRequestSize(
    LONGLONG  requestSize
    )

/*++

Implements:

  IFsaPostIt::SetRequestSize().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetRequestSize"), OLESTR(""));

    m_requestSize = requestSize;

    WsbTraceOut(OLESTR("CFsaPostIt::SetRequestSize"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaPostIt::SetResult(
    HRESULT result
    )

/*++

Implements:

  IFsaPostIt::SetResult().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetResult"), OLESTR("result = <%ls>"), WsbHrAsString(result));

    m_hr =  result;

    WsbTraceOut(OLESTR("CFsaPostIt::SetResult"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::SetResultAction(
    FSA_RESULT_ACTION  resultAction
    )

/*++

Implements:

  IFsaPostIt::SetResultAction().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetResultAction"), OLESTR(""));

    m_resultAction =  resultAction;

    WsbTraceOut(OLESTR("CFsaPostIt::SetResultAction"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaPostIt::SetSession(
    IHsmSession *pSession
    )

/*++

Implements:

  IFsaPostIt::SetSession().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetSession"), OLESTR(""));

    if (m_pSession != 0) {
        m_pSession = 0;
    }

    m_pSession = pSession;

    WsbTraceOut(OLESTR("CFsaPostIt::SetSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::SetStoragePoolId(
    GUID  StoragePoolId
    )

/*++

Implements:

  IFsaPostIt::SetStoragePoolId().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetStoragePoolId"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        memcpy(&m_storagePoolId, &StoragePoolId, sizeof(GUID));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::SetStoragePoolId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::SetUSN(
    LONGLONG  usn
    )

/*++

Implements:

  IFsaPostIt::SetUSN().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetUSN"), OLESTR("USN = <%ls>"), WsbLonglongAsString(usn));

    m_usn = usn;

    WsbTraceOut(OLESTR("CFsaPostIt::SetUSN"), OLESTR("hr = <%ls>"),  WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::SetThreadId(
    DWORD threadId
    )

/*++

Implements:

  IFsaPostIt::SetThreadId().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::SetThreadId"), OLESTR("ThreadId = <%ls>"), WsbLongAsString(threadId));

    m_threadId = threadId;

    WsbTraceOut(OLESTR("CFsaPostIt::SetThreadId"), OLESTR("hr = <%ls>"),  WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaPostIt::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}


HRESULT CFsaPostIt::GetClassID
(
    OUT LPCLSID pclsid
    ) 
/*++

Routine Description:

  See IPerist::GetClassID()

Arguments:

  See IPerist::GetClassID()

Return Value:

    See IPerist::GetClassID()

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::GetClassID"), OLESTR(""));


    try {
        WsbAssert(0 != pclsid, E_POINTER);

        *pclsid = CLSID_CFsaPostIt;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pclsid));
    return(hr);
}

HRESULT CFsaPostIt::GetSizeMax
(
    OUT ULARGE_INTEGER* pcbSize
    ) 
/*++

Routine Description:

  See IPersistStream::GetSizeMax().

Arguments:

  See IPersistStream::GetSizeMax().

Return Value:

  See IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::GetSizeMax"), OLESTR(""));

    try {
        
        WsbAssert(0 != pcbSize, E_POINTER);

        pcbSize->QuadPart = 0;
        hr = E_NOTIMPL;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::GetSizeMax"), 
        OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), 
        WsbPtrToUliAsString(pcbSize));

    return(hr);
}

HRESULT CFsaPostIt::Load
(
    IN IStream* /*pStream*/
    ) 
/*++

Routine Description:

  See IPersistStream::Load().

Arguments:

  See IPersistStream::Load().

Return Value:

  See IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::Load"), OLESTR(""));

    try {
        hr = E_NOTIMPL;

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaPostIt::Load"), OLESTR("hr = <%ls>"),   WsbHrAsString(hr));

    return(hr);
}

HRESULT CFsaPostIt::Save
(
    IN IStream* pStream, 
    IN BOOL clearDirty
    ) 
/*++

Routine Description:

  See IPersistStream::Save().

Arguments:

  See IPersistStream::Save().

Return Value:

  See IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPostIt::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        hr = E_NOTIMPL;

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPostIt::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsaprem.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsaprem.cpp

Abstract:

    Defines the functions for the premigrated list classes.

Author:

    Ron White   [ronw]   18-Feb-1997

Revision History:

--*/


#include "stdafx.h"
#include "wsb.h"


#include "fsaprem.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_FSA

static USHORT iCountPrem = 0;  // Count of existing objects


HRESULT 
CFsaPremigratedDb::FinalConstruct(
    void
    ) 
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssertHr(CWsbDb::FinalConstruct());
        m_version = 1;
    } WsbCatch(hr);

    return(hr);
}


HRESULT 
CFsaPremigratedDb::FinalRelease(
    void
    ) 
/*++

Implements:

  CComObjectRoot::FinalRelease

--*/
{
    HRESULT     hr = S_OK;

    CWsbDb::FinalRelease();
    return(hr);
}



HRESULT
CFsaPremigratedDb::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CFsaPremigratedDb;
    } WsbCatch(hr);
    
    return(hr);
}


HRESULT
CFsaPremigratedDb::Init(
    IN  OLECHAR* path,
    IN  IWsbDbSys* pDbSys, 
    OUT BOOL*    pCreated
    )

/*++

Implements:

  IFsaPremigrated::Init

--*/
{
    BOOL             created = FALSE;
    HRESULT          hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedDb::Init"),OLESTR(""));
    try {
        int            i = 0;

        m_pWsbDbSys = pDbSys;
        WsbAffirmPointer(m_pWsbDbSys);

        //  Attempt to find the DB
        hr = Locate(path);

        if (S_OK != hr) {
            WsbTrace(OLESTR("CFsaPremigratedDb::Init: db Locate failed\n"));
            if (STG_E_FILENOTFOUND != hr) {
                // Got some error; try deleting the DB and recreating it
                WsbTrace(OLESTR("CFsaPremigratedDb::Init: deleting DB\n"));
                WsbAffirmHr(Delete(path));
                hr = STG_E_FILENOTFOUND;
            }
        }

        if (STG_E_FILENOTFOUND == hr){
            ULONG memSize;

            hr = S_OK;
            m_nRecTypes = 2;

            memSize = m_nRecTypes * sizeof(IDB_REC_INFO);
            m_RecInfo = (IDB_REC_INFO*)WsbAlloc(memSize);
            WsbAffirm(0 != m_RecInfo, E_FAIL);
            ZeroMemory(m_RecInfo, memSize);

            //  Premigrated file record type
            m_RecInfo[0].Type = PREMIGRATED_REC_TYPE;
            m_RecInfo[0].EntityClassId = CLSID_CFsaPremigratedRec;
            m_RecInfo[0].Flags = IDB_REC_FLAG_VARIABLE;
            m_RecInfo[0].MinSize = (2 * WsbPersistSizeOf(FILETIME)) +
                    (5 * WsbPersistSizeOf(LONGLONG)) +
                    WsbPersistSizeOf(GUID) + 4 + WsbPersistSizeOf(BOOL);
            m_RecInfo[0].MaxSize = m_RecInfo[0].MinSize + PREMIGRATED_MAX_PATH_SIZE;

            m_RecInfo[0].nKeys = 3;

            memSize = m_RecInfo[0].nKeys * sizeof(IDB_KEY_INFO);
            m_RecInfo[0].Key = (IDB_KEY_INFO*)WsbAlloc(memSize);
            WsbAffirm(0 != m_RecInfo[0].Key, E_FAIL);
            ZeroMemory(m_RecInfo[0].Key, memSize);

            //  This is the default key used after a GetEntity call
            m_RecInfo[0].Key[0].Type = PREMIGRATED_ACCESS_TIME_KEY_TYPE;
            m_RecInfo[0].Key[0].Size = WSB_BYTE_SIZE_BOOL + WSB_BYTE_SIZE_FILETIME + WSB_BYTE_SIZE_LONGLONG + WSB_BYTE_SIZE_GUID;
            m_RecInfo[0].Key[0].Flags = IDB_KEY_FLAG_DUP_ALLOWED;

            //  This is the primary key, which controls how the records are
            //  arranged in the DB
            m_RecInfo[0].Key[1].Type = PREMIGRATED_BAGID_OFFSETS_KEY_TYPE;
            m_RecInfo[0].Key[1].Size = WSB_BYTE_SIZE_BOOL + 2 * WSB_BYTE_SIZE_LONGLONG + WSB_BYTE_SIZE_GUID;
            m_RecInfo[0].Key[1].Flags = IDB_KEY_FLAG_PRIMARY;

            m_RecInfo[0].Key[2].Type = PREMIGRATED_SIZE_KEY_TYPE;
            m_RecInfo[0].Key[2].Size = WSB_BYTE_SIZE_BOOL + WSB_BYTE_SIZE_LONGLONG + WSB_BYTE_SIZE_LONGLONG + WSB_BYTE_SIZE_GUID;
            m_RecInfo[0].Key[2].Flags = IDB_KEY_FLAG_DUP_ALLOWED;

            WsbAffirm(m_RecInfo[0].nKeys <= IDB_MAX_KEYS_PER_REC, E_FAIL);

            //  Recovery record type
            m_RecInfo[1].Type = RECOVERY_REC_TYPE;
            m_RecInfo[1].EntityClassId = CLSID_CFsaRecoveryRec;
            m_RecInfo[1].Flags = IDB_REC_FLAG_VARIABLE;
            m_RecInfo[1].MinSize = 4 * WsbPersistSizeOf(LONGLONG) + 
                    WsbPersistSizeOf(LONG) + WsbPersistSizeOf(ULONG) + WsbPersistSizeOf(GUID) + 4;
            m_RecInfo[1].MaxSize = m_RecInfo[1].MinSize + PREMIGRATED_MAX_PATH_SIZE;

            m_RecInfo[1].nKeys = 1;

            memSize = m_RecInfo[1].nKeys * sizeof(IDB_KEY_INFO);
            m_RecInfo[1].Key = (IDB_KEY_INFO*)WsbAlloc(memSize);
            WsbAffirm(0 != m_RecInfo[1].Key, E_FAIL);
            ZeroMemory(m_RecInfo[1].Key, memSize);

            //  This is the default and primary key
            m_RecInfo[1].Key[0].Type = RECOVERY_KEY_TYPE;
            m_RecInfo[1].Key[0].Size = RECOVERY_KEY_SIZE;
            m_RecInfo[1].Key[0].Flags = IDB_KEY_FLAG_PRIMARY;

            //  Attempt to create the DB
            WsbAssertHr(Create(path));
            created = TRUE;
        } else {
            WsbAffirmHr(hr);
        }
    } WsbCatch(hr);

    if (pCreated) {
        *pCreated = created;
    }
    WsbTraceOut(OLESTR("CFsaPremigratedDb::Init"),
        OLESTR("hr = <%ls>, Created = %ls"), WsbHrAsString(hr),
        WsbBoolAsString(created));
    return(hr);
}


HRESULT
CFsaPremigratedDb::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT             hr = S_OK;

    hr = CWsbDb::Load(pStream);

    if (S_OK != hr && STG_E_FILENOTFOUND != hr) {
        // Got some error; delete the DB (we'll recreate it later if
        // we need it
        WsbTrace(OLESTR("CFsaPremigratedDb::Load: deleting DB\n"));
        if (S_OK == Delete(NULL)) {
            hr = STG_E_FILENOTFOUND;
        }
    }

    return(hr);
}


HRESULT
CFsaPremigratedDb::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT             hr = S_OK;

    try {
        WsbAffirmHr(CWsbDb::Save(pStream, clearDirty));
    } WsbCatch(hr);

    return(hr);
}



HRESULT 
CFsaPremigratedRec::GetAccessTime(
    OUT FILETIME* pAccessTime 
    ) 
/*++

Implements:

  IFsaPremigratedRec::GetAccessTime

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::GetAccessTime"),OLESTR(""));

    try {
        WsbAssert(0 != pAccessTime, E_POINTER);
        *pAccessTime = m_AccessTime;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::GetAccessTime"),
        OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::GetBagId(
    OUT GUID* pId 
    ) 
/*++

Implements:

  IFsaPremigratedRec::GetBagId

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::GetBagId"),OLESTR(""));

    try {
        WsbAssert(0 != pId, E_POINTER);

        *pId = m_BagId;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::GetBagId"), OLESTR("hr = <%ls> Id = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pId));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::GetBagOffset(
    OUT LONGLONG* pOffset 
    ) 
/*++

Implements:

  IFsaPremigratedRec::GetBagOffset

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::GetBagOffset"),OLESTR(""));

    try {
        WsbAssert(0 != pOffset, E_POINTER);
        *pOffset = m_BagOffset;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::GetBagOffset"), OLESTR("hr = <%ls> Offset = <%ls>"), WsbHrAsString(hr), WsbLonglongAsString(*pOffset));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::GetFileId(
    OUT LONGLONG* pFileId 
    ) 
/*++

Implements:

  IFsaPremigratedRec::GetFileId

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::GetFileId"),OLESTR(""));

    try {
        WsbAssert(0 != pFileId, E_POINTER);
        *pFileId = m_FileId;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::GetFileId"),
        OLESTR("hr = <%ls> FileId = <%ls>"), WsbHrAsString( hr ), WsbLonglongAsString( *pFileId ) );

    return(hr);
}


HRESULT 
CFsaPremigratedRec::GetFileUSN(
    OUT LONGLONG* pFileUSN 
    ) 
/*++

Implements:

  IFsaPremigratedRec::GetFileUSN

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::GetFileUSN"),OLESTR(""));

    try {
        WsbAssert(0 != pFileUSN, E_POINTER);
        *pFileUSN = m_FileUSN;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::GetFileUSN"),
        OLESTR("hr = <%ls> File USN = <%ls>"), WsbHrAsString( hr ), WsbLonglongAsString( *pFileUSN ) );

    return(hr);
}


HRESULT 
CFsaPremigratedRec::GetOffset(
    OUT LONGLONG* pOffset 
    ) 
/*++

Implements:

  IFsaPremigratedRec::GetOffset

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::GetOffset"),OLESTR(""));

    try {
        WsbAssert(0 != pOffset, E_POINTER);
        *pOffset = m_Offset;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::GetOffset"),
        OLESTR("hr = <%ls> Offset = <%ls>"), WsbHrAsString( hr ), WsbLonglongAsString( *pOffset ) );

    return(hr);
}


HRESULT 
CFsaPremigratedRec::GetPath(
    OUT OLECHAR** ppPath,
    IN  ULONG     bufferSize
    ) 
/*++

Implements:

  IFsaPremigratedRec::GetPath

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::GetPath"),OLESTR(""));

    try {
        WsbAssert(0 != ppPath, E_POINTER);
        WsbAffirmHr(m_Path.CopyTo(ppPath, bufferSize));
        WsbTrace( OLESTR("CFsaPremigratedRec::GetPath path = <%ls>\n"), *ppPath );
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::GetPath"),
        OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::GetRecallTime(
    OUT FILETIME* pTime 
    ) 
/*++

Implements:

  IFsaPremigratedRec::GetRecallTime

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::GetRecallTime"),OLESTR(""));

    try {
        WsbAssert(0 != pTime, E_POINTER);
        *pTime = m_RecallTime;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::GetRecallTime"),
        OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::GetSize(
    OUT LONGLONG* pSize 
    ) 
/*++

Implements:

  IFsaPremigratedRec::GetSize

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::GetSize"),OLESTR(""));

    try {
        WsbAssert(0 != pSize, E_POINTER);
        *pSize = m_Size;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::GetSize"),
        OLESTR("hr = <%ls> Size = <%ls>"), WsbHrAsString( hr ), WsbLonglongAsString( *pSize ) );

    return(hr);
}


HRESULT 
CFsaPremigratedRec::FinalConstruct(
    void
    ) 
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssertHr(CWsbDbEntity::FinalConstruct());

        m_AccessTime.dwLowDateTime = 0;
        m_AccessTime.dwHighDateTime = 0;
        m_BagOffset = 0;
        m_BagId = GUID_NULL;
        m_FileId = 0;
        m_IsWaitingForClose = FALSE;
        m_Size = 0;
        m_Offset = 0;
        m_FileUSN = 0;

    } WsbCatch(hr);

    iCountPrem++;

    return(hr);
}


HRESULT 
CFsaPremigratedRec::FinalRelease(
    void
    ) 
/*++

Implements:

  CComObjectRoot::FinalRelease

--*/
{
    HRESULT     hr = S_OK;

    CWsbDbEntity::FinalRelease();

    iCountPrem--;

    return(hr);
}


HRESULT CFsaPremigratedRec::GetClassID
(
    OUT LPCLSID pclsid
    ) 
/*++

Implements:

  IPerist::GetClassID

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::GetClassID"), OLESTR(""));


    try {
        WsbAssert(0 != pclsid, E_POINTER);
        *pclsid = CLSID_CFsaPremigratedRec;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CSecRec::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pclsid));
    return(hr);
}


HRESULT CFsaPremigratedRec::GetSizeMax
(
    OUT ULARGE_INTEGER* pcbSize
    ) 
/*++

Routine Description:

  See IPersistStream::GetSizeMax().

Arguments:

  See IPersistStream::GetSizeMax().

Return Value:

  See IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::GetSizeMax"), OLESTR(""));

    try {
        
        WsbAssert(0 != pcbSize, E_POINTER);

        pcbSize->QuadPart = WsbPersistSizeOf(FILETIME) + 
                            WsbPersistSizeOf(BOOL)  + 
                            WsbPersistSizeOf(GUID)  + 
                            4 * WsbPersistSizeOf(LONGLONG)  + 
                            WsbPersistSize((wcslen(m_Path) + 1) * sizeof(OLECHAR));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::GetSizeMax"), 
        OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), 
        WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::IsWaitingForClose(
    void
    ) 
/*++

Implements:

  IFsaPremigratedRec::IsWaitingForClose

--*/
{
    
    HRESULT     hr = S_FALSE;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::IsWaitingForClose"),OLESTR(""));

    if (m_IsWaitingForClose) {
        hr = S_OK;
    }

    WsbTraceOut(OLESTR("CFsaPremigratedRec::IsWaitingForClose"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT CFsaPremigratedRec::Load
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        WsbAssertHr(WsbLoadFromStream(pStream, &m_AccessTime));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_BagId));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_BagOffset));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_FileId));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_IsWaitingForClose));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_Offset));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_Path, 0));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_Size));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_RecallTime));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_FileUSN));

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaPremigratedRec::Load"), 
        OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT CFsaPremigratedRec::Print
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IWsbDbEntity::Print

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::Print"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" AccessTime = %ls"), 
                WsbFiletimeAsString(FALSE, m_AccessTime)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" BagId = %ls"), 
                WsbGuidAsString(m_BagId)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", BagOffset = %ls"), 
                WsbLonglongAsString(m_BagOffset)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", FileId = %ls"), 
                WsbLonglongAsString(m_FileId)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Waiting for close = %ls"), 
                WsbBoolAsString(m_IsWaitingForClose)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", Offset = %ls"), 
                WsbLonglongAsString(m_Offset)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", Path = %ls"), 
                static_cast<OLECHAR*>(m_Path)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", Size = %ls"), 
                WsbLonglongAsString(m_Size)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" RecallTime = %ls"), 
                WsbFiletimeAsString(FALSE, m_RecallTime)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", File USN = %ls"), 
                WsbLonglongAsString(m_FileUSN)));
        WsbAffirmHr(CWsbDbEntity::Print(pStream));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::Print"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT CFsaPremigratedRec::Save
(
    IN IStream* pStream, 
    IN BOOL clearDirty
    ) 
/*++

Implements:

  IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        WsbAssertHr(WsbSaveToStream(pStream, m_AccessTime));
        WsbAssertHr(WsbSaveToStream(pStream, m_BagId));
        WsbAssertHr(WsbSaveToStream(pStream, m_BagOffset));
        WsbAssertHr(WsbSaveToStream(pStream, m_FileId));
        WsbAssertHr(WsbSaveToStream(pStream, m_IsWaitingForClose));
        WsbAssertHr(WsbSaveToStream(pStream, m_Offset));
        WsbAssertHr(WsbSaveToStream(pStream, m_Path));
        WsbAssertHr(WsbSaveToStream(pStream, m_Size));
        WsbAssertHr(WsbSaveToStream(pStream, m_RecallTime));
        WsbAssertHr(WsbSaveToStream(pStream, m_FileUSN));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT 
CFsaPremigratedRec::SetAccessTime(
    IN FILETIME AccessTime 
    ) 
/*++

Implements:

  IFsaPremigratedRec::SetAccessTime

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::SetAccessTime"),OLESTR(""));

    try {
        m_AccessTime = AccessTime;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::SetAccessTime"),
        OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::SetFromScanItem(
    IN IFsaScanItem* pScanItem,
    IN LONGLONG offset,
    IN LONGLONG size,
    IN BOOL isWaitingForClose
    ) 
/*++

Implements:

  IFsaPremigratedRec::SetFromScanItem

--*/
{
    
    HRESULT             hr = S_OK;
    FSA_PLACEHOLDER     placeholder;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::SetFromScanItem"),OLESTR(""));

    try {
        WsbAssert(0 != pScanItem, E_POINTER);

        // Get the name of the file
        WsbAffirmHr(pScanItem->GetPathAndName(0, &m_Path, 0));
        WsbTrace(OLESTR("CFsaPremigratedRec::SetFromScanItem: path = %ls\n"),
                static_cast<WCHAR*>(m_Path));

        // Get the file id.
        WsbAffirmHr(pScanItem->GetFileId(&m_FileId));

        // Get the access time, offset, and size.
        WsbAffirmHr(pScanItem->GetAccessTime(&m_AccessTime));
        WsbTrace(OLESTR("CFsaPremigratedRec::SetFromScanItem: access time = %ls\n"),
                WsbFiletimeAsString(FALSE, m_AccessTime));
        m_Offset = offset;
        m_Size = size;
        m_IsWaitingForClose = isWaitingForClose;

        // Get the bag id and offset.
        WsbAffirmHr(pScanItem->GetPlaceholder(offset, size, &placeholder));
        m_BagId = placeholder.bagId;
        m_BagOffset = placeholder.fileStart;
        m_RecallTime = placeholder.recallTime;
        WsbTrace(OLESTR("CFsaPremigratedRec::SetFromScanItem: recall time = %ls\n"),
                WsbFiletimeAsString(FALSE, m_RecallTime));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::SetFromScanItem"),
        OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::SetBagId(
    IN GUID BagId
    ) 
/*++

Implements:

  IFsaPremigratedRec::SetBagId

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::SetBagId"),OLESTR(""));

    m_BagId = BagId;

    WsbTraceOut(OLESTR("CFsaPremigratedRec::SetBagId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::SetBagOffset(
    IN LONGLONG BagOffset 
    ) 
/*++

Implements:

  IFsaPremigratedRec::SetBagOffset

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::SetBagOffset"),OLESTR(""));

    m_BagOffset = BagOffset;

    WsbTraceOut(OLESTR("CFsaPremigratedRec::SetBagOffset"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::SetFileId(
    IN LONGLONG FileId 
    ) 
/*++

Implements:

  IFsaPremigratedRec::SetFileId

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::SetFileId"),OLESTR("FileId = %ls"),
            WsbLonglongAsString(FileId));

    try {
        m_FileId = FileId;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::SetFileId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::SetFileUSN(
    IN LONGLONG FileUSN 
    ) 
/*++

Implements:

  IFsaPremigratedRec::SetFileUSN

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::SetFileUSN"),OLESTR("File USN = %ls"),
            WsbLonglongAsString(FileUSN));

    try {
        m_FileUSN = FileUSN;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::SetFileUSN"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::SetIsWaitingForClose(
    IN BOOL isWaiting
    ) 
/*++

Implements:

  IFsaPremigratedRec::SetIsWaitingForClose

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::SetIsWaitingForClose"),OLESTR(""));

    m_IsWaitingForClose = isWaiting;

    WsbTraceOut(OLESTR("CFsaPremigratedRec::SetIsWaitingForClose"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::SetOffset(
    IN LONGLONG Offset 
    ) 
/*++

Implements:

  IFsaPremigratedRec::SetOffset

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::SetOffset"),OLESTR(""));

    try {
        m_Offset = Offset;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::SetOffset"),
        OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::SetPath(
    IN OLECHAR* Path 
    ) 
/*++

Implements:

  IFsaPremigratedRec::SetPath

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::SetPath"),OLESTR(""));

    try {
        m_Path = Path;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::SetPath"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::SetRecallTime(
    IN FILETIME time 
    ) 
/*++

Implements:

  IFsaPremigratedRec::SetRecallTime

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::SetRecallTime"),OLESTR(""));

    try {
        m_RecallTime = time;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::SetRecallTime"),
        OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::SetSize(
    IN LONGLONG Size 
    ) 
/*++

Implements:

  IFsaPremigratedRec::SetSize

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaPremigratedRec::SetSize"),OLESTR(""));

    try {
        m_Size = Size;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaPremigratedRec::SetSize"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaPremigratedRec::UpdateKey(
    IWsbDbKey *pKey
    ) 
/*++

Implements:

  IWsbDbEntity::UpdateKey

--*/
{ 
    HRESULT     hr = S_OK; 

    try {
        ULONG    KeyType;

        WsbAffirmHr(pKey->GetType(&KeyType));
        switch (KeyType) {
        case PREMIGRATED_ACCESS_TIME_KEY_TYPE:
            WsbAffirmHr(pKey->SetToBool(m_IsWaitingForClose));
            WsbAffirmHr(pKey->AppendFiletime(m_AccessTime));
            WsbAffirmHr(pKey->AppendGuid(m_BagId));
            WsbAffirmHr(pKey->AppendLonglong(m_BagOffset));
            break;

        case PREMIGRATED_BAGID_OFFSETS_KEY_TYPE:
            WsbAffirmHr(pKey->SetToGuid(m_BagId));
            WsbAffirmHr(pKey->AppendLonglong(m_BagOffset));
            WsbAffirmHr(pKey->AppendLonglong(m_Offset));
            break;

        case PREMIGRATED_SIZE_KEY_TYPE:
            WsbAffirmHr(pKey->SetToBool(m_IsWaitingForClose));
            WsbAffirmHr(pKey->AppendLonglong(m_Size));
            WsbAffirmHr(pKey->AppendGuid(m_BagId));
            WsbAffirmHr(pKey->AppendLonglong(m_BagOffset));
            break;
        }
    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsarsc.h ===
#ifndef _FSARSC_
#define _FSARSC_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsarsc.h

Abstract:

    This module represents a file system resource (i.e. volume)
    for NTFS 5.0.

Author:

    Chuck Bardeen   [cbardeen]   1-Dec-1996

Revision History:

--*/

#include "resource.h"       // main symbols

#include "fsa.h"
#include "task.h"


#define FSA_VALIDATE_LOG_KEY_NAME OLESTR("SYSTEM\\CurrentControlSet\\Services\\Remote_Storage_File_System_Agent\\Validate")

// Usn journal Registry parameters
#define FSA_USN_MIN_SIZE                        OLESTR("UsnMinSize")    
#define FSA_USN_MAX_SIZE                        OLESTR("UsnMaxSize")    
#define FSA_USN_FREE_SPACE_FRACTION             OLESTR("UsnSizeFreeSpaceFraction")    
#define FSA_USN_TOTAL_SPACE_FRACTION            OLESTR("UsnSizeTotalSpaceFraction")      

// Usn journal defaults
#define FSA_USN_MIN_SIZE_DEFAULT                100                                 // in MB
#define FSA_USN_MAX_SIZE_DEFAULT                4096                                // in MB (4 GB)
#define FSA_USN_FREE_SPACE_FRACTION_DEFAULT     64                                  // 1/64 out of current free space
#define FSA_USN_TOTAL_SPACE_FRACTION_DEFAULT    64                                  // 1/64 out of total volume space

#define UNMANAGE_DB_PREFIX       OLESTR("Unmanage_")

/*++

Class Name:
    
    CFsaResource

Class Description:

    This class represents a file system resource (i.e. volume)
    for NTFS 5.0.

--*/

class CFsaResource : 
    public CWsbCollectable,
    public IFsaResource,
    public IFsaResourcePriv,
    public IConnectionPointContainerImpl<CFsaResource>,
    public IConnectionPointImpl<CFsaResource, &IID_IHsmEvent, CComDynamicUnkArray>,
    public CComCoClass<CFsaResource,&CLSID_CFsaResourceNTFS>
{
public:
    CFsaResource() {}
BEGIN_COM_MAP(CFsaResource)
    COM_INTERFACE_ENTRY(IFsaResource)
    COM_INTERFACE_ENTRY(IFsaResourcePriv)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_FsaResource)

// Connection Point
    BEGIN_CONNECTION_POINT_MAP(CFsaResource)
        CONNECTION_POINT_ENTRY(IID_IHsmEvent)
    END_CONNECTION_POINT_MAP()

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IHsmSystemState
    STDMETHOD( ChangeSysState )( HSM_SYSTEM_STATE* pSysState );

// IFsaResourcePriv
public:
    STDMETHOD(AddPremigratedSize)(LONGLONG size);
    STDMETHOD(AddTruncatedSize)(LONGLONG size);
    STDMETHOD(DoRecovery)(void);
    STDMETHOD(FilterSawOpen)(IHsmSession* pSession, IFsaFilterRecall* pRecall, 
                             OLECHAR* path, LONGLONG fileId,
                             LONGLONG requestOffset, LONGLONG requestSize, 
                             FSA_PLACEHOLDER* pPlaceholder, ULONG mode, 
                             FSA_RESULT_ACTION resultAction, DWORD threadId);
    STDMETHOD(FilterSawDelete)(GUID filterId, OLECHAR* path, LONGLONG size, 
                               FSA_PLACEHOLDER* pPlaceholder);
    STDMETHOD(GetPremigrated)(REFIID riid, void** ppDb);
    STDMETHOD(GetUnmanageDb)(REFIID riid, void** ppDb);
    STDMETHOD(Init)(IFsaServer* pFsaServer, OLECHAR* path, OLECHAR *dosName);
    STDMETHOD(RemovePremigratedSize)(LONGLONG size);
    STDMETHOD(RemoveTruncatedSize)(LONGLONG size);
    STDMETHOD(SetAlternatePath)(OLECHAR* name);
    STDMETHOD(SetIdentifier)(GUID id);
    STDMETHOD(SetName)(OLECHAR* name);
    STDMETHOD(SetOldPath)(OLECHAR* oldPath);
    STDMETHOD(SetPath)(OLECHAR* name);
    STDMETHOD(SetUserFriendlyName)(OLECHAR* name);
    STDMETHOD(SetStickyName)(OLECHAR* name);
    STDMETHOD(UpdateFrom)(IFsaServer* pServer, IFsaResource* pResource);
    STDMETHOD(InitializeUnmanageDb)(void);
    STDMETHOD(TerminateUnmanageDb)(void);

// IFsaResource
public:
    STDMETHOD(AddPremigrated)(IFsaScanItem* pScanItem, LONGLONG offset, LONGLONG size, 
                              BOOL isWaitingForClose, LONGLONG usn);
    STDMETHOD(AddTruncated)(IFsaScanItem* pScanItem, LONGLONG offset, LONGLONG size);
    STDMETHOD(BeginSession)(OLECHAR* name, ULONG logControl, ULONG runId, ULONG subRunId, 
                            IHsmSession** ppSession);
    STDMETHOD(BeginValidate)(void);
    STDMETHOD(CompareBy)(FSA_RESOURCE_COMPARE by);
    STDMETHOD(CompareToAlternatePath)(OLECHAR* name, SHORT* pResult);
    STDMETHOD(CompareToIdentifier)(GUID id, SHORT* pResult);
    STDMETHOD(CompareToIResource)(IFsaResource* pResource, SHORT* pResult);
    STDMETHOD(CompareToName)(OLECHAR* name, SHORT* pResult);
    STDMETHOD(CompareToUserName)(OLECHAR* userName, SHORT* pResult);
    STDMETHOD(CompareToPath)(OLECHAR* name, SHORT* pResult);
    STDMETHOD(CompareToSerial)(ULONG serial, SHORT* pResult);
    STDMETHOD(CompareToStickyName)(OLECHAR* name, SHORT* pResult);
    STDMETHOD(CreateDefaultRules)(void);
    STDMETHOD(EndSession)(IHsmSession* pSession);
    STDMETHOD(EndValidate)(HSM_JOB_STATE state);
    STDMETHOD(EnumDefaultRules)(IWsbEnum** ppEnum);
    STDMETHOD(FindFirst)(OLECHAR* path, IHsmSession* pSession, IFsaScanItem** ppScanItem);
    STDMETHOD(FindFirstInRPIndex)(IHsmSession* pSession, IFsaScanItem** ppScanItem);
    STDMETHOD(FindFirstInDbIndex)(IHsmSession* pSession, IFsaScanItem** ppScanItem);
    STDMETHOD(FindNext)(IFsaScanItem* pScanItem);
    STDMETHOD(FindNextInRPIndex)(IFsaScanItem* pScanItem);
    STDMETHOD(FindNextInDbIndex)(IFsaScanItem* pScanItem);
    STDMETHOD(FindFileId)(LONGLONG fileId, IHsmSession* pSession, 
                          IFsaScanItem** ppScanItem);
    STDMETHOD(FindObjectId)(LONGLONG objIdHi, LONGLONG objIdLo, IHsmSession* pSession, 
                            IFsaScanItem** ppScanItem);
    STDMETHOD(GetAlternatePath)(OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetDefaultRules)(IWsbCollection** ppCollection);
    STDMETHOD(GetDbPath)(OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetUnmanageDbPath)(OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetFreeLevel)(ULONG* pLevel);
    STDMETHOD(GetFsName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetHsmEngine)(IHsmFsaTskMgr** ppEngine);
    STDMETHOD(GetHsmLevel)(ULONG* pLevel);
    STDMETHOD(GetIdentifier)(GUID* pId);
    STDMETHOD(GetLogicalName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetManageableItemLogicalSize)(LONGLONG* pSize);
    STDMETHOD(GetManageableItemAccessTime)(BOOL* isRelative, FILETIME* pTime);
    STDMETHOD(GetManagingHsm)(GUID* pId);
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetOldPath)(OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetPath)(OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetSerial)(ULONG *serial);
    STDMETHOD(GetSizes)(LONGLONG* pTotal, LONGLONG* pFree, LONGLONG* pPremigrated, 
                        LONGLONG* pTruncated);
    STDMETHOD(GetTruncator)(IFsaTruncator** ppTruncator);
    STDMETHOD(GetUncPath)(OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetUserFriendlyName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetStickyName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(IsActive)(void);
    STDMETHOD(IsAvailable)(void);
    STDMETHOD(IsDeletePending)(void);
    STDMETHOD(IsManaged)(void);
    STDMETHOD(Manage)(IFsaScanItem* pScanItem, LONGLONG offset, LONGLONG size, 
                      GUID storagePoolId, BOOL truncate);
    STDMETHOD(ManagedBy)(GUID hsmId, ULONG hsmLevel, BOOL release);
    STDMETHOD(NeedsRepair)(void);
    STDMETHOD(ProcessResult)(IFsaPostIt* pResult);
    STDMETHOD(Recall)(IFsaScanItem* pScanItem, LONGLONG offset, LONGLONG size, 
                      BOOL deletePlaceholder);
    STDMETHOD(RemovePremigrated)(IFsaScanItem* pScanItem, LONGLONG offset, LONGLONG size);
    STDMETHOD(RemoveTruncated)(IFsaScanItem* pScanItem, LONGLONG offset, LONGLONG size);
    STDMETHOD(SetHsmLevel)(ULONG level);
    STDMETHOD(SetIsActive)(BOOL isActive);
    STDMETHOD(SetIsAvailable)(BOOL isAvailable);
    STDMETHOD(SetIsDeletePending)(BOOL isDeletePending);
    STDMETHOD(SetManageableItemLogicalSize)(LONGLONG pSize);
    STDMETHOD(SetManageableItemAccessTime)(BOOL isRelative, FILETIME pTime);
    STDMETHOD(SetSerial)(ULONG serial);
    STDMETHOD(StartJob)(OLECHAR* startingPath, IHsmSession* pSession);
    STDMETHOD(StartJobSession)(IHsmJob* pJob, ULONG subRunId, IHsmSession** ppSession);
    STDMETHOD(Validate)(IFsaScanItem* pScanItem, LONGLONG offset, LONGLONG size, 
                        LONGLONG usn);
    STDMETHOD(SetupValidateJob)(SYSTEMTIME runtime);
    STDMETHOD(CheckForValidate)(BOOL bForceValidate);
    STDMETHOD(GetUsnId)(ULONGLONG *usnId);
    STDMETHOD(ValidateForTruncate)(IFsaScanItem* pScanItem, LONGLONG offset, LONGLONG size, 
                        LONGLONG usn);

// Local Methods
    void OnStateChange( void );
protected:
    STDMETHOD(CheckForJournal)(BOOL *pValidateNeeded);
    STDMETHOD(InitializePremigrationList)(BOOL bStartValidateJob);
    HRESULT ReadIdentifier(void);
    HRESULT WriteIdentifier(void);

protected:
    GUID                        m_id;
    CWsbStringPtr               m_oldPath;      // Previous value for 'm_path'.
    CWsbStringPtr               m_path;         // Drive letter (with backslash) if named 
                                                // volume, otherwise same as m_stickyName.
    CWsbStringPtr               m_alternatePath;
    CWsbStringPtr               m_name;         // Volume name.
    CWsbStringPtr               m_userName;     // Drive letter (with backslash) if named 
                                                // volume, otherwise NULL.
    CWsbStringPtr               m_stickyName;   // Long ugly PNP name (without \\?\ prefix)
    CWsbStringPtr               m_fsName;       // File system type (e.g., NTFS).
    BOOL                        m_isActive;
    BOOL                        m_isAvailable;  // If volume is manageable.
    BOOL                        m_isDeletePending;
    BOOL                        m_isRecovered;
    BOOL                        m_isDbInitialized;
    ULONG                       m_maxComponentLength;
    ULONG                       m_fsFlags;
    FSA_RESOURCE_COMPARE        m_compareBy;
    GUID                        m_managingHsm;
    ULONG                       m_hsmLevel;
    LONGLONG                    m_premigratedSize;
    LONGLONG                    m_truncatedSize;
    LONGLONG                    m_oldPremigratedSize;
    LONGLONG                    m_oldTruncatedSize;
    BOOL                        m_isDoingValidate;
    LONGLONG                    m_manageableItemLogicalSize;
    BOOL                        m_manageableItemAccessTimeIsRelative;
    FILETIME                    m_manageableItemAccessTime;
    ULONGLONG                   m_usnJournalId;
    LONGLONG                    m_lastUsnId;
    IFsaServer*                 m_pFsaServer;       // Parent Pointer, Weak Reference
                                                    // (do not AddRef() it)
    unsigned long               m_serial;           // Serial number of volume 
    CComPtr<IFsaPremigratedDb>  m_pPremigrated;
    CComPtr<IHsmFsaTskMgr>      m_pHsmEngine;
    CComPtr<IFsaTruncator>      m_pTruncator;
    CComPtr<IWsbCollection>     m_pDefaultRules;

    CComPtr<IFsaUnmanageDb>     m_pUnmanageDb;
    BOOL                        m_isUnmanageDbInitialized;
};

#endif  // _FSARSC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsarsc.cpp ===
/*++

(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsarsc.cpp

Abstract:

    This class represents a file system resource (i.e. volume)
    for NTFS 5.0.

Author:

    Chuck Bardeen   [cbardeen]   1-Dec-1996

--*/


#include "stdafx.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_FSA

#include "wsb.h"
#include "fsa.h"
#include "fsaprem.h"
#include "fsaprv.h"
#include "fsarcvy.h"
#include "fsarsc.h"
#include "fsasrvr.h"
#include "engine.h"
#include "HsmConn.h"
#include "job.h"
#include "task.h"
#include "mstask.h"
#include <shlobj.h>

static short g_InstanceCount = 0;
static DWORD g_ThreadId;


DWORD FsaStartOnStateChange(
    void* pVoid
    )
/*++

    Note: This is done as a separate thread to avoid a deadlock situation

--*/
{
    ((CFsaResource*) pVoid)->OnStateChange();
    return(0);
}


HRESULT
CFsaResource::AddPremigrated(
    IN IFsaScanItem* pScanItem,
    IN LONGLONG offset,
    IN LONGLONG size,
    IN BOOL isWaitingForClose,
    IN LONGLONG usn
    )

/*++

Implements:

  IFsaResource::AddPremigrated().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IWsbDbSession>          pDbSession;
    CComPtr<IFsaPremigratedRec>     pRec;

    WsbTraceIn(OLESTR("CFsaResource::AddPremigrated"), OLESTR("offset = %I64d, size = %I64d, waiting = <%ls>, usn = <%I64d>"),
            offset, size, WsbBoolAsString(isWaitingForClose), usn);

    try {

        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAffirm(m_pPremigrated != NULL, E_UNEXPECTED);
        WsbAffirm(m_isDbInitialized, S_FALSE);  // Not an necessarily an error

        // Open the data base
        WsbAffirmHr(m_pPremigrated->Open(&pDbSession));

        try {

            WsbAffirmHr(m_pPremigrated->GetEntity(pDbSession, PREMIGRATED_REC_TYPE, IID_IFsaPremigratedRec, (void**) &pRec));
            WsbAffirmHr(pRec->UseKey(PREMIGRATED_BAGID_OFFSETS_KEY_TYPE));
            WsbAffirmHr(pRec->SetFromScanItem(pScanItem, offset, size, isWaitingForClose));
            WsbAffirmHr(pRec->SetFileUSN(usn));

            // If the key doesn't exist, then create it.
            if (FAILED(pRec->FindEQ())) {
                WsbAffirmHr(pRec->MarkAsNew());
                WsbAffirmHr(pRec->Write());

                // Add the size of the section migrated to the amount of premigrated data.
                m_premigratedSize += size;
            }

            // Otherwise, update it.
            else {
                LONGLONG        itemSize;

                WsbAffirmHr(pRec->GetSize(&itemSize));
                WsbAffirmHr(pRec->SetFromScanItem(pScanItem, offset, size, isWaitingForClose));
                WsbAffirmHr(pRec->Write());
                if (m_isDoingValidate) {
                    m_premigratedSize += size;
                } else if (itemSize != size) {
                    m_premigratedSize = max(0, (m_premigratedSize - itemSize) + size);
                }
            }
            m_isDirty = TRUE;

        } WsbCatch(hr);

        // Close the data base
        WsbAffirmHr(m_pPremigrated->Close(pDbSession));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::AddPremigrated"),
            OLESTR("hr = <%ls>, m_premigratedSize = %I64d"), WsbHrAsString(hr),
            m_premigratedSize);

    return(hr);
}


HRESULT
CFsaResource::AddPremigratedSize(
    IN LONGLONG size
    )

/*++

Implements:

  IFsaResourcePriv::AddPremigratedSize().

--*/
{
    WsbTraceIn(OLESTR("CFsaResource::AddPremigratedSize"), OLESTR("m_premigratedSize = %I64d"), m_premigratedSize);

    m_isDirty = TRUE;
    m_premigratedSize += size;

    WsbTraceOut(OLESTR("CFsaResource::AddPremigratedSize"), OLESTR("m_premigratedSize = %I64d"), m_premigratedSize);
    return(S_OK);
}


HRESULT
CFsaResource::AddTruncated(
    IN IFsaScanItem* /*pScanItem*/,
    IN LONGLONG /*offset*/,
    IN LONGLONG size
    )

/*++

Implements:

  IFsaResource::AddTruncated().

--*/
{
    HRESULT                         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::AddTruncated"), OLESTR(""));

    try {

        m_truncatedSize += size;
        m_isDirty = TRUE;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::AddTruncated"),
            OLESTR("hr = <%ls>, m_truncatedSize = %I64d"), WsbHrAsString(hr),
            m_truncatedSize);

    return(hr);
}


HRESULT
CFsaResource::AddTruncatedSize(
    IN LONGLONG size
    )

/*++

Implements:

  IFsaResource::AddTruncatedSize().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::AddTruncatedSize"), OLESTR(""));

    try {

        m_truncatedSize += size;
        m_isDirty = TRUE;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::AddTruncatedSize"), OLESTR("hr = <%ls>, m_truncatedSize = %I64d"), WsbHrAsString(hr), m_truncatedSize);

    return(hr);
}


HRESULT
CFsaResource::BeginSession(
    IN OLECHAR* name,
    IN ULONG logControl,
    IN ULONG runId,
    IN ULONG subRunId,
    OUT IHsmSession** ppSession
    )

/*++

Implements:

  IFsaResource::BeginSession().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmSession>    pSession;
    BOOL                    bLog = TRUE;

    WsbTraceIn(OLESTR("CFsaResource::BeginSession"), OLESTR("name = <%ls>, Log = <%lu>, runId = <%lu>, subRunId = <%lu>"),
            (OLECHAR *)name, logControl, runId, subRunId);
    try {

        WsbAssert(0 != ppSession, E_POINTER);
        *ppSession = 0;

        // Create and Initialize a session object.
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmSession, 0, CLSCTX_SERVER, IID_IHsmSession, (void**) &pSession));
        WsbAffirmHr(pSession->Start(name, logControl, m_managingHsm, 0, (IFsaResource*) this, runId, subRunId));

        // Since begin sesson doesn't use a formal scan, indicate that the scan phase has
        // started.
        WsbAffirmHr(pSession->ProcessState(HSM_JOB_PHASE_SCAN, HSM_JOB_STATE_STARTING, OLESTR(""),bLog));

        // Return the session to the caller.
        *ppSession = pSession;
        pSession->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::BeginSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::BeginValidate(
    void
    )

/*++

Implements:

  IFsaResource::BeginValidate().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::BeginValidate"),
            OLESTR("PremigratedSize = %I64d, TruncatedSize = %I64d"),
            m_premigratedSize, m_truncatedSize);

    try {

        m_oldPremigratedSize = m_premigratedSize;
        m_premigratedSize = 0;
        m_oldTruncatedSize = m_truncatedSize;
        m_truncatedSize = 0;
        m_isDoingValidate = TRUE;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::BeginValidate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::CheckForJournal(
    BOOL *pValidateNeeded
    )

/*++

Implements:

  IFsaResource::CheckForJournal

--*/
{
    HRESULT         hr = S_OK;
    ULONGLONG       usnSize, usnId;
    DWORD           spc, bps, freeC, totalC;
    CWsbStringPtr   name;


    WsbTraceIn(OLESTR("CFsaResource::CheckForJournal"),OLESTR("volume = %ls"), m_path);
    //
    // First we check the USN journal and determine if it is out of date.
    //
    try {
        hr = WsbGetUsnJournalId(m_path, &usnId);

        if (S_OK == hr) {
            WsbTrace(OLESTR("CFsaResource::CheckForJournal - USN Journal ID = %I64x\n"),
                usnId);
            if (0 != m_usnJournalId && usnId != m_usnJournalId) {
                WsbTrace(OLESTR("CFsaResource::CheckForJournal - USN Journal ID changed from %I64\n"),
                        m_usnJournalId);
                *pValidateNeeded = TRUE;        // No match - we must validate
                // WsbAffirmHr(E_FAIL);
            }
        } else if (WSB_E_NOTFOUND == hr) {

            hr = S_OK;

            //  The journal is not active, try to create it.
            //  Make the max USN journal 1/64 the volume size.
            //
            WsbTrace(OLESTR("CFsaResource::CheckForJournal - Failed to get the journal ID for %ws\n"), m_path);

            name = m_path;
            WsbAffirmHr(name.Prepend(OLESTR("\\\\?\\")));
            if (GetDiskFreeSpace(name, &spc, &bps, &freeC, &totalC)) {
                ULONGLONG   freeBytes, totalBytes;
                ULONGLONG   minSize, maxSize;
                ULONG       freeSpaceFraction, totalSpaceFraction, minSizeMB, maxSizeMB;

                WsbTrace(OLESTR("CFsaResource::CheckForJournal - Got disk free space\n"));

                freeBytes = (ULONGLONG) spc * (ULONGLONG) bps * (ULONGLONG) freeC;
                totalBytes = (ULONGLONG) spc * (ULONGLONG) bps * (ULONGLONG) totalC;

                // Get constants for USN size calculation
                minSizeMB = FSA_USN_MIN_SIZE_DEFAULT;
                WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, FSA_REGISTRY_PARMS, FSA_USN_MIN_SIZE,
                        &minSizeMB));
                minSize = (ULONGLONG)minSizeMB * (ULONGLONG)0x100000;

                maxSizeMB = FSA_USN_MAX_SIZE_DEFAULT;
                WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, FSA_REGISTRY_PARMS, FSA_USN_MAX_SIZE,
                        &maxSizeMB));
                maxSize = (ULONGLONG)maxSizeMB * (ULONGLONG)0x100000;

                freeSpaceFraction = FSA_USN_FREE_SPACE_FRACTION_DEFAULT;
                WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, FSA_REGISTRY_PARMS, FSA_USN_FREE_SPACE_FRACTION,
                        &freeSpaceFraction));

                totalSpaceFraction = FSA_USN_TOTAL_SPACE_FRACTION_DEFAULT;
                WsbAffirmHr(WsbRegistryValueUlongAsString(NULL, FSA_REGISTRY_PARMS, FSA_USN_TOTAL_SPACE_FRACTION,
                        &totalSpaceFraction));

                // Get a max value out of fraction-of-free=space and a constant
                //  This ensures that volume with little free space still gets a decent journal size
                usnSize = MAX( (freeBytes / freeSpaceFraction) , minSize );

                // Get a min value out of fraction-of-total-bytes and previous number
                //  This ensures that small volumes don't allocate unproportional size for the journal
                usnSize = MIN ( (totalBytes / totalSpaceFraction) , usnSize);

                // Get a min of an NTFS upper-limit const and previous number
                //  This ensures that large empty volumes don't allocate a too large journal
                usnSize = MIN ( maxSize , usnSize);

                WsbTrace(OLESTR("CFsaResource::CheckForJournal - Create USN journal - %u\n"), usnSize);

                WsbAffirmHr(WsbCreateUsnJournal(m_path, usnSize));
                WsbAffirmHr(WsbGetUsnJournalId(m_path, &m_usnJournalId));
                WsbTrace(OLESTR("CFsaResource::CheckForJournal - USN Journal ID = %I64x\n"),
                    m_usnJournalId);
            } else {
                DWORD   lErr;

                lErr = GetLastError();
                WsbTrace(OLESTR("CFsaResource::CheckForJournal - GetDiskFreeSpace failed - %x\n"), lErr);
                hr = E_FAIL;
            }
        }
    } WsbCatch(hr);


    if (hr != S_OK) {
        //
        // Problem - could not find or create the USN journal - we refuse to
        // run without it
        //
        WsbTrace(OLESTR("CFsaResource::CheckForJournal - ERROR creating/accessing the USN journal for %ws\n"),
                m_path);
        if (WSB_E_USNJ_CREATE_DISK_FULL == hr) {
            WsbLogEvent(FSA_MESSAGE_CANNOT_CREATE_USNJ_DISK_FULL, 0, NULL,
                        (OLECHAR *) m_path, NULL);
        } else if (WSB_E_USNJ_CREATE == hr) {
            WsbLogEvent(FSA_MESSAGE_CANNOT_CREATE_USNJ, 0, NULL,
                        (OLECHAR *) m_path, NULL);
        } else {
            WsbLogEvent(FSA_MESSAGE_CANNOT_ACCESS_USNJ, 0, NULL,
                        WsbHrAsString(hr), (OLECHAR *) m_path, NULL);
        }
        m_usnJournalId = (ULONGLONG) 0;

    }

    WsbTraceOut(OLESTR("CFsaResource::CheckForJournal"),OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaResource::CheckForValidate(BOOL bForceValidate)

/*++

Implements:

  IFsaResource::CheckForValidate

--*/
{
    HRESULT         hr = S_OK;
    SYSTEMTIME      sysTime;
    FILETIME        curTime;
    LARGE_INTEGER   ctime;
    CWsbStringPtr   tmpString;
    BOOL            validateNeeded = FALSE;     // Start out assuming no validate needed

    WsbTraceIn(OLESTR("CFsaResource::CheckForValidate"),OLESTR("bForceValidate"),
            WsbBoolAsString(bForceValidate));

    try {

        //
        // First we check the USN journal and determine if it is out of date.
        //
        WsbAffirmHr(CheckForJournal(&validateNeeded));

        //
        // Check the registry to see if a validate job needs to be run.  If the filter detected
        // a HSM reparse point getting set and it was not by us it sets a registry value to
        // indicate it.
        //
        try {

            WsbAffirmHr(tmpString.Alloc(32));
            swprintf((OLECHAR *) tmpString, L"%x", m_serial);
            WsbTrace(L"CFsaResource::CheckForValidate - Checking registry for validate - %ws\\%ws\n",
                FSA_VALIDATE_LOG_KEY_NAME, (OLECHAR *) tmpString);

            hr = WsbGetRegistryValueData(NULL, FSA_VALIDATE_LOG_KEY_NAME,
                    tmpString, (BYTE *) &ctime, sizeof(ctime), NULL);

            if ((hr == S_OK) || validateNeeded || bForceValidate) {
                //
                // Regardless of what value the registry entry was we set up the job for 2 hours from now.
                // The actual event may have been well in the past and the task scheduler will not like a
                // time in the past as the start time.
                //
                GetLocalTime(&sysTime);
                WsbAffirmStatus(SystemTimeToFileTime(&sysTime, &curTime));
                ctime.LowPart = curTime.dwLowDateTime;
                ctime.HighPart = curTime.dwHighDateTime;

                if (validateNeeded || bForceValidate) {
                    ctime.QuadPart += WSB_FT_TICKS_PER_MINUTE * 5;  // 5 Minutes from now if the USN journal changed
                } else {
                    ctime.QuadPart += WSB_FT_TICKS_PER_HOUR * 2;    // 2 Hours from now if restore activity took place
                }
                curTime.dwLowDateTime = ctime.LowPart;
                curTime.dwHighDateTime = ctime.HighPart;
                WsbAffirmStatus(FileTimeToSystemTime(&curTime, &sysTime));
                WsbAffirmHr(SetupValidateJob(sysTime));
                WsbLogEvent(FSA_MESSAGE_AUTO_VALIDATE, 0, NULL,
                        (OLECHAR *) m_path, NULL);
            } else {
                WsbTrace(L"CFsaResource::CheckForValidate - Registry entry not there - %ws\n", WsbHrAsString(hr));
            }
            hr = S_OK;
        } WsbCatchAndDo(hr,
            //
            // Log an event if we fail to set up the job
            //
            WsbTrace(L"CFsaResource::CheckForValidate - Failed to set the job - %x\n", hr);
            WsbLogEvent(FSA_MESSAGE_AUTOVALIDATE_SCHEDULE_FAILED, 0, NULL, WsbAbbreviatePath(m_path, 120), NULL);

        );

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::CheckForValidate"),OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CFsaResource::CompareBy(
    FSA_RESOURCE_COMPARE by
    )

/*++

Implements:

  IFsaResource::CompareBy().

--*/
{
    HRESULT                 hr = S_OK;

    m_compareBy = by;

    m_isDirty = TRUE;

    return(hr);
}


HRESULT
CFsaResource::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IFsaResource>   pResource;

    WsbTraceIn(OLESTR("CFsaResource::CompareTo"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        // We need the IFsaResource interface to get the value of the object.
        WsbAffirmHr(pUnknown->QueryInterface(IID_IFsaResource, (void**) &pResource));

        // Compare the rules.
        hr = CompareToIResource(pResource, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"),
                        WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CFsaResource::CompareToAlternatePath(
    IN OLECHAR* path,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaResource::CompareToAlternatePath().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CFsaResource::CompareToAlternatePath"), OLESTR("path = <%ls>"), (OLECHAR *)path);

    try {

        WsbTrace(OLESTR("CFsaResource::CompareToAlternatePath - Compare %ls to %ls\n"),
            (WCHAR *) m_alternatePath, (WCHAR *) path);

        // Compare the path.
        aResult = WsbSign( _wcsicmp(m_alternatePath, path) );

        if (0 != aResult) {
            hr = S_FALSE;
        }

        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::CompareToAlternatePath"), OLESTR("hr = <%ls>, result = <%u>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CFsaResource::CompareToIdentifier(
    IN GUID id,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaResource::CompareToIdentifier().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CFsaResource::CompareToIdentifier"), OLESTR(""));

    try {

        aResult = WsbSign( memcmp(&m_id, &id, sizeof(GUID)) );

        if (0 != aResult) {
            hr = S_FALSE;
        }

        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::CompareToIdentifier"), OLESTR("hr = <%ls>, result = <%u>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CFsaResource::CompareToIResource(
    IN IFsaResource* pResource,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaResource::CompareToIResource().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   name;
    GUID            id;
    ULONG           serial;

    WsbTraceIn(OLESTR("CFsaResource::CompareToIResource"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pResource, E_POINTER);

        // Either compare the name or the id.
        if (m_compareBy == FSA_RESOURCE_COMPARE_PATH) {
            WsbAffirmHr(pResource->GetPath(&name, 0));
            hr = CompareToPath(name, pResult);
        } else if (m_compareBy == FSA_RESOURCE_COMPARE_ALTERNATEPATH) {
            WsbAffirmHr(pResource->GetAlternatePath(&name, 0));
            hr = CompareToAlternatePath(name, pResult);
        } else if (m_compareBy == FSA_RESOURCE_COMPARE_ID) {
            WsbAffirmHr(pResource->GetIdentifier(&id));
            hr = CompareToIdentifier(id, pResult);
        } else if (m_compareBy == FSA_RESOURCE_COMPARE_NAME) {
            WsbAffirmHr(pResource->GetName(&name, 0));
            hr = CompareToName(name, pResult);
        } else if (m_compareBy == FSA_RESOURCE_COMPARE_SERIAL) {
            WsbAffirmHr(pResource->GetSerial(&serial));
            hr = CompareToSerial(serial, pResult);
        } else if (m_compareBy == FSA_RESOURCE_COMPARE_USER_NAME) {
            WsbAffirmHr(pResource->GetUserFriendlyName(&name, 0));
            hr = CompareToUserName(name, pResult);
        } else if (m_compareBy == FSA_RESOURCE_COMPARE_STICKY_NAME) {
            WsbAffirmHr(pResource->GetStickyName(&name, 0));
            hr = CompareToStickyName(name, pResult);
        } else {
            WsbAssert(FALSE, E_FAIL);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::CompareToIResource"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CFsaResource::CompareToName(
    IN OLECHAR* name,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaResource::CompareToName().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CFsaResource::CompareToName"), OLESTR(""));

    try {

        // Compare the path.
        aResult = WsbSign( _wcsicmp(m_name, name) );

        if (0 != aResult) {
            hr = S_FALSE;
        }

        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::CompareToName"), OLESTR("hr = <%ls>, result = <%u>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CFsaResource::CompareToUserName(
    IN OLECHAR* name,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaResource::CompareToUserName().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CFsaResource::CompareToUserName"), OLESTR(""));

    try {

        // Compare the path.
        aResult = WsbSign( _wcsicmp(m_userName, name) );

        if (0 != aResult) {
            hr = S_FALSE;
        }

        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::CompareToUserName"), OLESTR("hr = <%ls>, result = <%u>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CFsaResource::CompareToPath(
    IN OLECHAR* path,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaResource::CompareToPath().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CFsaResource::CompareToPath"), OLESTR(""));

    try {

        // Compare the path.
        aResult = WsbSign( _wcsicmp(m_path, path) );

        if (0 != aResult) {
            hr = S_FALSE;
        }

        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::CompareToPath"), OLESTR("hr = <%ls>, result = <%u>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CFsaResource::CompareToSerial(
    IN ULONG serial,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaResource::CompareToSerial().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CFsaResource::CompareToSerial"), OLESTR(""));

    try {

        WsbTrace(OLESTR("CFsaResource::CompareToSerial - Compare %lu to %lu\n"),
            m_serial, serial);

        // Compare the path.
        if (m_serial == serial) {
            aResult = 0;
        } else {
            aResult = 1;
        }

        if (0 != aResult) {
            hr = S_FALSE;
        }

        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::CompareToSerial"), OLESTR("hr = <%ls>, result = <%u>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CFsaResource::CompareToStickyName(
    IN OLECHAR* name,
    OUT SHORT* pResult
    )

/*++

Implements:

  IFsaResource::CompareToStickyName().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CFsaResource::CompareToStickyName"), OLESTR(""));

    try {

        WsbTrace(OLESTR("CFsaResource::CompareToStickyName - Compare %ws to %ws\n"),
            (WCHAR *) m_stickyName, name);

        aResult = WsbSign( _wcsicmp(m_stickyName, name) );

        if (0 != aResult) {
            hr = S_FALSE;
        }

        if (0 != pResult) {
            *pResult = aResult;
        }

        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::CompareToStickyName"), OLESTR("hr = <%ls>, result = <%u>"), WsbHrAsString(hr), aResult);

    return(hr);
}

static
HRESULT
AddExclusion(
    const OLECHAR*         DrivePath,
    IWsbIndexedCollection* pDefaultRules,
    const OLECHAR*         ExcludePath,
    BOOL                   UserRule
)
{
    HRESULT hr = S_OK;
    try {

        // If this is resource matches the drive of the folder path, exclude the path.
        if( _wcsnicmp( DrivePath, ExcludePath, 1 ) == 0 ) {

            CComPtr<IHsmRule>               pRule;
            CComPtr<IWsbCollection>         pCollection;
            CComPtr<IHsmCriteria>           pCriteria;

            WsbAffirmHr( CoCreateInstance( CLSID_CHsmRule, NULL, CLSCTX_SERVER, IID_IHsmRule, (void**) &pRule ) );
            WsbAffirmHr( pRule->SetIsInclude( FALSE ) );
            WsbAffirmHr( pRule->SetIsUserDefined( UserRule ) );
            WsbAffirmHr( pRule->SetPath( (OLECHAR*) &ExcludePath[2] ) );
            WsbAffirmHr( pRule->SetName( OLESTR("*") ) );
    
            WsbAssertHr( CoCreateInstance( CLSID_CHsmCritAlways, NULL, CLSCTX_SERVER, IID_IHsmCriteria, (void**) &pCriteria ) );
            WsbAssertHr( pRule->Criteria( &pCollection ) );
            WsbAssertHr( pCollection->Add( pCriteria ) );
    
            WsbAffirmHr( pDefaultRules->Append( pRule ) );
            WsbTrace( L"Excluding <%ls>, <%ls>\n", ExcludePath, UserRule ? "UserRule" : "SystemRule" );

        }

    } WsbCatch( hr );
    return( hr );
}


static
HRESULT
AddShellFolderExclusion(
    const OLECHAR*         DrivePath,
    IWsbIndexedCollection* pDefaultRules,
    int                    FolderId,
    BOOL                   UserRule
)
{
    HRESULT hr = S_OK;
    try {

        OLECHAR folderPath[_MAX_PATH] = L"";
        WsbAffirmHrOk( SHGetFolderPath( 0, FolderId, 0, 0, folderPath ) );
        WsbAffirmHr( AddExclusion( DrivePath, pDefaultRules, folderPath, UserRule ) );

    } WsbCatch( hr );
    return( hr );
}


static
HRESULT
AddRegistryPathExclusion(
    const OLECHAR*         DrivePath,
    IWsbIndexedCollection* pDefaultRules,
    HKEY                   hKeyRoot,
    const OLECHAR*         KeyName,
    const OLECHAR*         ValueName,
    BOOL                   UserRule
)
{
    HRESULT hr = S_OK;
    try {

        DWORD   pathSize = 0;
        CWsbStringPtr folderPath, regValue;

        //
        // Open the Key
        //
        CRegKey key;
        WsbAffirmWin32( key.Open( hKeyRoot, KeyName, KEY_QUERY_VALUE ) );

        //
        // Get the size of the value's data and allocatate buffer
        //
        WsbAffirmWin32( key.QueryValue( 0, ValueName, &pathSize ) );
        WsbAffirmHr( regValue.Alloc( ( pathSize / sizeof( OLECHAR ) ) + 1 ) );

        //
        // Get the data and expand any environment variables
        //
        WsbAffirmWin32( key.QueryValue( regValue, ValueName, &pathSize ) );

        pathSize = ExpandEnvironmentStrings( regValue, 0, 0 );
        WsbAffirmHr( folderPath.Alloc( pathSize ) );
        pathSize = ExpandEnvironmentStrings( regValue, folderPath, pathSize );
        WsbAffirmStatus( pathSize > 0 );

        //
        // And finally add the exclusion
        //
        WsbAffirmHr( AddExclusion( DrivePath, pDefaultRules, folderPath, UserRule ) );

    } WsbCatch( hr );
    return( hr );
}


HRESULT
CFsaResource::CreateDefaultRules(
    void
    )

/*++

Implements:

  IFsaResource::CreateDefaultRules().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IHsmRule>               pRule;
    CComPtr<IWsbCollection>         pCollection;
    CComPtr<IWsbIndexedCollection>  pDefaultRules;
    CComPtr<IHsmCriteria>           pCriteria;

    WsbTraceIn(OLESTR("CFsaResource::CreateDefaultRules"), OLESTR(""));
    try {

        // Since we are recreating back to the default rules, remove all the existing default
        // rules.
        //
        // NOTE: This will cause any extra rules (non-default) to be removed.
        WsbAffirmHr(m_pDefaultRules->RemoveAllAndRelease());

        // We need to preserve the order of the rules, so use the indexed collection interface.
        WsbAffirmHr(m_pDefaultRules->QueryInterface(IID_IWsbIndexedCollection, (void**) &pDefaultRules));

        // Create rules to exclude the following file types:
        //  *.cur   -   cursors
        //  *.ico   -   icons
        //  *.lnk   -   shortcuts
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmRule, NULL, CLSCTX_SERVER, IID_IHsmRule, (void**) &pRule));
        WsbAffirmHr(pRule->SetIsInclude(FALSE));
        WsbAffirmHr(pRule->SetIsUserDefined(FALSE));
        WsbAffirmHr(pRule->SetPath(OLESTR("\\")));
        WsbAffirmHr(pRule->SetName(OLESTR("*.cur")));

        WsbAssertHr(CoCreateInstance(CLSID_CHsmCritAlways, NULL, CLSCTX_SERVER, IID_IHsmCriteria, (void**) &pCriteria));
        WsbAssertHr(pRule->Criteria(&pCollection));
        WsbAssertHr(pCollection->Add(pCriteria));

        WsbAffirmHr(pDefaultRules->Append(pRule));
        pCollection = 0;
        pCriteria = 0;
        pRule = 0;

        WsbAffirmHr(CoCreateInstance(CLSID_CHsmRule, NULL, CLSCTX_SERVER, IID_IHsmRule, (void**) &pRule));
        WsbAffirmHr(pRule->SetIsInclude(FALSE));
        WsbAffirmHr(pRule->SetIsUserDefined(FALSE));
        WsbAffirmHr(pRule->SetPath(OLESTR("\\")));
        WsbAffirmHr(pRule->SetName(OLESTR("*.ico")));

        WsbAssertHr(CoCreateInstance(CLSID_CHsmCritAlways, NULL, CLSCTX_SERVER, IID_IHsmCriteria, (void**) &pCriteria));
        WsbAssertHr(pRule->Criteria(&pCollection));
        WsbAssertHr(pCollection->Add(pCriteria));

        WsbAffirmHr(pDefaultRules->Append(pRule));
        pCollection = 0;
        pCriteria = 0;
        pRule = 0;

        WsbAffirmHr(CoCreateInstance(CLSID_CHsmRule, NULL, CLSCTX_SERVER, IID_IHsmRule, (void**) &pRule));
        WsbAffirmHr(pRule->SetIsInclude(FALSE));
        WsbAffirmHr(pRule->SetIsUserDefined(FALSE));
        WsbAffirmHr(pRule->SetPath(OLESTR("\\")));
        WsbAffirmHr(pRule->SetName(OLESTR("*.lnk")));

        WsbAssertHr(CoCreateInstance(CLSID_CHsmCritAlways, NULL, CLSCTX_SERVER, IID_IHsmCriteria, (void**) &pCriteria));
        WsbAssertHr(pRule->Criteria(&pCollection));
        WsbAssertHr(pCollection->Add(pCriteria));

        WsbAffirmHr(pDefaultRules->Append(pRule));
        pCollection = 0;
        pCriteria = 0;
        pRule = 0;

        WsbAffirmHr( AddShellFolderExclusion( m_path, pDefaultRules, CSIDL_WINDOWS, FALSE ) );
        WsbAffirmHr( AddShellFolderExclusion( m_path, pDefaultRules, CSIDL_PROGRAM_FILES, TRUE ) );\

        WsbAffirmHr( AddRegistryPathExclusion( m_path, pDefaultRules,
                                               HKEY_LOCAL_MACHINE,
                                               WSB_PROFILELIST_REGISTRY_KEY,
                                               WSB_PROFILES_DIR_REGISTRY_VALUE,
                                               TRUE ) );
        // If this is the boot drive (i.e. C), then exclude everything in the root, since most of
        // these files are important to boot the system (better safe than sorry, fewer rules).
        if (_wcsnicmp(m_path, OLESTR("C"), 1) == 0) {

            WsbAffirmHr(CoCreateInstance(CLSID_CHsmRule, NULL, CLSCTX_SERVER, IID_IHsmRule, (void**) &pRule));
            WsbAffirmHr(pRule->SetIsInclude(FALSE));
            WsbAffirmHr(pRule->SetIsUserDefined(FALSE));
            WsbAffirmHr(pRule->SetIsUsedInSubDirs(FALSE));
            WsbAffirmHr(pRule->SetPath(OLESTR("\\")));
            WsbAffirmHr(pRule->SetName(OLESTR("*")));

            WsbAssertHr(CoCreateInstance(CLSID_CHsmCritAlways, NULL, CLSCTX_SERVER, IID_IHsmCriteria, (void**) &pCriteria));
            WsbAssertHr(pRule->Criteria(&pCollection));
            WsbAssertHr(pCollection->Add(pCriteria));

            WsbAffirmHr(pDefaultRules->Append(pRule));
            pCollection = 0;
            pCriteria = 0;
            pRule = 0;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::CreateDefaultRules"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::DoRecovery(
    void
    )

/*++

Implements:

  IFsaResourcePriv::DoRecovery().

--*/
{
    HRESULT                     hr = S_OK;
    HRESULT                     hrFindFile;
    HRESULT                     hrFindRec;
    HRESULT                     hrLoop = S_OK;
    LONGLONG                    Offset;
    GUID                        bagId;
    LONGLONG                    bagOffset;
    LONGLONG                    fileId;
    OLECHAR *                   pPath = NULL;
    LONG                        RecCount;
    ULONG                       RecStatus;
    LONGLONG                    Size;
    FSA_PLACEHOLDER             placeholder;
    CComPtr<IWsbDbSession>      pDbSession;
    CComPtr<IFsaPremigratedRec> pPremRec;
    CComPtr<IFsaScanItem>       pScanItem;
    CComPtr<IFsaScanItemPriv>   pScanItemPriv;
    CComPtr<IFsaRecoveryRec>    pRecRec;
    CComPtr<IHsmSession>        pSession;

    WsbTraceIn(OLESTR("CFsaResource::DoRecovery"), OLESTR("Path = <%ls>"), WsbAbbreviatePath(m_path,120));

    try {

        // Don't bother if we already did recovery
        WsbAffirm(!m_isRecovered, S_FALSE);

        // Don't bother if this volume isn't managed
        WsbAffirm(S_OK == IsManaged(), S_FALSE);

        // Don't bother if we don't have a premigration-list DB (since it
        // contains the recovery records)
        if (!m_isDbInitialized) {
            // Set recovered flag so we don't end up in here again
            m_isRecovered = TRUE;
            WsbThrow(S_FALSE);
        }

        // Create and Initialize a session object.
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmSession, 0, CLSCTX_SERVER, IID_IHsmSession, (void**) &pSession));
        WsbAffirmHr(pSession->Start(OLESTR(""), HSM_JOB_LOG_NONE, m_managingHsm, 0, (IFsaResource*) this, 0, 0));

        //  Loop over recovery records and fix any problems
        WsbAffirmHr(m_pPremigrated->Open(&pDbSession));
        WsbAffirmHr(m_pPremigrated->GetEntity(pDbSession, RECOVERY_REC_TYPE, IID_IFsaRecoveryRec, (void**) &pRecRec));

        WsbAffirmHr(m_pPremigrated->GetEntity(pDbSession, PREMIGRATED_REC_TYPE, IID_IFsaPremigratedRec, (void**) &pPremRec));
        WsbAffirmHr(pPremRec->UseKey(PREMIGRATED_BAGID_OFFSETS_KEY_TYPE));

        WsbAffirmHr(pRecRec->First());

        while (TRUE) {

            //  Get record data
            WsbAffirmHr(pRecRec->GetBagId(&bagId));
            WsbAffirmHr(pRecRec->GetBagOffset(&bagOffset));
            WsbAffirmHr(pRecRec->GetFileId(&fileId));
            WsbAffirmHr(pRecRec->GetPath(&pPath, 0));
            WsbAffirmHr(pRecRec->GetStatus(&RecStatus));
            WsbAffirmHr(pRecRec->GetOffsetSize(&Offset, &Size));
            WsbAffirmHr(pRecRec->GetRecoveryCount(&RecCount));
            WsbTrace(OLESTR("CFsaResource::DoRecovery, FileId = %I64u, File = <%ls>, RecStatus = %lx, RecCount = %ld\n"), fileId, WsbAbbreviatePath(pPath, 120), RecStatus, RecCount);

            RecCount++;
            WsbAffirmHr(pRecRec->SetRecoveryCount(RecCount));

            //  Mark the record as being recovered (in case we crash here)
            WsbAffirmHr(pRecRec->Write());

            try {

                //  Create a scan item for this file
                hrFindFile = FindFileId(fileId, pSession, &pScanItem);

                if (SUCCEEDED(hrFindFile) && (pScanItem->IsManaged(Offset, Size) != S_FALSE)) {
                    WsbAffirmHr(pScanItem->GetPlaceholder(Offset, Size, &placeholder));
                }

                WsbAffirmHr(pPremRec->SetBagId(bagId));
                WsbAffirmHr(pPremRec->SetBagOffset(bagOffset));
                WsbAffirmHr(pPremRec->SetOffset(Offset));

                hrFindRec = pPremRec->FindEQ();

                // If the file has been deleted, is not managed by HSM or its BAG data is
                // different from the RP data, then it shouldn't be in the premigration list.
                if ( (WSB_E_NOTFOUND == hrFindFile) ||
                     (SUCCEEDED(hrFindFile) && (pScanItem->IsManaged(Offset, Size) != S_OK)) ||
                     (SUCCEEDED(hrFindFile) && (pScanItem->IsManaged(Offset, Size) == S_OK) && 
                      ((bagId != placeholder.bagId) || (bagOffset != placeholder.fileStart))) ) {

                    // If the record is in the list, then remove it and adjust the sizes.
                    // Note: The removal is not protected within a transaction since the
                    // recovery is done only during initialization or when a new volume is 
                    // managed. In both cases, the auto-truncator does not run yet.
                    if (S_OK == hrFindRec) {
                        WsbAffirmHr(pPremRec->Remove());
                        WsbAffirmHr(RemovePremigratedSize(Size));
                    } else {
                        WsbAffirmHr(RemoveTruncatedSize(Size));
                    }
                }

                else {

                    WsbAffirmHr(hrFindFile);

                    //  Check the status of the file according to the reparse point
                    if (S_OK == pScanItem->IsTruncated(Offset, Size)) {

                        //  Force a truncate, just in case
                        WsbAffirmHr(pScanItem->QueryInterface(IID_IFsaScanItemPriv, (void**)&pScanItemPriv));
                        hrLoop = pScanItemPriv->TruncateInternal(Offset, Size);

                        //  Remove from premigrated list if there
                        if (S_OK == hrFindRec) {
                            if ((S_OK == hrLoop) || (FSA_E_ITEMCHANGED == hrLoop)) {
                                WsbAffirmHr(pPremRec->Remove());
                                WsbAffirmHr(RemovePremigratedSize(Size));
                                if (S_OK == hrLoop) {
                                    WsbAffirmHr(AddTruncatedSize(Size));
                                }
                            }
                        }
                    }

                    else if (S_OK == pScanItem->IsPremigrated(Offset, Size)) {

                        //  Add to premigrated list if not there
                        if (WSB_E_NOTFOUND == hrFindRec) {
                            WsbAffirmHr(RemoveTruncatedSize(Size));
                            WsbAffirmHr(AddPremigratedSize(Size));
                            WsbAffirmHr(pPremRec->MarkAsNew());
                            WsbAffirmHr(pPremRec->Write());
                        }
                    }
                }

            } WsbCatch(hrLoop);

            if (FAILED(hrLoop)) {

                if ((RecStatus & FSA_RECOVERY_FLAG_TRUNCATING) != 0) {
                    WsbLogEvent(FSA_MESSAGE_TRUNCATE_RECOVERY_FAIL, 0, NULL, WsbAbbreviatePath(pPath, 120), WsbHrAsString(hr), 0);
                } else if ((RecStatus & FSA_RECOVERY_FLAG_RECALLING) != 0) {
                    WsbLogEvent(FSA_MESSAGE_RECALL_RECOVERY_FAIL, 0, NULL, WsbAbbreviatePath(pPath, 120), WsbHrAsString(hr), 0);
                }

                //  If we have tried enough, then get rid of the record.
                if (RecCount > 2) {
                    WsbTrace(OLESTR("CFsaResource::DoRecovery, unable to do recovery - too many attempts already\n"));
                    WsbAffirmHr(pRecRec->Remove());
                }

            } else {

                //  Log an event to commemorate our success
                WsbTrace(OLESTR("CFsaResource::DoRecovery, recovered <%ls>\n"), WsbAbbreviatePath(pPath, 120));
                if ((RecStatus & FSA_RECOVERY_FLAG_TRUNCATING) != 0) {
                    WsbLogEvent(FSA_MESSAGE_TRUNCATE_RECOVERY_OK, 0, NULL, WsbAbbreviatePath(pPath, 120), 0);
                } else if ((RecStatus & FSA_RECOVERY_FLAG_RECALLING) != 0) {
                    WsbLogEvent(FSA_MESSAGE_RECALL_RECOVERY_OK, 0, NULL, WsbAbbreviatePath(pPath, 120), 0);
                }

                //  Remove this record from the DB
                WsbAffirmHr(pRecRec->Remove());
            }

            //  Get the next one
            WsbAffirmHr(pRecRec->FindGT());

            //  Release any objects we may have created
            //  this time through the loop
            pScanItem = 0;
            pScanItemPriv = 0;

            hrLoop = S_OK;
        }

    } WsbCatch(hr);

    if (WSB_E_NOTFOUND == hr) {
        hr = S_OK;
    }

    if (pDbSession != 0) {
        m_pPremigrated->Close(pDbSession);
    }

    m_isRecovered = TRUE;

    // Now that everything is done, see if we need to start the truncator.
    WsbTrace(OLESTR("CFsaResource::DoRecovery, IsManaged = %ls, isActive = %ls\n"),
            WsbQuickString(WsbBoolAsString(IsManaged() == S_OK)),
            WsbQuickString(WsbBoolAsString(m_isActive)));

    // Make sure the truncator is started
    WsbAffirmHr(InitializePremigrationList(FALSE));

    WsbTraceOut(OLESTR("CFsaResource::DoRecovery"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaResource::EndSession(
    IN IHsmSession* pSession
    )

/*++

Implements:

  IFsaResource::EndSession().

--*/
{
    HRESULT                 hr = S_OK;
    BOOL                    bLog = TRUE;

    WsbTraceIn(OLESTR("CFsaResource::EndSession"), OLESTR(""));
    try {

        WsbAssert(0 != pSession, E_POINTER);

        // Tell the session that the scan is done.
        WsbAffirmHr(pSession->ProcessState(HSM_JOB_PHASE_SCAN, HSM_JOB_STATE_DONE, OLESTR(""), bLog));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::EndSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::EndValidate(
    HSM_JOB_STATE state
    )

/*++

Implements:

  IFsaResource::EndValidate().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::EndValidate"),
            OLESTR("state = %ld, new PremigratedSize = %I64d, new TruncatedSize = %I64d"),
            (LONG)state, m_premigratedSize, m_truncatedSize);

    try {

        if (HSM_JOB_STATE_DONE != state) {
            m_premigratedSize = m_oldPremigratedSize;
            m_truncatedSize = m_oldTruncatedSize;
        }
        m_isDoingValidate = FALSE;

        // Make sure the truncator is running
        WsbAffirmHr(InitializePremigrationList(FALSE));
        WsbAffirmHr(m_pTruncator->KickStart());

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::EndValidate"),
            OLESTR("hr = <%ls>, PremigratedSize = %I64d, TruncatedSize = %I64d"),
            WsbQuickString(WsbHrAsString(hr)), m_premigratedSize, m_truncatedSize);
    return(hr);
}


HRESULT
CFsaResource::EnumDefaultRules(
    OUT IWsbEnum** ppEnum
    )

/*++

Implements:

  IFsaResource::EnumDefaultRules().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != ppEnum, E_POINTER);

        WsbAffirmHr(m_pDefaultRules->Enum(ppEnum));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::FilterSawOpen(
    IN IHsmSession* pSession,
    IN IFsaFilterRecall* pRecall,
    IN OLECHAR* path,
    IN LONGLONG fileId,
    IN LONGLONG requestOffset,
    IN LONGLONG requestSize,
    IN FSA_PLACEHOLDER* pPlaceholder,
    IN ULONG mode,
    IN FSA_RESULT_ACTION resultAction,
    IN DWORD    threadId
    )

/*++

Implements:

  IFsaResource::FilterSawOpen().

--*/
{
    HRESULT                     hr = S_OK;
    HRESULT                     hrFind;
    CComPtr<IFsaPostIt>         pWorkItem;
    CComPtr<IHsmFsaTskMgr>      pEngine;
    CComPtr<IWsbDbSession>      pDbSession;
    CComPtr<IFsaRecoveryRec>    pRecRec;

    WsbTraceIn(OLESTR("CFsaResource::FilterSawOpen"),
            OLESTR("path = <%ls>, requestOffset = %I64d, requestSize = %I64d"),
            path, requestOffset, requestSize);
    try {

        WsbAssert(0 != pSession, E_POINTER);
        WsbAssert(0 != pRecall, E_POINTER);
        WsbAssert(0 != path, E_POINTER);
        WsbAssert(0 != pPlaceholder, E_POINTER);
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaPostIt, 0, CLSCTX_SERVER, IID_IFsaPostIt, (void**) &pWorkItem));

        // Remember which recall is being used to track the open.
        WsbAffirmHr(pWorkItem->SetFilterRecall(pRecall));

        //
        // Set the session for others to know
        //
        WsbAffirmHr(pWorkItem->SetSession(pSession));
        WsbAffirmHr(pWorkItem->SetMode(mode));
        WsbAffirmHr(pWorkItem->SetFileVersionId(pPlaceholder->fileVersionId));

        //
        // Set the transfer size
        //
        WsbAffirmHr(pWorkItem->SetRequestOffset(requestOffset));
        WsbAffirmHr(pWorkItem->SetRequestSize(requestSize));
        WsbAffirmHr(pWorkItem->SetPlaceholder(pPlaceholder));

        //
        // Get a new copy of the path into the workitem
        //
        WsbAffirmHr(pWorkItem->SetPath(path));

        //
        // Need to check the mode to set the right result action. For now
        // just set it to OPEN.
        //
        WsbAffirmHr(pWorkItem->SetResultAction(resultAction));
        WsbAffirmHr(pWorkItem->SetThreadId(threadId));

        //
        // Send the request to the task manager. If the file was archived by someone other
        // than the managing HSM, then that HSM will need to be looked up.
        //
        if ( GUID_NULL != m_managingHsm &&
             memcmp(&m_managingHsm, &(pPlaceholder->hsmId), sizeof(GUID)) == 0) {
            WsbAffirmHr(GetHsmEngine(&pEngine));
        } else {
            CComPtr<IHsmServer>     pHsmServer;

            WsbAssertHr(HsmConnectFromId(HSMCONN_TYPE_HSM, (pPlaceholder->hsmId), IID_IHsmServer, (void**) &pHsmServer));
            WsbAffirmHr(pHsmServer->GetHsmFsaTskMgr(&pEngine));
        }

        //
        // Fill in the rest of the work
        //
        if (mode & FILE_OPEN_NO_RECALL) {
            WsbAffirmHr(pWorkItem->SetRequestAction(FSA_REQUEST_ACTION_FILTER_READ));
        } else {

            WsbAffirmHr(pWorkItem->SetRequestAction(FSA_REQUEST_ACTION_FILTER_RECALL));

            if (m_isDbInitialized) {
                //  Save a recovery record in case anything goes wrong
                WsbAffirmHr(m_pPremigrated->Open(&pDbSession));
                WsbAffirmHr(m_pPremigrated->GetEntity(pDbSession, RECOVERY_REC_TYPE, IID_IFsaRecoveryRec, (void**) &pRecRec));
                WsbAffirmHr(pRecRec->SetPath(path));

                // If the record already exists rewrite it, otherwise create a new record.
                hrFind = pRecRec->FindEQ();
                if (WSB_E_NOTFOUND == hrFind) {
                    WsbAffirmHr(pRecRec->MarkAsNew());
                } else if (FAILED(hrFind)) {
                    WsbThrow(hrFind);
                }

                WsbAffirmHr(pRecRec->SetFileId(fileId));
                WsbAffirmHr(pRecRec->SetOffsetSize(requestOffset, requestSize));
                WsbAffirmHr(pRecRec->SetStatus(FSA_RECOVERY_FLAG_RECALLING));
                WsbAffirmHr(pRecRec->Write());
            }
        }

        // If anything that follows fails, then we need to delete the recovery record.
        try {

            WsbTrace(OLESTR("CFsaResource::FilterSawOpen calling DoFsaWork\n"));
            WsbAffirmHr(pEngine->DoFsaWork(pWorkItem));

        } WsbCatchAndDo(hr,
            if (pRecRec != 0) {
                hrFind = pRecRec->FindEQ();
                if (hrFind == S_OK)  {
                    WsbAffirmHr(pRecRec->Remove());
                }
            }
        );

    } WsbCatch(hr);

    if (pDbSession != 0) {
        m_pPremigrated->Close(pDbSession);
    }

    WsbTraceOut(OLESTR("CFsaResource::FilterSawOpen"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::FilterSawDelete(
    IN GUID /*filterId*/,
    IN OLECHAR* path,
    IN LONGLONG /*size*/,
    IN FSA_PLACEHOLDER* pPlaceholder
    )

/*++

Implements:

  IFsaResource::FilterSawDelete().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::FilterSawDelete"), OLESTR("path = <%ls>"), (OLECHAR *)path);
    try {

        WsbAssert(0 != path, E_POINTER);
        WsbAssert(0 != pPlaceholder, E_POINTER);

        hr = E_NOTIMPL;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::FilterSawDelete"), OLESTR(""));
    return(hr);
}


HRESULT
CFsaResource::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::FinalConstruct"), OLESTR(""));
    try {

        WsbAffirmHr(CWsbCollectable::FinalConstruct());

        m_id = GUID_NULL;
        m_compareBy = FSA_RESOURCE_COMPARE_ID;
        m_managingHsm = GUID_NULL;
        m_isActive = TRUE;
        m_isAvailable = TRUE;
        m_isDeletePending = FALSE;
        m_isRecovered = FALSE;
        m_hsmLevel = 0;
        m_premigratedSize = 0;
        m_truncatedSize = 0;
        m_isDoingValidate = FALSE;
        m_usnJournalId = (ULONGLONG) 0;
        m_lastUsnId = (LONGLONG) 0;         // Not used yet but persisted for possible future use.

        // Default Criteria (12Kb, 180 days old)
        m_manageableItemLogicalSize = 12288;
        m_manageableItemAccessTimeIsRelative = TRUE;
        m_manageableItemAccessTime = WsbLLtoFT(180 * WSB_FT_TICKS_PER_DAY);

        m_isUnmanageDbInitialized = FALSE;

        //Create the default rule list.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_SERVER, IID_IWsbCollection, (void**) &m_pDefaultRules));

        // Create the premigrated list DB
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaPremigratedDb, NULL, CLSCTX_SERVER, IID_IFsaPremigratedDb, (void**) &m_pPremigrated));
        m_isDbInitialized = FALSE;

        // Create the object for the auto truncator.
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaTruncatorNTFS, NULL, CLSCTX_SERVER, IID_IFsaTruncator, (void**) &m_pTruncator));


    } WsbCatch(hr);

    if (hr == S_OK)  {
        g_InstanceCount++;
    }
    WsbTrace(OLESTR("CFsaResource::FinalConstruct: this = %p, instance count = %d\n"),
            this, g_InstanceCount);
    WsbTraceOut(OLESTR("CFsaResource::FinalConstruct"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::FinalRelease"), OLESTR(""));
    try {
        HSM_SYSTEM_STATE SysState;

        // Terminate Unmanage Db (If it wasn't created, nothing happens...) 
        TerminateUnmanageDb();
        m_isUnmanageDbInitialized = FALSE;
        m_pUnmanageDb = NULL;

        // Shutdown resource
        SysState.State = HSM_STATE_SHUTDOWN;
        ChangeSysState(&SysState);
        CWsbCollectable::FinalRelease();

        // Free String members
        // Note: Member objects held in smart-pointers are freed when the 
        // smart-pointer destructor is being called (as part of this object destruction)
        m_oldPath.Free();
        m_path.Free();
        m_alternatePath.Free();
        m_name.Free();
        m_fsName.Free();

    } WsbCatch(hr);

    if (hr == S_OK)  {
        g_InstanceCount--;
    }
    WsbTrace(OLESTR("CFsaResource::FinalRelease: this =  %p, instance count = %d\n"),
            this, g_InstanceCount);
    WsbTraceOut(OLESTR("CFsaResource::FinalRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::FindFirst(
    IN OLECHAR* path,
    IN IHsmSession* pSession,
    OUT IFsaScanItem** ppScanItem
    )

/*++

Implements:

  IFsaResource::FindFirst().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaScanItemPriv>   pScanItem;

    try {

        WsbAssert(0 != path, E_POINTER);
        WsbAssert(0 != ppScanItem, E_POINTER);

        // Create an FsaScanItem that will scan for us.
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaScanItemNTFS, NULL, CLSCTX_SERVER, IID_IFsaScanItemPriv, (void**) &pScanItem));

        // Scan starting at the specified path.
        WsbAffirmHr(pScanItem->FindFirst((IFsaResource*) this, path, pSession));

        // If we found something, then return the scan item.
        WsbAffirmHr(pScanItem->QueryInterface(IID_IFsaScanItem, (void**) ppScanItem));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::FindFirstInRPIndex(
    IN IHsmSession* pSession,
    OUT IFsaScanItem** ppScanItem
    )

/*++

Implements:

  IFsaResource::FindFirstInRPIndex

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaScanItemPriv>   pScanItem;

    try {

        WsbAssert(0 != ppScanItem, E_POINTER);

        // Create an FsaScanItem that will scan for us.
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaScanItemNTFS, NULL, CLSCTX_SERVER, IID_IFsaScanItemPriv, (void**) &pScanItem));

        // Scan starting at the specified path.
        WsbAffirmHr(pScanItem->FindFirstInRPIndex((IFsaResource*) this, pSession));

        // If we found something, then return the scan item.
        WsbAffirmHr(pScanItem->QueryInterface(IID_IFsaScanItem, (void**) ppScanItem));

    } WsbCatch(hr);

    return(hr);
}

HRESULT
CFsaResource::FindFirstInDbIndex(
    IN IHsmSession* pSession,
    OUT IFsaScanItem** ppScanItem
    )

/*++

Implements:

  IFsaResource::FindFirstInDbIndex

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaScanItemPriv>   pScanItem;

    try {

        WsbAssert(0 != ppScanItem, E_POINTER);

        // Create an FsaScanItem that will scan for us.
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaScanItemNTFS, NULL, CLSCTX_SERVER, IID_IFsaScanItemPriv, (void**) &pScanItem));

        // Scan starting at the specified path.
        WsbAffirmHr(pScanItem->FindFirstInDbIndex((IFsaResource*) this, pSession));

        // If we found something, then return the scan item.
        WsbAffirmHr(pScanItem->QueryInterface(IID_IFsaScanItem, (void**) ppScanItem));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::FindNext(
    IN IFsaScanItem* pScanItem
    )

/*++

Implements:

  IFsaResource::FindNext().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaScanItemPriv>   pPriv;

    try {

        WsbAssert(0 != pScanItem, E_POINTER);

        // Continue the scan.
        WsbAffirmHr(pScanItem->QueryInterface(IID_IFsaScanItemPriv, (void**) &pPriv))
        WsbAffirmHr(pPriv->FindNext());

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::FindNextInRPIndex(
    IN IFsaScanItem* pScanItem
    )

/*++

Implements:

  IFsaResource::FindNextInRPIndex

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaScanItemPriv>   pPriv;

    try {

        WsbAssert(0 != pScanItem, E_POINTER);

        // Continue the scan.
        WsbAffirmHr(pScanItem->QueryInterface(IID_IFsaScanItemPriv, (void**) &pPriv))
        WsbAffirmHr(pPriv->FindNextInRPIndex());

    } WsbCatch(hr);

    return(hr);
}

HRESULT
CFsaResource::FindNextInDbIndex(
    IN IFsaScanItem* pScanItem
    )

/*++

Implements:

  IFsaResource::FindNextInDbIndex

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaScanItemPriv>   pPriv;

    try {

        WsbAssert(0 != pScanItem, E_POINTER);

        // Continue the scan.
        WsbAffirmHr(pScanItem->QueryInterface(IID_IFsaScanItemPriv, (void**) &pPriv))
        WsbAffirmHr(pPriv->FindNextInDbIndex());

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::FindFileId(
    IN LONGLONG fileId,
    IN IHsmSession* pSession,
    OUT IFsaScanItem** ppScanItem
    )

/*++

Implements:

  IFsaResource::FindFileId().

    Creates a scan item for the given file ID.

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaScanItemPriv>   pScanItem;
    CWsbStringPtr               VolumePath;
    CWsbStringPtr               filePath;
    HANDLE                      File = INVALID_HANDLE_VALUE;
    HANDLE                      VolumeHandle = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK             IoStatusBlock;
    NTSTATUS                    Status;
    NTSTATUS                    GetNameStatus;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    UNICODE_STRING              str;
    PFILE_NAME_INFORMATION      FileName;
    DWORD                       pathSize;
    OLECHAR                     *buffer = NULL;

    WsbTraceIn(OLESTR("CFsaResource::FindFileId"), OLESTR("File ID = %I64x"), fileId);

    try {
        WsbAssert(0 != ppScanItem, E_POINTER);

        // If we were passed an existing scan item (special internal code),
        // use it; otherwise, create one.
        if (NULL != *ppScanItem) {
            WsbAffirmHr((*ppScanItem)->QueryInterface(IID_IFsaScanItemPriv,
                    (void**) &pScanItem));
        } else {
            WsbAffirmHr(CoCreateInstance(CLSID_CFsaScanItemNTFS, NULL,
                    CLSCTX_SERVER, IID_IFsaScanItemPriv, (void**) &pScanItem));
        }

        //
        // Get the file path from the ID
        //


        //
        //  Open by File Reference Number (FileID),
        //  Relative opens from the Volume Handle.
        //

        VolumePath = L"\\\\.\\";
        //VolumePath = L"";
        WsbAffirmHr(VolumePath.Append(m_path));
        ((OLECHAR *) VolumePath)[wcslen(VolumePath) - 1] = L'\0';

        WsbTrace(OLESTR("CFsaResource::FindFileId - Volume path is <%ls>\n"),
                static_cast<WCHAR*>(VolumePath));

        VolumeHandle = CreateFileW( VolumePath,
                                    GENERIC_READ,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    0,
                                    NULL );

        WsbAffirmHandle(VolumeHandle);

        RtlInitUnicodeString(&str, (WCHAR *) &fileId);
        str.Length = 8;
        str.MaximumLength = 8;

        InitializeObjectAttributes( &ObjectAttributes,
                                    &str,
                                    OBJ_CASE_INSENSITIVE,
                                    VolumeHandle,
                                    NULL );

        Status = NtCreateFile(&File,
                              FILE_READ_ATTRIBUTES,
                              &ObjectAttributes,
                              &IoStatusBlock,
                              NULL,                  // AllocationSize
                              FILE_ATTRIBUTE_NORMAL,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              FILE_OPEN,
                              FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_BY_FILE_ID | FILE_OPEN_REPARSE_POINT,
                              NULL,                  // EaBuffer
                              0);

        WsbTrace(OLESTR("CFsaResource::FindFileId - NtCreateFile status = %lx\n"),
                static_cast<LONG>(Status));
        if (STATUS_INVALID_PARAMETER == Status) {
            //  This seems to be the error we get if the file is missing so
            //  we translate it to something our code will understand
            WsbThrow(WSB_E_NOTFOUND);
        }
        WsbAffirmNtStatus(Status);

        GetNameStatus = STATUS_BUFFER_OVERFLOW;
        //
        // Take a guess at the path length to start with
        //
        pathSize = 256 + sizeof(FILE_NAME_INFORMATION);
        //
        // Keep trying for the name until we get an error other than buffer overflow or success.
        //

        WsbAffirmPointer((buffer = (OLECHAR *) malloc(pathSize)));

        do {
            FileName = (PFILE_NAME_INFORMATION) buffer;

            GetNameStatus = NtQueryInformationFile( File,
                                                &IoStatusBlock,
                                                FileName,
                                                pathSize - sizeof(WCHAR),  // leave room for the NULL we add
                                                FileNameInformation );

            WsbTrace(OLESTR("CFsaResource::FindFileId - NtQueryInformationFile status = %ld\n"),
                    static_cast<LONG>(GetNameStatus));

            if (GetNameStatus == STATUS_BUFFER_OVERFLOW) {
                pathSize += 256;
                WsbAffirmPointer((buffer = (OLECHAR *) realloc(buffer, pathSize)));
            }
        } while (GetNameStatus == STATUS_BUFFER_OVERFLOW);

        WsbAffirmNtStatus(GetNameStatus);

        FileName->FileName[FileName->FileNameLength / sizeof(WCHAR)] = L'\0';
        filePath = FileName->FileName;

        // Scan starting at the specified path.
        WsbAffirmHr(pScanItem->FindFirst((IFsaResource*) this, filePath, pSession));

        // If we found something, then return the scan item.
        WsbAffirmHr(pScanItem->QueryInterface(IID_IFsaScanItem, (void**) ppScanItem));

    } WsbCatch(hr);

    // Make sure we clean up
    if (INVALID_HANDLE_VALUE != VolumeHandle) {
        CloseHandle(VolumeHandle);
    }

    if (INVALID_HANDLE_VALUE != File) {
        NtClose(File);
    }

    if (buffer != NULL) {
        free(buffer);
    }

    WsbTraceOut(OLESTR("CFsaResource::FindFileId"), OLESTR("hr = <%ls>"),
            WsbHrAsString(hr));

    return(hr);
}



HRESULT
CFsaResource::FindObjectId(
    IN LONGLONG objIdHi,
    IN LONGLONG objIdLo,
    IN IHsmSession* pSession,
    OUT IFsaScanItem** ppScanItem
    )

/*++

Implements:

  IFsaResource::FindObjectId().

    Creates a scan item for the given object Id.

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaScanItemPriv>   pScanItem;
    CWsbStringPtr               VolumePath;
    HANDLE                      File = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK             IoStatusBlock;
    NTSTATUS                    Status;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    LONG                        pathLength;
    WCHAR                       unicodeStringBuffer[100];
    UNICODE_STRING              unicodeString;
    FILE_INTERNAL_INFORMATION   iInfo;
    LONGLONG                    fileId;

    WsbTraceIn(OLESTR("CFsaResource::FindObjectId"), OLESTR("Object ID = %I64x %I64x"), objIdHi, objIdLo);
    try {
        WsbAssert(0 != ppScanItem, E_POINTER);

        // Create an FsaScanItem that will scan for us.
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaScanItemNTFS, NULL, CLSCTX_SERVER, IID_IFsaScanItemPriv, (void**) &pScanItem));


        //
        //  Open by object ID
        //  Relative opens from the Volume Handle.
        //

        VolumePath = L"\\??\\";
        //VolumePath = L"";

        WsbAffirmHr(VolumePath.Append((WCHAR *) m_path));


        WsbTrace(OLESTR("CFsaResource::FindObjectId - Volume path is %ws.\n"), (OLECHAR *) VolumePath);
        WsbTrace(OLESTR("CFsaResource::FindObjectId - Object ID = %I64x %I64x.\n"), objIdHi, objIdLo);

        pathLength = wcslen(VolumePath);
        RtlInitUnicodeString(&unicodeString, unicodeStringBuffer);
        unicodeString.Length  = (USHORT)((pathLength * sizeof(WCHAR)) + (sizeof(LONGLONG) * 2));
        RtlCopyMemory(&unicodeString.Buffer[0], VolumePath, pathLength * sizeof(WCHAR));
        RtlCopyMemory(&unicodeString.Buffer[pathLength], &objIdHi, sizeof(LONGLONG));
        RtlCopyMemory(&unicodeString.Buffer[pathLength + (sizeof(LONGLONG) / sizeof(WCHAR))], &objIdLo, sizeof(LONGLONG));

        InitializeObjectAttributes( &ObjectAttributes,
                                    &unicodeString,
                                    OBJ_CASE_INSENSITIVE,
                                    0,
                                    NULL );

        WsbAffirmNtStatus(Status = NtCreateFile( &File,
                               FILE_READ_ATTRIBUTES,
                               &ObjectAttributes,
                               &IoStatusBlock,
                               NULL,                  // AllocationSize
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               FILE_OPEN,
                               FILE_OPEN_BY_FILE_ID | FILE_OPEN_REPARSE_POINT,
                               NULL,                  // EaBuffer
                               0 ));


        //
        // Get the file id from the object ID
        //
        WsbAffirmHr(NtQueryInformationFile(File, &IoStatusBlock, &iInfo, sizeof(FILE_INTERNAL_INFORMATION), FileInternalInformation));
        fileId = iInfo.IndexNumber.QuadPart;

        WsbAffirmNtStatus(NtClose(File));
        File = INVALID_HANDLE_VALUE;

        // Now open by file id.
        WsbAffirmHr(FindFileId(fileId, pSession, ppScanItem));

    } WsbCatch(hr);

    // Make sure we clean up.
    if (INVALID_HANDLE_VALUE != File) {
        NtClose( File );
    }

    WsbTraceOut(OLESTR("CFsaResource::FindObjectId"), OLESTR("hr = <%ls>"),
            WsbHrAsString(hr));
    return(hr);
}




HRESULT
CFsaResource::GetAlternatePath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaResource::GetAlternatePath().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pPath, E_POINTER);
        WsbAffirmHr(m_alternatePath.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CFsaResourceNTFS;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}



HRESULT
CFsaResource::GetDbPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaResource::GetDbPath().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    WsbTraceIn(OLESTR("CFsaResource::GetDbPath"), OLESTR(""));
    try {

        WsbAssert(0 != pPath, E_POINTER);

        // Use a relative path under the install directory.
        WsbAffirmHr(m_pFsaServer->GetIDbPath(&tmpString, 0));
        tmpString.Append(OLESTR("\\"));
        tmpString.Append(WsbGuidAsString(m_id));

        WsbAffirmHr(tmpString.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);
    WsbTraceOut(OLESTR("CFsaResource::GetDbPath"), OLESTR("hr = <%ls>, path = <%ls)"),
        WsbHrAsString(hr), WsbPtrToStringAsString(pPath));

    return(hr);
}

HRESULT
CFsaResource::GetUnmanageDbPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaResource::GetDbPath().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    WsbTraceIn(OLESTR("CFsaResource::GetUnmanageDbPath"), OLESTR(""));
    try {
        WsbAssert(0 != pPath, E_POINTER);

        // Use a relative path under the install directory.
        WsbAffirmHr(m_pFsaServer->GetUnmanageIDbPath(&tmpString, 0));
        tmpString.Append(OLESTR("\\"));
        tmpString.Append(UNMANAGE_DB_PREFIX);
        tmpString.Append(WsbGuidAsString(m_id));

        WsbAffirmHr(tmpString.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);
    WsbTraceOut(OLESTR("CFsaResource::GetUnmanageDbPath"), OLESTR("hr = <%ls>, path = <%ls)"),
        WsbHrAsString(hr), WsbPtrToStringAsString(pPath));

    return(hr);
}


HRESULT
CFsaResource::GetDefaultRules(
    OUT IWsbCollection** ppCollection
    )

/*++

Implements:

  IFsaResource::GetDefaultRules().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != ppCollection, E_POINTER);

        *ppCollection = m_pDefaultRules;
        m_pDefaultRules->AddRef();

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetFreeLevel(
    OUT ULONG* pLevel
    )

/*++

Implements:

  IFsaResource::GetFreeLevel().

--*/
{
    HRESULT         hr = S_OK;
    LONGLONG        total;
    LONGLONG        free;

    try {

        WsbAssert(0 != pLevel, E_POINTER);

        // Get the capacities for this resource.
        WsbAffirmHr(GetSizes(&total, &free, 0, 0));
        *pLevel = (ULONG) (((double)free / (double)total) * (double)FSA_HSMLEVEL_100);

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetFsName(
    OUT OLECHAR** pFsName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaResource::GetFsName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pFsName, E_POINTER);
        WsbAffirmHr(m_fsName.CopyTo(pFsName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetHsmEngine(
    IHsmFsaTskMgr** ppEngine
    )

/*++

Implements:

  IFsaResource::GetHsmEngine().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmServer>     pHsmServer;

    WsbTraceIn(OLESTR("CFsaResource::GetHsmEngine"), OLESTR(""));
    try {
        WsbAssert(0 != ppEngine, E_POINTER);

        if (m_pHsmEngine != 0) {
            //
            // See if the connection is still valid
            //
            CComPtr<IHsmFsaTskMgr>  pTestInterface;
            hr = m_pHsmEngine->ContactOk();
            if (hr != S_OK) {
                // We don't have a valid
                WsbTrace(OLESTR("CHsmServer::GetHsmEngine - Current connection invalid.\n"));
                hr = S_OK;
                m_pHsmEngine = 0;
            }
        }
        // If we haven't already looked it up, then do so now.
        if (m_pHsmEngine == 0) {
            WsbAffirm(IsManaged() == S_OK, E_FAIL);
            WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, m_managingHsm, IID_IHsmServer, (void**) &pHsmServer));
            WsbAffirmHr(pHsmServer->GetHsmFsaTskMgr(&m_pHsmEngine));
        }

        // Return the pointer that we have stored.
        *ppEngine = m_pHsmEngine;
        m_pHsmEngine->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::GetHsmEngine"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::GetHsmLevel(
    OUT ULONG* pLevel
    )

/*++

Implements:

  IFsaResource::GetHsmLevel().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pLevel, E_POINTER);

        *pLevel = m_hsmLevel;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetIdentifier(
    OUT GUID* pId
    )

/*++

Implements:

  IFsaResource::GetIdentifier().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);

        *pId = m_id;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetLogicalName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaResource::GetLogicalName().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;
    CWsbStringPtr   name;

    try {

        WsbAssert(0 != pName, E_POINTER);
        WsbAssert(m_pFsaServer != 0, E_POINTER);

        WsbAffirmHr(tmpString.TakeFrom(*pName, bufferSize));

        try {

            // This is an arbitrary choice for the naming convention. Nothing has been
            // decided upon.
            WsbAffirmHr(m_pFsaServer->GetLogicalName(&tmpString, 0));
            WsbAffirmHr(GetPath(&name, 0));
            //
            // Strip off trailing \ if there
            if (name[(int) wcslen((WCHAR *) name) - 1] == L'\\') {
                name[(int) wcslen((WCHAR *) name) - 1] = L'\0';
            }
            WsbAffirmHr(tmpString.Append(OLESTR("\\")));
            WsbAffirmHr(tmpString.Append(name));

        } WsbCatch(hr);

        WsbAffirmHr(tmpString.GiveTo(pName));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetManageableItemLogicalSize(
    OUT LONGLONG* pSize
    )

/*++

Implements:

  IFsaResource::GetManageableItemLogicalSize().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pSize, E_POINTER);

        *pSize = m_manageableItemLogicalSize;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetManageableItemAccessTime(
    OUT BOOL* pIsRelative,
    OUT FILETIME* pTime
    )

/*++

Implements:

  IFsaResource::GetManageableItemAccessTime().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pIsRelative, E_POINTER);
        WsbAssert(0 != pTime, E_POINTER);

        *pIsRelative = m_manageableItemAccessTimeIsRelative;
        *pTime = m_manageableItemAccessTime;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetManagingHsm(
    GUID* pId
    )

/*++

Implements:

  IFsaResource::GetManagingHsm().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);

        *pId = m_managingHsm;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaResource::GetName().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::GetName"), OLESTR(""));
    try {

        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(m_name.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::GetName"), OLESTR("hr = <%ls>, name = <%ls>"),
        WsbHrAsString(hr), (OLECHAR *)m_name);
    return(hr);
}


HRESULT
CFsaResource::GetOldPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaResource::GetOldPath().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pPath, E_POINTER);
        WsbAffirmHr(m_oldPath.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaResource::GetPath().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pPath, E_POINTER);
        WsbAffirmHr(m_path.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetStickyName(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaResource::GetStickyName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pPath, E_POINTER);
        WsbAffirmHr(m_stickyName.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}




HRESULT
CFsaResource::GetUserFriendlyName(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaResource::GetUserFriendlyName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pPath, E_POINTER);
        WsbAffirmHr(m_userName.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CFsaResource::GetPremigrated(
    IN  REFIID   riid,
    OUT void**   ppDb
    )

/*++

Implements:

  IFsaResourcePriv::GetPremigrated

--*/
{
    HRESULT         hr = S_OK;

    try {
        WsbAssert(0 != ppDb, E_POINTER);
        if (m_isDbInitialized) {
            WsbAffirmHr(m_pPremigrated->QueryInterface(riid, ppDb));
            hr = S_OK;
        } else {
            hr = WSB_E_RESOURCE_UNAVAILABLE;
        }
    } WsbCatch(hr);

    return(hr);
}

HRESULT
CFsaResource::GetUnmanageDb(
    IN  REFIID   riid,
    OUT void**   ppDb
    )

/*++

Implements:

  IFsaResourcePriv::GetUnmanageDb

--*/
{
    HRESULT         hr = S_OK;

    try {
        WsbAssert(0 != ppDb, E_POINTER);
        if ((m_isUnmanageDbInitialized) && (m_pUnmanageDb != NULL)) {
            WsbAffirmHr(m_pUnmanageDb->QueryInterface(riid, ppDb));
            hr = S_OK;
        } else {
            hr = WSB_E_RESOURCE_UNAVAILABLE;
        }
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetSerial(
    OUT ULONG *serial
    )

/*++

Implements:

  IFsaResourcePriv:GetSerial

--*/
{
    HRESULT                 hr = S_OK;


    WsbTraceIn(OLESTR("CFsaResource::GetSerial"), OLESTR(""));

    try {

        WsbAssert(0 != serial, E_POINTER);

        *serial = m_serial;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::GetSerial"), OLESTR("hr = <%ls>, Serial = %u"), WsbHrAsString(hr), m_serial);

    return(hr);
}


HRESULT
CFsaResource::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistStream> pPersistStream;
    ULARGE_INTEGER          entrySize;


    WsbTraceIn(OLESTR("CFsaResource::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pSize, E_POINTER);

        // Determine the size for a rule with no criteria.
        pSize->QuadPart = WsbPersistSize((wcslen(m_name) + 1) * sizeof(OLECHAR)) +
            WsbPersistSize((wcslen(m_fsName) + 1) * sizeof(OLECHAR)) +
            WsbPersistSize((wcslen(m_path) + 1) * sizeof(OLECHAR)) +
            WsbPersistSize((wcslen(m_alternatePath) + 1) * sizeof(OLECHAR)) +
            3 * WsbPersistSizeOf(LONGLONG) +
            WsbPersistSizeOf(FILETIME) +
            WsbPersistSizeOf(BOOL) +
            3 * WsbPersistSizeOf(ULONG) +
            WsbPersistSizeOf(FSA_RESOURCE_COMPARE) +
            2 * WsbPersistSizeOf(GUID);

        // Now allocate space for the default rules list.
        WsbAffirmHr((m_pDefaultRules)->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
        pSize->QuadPart += entrySize.QuadPart;
        pPersistStream = 0;

        // Now allocate space for the premigration list.
        WsbAffirmHr(((IWsbDb*)m_pPremigrated)->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
        pSize->QuadPart += entrySize.QuadPart;
        pPersistStream = 0;

        // Now allocate space for truncator.
        WsbAffirmHr(m_pTruncator->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
        pSize->QuadPart += entrySize.QuadPart;
        pPersistStream = 0;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CFsaResource::GetSizes(
    OUT LONGLONG* pTotal,
    OUT LONGLONG* pFree,
    OUT LONGLONG* pPremigrated,
    OUT LONGLONG* pTruncated
    )

/*++

Implements:

  IFsaResource::GetSizes().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   path;
    ULARGE_INTEGER  freeCaller;
    ULARGE_INTEGER  total;
    ULARGE_INTEGER  free;


    try {

        if ((0 != pTotal)  || (0 != pFree)) {

            WsbAffirmHr(GetPath(&path, 0));
            WsbAffirmHr(path.Prepend("\\\\?\\"));
            WsbAffirmStatus(GetDiskFreeSpaceEx(path, &freeCaller, &total, &free));

            if (0 != pTotal) {
                *pTotal = total.QuadPart;
            }

            if (0 != pFree) {
                *pFree = free.QuadPart;
            }
        }

        if (0 != pPremigrated) {
            *pPremigrated = m_premigratedSize;
        }

        if (0 != pTruncated) {
            *pTruncated = m_truncatedSize;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetTruncator(
    IFsaTruncator** ppTruncator
    )

/*++

Implements:

  IFsaResource::GetTruncator().

--*/
{
    HRESULT                 hr = S_OK;

    try {

        WsbAssert(0 != ppTruncator, E_POINTER);

        // Return the pointer that we have stored.
        *ppTruncator = m_pTruncator;
        if (m_pTruncator != 0)  {
            m_pTruncator->AddRef();
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetUncPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaResource::GetUncPath().

    // Returns system generated UNC path if there is one.  If not it returns WSB_E_NOTFOUND


--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;
    OLECHAR         driveName[3];

    try {

        WsbAssert(0 != pPath, E_POINTER);

        // The path is either "d:\" where d is a drive letter or "Volume{GUID}" for an
        // unnamed drive. So make sure we have at least that many characters.
        //
        if (wcslen(m_path) >= 3) {

            // There is no system created UNC path to a volume without a drive letter so
            // see if the path has form of "Volume{GUID}". For a volume with no drive letter we
            // store this PNP (sticky) name as the path also.

            if (wcsstr(m_path, OLESTR("Volume{")) != 0) {
                WsbAffirmHr(tmpString.GiveTo(pPath));   // give caller an empty string back.
            }
            else {
                // The UNC path is \\ssss\d$, where ssss is the server name and d is the drive
                // letter.
                WsbAffirmHr(tmpString.TakeFrom(*pPath, bufferSize));

                WsbAffirmHr(m_pFsaServer->GetName(&tmpString, 0));
                WsbAffirmHr(tmpString.Prepend(OLESTR("\\\\")));
                WsbAffirmHr(tmpString.Append(OLESTR("\\")));
                driveName[0] = m_path[0];
                driveName[1] = L'$';
                driveName[2] = 0;

                WsbAffirmHr(tmpString.Append(driveName));

                WsbAffirmHr(tmpString.GiveTo(pPath));
            }
        } else {
            hr = WSB_E_NOTFOUND;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::GetUsnId(
    OUT ULONGLONG   *usnId
    )

/*++

Implements:

  IFsaResource::GetUsnId().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != usnId, E_POINTER);

        *usnId = m_usnJournalId;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::Init(
    IN IFsaServer* pFsaServer,
    IN OLECHAR* path,
    IN OLECHAR* dosName
    )

/*++

Implements:

  IFsaResourcePriv::Init().

Routine Description:

    This routine implements the COM method for testing a resource to see if it is
    'manageable' by the HSM (Remote Storage) system.  (Only NTFS-formatted
    volumes which support sparse files and reparse points are considered to be
    manageable by Sakkara.)  If the resource is manageable, it initializes the
    resource object.

Arguments:

    pFsaServer - Interface pointer to the FSA service that is scanning this resource.

    path - The long ugly PNP name that can be used if there is no drive letter for
            the resource being tested (i.e., it is mounted as a volume without a
            drive letter).

    dosName - The drive letter (if there is one) of the resource being tested.

Return Value:

    S_OK - The call succeeded (the resource being tested was found to be manageable,
            and the resource object was initialized).

    FSA_E_UNMANAGEABLE - Thrown if the resource being tested for manageability is
            found to be unmanageable.

    FSA_E_NOMEDIALOADED - Thrown if the resource being tested for manageability is
            a removable type of drive and no media is presently loaded.

    E_POINTER - Thrown if the path argument passed in is null.

    Any other value - The call failed because one of the Remote Storage or Win32 API
            calls contained internally in this method failed.  The error value returned
            is specific to the API call which failed.

--*/

{
    HRESULT         hr = FSA_E_UNMANAGABLE;
    UINT            type;
    UINT            lastErrorMode;
    BOOL            gotInfo = FALSE;
    OLECHAR         alternatePath[256];
    CWsbStringPtr   queryPath;

    WsbTraceIn(OLESTR("CFsaResource::Init"), OLESTR("path = <%ls>, dosName = <%ls>"),
                                                (OLECHAR *)path, (OLECHAR *)dosName);
    try {

        WsbAssert(0 != path, E_POINTER);

        // Determine type of drive (removable, fixed, CD-ROM, RAM or network).
        type = GetDriveType(path);

        // Only FIXED or removable media are candidates for management
        // (ignore network drives, ...).
        //
        // NOTE: For now, it has been decided not to allow removable media.
        // if ((type == DRIVE_FIXED) || (type == DRIVE_REMOVABLE)) {
        if (type == DRIVE_FIXED) {

            // Get more information about the resource. For removable drives, we want to
            // fail if no volume is located.
            m_name.Realloc(128);    // volume name
            m_fsName.Realloc(128);  // volume file system type (e.g., FAT, NTFS)

            if (type == DRIVE_REMOVABLE) {
                // Suppress OS message asking to install a volume in the drive if it is
                // found to be missing.

                // First get the current error-mode bit flags by clearing them.
                lastErrorMode = SetErrorMode(0);
                // Reset error-mode bit flags by 'or'ing them with the value which
                // suppresses critical error messages.
                SetErrorMode(lastErrorMode | SEM_FAILCRITICALERRORS);

                gotInfo = GetVolumeInformation(path, m_name, 128, &m_serial,
                                    &m_maxComponentLength, &m_fsFlags, m_fsName, 128);

                // Got resource info, reset error-mode bit flags to original setting.
                SetErrorMode(lastErrorMode);

                // Throw and abort if no volume loaded.
                WsbAffirm(gotInfo, FSA_E_NOMEDIALOADED);

            } else { // if drive is a fixed drive type:

                // This call can fail.  This should just cause a message to be logged
                // and the resource to be skipped.
                try {
                    WsbAffirmStatus(GetVolumeInformation(path, m_name, 128, &m_serial,
                                        &m_maxComponentLength, &m_fsFlags, m_fsName, 128));
                } WsbCatchAndDo(hr,
                    WsbLogEvent(FSA_MESSAGE_RSCFAILEDINIT, 0, NULL, WsbHrAsString(hr),
                                    WsbAbbreviatePath(path, 120), 0);
                    WsbThrow(FSA_E_UNMANAGABLE);
                );
            }

            // Trace out info about the volume.
            CWsbStringPtr       traceString;

            traceString = m_fsName;

            traceString.Append(OLESTR("  file system, supports ... "));

            // Note that MS removed support for Remote Storage bit flag.
            if ((m_fsFlags & FILE_SUPPORTS_REPARSE_POINTS) != 0) {
                traceString.Append(OLESTR("reparse points ... "));
            }
            if ((m_fsFlags & FILE_SUPPORTS_SPARSE_FILES) != 0) {
                traceString.Append(OLESTR("sparse files ... "));
            }

            traceString.Append(OLESTR("\n"));

            WsbTrace(traceString);

            // Currently, we only support NTFS volumes that support sparse files and
            // reparse points (since support for Remote Storage bit flag was removed).
            if ((_wcsicmp(m_fsName, OLESTR("NTFS")) == 0) &&
                ((m_fsFlags & FILE_SUPPORTS_SPARSE_FILES) != 0) &&
                ((m_fsFlags & FILE_SUPPORTS_REPARSE_POINTS) != 0)) {

                // Indicate this is a manageable volume.
                hr = S_OK;

                // Store the parent FSA, but since it is a weak reference, do not AddRef().
                m_pFsaServer = pFsaServer;

                // Store the "sticky" name - this is the long ugly PNP name that can be
                // used if there is no drive letter.  (skip the prefix - \\?\)
                m_stickyName = &path[4];

                // Store the path to the resource.  Use the drive letter if it is present
                // (dosName != NULL and contains drive letter), else store it to be the same as the "sticky name".
                if (NULL != dosName) {
                    if ((wcslen(dosName) == 2) && (dosName[wcslen(dosName)-1] == L':')) {
                        m_path = dosName;
                        m_path.Append(OLESTR("\\"));
                    } else {
                        // It is a mount point path
                        m_path = &path[4];
                    }
                } else {
                    m_path = &path[4];
                }
                WsbTrace(OLESTR("CFsaResource::Init - m_path = %ws\n"), (WCHAR *) m_path);

                // Now save the "User Friendly" name for the resource.  If there is a
                // drive letter it is used.  If it is an unnamed volume then there is
                // no user friendly name and a NULL string is stored.  The volume name
                // should also be shown in this case.
                if (NULL != dosName) {
                    m_userName = dosName;
                    m_userName.Append(OLESTR("\\"));
                } else {

                    m_userName = L"";
                }

                WsbTrace(OLESTR("CFsaResource::Init - UserPath = %ws\n"), (WCHAR *) m_userName);

                // Get the alternate path to the resource.  This requires removing the '\'
                // from the path.
                queryPath = &path[4];
                if (L'\\' == queryPath[(int) wcslen((WCHAR *) queryPath) - 1]) {
                    queryPath[(int) wcslen((WCHAR *) queryPath) - 1] = L'\0';
                }

                WsbTrace(OLESTR("CFsaResource::Init - QueryPath = %ws\n"),
                                (WCHAR *) queryPath);

                WsbAffirm(QueryDosDevice(queryPath, alternatePath, 256) != 0,
                                HRESULT_FROM_WIN32(GetLastError()));
                m_alternatePath = alternatePath;
                //
                // Get the unique id for the volume
                //
                WsbAffirmHr(ReadIdentifier());
            }
        }

        m_isDirty = TRUE;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFsaResource::Init"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::InitializePremigrationList(
    BOOL bStartValidateJob
    )

/*++

Routine Description:

    If this volume is managed & active & available: create or 
    open the premigration-list DB; schedule a validate job if requested; 
    if recovery is also done, start the truncator running.

Arguments:

    bStartValidateJob - If TRUE, schedule a validate job on this volume
        if we just created a new DB

Return Value:

    S_OK    - The call succeeded.
    S_FALSE - The actions were skipped because some condition was not met
    E_*     - An error occurred.

--*/
{
    HRESULT                           hr = S_OK;


    WsbTraceIn(OLESTR("CFsaResource::InitializePremigrationList"), 
            OLESTR("m_managingHsm = %ls, m_isActive = %ls, m_isAvailable = %ls, m_isDbInitialized = %ls, m_isRecovered = %ls"),
            WsbGuidAsString(m_managingHsm), WsbBoolAsString(m_isActive), 
            WsbBoolAsString(m_isAvailable), WsbBoolAsString(m_isDbInitialized),
            WsbBoolAsString(m_isRecovered));
    try {
        if ((S_OK == IsManaged()) && m_isActive && m_isAvailable) {

            // Create/open the DB if not done already
            if (!m_isDbInitialized) {
                BOOL            bCreated;
                CWsbStringPtr   dbPath;
                CComPtr<IWsbDbSys>  pDbSys;

                WsbAffirmHr(m_pFsaServer->GetIDbSys(&pDbSys));
                WsbAffirmHr(GetDbPath(&dbPath, 0));
                WsbAffirmHr(m_pPremigrated->Init(dbPath, pDbSys, &bCreated));
                m_isDbInitialized = TRUE;
                if (bCreated) {
                    // Can't have recovery records if we just created
                    // the DB
                    m_isRecovered = TRUE;
                }

                if (bCreated && bStartValidateJob) {
                    LARGE_INTEGER           ctime;
                    FILETIME                curTime;
                    SYSTEMTIME              sysTime;
                    CWsbStringPtr           tmpString;

                    // Determine if the Engine is up and running.  If it isn't
                    // we have to set a value in the registry that the Engine 
                    // will find when it comes up and it will schedule the
                    // validate job.  If the Engine is up, we can take care of
                    // scheduling the validate job ourselves.  (If we don't, the
                    // Engine won't do it until the next time it starts up.)
                    hr = WsbCheckService(NULL, APPID_RemoteStorageEngine);
                    if (S_OK != hr) {
                        //  "Schedule" a validate job to rebuild the premigration list.
                        //  This is done by putting a value in the registry since the Engine
                        //  may not be running right now so we can't set up a job.
                        WsbLogEvent(FSA_MESSAGE_PREMIGRATION_LIST_MISSING, 0, NULL,
                                (OLECHAR *) m_path, NULL);
                        WsbAffirmHr(tmpString.Alloc(32));
                        swprintf((OLECHAR *) tmpString, L"%x", m_serial);
                        GetSystemTime( &sysTime );
                        WsbAffirmStatus(SystemTimeToFileTime(&sysTime, &curTime));
                        ctime.LowPart = curTime.dwLowDateTime;
                        ctime.HighPart = curTime.dwHighDateTime;
                        WsbAffirmHr( WsbEnsureRegistryKeyExists( 0, FSA_VALIDATE_LOG_KEY_NAME ) );
                        WsbAffirmHr(WsbSetRegistryValueData(NULL, FSA_VALIDATE_LOG_KEY_NAME,
                            tmpString, (BYTE *) &ctime, sizeof(ctime)));
                    } else {
                        WsbAffirmHr(CheckForValidate(TRUE));
                    }
                }
            }

            // Start the auto-truncator if recovery is done
            if (m_pTruncator && m_isRecovered) {

                // Try starting the truncator; ignore errors (we get one if
                // truncator is already started)
                m_pTruncator->Start((IFsaResource*) this);
            }
        }
    } WsbCatch(hr);
    WsbTraceOut(OLESTR("CFsaResource::InitializePremigrationList"), OLESTR("hr = <%ls>"), 
            WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaResource::InitializeUnmanageDb(
    void
    )

/*++

Implements:

  IFsaResourcePriv::InitializeUnmanageDb().

--*/
{
    HRESULT                           hr = S_OK;


    WsbTraceIn(OLESTR("CFsaResource::InitializeUnmanageDb"), 
            OLESTR("m_isActive = %ls, m_isAvailable = %ls, m_isUnmanageDbInitialized = %ls"), 
            WsbBoolAsString(m_isActive), WsbBoolAsString(m_isAvailable), WsbBoolAsString(m_isUnmanageDbInitialized));
    try {
        if ((S_OK == IsManaged()) && m_isActive && m_isAvailable) {
            if (! m_pUnmanageDb) {
                WsbAffirmHr(CoCreateInstance(CLSID_CFsaUnmanageDb, NULL, CLSCTX_SERVER, IID_IFsaUnmanageDb, (void**) &m_pUnmanageDb));
            }
            if (! m_isUnmanageDbInitialized) {
                BOOL                bCreated;
                CWsbStringPtr       dbPath;
                CComPtr<IWsbDbSys>  pDbSys;

                // Get (and init if necessary) the idb instance
                WsbAffirmHr(m_pFsaServer->GetUnmanageIDbSys(&pDbSys));

                // Initialize the db 
                WsbAffirmHr(GetUnmanageDbPath(&dbPath, 0));
                WsbAffirmHr(m_pUnmanageDb->Init(dbPath, pDbSys, &bCreated));

                // Init succeeded means DB must have been created 
                WsbAssert(bCreated, E_UNEXPECTED);

                m_isUnmanageDbInitialized = TRUE;
            }
        } else {
            hr = WSB_E_RESOURCE_UNAVAILABLE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::InitializeUnmanageDb"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaResource::TerminateUnmanageDb(
    void
    )

/*++

Implements:

  IFsaResourcePriv::TerminateUnmanageDb().

--*/
{
    HRESULT                           hr = S_OK;


    WsbTraceIn(OLESTR("CFsaResource::TerminateUnmanageDb"), 
            OLESTR("m_isUnmanageDbInitialized = %ls"), WsbBoolAsString(m_isUnmanageDbInitialized));
    try {
        if (m_isUnmanageDbInitialized) {
            WsbTrace(OLESTR("CFsaResource::TerminateUnmanageDb: Deleting Unmanage Db\n"));
            hr = m_pUnmanageDb->Delete(NULL, IDB_DELETE_FLAG_NO_ERROR);
            WsbTrace(OLESTR("CFsaResource::TerminateUnmanageDb: Deleting of Unmanage Db complete, hr = <%ls>\n"),
                WsbHrAsString(hr));
            if (SUCCEEDED(hr)) {
                m_isUnmanageDbInitialized = FALSE;
                m_pUnmanageDb = NULL;
            }
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::TerminateUnmanageDb"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaResource::IsActive(
    void
    )

/*++

Implements:

  IFsaResource::IsActive().

--*/
{
    return(m_isActive ? S_OK : S_FALSE);
}


HRESULT
CFsaResource::IsAvailable(
    void
    )

/*++

Implements:

  IFsaResource::IsAvailable().

--*/
{
    return(m_isAvailable ? S_OK : S_FALSE);
}


HRESULT
CFsaResource::IsDeletePending(
    void
    )

/*++

Implements:

  IFsaResource::IsDeletePending().

--*/
{
    return(m_isDeletePending ? S_OK : S_FALSE);
}



HRESULT
CFsaResource::IsManaged(
    void
    )

/*++

Implements:

  IFsaResource::IsManaged().

--*/
{
    HRESULT         hr = S_OK;

    if (memcmp(&m_managingHsm, &GUID_NULL, sizeof(GUID)) == 0) {
        hr = S_FALSE;
    }

    return(hr);
}


HRESULT
CFsaResource::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;
    CComPtr<IWsbCollectable>    pCollectable;

    WsbTraceIn(OLESTR("CFsaResource::Load"), OLESTR(""));

    try {
        ULONG  tmp;

        WsbAssert(0 != pStream, E_POINTER);

        // Do the easy stuff, but make sure that this order matches the order
        // in the save method.
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_oldPath, 0));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_alternatePath, 0));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_name, 0));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_stickyName, 0));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_fsName, 0));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_maxComponentLength));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_fsFlags));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_id));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isActive));
        WsbAffirmHr(WsbLoadFromStream(pStream, &tmp));
        m_compareBy = (FSA_RESOURCE_COMPARE)tmp;
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_managingHsm));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_hsmLevel));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_premigratedSize));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_truncatedSize));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_manageableItemLogicalSize));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_manageableItemAccessTimeIsRelative));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_manageableItemAccessTime));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_usnJournalId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_lastUsnId));


        // Load the default rules list
        WsbAffirm(m_pDefaultRules != NULL, E_UNEXPECTED);
        WsbAffirmHr((m_pDefaultRules)->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        // Load the premigration list DB
        WsbAffirm(m_pPremigrated != NULL, E_UNEXPECTED);
        WsbAffirmHr(((IWsbDb*)m_pPremigrated)->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        hr = pPersistStream->Load(pStream);
        WsbTrace(OLESTR("CFsaResource::Load, DB load hr = <%ls>\n"), WsbHrAsString(hr));
        if (S_OK == hr) {
            m_isDbInitialized = TRUE;
        } else {
            m_isDbInitialized = FALSE;
            hr = S_OK;
        }

        pPersistStream = 0;

        // Load the truncator.
        WsbAffirm(m_pTruncator != NULL, E_UNEXPECTED);
        WsbAffirmHr(m_pTruncator->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaResource::Manage(
    IN IFsaScanItem* pScanItem,
    IN LONGLONG /*offset*/,
    IN LONGLONG /*size*/,
    IN GUID storagePoolId,
    IN BOOL truncate
    )

/*++

Implements:

  IFsaResource::Manage().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IFsaPostIt>     pWorkItem;
    CComPtr<IHsmFsaTskMgr>  pEngine;
    CComPtr<IHsmSession>    pSession;
    CWsbStringPtr           tmpString;
    LONGLONG                fileVersionId;
    LONGLONG                requestSize;

    WsbTraceIn(OLESTR("CFsaResource::Manage"), OLESTR(""));

    try {

        // Make sure the  Scan Item interface is OK
        WsbAssert(pScanItem != 0, E_POINTER);
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaPostIt, 0, CLSCTX_SERVER, IID_IFsaPostIt, (void**) &pWorkItem));

        // Get the data from the scan item.
        WsbAffirmHr(pScanItem->GetSession(&pSession));
        WsbAffirmHr(pWorkItem->SetSession(pSession));

        WsbAffirmHr(pScanItem->GetPathAndName(0, &tmpString, 0));
        WsbAffirmHr(pScanItem->GetVersionId(&fileVersionId));
        WsbAffirmHr(pWorkItem->SetFileVersionId(fileVersionId));

        // Currently, we only can ask for the whole file.
        WsbAffirmHr(pWorkItem->SetRequestOffset(0));
        WsbAffirmHr(pScanItem->GetLogicalSize(&requestSize));
        WsbAffirmHr(pWorkItem->SetRequestSize(requestSize));

        // Fill in the rest of the work
        WsbAffirmHr(pWorkItem->SetStoragePoolId(storagePoolId));

        WsbAffirmHr(pWorkItem->SetRequestAction(FSA_REQUEST_ACTION_PREMIGRATE));
        if (truncate) {
            WsbAffirmHr(pWorkItem->SetResultAction(FSA_RESULT_ACTION_TRUNCATE));
        } else {
            WsbAffirmHr(pWorkItem->SetResultAction(FSA_RESULT_ACTION_LIST));
        }

        // Send the request to the task manager
        WsbAffirmHr(GetHsmEngine(&pEngine));
        WsbAffirmHr(pWorkItem->SetPath(tmpString));
        WsbAffirmHr(pScanItem->PrepareForManage(0, requestSize));
        WsbAffirmHr(pEngine->DoFsaWork(pWorkItem));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::Manage"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaResource::ManagedBy(
    IN GUID hsmId,
    IN ULONG hsmLevel,
    IN BOOL release
    )

/*++

Implements:

  IFsaResource::ManagedBy().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmSession>    pSession;
    HANDLE                  threadHandle;

    WsbTraceIn(OLESTR("CFsaResource::ManagedBy"), OLESTR("HsmId - <%ls>, hsmLevel - <%lu>, release = <%ls>"),
                        WsbGuidAsString(hsmId), hsmLevel, WsbBoolAsString(release));
    try {

        // Are we releasing or acquiring a managing HSM?
        if (release) {

            // We can only release if we are the orignal owner. This is to prevent two HSMs from thinking they
            // manage the same resource at the same time. We may want a better way to do this.
            WsbAffirm(memcmp(&m_managingHsm, &hsmId, sizeof(GUID)) == 0, FSA_E_RSCALREADYMANAGED);

            // If the truncator is running, then ask it to stop.
            WsbAffirmHr(m_pTruncator->GetSession(&pSession));
            if (pSession != 0) {
                WsbAffirmHr(pSession->ProcessEvent(HSM_JOB_PHASE_ALL, HSM_JOB_EVENT_CANCEL));
            }

            // Clear out the managing Hsm.
            m_managingHsm = GUID_NULL;
            m_pHsmEngine = 0;
            m_isDeletePending = FALSE;
            threadHandle = CreateThread(0, 0, FsaStartOnStateChange, (void*) this, 0, &g_ThreadId);
            if (threadHandle != NULL) {
               CloseHandle(threadHandle);
            }

        } else {
            // Make sure there is a journal
            // At this point we don't care about the need to
            // validate
            BOOL validateNeeded;
            WsbAffirmHr(CheckForJournal(&validateNeeded));

            // Is the id changing?
            if (memcmp(&m_managingHsm, &hsmId, sizeof(GUID)) != 0) {

                // Make sure that they set it to something valid.
                WsbAssert(memcmp(&GUID_NULL, &hsmId, sizeof(GUID)) != 0, E_INVALIDARG);

                // If the truncator is running, then ask it to stop.
                WsbAffirmHr(m_pTruncator->GetSession(&pSession));
                if (pSession != 0) {
                    WsbAffirmHr(pSession->ProcessEvent(HSM_JOB_PHASE_ALL, HSM_JOB_EVENT_CANCEL));
                }

                // Create/Recreate the default rules.
                WsbAffirmHr(CreateDefaultRules());

                // Store the Id and level.
                m_managingHsm = hsmId;
                m_hsmLevel = hsmLevel;
                m_pHsmEngine = 0;

                // Do recovery (if needed) and start truncator
                if (m_isActive) {
                    if (m_isDbInitialized && !m_isRecovered) {
                        // DoRecovery will start truncator when it is done
                        WsbAffirmHr(DoRecovery());
                    } else {
                        WsbAffirmHr(InitializePremigrationList(TRUE));
                    }
                }

                threadHandle = CreateThread(0, 0, FsaStartOnStateChange, (void*) this, 0, &g_ThreadId);
                if (threadHandle != NULL) {
                   CloseHandle(threadHandle);
                }

            } else {
                BOOL DoKick = FALSE;

                if (m_hsmLevel < hsmLevel) {
                    DoKick = TRUE;
                }
                m_hsmLevel = hsmLevel;

                // Create/Recreate the default rules.
                WsbAffirmHr(CreateDefaultRules());

                // Wake up the AutoTruncator if the new level is higher
                if (DoKick) {
                    WsbAffirmHr(m_pTruncator->KickStart());
                }
            }
        }

        m_isDirty = TRUE;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::ManagedBy"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::NeedsRepair(
    void
    )

/*++

Implements:

  IFsaResource::NeedsRepair().

--*/
{
    HRESULT             hr = S_OK;
    ULONG               flag;
    IO_STATUS_BLOCK     Iosb;
    CWsbStringPtr       volumePath;
    HANDLE              volumeHandle = INVALID_HANDLE_VALUE;

    WsbTraceIn(OLESTR("CFsaResource::NeedsRepair"), OLESTR(""));

    try {

        volumePath = L"\\\\.\\";
        WsbAffirmHr(volumePath.Append(m_path));
        ((OLECHAR *) volumePath)[wcslen(volumePath) - 1] = L'\0';
        WsbAffirmHandle(volumeHandle = CreateFileW(volumePath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL));
        WsbAffirmNtStatus(NtFsControlFile(volumeHandle, NULL, NULL, NULL, &Iosb, FSCTL_IS_VOLUME_DIRTY, NULL, 0, &flag, sizeof(flag)));
        WsbAffirmNtStatus(Iosb.Status);

        if ((flag & VOLUME_IS_DIRTY) == 0) {
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    if (INVALID_HANDLE_VALUE != volumeHandle) {
        CloseHandle(volumeHandle);
    }

    WsbTraceOut(OLESTR("CFsaResource::NeedsRepair"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaResource::ProcessResult(
    IN IFsaPostIt*      pResult
    )

/*++

Implements:

  IFsaResource::ProcessResult().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaScanItem>       pScanItem;
    CComPtr<IHsmSession>        pSession;
    FILETIME                    currentTime;
    FSA_RESULT_ACTION           resultAction = FSA_RESULT_ACTION_NONE;
    FSA_PLACEHOLDER             placeholder;
    CWsbStringPtr               path;
    LONGLONG                    offset;
    LONGLONG                    size;
    ULONG                       mode;
    HRESULT                     resultHr;
    CComPtr<IFsaFilterRecall>   pRecall;
    ULONG                       completionSent = FALSE;
    LONGLONG                    usn;
    LONGLONG                    afterPhUsn;


    WsbTraceIn(OLESTR("CFsaResource::ProcessResult"), OLESTR(""));

    try {
        BOOL    wasPremigrated = FALSE;
        BOOL    wasTruncated   = FALSE;

        // Several of the actions need to know the current time, so calculate it now.
        GetSystemTimeAsFileTime(&currentTime);

        // Since the workItem session is IUnknown, QI for what we want.
        WsbAffirmHr(pResult->GetSession(&pSession));


        // Now perform the required action.
        WsbAffirmHr(pResult->GetResultAction(&resultAction));
        WsbAffirmHr(pResult->GetPlaceholder(&placeholder));
        WsbAffirmHr(pResult->GetPath(&path, 0));
        WsbAffirmHr(pResult->GetRequestOffset(&offset));
        WsbAffirmHr(pResult->GetRequestSize(&size));
        WsbAffirmHr(pResult->GetMode(&mode));
        WsbAffirmHr(pResult->GetUSN(&usn));
        WsbTrace(OLESTR("CFsaResource::ProcessResult, path = <%ls>, requestOffset = %I64d, requestSize = %I64d\n"),
            WsbAbbreviatePath(path, 120), offset, size);

        switch(resultAction) {

        case FSA_RESULT_ACTION_DELETE:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Delete\n"));
            WsbAffirmHr(FindFirst(path, pSession, &pScanItem));
            if (S_OK == pScanItem->IsPremigrated(offset, size)) {
                wasPremigrated = TRUE;
            } else if (S_OK == pScanItem->IsTruncated(offset, size)) {
                wasTruncated = TRUE;
            }
            WsbAffirmHr(pScanItem->Delete());
            if (wasPremigrated) {
                WsbAffirmHr(RemovePremigrated(pScanItem, offset, size));
            } else if (wasTruncated) {
                WsbAffirmHr(RemoveTruncated(pScanItem, offset, size));
            }
            break;

        case FSA_RESULT_ACTION_DELETEPLACEHOLDER:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Delete Placeholder\n"));
            WsbAffirmHr(FindFirst(path, pSession, &pScanItem));

            //  We shouldn't have gotten to here if the file isn't managed,
            //  but it's been known to happen
            if (S_OK == pScanItem->IsManaged(offset, size)) {
                HRESULT hrRemove = S_OK;

                if (S_OK == pScanItem->IsPremigrated(offset, size)) {
                    wasPremigrated = TRUE;
                } else if (S_OK == pScanItem->IsTruncated(offset, size)) {
                    wasTruncated = TRUE;
                }

                // RemovePremigrated needs to get some information from the placeholder, therefore, remove
                // from premigrated db first and then (regardless of the result), delete the placeholder
                if (wasPremigrated) {
                    hrRemove = RemovePremigrated(pScanItem, offset, size);
                } else if (wasTruncated) {
                    hrRemove = RemoveTruncated(pScanItem, offset, size);
                }
                WsbAffirmHr(pScanItem->DeletePlaceholder(offset, size));
                WsbAffirmHr(hrRemove);
            }

            //  Remove the recovery record if we created one
            if (m_isDbInitialized) {
                BOOL bOpenDb = FALSE;
                CComPtr<IWsbDbSession>   pDbSession;
                CComPtr<IFsaRecoveryRec> pRecRec;

                try {
                    WsbAffirmHr(m_pPremigrated->Open(&pDbSession));
                    bOpenDb = TRUE;
                    WsbAffirmHr(m_pPremigrated->GetEntity(pDbSession, RECOVERY_REC_TYPE,
                            IID_IFsaRecoveryRec, (void**) &pRecRec));
                    WsbAffirmHr(pRecRec->SetPath(path));
                    if (S_OK == pRecRec->FindEQ()) {
                        WsbAffirmHr(pRecRec->Remove());
                    }
                } WsbCatch(hr);
                if (bOpenDb) {
                    WsbAffirmHr(m_pPremigrated->Close(pDbSession));
                }
            }
            break;

        case FSA_RESULT_ACTION_LIST:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Truncate / Add to Premigration List\n"));
            WsbAffirmHr(FindFirst(path, pSession, &pScanItem));
            (placeholder).isTruncated = FALSE;
            (placeholder).migrationTime = currentTime;
            hr = pScanItem->CreatePlaceholder(offset, size, placeholder, TRUE, usn, &afterPhUsn);

            if (SUCCEEDED(hr) && (FSA_E_REPARSE_NOT_WRITTEN_FILE_CHANGED != hr)) {
                //
                // Add the file to the premigration list.  If this fails, log and error
                // and request that the validation code be run to hopefully correct this
                // problem.   This problem should not stop processing, so return OK
                //
                hr = AddPremigrated(pScanItem, offset, size, FALSE, afterPhUsn);
                if (!SUCCEEDED(hr))  {
                    WsbLogEvent(FSA_MESSAGE_FILE_NOT_IN_PREMIG_LIST, 0, NULL,  WsbAbbreviatePath(path, 120), WsbHrAsString(hr), NULL);
                    //
                    // TBD - launch validate job
                    //
                    hr = S_OK;
                }
                //
                // Tell the truncator that we have added something to the list in case we are over the level.
                // This will kick start the truncator to insure quick response.
                //
                WsbAffirmHr(m_pTruncator->KickStart());
            }

            break;

        case FSA_RESULT_ACTION_NONE:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - None\n"));
            break;

        case FSA_RESULT_ACTION_OPEN:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Open (No longer placeholder)\n"));

            // If it succeeded, then update the placeholder information.
            WsbAffirmHr(pResult->GetResult(&resultHr));
            WsbAffirmHr(pResult->GetFilterRecall(&pRecall));
            WsbAssert(pRecall != 0, E_POINTER);

            if (SUCCEEDED(resultHr)) {
                WsbAffirmHr(FindFirst(path, pSession, &pScanItem));

                // The placeholder info is updated by the filter now.
            //    placeholder.recallTime = currentTime;
            //    placeholder.recallCount++;
            //    placeholder.isTruncated = FALSE;
            //    placeholder.truncateOnClose = FALSE;
            //    placeholder.premigrateOnClose = FALSE;
            //    WsbAffirmHr(pScanItem->CreatePlaceholder(offset, size, placeholder, TRUE, usn, &afterPhUsn));
            }

            // If it had succeeded, then add the file in the premigration list.
            // (This used to be done after communicating with the filter to
            // give the client time to open the file before the truncator would
            // try to retruncate it.  This is no longer needed since we do the
            // recall on first I/O not on the open.  Leaving that order created
            // a new problem: the file would have a reparse point saying it was
            // premigrated and test code could then try to retruncate it, but it
            // wouldn't be in the premigration list yet.)
            if (SUCCEEDED(resultHr)) {
                //
                // We do not need to fail the recall if we cannot add the file to the premigration list.
                // Just log a warning, if appropriate, and continue
                //
                try {
                   WsbAffirmHr(RemoveTruncated(pScanItem, offset, size));
                   WsbAffirmHr(pScanItem->GetFileUsn(&afterPhUsn));
                   WsbAffirmHr(AddPremigrated(pScanItem, offset, size, TRUE, afterPhUsn));
                } WsbCatchAndDo(hr,
                   //
                   // We failed to add it to the premigration list.  In some cases this is not an error worth
                   // reporting.  For instance, when a file is moved to another volume it is copied (causing a recall) and then
                   // deleted.  We can get an error here if the delete is pending or has completed and the failure to
                   // add the original file to the premigration list is not an error since the file is now gone.
                   //
                   if ( (hr != WSB_E_NOTFOUND) &&
                        ((hr & ~(FACILITY_NT_BIT)) != STATUS_DELETE_PENDING) ) {
                         //
                         // Log all other errors
                         //
                         WsbLogEvent(FSA_MESSAGE_FILE_NOT_IN_PREMIG_LIST, 0, NULL,
                            (OLECHAR *) m_path, WsbQuickString(WsbHrAsString(hr)), NULL);
                   }
                );
            }

            // Tell the filter that the recall attempt finished.
            hr = pRecall->HasCompleted(resultHr);
            completionSent = TRUE;

            //  Remove the recovery record if we created one
            if (m_isDbInitialized) {
                BOOL bOpenDb = FALSE;
                CComPtr<IWsbDbSession>   pDbSession;
                CComPtr<IFsaRecoveryRec> pRecRec;

                try {
                    WsbAffirmHr(m_pPremigrated->Open(&pDbSession));
                    bOpenDb = TRUE;
                    WsbAffirmHr(m_pPremigrated->GetEntity(pDbSession, RECOVERY_REC_TYPE,
                            IID_IFsaRecoveryRec, (void**) &pRecRec));
                    WsbAffirmHr(pRecRec->SetPath(path));
                    if (S_OK == pRecRec->FindEQ()) {
                        WsbAffirmHr(pRecRec->Remove());
                    }
                } WsbCatch(hr);
                if (bOpenDb) {
                    WsbAffirmHr(m_pPremigrated->Close(pDbSession));
                }
            }
            break;

        case FSA_RESULT_ACTION_PEEK:
        case FSA_RESULT_ACTION_REPARSE:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Peek/Reparse\n"));
            hr = E_NOTIMPL;
            break;

        case FSA_RESULT_ACTION_TRUNCATE:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Truncate\n"));
            WsbAffirmHr(FindFirst(path, pSession, &pScanItem));
            placeholder.isTruncated = FALSE;
            placeholder.migrationTime = currentTime;
            hr = pScanItem->CreatePlaceholder(offset, size, placeholder, TRUE, usn, &afterPhUsn);
            if (SUCCEEDED(hr) && (FSA_E_REPARSE_NOT_WRITTEN_FILE_CHANGED != hr)) {
                WsbAffirmHr(pScanItem->Truncate(offset, size));
            }
            break;

        case FSA_RESULT_ACTION_REWRITEPLACEHOLDER:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Rewrite Placeholder\n"));
            WsbAffirmHr(FindFirst(path, pSession, &pScanItem));
            WsbAffirmHr(pScanItem->CreatePlaceholder(offset, size, placeholder, TRUE, usn, &afterPhUsn));
            break;

        case FSA_RESULT_ACTION_RECALLEDDATA:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Recalled\n"));
            WsbAffirmHr(FindFirst(path, pSession, &pScanItem));
            placeholder.isTruncated = FALSE;
            placeholder.recallTime = currentTime;
            placeholder.recallCount++;
            WsbAffirmHr(pScanItem->CreatePlaceholder(offset, size, placeholder, TRUE, usn, &afterPhUsn));
            WsbAffirmHr(RemoveTruncated(pScanItem, offset, size));
            WsbAffirmHr(AddPremigrated(pScanItem, offset, size, FALSE, afterPhUsn));

            //  Remove the recovery record if we created one
            if (m_isDbInitialized) {
                BOOL bOpenDb = FALSE;
                CComPtr<IWsbDbSession>   pDbSession;
                CComPtr<IFsaRecoveryRec> pRecRec;

                try {
                    WsbAffirmHr(m_pPremigrated->Open(&pDbSession));
                    bOpenDb = TRUE;
                    WsbAffirmHr(m_pPremigrated->GetEntity(pDbSession, RECOVERY_REC_TYPE,
                            IID_IFsaRecoveryRec, (void**) &pRecRec));
                    WsbAffirmHr(pRecRec->SetPath(path));
                    if (S_OK == pRecRec->FindEQ()) {
                        WsbAffirmHr(pRecRec->Remove());
                    }
                } WsbCatch(hr);
                if (bOpenDb) {
                    WsbAffirmHr(m_pPremigrated->Close(pDbSession));
                }
            }
            break;

        case FSA_RESULT_ACTION_NORECALL:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Open without recall\n"));
            // Tell the filter that the recall attempt finished.
            WsbAffirmHr(pResult->GetResult(&resultHr));
            WsbAffirmHr(pResult->GetFilterRecall(&pRecall));
            WsbAssert(pRecall != 0, E_POINTER);
            hr = pRecall->HasCompleted(resultHr);
            completionSent = TRUE;
            break;

        case FSA_RESULT_ACTION_VALIDATE_BAD:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Validate Bad\n"));
            WsbAffirmHr(pResult->GetResult(&resultHr));
            WsbAffirmHr(FindFirst(path, pSession, &pScanItem));
            if (S_OK == pScanItem->IsPremigrated(offset, size)) {
                WsbLogEvent(FSA_MESSAGE_VALIDATE_UNMANAGED_FILE_ENGINE, 0, NULL,  WsbAbbreviatePath(path, 120), (OLECHAR *)m_path, WsbHrAsString(resultHr), WsbQuickString(WsbHrAsString(resultHr)), NULL);
                WsbAffirmHr(pScanItem->DeletePlaceholder(offset, size));
            } else if (S_OK == pScanItem->IsTruncated(offset, size)) {
                //
                //  We no longer delete bad placeholders here - let the diagnostic tool clean them up
                //  The message that is logged here has been changed to indicate that the file did not validate
                //  and will not be recallable until the problem is fixed.
                //WsbAffirmHr(pScanItem->Delete());
                WsbLogEvent(FSA_MESSAGE_VALIDATE_DELETED_FILE_ENGINE, 0, NULL,  WsbAbbreviatePath(path, 120), (OLECHAR *) m_path, WsbHrAsString(resultHr), WsbQuickString(WsbHrAsString(resultHr)), NULL);
            }
            break;

        case FSA_RESULT_ACTION_VALIDATE_OK:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Validate OK\n"));
            if (m_isDoingValidate) {
                WsbAffirmHr(FindFirst(path, pSession, &pScanItem));
                if (S_OK == pScanItem->IsPremigrated(offset, size)) {
                    WsbAffirmHr(AddPremigrated(pScanItem, offset, size, FALSE, usn));
                } else if (S_OK == pScanItem->IsTruncated(offset, size)) {
                    WsbAffirmHr(AddTruncated(pScanItem, offset, size));
                }
            }
            break;

        case FSA_RESULT_ACTION_VALIDATE_FOR_TRUNCATE_BAD:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Validate for truncate Bad\n"));
            //
            // The file did not validate - make it back into a real file
            //
            WsbAffirmHr(FindFirst(path, pSession, &pScanItem));
            if (S_OK == pScanItem->IsPremigrated(offset, size)) {
                WsbAffirmHr(pScanItem->DeletePlaceholder(offset, size));
            }
            break;

        case FSA_RESULT_ACTION_VALIDATE_FOR_TRUNCATE_OK:
            WsbTrace(OLESTR("CFsaResource::ProcessResult - Validate for truncate OK\n"));
            //
            // The file validated - go ahead and truncate it (if it has not changed)
            //
            WsbAffirmHr(FindFirst(path, pSession, &pScanItem));
            WsbAffirmHr(pScanItem->TruncateValidated(offset, size));
            break;

        default:
            WsbAssert(FALSE, E_FAIL);
            break;
        }

    } WsbCatchAndDo(hr,
        if (completionSent == FALSE) {
            switch(resultAction) {
                //
                //If it was a demand recall we must make all effort to let them know it failed
                //
                case FSA_RESULT_ACTION_OPEN:
                case FSA_RESULT_ACTION_NORECALL:
                    WsbTrace(OLESTR("CFsaResource::ProcessResult - Open (No longer placeholder)\n"));
                    // Tell the filter that the recall attempt finished.
                    pRecall = 0;        // Just in case we already had the interfae we deref it here.
                    hr = pResult->GetFilterRecall(&pRecall);
                    if (hr == S_OK) {
                        hr = pRecall->HasCompleted(E_FAIL);
                    }
                    break;
                default:
                    break;
            }
        }
    );

    WsbTraceOut(OLESTR("CFsaResource::ProcessResult"), OLESTR("hr = %ls"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaResource::ReadIdentifier(
    void
    )

/*++


--*/
{
    HRESULT                           hr = S_OK;
    CWsbStringPtr                     tmpString;
    HANDLE                            aHandle;
    ULONG                             size;
    UCHAR                             bytes[sizeof(m_id)];
    PUCHAR                            bytePtr;
    UCHAR                             buffer[sizeof(FILE_FS_VOLUME_INFORMATION)+MAX_PATH];
    PFILE_FS_VOLUME_INFORMATION       volInfo;
    NTSTATUS                          status = STATUS_SUCCESS;
    IO_STATUS_BLOCK                   ioStatus;
    WCHAR *                           wString = NULL;

    try {

        //
        // The identifier is composed of:
        //
        // 15     14       13    12    11    10    9     8   7    6     5    4    3       2    1     0
        // 0      0        0      0    <---------Volume Creation Time-------->    <Volume Serial Number>
        // We need to open a handle to the volume
        //
        tmpString = m_path;
        WsbAffirmHr(tmpString.Prepend("\\\\?\\"));

        tmpString.CopyTo(&wString);
        //
        // Remove trailing backslash in the path
        //
        wString[wcslen(wString)-1] = L'\0';

        WsbAffirmHandle(aHandle = CreateFile(wString,
                                             GENERIC_READ,
                                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                                             0,
                                             OPEN_EXISTING,
                                             FILE_ATTRIBUTE_NORMAL,
                                             0));
        WsbFree(wString);
        wString = NULL;

        try {

            volInfo = (PFILE_FS_VOLUME_INFORMATION) buffer;
            bytePtr = bytes;

            status = NtQueryVolumeInformationFile(
                                    aHandle,
                                    &ioStatus,
                                    buffer,
                                    sizeof(buffer),
                                    FileFsVolumeInformation);

            WsbAffirmNtStatus(status);
            //
            // Volume serial number forms the lower 4 bytes of the GUID
            //
            WsbAffirmHr(WsbConvertToBytes(bytePtr, volInfo->VolumeSerialNumber, &size));
            WsbAffirm(size == sizeof(volInfo->VolumeSerialNumber), E_FAIL);
            //
            // Volume creation time forms the next 8 bytes
            //
            bytePtr += size;
            WsbAffirmHr(WsbConvertToBytes(bytePtr, volInfo->VolumeCreationTime.QuadPart, &size));
            WsbAffirm(size == sizeof(volInfo->VolumeCreationTime.QuadPart), E_FAIL);
            //
            // Next 4 bytes: 0's are good as any
            //
            bytePtr += size;
            WsbAffirmHr(WsbConvertToBytes(bytePtr, (ULONG) 0, &size));
            WsbAffirm(size == sizeof(ULONG), E_FAIL);

            WsbAffirmHr(WsbConvertFromBytes(bytes, &m_id, &size));
            WsbAffirm(size == sizeof(m_id), E_FAIL);

        } WsbCatch(hr);

        WsbAffirmStatus(CloseHandle(aHandle));

        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::Recall(
    IN IFsaScanItem* pScanItem,
    IN LONGLONG offset,
    IN LONGLONG size,
    IN BOOL deletePlaceholder
    )

/*++

Implements:

  IFsaResource::Recall().

--*/
{
    HRESULT                     hr = S_OK;
    HRESULT                     hrFind;
    CComPtr<IFsaPostIt>         pWorkItem;
    LONGLONG                    fileId;
    CComPtr<IHsmFsaTskMgr>      pEngine;
    CComPtr<IHsmSession>        pSession;
    CComPtr<IWsbDbSession>      pDbSession;
    CComPtr<IFsaRecoveryRec>    pRecRec;
    CWsbStringPtr               tmpString;
    FSA_PLACEHOLDER             placeholder;
    LONGLONG                    fileVersionId;


    WsbTraceIn(OLESTR("CFsaResource::Recall"), OLESTR(""));
    try {

        // Make sure the  Scan Item interface is OK
        WsbAssert(pScanItem != 0, E_FAIL);
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaPostIt, 0, CLSCTX_SERVER, IID_IFsaPostIt, (void**) &pWorkItem));

        // Get the data from the scan item.
        WsbAffirmHr(pScanItem->GetSession((IHsmSession**) &(pSession)));
        WsbAffirmHr(pWorkItem->SetSession(pSession));

        WsbAffirmHr(pScanItem->GetPathAndName(0, &tmpString, 0));
        WsbAffirmHr(pWorkItem->SetPath(tmpString));

        WsbAffirmHr(pWorkItem->SetRequestOffset(offset));
        WsbAffirmHr(pWorkItem->SetRequestSize(size));

        WsbAffirmHr(pScanItem->GetPlaceholder(offset, size, &placeholder));
        WsbAffirmHr(pWorkItem->SetPlaceholder(&placeholder));

        WsbAffirmHr(pScanItem->GetVersionId(&fileVersionId));
        WsbAffirmHr(pWorkItem->SetFileVersionId(fileVersionId));


        // Fill in the rest of the work
        WsbAffirmHr(pWorkItem->SetRequestAction(FSA_REQUEST_ACTION_RECALL));
        if (deletePlaceholder) {
            WsbAffirmHr(pWorkItem->SetResultAction(FSA_RESULT_ACTION_DELETEPLACEHOLDER));
        } else {
            WsbAffirmHr(pWorkItem->SetResultAction(FSA_RESULT_ACTION_RECALLEDDATA));
        }

        // Send the request to the task manager. If the file was archived by someone other
        // than the managing HSM, then that HSM will need to be looked up.
        if ( GUID_NULL != m_managingHsm &&
             memcmp(&m_managingHsm, &(placeholder.hsmId), sizeof(GUID)) == 0) {
            WsbAffirmHr(GetHsmEngine(&pEngine));
        } else {
            CComPtr<IHsmServer>     pHsmServer;

            WsbAssertHr(HsmConnectFromId(HSMCONN_TYPE_HSM, placeholder.hsmId, IID_IHsmServer, (void**) &pHsmServer));
            WsbAffirmHr(pHsmServer->GetHsmFsaTskMgr(&pEngine));
        }

        WsbAffirmHr(pScanItem->GetFileId(&fileId));

        if (m_isDbInitialized) {
            //  Save a recovery record in case anything goes wrong
            WsbAffirmHr(m_pPremigrated->Open(&pDbSession));
            WsbAffirmHr(m_pPremigrated->GetEntity(pDbSession, RECOVERY_REC_TYPE, IID_IFsaRecoveryRec, (void**) &pRecRec));
            WsbAffirmHr(pRecRec->SetPath(tmpString));

            // If the record already exists rewrite it, otherwise create a new record.
            hrFind = pRecRec->FindEQ();
            if (WSB_E_NOTFOUND == hrFind) {
                WsbAffirmHr(pRecRec->MarkAsNew());
            } else if (FAILED(hrFind)) {
                WsbThrow(hrFind);
            }

            WsbAffirmHr(pRecRec->SetFileId(fileId));
            WsbAffirmHr(pRecRec->SetOffsetSize(offset, size));
            WsbAffirmHr(pRecRec->SetStatus(FSA_RECOVERY_FLAG_RECALLING));
            WsbAffirmHr(pRecRec->Write());
        }

        try {
            WsbAffirmHr(pEngine->DoFsaWork(pWorkItem));
        } WsbCatchAndDo(hr,
            // This FindEQ seems unnecessary, but we can't assume the
            // the Remove will work
            if (pRecRec) {
                if (SUCCEEDED(pRecRec->FindEQ())) {
                    hr = pRecRec->Remove();
                }
            }
        );

    } WsbCatch(hr);

    if (pDbSession != 0) {
        m_pPremigrated->Close(pDbSession);
    }

    WsbTraceOut(OLESTR("CFsaResource::Recall"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::RemovePremigrated(
    IN IFsaScanItem* pScanItem,
    IN LONGLONG offset,
    IN LONGLONG size
    )

/*++

Implements:

  IFsaResource::RemovePremigrated().

--*/
{
    HRESULT                     hr = S_OK;
    CWsbStringPtr               path;
    CComPtr<IWsbDbSession>      pDbSession;
    CComPtr<IFsaPremigratedRec> pRec;

    WsbTraceIn(OLESTR("CFsaResource::RemovePremigrated"), OLESTR(""));

    try {

        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAffirm(m_pPremigrated != NULL, E_UNEXPECTED);

        // Open the database.
        WsbAffirmHr(m_pPremigrated->Open(&pDbSession));

        // Protect the removal with Jet transaction since the auto-truncator thread 
        // may try to remove the same record at the same time
        WsbAffirmHr(pDbSession->TransactionBegin());

        try {
            LONGLONG        itemSize;
            HRESULT         hrTemp;

            // Find the record using the bag/offsets key.
            WsbAffirmHr(m_pPremigrated->GetEntity(pDbSession, PREMIGRATED_REC_TYPE, IID_IFsaPremigratedRec, (void**) &pRec));
            WsbAffirmHr(pRec->UseKey(PREMIGRATED_BAGID_OFFSETS_KEY_TYPE));
            WsbAffirmHr(pRec->SetFromScanItem(pScanItem, offset, size, FALSE));

            // The record may already been deleted by the auto-truncator
            hrTemp = pRec->FindEQ();
            if (hrTemp == WSB_E_NOTFOUND) {
                hr = S_OK;
                WsbThrow(hr);
            }
            WsbAffirmHr(hrTemp);

            WsbAffirmHr(pRec->GetSize(&itemSize));

            // the record may be involved with another transaction with delete pending
            hrTemp = pRec->Remove();
            if (hrTemp == WSB_E_IDB_UPDATE_CONFLICT) {
                hr = S_OK;
                WsbThrow(hr);
            }
            WsbAffirmHr(hrTemp);

            // Remove the size of the section from the amount of premigrated data.
            RemovePremigratedSize(itemSize);
            m_isDirty = TRUE;

        } WsbCatch(hr);

        WsbAffirmHr(pDbSession->TransactionEnd());

        WsbAffirmHr(m_pPremigrated->Close(pDbSession));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::RemovePremigrated"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaResource::RemoveTruncated(
    IN IFsaScanItem* /*pScanItem*/,
    IN LONGLONG /*offset*/,
    IN LONGLONG size
    )

/*++

Implements:

  IFsaResource::RemoveTruncated().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::RemoveTruncated"), OLESTR(""));

    try {

        WsbAffirmHr(RemoveTruncatedSize(size));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::RemoveTruncated"),
            OLESTR("hr = <%ls>, m_truncatedSize = %I64d"), WsbHrAsString(hr),
            m_truncatedSize);

    return(hr);
}


HRESULT
CFsaResource::RemoveTruncatedSize(
    IN LONGLONG size
    )

/*++

Implements:

  IFsaResource::RemoveTruncatedSize().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::RemoveTruncatedSize"), OLESTR(""));

    try {

        m_truncatedSize = max(0, m_truncatedSize - size);
        m_isDirty = TRUE;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::RemoveTruncatedSize"),
            OLESTR("hr = <%ls>, m_truncatedSize = %I64d"), WsbHrAsString(hr),
            m_truncatedSize);

    return(hr);
}


HRESULT
CFsaResource::RemovePremigratedSize(
    IN LONGLONG size
    )

/*++

Implements:

  IFsaResourcePriv::RemovePremigratedSize().

--*/
{
    WsbTraceIn(OLESTR("CFsaResource::RemovePremigratedSize"),
            OLESTR("m_premigratedSize = %I64d"), m_premigratedSize);

    m_isDirty = TRUE;
    if (size > m_premigratedSize) {
        m_premigratedSize = 0;
    } else {
        m_premigratedSize -= size;
    }
    WsbTraceOut(OLESTR("CFsaResource::RemovePremigratedSize"),
            OLESTR("m_premigratedSize = %I64d"), m_premigratedSize);

    return(S_OK);
}


HRESULT
CFsaResource::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistStream> pPersistStream;

    WsbTraceIn(OLESTR("CFsaResource::Save"), OLESTR("clearDirty = <%ls>"),
                                                WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        // Do the easy stuff, but make sure that this order matches the order
        // in the Load() method.

        // Save the path by which this resource is/was last known.  Note the
        // Load() method reads it back into the resource's 'm_oldPath' field.
        if ( m_path == NULL ) {
            WsbAffirmHr(WsbSaveToStream(pStream, m_oldPath));
        }
        else {
            WsbAffirmHr(WsbSaveToStream(pStream, m_path));
        }
        WsbAffirmHr(WsbSaveToStream(pStream, m_alternatePath));
        WsbAffirmHr(WsbSaveToStream(pStream, m_name));
        WsbAffirmHr(WsbSaveToStream(pStream, m_stickyName));
        WsbAffirmHr(WsbSaveToStream(pStream, m_fsName));
        WsbAffirmHr(WsbSaveToStream(pStream, m_maxComponentLength));
        WsbAffirmHr(WsbSaveToStream(pStream, m_fsFlags));
        WsbAffirmHr(WsbSaveToStream(pStream, m_id));
        WsbAffirmHr(WsbSaveToStream(pStream, m_isActive));
        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_compareBy));
        WsbAffirmHr(WsbSaveToStream(pStream, m_managingHsm));
        WsbAffirmHr(WsbSaveToStream(pStream, m_hsmLevel));
        WsbAffirmHr(WsbSaveToStream(pStream, m_premigratedSize));
        WsbAffirmHr(WsbSaveToStream(pStream, m_truncatedSize));
        WsbAffirmHr(WsbSaveToStream(pStream, m_manageableItemLogicalSize));
        WsbAffirmHr(WsbSaveToStream(pStream, m_manageableItemAccessTimeIsRelative));
        WsbAffirmHr(WsbSaveToStream(pStream, m_manageableItemAccessTime));
        WsbAffirmHr(WsbSaveToStream(pStream, m_usnJournalId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_lastUsnId));

        // Save off the default rules.
        WsbAffirmHr(m_pDefaultRules->QueryInterface(IID_IPersistStream,
                    (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        // Save off the premigration list.
        WsbAffirmHr(((IWsbDb*)m_pPremigrated)->QueryInterface(IID_IPersistStream,
                    (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        // Save off the truncator.
        WsbAffirmHr(m_pTruncator->QueryInterface(IID_IPersistStream,
                    (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaResource::SetAlternatePath(
    IN OLECHAR* path
    )

/*++

Implements:

  IFsaResourcePriv::SetAlternatePath().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != path, E_POINTER);
        m_alternatePath = path;

        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::SetHsmLevel(
    IN ULONG level
    )

/*++

Implements:

  IFsaResource::SetHsmLevel().

--*/
{
    BOOL            DoKick = FALSE;
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::SetHsmLevel"),
            OLESTR("current level = %lx, new level = %lx"), m_hsmLevel, level);

    if (m_hsmLevel < level) {
        DoKick = TRUE;
    }
    m_hsmLevel = level;

    // Wake up the AutoTruncator if the new level is higher
    if (DoKick) {
        WsbAffirmHr(m_pTruncator->KickStart());
    }

    m_isDirty = TRUE;

    WsbTraceOut(OLESTR("CFsaResource::SetHsmLevel"), OLESTR("hr = <%ls>"),
            WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaResource::SetIdentifier(
    IN GUID id
    )

/*++

Implements:

  IFsaResourcePriv::SetIdentifier().

--*/
{
    HRESULT         hr = S_OK;

    m_id = id;

    m_isDirty = TRUE;

    return(hr);
}


HRESULT
CFsaResource::SetIsActive(
    BOOL isActive
    )

/*++

Implements:

  IFsaResource::SetIsActive().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IHsmSession>        pSession;

    WsbTraceIn(OLESTR("CFsaResource::SetIsActive"), OLESTR(""));
    // If the flag is changing values, then we may need to do something to the truncator.
    try  {
        if (m_isActive != isActive) {

            // Change the flag.
            m_isActive = isActive;

            // If we are becoming active, then we need to start the truncator. Otherwise we need to stop it.
            if (m_isActive) {

                // If we are managed & done with recovery, then the truncator should be running.
                if (IsManaged() == S_OK && m_isRecovered) {

                    // Try to start the truncator
                    WsbAffirmHr(InitializePremigrationList(TRUE));
                }
            } else {

                // If the truncator is running, then ask it to stop.
                WsbAffirmHr(m_pTruncator->GetSession(&pSession));
                if (pSession != 0) {
                    WsbAffirmHr(pSession->ProcessEvent(HSM_JOB_PHASE_ALL, HSM_JOB_EVENT_CANCEL));
                }
            }

        } else {
            m_isActive = isActive;
        }

        m_isDirty = TRUE;
    } WsbCatch( hr );

    WsbTraceOut(OLESTR("CFsaResource::SetIsActive"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::SetIsAvailable(
    BOOL isAvailable
    )

/*++

Implements:

  IFsaResource::SetIsAvailable().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::SetIsAvailable"), OLESTR(""));

    // Change the flag.
    m_isAvailable = isAvailable;

    WsbTraceOut(OLESTR("CFsaResource::SetIsAvailable"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}



HRESULT
CFsaResource::SetIsDeletePending(
    BOOL isDeletePending
    )

/*++

Implements:

  IFsaResource::SetIsDeletePending().

--*/
{
    HRESULT                     hr = S_OK;
    HANDLE                      threadHandle;

    WsbTraceIn(OLESTR("CFsaResource::SetIsDeletePending"), OLESTR(""));

    // Change the flag.
    m_isDeletePending = isDeletePending;

    threadHandle = CreateThread(0, 0, FsaStartOnStateChange, (void*) this, 0, &g_ThreadId);
    if (threadHandle != NULL) {
       CloseHandle(threadHandle);
    }

    WsbTraceOut(OLESTR("CFsaResource::SetIsDeletePending"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CFsaResource::SetManageableItemLogicalSize(
    IN LONGLONG size
    )

/*++

Implements:

  IFsaResource::SetManageableItemLogicalSize().

--*/
{
    m_manageableItemLogicalSize = size;

    return(S_OK);
}


HRESULT
CFsaResource::SetManageableItemAccessTime(
    IN BOOL isRelative,
    IN FILETIME time
    )

/*++

Implements:

  IFsaResource::SetManageableItemAccessTime().

--*/
{
    m_manageableItemAccessTimeIsRelative = isRelative;
    m_manageableItemAccessTime = time;

    return(S_OK);
}


HRESULT
CFsaResource::SetName(
    IN OLECHAR* name
    )

/*++

Implements:

  IFsaResourcePriv::SetName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != name, E_POINTER);
        m_name = name;

        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::SetOldPath(
    IN OLECHAR* oldPath
    )

/*++

Implements:

  IFsaResourcePriv::SetOldPath().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != oldPath, E_POINTER);
        m_oldPath = oldPath;

        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::SetPath(
    IN OLECHAR* path
    )

/*++

Implements:

  IFsaResourcePriv::SetPath().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != path, E_POINTER);
        m_path = path;

        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::SetSerial(
    IN ULONG serial
    )

/*++

Implements:

  IFsaResourcePriv::SetSerial().

--*/
{
    HRESULT         hr = S_OK;

    try {

        m_serial = serial;

        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::SetStickyName(
    IN OLECHAR* name
    )

/*++

Implements:

  IFsaResourcePriv::SetStickyName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != name, E_POINTER);
        m_stickyName = name;

        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaResource::SetUserFriendlyName(
    IN OLECHAR* name
    )

/*++

Implements:

  IFsaResourcePriv::SetUserFriendlyName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != name, E_POINTER);
        m_userName = name;

        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CFsaResource::ChangeSysState(
    IN OUT HSM_SYSTEM_STATE* pSysState
    )

/*++

Implements:

  IHsmSystemState::ChangeSysState().

--*/

{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaResource::ChangeSysState"), OLESTR(""));

    try {

        //
        // Make sure the truncater is stopped so it won't
        // try to use the database
        //
        if (m_pTruncator) {
            CComPtr<IHsmSession>    pSession;

            WsbAffirmHr(m_pTruncator->GetSession(&pSession));
            if (pSession != 0) {
                if (pSysState->State & HSM_STATE_SHUTDOWN) {
                    WsbAffirmHr(pSession->ProcessEvent(HSM_JOB_PHASE_ALL, HSM_JOB_EVENT_CANCEL));
                }
            }
            m_pTruncator->ChangeSysState(pSysState);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::ChangeSysState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaResource::StartJob(
    IN OLECHAR* startingPath,
    IN IHsmSession* pSession
    )

/*++

Implements:

  IFsaResource::StartJob().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmScanner>    pScanner;

    WsbTraceIn(OLESTR("CFsaResource::StartJob"), OLESTR("starting path = %ls"), startingPath);

    try {

        WsbAssert(0 != pSession, E_POINTER);

        // Create an initialize the scanner.
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmScanner, 0, CLSCTX_SERVER, IID_IHsmScanner, (void**) &pScanner));
        WsbAffirmHr(pScanner->Start(pSession, startingPath));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::StartJob"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaResource::StartJobSession(
    IN IHsmJob* pJob,
    IN ULONG subRunId,
    OUT IHsmSession** ppSession
    )

/*++

Implements:

  IFsaResource::StartJobSession().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmSession>    pSession;
    GUID                    hsmId;
    ULONG                   runId;
    CWsbStringPtr           name;

    WsbTraceIn(OLESTR("CFsaResource::StartJobSession"), OLESTR(""));

    try {

        WsbAssert(0 != pJob, E_POINTER);
        WsbAssert(0 != ppSession, E_POINTER);
        *ppSession = 0;

        // Create and Initialize a session object.
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmSession, 0, CLSCTX_SERVER, IID_IHsmSession, (void**) &pSession));

        WsbAffirmHr(pJob->GetHsmId(&hsmId));
        WsbAffirmHr(pJob->GetRunId(&runId));
        WsbAffirmHr(pJob->GetName(&name, 0));
        WsbAffirmHr(pSession->Start(name, HSM_JOB_LOG_NORMAL, hsmId, pJob, (IFsaResource*) this, runId, subRunId));

        // Return the session to the caller.
        *ppSession = pSession;
        pSession->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::StartJobSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CFsaResource::SetupValidateJob(SYSTEMTIME runTime)
{

    HRESULT hr = S_OK;
    CComPtr<IWsbCreateLocalObject>  pLocalObject;
    CComPtr <IWsbIndexedCollection> pJobs;
    CComPtr<IHsmJob>                pExistJob;
    CComPtr<IHsmJob>                pNewJob;
    CComPtr<IHsmServer>             pHsmServer;
    CWsbStringPtr                   pszExistJobName;
    CWsbStringPtr                   szJobName;
    CWsbStringPtr                   parameters;
    CWsbStringPtr                   commentString;
    CWsbStringPtr                   tmpString;
    CWsbStringPtr                   formatString;
    TASK_TRIGGER_TYPE               jobTriggerType;
    BOOL                            scheduledJob;


    WsbTraceIn(OLESTR("CFsaResource::SetupValidateJob"), OLESTR(""));

    try {

        // Get the volume name
        CWsbStringPtr szWsbVolumeName;
        WsbAffirmHr (GetLogicalName ( &szWsbVolumeName, 0));

        // Create a job name
        CWsbStringPtr volumeString;
        WsbAffirmHr( volumeString.Alloc( 128 ) );

        // For now, ignore the user name if it's not a drive letter
        CWsbStringPtr userName = m_userName;
        size_t userLen = 0;
        if ((WCHAR *)userName) {
            userLen = wcslen(userName);
        }
        if ((userLen != 3) || (userName[1] != L':')) {
            userName = L"";
        }

        if( ! userName || userName.IsEqual ( L"" ) ) {

            //
            // No drive letter - use the volume name and serial number instead
            //
            if( ! m_name || m_name.IsEqual( L"" ) ) {

                //
                // No name, no drive letter - just have serial number
                //
                swprintf( volumeString, L"%8.8lx", m_serial );

            } else {

                swprintf( volumeString, L"%ls-%8.8lx", (OLECHAR*)m_name, m_serial );

            }

        } else {

            //
            // Just want the drive letter (first character)
            //
            volumeString = userName;
            volumeString[1] = L'\0';

        }

        WsbAffirmHr(formatString.LoadFromRsc(_Module.m_hInst, IDS_JOB_NAME_PREFIX));
        WsbAffirmHr(szJobName.Alloc(512));
        swprintf((OLECHAR *) szJobName, formatString, (OLECHAR*)volumeString);

        // Get a pointer to the HSM server
        WsbAffirm(IsManaged() == S_OK, E_FAIL);
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, m_managingHsm, IID_IHsmServer,
            (void**) &pHsmServer));

        // Get a CreateLocalObject interface with which to create the job
        WsbAffirmHr (pHsmServer->QueryInterface( IID_IWsbCreateLocalObject,
            (void **) &pLocalObject));

        // Create the new job in the engine
        WsbAffirmHr (pLocalObject->CreateInstance( CLSID_CHsmJob, IID_IHsmJob,
            (void**) &pNewJob));
        WsbAffirmHr (pNewJob->InitAs(
            szJobName, NULL, HSM_JOB_DEF_TYPE_VALIDATE, GUID_NULL,
            pHsmServer, TRUE, this));

        // Get the jobs collection from the engine
        WsbAffirmHr (pHsmServer->GetJobs (&pJobs));

        // If any jobs exist with this name, delete them
        ULONG cCount;
        WsbAffirmHr (pJobs->GetEntries (&cCount));
        for (UINT i = 0; i < cCount; i++) {
            WsbAffirmHr (pJobs->At (i, IID_IHsmJob, (void **) &pExistJob));
            WsbAffirmHr (pExistJob->GetName (&pszExistJobName, 0));
            if (pszExistJobName.Compare (szJobName) == 0) {
                WsbAffirmHr (pJobs->RemoveAndRelease(pExistJob));
                i--; cCount--;
            }
            pExistJob = 0;      // make sure we release this interface.
        }

        // Add the new job to the engine collection
        WsbAffirmHr (pJobs->Add(pNewJob));

        // Set up to call the Engine to create an entry in the NT Task Scheduler

        // Create the parameter string for the program NT Scheduler
        // will run (for Sakkara this is RsLaunch) by putting the
        // job name in as the parameter.  This is how RsLaunch knows
        // which job in the Engine to run.
        WsbAffirmHr(parameters.Alloc(256));
        swprintf((OLECHAR *)parameters, L"run \"%ls\"", (OLECHAR *) szJobName);

        // Create the comment string for the NT Scheduler entry
        WsbAffirmHr(formatString.LoadFromRsc(_Module.m_hInst, IDS_JOB_AUTOVALIDATE_COMMENT));
        WsbAffirmHr(commentString.Alloc(512));
        swprintf((OLECHAR *) commentString, formatString, (OLECHAR *) szWsbVolumeName);

        // Declare and initialize the schedule components passed to
        // the Engine.
        jobTriggerType = TASK_TIME_TRIGGER_ONCE;

        // Indicate this is a scheduled job
        scheduledJob = TRUE;

        // Create the task
        WsbAffirmHr( pHsmServer->CreateTaskEx( szJobName, parameters,
                                               commentString, jobTriggerType,
                                               runTime, 0,
                                               scheduledJob ) );
        //
        // Remove the registry value if it is there.
        //
        WsbAffirmHr(tmpString.Alloc(32));
        swprintf((OLECHAR *) tmpString, L"%x", m_serial);
        (void) WsbRemoveRegistryValue(NULL, FSA_VALIDATE_LOG_KEY_NAME, tmpString);

    } WsbCatch( hr );

    WsbTraceOut( L"CFsaResource::SetupValidateJob", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}



HRESULT
CFsaResource::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CFsaResource::UpdateFrom(
    IN IFsaServer* pServer,
    IN IFsaResource* pResource
    )

/*++

Implements:

  IFsaResourcePriv::UpdateFrom().

Routine Description:

    This routine implements the COM method for updating a resource object from another.
    It is generally used to update a resource contained in the manageable resources
    collection from a 'working' resource which was just created during a scan for
    resources.  Note that both source and target resource objects must represent the
    same physical resource.

    To capture the latest information about the resource, only the owning FSA and path
    info is updated from the source resource object.  All other resource info is
    updated via a direct query contained within this method.  This technique allows
    for capturing any updates made by the user since the scan was run.

Arguments:

    pServer - Interface pointer to the FSA service that is updating this resource.

    pResource - Interface pointer to the resource used as the source during the update.

Return Value:

    S_OK - The call succeeded (the resource being tested was found to be manageable,
            and the resource object was initialized).

    E_UNEXPECTED - Thrown if the id's (Guids) for the resource to updated and the
            source resource do not match.

    Any other value - The call failed because one of the Remote Storage or Win32 API
            calls contained internally in this method failed.  The error value returned
            is specific to the API call which failed.

--*/

{
    HRESULT         hr = S_OK;
    GUID            id;
    CWsbStringPtr   tmpString;
    CWsbStringPtr   volPath;

    WsbTraceIn(OLESTR("CFsaResource::UpdateFrom"), OLESTR(""));
    try {

        // The identifiers must be the same! (Meaning both resource objects must
        // represent the same physical resource.)
        WsbAffirmHr(pResource->GetIdentifier(&id));
        WsbAssert(m_id == id, E_UNEXPECTED);

        // Update (store) the owning FSA interface.  However, since this is a weak
        // reference, do not AddRef() it.
        m_pFsaServer = pServer;

        // Update the path specific information, preserving the last known path (if any).
        // If the 'path' of this resource is null, set it to the 'path' of the resource
        // we are updating from. Else, compare the 2 'path' fields. If different, copy
        // this resource's path to 'old path', then update 'path' from the resource we are
        // updating from. If the 2 resources' paths are not null and the same, do nothing.
        //
        WsbAffirmHr(pResource->GetPath(&tmpString, 0));
        if (m_path == 0) {
            WsbAffirmHr(SetPath(tmpString));
        }
        else if (wcscmp(tmpString, m_path) != 0) {
            // copy path to 'old path' field, then update 'path' field.
            WsbAffirmHr(m_path.CopyTo(&m_oldPath, 0));
            WsbAffirmHr(SetPath(tmpString));
        }

        // Update 'user friendly' name of this resource from the resource we are updating
        // from.
        WsbAffirmHr(pResource->GetUserFriendlyName(&tmpString, 0));
        WsbTrace(OLESTR("CFsaResource::UpdateFrom - setting user friendly name to %ws\n"),
            (WCHAR *) tmpString);
        WsbAffirmHr(SetUserFriendlyName(tmpString));

        // Update 'sticky' (long, ugly PNP) name of this resource from the resource we are
        // updating from.
        WsbAffirmHr(pResource->GetStickyName(&tmpString, 0));
        WsbAffirmHr(SetStickyName(tmpString));

        // Since the other data that we would like to refresh is not exposed by an interface,
        // we will query for it again.
        //
        // NOTE: fsFlags and maxComponentLength are the real issues, since name and fsName
        // are done via exposed interfaces.
        //
        // NOTE: To keep every update from making the item seem dirty, we may want to
        // compare all the fields first. (Idea for later enhancement)
        m_name.Realloc(128);    // volume name
        m_fsName.Realloc(128);  // volume file system type (e.g., FAT, NTFS)
        HRESULT hrAvailable;
        WsbAffirmHr( hrAvailable = pResource->IsAvailable( ) );
        m_isAvailable = S_OK == hrAvailable ? TRUE : FALSE;

        // Reformat resource's path for 'GetVolumeInfo' call below.
        volPath = m_path;
        WsbAffirmHr(volPath.Prepend("\\\\?\\"));

        WsbAffirm(GetVolumeInformation(volPath, m_name, 128, &m_serial,
                            &m_maxComponentLength, &m_fsFlags, m_fsName, 128), E_FAIL);

        // Now that everything is updated, initialize the
        // premigration list if necessary
        WsbAffirmHr(InitializePremigrationList(TRUE));

        m_isDirty = TRUE;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::UpdateFrom"), OLESTR("hr = <%ls>"),
                                                            WsbHrAsString(hr));
    return(hr);
}



HRESULT
CFsaResource::Validate(
    IN IFsaScanItem* pScanItem,
    IN LONGLONG offset,
    IN LONGLONG size,
    IN LONGLONG usn
    )

/*++

Implements:

  IFsaResource::Validate().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IFsaPostIt>     pWorkItem;
    CComPtr<IHsmFsaTskMgr>  pEngine;
    CWsbStringPtr           tmpString;
    CComPtr<IHsmSession>    pSession;
    FSA_PLACEHOLDER         placeholder;

    WsbTraceIn(OLESTR("CFsaResource::Validate"), OLESTR("offset = %I64d, size = %I64d, usn = <%I64d>"),
                offset, size, usn);
    try {

        // Make sure the  Scan Item interface is OK
        WsbAssert(pScanItem != 0, E_POINTER);
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaPostIt, 0, CLSCTX_SERVER, IID_IFsaPostIt, (void**) &pWorkItem));

        // Get the data from the scan item.
        WsbAffirmHr(pScanItem->GetSession(&pSession));
        WsbAffirmHr(pWorkItem->SetSession(pSession));

        WsbAffirmHr(pScanItem->GetPathAndName(0, &tmpString, 0));
        WsbAffirmHr(pWorkItem->SetPath(tmpString));

        WsbAffirmHr(pWorkItem->SetRequestOffset(offset));
        WsbAffirmHr(pWorkItem->SetRequestSize(size));

        WsbAffirmHr(pScanItem->GetPlaceholder(offset, size, &(placeholder)));
        WsbAffirmHr(pWorkItem->SetPlaceholder(&placeholder));

        // Fill in the rest of the work
        WsbAffirmHr(pWorkItem->SetRequestAction(FSA_REQUEST_ACTION_VALIDATE));
        WsbAffirmHr(pWorkItem->SetResultAction(FSA_RESULT_ACTION_NONE));

        // Fill in the USN
        WsbAffirmHr(pWorkItem->SetUSN(usn));

        // Send the request to the task manager
        WsbAffirmHr(GetHsmEngine(&pEngine));
        WsbAffirmHr(pEngine->DoFsaWork(pWorkItem));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::Validate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}



HRESULT
CFsaResource::ValidateForTruncate(
    IN IFsaScanItem* pScanItem,
    IN LONGLONG offset,
    IN LONGLONG size,
    IN LONGLONG usn
    )

/*++

Implements:

  IFsaResource::ValidateForTruncate().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IFsaPostIt>     pWorkItem;
    CComPtr<IHsmFsaTskMgr>  pEngine;
    CWsbStringPtr           tmpString;
    CComPtr<IHsmSession>    pSession;
    FSA_PLACEHOLDER         placeholder;

    WsbTraceIn(OLESTR("CFsaResource::ValidateForTruncate"), OLESTR("offset = %I64d, size = %I64d, usn = <%I64d>"),
                offset, size, usn);
    try {

        // Make sure the  Scan Item interface is OK
        WsbAssert(pScanItem != 0, E_POINTER);
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaPostIt, 0, CLSCTX_SERVER, IID_IFsaPostIt, (void**) &pWorkItem));

        // Get the data from the scan item.
        WsbAffirmHr(pScanItem->GetSession(&pSession));
        WsbAffirmHr(pWorkItem->SetSession(pSession));

        WsbAffirmHr(pScanItem->GetPathAndName(0, &tmpString, 0));
        WsbAffirmHr(pWorkItem->SetPath(tmpString));

        WsbAffirmHr(pWorkItem->SetRequestOffset(offset));
        WsbAffirmHr(pWorkItem->SetRequestSize(size));

        WsbAffirmHr(pScanItem->GetPlaceholder(offset, size, &(placeholder)));
        WsbAffirmHr(pWorkItem->SetPlaceholder(&placeholder));

        // Fill in the rest of the work
        WsbAffirmHr(pWorkItem->SetRequestAction(FSA_REQUEST_ACTION_VALIDATE_FOR_TRUNCATE));
        WsbAffirmHr(pWorkItem->SetResultAction(FSA_RESULT_ACTION_NONE));

        // Fill in the USN
        WsbAffirmHr(pWorkItem->SetUSN(usn));

        // Send the request to the task manager
        WsbAffirmHr(GetHsmEngine(&pEngine));
        WsbAffirmHr(pEngine->DoFsaWork(pWorkItem));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::ValidateForTruncate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}



HRESULT
CFsaResource::WriteIdentifier(
    void
    )

/*++

    This code is no longer called, in time it will be removed

--*/
{
#if 0
    HRESULT                           hr = S_OK;
    CWsbStringPtr                     tmpString;
    HANDLE                            aHandle;
    ULONG                             size;
    ULONG                             bytesWritten;
    FILE_FS_OBJECT_ID_INFORMATION     objectId;
    NTSTATUS                          status = STATUS_SUCCESS;
    IO_STATUS_BLOCK                   ioStatus;

    WsbTraceIn(OLESTR("CFsaResource::WriteIdentifier"), OLESTR(""));
    try {

        // For now, we will create a file in the root of the volume.
        tmpString = m_path;
        WsbAffirmHr(tmpString.Prepend("\\\\?\\"));
        // WsbAffirmHr(tmpString.Append(":MSHSM_FSAID"));

        WsbAffirmHandle(aHandle = CreateFile(tmpString,
                                             GENERIC_WRITE,
                                             0,
                                             0,
                                             OPEN_EXISTING,
                                             FILE_ATTRIBUTE_NORMAL,
                                             0));

        try {

            WsbAffirmHr(WsbConvertToBytes(objectId.ObjectId, m_id, &size));

            status = NtSetVolumeInformationFile(
                                    aHandle,
                                    &ioStatus,
                                    &objectId,
                                    sizeof(objectId),
                                    FileFsObjectIdInformation);

            WsbAffirmNtStatus(status);

            WsbAffirm(bytesWritten == size, E_FAIL);

        } WsbCatch(hr);

        WsbAffirmStatus(CloseHandle(aHandle));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaResource::WriteIdentifier"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);

#else
    return  S_OK;
#endif
}


void CFsaResource::OnStateChange( )
/*++

    Note:  This function is run in a separate thread to avoid a deadlock situation

--*/
{
    IConnectionPointImpl<CFsaResource, &IID_IHsmEvent, CComDynamicUnkArray>* p = this;
    Lock();
    HRESULT hr = S_OK;
    IUnknown** pp = p->m_vec.begin();
    while (pp < p->m_vec.end() && hr == S_OK)
    {
        if (*pp != NULL)
        {
            IHsmEvent* pIHsmEvent = (IHsmEvent*)*pp;
            hr = pIHsmEvent->OnStateChange( );
        }
        pp++;
    }
    Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsarcvy.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsarcvy.h

Abstract:

    Header file for the diaster recovery class.

Author:

    Ron White   [ronw]   8-Sep-1997

Revision History:

--*/

#ifndef _FSARCVY_
#define _FSARCVY_


#include "resource.h"       // main symbols
#include "wsbdb.h"
#include "fsa.h"
#include "fsaprv.h"
#include "fsaprem.h"

// FSA_RECOVERY_FLAG_* - status flags for Recovery records
#define FSA_RECOVERY_FLAG_TRUNCATING      0x00000001
#define FSA_RECOVERY_FLAG_RECALLING       0x00000002


/////////////////////////////////////////////////////////////////////////////
// CFsaRecoveryRec

class CFsaRecoveryRec : 
    public CWsbDbEntity,
    public IFsaRecoveryRec,
    public CComCoClass<CFsaRecoveryRec,&CLSID_CFsaRecoveryRec>
{
public:
    CFsaRecoveryRec() {}
BEGIN_COM_MAP(CFsaRecoveryRec)
    COM_INTERFACE_ENTRY(IFsaRecoveryRec)
    COM_INTERFACE_ENTRY2(IWsbDbEntity, CWsbDbEntity)
    COM_INTERFACE_ENTRY(IWsbDbEntityPriv)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
END_COM_MAP()

//DECLARE_NO_REGISTRY()
DECLARE_REGISTRY_RESOURCEID(IDR_FsaRecoveryRec)

// IFsaRecoveryRec
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* /*pSize*/) {
            return(E_NOTIMPL); }
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbDbEntity
public:
    STDMETHOD(Print)(IStream* pStream);
    STDMETHOD(UpdateKey)(IWsbDbKey *pKey);
    WSB_FROM_CWSBDBENTITY;

// IWsbTestable
    STDMETHOD(Test)(USHORT* /*passed*/, USHORT* /*failed*/) {
        return(E_NOTIMPL); }

// IFsaRecoveryRec
public:
    STDMETHOD(GetBagId)(GUID* pId);
    STDMETHOD(GetBagOffset)(LONGLONG* pOffset);
    STDMETHOD(GetFileId)(LONGLONG* pFileId);
    STDMETHOD(GetOffsetSize)(LONGLONG *pOffset, LONGLONG* pSize);
    STDMETHOD(GetPath)(OLECHAR** ppPath, ULONG bufferSize);
    STDMETHOD(GetRecoveryCount)(LONG* pCount);
    STDMETHOD(GetStatus)(ULONG* pStatus);
    STDMETHOD(SetBagId)(GUID id);
    STDMETHOD(SetBagOffset)(LONGLONG offset);
    STDMETHOD(SetFileId)(LONGLONG FileId);
    STDMETHOD(SetOffsetSize)(LONGLONG Offset, LONGLONG Size);
    STDMETHOD(SetPath)(OLECHAR* pPath);
    STDMETHOD(SetRecoveryCount)(LONG Count);
    STDMETHOD(SetStatus)(ULONG Status);

private:
    GUID           m_BagId;
    LONGLONG       m_BagOffset;
    LONGLONG       m_FileId;
    LONGLONG       m_Offset;
    CWsbStringPtr  m_Path;
    LONG           m_RecoveryCount;
    LONGLONG       m_Size;
    ULONG          m_Status;  // FSA_RECOVERY_FLAG_* flags
};


#endif // _FSARCVY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsarcvy.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsarcvy.cpp

Abstract:

    Defines the functions for the recovery record class.

Author:

    Ron White   [ronw]   8-Sep-1997

Revision History:

    Steve Wimmer    [stevew]    30-July-1998
        - updated CFsaRecoveryRec::GetClassId's WsbTraceOut to hold 
            the proper function name

--*/


#include "stdafx.h"
#include "wsb.h"


#include "fsarcvy.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_FSA


HRESULT 
CFsaRecoveryRec::GetBagId(
    OUT GUID* pId 
    ) 
/*++

Implements:

  IFsaRecoveryRec::GetBagId

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::GetBagId"),OLESTR(""));

    try {
        WsbAssert(0 != pId, E_POINTER);

        *pId = m_BagId;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaRecoveryRec::GetBagId"),    OLESTR("hr = <%ls> Id = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pId));

    return(hr);
}


HRESULT 
CFsaRecoveryRec::GetBagOffset(
    OUT LONGLONG* pOffset 
    ) 
/*++

Implements:

  IFsaRecoveryRec::GetBagOffset

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::GetBagOffset"),OLESTR(""));

    try {
        WsbAssert(0 != pOffset, E_POINTER);
        *pOffset = m_BagOffset;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaRecoveryRec::GetBagOffset"),    OLESTR("hr = <%ls> Offset = <%ls>"), WsbHrAsString(hr), WsbLonglongAsString(*pOffset));

    return(hr);
}


HRESULT 
CFsaRecoveryRec::GetFileId(
    OUT LONGLONG* pFileId 
    ) 
/*++

Implements:

  IFsaRecoveryRec::GetFileId

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::GetFileId"),OLESTR(""));

    try {
        WsbAssert(0 != pFileId, E_POINTER);
        *pFileId = m_FileId;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaRecoveryRec::GetFileId"),
        OLESTR("hr = <%ls> Size = <%ls>"), WsbHrAsString( hr ), WsbLonglongAsString( *pFileId ) );

    return(hr);
}


HRESULT 
CFsaRecoveryRec::GetOffsetSize(
    OUT LONGLONG* pOffset,
    OUT LONGLONG* pSize
    ) 
/*++

Implements:

  IFsaRecoveryRec::GetOffsetSize

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::GetOffsetSize"),OLESTR(""));

    try {
        WsbAssertPointer(pOffset);
        WsbAssertPointer(pSize);
        *pOffset = m_Offset;
        *pSize   = m_Size;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaRecoveryRec::GetOffsetSize"), OLESTR("hr = <%ls> Offset = %I64d, Size = %I64d"), 
        WsbHrAsString(hr), *pOffset, *pSize);

    return(hr);
}


HRESULT 
CFsaRecoveryRec::GetPath(
    OUT OLECHAR** ppPath,
    IN  ULONG     bufferSize
    ) 
/*++

Implements:

  IFsaRecoveryRec::GetPath

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::GetPath"),OLESTR(""));

    try {
        WsbAssert(0 != ppPath, E_POINTER);
        WsbAffirmHr(m_Path.CopyTo(ppPath, bufferSize));
        WsbTrace( OLESTR("CFsaRecoveryRec::GetPath path = <%ls>\n"), *ppPath );
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaRecoveryRec::GetPath"),
        OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaRecoveryRec::GetRecoveryCount(
    OUT LONG* pRecoveryCount 
    ) 
/*++

Implements:

  IFsaRecoveryRec::GetRecoveryCount

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::GetRecoveryCount"),OLESTR(""));

    try {
        WsbAssertPointer(pRecoveryCount);
        *pRecoveryCount = m_RecoveryCount;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaRecoveryRec::GetRecoveryCount"), OLESTR("hr = <%ls> RecoveryCount = %ld"), 
        WsbHrAsString(hr), *pRecoveryCount);

    return(hr);
}


HRESULT 
CFsaRecoveryRec::GetStatus(
    OUT ULONG* pStatus 
    ) 
/*++

Implements:

  IFsaRecoveryRec::GetStatus

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::GetStatus"),OLESTR(""));

    try {
        WsbAssertPointer(pStatus);
        *pStatus = m_Status;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaRecoveryRec::GetStatus"), OLESTR("hr = <%ls> Status = %lx"), 
        WsbHrAsString(hr), *pStatus);

    return(hr);
}


HRESULT 
CFsaRecoveryRec::FinalConstruct(
    void
    ) 
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssertHr(CWsbDbEntity::FinalConstruct());

        m_BagId = GUID_NULL;
        m_BagOffset = 0;
        m_FileId = 0;
        m_Offset = 0;
        m_RecoveryCount = 0;
        m_Size   = 0;
        m_Status = 0;

    } WsbCatch(hr);

    return(hr);
}


HRESULT 
CFsaRecoveryRec::FinalRelease(
    void
    ) 
/*++

Implements:

  CComObjectRoot::FinalRelease

--*/
{
    HRESULT     hr = S_OK;

    CWsbDbEntity::FinalRelease();

    return(hr);
}


HRESULT CFsaRecoveryRec::GetClassID
(
    OUT LPCLSID pclsid
    ) 
/*++

Implements:

  IPerist::GetClassID

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::GetClassID"), OLESTR(""));


    try {
        WsbAssertPointer(pclsid);
        *pclsid = CLSID_CFsaRecoveryRec;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaRecoveryRec::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pclsid));
    return(hr);
}


HRESULT CFsaRecoveryRec::Load
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::Load"), OLESTR(""));

    try {
        OLECHAR* pPath = NULL;

        WsbAssertPointer(pStream);
        WsbAssertHr(WsbLoadFromStream(pStream, &m_BagId));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_BagOffset));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_FileId));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_Offset));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_Path, 0));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_RecoveryCount));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_Size));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_Status));

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaRecoveryRec::Load"), 
        OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT CFsaRecoveryRec::Print
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IWsbDbEntity::Print

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::Print"), OLESTR(""));

    try {
        WsbAssertPointer(pStream);
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" BagId = %ls"), WsbGuidAsString(m_BagId)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" BagOffset = %I64d"), m_BagOffset));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" FileId = %I64d"), m_FileId));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Offset = %I64d"), m_Offset));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Size = %I64d"), m_Size));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" RecoveryCount = %ld"), 
                m_RecoveryCount));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" Status = %lx"), m_Status));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", Path = %ls"), 
                static_cast<OLECHAR*>(m_Path)));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaRecoveryRec::Print"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT CFsaRecoveryRec::Save
(
    IN IStream* pStream, 
    IN BOOL clearDirty
    ) 
/*++

Implements:

  IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssertPointer(pStream);
        WsbAssertHr(WsbSaveToStream(pStream, m_BagId));
        WsbAssertHr(WsbSaveToStream(pStream, m_BagOffset));
        WsbAssertHr(WsbSaveToStream(pStream, m_FileId));
        WsbAssertHr(WsbSaveToStream(pStream, m_Offset));
        WsbAssertHr(WsbSaveToStream(pStream, m_Path));
        WsbAssertHr(WsbSaveToStream(pStream, m_RecoveryCount));
        WsbAssertHr(WsbSaveToStream(pStream, m_Size));
        WsbAssertHr(WsbSaveToStream(pStream, m_Status));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaRecoveryRec::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaRecoveryRec::SetBagId(
    IN GUID BagId
    ) 
/*++

Implements:

  IFsaRecoveryRec::SetBagId

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::SetBagId"),OLESTR(""));

    m_BagId = BagId;

    WsbTraceOut(OLESTR("CFsaRecoveryRec::SetBagId"),    OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaRecoveryRec::SetBagOffset(
    IN LONGLONG BagOffset 
    ) 
/*++

Implements:

  IFsaRecoveryRec::SetBagOffset

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::SetBagOffset"),OLESTR(""));

    m_BagOffset = BagOffset;

    WsbTraceOut(OLESTR("CFsaRecoveryRec::SetBagOffset"),    OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaRecoveryRec::SetFileId(
    IN LONGLONG FileId 
    ) 
/*++

Implements:

  IFsaRecoveryRec::SetFileId

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::SetFileId"),OLESTR(""));

    try {
        m_FileId = FileId;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaRecoveryRec::SetFileId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaRecoveryRec::SetOffsetSize(
    IN LONGLONG Offset,
    IN LONGLONG Size
    ) 
/*++

Implements:

  IFsaRecoveryRec::SetOffsetSize

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::SetOffsetSize"),OLESTR("Offset = %I64d, Size = %I64d"),
            Offset, Size);

    m_Offset = Offset;
    m_Size   = Size;

    WsbTraceOut(OLESTR("CFsaRecoveryRec::SetOffsetSize"),   OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaRecoveryRec::SetPath(
    IN OLECHAR* Path 
    ) 
/*++

Implements:

  IFsaRecoveryRec::SetPath

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::SetPath"),OLESTR("Path = <%ls>"),
            Path);

    try {
        m_Path = Path;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaRecoveryRec::SetPath"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaRecoveryRec::SetRecoveryCount(
    IN LONG RecoveryCount 
    ) 
/*++

Implements:

  IFsaRecoveryRec::SetRecoveryCount

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::SetRecoveryCount"),OLESTR("RecoveryCount = %ld"),
            RecoveryCount);

    m_RecoveryCount = RecoveryCount;

    WsbTraceOut(OLESTR("CFsaRecoveryRec::SetRecoveryCount"),    OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaRecoveryRec::SetStatus(
    IN ULONG Status 
    ) 
/*++

Implements:

  IFsaRecoveryRec::SetStatus

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaRecoveryRec::SetStatus"),OLESTR("Status = %lx"),
            Status);

    m_Status = Status;

    WsbTraceOut(OLESTR("CFsaRecoveryRec::SetStatus"),   OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaRecoveryRec::UpdateKey(
    IWsbDbKey *pKey
    ) 
/*++

Implements:

  IWsbDbEntity::UpdateKey

--*/
{ 
    HRESULT     hr = E_FAIL; 

    try {
        UCHAR    FileKey[RECOVERY_KEY_SIZE + 1];
        ULONG    KeyType;

        WsbAffirmHr(pKey->GetType(&KeyType));
        if (RECOVERY_KEY_TYPE == KeyType) {
            WsbAffirmHr(SquashFilepath(m_Path, FileKey, RECOVERY_KEY_SIZE));
            WsbAffirmHr(pKey->SetToBytes(FileKey, RECOVERY_KEY_SIZE));
            hr = S_OK;
        }
    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsasrvr.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsasrvr.cpp

Abstract:

    This class contains represents a file system for NTFS.

Author:

    Chuck Bardeen   [cbardeen]   1-Dec-1996

Revision History:

    Chris Timmes    [ctimmes]   31-Dec-1997  
    
    - basically rewrote the ScanForResources() method to fix RAID bug 117412 
      (volumes which were once manageable but are now unmanageable still show as 
      manageable in the UI).

--*/

#include "stdafx.h"

#include "job.h"
#include "fsa.h"
#include "fsaprv.h"
#include "fsasrvr.h"
#include "HsmConn.h"
#include "wsbdb.h"
#include "wsbtrak.h"
#include "wsbvol.h"
#include "task.h"
#include "rsbuild.h"
#include "rsevents.h"
#include "ntverp.h"
#include <winioctl.h>
#include <setupapi.h>
#include <objbase.h>
#include <stdio.h>
#include <initguid.h>
#include <mountmgr.h>



static short g_InstanceCount = 0;


//  Non-member function initially called for autosave thread
static DWORD FsaStartAutosave(
    void* pVoid
    )
{
    return(((CFsaServer*) pVoid)->Autosave());
}


HRESULT
CFsaServer::Autosave(
    void
    )

/*++

Routine Description:

  Implements an autosave loop.

Arguments:

  None.
  
Return Value:

  Doesn't matter.


--*/
{

    HRESULT         hr = S_OK;
    ULONG           l_autosaveInterval = m_autosaveInterval;
    BOOL            exitLoop = FALSE;

    WsbTraceIn(OLESTR("CFsaServer::Autosave"), OLESTR(""));

    try {
        while (m_autosaveInterval && (! exitLoop)) {

            // Wait for termination event, if timeout occurs, check if we can perform Autosave
            switch (WaitForSingleObject(m_terminateEvent, l_autosaveInterval)) {
                case WAIT_OBJECT_0:
                    // Need to terminate
                    WsbTrace(OLESTR("CFsaServer::Autosave: signaled to terminate\n"));
                    exitLoop = TRUE;
                    break;

                case WAIT_TIMEOUT: 
                    // Check if backup need to be performed
                    WsbTrace(OLESTR("CFsaServer::Autosave: Autosave awakened\n"));

                    //  Don't do this if we're suspended
                    if (!m_Suspended) {
                        //  Save data
                        //  NOTE: Because this is a separate thread, there is the possibility
                        //  of a conflict if the main thread is changing some data at the same
                        //  time we're trying to save it.
                        //  If a save is already happening, just skip this one and
                        //  go back to sleep
                        hr = SaveAll();
    
                        //  If the save fails, increase the sleep time to avoid filling
                        //  the event log
                        if (!SUCCEEDED(hr)) {
                            if ((MAX_AUTOSAVE_INTERVAL / 2) < l_autosaveInterval) {
                                l_autosaveInterval = MAX_AUTOSAVE_INTERVAL;
                            } else {
                                l_autosaveInterval *= 2;
                            }
                        } else {
                            l_autosaveInterval = m_autosaveInterval;
                        }
                    }

                    break;  // end of timeout case

                case WAIT_FAILED:
                default:
                    WsbTrace(OLESTR("CFsaServer::Autosave: WaitForSingleObject returned error %lu\n"), GetLastError());
                    exitLoop = TRUE;
                    break;

            } // end of switch

        } // end of while

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::Autosave"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaServer::CreateInstance( 
    REFCLSID rclsid, 
    REFIID riid, 
    void **ppv 
    )
{
    HRESULT     hr = S_OK;
    
    hr = CoCreateInstance(rclsid, NULL, CLSCTX_SERVER, riid, ppv);

    return hr;
}


HRESULT
CFsaServer::DoRecovery(
    void
    )

/*++

Routine Description:

  Do recovery.

Arguments:

  None.
  
Return Value:

  S_OK  - Success.


--*/
{

    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaServer::DoRecovery"), OLESTR(""));

    try {
        CComPtr<IWsbEnum>           pEnum;
        CComPtr<IFsaResourcePriv>   pResourcePriv;
        CComPtr<IFsaResource>       pResource;

        //  Loop over resources and tell them to do their own recovery
        WsbAffirmPointer(m_pResources);
        WsbAffirmHr(m_pResources->Enum(&pEnum));
        hr = pEnum->First(IID_IFsaResourcePriv, (void**)&pResourcePriv);
        while (S_OK == hr) {
        
            WsbAffirmHr(pResourcePriv->QueryInterface(IID_IFsaResource, (void**) &pResource));
            
            if ((pResource->IsActive() == S_OK) && (pResource->IsAvailable() == S_OK)) {
                hr = pResourcePriv->DoRecovery();
                // Log event if (S_OK != hr) ???
            }

            //  Release this resource and get the next one
            pResource = 0;
            pResourcePriv = 0;
            
            hr = pEnum->Next(IID_IFsaResourcePriv, (void**)&pResourcePriv);
        }
        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::DoRecovery"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaServer::EnumResources(
    OUT IWsbEnum** ppEnum
    )

/*++

Implements:

  IFsaServer::EnumResources().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != ppEnum, E_POINTER);
        
        //
        // We can't trust that the resource information 
        // that we have is current so redo the scan.  This 
        // is expensive and should be changed once we
        // know how NT can tell us when things have 
        // changed
        //
        try  {
            WsbAffirmHr(ScanForResources());
        } WsbCatch( hr );
        
        WsbAffirmHr(m_pResources->Enum(ppEnum));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaServer::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaServer::FinalConstruct"), OLESTR(""));


    hr = CWsbPersistable::FinalConstruct();

    // Keep it simple, most of the work is done in Init();
    m_terminateEvent = NULL;
    m_savingEvent = NULL;
    m_id = GUID_NULL;
    m_Suspended = FALSE;
    m_isUnmanageDbSysInitialized = FALSE;

    if (hr == S_OK)  {
        g_InstanceCount++;
    }

    WsbTrace(OLESTR("CFsaServer::FinalConstruct: Instance count = %d\n"), g_InstanceCount);
    WsbTraceOut(OLESTR("CFsaServer::FinalConstruct"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


void
CFsaServer::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistFile>   pPersistFile;

    WsbTraceIn(OLESTR("CFsaServer::FinalRelease"), OLESTR(""));

    try {
        HSM_SYSTEM_STATE SysState;

        SysState.State = HSM_STATE_SHUTDOWN;
        ChangeSysState(&SysState);

    } WsbCatch(hr)
    
    // Let the parent class do his thing.   
    CWsbPersistable::FinalRelease();

    // Free String members
    // Note: Member objects held in smart-pointers are freed when the 
    // smart-pointer destructor is being called (as part of this object destruction)
    m_dbPath.Free();
    m_name.Free();

    // Free autosave terminate event 
    if (m_terminateEvent != NULL) {
        CloseHandle(m_terminateEvent);
        m_terminateEvent = NULL;
    }

    // Clean up database system
    m_pDbSys->Terminate();
    if (m_isUnmanageDbSysInitialized) {
        m_pUnmanageDbSys->Terminate();
        m_isUnmanageDbSysInitialized = FALSE;
    }

    if (m_savingEvent != NULL) {
        CloseHandle(m_savingEvent);
        m_savingEvent = NULL;
    }

    if (hr == S_OK)  {
        g_InstanceCount--;
    }
    WsbTrace(OLESTR("CFsaServer::FinalRelease: Instance count = %d\n"), g_InstanceCount);

    WsbTraceOut(OLESTR("CFsaServer::FinalRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
}



HRESULT
CFsaServer::FindResourceByAlternatePath(
    IN OLECHAR* path,
    OUT IFsaResource** ppResource
    )

/*++

Implements:

  IFsaServer::FindResourceByAlternatePath().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaResourcePriv>   pResourcePriv;
    CComPtr<IFsaResource>       pResource;

    WsbTraceIn(OLESTR("CFsaServer::FindResourceByAlternatePath"), OLESTR("path = <%ls>"), path);

    try {

        WsbAssert(0 != path, E_POINTER);
        WsbAssert(0 != ppResource, E_POINTER);
        WsbAffirmPointer(m_pResources);

        // Create an FsaResource that will scan for us.
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaResourceNTFS, NULL, CLSCTX_SERVER, IID_IFsaResourcePriv, (void**) &pResourcePriv));

        WsbAffirmHr(pResourcePriv->SetAlternatePath(path));
        WsbAffirmHr(pResourcePriv->QueryInterface(IID_IFsaResource, (void**) &pResource));
        WsbAffirmHr(pResource->CompareBy(FSA_RESOURCE_COMPARE_ALTERNATEPATH));
        WsbAffirmHr(m_pResources->Find(pResource, IID_IFsaResource, (void**) ppResource));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::FindResourceByAlternatePath"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaServer::FindResourceById(
    IN GUID id,
    OUT IFsaResource** ppResource
    )

/*++

Implements:

  IFsaServer::FindResourceById().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaResourcePriv>   pResourcePriv;
    CComPtr<IFsaResource>       pResource;

    WsbTraceIn(OLESTR("CFsaServer::FindResourceById"), OLESTR("id = <%ls>"), WsbGuidAsString(id));

    try {

        WsbAssert(0 != ppResource, E_POINTER);
        WsbAffirmPointer(m_pResources);

        // Create an FsaResource that will scan for us.
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaResourceNTFS, NULL, CLSCTX_SERVER, IID_IFsaResourcePriv, (void**) &pResourcePriv));

        WsbAffirmHr(pResourcePriv->SetIdentifier(id));
        WsbAffirmHr(pResourcePriv->QueryInterface(IID_IFsaResource, (void**) &pResource));
        WsbAffirmHr(pResource->CompareBy(FSA_RESOURCE_COMPARE_ID));
        WsbAffirmHr(m_pResources->Find(pResource, IID_IFsaResource, (void**) ppResource));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::FindResourceById"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CFsaServer::FindResourceByName(
    IN OLECHAR* name,
    OUT IFsaResource** ppResource
    )

/*++

Implements:

  IFsaServer::FindResourceByName().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaResourcePriv>   pResourcePriv;
    CComPtr<IFsaResource>       pResource;

    WsbTraceIn(OLESTR("CFsaServer::FindResourceByName"), OLESTR("name = <%ls>"), name);

    try {

        WsbAssert(0 != ppResource, E_POINTER);
        WsbAffirmPointer(m_pResources);

        // Create an FsaResource that will scan for us.
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaResourceNTFS, NULL, CLSCTX_SERVER, IID_IFsaResourcePriv, (void**) &pResourcePriv));

        WsbAffirmHr(pResourcePriv->SetName(name));
        WsbAffirmHr(pResourcePriv->QueryInterface(IID_IFsaResource, (void**) &pResource));
        WsbAffirmHr(pResource->CompareBy(FSA_RESOURCE_COMPARE_NAME));
        WsbAffirmHr(m_pResources->Find(pResource, IID_IFsaResource, (void**) ppResource));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::FindResourceByName"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaServer::FindResourceByPath(
    IN OLECHAR* path,
    OUT IFsaResource** ppResource
    )

/*++

Implements:

  IFsaServer::FindResourceByPath().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaResourcePriv>   pResourcePriv;
    CComPtr<IFsaResource>       pResource;

    WsbTraceIn(OLESTR("CFsaServer::FindResourceByPath"), OLESTR("path = <%ls>"), path);

    try {

        WsbAssert(0 != path, E_POINTER);
        WsbAssert(0 != ppResource, E_POINTER);
        WsbAffirmPointer(m_pResources);

        // Create an FsaResource that will scan for us.
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaResourceNTFS, NULL, CLSCTX_SERVER, IID_IFsaResourcePriv, (void**) &pResourcePriv));

        //WsbAffirmHr(pResourcePriv->SetPath(path));

        WsbAffirmHr(pResourcePriv->SetUserFriendlyName(path));

        WsbAffirmHr(pResourcePriv->QueryInterface(IID_IFsaResource, (void**) &pResource));

        //WsbAffirmHr(pResource->CompareBy(FSA_RESOURCE_COMPARE_PATH));
        WsbAffirmHr(pResource->CompareBy(FSA_RESOURCE_COMPARE_USER_NAME));

        WsbAffirmHr(m_pResources->Find(pResource, IID_IFsaResource, (void**) ppResource));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::FindResourceByPath"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaServer::FindResourceBySerial(
    IN ULONG serial,
    OUT IFsaResource** ppResource
    )

/*++

Implements:

  IFsaServer::FindResourceBySerial().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaResourcePriv>   pResourcePriv;
    CComPtr<IFsaResource>       pResource;

    WsbTraceIn(OLESTR("CFsaServer::FindResourceBySerial"), OLESTR("serial = <%lu>"), serial);

    try {

        WsbAssert(0 != ppResource, E_POINTER);
        WsbAffirmPointer(m_pResources);

        // Create an FsaResource that will scan for us.
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaResourceNTFS, NULL, CLSCTX_SERVER, IID_IFsaResourcePriv, (void**) &pResourcePriv));

        WsbAffirmHr(pResourcePriv->SetSerial(serial));
        WsbAffirmHr(pResourcePriv->QueryInterface(IID_IFsaResource, (void**) &pResource));
        WsbAffirmHr(pResource->CompareBy(FSA_RESOURCE_COMPARE_SERIAL));
        WsbAffirmHr(m_pResources->Find(pResource, IID_IFsaResource, (void**) ppResource));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::FindResourceBySerial"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaServer::FindResourceByStickyName(
    IN OLECHAR* name,
    OUT IFsaResource** ppResource
    )

/*++

Implements:

  IFsaServer::FindResourceByStickyName().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IFsaResourcePriv>   pResourcePriv;
    CComPtr<IFsaResource>       pResource;

    WsbTraceIn(OLESTR("CFsaServer::FindResourceByStickyName"), OLESTR("name = <%ls>"), name);

    try {

        WsbAssert(0 != ppResource, E_POINTER);
        WsbAffirmPointer(m_pResources);

        // Create an FsaResource that will scan for us.
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaResourceNTFS, NULL, CLSCTX_SERVER, IID_IFsaResourcePriv, (void**) &pResourcePriv));

        WsbAffirmHr(pResourcePriv->SetStickyName(name));
        WsbAffirmHr(pResourcePriv->QueryInterface(IID_IFsaResource, (void**) &pResource));
        WsbAffirmHr(pResource->CompareBy(FSA_RESOURCE_COMPARE_STICKY_NAME));
        WsbAffirmHr(m_pResources->Find(pResource, IID_IFsaResource, (void**) ppResource));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::FindResourceByStickyName"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaServer::GetAutosave(
    OUT ULONG* pMilliseconds
    )

/*++

Implements:

  IFsaServer::GetAutosave().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaServer::GetAutosave"), OLESTR(""));

    try {

        WsbAssert(0 != pMilliseconds, E_POINTER);
        *pMilliseconds = m_autosaveInterval;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::GetAutosave"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaServer::GetBuildVersion( 
    ULONG *pBuildVersion
    )

/*++

Implements:

  IWsbServer::GetBuildVersion().

--*/
{
    HRESULT       hr = S_OK;
    WsbTraceIn(OLESTR("CFsaServer::GetBuildVersion"), OLESTR(""));
   
    try {
        WsbAssertPointer(pBuildVersion);

        *pBuildVersion = m_buildVersion;

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaServer::GetBuildVersion"), OLESTR("hr = <%ls>, Version = <%ls)"),
        WsbHrAsString(hr), RsBuildVersionAsString(m_buildVersion));
    return ( hr );
}

HRESULT
CFsaServer::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaServer::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CFsaServerNTFS;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CFsaServer::GetDatabaseVersion( 
    ULONG *pDatabaseVersion
    )

/*++

Implements:

  IWsbServer::GetDatabaseVersion().

--*/
{
    HRESULT       hr = S_OK;
    WsbTraceIn(OLESTR("CFsaServer::GetDatabaseVersion"), OLESTR(""));
    
    *pDatabaseVersion = m_databaseVersion;
    
    WsbTraceOut(OLESTR("CFsaServer::GetDatabaseVersion"), OLESTR("hr = <%ls>, Version = <%ls)"),
        WsbHrAsString(hr), WsbPtrToUlongAsString(pDatabaseVersion));
    return ( hr );
}

HRESULT
CFsaServer::GetDbPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaServer::GetDbPath().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaServer::GetDbPath"), OLESTR(""));
    try {

        WsbAssert(0 != pPath, E_POINTER); 

        // Right now it is hard coded. This will probably change to something from the registry.
        WsbAffirmHr(m_dbPath.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);
    WsbTraceOut(OLESTR("CFsaServer::GetDbPath"), OLESTR("hr = <%ls>, path = <%ls)"),
        WsbHrAsString(hr), WsbPtrToStringAsString(pPath));

    return(hr);
}


HRESULT
CFsaServer::GetDbPathAndName(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaServer::GetDbPathAndName().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pPath, E_POINTER); 

        tmpString = m_dbPath;
        tmpString.Append(OLESTR("\\RsFsa.col"));
        WsbAffirmHr(tmpString.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaServer::GetIDbPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaServer::GetIDbPath().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pPath, E_POINTER); 

        WsbAffirmHr(GetDbPath(&tmpString, 0));

        tmpString.Append(OLESTR("\\"));
        tmpString.Append(FSA_DB_DIRECTORY);

        WsbAffirmHr(tmpString.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}

HRESULT
CFsaServer::GetUnmanageIDbPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaServer::GetIDbPath().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pPath, E_POINTER); 

        WsbAffirmHr(GetDbPath(&tmpString, 0));

        tmpString.Append(OLESTR("\\"));
        tmpString.Append(FSA_DB_DIRECTORY);
        tmpString.Append(OLESTR("\\"));
        tmpString.Append(UNMANAGE_DB_DIRECTORY);

        WsbAffirmHr(tmpString.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}

HRESULT
CFsaServer::GetIDbSys(
    OUT IWsbDbSys** ppDbSys
    )

/*++

Implements:

  IFsaServer::GetIDbSys().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != ppDbSys, E_POINTER);

        *ppDbSys = m_pDbSys;
        m_pDbSys->AddRef();

    } WsbCatch(hr);

    return(hr);
}

HRESULT
CFsaServer::GetUnmanageIDbSys(
    OUT IWsbDbSys** ppDbSys
    )

/*++

Implements:

  IFsaServer::GetUnmanageIDbSys().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaServer::GetUnmanageIDbSys"), OLESTR(""));

    try {
        CWsbStringPtr   tmpString;

        WsbAssert(0 != ppDbSys, E_POINTER);

        // Unlike the premigarted db-sys-instance, we initialize the unamange db-sys-instance 
        // only when it is required for the first time
        if (! m_isUnmanageDbSysInitialized) {
            WsbAffirmHr(CoCreateInstance(CLSID_CWsbDbSys, NULL, CLSCTX_SERVER, IID_IWsbDbSys, (void**) &m_pUnmanageDbSys));

            WsbAffirmHr(GetUnmanageIDbPath(&tmpString, 0));
            WsbAffirmHr(m_pUnmanageDbSys->Init(tmpString, IDB_SYS_INIT_FLAG_NO_LOGGING | 
                        IDB_SYS_INIT_FLAG_SPECIAL_ERROR_MSG | IDB_SYS_INIT_FLAG_NO_BACKUP));

            m_isUnmanageDbSysInitialized = TRUE;
        }

        *ppDbSys = m_pUnmanageDbSys;
        m_pUnmanageDbSys->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::GetUnmanageIDbSys"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaServer::GetId(
    OUT GUID* pId
    )

/*++

Implements:

  IWsbServer::GetId().

--*/
{
    return(GetIdentifier(pId));
}

HRESULT
CFsaServer::GetIdentifier(
    OUT GUID* pId
    )

/*++

Implements:

  IFsaServer::GetIdentifier().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);

        *pId = m_id;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaServer::GetFilter(
    OUT IFsaFilter** ppFilter
    )

/*++

Implements:

  IFsaServer::GetFilter().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != ppFilter, E_POINTER);

        *ppFilter = m_pFilter;
        m_pFilter->AddRef();

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaServer::GetLogicalName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaServer::GetLogicalName().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pName, E_POINTER); 

        WsbAffirmHr(tmpString.TakeFrom(*pName, bufferSize));

        try {

            // This is an arbitrary choice for the naming convention. Nothing has been
            // decided upon.
            tmpString = m_name;
            WsbAffirmHr(tmpString.Append(OLESTR("\\NTFS")));

        } WsbCatch(hr);

        WsbAffirmHr(tmpString.GiveTo(pName));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaServer::GetName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IFsaServer::GetName().

--*/
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pName, E_POINTER); 
        WsbAffirmHr(m_name.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT CFsaServer::GetRegistryName ( 
    OLECHAR **pName, 
    ULONG bufferSize
    )  
/*++

Implements:

  IWsbServer::GetRegistryName().

--*/
{

    HRESULT hr = S_OK;
    
    try  {
        CWsbStringPtr tmpString;
        
        WsbAssert(0 != pName,  E_POINTER);
        
        tmpString = FSA_REGISTRY_NAME;
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));
        
    } WsbCatch( hr );
    
    return (hr);
}


HRESULT
CFsaServer::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistStream> pPersistStream;
    ULARGE_INTEGER          entrySize;

    WsbTraceIn(OLESTR("CFsaServer::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pSize, E_POINTER);

        // Determine the size for a rule with no criteria.
        pSize->QuadPart = WsbPersistSize((wcslen(m_name) + 1) * sizeof(OLECHAR)) + WsbPersistSizeOf(GUID);

        // Now allocate space for the resource collection.
        WsbAffirmPointer(m_pResources);
        WsbAffirmHr(m_pResources->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
        pSize->QuadPart += entrySize.QuadPart;
        pPersistStream = 0;

        // Now allocate space for the filter.
        WsbAffirmHr(m_pFilter->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
        pSize->QuadPart += entrySize.QuadPart;
        pPersistStream = 0;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CFsaServer::Init(
    void
    )

/*++

Implements:

  CFsaServer::Init().

--*/
{

    HRESULT                     hr = S_OK;
    CComPtr<IPersistFile>       pPersistFile;
    CComPtr<IWsbServer>         pWsbServer;
    CComPtr<IFsaFilterPriv>     pFilterPriv;
    CWsbStringPtr               tmpString;
    HANDLE                      pHandle;
    LUID                        backupValue;
    HANDLE                      tokenHandle;
    TOKEN_PRIVILEGES            newState;
    DWORD                       lErr;
    

    WsbTraceIn(OLESTR("CFsaServer::Init"), OLESTR(""));

    try {

        // Store of the name of the server and path to meta data
        WsbAffirmHr(WsbGetComputerName(m_name));
        WsbAffirmHr(WsbGetMetaDataPath(m_dbPath));

        // Set the build and database parameters
        m_databaseVersion = FSA_CURRENT_DB_VERSION;
        m_buildVersion = RS_BUILD_VERSION;

        // Set the autosave parameters.
        m_autosaveInterval = DEFAULT_AUTOSAVE_INTERVAL;
        m_autosaveThread = 0;

        // Enable the backup operator privilege.  This is required to insure that we 
        // have full access to all resources on the system.
        pHandle = GetCurrentProcess();
        WsbAffirmStatus(OpenProcessToken(pHandle, MAXIMUM_ALLOWED, &tokenHandle));

        // adjust backup token privileges
        WsbAffirmStatus(LookupPrivilegeValueW(NULL, L"SeBackupPrivilege", &backupValue));
        newState.PrivilegeCount = 1;
        newState.Privileges[0].Luid = backupValue;
        newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        WsbAffirmStatus(AdjustTokenPrivileges(tokenHandle, FALSE, &newState, (DWORD)0, NULL, NULL));

        // Note that AdjustTokenPrivileges may return success even if it did not assign all privileges.
        // We check last error here to insure everything was set.
        if ((lErr = GetLastError()) != ERROR_SUCCESS) {
            // Not backup user or some other error
            //
            // TODO: Should we fail here or just log something?
            WsbLogEvent( FSA_MESSAGE_SERVICE_UNABLE_TO_SET_BACKUP_PRIVILEGE, 0, NULL,
                         WsbHrAsString(HRESULT_FROM_WIN32(lErr)), NULL );
        }

        WsbAffirmStatus(LookupPrivilegeValueW(NULL, L"SeRestorePrivilege", &backupValue));
        newState.PrivilegeCount = 1;
        newState.Privileges[0].Luid = backupValue;
        newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        WsbAffirmStatus(AdjustTokenPrivileges(tokenHandle, FALSE, &newState, (DWORD)0, NULL, NULL));

        // Note that AdjustTokenPrivileges may return success even if it did not assign all privileges.
        // We check last error here to insure everything was set.
        if ((lErr = GetLastError()) != ERROR_SUCCESS) {
            // Not backup user or some other error
            //
            // TODO: Should we fail here or just log something?
            WsbLogEvent( FSA_MESSAGE_SERVICE_UNABLE_TO_SET_RESTORE_PRIVILEGE, 0, NULL,
                         WsbHrAsString(HRESULT_FROM_WIN32(lErr)), NULL );
        }
        CloseHandle(tokenHandle);

        // Check to see if trtacking of last access dates is enabled. If not,
        // we don't want to start the service. However, Microsoft wants us to
        // start it anyway, so we will log a warning.
        if (IsUpdatingAccessDates() != S_OK) {
            WsbLogEvent(FSA_MESSAGE_NOT_UPDATING_ACCESS_DATES, 0, NULL, NULL);
        }
        
        //  Create the event that synchronize saving of persistent data with snapshots
        WsbAffirmHandle(m_savingEvent = CreateEvent(NULL, FALSE, TRUE, HSM_FSA_STATE_EVENT));

        // Create the IDB system for this process
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbDbSys, NULL, CLSCTX_SERVER, IID_IWsbDbSys, (void**) &m_pDbSys));

        // Initialize the IDB system
        WsbAffirmHr(GetIDbPath(&tmpString, 0));
        WsbAffirmHr(m_pDbSys->Init(tmpString, IDB_SYS_INIT_FLAG_LIMITED_LOGGING | 
                        IDB_SYS_INIT_FLAG_SPECIAL_ERROR_MSG | IDB_SYS_INIT_FLAG_NO_BACKUP));

        // Create the resource collection (with no items).
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_SERVER, IID_IWsbCollection, (void**) &m_pResources));

        // Create the Filter.
        WsbAffirmHr(CoCreateInstance(CLSID_CFsaFilterNTFS, NULL, CLSCTX_SERVER, IID_IFsaFilter, (void**) &m_pFilter));
        WsbAffirmHr(m_pFilter->QueryInterface(IID_IFsaFilterPriv, (void**) &pFilterPriv));
        WsbAffirmHr(pFilterPriv->Init((IFsaServer*) this));
        
        // Try to load the server from stored information. If this fails, then store out the current state.
        WsbAffirmHr(((IUnknown*) (IFsaServer*) this)->QueryInterface(IID_IWsbServer, (void**) &pWsbServer));
        WsbAffirmHr(WsbServiceSafeInitialize(pWsbServer, TRUE, FALSE, NULL));
        
        // Register the FSA Service.
        WsbAffirmHr(GetLogicalName(&tmpString, 0));
        WsbAffirmHr(HsmPublish(HSMCONN_TYPE_FSA, tmpString, m_id, m_name, CLSID_CFsaServerNTFS));

        // Update our information about the available resources, and save it out.
        WsbAffirmHr(ScanForResources());

        // Save updated information
        hr = SaveAll();
        // S_FALSE just means that FSA is already saving...
        if ((S_OK != hr) && (S_FALSE != hr)) {
            WsbAffirmHr(hr);
        }

        // Check if recovery is needed
        WsbAffirmHr(DoRecovery());

        // If the filter is enabled, then start it.
        if (m_pFilter->IsEnabled() == S_OK) {
            WsbAffirmHr(m_pFilter->Start());
        }

        // Create termination event for auto-backup thread
        WsbAffirmHandle((m_terminateEvent = CreateEvent(NULL, FALSE, FALSE, NULL)));

        // If the autosave interval is non-zero, start the autosave thread
        if (m_autosaveInterval) {
            ULONG  interval = m_autosaveInterval;

            WsbAffirm(0 == m_autosaveThread, E_FAIL);
            m_autosaveInterval = 0;

            //  Trick SetAutosave into starting the thread
            WsbAffirmHr(SetAutosave(interval));
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::Init"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);

}


HRESULT
CFsaServer::IsUpdatingAccessDates(
    void
    )

/*++

Implements:

  IFsaServer::IsUpdatingAccessDates().

--*/
{
    HRESULT         hr = S_OK;
    DWORD           value = 0;
    
    // See if the appropriate registry entry has been created and has the
    // specified value of 1. This disables access time updating.
    if ((WsbGetRegistryValueDWORD(NULL, OLESTR("SYSTEM\\CurrentControlSet\\Control\\FileSystem"), OLESTR("NtfsDisableLastAccessUpdate"), &value) == S_OK) &&
        (0 != value)) {
        hr = S_FALSE;
    }

    return(hr);    
}


HRESULT
CFsaServer::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;

    WsbTraceIn(OLESTR("CFsaServer::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the save method.
        
        //
        // Make sure this is the right version of the database to load
        //
        ULONG tmpDatabaseVersion;
        WsbAffirmHr(WsbLoadFromStream(pStream, &tmpDatabaseVersion));
        if (tmpDatabaseVersion != m_databaseVersion)  {
            //
            // The database version this server is expecting does not
            // match that of the saved database - so error out.
            WsbLogEvent( FSA_MESSAGE_DATABASE_VERSION_MISMATCH, 0, NULL, WsbQuickString(WsbPtrToUlongAsString(&m_databaseVersion)),
                         WsbQuickString(WsbPtrToUlongAsString(&tmpDatabaseVersion)), NULL );
            WsbThrow(FSA_E_DATABASE_VERSION_MISMATCH);
        }
        //
        // Now read in the build version but don't do anything with it.  It is in the
        // databases for dump programs to display
        //
        ULONG tmpBuildVersion;
        WsbAffirmHr(WsbLoadFromStream(pStream, &tmpBuildVersion));
        
        
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_id));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_name, 0));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_autosaveInterval));

        // Load the resource collection.
        WsbAffirmPointer(m_pResources);
        WsbAffirmHr(m_pResources->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        // Load the filter.
        WsbAffirmHr(m_pFilter->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CFsaServer::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaServer::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistStream> pPersistStream;

    WsbTraceIn(OLESTR("CFsaServer::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the load method.
        WsbAffirmHr(WsbSaveToStream(pStream, m_databaseVersion));
        WsbAffirmHr(WsbSaveToStream(pStream, m_buildVersion));
        
        WsbAffirmHr(WsbSaveToStream(pStream, m_id));
        WsbAffirmHr(WsbSaveToStream(pStream, m_name));
        WsbAffirmHr(WsbSaveToStream(pStream, m_autosaveInterval));

        // Save off the resource collections.
        WsbAffirmPointer(m_pResources);
        WsbAffirmHr(m_pResources->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        // Save off the filter.
        WsbAffirmHr(m_pFilter->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaServer::SaveAll(
    void
    )

/*++

Implements:

  IwsbServer::SaveAll

Return Value:
    S_OK     - Success
    S_FALSE  - Already saving
    Other    - Error

--*/
{

    HRESULT                     hr = S_OK;
    static BOOL                 saving = FALSE;

    WsbTraceIn(OLESTR("CFsaServer::SaveAll"), OLESTR(""));

    try {
        DWORD   status, errWait;
        CComPtr<IPersistFile>       pPersistFile;

        WsbAffirm(!saving, S_FALSE);

        // Synchronize saving of persistent data with snapshot signaling event
        saving = TRUE;
        status = WaitForSingleObject(m_savingEvent, EVENT_WAIT_TIMEOUT);
        
        // Save anyway, then report if the Wait function returned an unexpected error
        errWait = GetLastError();
        
        // Note: Don't throw exception here because even if saving fails, we still need 
        //  to set the saving event and reset the saving flag.
        hr = (((IUnknown*) (IFsaServer*) this)->QueryInterface(IID_IPersistFile, (void**) &pPersistFile));
        if (SUCCEEDED(hr)) {
            hr = WsbSafeSave(pPersistFile);
        }

        // Check Wait status... Note that hr remains OK because the saving itself completed fine
        switch (status) {
            case WAIT_OBJECT_0: 
                // The expected case
                if (! SetEvent(m_savingEvent)) {
                    // Don't abort, just trace error
                    WsbTraceAlways(OLESTR("CFsaServer::SaveAll: SetEvent returned unexpected error %lu\n"), GetLastError());
                }
                break;

            case WAIT_TIMEOUT: 
                // TEMPORARY: Should we log somethig here? This might happen if snapshot process 
                //  takes too long for some reason, but logging seems to just confuse the user
                //  and he really can not (and should not) do anything...
                WsbTraceAlways(OLESTR("CFsaServer::SaveAll: Wait for Single Object timed out after %lu ms\n"), EVENT_WAIT_TIMEOUT);
                break;

            case WAIT_FAILED:
                WsbTraceAlways(OLESTR("CFsaServer::SaveAll: Wait for Single Object returned error %lu\n"), errWait);
                break;

            default:
                WsbTraceAlways(OLESTR("CFsaServer::SaveAll: Wait for Single Object returned unexpected status %lu\n"), status);
                break;
        }         

        saving = FALSE;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::SaveAll"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CFsaServer::ScanForResources(
    void
    )

/*++

Implements:

  IFsaServer::ScanForResources().

Routine Description:

    This routine implements the COM method for creating (on the first call) or 
    updating (on all subsequent calls) the persisted ('master') collection of 
    resources (i.e., drives/volumes) which are MANAGEABLE by this HSM system.

    The method contains 3 phases (sections).  The first phase creates a 'working' 
    resource collection, which it then populates with all manageable resources it 
    finds after scanning all resources on this computer.  (Only NTFS-formatted 
    volumes which support sparse files and reparse points are considered to be 
    manageable by Sakkara.)  The second phase then correlates, or 'synchronizes', 
    the contents of the 'working' collection with those of the 'master' collection.  
    This synchronization consists of adding to the 'master' collection any resources 
    contained in the 'working' collection which are not in the 'master' collection, 
    and updating any resources already in the master collection from the resources 
    in the working collection. The third phase 'synchronizes' (compares) the contents 
    of the master collection to those in the working collection.  Any resources in 
    the master collection which are not in the working collection are marked as 'not 
    available' so those resources do not appear in any list of manageable 
    resources presented to the user.

    NOTE that the method does not end by explicitly releasing the working resource 
    collection.  This is because the interface pointer to the working collection is 
    contained within a smart pointer, which automatically calls Release() on itself 
    when it goes out of scope.  The working collection derives from the 
    CWsbIndexedCollection class, which contains a Critical Section.  This section is 
    destroyed on a Release() call, so subsequent calls to Release() would fail 
    (normally with an Access Violation in NTDLL.dll) due to the non-existence of the 
    Critical Section.  For this reason the working collection is allowed to auto-
    garbage collect itself when it goes out of scope at method end (which also 
    releases all the resources contained in the working collection).

Arguments:

    none.

Return Value:

    S_OK - The call succeeded (the persisted collection of manageable resources on 
            this computer was either created or updated).

    E_FAIL - The call to get the logical names of all drives (resources) on this 
            computer failed.

    E_UNEXPECTED - Thrown if the total number of either working collection or master
            collection resources were not processed during the synchronization phases.

    Any other value - The call failed because one of the Remote Storage API calls 
            contained internally in this method failed.  The error value returned is
            specific to the API call which failed.
            
--*/

{
    HRESULT                     hr = S_OK;
    HRESULT                     searchHr = E_FAIL;
    CComPtr<IWsbCollection>     pWorkingResourceCollection;
    CComPtr<IWsbEnum>           pEnum;
    CComPtr<IFsaResource>       pScannedResource;
    CComPtr<IFsaResourcePriv>   pScannedResourcePriv;
    CComPtr<IFsaResource>       pWorkingResource;
    CComPtr<IFsaResource>       pMasterResource;
    CComPtr<IFsaResourcePriv>   pMasterResourcePriv;
    GUID                        id = GUID_NULL;
    DWORD                       i = 0;
    DWORD                       j = 0;
    ULONG                       nbrResources = 0;
    ULONG                       nbrResourcesSynced  = 0;
    ULONG                       nbrResourcesUpdated = 0;
    ULONG                       nbrResourcesAdded   = 0;
    CWsbStringPtr               tmpString;
// The below variables are used in support of the code which scans all resources known 
// by this computer in building the working collection of manageable resources (the 
// code contained in Phase 1 below).  The code is written to discover ALL resources, 
// including those mounted without drive letters.
    BOOL                        b;
    PWSTR                       dosName;            // Pointer to a null-terminated Unicode
                                                    // character string.
    HANDLE                      hVol;
    WCHAR                       volName[2*MAX_PATH];
    WCHAR                       driveName[10];
    WCHAR                       driveNameWOBack[10];
    WCHAR                       driveLetter;
    WCHAR                       otherName[MAX_PATH];

    WsbTraceIn(OLESTR("CFsaServer::ScanForResources"), OLESTR(""));

    try {
        WsbAffirmPointer(m_pResources);

        //
        // First phase: Scan all resources, load manageable ones in a 'working' collection.
        //
        
        // Create the 'working' resource collection (with no items).
        // This is where the results of this scan will be stored.  
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, 
                                     CLSCTX_SERVER, IID_IWsbCollection, 
                                     (void**) &pWorkingResourceCollection));

        // Begin code added to use new API's which discover all volumes, including those 
        // mounted without drive letters (new feature to NT5) - added by Mike Lotz
        driveName[1] = ':';
        driveName[2] = '\\';
        driveName[3] = 0;
        // drive name without back slash
        driveNameWOBack[1] = ':';
        driveNameWOBack[2] = 0;
    
        // Find the first volume on this computer.  Call returns the long, ugly PNP name.
        hVol = FindFirstVolume( volName, MAX_PATH );
        if ( INVALID_HANDLE_VALUE != hVol ) {
            do {
        
                // Release the current interface pointers that will be reused in this loop.  
                // This drops the ref count to 0, releasing memory, object (if it was not 
                // added to the collection), and the interface pointer itself, but not the 
                // smart pointer instance.
                //
                // Do first so we gaurantee cleanup before reuse
                //
                pScannedResource = 0;
                pScannedResourcePriv = 0;
                // The long, ugly PNP name.
                tmpString = volName;

                // Initialize
                dosName = NULL;

                WsbTrace(OLESTR("CFsaServer::ScanForResources - Searching for %ws\n"),
                                tmpString);

                // Loop through this computer's volumes/resources until we find the one 
                // that 'FindFirstVolume' or 'FindNextVolume' returned to us.  (Note they 
                // are not returned in drive letter order, but in PNP name order.)  We do 
                // this since we need the drive letter for the resource (if there is one), 
                // and currently neither of the above calls returns it.
                for (driveLetter = L'C'; driveLetter <= L'Z'; driveLetter++) {

                    driveName[0] = driveLetter;
                    driveNameWOBack[0] = driveLetter;
                    b = GetVolumeNameForVolumeMountPoint(driveName, otherName,
                                                         MAX_PATH);
                    // If unable to get a volume name for the mount point (if 'driveLetter'
                    // volume doesn't exist) jump back to the 'top' of the for loop.
                    if (!b) {
                        continue;
                    }

                    WsbTrace(OLESTR("CFsaServer::ScanForResources - for drive letter %ws "
                                L"volume name is %ws\n"),
                                driveName, otherName);

                    // if 'tmpString' (the long, ugly PNP volume name returned by the 
                    // 'Find[First/Next]Volume' call) and 'otherName' (also the PNP 
                    // volume name, but is returned by the 'GetVolumeNameFor...
                    // VolumeMountPoint call) ARE equal (lstrcmpi returns 0 if the 2 
                    // strings it compares are equal), set 'dosName' and break out of 
                    // the for loop, continuing thru the do-while.
                    if (!lstrcmpi(tmpString, otherName)) {
                        dosName = driveNameWOBack;
                        break;
                    }
                } // end for loop

                if (NULL != dosName) {
                    WsbTrace(OLESTR("CFsaServer::ScanForResources - DOS name is %ws "
                                L"Volume name to use is %ws\n"),
                                dosName, (WCHAR *)tmpString);
                } else {
                    WsbTrace(OLESTR("CFsaServer::ScanForResources - No DOS name, "
                                L"Volume name to use is %ws\n"),
                                (WCHAR *)tmpString);
                    
                    // Find if the volume is mounted in a mount point other than drive letter
                    HRESULT hrMount = WsbGetFirstMountPoint(tmpString, otherName, MAX_PATH);
                    if (S_OK == hrMount) {
                        if (wcslen(otherName) > 1) {
                            // Remove trailing backslash
                            dosName = otherName;
                            dosName[wcslen(otherName)-1] = 0;
                            WsbTrace(OLESTR("CFsaServer::ScanForResources - Mount path is %ws\n"),
                                        dosName);
                        }
                    } else {
                        WsbTrace(OLESTR("CFsaServer::ScanForResources - no Mount path found, hr = <%ls>\n"),
                                WsbHrAsString(hrMount));                                
                    }
                }
                // end of code added to support volumes without drive letters.

                WsbTrace(OLESTR("CFsaServer::ScanForResources - Checking resource %ls "
                                L"for manageability\n"), 
                                (WCHAR *) tmpString);


                // Create Resource instance to be used to test volume manageability.  Get
                // 'private' (non-exposed) interface since test method (Init()) is there.
                WsbAffirmHr(CoCreateInstance(CLSID_CFsaResourceNTFS, NULL, 
                                             CLSCTX_SERVER, IID_IFsaResourcePriv, 
                                             (void**) &pScannedResourcePriv));
                
                try {
                    
                    // Test volume for manageability.  If so, get and store volume info, 
                    // assign a Guid to the volume (if not already done), and create and/or 
                    // locate the Premigrated DB.
                    WsbAffirmHr(pScannedResourcePriv->Init((IFsaServer*) this, tmpString, 
                                                            dosName));
                    // We have a manageable volume (resource).  Get 'public' interface for 
                    // the resource since this is what is stored in the collection.
                    WsbAffirmHr(pScannedResourcePriv->QueryInterface(IID_IFsaResource, 
                                                             (void**) &pScannedResource));

                    // Add the manageable resource to the 'working' collection.
                    WsbAffirmHr( pWorkingResourceCollection->Add( pScannedResource ) );
                    WsbAffirmHr(pScannedResource->GetIdentifier( &id ) );
                    WsbTrace
                      (OLESTR("CFsaServer::ScanForResources - Added <%ls> to working list "
                                L"(id = %ls)\n"),
                                (WCHAR *) tmpString, WsbGuidAsString(id));

                // Test if Init() call above failed.  If so, skip this volume, go on to next.
                } WsbCatchAndDo(hr, if ((FSA_E_UNMANAGABLE == hr) || 
                                        (FSA_E_NOMEDIALOADED == hr)) {hr = S_OK;} 
                                        else {
                                            if (NULL != dosName) {
                                                WsbLogEvent(FSA_MESSAGE_BAD_VOLUME, 0, NULL, 
                                                  (WCHAR *) dosName, WsbHrAsString(hr), 0);
                                                        
                                            } else {
                                                WsbLogEvent(FSA_MESSAGE_BAD_VOLUME, 0, NULL, 
                                                (WCHAR *) tmpString, WsbHrAsString(hr), 0);
                                            }
                                        //
                                        // Do not fail just because one volume got an error
                                        hr = S_OK;
                                        });

            // end do-while; process next resource on this computer
            } while ( FindNextVolume( hVol, volName, MAX_PATH ) );

            // close the handle
            FindVolumeClose( hVol );

        } // if INVALID_HANDLE_VALUE != hVol

        // If first phase didn't complete Ok abort this method (with Trace & Logging).
        WsbAssertHrOk( hr );


        //
        // Second phase: Correlate/synchronize resources in 'working' collection with 
        // those in the 'master' (persisted) collection.
        //
        
        // Get number of resources stored in the working collection.
        WsbAffirmHr( pWorkingResourceCollection->GetEntries( &nbrResources ) );

        // Get iterator to working collection.
        WsbAffirmHr( pWorkingResourceCollection->Enum( &pEnum ) );

        // For each resource in the 'working' collection, search the 'master' collection 
        // to see if the resource is listed.  If so, update the master resource's state 
        // from the working resource.  If not, add it.
    
        for ( hr = pEnum->First( IID_IFsaResource, (void**) &pWorkingResource ); 
              SUCCEEDED( hr ); 
              hr = pEnum->Next( IID_IFsaResource, (void**) &pWorkingResource ) ) {

            // Release reused interface pointers for next loop iteration.
            // Do first to gaurantee clean pointer before use
            pMasterResource = 0;
            pMasterResourcePriv = 0;

            // Search for this resource in master collection.  (There is no need to 
            // set the 'working' resource's 'compare by' field since it is constructed 
            // with the 'compare by id' value and we haven't changed it.)
            searchHr = m_pResources->Find( pWorkingResource, IID_IFsaResource, 
                                             (void**) &pMasterResource );

            try {
                if ( SUCCEEDED( searchHr ) ) {
                    // A matching resource entry has been found in the master 
                    // collection, so update it.

                    // Get the 'private' interface to the master resource & update it 
                    // from the working resource.

                    WsbAffirmHr(pMasterResource->QueryInterface( IID_IFsaResourcePriv, 
                                                      (void**) &pMasterResourcePriv ) );
                    WsbAffirmHr(pMasterResourcePriv->UpdateFrom( (IFsaServer*) this, 
                                                             pWorkingResource ) );

                    /*/ *** TEMP TRACE - remove from normal code path for efficiency.
                    CWsbStringPtr   workingRsc;
                    CWsbStringPtr   masterRsc;
                    GUID            workingRscId = GUID_NULL;
                    
                    // First get the path (root of volume) & id of the 'working' resource.
                    WsbAffirmHr(pWorkingResource->GetPath( &workingRsc, 0 ) );
                    WsbAffirmHr(pWorkingResource->GetIdentifier( &workingRscId ) );
                    // then that of the 'master' resource.
                    WsbAffirmHr(pMasterResource->GetPath( &masterRsc, 0 ) );

                    WsbTrace(OLESTR("CFsaServer::ScanForResources - "   
                        L"Master resource <%ls> updated from working resource <%ls>"
                        L" (id = <%ls>).\n"),
                                    (OLECHAR*)masterRsc, (OLECHAR*)workingRsc,
                                    WsbGuidAsString( workingRscId ) );
                    // *** End TEMP TRACE  */
        
                    nbrResourcesUpdated += 1;
                
                }
                else if ( WSB_E_NOTFOUND == searchHr ) { 
                    // No matching entry found in the master collection, add it, indicate 
                    // synchronization success.
                    WsbAffirmHr( m_pResources->Add( pWorkingResource ) );

                    /*/ *** TEMP TRACE - remove from normal code path for efficiency.
                    CWsbStringPtr   workingRsc;
                    GUID            workingRscId = GUID_NULL;
                    
                    // Get the path (root of volume) and id of the 'working' resource.
                    WsbAffirmHr(pWorkingResource->GetPath( &workingRsc, 0 ) );
                    WsbAffirmHr(pWorkingResource->GetIdentifier( &workingRscId ) );

                    WsbTrace(OLESTR("CFsaServer::ScanForResources - "   
                        L"Working resource <%ls> added to master collection "
                        L"(id = <%ls>.\n"),
                                    workingRsc, WsbGuidAsString( workingRscId ) );
                    // *** End TEMP TRACE  */
        
                    nbrResourcesAdded += 1;
                    searchHr = S_OK;
                }
                
                // Trap any unexpected search failure: Trace, Log, Throw; skip to next rsc.
                WsbAssertHrOk( searchHr );

                // This volume has been synchronized in the master collection, register 
                // or update the FSA Resource in Directory Services as necessary.
                WsbAffirmHr(pWorkingResource->GetLogicalName(&tmpString, 0));
                WsbAffirmHr(HsmPublish(HSMCONN_TYPE_RESOURCE, tmpString, id, 0, m_id));

            } WsbCatch( hr );
            
            // Done with this Resource. Increment count of resources synchronized and 
            // release interface pointer for next iteration.
            nbrResourcesSynced += 1;
            pWorkingResource = 0;

        } // end 'for'

        // Ensure all resources in working collection were processed.  If not,
        // Trace, Log and Throw and abort the method.
        WsbAssert( nbrResources == nbrResourcesSynced, E_UNEXPECTED );

        // Ensure we are at the end of the working collection.  If not, abort.
        WsbAssert( WSB_E_NOTFOUND == hr, hr );
        
        hr = S_OK;

        WsbTrace(OLESTR("CFsaServer::ScanForResources - "   
                        L"2nd phase (1st search): Total working resources %lu. "
                        L"Resources updated %lu, resources added %lu.\n"),
                        nbrResources, nbrResourcesUpdated, nbrResourcesAdded);
        

        //
        // Third phase: Correlate/synchronize resources in 'master' collection with 
        // those in the 'working' collection.
        //
        
        // Reset counters for next for loop
        nbrResourcesSynced = 0;
        nbrResourcesUpdated = 0;

        // Get number of volumes stored in the 'master' Resource collection.
        WsbAffirmHr( m_pResources->GetEntries( &nbrResources ) );

        // Release the collection enumerator since we are about to reuse it.
        pEnum = 0;
        
        // Get an iterator to the 'master' collection
        WsbAffirmHr( m_pResources->Enum( &pEnum ) );

        /*/ *** TEMP TRACE - remove from normal code path for efficiency.
        CWsbStringPtr   masterResource;
        GUID            masterResourceId = GUID_NULL;
        // *** End TEMP TRACE  */

        // For each volume in the 'master' collection, search the 'working' collection 
        // to see if the resource is listed.  If so, skip to the next resource.  If not 
        // (this indicates this resource is no longer manageable), mark it as not available
        // in the 'master' collection's resource, which prevents the resource from  
        // being displayed whenever the list of manageable resources is presented.
        pMasterResource = 0;
        for ( hr = pEnum->First( IID_IFsaResource, (void**) &pMasterResource ); 
              SUCCEEDED( hr ); 
              pMasterResource = 0, hr = pEnum->Next( IID_IFsaResource, (void**) &pMasterResource ) ) {

            pMasterResourcePriv = 0;
            pWorkingResource = 0;

            // Set the search key, then search for this resource in working collection.
            // (Even though resource objects are constructed with their 'compare by' field 
            // set to 'compare by id', reset it here in case it has changed.)
            WsbAffirmHr( pMasterResource->CompareBy( FSA_RESOURCE_COMPARE_ID ) );
            searchHr = pWorkingResourceCollection->Find( pMasterResource, IID_IFsaResource,
                                                    (void**) &pWorkingResource );


            try {
                if ( WSB_E_NOTFOUND == searchHr ) { 
                    // No matching entry found in the 'working' collection, so this 
                    // resource is no longer manageable.  Mark it as not-available.

                    /*/ *** TEMP TRACE - remove from normal code path for efficiency.
                    CWsbStringPtr   masterRsc;
                    GUID            masterRscId = GUID_NULL;
                    
                    // Get the path (root of volume) and GUID of the 'master' resource 
                    // before it is nulled.
                    WsbAffirmHr(pMasterResource->GetPath( &masterRsc, 0 ) );
                    WsbAffirmHr(pMasterResource->GetIdentifier( &masterRscId ) );
                    // *** End TEMP TRACE  */

                    //
                    // Make it not available and null out the path, sticky name, and user friendly name so 
                    // it is not confused with another resource with the same name.
                    //
                    WsbAffirmHr(pMasterResource->QueryInterface( IID_IFsaResourcePriv, 
                                                      (void**) &pMasterResourcePriv ) );
                    WsbAffirmHr(pMasterResource->SetIsAvailable(FALSE));
                    WsbAffirmHr(pMasterResourcePriv->SetPath(OLESTR("")));
                    WsbAffirmHr(pMasterResourcePriv->SetStickyName(OLESTR("")));
                    WsbAffirmHr(pMasterResourcePriv->SetUserFriendlyName(OLESTR("")));

                    // Indicate synchronization success (for Assert below)
                    searchHr = S_OK;

                    /*/ *** TEMP TRACE - remove from normal code path for efficiency.
                    WsbTrace(OLESTR("CFsaServer::ScanForResources - "   
                        L"Master resource <%ls> (path = <%ls>) was marked unavailable.\n"),
                                    WsbGuidAsString( masterRscId ), masterRsc );
                    // *** End TEMP TRACE  */
        
                    nbrResourcesUpdated += 1;
                }

                // Trap any unexpected search failure: Trace, Log, Throw; skip to next rsc.
                WsbAssertHrOk( searchHr );

            } WsbCatch( hr );
            
            // Done with this Resource. Increment count of resources synchronized and 
            // release interface pointer for next iteration.
            nbrResourcesSynced += 1;

            /*/ *** TEMP TRACE - remove from normal code path for efficiency.
            // Get the path of the 'master' resource.
            WsbAffirmHr(pMasterResource->GetPath( &masterResource, 0 ) );
            WsbAffirmHr(pMasterResource->GetIdentifier( &masterResourceId ) );
            WsbTrace(OLESTR("CFsaServer::ScanForResources - "   
                    L"Processed Master resource <%ls> (path = <%ls>), "
                    L"moving on to next Master...\n"),
                                WsbGuidAsString( masterResourceId ), masterResource );
            // *** End TEMP TRACE  */

            pMasterResource = 0;
        
        } // end 'for'

        // Ensure all resources in master collection were processed.  If not,
        // Trace, Log and Throw and abort the method.
        WsbAssert( nbrResources == nbrResourcesSynced, E_UNEXPECTED );

        // Ensure we are at the end of the master collection.  If not, abort.
        WsbAssert( WSB_E_NOTFOUND == hr, hr );
        
        hr = S_OK;

        WsbTrace(OLESTR("CFsaServer::ScanForResources - "   
                        L"3rd phase (2nd search): Total master resources %lu. "
                        L"Resources marked as not available: %lu.\n"),
                        nbrResources, nbrResourcesUpdated );
        
    } WsbCatch( hr );

    // Scan done. Again, DO NOT explicitly release the 'working' collection due to 
    // the reasons listed in the final paragraph under "Routine Description" above.
    // Both the working resource collection, and all the resources it contains, will 
    // be released implicitly at method end.

    WsbTraceOut(OLESTR("CFsaServer::ScanForResources"), OLESTR("hr = <%ls>"), 
                                                        WsbHrAsString(hr));
    return( hr );
}



HRESULT
CFsaServer::SetAutosave(
    IN ULONG milliseconds
    )

/*++

Implements:

  IFsaServer::SetAutosave().

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CFsaServer::SetAutosave"), OLESTR("milliseconds = <%ls>"), WsbPtrToUlongAsString( &milliseconds ) );

    try {
        //  Don't do anything if interval isn't changing
        if (milliseconds != m_autosaveInterval) {
            //  Close the current thread
            if (m_autosaveThread) {
                StopAutosaveThread();
            }
            m_autosaveInterval = milliseconds;

            //  Start/restart the autosave thread
            if (m_autosaveInterval) {
                DWORD  threadId;

                WsbAffirm((m_autosaveThread = CreateThread(0, 0, FsaStartAutosave, (void*) this, 0, &threadId)) != 0, HRESULT_FROM_WIN32(GetLastError()));
            }
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::SetAutosave"), OLESTR("hr = <%ls> m_runInterval = <%ls>"), WsbHrAsString(hr), WsbPtrToUlongAsString( &m_autosaveInterval ) );

    return(hr);
}


HRESULT CFsaServer::SetId(
    GUID  id
    )
/*++

Implements:

  IWsbServer::SetId().

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CFsaServer::SetId"), OLESTR("id = <%ls>"), WsbGuidAsString( id ) );
    m_id = id;
    WsbTraceOut(OLESTR("CFsaServer::SetId"), OLESTR("hr = <%ls>"), WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CFsaServer::SetIsUpdatingAccessDates(
    BOOL isUpdating
    )

/*++

Implements:

  IFsaServer::IsUpdatingAccessDates().

--*/
{
    HRESULT         hr = S_OK;
   
    try { 

        // Removing the key allows for updating access times, and setting it
        // to 1 causes updating to be stopped.      
        if (isUpdating) {
            WsbAffirmHr(WsbRemoveRegistryValue(NULL, OLESTR("SYSTEM\\CurrentControlSet\\Control\\FileSystem"), OLESTR("NtfsDisableLastAccessUpdate")));
        } else {
            WsbAffirmHr(WsbSetRegistryValueDWORD(NULL, OLESTR("SYSTEM\\CurrentControlSet\\Control\\FileSystem"), OLESTR("NtfsDisableLastAccessUpdate"), 1));
        }

    } WsbCatch(hr);
    
    return(hr);    
}


HRESULT 
CFsaServer::ChangeSysState( 
    IN OUT HSM_SYSTEM_STATE* pSysState 
    )

/*++

Implements:

  IHsmSystemState::ChangeSysState().

--*/

{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaServer::ChangeSysState"), OLESTR(""));

    try {
        if (pSysState->State & HSM_STATE_SUSPEND) {
            if (!m_Suspended) {
                m_Suspended = TRUE;

                // Save data
                SaveAll();
            }
        } else if (pSysState->State & HSM_STATE_RESUME) {
            m_Suspended = FALSE;
        } else if (pSysState->State & HSM_STATE_SHUTDOWN) {

            //  Close the autosave thread
            StopAutosaveThread();

            if (m_pFilter != NULL) {
                //
                // Kill the filter thread and cancel the IOCTLS pending in the kernel filter
                //
                m_pFilter->StopIoctlThread();
            }
        }

        //  Notify resources
        if (m_pResources) {
            //
            // Scan through the resources and notify
            //
            CComPtr<IWsbEnum>         pEnum;
            CComPtr<IFsaResourcePriv> pResourcePriv;

            WsbAffirmHr(m_pResources->Enum(&pEnum));
            hr = pEnum->First(IID_IFsaResourcePriv, (void**)&pResourcePriv);
            while (S_OK == hr) {
                hr = pResourcePriv->ChangeSysState(pSysState);
                pResourcePriv = 0;
                hr = pEnum->Next(IID_IFsaResourcePriv, (void**)&pResourcePriv);
            }
            if (WSB_E_NOTFOUND == hr) {
                hr = S_OK;
            }
        }

        if (pSysState->State & HSM_STATE_SHUTDOWN) {

            //  Dump object table info
            WSB_OBJECT_TRACE_TYPES;
            WSB_OBJECT_TRACE_POINTERS(WSB_OTP_STATISTICS | WSB_OTP_ALL);
         }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::ChangeSysState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaServer::Unload(
    void
    )

/*++

Implements:

  IwsbServer::Unload

Return Value:
    S_OK     - Success
    Other    - Error

--*/
{

    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaServer::Unload"), OLESTR(""));

    try {

        //  We only need to release what may have gotten set/created by
        //  a failed Load attempt.

        if (m_pResources) {
            WsbAffirmHr(m_pResources->RemoveAllAndRelease());
        }

        m_name.Free();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::Unload"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaServer::DestroyObject(
    void
    )
/*++

Implements:

  IWsbServer::DestroyObject

Return Value:
    S_OK     - Success

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaServer::DestroyObject"), OLESTR(""));

    CComObject<CFsaServer> *pFsaDelete = (CComObject<CFsaServer> *)this;
    delete pFsaDelete;

    WsbTraceOut(OLESTR("CFsaServer::DestroyObject"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaServer::GetNtProductVersion ( 
    OLECHAR **pNtProductVersion, 
    ULONG bufferSize
    )  
/*++

Implements:

  IWsbServer::GetNtProductVersion().

--*/

{

    HRESULT hr = S_OK;
    
    try  {
        CWsbStringPtr tmpString;
        
        WsbAssert(0 != pNtProductVersion,  E_POINTER);
        
        tmpString = VER_PRODUCTVERSION_STRING;
        WsbAffirmHr(tmpString.CopyTo(pNtProductVersion, bufferSize));
        
    } WsbCatch( hr );
    
    return (hr);
}

HRESULT
CFsaServer::GetNtProductBuild( 
    ULONG *pNtProductBuild
    )

/*++

Implements:

  IWsbServer::GetNtProductBuild().

--*/
{
    HRESULT       hr = S_OK;
    WsbTraceIn(OLESTR("CFsaServer::GetNtProductBuild"), OLESTR(""));
   
    *pNtProductBuild = VER_PRODUCTBUILD;
    
    WsbTraceOut(OLESTR("CFsaServer::GetNtProductBuild"), OLESTR("hr = <%ls>, Version = <%ls)"),
        WsbHrAsString(hr), WsbLongAsString(VER_PRODUCTBUILD));
    return ( hr );
}


HRESULT
CFsaServer::CheckAccess(
    WSB_ACCESS_TYPE AccessType
    )
/*++

Implements:

  IWsbServer::CheckAccess().

--*/
{
    WsbTraceIn(OLESTR("CFsaServer::CheckAccess"), OLESTR(""));
    HRESULT hr = S_OK;
    
    try  {

        //
        // Do the impersonation
        //
        WsbAffirmHr( CoImpersonateClient() );

        hr = WsbCheckAccess( AccessType );
    
        CoRevertToSelf();
        
    } WsbCatchAndDo( hr,

        //
        // Handle case where there is no COM context to check against
        // in which case we are the service so any security is allowed.
        //
        if( ( hr == RPC_E_NO_CONTEXT ) || ( hr != RPC_E_CALL_COMPLETE ) ) {
        
            hr = S_OK;
        
        }                      

    );
    
    WsbTraceOut(OLESTR("CFsaServer::CheckAccess"), OLESTR("hr = <%ls>"), WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CFsaServer::GetTrace(
    OUT IWsbTrace ** ppTrace
    )
/*++

Implements:

  IWsbServer::GetTrace().

--*/
{
    WsbTraceIn(OLESTR("CFsaServer::GetTrace"), OLESTR("ppTrace = <0x%p>"), ppTrace);
    HRESULT hr = S_OK;
    
    try {

        WsbAffirmPointer(ppTrace);
        *ppTrace = 0;

        WsbAffirmPointer(m_pTrace);
        
        *ppTrace = m_pTrace;
        (*ppTrace)->AddRef();
        
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaServer::GetTrace"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CFsaServer::SetTrace(
    OUT IWsbTrace * pTrace
    )
/*++

Implements:

  IWsbServer::SetTrace().

--*/
{
    WsbTraceIn(OLESTR("CFsaServer::SetTrace"), OLESTR("pTrace = <0x%p>"), pTrace);
    HRESULT hr = S_OK;
    
    try {

        WsbAffirmPointer(pTrace);

        m_pTrace = pTrace;

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaServer::SetTrace"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

void
CFsaServer::StopAutosaveThread(
    void
    )
/*++

Routine Description:

  Stop the Autosave thread:
    First try gracefully, using the termination event
    If doesn't work, just terminate the thread

Arguments:

  None.
  
Return Value:

  S_OK  - Success.

--*/
{

    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaServer::StopAutosaveThread"), OLESTR(""));

    try {
        // Terminate the autosave thread
        if (m_autosaveThread) {
            // Signal thread to terminate
            SetEvent(m_terminateEvent);

            // Wait for the thread, if it doesn't terminate gracefully - kill it
            switch (WaitForSingleObject(m_autosaveThread, 20000)) {
                case WAIT_FAILED: {
                    WsbTrace(OLESTR("CFsaServer::StopAutosaveThread: WaitForSingleObject returned error %lu\n"), GetLastError());
                }
                // fall through...

                case WAIT_TIMEOUT: {
                    WsbTrace(OLESTR("CFsaServer::StopAutosaveThread: force terminating of autosave thread.\n"));

                    DWORD dwExitCode;
                    if (GetExitCodeThread( m_autosaveThread, &dwExitCode)) {
                        if (dwExitCode == STILL_ACTIVE) {   // thread still active
                            if (!TerminateThread (m_autosaveThread, 0)) {
                                WsbTrace(OLESTR("CFsaServer::StopAutosaveThread: TerminateThread returned error %lu\n"), GetLastError());
                            }
                        }
                    } else {
                        WsbTrace(OLESTR("CFsaServer::StopAutosaveThread: GetExitCodeThread returned error %lu\n"), GetLastError());
                    }

                    break;
                }

                default:
                    // Thread terminated gracefully
                    WsbTrace(OLESTR("CFsaServer::StopAutosaveThread: Autosave thread terminated gracefully\n"));
                    break;
            }

            // Best effort done for terminating auto-backup thread
            CloseHandle(m_autosaveThread);
            m_autosaveThread = 0;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaServer::StopAutosaveThread"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsatrace.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    FsaTrace.cpp

Abstract:

    These functions are used to provide an ability to trace the flow
    of the application for FSA debugging purposes.

Author:

    Cat Brant   [cbrant]   7-Dec-1996

Revision History:

--*/

#include "stdafx.h"
#include "stdio.h"

#include "fsa.h"


const OLECHAR*
FsaRequestActionAsString(
    FSA_REQUEST_ACTION  requestAction
    )

/*++

Routine Description:

    This routine provides a string repesentation (e.g. FSA_REQUSEST_ACTION_MIGRATE) for
    the value of the request action supplied.
    
    NOTE: This method does not support localization of the strings.

Arguments:

    requestAction       - An FSA_REQUEST_ACTION value.

Return Value:

    A string representation of the value of the request action.

--*/
{
    static OLECHAR  returnString[60];

    switch (requestAction) {
    case FSA_REQUEST_ACTION_DELETE:
        swprintf(returnString, OLESTR("FSA_REQUEST_ACTION_DELETE"));
            break;
    case FSA_REQUEST_ACTION_FILTER_RECALL:
        swprintf(returnString, OLESTR("FSA_REQUEST_ACTION_FIILTER_RECALL"));
            break;
    case FSA_REQUEST_ACTION_PREMIGRATE:
        swprintf(returnString, OLESTR("FSA_REQUEST_ACTION_PREMIGRATE"));
            break;
    case FSA_REQUEST_ACTION_RECALL:
        swprintf(returnString, OLESTR("FSA_REQUEST_ACTION_RECALL"));
            break;
    case FSA_REQUEST_ACTION_VALIDATE:
        swprintf(returnString, OLESTR("FSA_REQUEST_ACTION_VALIDATE"));
            break;
    default:
        swprintf(returnString, OLESTR("UNKNOWN FSA_REQUEST_ACTION_?????"));
            break;
    }

    return(returnString);
}


const OLECHAR*
FsaResultActionAsString(
    FSA_RESULT_ACTION  resultAction
    )

/*++

Routine Description:

    This routine provides a string repesentation (e.g. FSA_RESULT_ACTION_TRUNCATE) for
    the value of the result action supplied.
    
    NOTE: This method does not support localization of the strings.

Arguments:

    resultAction        - An FSA_RESULT_ACTION value.

Return Value:

    A string representation of the value of the result action.

--*/
{
    static OLECHAR  returnString[60];

    switch (resultAction) {
    case FSA_RESULT_ACTION_DELETE:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_DELETE"));
            break;
    case FSA_RESULT_ACTION_DELETEPLACEHOLDER:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_DELETEPLACEHOLDER"));
            break;
    case FSA_RESULT_ACTION_LIST:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_LIST"));
            break;
    case FSA_RESULT_ACTION_OPEN:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_OPEN"));
            break;
    case FSA_RESULT_ACTION_PEEK:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_PEEK"));
            break;
    case FSA_RESULT_ACTION_REPARSE:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_REPARSE"));
            break;
    case FSA_RESULT_ACTION_TRUNCATE:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_TRUNCATE"));
            break;
    case FSA_RESULT_ACTION_REWRITEPLACEHOLDER:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_REWRITEPLACEHOLDER"));
            break;
    case FSA_RESULT_ACTION_RECALLEDDATA:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_RECALLEDDATA"));
            break;
    case FSA_RESULT_ACTION_NONE:
        swprintf(returnString, OLESTR("FSA_RESULT_ACTION_NONE"));
            break;
    default:
        swprintf(returnString, OLESTR("UNKNOWN FSA_RESULT_ACTION_?????"));
            break;
    }

    return(returnString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsasrvr.h ===
#ifndef _FSASRVR_
#define _FSASRVR_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsasvr.h

Abstract:

    This module represents the root object for an FSA service for NTFS50.

Author:

    Chuck Bardeen   [cbardeen]   1-Dec-1996

Revision History:

--*/

#define FSA_DB_DIRECTORY        OLESTR("FsaDb")
#define UNMANAGE_DB_DIRECTORY   OLESTR("UnmanageDb")

/*++

Class Name:
    
    CFsaServer

Class Description:

    This class represents the root object for an FSA service for NTFS50.

--*/

class CFsaServer : 
    public CWsbPersistable,
    public IWsbCreateLocalObject,
    public IFsaServer,
    public IWsbServer,
    public CComCoClass<CFsaServer,&CLSID_CFsaServerNTFS>
{
public:
    CFsaServer() {}
BEGIN_COM_MAP(CFsaServer)
    COM_INTERFACE_ENTRY(IFsaServer)
    COM_INTERFACE_ENTRY(IWsbServer)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IPersistFile)
    COM_INTERFACE_ENTRY(IWsbPersistable)
    COM_INTERFACE_ENTRY(IWsbCreateLocalObject)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE( CFsaServer) 

DECLARE_REGISTRY_RESOURCEID(IDR_FsaServer)
DECLARE_PROTECT_FINAL_CONSTRUCT()

// CFsaServer
    STDMETHOD(Autosave)(void);
    STDMETHOD(IsUpdatingAccessDates)(void);
    STDMETHOD(SetIsUpdatingAccessDates)(BOOL isUpdating);

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCreateLocalServer
    STDMETHOD(CreateInstance)(REFCLSID rclsid, REFIID riid, void **ppv);

// IWsbServer
public:
    STDMETHOD( GetBuildVersion )( ULONG *pBuildVersion );
    STDMETHOD( GetNtProductVersion )( OLECHAR **pNtProductVersion, ULONG bufferSize );
    STDMETHOD( GetNtProductBuild )( ULONG *pNtProductBuild );
    STDMETHOD( GetDatabaseVersion )( ULONG *pDatabaseVersion );
    STDMETHOD( GetId )( GUID* pId );
    STDMETHOD( GetRegistryName )( OLECHAR **pRegistryName, ULONG bufferSize );
    STDMETHOD( SetId )( GUID  id );
    STDMETHOD( SaveAll )( void );
    STDMETHOD( Unload )( void );
    STDMETHOD( CheckAccess )( WSB_ACCESS_TYPE AccessType );
    STDMETHOD( GetTrace )( OUT IWsbTrace ** ppTrace );
    STDMETHOD( SetTrace )( IN IWsbTrace *pTrace );
    STDMETHOD( DestroyObject )( void );

// IHsmSystemState
    STDMETHOD( ChangeSysState )( HSM_SYSTEM_STATE* pSysState );

// IFsaServer
public:
    STDMETHOD(EnumResources)(IWsbEnum** ppEnum);
    STDMETHOD(FindResourceByAlternatePath)(OLECHAR* path, IFsaResource** ppResource);
    STDMETHOD(FindResourceById)(GUID id, IFsaResource** ppResource);
    STDMETHOD(FindResourceByName)(OLECHAR* name, IFsaResource** ppResource);
    STDMETHOD(FindResourceByPath)(OLECHAR* path, IFsaResource** ppResource);
    STDMETHOD(FindResourceBySerial)(ULONG serial, IFsaResource** ppResource);
    STDMETHOD(FindResourceByStickyName)(OLECHAR* name, IFsaResource** ppResource);
    STDMETHOD(GetAutosave)(ULONG* pMilliseconds);
    STDMETHOD(GetDbPath)(OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetDbPathAndName)(OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetIDbPath)(OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetUnmanageIDbPath)(OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(GetIDbSys)(IWsbDbSys** ppDbSys);
    STDMETHOD(GetUnmanageIDbSys)(IWsbDbSys** ppDbSys);
    STDMETHOD(GetFilter)(IFsaFilter** ppFilter);
    STDMETHOD(GetIdentifier)(GUID* pId);
    STDMETHOD(GetLogicalName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(Init)(void);
    STDMETHOD(ScanForResources)(void);
    STDMETHOD(SetAutosave)(ULONG milliseconds);

//  Internal functions
private:
    STDMETHOD(DoRecovery)(void);
    void StopAutosaveThread(void);


protected:
    ULONG                       m_autosaveInterval;  // Autosave interval in milliseconds; 
                                                     // zero turns if off.
    HANDLE                      m_autosaveThread;
    HANDLE                      m_terminateEvent;    // An event for signaling termination to the autosave thread
    HANDLE                      m_savingEvent;       // An event for synchronizing saving of persistent data
    BOOL                        m_Suspended;
    BOOL                        m_isUnmanageDbSysInitialized;
    GUID                        m_id;
    CWsbStringPtr               m_dbPath;
    CWsbStringPtr               m_name;
    CComPtr<IWsbCollection>     m_pResources;        // persisted collection of manageable
                                                     // resources.
    CComPtr<IFsaFilter>         m_pFilter;
    CComPtr<IWsbDbSys>          m_pDbSys;
    CComPtr<IWsbDbSys>          m_pUnmanageDbSys;
    CComPtr<IWsbTrace>          m_pTrace;

    ULONG                       m_buildVersion;
    ULONG                       m_databaseVersion;

};

#endif  // _FSASRVR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsatrunc.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsatrunc.cpp

Abstract:

    This class handles the automatic truncation of files that have already 
    been premigrated.

Author:

    Chuck Bardeen   [cbardeen]   20-Feb-1997

Revision History:

--*/

#include "stdafx.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_FSA

#include "wsb.h"
#include "fsa.h"
#include "fsaprem.h"
#include "fsarcvy.h"
#include "fsasrvr.h"
#include "fsatrunc.h"
#include "job.h"

#define DEFAULT_MAX_FILES_PER_RUN  10000
#define DEFAULT_RUN_INTERVAL       (15 * 60 * 1000)  // 15 minutes in milliseconds

#define STRINGIZE(_str) (OLESTR( #_str ))
#define RETURN_STRINGIZED_CASE(_case) \
case _case:                           \
    return ( STRINGIZE( _case ) );


static const OLECHAR *
FsaStateAsString (
    IN  HSM_JOB_STATE  state
    )

/*++

Routine Description:

    Gives back a static string representing the connection state. 

Arguments:

    state - the state to return a string for.

Return Value:

    NULL - invalid state passed in.

    Otherwise, a valid char *.

--*/

{
    //
    // Do the Switch
    //

    switch ( state ) {

    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_ACTIVE );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_CANCELLED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_CANCELLING );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_DONE );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_FAILED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_IDLE );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_PAUSED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_PAUSING );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_RESUMING );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_SKIPPED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_STARTING );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_SUSPENDED );
    RETURN_STRINGIZED_CASE( HSM_JOB_STATE_SUSPENDING );

    default:

        return ( OLESTR("Invalid Value") );

    }
}


static const OLECHAR *
FsaEventAsString (
    IN HSM_JOB_EVENT event
    )

/*++

Routine Description:

    Gives back a static string representing the connection event. 

Arguments:

    event - the event to return a string for.

Return Value:

    NULL - invalid event passed in.

    Otherwise, a valid char *.

--*/

{
    //
    // Do the Switch
    //

    switch ( event ) {

    RETURN_STRINGIZED_CASE( HSM_JOB_EVENT_CANCEL );
    RETURN_STRINGIZED_CASE( HSM_JOB_EVENT_FAIL );
    RETURN_STRINGIZED_CASE( HSM_JOB_EVENT_LOWER_PRIORITY );
    RETURN_STRINGIZED_CASE( HSM_JOB_EVENT_PAUSE );
    RETURN_STRINGIZED_CASE( HSM_JOB_EVENT_RAISE_PRIORITY );
    RETURN_STRINGIZED_CASE( HSM_JOB_EVENT_RESUME );
    RETURN_STRINGIZED_CASE( HSM_JOB_EVENT_START );
    RETURN_STRINGIZED_CASE( HSM_JOB_EVENT_SUSPEND );

    default:

        return ( OLESTR("Invalid Value") );

    }
}



static const OLECHAR *
FsaSortOrderAsString (
    IN FSA_PREMIGRATED_SORT_ORDER SortOrder
    )

/*++

Routine Description:

    Gives back a static string representing the connection SortOrder. 

Arguments:

    SortOrder - the SortOrder to return a string for.

Return Value:

    NULL - invalid SortOrder passed in.

    Otherwise, a valid char *.

--*/

{
    //
    // Do the Switch
    //

    switch ( SortOrder ) {

    RETURN_STRINGIZED_CASE( FSA_SORT_PL_BY_ACCESS_TIME );
    RETURN_STRINGIZED_CASE( FSA_SORT_PL_BY_SIZE );
    RETURN_STRINGIZED_CASE( FSA_SORT_PL_BY_PATH_NAME );
    RETURN_STRINGIZED_CASE( FSA_SORT_PL_BY_SIZE_AND_TIME );

    default:

        return ( OLESTR("Invalid Value") );

    }
}


DWORD FsaStartTruncator(
    void* pVoid
    )

/*++


--*/
{
    return(((CFsaTruncator*) pVoid)->StartScan());
}




HRESULT
CFsaTruncator::Cancel(
    HSM_JOB_EVENT       event
    )

/*++

Implements:

  IFsaTruncator::Cancel().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::Cancel"), OLESTR("event = <%ls>"), FsaEventAsString( event ));

    //  Lock this object to avoid having the state change between testing its value
    //  and setting it to a new value
    Lock();
    try {

        // If we have started, but haven't finished, then change the state of the job. The thread
        // will exit on it's own.
        if ((HSM_JOB_STATE_IDLE != m_state) &&
            (HSM_JOB_STATE_DONE != m_state) &&
            (HSM_JOB_STATE_FAILED != m_state) &&
            (HSM_JOB_STATE_CANCELLED != m_state)) {

            if (HSM_JOB_EVENT_CANCEL == event) {
                WsbAffirmHr(SetState(HSM_JOB_STATE_CANCELLED));
            } else if (HSM_JOB_EVENT_SUSPEND == event) {
                WsbAffirmHr(SetState(HSM_JOB_STATE_SUSPENDED));
            } else if (HSM_JOB_EVENT_FAIL == event) {
                WsbAffirmHr(SetState(HSM_JOB_STATE_FAILED));
            } else {
                WsbAssert(FALSE, E_UNEXPECTED);
            }
        }

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CFsaTruncator::Cancel"), OLESTR("hr = <%ls> m_state = <%ls>"), WsbHrAsString(hr), FsaStateAsString( m_state ) );
    return(hr);
}


HRESULT
CFsaTruncator::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT                     hr = S_OK;
    
    WsbTraceIn(OLESTR("CFsaTruncator::FinalConstruct"), OLESTR(""));

    try {

        WsbAffirmHr(CWsbPersistStream::FinalConstruct());

        m_state = HSM_JOB_STATE_IDLE;
        m_priority = HSM_JOB_PRIORITY_NORMAL;
        m_threadHandle = 0;
        m_threadId = 0;
        m_threadHr = S_OK;
        m_maxFiles = DEFAULT_MAX_FILES_PER_RUN;
        m_runInterval = DEFAULT_RUN_INTERVAL;
        m_runId = 0;
        m_subRunId = 0;
        m_pSession = 0;
        m_SortOrder = FSA_SORT_PL_BY_ACCESS_TIME;
        m_keepRecallTime = WsbLLtoFT(WSB_FT_TICKS_PER_MINUTE);
        m_event = 0;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::FinalConstruct"), OLESTR(""));

    return(hr);
}


HRESULT
CFsaTruncator::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    HRESULT          hr = S_OK;
    HSM_SYSTEM_STATE SysState;

    WsbTraceIn(OLESTR("CFsaTruncator::FinalRelease"), OLESTR(""));

    SysState.State = HSM_STATE_SHUTDOWN;
    ChangeSysState(&SysState);

    CWsbPersistStream::FinalRelease();

    // Free String members
    // Note: Member objects held in smart-pointers are freed when the 
    // smart-pointer destructor is being called (as part of this object destruction)
    m_currentPath.Free();

    WsbTraceOut(OLESTR("CFsaTruncator::FinalRelease"), OLESTR(""));

    return(hr);

}


HRESULT
CFsaTruncator::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CFsaTruncatorNTFS;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CFsaTruncator::GetKeepRecallTime(
    OUT FILETIME* pTime
    )

/*++

Implements:

  IFsaTruncator::GetKeepRecallTime().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::GetKeepRecallTime"), OLESTR(""));

    try {

        WsbAssert(0 != pTime, E_POINTER);
        *pTime = m_keepRecallTime;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::GetKeepRecallTime"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaTruncator::GetMaxFilesPerRun(
    OUT LONGLONG* pMaxFiles
    )

/*++

Implements:

  IFsaTruncator::GetMaxFilesPerRun().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::GetMaxFilesPerRun"), OLESTR(""));

    try {

        WsbAssert(0 != pMaxFiles, E_POINTER);
        *pMaxFiles = m_maxFiles;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::GetMaxFilesPerRun"), OLESTR("hr = <%ls> maxFiles = <%ls>"), WsbHrAsString(hr), WsbLonglongAsString( *pMaxFiles ) );

    return(hr);
}


HRESULT
CFsaTruncator::GetPremigratedSortOrder(
    OUT FSA_PREMIGRATED_SORT_ORDER* pSortOrder
    )

/*++

Implements:

  IFsaTruncator::GetPremigratedSortOrder().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::GetPremigratedSortOrder"), OLESTR(""));

    try {

        WsbAssert(0 != pSortOrder, E_POINTER);
        *pSortOrder = m_SortOrder;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::GetPremigratedSortOrder"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaTruncator::GetRunInterval(
    OUT ULONG* pMilliseconds
    )

/*++

Implements:

  IFsaTruncator::GetRunInterval().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::GetRunInterval"), OLESTR(""));

    try {

        WsbAssert(0 != pMilliseconds, E_POINTER);
        *pMilliseconds = m_runInterval;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::GetRunInterval"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaTruncator::GetSession(
    OUT IHsmSession** ppSession
    )

/*++

Implements:

  IFsaTruncator::GetSession().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::GetSession"), OLESTR(""));

    try {

        WsbAssert(0 != ppSession, E_POINTER);
        *ppSession = m_pSession;
        if (m_pSession != 0) {
            m_pSession->AddRef();
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::GetSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaTruncator::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pSize, E_POINTER);

        // Determine the size for a rule with no criteria.
        pSize->QuadPart = WsbPersistSizeOf(LONGLONG) + 3 * WsbPersistSizeOf(ULONG) + WsbPersistSizeOf(FILETIME);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}



HRESULT
CFsaTruncator::KickStart(
    void
    )

/*++

Implements:

  IFsaTruncator:KickStart

    Data was just moved for this volume - wake up the truncator thread in case we need space.

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IFsaResource>   pResource;
    ULONG                   freeLevel;
    ULONG                   hsmLevel;


    WsbTraceIn(OLESTR("CFsaTruncator::KickStart"), OLESTR(""));

    try {
        if (m_pSession) {
            WsbAffirmHr(m_pSession->GetResource(&pResource));

            // If the truncator is running and the resource does not have enough free space
            // check to see if the resource is over the threshold and truncation is needed.
            WsbAffirmHr(pResource->GetHsmLevel(&hsmLevel));
            WsbAffirmHr(pResource->GetFreeLevel(&freeLevel));

            if (freeLevel < hsmLevel) {
                WsbTrace(OLESTR("CFsaTruncator::KickStarting truncator.\n"));
                SetEvent(m_event);
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::KickStart"), OLESTR("hr = <%ls>>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaTruncator::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::Load"), OLESTR(""));

    try {
        USHORT us_tmp;
        ULONG  ul_tmp;

        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the save method.
        WsbAffirmHr(WsbLoadFromStream(pStream, &ul_tmp));
        m_priority = static_cast<HSM_JOB_PRIORITY>(ul_tmp);
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_maxFiles));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_runInterval));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_runId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_keepRecallTime));
        WsbAffirmHr(WsbLoadFromStream(pStream, &us_tmp));
        m_SortOrder = static_cast<FSA_PREMIGRATED_SORT_ORDER>(us_tmp);
        
        // Check to see if values for maxFiles and runInterval are specified in the registry.
        // If so, use these values instead of the ones stored.
        {
            DWORD               sizeGot;
            CWsbStringPtr       tmpString;
            
            WsbAffirmHr(tmpString.Alloc(256));
            
            if (SUCCEEDED(WsbGetRegistryValueString(NULL, FSA_REGISTRY_PARMS, FSA_REGISTRY_TRUNCATOR_INTERVAL, tmpString, 256, &sizeGot))) {
                m_runInterval = 1000 * wcstoul(tmpString, NULL, 10);
            } else {
                m_runInterval = DEFAULT_RUN_INTERVAL;
            }

            if (SUCCEEDED(WsbGetRegistryValueString(NULL, FSA_REGISTRY_PARMS, FSA_REGISTRY_TRUNCATOR_FILES, tmpString, 256, &sizeGot))) {
                m_maxFiles = (LONGLONG) wcstoul(tmpString, NULL, 10);
            } else {
                m_maxFiles = DEFAULT_MAX_FILES_PER_RUN;
            }
        }
            
    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CFsaTruncator::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaTruncator::LowerPriority(
    void
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::LowerPriority"), OLESTR(""));
    try {

        WsbAssert(0 != m_threadHandle, E_UNEXPECTED);
        WsbAssert(m_pSession != 0, E_UNEXPECTED);

        switch(m_priority) {
            case HSM_JOB_PRIORITY_IDLE:
                WsbAffirm(FALSE, E_UNEXPECTED);
                break;

            case HSM_JOB_PRIORITY_LOWEST:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_IDLE));
                m_priority = HSM_JOB_PRIORITY_IDLE;
                break;

            case HSM_JOB_PRIORITY_LOW:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_LOWEST));
                m_priority = HSM_JOB_PRIORITY_LOWEST;
                break;

            case HSM_JOB_PRIORITY_NORMAL:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_BELOW_NORMAL));
                m_priority = HSM_JOB_PRIORITY_LOW;
                break;

            case HSM_JOB_PRIORITY_HIGH:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_NORMAL));
                m_priority = HSM_JOB_PRIORITY_NORMAL;
                break;

            case HSM_JOB_PRIORITY_HIGHEST:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_ABOVE_NORMAL));
                m_priority = HSM_JOB_PRIORITY_HIGH;
                break;

            default:
            case HSM_JOB_PRIORITY_CRITICAL:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_HIGHEST));
                m_priority = HSM_JOB_PRIORITY_HIGHEST;
                break;
        }

        WsbAffirmHr(m_pSession->ProcessPriority(HSM_JOB_PHASE_SCAN, m_priority));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::LowerPriority"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );
    return(hr);
}


HRESULT
CFsaTruncator::Pause(
    void
    )

/*++

Implements:

  IFsaTruncator::Pause().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::Pause"), OLESTR("state = %ls"),
            FsaStateAsString(m_state));

    //  Lock this object to avoid having the state change between testing its value
    //  and setting it to a new value
    Lock();
    try {

        // If we are running, then suspend the thread.
        WsbAssert(HSM_JOB_STATE_ACTIVE == m_state, E_UNEXPECTED);

        // Set the state & the active thread will not do any work
        WsbAffirmHr(SetState(HSM_JOB_STATE_PAUSING));

        // We would like to wait until the thread is really inactive, but that's
        // hard to tell because it could be in a sleep interval

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CFsaTruncator::Pause"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return(hr);
}


HRESULT
CFsaTruncator::ProcessSessionEvent(
    IN IHsmSession* pSession,
    IN HSM_JOB_PHASE phase,
    IN HSM_JOB_EVENT event
    )

/*++

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::ProcessSessionEvent"), OLESTR(""));

    try {
        
        WsbAssert(0 != pSession, E_POINTER);

        // If the phase applies to use (SCAN or ALL), then do any work required by the
        // event.
        if ((HSM_JOB_PHASE_ALL == phase) || (HSM_JOB_PHASE_SCAN == phase)) {

            switch(event) {

                case HSM_JOB_EVENT_SUSPEND:
                case HSM_JOB_EVENT_CANCEL:
                case HSM_JOB_EVENT_FAIL:
                    WsbAffirmHr(Cancel(event));
                    break;

                case HSM_JOB_EVENT_PAUSE:
                    WsbAffirmHr(Pause());
                    break;

                case HSM_JOB_EVENT_RESUME:
                    WsbAffirmHr(Resume());
                    break;

                case HSM_JOB_EVENT_RAISE_PRIORITY:
                    WsbAffirmHr(RaisePriority());
                    break;

                case HSM_JOB_EVENT_LOWER_PRIORITY:
                    WsbAffirmHr(LowerPriority());
                    break;

                default:
                case HSM_JOB_EVENT_START:
                    WsbAssert(FALSE, E_UNEXPECTED);
                    break;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::ProcessSessionEvent"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return(S_OK);
}


HRESULT
CFsaTruncator::RaisePriority(
    void
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    try {

        WsbAssert(0 != m_threadHandle, E_UNEXPECTED);
        WsbAssert(m_pSession != 0, E_UNEXPECTED);

        switch(m_priority) {

            case HSM_JOB_PRIORITY_IDLE:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_LOWEST));
                m_priority = HSM_JOB_PRIORITY_LOWEST;
                break;

            case HSM_JOB_PRIORITY_LOWEST:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_BELOW_NORMAL));
                m_priority = HSM_JOB_PRIORITY_LOW;
                break;

            case HSM_JOB_PRIORITY_LOW:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_NORMAL));
                m_priority = HSM_JOB_PRIORITY_NORMAL;
                break;

            case HSM_JOB_PRIORITY_NORMAL:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_ABOVE_NORMAL));
                m_priority = HSM_JOB_PRIORITY_HIGH;
                break;

            case HSM_JOB_PRIORITY_HIGH:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_HIGHEST));
                m_priority = HSM_JOB_PRIORITY_HIGHEST;
                break;

            case HSM_JOB_PRIORITY_HIGHEST:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_TIME_CRITICAL));
                m_priority = HSM_JOB_PRIORITY_CRITICAL;
                break;

            default:
            case HSM_JOB_PRIORITY_CRITICAL:
                WsbAffirm(FALSE, E_UNEXPECTED);
                break;
        }

        WsbAffirmHr(m_pSession->ProcessPriority(HSM_JOB_PHASE_SCAN, m_priority));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CFsaTruncator::Resume(
    void
    )

/*++

Implements:

  IFsaTruncator::Resume().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::Resume"), OLESTR("state = %ls"),
            FsaStateAsString(m_state));

    //  Lock this object to avoid having the state change between testing its value
    //  and setting it to a new value
    Lock();
    try {

        // We should only see a resume from a paused state, so ignore the resume if we are
        // in some other state. NOTE: This used to be an assert, but it scared people since it
        // can occur occassionally.
        if ((HSM_JOB_STATE_PAUSING == m_state) || (HSM_JOB_STATE_PAUSED == m_state)) {
            WsbAffirmHr(SetState(HSM_JOB_STATE_ACTIVE));
        }

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CFsaTruncator::Resume"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return(hr);
}


HRESULT
CFsaTruncator::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the save method.
        WsbAffirmHr(WsbSaveToStream(pStream, static_cast<ULONG>(m_priority)));
        WsbAffirmHr(WsbSaveToStream(pStream, m_maxFiles));
        WsbAffirmHr(WsbSaveToStream(pStream, m_runInterval));
        WsbAffirmHr(WsbSaveToStream(pStream, m_runId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_keepRecallTime));
        WsbAffirmHr(WsbSaveToStream(pStream, static_cast<USHORT>(m_SortOrder)));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaTruncator::SetKeepRecallTime(
    IN FILETIME time
    )

/*++

Implements:

  IFsaTruncator::SetKeepRecallTime().

--*/
{
    WsbTraceIn(OLESTR("CFsaTruncator::SetKeepRecallTime"), OLESTR(""));

    m_keepRecallTime = time;

    WsbTraceOut(OLESTR("CFsaTruncator::SetKeepRecallTime"), OLESTR("hr = <%ls>"), WsbHrAsString(S_OK));

    return(S_OK);
}


HRESULT
CFsaTruncator::SetMaxFilesPerRun(
    IN LONGLONG maxFiles
    )

/*++

Implements:

  IFsaTruncator::SetMaxFilesPerRun().

--*/
{
    WsbTraceIn(OLESTR("CFsaTruncator::SetMaxFilesPerRun"), OLESTR(""));

    m_maxFiles = maxFiles;

    WsbTraceOut(OLESTR("CFsaTruncator::SetMaxFilesPerRun"), OLESTR("hr = <%ls>"), WsbHrAsString(S_OK));

    return(S_OK);
}


HRESULT
CFsaTruncator::SetPremigratedSortOrder(
    IN FSA_PREMIGRATED_SORT_ORDER SortOrder
    )

/*++

Implements:

  IFsaTruncator::SetSortOrder().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::SetPremigratedSortOrder"), OLESTR("SortOrder = <%ls>"), FsaSortOrderAsString( SortOrder ) );

    // This key has not been implmented yet.
    if (FSA_SORT_PL_BY_SIZE_AND_TIME == SortOrder) {
        hr = E_NOTIMPL;
    } else {
        m_SortOrder = SortOrder;
    }

    WsbTraceOut(OLESTR("CFsaTruncator::SetPremigratedSortOrder"), OLESTR("hr = <%ls> m_SortOrder = <%ls>"), WsbHrAsString(S_OK) , FsaSortOrderAsString( m_SortOrder ) );

    return(hr);
}


HRESULT
CFsaTruncator::SetRunInterval(
    IN ULONG milliseconds
    )

/*++

Implements:

  IFsaTruncator::SetRunInterval().

--*/
{
    BOOL   DoKick = FALSE;

    WsbTraceIn(OLESTR("CFsaTruncator::SetRunInterval"), OLESTR("milliseconds = <%ls>"), WsbPtrToUlongAsString( &milliseconds ) );

    if (milliseconds < m_runInterval) {
        DoKick = TRUE;
    }
    m_runInterval = milliseconds;

    //  Wake up the Truncator if the interval has decreased
    if (DoKick) {
        KickStart();
    }

    WsbTraceOut(OLESTR("CFsaTruncator::SetRunInterval"), OLESTR("hr = <%ls> m_runInterval = <%ls>"), WsbHrAsString(S_OK), WsbPtrToUlongAsString( &m_runInterval ) );

    return(S_OK);
}


HRESULT
CFsaTruncator::SetState(
    IN HSM_JOB_STATE state
    )

/*++

--*/
{
    HRESULT         hr = S_OK;
    BOOL            bLog = FALSE;

    WsbTraceIn(OLESTR("CFsaTruncator::SetState"), OLESTR("state = <%ls>"), FsaStateAsString( state ) );
 
    // Change the state and report the change to the session.
    Lock();
    m_state = state;
    Unlock();
    hr = m_pSession->ProcessState(HSM_JOB_PHASE_SCAN, m_state, m_currentPath, bLog);

    WsbTraceOut(OLESTR("CFsaTruncator::SetState"), OLESTR("hr = <%ls> m_state = <%ls>"), WsbHrAsString(hr), FsaStateAsString( m_state ) );

    return(hr);
}


HRESULT 
CFsaTruncator::ChangeSysState( 
    IN OUT HSM_SYSTEM_STATE* pSysState 
    )

/*++

Implements:

  IHsmSystemState::ChangeSysState().

--*/

{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaTruncator::ChangeSysState"), OLESTR("thread is %ls"),
        (m_threadHandle ? OLESTR("active") : OLESTR("inactive")));

    try {
        if (pSysState->State & HSM_STATE_SUSPEND) {
            if (HSM_JOB_STATE_ACTIVE == m_state) {
                Pause();
            }
        } else if (pSysState->State & HSM_STATE_RESUME) {
            if ((HSM_JOB_STATE_PAUSING == m_state) || 
                    (HSM_JOB_STATE_PAUSED == m_state)) {
                Resume();
            }
        } else if (pSysState->State & HSM_STATE_SHUTDOWN) {
            //  Make sure the thread is stopped
            if (m_threadHandle) {
                m_state = HSM_JOB_STATE_DONE;
                if (m_event) {
                    SetEvent(m_event);
                }

                //  Wait for the thread to end
                if (m_threadHandle) {
                    WsbTrace(OLESTR("CFsaTruncator::ChangeSysState, waiting for truncator thread to end\n"));
                    switch (WaitForSingleObject(m_threadHandle, 120000)) {
                    case WAIT_FAILED:
                        WsbTrace(OLESTR("CFsaTruncator::ChangeSysState, WaitforSingleObject returned error %lu\n"),
                            GetLastError());
                        break;
                    case WAIT_TIMEOUT:
                        WsbTrace(OLESTR("CFsaTruncator::ChangeSysState, timeout.\n"));
                        break;
                    default:
                        break;
                    }
                }

                //  If the thread is still active, terminate it
                if (m_threadHandle) {
                    WsbTrace(OLESTR("CFsaTruncator::ChangeSysState: calling TerminateThread\n"));
                    if (!TerminateThread(m_threadHandle, 0)) {
                        WsbTrace(OLESTR("CFsaTruncator::ChangeSysState: TerminateThread returned error %lu\n"),
                            GetLastError());
                    }
                }
            }

            if (m_event) {
                CloseHandle(m_event);
                m_event = 0;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::ChangeSysState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CFsaTruncator::Start(
    IFsaResource* pResource
    )

/*++

Implements:

  IFsaTruncator::Start().

--*/
{
    HRESULT                             hr = S_OK;
    CComPtr<IHsmSession>                pSession;
    CComPtr<IConnectionPointContainer>  pCPC;
    CComPtr<IConnectionPoint>           pCP;
    CComPtr<IHsmSessionSinkEveryEvent>  pSink;
    CWsbStringPtr                       name;

    WsbTraceIn(OLESTR("CFsaTruncator::Start"), OLESTR("m_state = <%ls>"), FsaStateAsString( m_state ) );

    try {
        if (0 == m_threadId)  {
            //
            // If the thread is dead, start one.
            //
            // Make sure that we don't already have a session, and that we haven't started already.
            WsbAssert(m_pSession == 0, E_UNEXPECTED);
            WsbAssert( (HSM_JOB_STATE_IDLE == m_state) || (HSM_JOB_STATE_DONE == m_state) || 
                    (HSM_JOB_STATE_CANCELLED == m_state) || (HSM_JOB_STATE_FAILED == m_state), E_UNEXPECTED);

            // Get the name for the session, increment the runId, and reset the subRunId.
            WsbAffirmHr(name.LoadFromRsc(_Module.m_hInst, IDS_FSA_TRUNCATOR_NAME));
            m_runId++;
            m_subRunId = 0;

            // Begin a Session.
            WsbAffirmHr(pResource->BeginSession(name, HSM_JOB_LOG_NONE, m_runId, m_subRunId, &pSession));
            m_pSession = pSession;

            // Ask the session to advise of every event.
            WsbAffirmHr(pSession->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
            WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryEvent, &pCP));
            WsbAffirmHr(((IUnknown*) (IFsaTruncator*) this)->QueryInterface(IID_IHsmSessionSinkEveryEvent, (void**) &pSink));
            WsbAffirmHr(pCP->Advise(pSink, &m_cookie));

            try {
                GUID            rscId;
                CWsbStringPtr   nameString;
        
                // Give the event a unique name, so that we can trace it
                // in a dump of open handles.
                if (0 == m_event) {
                    WsbAffirmHr(pResource->GetIdentifier(&rscId));
                    nameString = rscId;
                    nameString.Prepend(OLESTR("Truncator Kicker for "));
                    WsbAssertHandle(m_event = CreateEvent(NULL, FALSE, FALSE, nameString));
                }
        
                // Now that we have prepared, create the thread that will do the scanning!
                WsbAffirm((m_threadHandle = CreateThread(0, 0, FsaStartTruncator, (void*) this, 0, &m_threadId)) != 0, HRESULT_FROM_WIN32(GetLastError()));

            } WsbCatchAndDo(hr, SetState(HSM_JOB_STATE_FAILED););
        } else  {
            // The thread is still alive, just keep it going. If it is in a state that would
            // cause it to exit, then make it active again.
            WsbAssert(m_pSession != 0, E_UNEXPECTED);
            if ((HSM_JOB_STATE_ACTIVE != m_state) && (HSM_JOB_STATE_PAUSING != m_state) &&
                (HSM_JOB_STATE_PAUSED != m_state) && (HSM_JOB_STATE_RESUMING != m_state)) {
                WsbAffirmHr(SetState(HSM_JOB_STATE_ACTIVE));
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaTruncator::Start"), OLESTR("hr = <%ls> m_state = <%ls>"), WsbHrAsString(hr), FsaStateAsString( m_state ) );

    return(hr);
}


HRESULT
CFsaTruncator::StartScan(
    void
    )

/*++


--*/
{
    ULONG                               adjustedFreeLevel = 0;
    HRESULT                             hr = S_OK;
    HRESULT                             hr2;
    LONGLONG                            itemOffset;
    LONGLONG                            itemSize = 0;
    LONGLONG                            fileId;
    ULONG                               freeLevel;
    ULONG                               hsmLevel;
    BOOL                                skipFile;
    BOOL                                dummy;
    LONGLONG                            llLastTruncTime = 0;
    LONGLONG                            llRunIntervalTicks;
    FILETIME                            recallTime, currentTime, accessTime, criteriaTime, premRecAccessTime;
    LONGLONG                            totalVolumeSpace;
    CComPtr<IFsaResource>               pResource;
    CComPtr<IFsaResourcePriv>           pResourcePriv;
    CComPtr<IFsaScanItem>               pScanItem;
    CComPtr<IFsaPremigratedRec>         pPremRec;
    CComPtr<IConnectionPointContainer>  pCPC;
    CComPtr<IConnectionPoint>           pCP;
 
    try {

        WsbTrace(OLESTR("CFsaTruncator::StartScan - starting loop\n"));

        // Increment the ref count so this object (or its session) doesn't 
        // get released before this thread ends
        ((IUnknown *)(IFsaTruncator *)this)->AddRef();

        WsbAssert(m_pSession != 0, E_POINTER);

        // The thread is running.
        WsbAffirmHr(SetState(HSM_JOB_STATE_ACTIVE));

        // Get the resource
        WsbAffirmHr(m_pSession->GetResource(&pResource));
        WsbAffirmHr(pResource->QueryInterface(IID_IFsaResourcePriv, (void**) &pResourcePriv));
        WsbAffirmHr(pResource->GetSizes(&totalVolumeSpace, NULL, NULL, NULL));

        // Start with the first path.
        while ((HSM_JOB_STATE_ACTIVE == m_state) || (HSM_JOB_STATE_PAUSING == m_state) || 
               (HSM_JOB_STATE_PAUSED == m_state) || (HSM_JOB_STATE_RESUMING == m_state)) {

            WsbTrace(OLESTR("CFsaTruncator::StartScan, top of outside while loop, state = <%ls>\n"), 
                    FsaStateAsString( m_state ) );

            // If the truncator is running and the resource does not have enough free space
            // check to see if the resource is over the threshold and truncation is needed.
            WsbAffirmHr(pResource->GetHsmLevel(&hsmLevel));
            WsbAffirmHr(pResource->GetFreeLevel(&freeLevel));

            // Because the truncation is asynchronous (FsaPostIt is sent to Engine for
            // verification and then returned to FSA for actual truncation), the 
            // measured freeLevel may not be very accurate if there are truncations
            // pending.  To compensate for this, we keep an adjustedFreeLevel which
            // attempts to take into account the pending truncates.  We synchronize the
            // adjustedFreeLevel to the measured freeLevel the first time through and
            // after we have slept for a while (on the assumption that the pending
            // truncates have had time to be performed).  This still leaves open the possiblility
            // that the measured freeLevel is wrong (because truncates are pending), but
            // should be an improvement over just using the measured freeLevel.
            llRunIntervalTicks = m_runInterval * (WSB_FT_TICKS_PER_SECOND / 1000);
            GetSystemTimeAsFileTime(&currentTime);
            if (0 == adjustedFreeLevel || 
                    ((WsbFTtoLL(currentTime) - llLastTruncTime) > llRunIntervalTicks)) {
                adjustedFreeLevel = freeLevel;
                WsbTrace(OLESTR("CFsaTruncator::StartScan, resetting adjusted free level, RunInterval = %ls, time diff = %ls\n"), 
                        WsbQuickString(WsbLonglongAsString(llRunIntervalTicks)),
                        WsbQuickString(WsbLonglongAsString(WsbFTtoLL(currentTime) - llLastTruncTime)));
            }

            WsbTrace(OLESTR("CFsaTruncator::StartScan, desired level = %u, free level = %u, adjusted free level = %u\n"), 
                    hsmLevel, freeLevel, adjustedFreeLevel);

            if (adjustedFreeLevel < hsmLevel && HSM_JOB_STATE_ACTIVE == m_state) {
                CComPtr<IWsbDbSession>      pDbSession;
                CComPtr<IFsaPremigratedDb>  pPremDb;

                // Open the premigration list, and set the order in which it will be scanned.
                WsbAffirmHr(pResourcePriv->GetPremigrated(IID_IFsaPremigratedDb, 
                        (void**) &pPremDb));
                WsbAffirmHr(pPremDb->Open(&pDbSession));

                try  {
                    WsbAffirmHr(pPremDb->GetEntity(pDbSession, PREMIGRATED_REC_TYPE, IID_IFsaPremigratedRec, (void**) &pPremRec));

                    //  Set the order to get items from the Premigrated List
                    switch (m_SortOrder) {
                    case FSA_SORT_PL_BY_SIZE:
                        WsbAffirmHr(pPremRec->UseKey(PREMIGRATED_SIZE_KEY_TYPE));
                        break;

                    case FSA_SORT_PL_BY_PATH_NAME:
                        //  We use the BagId and offsets instead
                        WsbAffirmHr(pPremRec->UseKey(PREMIGRATED_BAGID_OFFSETS_KEY_TYPE));
                        break;

                    case FSA_SORT_PL_BY_SIZE_AND_TIME:
                        //  We don't know how to handle this one yet
                        WsbThrow(E_UNEXPECTED);
                        break;

                    case FSA_SORT_PL_BY_ACCESS_TIME:
                    default:
                        WsbAffirmHr(pPremRec->UseKey(PREMIGRATED_ACCESS_TIME_KEY_TYPE));
                        break;
                    }

                    // Make a pass through the list of premigrated files until the 
                    // desired level has been reached. Some items that are on the
                    // list may be in a state that causes them to be skipped, but left on the list.
                    WsbAffirmHr(pPremRec->First());

                    while ((adjustedFreeLevel < hsmLevel) && (HSM_JOB_STATE_ACTIVE == m_state)) {
                        CComPtr<IFsaRecoveryRec>       pRecRec;

                        WsbTrace(OLESTR("CFsaTruncator::StartScan (top of inside while loop) desired level = %u, adjusted free level = %u\n"), 
                                hsmLevel, adjustedFreeLevel);
                                                          
                        try {
                            skipFile = FALSE;

                            //
                            // Get the access time as recorded in the premigrated record
                            // Note that the real access time cannot be older than the one 
                            // in the premigrated list but it can be newer
                            //
                            WsbAffirmHr(pPremRec->GetAccessTime(&premRecAccessTime));
                            WsbAffirmHr(pResource->GetManageableItemAccessTime(&dummy, &criteriaTime));

                            if (WsbCompareFileTimes(premRecAccessTime, criteriaTime, TRUE, FALSE)  < 0 )  {
                                if (pPremRec->IsWaitingForClose() == S_FALSE) {
                                    //
                                    // Can skip the current file but NOT break out of the loop since
                                    // files with access time old enough and WaitingForClose flag set
                                    // may still exists in the list
                                    //
                                    skipFile = TRUE;
                                } else {
                                    //
                                    // The access time in the prem. rec is within the window.
                                    // This means there aren't any other records which are outside the
                                    // user-desired last access window. So break out
                                    //
                                    WsbTrace(OLESTR("CFsaTruncator::StartScan: breaking out of auto-truncator, encountered item with access time not within criteria\n"));
                                    hr = WSB_E_NOTFOUND;
                                    break;
                                }
                            }

                            // Get information about the file that could be truncated.
                            WsbAffirmHr(pPremRec->GetFileId(&fileId));
                            WsbAffirmHr(pPremRec->GetOffset(&itemOffset));
                            WsbAffirmHr(pPremRec->GetSize(&itemSize));
                            m_currentPath.Free();
                            WsbAffirmHr(pPremRec->GetPath(&m_currentPath, 0));
                            WsbAffirmHr(pPremRec->GetRecallTime(&recallTime));

                            GetSystemTimeAsFileTime(&currentTime);

                            // Make sure that this file wasn't recently recalled. For now,
                            // this will check for 1 minute.
                            if ((! skipFile) &&
                                ( (pPremRec->IsWaitingForClose() == S_FALSE) || 
                                    ((WsbFTtoLL(currentTime) > WsbFTtoLL(recallTime)) && 
                                    (WsbCompareFileTimes(recallTime, m_keepRecallTime, TRUE, FALSE) >= 0)) )) {

                                hr = pResource->FindFileId(fileId, m_pSession, &pScanItem);
                                if (hr == WSB_E_NOTFOUND) {
                                    //
                                    // The file does not exist anymore - remove the record from the list.
                                    //
                                    WsbAffirmHr(pDbSession->TransactionBegin());
                                    try {
                                        // Make sure the record is still in the DB
                                        WsbAffirmHr(pPremRec->FindEQ());
                                        WsbAffirmHr(pPremRec->Remove());
                                        WsbAffirmHr(pResourcePriv->RemovePremigratedSize(itemSize));
                                    } WsbCatch(hr);
                                    WsbAffirmHr(pDbSession->TransactionEnd());
                                    WsbThrow(hr);
                                } else if (hr != S_OK) {
                                    //
                                    // Any other error is unexpected - log it and continue 
                                    //
                                    WsbLogEvent(FSA_E_ACCESS_ERROR, 0, NULL, m_currentPath, WsbHrAsString(hr), NULL);
                                    WsbThrow(hr);
                                }
                              
                                //
                                // Verify that the file is still in a premigrated state
                                //
                                if (S_OK == pScanItem->IsPremigrated(itemOffset, itemSize)) {
                                    

                                    WsbAffirmHr(pScanItem->GetAccessTime(&accessTime));
                                    //
                                    // accessTime is the last access time for the file
                                    // criteriaTime is the 'not accessed in so many ticks' criteria for truncating
                                    // the file. 
                                    // So if (currentTime - accessTime) >= criteriaTime, then the file is ok to be truncated
                                    //
                                    if (WsbCompareFileTimes(accessTime, criteriaTime, TRUE, FALSE) >=0 )  {
                                        //
                                        // The file was not accessed within the last access window 
                                        //
                                         WsbTrace(OLESTR("CFsaTruncator::StartScan, truncating file <%ls>\n"),
                                                 (WCHAR *)m_currentPath);
          
                                         // Try to truncate the file.
                                         try {
                                             //  Create and save a recovery record in case something goes wrong
                                             WsbAffirmHr(pPremDb->GetEntity(pDbSession, RECOVERY_REC_TYPE, IID_IFsaRecoveryRec, (void**) &pRecRec));
                                             WsbAffirmHr(pRecRec->SetPath(m_currentPath));
      
                                             // If the record already exists rewrite it, otherwise create a new record.
                                             hr2 = pRecRec->FindEQ();
                                             if (WSB_E_NOTFOUND == hr2) {
                                                 hr2 = S_OK;
                                                 WsbAffirmHr(pRecRec->MarkAsNew());
                                             } else if (FAILED(hr2)) {
                                                 WsbThrow(hr2);
                                             }
      
                                             WsbAffirmHr(pRecRec->SetFileId(fileId));
                                             WsbAffirmHr(pRecRec->SetOffsetSize(itemOffset, itemSize));
                                             WsbAffirmHr(pRecRec->SetStatus(FSA_RECOVERY_FLAG_TRUNCATING));
                                             WsbAffirmHr(pRecRec->Write());
                                             //
                                             // Set the waiting for close flag to prevent this file
                                             // from being selected again while the engine is
                                             // processing the truncate.  Set the recall time to
                                             // now plus 1 hour so we are sure not to retry this
                                             // until we have had a chance to truncate it.
                                             //
                                             WsbAffirmHr(pPremRec->SetIsWaitingForClose(TRUE));
                                             WsbAffirmHr(pPremRec->SetRecallTime(WsbLLtoFT(WsbFTtoLL(currentTime) + WSB_FT_TICKS_PER_HOUR)));

                                             hr2 = pPremRec->Write();

                                             // Special code to deal with a problem that has been seen
                                             // but isn't understood
                                             if (WSB_E_IDB_PRIMARY_KEY_CHANGED == hr2) {
                                                 WsbAffirmHr(pPremRec->Remove());
                                                 WsbAffirmHr(pResourcePriv->RemovePremigratedSize(itemSize));
                                                 // Ignore result from DeletePlaceholder since there's nothing we
                                                 // can do anyway.
                                                 pScanItem->DeletePlaceholder(itemOffset, itemSize);
                                                 WsbThrow(FSA_E_SKIPPED);
                                             } else {
                                                 WsbAffirmHr(hr2);
                                             }

                                            //
                                            // Set IsWaitingForClose back to false so that the FindGt done later gets the next record.
                                            // This affects the in memory record only and not the persisted record.
                                            //
                                            WsbAffirmHr(pPremRec->SetIsWaitingForClose(FALSE));

                                            WsbAffirmHr(pScanItem->Truncate(itemOffset, itemSize));
                                            llLastTruncTime = WsbFTtoLL(currentTime);

                                            // Add the file size to the adjustedFreeLevel so we know when to
                                            // stop doing truncations.  Unfortunately, the itemSize is in 
                                            // bytes but adjustedFreeLevl is a fixed-point percentage so we
                                            // have to do a calculation to convert the itemSize
                                            adjustedFreeLevel += (ULONG) (((double)itemSize / 
                                                                 (double)totalVolumeSpace) * 
                                                                 (double)FSA_HSMLEVEL_100);
    
                                        } WsbCatchAndDo(hr,
    
                                         // Do we need to skip this file for the time being?
                                         if (FSA_E_SKIPPED == hr) {
                                             // Do nothing
                                         }  else if ((FSA_E_ITEMCHANGED != hr)  && (FSA_E_NOTMANAGED != hr)) {
                                             // Something unexpected happened, so report the error.
                                             WsbAffirmHr(m_pSession->ProcessHr(HSM_JOB_PHASE_FSA_ACTION, 0, 0, hr));
                                         }
                                        );
                                  }  else { 
                                      //
                                      // File is premigrated, but skipped because the last access was too recent
                                      //
                                      WsbTrace(OLESTR("CFsaTruncator::StartScan, skipping file <%ls> which is premigrated but last access is too recent\n"),
                                                 (WCHAR *)m_currentPath);

                                      hr = FSA_E_SKIPPED;

                                      //
                                      // Update the access time in the db for this file
                                      //
                                      WsbAffirmHr(pPremRec->SetAccessTime(accessTime));
                                      //
                                      // Commit this
                                      //
                                      WsbAffirmHr(pPremRec->Write());
                                      //
                                      // Revert the in-memory accessTime to the old access time to
                                      // let the enumeration continue (so that FindGT will fetch the next record)
                                      //
                                      WsbAffirmHr(pPremRec->SetAccessTime(premRecAccessTime));
                                  }

                                }  else {
                                    //
                                    // If the file is no longer managed by HSM or truncated (may have been modified
                                    // after it was premigrated) - we remove the record from the list.
                                    // Note that if we reached this else close, the condition below should be TRUE
                                    //
                                    if ( (S_FALSE == pScanItem->IsManaged(itemOffset, itemSize)) ||
                                         (S_OK == pScanItem->IsTruncated(itemOffset, itemSize)) ) {
                                        WsbAffirmHr(pDbSession->TransactionBegin());
                                        try {
                                            // Make sure the record is still in the DB
                                            WsbAffirmHr(pPremRec->FindEQ());
                                            WsbAffirmHr(pPremRec->Remove());
                                            WsbAffirmHr(pResourcePriv->RemovePremigratedSize(itemSize));
                                        } WsbCatch(hr);
                                        WsbAffirmHr(pDbSession->TransactionEnd());

                                        // Ignore hr of the removal itself (truncated files may have been removed by another thread)
                                        hr = WSB_E_NOTFOUND;
                                        WsbThrow(hr);
                                    }
                                }

                                // Tell the session we saw the file, and whether we were able to truncate it.
                                WsbAffirmHr(m_pSession->ProcessItem(HSM_JOB_PHASE_FSA_ACTION, HSM_JOB_ACTION_TRUNCATE, pScanItem, hr));
                            
                                // Don't let this errors stop us from continuing to process the list.
                                hr = S_OK;

                            } else {
                                //
                                // File is premigrated, but skipped because the last access was too recent or 
                                // because it was recalled recently
                                //
                                WsbTrace(OLESTR("CFsaTruncator::StartScan, skipping file <%ls> since its last access time is too recent or recently recalled\n"),
                                                 (WCHAR *)m_currentPath);

                                hr = FSA_E_SKIPPED;
                            }

                        } WsbCatchAndDo(hr, 

                            if (WSB_E_NOTFOUND != hr) {
                                m_pSession->ProcessHr(HSM_JOB_PHASE_FSA_ACTION, __FILE__, __LINE__, hr);
                            }

                            // Don't let this errors stop us from continuing to process the list.
                            hr = S_OK;
                        );

                        // If item is skipped - set hr to OK (this is not really an error)
                        if (FSA_E_SKIPPED == hr) {
                            hr = S_OK;
                        }

                        //  Remove recovery record
                        if (pRecRec) {
                            WsbAffirmHr(pRecRec->FindEQ());
                            WsbAffirmHr(pRecRec->Remove());
                            pRecRec = NULL;
                        }

                        // Get the desired level again in case it changed
                        WsbAffirmHr(pResource->GetHsmLevel(&hsmLevel));

                        // Free the scan item.
                        pScanItem = 0;

                        // Whether we removed or skipped the item, go on to the next item.
                        WsbAffirmHr(pPremRec->FindGT());

                        WsbTrace(OLESTR("CFsaTruncator::StartScan, bottom of inside while loop, state = <%ls>\n"), 
                                FsaStateAsString( m_state ) );
                    } // inner while 
                    
                } WsbCatch(hr);

                // Free the premigrated record object and close the data base.
                try {
                    pPremRec = 0;
                    WsbAffirmHr(pPremDb->Close(pDbSession));
                } WsbCatchAndDo(hr2,
                    m_pSession->ProcessHr(HSM_JOB_PHASE_ALL, __FILE__, __LINE__, hr2);
                );
            }

            // Sleep or wait for an event signal.
            // If the event is signaled it means that data was just moved for this 
            // volume and there should be something to do.
            if (SUCCEEDED(hr) || WSB_E_NOTFOUND == hr) {
                ULONG   l_runInterval;
                
                // If we got to the end of the list, then wait a little longer. This
                // is because we probably won't be able to do anything when we retry.
                if (WSB_E_NOTFOUND == hr) {
                    l_runInterval = m_runInterval * 10;
                } else {
                    l_runInterval = m_runInterval;
                }
                WsbTrace(OLESTR("CFsaTruncator::StartScan, sleeping for %lu msec\n"), l_runInterval);
                switch(WaitForSingleObject(m_event, l_runInterval)) {
                    case WAIT_FAILED:
                        WsbTrace(OLESTR("CFsaTruncator::StartScan, Wait for Single Object returned error %lu\n"),
                            GetLastError());
                        break;
                    case WAIT_TIMEOUT:
                        WsbTrace(OLESTR("CFsaTruncator::StartScan, Awakened by timeout.\n"));
                        // Set adjustedFreeLevel to zero so it will get reset to current freeLevel;
                        adjustedFreeLevel = 0;
                        break;
                    default:
                        WsbTrace(OLESTR("CFsaTruncator::StartScan, Awakened by kick start.\n"));
                        break;
                }
            } else {
                WsbThrow(hr);
            }
            WsbTrace(OLESTR("CFsaTruncator::StartScan, bottom of outside while loop, state = <%ls>\n"), 
                    FsaStateAsString( m_state ) );
        }

    } WsbCatch(hr);
    m_threadHr = hr;

    // The thread is exiting, so tell the session.
    if (FAILED(hr)) {
        hr2 = SetState(HSM_JOB_STATE_FAILED);
    } else {
        hr2 = SetState(HSM_JOB_STATE_DONE);
    }
    if (FAILED(hr2)) {
        m_pSession->ProcessHr(HSM_JOB_PHASE_ALL, __FILE__, __LINE__, hr2);
    }

    // Regardless of how this thread is exiting, we need to unadvise from the session.
    // Indicate that we no longer want to be advised of events.
    if ((m_pSession != 0) && (m_cookie != 0)) {
        try {
            WsbAffirmHr(m_pSession->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
            WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryEvent, &pCP));
            pCP->Unadvise(m_cookie);
            m_cookie = 0;
        } WsbCatch(hr);
    }
    
    // Since we have terminated, we should release the session.
    m_pSession = 0;

    // Clean up after this thread.
    CloseHandle(m_threadHandle);
    m_threadId = 0;
    m_threadHandle = 0;

    // Decrement ref count so this object can be release
    ((IUnknown *)(IFsaTruncator *)this)->Release();

    WsbTrace(OLESTR("CFsaTruncator::StartScan - terminating, hr = <%ls>, m_state = <%ls>\n"), 
        WsbHrAsString(hr), FsaStateAsString( m_state ) );

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by fsa.rc
//
#define IDR_FsaScanItem                 1
#define IDR_FsaResource                 2
#define IDR_FsaServer                   3
#define IDR_FsaFilter                   4
#define IDR_FsaFilterClient             5
#define IDR_FsaFilterRecall             6
#define IDR_FsaTruncator                7
#define IDR_FsaPremigratedDb            8
#define IDR_FsaPremigratedRec           9
#define IDR_FsaPostIt                   10
#define IDR_FsaRecoveryRec              11
#define IDR_FsaUnmanageDb               12
#define IDR_FsaUnmanageRec              13
#define IDS_FSA_TRUNCATOR_NAME          50
#define IDS_FSA_RECALL_NAME             51
#define IDS_SERVICE_KEY_NAME_SECURE     100
#define IDR_FsaSecure                   100
#define IDS_SERVICE_DISPLAY_NAME_SECURE 101
#define IDS_SERVICE_DESCRIPTION_SECURE  105
#define IDS_PRODUCT_NAME                106
#define IDS_JOB_NAME_PREFIX             107
#define IDS_JOB_AUTOVALIDATE_COMMENT    109
#define IDS_FSAPOSTIT_DESC              200

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsaunmdb.h ===
/*++

Module Name:

    fsaunmdb.h

Abstract:

    Header file for the Unmanage Db classes (db and rec)

Author:

    Ran Kalach   [rankala]   05-Dec-2000

Revision History:

--*/

#ifndef _FSAUNMDB_
#define _FSAUNMDB_


#include "resource.h"       
#include "wsbdb.h"

// Simple Db - one rec type with one index
#define UNMANAGE_KEY_TYPE                   1

/////////////////////////////////////////////////////////////////////////////
// CFsaUnmanageDb

class CFsaUnmanageDb : 
    public IFsaUnmanageDb,
    public CWsbDb,
    public CComCoClass<CFsaUnmanageDb,&CLSID_CFsaUnmanageDb>
{
public:
    CFsaUnmanageDb() {}
BEGIN_COM_MAP(CFsaUnmanageDb)
    COM_INTERFACE_ENTRY(IFsaUnmanageDb)
    COM_INTERFACE_ENTRY2(IWsbDb, IFsaUnmanageDb)
    COM_INTERFACE_ENTRY(IWsbDbPriv)
    COM_INTERFACE_ENTRY(IPersistStream)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_FsaUnmanageDb)

DECLARE_PROTECT_FINAL_CONSTRUCT();

    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IWsbDb
    WSB_FROM_CWSBDB;

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pclsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize) {
            return(CWsbDb::GetSizeMax(pSize)); }
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IFsaUnmanageDb
public:
    STDMETHOD(Init)(OLECHAR* name, IWsbDbSys* pDbSys, BOOL* pCreated);

private:
};                                                                           




/////////////////////////////////////////////////////////////////////////////
// CFsaUnmanageRec

class CFsaUnmanageRec : 
    public CWsbDbEntity,
    public IFsaUnmanageRec,
    public CComCoClass<CFsaUnmanageRec,&CLSID_CFsaUnmanageRec>
{
public:
    CFsaUnmanageRec() {}
BEGIN_COM_MAP(CFsaUnmanageRec)
    COM_INTERFACE_ENTRY(IFsaUnmanageRec)
    COM_INTERFACE_ENTRY2(IWsbDbEntity, CWsbDbEntity)
    COM_INTERFACE_ENTRY(IWsbDbEntityPriv)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
END_COM_MAP()

//DECLARE_NO_REGISTRY()
DECLARE_REGISTRY_RESOURCEID(IDR_FsaUnmanageRec)

    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbDbEntity
public:
    STDMETHOD(Print)(IStream* pStream);
    STDMETHOD(UpdateKey)(IWsbDbKey *pKey);
    WSB_FROM_CWSBDBENTITY;

// IWsbTestable
    STDMETHOD(Test)(USHORT* /*passed*/, USHORT* /*failed*/) {
        return(E_NOTIMPL); }

// IFsaUnmanageRec
public:
    STDMETHOD(GetMediaId)(GUID* pId);
    STDMETHOD(GetFileOffset)(LONGLONG* pOffset);
    STDMETHOD(GetFileId)(LONGLONG* pFileId);
    STDMETHOD(SetMediaId)(GUID id);
    STDMETHOD(SetFileOffset)(LONGLONG offset);
    STDMETHOD(SetFileId)(LONGLONG FileId);

private:
    GUID            m_MediaId;          // id of media where the file resides  
    LONGLONG        m_FileOffset;       // absolute offset of the file on media
    LONGLONG        m_FileId;           // file id 
};

#endif  // _FSAUNMDB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\dll\makefile.inc ===
$(O)\fsa.res: ..\fsaitem.rgs   \
              ..\fsarsc.rgs    \
              ..\fsasvr.rgs    \
              ..\fsafltr.rgs   \
              ..\fsaftrcl.rgs  \
              ..\fsaftclt.rgs  \
              ..\fsatrunc.rgs  \
              ..\fsapost.rgs   \
              ..\fsapremd.rgs  \
              ..\fsapremr.rgs  \
              ..\fsarcvy.rgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsaunmdb.cpp ===
/*++


Module Name:

    fsaunmdb.cpp

Abstract:

    Defines the functions for the Unmanage Db & record classes.

Author:

    Ran Kalach   [rankala]   05-Dec-2000

Revision History:

--*/


#include "stdafx.h"
#include "wsb.h"


#include "fsaunmdb.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_FSA

static USHORT iCountUnmRec = 0;  // Count of existing objects

HRESULT 
CFsaUnmanageDb::FinalConstruct(
    void
    ) 
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssertHr(CWsbDb::FinalConstruct());
        m_version = 1;
    } WsbCatch(hr);

    return(hr);
}

HRESULT 
CFsaUnmanageDb::FinalRelease(
    void
    ) 
/*++

Implements:

  CComObjectRoot::FinalRelease

--*/
{
    HRESULT     hr = S_OK;

    CWsbDb::FinalRelease();
    return(hr);
}

HRESULT
CFsaUnmanageDb::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CFsaUnmanageDb;
    } WsbCatch(hr);
    
    return(hr);
}

HRESULT
CFsaUnmanageDb::Init(
    IN  OLECHAR* path,
    IN  IWsbDbSys* pDbSys, 
    OUT BOOL*    pCreated
    )

/*++

Implements:

  IFsaUnmanageDb::Init

--*/
{
    BOOL             created = FALSE;
    HRESULT          hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageDb::Init"),OLESTR(""));

    try {
        m_pWsbDbSys = pDbSys;
        WsbAffirmPointer(m_pWsbDbSys);

        // Attempt to find the DB
        // If we find it - delete it, since we always want to start with a new db !!
        hr = Locate(path);

        if (STG_E_FILENOTFOUND == hr) {
            // Expected...
            WsbTrace(OLESTR("CFsaUnmanageDb::Init: db Locate failed with not-found, will create a new one...\n"));
            hr = S_OK;
        } else if (S_OK == hr) {
            // Cleanup wasn't done in previous run
            WsbTrace(OLESTR("CFsaUnmanageDb::Init: db Locate succeeded - will delete so a new one can be created\n"));

            WsbAffirmHr(Delete(path, IDB_DELETE_FLAG_NO_ERROR));
        } else {
            // Still try to delete and continue...
            // (Db could be corrupted for example due to abnormal termination of previous run -
            //  we don't care since all we want is to always try creating a new one).
            WsbTrace(OLESTR("CFsaUnmanageDb::Init: db Locate failed with <%ls> - will try to delete and continue\n"),
                        WsbHrAsString(hr));

            // Ignore Delete errors...
            hr = Delete(path, IDB_DELETE_FLAG_NO_ERROR);
            WsbTrace(OLESTR("CFsaUnmanageDb::Init: db Delete finished with <%ls> - will try to create a new db\n"),
                        WsbHrAsString(hr));
            hr = S_OK;
        }

        // If we got that far, it means that the Unmanage Db doesn't exist and we can re-create
        ULONG memSize;

        m_nRecTypes = 1;

        memSize = m_nRecTypes * sizeof(IDB_REC_INFO);
        m_RecInfo = (IDB_REC_INFO*)WsbAlloc(memSize);
        WsbAffirm(0 != m_RecInfo, E_OUTOFMEMORY);
        ZeroMemory(m_RecInfo, memSize);

        //  Unmanage record type
        m_RecInfo[0].Type = UNMANAGE_REC_TYPE;
        m_RecInfo[0].EntityClassId = CLSID_CFsaUnmanageRec;
        m_RecInfo[0].Flags = 0;
        m_RecInfo[0].MinSize = (WSB_BYTE_SIZE_GUID      +             // media id
                                WSB_BYTE_SIZE_LONGLONG  +             // file offset on media
                                WSB_BYTE_SIZE_LONGLONG);              // file id
        m_RecInfo[0].MaxSize = m_RecInfo[0].MinSize;
        m_RecInfo[0].nKeys = 1;

        memSize = m_RecInfo[0].nKeys * sizeof(IDB_KEY_INFO);
        m_RecInfo[0].Key = (IDB_KEY_INFO*)WsbAlloc(memSize);
        WsbAffirm(0 != m_RecInfo[0].Key, E_OUTOFMEMORY);
        ZeroMemory(m_RecInfo[0].Key, memSize);

        m_RecInfo[0].Key[0].Type = UNMANAGE_KEY_TYPE;
        m_RecInfo[0].Key[0].Size = WSB_BYTE_SIZE_GUID + WSB_BYTE_SIZE_LONGLONG;;
        m_RecInfo[0].Key[0].Flags = IDB_KEY_FLAG_DUP_ALLOWED;   
        // same key possible on tape if a placeholder is restored to a new location on the same volume.
        // same key is common in optical
        // TEMPORARY - check if we shouldn't use IDB_KEY_FLAG_PRIMARY for performance (even if it means not allow dup !!
        //             (==> add one more part to the index, maybe auto-increment-coloumn, so it is always uniqe)

        //  Attempt to create the DB
        WsbAssertHr(Create(path, (IDB_CREATE_FLAG_NO_TRANSACTION | IDB_CREATE_FLAG_FIXED_SCHEMA)));
        created = TRUE;

    } WsbCatch(hr);

    if (pCreated) {
        *pCreated = created;
    }

    WsbTraceOut(OLESTR("CFsaUnmanageDb::Init"), OLESTR("hr = <%ls>, Created = %ls"), 
        WsbHrAsString(hr), WsbBoolAsString(created));

    return(hr);
}

HRESULT
CFsaUnmanageDb::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

Note:
  This database is not expected to be persistent by the using class.
  However, the base class CWsbDb is persistable so we need to implement this 

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageDb::Load"),OLESTR(""));

    hr = CWsbDb::Load(pStream);

    if (S_OK != hr && STG_E_FILENOTFOUND != hr) {
        // Got some error; delete the DB (we'll recreate it later if
        // we need it
        WsbTrace(OLESTR("CFsaUnmanageDb::Load: deleting DB\n"));
        if (S_OK == Delete(NULL, IDB_DELETE_FLAG_NO_ERROR)) {
            hr = STG_E_FILENOTFOUND;
        }
    }

    WsbTraceOut(OLESTR("CFsaUnmanageDb::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CFsaUnmanageDb::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

Note:
  This database is not expected to be persistent by the using class.
  However, the base class CWsbDb is persistable so we need to implement this 

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageDb::Save"),OLESTR(""));

    try {
        WsbAffirmHr(CWsbDb::Save(pStream, clearDirty));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaUnmanageDb::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT 
CFsaUnmanageRec::GetMediaId(
    OUT GUID* pId 
    ) 
/*++

Implements:

  IFsaUnmanageRec::GetMediaId

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageRec::GetMediaId"),OLESTR(""));

    try {
        WsbAssert(0 != pId, E_POINTER);

        *pId = m_MediaId;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaUnmanageRec::GetMediaId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaUnmanageRec::GetFileOffset(
    OUT LONGLONG* pOffset 
    ) 
/*++

Implements:

  IFsaUnmanageRec::GetFileOffset

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageRec::GetFileOffset"),OLESTR(""));

    try {
        WsbAssert(0 != pOffset, E_POINTER);
        *pOffset = m_FileOffset;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaUnmanageRec::GetFileOffset"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT 
CFsaUnmanageRec::GetFileId(
    OUT LONGLONG* pFileId 
    ) 
/*++

Implements:

  IFsaUnmanageRec::GetFileId

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageRec::GetFileId"),OLESTR(""));

    try {
        WsbAssert(0 != pFileId, E_POINTER);
        *pFileId = m_FileId;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaUnmanageRec::GetFileId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CFsaUnmanageRec::SetMediaId(
    IN GUID id
    ) 
/*++

Implements:

  IFsaUnmanageRec::SetMediaId

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageRec::SetMediaId"),OLESTR(""));

    m_MediaId = id;

    WsbTraceOut(OLESTR("CFsaUnmanageRec::SetMediaId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CFsaUnmanageRec::SetFileOffset(
    IN LONGLONG offset 
    ) 
/*++

Implements:

  IFsaUnmanageRec::SetFileOffset

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageRec::SetFileOffset"),OLESTR(""));

    m_FileOffset = offset;

    WsbTraceOut(OLESTR("CFsaUnmanageRec::SetFileOffset"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CFsaUnmanageRec::SetFileId(
    IN LONGLONG FileId 
    ) 
/*++

Implements:

  IFsaUnmanageRec::SetFileId

--*/
{
    
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageRec::SetFileId"),OLESTR(""));

    m_FileId = FileId;

    WsbTraceOut(OLESTR("CFsaUnmanageRec::SetFileId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT 
CFsaUnmanageRec::FinalConstruct(
    void
    ) 
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssertHr(CWsbDbEntity::FinalConstruct());

        m_MediaId = GUID_NULL;
        m_FileOffset = 0;
        m_FileId = 0;

    } WsbCatch(hr);

    iCountUnmRec++;

    return(hr);
}


HRESULT 
CFsaUnmanageRec::FinalRelease(
    void
    ) 
/*++

Implements:

  CComObjectRoot::FinalRelease

--*/
{
    HRESULT     hr = S_OK;

    CWsbDbEntity::FinalRelease();

    iCountUnmRec--;

    return(hr);
}


HRESULT CFsaUnmanageRec::GetClassID
(
    OUT LPCLSID pclsid
    ) 
/*++

Implements:

  IPerist::GetClassID

--*/

{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageRec::GetClassID"), OLESTR(""));


    try {
        WsbAssert(0 != pclsid, E_POINTER);
        *pclsid = CLSID_CFsaUnmanageRec;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaUnmanageRec::GetClassID"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT CFsaUnmanageRec::GetSizeMax
(
    OUT ULARGE_INTEGER* pcbSize
    ) 
/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageRec::GetSizeMax"), OLESTR(""));

    try {
        
        WsbAssert(0 != pcbSize, E_POINTER);

        pcbSize->QuadPart = WsbPersistSizeOf(GUID)      + 
                            WsbPersistSizeOf(LONGLONG)  + 
                            WsbPersistSizeOf(LONGLONG);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaUnmanageRec::GetSizeMax"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT CFsaUnmanageRec::Load
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageRec::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAssertHr(WsbLoadFromStream(pStream, &m_MediaId));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_FileOffset));
        WsbAssertHr(WsbLoadFromStream(pStream, &m_FileId));

    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CFsaUnmanageRec::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT CFsaUnmanageRec::Print
(
    IN IStream* pStream
    ) 
/*++

Implements:

  IWsbDbEntity::Print

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageRec::Print"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" MediaId = %ls"), 
                WsbGuidAsString(m_MediaId)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", FileOffset = %ls"), 
                WsbLonglongAsString(m_FileOffset)));
        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(", FileId = %ls"), 
                WsbLonglongAsString(m_FileId)));

        WsbAffirmHr(CWsbDbEntity::Print(pStream));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaUnmanageRec::Print"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT CFsaUnmanageRec::Save
(
    IN IStream* pStream, 
    IN BOOL clearDirty
    ) 
/*++

Implements:

  IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFsaUnmanageRec::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        WsbAssertHr(WsbSaveToStream(pStream, m_MediaId));
        WsbAssertHr(WsbSaveToStream(pStream, m_FileOffset));
        WsbAssertHr(WsbSaveToStream(pStream, m_FileId));

        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFsaUnmanageRec::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT 
CFsaUnmanageRec::UpdateKey(
    IWsbDbKey *pKey
    ) 
/*++

Implements:

  IWsbDbEntity::UpdateKey

--*/
{ 
    HRESULT     hr = S_OK; 

    try {
        WsbAffirmHr(pKey->SetToGuid(m_MediaId));
        WsbAffirmHr(pKey->AppendLonglong(m_FileOffset));
    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#ifndef _STDAFX_H
#define _STDAFX_H

//
// These NT header files must be included before any Win32 stuff or you
// get lots of compiler errors
//
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#define WSB_TRACE_IS WSB_TRACE_BIT_FSA


#include <wsb.h>

#include <fsa.h>
#include <mover.h>
#include <mvrint.h>

#include "resource.h"
#include "esent.h"

// Fsa is running under RsServ serivce, these settings may change or become dynamic for a C/S HSM
#define FSA_REGISTRY_NAME       OLESTR("Remote_Storage_Server")
#define FSA_REGISTRY_PARMS      OLESTR("SYSTEM\\CurrentControlSet\\Services\\Remote_Storage_Server\\Parameters\\Fsa")

#ifndef MAX
#define MAX(a,b) ((a) > (b) ? (a) : (b))
#endif

#ifndef MIN
#define MIN(a,b) ((a) > (b) ? (b) : (a))
#endif

#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\fsatrunc.h ===
#ifndef _FSATRUNC_
#define _FSATRUNC_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsatrunc.h

Abstract:

    This class handles the automatic truncation of files that have already been premigrated.

Author:

    Chuck Bardeen   [cbardeen]   20-Feb-1997

Revision History:

--*/

#include "resource.h"       // main symbols

#include "fsa.h"


#define FSA_REGISTRY_TRUNCATOR_INTERVAL     OLESTR("TruncatorInterval")
#define FSA_REGISTRY_TRUNCATOR_FILES        OLESTR("TruncatorFiles")

extern DWORD FsaStartTruncator(void* pVoid);


/*++

Class Name:
    
    CFsaTruncator

Class Description:

    This class handles the automatic truncation of files that have already been premigrated.

--*/

class CFsaTruncator : 
    public CWsbPersistStream,
    public IHsmSessionSinkEveryEvent,
    public IFsaTruncator,
    public CComCoClass<CFsaTruncator, &CLSID_CFsaTruncatorNTFS>
{
public:
    CFsaTruncator() {}
BEGIN_COM_MAP(CFsaTruncator)
    COM_INTERFACE_ENTRY(IFsaTruncator)
    COM_INTERFACE_ENTRY(IHsmSessionSinkEveryEvent)
    COM_INTERFACE_ENTRY(IPersist)
    COM_INTERFACE_ENTRY(IPersistStream)
END_COM_MAP()

//DECLARE_NO_REGISTRY()
DECLARE_REGISTRY_RESOURCEID(IDR_FsaTruncator)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// CFsaTruncator
    STDMETHOD(Cancel)(HSM_JOB_EVENT event);
    STDMETHOD(LowerPriority)(void);
    STDMETHOD(Pause)(void);
    STDMETHOD(RaisePriority)(void);
    STDMETHOD(Resume)(void);
    STDMETHOD(SetState)(HSM_JOB_STATE state);
    STDMETHOD(StartScan)(void);

// IHsmSessionSinkEveryEvent
    STDMETHOD(ProcessSessionEvent)(IHsmSession* pSession, HSM_JOB_PHASE phase, HSM_JOB_EVENT event);

// IHsmSystemState
    STDMETHOD( ChangeSysState )( HSM_SYSTEM_STATE* pSysState );

// IFsaTruncator
public:
    STDMETHOD(GetKeepRecallTime)(FILETIME* pTime);
    STDMETHOD(GetMaxFilesPerRun)(LONGLONG* pMaxFiles);
    STDMETHOD(GetPremigratedSortOrder)(FSA_PREMIGRATED_SORT_ORDER* pSortOrder);
    STDMETHOD(GetRunInterval)(ULONG* pMilliseconds);
    STDMETHOD(GetSession)(IHsmSession** ppSession);
    STDMETHOD(SetKeepRecallTime)(FILETIME time);
    STDMETHOD(SetMaxFilesPerRun)(LONGLONG maxFiles);
    STDMETHOD(SetPremigratedSortOrder)(FSA_PREMIGRATED_SORT_ORDER SortOrder);
    STDMETHOD(SetRunInterval)(ULONG milliseconds);
    STDMETHOD(Start)(IFsaResource* pResource);
    STDMETHOD(KickStart)(void);

protected:
    HSM_JOB_STATE               m_state;
    HSM_JOB_PRIORITY            m_priority;
    HANDLE                      m_threadHandle;
    DWORD                       m_threadId;
    HRESULT                     m_threadHr;
    CComPtr<IHsmSession>        m_pSession;
    LONGLONG                    m_maxFiles;
    ULONG                       m_runInterval;
    ULONG                       m_runId;
    FSA_PREMIGRATED_SORT_ORDER  m_SortOrder;
    ULONG                       m_subRunId;
    CWsbStringPtr               m_currentPath;
    FILETIME                    m_keepRecallTime;
    DWORD                       m_cookie;
    HANDLE                      m_event;
};

#endif  // _FSATRUNC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\fsa\service\makefile.inc ===
$(O)\fsa.res: ..\fsa.rgs       \
              ..\fsaitem.rgs   \
              ..\fsarsc.rgs    \
              ..\fsasvr.rgs    \
              ..\fsafltr.rgs   \
              ..\fsaftrcl.rgs  \
              ..\fsaftclt.rgs  \
              ..\fsatrunc.rgs  \
              ..\fsapost.rgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\about.cpp ===
/*++

(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    About.cpp

Abstract:

    This component implements the ISnapinAbout
    interface for the Remote Storage Snapin.

Author:

    Art Bragg [abragg]   04-Aug-1997

Revision History:

--*/

#include "stdafx.h"

#include <NtVerP.h>
#include "RsBuild.h"

#include "About.h"

/////////////////////////////////////////////////////////////////////////////
//

///////////////////////////////////////////////////////////////////////
//                  ISnapinAbout
///////////////////////////////////////////////////////////////////////

HRESULT CAbout::AboutHelper(UINT nID, LPOLESTR* lpPtr)
{
    WsbTraceIn( L"CAbout::AboutHelper", L"lpPtr = <0x%p>", lpPtr );

    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( lpPtr );
        
        CWsbStringPtr s;
        s.LoadFromRsc( _Module.m_hInst, nID );

        *lpPtr = 0;
        WsbAffirmHr( s.CopyTo( lpPtr ) );
        
    } WsbCatch( hr );

    WsbTraceOut( L"CAbout::AboutHelper", L"hr = <%ls>, *lpPtr = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( lpPtr ) );
    return( hr );
}


STDMETHODIMP CAbout::GetSnapinDescription(LPOLESTR* lpDescription)
{
    WsbTraceIn( L"CAbout::GetSnapinDescription", L"lpDescription = <0x%p>", lpDescription );

    HRESULT hr = AboutHelper(IDS_DESCRIPTION, lpDescription);

    WsbTraceOut( L"CAbout::GetSnapinDescription", L"hr = <%ls>, *lpDescription = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( lpDescription ) );
    return( hr );
}


STDMETHODIMP CAbout::GetProvider(LPOLESTR* lpName)
{
    WsbTraceIn( L"CAbout::GetProvider", L"lpName = <0x%p>", lpName );

    HRESULT hr = AboutHelper(IDS_COMPANY, lpName);

    WsbTraceOut( L"CAbout::GetProvider", L"hr = <%ls>, *lpName = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( lpName ) );
    return( hr );
}


STDMETHODIMP CAbout::GetSnapinVersion(LPOLESTR* lpVersion)
{
    WsbTraceIn( L"CAbout::GetSnapinVersion", L"lpVersion = <0x%p>", lpVersion );

    HRESULT hr = S_OK;

    try {

        *lpVersion = 0;

        CWsbStringPtr s;
        s.Alloc( 100 );
        swprintf( s, L"%hs.%d [%ls]", VER_PRODUCTVERSION_STRING, VER_PRODUCTBUILD, RS_BUILD_VERSION_STRING );

        WsbAffirmHr( s.CopyTo( lpVersion ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CAbout::GetSnapinVersion", L"hr = <%ls>, *lpVersion = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( lpVersion ) );
    return( hr );
}


STDMETHODIMP CAbout::GetSnapinImage(HICON* hAppIcon)
{
    WsbTraceIn( L"CAbout::GetSnapinImage", L"hAppIcon = <0x%p>", hAppIcon );

    AFX_MANAGE_STATE( AfxGetStaticModuleState());
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( hAppIcon )

        *hAppIcon = LoadIcon( AfxGetInstanceHandle(), MAKEINTRESOURCE( IDI_BLUESAKKARA ) );

        WsbAffirmPointer( *hAppIcon );

    } WsbCatch( hr );

    WsbTraceOut( L"CAbout::GetSnapinImage", L"hr = <%ls>, *lpVersion = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)hAppIcon ) );
    return( hr );
}


STDMETHODIMP
CAbout::GetStaticFolderImage(
    HBITMAP* hSmallImage, 
    HBITMAP* hSmallImageOpen,
    HBITMAP* hLargeImage, 
    COLORREF* cLargeMask
    )
{
    WsbTraceIn( L"CAbout::GetStaticFolderImage", L"" );

    AFX_MANAGE_STATE( AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    
    try {

        *hSmallImage =     LoadBitmap( AfxGetInstanceHandle(), MAKEINTRESOURCE( IDB_SMALL_SAKKARA ) );
        WsbAffirmStatus( 0 != *hSmallImage );

        *hSmallImageOpen = LoadBitmap( AfxGetInstanceHandle(), MAKEINTRESOURCE( IDB_SMALL_SAKKARA ) );
        WsbAffirmStatus( 0 != *hSmallImageOpen );

        *hLargeImage =     LoadBitmap( AfxGetInstanceHandle(), MAKEINTRESOURCE( IDB_LARGE_SAKKARA ) );
        WsbAffirmStatus( 0 != *hLargeImage );

        *cLargeMask =      RGB( 0xFF, 0x00, 0xFF ); // Magenta

    } WsbCatch( hr );

    WsbTraceOut( L"CAbout::GetStaticFolderImage", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\basehsm.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    BaseHSM.cpp

Abstract:

    Implementation of ISakNode interface.

Author:

    Rohde Wakefield [rohde]   04-Mar-1997

Revision History:

--*/

#include "stdafx.h"
#include "CSakData.h"
#include "CSakSnap.h"

/////////////////////////////////////////////////////////////////////////////
//
// CoComObjectRoot
//
/////////////////////////////////////////////////////////////////////////////
//---------------------------------------------------------------------------
//
//         FinalConstruct
//
//  Initialize this level of the object hierarchy
//

HRESULT CSakNode::FinalConstruct( )
{
    WsbTraceIn( L"CSakNode::FinalConstruct", L"" );

    // Connection point variables
    m_Advise                        = 0;
    m_bEnumState                    = FALSE;
    m_scopeID                       = UNINITIALIZED;
    m_bChildrenAreValid             = FALSE;
    m_bHasDynamicChildren           = FALSE;
    m_cChildProps                   = 0;
    m_cChildPropsShow               = 0;
    m_bSupportsPropertiesNoEngine   = FALSE;
    m_bSupportsPropertiesSingle     = FALSE;
    m_bSupportsPropertiesMulti      = FALSE;
    m_bSupportsRefreshNoEngine      = FALSE;
    m_bSupportsRefreshSingle        = FALSE;
    m_bSupportsRefreshMulti         = FALSE;
    m_bSupportsDeleteSingle         = FALSE;
    m_bSupportsDeleteMulti          = FALSE;
    m_PrivateData                   = 0;

    // Initialize toolbar stuff.  If not overrided,
    // node does not have a toolbar

    m_ToolbarBitmap             = UNINITIALIZED;
    m_cToolbarButtons           = 0;
    INT i;
    for( i = 0; i < MAX_TOOLBAR_BUTTONS; i++ ) {

        m_ToolbarButtons[i].nBitmap = UNINITIALIZED;
        m_ToolbarButtons[i].idCommand = UNINITIALIZED;
        m_ToolbarButtons[i].fsState = TBSTATE_ENABLED;
        m_ToolbarButtons[i].fsType = TBSTYLE_BUTTON;
        m_ToolbarButtons[i].idButtonText = UNINITIALIZED;
        m_ToolbarButtons[i].idTooltipText = UNINITIALIZED;

    }

    // Do not initialize m_nOpenIcon and m_nCloseIcon. The derived classes 
    // will do that.

    HRESULT hr = CComObjectRoot::FinalConstruct( );

    WsbTraceOut( L"CSakNode::FinalConstruct", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CSakNode::OnToolbarButtonClick( IDataObject * /* pDataObject */, long /* cmdId */ )
{
    return S_OK;
}

//---------------------------------------------------------------------------
//
//         FinalRelease
//
//  Clean up this level of the object hierarchy
//

void CSakNode::FinalRelease( )
{
    WsbTraceIn( L"CSakNode::FinalRelease", L"" );

    //
    // Free the children of this node.
    //
    DeleteAllChildren( );

    //
    // Free the child properties list and their widths.
    //
    FreeChildProps();

    CComObjectRoot::FinalRelease( );

    WsbTraceOut( L"CSakNode::FinalRelease", L"" );
}

void CSakNode::SetConnection( IUnknown *pUnkConnection )
{
    WsbTraceIn( L"CSakNode::SetConnection", L"" );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer ( pUnkConnection );
        m_pUnkConnection = pUnkConnection;

        //
        // Set up the connection point
        //
        WsbAffirmHr( AtlAdvise( pUnkConnection, (IUnknown *) (ISakNode*) this, IID_IHsmEvent, &m_Advise ) );

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakNode::SetConnection", L"" );
}

// Connection point "callback"
STDMETHODIMP CSakNode::OnStateChange( )
{
    WsbTraceIn( L"CSakNode::OnStateChange", L"" );
    HRESULT hr = S_OK;

    try {

        WsbAffirmHr( m_pSakSnapAsk->UpdateAllViews( this ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::OnStateChange", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( S_OK );
}
/////////////////////////////////////////////////////////////////////////////
//
// ISakNode
//
/////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------
//
//         get/put_DisplayName
//
//  Give back the 'DisplayName' property.
//

STDMETHODIMP CSakNode::get_DisplayName( BSTR *pName )
{
    WsbTraceIn( L"CSakNode::get_DisplayName", L"pName = <0x%p>", pName );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pName );
        *pName = 0;

        BSTR name = 0;
        if( m_szName ) {

            name = SysAllocString( m_szName );
            WsbAffirmAlloc( name );

        }
        *pName = name;

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::get_DisplayName", L"hr = <%ls>, *pName = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( pName ) );
    return( hr );
}

STDMETHODIMP CSakNode::put_DisplayName( OLECHAR *pszName )
{
    WsbTraceIn( L"CSakNode::put_DisplayName", L"pszName = <%ls>", pszName );

    HRESULT hr = S_OK;
    m_szName = pszName;

    WsbTraceOut( L"CSakNode::put_DisplayName", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakNode::get_DisplayName_SortKey( BSTR *pName )
{
    WsbTraceIn( L"CSakNode::get_DisplayName_SortKey", L"pName = <0x%p>", pName );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pName );
        *pName = 0;

        BSTR name = 0;
        if( m_szName_SortKey ) {

            name = SysAllocString( m_szName_SortKey );
            WsbAffirmAlloc( name );

        } else if( m_szName ) {

            name = SysAllocString( m_szName );
            WsbAffirmAlloc( name );

        }

        *pName = name;

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::get_DisplayName_SortKey", L"hr = <%ls>, *pName = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( pName ) );
    return( hr );
}


STDMETHODIMP CSakNode::put_DisplayName_SortKey( OLECHAR *pszName )
{
    WsbTraceIn( L"CSakNode::put_DisplayName_SortKey", L"pszName = <%ls>", pszName );

    HRESULT hr = S_OK;
    m_szName_SortKey = pszName;

    WsbTraceOut( L"CSakNode::put_DisplayName_SortKey", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         get/put_Type
//
//  Give back the 'Type' property.
//

STDMETHODIMP CSakNode::get_Type( BSTR *pType )
{
    WsbTraceIn( L"CSakNode::get_Type", L"pType = <0x%p>", pType );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pType );
        *pType = 0;

        BSTR type = 0;
        if( m_szType ) {

            type = SysAllocString( m_szType );
            WsbAffirmAlloc( type );

        }
        *pType = type;

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::get_Type", L"hr = <%ls>, *pType = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( pType ) );
    return( hr );
}

STDMETHODIMP CSakNode::put_Type( OLECHAR *pszType )
{
    WsbTraceIn( L"CSakNode::put_Type", L"pszType = <%ls>", pszType );

    HRESULT hr = S_OK;
    m_szType = pszType;

    WsbTraceOut( L"CSakNode::put_Type", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakNode::get_Type_SortKey( BSTR *pType )
{
    WsbTraceIn( L"CSakNode::get_Type_SortKey", L"pType = <0x%p>", pType );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pType );
        *pType = 0;

        BSTR type = 0;
        if( m_szType ) {

            type = SysAllocString( m_szType );
            WsbAffirmAlloc( type );

        }
        *pType = type;

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::get_Type_SortKey", L"hr = <%ls>, *pType = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( pType ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         get/put_Description
//
//  Give back the 'Description' property.
//

STDMETHODIMP CSakNode::get_Description( BSTR *pDesc )
{
    WsbTraceIn( L"CSakNode::get_Description", L"pDesc = <0x%p>", pDesc );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pDesc );
        *pDesc = 0;

        BSTR desc = 0;
        if( m_szDesc ) {

            desc = SysAllocString( m_szDesc );
            WsbAffirmAlloc( desc );

        }
        *pDesc = desc;


    } WsbCatch( hr );


    WsbTraceOut( L"CSakNode::get_Description", L"hr = <%ls>, *pDesc = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( pDesc ) );
    return( hr );
}

STDMETHODIMP CSakNode::put_Description( OLECHAR *pszDesc )
{
    WsbTraceIn( L"CSakNode::put_Description", L"pszDesc = <%ls>", pszDesc );

    HRESULT hr = S_OK;
    m_szDesc = pszDesc;

    WsbTraceOut( L"CSakNode::put_Description", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakNode::get_Description_SortKey( BSTR *pDesc )
{
    WsbTraceIn( L"CSakNode::get_Description_SortKey", L"pDesc = <0x%p>", pDesc );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pDesc );
        *pDesc = 0;

        BSTR desc = 0;
        if( m_szDesc ) {

            desc = SysAllocString( m_szDesc );
            WsbAffirmAlloc( desc );

        }
        *pDesc = desc;


    } WsbCatch( hr );


    WsbTraceOut( L"CSakNode::get_Description_SortKey", L"hr = <%ls>, *pDesc = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( pDesc ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         ChildrenAreValid
//
//  Report if node's current list of children are valid. Things that can make the
//  children invalid are: 
//  1) They have not yet been discovered.
//  2) Something has occurred in the "external" world to cause them to become out-of-date.
//

STDMETHODIMP CSakNode::ChildrenAreValid( void )
{
    WsbTraceIn( L"CSakNode::ChildrenAreValid", L"" );

    HRESULT hr = m_bChildrenAreValid ? S_OK : S_FALSE;

    WsbTraceOut( L"CSakNode::ChildrenAreValid", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         InvalidateChildren
//

STDMETHODIMP CSakNode::InvalidateChildren( void )
{
    WsbTraceIn( L"CSakNode::InvalidateChildren", L"" );
    HRESULT hr = S_OK;

    m_bChildrenAreValid = FALSE;

    WsbTraceOut( L"CSakNode::InvalidateChildren", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


//---------------------------------------------------------------------------
//
//         GetEnumState / SetEnumState
//
//  Report if node's children have already been enumerated once. This is a convenience
//  function to help users of nodes from needlessly enumerating children if it has already
//  been done.
//
//  !! future work - if the hsm engine changes the children of a node, making re-enumeration
//     necessary, this switch could be turned back to FALSE so that the next time a node
//     is queried as to its enumeration state, it would show up as needing enumeration.
//

STDMETHODIMP CSakNode::GetEnumState( BOOL* pState )
{
    WsbTraceIn( L"CSakNode::GetEnumState", L"pState = <0x%p>", pState );

    HRESULT hr = S_OK;
    *pState = m_bEnumState;

    WsbTraceOut( L"CSakNode::GetEnumState", L"hr = <%ls>, *pState = <%ls>", WsbHrAsString( hr ), WsbPtrToBoolAsString( pState ) );
    return( hr );
}

STDMETHODIMP CSakNode::SetEnumState( BOOL state )
{
    WsbTraceIn( L"CSakNode::SetEnumState", L"state = <%ls>", WsbBoolAsString( state ) );

    HRESULT hr = S_OK;
    m_bEnumState = state;

    WsbTraceOut( L"CSakNode::SetEnumState", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         GetHsmObj
//
//  Return a pointer to the underlying Hsm Object that the CBaseHsm 
//  object encapsulates.
//
STDMETHODIMP CSakNode::GetHsmObj( IUnknown** ppHsmObj )
{
    WsbTraceIn( L"CSakNode::GetHsmObj", L"ppHsmObj = <0x%p>", ppHsmObj );

    HRESULT hr = S_OK;
    m_pHsmObj.CopyTo( ppHsmObj );

    WsbTraceOut( L"CSakNode::GetHsmObj", L"hr = <%ls>, *ppHsmObj = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppHsmObj ) );
    return( hr );
}


//---------------------------------------------------------------------------
//
//         GetParent
//
//  Return the cookie of the parent node
//
STDMETHODIMP CSakNode::GetParent( ISakNode** ppParent )
{
    WsbTraceIn( L"CSakNode::GetParent", L"ppParent = <0x%p>", ppParent );

    HRESULT hr = S_OK;
    
    try {

        WsbAffirmPointer( ppParent );
        m_pParent.CopyTo( ppParent );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::GetParent", L"hr = <%ls>, *ppParent = <0x%p>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppParent ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         GetScopeID / SetScopeID
//
//  Put and set the scopeview ID for this item into the node, itself.
//

STDMETHODIMP CSakNode::GetScopeID( HSCOPEITEM* pid )
{
    WsbTraceIn( L"CSakNode::GetScopeID", L"pid = <0x%p>", pid );

    HRESULT hr = S_OK;
    *pid = m_scopeID;

    if( m_scopeID == UNINITIALIZED ) {

        hr = E_PENDING;

    }

    WsbTraceOut( L"CSakNode::GetScopeID", L"hr = <%ls>, *pid = <0x%p>", WsbHrAsString( hr ), *pid );
    return( hr );
}

STDMETHODIMP CSakNode::SetScopeID( HSCOPEITEM id )
{
    WsbTraceIn( L"CSakNode::SetScopeID", L"id = <0x%p>", id );

    HRESULT hr = S_OK;
    m_scopeID = id;

    WsbTraceOut( L"CSakNode::SetScopeID", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         EnumChildren
//
//  Create an enumerator and return the children.
//

STDMETHODIMP CSakNode::EnumChildren( IEnumUnknown ** ppEnum )
{
    WsbTraceIn( L"CSakNode::EnumChildren", L"ppEnum = <0x%p>", ppEnum );

    HRESULT hr = S_OK;
    CEnumUnknown * pEnum = 0;

    try {

        WsbAffirmPointer( ppEnum );
        *ppEnum = 0;

        //
        // New an ATL enumerator
        //
        pEnum = new CEnumUnknown;
        WsbAffirmAlloc( pEnum );
        
        //
        // Initialize it to copy the current child interface pointers
        //
        WsbAffirmHr( pEnum->FinalConstruct() );
        if( m_Children.begin( ) ) {

            WsbAffirmHr( pEnum->Init( (IUnknown**)m_Children.begin( ), (IUnknown**)m_Children.end( ), NULL, AtlFlagCopy ) );

        } else {

            static IUnknown* pUnkDummy;
            WsbAffirmHr( pEnum->Init( &pUnkDummy, &pUnkDummy, NULL, AtlFlagCopy ) );
        }
        WsbAffirmHr( pEnum->QueryInterface( IID_IEnumUnknown, (void**)ppEnum ) );

    } WsbCatchAndDo( hr,

        if( pEnum ) delete pEnum;

    );

    WsbTraceOut( L"CSakNode::EnumChildren", L"hr = <%ls>, *ppEnum = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppEnum ) );
    return( hr );
}


//---------------------------------------------------------------------------
//
//         EnumChildDisplayPropWidths
//
//  Enumerate back the widths for the properties of my children that should be 
//  shown in the result pane view.
//

STDMETHODIMP CSakNode::EnumChildDisplayPropWidths( IEnumString** ppEnum )
{
    WsbTraceIn( L"CSakNode::EnumChildDisplayPropWidths", L"ppEnum = <0x%p>", ppEnum );

    HRESULT hr = S_OK;
    
    CEnumString * pEnum = 0;
    
    try {

        WsbAffirmPointer( ppEnum );
        WsbAffirm( m_cChildPropsShow > 0, S_FALSE );

        *ppEnum = 0;

        //
        // New an ATL enumerator
        //
        pEnum = new CEnumString;
        WsbAffirmAlloc( pEnum );

        WsbAffirmHr( pEnum->FinalConstruct( ) );
        WsbAffirmHr( pEnum->Init( &m_rgszChildPropWidths[0], &m_rgszChildPropWidths[m_cChildPropsShow], NULL, AtlFlagCopy ) );
        WsbAffirmHr( pEnum->QueryInterface( IID_IEnumString, (void**)ppEnum ) );
        
    } WsbCatchAndDo( hr,
        
        if( pEnum ) delete pEnum;
        
    );

    WsbTraceOut( L"CSakNode::EnumChildDisplayPropWidths", L"hr = <%ls>, *ppEnum = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppEnum ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         EnumChildDisplayProps
//
//  Enumerate back the properties of my children that should be shown in the
//  result pane view.
//

STDMETHODIMP CSakNode::EnumChildDisplayProps( IEnumString ** ppEnum )
{
    WsbTraceIn( L"CSakNode::EnumChildDisplayProps", L"ppEnum = <0x%p>", ppEnum );

    HRESULT hr = S_OK;
    
    CEnumString * pEnum = 0;
    
    try {

        WsbAffirmPointer( ppEnum );
        WsbAffirm( m_cChildPropsShow > 0, S_FALSE );

        *ppEnum = 0;

        //
        // New an ATL enumerator
        //
        pEnum = new CEnumString;
        WsbAffirmAlloc( pEnum );

        WsbAffirmHr( pEnum->FinalConstruct( ) );
        WsbAffirmHr( pEnum->Init( &m_rgszChildPropIds[0], &m_rgszChildPropIds[m_cChildPropsShow], NULL, AtlFlagCopy ) );
        WsbAffirmHr( pEnum->QueryInterface( IID_IEnumString, (void**)ppEnum ) );
        
    } WsbCatchAndDo( hr,
        
        if( pEnum ) delete pEnum;
        
    );

    WsbTraceOut( L"CSakNode::EnumChildDisplayProps", L"hr = <%ls>, *ppEnum = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppEnum ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         EnumChildDisplayTitles
//
//  Enumerate back the properties of my children that should be shown in the
//  result pane view.
//

STDMETHODIMP CSakNode::EnumChildDisplayTitles( IEnumString ** ppEnum )
{
    WsbTraceIn( L"CSakNode::EnumChildDisplayTitles", L"ppEnum = <0x%p>", ppEnum );

    HRESULT hr = S_OK;
    
    CEnumString * pEnum = 0;
    
    try {

        WsbAffirmPointer( ppEnum );
        WsbAffirm( m_cChildPropsShow > 0, S_FALSE );

        *ppEnum = 0;

        //
        // New an ATL enumerator
        //
        pEnum = new CEnumString;
        WsbAffirmAlloc( pEnum );

        WsbAffirmHr( pEnum->FinalConstruct( ) );
        WsbAffirmHr( pEnum->Init( &m_rgszChildPropTitles[0], &m_rgszChildPropTitles[m_cChildPropsShow], NULL, AtlFlagCopy ) );
        WsbAffirmHr( pEnum->QueryInterface( IID_IEnumString, (void**)ppEnum ) );
        
    } WsbCatchAndDo( hr,
        
        if( pEnum ) delete pEnum;
        
    );

    WsbTraceOut( L"CSakNode::EnumChildDisplayTitles", L"hr = <%ls>, *ppEnum = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppEnum ) );
    return( hr );
}


/////////////////////////////////////////////////////////////////////////////
//
//         Helper Functions for derived classes
//
/////////////////////////////////////////////////////////////////////////////


//---------------------------------------------------------------------------
//
//         LoadContextMenu
//
//  Loads the specified menu resource and returns the first 
//  popup menu in it - used for context menus
//

HRESULT CSakNode::LoadContextMenu( UINT nId, HMENU *phMenu )
{
    WsbTraceIn( L"CSakNode::LoadContextMenu", L"nId = <%u>, phMenu = <0x%p>", nId, phMenu );

    *phMenu = LoadMenu ( _Module.m_hInst, MAKEINTRESOURCE( nId ) );
    HRESULT hr = *phMenu ? S_OK : E_FAIL;

    WsbTraceOut( L"CSakNode::LoadContextMenu", L"hr = <%ls>, *phMenu = <0x%p>", WsbHrAsString( hr ), *phMenu );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         FindNodeOfType
//
//  Recursive search through nodes. Give back the IUnknown* interface of the 
// "nodetype" object (JobDefLst, JobPolLst, etc).
//

STDMETHODIMP 
CSakNode::FindNodeOfType(REFGUID nodetype, ISakNode** ppNode)
{
    WsbTraceIn( L"CSakNode::FindNodeOfType", L"nodetype = <%ls>, ppNode = <0x%p>", WsbGuidAsString( nodetype ), ppNode );

    HRESULT hr = S_FALSE;

    // check if this is the node we are looking for.
    if( IsEqualGUID( *m_rTypeGuid, nodetype ) ) {

        *ppNode = (ISakNode*)this;
        (*ppNode)->AddRef( );

        hr = S_OK;

    } else {

        // Search for correct node in this node's children.
        try {

            ISakNode** ppNodeEnum;
            for( ppNodeEnum = m_Children.begin( ); ppNodeEnum < m_Children.end( ); ppNodeEnum++ )  {
        
                if( *ppNodeEnum ) {

                    hr = (*ppNodeEnum)->FindNodeOfType( nodetype, ppNode );
                    if( hr == S_OK ) {
        
                        break;
                    }
                }
            }
        
        } WsbCatch( hr );
    }

    WsbTraceOut( L"CSakNode::FindNodeOfType", L"hr = <%ls>, *ppNode = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppNode ) );
    return( hr );
}


//-----------------------------------------------------------------------------
//
//          SetChildProps
//
// Set the result view column properties
//

HRESULT
CSakNode::SetChildProps (
    const TCHAR* ResIdPropsIds,
    LONG         ResIdPropsTitles,
    LONG         ResIdPropsWidths
    )
/*++

Routine Description:

    Set the result view Ids, Titles, and Width strings from the 
    given resource Ids.

Arguments:


Return Value:

    S_OK - All added fine - continue.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakNode::SetChildProps", L"ResIdPropsIds = <%ls>, ResIdPropsTitles = <%ld>, ResIdPropsWidths = <%ld>", ResIdPropsIds, ResIdPropsTitles, ResIdPropsWidths );

    CString szResource;
    CWsbStringPtr szWsbData;
    OLECHAR* szData;
    HRESULT hr = S_OK;
    INT i = 0;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    try {

        // First clean up the current properties (if any)
        FreeChildProps();

        // Properties Ids
        szWsbData = ResIdPropsIds;
        szData = szWsbData;
        szData = wcstok( szData, L":" );
        while( szData ) {

            m_rgszChildPropIds[m_cChildProps] = SysAllocString( szData );
            WsbAffirmAlloc( m_rgszChildPropIds[m_cChildProps] );
            szData = wcstok( NULL, L":" );
            m_cChildProps++;

        }

        // Property Titles
        i = 0;
        szResource.LoadString (ResIdPropsTitles);
        szWsbData = szResource;
        szData = szWsbData;
        szData = wcstok( szData, L":" );
        while( szData ) {

            m_rgszChildPropTitles[i] = SysAllocString( szData );
            WsbAffirmAlloc( m_rgszChildPropTitles[i] );
            szData = wcstok( NULL, L":" );
            i++;

        }

        // Properties Widths
        i = 0;
        szResource.LoadString( ResIdPropsWidths );
        szWsbData = szResource;
        szData = szWsbData;
        szData = wcstok( szData, L":" );
        while( szData ) {

            m_rgszChildPropWidths[i] = SysAllocString( szData );
            WsbAffirmAlloc( m_rgszChildPropWidths[i] );
            szData = wcstok( NULL, L":" );
            i++;

        }

        //
        // By default, show all props
        //

        m_cChildPropsShow = m_cChildProps;

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::SetChildProps", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//-------------------------------------------------------------------------------
//
//              FreeChildProps
//
// free up the old child properties and widths
//

HRESULT
CSakNode::FreeChildProps()
{
    WsbTraceIn( L"CSakNode::FreeChildProps", L"" );

    HRESULT hr = S_OK;

    for( INT i = 0; i < m_cChildProps; i++ ) {

        if( m_rgszChildPropIds[i]   )   SysFreeString( m_rgszChildPropIds[i] );
        if( m_rgszChildPropTitles[i])   SysFreeString( m_rgszChildPropTitles[i] );
        if( m_rgszChildPropWidths[i])   SysFreeString( m_rgszChildPropWidths[i] );

    }

    m_cChildProps     = 0;
    m_cChildPropsShow = 0;

    WsbTraceOut( L"CSakNode::FreeChildProps", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//---------------------------------------------------------------------------------
//
//              RefreshObject
//
//  Fetch up-to-date information for the object.  Implemented in derived
//  classes
//
STDMETHODIMP 
CSakNode::RefreshObject ()
{
    WsbTraceIn( L"CSakNode::RefreshObject", L"" );

    HRESULT hr = S_OK;

    WsbTraceOut( L"CSakNode::RefreshObject", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//---------------------------------------------------------------------------------
//
//              DeleteObject
//
//  Fetch up-to-date information for the object.  Implemented in derived
//  classes
//
STDMETHODIMP 
CSakNode::DeleteObject ()
{
    WsbTraceIn( L"CSakNode::DeleteObject", L"" );

    HRESULT hr = S_OK;

    WsbTraceOut( L"CSakNode::DeleteObject", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
//
// Local utility functions
//
/////////////////////////////////////////////////////////////////////////////




STDMETHODIMP 
CSakNode::GetMenuHelp (
    LONG sCmd,
    BSTR * szHelp
    )

/*++

Routine Description:

    Retrieve .

Arguments:

    pDataObject - identifies the node to be worked on.

    pContextMenuCallback - The MMC menu interface to use.

Return Value:

    S_OK - All added fine - continue.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakNode::GetMenuHelp", L"sCmd = <%ld>, szHelp = <0x%p>", sCmd, szHelp );

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    CString string;

    try  {

        if ( string.LoadString ( sCmd ) ) {
        
            *szHelp = string.AllocSysString ( );
        
        } else {
        
            //
            // Must not be a help string - return S_FALSE
            //
        
            *szHelp = 0;
            hr = S_FALSE;
        
        }

    } catch ( CMemoryException ) {

        //
        // If out of memory, return as such
        //

        *szHelp = 0;
        hr = E_OUTOFMEMORY;

    }

    WsbTraceOut( L"CSakNode::GetMenuHelp", L"hr = <%ls>, *szHelp = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( szHelp ) );
    return( hr );
}

STDMETHODIMP CSakNode::SupportsProperties ( BOOL bMultiSelect )
{
    WsbTraceIn( L"CSakNode::SupportsProperties", L"" );
    HRESULT hr = S_OK;

    if( bMultiSelect ) {

        hr = m_bSupportsPropertiesMulti ? S_OK : S_FALSE;

    } else {

        hr = m_bSupportsPropertiesSingle ? S_OK : S_FALSE;

    }

    WsbTraceOut( L"CSakNode::SupportsProperties", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakNode::SupportsPropertiesNoEngine (  )
{
    WsbTraceIn( L"CSakNode::SupportsPropertiesNoEngine", L"" );
    HRESULT hr = S_OK;
    hr = m_bSupportsPropertiesNoEngine ? S_OK : S_FALSE;

    WsbTraceOut( L"CSakNode::SupportsPropertiesNoEngine", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}



STDMETHODIMP CSakNode::SupportsRefresh ( BOOL bMultiSelect )
{
    WsbTraceIn( L"CSakNode::SupportsRefresh", L"" );
    HRESULT hr = S_OK;
    if( bMultiSelect ) {

        hr = m_bSupportsRefreshMulti ? S_OK : S_FALSE;

    } else {

        hr = m_bSupportsRefreshSingle ? S_OK : S_FALSE;

    }

    WsbTraceOut( L"CSakNode::SupportsRefresh", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakNode::SupportsRefreshNoEngine (  )
{
    WsbTraceIn( L"CSakNode::SupportsRefreshNoEngine", L"" );
    HRESULT hr = S_OK;
    hr = m_bSupportsRefreshNoEngine ? S_OK : S_FALSE;

    WsbTraceOut( L"CSakNode::SupportsRefreshNoEngine", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakNode::SupportsDelete ( BOOL bMultiSelect )
{
    WsbTraceIn( L"CSakNode::SupportsDelete", L"" );
    HRESULT hr = S_OK;

    if( bMultiSelect ) {

        hr = m_bSupportsDeleteMulti ? S_OK : S_FALSE;

    } else {

        hr = m_bSupportsDeleteSingle ? S_OK : S_FALSE;

    }

    WsbTraceOut( L"CSakNode::SupportsDelete", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakNode::IsContainer (void )
{
    WsbTraceIn( L"CSakNode::IsContainer", L"" );

    HRESULT hr = m_bIsContainer ? S_OK : S_FALSE;

    WsbTraceOut( L"CSakNode::IsContainer", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakNode::HasDynamicChildren( void )
{
    WsbTraceIn( L"CSakNode::HasDynamicChildren", L"" );

    HRESULT hr = m_bHasDynamicChildren ? S_OK : S_FALSE;

    WsbTraceOut( L"CSakNode::HasDynamicChildren", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakNode::IsValid( void )
{
    WsbTraceIn( L"CSakNode::IsValid", L"" );

    HRESULT hr = S_OK;

    WsbTraceOut( L"CSakNode::IsValid", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP CSakNode::GetNodeType ( GUID* pGuid )
{
    WsbTraceIn( L"CSakNode::GetNodeType", L"pGuid = <0x%p>", pGuid );

    HRESULT hr = S_OK;
    *pGuid = *m_rTypeGuid;

    WsbTraceOut( L"CSakNode::GetNodeType", L"hr = <%ls>, *pGuid = <%ls>", WsbHrAsString( hr ), WsbPtrToGuidAsString( pGuid ) );
    return( hr );
}

STDMETHODIMP CSakNode::AddPropertyPages( RS_NOTIFY_HANDLE /*handle*/, IUnknown* /*pUnkPropSheetCallback*/, IEnumGUID* /*pEnumObjectId*/, IEnumUnknown* /*pEnumUnkNode*/ )
{
    //
    // CSakNode does not implement prop sheets. However, some
    // derived nodes also do not implement, so we provide a default
    // not impl here
    //

    WsbTraceIn( L"CSakNode::AddPropertyPages", L"" );

    HRESULT hr = S_OK;

    WsbTraceOut( L"CSakNode::AddPropertyPages", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakNode::GetObjectId( GUID *pObjectId)
{

    HRESULT hr = S_OK;
    WsbTraceIn( L"CSakNode::GetObjectId", L"" );

    *pObjectId = m_ObjectId;

    WsbTraceOut( L"CSakNode::GetObjectId", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakNode::SetObjectId( GUID pObjectId)
{
    HRESULT hr = S_OK;
    WsbTraceIn( L"CSakNode::SetObjectId", L"" );

    m_ObjectId = pObjectId;

    WsbTraceOut( L"CSakNode::SetObjectId", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP CSakNode::GetPrivateData( RS_PRIVATE_DATA *pData )
{
    WsbTraceIn( L"CSakNode::GetPrivateData", L"" );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pData );
        *pData = m_PrivateData;

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::GetPrivateData", L"hr = <%ls>, *pData = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)pData ) );
    return( hr );
}

STDMETHODIMP CSakNode::SetPrivateData( RS_PRIVATE_DATA Data )
{
    WsbTraceIn( L"CSakNode::SetPrivateData", L"pData = <0x%p>", Data );
    HRESULT hr = S_OK;

    m_PrivateData = Data;

    WsbTraceOut( L"CSakNode::SetPrivateData", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


//---------------------------------------------------------------------------
//
//         CSakNode::ActivateView
//
//  Activate a result pane view - not supported in CSakNode.
//

STDMETHODIMP 
CSakNode::ActivateView( OLE_HANDLE )
{
    WsbTraceIn( L"CSakNode::ActivateView", L"" );

    HRESULT hr = S_FALSE;

    WsbTraceOut( L"CSakNode::ActivateView", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP 
CSakNode::HasToolbar( ) 
{
    return ( m_cToolbarButtons > 0 ) ? S_OK : S_FALSE;
}

STDMETHODIMP
CSakNode::SetupToolbar( IToolbar *pToolbar )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CBitmap *pBmpToolbar;
    HRESULT hr = S_OK;
    MMCBUTTON mmcButton;

    if( ( m_cToolbarButtons > 0 ) && ( m_ToolbarBitmap != UNINITIALIZED ) ) {

        try {

            //
            // Add the bitmap
            //
            pBmpToolbar = new ::CBitmap;
            pBmpToolbar->LoadBitmap(m_ToolbarBitmap);
            WsbAffirmHr ( pToolbar->AddBitmap(m_cToolbarButtons, *pBmpToolbar, 16, 16, RGB(255, 0, 255)) );

            //
            // Convert the RS button format to MMCBUTTON
            //
            for( INT i = 0; i < m_cToolbarButtons; i++ ) {

                mmcButton.nBitmap   = m_ToolbarButtons[i].nBitmap; 
                mmcButton.idCommand = m_ToolbarButtons[i].idCommand;
                mmcButton.fsState   = m_ToolbarButtons[i].fsState;
                mmcButton.fsType    = m_ToolbarButtons[i].fsType;

                CString szButtonText;
                szButtonText.Format( m_ToolbarButtons[i].idButtonText );
                mmcButton.lpButtonText = szButtonText.GetBuffer(0);

                CString szTooltipText;
                szTooltipText.Format( m_ToolbarButtons[i].idTooltipText );
                mmcButton.lpTooltipText = szTooltipText.GetBuffer(0);

                WsbAffirmHr( pToolbar->AddButtons( 1, &mmcButton ) );

            }

        } WsbCatch( hr );

    } else {

        hr = S_FALSE;

    }
    return hr;
}

//------------------------------------------------------------------------------
//
//          RefreshScopePane
//
//  Refreshes the scope pane from this node down
//
//

HRESULT CSakNode::RefreshScopePane( )
{
    WsbTraceIn( L"CSakNode::RefreshScopePane", L"" );

    HRESULT hr = S_OK;
    try {

        //
        // Refresh the scope pane
        //
        WsbAffirmHr( m_pSakSnapAsk->UpdateAllViews( (ISakNode*)this ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::RefreshScopePane", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

ULONG
CSakNode::InternalAddRef(
    )
{
    WsbTraceIn( L"CSakNode::InternalAddRef", L"m_Name = <%ls>", m_szName );

    ULONG retval = CComObjectRoot::InternalAddRef( );

    WsbTraceOut( L"CSakNode::InternalAddRef", L"retval = <%lu>, type = <%ls>", retval, GetClassNameFromNodeType( *m_rTypeGuid ) );
    return( retval );
}

ULONG
CSakNode::InternalRelease(
    )
{
    WsbTraceIn( L"CSakNode::InternalRelease", L"m_Name = <%ls>", m_szName );

    ULONG retval = CComObjectRoot::InternalRelease( );

    WsbTraceOut( L"CSakNode::InternalRelease", L"retval = <%lu>, type = <%ls>", retval, GetClassNameFromNodeType( *m_rTypeGuid ) );
    return( retval );
}

int
CSakNode::AddResultImage( UINT nId )
{
    return( CSakSnap::AddImage( nId ) );
}

int
CSakNode::AddScopeImage( UINT nId )
{
    return( CSakData::AddImage( nId ) );
}

HRESULT
CSakNode::AddChild( ISakNode* pChild )
{
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pChild );

        WsbAffirmHr( m_Children.Add( pChild ) );

    } WsbCatch( hr );

    return( hr );
}

BSTR CSakNode::SysAlloc64BitSortKey( LONGLONG Number )
{
    BSTR retval = 0;

    CString sortKey;
    sortKey.Format( L"%16.16I64X", Number );
    retval = SysAllocString( sortKey );

    return( retval );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\cpropsht.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    CPropSht.cpp

Abstract:

    Implementation of Property-Sheet-Like container object
    for property sheet pages.

Author:

    Art Bragg 10/8/97

Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////
//
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

// To make sure callbacks are in correct order:
// PropPageCallback -> MMC Callback -> MFC Callback
// This is because MMC only stores one pointer, and they want it
// to be MFC's
// note that pfnCallback has already been set to PropPageCallback

HRESULT CSakPropertyPage::SetMMCCallBack( )
{
    HRESULT hr = S_OK;

    m_psp.pfnCallback = m_pMfcCallback;
    hr = MMCPropPageCallback( &( m_psp ) );
    m_pMfcCallback = m_psp.pfnCallback;
    m_psp.pfnCallback = PropPageCallback;

    return( hr );
}

// To make sure callbacks are in correct order:
// PropPageCallback -> MMC Callback -> MFC Callback
// This is because MMC only stores one pointer, and they want it
// to be MFC's
// note that pfnCallback has already been set to PropPageCallback

HRESULT CSakWizardPage::SetMMCCallBack( )
{
    HRESULT hr = S_OK;

    m_psp.pfnCallback = m_pMfcCallback;
    hr = MMCPropPageCallback( &( m_psp ) );
    m_pMfcCallback = m_psp.pfnCallback;
    m_psp.pfnCallback = PropPageCallback;

    return( hr );
}


HRESULT
CSakPropertySheet::InitSheet(
            RS_NOTIFY_HANDLE Handle,
            IUnknown*        pUnkPropSheetCallback,
            CSakNode*        pSakNode,
            ISakSnapAsk*     pSakSnapAsk,
            IEnumGUID*       pEnumObjectId,
            IEnumUnknown*    pEnumUnkNode
    )
{
    WsbTraceIn( L"CSakPropertySheet::InitSheet", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // Set data members
        //
        WsbAffirmHr( RsQueryInterface( pUnkPropSheetCallback, IPropertySheetCallback, m_pPropSheetCallback ) );
        m_pSakNode              = pSakNode;
        m_Handle                = Handle;
        m_bMultiSelect          = pEnumObjectId ? TRUE : FALSE ;

        if( pSakNode ) {

            WsbAffirmHr( SetNode( pSakNode ) );

        }

        //
        // Marshall ISakSnapAsk
        //
        WsbAffirmPointer( pSakSnapAsk );
        WsbAffirmHr ( CoMarshalInterThreadInterfaceInStream(
            IID_ISakSnapAsk, pSakSnapAsk, &m_pSakSnapAskStream ) );

        //
        // Store the GUIDs
        //
        if( pEnumObjectId ) {

            GUID objectId;
            while( pEnumObjectId->Next( 1, &objectId, NULL ) == S_OK) {

                m_ObjectIdList.Add( objectId );

            }
        }

        //
        // Store the nodes
        //
        if( pEnumUnkNode ) {

            CComPtr<IUnknown> pUnkNode;
            CComPtr<ISakNode> pNode;
            pEnumUnkNode->Reset( );
            while( pEnumUnkNode->Next( 1, &pUnkNode, NULL ) == S_OK ) {

                WsbAffirmHr( pUnkNode.QueryInterface( &pNode ) );
                m_UnkNodeList.Add( pNode );
                pUnkNode.Release( );
                pNode.Release( );

            }
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakPropertySheet::InitSheet", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakPropertySheet::SetNode(
    CSakNode*        pSakNode
    )
{
    WsbTraceIn( L"CSakPropertySheet::SetNode", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // Marshall pHsmObj as an unknown
        //
        CComPtr <IUnknown> pHsmObj;
        pSakNode->GetHsmObj( &pHsmObj );
        if( pHsmObj ) {

            WsbAffirmHr ( CoMarshalInterThreadInterfaceInStream(
                IID_IUnknown, pHsmObj, &m_pHsmObjStream ) );

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakPropertySheet::SetNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

CSakPropertySheet::~CSakPropertySheet()
{
    WsbTraceIn( L"CSakPropertySheet::~CSakPropertySheet", L"" );

    MMCFreeNotifyHandle( m_Handle );

    WsbTraceOut( L"CSakPropertySheet::~CSakPropertySheet", L"" );
}

HRESULT CSakPropertySheet::GetNextObjectId( INT *pBookMark, GUID *pObjectId )
{
    HRESULT hr = S_OK;
    try {
        WsbAffirm( *pBookMark >= 0, E_FAIL );
        if( *pBookMark <= m_ObjectIdList.GetUpperBound( ) ) {

            *pObjectId = m_ObjectIdList[ *pBookMark ];
            (*pBookMark)++;

        } else {

            //
            // We're done
            //
            WsbThrow ( S_FALSE );

        }
    } WsbCatch( hr );

    return( hr );
}

HRESULT CSakPropertySheet::GetNextNode( INT *pBookMark, ISakNode **ppNode )
{
    HRESULT hr = S_OK;
    try {

        WsbAffirm( *pBookMark >= 0, E_FAIL );
        if( *pBookMark < m_UnkNodeList.length( ) ) {

            WsbAffirmHr( m_UnkNodeList.CopyTo( *pBookMark, ppNode ) );
            (*pBookMark)++;

        } else {

            //
            // We're done
            //
            hr = S_FALSE;

        }

    } WsbCatch( hr );

    return( hr );
}

void CSakPropertySheet::AddPageRef()
{
    m_nPageCount++;
}


void CSakPropertySheet::ReleasePageRef()
{
    m_nPageCount--;

    //
    // Check to see if this is last reference
    //
    if( m_nPageCount <= 0 ) {

        delete( this );

    }
}


HRESULT CSakPropertySheet::GetHsmObj( IUnknown **ppHsmObj )
{
    HRESULT hr = S_OK;
    try {

        if( !m_pHsmObj ) {

            //
            // Unmarhsall the pointer
            //
            WsbAffirmHr( CoGetInterfaceAndReleaseStream( m_pHsmObjStream, IID_IUnknown, 
                    (void **) &m_pHsmObj ) );
        } 
        m_pHsmObj.CopyTo( ppHsmObj );

    } WsbCatch( hr );
    return( hr );
}

HRESULT CSakPropertySheet::GetSakSnapAsk( ISakSnapAsk **ppAsk )
{
    HRESULT hr = S_OK;
    try {

        if ( !m_pSakSnapAsk ) {

            //
            // Unmarhsall the pointer
            //
            WsbAffirmHr( CoGetInterfaceAndReleaseStream( m_pSakSnapAskStream, IID_ISakSnapAsk, 
                    (void **) &m_pSakSnapAsk ) );
        }
        m_pSakSnapAsk.CopyTo( ppAsk );

    } WsbCatch( hr );

    return( hr );
}

HRESULT CSakPropertySheet::GetHsmServer (IHsmServer **ppHsmServer)
{
    HRESULT hr = S_OK;
    try {

        CComPtr<ISakSnapAsk> pAsk;
        WsbAffirmHr( GetSakSnapAsk( &pAsk ) );
        WsbAffirmHrOk( pAsk->GetHsmServer( ppHsmServer ) );

    } WsbCatch( hr );
    return( hr );
}

HRESULT CSakPropertySheet::GetFsaServer (IFsaServer **ppFsaServer)
{
    HRESULT hr = S_OK;
    try {

        CComPtr<ISakSnapAsk> pAsk;
        WsbAffirmHr( GetSakSnapAsk( &pAsk ) );
        WsbAffirmHrOk( pAsk->GetFsaServer( ppFsaServer ) );

    } WsbCatch( hr );
    return( hr );
}

HRESULT CSakPropertySheet::GetRmsServer (IRmsServer **ppRmsServer)
{
    HRESULT hr = S_OK;
    try {

        CComPtr<ISakSnapAsk> pAsk;
        WsbAffirmHr( GetSakSnapAsk( &pAsk ) );
        WsbAffirmHrOk( pAsk->GetRmsServer( ppRmsServer ) );

    } WsbCatch( hr );
    return( hr );
}


HRESULT CSakPropertySheet::IsMultiSelect ( )
{
    return m_bMultiSelect ? S_OK : S_FALSE;
}
        
HRESULT CSakPropertySheet::OnPropertyChange( RS_NOTIFY_HANDLE hConsoleHandle, ISakNode* pNode )
{
    //
    // Called by a property sheet to notify MMC
    //
    HRESULT hr = S_OK;
    RS_PRIVATE_DATA privData;

    //
    // Notify the console that properties have changed for the node(s)
    //
    try {

        if( !m_bMultiSelect ) {

            //
            // Single Select
            //
            if( ! pNode ) {

                pNode = m_pSakNode;
            }

            WsbAffirmHr( pNode->GetPrivateData( &privData ) );
            WsbAffirmHr( MMCPropertyChangeNotify( hConsoleHandle, (LPARAM)privData ) );

        } else {

            //
            // Multi Select
            //
            INT bookMark = 0;
            CComPtr<ISakNode> pNode;
            while( GetNextNode( &bookMark, &pNode ) == S_OK) {

                WsbAffirmHr( pNode->GetPrivateData( &privData ) );
                WsbAffirmHr( MMCPropertyChangeNotify( hConsoleHandle, (LPARAM)privData ) );

                pNode.Release( );

            }
        }

    } WsbCatch( hr );

    return( hr );
}

// This function is to be called from the page thread
HRESULT CSakPropertySheet::GetFsaFilter( IFsaFilter **ppFsaFilter )
{
    WsbTraceIn( L"CSakPropertySheet::GetFsaFilter", L"" ); 
    HRESULT hr = S_OK;

    try {

        CComPtr<IFsaServer> pFsa;
        WsbAffirmHr( GetFsaServer( &pFsa ) );

        //
        // Get the FsaFilter object
        //
        WsbAffirmHr( pFsa->GetFilter( ppFsaFilter ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakPropertySheet::GetFsaFilter", L"hr = <%ls>, *ppFsaFilter = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppFsaFilter ) );
    return( hr );
}

HRESULT
CSakPropertySheet::AddPage(
    IN CSakPropertyPage* pPage
    )
{
    WsbTraceIn( L"CSakPropertySheet::AddPage", L"" ); 
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
    HRESULT hr = S_OK;

    try {

        //
        // Get the property sheet callback interface from the input param.
        //
        pPage->m_hConsoleHandle = m_Handle;
        pPage->m_pParent        = this;

        WsbAffirmHr( pPage->SetMMCCallBack( ) );

        HPROPSHEETPAGE hPage;
        hPage = CreatePropertySheetPage( &( pPage->m_psp ) );
        WsbAffirmPointer( hPage );
        AddPageRef( );

        WsbAffirmHr( m_pPropSheetCallback->AddPage( hPage ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakPropertySheet::AddPage", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

CSakPropertyPage::CSakPropertyPage( UINT nIDTemplate, UINT nIDCaption ) :
    CRsPropertyPage( nIDTemplate, nIDCaption ),
    m_pParent( 0 )
{
}

void
CSakPropertyPage::OnPageRelease( )
{
    if( m_pParent ) {

        m_pParent->ReleasePageRef( );

    }
    delete this;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// class CSakVolPropSheet
//
// Supports property sheets for Managed volume and Managed Volume List
//
//
HRESULT CSakVolPropSheet::GetFsaResource (IFsaResource **ppFsaResource)
{
    WsbTraceIn( L"CSakVolPropSheet::GetFsaResource", L"" ); 
    HRESULT hr = S_OK;

    try {

        //
        // Get the hsm object which is a CHsmManagedResource
        //
        CComPtr<IUnknown> pUnk;
        WsbAffirmHr( GetHsmObj( &pUnk ) );
        CComPtr<IHsmManagedResource> pManRes;
        WsbAffirmHr( pUnk.QueryInterface( &pManRes ) );

        //
        // Then Get Coresponding FSA resource
        //
        CComPtr<IUnknown> pUnkFsaRes;
        WsbAffirmHr( pManRes->GetFsaResource( &pUnkFsaRes ) );
        WsbAffirmHr( pUnkFsaRes.QueryInterface( ppFsaResource ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakVolPropSheet::GetFsaResource", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakVolPropSheet::AddPage(
    IN CSakVolPropPage* pPage
    )
{
    WsbTraceIn( L"CSakVolPropSheet::AddPage", L"" ); 

    HRESULT hr = CSakPropertySheet::AddPage( pPage );
    if( SUCCEEDED( hr ) ) {

        pPage->m_pVolParent = this;

    }

    WsbTraceOut( L"CSakVolPropSheet::AddPage", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

CSakVolPropPage::CSakVolPropPage( UINT nIDTemplate, UINT nIDCaption ) :
    CSakPropertyPage( nIDTemplate, nIDCaption ),
    m_pVolParent( 0 )
{
}

////////////////////////////////////////////////////////////////////////////////////////
//
// class CSakWizardSheet
//
// Supports wizards created through MMC
//
//

CSakWizardSheet::CSakWizardSheet( ) :
    m_HrFinish( RS_E_CANCELLED ),
    m_pFirstPage( 0 )
{

}

STDMETHODIMP
CSakWizardSheet::GetWatermarks(
    OUT HBITMAP*  pWatermark,
    OUT HBITMAP*  pHeader,
    OUT HPALETTE* pPalette,
    OUT BOOL*     pStretch
    )
{
    WsbTraceIn( L"CSakWizardSheet::GetWatermarks", L"" ); 
    AFX_MANAGE_STATE(AfxGetStaticModuleState()); 
    HRESULT hr = S_OK;

    try {

        //
        // Have we loaded them yet?
        //
        if( ! m_Header.GetSafeHandle( ) ) {

            m_Header.LoadBitmap( m_HeaderId );
            m_Watermark.LoadBitmap( m_WatermarkId );

        }

        *pHeader    = (HBITMAP)m_Header.GetSafeHandle( );
        *pWatermark = (HBITMAP)m_Watermark.GetSafeHandle( );
        *pStretch   = TRUE;
        *pPalette   = 0;
     
    } WsbCatch( hr );

    WsbTraceOut( L"CSakWizardSheet::GetWatermarks", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP
CSakWizardSheet::GetTitle(
    OUT OLECHAR** pTitle
    )
{
    WsbTraceIn( L"CSakWizardSheet::GetTitle", L"" ); 
    HRESULT hr = S_OK;

    try {

        //
        // Have we loaded yet?
        //
        if( m_Title.IsEmpty( ) ) {

            m_Title.LoadString( m_TitleId );

        }

        //
        // Easiest way to CoTaskMemAlloc string
        //
        CWsbStringPtr title = m_Title;
        WsbAffirmHr( title.GiveTo( pTitle ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakWizardSheet::GetTitle", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

void CSakWizardSheet::AddPageRef()
{
    ((ISakWizard*)this)->AddRef( );
}


void CSakWizardSheet::ReleasePageRef()
{
    ((ISakWizard*)this)->Release( );
}

HRESULT
CSakWizardSheet::AddPage(
    IN CSakWizardPage* pPage
    )
{
    WsbTraceIn( L"CSakWizardSheet::AddPage", L"" ); 
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
    HRESULT hr = S_OK;

    try {

        //
        // Need to track first page so that we can find true HWND of sheet
        // in later calls
        //
        if( ! m_pFirstPage ) {

            m_pFirstPage = pPage;

        }

        //
        // Take the caption from our sheet class and put it in the page
        //
        pPage->SetCaption( CString( m_Title ) );


        //
        // Get the property sheet callback interface from the input param.
        //
        pPage->m_pSheet = this;
        WsbAffirmHr( pPage->SetMMCCallBack( ) );

        HPROPSHEETPAGE hPage;
        hPage = pPage->CreatePropertyPage( );
        WsbAffirmPointer( hPage );
        AddPageRef( );

        WsbAffirmHr( m_pPropSheetCallback->AddPage( hPage ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakWizardSheet::AddPage", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


void CSakWizardSheet::SetWizardButtons(
    DWORD Flags
    )
{
    WsbTraceIn( L"CSakWizardSheet::SetWizardButtons", L"" );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( m_pFirstPage );
        WsbAffirmHandle( m_pFirstPage->GetSafeHwnd( ) );

        CPropertySheet* pSheet;
        pSheet = (CPropertySheet*)m_pFirstPage->GetParent( );

        WsbAffirmPointer( pSheet );
        pSheet->SetWizardButtons( Flags );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakWizardSheet::SetWizardButtons", L"hr = <%ls>", WsbHrAsString( hr ) );
}


BOOL CSakWizardSheet::PressButton(
    int Button
    )
{
    WsbTraceIn( L"CSakWizardSheet::PressButton", L"" );
    HRESULT hr     = S_OK;
    BOOL    retVal = FALSE;

    try {

        WsbAffirmPointer( m_pFirstPage );
        WsbAffirmHandle( m_pFirstPage->GetSafeHwnd( ) );

        CPropertySheet* pSheet;
        pSheet = (CPropertySheet*)m_pFirstPage->GetParent( );

        WsbAffirmPointer( pSheet );
        retVal = pSheet->PressButton( Button );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakWizardSheet::PressButton", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( retVal );
}


CSakWizardPage::CSakWizardPage( UINT nIDTemplate, BOOL bExterior, UINT nIdTitle, UINT nIdSubtitle ) :
    CRsWizardPage( nIDTemplate, bExterior, nIdTitle, nIdSubtitle ),
    m_pSheet( 0 )
{
}

BOOL CSakWizardPage::OnWizardFinish( )
{
    WsbTraceIn( L"CSakWizardPage::OnWizardFinish", L"" );

    //
    // Delegate the finish work to the sheet
    //
    m_pSheet->OnFinish( );
    
    BOOL retval = CRsWizardPage::OnWizardFinish( );

    WsbTraceOut( L"CSakWizardPage::OnWizardFinish", L"" );
    return( retval );
}

void CSakWizardPage::OnCancel( ) 
{
    WsbTraceIn( L"CSakWizardPage::OnCancel", L"" );

    //
    // Since the Sheet does not receive an "OnCancel", we call it from the
    // page that will always exist - the intro
    //

    m_pSheet->OnCancel( );
    
    CRsWizardPage::OnCancel( );

    WsbTraceOut( L"CSakWizardPage::OnCancel", L"" );
}

void
CSakWizardPage::OnPageRelease( )
{
    if( m_pSheet ) {

        m_pSheet->ReleasePageRef( );

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\about.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    About.h

Abstract:

    Definition of the CAbout class.

Author:

    Art Bragg [abragg]   12-Aug-1997

Revision History:

--*/

#ifndef _ABOUT_H
#define _ABOUT_H

/////////////////////////////////////////////////////////////////////////////
// CAbout

class ATL_NO_VTABLE CAbout : 
    public ISnapinAbout,        // Supplies information to the About Box
    public CComObjectRoot,
    public CComCoClass<CAbout,&CLSID_CAbout>
{
public:
    CAbout() {}

BEGIN_COM_MAP(CAbout)
    COM_INTERFACE_ENTRY(ISnapinAbout)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CAbout) 

DECLARE_REGISTRY_RESOURCEID(IDR_About)

// ISnapinAbout methods
public:
    STDMETHOD(GetSnapinDescription)(LPOLESTR* lpDescription);
    STDMETHOD(GetProvider)(LPOLESTR* lpName);
    STDMETHOD(GetSnapinVersion)(LPOLESTR* lpVersion);
    STDMETHOD(GetSnapinImage)(HICON* hAppIcon);
    STDMETHOD(GetStaticFolderImage)(HBITMAP* hSmallImage, 
                                    HBITMAP* hSmallImageOpen, 
                                    HBITMAP* hLargeImage, 
                                    COLORREF* cLargeMask);
private:
    HRESULT AboutHelper(UINT nID, LPOLESTR* lpPtr);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\choohsm.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    ChooHsm.cpp

Abstract:

    Initial property page Wizard implementation. Allows the setting
    of who the snapin will manage.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include "ChooHsm.h"

/////////////////////////////////////////////////////////////////////////////
// CChooseHsmDlg property page


CChooseHsmDlg::CChooseHsmDlg(
    CWnd* /*pParent*/ /*=NULL*/
    )
    : CPropertyPage( )
{
    WsbTraceIn( L"CChooseHsmDlg::CChooseHsmDlg", L"" );

    //{{AFX_DATA_INIT( CChooseHsmDlg )
    //}}AFX_DATA_INIT

    Construct( IDD_CHOOSE_HSM_2 );

    WsbTraceOut( L"CChooseHsmDlg::CChooseHsmDlg", L"" );
}

CChooseHsmDlg::~CChooseHsmDlg(
    )
{
    
}

void
CChooseHsmDlg::DoDataExchange(
    CDataExchange* pDX
    )
{
    CPropertyPage::DoDataExchange( pDX );
    //{{AFX_DATA_MAP( CChooseHsmDlg )
    DDX_Control( pDX, IDC_MANAGE_LOCAL,  m_ManageLocal );
    DDX_Control( pDX, IDC_MANAGE_REMOTE, m_ManageRemote );
    DDX_Text( pDX, IDC_MANAGE_NAME, m_ManageName );
    DDV_MaxChars( pDX, m_ManageName, 15 );
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP( CChooseHsmDlg, CPropertyPage )
//{{AFX_MSG_MAP( CChooseHsmDlg )
ON_BN_CLICKED( IDC_MANAGE_LOCAL, OnManageLocal )
ON_BN_CLICKED( IDC_MANAGE_REMOTE, OnManageRemote )
//}}AFX_MSG_MAP
END_MESSAGE_MAP( )

BOOL CChooseHsmDlg::OnInitDialog( ) {
    WsbTraceIn( L"CChooseHsmDlg::OnInitDialog", L"" );
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    CPropertyPage::OnInitDialog( );

    HRESULT hr = S_OK;
    try {

        SetButtons( CHOOSE_LOCAL );

//      m_WizardAnim.Seek( Use256ColorBitmap( ) ? 0 : 1 );
//      m_WizardAnim.Play( 0, -1, -1 );

    }WsbCatch( hr );

    WsbTraceOut( L"CChooseHsmDlg::OnInitDialog", L"" );
    return( FALSE );
}

// Set the finish button correctly based on the validity of the contents of the
// controls in this dialog page.
void
CChooseHsmDlg::SetButtons(
    CHOOSE_STATE state
    )
{
    WsbTraceIn( L"CChooseHsmDlg::SetButtons", L"" );

    ::PropSheet_SetWizButtons( GetParent( )->m_hWnd, PSWIZB_FINISH );

#define CTL_ENABLE( _id,_enable ) GetDlgItem( _id )->EnableWindow( _enable )
#define CTL_SHOW( _id,_show ) GetDlgItem( _id )->ShowWindow( ( _show ) ? SW_SHOWNA : SW_HIDE )

    CTL_ENABLE( IDC_MANAGE_NAME,   state & CHOOSE_REMOTE );
    CTL_ENABLE( IDC_MANAGE_BROWSE, state & CHOOSE_REMOTE );

    if( state & CHOOSE_LOCAL ) {

        if( ! m_ManageLocal.GetCheck( ) ) {

            m_ManageLocal.SetCheck( 1 );
            m_ManageRemote.SetCheck( 0 );

        }

//      m_WizardAnim.Open( m_AllowSetup ? IDR_WIZARD_AVI : IDR_LOCAL_AVI );
//      m_WizardAnim.Seek( Use256ColorBitmap( ) ? 0 : 1 );
//      m_WizardAnim.Play( 0, -1, -1 );

    } else {

        if( ! m_ManageRemote.GetCheck( ) ) {

            m_ManageRemote.SetCheck( 1 );
            m_ManageLocal.SetCheck( 0 );

        }

//      m_WizardAnim.Open( IDR_REMOTE_AVI );
//      m_WizardAnim.Seek( Use256ColorBitmap( ) ? 0 : 1 );
//      m_WizardAnim.Play( 0, -1, -1 );

    }

    WsbTraceOut( L"CChooseHsmDlg::SetButtons", L"" );
}

BOOL
CChooseHsmDlg::OnWizardFinish(
    )
{
    WsbTraceIn( L"CChooseHsmDlg::OnWizardFinish", L"" );

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

//  m_WizardAnim.Stop( );

    //
    // Otherwise connect
    //

    if( m_ManageRemote.GetCheck( ) ) {

        GetDlgItemText( IDC_MANAGE_NAME, *m_pHsmName );

        while( *m_pHsmName[0] == '\\' ) {

            *m_pHsmName = m_pHsmName->Right( m_pHsmName->GetLength( ) - 1 );

        }

    } else {

        *m_pManageLocal = TRUE;

    }

    BOOL retval = CPropertyPage::OnWizardFinish( );

    WsbTraceOut( L"CChooseHsmDlg::OnWizardFinish", L"" );
    return( retval );
}


void
CChooseHsmDlg::OnManageLocal(
    )
{
    SetButtons( CHOOSE_LOCAL ); 
}

void
CChooseHsmDlg::OnManageRemote(
    )
{
    SetButtons( CHOOSE_REMOTE );    
}

/////////////////////////////////////////////////////////////////////////////
// CChooseHsmQuickDlg dialog


CChooseHsmQuickDlg::CChooseHsmQuickDlg( CWnd* pParent /*=NULL*/ )
: CDialog( CChooseHsmQuickDlg::IDD, pParent )
{
    //{{AFX_DATA_INIT( CChooseHsmQuickDlg )
    // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    
}


void
CChooseHsmQuickDlg::DoDataExchange(
    CDataExchange* pDX
    )
{
    CDialog::DoDataExchange( pDX );
    //{{AFX_DATA_MAP( CChooseHsmQuickDlg )
    // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP( CChooseHsmQuickDlg, CDialog )
//{{AFX_MSG_MAP( CChooseHsmQuickDlg )
//}}AFX_MSG_MAP
END_MESSAGE_MAP( )

/////////////////////////////////////////////////////////////////////////////
// CChooseHsmQuickDlg message handlers

BOOL
CChooseHsmQuickDlg::OnInitDialog(
    )
{
    CDialog::OnInitDialog( );

    //
    // ??? At some point do we want to store in the registry
    // or the console the last machine contact was attempted to?
    //

    return( TRUE );
}

void
CChooseHsmQuickDlg::OnOK(
    )
{
    GetDlgItemText( IDC_MANAGE_NAME, *m_pHsmName );

    while( *m_pHsmName[0] == '\\' ) {

        *m_pHsmName = m_pHsmName->Right( m_pHsmName->GetLength( ) - 1 );

    }

    CDialog::OnOK( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\cpropsht.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    CPropSht.h

Abstract:

    Implementation of Property-Sheet-Like container object
    for property sheet pages.

Author:

    Art Bragg 10/8/97

Revision History:

--*/

#ifndef _CSAKPROPSHT_H
#define _CSAKPROPSHT_H

class CSakPropertyPage;

class CSakPropertySheet
{
public:
    CSakPropertySheet() :
        m_pEnumObjectIdStream( 0 ),
        m_pHsmObjStream( 0 ),
        m_pSakSnapAskStream( 0 ),
        m_pSakNode( 0 ),
        m_Handle( 0 ),
        m_nPageCount( 0 )
        { };
    HRESULT InitSheet(
            RS_NOTIFY_HANDLE Handle,
            IUnknown*        pUnkPropSheetCallback,
            CSakNode*        pSakNode,
            ISakSnapAsk*     pSakSnapAsk,
            IEnumGUID*       pEnumObjectId,
            IEnumUnknown*    pEnumUnkNode );

    HRESULT SetNode( CSakNode* pSakNode );

    ~CSakPropertySheet();
    virtual void AddPageRef();
    virtual void ReleasePageRef();

protected:
    LPSTREAM m_pEnumObjectIdStream;
    LPSTREAM m_pHsmObjStream;
    LPSTREAM m_pSakSnapAskStream;

public:
    HRESULT AddPropertyPages( );
    HRESULT IsMultiSelect( );
    HRESULT GetSakSnapAsk( ISakSnapAsk **ppAsk );
    HRESULT GetHsmObj( IUnknown **ppHsmObj );
    HRESULT GetHsmServer( IHsmServer **ppHsmServer );
    HRESULT GetFsaServer( IFsaServer **ppHsmServer );
    HRESULT GetFsaFilter( IFsaFilter **ppFsaFilter );
    HRESULT GetRmsServer( IRmsServer **ppHsmServer );
    HRESULT GetNextObjectId( INT *pBookMark, GUID *pObjectId );
    HRESULT GetNextNode( INT *pBookMark, ISakNode **ppNode );
    HRESULT OnPropertyChange( RS_NOTIFY_HANDLE notifyHandle, ISakNode* pNode = 0 );

    HRESULT AddPage( CSakPropertyPage* pPage );


public:
    CSakNode    *m_pSakNode;

protected:
    RS_NOTIFY_HANDLE     m_Handle;
    CComPtr<IPropertySheetCallback> m_pPropSheetCallback;
    CComPtr<ISakSnapAsk> m_pSakSnapAsk;
    CComPtr<IUnknown>    m_pHsmObj;
    BOOL                 m_bMultiSelect;
    INT                  m_nPageCount;

    CArray<GUID, GUID&>  m_ObjectIdList;
    CRsNodeArray         m_UnkNodeList;
};

class CSakPropertyPage : public CRsPropertyPage
{
public:
    CSakPropertyPage( UINT nIDTemplate, UINT nIDCaption = 0 );

public:
    HRESULT SetMMCCallBack( );

    CSakPropertySheet * m_pParent;
    RS_NOTIFY_HANDLE    m_hConsoleHandle; // Handle given to the snap-in by the console

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CSakWizardPage)
    public:
    //}}AFX_VIRTUAL

protected:
    virtual void OnPageRelease( );

};

class CSakVolPropPage;

class CSakVolPropSheet:public CSakPropertySheet
{
public:
    CSakVolPropSheet() { };
    ~CSakVolPropSheet() { };

public:
    virtual HRESULT GetNextFsaResource( INT *pBookMark, IFsaResource ** ppFsaResource ) = 0;
    HRESULT GetFsaResource( IFsaResource ** ppFsaResource );
    
    HRESULT AddPage( CSakVolPropPage* pPage );
};

class CSakVolPropPage : public CSakPropertyPage
{
public:
    CSakVolPropPage( UINT nIDTemplate, UINT nIDCaption = 0 );

public:
    CSakVolPropSheet * m_pVolParent;

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CSakWizardPage)
    public:
    //}}AFX_VIRTUAL

};

class CSakWizardPage;

class CSakWizardSheet : 
    public CSakPropertySheet,
    public CComObjectRoot,
    public IDataObject,
    public ISakWizard
{

public:
    CSakWizardSheet( );
    virtual void AddPageRef();
    virtual void ReleasePageRef();

BEGIN_COM_MAP(CSakWizardSheet)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(ISakWizard)
END_COM_MAP()


public:
    //
    // IDataObject
    STDMETHOD( SetData )                    ( LPFORMATETC /*lpFormatetc*/, LPSTGMEDIUM /*lpMedium*/, BOOL /*bRelease*/ )
    { return( DV_E_CLIPFORMAT ); };
    STDMETHOD( GetData )                    ( LPFORMATETC /*lpFormatetc*/, LPSTGMEDIUM /*lpMedium*/ )
    { return( DV_E_CLIPFORMAT ); };
    STDMETHOD( GetDataHere )                ( LPFORMATETC /*lpFormatetc*/, LPSTGMEDIUM /*lpMedium*/ )
    { return( DV_E_CLIPFORMAT ); };
    STDMETHOD( EnumFormatEtc )              ( DWORD /*dwDirection*/, LPENUMFORMATETC* /*ppEnumFormatEtc*/ )
    { return( E_NOTIMPL ); };               
    STDMETHOD( QueryGetData )               ( LPFORMATETC /*lpFormatetc*/ ) 
    { return( E_NOTIMPL ); };               
    STDMETHOD( GetCanonicalFormatEtc )      ( LPFORMATETC /*lpFormatetcIn*/, LPFORMATETC /*lpFormatetcOut*/ )
    { return( E_NOTIMPL ); };               
    STDMETHOD( DAdvise )                    ( LPFORMATETC /*lpFormatetc*/, DWORD /*advf*/, LPADVISESINK /*pAdvSink*/, LPDWORD /*pdwConnection*/ )
    { return( E_NOTIMPL ); };               
    STDMETHOD( DUnadvise )                  ( DWORD /*dwConnection*/ )
    { return( E_NOTIMPL ); };               
    STDMETHOD( EnumDAdvise )                ( LPENUMSTATDATA* /*ppEnumAdvise*/ )
    { return( E_NOTIMPL ); };

  
    //
    // ISakWizard
    //
  //STDMETHOD( AddWizardPages ) ( IN RS_PCREATE_HANDLE Handle, IN IUnknown* pPropSheetCallback, IN ISakSnapAsk* pSakSnapAsk );
    STDMETHOD( GetWatermarks )  ( OUT HBITMAP* lphWatermark, OUT HBITMAP* lphHeader, OUT HPALETTE* lphPalette,  OUT BOOL* bStretch );
    STDMETHOD( GetTitle )       ( OUT OLECHAR** pTitle );

public:
    //
    // Used by pages
    //
    void SetWizardButtons( DWORD Flags );
    BOOL PressButton( INT Button );
    virtual HRESULT OnFinish( ) { m_HrFinish = S_OK; return( m_HrFinish ); };
    virtual HRESULT OnCancel( ) { return( m_HrFinish ); };

    //
    // Used to check finish status of wizard
    //
    HRESULT         m_HrFinish;

protected:
    HRESULT AddPage( CSakWizardPage* pPage );

    UINT            m_TitleId;
    CString         m_Title;
    INT             m_HeaderId,
                    m_WatermarkId;
    CBitmap         m_Header,
                    m_Watermark;
    CSakWizardPage* m_pFirstPage;

private:
    HRESULT AddPage( CSakPropertyPage* ) { return( E_NOTIMPL ); }


};

class CSakWizardPage : public CRsWizardPage
{
public:
    CSakWizardPage( UINT nIDTemplate, BOOL bExterior = FALSE, UINT nIdTitle = 0, UINT nIdSubtitle = 0 );

public:
    CSakWizardSheet * m_pSheet;
    HRESULT SetMMCCallBack( );

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CSakWizardPage)
    public:
    virtual BOOL OnWizardFinish();
    virtual void OnCancel();
    //}}AFX_VIRTUAL

protected:
    virtual void OnPageRelease( );
};

#define CSakWizardPage_InitBaseInt( DlgId )  CSakWizardPage( IDD_##DlgId, FALSE, IDS_##DlgId##_TITLE, IDS_##DlgId##_SUBTITLE )
#define CSakWizardPage_InitBaseExt( DlgId )  CSakWizardPage( IDD_##DlgId, TRUE )


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\choohsm.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    ChooHsm.cpp

Abstract:

    Initial property page Wizard implementation. Allows the setting
    of who the snapin will manage.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

class CChooseHsmDlg : public CPropertyPage
{
// Construction
public:
    CChooseHsmDlg(CWnd* pParent = NULL);   // standard constructor
    virtual ~CChooseHsmDlg();

// Property page Data
    //{{AFX_DATA(CChooseHsmDlg)
    enum { IDD = IDD_CHOOSE_HSM_2 };
    CButton m_ManageLocal;
    CButton m_ManageRemote;
    CString m_ManageName;
    //}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CChooseHsmDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Operations 
#define CHOOSE_STATE      ULONG
#define CHOOSE_LOCAL      0x1
#define CHOOSE_REMOTE     0x2

    void SetButtons( CHOOSE_STATE );

    // Implementation
public:
    RS_NOTIFY_HANDLE m_hConsoleHandle;     // Handle given to the snap-in by the console
    CString *        m_pHsmName;           // pointer to CSakData's HSM server string.
    BOOL *           m_pManageLocal;       // pointer to CSakData's m_ManageLocal bool.

    BOOL             m_RunningRss;         // 
    BOOL             m_AllowSetup;
    BOOL             m_SkipAccountSetup;

protected:

    // Generated message map functions
    //{{AFX_MSG(CChooseHsmDlg)
    virtual BOOL OnInitDialog();
    virtual BOOL OnWizardFinish();
    afx_msg void OnManageLocal();
    afx_msg void OnManageRemote();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};
/////////////////////////////////////////////////////////////////////////////
// CChooseHsmQuickDlg dialog

class CChooseHsmQuickDlg : public CDialog
{
// Construction
public:
    CChooseHsmQuickDlg(CWnd* pParent = NULL);   // standard constructor

    CString *       m_pHsmName;           // pointer to CSakData's HSM server string.

// Dialog Data
    //{{AFX_DATA(CChooseHsmQuickDlg)
    enum { IDD = IDD_CHOOSE_HSM };
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CChooseHsmQuickDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CChooseHsmQuickDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\basehsm.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    BaseHSM.h

Abstract:

    Implementation of CSakNode. This is the base class for any
    of the node implementations, providing common functionality.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#ifndef _BASEHSM_H
#define _BASEHSM_H

#define BHSM_MAX_CHILD_PROPS      15
#define BHSM_MAX_NAME             40
#define BHSM_MAX_REG_NAME         512
#define BHSM_MAX_NODE_TYPES       10

// Toolbar buttons for all nodes
#define TB_CMD_VOLUME_SETTINGS      100
#define TB_CMD_VOLUME_TOOLS         101
#define TB_CMD_VOLUME_RULES         102

#define TB_CMD_VOLUME_LIST_SCHED    110
#define TB_CMD_VOLUME_LIST_NEW      111

#define TB_CMD_MESE_COPY            120

#define TB_CMD_CAR_COPIES           130

typedef struct  _RS_MMCButton {

    INT nBitmap;
    INT idCommand;
    BYTE fsState;
    BYTE fsType;
    UINT idButtonText;
    UINT idTooltipText;

}   RS_MMCBUTTON;

#define MAX_TOOLBAR_BUTTONS 20

// This is a dataobject-related structure that maintains basic information that needs to be passed
// from one dataobject-taking method to another.
struct INTERNAL {
    DATA_OBJECT_TYPES   m_type;     // What context is the data object.
};

//
// Declare array that can be added to or completely cleared
// Grows as needed
//
class CRsNodeArray : public CArray<ISakNode*, ISakNode*>
{
public:
    CRsNodeArray( )  { SetSize( 0, 10 ); };
    ~CRsNodeArray( ) { Clear( ); };

    ISakNode** begin( )  { return( GetData( ) ); };
    ISakNode** end( )    { return( GetData( ) + length( ) ); } ;
    INT        length( ) { return( (INT)GetUpperBound( ) + 1 ); };

    HRESULT Add( ISakNode* pNode )
    {
        HRESULT hr = S_OK;
        try {

            CWsbBstrPtr keyAdd, keyEnum;
            CComPtr<ISakNodeProp> pNodeProp, pEnumProp;
            WsbAffirmHr( RsQueryInterface( pNode, ISakNodeProp, pNodeProp ) );
            WsbAffirmHr( pNodeProp->get_DisplayName_SortKey( &keyAdd ) );
            ISakNode*pNodeEnum;
            INT index;
            for( index = 0; index < length( ); index++ ) { 
                pNodeEnum = GetAt( index );
                if( pNodeEnum ) {
                    keyEnum.Free( );
                    pEnumProp.Release( );
                    if( SUCCEEDED( RsQueryInterface( pNodeEnum, ISakNodeProp, pEnumProp ) ) ) {
                        if( SUCCEEDED( pEnumProp->get_DisplayName_SortKey( &keyEnum ) ) ) {
                            if( _wcsicmp( keyAdd, keyEnum ) <= 0 ) {
                                break;
                            }
                        }
                    }
                }
            }
            try {
                CArray<ISakNode*, ISakNode*>::InsertAt( index, pNode );
            } catch( CMemoryException ) {
                WsbThrow( E_OUTOFMEMORY );
            }
            pNode->AddRef( );
        } WsbCatch( hr );
        return( hr );
    };

    void Clear( void )
    {
        ISakNode*pNode;
        for( int index = 0; index < length( ); index++ ) {
            pNode = GetAt( index );
            SetAt( index, 0 );
            if( pNode ) pNode->Release( );
        }
        RemoveAll( );
    };

    HRESULT CopyTo( int Index, ISakNode** ppNode )
    {
        if( !ppNode ) return( E_POINTER );
        *ppNode = GetAt( Index );
        if( *ppNode )  (*ppNode)->AddRef( );
        return S_OK;
    };

};

class ATL_NO_VTABLE CSakNode :
    public CComObjectRoot,
    public ISakNode,
    public IHsmEvent,
    public CComDualImpl<ISakNodeProp, &IID_ISakNodeProp, &LIBID_HSMADMINLib>,
    public IDataObject
{
public:
    CSakNode( ) : m_rTypeGuid(&(GUID_NULL)) {}

    HRESULT FinalConstruct( void );
    void    FinalRelease( void );

    ULONG InternalAddRef( );
    ULONG InternalRelease( );

// ISakNode methods
    STDMETHOD( InitNode )                   ( ISakSnapAsk* pSakSnapAsk, IUnknown* pHsmObj, ISakNode* pParent );
    STDMETHOD( TerminateNode )              ( void );
    STDMETHOD( GetPrivateData )             ( OUT RS_PRIVATE_DATA* pData );
    STDMETHOD( SetPrivateData )             ( IN RS_PRIVATE_DATA Data );
    STDMETHOD( GetHsmObj )                  ( IUnknown** ppHsmObj );
    STDMETHOD( GetNodeType )                ( GUID *pNodeType );
    STDMETHOD( FindNodeOfType )             ( REFGUID nodetype, ISakNode** ppNode );
    STDMETHOD( GetEnumState )               ( BOOL* pState );
    STDMETHOD( SetEnumState )               ( BOOL State );
    STDMETHOD( GetScopeID )                 ( HSCOPEITEM* pid );
    STDMETHOD( SetScopeID )                 ( HSCOPEITEM id );
    STDMETHOD( GetParent )                  ( ISakNode ** ppParent );
    STDMETHOD( IsContainer )                ( void );
    STDMETHOD( CreateChildren )             ( void );
    STDMETHOD( EnumChildren )               ( IEnumUnknown ** ppEnum );
    STDMETHOD( DeleteChildren )             ( void );
    STDMETHOD( DeleteAllChildren )          ( void );
    STDMETHOD( ChildrenAreValid )           ( void );
    STDMETHOD( InvalidateChildren )         ( void );
    STDMETHOD( HasDynamicChildren )         ( void );
    STDMETHOD( EnumChildDisplayProps )      ( IEnumString ** ppEnum );
    STDMETHOD( EnumChildDisplayTitles )     ( IEnumString ** ppEnum );
    STDMETHOD( EnumChildDisplayPropWidths ) ( IEnumString ** ppEnum );
    STDMETHOD( GetMenuHelp )                ( LONG sCmd, BSTR * szHelp );
    STDMETHOD( SupportsPropertiesNoEngine ) ( void );
    STDMETHOD( SupportsProperties )         ( BOOL bMutliSelec );
    STDMETHOD( SupportsRefresh )            ( BOOL bMutliSelect );
    STDMETHOD( SupportsRefreshNoEngine )    (  );
    STDMETHOD( SupportsDelete )             ( BOOL bMutliSelec );
    STDMETHOD( AddPropertyPages )           ( RS_NOTIFY_HANDLE handle, IUnknown* pUnkPropSheetCallback, IEnumGUID *pEnumGuid, IEnumUnknown *pEnumUnkNode);
    STDMETHOD( ActivateView )               ( OLE_HANDLE );
    STDMETHOD( RefreshObject )              ( void );
    STDMETHOD( DeleteObject )               ( void );
    STDMETHOD( GetObjectId )                ( GUID *pObjectId );
    STDMETHOD( SetObjectId )                ( GUID pObjectId );
    STDMETHOD( SetupToolbar )               ( IToolbar *pToolbar );
    STDMETHOD( HasToolbar )                 ( void );
    STDMETHOD( OnToolbarButtonClick )       ( IDataObject *pDataObject, long cmdId );
    STDMETHOD( IsValid )                    ( );

// IHsmEvent methods
    STDMETHOD( OnStateChange )              ( void );


// ISakNodeProp methods
    STDMETHOD( get_DisplayName )            ( BSTR *pszName );
    STDMETHOD( put_DisplayName )            ( OLECHAR *pszName );
    STDMETHOD( get_DisplayName_SortKey )    ( BSTR *pszName );
    STDMETHOD( put_DisplayName_SortKey )    ( OLECHAR *pszName );
    STDMETHOD( get_Type )                   ( BSTR *pszType );
    STDMETHOD( put_Type )                   ( OLECHAR *pszType );
    STDMETHOD( get_Type_SortKey )           ( BSTR *pszType );
    STDMETHOD( get_Description )            ( BSTR *pszDesc );
    STDMETHOD( put_Description )            ( OLECHAR *pszDesc );
    STDMETHOD( get_Description_SortKey )    ( BSTR *pszDesc );


// IDataObject methods
public:
// Implemented
    STDMETHOD( SetData )         ( LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease );
    STDMETHOD( GetData )         ( LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium );
    STDMETHOD( GetDataHere )     ( LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium );
    STDMETHOD( EnumFormatEtc )   ( DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc );

// IDataObject methods that are Not Implemented
private:
    STDMETHOD( QueryGetData )              ( LPFORMATETC /*lpFormatetc*/ )
    { return E_NOTIMPL; };

    STDMETHOD( GetCanonicalFormatEtc )     ( LPFORMATETC /*lpFormatetcIn*/, LPFORMATETC /*lpFormatetcOut*/ )
    { return E_NOTIMPL; };

    STDMETHOD( DAdvise )                   ( LPFORMATETC /*lpFormatetc*/, DWORD /*advf*/, LPADVISESINK /*pAdvSink*/, LPDWORD /*pdwConnection*/ )
    { return E_NOTIMPL; };

    STDMETHOD( DUnadvise )                 ( DWORD /*dwConnection*/ )
    { return E_NOTIMPL; };

    STDMETHOD( EnumDAdvise )               ( LPENUMSTATDATA* /*ppEnumAdvise*/ )
    { return E_NOTIMPL; };

// Implementation
public:
    CRsNodeArray m_Children;                                // Child nodes
    BOOL        m_bEnumState;                               // TRUE if children have been enumerated
    HSCOPEITEM  m_scopeID;                                  // MMC scope item id.
    BOOL        m_bChildrenAreValid;                        // TRUE if list of children is up-to-date
    CWsbBstrPtr m_szName;                                   // name of node
    CWsbBstrPtr m_szName_SortKey;                           // name of node
    CWsbBstrPtr m_szType;                                   // type of node
    CWsbBstrPtr m_szDesc;                                   // description of node
    BSTR        m_rgszChildPropIds[BHSM_MAX_CHILD_PROPS];   // array of child node property Ids
    BSTR        m_rgszChildPropTitles[BHSM_MAX_CHILD_PROPS];// array of child node title properties
    BSTR        m_rgszChildPropWidths[BHSM_MAX_CHILD_PROPS];// array of child node width properties
    INT         m_cChildProps;                              // number of child node properties
    INT         m_cChildPropsShow;                          // number of child node properties to show
    CComPtr<ISakNode>    m_pParent;
    CComPtr<ISakSnapAsk> m_pSakSnapAsk;                     // pointer to the saksnap "ask" interface
    CComPtr<IUnknown>    m_pHsmObj;                            // pointer to the underlying HSM COM object this node encapsulates
    const GUID* m_rTypeGuid;                                // pointer to the type guid for this node type
    BOOL        m_bSupportsPropertiesNoEngine;              // TRUE if this node has property pages.
    BOOL        m_bSupportsPropertiesSingle;                // TRUE if this node has property pages.
    BOOL        m_bSupportsPropertiesMulti;                 // TRUE if this node has property pages.
    BOOL        m_bSupportsRefreshSingle;                   // TRUE if this node supports the refresh method.
    BOOL        m_bSupportsRefreshMulti;                    // TRUE if this node supports the refresh method.
    BOOL        m_bSupportsRefreshNoEngine;                 // TRUE if this node supports the refresh method.
    BOOL        m_bSupportsDeleteSingle;                    // TRUE if this node supports the delete method.
    BOOL        m_bSupportsDeleteMulti;                     // TRUE if this node supports the delete method.
    BOOL        m_bIsContainer;                             // TRUE if this node is a container type (as opposed to leaf).
    BOOL        m_bHasDynamicChildren;                      // TRUE if this nodes immediate children change

protected:
    GUID                m_ObjectId;
    RS_PRIVATE_DATA     m_PrivateData;
    INT                 m_ToolbarBitmap;
    INT                 m_cToolbarButtons;
    RS_MMCBUTTON        m_ToolbarButtons[MAX_TOOLBAR_BUTTONS];

// Clipboard formats that are required by the console
public:
    static UINT    m_cfNodeType;
    static UINT    m_cfNodeTypeString;
    static UINT    m_cfDisplayName;
    static UINT    m_cfInternal;
    static UINT    m_cfClassId;
    static UINT    m_cfComputerName;
    static UINT    m_cfEventLogViews;

private:

    // Generic "GetData" which will allocate if told to
    HRESULT GetDataGeneric( LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium, BOOL DoAlloc );

    // methods to retrieve particular "flavors" of data from a dataobject
    HRESULT RetrieveNodeTypeData( LPSTGMEDIUM lpMedium );
    HRESULT RetrieveNodeTypeStringData( LPSTGMEDIUM lpMedium );
    HRESULT RetrieveDisplayName( LPSTGMEDIUM lpMedium );
    HRESULT RetrieveInternal( LPSTGMEDIUM lpMedium );
    HRESULT RetrieveClsid( LPSTGMEDIUM lpMedium );
    HRESULT RetrieveComputerName( LPSTGMEDIUM lpMedium );
    HRESULT RetrieveEventLogViews( LPSTGMEDIUM lpMedium );

    // methods to store particular "flavors" of data from a dataobject
    HRESULT StoreInternal( LPSTGMEDIUM lpMedium );

    // helper method utilized by each of the above
    HRESULT Retrieve(const void* pBuffer, DWORD len, LPSTGMEDIUM lpMedium);
    HRESULT Store(void* pBuffer, DWORD len, LPSTGMEDIUM lpMedium);

    // actual data store in this dataobject.
    INTERNAL m_internal;

    // Maintain a connection point
    CComPtr<IUnknown> m_pUnkConnection;
    DWORD             m_Advise;


protected:
    void SetConnection( IUnknown *pUnkConnection );
    virtual HRESULT RefreshScopePane( );

    // Registry Helper Functions for derived classes. Not a part of any interface.
    static HRESULT LoadRegString( HKEY hKey, OLECHAR * szValName, OLECHAR * sz, OLECHAR * szDefault );
    static HRESULT LoadRegDWord( HKEY hKey, OLECHAR * szValName, DWORD * pdw, DWORD dwDefault );

    // Helper functions for derived classes to set result pane properties from resource strings
    HRESULT FreeChildProps();
    HRESULT SetChildProps (const TCHAR* ResIdPropsIds, LONG resIdPropsTitles, LONG resIdPropsWidths);

    // Helper Functions to create our children.
    static HRESULT NewChild( REFGUID nodetype, IUnknown** ppUnkChild );
    HRESULT InternalDelete( BOOL Recurse );
    HRESULT AddChild( ISakNode* pChild );

    // General Helper functions - not part of any interface.
    static HRESULT LoadContextMenu( UINT nId, HMENU *phMenu );
    static HRESULT GetCLSIDFromNodeType( REFGUID nodetype, const CLSID ** ppclsid );
    static const OLECHAR * CSakNode::GetClassNameFromNodeType( REFGUID Nodetype );
    static int AddScopeImage( UINT nId );
    static int AddResultImage( UINT nId );
    static BSTR SysAlloc64BitSortKey( LONGLONG Number );
};

    // macro for multiple-inheritance (CSakNode and a ISakNode derived interface)
    // Forwards all CSakNode implemented members to CSakNode explicitly
#define FORWARD_BASEHSM_IMPLS \
    STDMETHOD( get_DisplayName )            ( BSTR *pszName )                                { return CSakNode::get_DisplayName( pszName );           } \
    STDMETHOD( put_DisplayName )            ( OLECHAR *pszName )                             { return CSakNode::put_DisplayName( pszName );           } \
    STDMETHOD( get_DisplayName_SortKey )    ( BSTR *pszName )                                { return CSakNode::get_DisplayName_SortKey( pszName );   } \
    STDMETHOD( put_DisplayName_SortKey )    ( OLECHAR *pszName )                             { return CSakNode::put_DisplayName_SortKey( pszName );           } \
    STDMETHOD( get_Type )                   ( BSTR *pszType )                                { return CSakNode::get_Type( pszType );                  } \
    STDMETHOD( put_Type )                   ( OLECHAR *pszType )                             { return CSakNode::put_Type( pszType );                  } \
    STDMETHOD( get_Type_SortKey )           ( BSTR *pszType )                                { return CSakNode::get_Type_SortKey( pszType );          } \
    STDMETHOD( get_Description )            ( BSTR *pszDesc )                                { return CSakNode::get_Description( pszDesc );           } \
    STDMETHOD( put_Description )            ( OLECHAR *pszDesc )                             { return CSakNode::put_Description( pszDesc );           } \
    STDMETHOD( get_Description_SortKey )    ( BSTR *pszDesc )                                { return CSakNode::get_Description_SortKey( pszDesc );   } \

// Typedef of class that implements IEnumUnknown
typedef CComObject<CComEnum<IEnumUnknown, &IID_IEnumUnknown, IUnknown *,
        _CopyInterface<IUnknown> > > CEnumUnknown;

// Typedef of class that implements IEnumVARIANT
typedef CComObject<CComEnum<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT,
        _Copy<VARIANT> > > CEnumVariant;

// Typedef of class that implements IEnumString
typedef CComObject<CComEnum<IEnumString, &IID_IEnumString, LPOLESTR,
        _Copy<LPOLESTR> > > CEnumString;

// Typedef of class that implements IEnumGUID
typedef CComObject<CComEnum<IEnumGUID, &IID_IEnumGUID, GUID,
        _Copy<GUID> > > CEnumGUID;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\csakdata.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    CSakData.cpp

Abstract:

    This component implements the IComponentData interface for
    the snapin. Primarily it is responsible for handling the
    scope view panes.

Author:

    Rohde Wakefield [rohde]   04-Mar-1997

Revision History:

--*/

#include "stdafx.h"
#include "HsmConn.h"
#include "CSakSnap.h"
#include "CSakData.h"
#include "ChooHsm.h"
#include "WzQstart.h"


UINT CSakData::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME); 
UINT CSakData::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
UINT CSakData::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);  
UINT CSakData::m_cfClassId        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);  
UINT CSakData::m_cfObjectTypes    = RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);  
UINT CSakData::m_cfMultiSelect    = RegisterClipboardFormat(CCF_MULTI_SELECT_SNAPINS);  

UINT CSakData::m_nImageArray[RS_SCOPE_IMAGE_ARRAY_MAX];
INT  CSakData::m_nImageCount = 0;


///////////////////////////////////////////////////////////////////////
// CSakData
//
// CSakData plays several roles in the snapin:
//
//   1) Provides the single entry into the HSM Admin Snapin by
//      implementing IComponentData
//
//   2) Provides the "Interface" for scopeview activities within MMC
//
//   3) Owns the node tree / objects
//
//   4) Provides a layer between MMC and the node objects
//
//   5) Act as its own data object for MMC's node manager,
//
//   6) Manages our portion of the MMC image lists.
//
///////////////////////////////////////////////////////////////////////


const CString CSakData::CParamParse::m_DsFlag = TEXT( "ds:" );

void CSakData::CParamParse::ParseParam( LPCTSTR lpszParam, BOOL bFlag, BOOL /* bLast */ )
{
    CString cmdLine = lpszParam;

    WsbTraceIn( L"CSakData::CParamParse::ParseParam", L"cmdLine = \"%ls\"\n", (LPCTSTR)cmdLine );

    if( bFlag ) {

        //  This is the "correct" code, but currently we don't get the DsFlag parameter
        //  passed on the command line via Directory Services
        if( cmdLine.Left( m_DsFlag.GetLength( ) ) == m_DsFlag ) {
        
            CString dsToken;
            CWsbStringPtr computerName;
            dsToken = cmdLine.Mid( m_DsFlag.GetLength( ) );

            if( SUCCEEDED( HsmGetComputerNameFromADsPath( dsToken, &computerName ) ) ) {

                m_HsmName               = computerName;
                m_ManageLocal           = FALSE;
                m_PersistManageLocal    = FALSE;
                m_SetHsmName            = TRUE;
                m_SetManageLocal        = TRUE;
                m_SetPersistManageLocal = TRUE;

            }
        }
    } else {

        //  This code is our stopgap measure until Directory Services starts
        //  working the way it should
        if( cmdLine.Left( 5 ) == TEXT("LDAP:") ) {
        
            CWsbStringPtr computerName;

            if( SUCCEEDED( HsmGetComputerNameFromADsPath( cmdLine, &computerName ) ) ) {

                WsbTrace(L"CSakData::CParamParse::ParseParam: computerName = \"%ls\"\n", (OLECHAR*)computerName);
                m_HsmName               = computerName;
                m_ManageLocal           = FALSE;
                m_PersistManageLocal    = FALSE;
                m_SetHsmName            = TRUE;
                m_SetManageLocal        = TRUE;
                m_SetPersistManageLocal = TRUE;

            }
        }
    }

    WsbTraceOut( L"CSakData::CParamParse::ParseParam", L"" );
}

HRESULT
CSakData::FinalConstruct(
    void
    )
/*++

Routine Description:

    Called during initial CSakData construction to initialize members.

Arguments:

    none.

Return Value:

    S_OK            - Initialized correctly.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::FinalConstruct", L"" );

    HRESULT hr = S_OK;

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    try {

        //
        // Init values
        //
        m_ManageLocal         = FALSE;
        m_PersistManageLocal  = TRUE;
        m_IsDirty             = TRUE;
        m_State               = FALSE;
        m_FirstTime           = TRUE;
        m_Disabled            = FALSE;
        m_RootNodeInitialized = FALSE;
        m_HrRmsConnect        = S_FALSE;
        
        //
        // Create the hidden window so we can post messages back to self
        //
        m_pWnd = new CSakDataWnd;
        WsbAffirmPointer( m_pWnd );
        WsbAffirmStatus( m_pWnd->Create( this ) );
        
        //
        // Finally do low level ATL construct
        //
        WsbAffirmHr( CComObjectRoot::FinalConstruct( ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::FinalConstruct", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}



void
CSakData::FinalRelease(
    void
    )
/*++

Routine Description:

    Called on final release in order to clean up all members.

Arguments:

    none.

Return Value:

    none.

--*/
{
    WsbTraceIn( L"CSakData::FinalRelease", L"" );
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    HRESULT hr = S_OK;
    try {

        if( m_pWnd ) {

            m_pWnd->DestroyWindow( );
            m_pWnd = 0;

        }
    
    } WsbCatch( hr );


    WsbTraceOut( L"CSakData::FinalRelease", L"" );
}


///////////////////////////////////////////////////////////////////////
//                 IComponentData                                    //
///////////////////////////////////////////////////////////////////////


STDMETHODIMP 
CSakData::Initialize(
    IN  IUnknown * pUnk
    )
/*++

Routine Description:

    Called when the user first adds a snapin.

Arguments:

    pUnk            - Base IUnknown of console

Return Value:

    S_OK            - Correctly initialized.

    E_xxxxxxxxxxx   - Unable to initialize.

--*/
{
    WsbTraceIn( L"CSakData::Initialize", L"pUnk = <0x%p>", pUnk );
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    HRESULT hr = S_OK;
    try {
        //
        // validity check on parameters
        //

        WsbAffirmPointer( pUnk );

        //
        // QI and Save interfaces
        //
        WsbAffirmHr( RsQueryInterface( pUnk, IConsole,          m_pConsole ) );
        WsbAffirmHr( RsQueryInterface( pUnk, IConsoleNameSpace, m_pNameSpace ) );

        //
        // Get the scope image list only and store it in the snapin.
        // It is AddRef'ed by the console
        //

        WsbAffirmHr( m_pConsole->QueryScopeImageList( &m_pImageScope ) );

        // Create the root node (make sure not already set)

        WsbAffirmPointer( !m_pRootNode );
        WsbAffirmHr( m_pRootNode.CoCreateInstance( CLSID_CUiHsmCom ) );


        //
        // If the Hsm name has not been set (by choose Hsm), 
        // do not initialize the node here.  Allow
        // IPersistStream::Load to initialize it, or to be grabbed
        // from the extension's parent
        //

        if( m_ManageLocal || ( m_HsmName != "" ) ) {

            //
            // Make sure no changes from command line
            //
            InitFromCommandLine( );

            //
            // Set the Hsm name in sakData and HsmCom objectds
            //
            WsbAffirmHr( InitializeRootNode( ) );

        }

        WsbAffirmHr( OnAddImages() );
    } WsbCatch( hr);

    WsbTraceOut( L"CSakData::Initialize", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP
CSakData::Notify(
    IN  IDataObject*    pDataObject,
    IN  MMC_NOTIFY_TYPE event,
    IN  LPARAM            arg,
    IN  LPARAM            param
    )
/*++

Routine Description:

    Handle user clicks on nodes in the treeview, along with other
    MMC notices.

Arguments:

    pDataObject     - Data Object for which event occured

    event           - The event type

    arg, param      - Info for event (depend on type)

Return Value:

    S_OK            - Notification handled without error.

    E_xxxxxxxxxxx   - Unable to register server.

--*/
{
    WsbTraceIn( L"CSakData::Notify", L"pDataObject = <0x%p>, event = <%ls>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, RsNotifyEventAsString( event ), arg, arg, param, param );
    HRESULT hr = S_OK;

    try {

        switch( event ) {

        //
        // This node was selected or deselected in the scope pane (the user clicked
        // on the expansion/contraction button)
        //
        case MMCN_EXPAND:
            WsbAffirmHr( OnFolder(pDataObject, arg, param) );
            break;
        
        //
        // This node was expanded or contracted in the scope pane (the user 
        // clicked on the actual node
        //
        case MMCN_SHOW:
            WsbAffirmHr( OnShow( pDataObject, arg, param ) );
            break;
        
        // Not implemented
        case MMCN_SELECT:
            WsbAffirmHr( OnSelect( pDataObject, arg, param ) );
            break;
        
        // Not implemented
        case MMCN_MINIMIZED:
            WsbAffirmHr( OnMinimize( pDataObject, arg, param ) );
            break;
        
        case MMCN_ADD_IMAGES:
            WsbAffirmHr( OnAddImages() );
            break;

        case MMCN_PROPERTY_CHANGE:
            {
                CComPtr<ISakNode> pNode;
                WsbAffirmHr( GetBaseHsmFromCookie( (MMC_COOKIE) param, &pNode ) );
                WsbAffirmHr( UpdateAllViews( pNode ) );
            }
            break;

        case MMCN_CONTEXTHELP:
            WsbAffirmHr( OnContextHelp( pDataObject, arg, param ) );
            break;

        case MMCN_REMOVE_CHILDREN:
            WsbAffirmHr( OnRemoveChildren( pDataObject ) );
            break;

        // Note - Future expansion of notify types possible
        default:
            break;

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::Notify", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP
CSakData::Destroy(
    void
    )
/*++

Routine Description:

    Called to force the release of any owned objects and
    to clear all views.

Arguments:

    none.

Return Value:

    S_OK            - Correctly tore down.

    E_xxxxxxxxxxx   - Failure occurred (not meaningful).

--*/
{
    WsbTraceIn( L"CSakData::Destroy", L"" );
    HRESULT hr = S_OK;

    try {

        // Release the interfaces that we QI'ed
        if( m_pConsole != NULL ) {

            //
            // Tell the console to release the header control interface
            //

            m_pNameSpace.Release();
            m_pImageScope.Release();

            //
            // Release the IConsole interface last
            //
            m_pConsole.Release();


        }

        // Recursive delete list of UI nodes, including the root node.
        if( m_pRootNode ) {

            m_pRootNode->DeleteAllChildren( );
            m_pRootNode->TerminateNode( );
            m_pRootNode.Release( );

        }

        m_pHsmServer.Release( );
        m_pFsaServer.Release( );
        m_pRmsServer.Release( );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::Destroy", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP
CSakData::QueryDataObject(
    IN  MMC_COOKIE              cookie,
    IN  DATA_OBJECT_TYPES type, 
    OUT IDataObject**     ppDataObject
    )
/*++

Routine Description:

    Called by the console when it needs data for a particular node.
    Since each node is a data object, its IDataObject interface is
    simply returned. The console will later pass in this dataobject to 
    SakSnap help it establish the context under which it is being called.

Arguments:

    cookie          - Node which is being queried.

    type            - The context under which a dataobject is being requested.

    ppDataObject    - returned data object.

Return Value:

    S_OK            - Data Object found and returned.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::QueryDataObject", L"cookie = <0x%p>, type = <%d>, ppDataObject = <0x%p>", cookie, type, ppDataObject );
    HRESULT hr = S_OK;
    try {

        //
        // We return ourself if needing a root for the node manager
        //

        if( ( ( 0 == cookie ) || ( EXTENSION_RS_FOLDER_PARAM == cookie ) ) && ( CCT_SNAPIN_MANAGER == type ) ) {

            WsbAffirmHr( _InternalQueryInterface( IID_IDataObject, (void**)ppDataObject ) );

        } else {

            WsbAffirmHr( GetDataObjectFromCookie ( cookie, ppDataObject ) );
            WsbAffirmHr( SetContextType( *ppDataObject, type ) );

        }

    } WsbCatch ( hr )

    WsbTraceOut( L"CSakData::QueryDataObject", L"hr = <%ls>, *ppDataObject = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppDataObject ) );
    return ( hr );
}


STDMETHODIMP
CSakData::CompareObjects(
    IN  IDataObject* pDataObjectA,
    IN  IDataObject* pDataObjectB
    )
/*++

Routine Description:

    Compare data objects for MMC

Arguments:

    pDataObjectA,     - Data object refering to node.
    pDataObjectB

Return Value:

    S_OK            - Objects represent the same node.

    S_FALSE         - Objects do not represent the same node.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::CompareObjects", L"pDataObjectA = <0x%p>, pDataObjectB = <0x%p>", pDataObjectA, pDataObjectB );

    HRESULT hr = S_OK;
    try {

        WsbAssertPointer ( pDataObjectA );
        WsbAssertPointer ( pDataObjectB );

        //
        // Since only one dataobject exists for any given node,
        // the QI's for IUnknown should match. (object identity)
        //

        CComPtr<IUnknown> pUnkA, pUnkB;
        WsbAssertHr( RsQueryInterface( pDataObjectA, IUnknown, pUnkA ) );
        WsbAssertHr( RsQueryInterface( pDataObjectB, IUnknown, pUnkB ) );

        if ( (IUnknown*)pUnkA != (IUnknown*)pUnkB ) {

            hr = S_FALSE;

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::CompareObjects", L"hr = <%ls>", WsbHrAsString( hr ) );
    return ( hr );
}


STDMETHODIMP
CSakData::CreateComponent(
    OUT  IComponent** ppComponent
    )
/*++

Routine Description:

    Creates a new Component object for MMC - our
    CSakSnap object.

Arguments:

    ppComponent     - Return value of the Component.

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::CreateComponent", L"ppComponent = <0x%p>", ppComponent );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( ppComponent );

        //
        // Create the Snapin Component as C++ object so we can init.
        //

        CSakSnap * pSnapin = new CComObject<CSakSnap>;

        WsbAffirmPointer( pSnapin );

        //
        // Following code is based on ATL's CreateInstance
        //

        pSnapin->SetVoid( NULL );
        pSnapin->InternalFinalConstructAddRef();
        HRESULT hRes = pSnapin->FinalConstruct();
        pSnapin->InternalFinalConstructRelease();

        if( FAILED( hRes ) ) {

            delete pSnapin;
            pSnapin = NULL;
            WsbThrow( hRes );

        }

        //
        // And QI for right interface
        //

        WsbAffirmHr ( pSnapin->_InternalQueryInterface( IID_IComponent, (void**)ppComponent ) );

        //
        // Initialize internal pointer to CSakData
        //

        pSnapin->m_pSakData = this;

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::CreateComponent", L"hr = <%ls>, *ppComponent = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppComponent ) );
    return( hr );
}


STDMETHODIMP
CSakData::GetDisplayInfo(
    IN OUT SCOPEDATAITEM* pScopeItem
    )
/*++

Routine Description:

    When MMC is told to call back concerning scope items,
    we receive a call here to fill in missing information.

    Currently we do not use this capability.

Arguments:

    pScopeItem      - SCOPEDATAITEM structure representing state of the node
                      in the scope treeview.

Return Value:

    S_OK            - Struct filled in.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    static CWsbStringPtr tmpString;

    WsbTraceIn( L"CSakData::GetDisplayInfo", L"cookie = <0x%p>, pScopeItem->mask = <0x%p>", pScopeItem->lParam, pScopeItem->mask );

    HRESULT hr = S_OK;
    try {

        CComPtr<ISakNode> pNode;
        CComPtr<ISakNodeProp> pNodeProp;
        WsbAffirmHr( GetBaseHsmFromCookie( pScopeItem->lParam, &pNode ) );

        WsbAffirmHr( pNode.QueryInterface( &pNodeProp ) );

        if( pScopeItem->mask & SDI_IMAGE ) {

            WsbAffirmHr( pNode->GetScopeOpenIcon( m_State, &pScopeItem->nImage ) );

        }

        if( SDI_STR & pScopeItem->mask ) {

            //
            // Go to the node and get the display name.
            // Following the example of the snapin framework, we
            // copy the name into a static string pointer and
            // return a pointer to this.
            //

            CWsbBstrPtr bstr;

            WsbAffirmHr( pNodeProp->get_DisplayName( &bstr ) );

            tmpString = bstr;
            pScopeItem->displayname = tmpString;
        }
    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::GetDisplayInfo", L"hr = <%ls>, pScopeItem->displayname = <%ls>", WsbHrAsString( hr ), (SDI_STR & pScopeItem->mask) ? pScopeItem->displayname : L"N/A" );
    return( hr );
}

///////////////////////////////////////////////////////////////////////
//                 IExtendPropertySheet                              //
///////////////////////////////////////////////////////////////////////


STDMETHODIMP
CSakData::CreatePropertyPages(
    IN  IPropertySheetCallback* pPropSheetCallback, 
    IN  RS_NOTIFY_HANDLE        handle,
    IN  IDataObject*            pDataObject
    )
/*++

Routine Description:

    Console calls this when it is building a property sheet to
    show for a node. It is also called for the data object given
    to represent the snapin to the snapin manager, and should 
    show the initial selection page at that point.

Arguments:

    pPropSheetCallback - MMC interface to use to add page.

    handle          - Handle to MMC to use to add the page.

    pDataObject     - Data object refering to node.

Return Value:

    S_OK            - Pages added.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::CreatePropertyPages", L"pPropSheetCallback = <0x%p>, handle = <0x%p>, pDataObject = <0x%p>", pPropSheetCallback, handle, pDataObject );

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
    HRESULT hr = S_OK;

    try {

        //
        // Confirm parameters.
        //
        WsbAffirmPointer( pPropSheetCallback );
//      WsbAffirmPointer( handle ); // Can be zero
        WsbAffirmPointer( pDataObject );


        //
        // If DataObject is CSakData, we need to present user
        // with page for machine. Do this by checking for
        // support of IComponentData interface.
        //

        CComPtr<IComponentData> pData;
        CComPtr<ISakWizard>     pWizard;

        if( SUCCEEDED( RsQueryInterface( pDataObject, IComponentData, pData ) ) ) {

            //
            // Create the Hsm Choose property page.
            //

            HPROPSHEETPAGE hPage = 0; // Windows property page handle

            CChooseHsmDlg * pChooseDlg = new CChooseHsmDlg( );
            WsbAffirmPointer( pChooseDlg );

            pChooseDlg->m_hConsoleHandle = handle;
            pChooseDlg->m_pHsmName       = &m_HsmName;
            pChooseDlg->m_pManageLocal   = &m_ManageLocal;

            WsbAffirmHr( MMCPropPageCallback( &(pChooseDlg->m_psp) ) );
            hPage = CreatePropertySheetPage( &pChooseDlg->m_psp );
            WsbAffirmPointer( hPage );
            pPropSheetCallback->AddPage( hPage );
 
        } else if( SUCCEEDED( RsQueryInterface( pDataObject, ISakWizard, pWizard ) ) ) {

            WsbAffirmHr( pWizard->AddWizardPages( handle, pPropSheetCallback, this ) );

        } else {

            //
            // Get node out of the dataobject.
            //
            CComPtr<ISakNode> pNode;
            CComPtr<IEnumGUID> pEnumObjectId;
            CComPtr<IEnumUnknown> pEnumUnkNode;

            //
            // Get the base hsm pointer depending on the data object type
            //
            WsbAffirmHr( GetBaseHsmFromDataObject( pDataObject, &pNode, &pEnumObjectId, &pEnumUnkNode ) );
            
            //
            // Tell the node to add its property pages.  pEnumObjectId will be NULL if
            // we are processing single-select.
            //
            WsbAffirmHr( pNode->AddPropertyPages( handle, pPropSheetCallback, pEnumObjectId, pEnumUnkNode ) );

        }

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::CreatePropertyPages", L"hr = <%ls>", WsbHrAsString( hr ) );
    return ( hr );
}


STDMETHODIMP
CSakData::QueryPagesFor(
    IN  IDataObject* pDataObject
    )
/*++

Routine Description:

    This method is called by MMC when it wants to find out if this node
    supports property pages. The answer is yes if:

    1) The MMC context is either for the scope pane or result pane, AND

    2) The node actually DOES have property pages.

    OR

    1) The Data Object is acquired by the snapin manager.

    OR

    1) It is a wizard data object

    Return S_OK if it DOES have pages, and S_FALSE if it does NOT have pages.

Arguments:

    pDataObject     - Data object refering to node.

Return Value:

    S_OK            - Pages exist.

    S_FALSE         - No property pages.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::QueryPagesFor", L"pDataObject = <0x%p>", pDataObject );

    HRESULT hr = S_FALSE;

    try {

        //
        // Confirm parameter.
        //
        WsbAffirmPointer( pDataObject );


        //
        // If DataObject is CSakData, we need to present user
        // with page for machine. Do this by checking for
        // support of IComponentData interface, which is only
        // supported by CSakData.
        //

        CComPtr<IComponentData> pData;
        CComPtr<ISakWizard>     pWizard;

        if( SUCCEEDED( RsQueryInterface( pDataObject, IComponentData, pData ) ) ||
            SUCCEEDED( RsQueryInterface( pDataObject, ISakWizard, pWizard ) ) ) {

            hr = S_OK;
            
        } else {

            //
            // Get node out of the dataobject.
            //

            CComPtr<ISakNode> pBaseHsm;
            WsbAffirmHr( GetBaseHsmFromDataObject( pDataObject, &pBaseHsm ) );
            
            //
            // Ask the node if it has property pages.
            // Ensure we did not get an error.
            //

            hr = pBaseHsm->SupportsProperties( FALSE );
            WsbAffirmHr( hr );

        }

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::QueryPagesFor", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}



///////////////////////////////////////////////////////////////////////
//                 IDataObject methods
///////////////////////////////////////////////////////////////////////



STDMETHODIMP
CSakData::GetDataHere(
    IN  LPFORMATETC lpFormatetc,
    IN  LPSTGMEDIUM lpMedium
    )
/*++

Routine Description:

    Retrieve information FROM the dataobject and put INTO lpMedium.

Arguments:

    lpFormatetc     - Format to retreive.

    lpMedium        - Storage to put information into.

Return Value:

    S_OK            - Storage filled in.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::GetDataHere", L"lpFormatetc->cfFormat = <%ls>", RsClipFormatAsString( lpFormatetc->cfFormat ) );
    HRESULT hr = DV_E_CLIPFORMAT;

    //
    // Based on the CLIPFORMAT write data to "lpMedium" in the correct format.
    //
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    //
    // clip format is the Display Name
    //

    if( cf == m_cfDisplayName ) {

        hr = RetrieveDisplayName( lpMedium );

    }
    
    //
    // clip format is the Node Type
    //

    else if( cf == m_cfNodeType ) {

        hr = RetrieveNodeTypeData( lpMedium );

    }

    //
    // clip format is the Node Type
    //

    else if( cf == m_cfNodeTypeString ) {

        hr = RetrieveNodeTypeStringData( lpMedium );

    }

    //
    // clip format is the ClassId
    //

    else if( cf == m_cfClassId ) {

        hr = RetrieveClsid( lpMedium );

    }

    WsbTraceOut( L"CSakData::GetDataHere", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP
CSakData::SetData(
    IN  LPFORMATETC lpFormatetc,
    IN  LPSTGMEDIUM /*lpMedium*/,
    IN  BOOL /*fRelease*/
    )
/*++

Routine Description:

    Put data INTO a dataobject FROM the information in the lpMedium.
    We do not allow any data to be set.

Arguments:

    lpFormatetc     - Format to set.

    lpMedium        - Storage to get information from.

    fRelease        - Indicates who owns storage after call.

Return Value:

    S_OK            - Storage retreived.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::SetData", L"lpFormatetc->cfFormat = <%ls>", RsClipFormatAsString( lpFormatetc->cfFormat ) );

    HRESULT hr = DV_E_CLIPFORMAT;

    WsbTraceOut( L"CSakData::SetData", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


///////////////////////////////////////////////////////////////////////
// Note - CSakData does not implement these
///////////////////////////////////////////////////////////////////////

STDMETHODIMP CSakData::GetData(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM /*lpMedium*/)
{
    WsbTraceIn( L"CSakData::GetData", L"lpFormatetc->cfFormat = <%ls>", RsClipFormatAsString( lpFormatetcIn->cfFormat ) );

    HRESULT hr = E_NOTIMPL;

    WsbTraceOut( L"CSakData::GetData", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakData::EnumFormatEtc(DWORD /*dwDirection*/, LPENUMFORMATETC* /*ppEnumFormatEtc*/)
{
    WsbTraceIn( L"CSakData::EnumFormatEtc", L"" );

    HRESULT hr = E_NOTIMPL;

    WsbTraceOut( L"CSakData::EnumFormatEtc", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakData::RetrieveDisplayName(
    OUT LPSTGMEDIUM lpMedium
    )
/*++

Routine Description:

    Retrieve from a dataobject with the display named used in the scope pane

Arguments:

    lpMedium        - Storage to set information into.

Return Value:

    S_OK            - Storage set.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    HRESULT hr = S_OK;

    try {

        //
        // Load the name the data object
        //

        CString fullTitle;

        if(  m_ManageLocal ) {

            fullTitle.LoadString( IDS_MANAGE_LOCAL );
        
        } else if( !m_HsmName.IsEmpty( ) ) {

            AfxFormatString1( fullTitle, IDS_HSM_NAME_PREFIX, m_HsmName );
    
        } else {

            fullTitle = HSMADMIN_NO_HSM_NAME;

        }

        WsbAffirmHr( Retrieve( fullTitle, ((wcslen( fullTitle ) + 1) * sizeof(wchar_t)), lpMedium ) );

    } WsbCatch( hr );

    return( hr );
}


HRESULT
CSakData::RetrieveNodeTypeData(
    LPSTGMEDIUM lpMedium
    )
/*++

Routine Description:

    Retrieve from a dataobject with the NodeType (GUID) data in it.

Arguments:

    lpMedium        - Storage to set information into.

Return Value:

    S_OK            - Storage set.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    return Retrieve( (const void*)(&cGuidHsmCom), sizeof(GUID), lpMedium );
}
 
HRESULT
CSakData::RetrieveClsid(
    LPSTGMEDIUM lpMedium
    )
/*++

Routine Description:

    Retrieve from a dataobject with the CLSID data in it.

Arguments:

    lpMedium        - Storage to set information into.

Return Value:

    S_OK            - Storage set.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    GUID guid = GetCoClassID();
    return Retrieve( (const void*) &guid, sizeof(CLSID), lpMedium );
}

HRESULT
CSakData::RetrieveNodeTypeStringData(
    LPSTGMEDIUM lpMedium
    )
/*++

Routine Description:

    Retrieve from a dataobject with the node type object in GUID string format

Arguments:

    lpMedium        - Storage to set information into.

Return Value:

    S_OK            - Storage set.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    CWsbStringPtr guidString = cGuidHsmCom;
    return Retrieve( guidString, ((wcslen( guidString ) + 1 ) * sizeof(wchar_t)), lpMedium );
}


HRESULT
CSakData::Retrieve(
    IN  const void* pBuffer,
    IN  DWORD       len,
    OUT LPSTGMEDIUM lpMedium)
/*++

Routine Description:

    Retrieve FROM a dataobject INTO a lpMedium. The data object can be one of
    several types of data in it (nodetype, nodetype string, display name).
    This function moves data from pBuffer to the lpMedium->hGlobal

Arguments:

    pBuffer         - Buffer to copy contents out of.

    len             - Length of buffer in bytes.

    lpMedium        - Storage to set information into.

Return Value:

    S_OK            - Storage set.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    HRESULT hr = S_OK;

    try {

        //
        // Check Parameters
        //

        WsbAffirmPointer( pBuffer );
        WsbAffirmPointer( lpMedium );
        WsbAffirm( lpMedium->tymed == TYMED_HGLOBAL, E_FAIL );

        //
        // Create the stream on the hGlobal passed in. When we write to the stream,
        // it simultaneously writes to the hGlobal the same information.
        //

        CComPtr<IStream> lpStream;
        WsbAffirmHr( CreateStreamOnHGlobal( lpMedium->hGlobal, FALSE, &lpStream ) );

        //
        // Write 'len' number of bytes from pBuffer into the stream. When we write
        // to the stream, it simultaneously writes to the global memory we
        // associated it with above.
        //

        ULONG numBytesWritten;
        WsbAffirmHr( lpStream->Write( pBuffer, len, &numBytesWritten ) );

    } WsbCatch( hr );

    return( hr );
}




///////////////////////////////////////////////////////////////////////
//                 ISakSnapAsk
///////////////////////////////////////////////////////////////////////


STDMETHODIMP
CSakData::GetHsmName(
    OUT OLECHAR ** pszName OPTIONAL
    )
/*++

Routine Description:

    Retrieves the IUnknown pointer of a UI node given the node type.
    This will return the first node found of this type.

Arguments:

    pszName - Return of the name of the computer (can be NULL).

Return Value:

    S_OK - Managing remote machine - computer name given.

    S_FALSE - Managing local machine - *pszName set to local name.

--*/
{
    WsbTraceIn( L"CSakData::GetHsmName", L"pszName = <0x%p>", pszName );

    HRESULT hr = S_OK;

    try {

        CWsbStringPtr name = m_HsmName;

        if( m_ManageLocal ) {

            hr = S_FALSE;

        }

        if( pszName ) {

            WsbAffirmHr( name.GiveTo( pszName ) );

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::GetHsmName", L"hr = <%ls>, *pszName = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( pszName ) );
    return( hr );
}


STDMETHODIMP
CSakData::GetNodeOfType(
    IN  REFGUID nodetype,
    OUT ISakNode** ppNode
    )
/*++

Routine Description:

    Retrieves the IUnknown pointer of a UI node given the node type.
    This will return the first node found of this type.

Arguments:

    nodetype - The GUID node type to look for.

    ppUiNode - returned IUnknown interface.

Return Value:

    S_OK - Found.

    S_FALSE - No Error, not found.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::GetNodeOfType", L"nodetype = <%ls>, ppUiNode = <0x%p>", WsbGuidAsString( nodetype ), ppNode );

    HRESULT hr = S_OK;

    try {

        //
        // Verify Params
        //

        WsbAffirmPointer( ppNode );

        *ppNode = NULL;

        //
        // Call on base node to search down the node tree.
        // Save result, verify no error
        //
        CComPtr<ISakNode> pBaseHsm;
        WsbAffirmHr( m_pRootNode.QueryInterface( &pBaseHsm ) );

        hr = pBaseHsm->FindNodeOfType( nodetype, ppNode );
        WsbAffirmHr( hr );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::GetNodeOfType", L"hr = <%ls>, *ppNode = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppNode ) );
    return( hr );
}


STDMETHODIMP
CSakData::GetHsmServer(
    OUT IHsmServer** ppHsmServer
    )
/*++

Routine Description:

    Retrieve an interface pointer to the HSM server the snapin
    is managing.

Arguments:

    ppHsmServer - returned HSM server interface pointer.

Return Value:

    S_OK - Return fine.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::GetHsmServer", L"ppHsmServer = <0x%p>", ppHsmServer );

    HRESULT hr = S_OK;

    try {

        //
        // Check Params
        //
        WsbAffirmPointer( ppHsmServer );
        *ppHsmServer = 0;

        WsbAffirmHrOk( AffirmServiceConnection( HSMCONN_TYPE_HSM ) );

        //
        // The connection should now be valid
        //
        WsbAffirmPointer( m_pHsmServer );

        //
        // Return the connection to the caller
        //
        m_pHsmServer.CopyTo( ppHsmServer );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::GetHsmServer", L"hr = <%ls>, *ppHsmServer = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppHsmServer ) );
    return( hr );
}


STDMETHODIMP
CSakData::GetRmsServer(
    OUT IRmsServer** ppRmsServer
    )
/*++

Routine Description:

    Retrieve an interface pointer to the RMS server the snapin
    is managing.

Arguments:

    ppRmsServer - returned HSM server interface pointer.

Return Value:

    S_OK - Return fine.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::GetRmsServer", L"ppRmsServer = <0x%p>", ppRmsServer );

    HRESULT hr = S_OK;

    try {

        //
        // Check Params
        //

        WsbAffirmPointer( ppRmsServer );
        *ppRmsServer = 0;

        WsbAffirmHrOk( AffirmServiceConnection( HSMCONN_TYPE_RMS ) );

        //
        // We should now be connected
        //
        WsbAffirmPointer( m_pRmsServer );
        m_pRmsServer.CopyTo( ppRmsServer );

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::GetRmsServer", L"hr = <%ls>, *ppRmsServer = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppRmsServer ) );
    return( hr );
}

STDMETHODIMP
CSakData::GetFsaServer(
    OUT IFsaServer** ppFsaServer
    )
/*++

Routine Description:

    Retrieve an interface pointer to the Fsa server the snapin
    is managing.

Arguments:

    ppFsaServer - returned HSM server interface pointer.

Return Value:

    S_OK - Return fine.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::GetFsaServer", L"ppFsaServer = <0x%p>", ppFsaServer );

    HRESULT hr = S_OK;

    try {

        //
        // Check Params
        //

        WsbAffirmPointer( ppFsaServer );
        *ppFsaServer = 0;

        WsbAffirmHrOk( AffirmServiceConnection( HSMCONN_TYPE_FSA ) );

        WsbAffirmPointer( m_pFsaServer );
        m_pFsaServer.CopyTo( ppFsaServer );

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::GetFsaServer", L"hr = <%ls>, *ppFsaServer = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppFsaServer ) );
    return( hr );
}

STDMETHODIMP
CSakData::ShowPropertySheet(
    IN ISakNode* pNode,
    IN IDataObject* pDataObject,
    IN INT       initialPage
    )
/*++

Routine Description:

    Create a property sheet for this node with the given page displayed
    on top

Arguments:

    pNode - node to show property sheet for

    initialPage - 0 based index of initial page to show

Return Value:

    S_OK - Return fine.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::ShowPropertySheet", L"pNode = <0x%p>, initialPage = <%d>", pNode, initialPage );

    HRESULT hr = S_OK;
    HRESULT hrInternal = S_OK;

    try {

        WsbAffirmPointer( pNode );

        //
        // Get the property sheet provider interface from IConsole
        //
        CComPtr <IPropertySheetProvider> pProvider;
        WsbAffirmHr( m_pConsole.QueryInterface( &pProvider ) );

        //
        // Get the component data pointer
        //
        CComPtr <IComponent> pComponent;
        pComponent     = (IComponent *) this;

        //
        // If the sheet is already loaded, just show it
        //
        hrInternal = pProvider->FindPropertySheet( 0, pComponent, pDataObject );

        if( hrInternal != S_OK ) {

            //
            // Not loaded, create it
            //
            CComPtr<ISakNodeProp> pNodeProp;
            WsbAffirmHr( RsQueryInterface( pNode, ISakNodeProp, pNodeProp ) );

            CWsbBstrPtr pszName;
            WsbAffirmHr( pNodeProp->get_DisplayName( &pszName ) );

            //
            // If multiselect, append ellipses
            //
            if( IsDataObjectMultiSelect( pDataObject ) == S_OK ) {

                pszName.Append( L", ...");

            }

            //
            // Create the property sheet
            //
            WsbAffirmHr( pProvider->CreatePropertySheet (pszName, TRUE, 0, pDataObject, 0 ) );

            //
            // Tell the IComponentData interface to add pages
            //
            CComPtr <IUnknown> pUnkComponentData;
            pUnkComponentData = (IUnknown *) (IComponentData*) this;
            
            WsbAffirmHr( pProvider->AddPrimaryPages( pUnkComponentData, TRUE, 0, TRUE ) );
            WsbAffirmHr( pProvider->Show( 0, initialPage ) );
        }
    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::ShowPropertySheet", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP
CSakData::RefreshNode(
    IN ISakNode* pNode
    )
/*++

Routine Description:

    Refresh scope pane from this node on down

Arguments:

    pNode - node to refresh

Return Value:

    S_OK - Return fine.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::RefreshNode", L"pNode = <0x%p>", pNode );

    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( m_pWnd->GetSafeHwnd( ) );

        //
        // Post it to handle later
        //
        MMC_COOKIE cookie;
        WsbAffirmHr( GetCookieFromBaseHsm( pNode, &cookie ) );
        m_pWnd->PostRefreshNode( cookie );

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::RefreshNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakData::InternalRefreshNode(
    IN MMC_COOKIE Cookie
    )
/*++

Routine Description:

    Refresh scope pane from this node on down.

Arguments:

    pNode - node to refresh

Return Value:

    S_OK - Return fine.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::InternalRefreshNode", L"Cookie = <0x%p>", Cookie );

    HRESULT hr = S_OK;

    try {

        //
        // Decode the node, make sure still exists
        //
        CComPtr<ISakNode> pNode;
        WsbAffirmHr( GetBaseHsmFromCookie( Cookie, &pNode ) );

        //
        // Recursively update tree
        //
        WsbAffirmHr( RefreshNodeEx( pNode ) );

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::InternalRefreshNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakData::RefreshNodeEx(
    IN ISakNode* pNode
    )
/*++

Routine Description:

    Refresh scope pane from this node on down. This is recursively called.

Arguments:

    pNode - node to refresh

Return Value:

    S_OK - Return fine.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::RefreshNodeEx", L"pNode = <0x%p>", pNode );

    HRESULT hr = S_OK;

    try {

        //
        // Refresh this node
        //
        WsbAffirmHr( pNode->RefreshObject( ) );

        //
        // Refresh Icon and Text if container
        //
        if( S_OK == pNode->IsContainer( ) ) {

            SCOPEDATAITEM sdi;
            ZeroMemory( &sdi, sizeof sdi );
            sdi.mask        = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE;

            WsbAffirmHr( pNode->GetScopeID( &sdi.ID ) );

            sdi.displayname = MMC_CALLBACK;

            WsbAffirmHr( pNode->GetScopeCloseIcon( m_State, &sdi.nImage ) );
            WsbAffirmHr( pNode->GetScopeOpenIcon( m_State, &sdi.nOpenImage ) );

            WsbAffirmHr( m_pNameSpace->SetItem( &sdi ) );

        }
        //
        // If this is a container with dynamic children, then we
        // want to just cause our contents to be recreated
        //
        if( S_OK == pNode->HasDynamicChildren( ) ) {

            WsbAffirmHr( FreeEnumChildren( pNode ) );

            WsbAffirmHr( pNode->InvalidateChildren() )
            WsbAffirmHr( EnsureChildrenAreCreated( pNode ) );

            HSCOPEITEM scopeID;
            WsbAffirmHr( pNode->GetScopeID( &scopeID ) );
            WsbAffirmHr( EnumScopePane( pNode, (HSCOPEITEM)( scopeID ) ) );

        } else {

            //
            // Loop over the children and call
            //
            CComPtr<IEnumUnknown> pEnum;
            if( ( pNode->EnumChildren( &pEnum ) ) == S_OK ) {

                CComPtr<ISakNode> pChildNode;
                CComPtr<IUnknown> pUnk;
                while( S_OK == pEnum->Next( 1, &pUnk, NULL ) ) {

                    WsbAffirmHr( pUnk.QueryInterface( &pChildNode ) );

                    WsbAffirmHr( RefreshNodeEx( pChildNode ) );

                    //
                    // must release even for smart pointer because of re-assign.
                    //
                    pChildNode.Release( );
                    pUnk.Release( );

                }

            }

        }

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::RefreshNodeEx", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakData::InternalUpdateAllViews(
    IN MMC_COOKIE Cookie 
    )
/*++

Routine Description:
    Calls MMC to update all views

Arguments:

    pUnkNode - node to refresh

Return Value:

    S_OK - Return fine.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::InternalUpdateAllViews", L"Cookie = <0x%p>", Cookie );

    HRESULT hr = S_OK;

    try {

        //
        // Decode the node
        //
        CComPtr <IDataObject> pDataObject;
        WsbAffirmHr( GetDataObjectFromCookie( Cookie, &pDataObject ) );

        //
        // Call MMC
        //
        WsbAffirmHr( m_pConsole->UpdateAllViews( pDataObject, 0L, 0L ) );

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::InternalUpdateAllViews", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}




STDMETHODIMP
CSakData::UpdateAllViews (
    IN ISakNode* pNode
    )
/*++

Routine Description:
    Calls MMC to update all views

Arguments:

    pUnkNode - node to refresh

Return Value:

    S_OK - Return fine.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::UpdateAllViews", L"pNode = <0x%p>", pNode );

    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( m_pWnd->GetSafeHwnd( ) );

        //
        // Post it to handle later
        //
        MMC_COOKIE cookie;
        WsbAffirmHr( GetCookieFromBaseHsm( pNode, &cookie ) );
        m_pWnd->PostUpdateAllViews( cookie );

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::UpdateAllViews", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}







///////////////////////////////////////////////////////////////////////
//                 Node type manipulation routines
///////////////////////////////////////////////////////////////////////


HRESULT
CSakData::GetBaseHsmFromDataObject (
    IN  IDataObject *pDataObject, 
    OUT ISakNode **ppBaseHsm,
    OUT IEnumGUID **ppEnumObjectId,
    OUT IEnumUnknown **ppEnumUnkNode
    )

/*++

Routine Description:

    Retrieves the ISakNode for the object referenced by the 
    given data object.

Arguments:

    pDataObject - identifies the node to be worked on.

    ppBaseHSM - returned IBaseHSM interface.

    ppEnumObjectId - returned interface to enumeration of object Ids. Can be NULL.
        
Return Value:

    S_OK         - Node found and returned.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakData::GetBaseHsmFromDataObject",
        L"pDataObject = <0x%p>, ppBaseHsm = <0x%p>, ppEnumObjectId = <0x%p>", 
        pDataObject, ppBaseHsm, ppEnumObjectId );

    HRESULT hr = S_OK;

    try {

        *ppBaseHsm = 0;
        if ( ppEnumObjectId ) *ppEnumObjectId = NULL;

        //
        // Get the base hsm pointer depending on the data object type
        //
        if (IsDataObjectMs( pDataObject ) == S_OK) {

            WsbAffirmHr( GetBaseHsmFromMsDataObject( pDataObject, ppBaseHsm, ppEnumObjectId, ppEnumUnkNode ) );

        } else if (IsDataObjectOt( pDataObject ) == S_OK) {

            WsbAffirmHr( GetBaseHsmFromOtDataObject( pDataObject, ppBaseHsm, ppEnumObjectId, ppEnumUnkNode ) );

        } else { // Assume single select

            WsbAffirmPointer( pDataObject );
            WsbAffirmHr( RsQueryInterface2( pDataObject, ISakNode, ppBaseHsm ) );

        }

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::GetBaseHsmFromDataObject", L"hr = <%ls>, *ppBaseHsm = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppBaseHsm ) );
    return ( hr );
}

HRESULT
CSakData::GetBaseHsmFromMsDataObject (
    IN  IDataObject  *pDataObject, 
    OUT ISakNode     **ppBaseHsm,
    OUT IEnumGUID    **ppEnumObjectId,
    OUT IEnumUnknown **ppEnumUnkNode
    )

/*++

Routine Description:

    Retrieves the ISakNode for the object referenced by the 
    given data object.

Arguments:

    pDataObject - identifies the node to be worked on.

    ppBaseHSM - returned IBaseHSM interface.

Return Value:

    S_OK         - Node found and returned.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakData::GetBaseHsmFromMsDataObject", L"pDataObject = <0x%p>, ppBaseHsm = <0x%p>", pDataObject, ppBaseHsm );

    HRESULT hr = S_OK;

    try {

        // We've got an MMC mutli-select data object.  Get the first 
        // data object from it's array of data objects

        FORMATETC fmt = {(CLIPFORMAT)m_cfMultiSelect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        STGMEDIUM stgm = {TYMED_HGLOBAL, NULL};

        WsbAffirmHr ( pDataObject->GetData( &fmt, &stgm ) == S_OK );
        DWORD count;
        memcpy( &count, stgm.hGlobal, sizeof (DWORD) );
        if ( count > 0 ) {

            //
            // The following code is admittedly UGLY
            // We have a data stream where we need to skip past the 
            // first DWORD count and grab an interface pointer.
            // Other snapins code does it as follows:

//            IDataObject * pDO;
//            memcpy( &pDO, (DWORD *) stgm.hGlobal + 1, sizeof(IDataObject*) );

            //
            // However, since this code does an indirect cast (via memcpy) 
            // from DWORD to IDataObject*, and does not keep a true reference
            // on the interface pointer, we will use a smart pointer.
            // The (DWORD*) and +1 operation bump our pointer past the count.
            // We then need to grab the next bytes in the buffer and use them
            // as a IDataObject *.
            //
            CComPtr<IDataObject> pOtDataObject;
            pOtDataObject = *( (IDataObject**)( (DWORD *) stgm.hGlobal + 1 ) );

            //
            // Note: When we can be extended we need to check to see if this is one of ours
            //
            WsbAffirmHr( GetBaseHsmFromOtDataObject ( pOtDataObject, ppBaseHsm,  ppEnumObjectId, ppEnumUnkNode ) );
        }
    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::GetBaseHsmFromMsDataObject", L"hr = <%ls>, *ppBaseHsm = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppBaseHsm ) );
    return ( hr );
}

HRESULT
CSakData::GetBaseHsmFromOtDataObject (
    IN  IDataObject     *pDataObject, 
    OUT ISakNode        **ppBaseHsm,
    OUT IEnumGUID       **ppEnumObjectId,
    OUT IEnumUnknown    **ppEnumUnkNode
    )

/*++

Routine Description:

    Retrieves the ISakNode for the object referenced by the 
    given data object.

Arguments:

    pDataObject - identifies the node to be worked on.

    ppBaseHSM - returned IBaseHSM interface.

Return Value:

    S_OK         - Node found and returned.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakData::GetBaseHsmFromOtDataObject", L"pDataObject = <0x%p>, ppBaseHsm = <0x%p>", pDataObject, ppBaseHsm );

    HRESULT hr = S_OK;

    try {

        // we've got an object types mutli-select data object.  Get the first node selected 
        // from the data object.
        CComPtr<IMsDataObject> pMsDataObject;
        CComPtr<IUnknown>      pUnkNode;
        CComPtr<IEnumUnknown>  pEnumUnkNode;
        CComPtr<ISakNode>      pNode;

        WsbAffirmHr( RsQueryInterface( pDataObject, IMsDataObject, pMsDataObject ) );
        WsbAffirmHr( pMsDataObject->GetNodeEnumerator( &pEnumUnkNode ) );
        WsbAffirmHr( pEnumUnkNode->Next( 1, &pUnkNode, NULL ) );
        WsbAffirmHr( pUnkNode.QueryInterface( &pNode ) );
        WsbAffirmHr( pEnumUnkNode->Reset() );  // This enumeration is passed on, so we must reset it

        if( ppBaseHsm ) {

            pNode.CopyTo( ppBaseHsm );

        }

        if( ppEnumObjectId ) {

            pMsDataObject->GetObjectIdEnumerator( ppEnumObjectId );

        }

        if( ppEnumUnkNode ) {

            pEnumUnkNode.CopyTo( ppEnumUnkNode );

        }

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::GetBaseHsmFromOtDataObject", L"hr = <%ls>, *ppBaseHsm = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppBaseHsm ) );
    return ( hr );
}

HRESULT
CSakData::GetDataObjectFromBaseHsm (
    IN  ISakNode *    pBaseHsm,
    OUT IDataObject* *ppDataObject
    )

/*++

Routine Description:

    Retrieves the dataobject for the object referenced by the 
    given IBaseHSM.

Arguments:

    pBaseHsm - identifies the node to be worked on.

    ppDataObject - returned IDataObject interface.

Return Value:

    S_OK         - Node found and returned.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakData::GetDataObjectFromBaseHsm", L"pBaseHsm = <0x%p>, ppDataObject = <0x%p>", pBaseHsm, ppDataObject );

    HRESULT hr = S_OK;

    try {

        *ppDataObject = 0;
        if( pBaseHsm ) {

            WsbAffirmHr( RsQueryInterface2( pBaseHsm, IDataObject, ppDataObject ) );

        }

    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::GetDataObjectFromBaseHsm", L"hr = <%ls>, *ppDataObject = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppDataObject ) );
    return ( hr );
}


HRESULT
CSakData::GetBaseHsmFromCookie (
    IN  MMC_COOKIE          Cookie, 
    OUT ISakNode **   ppBaseHsm
    )

/*++

Routine Description:

    Retrieves the ISakNode for the object referenced by the 
    given cookie.

Arguments:

    Cookie       - identifies the node to be worked on.

    ppBaseHsm    - returned ISakNode interface.

Return Value:

    S_OK         - Node found and returned.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::GetBaseHsmFromCookie", L"Cookie = <0x%p>, ppBaseHsm = <0x%p>", Cookie, ppBaseHsm );

    HRESULT hr = S_OK;

    try {

        //
        // Cookies are pointers to CSakDataNodePrivate classes, which
        // contain smart pointers to their nodes.
        // NULL cookie means root snapin.
        //

        if( ( 0 == Cookie ) || ( EXTENSION_RS_FOLDER_PARAM == Cookie ) ) {

            WsbAffirmHr( GetCookieFromBaseHsm( m_pRootNode, &Cookie ) );

        }

        WsbAffirmPointer( Cookie );

        CSakDataNodePrivate* pNodePriv = (CSakDataNodePrivate*)Cookie;
        WsbAffirmHr( CSakDataNodePrivate::Verify( pNodePriv ) );

        WsbAffirmHr( pNodePriv->m_pNode.QueryInterface( ppBaseHsm ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::GetBaseHsmFromCookie", L"hr = <%ls>, *ppBaseHsm = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppBaseHsm ) );
    return ( hr );
}


HRESULT
CSakData::GetCookieFromBaseHsm (
    IN  ISakNode *    pNode,
    OUT MMC_COOKIE *        pCookie
    )
/*++

Routine Description:

    Retrieves the cookie for the object referenced by the 
    given IBaseHSM.

Arguments:

    pBaseHsm     - identifies the node to be worked on.

    pCookie      - returned Cookie.

Return Value:

    S_OK         - Node found and returned.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakData::GetCookieFromBaseHsm", L"pNode = <0x%p>, pCookie = <0x%p>", pNode, pCookie );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pNode );

        //
        // Ask the node for our private data back
        //
        RS_PRIVATE_DATA data;

        WsbAffirmHr( pNode->GetPrivateData( &data ) );

        if( !data ) {

            CSakDataNodePrivate *pNodePriv = new CSakDataNodePrivate( pNode );
            WsbAffirmAlloc( pNodePriv );
            WsbAffirmHr( pNode->GetPrivateData( &data ) );

        }

        WsbAffirmHr( CSakDataNodePrivate::Verify( (CSakDataNodePrivate*)data ) );

        *pCookie = (MMC_COOKIE)data;

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::GetCookieFromBaseHsm", L"hr = <%ls>, *pCookie = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)pCookie ) );
    return( hr );
}


HRESULT
CSakData::GetDataObjectFromCookie (
    IN  MMC_COOKIE          Cookie, 
    OUT IDataObject **ppDataObject
    )

/*++

Routine Description:

    Retrieves the IDataObject for the object referenced by the 
    given cookie.

Arguments:

    Cookie       - identifies the node to be worked on.

    ppDataObject - returned IDataObject interface.

Return Value:

    S_OK         - Node found and returned.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::GetDataObjectFromCookie", L"Cookie = <0x%p>, ppDataObject = <0x%p>", Cookie, ppDataObject );

    HRESULT hr = S_OK;

    try {

        //
        // Check Params
        //
        WsbAffirmPointer( ppDataObject );

        //
        // Use GetBaseHsmFromCookie to resolve to node object
        //
        CComPtr<ISakNode> pNode;
        WsbAffirmHr( GetBaseHsmFromCookie( Cookie, &pNode ) );
        WsbAffirmPointer( pNode );

        WsbAffirmHr( RsQueryInterface2( pNode, IDataObject, ppDataObject ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::GetDataObjectFromCookie", L"hr = <%ls>, *ppDataObject = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppDataObject ) );
    return( hr );
}


HRESULT
CSakData::SetContextType(
    IDataObject*      pDataObject,
    DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Set the MMC context type in the data object for later retrieval by any method
    which receives this dataobject (CCT_SNAPIN_MANAGER, CCT_SCOPE, CCT_RESULT, etc).

Arguments:

    pDataObject  - identifies the node to be worked on.

Return Value:

    S_OK         - Node found and returned.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::SetContextType", L"pDataObject = <0x%p>, type = <%d>", pDataObject, type );

    // Prepare structures to store an HGLOBAL from the dataobject.
    // Allocate memory for the stream which will contain the SakSnap GUID.
    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = { (CLIPFORMAT)CSakNode::m_cfInternal, NULL, 
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    HRESULT hr = S_OK;

    try {

        // Allocate space in which to place the data
        stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, sizeof(INTERNAL));
        WsbAffirm( stgmedium.hGlobal != NULL, E_POINTER );

        // Put the data into the global memory. This is what will eventually be 
        // copied down into the member variables of the dataobject, itself.
        memcpy(&stgmedium.hGlobal, &type, sizeof(type));

        // Copy this data into the dataobject.
        WsbAffirmHr( pDataObject->SetData(&formatetc, &stgmedium, FALSE ));

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::SetContextType", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakData::InitializeRootNode(
    void
    )
/*++

Routine Description:

    The initialization of the root node is separate in order to
    allow reconnect multiple times (as needed). This is the
    implementation of initialization.

Arguments:

    pDataObject  - identifies the node to be worked on.

Return Value:

    S_OK         - Node found and returned.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::InitializeRootNode", L"" );
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    HRESULT hr = S_OK;

    try {

        // Make sure the computer name is set in CSakdata if we are managing the local
        // Hsm

        if( m_ManageLocal ) {

            WCHAR computerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
            DWORD dw = MAX_COMPUTERNAME_LENGTH + 1;

            GetComputerName( computerName, &dw );

            m_HsmName = computerName;

        }
        //
        // Initialize the static root node (no recursion. Descendants are NOT created here)
        //

        WsbAffirmPointer( m_pRootNode );

        WsbAffirmHr( m_pRootNode->InitNode( (ISakSnapAsk*)this, NULL, NULL ) );

        //
        // Set the Display Name in the object
        //
        CString fullTitle;

        if( IsPrimaryImpl( ) ) {

            //
            // We're standalone, so show the targeted server
            //
            if( m_ManageLocal ) {

                fullTitle.LoadString( IDS_MANAGE_LOCAL );
        
            } else if( !m_HsmName.IsEmpty( ) ) {

                AfxFormatString1( fullTitle, IDS_HSM_NAME_PREFIX, m_HsmName );
    
            } else {

                fullTitle = HSMADMIN_NO_HSM_NAME;

            }

        } else {

            //
            // We're an extension, so just show app name
            //
            fullTitle.LoadString( AFX_IDS_APP_TITLE );

        }


        // Put the displayname
        CComPtr <ISakNodeProp> pRootNodeProp;
        WsbAffirmHr( RsQueryInterface( m_pRootNode, ISakNodeProp, pRootNodeProp ) );
        WsbAffirmHr( pRootNodeProp->put_DisplayName( (LPWSTR)(LPCWSTR) fullTitle ) );

        WsbAffirmHr( m_pRootNode->RefreshObject() );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::InitializeRootNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakData::AffirmServiceConnection(
    INT ConnType
    )
/*++

Routine Description:
    Validates that the connection to the requested HSM service is still valid.  If not,
    attempts to reconnect to the service.

Arguments:

    ConnType - type of service connection being checked

Return Value:

    S_OK         - Node created and bound to server.

    S_FALSE      - Service has not yet been setup or stopped.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::AffirmServiceConnection", L"" );
    HRESULT hr = S_OK;

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    BOOL          previouslyConnected = ( GetState() == S_OK );
    BOOL          firstTime           = m_FirstTime;
    CString       szMessage;
    CWsbStringPtr computerName;


    try {


        //
        // Handle this first so reentrancy is not a problem
        //
        if( m_FirstTime ) {

            m_FirstTime = FALSE;

        }

        WsbAffirmHr( WsbGetComputerName( computerName ) );

        //
        // See if snapin is supposed to be disabled. If so, then 
        // don't do anything.
        //
        if( m_Disabled ) {

            WsbThrow( RS_E_DISABLED );

        }

        //
        // We want to avoid starting the services if they are stopped.
        // So, check the service state before continuing.
        //
        HRESULT hrCheck;
        {
            //
            // Potentially a long operation - show wait cursor if possible
            //
            CWaitCursor waitCursor;
            hrCheck = WsbCheckService( m_HsmName, APPID_RemoteStorageEngine );
        }
        if( S_FALSE == hrCheck ) {

            //
            // Engine service is not running
            //
            WsbThrow( S_FALSE );

        } else if( ( HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) == hrCheck ) ||
                   ( E_ACCESSDENIED == hrCheck ) ) {

            //
            // Engine is not installed (or at least we can't check
            // because local privs don't allow, but may on a different
            // server)
            //
            // If we are set to "Manage Local" then we will provide the
            // opportunity to look at a different machine
            //
            if( firstTime && m_ManageLocal ) {

                //
                // If we get back "File not found" then the engine was
                // not installed, so we need to ask for a different machine
                // to administer
                //
                hrCheck = RetargetSnapin( );
                WsbAffirmHrOk( hrCheck );


            } else {

                //
                // we want to return the true error if access is denied
                // and can't retarget to another machine without same error
                //
                if( E_ACCESSDENIED == hrCheck ) {

                    WsbThrow( hrCheck );

                } else {

                    WsbThrow( RS_E_NOT_INSTALLED );

                }

            }
        }

        //
        // Is the current connection still valid?
        // Test the connection. If it's OK, return it.  If not,
        // re-establish the connection.
        //
        HRESULT hrConnected = VerifyConnection( ConnType );
        WsbAffirmHr( hrConnected );
        
        //
        // If it looks like we're not connected, then connect
        //
        if( S_FALSE == hrConnected ) {
    
            //
            // Connect to engine first and see if we are setup.
            // Don't process any further if not setup.
            //
            WsbAffirmHr( RawConnect( HSMCONN_TYPE_HSM ) );
            HRESULT hrSetup = RsIsRemoteStorageSetupEx( m_pHsmServer );
            WsbAffirmHr( hrSetup );

            if( S_FALSE == hrSetup ) {

                //
                // Not setup - see if we are local
                //
                if( computerName.IsEqual( m_HsmName ) && firstTime ) {

                    hrSetup = RunSetupWizard( m_pHsmServer );

                }

                //
                // By this point, if hrSetup is not S_OK,
                // we are not configured.
                //
                if( S_OK != hrSetup ) {

                    WsbThrow( RS_E_NOT_CONFIGURED );

                }

            }

            //
            // At this point we should be setup and ready to connect
            //
            WsbAffirmHrOk( RawConnect( ConnType ) );

        }

        //
        // We're connected
        //
        SetState( TRUE );

    } WsbCatchAndDo( hr,

        //
        // Need to decide if we should ignore the error or not.
        // Note that even if the error is ignored here, its 
        // returned still to the caller
        //
        BOOL ignoreError = FALSE;

        //
        // if RMS error of not ready, and we received this last time RMS 
        // connection was made, ignore the error.
        //
        if( HSMCONN_TYPE_RMS == ConnType ) {
        
            HRESULT hrPrevConnect = m_HrRmsConnect;
            m_HrRmsConnect = hr;

            if( ( RsIsRmsErrorNotReady( hr ) == S_OK ) &&
                ( RsIsRmsErrorNotReady( hrPrevConnect ) == S_OK ) ) {

                ignoreError = TRUE;

            }

        }

        if( !ignoreError ) {

            //
            // Set up state conditions before anything else
            //
            ClearConnections( );
            SetState( FALSE );

            //
            // If we were previously connected or this is the first connect,
            // report the error
            //
            if( previouslyConnected || firstTime ) {

                //
                // Temporarily set to disable so we don't recurse when dialog is up
                //
                BOOL disabled = m_Disabled;
                m_Disabled = TRUE;

                CString msg;
                switch( hr ) {

                case S_OK:
                    //
                    // Connected OK - no error
                    //
                    break;
            
                case RS_E_DISABLED:
                    //
                    // Disabled - just ignore
                    //
                    break;
            
                case S_FALSE:
                    //
                    // Service not running
                    //
                    AfxFormatString1( msg, IDS_ERR_SERVICE_NOT_RUNNING, m_HsmName );
                    AfxMessageBox( msg, RS_MB_ERROR );
                    break;

                case RS_E_NOT_CONFIGURED:
                    //
                    // If remote, let user know it needs to be set up locally
                    //
                    if( ! computerName.IsEqual( m_HsmName ) ) {

                        AfxFormatString1( msg, IDS_ERR_SERVICE_NOT_SETUP_REMOTE, m_HsmName );
                        AfxMessageBox( msg, RS_MB_ERROR );

                    }
                    break;

               case RS_E_NOT_INSTALLED:
                    //
                    // Give indication of where this can be setup
                    //
                    AfxFormatString1( msg, IDS_ERR_SERVICE_NOT_INSTALLED, m_HsmName );
                    AfxMessageBox( msg, RS_MB_ERROR );
                    break;

               case RS_E_CANCELLED:
                    //
                    // User cancelled - there's no error to notify
                    //
                    break;

                default:
                    //
                    // Report the error
                    //
                    AfxFormatString1( msg, IDS_ERR_SERVICE_NOT_CONNECTING, m_HsmName );
                    AfxMessageBox( msg, RS_MB_ERROR );
                    if( HSMCONN_TYPE_RMS == ConnType ) {

                        disabled = TRUE;

                    }

                }

                //
                // Restore disabledness
                //
                m_Disabled = disabled;
            }

        }
    );

    //
    // Need to track RMS connections separately
    //
    if( HSMCONN_TYPE_RMS == ConnType ) {

        m_HrRmsConnect = hr;

    }

    //
    // If our state of "Connection" changed, cause a refresh
    //
    BOOL connected = ( GetState() == S_OK );
    if( ( connected != previouslyConnected ) && ( ! firstTime ) ) {

        RefreshNode( m_pRootNode );

    }

    WsbTraceOut( L"CSakData::AffirmServiceConnection", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakData::VerifyConnection(
    INT ConnType
    )
/*++

Routine Description:

    Verify whether the indicated connection is still good or not.
    Does not attempt to reconnect.

Arguments:

    ConnType - type of service connection being checked

Return Value:

    S_OK         - Connected.

    S_FALSE      - Not connected. 

    E_*          - Error occurred while checking

--*/
{
    WsbTraceIn( L"CSakData::VerifyConnection", L"" );
    HRESULT hr = S_FALSE;

    try {

        switch( ConnType ) {
    
        case HSMCONN_TYPE_HSM:
            if( m_pHsmServer ) {
    
                GUID id;
                WsbAffirmHr( m_pHsmServer->GetID( &id ) );
                hr = S_OK;
    
            }
            break;
    
        case HSMCONN_TYPE_RMS:
            if( m_pRmsServer ) {
    
                WsbAffirmHr( m_pRmsServer->IsReady( ) );
                hr = S_OK;
    
            }
            break;
    
        case HSMCONN_TYPE_FSA:
            if( m_pFsaServer ) {
    
                CWsbStringPtr pszName;
                WsbAffirmHr( m_pFsaServer->GetName( &pszName, 0 ) );
                hr = S_OK;
    
            }
            break;
        }

    } WsbCatchAndDo( hr,
        
        ClearConnections( );
        
    );
    
    WsbTraceOut( L"CSakData::VerifyConnection", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakData::RawConnect(
    INT ConnType
    )
/*++

Routine Description:

    Do low level connection to service specified

Arguments:

    ConnType - type of service connection

Return Value:

    S_OK         - Connected.

    E_*          - Error occurred while checking

--*/
{
    WsbTraceIn( L"CSakData::RawConnect", L"" );
    HRESULT hr = S_OK;

    try {

        
        //
        // Potentially a long operation - show wait cursor if possible
        //
        CWaitCursor waitCursor;

        switch( ConnType ) {
       
        case HSMCONN_TYPE_HSM:
            if( ! m_pHsmServer ) {

                WsbAffirmHr( HsmConnectFromName( HSMCONN_TYPE_HSM, m_HsmName, IID_IHsmServer, (void**)&m_pHsmServer ) );

            }
            break;
       
        case HSMCONN_TYPE_RMS:
            if( ! m_pRmsServer ) {

                CComPtr<IHsmServer> pHsm;
                WsbAffirmHr( HsmConnectFromName( HSMCONN_TYPE_HSM, m_HsmName, IID_IHsmServer, (void**)&pHsm ) );
                WsbAffirmPointer(pHsm);
                WsbAffirmHr(pHsm->GetHsmMediaMgr(&m_pRmsServer));
                WsbAffirmHrOk( VerifyConnection( HSMCONN_TYPE_RMS ) );

            }
            break;
       
        case HSMCONN_TYPE_FSA:
            if( ! m_pFsaServer ) {

                CWsbStringPtr LogicalName( m_HsmName );
       
                //
                //  FSA confuses things by having a
                // extra level for the "type"
                //
                LogicalName.Append( "\\NTFS" );
                WsbAffirmHr( HsmConnectFromName( HSMCONN_TYPE_FSA, LogicalName, IID_IFsaServer, (void**)&m_pFsaServer ) );

            }
            break;
        }

    } WsbCatch( hr );
    
    WsbTraceOut( L"CSakData::RawConnect", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakData::ClearConnections(
    )
/*++

Routine Description:

    Clear cached connections

Arguments:

    none.

Return Value:

    S_OK         - Cleared.

    E_*          - Error occurred while checking

--*/
{
    WsbTraceIn( L"CSakData::ClearConnections", L"" );
    HRESULT hr = S_OK;

    try {

        m_pHsmServer = 0;
        m_pRmsServer = 0;
        m_pFsaServer = 0;

    } WsbCatch( hr );
    
    WsbTraceOut( L"CSakData::ClearConnections", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakData::RunSetupWizard(
    IHsmServer * pServer
    )
/*++

Routine Description:

    Run the setup wizard

    Handles disabling / enabling as needed

Arguments:

    pServer - interface to engine

Return Value:

    S_OK         - Setup Correctly.

    S_FALSE      - Canceled

    E_*          - Error occurred while setting up

--*/
{
    WsbTraceIn( L"CSakData::RunSetupWizard", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // use wizard to create manage volume
        //
        CComObject<CQuickStartWizard>* pWizard = new CComObject<CQuickStartWizard>;
        WsbAffirmAlloc( pWizard );

        CComPtr<ISakWizard> pSakWizard = (ISakWizard*)pWizard;
        WsbAffirmHr( CreateWizard( pSakWizard ) );

        //
        // RS_E_CANCELED indicates canceled, and FAILEd indicates error.
        // If so, then throw "Not set up"
        //
        if( S_OK != pWizard->m_HrFinish ) {

            WsbThrow( S_FALSE );

        }

        WsbAffirmHrOk( RsIsRemoteStorageSetupEx( pServer ) );

    } WsbCatch( hr );
    
    WsbTraceOut( L"CSakData::RunSetupWizard", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakData::RetargetSnapin(
    )
/*++

Routine Description:

    Run the small choose server dialog

Arguments:

    none.

Return Value:

    S_OK         - Setup Correctly.

    S_FALSE      - Canceled

    E_*          - Error occurred while changing

--*/
{
    WsbTraceIn( L"CSakData::RetargetSnapin", L"" );
    HRESULT hr = S_OK;

    try {

        if( IsPrimaryImpl( ) ) {

            //
            // Bring up dialog
            //
            CChooseHsmQuickDlg dlg;
            dlg.m_pHsmName = &m_HsmName;
            if( IDOK == dlg.DoModal( ) ) {

                m_PersistManageLocal = FALSE;
                m_ManageLocal        = FALSE;

                //
                // We want the name shown to be accurate, regardless
                // of whether they targetted to a valid machine.
                // So, re-initialize the root node before going 
                // any further.
                //
                WsbAffirmHr( InitializeRootNode( ) );

                //
                // Make sure we hook up OK. If not, just disable
                // Note that since we set "First" flag at beginning
                // of the block, this will not endlessly recurse
                //
                hr = AffirmServiceConnection( HSMCONN_TYPE_HSM );
                if( FAILED( hr ) ) {

                    Disable( );
                    WsbThrow( hr );

                }
            
            } else {

                //
                // They canceled out, so just disable
                //
                Disable( );
                WsbThrow( RS_E_CANCELLED );

            }

        } else {

            //
            // As extension we don't allow retargeting, so we just disable
            //
            Disable( );
            WsbThrow( S_FALSE );

        }


    } WsbCatch( hr );
    
    WsbTraceOut( L"CSakData::RetargetSnapin", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakData::CreateChildNodes(
    ISakNode* pParentNode
    ) 
/*++

Routine Description:

    Create and initialize the children of an existing COM parent. Currently, this 
    initialization is being done from HSM object.

Arguments:

    pNode        - The node to create the children of.

Return Value:

    S_OK         - Children created.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::CreateChildNodes", L"pParentNode = <0x%p>", pParentNode );
    HRESULT hr = S_OK;

    try {

        //
        // Initialize the child nodes - first delete existing children from UI,
        // then initialize new children into UI. No recursion. Decendents are 
        // NOT created here.
        //

        CComPtr<ISakNode> pNode;
        WsbAffirmHr( RsQueryInterface( pParentNode, ISakNode, pNode ) );
        WsbAffirmHr( pNode->DeleteAllChildren( ) );
        WsbAffirmHr( pNode->CreateChildren( ) );

    } WsbCatch( hr );
    
    WsbTraceOut( L"CSakData::CreateChildNodes", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakData::FreeEnumChildren(
    ISakNode* pParentNode
    )
/*++

Routine Description:

    Recursively (bottom-up) free the SCOPEDATAITEM children of the pParent 
    enumerated node  

Arguments:

    pParentNode  - identifies the node to be worked on.

Return Value:

    S_OK         - Children freed successfully.

    E_UNEXPECTED - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakData::FreeEnumChildren", L"pParentNode = <0x%p>", pParentNode );
    HRESULT hr = S_OK;
    
    try {

        HSCOPEITEM scopeIDParent;
        pParentNode->GetScopeID( &scopeIDParent );

        WsbAffirm( scopeIDParent > 0, E_FAIL )
    
        WsbAffirmHr( m_pNameSpace->DeleteItem( scopeIDParent, FALSE ) );
        pParentNode->SetEnumState( FALSE );

    } WsbCatch (hr);

    WsbTraceOut( L"CSakData::FreeEnumChildren", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// IPersistStream implementation
//

STDMETHODIMP
CSakData::Save( 
    IStream *pStm, 
    BOOL fClearDirty 
    ) 

/*++

Routine Description:

    Save the information we need to reconstruct the root node in the
    supplied stream.

Arguments:

    pStm        I: Console-supplied stream
    fClearDirty I: The console tells us to clear our dirty flag
    
Return Value:

    S_OK         - Saved successfully.
    E_*          - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakData::Save", L"pStm = <0x%p>, fClearDirty", pStm, WsbBoolAsString( fClearDirty ) );

    HRESULT hr = S_OK;

    try {

        ULONG version = HSMADMIN_CURRENT_VERSION;
        WsbAffirmHr( WsbSaveToStream( pStm, version ) );

        if( m_PersistManageLocal ) {

            WsbAffirmHr( WsbSaveToStream( pStm, m_ManageLocal ) );
            CWsbStringPtr pHsmName( m_HsmName );
            WsbAffirmHr( WsbSaveToStream( pStm, pHsmName ) );

        } else {

            WsbAffirmHr( WsbSaveToStream( pStm, (BOOL)TRUE ) );
            CWsbStringPtr pHsmName( "" );
            WsbAffirmHr( WsbSaveToStream( pStm, pHsmName ) );

        }

        // Set the dirty flag
        if( fClearDirty ) ClearDirty( );

    } WsbCatch( hr );


    WsbTraceOut( L"CSakData::Save", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP
CSakData::Load( 
    IStream *pStm
    )
/*++

Routine Description:

    Load the information we need to reconstruct the root node from the
    supplied stream.

Arguments:

    pStm        IConsole-supplied stream
    
Return Value:

    S_OK         - Saved successfully.
    E_*          - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakData::Load", L"pStm = <0x%p>", pStm );

    HRESULT hr = S_OK;
    try {

        ULONG version = 0;
        WsbAffirmHr( WsbLoadFromStream( pStm, &version ) );
        WsbAssert( ( version == 1 ), E_FAIL );

        // Get the flag for local or named HSM
        WsbLoadFromStream( pStm, &m_ManageLocal );
        CWsbStringPtr pHsmName;

        // Get the HSM name ("" for local HSM)
        WsbLoadFromStream( pStm, &pHsmName, 0 );
        m_HsmName = pHsmName;

        // Grab any options from the command line after loading
        InitFromCommandLine( );

        // Set the Hsm name in SakData and HsmCom objects
        WsbAffirmHr( InitializeRootNode() );

        ClearDirty();

    } WsbCatch (hr);

    WsbTraceOut( L"CSakData::Load", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}   

STDMETHODIMP
CSakData::IsDirty(
    void
    )

/*++

Routine Description:

    The console asks us if we are dirty.

Arguments:

    None
    
Return Value:

    S_OK         - Dirty.
    S_FALSE      - Not Dirty. 

--*/
{
    WsbTraceIn( L"CSakData::IsDirty", L"" );

    HRESULT hr = ThisIsDirty() ? S_OK : S_FALSE;

    WsbTraceOut( L"CSakData::IsDirty", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakData::GetSizeMax( 
    ULARGE_INTEGER * /*pcbSize*/
    )

/*++

Routine Description:

    Not currently used by the console

Arguments:

    pcbSize
    
Return Value:

    E_NOTIMPL
--*/

{
    WsbTraceIn( L"CSakData::GetSizeMax", L"" );

    HRESULT hr = E_NOTIMPL;

    WsbTraceOut( L"CSakData::GetSizeMax", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP
CSakData::GetClassID( 
    CLSID *pClassID 
    )
/*++

Routine Description:

    Not currently used by the console

Arguments:

    pClassID  - The class ID for the snapin
    
Return Value:

    S_OK
--*/
{
    WsbTraceIn( L"CSakData::GetClassID", L"pClassID = <0x%p>", pClassID );

    HRESULT hr = S_OK;
    *pClassID = CLSID_HsmAdmin;

    WsbTraceOut( L"CSakData::GetClassID", L"hr = <%ls>, *pClassID = <%ls>", WsbHrAsString( hr ), WsbPtrToGuidAsString( pClassID ) );
    return( hr );
}


/////////////////////////////////////////////////////////////////////////////
//
// Adds images to the consoles image list from the static array
//
HRESULT CSakData::OnAddImages()
{
    HRESULT hr = S_OK;
    HICON hIcon;
    try {

        //
        // Put the images from the static array into the image list
        // for the scope pane
        //

        for( INT i = 0; i < m_nImageCount; i++ ) {
            // Load the icon using the resource Id stored in the
            // static array and get the handle.  

            hIcon = LoadIcon( _Module.m_hInst, 
                MAKEINTRESOURCE( m_nImageArray [i] ) );

            // Add to the Console's Image list
            WsbAffirmHr( m_pImageScope->ImageListSetIcon( (RS_WIN32_HANDLE*)hIcon, i ) );
        }
    } WsbCatch (hr);
    return hr;
}
    

//////////////////////////////////////////////////////////////////////////////////
//
// Description: Add the supplied resource ID to the list of resource IDs for
//      the scope pane.  Returns the index into the array.
//
INT CSakData::AddImage( UINT rId )
{
    INT nIndex = -1;
    if (CSakData::m_nImageCount < RS_SCOPE_IMAGE_ARRAY_MAX) {

        CSakData::m_nImageArray[CSakData::m_nImageCount] = rId;
        nIndex = CSakData::m_nImageCount;
        CSakData::m_nImageCount++;

    }
    return nIndex;
}

void CSakData::SetState (BOOL State)
{
    m_State = State;
}

STDMETHODIMP
CSakData::GetState ()
{
    return ((m_State) ? S_OK : S_FALSE);
}

STDMETHODIMP
CSakData::Disable(
    IN BOOL Disable
    )
{
    WsbTraceIn( L"CSakData::Disable", L"Disable = <%ls>", WsbBoolAsString( Disable ) );

    HRESULT hr = S_OK;
    m_Disabled = Disable ? TRUE : FALSE; // Force values to TRUE or FALSE

    //
    // Make sure state is correct as well
    //
    if( Disable ) {

        SetState( FALSE );

    }

    WsbTraceOut( L"CSakData::Disable", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP
CSakData::IsDisabled(
    )
{
    WsbTraceIn( L"CSakData::IsDisabled", L"" );

    HRESULT hr = m_Disabled ? S_OK : S_FALSE;

    WsbTraceOut( L"CSakData::IsDisabled", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


// Is the dataobject either type of multi-select dataobject?
HRESULT 
CSakData::IsDataObjectMultiSelect   ( IDataObject *pDataObject ) 
{ 
    HRESULT hr = S_OK;

    WsbTraceThreadOff( );

    hr = ( ( (IsDataObjectOt( pDataObject ) ) == S_OK ) || 
        ( (IsDataObjectMs( pDataObject ) ) == S_OK ) ) ? S_OK : S_FALSE;

    WsbTraceThreadOn( );
    return( hr );
}

// Is the dataobject an Object Types dataobject?
HRESULT
CSakData::IsDataObjectOt ( IDataObject *pDataObject )
{
    HRESULT hr = S_FALSE;

    WsbTraceThreadOff( );

    // Is this a mutli-select data object?
    FORMATETC fmt = {(CLIPFORMAT)m_cfObjectTypes, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgm = {TYMED_HGLOBAL, NULL};

    if ( pDataObject->GetData( &fmt, &stgm ) == S_OK ) {
        hr = S_OK;
    }

    ReleaseStgMedium( &stgm );

    WsbTraceThreadOn( );
    return( hr );
}

// Is the dataobject a Mutli-Select dataobject?
HRESULT
CSakData::IsDataObjectMs ( IDataObject *pDataObject )
{
    HRESULT hr = S_FALSE;

    WsbTraceThreadOff( );

    // Is this a mutli-select data object?
    FORMATETC fmt = {(CLIPFORMAT)m_cfMultiSelect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgm = {TYMED_HGLOBAL, NULL};

    if ( pDataObject->GetData( &fmt, &stgm ) == S_OK ) {
        hr = S_OK;
    }

    ReleaseStgMedium( &stgm );

    WsbTraceThreadOn( );
    return( hr );
}

#if 0
HRESULT CSakData::SaveColumnWidths( USHORT listCtrlId, CListCtrl *pListCtrl ) 
{
    WsbTraceIn( L"CSakData::SaveColumnWidths", L"pNode = <0x%p>", pNode );

    HRESULT hr = S_OK;
    HRESULT hrInternal;
    UINT columnWidth;
    GUID nodeTypeGuid;
    BOOL exists = FALSE;
    UINT updateIndex;
    UINT col;

    try {
        WsbAssertPointer( pListCtrl );

        // Search to see if the listCtrlId already has an entry
        for( INT index = 0; index < m_cListViewWidths; index++ ) {

            if ( m_ListViewWidths[ index ].listCtrlId == listCtrlId ) {

                updateIndex = index;
                exists = TRUE;

            }
        }
        if ( !exists ) {

            // Create a new entry
            WsbAssert( m_cListViewWidths < BHSM_MAX_NODE_TYPES - 1, E_FAIL );
            updateIndex = m_cListViewWidths;
            m_ListViewWidths[ updateIndex ].listCtrlId = listCtrlId;
            m_cListViewWidths++;
        }

        // Now set the column widths
         col = 0;
         hrInternal = S_OK;
         while( hrInternal == S_OK ) {

            hrInternal =  pListCtrl->GetColumnWidth( col, &columnWidth );
            if (hrInternal == S_OK) {

                m_ListViewWidths[ updateIndex ].columnWidths[ col ] = columnWidth;
                col++;

            }
        }
        // if we failed totally to get column widths, don't wipe out the previous value
        if ( col > 0 ) {
         m_ListViewWidths[ updateIndex ].colCount = col;
        }
    } WsbCatch (hr);
    WsbTraceOut( L"CSakData::SaveColumnWidths", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

HRESULT CSakData::GetSavedColumnWidths( USHORT listCtrlId, CListCtrl *pListCtrl ) 
{
    WsbTraceIn( L"CSakData::SaveColumnWidths", L"pNode = <0x%p>", pNode );

    HRESULT hr = S_OK;
    GUID nodeTypeGuid;
    BOOL exists = FALSE;
    INT col;

    try {
        WsbAssertPointer( pNode );

        // Search to see if the listCtrlId already has an entry
        for ( INT index = 0; index < m_cListViewWidths; index++ ) {
            if ( m_ListViewWidths[ index ].listCtrlId == listCtrlId ) {
                for ( col = 0; col < m_ListViewWidths[ index ].colCount; col++) {
                    // Return the column widths
                    pColumnWidths[ col ] = m_ListViewWidths[ index ].columnWidths[ col ];
                }
                *pColCount = m_ListViewWidths[ index ].colCount;
                exists = TRUE;
            }
        }
        if ( !exists ) {
            return WSB_E_NOTFOUND;
        }
    } WsbCatch (hr);
    WsbTraceOut( L"CSakData::SaveColumnWidths", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}
#endif


void
CSakData::InitFromCommandLine(
    void
    )
/*++

Routine Description:

    Retreive the command line info and fill in appropriate fields.

Arguments:

  none.

Return Value:

  none.

--*/
{
    WsbTraceIn( L"CSakData::InitFromCommandLine", L"" );

    g_App.ParseCommandLine( m_Parse );

    if( m_Parse.m_SetManageLocal )          m_ManageLocal           = m_Parse.m_ManageLocal;
    if( m_Parse.m_SetHsmName )              m_HsmName               = m_Parse.m_HsmName;
    if( m_Parse.m_SetPersistManageLocal )   m_PersistManageLocal    = m_Parse.m_PersistManageLocal;

}

/////////////////////////////////////////////////////////////////////////////
// CSakDataWnd

BOOL
CSakDataWnd::Create(
    CSakData * pSakData
    )
{
    WsbTraceIn( L"CSakDataWnd::Create", L"" );
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    m_pSakData = pSakData;

    BOOL retval = CWnd::CreateEx( 0, AfxRegisterWndClass( 0 ), _T("RSAdmin MsgWnd"), WS_OVERLAPPED, 0, 0, 0, 0, 0, 0 );

    WsbTraceOut( L"CSakDataWnd::Create", L"retval = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}

void
CSakDataWnd::PostNcDestroy(
    )
{
    WsbTraceIn( L"CSakDataWnd::PostNcDestroy", L"" );
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    CWnd::PostNcDestroy( );

    //
    // Cleanup object
    //
    delete this;

    WsbTraceOut( L"CSakDataWnd::PostNcDestroy", L"" );
}

BEGIN_MESSAGE_MAP(CSakDataWnd, CWnd)
    //{{AFX_MSG_MAP(CSakDataWnd)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
    ON_MESSAGE( WM_SAKDATA_UPDATE_ALL_VIEWS, OnUpdateAllViews )
    ON_MESSAGE( WM_SAKDATA_REFRESH_NODE,     OnRefreshNode )
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSakDataWnd message handlers
LONG
CSakDataWnd::OnUpdateAllViews(
    IN UINT,
    IN LONG lParam )
{
    WsbTraceIn( L"CSakDataWnd::OnUpdateAllViews", L"" );

    HRESULT hr = S_OK;

    try {

        //
        // Call the internal update
        //
        WsbAffirmHr( m_pSakData->InternalUpdateAllViews( (MMC_COOKIE)lParam ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakDataWnd::OnUpdateAllViews", L"" );
    return( 0 );
}

void
CSakDataWnd::PostUpdateAllViews(
    IN MMC_COOKIE Cookie
    )
{
    WsbTraceIn( L"CSakDataWnd::PostUpdateAllViews", L"" );

    PostMessage( WM_SAKDATA_UPDATE_ALL_VIEWS, 0, Cookie );

    WsbTraceOut( L"CSakDataWnd::PostUpdateAllViews", L"" );

}

LONG
CSakDataWnd::OnRefreshNode(
    IN UINT,
    IN LONG lParam )
{
    WsbTraceIn( L"CSakDataWnd::OnRefreshNode", L"" );

    HRESULT hr = S_OK;

    try {

        //
        // Call the internal update
        //
        WsbAffirmHr( m_pSakData->InternalRefreshNode( (MMC_COOKIE)lParam ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakDataWnd::OnRefreshNode", L"" );
    return( 0 );
}

void
CSakDataWnd::PostRefreshNode(
    IN MMC_COOKIE Cookie
    )
{
    WsbTraceIn( L"CSakDataWnd::PostRefreshNode", L"" );

    PostMessage( WM_SAKDATA_REFRESH_NODE, 0, Cookie );

    WsbTraceOut( L"CSakDataWnd::PostRefreshNode", L"" );

}

ULONG
CSakData::InternalAddRef(
    )
{
    WsbTraceIn( L"CSakData::InternalAddRef", L"" );

    ULONG retval = CComObjectRoot::InternalAddRef( );

    WsbTraceOut( L"CSakData::InternalAddRef", L"retval = <%lu>", retval );
    return( retval );
}

ULONG
CSakData::InternalRelease(
    )
{
    WsbTraceIn( L"CSakData::InternalRelease", L"" );

    ULONG retval = CComObjectRoot::InternalRelease( );

    WsbTraceOut( L"CSakData::InternalRelease", L"retval = <%lu>", retval );
    return( retval );
}

STDMETHODIMP
CSakData::GetHelpTopic(
    LPOLESTR* pTopic
    )
{
    WsbTraceIn( L"CSakData::GetHelpTopic", L"" );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pTopic );

        *pTopic = 0;
        CWsbStringPtr topic;
        WsbAffirmHr( topic.LoadFromRsc( _Module.m_hInst, IDS_HELPFILE ) );

#if 1 // Hopefully temporary hack since MMC can't find the help directory
        WsbAffirmHr( topic.Prepend( L"\\help\\" ) );
        CWsbStringPtr winDir;
        WsbAffirmHr( winDir.Alloc( RS_WINDIR_SIZE ) );
        WsbAffirmStatus( ::GetWindowsDirectory( (WCHAR*)winDir, RS_WINDIR_SIZE ) != 0 );
        WsbAffirmHr( topic.Prepend( winDir ) );
#endif

        WsbAffirmHr( topic.GiveTo( pTopic ) );

    } WsbCatch( hr );
    
    WsbTraceOut( L"CSakData::GetHelpTopic", L"hr = <%ls>, *pTopic = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( pTopic ) );
    return( hr );
}

STDMETHODIMP
CSakData::GetLinkedTopics(
    LPOLESTR* pTopic
    )
{
    WsbTraceIn( L"CSakData::GetLinkedTopics", L"" );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pTopic );

        *pTopic = 0;
        CWsbStringPtr topic;
        WsbAffirmHr( topic.LoadFromRsc( _Module.m_hInst, IDS_HELPFILELINK ) );

#if 1 // Hopefully temporary hack since MMC can't find the help directory
        WsbAffirmHr( topic.Prepend( L"\\help\\" ) );
        CWsbStringPtr winDir;
        WsbAffirmHr( winDir.Alloc( RS_WINDIR_SIZE ) );
        WsbAffirmStatus( ::GetWindowsDirectory( (WCHAR*)winDir, RS_WINDIR_SIZE ) != 0 );
        WsbAffirmHr( topic.Prepend( winDir ) );
#endif

        WsbAffirmHr( topic.GiveTo( pTopic ) );

    } WsbCatch( hr );
    
    WsbTraceOut( L"CSakData::GetLinkedTopics", L"hr = <%ls>, *pTopic = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( pTopic ) );
    return( hr );
}

STDMETHODIMP
CSakData::CreateWizard(
    IN ISakWizard * pWizard
    )
{
    WsbTraceIn( L"CSakData::CreateWizard", L"" );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pWizard );

        //
        // Need to get prop sheet privider and create wizard
        //
        CComPtr<IPropertySheetProvider> pProvider;
        WsbAffirmHr( m_pConsole.QueryInterface( &pProvider ) );

        //
        // Create it
        //
        CWsbStringPtr pszName;
        WsbAffirmHr( pWizard->GetTitle( &pszName ) );

        //
        // Create the property sheet
        //
        CComPtr<IDataObject> pDataObject;
        WsbAffirmHr( RsQueryInterface( pWizard, IDataObject, pDataObject ) );
        WsbAffirmHr( pProvider->CreatePropertySheet( pszName, FALSE, 0, pDataObject, MMC_PSO_NEWWIZARDTYPE ) );

        //
        // Tell the IComponentData interface to add pages
        //
        CComPtr <IUnknown> pUnkComponentData;
        pUnkComponentData = (IUnknown *) (IComponentData*) this;
        WsbAffirmHr( pProvider->AddPrimaryPages( pUnkComponentData, TRUE, 0, TRUE ) );

        //
        // And show it
        //
        HWND mainWnd;
        WsbAffirmHr( m_pConsole->GetMainWindow( &mainWnd ) );
        WsbAffirmHr( pProvider->Show( reinterpret_cast<RS_WIN32_HANDLE>(mainWnd), 0 ) );

    } WsbCatch( hr );
    
    WsbTraceOut( L"CSakData::CreateWizard", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP
CSakData::GetWatermarks(
    IN  LPDATAOBJECT pDataObject,
    OUT HBITMAP*     pWatermark,
    OUT HBITMAP*     pHeader,
    OUT HPALETTE*    pPalette,
    OUT BOOL*        pStretch
    )
{
    WsbTraceIn( L"CSakData::GetWatermarks", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // Need to get the ISakWizard interface to do actual work
        //
        CComPtr<ISakWizard> pWizard;
        WsbAffirmHr( RsQueryInterface( pDataObject, ISakWizard, pWizard ) );

        //
        // And make the call
        //
        WsbAffirmHr( pWizard->GetWatermarks( pWatermark, pHeader, pPalette, pStretch ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::GetWatermarks", L"" );
    return( hr );
}

CSakDataNodePrivate::CSakDataNodePrivate( ISakNode* pNode )
{
    m_pNode = pNode;
    RS_PRIVATE_DATA data = (RS_PRIVATE_DATA)this;
    if( SUCCEEDED( pNode->SetPrivateData( data ) ) ) {

        m_Magic = RS_NODE_MAGIC_GOOD;

    } else {

        m_Magic = RS_NODE_MAGIC_DEFUNCT;

    }
}

CSakDataNodePrivate::~CSakDataNodePrivate( )
{
    m_Magic = RS_NODE_MAGIC_DEFUNCT;
    if( m_pNode ) {

        m_pNode->SetPrivateData( 0 );

    }
}

HRESULT CSakDataNodePrivate::Verify( CSakDataNodePrivate* pNodePriv )
{
    HRESULT hr = E_POINTER;

    if( !IsBadWritePtr( pNodePriv, sizeof( CSakDataNodePrivate ) ) ) {

        if( RS_NODE_MAGIC_GOOD == pNodePriv->m_Magic ) {

            hr = S_OK;

        }
    }

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\csaksnap.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    CSakSnap.cpp

Abstract:

    This component implements the IComponent interface for
    the snapin. Primarily it is responsible for handling the
    result view panes.

Author:

    Rohde Wakefield [rohde]   04-Mar-1997

Revision History:

--*/

#include "stdafx.h"
#include "CSakSnap.h"
#include "CSakData.h"
#include "MsDatObj.h"


UINT CSakSnap::m_nImageArray[RS_RESULT_IMAGE_ARRAY_MAX];
INT  CSakSnap::m_nImageCount = 0;

STDMETHODIMP
CSakSnap::GetResultViewType(
    IN  MMC_COOKIE Cookie,
    OUT BSTR* ppViewType,
    OUT long* pViewOptions
    )
/*++

Routine Description:

    Determine what the type of the result view will be:

Arguments:

    pUnk            - Base IUnknown of console

Return Value:

    S_OK    : either an OCX CLSID string or a URL path.
    S_FALSE : default list view will be used.

--*/
{
    WsbTraceIn( L"CSakSnap::GetResultViewType", L"Cookie = <0x%p>, ppViewType = <0x%p>, pViewOptions = <0x%p>", Cookie, ppViewType, pViewOptions );

    HRESULT hr = S_FALSE;

    try {

        CComPtr<ISakNode> pSakNode;
        WsbAffirmHr( m_pSakData->GetBaseHsmFromCookie( Cookie, &pSakNode ) );


        //
        // Use default view
        //

        *ppViewType = 0;
        *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
        hr = S_FALSE;

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::GetResultViewType", L"hr = <%ls>, *ppViewType = <%ls>, *pViewOptions = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( ppViewType ), WsbPtrToPtrAsString( (void**)pViewOptions ) );
    return( hr );
}


STDMETHODIMP
CSakSnap::Initialize(
    IN  IConsole * lpConsole
    )
/*++

Routine Description:

    Called when the user first clicks on node to show result pane.

Arguments:

    pUnk            - Base IUnknown of console

Return Value:

    S_OK            - Correctly initialized.

    E_xxxxxxxxxxx   - Unable to initialize.

--*/
{
    WsbTraceIn( L"CSakSnap::Initialize", L"lpConsole = <0x%p>", lpConsole );

    HRESULT hr = S_OK;
    try {

        //
        // validity check on parameters
        //

        WsbAffirmPointer( lpConsole );

        //
        // Save the IConsole pointer 
        //

        m_pConsole = lpConsole;

        //
        // Save the result image list
        // MS seems to QI for this instead of call
        // 'QueryResultImageList'
        //

        WsbAffirmHr( m_pConsole->QueryInterface( IID_IImageList, (void**)&m_pImageResult ) );
        // WsbAffirmHr( m_pConsole->QueryResultImageList( &m_pImageResult ) );

        //
        // Save the result data pointer
        //
        WsbAffirmHr( m_pConsole->QueryInterface( IID_IResultData, (void**)&m_pResultData ) );
        // Save the ConsolveVerb pointer
//      WsbAffirmHr( m_pConsole->QueryInterface( IID_IConsoleVerb, (void **)&m_pConsoleVerb ) );
        WsbAffirmHr (m_pConsole->QueryConsoleVerb(&m_pConsoleVerb));

 
        //
        // Get the header interface
        //

        WsbAffirmHr( m_pConsole->QueryInterface( IID_IHeaderCtrl, (void**)&m_pHeader ) );

        //
        // Give the console the header control interface pointer
        //

        WsbAffirmHr( m_pConsole->SetHeader( m_pHeader ) );

    } WsbCatch( hr);

    WsbTraceOut( L"CSakSnap::Initialize", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}





STDMETHODIMP
CSakSnap::Notify(
    IN  IDataObject*    pDataObject,
    IN  MMC_NOTIFY_TYPE event,
    IN  LPARAM            arg,
    IN  LPARAM            param
    )
/*++

Routine Description:

    Handle user clicks on nodes in the result view, along with other
    MMC notices.

Arguments:

    pDataObject     - Data Object for which event occured

    event           - The event type

    arg, param      - Info for event (depend on type)

Return Value:

    S_OK            - Notification handled without error.

    E_xxxxxxxxxxx   - Unable to register server.

--*/
{
    WsbTraceIn( L"CSakSnap::Notify", L"pDataObject = <0x%p>, event = <%ls>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, RsNotifyEventAsString( event ), arg, arg, param, param );
    CComPtr <IDataObject> pTempDataObject;
    HRESULT hr = S_OK;

    try {

        CComPtr<ISakNode> pBaseHsm;
        CComPtr <ISakSnapAsk> pSakSnapAsk;

        
        switch( event ) {

        case MMCN_PROPERTY_CHANGE:
            WsbAffirmHr( m_pSakData->GetDataObjectFromCookie( param, &pTempDataObject ) );
            WsbAffirmHr( OnChange( pTempDataObject, arg, 0L ) );
            break;

        // This node was expanded or contracted in the scope pane (the user 
        // clicked on the actual node
        case MMCN_SHOW:
            WsbAffirmHr( OnShow(pDataObject, arg, param) );
            break;
        
        // Not implemented
        case MMCN_SELECT:
            WsbAffirmHr( OnSelect(pDataObject, arg, param) );
            break;
        
        // Not implemented
        case MMCN_MINIMIZED:
            WsbAffirmHr( OnMinimize(pDataObject, arg, param) );
            break;
                
        case MMCN_ADD_IMAGES:
            WsbAffirmHr( OnAddImages() );
            break;

        case MMCN_VIEW_CHANGE:
            WsbAffirmHr ( OnChange(pDataObject, arg, param) );
            break;

        case MMCN_CLICK:
            break;

        case MMCN_DBLCLICK:
            //
            // return S_FALSE so that auto-expansion takes place
            //
            hr = S_FALSE;
            break;

        case MMCN_DELETE:
            WsbAffirmHr( OnDelete(pDataObject, arg, param) );
            break;

        case MMCN_REFRESH:
            WsbAffirmHr( OnRefresh(pDataObject, arg, param) );
            break;

        case MMCN_CONTEXTHELP:
            WsbAffirmHr( m_pSakData->OnContextHelp( pDataObject, arg, param ) );
            break;

        // Note - Future expansion of notify types possible
        default:
//          WsbThrow( S_FALSE );  // Handle new messages
            break;
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::Notify", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP
CSakSnap::Destroy(
    MMC_COOKIE Cookie
    )
/*++

Routine Description:

    Called to force the release of any owned objects and
    to clear all views.

Arguments:

    cookie          - Not used.

Return Value:

    S_OK            - Correctly tore down.

    E_xxxxxxxxxxx   - Failure occurred (not meaningful).

--*/
{
    WsbTraceIn( L"CSakSnap::Destroy", L"Cookie = <0x%p>", Cookie );

    HRESULT hr = S_OK;

    try {

        // This is a straight C++ pointer, so null it out
        m_pSakData = 0;


        // Release the interfaces that we QI'ed
        if( m_pToolbar && m_pControlbar ) {
            m_pControlbar->Detach( m_pToolbar );
        }
        if( m_pConsole ) {
            m_pConsole->SetHeader( 0 );
        }

        m_pToolbar.Release();
        m_pControlbar.Release();
        m_pHeader.Release();
        m_pResultData.Release();
        m_pImageResult.Release();
        m_pConsoleVerb.Release();
        m_pConsole.Release( );


    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::Destroy", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP
CSakSnap::QueryDataObject(
    IN  MMC_COOKIE              cookie,
    IN  DATA_OBJECT_TYPES type, 
    OUT IDataObject**     ppDataObject
    )
/*++

Routine Description:

    Called by the console when it needs data for a particular node.
    Since each node is a data object, its IDataObject interface is
    simply returned. The console will later pass in this dataobject to 
    SakSnap help it establish the context under which it is being called.

Arguments:

    cookie          - Node which is being queried.

    type            - The context under which a dataobject is being requested.

    ppDataObject    - returned data object.

Return Value:

    S_OK            - Data Object found and returned.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{

    WsbTraceIn( L"CSakSnap::QueryDataObject", L"cookie = <0x%p>, type = <%d>, ppDataObject = <0x%p>", cookie, type, ppDataObject );

    HRESULT hr = S_OK;

    try {
        //
        // If multi select, we create and return a special data object
        //
        if( ( MMC_MULTI_SELECT_COOKIE == cookie ) ) {
            HRESULT hrInternal = S_OK;

            RESULTDATAITEM item;
            item.mask = RDI_STATE;
            item.nState = LVIS_SELECTED;
            item.nIndex = -1;

            // Create a Com object
            CComObject <CMsDataObject> * pMsDataObject = new CComObject <CMsDataObject>;
            pMsDataObject->FinalConstruct();
            pMsDataObject->AddRef(); // zzzzz

            // Get the IDataObject pointer to pass back to the caller
            WsbAffirmHr (pMsDataObject->QueryInterface (IID_IDataObject, (void **) ppDataObject));

            // Go through the selected nodes in the result pane and add their node pointers
            // and GUIDs to the Data object.
            while (hrInternal == S_OK) {
                hrInternal = m_pResultData->GetNextItem (&item);
                if (hrInternal == S_OK) {
                    CComPtr<ISakNode> pSakNode;
                    WsbAffirmHr( m_pSakData->GetBaseHsmFromCookie( item.lParam, &pSakNode ) );
                    WsbAffirmPointer( pSakNode );
                    WsbAffirmHr( pMsDataObject->AddNode( pSakNode ) );
                }
            } // while

        } else {

            //
            // Delegate to SakData
            //

            WsbAffirmHr (m_pSakData->QueryDataObject( cookie, type, ppDataObject ));
        }
    } WsbCatch (hr);

    WsbTraceOut( L"CSakSnap::QueryDataObject", L"hr = <%ls>, *ppDataObject = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppDataObject ) );
    return( hr );
}

void
CSakSnap::FinalRelease(
    void
    )
/*++

Routine Description:

    Called on final release in order to clean up all members.

Arguments:

    none.

Return Value:

    none.

--*/
{
    WsbTraceIn( L"CSakSnap::FinalRelease", L"" );
    WsbTraceOut( L"CSakSnap::FinalRelease", L"" );
}


HRESULT
CSakSnap::FinalConstruct(
    void
    )
/*++

Routine Description:

    Called during initial CSakSnap construction to initialize members.

Arguments:

    none.

Return Value:

    S_OK            - Initialized correctly.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakSnap::FinalConstruct", L"" );

    HRESULT hr = CComObjectRoot::FinalConstruct( );

    m_ActiveNodeCookie = 0;
    m_pEnumeratedNode = NULL;

    //
    // Initialize column widths to 0
    //
    for( INT i = 0; i < BHSM_MAX_NODE_TYPES; i++ ) {

        m_ChildPropWidths[ i ].nodeTypeId = GUID_NULL;
        m_ChildPropWidths[ i ].colCount = 0;

        for ( INT j = 0; j < BHSM_MAX_CHILD_PROPS; j++ ) {

            m_ChildPropWidths[ i ].columnWidths[ j ] = 0;

        }
    }
    m_cChildPropWidths = 0;

    WsbTraceOut( L"CSakSnap::FinalConstruct", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakSnap::InitResultPaneHeaders(
    ISakNode* pNode
    )
/*++

Routine Description:

    This functions sets up the result view header titles and widths. 
    It should be called immediately prior to populating the result view.

Arguments:

    pNode - Node whose contents will be shown.

Return Value:

    S_OK            - Initialized correctly.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakSnap::InitResultPaneHeaders", L"pNode = <0x%p>", pNode );

    HRESULT hr = S_OK;
    HRESULT hrInternal = S_OK;
    BOOL bGotSavedWidths = FALSE;
    CComPtr<IEnumString> pEnumStr;

    try {

        WsbAffirmPointer( m_pHeader );
        WsbAffirmPointer( pNode );

        // Clean out any old columns in the result pane
        hrInternal = S_OK;
        while ( hrInternal == S_OK ) {
            hrInternal = m_pHeader->DeleteColumn( 0 );
        }

        // Get saved column widths (from CSakSnap) (they may not exist). 

        INT columnWidths [ BHSM_MAX_CHILD_PROPS ];
        INT colCount;
        hrInternal = GetSavedColumnWidths( pNode, &colCount, columnWidths );
        if( hrInternal == S_OK ) {

            bGotSavedWidths = TRUE;

        }

        // Enumerate child display property column widths and create the columns with the correct
        // widths (but wrong titles). 
        WsbAffirmHr( pNode->EnumChildDisplayPropWidths( &pEnumStr ) );
        if( pEnumStr )  {

            OLECHAR* str;
        
            // loop over the columns of display properties to get their widths.
            INT nCol = 0;
            while( pEnumStr->Next( 1, &str, NULL ) == S_OK ) {
            
                // Set the the next column width.  Sometimes we may display more columns
                // than were saved - if so use the resource string for those columns.  We
                // don't throw errors because this function can get called when (I think)
                // when the scope pane is displaying the nodes in the result pane and the 
                // header functions will fail.

                if( bGotSavedWidths && ( nCol < colCount ) ) {

                    hrInternal = m_pHeader->InsertColumn( nCol, str, LVCFMT_LEFT, columnWidths[ nCol ]  );

                } else {

                    hrInternal = m_pHeader->InsertColumn( nCol, str, LVCFMT_LEFT, MMCLV_AUTO );

                }
                nCol++;
                CoTaskMemFree( str );
                str = 0;
            }
        
        } else {
        
            hr = S_FALSE;
        
        }
        
        // Enumerate child display titles and use as correct column titles.
        pEnumStr = NULL;
        pNode->EnumChildDisplayTitles( &pEnumStr );
        if( pEnumStr )  {
        
            OLECHAR* str;
        
            // loop over the columns of display properties to get their titles.
            INT nCol = 0;
            while( pEnumStr->Next( 1, &str, NULL ) == S_OK ) {
        
                // Reset the strings in the titles of the headers. For some reason, it is NOW
                // acting as if 0 based.
                WsbAffirmHr( m_pHeader->SetColumnText( nCol, str ) );
                nCol++;

                CoTaskMemFree( str );
                str = 0;
            }
        
        } else {
        
            hr = S_FALSE;
        
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::InitResultPaneHeaders", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}


STDMETHODIMP
CSakSnap::GetDisplayInfo(
    IN OUT RESULTDATAITEM * pResult
    )
/*++

Routine Description:

    When MMC is told to call back concerning resultview items,
    we receive a call here to fill in missing information (once per "cell" 
    in the columns and rows of a "listview" style of result view).  
    
    Note that the snapin manager automatically calls this method for the items 
    appearing in the scope pane to render them in the result pane, and then it is 
    called again for the items that appear only in the result pane as a result of 
    our establishing the callback in EnumResultView.

Arguments:

    pResult         - RESULTDATAITEM structure representing state of the node
                      in the result listview.

Return Value:

    S_OK            - Struct filled in.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    static CWsbStringPtr tmpString;

    WsbTraceIn( L"CSakSnap::GetDisplayInfo", L"cookie = <0x%p>, pScopeItem->mask = <0x%p>, pResult->nCol = <%d>", pResult->lParam, pResult->mask, pResult->nCol );

    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pResult );
        
        CComPtr<ISakNode> pNode;    // basehsm interface for the node whose properties are being displayed.
        WsbAffirmHr( m_pSakData->GetBaseHsmFromCookie( pResult->lParam, &pNode ) );
        
        if( pResult->mask & RDI_IMAGE ) {

            WsbAffirmHr( pNode->GetResultIcon( m_pSakData->m_State, &pResult->nImage ) );

        }
        //
        // If the RESULTDATAITEM indicates that it needs a string...
        //
        if( pResult->mask & RDI_STR ) {
        
            //
            // Use the basehsm pointer to get the correct data to populate the listview.
            //

            DISPID             dispid;
            CComPtr<IDispatch> pDisp;       // dispatch interface
            CComPtr<ISakNode>  pParentNode; // basehsm interface for the node's parent
        
            CWsbVariant        varRet;
            CWsbStringPtr      pPropString;
        
            //
            // Prepare an enumerator to look at each child property 
            // (i.e. - column of info). Need to get the list of child properties from
            // the parent of this child.
            //

            CComPtr<IEnumString> pEnum;
            WsbAffirmHr( pNode->GetParent( &pParentNode ));

            //
            // If parentNode == 0, we are displaying our root node in the result pane
            // ( we are extending someone else ).  Since the parent has determined the
            // columns to be name, type and description, we show that.
            //

            if( ! pParentNode ) {

                WsbAffirmHr( EnumRootDisplayProps( &pEnum ) );

            } else {

                WsbAffirmHr( pParentNode->EnumChildDisplayProps( &pEnum ) );

            }
            if( pEnum ) {
        
                //
                // Skip the correct number of columns to access 
                // the exact column that we need.
                //

                if( pResult->nCol > 0 ) {

                    WsbAffirmHr( pEnum->Skip( pResult->nCol ) );

                }
                WsbAffirmHr( pEnum->Next( 1, &pPropString, NULL ) );
        
                //
                // get the dispatch interface for this node
                //
                WsbAffirmHr( pNode->QueryInterface( IID_IDispatch, (void**)&pDisp ) );
        
                DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};

                //      
                // convert the property name to a dispatch id that can be invoked.
                // Invoke the interfaces to get the value of the cell.
                //

                WsbAffirmHr( pDisp->GetIDsOfNames( IID_NULL, &(pPropString), 1, LOCALE_USER_DEFAULT, &dispid ));
                WsbAffirmHr( pDisp->Invoke( dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, 
                    &dispparamsNoArgs, &varRet, NULL, NULL) );
                tmpString = (OLECHAR*)varRet;
            }

            pResult->str = tmpString;
        }
    
    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::GetDisplayInfo", L"hr = <%ls>, pResult->str = <%ls>, pResult->nImage = <%ls>", WsbHrAsString( hr ), (RDI_STR & pResult->mask) ? pResult->str : L"N/A", (RDI_IMAGE & pResult->mask) ? WsbLongAsString( pResult->nImage ) : L"N/A" );
    return( hr );
}

HRESULT CSakSnap::EnumRootDisplayProps( IEnumString ** ppEnum )
{
    WsbTraceIn( L"CSakSnap::EnumRootDisplayProps", L"ppEnum = <0x%p>", ppEnum );

    HRESULT hr = S_OK;
    
    CEnumString * pEnum = 0;
    BSTR rgszRootPropIds[] = {L"DisplayName", L"Type", L"Description"};
    INT cRootPropsShow = 3;
    try {

        WsbAffirmPointer( ppEnum );
        WsbAffirm( cRootPropsShow > 0, S_FALSE );

        *ppEnum = 0;

        //
        // New an ATL enumerator
        //
        pEnum = new CEnumString;
        WsbAffirm( pEnum, E_OUTOFMEMORY );

        WsbAffirmHr( pEnum->FinalConstruct( ) );
        WsbAffirmHr( pEnum->Init( &rgszRootPropIds[0], &rgszRootPropIds[cRootPropsShow], NULL, AtlFlagCopy ) );
        WsbAffirmHr( pEnum->QueryInterface( IID_IEnumString, (void**)ppEnum ) );
        
    } WsbCatchAndDo( hr,
        
        if( pEnum ) delete pEnum;
        
    );

    WsbTraceOut( L"CSakSnap::EnumRootDisplayProps", L"hr = <%ls>, *ppEnum = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppEnum ) );
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// IExtendPropertySheet Implementation. 
//

STDMETHODIMP
CSakSnap::CreatePropertyPages(
    IPropertySheetCallback* pPropSheetCallback, 
    RS_NOTIFY_HANDLE        handle,
    IDataObject*            pDataObject
    )
/*++

Routine Description:

    Console calls this when it is building a property sheet to
    show for a node. It is also called for the data object given
    to represent the snapin to the snapin manager, and should 
    show the initial selection page at that point.

Arguments:

    pPropSheetCallback - MMC interface to use to add page.

    handle          - Handle to MMC to use to add the page.

    pDataObject     - Data object refering to node.

Return Value:

    S_OK            - Pages added.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakSnap::CreatePropertyPages", L"pPropSheetCallback = <0x%p>, handle = <0x%p>, pDataObject = <0x%p>", pPropSheetCallback, handle, pDataObject );

    //
    // Delegate to CSakData
    //

    HRESULT hr = m_pSakData->CreatePropertyPages( pPropSheetCallback, handle, pDataObject );

    WsbTraceOut( L"CSakSnap::CreatePropertyPages", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP
CSakSnap::QueryPagesFor(
    IDataObject* pDataObject
    )
/*++

Routine Description:

    This method is called by MMC when it wants to find out if this node
    supports property pages. The answer is yes if:

    1) The MMC context is either for the scope pane or result pane, AND

    2) The node actually DOES have property pages.

    OR

    1) The Data Object is acquired by the snapin manager.

    Return S_OK if it DOES have pages, and S_FALSE if it does NOT have pages.

Arguments:

    pDataObject     - Data object refering to node.

Return Value:

    S_OK            - Pages exist.

    S_FALSE         - No property pages.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakSnap::QueryPagesFor", L"pDataObject = <0x%p>", pDataObject );

    HRESULT hr = m_pSakData->QueryPagesFor( pDataObject );

    WsbTraceOut( L"CSakSnap::QueryPagesFor", L"hr = <%ls>", WsbHrAsString( hr ) );
    return ( hr );
}

STDMETHODIMP
CSakSnap::CompareObjects(
    IN  IDataObject* pDataObjectA,
    IN  IDataObject* pDataObjectB
    )
/*++

Routine Description:

    Compare data objects for MMC

Arguments:

    pDataObjectA,     - Data object refering to node.
    pDataObjectB

Return Value:

    S_OK            - Objects represent the same node.

    S_FALSE         - Objects do not represent the same node.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn( L"CSakSnap::CompareObjects", L"pDataObjectA = <0x%p>, pDataObjectB = <0x%p>", pDataObjectA, pDataObjectB );

    hr = m_pSakData->CompareObjects( pDataObjectA, pDataObjectB );

    WsbTraceOut( L"CSakSnap::CompareObjects", L"hr = <%ls>", WsbHrAsString( hr ) );
    return ( hr );
}


/////////////////////////////////////////////////////////////////////////////////////////
//
// IPersistStream implementation
//

HRESULT
CSakSnap::Save( 
    IStream *pStm, 
    BOOL fClearDirty 
    )
/*++

Routine Description:

    Save the information we need to reconstruct the root node in the
    supplied stream.

Arguments:

    pStm        I: Console-supplied stream
    fClearDirty I: The console tells us to clear our dirty flag
    
Return Value:

    S_OK         - Saved successfully.
    E_*          - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakSnap::Save", L"pStm = <0x%p>, fClearDirty", pStm, WsbBoolAsString( fClearDirty ) );

    HRESULT hr = S_OK;
    INT index;
    INT jindex;

    try {
        ULONG version = HSMADMIN_CURRENT_VERSION;
        WsbAffirmHr( WsbSaveToStream( pStm, version ) );

        // Get the settings from the currently opened view
        if ( m_pEnumeratedNode ) {
            SaveColumnWidths( m_pEnumeratedNode );
        }

        // Save the number of different nodes
        WsbAffirmHr( WsbSaveToStream ( pStm, m_cChildPropWidths ) );

        // For each different node...
        for ( index = 0; index < m_cChildPropWidths; index++ ) {

            // Save the nodetype and column count
            WsbAffirmHr( WsbSaveToStream ( pStm, m_ChildPropWidths[ index ].nodeTypeId ) );
            WsbAffirmHr( WsbSaveToStream ( pStm, m_ChildPropWidths[ index ].colCount ) );

            // Save the column widths
            for ( jindex = 0; jindex < m_ChildPropWidths[ index ].colCount; jindex++ ) {
                WsbAffirmHr( WsbSaveToStream ( pStm, m_ChildPropWidths[ index ].columnWidths[ jindex ] ) );
            }
        }
    } WsbCatch ( hr );

    WsbTraceOut( L"CSakSnap::Save", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakSnap::Load( 
    IStream *pStm
    )
/*++

Routine Description:

    Load the information we need to reconstruct the root node from the
    supplied stream.

Arguments:

    pStm        IConsole-supplied stream
    
Return Value:

    S_OK         - Saved successfully.
    E_*          - Some error occurred. 

--*/
{
    WsbTraceIn( L"CSakSnap::Load", L"pStm = <0x%p>", pStm );

    HRESULT hr = S_OK;
    HRESULT hrInternal = S_OK;
    USHORT  nodeCount;
    INT index;
    INT jindex;

    try {
        ULONG version = 0;
        WsbAffirmHr( WsbLoadFromStream( pStm, &version ) );
        WsbAssert( ( version == 1 ), E_FAIL );

        // Set to zero in case we fail part way through
        m_cChildPropWidths = 0;

        // If this fails, it probably means that nothing has been saved yet
        hrInternal = WsbLoadFromStream (pStm, &nodeCount);
        if ( hrInternal == S_OK ) {

            for ( index = 0; index < nodeCount; index++ ) {

                // Retrieve the nodetype and column count
                WsbAffirmHr( WsbLoadFromStream ( pStm, &( m_ChildPropWidths[ index ].nodeTypeId ) ) );
                WsbAffirmHr( WsbLoadFromStream ( pStm, &( m_ChildPropWidths[ index ].colCount ) ) );

                // Retrieve the column widths
                for ( jindex = 0; jindex < m_ChildPropWidths[ index ].colCount; jindex++ ) {
                    WsbAffirmHr( WsbLoadFromStream ( pStm, &( m_ChildPropWidths[ index ].columnWidths[ jindex ] ) ) );
                }
            }
            m_cChildPropWidths = nodeCount;
        }
        WsbTraceOut( L"CSakSnap::Load", L"hr = <%ls>", WsbHrAsString( hr ) );
    } WsbCatch (hr);
    return( hr );
}   

HRESULT
CSakSnap::IsDirty(
    void
    )
/*++

Routine Description:

    The console asks us if we are dirty.

Arguments:

    None
    
Return Value:

    S_OK         - Dirty.
    S_FALSE      - Not Dirty. 

--*/
{
    WsbTraceIn( L"CSakSnap::IsDirty", L"" );

    HRESULT hr = S_OK;

    WsbTraceOut( L"CSakSnap::IsDirty", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakSnap::GetSizeMax( 
    ULARGE_INTEGER *pcbSize
    )
/*++

Routine Description:

    Not currently used by the console

Arguments:

    pcbSize
    
Return Value:

    S_OK

--*/
{
    WsbTraceIn( L"CSakSnap::GetSizeMax", L"" );

    pcbSize->QuadPart = 256;
    HRESULT hr = S_OK;

    WsbTraceOut( L"CSakSnap::GetSizeMax", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakSnap::GetClassID( 
    CLSID *pClassID 
    )
/*++

Routine Description:

    Not currently used by the console

Arguments:

    pClassID  - The class ID for the snapin
    
Return Value:

    S_OK
--*/
{
    WsbTraceIn( L"CSakSnap::GetClassID", L"pClassID = <0x%p>", pClassID );

    HRESULT hr = S_OK;
    *pClassID = CLSID_HsmAdmin;

    WsbTraceOut( L"CSakSnap::GetClassID", L"hr = <%ls>, *pClassID = <%ls>", WsbHrAsString( hr ), WsbPtrToGuidAsString( pClassID ) );
    return( hr );
}


//////////////////////////////////////////////////////////////////////////////////
//
// Description: Add the supplied resource ID to the list of resource IDs for
//      the scope pane.  Returns the index into the array.
//
INT CSakSnap::AddImage( UINT rId )
{
    INT nIndex = 1;
    if (CSakSnap::m_nImageCount < RS_RESULT_IMAGE_ARRAY_MAX) {

        CSakSnap::m_nImageArray[CSakSnap::m_nImageCount] = rId;
        nIndex = CSakSnap::m_nImageCount;
        CSakSnap::m_nImageCount++;

    }
    return nIndex;
}

/////////////////////////////////////////////////////////////////////////////
//
// Adds images to the consoles image list from the static array
//
HRESULT CSakSnap::OnAddImages()
{
    HRESULT hr = S_OK;
    HICON hIcon;
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
    try {

        //
        // References to the image list are now invalid
        //

        // Put the images from the static array into the image list
        // for the result pane

        for( INT i = 0; i < m_nImageCount; i++) {
            // Load the icon using the resource Id stored in the
            // static array and get the handle.  

            hIcon = LoadIcon( _Module.m_hInst, 
                MAKEINTRESOURCE( m_nImageArray [i] ) );

            // Add to the Console's Image list
            WsbAffirmHr( m_pImageResult->ImageListSetIcon( (RS_WIN32_HANDLE*)hIcon, i) );
        }
    } WsbCatch (hr);
    return hr;
}


HRESULT CSakSnap::SaveColumnWidths( ISakNode *pNode ) 
{
    WsbTraceIn( L"CSakSnap::SaveColumnWidths", L"pNode = <0x%p>", pNode );

    HRESULT hr = S_OK;
    HRESULT hrInternal;
    INT columnWidth;
    GUID nodeTypeGuid;
    BOOL exists = FALSE;
    INT updateIndex = -1;
    INT col;

    try {
        WsbAssertPointer( pNode );

        // Get the type of the supplied node
        WsbAffirmHr( pNode->GetNodeType ( &nodeTypeGuid ) );

        // Search to see if the GUID already has an entry
        for ( INT index = 0; index < m_cChildPropWidths; index++ ) {

            if ( m_ChildPropWidths[ index ].nodeTypeId == nodeTypeGuid ) {

                updateIndex = index;
                exists = TRUE;

            }
        }
        if ( !exists ) {

            // Create a new entry
            WsbAssert( m_cChildPropWidths < BHSM_MAX_NODE_TYPES - 1, E_FAIL );
            updateIndex = m_cChildPropWidths;
            m_ChildPropWidths[ updateIndex ].nodeTypeId = nodeTypeGuid;
            m_cChildPropWidths++;
        }

        // Now set the column widths
         col = 0;
         hrInternal = S_OK;
         while ( hrInternal == S_OK ) {
            hrInternal =  m_pHeader->GetColumnWidth( col, &columnWidth );
            if (hrInternal == S_OK) {
                m_ChildPropWidths[ updateIndex ].columnWidths[ col ] = (USHORT)columnWidth;
                col++;
            }
        }
        // if we failed totally to get column widths, don't wipe out the previous value
        if ( col > 0 ) {
         m_ChildPropWidths[ updateIndex ].colCount = (USHORT)col;
        }
    } WsbCatch (hr);
    WsbTraceOut( L"CSakSnap::SaveColumnWidths", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

HRESULT CSakSnap::GetSavedColumnWidths( ISakNode *pNode, INT *pColCount, INT *pColumnWidths ) 
{
    WsbTraceIn( L"CSakSnap::SaveColumnWidths", L"pNode = <0x%p>", pNode );

    HRESULT hr = S_OK;
    GUID nodeTypeGuid;
    BOOL exists = FALSE;
    INT col;

    try {

        WsbAssertPointer( pNode );

        // Get the type of the supplied node
        WsbAffirmHr( pNode->GetNodeType ( &nodeTypeGuid ) );

        // Search to see if the GUID already has an entry
        for( INT index = 0; index < m_cChildPropWidths; index++ ) {

            if ( m_ChildPropWidths[ index ].nodeTypeId == nodeTypeGuid ) {

                for ( col = 0; col < m_ChildPropWidths[ index ].colCount; col++) {

                    // Return the column widths
                    pColumnWidths[ col ] = m_ChildPropWidths[ index ].columnWidths[ col ];

                }
                *pColCount = m_ChildPropWidths[ index ].colCount;
                exists = TRUE;
            }
        }
        if ( !exists ) {
            return WSB_E_NOTFOUND;
        }
    } WsbCatch (hr);
    WsbTraceOut( L"CSakSnap::SaveColumnWidths", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
// IExtendControlbar implementation
//


STDMETHODIMP CSakSnap::SetControlbar(LPCONTROLBAR pControlbar)
{
    WsbTraceIn( L"CSakSnap::SetControlbar", L"pControlbar = <0x%p>", pControlbar );

    HRESULT hr = S_OK;

    try {

        //
        // Clear out old controlbar
        //
        if( m_pControlbar && m_pToolbar ) {

            m_pControlbar->Detach( m_pToolbar );

        }
        m_pToolbar.Release( );
        m_pControlbar.Release( );

        //
        // Hold on to the controlbar interface.
        //
        m_pControlbar = pControlbar;

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::SetControlbar", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CSakSnap::ControlbarNotify( MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param )
{
    WsbTraceIn( L"CSakSnap::ControlbarNotify", L"" );
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_FALSE;

    switch( event ) {

    case MMCN_BTN_CLICK:
        hr = OnToolbarButtonClick( arg, param );
        break;

    case MMCN_DESELECT_ALL:
        break;

    case MMCN_SELECT:
        OnSelectToolbars( arg, param );
        break;

    case MMCN_MENU_BTNCLICK:
//      HandleExtMenus(arg, param);
        break;

    default:
        break;
    }

    WsbTraceOut( L"CSakSnap::ControlbarNotify", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CSakSnap::OnToolbarButtonClick( LPARAM arg, LPARAM cmdId )
{
    WsbTraceIn( L"CSakSnap::OnToolbarButtonClick", L"arg = <0x%p>, cmdId = <%ld>" );
    HRESULT hr = S_OK;


    try {

        IDataObject* pDataObject = (IDataObject*)arg;
        WsbAffirmPointer( pDataObject );

        CComPtr<ISakNode> pNode;
        WsbAffirmHr( m_pSakData->GetBaseHsmFromDataObject( pDataObject, &pNode ) );

        // Delegate to the node
        WsbAffirmHr( pNode->OnToolbarButtonClick( pDataObject, (LONG)cmdId ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::OnToolbarButtonClick", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


void CSakSnap::OnSelectToolbars(LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    try {

        BOOL bScope  = (BOOL) LOWORD( arg );
        BOOL bSelect = (BOOL) HIWORD( arg );

        IDataObject* pDataObject = (IDataObject*)param;
        WsbAffirmPointer( pDataObject );

        CComPtr<ISakNode> pNode;
        WsbAffirmHr( m_pSakData->GetBaseHsmFromDataObject( pDataObject, &pNode ) );

        if( bSelect ) {

            //
            // ATL detaches any existing toolbar before attaching new ones.
            // This appears to fix issues of us adding toolbar upon toolbar
            //
            if( m_pToolbar ) {

                m_pControlbar->Detach( m_pToolbar );
                m_pToolbar.Release( );

            }

            //
            // Does the node have a toolbar?
            //
            if( pNode->HasToolbar() == S_OK ) {

                //
                // Create the toolbar for the indicated node
                //
                WsbAffirmHr( m_pControlbar->Create( TOOLBAR, this, reinterpret_cast<LPUNKNOWN*>(&m_pToolbar) ) );

                //
                // Returns S_FALSE if there is no toolbar for the node
                //
                if( pNode->SetupToolbar( m_pToolbar ) == S_OK ) {

                    //
                    // Attach the toolbar
                    //
                    WsbAffirmHr( m_pControlbar->Attach( TOOLBAR, (IUnknown*) m_pToolbar ) );

                }

            }

        } else {

            //
            // Destroy the toolbar
            // NOTE: Not done in ATL snapin classes
            //
            if( m_pToolbar ) {

                m_pControlbar->Detach( m_pToolbar );

            }
            m_pToolbar.Release();

       }


    } WsbCatch( hr );
}




STDMETHODIMP
CSakSnap::Compare(
    IN     LPARAM   /*lUserParam*/,
    IN     MMC_COOKIE CookieA,
    IN     MMC_COOKIE CookieB,
    IN OUT int*       pnResult
    )
{
    HRESULT hr = S_OK;

    try {

        //
        // Store column and set result to 'equal' ASAP
        //
        WsbAffirmPointer( pnResult );
        int col = *pnResult;
        *pnResult = 0;

        //
        // And make sure we have a node we know we're showing
        //
        WsbAffirmPointer( m_pEnumeratedNode );


        CComPtr<ISakNode>  pNodeA, pNodeB;
        CComPtr<IDispatch> pDispA, pDispB;
        WsbAffirmHr( m_pSakData->GetBaseHsmFromCookie( CookieA, &pNodeA ) );
        WsbAffirmHr( m_pSakData->GetBaseHsmFromCookie( CookieB, &pNodeB ) );
        WsbAffirmHr( pNodeA.QueryInterface( &pDispA ) );
        WsbAffirmHr( pNodeB.QueryInterface( &pDispB ) );

        CComPtr<IEnumString> pEnum;
        WsbAffirmHrOk( m_pEnumeratedNode->EnumChildDisplayProps( &pEnum ) );

        //
        // Skip the correct number of columns to access 
        // the exact column that we need.
        //
        if( col > 0 ) {

            WsbAffirmHr( pEnum->Skip( col ) );

        }

        CWsbVariant    varRetA, varRetB;
        CWsbStringPtr  pPropString;
        WsbAffirmHrOk( pEnum->Next( 1, &pPropString, NULL ) );
        WsbAffirmHr( pPropString.Append( L"_SortKey" ) );


        //      
        // convert the property name to a dispatch id that can be invoked.
        // Invoke the interfaces to get the value of the cell.
        //
        DISPID     dispid;
        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};

        WsbAffirmHr( pDispA->GetIDsOfNames( IID_NULL, &(pPropString), 1, LOCALE_USER_DEFAULT, &dispid ));
        WsbAffirmHr(
            pDispA->Invoke(
                dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET,
                &dispparamsNoArgs, &varRetA, NULL, NULL ) );
        WsbAffirmHr(
            pDispB->Invoke(
                dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET,
                &dispparamsNoArgs, &varRetB, NULL, NULL ) );

        WsbAffirmPointer( (WCHAR*)varRetA );
        WsbAffirmPointer( (WCHAR*)varRetB );
        *pnResult = _wcsicmp( (WCHAR*)varRetA, (WCHAR*)varRetB );

        //
        // If results are that they are the same (and not first column)
        // than compare the first column (the Name)
        //
        if( ( 0 == *pnResult ) && ( col > 0 ) ) {

            *pnResult = 0; // Compare first Column if same
            WsbAffirmHr( Compare( 0, CookieA, CookieB, pnResult ) );

        }
        WsbTrace( L"CSakSnap::Compare: *pnResult = <%ls>, SortKeyA = <%ls>, SortKeyB = <%ls>\n", WsbPtrToLongAsString( (LONG*)pnResult ), (WCHAR*)varRetA, (WCHAR*)varRetB );

    } WsbCatch( hr );

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\csakdata.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    CSakData.h

Abstract:

    IComponentData implementation for Snapin.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#ifndef _CSAKDATA_H
#define _CSAKDATA_H

#define RS_SCOPE_IMAGE_ARRAY_MAX  100

//typedef struct {
//  USHORT listViewId;
//  USHORT colCount;
//  USHORT columnWidths[BHSM_MAX_CHILD_PROPS];
//} COLUMN_WIDTH_SET_PROP_PAGE;

// Maximum number of listview controls that have their properties saved
// #define MAX_LISTVIEWS 20

/////////////////////////////////////////////////////////////////////////////
// CSakDataWnd window
class CSakData;

class CSakDataWnd : public CWnd
{
// Construction
public:
    CSakDataWnd( ) {};

    BOOL Create( CSakData * pSakData );
    virtual void PostNcDestroy( );

// Attributes
public:
    CSakData * m_pSakData;

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSakDataWnd)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CSakDataWnd() {};

    // Generated message map functions
#define WM_SAKDATA_UPDATE_ALL_VIEWS ( WM_USER + 1 )
#define WM_SAKDATA_REFRESH_NODE     ( WM_USER + 2 )
    void PostUpdateAllViews( MMC_COOKIE Cookie );
    void PostRefreshNode( MMC_COOKIE Cookie );

protected:
    //{{AFX_MSG(CSakDataWnd)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    virtual LONG OnUpdateAllViews( UINT, IN LONG lParam );
    virtual LONG OnRefreshNode( UINT, IN LONG lParam );
    DECLARE_MESSAGE_MAP()
};


class CSakDataNodePrivate
{
public:
    CSakDataNodePrivate( ISakNode* pNode );
    ~CSakDataNodePrivate( );

    static HRESULT Verify( CSakDataNodePrivate* pNodePriv );


    DWORD             m_Magic;
    CComPtr<ISakNode> m_pNode;
};
#define RS_NODE_MAGIC_GOOD     ((DWORD)0xF0E1D2C3)
#define RS_NODE_MAGIC_DEFUNCT  ((DWORD)0x4BADF00D)

/////////////////////////////////////////////////////////////////////////////
// COM class representing the SakSnap snapin object
class ATL_NO_VTABLE CSakData : 
    public IComponentData,      // Access to cached info
    public IExtendPropertySheet2,// add pages to the property sheet of an item.
    public IExtendContextMenu,  // add items to context menu of an item
    public ISnapinHelp2,        // Add support for HTMLHelp
    public IDataObject,         // To support data object queries.
    public ISakSnapAsk,         // provided so that nodes can query snapin info
    public IPersistStream,
    public CComObjectRoot      // handle object reference counts for objects
//  public CComCoClass<CSakData,&CLSID_HsmAdminData>
{
public:
    CSakData() {};

BEGIN_COM_MAP(CSakData)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendPropertySheet2)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(ISakSnapAsk)
    COM_INTERFACE_ENTRY(ISnapinHelp)
    COM_INTERFACE_ENTRY(ISnapinHelp2)
    COM_INTERFACE_ENTRY(IPersistStream)
END_COM_MAP()

static UINT    m_cfMultiSelect;
static UINT    m_cfObjectTypes;

public:
    virtual const CLSID& GetCoClassID() = 0;
    virtual const BOOL IsPrimaryImpl() = 0;

public:
    static UINT m_nImageArray[RS_SCOPE_IMAGE_ARRAY_MAX];
    static INT  m_nImageCount;

// IComponentData
public:
    STDMETHOD( Initialize )      ( IUnknown* pUnk );
    STDMETHOD( CreateComponent ) ( IComponent** ppComponent );
    STDMETHOD( Notify )          ( IDataObject* pDataObject, MMC_NOTIFY_TYPE, LPARAM arg, LPARAM param );
    STDMETHOD( Destroy )         ( void );
    STDMETHOD( QueryDataObject ) ( MMC_COOKIE cookie, DATA_OBJECT_TYPES, IDataObject** ppDataObject);
    STDMETHOD( GetDisplayInfo )  ( SCOPEDATAITEM* pScopeItem);
    STDMETHOD( CompareObjects )  ( IDataObject* pDataObjectA, IDataObject* pDataObjectB);

// IExtendPropertySheet interface
public:
    STDMETHOD( CreatePropertyPages )( LPPROPERTYSHEETCALLBACK lpProvider, RS_NOTIFY_HANDLE handle, LPDATAOBJECT lpIDataObject );
    STDMETHOD( QueryPagesFor )      ( LPDATAOBJECT lpDataObject );

// IExtendPropertySheet2 interface
public:
    STDMETHOD( GetWatermarks )   ( IN LPDATAOBJECT pDataObject, OUT HBITMAP* pWatermark, OUT HBITMAP* pHeader, OUT HPALETTE* pPalette, OUT BOOL* pStretch );

// IExtendContextMenu 
public:
    STDMETHOD( AddMenuItems )    ( IDataObject* pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, LONG* pInsertionAllowed );
    STDMETHOD( Command )         ( long nCommandID, IDataObject* pDataObject );

// ISnapinHelp2 
public:
    STDMETHOD( GetHelpTopic )    ( LPOLESTR * pHelpTopic );
    STDMETHOD( GetLinkedTopics ) ( LPOLESTR * pHelpTopic );

// IDataObject methods
public:
    // Implemented
    STDMETHOD( SetData )         ( LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease );
    STDMETHOD( GetData )         ( LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium );
    STDMETHOD( GetDataHere )     ( LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium );
    STDMETHOD( EnumFormatEtc )   ( DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc );

// IPersistStream methods
    STDMETHOD( Save )( IStream *pStm, BOOL fClearDirty ); 
    STDMETHOD( Load )( IStream *pStm );
    STDMETHOD( IsDirty )(void); 
    STDMETHOD( GetSizeMax )( ULARGE_INTEGER *pcbSize ); 
    STDMETHOD( GetClassID )( CLSID *pClassID ); 

    // Not Implemented
private:
    STDMETHOD( QueryGetData )    ( LPFORMATETC /*lpFormatetc*/ ) { return E_NOTIMPL; };
    STDMETHOD( GetCanonicalFormatEtc ) ( LPFORMATETC /*lpFormatetcIn*/, LPFORMATETC /*lpFormatetcOut*/ ) { return E_NOTIMPL; };
    STDMETHOD( DAdvise )         ( LPFORMATETC /*lpFormatetc*/, DWORD /*advf*/, LPADVISESINK /*pAdvSink*/, LPDWORD /*pdwConnection*/ ) { return E_NOTIMPL; };
    STDMETHOD( DUnadvise )       ( DWORD /*dwConnection*/ ) { return E_NOTIMPL; };
    STDMETHOD( EnumDAdvise )     ( LPENUMSTATDATA* /*ppEnumAdvise*/ ) { return E_NOTIMPL; };


// ISakSnapAsk interface members
public:
    STDMETHOD( GetNodeOfType )    ( REFGUID nodetype, ISakNode** ppUiNode );
    STDMETHOD( GetHsmServer )     ( IHsmServer** ppHsmServer );
    STDMETHOD( GetRmsServer )     ( IRmsServer** ppRmsServer );
    STDMETHOD( GetFsaServer )     ( IFsaServer** ppFsaServer );
    STDMETHOD( RefreshNode )      ( ISakNode* pNode );
    STDMETHOD( UpdateAllViews )   ( ISakNode* pUnkNode );
    STDMETHOD( ShowPropertySheet )( ISakNode* pUnkNode, IDataObject *pDataObject, INT initialPage );
    STDMETHOD( GetHsmName )       ( OUT OLECHAR ** pszName OPTIONAL );
    STDMETHOD( GetState )         ();
    STDMETHOD( Disable )          ( IN BOOL Disable = TRUE );
    STDMETHOD( IsDisabled )       ( );
    STDMETHOD( CreateWizard )     ( IN ISakWizard * pWizard );
    STDMETHOD( DetachFromNode )   ( IN ISakNode* pNode );

// Pseudo Constructor / Destructor
public:
    HRESULT FinalConstruct();
    void    FinalRelease();
    ULONG InternalAddRef( );
    ULONG InternalRelease( );


// helper method utilized by Data Object Functions 
private:
    HRESULT Retrieve            ( const void* pBuffer, DWORD len, LPSTGMEDIUM lpMedium );
    HRESULT RetrieveDisplayName ( LPSTGMEDIUM lpMedium );
    HRESULT RetrieveNodeTypeData( LPSTGMEDIUM lpMedium );
    HRESULT RetrieveNodeTypeStringData( LPSTGMEDIUM lpMedium );
    HRESULT RetrieveClsid       ( LPSTGMEDIUM lpMedium );

    static UINT    m_cfDisplayName;
    static UINT    m_cfNodeType;
    static UINT    m_cfNodeTypeString;  
    static UINT    m_cfClassId;

// Methods to work with the image lists
private:
    HRESULT OnAddImages();

// Methods to work between cookie, DataObject, and ISakNode*
public:
    HRESULT GetBaseHsmFromDataObject    ( IDataObject * pDataObject, ISakNode ** ppBaseHsm, IEnumGUID **ppObjectId = NULL, IEnumUnknown **ppUnkNode = NULL );
    HRESULT GetBaseHsmFromCookie        ( MMC_COOKIE Cookie, ISakNode ** ppBaseHsm );
    HRESULT GetDataObjectFromBaseHsm    ( ISakNode * pBaseHsm, IDataObject**ppDataObject );
    HRESULT GetDataObjectFromCookie     ( MMC_COOKIE Cookie, IDataObject**ppDataObject );
    HRESULT GetCookieFromBaseHsm        ( ISakNode * pBaseHsm, MMC_COOKIE * pCookie );
    HRESULT IsDataObjectMs              ( IDataObject *pDataObject );
    HRESULT IsDataObjectOt              ( IDataObject *pDataObject );
    HRESULT IsDataObjectMultiSelect     ( IDataObject *pDataObject );

// Helpers for un-ravelling multi-select data objects
private:
    HRESULT GetBaseHsmFromMsDataObject  ( IDataObject * pDataObject, ISakNode ** ppBaseHsm, IEnumGUID ** ppObjectId, IEnumUnknown **ppEnumUnk );
    HRESULT GetBaseHsmFromOtDataObject  ( IDataObject * pDataObject, ISakNode ** ppBaseHsm, IEnumGUID ** ppObjectId, IEnumUnknown **ppEnumUnk );

// Methods to work with nodes as data objects
private:
    HRESULT SetContextType           ( IDataObject* pDataObject, DATA_OBJECT_TYPES type );

// Notify event handlers
protected:
    HRESULT OnFolder        ( IDataObject *pDataObject, LPARAM arg, LPARAM param );
    HRESULT OnShow          ( IDataObject *pDataObject, LPARAM arg, LPARAM param );
    HRESULT OnSelect        ( IDataObject *pDataObject, LPARAM arg, LPARAM param );
    HRESULT OnMinimize      ( IDataObject *pDataObject, LPARAM arg, LPARAM param );
    HRESULT OnContextHelp   ( IDataObject *pDataObject, LPARAM arg, LPARAM param );
    HRESULT OnRemoveChildren( IDataObject *pDataObject );

    HRESULT RemoveChildren( ISakNode *pNode );

// Handle posted (delayed) messages from nodes.
public:
    HRESULT InternalUpdateAllViews( MMC_COOKIE Cookie );
    HRESULT InternalRefreshNode( MMC_COOKIE Cookie );
    HRESULT RefreshNodeEx( ISakNode * pNode );

private:    
    // Initialize the root node 
    HRESULT InitializeRootNode( void );

    // Guarantee that the children of a particular node are created in our hierarchical list.
    friend class CSakSnap;
    HRESULT EnsureChildrenAreCreated( ISakNode* pNode );
    HRESULT CreateChildNodes( ISakNode* pNode );

    // Enumerate the children of a node in scope pane.
    HRESULT EnumScopePane( ISakNode* pNode, HSCOPEITEM pParent );
    HRESULT FreeEnumChildren( ISakNode* pBaseHsmParent );

// Connection helper functions
    HRESULT AffirmServiceConnection(INT ConnType);
    HRESULT VerifyConnection(INT ConnType);
    HRESULT ClearConnections( );
    HRESULT RawConnect(INT ConnType);
    HRESULT RunSetupWizard(IHsmServer * pServer );
    HRESULT RetargetSnapin( );

// About Helper functions
private:
    HRESULT AboutHelper(UINT nID, LPOLESTR* lpPtr);

// Internal Data
private:
    static UINT m_CFMachineName;
    HRESULT GetServerFocusFromDataObject(IDataObject *pDataObject, CString& HsmName);

    // Interface pointers
    CComPtr<IConsole>          m_pConsole;        // Console's IFrame interface
    CComPtr<IConsoleNameSpace> m_pNameSpace;      // SakSnap interface pointer to scope pane
    CComPtr<IImageList>        m_pImageScope;     // SakSnap interface pointer to scope pane image list
    CComPtr<ISakNode>          m_pRootNode;       // Node tree root

    CComPtr<IHsmServer>        m_pHsmServer;      // Hsm Engine pointer
    CComPtr<IRmsServer>        m_pRmsServer;      // Rms pointer
    CComPtr<IFsaServer>        m_pFsaServer;      // Fsa pointer

    CString                    m_HsmName;         // name of Hsm to connect to.
    BOOL                       m_ManageLocal;     // To know if we should manage the local server.
    BOOL                       m_PersistManageLocal;  // To know if snapin configuration is transient.
    BOOL                       m_RootNodeInitialized; // To know if we need to init node on expand

    // Persistence data and functions
    BOOL                    m_IsDirty;

    // Store user profile data for the listviews in the property sheets
    // Note: result view data is stored in CSakSnap
//  COLUMN_WIDTH_SET_PROP_PAGE m_ListViewWidths[MAX_LISTVIEWS];
//  USHORT m_cListViewWidths;


    void SetDirty( BOOL b = TRUE ) { m_IsDirty = b; }
    void ClearDirty() { m_IsDirty = FALSE; }
    BOOL ThisIsDirty() { return m_IsDirty; }

    BOOL m_State;
    void SetState( BOOL State );
    BOOL m_FirstTime;
    BOOL m_Disabled;

    // Variables to track RMS's state separately, since it can be delayed
    // in coming up when other services are OK
    HRESULT m_HrRmsConnect;

// Static functions
public:
    static INT AddImage( UINT rId );

//
// Command Line parsing functions
//  
private:
    class CParamParse : public CCommandLineInfo {

    public:
        CParamParse( ) : m_ManageLocal( 0 ), m_SetHsmName( 0 ), m_SetManageLocal( 0 ), m_SetPersistManageLocal( 0 ) { }

        virtual void ParseParam( LPCTSTR lpszParam, BOOL bFlag, BOOL bLast );

        CString m_HsmName;
        BOOL    m_ManageLocal;
        BOOL    m_PersistManageLocal;

        BOOL    m_SetHsmName;
        BOOL    m_SetManageLocal;
        BOOL    m_SetPersistManageLocal;

        static const CString m_DsFlag;

    };

    CParamParse m_Parse;

    void InitFromCommandLine( );
    
    CSakDataWnd *m_pWnd;
};


class CSakDataPrimaryImpl : public CSakData,
    public CComCoClass<CSakDataPrimaryImpl, &CLSID_HsmAdminDataSnapin>
{
public:
    DECLARE_REGISTRY_RESOURCEID(IDR_HsmAdminDataSnapin)
    virtual const CLSID & GetCoClassID() { return CLSID_HsmAdminDataSnapin; }
    virtual const BOOL IsPrimaryImpl() { return TRUE; }
};

class CSakDataExtensionImpl : public CSakData,
    public CComCoClass<CSakDataExtensionImpl, &CLSID_HsmAdminDataExtension>
{
public:
    DECLARE_REGISTRY_RESOURCEID(IDR_HsmAdminDataExtension)
    virtual const CLSID & GetCoClassID(){ return CLSID_HsmAdminDataExtension; }
    virtual const BOOL IsPrimaryImpl() { return FALSE; }
};

/////////////////////////////////////////////////////////////////////////////


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\csaksnap.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    CSakSnap.h

Abstract:

    Implementation of IComponent for Snapin.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#ifndef CSAKSNAP_H
#define CSAKSNAP_H

#define RS_RESULT_IMAGE_ARRAY_MAX 100

typedef struct {
    GUID nodeTypeId;
    USHORT colCount;
    USHORT columnWidths[BHSM_MAX_CHILD_PROPS];
} COLUMN_WIDTH_SET;

class CSakData;

/////////////////////////////////////////////////////////////////////////////
// COM class representing the SakSnap snapin object
class  ATL_NO_VTABLE CSakSnap : 
    public IComponent,          // interface that console calls into
    public IExtendPropertySheet,// add pages to the property sheet of an item. 
    public IExtendContextMenu,  // add items to context menu of an item
    public IExtendControlbar,   // add items to control bar of an item
    public IResultDataCompare,  // So we can custom sort
    public IPersistStream,
    public CComObjectRoot,      // handle object reference counts for objects
    public CComCoClass<CSakSnap,&CLSID_HsmAdmin>
{

public:
    CSakSnap( ) {};

BEGIN_COM_MAP(CSakSnap)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendControlbar)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IResultDataCompare)
END_COM_MAP()


DECLARE_REGISTRY_RESOURCEID(IDR_HsmAdmin)


// IComponent interface members
public:
    STDMETHOD( Initialize )      ( IConsole* pConsole);
    STDMETHOD( Notify )          ( IDataObject* pDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param );
    STDMETHOD( Destroy )         ( MMC_COOKIE cookie );
    STDMETHOD( GetResultViewType )(MMC_COOKIE cookie,  BSTR* ppViewType, long * pViewOptions );
    STDMETHOD( QueryDataObject ) ( MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject** ppDataObject );
    STDMETHOD( GetDisplayInfo )  ( LPRESULTDATAITEM pScopeItem );
    STDMETHOD( CompareObjects )  ( IDataObject* pDataObjectA, IDataObject* pDataObjectB );

// IExtendPropertySheet interface
public:
    STDMETHOD( CreatePropertyPages )( LPPROPERTYSHEETCALLBACK lpProvider, RS_NOTIFY_HANDLE handle, LPDATAOBJECT lpIDataObject );
    STDMETHOD( QueryPagesFor )      ( LPDATAOBJECT lpDataObject );

// IExtendContextMenu 
public:
    STDMETHOD( AddMenuItems )    ( IDataObject* pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, LONG* pInsertionAllowed );
    STDMETHOD( Command )         ( long nCommandID, IDataObject* pDataObject );

// IExtendControlbar
    STDMETHOD( SetControlbar )   ( LPCONTROLBAR pControlbar );
    STDMETHOD( ControlbarNotify )( MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param );

// IResultDataCompare
    STDMETHOD( Compare )         ( IN LPARAM lUserParam, IN MMC_COOKIE CookieA, IN MMC_COOKIE CookieB, IN OUT int* pnResult );

// IPersistStream methods
    STDMETHOD( Save )( IStream *pStm, BOOL fClearDirty ); 
    STDMETHOD( Load )( IStream *pStm );
    STDMETHOD( IsDirty )(void); 
    STDMETHOD( GetSizeMax )( ULARGE_INTEGER *pcbSize ); 
    STDMETHOD( GetClassID )( CLSID *pClassID ); 

public:

// Notify event handlers
protected:
    HRESULT OnFolder        (IDataObject * pNode, LPARAM arg, LPARAM param);
    HRESULT OnShow          (IDataObject * pNode, LPARAM arg, LPARAM param);
    HRESULT OnSelect        (IDataObject * pNode, LPARAM arg, LPARAM param);
    HRESULT OnMinimize      (IDataObject * pNode, LPARAM arg, LPARAM param);
    HRESULT OnChange        (IDataObject * pNode, LPARAM arg, LPARAM param);
    HRESULT OnRefresh       (IDataObject * pNode, LPARAM arg, LPARAM param);
    HRESULT OnDelete        (IDataObject * pNode, LPARAM arg, LPARAM param);

// Toolbar event handler
    void CSakSnap::OnSelectToolbars(LPARAM arg, LPARAM param);

// Pseudo Constructor / Destructor
public:
    HRESULT FinalConstruct();
    void    FinalRelease();

// Methods to work with the image lists
private:
    // Given an HICON, return "virtual index" from result pane's image list
    CComPtr<IImageList>        m_pImageResult;    // SakSnap interface pointer to result pane image list
    HRESULT OnAddImages();
    HRESULT OnToolbarButtonClick(LPARAM arg, LPARAM param);

protected:
    // Enumerate the children of a node in result pane.
    HRESULT EnumResultPane( ISakNode* pNode );

    // functions to initialize headers in result view
    HRESULT InitResultPaneHeaders( ISakNode* pNode );

    // function to clear all icons of the node's children
    HRESULT ClearResultIcons( ISakNode* pNode );

// Interface pointers
protected:
    friend class CSakData;

    CComPtr<IConsole>       m_pConsole;     // Console's IFrame interface
    CComPtr<IResultData>    m_pResultData;
    CComPtr<IHeaderCtrl>    m_pHeader;      // Result pane's header control interface
    CComPtr<IControlbar>    m_pControlbar;  // control bar to hold my tool bars
    CComPtr<IConsoleVerb>   m_pConsoleVerb;
    CComPtr<IToolbar>       m_pToolbar;     // Toolbar for view
    CSakData *              m_pSakData;     // Pointer to owning SakData

private:
    CComPtr<ISakNode>       m_pEnumeratedNode;
    MMC_COOKIE              m_ActiveNodeCookie;  // ISakNode of active node in scope pane
    HRESULT                 ClearResultPane();
    HRESULT                 EnumRootDisplayProps( IEnumString ** ppEnum );

    // Contains column widths for a given node type COLUMN_WIDTH_SET    
    COLUMN_WIDTH_SET    m_ChildPropWidths[ BHSM_MAX_NODE_TYPES ];
    USHORT              m_cChildPropWidths;

    HRESULT GetSavedColumnWidths( ISakNode *pNode, INT *pColCount, INT *pColumnWidths );
    HRESULT SaveColumnWidths( ISakNode *pNode );

    // Image Array
public:
    static UINT m_nImageArray[RS_RESULT_IMAGE_ARRAY_MAX];
    static INT  m_nImageCount;

    // Static functions
public:
    static INT AddImage( UINT rId );


};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\dlldatax.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    DllDataX.h

Abstract:

    Help wrap dlldata.c

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
    LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\dataobj.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    DataObj.cpp

Abstract:

    Implementation of IDataObject interface, which is supported
    by the CBaseHsm COM object.

Author:

    Rohde Wakefield [rohde]   19-Aug-1997

Revision History:

--*/

#include "stdafx.h"

// Declare Snap-in NodeType formats:
// - GUID format
// - string GUID format
// - display name format.
// - internal format.
UINT CSakNode::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
UINT CSakNode::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);  
UINT CSakNode::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME); 
UINT CSakNode::m_cfInternal       = RegisterClipboardFormat(SAKSNAP_INTERNAL); 
UINT CSakNode::m_cfClassId        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);  
UINT CSakNode::m_cfComputerName   = RegisterClipboardFormat(MMC_SNAPIN_MACHINE_NAME); 
UINT CSakNode::m_cfEventLogViews  = RegisterClipboardFormat(CF_EV_VIEWS); 


HRESULT
CSakNode::GetDataGeneric(
    IN     LPFORMATETC lpFormatetcIn,
    IN OUT LPSTGMEDIUM lpMedium,
    IN     BOOL DoAlloc
    )
/*++

Routine Description:

    Retrieve information FROM the dataobject and put INTO lpMedium.

Arguments:

    lpFormatetc     - Format to retreive.

    lpMedium        - Storage to put information into.

Return Value:

    S_OK            - Storage filled in.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakNode::GetDataGeneric", L"lpFormatetc->cfFormat = <%ls>", RsClipFormatAsString( lpFormatetcIn->cfFormat ), WsbBoolAsString( DoAlloc ) );
    HRESULT hr = DV_E_CLIPFORMAT;

    try {

        WsbAffirmPointer( lpMedium );

        if( DoAlloc ) {

            lpMedium->hGlobal = 0;
            lpMedium->tymed   = TYMED_HGLOBAL;

        } else {

            WsbAffirm( TYMED_HGLOBAL == lpMedium->tymed, DV_E_TYMED );
            WsbAffirmPointer( lpMedium->hGlobal );

        }

        // Based on the CLIPFORMAT write data to "lpMediam" in the correct format.
        const CLIPFORMAT cf = lpFormatetcIn->cfFormat;

        // clip format is the GUID node type
        if(cf == m_cfNodeType) {
            hr = RetrieveNodeTypeData(lpMedium);

        // clip format is the string "spelling" of the GUID node type
        } else if(cf == m_cfNodeTypeString) {
            hr = RetrieveNodeTypeStringData(lpMedium);

        // clip format is the computer represented
        } else if (cf == m_cfComputerName) {
            hr = RetrieveComputerName(lpMedium);

        // clip format is the event viewer setup
        } else if (cf == m_cfEventLogViews) {
            hr = RetrieveEventLogViews(lpMedium);

        // clip format is the display name of the node
        } else if (cf == m_cfDisplayName) {
            hr = RetrieveDisplayName(lpMedium);

        // clip format is the ClassId
        } else if( cf == m_cfClassId ) {
            hr = RetrieveClsid( lpMedium );

        // clip format is an INTERNAL format
        } else if (cf == m_cfInternal) {
            hr = RetrieveInternal(lpMedium);

        } else {
            hr = DV_E_CLIPFORMAT;
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::GetDataGeneric", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP
CSakNode::GetData(
    IN  LPFORMATETC lpFormatetcIn,
    OUT LPSTGMEDIUM lpMedium
    )
/*++

Routine Description:

    Retrieve information FROM the dataobject and put INTO lpMedium.
    Storage allocated and returned.

Arguments:

    lpFormatetc     - Format to retreive.

    lpMedium        - Storage to put information into.

Return Value:

    S_OK            - Storage filled in.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakNode::GetData", L"lpFormatetc->cfFormat = <%ls>", RsClipFormatAsString( lpFormatetcIn->cfFormat ) );

    HRESULT hr = S_OK;

    hr = GetDataGeneric( lpFormatetcIn, lpMedium, TRUE );

    WsbTraceOut( L"CSakNode::GetData", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP
CSakNode::GetDataHere(
    IN     LPFORMATETC lpFormatetc,
    IN OUT LPSTGMEDIUM lpMedium
    )
/*++

Routine Description:

    Retrieve information FROM the dataobject and put INTO lpMedium.

Arguments:

    lpFormatetc     - Format to retreive.

    lpMedium        - Storage to put information into.

Return Value:

    S_OK            - Storage filled in.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakNode::GetDataHere", L"lpFormatetc->cfFormat = <%ls>", RsClipFormatAsString( lpFormatetc->cfFormat ) );
    HRESULT hr = S_OK;

    hr = GetDataGeneric( lpFormatetc, lpMedium, FALSE );

    WsbTraceOut( L"CSakNode::GetDataHere", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP
CSakNode::SetData(
    LPFORMATETC lpFormatetc,
    LPSTGMEDIUM lpMedium,
    BOOL        /*fRelease*/
    )
/*++

Routine Description:

    Put data INTO a dataobject FROM the information in the lpMedium.
    We do not allow any data to be set.

Arguments:

    lpFormatetc     - Format to set.

    lpMedium        - Storage to get information from.

    fRelease        - Indicates who owns storage after call.

Return Value:

    S_OK            - Storage retreived.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakNode::SetData", L"lpFormatetc->cfFormat = <%ls>", RsClipFormatAsString( lpFormatetc->cfFormat ) );
    HRESULT hr = DV_E_CLIPFORMAT;

    // Based on the CLIPFORMAT write data to "lpMediam" in the correct format.
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    //clip format is an INTERNAL format
    if( cf == m_cfInternal ) {

        hr = StoreInternal( lpMedium );

    }

    WsbTraceOut( L"CSakNode::SetData", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

///////////////////////////////////////////////////////////////////////
// Note - CSakNode does not implement these
///////////////////////////////////////////////////////////////////////

STDMETHODIMP CSakNode::EnumFormatEtc(DWORD /*dwDirection*/, LPENUMFORMATETC* /*ppEnumFormatEtc*/)
{
    WsbTraceIn( L"CSakNode::EnumFormatEtc", L"" );

    HRESULT hr = E_NOTIMPL;

    WsbTraceOut( L"CSakNode::EnumFormatEtc", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

// Retrieve from a dataobject with the NodeType (GUID) data in it.
HRESULT CSakNode::RetrieveNodeTypeData(LPSTGMEDIUM lpMedium)
{
    return Retrieve((const void*)(m_rTypeGuid), sizeof(GUID), lpMedium);
}

// Retrieve from a dataobject with the node type object in GUID string format
HRESULT CSakNode::RetrieveNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    CWsbStringPtr guidString = *m_rTypeGuid;
    return Retrieve(guidString, ((wcslen(guidString)+1) * sizeof(wchar_t)), lpMedium);
}

// Retrieve from a dataobject with the display named used in the scope pane
HRESULT CSakNode::RetrieveDisplayName(LPSTGMEDIUM lpMedium)
{
    // Load the name the data object
    return Retrieve(m_szName, ((wcslen(m_szName)+1) * sizeof(wchar_t)), lpMedium);
}

//  Retrieve from a dataobject with the CLSID data in it.
HRESULT CSakNode::RetrieveClsid(LPSTGMEDIUM lpMedium)
{
    // zzzz
    return Retrieve( (const void*)(&CLSID_HsmAdminDataSnapin), sizeof(CLSID), lpMedium );
}

// Retrieve INTERNAL data from the dataobject's m_internal member INTO the lpMedium
HRESULT CSakNode::RetrieveInternal(LPSTGMEDIUM lpMedium)
{
    return Retrieve(&m_internal, sizeof(INTERNAL), lpMedium);
}

// Retrieve data from the dataobject's hsm name
HRESULT CSakNode::RetrieveComputerName(LPSTGMEDIUM lpMedium)
{
    HRESULT hr = S_OK;

    try {

        CWsbStringPtr computerName;
        HRESULT hrTemp = m_pSakSnapAsk->GetHsmName( &computerName );
        WsbAffirmHr( hrTemp );

        if( S_FALSE == hrTemp ) {

            computerName = L"";

        }

        WsbAffirmHr( 
            Retrieve(
                (WCHAR*)computerName,
                ( wcslen( computerName ) + 1 ) * sizeof(WCHAR),
                lpMedium ) );

    } WsbCatch( hr );

    return( hr );
}

// Retrieve event setup info
HRESULT CSakNode::RetrieveEventLogViews(LPSTGMEDIUM lpMedium)
{
    HRESULT hr = S_OK;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    try {

        BYTE buf[1024];
        BYTE *pPos = buf;
        size_t strLength;

        CWsbStringPtr hsmName;
        CString appName, sysName;
        CString nullString;
        CString appPath, sysPath;

        appName.LoadString( IDS_EVENT_LOG_APP_TITLE );
        sysName.LoadString( IDS_EVENT_LOG_SYS_TITLE );
        nullString = L"";

        HRESULT hrTemp = m_pSakSnapAsk->GetHsmName( &hsmName );
        WsbAffirmHr( hrTemp );
        if( S_FALSE == hrTemp ) {

            hsmName = L"";
            appPath = L"";
            sysPath = L"";

        } else {

            CString configPath = L"\\\\";
            configPath += hsmName;
            configPath += L"\\Admin$\\System32\\config\\";
            appPath = configPath;
            sysPath = configPath;
            appPath += L"AppEvent.Evt";
            sysPath += L"SysEvent.Evt";

        }
        
// Make sure that the data is processor word size aligned
#if defined(_X86_)
#define _RNDUP(p,m) (p)
#else
#define _RNDUP(p,m) (BYTE *)(((ULONG_PTR)(p) + (m) - 1) & ~((ULONG_PTR)(m) - 1))
#endif

#define ADD_TYPE(data, type) \
    pPos = _RNDUP(pPos, __alignof(type)); \
    *((type*)pPos) = (type)(data); \
    pPos += sizeof(type)

#define ADD_USHORT(us) ADD_TYPE(us, USHORT)
#define ADD_BOOL(b)    ADD_TYPE(b,  BOOL)
#define ADD_ULONG(ul)  ADD_TYPE(ul, ULONG)
#define ADD_STRING(str) \
    strLength = wcslen((LPCWSTR)(str)) + 1;           \
    ADD_USHORT(strLength);                            \
    wcsncpy((LPWSTR)pPos, (LPCWSTR)(str), strLength); \
    pPos += strLength * sizeof(WCHAR);


        //
        // Add header info
        //
        ADD_BOOL( TRUE ); // fOnlyTheseViews
        ADD_USHORT( 2 );  // cViews

        //
        // Add application log filtered for our services
        //
        ADD_ULONG( ELT_APPLICATION );      // Type;
        ADD_USHORT( VIEWINFO_FILTERED | 
                    LOGINFO_DONT_PERSIST); // flViewFlags
        ADD_STRING( hsmName );             // ServerName
        ADD_STRING( L"Application" );      // SourceName
        ADD_STRING( appPath );             // FileName
        ADD_STRING( appName );             // DisplayName

        ADD_ULONG( EVENTLOG_ALL_EVENTS );  // flRecType (could filter warning, error, etc.)
        ADD_USHORT( 0 );                   // usCategory
        ADD_BOOL( FALSE );                 // fEventID
        ADD_ULONG( 0 );                    // ulEventID
        ADD_STRING( WSB_LOG_SOURCE_NAME ); // szSourceName
        ADD_STRING( nullString );          // szUser
        ADD_STRING( hsmName );             // szComputer
        ADD_ULONG( 0 );                    // ulFrom
        ADD_ULONG( 0 );                    // ulTo

        //
        // Add system log filtered for our device
        //
        ADD_ULONG( ELT_SYSTEM );           // Type;
        ADD_USHORT( VIEWINFO_FILTERED | 
                    LOGINFO_DONT_PERSIST); // flViewFlags
        ADD_STRING( hsmName );             // ServerName
        ADD_STRING( L"System" );           // SourceName
        ADD_STRING( sysPath );             // FileName
        ADD_STRING( sysName );             // DisplayName

        ADD_ULONG( EVENTLOG_ALL_EVENTS );  // flRecType (could filter warning, error, etc.)
        ADD_USHORT( 0 );                   // usCategory
        ADD_BOOL( FALSE );                 // fEventID
        ADD_ULONG( 0 );                    // ulEventID
        ADD_STRING( WSB_LOG_FILTER_NAME ); // szSourceName
        ADD_STRING( nullString );          // szUser
        ADD_STRING( hsmName );             // szComputer
        ADD_ULONG( 0 );                    // ulFrom
        ADD_ULONG( 0 );                    // ulTo

        WsbAffirmHr( Retrieve( buf, (ULONG)(pPos - buf), lpMedium ) );

    } WsbCatch( hr );

    return( hr );
}

// Store the INTERNAL data FROM the lpMedium->hGlobal INTO the dataobject's m_internal member
HRESULT CSakNode::StoreInternal(LPSTGMEDIUM lpMedium)
{
    return Store(&m_internal, sizeof(INTERNAL), lpMedium);
}

// Retrieve FROM a dataobject INTO a lpMedium. The data object can be one of
// several types of data in it (nodetype, nodetype string, display name, or 
// INTERNAL data). 
// This function moves data from pBuffer to the lpMedium->hGlobal
//
HRESULT CSakNode::Retrieve(const void* pBuffer, DWORD len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pBuffer );
        WsbAffirmPointer( lpMedium );
        WsbAffirm( TYMED_HGLOBAL == lpMedium->tymed, DV_E_TYMED );

        //
        // Check to see if we need to allocate the global memory here
        //
        if( 0 == lpMedium->hGlobal ) {

            lpMedium->hGlobal = ::GlobalAlloc( GPTR, len );

        } else {

            WsbAffirm( GlobalSize( lpMedium->hGlobal ) >= (DWORD)len, STG_E_MEDIUMFULL );

        }

        WsbAffirmPointer( lpMedium->hGlobal );

        // Create the stream on the hGlobal passed in. When we write to the stream,
        // it simultaneously writes to the hGlobal the same information.
        LPSTREAM lpStream;
        WsbAffirmHr( CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream ));

        // Write 'len' number of bytes from pBuffer into the stream. When we write
        // to the stream, it simultaneously writes to the global memory we
        // associated it with above.
        ULONG numBytesWritten;
        WsbAffirmHr( lpStream->Write(pBuffer, len, &numBytesWritten ));

        // Because we told CreateStreamOnHGlobal with 'FALSE', only the stream is released here.
        // Note - the caller (i.e. snap-in, object) will free the HGLOBAL 
        // at the correct time.  This is according to the IDataObject specification.
        lpStream->Release();

    } WsbCatch( hr );

    return hr;
}

// Store INTO a dataobject FROM an lpMedium. The data object can be one of
// several types of data in it (nodetype, nodetype string, display name, or 
// INTERNAL data). 
// This function moves data INTO pBuffer FROM the lpMedium->hGlobal
//
HRESULT CSakNode::Store( void* pBuffer, DWORD len, LPSTGMEDIUM lpMedium )
{
    HRESULT hr = S_OK;

    try {
        WsbAffirmPointer( pBuffer );
        WsbAffirmPointer( lpMedium );
        WsbAffirm( lpMedium->tymed == TYMED_HGLOBAL, E_INVALIDARG );

        // Use memcpy, because the lpStream->Read is failing to read any bytes. 
        memcpy(pBuffer, &(lpMedium->hGlobal), len);

    } WsbCatch( hr );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\evntsnap.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    evntsnap.cpp

Abstract:

    This module is responsible for handling the notification
    calls from MMC for CSakSnap.

Author:

    Rohde Wakefield [rohde]   06-Mar-1997

Revision History:

--*/


#include "stdafx.h"
#include "CSakSnap.h"
#include "CSakData.h"





HRESULT
CSakSnap::OnShow(
    IN  IDataObject*    pDataObject,
    IN  LPARAM            arg,
    IN  LPARAM            param
    )
/*++

Routine Description:

    The result view is just about to be shown. 
    Set the headers for the result view.
    Param is the unique identifier (an HSCOPEITEM) of the 
    selected or deselected item.

Arguments:

    pDataObject           - The node which is showing.

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakSnap::OnShow", L"pDataObject = <0x%p>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, arg, arg, param, param );
    HRESULT hr = S_OK;

    try {

        CComPtr<ISakNode> pNode;
        //
        // We've got a regular data object (single select)
        //
        WsbAffirmHr( m_pSakData->GetBaseHsmFromDataObject( pDataObject, &pNode, NULL ) );

        //
        // Arg is TRUE when it is time to enumerate
        //

        if( arg ) {

            //
            // Initialize child node list prior to graphically enumerating them
            //
            WsbAffirmHr( m_pSakData->EnsureChildrenAreCreated( pNode ) );

            //
            // Show the the node's children column headers in the result view.
            //
            WsbAffirmHr( InitResultPaneHeaders( pNode ) );

            //
            // Enumerate both the scope and result views. "Param" contains the 
            // HSCOPEITEM of the node being shown.
            //
            WsbAffirmHr( EnumResultPane( pNode ) );

        } else {

            //
            // The node is being contracted - save the result pane configuration
            //

            //
            // Save them in CSakSnap for this node
            //
            WsbAffirmHr( SaveColumnWidths( pNode ) );

            //
            // Free data associated with the result pane items, because
            // your node is no longer being displayed.
            // Note: The console will remove the items from the result pane
            //
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::OnShow", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakSnap::OnChange(
    IN  IDataObject*    pDataObject,
    IN  LPARAM         arg,
    IN  LPARAM         param
    )
/*++

Routine Description:

    Update the scope and result panes from the already existing objects.

Arguments:

    pNode           - The node which is showing.

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakSnap::OnChange", L"pDataObject = <0x%p>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, arg, arg, param, param );

    HRESULT hr = S_OK;

    try {

        CComPtr<ISakNode> pNode;
        MMC_COOKIE cookie;

        //
        // We've got a regular data object (single select)
        //
        WsbAffirmHr( m_pSakData->GetBaseHsmFromDataObject( pDataObject, &pNode, NULL ) );
        WsbAffirmHr( m_pSakData->GetCookieFromBaseHsm( pNode, &cookie ) );

        //
        // Find out if object is still valid
        //
        if( S_OK == pNode->IsValid( ) ) {

            //
            // Refresh the object itself
            //
            pNode->RefreshObject( );

            //
            // If this node's children are currently enumerated in the result pane, 
            // delete and recreate all children
            //
            if( pNode == m_pEnumeratedNode ) {

                //
                // Re-show the the node's children column headers in the result view.
                // We do this because some views may change the number of columns they show
                //

                //
                // Save the current configuration
                //
                WsbAffirmHr( SaveColumnWidths( pNode ) );

                //
                // Clear out the MMC Result Pane
                //
                WsbAffirmHr( ClearResultPane() );

                //
                // Recreate the headers
                //
                WsbAffirmHr( InitResultPaneHeaders( pNode ) );

                //
                // Refresh the children
                //
                MMC_COOKIE cookie;
                WsbAffirmHr( m_pSakData->GetCookieFromBaseHsm( pNode, &cookie ) );
                WsbAffirmHr( m_pSakData->InternalRefreshNode( cookie ) );

                //
                // Redisplay children in the result pane
                //
                WsbAffirmHr( EnumResultPane( pNode ) );

            } else {

                //
                // If this is the active node (but not displayed in the result pane, 
                //  destroy and recreate it's child nodes
                //
                if( cookie == m_ActiveNodeCookie) {

                    //   
                    // This node's children are not currently in the result pane.
                    // Refresh the children
                    //
                    WsbAffirmHr( m_pSakData->RefreshNode( pNode ) );

                }
            }

            //
            // Is this a leaf node?
            //
            if( pNode->IsContainer() != S_OK ) {

                //
                // Redisplay in the result pane
                // Tell MMC to update the item
                //
                // Get the cookie for the node
                //
                if( cookie > 0 ) {

                    HRESULTITEM itemID;
                    WsbAffirmHr( m_pResultData->FindItemByLParam( cookie, &itemID ) );

                    //
                    // Force the result pane to udpate this item
                    // Note that we have to force an icon update ourselves
                    //
                    RESULTDATAITEM resultItem;
                    memset( &resultItem, 0, sizeof(RESULTDATAITEM) );

                    resultItem.itemID = itemID;
                    WsbAffirmHr( pNode->GetResultIcon( m_pSakData->m_State, &resultItem.nImage ) );
                    resultItem.mask |= RDI_IMAGE;

                    WsbAffirmHr( m_pResultData->SetItem( &resultItem ) );
                    WsbAffirmHr( m_pResultData->UpdateItem( itemID ) );

                }
            }

        } else {

            //
            // Not valid - have parent update
            //
            CComPtr<ISakNode> pParentNode;
            WsbAffirmHr( pNode->GetParent( &pParentNode ) );
            WsbAffirmHr( m_pSakData->UpdateAllViews( pParentNode ) );

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::OnChange", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakSnap::OnRefresh(
    IN  IDataObject*    pDataObject,
    IN  LPARAM         arg,
    IN  LPARAM         param
    )
/*++

Routine Description:

Arguments:

    pNode           - The node

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakSnap::OnRefresh", L"pDataObject = <0x%p>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, arg, arg, param, param );

    HRESULT hr = S_OK;

    try {

        CComPtr<ISakNode> pNode;
        
        //
        // We've got a regular data object (single select)
        //
        WsbAffirmHr( m_pSakData->GetBaseHsmFromDataObject( pDataObject, &pNode, NULL ) );
        WsbAffirmHr( m_pSakData->UpdateAllViews( pNode ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::OnRefresh", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CSakSnap::OnDelete(
    IN  IDataObject*    pDataObject,
    IN  LPARAM         arg,
    IN  LPARAM         param
    )
/*++

Routine Description:

Arguments:

    pDataObject           - The node

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakSnap::OnDelete", L"pDataObject = <0x%p>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, arg, arg, param, param );

    HRESULT hr = S_OK;
    CComPtr<ISakNode> pNode;

    try {

        //
        // We've got a regular data object (single select)
        //
        WsbAffirmHr( m_pSakData->GetBaseHsmFromDataObject( pDataObject, &pNode, NULL ) );
        WsbAffirmHr ( pNode->DeleteObject() );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::OnDelete", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}




HRESULT
CSakSnap::OnSelect(
    IN  IDataObject*    pDataObject,
    IN  LPARAM            arg,
    IN  LPARAM            param
    )
/*++

Routine Description:

    Called when a node is selected.  If the node is in the scope pane,
    save it as the currently active node.

Arguments:

    pNode           - The 

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakSnap::OnSelect", L"pDataObject = <0x%p>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, arg, arg, param, param );
    BOOL bState;
    BOOL bMultiSelect;
    MMC_CONSOLE_VERB defaultVerb = MMC_VERB_NONE;
    HRESULT hr = S_OK;

    try {

        CComPtr<IEnumGUID> pEnumObjectId;
        CComPtr<ISakNode>  pNode;
        WsbAffirmHr( m_pSakData->GetBaseHsmFromDataObject( pDataObject, &pNode, &pEnumObjectId ) );
        // If we got back an enumeration, we're doing multi-select
        bMultiSelect = pEnumObjectId ? TRUE : FALSE;

        bState = ( m_pSakData->GetState() == S_OK );

        //
        // Set the verb state for the node
        //
        if( pNode->SupportsProperties( bMultiSelect ) == S_OK ) {

            if( bState || ( pNode->SupportsPropertiesNoEngine() == S_OK) ) {

                //
                // Engine OK - enable
                //
                WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, HIDDEN, FALSE ) );
                WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE ) );
                defaultVerb = MMC_VERB_PROPERTIES;

            } else { 

                //
                // Engine down - set to disabled
                //
                WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, HIDDEN, FALSE ) );
                WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, FALSE ) );

            }

        } else {

            WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, HIDDEN, TRUE) );

        }
        

        if( pNode->SupportsRefresh( bMultiSelect ) == S_OK ) {

            if( bState || ( pNode->SupportsRefreshNoEngine() == S_OK ) ) {

                WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, HIDDEN, FALSE ) );
                WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE ) );

            } else {

                WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, HIDDEN, TRUE ) );

            }

        } else {

            WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_REFRESH, HIDDEN, TRUE ) );

        }
        
        if( pNode->SupportsDelete( bMultiSelect ) == S_OK ) {

            WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_DELETE, HIDDEN, FALSE ) );
            WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_DELETE, ENABLED, bState ) );

        } else {

            WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_DELETE, HIDDEN, TRUE ) );

        }
            
        //
        // If container, default action should be to open, regardless
        // of any previous work
        //
        if( S_OK == pNode->IsContainer( ) ) {

            defaultVerb = MMC_VERB_OPEN;

        }

        WsbAffirmHr( m_pConsoleVerb->SetDefaultVerb( defaultVerb ) );

        // Standard functionality NOT support by all items
        WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_RENAME, HIDDEN, TRUE ) );
        WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_COPY,   HIDDEN, TRUE ) );
        WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_PASTE,  HIDDEN, TRUE ) );
        WsbAffirmHr( m_pConsoleVerb->SetVerbState( MMC_VERB_PRINT,  HIDDEN, TRUE ) );
        
        // Extract data from the arg
        BOOL bScope = (BOOL) LOWORD(arg);
        BOOL bSelect = (BOOL) HIWORD(arg);
        
        if( bScope && bSelect ) {

            WsbAffirmHr( m_pSakData->GetCookieFromBaseHsm( pNode, &m_ActiveNodeCookie ) );
        
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::OnSelect", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakSnap::OnMinimize(
    IN  IDataObject*    pDataObject,
    IN  LPARAM         arg,
    IN  LPARAM         param
    )
/*++

Routine Description:

Arguments:

    pNode           - The node

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakSnap::OnMinimize", L"pDataObject = <0x%p>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, arg, arg, param, param );

    HRESULT hr = S_OK;

    WsbTraceOut( L"CSakSnap::OnMinimize", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}



HRESULT
CSakSnap::EnumResultPane(
    IN  ISakNode* pNode
    )
/*++

Routine Description:

    Insert the child items into the result pane. 

Arguments:

    pNode           - The node which is expanding.

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakSnap::EnumResultPane", L"pNode = <0x%p>", pNode );

    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pNode );

        CComPtr<IResultData> pResult;
        WsbAffirmHr( m_pConsole->QueryInterface( IID_IResultData, (void**)&pResult ) );

        //
        // Clear the result pane
        //
        WsbAffirmHr( ClearResultPane() );

        //
        // allocate and initialize a result item.
        //
        RESULTDATAITEM resultItem;
        memset( &resultItem, 0, sizeof(RESULTDATAITEM) );
        
        //
        // Loop through this node's children (just one level deep).
        //
        if( pNode->IsContainer( ) == S_OK ) {

            CComPtr<IEnumUnknown> pEnum;        // child enumerator
            CComPtr<ISakNode>     pNodeChild;   // ISakNode pointer for the child
        
            //
            // Force a fresh list to be used - this way list is updated
            // WRT added or deleted nodes
            //
            if( S_OK == pNode->HasDynamicChildren( ) ) {

                WsbAffirmHr( m_pSakData->FreeEnumChildren( pNode ) );
                WsbAffirmHr( pNode->InvalidateChildren() )
                WsbAffirmHr( pNode->RefreshObject( ) );

            }

            //
            // Enumerate and add in order
            //
            WsbAffirmHr( pNode->EnumChildren( &pEnum ) );
            CComPtr<IUnknown> pUnk;
            int virtIndex = 0;

            HRESULT hrEnum = S_OK;

            while( S_OK == hrEnum ) {

                //
                // Clear these from previous iterations
                //
                pUnk.Release( );
                pNodeChild.Release( );

                //
                // Get the next
                //
                hrEnum = pEnum->Next( 1, &pUnk, NULL );
                WsbAffirmHr( hrEnum );
                    
                //
                // Did we just hit the end of the list?
                //
                if( S_FALSE == hrEnum ) { 

                    continue;

                }

                WsbAffirmHr( RsQueryInterface( pUnk, ISakNode, pNodeChild ) );
                
                //
                // MMC will automatically put in items from the scope
                // pane so do not put these up.
                //
                if( pNodeChild->IsContainer( ) == S_OK ) {

                    continue;

                }

                //
                // Put the first column of info into the result view.
                //
                memset( &resultItem, 0, sizeof(RESULTDATAITEM) );

                resultItem.str = MMC_CALLBACK;
                resultItem.mask |= RDI_STR;
        
                //
                // stuff the child BaseHsm interface in the RESULTDATAITEM lParam.
                //
                WsbAffirmHr( m_pSakData->GetCookieFromBaseHsm( pNodeChild, (MMC_COOKIE*)( &resultItem.lParam ) ) );
                resultItem.mask |= RDI_PARAM;

                WsbAffirmHr( pNodeChild->GetResultIcon( m_pSakData->m_State, &resultItem.nImage ) );
                resultItem.mask |= RDI_IMAGE;

                pResult->InsertItem( &resultItem );

            }
        }

        // Record the fact that this node is showing in the result pane
        m_pEnumeratedNode = pNode;

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::EnumResultPane", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


/*++

Routine Description:

    Calls MMC to clear out the result pane.

Arguments:


Return Value:

    S_OK            - OK

    E_xxxxxxxxxxx   - Failure occurred.

--*/
HRESULT CSakSnap::ClearResultPane()
{
    WsbTraceIn( L"CSakSnap::ClearResultPane", L"");
    HRESULT hr = S_OK;

    try {

        CComPtr<IResultData> pResult;
        WsbAffirmHr( m_pConsole->QueryInterface( IID_IResultData, (void**)&pResult ) );
        WsbAffirmHr( pResult->DeleteAllRsltItems( ) );
        m_pEnumeratedNode = NULL;

    } WsbCatch (hr);

    WsbTraceOut( L"CSakSnap::ClearResultPane", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\evntdata.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    evntdata.cpp

Abstract:

    This module is responsible for handling the notification
    calls from MMC CSakData.

Author:

    Rohde Wakefield [rohde]   06-Mar-1997

Revision History:

--*/


#include "stdafx.h"
#include "CSakSnap.h"
#include "CSakData.h"

UINT CSakData::m_CFMachineName =
    RegisterClipboardFormat( L"MMC_SNAPIN_MACHINE_NAME" );


HRESULT
CSakData::OnFolder( 
    IN  IDataObject* pDataObject,
    IN  LPARAM         arg,
    IN  LPARAM         param
    )
/*++

Routine Description:

    Param is the unique identifier ( an HSCOPEITEM of the
    expanding or contracting item )

Arguments:

    pNode           - The node which is expanding.

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::OnFolder", L"pDataObject = <0x%p>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, arg, arg, param, param );

    HRESULT hr = S_OK;
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    try {

        // if the arg is TRUE, the node is being expanded.
        if( arg )
        {
            CComPtr<ISakNode> pNode;

            // Get the basehsm out of the data record.  
            GetBaseHsmFromDataObject ( pDataObject, &pNode );

            if( !pNode ) {
                // The dataobject is not one of ours - we must be extending another
                // snapin.

                // Get the root node from UnkRootNode ( it has already been created
                // by Initialize )
                WsbAffirmPointer( m_pRootNode );

                // We're an extension snapin. 
                // Get the server focus from the data object.
                //

                CString hsmName;
                WsbAffirmHr( GetServerFocusFromDataObject( pDataObject, hsmName ) );
                if( hsmName == "" ) {

                    m_ManageLocal = TRUE;
                    m_HsmName = "";

                } else {

                    m_ManageLocal = FALSE;
                    // eliminate starting \\ if there is one.  Computer management
                    // precedes the server name with \\.
                    if( hsmName.Left( 2 ) == L"\\\\" ) {

                        int len = hsmName.GetLength( );
                        m_HsmName = hsmName.Right( len - 2 );

                    } else {

                        m_HsmName = hsmName;

                    }
                }


                // Set the Hsm name in SakData and HsmCom objects
                WsbAffirmHr( InitializeRootNode( ) );

                // Create a scope pane item and insert it
                SCOPEDATAITEM sdi;
 
                ZeroMemory( &sdi, sizeof sdi );
                sdi.mask        = SDI_STR           | 
                                      SDI_PARAM     | 
                                      SDI_IMAGE     | 
                                      SDI_OPENIMAGE |
                                      SDI_PARENT;
                sdi.relativeID  = ( HSCOPEITEM )( param );
                sdi.displayname = MMC_CALLBACK;
                WsbAffirmHr( m_pRootNode->GetScopeCloseIcon( m_State, &sdi.nImage ) );
                WsbAffirmHr( m_pRootNode->GetScopeOpenIcon( m_State, &sdi.nOpenImage ) );

                // This is a special token for the extension root node
                sdi.lParam      = EXTENSION_RS_FOLDER_PARAM;
 
                // Insert the node into the scope pane and save the scope ID
                WsbAffirmHr( m_pNameSpace->InsertItem( &sdi ) );
                WsbAffirmHr( m_pRootNode->SetScopeID( ( HSCOPEITEM )( sdi.ID ) ) );
                m_RootNodeInitialized = TRUE;

 
            } else {

                GUID nodeGuid;
                WsbAffirmHr( pNode->GetNodeType( &nodeGuid ) );
                if( IsEqualGUID( nodeGuid, cGuidHsmCom ) ) {

                    if( !m_RootNodeInitialized ) {

                        m_RootNodeInitialized = TRUE;

                        //
                        // Set the scopeitem in the node
                        //
                        WsbAffirmHr( pNode->SetScopeID( ( HSCOPEITEM )( param ) ) );

                        //
                        // Update the text and icon ( text is wrong if loaded
                        // from file and command line switch given for 
                        // different machine
                        //
                        SCOPEDATAITEM sdi;
 
                        ZeroMemory( &sdi, sizeof sdi );
                        sdi.mask        = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE;

                        sdi.ID          = ( HSCOPEITEM )( param );

                        sdi.displayname = MMC_CALLBACK;

                        WsbAffirmHr( pNode->GetScopeCloseIcon( m_State, &sdi.nImage ) );
                        WsbAffirmHr( pNode->GetScopeOpenIcon( m_State, &sdi.nOpenImage ) );

                        WsbAffirmHr( m_pNameSpace->SetItem( &sdi ) );

                    }

                }

                //
                // Initialize child node list prior to graphically enumerating them 
                //

                WsbAffirmHr( EnsureChildrenAreCreated( pNode ) );

                //
                // Param contains the HSCOPEITEM of the node being opened.
                //

                WsbAffirmHr( EnumScopePane( pNode, ( HSCOPEITEM )( param ) ) );
            }
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::OnFolder", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

////////////////////////////////////////////////////////////////////////////////////
//
// Description: Get the server name from the supplied data object.  The dataobject
//      is implemented by the snapin we are extending
//
HRESULT CSakData::GetServerFocusFromDataObject( IDataObject *pDataObject, CString& HsmName )
{
    HRESULT hr = S_OK;
    try {


        STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
        FORMATETC formatetc = { (CLIPFORMAT)m_CFMachineName, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

         // Allocate memory for the stream

        // Note: we add 2 bytes because Computer Management puts \\ at the 
        // beginning of the computer name. - AHB 12/22/97
        //
        stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof( WCHAR ) * ( MAX_PATH + 1 + 2 ) );

        WsbAffirmPointer( stgmedium.hGlobal )

        // Attempt to get data from the object

        WsbAffirmHr( pDataObject->GetDataHere( &formatetc, &stgmedium ) );

        HsmName = ( OLECHAR * ) stgmedium.hGlobal;

        GlobalFree( stgmedium.hGlobal );

    } WsbCatch ( hr ) ;
    return hr;
}


HRESULT
CSakData::OnShow( 
    IN  IDataObject* pDataObject,
    IN  LPARAM         arg,
    IN  LPARAM         param
    )
/*++

Routine Description:

    The result view is just about to be shown. 
    Set the headers for the result view.
    Param is the unique identifier ( an HSCOPEITEM ) of the 
    selected or deselected item.

Arguments:

    pNode           - The node which is showing.

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::OnShow", L"pDataObject = <0x%p>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, arg, arg, param, param );

    HRESULT hr = S_OK;
    try {
        CComPtr<ISakNode> pNode;

        // Get the basehsm out of the data record.  
        GetBaseHsmFromDataObject ( pDataObject, &pNode );
        //
        // Arg is TRUE when it is time to enumerate
        //

        if( arg ) {

            //
            // Initialize child node list prior to graphically enumerating them
            //

            WsbAffirmHr( EnsureChildrenAreCreated( pNode ) );

            //
            // Enumerate both the scope and result views. "Param" contains the 
            // HSCOPEITEM of the node being shown.
            //

            WsbAffirmHr( EnumScopePane( pNode, ( HSCOPEITEM )( param ) ) );

        } else {
            //
            // Free data associated with the result pane items, because
            // your node is no longer being displayed.
            // Note: The console will remove the items from the result pane
            //
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::OnShow", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakData::OnSelect( 
    IN  IDataObject* pDataObject,
    IN  LPARAM         arg,
    IN  LPARAM         param
    )
/*++

Routine Description:

    Called when a "folder" ( node ) is going to be opened ( not expanded ).
    Param is the unique identifier ( an HSCOPEITEM of the
    expanding or contracting item )

Arguments:

    pNode           - The node which is expanding.

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::OnSelect", L"pDataObject = <0x%p>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, arg, arg, param, param );

    HRESULT hr = S_OK;

    WsbTraceOut( L"CSakData::OnSelect", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakData::OnMinimize( 
    IN  IDataObject* pDataObject,
    IN  LPARAM         arg,
    IN  LPARAM         param
    )
/*++

Routine Description:


Arguments:

    pNode           - The node which is expanding.

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::OnMinimize", L"pDataObject = <0x%p>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, arg, arg, param, param );

    HRESULT hr = S_OK;

    WsbTraceOut( L"CSakData::OnMinimize", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakData::OnContextHelp( 
    IN  IDataObject* pDataObject,
    IN  LPARAM         arg,
    IN  LPARAM         param
    )
/*++

Routine Description:

    Called when help is selected on a node. Shows the top level help.

Arguments:

    pNode           - The node which is requesting help.

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::OnContextHelp", L"pDataObject = <0x%p>, arg = <%ld><0x%p>, param = <%ld><0x%p>", pDataObject, arg, arg, param, param );

    HRESULT hr = S_OK;

    try {

        //
        // Get the help interface
        //
        CComPtr<IDisplayHelp> pDisplayHelp;
        WsbAffirmHr( m_pConsole.QueryInterface( &pDisplayHelp ) );

        //
        // Form up the correct name
        //
        CWsbStringPtr helpFile;
        WsbAffirmHr( helpFile.LoadFromRsc( _Module.m_hInst, IDS_HELPFILELINK ) );
        WsbAffirmHr( helpFile.Append( L"::/rss_node_howto.htm" ) );

        //
        // And show it
        //
        WsbAffirmHr( pDisplayHelp->ShowTopic( helpFile ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::OnContextHelp", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakData::EnumScopePane( 
    IN  ISakNode* pNode,
    IN  HSCOPEITEM pParent
    )
/*++

Routine Description:

    Insert the items into the scopepane under the item which is represented by
    cookie and pParent. 

Arguments:

    pNode           - The node which is expanding.

    arg             - 

    param           - 

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::EnumScopePane", L"pNode = <0x%p>, pParent = <0x%p>", pNode, pParent );

    HRESULT hr = S_OK;

    try {
        //
        // Verify params
        //

        WsbAffirmPointer( pNode );
        WsbAffirmPointer( pParent );

        //
        // make sure we QI'ed for the interface
        //

        WsbAffirmPointer( m_pNameSpace ); 

        //
        // Avoid enumerating the same node twice. Once enumerated, a node remembers it.
        //

        BOOL isEnumerated;
        WsbAffirmHr( pNode->GetEnumState( &isEnumerated ) );

        if( !isEnumerated ) {

            //
            // This node has NOT been enumerated in the tree.
            //

            if( S_OK == pNode->IsContainer( ) ) {

                CComPtr<IEnumUnknown> pEnum;        // child enumerator object
                CComQIPtr<ISakNode, &IID_ISakNode>     pBaseHsmChild;   // child pointer to BaseHsm interface
            
                // Create an Enumeration object for the children and enumerate them
                WsbAffirmHr( pNode->EnumChildren( &pEnum ) );
            
                CComPtr<IUnknown> pUnkChild;        // pointer to next child in list
            
                while( pEnum->Next( 1, &pUnkChild, NULL ) == S_OK ) {

                    pBaseHsmChild = pUnkChild;

                    WsbAffirmPointer( pBaseHsmChild );


                    //
                    // If this is a leaf node, don't enumerate in scope pane.
                    //

                    if( pBaseHsmChild->IsContainer( ) != S_OK ) {
                    
                        pBaseHsmChild.Release( );
                        pUnkChild.Release( );
                        continue;
                    
                    }
            
                    //
                    // Set up a SCOPEDATAITEM for this child node and insert the child into the scope treeview
                    //

                    SCOPEDATAITEM childScopeItem;
                    memset( &childScopeItem, 0, sizeof( SCOPEDATAITEM ) );
            
                    //
                    // Set String to be callback
                    //

                    childScopeItem.displayname = MMC_CALLBACK;
                    childScopeItem.mask |= SDI_STR;
            
                    //
                    // Add "expandable" indicator to tree node if 
                    // this node has children. Fake out number
                    // of children.
                    //

                    if( pBaseHsmChild->IsContainer( ) == S_OK ) {

                        childScopeItem.cChildren = 1;
                        childScopeItem.mask |= SDI_CHILDREN;

                    }
            
                    //
                    // Set child node's scope item parent.
                    //

                    childScopeItem.relativeID = pParent;
                    childScopeItem.mask |= SDI_PARENT;          

                    //
                    // Set the param in the ScopeItem to the unknown pointer
                    // to this node, so that when this scopeitem is sent back
                    // to us, we can get it out and use it to look up
                    // node-specific info.
                    //

                    WsbAffirmHr( GetCookieFromBaseHsm( pBaseHsmChild, (MMC_COOKIE*)(&childScopeItem.lParam) ) );
                    childScopeItem.mask |= SDI_PARAM;
            
                    childScopeItem.mask |= SDI_STATE;
                    childScopeItem.nState = 0;

                    //
                    // Note - After insertion into the tree, the SCOPEITEM ID member contains the handle to 
                    // the newly inserted item
                    //
                    WsbAffirmHr ( pBaseHsmChild->GetScopeCloseIcon( m_State, &childScopeItem.nImage ) );
                    childScopeItem.mask |= SDI_IMAGE;
                    WsbAffirmHr ( pBaseHsmChild->GetScopeOpenIcon( m_State, &childScopeItem.nOpenImage ) );
                    childScopeItem.mask |= SDI_OPENIMAGE;

                    WsbAffirmHr( m_pNameSpace->InsertItem( &childScopeItem ) );
                    WsbAffirm( childScopeItem.ID != NULL, E_UNEXPECTED );

                    //
                    // Set the scopeitem id in the node object
                    //
                    WsbAffirmHr( pBaseHsmChild->SetScopeID( childScopeItem.ID ) );
            
                    //
                    // release the test interface pointer and string for next node
                    //

                    pBaseHsmChild.Release( );
                    pUnkChild.Release( );
                }

                //
                // Indicate that this node has been enumerated
                //

                WsbAffirmHr( pNode->SetEnumState( TRUE ) );
            }

        }
        
    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::EnumScopePane", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}



HRESULT
CSakData::EnsureChildrenAreCreated( 
    IN  ISakNode * pNode
    )
/*++

Routine Description:

    Guarantee that the immediate children of a particular node are created 
    in our hierarchical list of nodes.

Arguments:

    pNode           - The node to check.

Return Value:

    S_OK            - Created successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::EnsureChildrenAreCreated", L"pNode = <0x%p>", pNode );

    HRESULT hr = S_OK;

    try {
    
        //
        // Create the node's children if the node's list of children is
        // currently invalid ( i.e. - never created, or out-of-date )
        //

        if( pNode->ChildrenAreValid( ) == S_FALSE ) {

            WsbAffirmHr( CreateChildNodes( pNode ) );

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::EnsureChildrenAreCreated", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakData::OnRemoveChildren(
    IN  IDataObject*    pDataObject
    )
/*++

Routine Description:

Arguments:

    pDataObject           - The node

Return Value:

    S_OK            - Removed successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::OnRemoveChildren", L"pDataObject = <0x%p>", pDataObject );
    HRESULT hr = S_OK;

    try {

        CComPtr<ISakNode> pNode;
        WsbAffirmHr( GetBaseHsmFromDataObject( pDataObject, &pNode ) );
        WsbAffirmHr( RemoveChildren( pNode ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::OnRemoveChildren", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakData::RemoveChildren(
    IN  ISakNode*    pNode
    )
/*++

Routine Description:
    Recursively clean up the cookies for this node's children,
    but not this node itself.

Arguments:

    pNode           - The node

Return Value:

    S_OK            - Removed successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::RemoveChildren", L"pNode = <0x%p>", pNode );
    HRESULT hr = S_OK;

    try {

        CComPtr<IEnumUnknown> pEnum;        // child enumerator object
        CComPtr<ISakNode>     pChild;       // child pointer to BaseHsm interface
    
        // Create an Enumeration object for the children and enumerate them
        WsbAffirmHr( pNode->EnumChildren( &pEnum ) );
    
        CComPtr<IUnknown> pUnkChild;        // pointer to next child in list
    
        while( pEnum->Next( 1, &pUnkChild, NULL ) == S_OK ) {

            WsbAffirmHr( pUnkChild.QueryInterface( &pChild ) );

            RemoveChildren( pChild ); // OK to fail and keep going

            DetachFromNode( pChild );

            pUnkChild.Release( );
            pChild.Release( );

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::RemoveChildren", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}



STDMETHODIMP
CSakData::DetachFromNode(
    IN ISakNode* pNode )
/*++

Routine Description:
    Called when a node is terminating in order for sakdata to remove
    any cookies holding onto node.

Arguments:

    pNode           - The node

Return Value:

    S_OK            - Removed successfully.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CSakData::DetachFromNode", L"" );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pNode );

        RS_PRIVATE_DATA data;
        WsbAffirmHr( pNode->GetPrivateData( &data ) );

        CSakDataNodePrivate* pNodePriv = (CSakDataNodePrivate*)data;
        if( pNodePriv && SUCCEEDED( CSakDataNodePrivate::Verify( pNodePriv ) ) ) {

            delete pNodePriv;

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSakData::DetachFromNode", L"" );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\hsmcreat.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    HsmCreate.cpp

Abstract:

    Implementation of ISakNode interfaces init and creation.

Author:

    Rohde Wakefield [rohde]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"


/////////////////////////////////////////////////////////////////////////////
//
// ISakNode
//
/////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------
//
//         InitNode
//
//  Initialize single COM object without using the registry. Derived
//  objects frequently augment this method by implementing it themselves.
//

STDMETHODIMP
CSakNode::InitNode(
    ISakSnapAsk* pSakSnapAsk,
    IUnknown*    pHsmObj,
    ISakNode*    pParent
    )
{
    WsbTraceIn( L"CSakNode::InitNode", L"pSakSnapAsk = <0x%p>, pHsmObj = <0x%p>, pParent = <0x%p>", pSakSnapAsk, pHsmObj, pParent );

    HRESULT hr = S_OK;

    try {

        CWsbStringPtr sz;
        
        // Grab Display Name, Displayed Type, Description
        WsbAffirmHr( put_DisplayName( L"Error Node Name" ) );
        WsbAffirmHr( put_Type( L"Error Node Type" ) );
        WsbAffirmHr( put_Description( L"Error Node Description" ) );
        
        // save a pointer to the ask interface in the main snapin.
        m_pSakSnapAsk = pSakSnapAsk;
        
        // Save the pointer to the COM object
        m_pHsmObj = pHsmObj;
        
        // save the cookie of the parent node.
        m_pParent = pParent;
        
        // Set result pane columns to the defaults
        WsbAffirmHr( SetChildProps(
            RS_STR_RESULT_PROPS_DEFAULT_IDS,
            IDS_RESULT_PROPS_DEFAULT_TITLES,
            IDS_RESULT_PROPS_DEFAULT_WIDTHS ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::InitNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( S_OK );
}

STDMETHODIMP
CSakNode::TerminateNode(
    )
{
    WsbTraceIn( L"CSakNode::TerminateNode", L"" );

    HRESULT hr = S_OK;

    try {


        //
        // Remove any info in console
        //
        m_pSakSnapAsk->DetachFromNode( this );

        //
        // Release the connection point, if it was established
        //

        if( m_Advise && m_pUnkConnection ) {

            AtlUnadvise( m_pUnkConnection, IID_IHsmEvent, m_Advise );

        }

        //
        // And cleanup internal interface pointers
        //
        m_pUnkConnection.Release( );
        m_pSakSnapAsk.Release( );
        m_pHsmObj.Release( );
        m_pParent.Release( );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::TerminateNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         CreateChildren
//
//  Create and initialize all the children of a given node. This method should 
//  be overridden in all derived classes that actually have children.
//

STDMETHODIMP CSakNode::CreateChildren( )
{
    WsbTraceIn( L"CSakNode::CreateChildren", L"" );

    HRESULT hr = E_FAIL;

    WsbTraceOut( L"CSakNode::CreateChildren", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
CSakNode::InternalDelete(
    BOOL Recurse
    )
{
    WsbTraceIn( L"CSakNode::InternalDelete", L"Recurse = <%ls>", WsbBoolAsString( Recurse ) );

    HRESULT hr = S_OK;

    //
    // Loop through children, deleting them recursively.
    //
    try {

        ISakNode**        ppNode;
        for( ppNode = m_Children.begin( ); ppNode < m_Children.end( ); ppNode++ ) {

            if( *ppNode ) {

                (*ppNode)->TerminateNode( );

                if( Recurse ) {

                    (*ppNode)->DeleteAllChildren( );

                }
            }
        }

        m_Children.Clear( );
        m_bChildrenAreValid = FALSE;

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::InternalDelete", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         DeleteChildren
//
//  Delete immediate children from this UI node. There is no need for
//  derived classes to override this function. This is NOT a recursive function.
//

STDMETHODIMP CSakNode::DeleteChildren( )
{
    WsbTraceIn( L"CSakNode::DeleteChildren", L"" );

    HRESULT hr = S_OK;

    hr = InternalDelete( FALSE );

    WsbTraceOut( L"CSakNode::DeleteChildren", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         DeleteAllChildren
//
//  Delete all children (recursively) from this UI node. There is no need for
//  derived classes to override this function. This IS a recursive function.
//  It is to be used to totally free up all UI nodes in the snapin from this node
//  on down.
//

STDMETHODIMP CSakNode::DeleteAllChildren( void )
{
    WsbTraceIn( L"CSakNode::DeleteAllChildren", L"" );

    HRESULT hr = S_OK;

    hr = InternalDelete( TRUE );

    WsbTraceOut( L"CSakNode::DeleteAllChildren", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


/////////////////////////////////////////////////////////////////////////////
//
//         Helper Functions for derived classes
//
/////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------
//
//         NewChild
//
//  Given a string describing the node type, create an instance of the 
//  corresponding COM object. Return an IUnknown pointer to the new child.
//

HRESULT CSakNode::NewChild( REFGUID nodetype, IUnknown** ppUnkChild )
{
    WsbTraceIn( L"CSakNode::NewChild", L"nodetype = <%ls>, ppUnkChild = <0x%p>", WsbGuidAsString( nodetype ), ppUnkChild );
    HRESULT hr = S_OK;

    try {
    
        // Get the class ID of the new node, based on its spelled-out class.
        // Create a COM instance of the child and retrieve its IUnknown interface pointer.
        const CLSID * pclsid;

        WsbAffirmHr( GetCLSIDFromNodeType( nodetype, &pclsid ) );
        WsbAffirmHr( CoCreateInstance( *pclsid, 0, CLSCTX_INPROC, IID_IUnknown, (void**)ppUnkChild ));

    } WsbCatch( hr );

    WsbTraceOut( L"CSakNode::NewChild", L"hr = <%ls>, *ppUnkChild = <0x%p>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppUnkChild ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         GetCLSIDFromNodeType
//
//  Given a class node type GUID report back its corresponding CLSID.
//

HRESULT CSakNode::GetCLSIDFromNodeType( REFGUID nodetype, const CLSID ** ppclsid )
{
    HRESULT hr = S_FALSE;
    *ppclsid = NULL;

    // As more classes are introduced into this system, add entries for them here.
    if( IsEqualGUID( nodetype, cGuidCar ))
        *ppclsid = &CLSID_CUiCar;

    else if( IsEqualGUID( nodetype, cGuidHsmCom ))
        *ppclsid = &CLSID_CUiHsmCom;

    else if( IsEqualGUID( nodetype, cGuidManVol ))
        *ppclsid = &CLSID_CUiManVol;

    else if( IsEqualGUID( nodetype, cGuidManVolLst ))
        *ppclsid = &CLSID_CUiManVolLst;

    else if( IsEqualGUID( nodetype, cGuidMedSet ))
        *ppclsid = &CLSID_CUiMedSet;

    if( *ppclsid  )
        hr = S_OK;

    return( hr );
}

const OLECHAR * CSakNode::GetClassNameFromNodeType( REFGUID NodeType )
{
    const OLECHAR * retval = L"Unkown";

    if( IsEqualGUID( NodeType, cGuidCar ) )
        retval = L"CUiCar";

    else if( IsEqualGUID( NodeType, cGuidHsmCom ) )
        retval = L"CUiHsmCom";

    else if( IsEqualGUID( NodeType, cGuidManVol ) )
        retval = L"CUiManVol";

    else if( IsEqualGUID( NodeType, cGuidManVolLst ) )
        retval = L"CUiManVolLst";

    else if( IsEqualGUID( NodeType, cGuidMedSet ) )
        retval = L"CUiMedSet";

    else if( IsEqualGUID( NodeType, GUID_NULL ) )
        retval = L"GUID_NULL";

    return( retval );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\hsmadmin.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    HsmAdmin.cpp

Abstract:

    Main module file - defines the overall COM server.

Author:

    Rohde Wakefield [rohde]   04-Mar-1997

Revision History:

--*/


#include "stdafx.h"

// Include typedefs for all classes declared in DLL
#include "CSakSnap.h"
#include "CSakData.h"

#include "About.h"
#include "Ca.h"
#include "HsmCom.h"
#include "ManVol.h"
#include "ManVolLs.h"
#include "MeSe.h"

#ifdef _MERGE_PROXYSTUB
#include "dlldatax.h"
extern "C" HINSTANCE hProxyDll;
#endif

CComModule         _Module;
CHsmAdminApp       g_App;
CComPtr<IWsbTrace> g_pTrace;

//
// Marks the beginning of the map of ATL objects in this DLL for which
// class factories will be supplied. When CComModule::RegisterServer is 
// called, it updates the system registry for each object in the object map. 
//

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CAbout,                  CAbout)
    OBJECT_ENTRY(CLSID_CUiCar,                  CUiCar)
    OBJECT_ENTRY(CLSID_CUiHsmCom,               CUiHsmCom)
    OBJECT_ENTRY(CLSID_CUiManVol,               CUiManVol)
    OBJECT_ENTRY(CLSID_CUiManVolLst,            CUiManVolLst)
    OBJECT_ENTRY(CLSID_CUiMedSet,               CUiMedSet)
    OBJECT_ENTRY(CLSID_HsmAdminDataSnapin,      CSakDataPrimaryImpl)
    OBJECT_ENTRY(CLSID_HsmAdminDataExtension,   CSakDataExtensionImpl)
    OBJECT_ENTRY(CLSID_HsmAdmin,                CSakSnap)
END_OBJECT_MAP()

BOOL CHsmAdminApp::InitInstance()
{
    _Module.Init(ObjectMap, m_hInstance);
    AfxEnableControlContainer( );

    try {

#ifdef _MERGE_PROXYSTUB
        hProxyDll = m_hInstance;
#endif

        CString keyName;
        keyName.Format( L"ClsID\\%ls", WsbGuidAsString( CLSID_CWsbTrace ) );

        CRegKey key;
        if( key.Open( HKEY_CLASSES_ROOT, keyName, KEY_READ ) != ERROR_SUCCESS ) {

            throw( GetLastError( ) );

        }

        if( SUCCEEDED( g_pTrace.CoCreateInstance( CLSID_CWsbTrace ) ) ) {
        
            CString tracePath, regPath;
            CWsbStringPtr outString;
        
            outString.Alloc( 256 );
            regPath = L"SOFTWARE\\Microsoft\\RemoteStorage\\RsAdmin";
        
            //
            // We want to put the path where the trace file should go.
            //
            if( WsbGetRegistryValueString( 0, regPath, L"WsbTraceFileName", outString, 256, 0 ) != S_OK ) {
        
                WCHAR * systemPath;
                systemPath = _wgetenv( L"SystemRoot" );
                tracePath.Format( L"%ls\\System32\\RemoteStorage\\Trace\\RsAdmin.Trc", systemPath );

                WsbSetRegistryValueString( 0, regPath, L"WsbTraceFileName", tracePath );

                //
                // Try a little to make sure the trace directory exists.
                //
                tracePath.Format( L"%ls\\System32\\RemoteStorage", systemPath );
                CreateDirectory( tracePath, 0 );
                tracePath += L"\\Trace";
                CreateDirectory( tracePath, 0 );

            }
        
            g_pTrace->SetRegistryEntry( (LPWSTR)(LPCWSTR)regPath );
            g_pTrace->LoadFromRegistry();
        
        }
    } catch( ... ) { }

    WsbTraceIn( L"CHsmAdminApp::InitInstance", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // Need to give complete path to POPUP help file
        //
        CWsbStringPtr helpFile;
        WsbAffirmHr( helpFile.LoadFromRsc( _Module.m_hInst, IDS_HELPFILEPOPUP ) );

        CWsbStringPtr winDir;
        WsbAffirmHr( winDir.Alloc( RS_WINDIR_SIZE ) );
        WsbAffirmStatus( ::GetWindowsDirectory( (WCHAR*)winDir, RS_WINDIR_SIZE ) != 0 );

        CString helpFilePath = CString( winDir ) + L"\\help\\" + CString( helpFile );
        m_pszHelpFilePath = _tcsdup( helpFilePath );

    } WsbCatch( hr );

    BOOL retval = CWinApp::InitInstance( );
    WsbTraceOut( L"CHsmAdminApp::InitInstance", L"BOOL = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}

int CHsmAdminApp::ExitInstance()
{
    WsbTraceIn( L"CHsmAdminApp::ExitInstance", L"" );

    _Module.Term();
    int retval = CWinApp::ExitInstance();

    WsbTraceOut( L"CHsmAdminApp::ExitInstance", L"int = <%ls>", WsbLongAsString( retval ) );
    return( retval );
}


void CHsmAdminApp::ParseCommandLine(CCommandLineInfo& rCmdInfo)
{
    int argc = 0;
    WCHAR **argv;

    WsbTraceIn( L"CHsmAdminApp::ParseCommandLine", L"" );

    argv = CommandLineToArgvW( GetCommandLineW(), &argc );
    if (argc > 0) {
    	WsbAffirmPointer(argv);
    }
    for (int i = 1; i < argc; i++)
    {
        CString pszParam = argv[i];
        BOOL bFlag = FALSE;
        BOOL bLast = ((i + 1) == argc);
        WsbTrace( L"CHsmAdminApp::ParseCommandLine: arg[%d] = \"%s\"\n",
                i, (LPCTSTR)pszParam);
        if( pszParam[0] == '-' || pszParam[0] == '/' )
        {
            // remove flag specifier
            bFlag = TRUE;
            pszParam = pszParam.Mid( 1 );
        }
        rCmdInfo.ParseParam( pszParam, bFlag, bLast );
    }
    WsbTraceOut( L"CHsmAdminApp::ParseCommandLine", L"" );
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    WsbTraceIn( L"DllCanUnloadNow", L"" );
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;
#ifdef _MERGE_PROXYSTUB
    hr = ( S_OK == PrxDllCanUnloadNow() ) ? S_OK : S_FALSE;
#endif

    if( S_OK == hr ) {
        
        hr = (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;

    }
    WsbTraceOut( L"DllCanUnloadNow", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    WsbTraceIn( L"DllGetClassObject", L"" );

    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;

#ifdef _MERGE_PROXYSTUB
    hr = PrxDllGetClassObject( rclsid, riid, ppv );
#endif

    if( CLASS_E_CLASSNOTAVAILABLE == hr ) {

        hr = _Module.GetClassObject(rclsid, riid, ppv);

    }

    WsbTraceOut( L"DllGetClassObject", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    WsbTraceIn( L"DllRegisterServer", L"" );

    // registers object, typelib and all interfaces in typelib
    HRESULT hr = S_OK;

#ifdef _MERGE_PROXYSTUB
    hr = PrxDllRegisterServer();
#endif

    if( SUCCEEDED( hr ) ) {

        hr = CoInitialize( 0 );

        if (SUCCEEDED(hr)) {
            hr = _Module.RegisterServer( TRUE );
            CoUninitialize( );
        }

        //
        // Need to over-ride the rgs name description for multi language support
        //
        CWsbStringPtr name, nameIndirect, regPath;
        HRESULT hrMUI = S_OK;
        UINT uLen = 0;
        if( SUCCEEDED( name.LoadFromRsc( _Module.m_hInst, IDS_HSMCOM_DESCRIPTION ) ) ) {

            const OLECHAR* mmcPath = L"SOFTWARE\\Microsoft\\MMC\\SnapIns\\";

            // Create indirect string
            hrMUI = nameIndirect.Alloc(MAX_PATH);
            if (S_OK == hrMUI) {
                uLen = GetSystemDirectory(nameIndirect, MAX_PATH);
                if (uLen > MAX_PATH) {
                    // Try again with larger buffer
                    hrMUI = nameIndirect.Realloc(uLen);
                    if (S_OK == hrMUI) {
                        uLen = GetSystemDirectory(nameIndirect, uLen);
                        if (0 == uLen) {
                            hrMUI = S_FALSE;
                        }
                    }
                }
            }

            if (S_OK == hrMUI) {
                hrMUI = nameIndirect.Prepend(OLESTR("@"));
            }
            if (S_OK == hrMUI) {
                WCHAR resId[64];
                wsprintf(resId, OLESTR("\\rsadmin.dll,-%d"), IDS_HSMCOM_DESCRIPTION);
                hrMUI = nameIndirect.Append(resId);
            } 

            // Sanpin
            regPath = mmcPath;
            regPath.Append( WsbGuidAsString( CLSID_HsmAdminDataSnapin ) );

            // Set the MUI support value
            if (S_OK == hrMUI) {
                WsbSetRegistryValueString( 0, regPath, L"NameStringIndirect", nameIndirect );
            }

            // Set the fallback value
            WsbSetRegistryValueString( 0, regPath, L"NameString", name );


            // Extension
            regPath = mmcPath;
            regPath.Append( WsbGuidAsString( CLSID_HsmAdminDataExtension ) );

            // Set the MUI support value
            if (S_OK == hrMUI) {
                WsbSetRegistryValueString( 0, regPath, L"NameStringIndirect", nameIndirect );
            }

            // Set the fallback value
            WsbSetRegistryValueString( 0, regPath, L"NameString", name );

        }

    }

    WsbTraceOut( L"DllRegisterServer", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;
    WsbTraceIn( L"DllUnregisterServer", L"" );

#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif

    hr = CoInitialize( 0 );

    if (SUCCEEDED(hr)) {
        _Module.UnregisterServer();
        CoUninitialize( );
        hr = S_OK;
    }

    WsbTraceOut( L"DllUnregisterServer", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\msdatobj.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    MsDatObj.cpp

Abstract:

    Implementation of IDataObject interface for Multi-Select
    Allows MMC to get a list of Node Types

Author:

    Art Bragg 28-Aug-1997

Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////
//
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "msdatobj.h"

#define BUMP_SIZE 20

// Declare Snap-in NodeType formats:
UINT CMsDataObject::m_cfObjectTypes    = RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);

HRESULT
CMsDataObject::FinalConstruct(
    void
    )
/*++

Routine Description:

    Called during initial CMsDataObject construction to initialize members.

Arguments:

    none.

Return Value:

    S_OK            - Initialized correctly.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn( L"CMsDataObject::FinalConstruct", L"" );

    try {
        m_Count = 0;

        // Allocate initial array of GUIDs
        m_pGUIDArray = (GUID *) malloc (BUMP_SIZE * sizeof(GUID));
        WsbAffirm ((m_pGUIDArray != NULL), E_OUTOFMEMORY);
        ZeroMemory (m_pGUIDArray, (BUMP_SIZE * sizeof(GUID)));

        m_pUnkNodeArray = (IUnknown **) malloc( BUMP_SIZE * sizeof(IUnknown*) );
        WsbAffirm ((m_pGUIDArray != NULL), E_OUTOFMEMORY);
        ZeroMemory (m_pGUIDArray, (BUMP_SIZE * sizeof(IUnknown*)));

        m_pObjectIdArray = (GUID *) malloc (BUMP_SIZE * sizeof(GUID));
        WsbAffirm ((m_pObjectIdArray != NULL), E_OUTOFMEMORY);
        ZeroMemory (m_pObjectIdArray, (BUMP_SIZE * sizeof(GUID)));

        m_ArraySize = BUMP_SIZE;

        WsbAffirmHr (CComObjectRoot::FinalConstruct( ));
    } WsbCatch (hr);

    WsbTraceOut( L"CMsDataObject::FinalConstruct", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

void
CMsDataObject::FinalRelease(
    void
    )
/*++

Routine Description:

    Called on final release in order to clean up all members.

Arguments:

    none.

Return Value:

    none.

--*/
{
    WsbTraceIn( L"CMsDataObject::FinalRelease", L"" );

    // Clean up array of GUIDs
    free( m_pGUIDArray );

    for( DWORD  i = 0; i < m_Count; i++ ) {

        m_pUnkNodeArray[i]->Release();

    }

    free( m_pUnkNodeArray );


    WsbTraceOut( L"CMsDataObject::FinalRelease", L"" );
}

// IDataObject

STDMETHODIMP
CMsDataObject::GetDataHere(
    LPFORMATETC lpFormatetc,
    LPSTGMEDIUM /*lpMedium*/
    )
/*++

Routine Description:

    Retrieve information FROM the dataobject and put INTO lpMedium.

Arguments:

    lpFormatetc     - Format to retreive.

    lpMedium        - Storage to put information into.

Return Value:

    S_OK            - Storage filled in.

    E_xxxxxxxxxxx   - Failure occurred.

--*/
{
    WsbTraceIn( L"CMsDataObject::GetDataHere", L"lpFormatetc->cfFormat = <%ls>", RsClipFormatAsString( lpFormatetc->cfFormat ) );

    HRESULT hr = E_NOTIMPL;

    WsbTraceOut( L"CMsDataObject::GetDataHere", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );

}

STDMETHODIMP
CMsDataObject::SetData(
    LPFORMATETC lpFormatetc,
    LPSTGMEDIUM /*lpMedium*/,
    BOOL /*fRelease*/
    )
{
    WsbTraceIn( L"CMsDataObject::SetData", L"lpFormatetc->cfFormat = <%ls>", RsClipFormatAsString( lpFormatetc->cfFormat ) );

    HRESULT hr = E_NOTIMPL;

    WsbTraceOut( L"CMsDataObject::SetData", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

///////////////////////////////////////////////////////////////////////
// Note - CMsDataObject does not implement these
///////////////////////////////////////////////////////////////////////

STDMETHODIMP
CMsDataObject::GetData(
    LPFORMATETC lpFormatetcIn,
    LPSTGMEDIUM lpMedium
    )
{
    WsbTraceIn( L"CMsDataObject::GetData", L"lpFormatetc->cfFormat = <%ls>", RsClipFormatAsString( lpFormatetcIn->cfFormat ) );

    HRESULT hr = S_OK;

    lpMedium->tymed          = TYMED_NULL;
    lpMedium->hGlobal        = NULL;
    lpMedium->pUnkForRelease = NULL;

    try {

        //
        // Don't need to throw error if not a format we don't understand - 
        // which is currently only CCF_OBJECT_TYPES_IN_MULTI_SELECT
        //
        if( lpFormatetcIn->cfFormat == m_cfObjectTypes ) {

            //
            // Check to make sure there is data to transfer
            //
            WsbAffirm( ( lpFormatetcIn->tymed & TYMED_HGLOBAL ), DV_E_TYMED );

            //
            // m_ppDataObjects  m_count
            //
            UINT datasize = sizeof(DWORD) + ( sizeof(GUID) * m_Count );
            lpMedium->hGlobal = ::GlobalAlloc( GPTR, datasize );
            WsbAffirmAlloc( lpMedium->hGlobal );

            //
            // Put the count in the allocated memory
            //
            BYTE* pb = reinterpret_cast<BYTE*>(lpMedium->hGlobal);
            *((DWORD*)lpMedium->hGlobal) = m_Count;

            //
            // Copy the GUIDs to the allocated memory
            //
            if( m_Count > 0 ) {

                pb += sizeof(DWORD);
                CopyMemory(pb, m_pGUIDArray, m_Count * sizeof(GUID));

            }

            lpMedium->tymed = TYMED_HGLOBAL;

        } else {

            hr = DATA_E_FORMATETC;

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CMsDataObject::GetData", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CMsDataObject::EnumFormatEtc(DWORD /*dwDirection*/, LPENUMFORMATETC* /*ppEnumFormatEtc*/)
{
    WsbTraceIn( L"CMsDataObject::EnumFormatEtc", L"" );

    HRESULT hr = E_NOTIMPL;

    WsbTraceOut( L"CMsDataObject::EnumFormatEtc", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT CMsDataObject::RetrieveMultiSelectData (LPSTGMEDIUM lpMedium)
{
    WsbTraceIn( L"CMsDataObject::RetrieveMultiSelectData", L"" );
    HRESULT hr = S_OK;

    try {
        WsbAffirm( lpMedium != NULL, E_POINTER);
        WsbAffirm( lpMedium->tymed == TYMED_HGLOBAL, E_FAIL );

        // Create the stream on the hGlobal passed in. When we write to the stream,
        // it simultaneously writes to the hGlobal the same information.
        LPSTREAM lpStream;
        WsbAffirmHr( CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream ));

        // Write 'len' number of bytes from pBuffer into the stream. When we write
        // to the stream, it simultaneously writes to the global memory we
        // associated it with above.
        ULONG numBytesWritten;

        // Write the count first
        WsbAffirmHr( lpStream->Write(&m_Count, sizeof (m_Count), &numBytesWritten ));

        // Write the GUID array
        WsbAffirmHr( lpStream->Write(m_pGUIDArray, m_Count * sizeof (GUID), &numBytesWritten ));

        // Because we told CreateStreamOnHGlobal with 'FALSE', only the stream is released here.
        // Note - the caller (i.e. snap-in, object) will free the HGLOBAL 
        // at the correct time.  This is according to the IDataObject specification.
        lpStream->Release();

    } WsbCatch( hr );

    WsbTraceOut( L"CMsDataObject::RetrieveMultiSelectData", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}


// Data setting method
// Note that we keep the node array seperate from the GUID array because
// the GetData interface memory copies the GUID array to the stream.

STDMETHODIMP
CMsDataObject::AddNode (ISakNode *pNode )
{
    WsbTraceIn( L"CMsDataObject::AddNode", L"pNode = <0x%p>", pNode );
    HRESULT hr = S_OK;
    GUID thisGUID;
    GUID objectId;

    GUID * pGUIDArray         = 0,
         * pObjectIdArray     = 0;
    IUnknown ** pUnkNodeArray = 0;


    try {

        //
        // Get the object type GUID
        //
        WsbAffirmHr( pNode->GetNodeType( &thisGUID ) );

        //
        // Get the unique ID for the engine object (i.e. FsaResource)
        //
        WsbAffirmHr( pNode->GetObjectId( &objectId ) );

        //
        // Reallocate if we need to
        //
        if( m_Count >= m_ArraySize ) {


            //
            // Allocate new buffer
            //
            m_ArraySize += BUMP_SIZE;
            pGUIDArray     = (GUID *)      malloc( m_ArraySize * sizeof( GUID ) );
            WsbAffirmAlloc( pGUIDArray ); 
            pUnkNodeArray  = (IUnknown **) malloc( m_ArraySize * sizeof( IUnknown* ) );
            WsbAffirmAlloc( pUnkNodeArray );
            pObjectIdArray = (GUID *)      malloc( m_ArraySize * sizeof( GUID ) );
            WsbAffirmAlloc( pObjectIdArray );

            //
            // copy over old buffer and free
            //
            memcpy( pGUIDArray,     m_pGUIDArray,     m_Count * sizeof( GUID ) );
            memcpy( pUnkNodeArray,  m_pUnkNodeArray,  m_Count * sizeof( IUnknown* ) );
            memcpy( pObjectIdArray, m_pObjectIdArray, m_Count * sizeof( GUID ) );
            free( m_pGUIDArray );
            free( m_pUnkNodeArray );
            free( m_pObjectIdArray );
            m_pGUIDArray     = pGUIDArray;
            m_pUnkNodeArray  = pUnkNodeArray;
            m_pObjectIdArray = pObjectIdArray;
            pGUIDArray     = 0;
            pUnkNodeArray  = 0;
            pObjectIdArray = 0;

        }

        //
        // Put the GUID in the array
        //
        m_pGUIDArray[ m_Count ] = thisGUID;

        //
        // Put the objectId in the array
        //
        m_pObjectIdArray[ m_Count ] = objectId;

        //
        // Put the unknown pointer (the Cookie) in the array
        //
        CComPtr<IUnknown> pUnkNode;
        WsbAffirmHr( RsQueryInterface( pNode, IUnknown, pUnkNode ) );
        pUnkNode.CopyTo( &m_pUnkNodeArray[ m_Count ] );
        m_Count++;

    } WsbCatch( hr );

    if( pGUIDArray )      free( pGUIDArray );
    if( pObjectIdArray )  free( pObjectIdArray );
    if( pUnkNodeArray )   free( pUnkNodeArray );

    WsbTraceOut( L"CMsDataObject::AddNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP 
CMsDataObject::GetNodeEnumerator( IEnumUnknown **ppEnum )
{
    WsbTraceIn( L"CMsDataObject::GetNodeEnumerator", L"ppEnum = <0x%p>", ppEnum );

    HRESULT hr = S_OK;
    CEnumUnknown * pEnum = 0;

    try {

        WsbAffirmPointer( ppEnum );
        *ppEnum = 0;

        //
        // New an ATL enumerator
        //
        pEnum = new CEnumUnknown;
        WsbAffirm( 0 != pEnum, E_OUTOFMEMORY );
        
        //
        // Initialize it to copy the current node interface pointers
        //
        WsbAffirmHr( pEnum->FinalConstruct() );
        WsbAffirmHr( pEnum->Init( &m_pUnkNodeArray[0], &m_pUnkNodeArray[m_Count], NULL, AtlFlagCopy ) );
        WsbAffirmHr( pEnum->QueryInterface( IID_IEnumUnknown, (void**)ppEnum ) );

    } WsbCatchAndDo( hr,

        if( pEnum ) delete pEnum;

    );

    WsbTraceOut( L"CMsDataObject::GetNodeEnumerator", L"hr = <%ls>, *ppEnum = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppEnum ) );
    return( hr );
}

STDMETHODIMP 
CMsDataObject::GetObjectIdEnumerator( IEnumGUID ** ppEnum )
{
    WsbTraceIn( L"CMsDataObject::GetObjectIdEnumerator", L"ppEnum = <0x%p>", ppEnum );

    HRESULT hr = S_OK;
    CEnumGUID * pEnum = 0;

    try {

        WsbAffirmPointer( ppEnum );
        *ppEnum = 0;

        //
        // New an ATL enumerator
        //
        pEnum = new CEnumGUID;
        WsbAffirm( 0 != pEnum, E_OUTOFMEMORY );
        
        //
        // Initialize it to copy the current node interface pointers
        //
        WsbAffirmHr( pEnum->FinalConstruct() );
        WsbAffirmHr( pEnum->Init( &m_pObjectIdArray[0], &m_pObjectIdArray[m_Count], NULL, AtlFlagCopy ) );
        WsbAffirmHr( pEnum->QueryInterface( IID_IEnumGUID, (void**)ppEnum ) );

    } WsbCatchAndDo( hr,

        if( pEnum ) delete pEnum;

    );

    WsbTraceOut( L"CMsDataObject::GetObjectIdEnumerator", L"hr = <%ls>, *ppEnum = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppEnum ) );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\msdatobj.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    MsDatObj.h

Abstract:

    Implementation of IDataObject for Multi-Select

Author:

    Art Bragg   28-Aug-1997

Revision History:

--*/

#ifndef MSDATOBJ_H
#define MSDATOBJ_H

class CMsDataObject;

/////////////////////////////////////////////////////////////////////////////
// COM class representing the object
class  ATL_NO_VTABLE CMsDataObject : 
    public IDataObject,
    public IMsDataObject, // Our internal interface to the data object
    public CComObjectRoot      // handle object reference counts for objects
//  public CComCoClass<CMsDataObject, &CLSID_MsDataObject>
{
public:
    CMsDataObject() {
    };

BEGIN_COM_MAP(CMsDataObject)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(IMsDataObject)
END_COM_MAP()


// DECLARE_REGISTRY_RESOURCEID(IDR_MsDataObject)


// IDataObject methods
public:
    // Implemented
    STDMETHOD( SetData )         ( LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease );
    STDMETHOD( GetData )         ( LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium );
    STDMETHOD( GetDataHere )     ( LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium );
    STDMETHOD( EnumFormatEtc )   ( DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc );

    // Not implemented
    STDMETHOD( QueryGetData )              ( LPFORMATETC /*lpFormatetc*/ ) 
    { return E_NOTIMPL; };

    STDMETHOD( GetCanonicalFormatEtc )     ( LPFORMATETC /*lpFormatetcIn*/, LPFORMATETC /*lpFormatetcOut*/ )
    { return E_NOTIMPL; };

    STDMETHOD( DAdvise )                   ( LPFORMATETC /*lpFormatetc*/, DWORD /*advf*/, LPADVISESINK /*pAdvSink*/, LPDWORD /*pdwConnection*/ )
    { return E_NOTIMPL; };
    
    STDMETHOD( DUnadvise )                 ( DWORD /*dwConnection*/ )
    { return E_NOTIMPL; };

    STDMETHOD( EnumDAdvise )               ( LPENUMSTATDATA* /*ppEnumAdvise*/ )
    { return E_NOTIMPL; };

// IMsDataObject methods
    STDMETHOD( AddNode )                    ( ISakNode *pNode );
    STDMETHOD( GetNodeEnumerator )          ( IEnumUnknown ** ppEnum );
    STDMETHOD( GetObjectIdEnumerator )      ( IEnumGUID ** ppEnum );

// Pseudo Constructor / Destructor
public:
    HRESULT FinalConstruct();
    void    FinalRelease();


// Data
private:
    DWORD       m_Count;                // Number of GUIDs in array
    DWORD       m_ArraySize;            // Current allocated size of array
    GUID        *m_pGUIDArray;          // Array of GUIDs - type of object
    GUID        *m_pObjectIdArray;      // Array of ObjectIds - unique GUIDs for specific objects
    IUnknown    **m_pUnkNodeArray;      // Array of unknown ISakNode pointers

static UINT m_cfObjectTypes;

// Private Helper Function
private:
    HRESULT RetrieveMultiSelectData(LPSTGMEDIUM lpMedium);


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by HsmAdmin.rc
//
#define IDR_HsmAdmin                    1
#define IDS_NAME                        3
#define IDS_SIZE                        4
#define IDS_TYPE                        5
#define IDS_EVENT_LOG_APP_TITLE         6
#define IDS_EVENT_LOG_SYS_TITLE         7
#define IDR_CUiMedSet                   8
#define IDS_ERR_SERVICE_NOT_CONNECTING  8
#define IDR_CUiManVolLst                9
#define IDS_COPYSET_COPYSET             9
#define IDS_COPYSET_OUT_OF_DATE         10
#define IDS_COPYSET_DO_NOT_EXIST        11
#define IDS_WIZ_CAR_COPY_NUM_COPIES_TITLE 12
#define IDS_WIZ_CAR_COPY_NUM_COPIES_SUBTITLE 13
#define IDS_WIZ_CAR_COPY_SELECT_TITLE   14
#define IDS_WIZ_CAR_COPY_SELECT_SUBTITLE 15
#define IDR_CUiHsmCom                   16
#define IDS_WIZ_MANVOLLST_LEVELS_TITLE  16
#define IDR_CUiManVol                   17
#define IDS_WIZ_MANVOLLST_LEVELS_SUBTITLE 17
#define IDR_HsmAdminDataSnapin          18
#define IDS_WIZ_MANVOLLST_SELECT_TITLE  18
#define IDR_HsmAdminDataExtension       19
#define IDS_WIZ_MANVOLLST_SELECT_SUBTITLE 19
#define IDS_WIZ_MANVOLLST_SELECTX_TITLE 20
#define IDS_WIZ_MANVOLLST_SELECTX_SUBTITLE 21
#define IDS_WIZ_QSTART_CHECK_TITLE      22
#define IDS_WIZ_QSTART_CHECK_SUBTITLE   23
#define IDR_CUiCar                      24
#define IDS_WIZ_QSTART_INITIAL_VAL_TITLE 24
#define IDS_WIZ_QSTART_INITIAL_VAL_SUBTITLE 25
#define IDS_WIZ_QSTART_MANRES_SEL_TITLE 26
#define IDS_WIZ_QSTART_MANRES_SEL_SUBTITLE 27
#define IDS_WIZ_QSTART_MANRES_SELX_TITLE 28
#define IDS_WIZ_QSTART_MANRES_SELX_SUBTITLE 29
#define IDS_WIZ_QSTART_MEDIA_SEL_TITLE  30
#define IDS_WIZ_QSTART_MEDIA_SEL_SUBTITLE 31
#define IDS_WIZ_QSTART_SCHEDULE_TITLE   32
#define IDS_WIZ_QSTART_SCHEDULE_SUBTITLE 33
#define IDS_WIZ_UNMANAGE_SELECT_TITLE   34
#define IDS_WIZ_UNMANAGE_SELECT_SUBTITLE 35
#define IDS_WIZ_LAST_ACCESS_DATE_DISABLED 36
#define IDS_WIZ_LAST_ACCESS_DATE_ENABLED 37
#define IDD_DLG_RECREATE_CHOOSE_COPY    101
#define IDD_WIZ_QSTART_INTRO            105
#define IDR_About                       108
#define IDC_MANAGE_BROWSE               110
#define IDR_MANVOLLST                   145
#define IDR_MANVOL                      186
#define IDR_MEDSET                      213
#define IDR_HSMCOM                      215
#define IDR_CAR                         218
#define IDR_VALIDATE_ANIM               219
#define IDD_PROP_HSMCOM_STAT            282
#define IDC_MANAGE_LOCAL                1004
#define IDC_MINSIZE_BUDDY               1022
#define IDC_MINSIZE_SPIN                1023
#define IDC_ACCESS_BUDDY                1024
#define IDC_ACCESS_SPIN                 1025
#define IDC_MANVOLLST_FSARESLBOX        1052
#define IDC_MANRES_SELECT               1085
#define IDC_FREESPACE_BUDDY             1087
#define IDC_FREESPACE_SPIN              1088
#define IDC_MEDIA_SEL                   1089
#define IDC_MANAGE_REMOTE               1101
#define IDC_MANAGE_NAME                 1102
#define IDC_EDIT_RECALL_LIMIT           1106
#define IDC_EDIT_COPYFILES_LIMIT        1107
#define IDC_INTRO_TEXT                  1108
#define IDC_SPIN_RECALL_LIMIT           1115
#define IDC_SPIN_COPYFILES_LIMIT        1116
#define IDC_EDIT_LEVEL                  1117
#define IDC_EDIT_SIZE                   1118
#define IDC_EDIT_TIME                   1119
#define IDC_SPIN_LEVEL                  1120
#define IDC_SPIN_SIZE                   1121
#define IDC_SPIN_TIME                   1122
#define IDC_BTN_ADD                     1127
#define IDC_BTN_REMOVE                  1128
#define IDC_BTN_UP                      1129
#define IDC_BTN_DOWN                    1130
#define IDC_BTN_EDIT                    1132
#define IDC_EDIT_PATH                   1136
#define IDC_EDIT_FILESPEC               1137
#define IDC_RADIO_INCLUDE               1138
#define IDC_RADIO_EXCLUDE               1139
#define IDC_CHECK_SUBDIRS               1140
#define IDC_EDIT_RESOURCE_NAME          1143
#define IDC_WIZ_MANVOLLST_INTRO_TEXT    1145
#define IDC_WIZ_MANVOLLST_EDIT_LEVEL    1151
#define IDC_WIZ_MANVOLLST_SPIN_LEVEL    1152
#define IDC_WIZ_MANVOLLST_EDIT_SIZE     1153
#define IDC_WIZ_MANVOLLST_SPIN_SIZE     1154
#define IDC_WIZ_MANVOLLST_EDIT_DAYS     1155
#define IDC_WIZ_MANVOLLST_SPIN_DAYS     1156
#define IDC_UNMANAGE_TRUNCATE           1164
#define IDC_STATIC_MANAGED_SPACE_4DIGIT 1165
#define IDC_STATIC_FREE_SPACE_4DIGIT    1166
#define IDC_STATIC_PREMIGRATED_SPACE_4DIGIT 1167
#define IDC_STATIC_USED_SPACE_4DIGIT    1169
#define IDC_STATIC_DESCRIPTION2         1170
#define IDC_STATIC_REMOTE_STORAGE_4DIGIT 1171
#define IDC_STATIC_FREE_PCT             1173
#define IDC_STATIC_USED_PCT             1174
#define IDC_STATIC_PREMIGRATED_PCT      1175
#define IDC_STATIC_FREE_DESIRED_4DIGIT  1176
#define IDC_STATIC_ACTUAL_FREE_PCT      1177
#define IDC_STATIC_FREE_ACTUAL_4DIGIT   1178
#define IDC_TEXT_DISABLED               1179
#define IDC_LIST_IE                     1180
#define IDI_BLUESAKKARA                 5100
#define IDI_DEVLST                      5203
#define IDI_NODEMANVOL                  5307
#define IDI_NODELIB                     5311
#define IDI_NODETAPE                    5405
#define IDD_WIZ_MANVOLLST_SELECT        5442
#define IDD_WIZ_QSTART_FINISH           5447
#define IDB_QSTART_WATERMARK            5448
#define IDD_WIZ_QSTART_MANRES_SEL       5449
#define IDD_WIZ_QSTART_INITIAL_VAL      5450
#define IDD_WIZ_QSTART_MEDIA_SEL        5451
#define IDB_QSTART_HEADER               5452
#define IDD_PROP_MANRES_STATUS          5457
#define IDD_PROP_MANRES_LEVELS          5458
#define IDD_PROP_MANRES_INCEXC          5459
#define IDD_PROP_SCHEDULE               5462
#define IDD_DLG_RULE_EDIT               5467
#define IDD_CHOOSE_HSM_2                5468
#define IDD_WIZ_MANVOLLST_INTRO         5477
#define IDD_WIZ_MANVOLLST_FINISH        5478
#define IDD_WIZ_MANVOLLST_LEVELS        5479
#define IDS_RECREATE_COL_COPY_TITLE     6000
#define IDS_RECREATE_COL_NAME_TITLE     6001
#define IDS_RECREATE_COL_DATE_TITLE     6002
#define IDS_RECREATE_COL_STATUS_TITLE   6003
#define IDS_RECREATE_COL_COPY_WIDTH     6004
#define IDS_RECREATE_COL_NAME_WIDTH     6005
#define IDS_RECREATE_COL_STATUS_WIDTH   6006
#define IDS_RECREATE_LOCATION_ONLINE    6007
#define IDS_RECREATE_LOCATION_OFFLINE   6008
#define IDS_RECREATE_LOCATION_UNKNOWN   6009
#define IDS_RECREATE_STATUS_FORMAT      6010
#define IDS_RECREATE_COPY_FORMAT        6011
#define IDS_MEDIA_NONAME                6012
#define IDS_RECREATE_LOCATION_DISABLED  6013
#define IDS_HSM_NAME_PREFIX             6039
#define IDS_HELPFILEPOPUP               6040
#define IDS_ERR_COPYSET_RANGE           6041
#define IDS_WIZ_QSTART_TITLE            6042
#define IDS_CONFIRM_MEDIA_COPY_DELETE   6043
#define IDS_ERR_VOLUME_DELETE_PENDING   6044
#define IDS_HELPFILE                    6045
#define IDS_HELPFILELINK                6046
#define IDS_ERR_MINSIZE_RANGE           6047
#define IDS_QSTART_MANRES_TEXT          6048
#define IDS_QSTART_FREESPACE_TEXT       6049
#define IDS_QSTART_CRITERIA_TEXT        6050
#define IDS_QSTART_MEDIA_TEXT           6051
#define IDS_QSTART_SCHED_TEXT           6052
#define IDS_QSTART_MANAGE_NO_VOLUMES    6053
#define IDS_QSTART_FINISH_INDENT        6054
#define IDS_SCHED_TASK_TEMP_TITLE       6058
#define IDS_ERR_NO_ITEM_SELECTED        6060
#define IDS_TB_TEXT_VOLUME_LIST_SCHED   6061
#define IDS_TB_TIP_VOLUME_LIST_SCHED    6062
#define IDS_TB_TEXT_MESE_COPY           6063
#define IDS_TB_TEXT_VOLUME_SETTINGS     6064
#define IDS_QSTART_RESTART_NT           6065
#define IDS_TB_TIP_VOLUME_SETTINGS      6067
#define IDS_CONFIRM_DELETE_RULE         6068
#define IDS_INCLUDE                     6069
#define IDS_EXCLUDE                     6070
#define IDS_RULE_TYPE_SYSTEM            6071
#define IDS_RULE_TYPE_USER              6072
#define IDS_YES                         6073
#define IDS_NO                          6074
#define IDS_ERR_RULE_NO_FILESPEC        6075
#define IDS_ERR_RULE_NO_PATH            6076
#define IDS_ERR_RULE_DUPLICATE          6077
#define IDS_ERR_RULE_ILLEGAL_PATH       6078
#define IDS_ERR_MANAGE_TASK             6079
#define IDS_TB_TEXT_VOLUME_TOOLS        6081
#define ID_MANVOLLST_NEW_MANVOL         6082
#define IDS_TB_TIP_VOLUME_TOOLS         6083
#define IDS_TB_TEXT_VOLUME_RULES        6084
#define IDS_TB_TIP_VOLUME_RULES         6085
#define IDS_TB_TIP_MESE_COPY            6086
#define IDS_TB_TEXT_CAR_COPIES          6087
#define IDS_TB_TIP_CAR_COPIES           6088
#define IDS_TB_TEXT_VOLUME_LIST_NEW     6089
#define IDS_TB_TIP_VOLUME_LIST_NEW      6091
#define ID_MANVOL_ROOT_LEVELS           6092
#define ID_MANVOL_TASK_LEVELS           6093
#define ID_MANVOL_ROOT_RULES            6094
#define ID_MANVOL_TASK_RULES            6095
#define IDS_ERR_QSTART_NO_FILTER        6096
#define IDS_ERR_QSTART_FILTER_ERROR     6097
#define IDS_ERR_OPEN_SERVICE            6098
#define IDS_ERROR_QSTART_ONFINISH       6099
#define ID_HSMCOM_ROOT_SCHEDULE         6100
#define IDS_ERR_MANVOLWIZ_FINISH        6101
#define IDS_WIZ_MANVOLLST_TITLE         6105
#define IDS_MANAGE_LOCAL                6106
#define IDS_UNLABELED_VOLUME            6108
#define IDS_UNLABELED_VOLUME2           6109
#define IDS_RUN_JOB                     6110
#define IDS_JOB_MANAGE                  6111
#define IDS_JOB_RECALL                  6112
#define IDS_JOB_TRUNCATE                6113
#define IDS_JOB_UNMANAGE                6114
#define IDS_JOB_VALIDATE                6115
#define IDS_JOB_NAME_PREFIX             6116
#define IDS_CAR_COPYSET_NONE_SINGULAR   6119
#define IDS_COMPANY                     6125
#define IDS_DESCRIPTION                 6126
#define IDS_CAR_STATUS_RECREATE_SINGULAR 6127
#define IDS_JOB_MEDIA_COPY_TITLE        6128
#define IDS_RESULT_PROPS_MANRESLST_TITLES 6130
#define IDS_RESULT_PROPS_MANRESLST_WIDTHS 6131
#define IDS_RESULT_PROPS_DEFAULT_TITLES 6133
#define IDS_RESULT_PROPS_DEFAULT_WIDTHS 6134
#define IDS_RESULT_PROPS_COM_TITLES     6136
#define IDS_RESULT_PROPS_COM_WIDTHS     6137
#define IDS_DAYS                        6138
#define IDS_MANVOLLST_DISPLAY_NAME      6139
#define IDS_MANVOLLST_DESCRIPTION       6140
#define IDS_ERR_SERVICE_NOT_RUNNING     6141
#define IDS_CAR_COPYSET_NONE            6142
#define IDS_ERR_SERVICE_NOT_SETUP       6143
#define IDS_ERR_REFRESH_FAILED          6144
#define IDS_SERVICE_STATUS_STOPPED      6147
#define IDS_SERVICE_STATUS_START_PENDING 6148
#define IDS_SERVICE_STATUS_STOP_PENDING 6149
#define IDS_SERVICE_STATUS_RUNNING      6150
#define IDS_SERVICE_STATUS_CONTINUE_PENDING 6151
#define IDS_SERVICE_STATUS_PAUSE_PENDING 6152
#define IDS_SERVICE_STATUS_PAUSED       6153
#define IDS_HSMCOM_TYPE                 6154
#define IDS_HSMCOM_DESCRIPTION          6155
#define IDS_SERVICE_STATUS_NOT_SETUP    6156
#define IDS_ERR_SERVICE_NOT_SETUP_REMOTE 6157
#define IDS_ERR_SERVICE_NOT_INSTALLED   6158
#define IDS_JOB_MEDIA_RECREATE_TITLE    6159
#define IDS_GENERIC_JOB_COMMENT         6163
#define IDS_MEDIA_COPIES_DESCRIPTION    6165
#define IDS_RESULT_PROPS_MEDSET_TITLES  6167
#define IDS_RESULT_PROPS_MEDSET_WIDTHS  6168
#define IDS_MEDSET_DISPLAYNAME          6169
#define IDS_MEDSET_TYPE                 6170
#define IDS_MEDSET_DESCRIPTION          6171
#define IDS_MEDTYPE_UNKNOWN             6172
#define IDS_MEDTYPE_FIXED               6173
#define IDS_MEDTYPE_REMOVABLE           6174
#define IDS_MEDTYPE_OPTICAL             6175
#define IDS_MEDTYPE_TAPE                6176
#define IDS_CAR_COPYSET_INSYNC          6177
#define IDS_CAR_COPYSET_OUTSYNC         6178
#define IDS_CAR_COPYSET_ERROR_SP        6179
#define IDS_MEDIA                       6180
#define IDS_VOLUMES                     6181
#define IDS_VOLUME                      6182
#define IDS_CAR_STATUS_ERROR_INCOMPLETE_SINGULAR 6183
#define IDS_CAR_STATUS_ERROR_INCOMPLETE_PLURAL 6184
#define IDS_CAR_TYPE                    6188
#define IDS_CAR_DESCRIPTION             6189
#define IDS_CAR_STATUS_ERROR_RW_SP      6190
#define IDS_CAR_STATUS_READONLY_PLURAL  6191
#define IDS_CAR_STATUS_NORMAL_PLURAL    6192
#define IDS_CAR_STATUS_ERROR_RO_SP      6193
#define IDS_CAR_COPYSET_INSYNC_PLURAL   6194
#define IDS_CAR_COPYSET_OUTSYNC_PLURAL  6195
#define IDS_CAR_COPYSET_ERROR           6196
#define IDS_CAR_STATUS_ERROR_MISSING    6197
#define IDS_CAR_STATUS_ERROR_MISSING_SINGULAR 6198
#define IDS_CAR_STATUS_ERROR_MISSING_PLURAL 6199
#define IDS_CAR_COPYSET_MISSING         6200
#define IDS_CAR_COPYSET_MISSING_SINGULAR 6201
#define IDS_MEDIA_RECREATE_JOB_COMMENT  6202
#define IDS_MEDIA_COPY_JOB_COMMENT      6203
#define IDS_CAR_COPYSET_MISSING_PLURAL  6204
#define IDS_SCHED_MANAGE_TITLE          6205
#define IDS_ERR_CREATE_TASK             6207
#define IDS_ERR_NO_ADMIN_PRIV           6212
#define IDS_ERR_NO_SUPP_MEDIA           6214
#define IDS_CONFIRM_MEDIA_RECREATE      6215
#define IDS_WIZ_CAR_COPY_TITLE          6217
#define IDS_WIZ_CAR_COPY_SELECT         6218
#define IDS_WIZ_CAR_COPY_SEL_TEXT       6219
#define IDS_WIZ_CAR_COPY_NEW_NUM        6220
#define IDS_WIZ_UNMANAGE_TITLE          6221
#define IDS_WIZ_FINISH_RUN_JOB          6224
#define IDS_WIZ_UNMANAGE_CONFIRM_NOMANAGE 6226
#define IDS_WIZ_UNMANAGE_CONFIRM_FULL   6227
#define IDS_WIZ_UNMANAGE_SELECT         6230
#define IDS_WIZ_UNMANAGE_SEL_NOMANAGE   6231
#define IDS_WIZ_UNMANAGE_SEL_FULL       6232
#define IDS_WIZ_UNMANAGE_NOMANAGE_TASK_TEXT 6235
#define IDS_JOB_QUICK_UNMANAGE          6236
#define IDS_JOB_FULL_UNMANAGE           6237
#define IDS_VOLUME_STATUS_LABEL_MULTI   6238
#define IDS_VOLUME_STATUS_RS_LABEL_MULTI 6239
#define IDS_VOLUME_STATUS_LABEL_SINGLE  6240
#define IDS_VOLUME_STATUS_RS_LABEL_SINGLE 6241
#define IDS_CAR_NAME_UNKNOWN            6242
#define IDS_CONFIRM_MEDIA_COPY_DELETE_MULTI 6243
#define IDS_CAR_COPYSET_NONE_PLURAL     6244
#define IDS_CAR_COPYSET_INSYNC_SINGULAR 6245
#define IDS_CAR_COPYSET_OUTSYNC_SINGULAR 6246
#define IDS_CAR_STATUS_READONLY_SINGULAR 6247
#define IDS_CAR_STATUS_RECREATE_PLURAL  6248
#define IDS_CAR_STATUS_NORMAL_SINGULAR  6249
#define IDS_RUN_JOB_MULTI1              6250
#define IDS_RUN_JOB_MULTI2              6251
#define IDS_NO_VOLUMES                  6253
#define IDS_LISTVIEW_WIDTHS_IE          6254
#define IDS_LISTVIEW_TITLES_IE          6255
#define IDS_RULE_SUBDIRS_USE            6256
#define IDS_RULE_SUBDIRS_IGNORE         6257
#define IDS_VOLUMES_MANAGED_PLURAL      6258
#define IDS_VOLUMES_MANAGED_SINGULAR    6259
#define IDS_CARTRIDGES_USED_PLURAL      6260
#define IDS_CARTRIDGES_USED_SINGULAR    6261
#define IDS_CAR_STATUS_NORMAL           6262
#define IDS_CAR_STATUS_READONLY         6263
#define IDS_CAR_STATUS_RECREATE         6264
#define IDS_CAR_STATUS_ERROR_RO         6265
#define IDS_CAR_STATUS_ERROR_RW         6266
#define IDS_CAR_STATUS_ERROR_INCOMPLETE 6267
#define IDS_ERROR_SYSTEM_CHECK          6273
#define IDS_CAPACITY                    6274
#define IDS_FREESPACE                   6275
#define IDS_RUN_COPY_JOB                6276
#define IDS_RUN_VALIDATE_JOB            6277
#define IDS_RUN_CFS_JOB                 6278
#define IDS_MONITOR_TASK                6279
#define IDS_RUN_MULTI_COPY_JOBS         6280
#define IDS_RUN_MULTI_VALIDATE_JOBS     6281
#define IDS_RUN_MULTI_CFS_JOBS          6282
#define IDS_VOL_NOT_AVAILABLE           6283
#define IDD_PROP_MEDIA_COPIES           7000
#define IDD_WIZ_QSTART_SCHEDULE         7001
#define IDB_SMALL_SAKKARA               7003
#define IDB_LARGE_SAKKARA               7004
#define IDD_WIZ_QSTART_CHECK            7004
#define IDD_PROP_CAR_STATUS             7005
#define IDD_PROP_CAR_COPIES             7006
#define IDI_DEVLSTX                     7007
#define IDD_WIZ_CAR_COPY_INTRO          7007
#define IDI_NODELIBX                    7008
#define IDD_WIZ_CAR_COPY_FINISH         7008
#define IDD_WIZ_CAR_COPY_SELECT         7009
#define IDD_WIZ_UNMANAGE_FINISH         7010
#define IDD_WIZ_UNMANAGE_INTRO          7011
#define IDD_WIZ_UNMANAGE_SELECT         7012
#define IDD_PROP_CAR_RECOVER            7013
#define IDD_PROP_CAR_STATUS_MULTI       7014
#define IDD_PROP_CAR_COPIES_MULTI       7015
#define IDD_PROP_MANRES_TOOLS           7016
#define IDD_WIZ_CAR_COPY_NUM_COPIES     7017
#define IDB_UNMANAGE_HEADER             7018
#define IDB_MANAGE_HEADER               7019
#define IDB_MEDIA_SYNC_WATERMARK        7020
#define IDB_MEDIA_SYNC_HEADER           7021
#define IDB_UNMANAGE_WATERMARK          7022
#define IDB_MANAGE_WATERMARK            7023
#define IDB_TOOLBAR_VOLUME              7028
#define IDB_TOOLBAR_VOLUME_LIST         7029
#define IDB_TOOLBAR_MESE                7030
#define IDB_TOOLBAR_CAR                 7031
#define IDI_NODEMANVOLX                 7036
#define IDD_CHOOSE_HSM                  7037
#define IDI_MOVEUP                      7038
#define IDD_WIZ_QSTART_MANRES_SELX      7038
#define IDI_MOVEDOWN                    7039
#define IDD_WIZ_MANVOLLST_SELECTX       7039
#define IDD_PROP_RECALL_LIMIT           7040
#define IDI_MOVEDOWN2                   7041
#define IDI_MOVEUP2                     7042
#define IDI_NODEOPENFOLDER              7044
#define IDI_NODETAPEX                   7046
#define IDI_NODEMANVOLD                 7047
#define IDI_NODETAPED                   7048
#define IDD_VALIDATE_WAIT               7049
#define ID_MANVOLLST_ROOT_MANVOL        8007
#define ID_HSMCOM_ROOT_SETUPWIZARD      8008
#define ID_HSMCOM_TASK_SETUPWIZARD      8009
#define ID_MEDSET_ROOT_COPY             8014
#define ID_CAR_COPIES                   8015
#define ID_MANVOL_ROOT_TASKS            8016
#define ID_TASK                         8019
#define ID_MANVOL_ROOT_TOOLS_COPY       8020
#define ID_MANVOL_ROOT_TOOLS_VALIDATE   8021
#define ID_MANVOL_ROOT_TOOLS_CREATE_FREESPACE 8022
#define ID_MANVOL_ROOT_REMOVE           8023
#define IDC_EDIT_MEDIA_COPIES           9000
#define IDC_SPIN_MEDIA_COPIES           9001
#define IDC_SCHED_TEXT                  9002
#define IDC_CHANGE_SCHED                9003
#define IDC_CHECK_LOGON_TEXT            9004
#define IDC_CHECK_LOGON_BOX             9005
#define IDC_CHECK_SUPP_MEDIA_BOX        9007
#define IDC_CHECK_SUPP_MEDIA_TEXT       9008
#define IDC_DESCRIPTION                 9014
#define IDC_NAME                        9015
#define IDC_MODIFIED_1_LABEL            9016
#define IDC_STATUS                      9017
#define IDC_CAPACITY                    9018
#define IDC_FREESPACE                   9019
#define IDC_MODIFIED_2_LABEL            9020
#define IDC_MODIFIED_3_LABEL            9021
#define IDC_RECREATE_MASTER             9023
#define IDC_NAME_1                      9024
#define IDC_STATUS_1                    9025
#define IDC_MODIFIED_1                  9026
#define IDC_STATUS_1_LABEL              9027
#define IDC_NAME_1_LABEL                9028
#define IDC_DELETE_1                    9029
#define IDC_NAME_2_LABEL                9030
#define IDC_NAME_2                      9031
#define IDC_STATUS_2_LABEL              9032
#define IDC_STATUS_2                    9033
#define IDC_MODIFIED_2                  9034
#define IDC_DELETE_2                    9035
#define IDC_NAME_3_LABEL                9036
#define IDC_NAME_3                      9037
#define IDC_STATUS_3_LABEL              9038
#define IDC_STATUS_3                    9039
#define IDC_MODIFIED_3                  9040
#define IDC_DELETE_3                    9041
#define IDC_COPY_1                      9042
#define IDC_COPY_2                      9043
#define IDC_COPY_3                      9044
#define IDC_MODIFIED                    9045
#define IDC_RECREATE_WARNING            9046
#define IDC_STATIC_STATUS               9047
#define IDC_TASK_TEXT                   9048
#define IDC_COPY_LIST                   9049
#define IDC_SELECT_TEXT                 9050
#define IDC_NOMANAGE                    9051
#define IDC_FULL                        9052
#define IDC_STATIC_RS_DATA_LABEL        9056
#define IDC_BTN_COPY_NOW                9057
#define IDC_BTN_VALIDATE                9059
#define IDC_BTN_FREE                    9060
#define IDC_STATIC_NO_VOLUMES_TEXT      9062
#define IDC_RADIO_MANAGE_ALL            9063
#define IDC_RADIO_SELECT                9064
#define IDC_STATIC_MANAGED_VOLUMES      9069
#define IDC_STATIC_DATA_IN_RS_LABEL     9070
#define IDC_STATIC_CARTS_USED           9071
#define IDC_STATIC_MANAGED_VOLUMES_LABEL 9072
#define IDC_STATIC_DATA_IN_RS           9073
#define IDC_STATIC_CARTS_USED_LABEL     9074
#define IDC_STATIC_ENGINE_BUILD_HSM     9075
#define IDC_STATIC_ENGINE_BUILD_FSA     9076
#define IDC_STATIC_BUILD_LABEL_HSM      9077
#define IDC_STATIC_BUILD_LABEL_FSA      9078
#define IDC_REQUESTS_IN_NTMS            9084
#define IDC_WHICH_VOLUME                9085
#define IDC_DESCRIPTION_MULTI           9086
#define IDC_STATIC_VOLUME_NAME          9087
#define IDC_STATIC_GROUP                9088
#define IDC_EXEMPT_ADMINS               9090
#define IDC_MANAGE_ALLOW_CHANGE         9091
#define IDC_TEXT_MEDIA_COPIES           9092
#define IDC_SNAPIN_TITLE                9093
#define IDC_MOREINFO                    9094
#define IDC_STATIC_STATUS_LABEL         9097
#define IDC_NAME_LABEL                  9098
#define IDC_STATUS_LABEL                9099
#define IDC_CAPACITY_LABEL              9100
#define IDC_FREESPACE_LABEL             9101
#define IDC_MODIFIED_LABEL              9102
#define IDC_LIST_IE_LABEL               9104
#define IDC_STATIC_ACTUAL_FREE_PCT_LABEL 9105
#define IDC_STATIC_ACTUAL_FREE_PCT_UNIT 9106
#define IDC_EDIT_LEVEL_LABEL            9107
#define IDC_EDIT_LEVEL_UNIT             9108
#define IDC_EDIT_SIZE_LABEL             9109
#define IDC_EDIT_SIZE_UNIT              9110
#define IDC_EDIT_TIME_LABEL             9111
#define IDC_EDIT_TIME_UNIT              9112
#define IDC_STATIC_PREMIGRATED_SPACE_4DIGIT_LABEL 9113
#define IDC_STATIC_PREMIGRATED_PCT_UNIT 9114
#define IDC_STATIC_USED_SPACE_4DIGIT_LABEL 9116
#define IDC_STATIC_USED_SPACE_4DIGIT_HELP 9117
#define IDC_STATIC_USED_PCT_UNIT        9118
#define IDC_STATIC_FREE_SPACE_4DIGIT_LABEL 9119
#define IDC_STATIC_FREE_PCT_UNIT        9120
#define IDC_STATIC_MANAGED_SPACE_4DIGIT_LABEL 9121
#define IDC_BTN_COPY_NOW_LABEL          9122
#define IDC_BTN_COPY_NOW_GROUP          9123
#define IDC_BTN_VALIDATE_LABEL          9124
#define IDC_BTN_VALIDATE_GROUP          9125
#define IDC_BTN_FREE_LABEL              9126
#define IDC_BTN_FREE_GROUP              9127
#define IDC_SCHED_LABEL                 9128
#define IDC_CHANGE_SCHED_LABEL          9129
#define IDC_EDIT_RECALL_LIMIT_LABEL     9130
#define IDC_SPIN_COPYFILES_LIMIT_LABEL  9131
#define IDC_UNMANAGE_FREE_SPACE_LABEL   9132
#define IDC_UNMANAGE_TRUNCATE_LABEL     9133
#define IDC_UNMANAGE_FREE_SPACE         9134
#define IDC_RECREATE_COPY_LIST          9135
#define IDC_BUTTON_REFRESH              9140
#define IDC_REFRESH_DESCRIPTION         9141
#define IDC_UNMANAGE_FULL_DESCRIPTION   9142
#define IDC_ANIMATE_VALIDATE            9143
#define IDS_ERROR_HEADER                33007
#define IDS_ERROR_CONNECT_HSM           33008

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        7050
#define _APS_NEXT_COMMAND_VALUE         8024
#define _APS_NEXT_CONTROL_VALUE         9145
#define _APS_NEXT_SYMED_VALUE           109
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\rsadutil.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsAdUtil.cpp

Abstract:

    Utility functions for GUI - for us in HSMADMIN files only

Author:

    Art Bragg [abragg]   04-Mar-1997

Revision History:

    Chris Timmes    [ctimmes]   21-Nov-1997  
    
    - modified RsCreateAndRunFsaJob(), RsCreateAndRunMediaCopyJob(),and 
      RsCreateAndRunMediaRecreateJob() to use the new Engine method CreateTask(), which
      creates a task in the NT Task Scheduler.  Change required due to changing Sakkara 
      to run under LocalSystem account.
      
--*/

#include "stdafx.h"


HRESULT
RsGetStatusString (
    DWORD    serviceStatus,
    HRESULT  hrSetup,
    CString& sStatus
    )
{

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    switch( serviceStatus ) {
    case SERVICE_STOPPED:
        sStatus.LoadString(IDS_SERVICE_STATUS_STOPPED);
        break;
    case SERVICE_START_PENDING:
        sStatus.LoadString(IDS_SERVICE_STATUS_START_PENDING);
        break;
    case SERVICE_STOP_PENDING:
        sStatus.LoadString(IDS_SERVICE_STATUS_STOP_PENDING);
        break;
    case SERVICE_RUNNING:
        //
        // See if we are setup yet
        //
        if( S_FALSE == hrSetup ) {

            sStatus.LoadString(IDS_SERVICE_STATUS_NOT_SETUP);

        } else {

            sStatus.LoadString(IDS_SERVICE_STATUS_RUNNING);

        }
        break;
    case SERVICE_CONTINUE_PENDING:
        sStatus.LoadString(IDS_SERVICE_STATUS_CONTINUE_PENDING);
        break;
    case SERVICE_PAUSE_PENDING:
        sStatus.LoadString(IDS_SERVICE_STATUS_PAUSE_PENDING);
        break;
    case SERVICE_PAUSED:
        sStatus.LoadString(IDS_SERVICE_STATUS_PAUSED);
        break;
    }
    return S_OK;
}

WCHAR *
RsNotifyEventAsString (
    IN  MMC_NOTIFY_TYPE event
    )
/*++

Routine Description:

    For debug purposes, converts the event type into a UNICODE string.

Arguments:

    event           - The event type

Return Value:

    String representing notify code - not I18N'd.

--*/
{
#define CASE_EVENT(x) case x: return TEXT(#x); break;
    
    switch( event )
    {

    CASE_EVENT( MMCN_ACTIVATE        )
    CASE_EVENT( MMCN_ADD_IMAGES      )
    CASE_EVENT( MMCN_BTN_CLICK       )
    CASE_EVENT( MMCN_CLICK           )
    CASE_EVENT( MMCN_COLUMN_CLICK    )
    CASE_EVENT( MMCN_CONTEXTMENU     )
    CASE_EVENT( MMCN_CUTORMOVE       )
    CASE_EVENT( MMCN_DBLCLICK        )
    CASE_EVENT( MMCN_DELETE          )
    CASE_EVENT( MMCN_DESELECT_ALL    )
    CASE_EVENT( MMCN_EXPAND          )
    CASE_EVENT( MMCN_HELP            )
    CASE_EVENT( MMCN_MENU_BTNCLICK   )
    CASE_EVENT( MMCN_MINIMIZED       )
    CASE_EVENT( MMCN_PASTE           )
    CASE_EVENT( MMCN_PROPERTY_CHANGE )
    CASE_EVENT( MMCN_QUERY_PASTE     )
    CASE_EVENT( MMCN_REFRESH         )
    CASE_EVENT( MMCN_REMOVE_CHILDREN )
    CASE_EVENT( MMCN_RENAME          )
    CASE_EVENT( MMCN_SELECT          )
    CASE_EVENT( MMCN_SHOW            )
    CASE_EVENT( MMCN_VIEW_CHANGE     )
    CASE_EVENT( MMCN_SNAPINHELP      )
    CASE_EVENT( MMCN_CONTEXTHELP     )
    CASE_EVENT( MMCN_INITOCX         )
    CASE_EVENT( MMCN_FILTER_CHANGE   )
    CASE_EVENT( MMCN_FILTERBTN_CLICK )
    CASE_EVENT( MMCN_RESTORE_VIEW    )
    CASE_EVENT( MMCN_PRINT           )
    CASE_EVENT( MMCN_PRELOAD         )
    CASE_EVENT( MMCN_LISTPAD         )
    CASE_EVENT( MMCN_EXPANDSYNC      )

    default:
        static WCHAR buf[32];
        swprintf( buf, L"Unknown Event[0x%p]", event );
        return( buf );
    }
}


WCHAR *
RsClipFormatAsString (
    IN  CLIPFORMAT cf
    )
/*++

Routine Description:

    For debug purposes, converts the event type into a UNICODE string.

Arguments:

    event           - The event type

Return Value:

    String representing notify code - not I18N'd.

--*/
{
    static WCHAR buf[128];

    GetClipboardFormatName( cf, buf, 128 );
    return( buf );
}


HRESULT
RsIsRemoteStorageSetup(
    void
    )
/*++

Routine Description:

    Reports back if Remote Storage has been set up on this machine.

Arguments:

    none.

Return Value:

    S_OK if setup
    S_FALSE if not

--*/
{
    WsbTraceIn( L"RsIsRemoteStorageSetup", L"" );
    HRESULT hr = S_FALSE;

    try {
    
        //
        // First, see if service is registered
        //

        CWsbStringPtr hsmName;
        WsbTrace( L"Checking if service is registered\n" );
        WsbAffirmHr( WsbGetServiceInfo( APPID_RemoteStorageEngine, &hsmName, 0 ) );

        //
        // Second, contact the engine. this will start the service if it
        // is not already started.
        //

        CWsbStringPtr computerName;
        WsbAffirmHr( WsbGetComputerName( computerName ) );

        CComPtr<IHsmServer> pHsm;
        WsbTrace( L"Contacting Engine\n" );
        WsbAffirmHr( HsmConnectFromName( HSMCONN_TYPE_HSM, computerName, IID_IHsmServer, (void**)&pHsm ) );

        //
        // Third, see if it has a storage pool ID
        //

        hr = RsIsRemoteStorageSetupEx( pHsm );

    } WsbCatch( hr );


    WsbTraceOut( L"RsIsRemoteStorageSetup", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

void 
RsReportError( HRESULT hrToReport, int textId, ... ) 
/*++

Routine Description:

    Reports an error to the user.

Arguments:

    hrToReport - the hr that was thrown
    textId      - Resource Id of context of the error
    ...         - Substitution arguments for textId

Return Value:

    none

--*/
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // Make sure we don't report S_OK, S_FALSE
    //
    if( FAILED( hrToReport ) ) {

        CString errorText;
        CString formatString;

        //
        // Substitute in the text context string
        //
        va_list list;
        va_start( list, textId );

        formatString.LoadString( textId );
        LPTSTR p;
        p = errorText.GetBuffer( 1024 );
        vswprintf( p, (LPCTSTR) formatString, list );
        errorText.ReleaseBuffer();

        va_end( list );


        CWsbStringPtr hrText;
        CString msgText;
        CString headerText;

        //
        // Put together the complete text
        //
        hrText = WsbHrAsString( hrToReport );
        headerText.LoadString( IDS_ERROR_HEADER );
        msgText = headerText + L"\n\r\n\r" + errorText + L"\n\r\n\r" + hrText;

        //
        // Show the message
        //
        AfxMessageBox( msgText, RS_MB_ERROR );

    }
}





HRESULT
RsIsRemoteStorageSetupEx(
    IHsmServer * pHsmServer
    )
/*++

Routine Description:

    Reports back if Remote Storage has been set up on this machine.

Arguments:

    none.

Return Value:

    S_OK if setup
    S_FALSE if not

--*/
{
    WsbTraceIn( L"RsIsRemoteStorageSetupEx", L"" );
    HRESULT hr = S_FALSE;

    try {
    
        //
        // If it has a Media Set ID, it's set up.
        //

        GUID guid;
        CWsbBstrPtr poolName;
        CComPtr<IHsmStoragePool> pPool;
        WsbAffirmHr( RsGetStoragePool( pHsmServer, &pPool ) );
        WsbAffirmHr( pPool->GetMediaSet( &guid, &poolName ) );

        if( ! IsEqualGUID( guid, GUID_NULL ) ) {

            hr = S_OK;

        }
    
    } WsbCatch( hr );

    WsbTraceOut( L"RsIsRemoteStorageSetupEx", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
RsIsSupportedMediaAvailable(
    void
    )
/*++

Routine Description:

    Checks to see if NTMS is setup, and setup with useable media.

Arguments:

    none.

Return Value:

    TRUE if NTMS is configured with supported media
    FALSE if NTMS is not configured with supported media

--*/
{
    WsbTraceIn( L"RsIsSupportedMediaAvailable", L"" );
    HRESULT hr = S_FALSE;

    try {
        
        //
        // First, contact the RMS engine and ask it if 
        // RMS has supported media.
        //

        CWsbStringPtr computerName;
        WsbAffirmHr( WsbGetComputerName( computerName ) );
        CComPtr<IHsmServer> pHsm;
        CComPtr<IRmsServer> pRms;
        WsbTrace( L"Contacting HSM Server to get RMS\n" );
        WsbAffirmHr( HsmConnectFromName( HSMCONN_TYPE_HSM, computerName, IID_IHsmServer, (void**)&pHsm ) );
        WsbAffirmPointer(pHsm);
        WsbAffirmHr(pHsm->GetHsmMediaMgr(&pRms));
        WsbTrace( L"Connected to RMS\n" );

        //
        // Second, wait for RMS to finish initializing, thus
        // to have all media sets added
        //

        {
            CComObject<CRmsSink> *pSink = new CComObject<CRmsSink>;
            CComPtr<IUnknown> pSinkUnk = pSink;
            WsbAffirmHr( pSink->Construct( pRms ) );

            WsbAffirmHr( pSink->WaitForReady( ) );

            WsbAffirmHr( pSink->DoUnadvise( ) );
        }

        //
        // Fourth
        // Ask it
        //

        CComPtr<IWsbIndexedCollection> pMediaSets;
        WsbAffirmHr( pRms->GetMediaSets( &pMediaSets ) );

        ULONG numEntries;
        WsbTrace( L"Checking for Media Sets\n" );
        WsbAffirmHr( pMediaSets->GetEntries( &numEntries ) );

        WsbTrace( L"NumMediaSets = 0x%lu\n", numEntries );

        if( numEntries > 0 ) {

            //
            // All conditions met, return TRUE
            //

            WsbTrace( L"Supported Media Found\n" );

            hr = S_OK;

        }

    } WsbCatch( hr );

    WsbTraceOut( L"RsIsSupportedMediaAvailable", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

USHORT
RsGetCopyStatus(
    IN  REFGUID   CopyId,
    IN  HRESULT   CopyHr,
    IN  SHORT     CopyNextDataSet,
    IN  SHORT     LastGoodNextDataSet
    )
/*++

Routine Description:

    Compares the two times and returns an appropriate defined value
    based upon comparison (for Media Copies)

Arguments:

    MasterTime - the time of last update to master

    CopyTime - the time of last update to copy

    copyStatus - returned value

Return Value:

    none

--*/
{
    WsbTraceIn( L"RsGetCopyStatus", L"CopyId = <%ls>, CopyHr = <%ls>, CopyNextDataSet = <%hd>, LastGoodNextDataSet = <%hd>", WsbGuidAsString( CopyId ), WsbHrAsString( CopyHr ), CopyNextDataSet, LastGoodNextDataSet );
    USHORT copyStatus;

    //
    // Certain errors need to be masked out because they do not necessarily
    // mean the media copy has an error - just that something happened that
    // was unexpected, like timed out mounts or canceled mounts
    //
    switch( CopyHr ) {

    case RMS_E_CANCELLED:
    case RMS_E_REQUEST_REFUSED:
    case RMS_E_WRITE_PROTECT:
    case RMS_E_MEDIA_OFFLINE:
    case RMS_E_TIMEOUT:
    case RMS_E_SCRATCH_NOT_FOUND:
    case RMS_E_CARTRIDGE_UNAVAILABLE:
    case RMS_E_CARTRIDGE_DISABLED:

        CopyHr = S_OK;
        break;

    }

    if( IsEqualGUID( CopyId, GUID_NULL ) ) {

        copyStatus = RS_MEDIA_COPY_STATUS_NONE;

    } else if( RMS_E_CARTRIDGE_NOT_FOUND == CopyHr ) {

        copyStatus = RS_MEDIA_COPY_STATUS_MISSING;

    } else if( FAILED( CopyHr ) ) {

        copyStatus = RS_MEDIA_COPY_STATUS_ERROR;

    } else if( CopyNextDataSet < LastGoodNextDataSet ) {

        copyStatus = RS_MEDIA_COPY_STATUS_OUTSYNC;

    } else {

        copyStatus = RS_MEDIA_COPY_STATUS_INSYNC;

    }

    WsbTraceOut( L"RsGetCopyStatus", L"copyStatus = <%hu>", copyStatus );
    return copyStatus;
}

HRESULT
RsGetCopyStatusStringVerb(
    IN  USHORT    copyStatus,
    IN  BOOL    plural,
    OUT CString & statusString
    )
/*++

Routine Description:

    Creates and returns a status string based on the status, with
    a verb on it, for example "is synchronized"

Arguments:

    copyStatus - defined status for media copies

    plural - true if verb should be plural

    String - Resulting string

Return Value:

    non.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn( L"RsGetCopyStatusStringVerb", L"CopyStatus = <%hu> ", copyStatus );
    switch ( copyStatus ) {
    case RS_MEDIA_COPY_STATUS_NONE:
        if ( plural )
            statusString.LoadString( IDS_CAR_COPYSET_NONE_PLURAL );
        else
            statusString.LoadString( IDS_CAR_COPYSET_NONE_SINGULAR );
        break;
    case RS_MEDIA_COPY_STATUS_ERROR:
        statusString.LoadString( IDS_CAR_COPYSET_ERROR_SP );
        break;
    case RS_MEDIA_COPY_STATUS_MISSING:
        if ( plural )
            statusString.LoadString( IDS_CAR_COPYSET_MISSING_PLURAL );
        else
            statusString.LoadString( IDS_CAR_COPYSET_MISSING_SINGULAR );
        break;
    case RS_MEDIA_COPY_STATUS_OUTSYNC:
        if ( plural )
            statusString.LoadString( IDS_CAR_COPYSET_OUTSYNC_PLURAL );
        else
            statusString.LoadString( IDS_CAR_COPYSET_OUTSYNC_SINGULAR );
        break;
    case RS_MEDIA_COPY_STATUS_INSYNC:
        if ( plural )
            statusString.LoadString( IDS_CAR_COPYSET_INSYNC_PLURAL );
        else
            statusString.LoadString( IDS_CAR_COPYSET_INSYNC_SINGULAR );
        break;
    default:
        statusString = L"";
        hr = E_INVALIDARG;
        break;
    }
    WsbTraceOut( L"RsGetCopyStatusStringVerb", L"String = <%ls>", statusString );
    return hr;
}

HRESULT
RsGetCopyStatusString(
    IN  USHORT    copyStatus,
    OUT CString & statusString
    )
/*++

Routine Description:

    Creates and returns a status string based on the status

Arguments:

    copyStatus - defined status for media copies

    String - Resulting string

Return Value:

    non.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn( L"RsGetCopyStatusString", L"CopyStatus = <%hu> ", copyStatus );
    switch ( copyStatus ) {
    case RS_MEDIA_COPY_STATUS_NONE:
        statusString.LoadString( IDS_CAR_COPYSET_NONE );
        break;
    case RS_MEDIA_COPY_STATUS_ERROR:
        statusString.LoadString( IDS_CAR_COPYSET_ERROR );
        break;
    case RS_MEDIA_COPY_STATUS_MISSING:
        statusString.LoadString( IDS_CAR_COPYSET_MISSING );
        break;
    case RS_MEDIA_COPY_STATUS_OUTSYNC:
        statusString.LoadString( IDS_CAR_COPYSET_OUTSYNC );
        break;
    case RS_MEDIA_COPY_STATUS_INSYNC:
        statusString.LoadString( IDS_CAR_COPYSET_INSYNC );
        break;
    default:
        statusString = L"";
        hr = E_INVALIDARG;
        break;
    }
    WsbTraceOut( L"RsGetCopyStatusString", L"String = <%ls>", statusString );
    return hr;
}


USHORT
RsGetCartStatus(
    IN  HRESULT   LastHr,
    IN  BOOL      ReadOnly,
    IN  BOOL      Recreate,
    IN  SHORT     NextDataSet,
    IN  SHORT     LastGoodNextDataSet
    )
/*++

Routine Description:

    Returns a constant appropriate the status of a piece of media.

Arguments:

    MasterTime - the time of last update to master

    CopyTime - the time of last update to copy

Return Value:

    defined constant for media status

--*/
{
    USHORT cartStatus;
    if( Recreate ) {

        cartStatus = RS_MEDIA_STATUS_RECREATE;

    } else if( NextDataSet < LastGoodNextDataSet ) {

        cartStatus = RS_MEDIA_STATUS_ERROR_INCOMPLETE;
        
    } else if( SUCCEEDED( LastHr ) || ( RMS_E_CARTRIDGE_DISABLED == LastHr ) ) {

        cartStatus = ( ReadOnly ? RS_MEDIA_STATUS_READONLY : RS_MEDIA_STATUS_NORMAL );

    } else if( RMS_E_CARTRIDGE_NOT_FOUND == LastHr ) {

        cartStatus = RS_MEDIA_STATUS_ERROR_MISSING;

    } else {

        cartStatus = ( ReadOnly ? RS_MEDIA_STATUS_ERROR_RO : RS_MEDIA_STATUS_ERROR_RW );

    }
    return cartStatus;
}

HRESULT
RsGetCartStatusStringVerb(
    IN USHORT cartStatus,
    IN BOOL plural,
    OUT CString & statusString
    )
/*++

Routine Description:

    Retreives a string appropriate the status of a piece of media with
    a verb on it, for example "is read-only"

Arguments:
    
    cartStatus


    String - Resulting string

Return Value:

    non.

--*/
{
    HRESULT hr = S_OK;
    switch( cartStatus ) {

    case RS_MEDIA_STATUS_RECREATE:
        if( plural ) {

            statusString.LoadString( IDS_CAR_STATUS_RECREATE_PLURAL );

        } else  {

            statusString.LoadString( IDS_CAR_STATUS_RECREATE_SINGULAR  );

        }
        break;

    case RS_MEDIA_STATUS_READONLY:
        if( plural ) {

            statusString.LoadString( IDS_CAR_STATUS_READONLY_PLURAL );

        } else {

            statusString.LoadString( IDS_CAR_STATUS_READONLY_SINGULAR );

        }
        break;

    case RS_MEDIA_STATUS_NORMAL:
        if( plural ) {

            statusString.LoadString( IDS_CAR_STATUS_NORMAL_PLURAL );

        } else {

            statusString.LoadString( IDS_CAR_STATUS_NORMAL_SINGULAR );

        }
        break;

    case RS_MEDIA_STATUS_ERROR_RO:
        statusString.LoadString( IDS_CAR_STATUS_ERROR_RO_SP );
        break;

    case RS_MEDIA_STATUS_ERROR_RW:
        statusString.LoadString( IDS_CAR_STATUS_ERROR_RW_SP );
        break;

    case RS_MEDIA_STATUS_ERROR_INCOMPLETE:
        if( plural ) {

            statusString.LoadString( IDS_CAR_STATUS_ERROR_INCOMPLETE_PLURAL );

        } else {

            statusString.LoadString( IDS_CAR_STATUS_ERROR_INCOMPLETE_SINGULAR );

        }
        break;

    case RS_MEDIA_STATUS_ERROR_MISSING:
        if( plural ) {

            statusString.LoadString( IDS_CAR_STATUS_ERROR_MISSING_PLURAL );

        } else {

            statusString.LoadString( IDS_CAR_STATUS_ERROR_MISSING_SINGULAR );

        }
        break;

    default:
        statusString = L"";
        hr = E_INVALIDARG;
    }
    return hr;
}

HRESULT
RsGetCartStatusString(
    IN USHORT cartStatus,
    OUT CString & statusString
    )
/*++

Routine Description:

    Retreives a string appropriate the status of a piece of media.

Arguments:
    
    cartStatus


    String - Resulting string

Return Value:

    non.

--*/
{
    HRESULT hr = S_OK;
    switch( cartStatus ) {

    case RS_MEDIA_STATUS_RECREATE:
        statusString.LoadString( IDS_CAR_STATUS_RECREATE );
        break;

    case RS_MEDIA_STATUS_READONLY:
        statusString.LoadString( IDS_CAR_STATUS_READONLY );
        break;

    case RS_MEDIA_STATUS_NORMAL:
        statusString.LoadString( IDS_CAR_STATUS_NORMAL );
        break;

    case RS_MEDIA_STATUS_ERROR_RO:
        statusString.LoadString( IDS_CAR_STATUS_ERROR_RO );
        break;

    case RS_MEDIA_STATUS_ERROR_RW:
        statusString.LoadString( IDS_CAR_STATUS_ERROR_RW );
        break;

    case RS_MEDIA_STATUS_ERROR_MISSING:
        statusString.LoadString( IDS_CAR_STATUS_ERROR_MISSING );
        break;

    case RS_MEDIA_STATUS_ERROR_INCOMPLETE:
        statusString.LoadString( IDS_CAR_STATUS_ERROR_INCOMPLETE );
        break;

    default:
        statusString = L"";
        hr = E_INVALIDARG;
    }

    return( hr );
}

HRESULT
RsGetCartMultiStatusString(
    IN USHORT statusRecreate,
    IN USHORT statusReadOnly,
    IN USHORT statusNormal,
    IN USHORT statusRO,
    IN USHORT statusRW,
    IN USHORT statusMissing,
    OUT CString &outString )
{
    HRESULT hr = S_OK;
    try {

        outString = L"";
        CString statusString;
        CString formatString;
        BOOL    skipSeparator = TRUE; // used to omit first prepended comma

#define INSERT_SEPARATOR if( ! skipSeparator ) { outString += ", "; } else { skipSeparator = FALSE; }

        if( statusNormal > 0 ) {
            
            INSERT_SEPARATOR
            WsbAffirmHr( RsGetCartStatusStringVerb( RS_MEDIA_STATUS_NORMAL, ( statusNormal != 1 ), statusString ) );
            formatString.Format( L"%d %s", statusNormal, statusString );
            outString += formatString;

        }

        if( statusReadOnly > 0 ) {
            
            INSERT_SEPARATOR
            WsbAffirmHr( RsGetCartStatusStringVerb( RS_MEDIA_STATUS_READONLY, ( statusReadOnly != 1 ), statusString ) );
            formatString.Format( L"%d %s", statusReadOnly, statusString );
            outString += formatString;

        }

        if( statusRecreate > 0 ) {
            
            INSERT_SEPARATOR
            WsbAffirmHr( RsGetCartStatusStringVerb( RS_MEDIA_STATUS_RECREATE, ( statusRecreate != 1 ), statusString ) );
            formatString.Format( L"%d %s", statusRecreate, statusString );
            outString += formatString;

        }

        if( statusRO > 0 ) {
            
            INSERT_SEPARATOR
            WsbAffirmHr( RsGetCartStatusStringVerb( RS_MEDIA_STATUS_ERROR_RO, ( statusRO != 1 ), statusString ) );
            formatString.Format( L"%d %s", statusRO, statusString );
            outString += formatString;

        }

        if( statusRW > 0 ) {
            
            INSERT_SEPARATOR
            WsbAffirmHr( RsGetCartStatusStringVerb( RS_MEDIA_STATUS_ERROR_RW, ( statusRW != 1 ), statusString ) );
            formatString.Format( L"%d %s", statusRW, statusString );
            outString += formatString;

        }

        if( statusMissing > 0 ) {
            
            INSERT_SEPARATOR
            WsbAffirmHr( RsGetCartStatusStringVerb( RS_MEDIA_STATUS_ERROR_MISSING, ( statusMissing != 1 ), statusString ) );
            formatString.Format( L"%d %s", statusMissing, statusString );
            outString += formatString;

        }

    } WsbCatch( hr );
    return( hr );
}

HRESULT
RsGetCopyMultiStatusString( 
    IN USHORT statusNone, 
    IN USHORT statusError, 
    IN USHORT statusOutSync, 
    IN USHORT statusInSync,
    OUT CString &outString
    )
{
    HRESULT hr = S_OK;
    try {
        outString = L"";
        CString statusString;
        CString formatString;


        WsbAffirmHr( RsGetCopyStatusStringVerb( RS_MEDIA_COPY_STATUS_INSYNC, ( statusInSync != 1), statusString ) );
        formatString.Format( L"%d %s, ", statusInSync, statusString );
        outString += formatString;

        WsbAffirmHr( RsGetCopyStatusStringVerb( RS_MEDIA_COPY_STATUS_OUTSYNC, ( statusOutSync != 1), statusString ) );
        formatString.Format( L"%d %s, ", statusOutSync, statusString );
        outString += formatString;

        WsbAffirmHr( RsGetCopyStatusStringVerb( RS_MEDIA_COPY_STATUS_NONE, ( statusNone != 1), statusString ) );
        formatString.Format( L"%d %s, ", statusNone, statusString );
        outString += formatString;

        WsbAffirmHr( RsGetCopyStatusStringVerb( RS_MEDIA_COPY_STATUS_ERROR, ( statusError != 1 ), statusString ) );
        formatString.Format( L"%d %s, ", statusError, statusString );
        outString += formatString;

        WsbAffirmHr( RsGetCopyStatusStringVerb( RS_MEDIA_COPY_STATUS_MISSING, ( statusError != 1 ), statusString ) );
        formatString.Format( L"%d %s", statusError, statusString );
        outString += formatString;
    } WsbCatch (hr);
    return hr;
}



HRESULT
RsCreateAndRunFsaJob(
    IN  HSM_JOB_DEF_TYPE jobType,
    IN  IHsmServer   *pHsmServer,
    IN  IFsaResource *pFsaResource,
    IN  BOOL ShowMsg
    )
///////////////////////////////////////////////////////////////////////
//
//      RsCreateAndRunFsaJob
//
// Creates a job in the engine of the given type, since scanning of a 
// resource is required by the job, and since the job is partitioned 
// across the Remote Storage major components.  Puts the job in the
// NT Task Scheduler and runs it now via a call to the Engine's CreateTask()
// method.  The Task Scheduler task is Disabled, so it will not be run 
// according to a schedule.
//
//
{
    WsbTraceIn( L"RsCreateAndRunFsaJob", L"jobType = <%d>", jobType );
                                    

    HRESULT hr = S_OK;
    CComPtr<IWsbCreateLocalObject>  pLocalObject;
    CComPtr<IHsmJob>                pExistJob;
    CComPtr<IHsmJob>                pNewJob;
    CWsbStringPtr                   pszExistJobName;

    try {

        WsbAssertPointer( pFsaResource );
        WsbAssertPointer( pHsmServer );

        //
        // First check to see if volume is available. If not, return
        // S_FALSE
        //
        HRESULT hrAvailable = pFsaResource->IsAvailable( );
        WsbAffirmHr( hrAvailable );
        HRESULT hrDeletePending = pFsaResource->IsDeletePending( );
        WsbAffirmHr( hrDeletePending );

        WsbAffirm( ( S_OK == hrAvailable ) && ( S_OK != hrDeletePending ), S_FALSE );

        //
        // Get the volume name
        //
        CWsbStringPtr szWsbVolumeName;
        WsbAffirmHr( pFsaResource->GetName( &szWsbVolumeName, 0 ) );

        //
        // Create a job name
        //
        CString jobName;
        RsCreateJobName( jobType, pFsaResource, jobName );

        //
        // Exit with an error if a job of this name is active already
        //
        if (S_OK == pHsmServer->FindJobByName( (LPWSTR)(LPCWSTR)jobName, &pExistJob)) {
            if (S_OK == pExistJob->IsActive()) {
                WsbThrow(JOB_E_ALREADYACTIVE);
            }
        }
        
        //
        // Inform the user, then create the job in the Engine, finally create 
        // and start the job in the NT Task Scheduler.
        //
        CString szJobType;
        WsbAffirmHr( RsGetJobTypeString( jobType, szJobType ) );
        CWsbStringPtr computerName;
        WsbAffirmHr( pHsmServer->GetName( &computerName ) );
        CString message;
        AfxFormatString2( message, IDS_RUN_JOB, jobName, computerName );

        if( !ShowMsg || ( AfxMessageBox( message, MB_ICONINFORMATION | MB_OKCANCEL | 
                                                    MB_DEFBUTTON2 ) == IDOK ) ) {
            //
            // Get the one and only (for Sakkara) storage pool Id
            //
            GUID storagePoolId;
            WsbAffirmHr( RsGetStoragePoolId( pHsmServer, &storagePoolId ) );

            //
            // Get a CreateLocalobject interface with which to create the job
            //
            WsbAffirmHr( RsQueryInterface( pHsmServer, IWsbCreateLocalObject, pLocalObject ) );

            //
            // Create the new job in the engine
            //
            WsbAffirmHr( pLocalObject->CreateInstance( CLSID_CHsmJob, IID_IHsmJob, (void**) &pNewJob ) );
            WsbAffirmHr( pNewJob->InitAs(
                (LPWSTR)(LPCWSTR)jobName, NULL, jobType, storagePoolId, 
                pHsmServer, TRUE, pFsaResource));

            //
            // Get the jobs collection from the engine
            //
            CComPtr<IWsbIndexedCollection> pJobs;
            WsbAffirmHr( pHsmServer->GetJobs( &pJobs ) );

            //
            // If any jobs exist with this name, delete them
            //
            ULONG cCount;
            WsbAffirmHr (pJobs->GetEntries( &cCount ) );
            for( UINT i = 0; i < cCount; i++ ) {

                pExistJob.Release( );
                WsbAffirmHr( pJobs->At( i, IID_IHsmJob, (void **) &pExistJob ) );
                WsbAffirmHr( pExistJob->GetName( &pszExistJobName, 0 ) );
                if( pszExistJobName.IsEqual( jobName ) ) {

                    WsbAffirmHr( pJobs->RemoveAndRelease( pExistJob ) );
                    i--; cCount--;

                }
            }

            //
            // Add the new job to the engine collection
            //
            WsbAffirmHr( pJobs->Add( pNewJob ) );

            //
            // Set up to call the Engine to create an entry in NT Task Scheduler
            //
            // Create the parameter string to the program NT Scheduler
            // will run (for Sakkara this is RsLaunch).
            //
            CString szParameters;
            szParameters.Format( L"run \"%ls\"", jobName );

            //
            // Create the comment string for the NT Scheduler entry
            //
            CString commentString;
            AfxFormatString2( commentString, IDS_GENERIC_JOB_COMMENT, szJobType, szWsbVolumeName);

            //
            // Declare and initialize the schedule components passed to 
            // the engine.  Since this task is Disabled these are simply
            // set to 0 (COM requires populating all arguments).
            //
            TASK_TRIGGER_TYPE   jobTriggerType = TASK_TIME_TRIGGER_ONCE;
            WORD                jobStartHour   = 0;
            WORD                jobStartMinute = 0;

            //
            // Indicate this is a Disabled task
            //
            BOOL                scheduledJob   = FALSE;

            //
            // Create and run the task
            //
            WsbAffirmHr( pHsmServer->CreateTask( jobName, szParameters,
                                                  commentString, jobTriggerType,
                                                  jobStartHour, jobStartMinute,
                                                  scheduledJob ) );
        }

    } WsbCatch( hr );

    WsbTraceOut( L"RsCreateAndRunFsaJob", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
RsCreateAndRunDirectFsaJob(
    IN  HSM_JOB_DEF_TYPE jobType,
    IN  IHsmServer   *pHsmServer,
    IN  IFsaResource *pFsaResource,
    IN  BOOL waitJob
    )
///////////////////////////////////////////////////////////////////////
//
//      RsCreateAndRunFsaJob
//
// Creates a job in the engine of the given type and run it.
// Wait for the job if required.
// Notes:
// 1) This job is not created and ran through the Task Scheduler
// 2) Most of the code is taken from StartJob in clivol.cpp
//    In the future we should consider using this code instead of replicating
//
{
    WsbTraceIn( L"RsCreateAndRunDirectFsaJob", L"jobType = <%d>", jobType );
                                    
    HRESULT hr = S_OK;

    try {
        CComPtr<IHsmJob>    pJob;
        CString             jobName;

        // Create job name
        WsbAffirmHr(RsCreateJobName(jobType, pFsaResource, jobName));

        // If job exists - use it, otherwize, craete and add an appropriate job object
        hr = pHsmServer->FindJobByName((LPWSTR)(LPCWSTR)jobName, &pJob);
        if (S_OK == hr) {
            // Job already exists

        } else if (WSB_E_NOTFOUND == hr) {
            // No such job yet
            CComPtr<IWsbCreateLocalObject>  pCreateObj;
            CComPtr<IWsbIndexedCollection>  pJobs;
            CComPtr<IWsbIndexedCollection>  pCollection;
            CComPtr<IHsmStoragePool>        pStoragePool;
            GUID                            poolId;
            ULONG                           count;

            hr = S_OK;
            pJob = 0;

            // Create and add the job
            WsbAffirmHr(pHsmServer->QueryInterface(IID_IWsbCreateLocalObject, (void**) &pCreateObj));
            WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmJob, IID_IHsmJob, (void**) &pJob));

            WsbAffirmHr(pHsmServer->GetStoragePools(&pCollection));
            WsbAffirmHr(pCollection->GetEntries(&count));
            WsbAffirm(1 == count, E_FAIL);
            WsbAffirmHr(pCollection->At(0, IID_IHsmStoragePool, (void **)&pStoragePool));
            WsbAffirmHr(pStoragePool->GetId(&poolId));

            WsbAffirmHr(pJob->InitAs((LPWSTR)(LPCWSTR)jobName, NULL, jobType, 
                                poolId, pHsmServer, TRUE, pFsaResource));
            WsbAffirmHr(pHsmServer->GetJobs(&pJobs));
            WsbAffirmHr(pJobs->Add(pJob));

        } else {
            // Other error - abort
            WsbThrow(hr);
        }

        // Start the job
        WsbAffirmHr(pJob->Start());

        // Wait if required
        if (waitJob) {
            WsbAffirmHr(pJob->WaitUntilDone());
        }

    } WsbCatch(hr);

    WsbTraceOut( L"RsCreateAndRunDirectFsaJob", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
RsCancelDirectFsaJob(
    IN  HSM_JOB_DEF_TYPE jobType,
    IN  IHsmServer   *pHsmServer,
    IN  IFsaResource *pFsaResource
    )
///////////////////////////////////////////////////////////////////////
//
//      RsCancelDirectFsaJob
//
// Cancel a job that was previously ran with RsCreateAndRunDirectFsaJob
// Notes:
// 1) This job is not cancelled through the Task Scheduler
// 2) Most of the code is taken from CancelJob in clivol.cpp
//    In the future we should consider using this code instead of replicating
//
{
    WsbTraceIn( L"RsCancelDirectFsaJob", L"jobType = <%d>", jobType );
                                    
    HRESULT hr = S_OK;

    try {
        CComPtr<IHsmJob>    pJob;
        CString             jobName;

        // Create job name
        WsbAffirmHr(RsCreateJobName(jobType, pFsaResource, jobName));

        // If job exists, try to cancel it
        hr = pHsmServer->FindJobByName((LPWSTR)(LPCWSTR)jobName, &pJob);
        if (S_OK == hr) {
            // Cancel (we don't care if it's actually running or not)
            WsbAffirmHr(pJob->Cancel(HSM_JOB_PHASE_ALL));

        } else if (WSB_E_NOTFOUND == hr) {
            // No such job, for sure it is not running...
            hr = S_OK;

        } else {
            // Other error - abort
            WsbThrow(hr);
        }

    } WsbCatch(hr);

    WsbTraceOut( L"RsCancelDirectFsaJob", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
RsCreateJobName(
    IN  HSM_JOB_DEF_TYPE jobType, 
    IN  IFsaResource *   pResource,
    OUT CString&         jobName
    )
/////////////////////////////////////////////////////////////////////////////////
//
//              RsCreateJobName
//
// Creates a job name for a volume type job
//
//
{
    WsbTraceIn( L"RsCreateJobName", L"jobType = <%d>", jobType );

    HRESULT hr = S_OK;
    try {

        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        CString jobTypeString;
        RsGetJobTypeString( jobType, jobTypeString );

        CWsbStringPtr path;
        WsbAffirmHr( pResource->GetUserFriendlyName( &path, 0 ) );

        // For now, ignore the path if it's not a drive letter
        size_t pathLen = wcslen(path);
        if ((pathLen != 3) || (path[1] != L':')) {
            path = L"";
        }

        CString volumeString;
        if( path.IsEqual ( L"" ) ) {

            //
            // No drive letter - use the volume name and serial number instead
            //
            ULONG   serial;
            CWsbStringPtr name;

            WsbAffirmHr( pResource->GetName( &name, 0 ) );
            WsbAffirmHr( pResource->GetSerial( &serial ) );

            if( name.IsEqual( L"" ) ) {

                //
                // No name, no drive letter - just have serial number
                //
                volumeString.Format( L"%8.8lx", serial );

            } else {

                volumeString.Format( L"%ls-%8.8lx", (OLECHAR*)name, serial );

            }

        } else {

            path[1] = L'\0';
            volumeString = path;

        }
        AfxFormatString2( jobName, IDS_JOB_NAME_PREFIX, jobTypeString, volumeString );

    } WsbCatch (hr);

    WsbTraceOut( L"RsCreateJobName", L"hr = <%ls>, jobName = <%ls>", WsbHrAsString( hr ), (LPCWSTR)jobName );
    return( hr );
}



HRESULT
RsGetJobTypeString(
    IN  HSM_JOB_DEF_TYPE jobType,
    OUT CString&         szJobType
    )
{
    WsbTraceIn( L"RsGetJobTypeString", L"jobType = <%d>", jobType );

    HRESULT hr = S_OK;
    try {
        switch( jobType ) {
        case HSM_JOB_DEF_TYPE_MANAGE:
            szJobType.LoadString( IDS_JOB_MANAGE );
            break;
        case HSM_JOB_DEF_TYPE_RECALL:
            szJobType.LoadString( IDS_JOB_RECALL );
            break;
        case HSM_JOB_DEF_TYPE_TRUNCATE:
            szJobType.LoadString( IDS_JOB_TRUNCATE );
            break;
        case HSM_JOB_DEF_TYPE_UNMANAGE:
            szJobType.LoadString( IDS_JOB_UNMANAGE );
            break;
        case HSM_JOB_DEF_TYPE_FULL_UNMANAGE:
            szJobType.LoadString( IDS_JOB_FULL_UNMANAGE );
            break;
        case HSM_JOB_DEF_TYPE_QUICK_UNMANAGE:
            szJobType.LoadString( IDS_JOB_QUICK_UNMANAGE );
            break;
        case HSM_JOB_DEF_TYPE_VALIDATE:
            szJobType.LoadString( IDS_JOB_VALIDATE );
            break;
        default:
            WsbAssert( FALSE, E_INVALIDARG );
        }
    } WsbCatch ( hr );

    WsbTraceOut( L"RsGetJobTypeString", L"hr = <%ls>, szJobType = <%ls>", WsbHrAsString( hr ), (LPCWSTR)szJobType );
    return( hr );
}



HRESULT
RsCreateAndRunMediaCopyJob(
    IN  IHsmServer * pHsmServer,
    IN  UINT         SetNum,
    IN  BOOL         ShowMsg
    )
///////////////////////////////////////////////////////////////////////
//
//      RsCreateAndRunMediaCopyJob
//
// Creates and runs a task to synchronize (update) a specified copy set.
// Since the Media Copy Job is run via a single Engine method (there is no 
// partitioning of the task across major components) and no scanning of 
// files/resources/etc is required to run it, this method does not create 
// a job in the Engine.  It only creates a task in the NT Task Scheduler and 
// runs it now via a call to the Engine's CreateTask() method.  The Task 
// Scheduler task is Disabled, so it will not be run according to a schedule.
//
//
{
    WsbTraceIn( L"RsCreateAndRunMediaCopyJob", L"SetNum = <%u>", SetNum );

    HRESULT hr = S_OK;

    try {

        WsbAssertPointer( pHsmServer );
        
        // Create the task name to put in the scheduler

        CString jobName, message;
        jobName.Format( IDS_JOB_MEDIA_COPY_TITLE, SetNum ); 
        CWsbStringPtr computerName;
        WsbAffirmHr( pHsmServer->GetName( &computerName ) );
        AfxFormatString2( message, IDS_RUN_JOB, jobName, computerName );
        if( !ShowMsg || ( AfxMessageBox( message, MB_ICONINFORMATION | 
                                            MB_OKCANCEL ) == IDOK ) ) {
            // Set up to call the Engine to create an entry in NT Task Scheduler

            // Create the parameter string to the program NT Scheduler 
            // will run (for Sakkara this is RsLaunch)
            CString szParameters;
            szParameters.Format( L"sync %d", SetNum );

            // Create the comment string for the NT Scheduler entry
            CString commentString;
            commentString.Format( IDS_MEDIA_COPY_JOB_COMMENT, SetNum );

            // Declare and initialize the schedule components passed to 
            // the engine.  Since this task is Disabled these are simply
            // set to 0 (COM requires populating all arguments).
            TASK_TRIGGER_TYPE   jobTriggerType = TASK_TIME_TRIGGER_ONCE;
            WORD                jobStartHour   = 0;
            WORD                jobStartMinute = 0;

            // Indicate this is a Disabled task
            BOOL                scheduledJob   = FALSE;

            // Create and run the task
            WsbAffirmHr( pHsmServer->CreateTask( jobName, szParameters,
                                                  commentString, jobTriggerType,
                                                  jobStartHour, jobStartMinute,
                                                  scheduledJob ) );
        }
    } WsbCatch (hr);

    WsbTraceOut( L"RsCreateAndRunMediaCopyJob", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}



HRESULT
RsCreateAndRunMediaRecreateJob(
    IN  IHsmServer * pHsmServer,
    IN  IMediaInfo * pMediaInfo,
    IN  REFGUID      MediaId,
    IN  CString &    MediaDescription,
    IN  SHORT        CopyToUse
    )
///////////////////////////////////////////////////////////////////////
//
//      RsCreateAndRunMediaRecreateJob
//
// Creates and runs a task to recreate the master of a piece of media.
// Since the Re-create Master Job is run via a single Engine method (there 
// is no partitioning of the task across major components) and no scanning 
// of files/resources/etc is required to run it, this method does not create 
// a job in the Engine.  It only creates a task in the NT Task Scheduler and 
// runs it now via a call to the Engine's CreateTask() method.  The Task 
// Scheduler task is Disabled, so it will not be run according to a schedule.
//
//
{
    WsbTraceIn( 
        L"RsCreateAndRunMediaRecreateJob", L"MediaId = <%ls>, Media Description = <%ls>, CopyToUse = <%hd>", 
                    WsbGuidAsString( MediaId ), (LPCWSTR)MediaDescription, CopyToUse );

    HRESULT hr = S_OK;

    try {

        WsbAssertPointer( pHsmServer );
        WsbAssertPointer( pMediaInfo );
        
        // Create the task name to put in the scheduler
        CString jobName, message;
        AfxFormatString1( jobName, IDS_JOB_MEDIA_RECREATE_TITLE, MediaDescription ); 
        CWsbStringPtr computerName;
        WsbAffirmHr( pHsmServer->GetName( &computerName ) );
        AfxFormatString2( message, IDS_RUN_JOB, jobName, computerName );

        if( IDOK == AfxMessageBox( message, MB_ICONINFORMATION | MB_OKCANCEL | MB_DEFBUTTON2 ) ) {

            // Set up to call the Engine to create an entry in NT Task Scheduler

            // Create the parameter string to the program NT Scheduler 
            // will run (for Sakkara this is RsLaunch).  First convert
            // the input MediaId GUID to a string since it is used in 
            // the job parameter string.
            CWsbStringPtr stringId( MediaId );
            CString szParameters;
            szParameters.Format( L"recreate -i %ls -c %hd", (WCHAR*)stringId, CopyToUse );

            // Create the comment string for the NT Scheduler entry
            CString commentString;
            commentString.LoadString( IDS_MEDIA_RECREATE_JOB_COMMENT );

            // Declare and initialize the schedule components passed to 
            // the engine.  Since this task is Disabled these are simply
            // set to 0 (COM requires populating all arguments).
            TASK_TRIGGER_TYPE   jobTriggerType = TASK_TIME_TRIGGER_ONCE;
            WORD                jobStartHour   = 0;
            WORD                jobStartMinute = 0;

            // Indicate this is a Disabled task
            BOOL                scheduledJob   = FALSE;

            // The Re-create Master job requires the Recreate state of the master 
            // media that will be re-created to have been set.  Do so here since
            // the user has already confirmed they want to run this job.  (The 
            // UI already has the Engine's Segment database open.)
            WsbAffirmHr( pMediaInfo->SetRecreate( TRUE ) );
            WsbAffirmHr( pMediaInfo->Write() );

            // Create and run the task
            WsbAffirmHr( pHsmServer->CreateTask( jobName, szParameters,
                                                  commentString, jobTriggerType,
                                                  jobStartHour, jobStartMinute,
                                                  scheduledJob ) );
        }

    } WsbCatch (hr);

    WsbTraceOut( L"RsCreateAndRunMediaRecreateJob", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}



HRESULT
RsGetStoragePoolId(
    IN  IHsmServer *pHsmServer,
    OUT GUID *pStoragePoolId
    )
{
    WsbTraceIn( L"RsGetStoragePoolId", L"pHsmServer = <0x%p>, pStoragePoolId = <0x%p>", pHsmServer, pStoragePoolId );

    HRESULT hr = S_OK;
    try {

        CComPtr <IHsmStoragePool>       pStoragePool;

        WsbAffirmHr( RsGetStoragePool( pHsmServer, &pStoragePool ) );

        //
        // Get the GUID of the storage pool
        //
        WsbAffirmHr( pStoragePool->GetId( pStoragePoolId ) );

    } WsbCatch( hr );

    WsbTraceOut( L"RsGetStoragePoolId", L"hr = <%ls>, *pStoragePoolId = <%ls>", WsbHrAsString( hr ), WsbPtrToGuidAsString( pStoragePoolId ) );
    return( hr );
}


HRESULT
RsGetStoragePool(
    IN  IHsmServer       *pHsmServer,
    OUT IHsmStoragePool **ppStoragePool
    )
{
    WsbTraceIn( L"RsGetStoragePool", L"pHsmServer = <0x%p>, ppStoragePool = <0x%p>", pHsmServer, ppStoragePool );

    ULONG count;
    HRESULT hr = S_OK;
    try {

        CComPtr <IWsbIndexedCollection> pCollection;

        //
        // Get the storage pools collection.  There should only be one member.
        //
        WsbAffirmHr( pHsmServer->GetStoragePools( &pCollection ) );
        WsbAffirmHr( pCollection->GetEntries( &count ) );
        WsbAffirm( 1 == count, E_FAIL );

        WsbAffirmHr( pCollection->At( 0, IID_IHsmStoragePool, (void **) ppStoragePool ) );

    } WsbCatch( hr );

    WsbTraceOut( L"RsGetStoragePool", L"hr = <%ls>, *pStoragePoolId = <%ls>", WsbHrAsString( hr ), WsbPtrToPtrAsString( (void**)ppStoragePool ) );
    return( hr );
}

HRESULT
RsGetInitialLVColumnProps(
    int IdWidths, 
    int IdTitles, 
    CString **pColumnWidths, 
    CString **pColumnTitles,
    int *pColumnCount
)
{
    HRESULT hr = S_OK;
    CString szResource;
    OLECHAR* szData;
    int colCount = 0;
    int colWidths = 0;
    int colTitles = 0;
    int i = 0;

    try {
        if ( !pColumnWidths ) {

            // Caller asked us to return number of columns
            colCount = 0;
            szResource.LoadString (IdTitles);
            szData = szResource.GetBuffer( 0 );
            szData = wcstok( szData, L":" );
            while( szData ) {
                colCount++;
                szData = wcstok( NULL, L":" );
            }
        } else {

            // Properites Widths
            colWidths = 0;
            szResource.LoadString (IdWidths);
            szData = szResource.GetBuffer( 0 );
            szData = wcstok( szData, L":" );
            while( szData ) {
                pColumnWidths[colWidths++] = new CString( szData );
                szData = wcstok( NULL, L":" );
            }

            // Properites Titles
            colTitles = 0;
            szResource.LoadString (IdTitles);
            szData = szResource.GetBuffer( 0 );
            szData = wcstok( szData, L":" );
            while( szData ) {
                pColumnTitles[colTitles++] = new CString( szData );
                szData = wcstok( NULL, L":" );
            }
            WsbAffirm( ( colTitles == colWidths ), E_FAIL );
            colCount = colTitles;
        }
        *pColumnCount = colCount;
    } WsbCatch (hr);
    return hr;
}


HRESULT
RsServerSaveAll(
    IN IUnknown * pUnkServer
    )
{
    WsbTraceIn( L"RsServerSaveAll", L"" );

    HRESULT hr = S_OK;

    try {

        CComPtr<IWsbServer> pServer;
        WsbAffirmHr( RsQueryInterface( pUnkServer, IWsbServer, pServer ) );
        WsbAffirmHr( pServer->SaveAll( ) );

    } WsbCatch( hr )

    WsbTraceOut( L"RsServerSaveAll", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
RsGetVolumeDisplayName(
    IFsaResource * pResource,
    CString &      DisplayName
    )
{
    WsbTraceIn( L"RsGetVolumeDisplayName", L"" );
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    try {

        WsbAffirmPointer( pResource );
        CWsbStringPtr label;
        CWsbStringPtr userName;
        WsbAffirmHr( pResource->GetName( &label, 0 ) );
        WsbAffirmHr( pResource->GetUserFriendlyName( &userName, 0 ) );

        // The user name is a drive letter.
        if( userName.IsEqual( L"" ) ) {

            if( label.IsEqual( L"" ) ) {

                if (S_OK == pResource->IsAvailable()) {

                    DisplayName.LoadString( IDS_UNLABELED_VOLUME );

                } else {

                    CString str1, str2;
                    str1.LoadString( IDS_UNLABELED_VOLUME );
                    str2.LoadString( IDS_VOL_NOT_AVAILABLE );
                    DisplayName.Format( L"%ls (%ls)", str1.GetBuffer(0), str2.GetBuffer(0) );
        
                }

            } else {

                // If it's not a drive letter we use the label.
                if (S_OK == pResource->IsAvailable()) {

                    DisplayName.Format( L"%ls", (WCHAR*)label );

                } else {

                    CString str2;
                    str2.LoadString( IDS_VOL_NOT_AVAILABLE );
                    DisplayName.Format( L"%ls (%ls)", (WCHAR*)label, str2.GetBuffer(0) );

                }

            }

        } else {

            userName[(int)(wcslen(userName)-1)] = 0;
            // The user name is a drive letter or a mount point path with a trailing backslash
            // If the label is "", it's ignored in the formatting.
            DisplayName.Format( L"%ls (%ls)", (WCHAR*)label, (WCHAR*)userName );

        }

    } WsbCatch( hr )

    WsbTraceOut( L"RsGetVolumeDisplayName", L"hr = <%ls>, DisplayName = <%ls>", WsbHrAsString( hr ), (LPCWSTR)DisplayName );
    return( hr );
}

// Temporary version that for unlabeled volumes w/ drive-letter puts in the 
// size and free space
HRESULT
RsGetVolumeDisplayName2(
    IFsaResource * pResource,
    CString &      DisplayName
    )
{
    WsbTraceIn( L"RsGetVolumeDisplayName2", L"" );
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    try {

        WsbAffirmPointer( pResource );
        CWsbStringPtr label;
        CWsbStringPtr userName;
        WsbAffirmHr( pResource->GetName( &label, 0 ) );
        WsbAffirmHr( pResource->GetUserFriendlyName( &userName, 0 ) );

        // The user name is a drive letter.
        if( userName.IsEqual ( L"" ) ) {

            if( label.IsEqual ( L"" ) ) {

                LONGLONG    totalSpace  = 0;
                LONGLONG    freeSpace   = 0;
                LONGLONG    premigrated = 0;
                LONGLONG    truncated   = 0;
                WsbAffirmHr( pResource->GetSizes( &totalSpace, &freeSpace, &premigrated, &truncated ) );
                CString totalString, freeString;
                RsGuiFormatLongLong4Char( totalSpace, totalString );
                RsGuiFormatLongLong4Char( freeSpace, freeString );
                AfxFormatString2( DisplayName, IDS_UNLABELED_VOLUME2, totalString, freeString );

            } else {

                // If it's not a drive letter we use the label.
                DisplayName.Format( L"%ls", (WCHAR*)label );

            }

        } else {
            userName[(int)(wcslen(userName)-1)] = 0;
            // The user name is a drive letter or a mount point path with a trailing backslash
            // If the label is "", it's ignored in the formatting.
            DisplayName.Format( L"%ls (%ls)", (WCHAR*)label, (WCHAR*)userName );

        }

    } WsbCatch( hr )

    WsbTraceOut( L"RsGetVolumeDisplayName2", L"hr = <%ls>, DisplayName = <%ls>", WsbHrAsString( hr ), (LPCWSTR)DisplayName );
    return( hr );
}

HRESULT
RsGetVolumeSortKey(
    IFsaResource * pResource,
    CString &      DisplayName
    )
{
    WsbTraceIn( L"RsGetVolumeSortKey", L"" );
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    try {

        WsbAffirmPointer( pResource );
        CWsbStringPtr label;
        CWsbStringPtr userName;
        WsbAffirmHr( pResource->GetName( &label, 0 ) );
        WsbAffirmHr( pResource->GetUserFriendlyName( &userName, 0 ) );

        DisplayName.Format( L"%ls %ls", (WCHAR*)userName, (WCHAR*)label );

    } WsbCatch( hr )

    WsbTraceOut( L"RsGetVolumeSortKey", L"hr = <%ls>, DisplayName = <%ls>", WsbHrAsString( hr ), (LPCWSTR)DisplayName );
    return( hr );
}

HRESULT
RsIsVolumeAvailable(
    IFsaResource * pResource
    )
{
    WsbTraceIn( L"RsIsVolumeAvailable", L"" );

    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( pResource );

        hr = pResource->IsAvailable();

    } WsbCatch( hr )

    WsbTraceOut( L"RsIsVolumeAvailable", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT
RsIsWhiteOnBlack(
    )
{
    WsbTraceIn( L"RsIsWhiteOnBlack", L"" );

    HRESULT hr = S_FALSE;

#define RS_CONTRAST_LIMIT 173
    //
    // Look to see if button background is within RS_CONTRAST_LIMIT
    // units of black.
    // Note that full white has a distance of 256 * sqrt(3) = 443
    // Use Euclidean distance but compare before taking root
    //
    DWORD face3d = ::GetSysColor( COLOR_3DFACE );
    DWORD blackDelta = GetRValue( face3d ) * GetRValue( face3d ) +
                       GetGValue( face3d ) * GetGValue( face3d ) +
                       GetBValue( face3d ) * GetBValue( face3d );

    if( blackDelta < RS_CONTRAST_LIMIT * RS_CONTRAST_LIMIT ) {

        hr = S_OK;

    }

    WsbTraceOut( L"RsIsWhiteOnBlack", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
RsIsRmsErrorNotReady(
    HRESULT HrError
    )
{
    WsbTraceIn( L"RsIsRmsErrorNotReady", L"" );

    HRESULT hr = S_FALSE;

    try {

            switch( HrError ) {

            case RMS_E_NOT_READY_SERVER_STARTING:
            case RMS_E_NOT_READY_SERVER_STARTED:
            case RMS_E_NOT_READY_SERVER_INITIALIZING:
            case RMS_E_NOT_READY_SERVER_STOPPING:
            case RMS_E_NOT_READY_SERVER_STOPPED:
            case RMS_E_NOT_READY_SERVER_DISABLED:
            case RMS_E_NOT_READY_SERVER_LOCKED:

                hr = S_OK;
    
            }

    } WsbCatch( hr );

    WsbTraceOut( L"RsIsRmsErrorNotReady", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\rsadutil.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsAdUtil.h

Abstract:

    Utility functions for GUI - for us in HSMADMIN files only

Author:

    Art Bragg [abragg]   04-Mar-1997

Revision History:

--*/

// Defined constants for media copy states
#define RS_MEDIA_COPY_STATUS_NONE           ((USHORT)5000)
#define RS_MEDIA_COPY_STATUS_ERROR          ((USHORT)5001)
#define RS_MEDIA_COPY_STATUS_OUTSYNC        ((USHORT)5002)
#define RS_MEDIA_COPY_STATUS_INSYNC         ((USHORT)5003)
#define RS_MEDIA_COPY_STATUS_MISSING        ((USHORT)5004)

// Defined constants for master media states
#define RS_MEDIA_STATUS_RECREATE            ((USHORT)5101)
#define RS_MEDIA_STATUS_READONLY            ((USHORT)5102)
#define RS_MEDIA_STATUS_NORMAL              ((USHORT)5103)
#define RS_MEDIA_STATUS_ERROR_RO            ((USHORT)5104)
#define RS_MEDIA_STATUS_ERROR_RW            ((USHORT)5105)
#define RS_MEDIA_STATUS_ERROR_MISSING       ((USHORT)5106)
#define RS_MEDIA_STATUS_ERROR_INCOMPLETE    ((USHORT)5107)

void
RsReportError( HRESULT hrToReport, int textId, ... );

HRESULT RsGetStatusString (
    DWORD    serviceStatus,
    HRESULT  hrSetup,
    CString& sStatus
    );

WCHAR *
RsNotifyEventAsString (
    IN  MMC_NOTIFY_TYPE event
    );

WCHAR *
RsClipFormatAsString (
    IN  CLIPFORMAT cf
    );

HRESULT
RsIsRemoteStorageSetup(
    void
    );

HRESULT
RsIsRemoteStorageSetupEx(
    IHsmServer * pHsmServer
    );

HRESULT
RsIsSupportedMediaAvailable(
    void
    );

HRESULT
RsIsRmsErrorNotReady(
    HRESULT HrError
    );

USHORT
RsGetCopyStatus(
    IN  REFGUID   CopyId,
    IN  HRESULT   CopyHr,
    IN  SHORT     CopyNextDataSet,
    IN  SHORT     LastGoodNextDataSet
    );

HRESULT
RsGetCopyStatusStringVerb(
    IN  USHORT      copyStatus,
    OUT CString&    String
    );

HRESULT
RsGetCopyStatusString(
    IN  USHORT      copyStatus,
    OUT CString&    String
    );

USHORT
RsGetCartStatus(
    IN  HRESULT   LastHr,
    IN  BOOL      ReadOnly,
    IN  BOOL      Recreate,
    IN  SHORT     NextDataSet,
    IN  SHORT     LastGoodNextDataSet
    );

HRESULT
RsGetCartStatusString(
    IN  USHORT      cartStatus,
    OUT CString&    String
    );

HRESULT
RsGetCartStatusStringVerb(
    IN  USHORT      cartStatus,
    IN  BOOL        plural,
    OUT CString&    String
    );

HRESULT
RsGetCartMultiStatusString( 
    IN USHORT statusRecreate, 
    IN USHORT statusReadOnly, 
    IN USHORT statusNormal, 
    IN USHORT statusRO, 
    IN USHORT statusRW, 
    IN USHORT statusMissing,
    OUT CString &outString 
    );

HRESULT
RsGetCopyMultiStatusString( 
    IN USHORT statusNone, 
    IN USHORT statusError, 
    IN USHORT statusOutSync, 
    IN USHORT statusInSync,
    OUT CString &outString
    );

HRESULT
RsCreateAndRunFsaJob(
    IN  HSM_JOB_DEF_TYPE jobType,
    IN  IHsmServer   *pHsmServer,
    IN  IFsaResource *pFsaResource,
    IN  BOOL ShowMsg = TRUE
    );

HRESULT
RsCreateAndRunDirectFsaJob(
    IN  HSM_JOB_DEF_TYPE jobType,
    IN  IHsmServer   *pHsmServer,
    IN  IFsaResource *pFsaResource,
    IN  BOOL waitJob
    );

HRESULT
RsCancelDirectFsaJob(
    IN  HSM_JOB_DEF_TYPE jobType,
    IN  IHsmServer   *pHsmServer,
    IN  IFsaResource *pFsaResource
    );

HRESULT
RsCreateJobName(
    IN  HSM_JOB_DEF_TYPE jobType, 
    IN  IFsaResource *   pResource,
    OUT CString&         szJobName
    );

HRESULT
RsGetJobTypeString(
    IN  HSM_JOB_DEF_TYPE jobType,
    OUT CString&         szJobType
    );

HRESULT
RsCreateAndRunMediaCopyJob(
    IN  IHsmServer * pHsmServer,
    IN  UINT SetNum,
    IN  BOOL ShowMsg
    );

HRESULT
RsCreateAndRunMediaRecreateJob(
    IN  IHsmServer * pHsmServer,
    IN  IMediaInfo * pMediaInfo,
    IN  REFGUID      MediaId,
    IN  CString &    MediaDescription,
    IN  SHORT        CopyToUse
    );

HRESULT
RsGetStoragePoolId(
    IN  IHsmServer *pHsmServer,
    OUT GUID *      pStoragePoolId
    );

HRESULT
RsGetStoragePool(
    IN  IHsmServer *       pHsmServer,
    OUT IHsmStoragePool ** ppStoragePool
    );

HRESULT
RsGetInitialLVColumnProps(
    int IdWidths, 
    int IdTitles, 
    CString **pColumnWidths, 
    CString **pColumnTitles,
    int *pColumnCount
    );

HRESULT
RsServerSaveAll(
    IUnknown * pUnkServer
    );

HRESULT
RsGetVolumeDisplayName(
    IFsaResource * pResource,
    CString &      DisplayName
    );

HRESULT
RsGetVolumeDisplayName2(
    IFsaResource * pResource,
    CString &      DisplayName
    );

HRESULT
RsGetVolumeSortKey(
    IFsaResource * pResource,
    CString &      DisplayName
    );

HRESULT
RsIsVolumeAvailable(
    IFsaResource * pResource
    );

HRESULT
RsIsWhiteOnBlack(
    );

class CCopySetInfo {

public:
    SHORT    m_NextDataSet;
    FILETIME m_ModifyTime;
    HRESULT  m_Hr;
    GUID     m_RmsId;
    BOOL     m_Disabled;
};

class CResourceInfo {
public:
    CResourceInfo( IFsaResource* pResource ) {
        m_pResource = pResource;
        m_HrConstruct = RsGetVolumeDisplayName( m_pResource, m_DisplayName );
        if( SUCCEEDED( m_HrConstruct ) ) {
            m_HrConstruct = RsGetVolumeSortKey( m_pResource, m_SortKey );
        }
    };
    static INT CALLBACK Compare( LPARAM lParam1, LPARAM lParam2, LPARAM /* lParamSort */ ) {
        CResourceInfo* pResInfo1 = (CResourceInfo*)lParam1;
        CResourceInfo* pResInfo2 = (CResourceInfo*)lParam2;
        if( ! pResInfo1 ) return( -1 );
        if( ! pResInfo2 ) return(  1 );
        return( pResInfo1->m_SortKey.CompareNoCase( pResInfo2->m_SortKey ) );
    }

    CString                 m_DisplayName;
    CString                 m_SortKey;
    CComPtr<IFsaResource>   m_pResource;
    HRESULT                 m_HrConstruct;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\sakmenu.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    SakMenu.cpp

Abstract:

    Implements all the context menu interface to the individual nodes,
    including getting menu resources and turning into MMC menus, and
    forwarding on command messages.

Author:

    Rohde Wakefield   [rohde]   09-Dec-1996

Revision History:

--*/


#include "stdafx.h"
#include "CSakData.h"
#include "CSakSnap.h"


//
// Mask for a long value out of a short value's range
//

#define SHORT_VALUE_RANGE (MAXULONG ^ ((unsigned short)MAXSHORT))




static HRESULT
AddMmcMenuItems (
    IN CMenu *                pMenu,
    IN LONG                   lInsertionPointID,
    IN ISakNode *             pNode,
    IN IContextMenuCallback * pContextMenuCallback
    )

/*++

Routine Description:

    Called for any node clicked on with right mouse. Goes to the
    node object to construct the MMC menu.

Arguments:

    pDataObject - identifies the node to be worked on.

    pContextMenuCallback - The MMC menu interface to use.

Return Value:

    S_OK - All added fine - continue.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"AddMmcMenuItems", L"lInsertionPointID = <0x%p>, pNode = <0x%p>", lInsertionPointID, pNode );

    HRESULT hr = S_OK;

    try {

        //
        // It is ok to pass a NULL pMenu - means do not add
        // any entries
        //

        if ( 0 != pMenu ) {

            CString menuText;
            CString statusText;
            
            BSTR    bstr;
            
            CONTEXTMENUITEM menuItem;
            memset ( (void*)&menuItem, 0, sizeof ( menuItem ) );
            menuItem.lInsertionPointID = lInsertionPointID;

            UINT menuCount = pMenu->GetMenuItemCount ( );

            for ( UINT index = 0; index < menuCount; index++ ) {

                //
                // For each menu item, fill out MMC's CONTEXTMENUITEM struct
                // appropriately and call AddItem
                //

                menuItem.lCommandID = pMenu->GetMenuItemID ( index );

                pMenu->GetMenuString ( index, menuText, MF_BYPOSITION );
                menuItem.strName = (LPTSTR)(LPCTSTR)menuText;

                WsbAffirmHr ( pNode->GetMenuHelp ( menuItem.lCommandID, &bstr ) );
                if ( 0 != bstr ) {

                    statusText = bstr;
                    SysFreeString ( bstr );
                    menuItem.strStatusBarText = (LPTSTR)(LPCTSTR)statusText;

                } else {

                    menuItem.strStatusBarText = 0;

                }

                menuItem.fFlags        = pMenu->GetMenuState ( index, MF_BYPOSITION );
                menuItem.fSpecialFlags = 0;

                //
                // Since AppStudio does not make available the MFS_DEFUALT flag,
                // we will use the MF_HELP flag for default entry.
                //

                if ( 0 != ( menuItem.fFlags & MF_HELP ) ) {

                    menuItem.fFlags        &= ~MF_HELP;
                    menuItem.fSpecialFlags |= CCM_SPECIAL_DEFAULT_ITEM;

                }

                pContextMenuCallback->AddItem ( &menuItem );

            }

        }
        
    } WsbCatch ( hr );

    WsbTraceOut( L"AddMmcMenuItems", L"hr = <%ls>", WsbHrAsString( hr ) );
    return ( hr );
}


STDMETHODIMP
CSakData::AddMenuItems (
    IN  LPDATAOBJECT          pDataObject, 
    IN  LPCONTEXTMENUCALLBACK pContextMenuCallback,
    OUT LONG*                 pInsertionAllowed
    )

/*++

Routine Description:

    Called for any node clicked on with right mouse. Goes to the
    node object to construct the MMC menu.

Arguments:

    pDataObject - identifies the node to be worked on.

    pContextMenuCallback - The MMC menu interface to use.

Return Value:

    S_OK - All added fine - continue.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakData::AddMenuItems", L"pDataObject = <0x%p>", pDataObject );

    HRESULT hr = S_OK;
    BOOL bMultiSelect;

    try {

        //
        // Note - snap-ins need to look at the data object and determine
        // in what context, menu items need to be added.

        // We should be expecting either single data object or Multi-Select
        // data object.  Not Object Types data object.
        //

        CComPtr<ISakNode>  pNode;
        CComPtr<IEnumGUID> pEnumObjectId;
        WsbAffirmHr( GetBaseHsmFromDataObject( pDataObject, &pNode, &pEnumObjectId ) );
        bMultiSelect = pEnumObjectId ? TRUE : FALSE;

        CMenu menu;
        HMENU hMenu;
        WsbAffirmHr( pNode->GetContextMenu ( bMultiSelect, &hMenu ) );

        menu.Attach( hMenu );

        //
        // Any menu returned by GetContextMenu should have three
        // top-level popups for the following portions of the 
        // MMC context menu:
        //
        // 1. Root (Above all other items)
        // 2. Create New
        // 3. Task
        //
        // If any of these should not have any items added for them,
        // the top-level item should not be a pop (sans MF_POPUP)
        //

        if( *pInsertionAllowed & CCM_INSERTIONALLOWED_TOP ) {

            WsbAffirmHr ( AddMmcMenuItems ( menu.GetSubMenu ( MENU_INDEX_ROOT ), 
                CCM_INSERTIONPOINTID_PRIMARY_TOP, pNode, pContextMenuCallback ) );

        }

        if( *pInsertionAllowed & CCM_INSERTIONALLOWED_NEW ) {

            WsbAffirmHr ( AddMmcMenuItems ( menu.GetSubMenu ( MENU_INDEX_NEW ), 
                CCM_INSERTIONPOINTID_PRIMARY_NEW, pNode, pContextMenuCallback ) );

        }

        if( *pInsertionAllowed & CCM_INSERTIONALLOWED_TASK ) {

            WsbAffirmHr ( AddMmcMenuItems ( menu.GetSubMenu ( MENU_INDEX_TASK ), 
                CCM_INSERTIONPOINTID_PRIMARY_TASK, pNode, pContextMenuCallback ) );

        }
        
    } WsbCatch ( hr );

    WsbTraceOut( L"CSakData::AddMenuItems", L"hr = <%ls>", WsbHrAsString( hr ) );
    return ( hr );
}



STDMETHODIMP
CSakData::Command (
    IN  long         nCommandID,
    IN  LPDATAOBJECT pDataObject
    )

/*++

Routine Description:

    Called for any node receiving a menu command. Goes to the
    node object to handle the command, and allows general
    (not node-specific) commands to be handled centrally.

Arguments:

    nCommandID - ID of command.

    pDataObject - Data object representing the node.

Return Value:

    S_OK - Handled.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakData::Command", L"nCommandID = <%ld>, pDataObject = <0x%p>", nCommandID, pDataObject );

    HRESULT hr = S_OK;

    try {

        HRESULT resultCommand = S_FALSE;

        //
        // All node commands are SHORT values. Check range first.
        //

        if ( 0 == ( nCommandID & SHORT_VALUE_RANGE ) ) {

            //
            // We start by getting the corresponding ISakNode interface 
            // to the node
            //
            
            CComPtr<ISakNode>  pNode;
            CComPtr<IEnumGUID> pEnumObjectId;
            WsbAffirmHr( GetBaseHsmFromDataObject ( pDataObject, &pNode, &pEnumObjectId ) );
            
            //
            // Then see if it wants to handle the command
            //
            
            WsbAffirmHr( ( resultCommand = pNode->InvokeCommand ( (SHORT)nCommandID, pDataObject ) ) );

        }

    } WsbCatch ( hr )

    WsbTraceOut( L"CSakData::Command", L"hr = <%ls>", WsbHrAsString( hr ) );
    return ( hr );
}


STDMETHODIMP
CSakSnap::AddMenuItems (
    IN  LPDATAOBJECT          pDataObject, 
    IN  LPCONTEXTMENUCALLBACK pContextMenuCallback,
    OUT LONG*                 pInsertionAllowed
    )
/*++

Routine Description:

    Called for any node clicked on with right mouse in result pane.
    Delegates to CSakData.

Arguments:

    pDataObject - identifies the node to be worked on.

    pContextMenuCallback - The MMC menu interface to use.

Return Value:

    S_OK - All added fine - continue.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakSnap::AddMenuItems", L"pDataObject = <0x%p>", pDataObject );
    HRESULT hr = S_OK;
    try {

        WsbAffirmHr( m_pSakData->AddMenuItems( pDataObject, pContextMenuCallback, pInsertionAllowed ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::AddMenuItems", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP
CSakSnap::Command (
    IN  long         nCommandID,
    IN  LPDATAOBJECT pDataObject
    )

/*++

Routine Description:

    Called for any node receiving a menu command.
    Delegated to CSakData.

Arguments:

    nCommandID - ID of command.

    pDataObject - Data object representing the node.

Return Value:

    S_OK - Handled.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"CSakSnap::Command", L"nCommandID = <%ld>, pDataObject = <0x%p>", nCommandID, pDataObject );
    HRESULT hr;
    try {

        hr = m_pSakData->Command( nCommandID, pDataObject );

    } WsbCatch( hr );

    WsbTraceOut( L"CSakSnap::Command", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\sakvlls.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    SAKVlLs.h

Abstract:

    Managed Volume wizard.

Author:

    Micheal Moore [mmoore]   30-Sep-1998

Revision History:

--*/

#ifndef _SAKVLLS_H
#define _SAKVLLS_H

class CSakVolList : public CListCtrl {
// Construction/Destruction
public:
    CSakVolList();
    virtual ~CSakVolList();

// Attributes
protected:
    int m_nVolumeIcon;
    CImageList m_imageList;

// Operations
public:    
    //
    // SetExtendedStyle, GetCheck, and SetCheck are temporary methods.
    // When the version of MFC we are building against is updated
    // they can be deleted.
    //
    DWORD SetExtendedStyle( DWORD dwNewStyle );
    BOOL GetCheck ( int nItem ) const;
    BOOL SetCheck( int nItem, BOOL fCheck = TRUE );

    //
    // Inserts an Item for the name at this->GetItemCount and
    // calls SetItem for the capacity and free space.  The int * pIndex
    // parameter is optional and will return the index of the newly appended
    // item to the list.  The return value suggests the Append was 
    // successful or not.
    //
    BOOL AppendItem( LPCTSTR name, LPCTSTR capacity, LPCTSTR freeSpace, int * pIndex = NULL );

// Implementation
protected:    
    BOOL CreateImageList();
    //{{AFX_MSG(CSakVolList)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSakVolList)
    virtual void PreSubclassWindow();
    //}}AFX_VIRTUAL

    DECLARE_MESSAGE_MAP()
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\saknodei.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    SakNodeI.h

Abstract:

    Template class for holding the icons for each node type derived
    from it.

Author:

    Art Bragg 9/26/97

Revision History:

--*/
#ifndef _CSAKNODI_H
#define _CSAKNODI_H


template <class T>
class CSakNodeImpl : public CSakNode {


protected:
    static int m_nScopeOpenIcon;    
    static int m_nScopeCloseIcon;  
    static int m_nScopeOpenIconX;   
    static int m_nScopeCloseIconX;  
    static int m_nResultIcon;  
    static int m_nResultIconX;  
    
public:
//---------------------------------------------------------------------------
//
//         get/SetScopeOpenIconIndex
//
//  Get/Put the virtual index of the Open Icon.
//

STDMETHODIMP GetScopeOpenIcon(BOOL bOK, int* pIconIndex)
{
    // return FALSE if the index has never been set
    if (bOK)
    {
        *pIconIndex = m_nScopeOpenIcon;
        return ((m_nScopeOpenIcon == UNINITIALIZED) ? S_FALSE : S_OK);
    } else {
        *pIconIndex = m_nScopeOpenIconX;
        return ((m_nScopeOpenIconX == UNINITIALIZED) ? S_FALSE : S_OK);
    }
}


//---------------------------------------------------------------------------
//
//         get/SetScopeCloseIconIndex
//
//  Get/Put the virtual index of the Close Icon.
//

STDMETHODIMP GetScopeCloseIcon(BOOL bOK, int* pIconIndex)
{
    // return FALSE if the index has never been set
    if (bOK) {
        *pIconIndex = m_nScopeCloseIcon;
        return ((m_nScopeCloseIcon == UNINITIALIZED) ? S_FALSE : S_OK);
    } else {
        *pIconIndex = m_nScopeCloseIconX;
        return ((m_nScopeCloseIconX == UNINITIALIZED) ? S_FALSE : S_OK);
    }
}


//---------------------------------------------------------------------------
//
//         get/SetResultIconIndex
//
//  Get/Put the virtual index of the Close Icon.
//

STDMETHODIMP GetResultIcon(BOOL bOK, int* pIconIndex)
{
    // return FALSE if the index has never been set
    if (bOK) {
        *pIconIndex = m_nResultIcon;
        return ((m_nResultIcon == UNINITIALIZED) ? S_FALSE : S_OK);
    } else {
        *pIconIndex = m_nResultIconX;
        return ((m_nResultIconX == UNINITIALIZED) ? S_FALSE : S_OK);
    }

}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\schdtask.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    SchdTask.h

Abstract:

    CSchdTask - Class that allows access to a scheduled task.

Author:

    Art Bragg   9/4/97

Revision History:

--*/

#ifndef _SCHDTASK_H
#define _SCHDTASK_H

#include "mstask.h"

class CSchdTask
{

// Construction/Destruction
public:

CSchdTask 
    (
    CString szComputerName, 
    const TCHAR* task,
    int          propPageTitleID,
    const TCHAR* parameters,
    const TCHAR* comment,
    CEdit*       pEdit
    );
~CSchdTask ();

// Public Functions

HRESULT CheckTaskExists (
    BOOL bCreateTask
    );

HRESULT CreateTask();

HRESULT DeleteTask();

HRESULT ShowPropertySheet();

HRESULT UpdateDescription();

HRESULT Save();

// Properties
private:
CString                     m_szParameters;
CString                     m_szComment;
CString                     m_szComputerName;       // Name of HSM computer
CComPtr <ITask>             m_pTask;                // Pointer to ITask - NULL task doesn't exist
CEdit                       *m_pEdit;               // Pointer to Edit Control
CString                     m_szJobTitle;           // Job Title
CComPtr <ISchedulingAgent>  m_pSchedAgent;          // Pointer to Scheduling Agent
CComPtr<ITaskTrigger>       m_pTrigger;             // Pointer to task trigger
int m_propPageTitleID;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\schdtask.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    SchdTask.cpp

Abstract:

    CSchdTask - Class that allows access to a scheduled task. 
        Check the task
        Create the task
        Delete the task
        Save the task
        Show property page
        Show task description in text box

Author:

    Art Bragg   9/4/97

Revision History:

--*/

#include "stdafx.h"
#include "SchdTask.h"
#include "SchedSht.h"


/////////////////////////////////////////////////////////////////////////////
// CSchdTask
//
// Description: Save arguments to data members.  Create the Scheduling Agent
//              object.
//
// Arguments:
//  szComputerName  - Name of HSM computer owning task scheduler
//  taskID          - Resource ID for task name
//  propPageTitleID - Resource ID for property page title
//  pEdit           - Edit control to show description in
//
// Returns:
//  S_OK, S_XXXX
//
///////////////////////////////////////////////////////////////////////////////////
//
CSchdTask::CSchdTask 
    (
    CString szComputerName, 
    const TCHAR* task,
    int          propPageTitleID,
    const TCHAR* parameters,
    const TCHAR* comment,
    CEdit*       pEdit
    )
{
    HRESULT hr = S_OK;
    try {
        WsbTraceIn( L"CSchdTask::CSchdTask", L"ComputerName = <%ls> task = <%ls> propPageTitleID = <%d> pEdit = <%ld>",
            szComputerName, task, propPageTitleID, pEdit  );

        m_pTask = NULL;

        m_szComputerName = szComputerName;

        // Save the property page title resource ID
        m_propPageTitleID = propPageTitleID;

        // Save the pointer to the control in which to display the schedule text
        m_pEdit = pEdit;

        WsbAffirmHr( m_pSchedAgent.CoCreateInstance( CLSID_CSchedulingAgent ) );

        // Get the hsm computer and prepend "\\"
        CString szHsmName ("\\\\" + szComputerName);

        // Tell the task manager which computer to look on
        m_pSchedAgent->SetTargetComputer (szHsmName);

        m_szJobTitle = task;
        m_szParameters = parameters;
        m_szComment = comment;

    } WsbCatch (hr);

    WsbTraceOut( L"CSchdTask::CSchdTask", L"hr = <%ls>", WsbHrAsString( hr ) );
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Function: CheckTaskExists
//
// Description:  Tries to access the task owned by the object.  If the task does not
//               exist, returns S_FALSE and if caller requested puts up an error and
//               creates the task.
//
//  Arguments:   bCreateTask - true = put up an error and create task if it doesn't exist
//
//  Returns:    S_OK - Task exists
//              S_FALSE - Task did not exist (may have been created)
//              S_XXXX - Error
//
/////////////////////////////////////////////////////////////////////////////////////////////

HRESULT
CSchdTask::CheckTaskExists(
    BOOL bCreateTask
    )
{
    WsbTraceIn( L"CSchdTask::CheckTaskExists", L"bCreateTask = <%ld>", bCreateTask );

    HRESULT hr = S_OK;

    try {

        //
        // Get the task we're interested in
        //
        CComPtr <IUnknown> pIU;
        if( m_pSchedAgent->Activate( m_szJobTitle, IID_ITask, &pIU ) == S_OK ) {

            //
            // QI to the task interface and save it
            //
            m_pTask.Release( );
            WsbAffirmHr( pIU->QueryInterface( IID_ITask, (void **) &m_pTask ) );

        } else {

            //
            // The task doesn't exist - create it if the caller wanted
            // us to.
            //
            if( bCreateTask ) {

                CString sMessage;
                AfxFormatString2( sMessage, IDS_ERR_MANAGE_TASK, m_szJobTitle, m_szComputerName );
                AfxMessageBox( sMessage, RS_MB_ERROR );
                
                //
                // Create the task
                //
                WsbAffirmHr( CreateTask( ) );
                WsbAffirmHr( Save( ) );

            }
            
            //
            // Return false (the task does or did not exist)
            //
            hr = S_FALSE;

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CSchdTask::CheckTaskExists", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Function: CreateTask
//
// Description: Creates the data-member task in the task scheduler.
//
// Arguments: None
//
// Returns: S_OK, S_XXXX
//
/////////////////////////////////////////////////////////////////////////////////////////////

HRESULT
CSchdTask::CreateTask()
{
    WsbTraceIn( L"CSchdTask::CreateTask", L"");
    HRESULT hr = S_OK;
    try {

        //
        // Need to connect to the HSM engine and let it create it
        // so that it runs under the LocalSystem account
        //
        CComPtr<IHsmServer> pServer;
        WsbAffirmHr( HsmConnectFromName( HSMCONN_TYPE_HSM, m_szComputerName, IID_IHsmServer, (void**)&pServer ) );

        WsbAffirmHr( pServer->CreateTask( m_szJobTitle, m_szParameters, m_szComment, TASK_TIME_TRIGGER_DAILY, 2, 0, TRUE ) );

        //
        // And Configure it
        //
        m_pTask.Release( );
        WsbAffirmHr( m_pSchedAgent->Activate( m_szJobTitle, IID_ITask, (IUnknown**)&m_pTask ) );

    } WsbCatch (hr);

    WsbTraceOut( L"CSchdTask::CreateTask", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

////////////////////////////////////////////////////////////////////////////////////////////
//
// Function: DeleteTask
//
// Description: Deletes the data-member task from the task scheduler
//
// Arguments: None
//
// Returns: S_OK, S_XXX
//
////////////////////////////////////////////////////////////////////////////////////////////

HRESULT
CSchdTask::DeleteTask()
{
    WsbTraceIn( L"CSchdTask::CreateTask", L"");
    HRESULT hr = S_OK;
    try {
        WsbAffirmPointer (m_pSchedAgent);
        WsbAffirmHr (m_pSchedAgent->Delete( m_szJobTitle ));
    } WsbCatch (hr);
    WsbTraceOut( L"CSchdTask::DeleteTask", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Function: ShowPropertySheet
//
// Description: Shows a property sheet for the data-member task.
//
// Arguments: None
//
// Returns: S_OK, S_XXX
//
//////////////////////////////////////////////////////////////////////////////////////////////

HRESULT
CSchdTask::ShowPropertySheet()
{
    WsbTraceIn( L"CSchdTask::ShowPropertySheet", L"");

    CScheduleSheet scheduleSheet(m_propPageTitleID , m_pTask, 0, 0 );

    scheduleSheet.DoModal( );
    WsbTraceOut( L"CSchdTask::ShowPropertySheet", L"hr = <%ls>", WsbHrAsString( S_OK ) );
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Function: UpdateDescription
//
// Description: Displays the data-member task's summary in the data-member text box.
//
// Arguments: None
//
// Returns: S_OK, S_XXX
//
//////////////////////////////////////////////////////////////////////////////////////////////

HRESULT
CSchdTask::UpdateDescription
(
    void
    )
{
    WsbTraceIn( L"CSchdTask::UpdateDescription", L"" );

    HRESULT hr = S_OK;

    try {

        //
        // And set schedule text into the text box.
        //
        
        CString buildString;
        WORD triggerCount, triggerIndex;

        WsbAffirmHr( m_pTask->GetTriggerCount( &triggerCount ) );
        
        CWsbStringPtr scheduleString;
        
        for( triggerIndex = 0; triggerIndex < triggerCount; triggerIndex++ ) {
        
            WsbAffirmHr( m_pTask->GetTriggerString( triggerIndex, &scheduleString ) );
            buildString += scheduleString;
            buildString += L"\r\n";

            scheduleString.Free( );
        
        }
        
        m_pEdit->SetWindowText( buildString );
        
        //
        // Now check to see if we should add a scroll bar
        //
        
        //
        // It seems the only way to know that an edit control needs a scrollbar
        // is to force it to scroll to the bottom and see if the first
        // visible line is the first actual line
        //
        
        m_pEdit->LineScroll( MAXSHORT );
        if( m_pEdit->GetFirstVisibleLine( ) > 0 ) {
        
            //
            // Add the scroll styles
            //
        
            m_pEdit->ModifyStyle( 0, WS_VSCROLL | ES_AUTOVSCROLL, SWP_DRAWFRAME );
        
        
        } else {
        
            //
            // Remove the scrollbar (set range to 0)
            //
        
            m_pEdit->SetScrollRange( SB_VERT, 0, 0, TRUE );
        
        }
        
        //
        // Remove selection
        //
        
        m_pEdit->PostMessage( EM_SETSEL, -1, 0 );

    } WsbCatch( hr );

    WsbTraceOut( L"CSchdTask::UpdateDescription", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Function: Save
//
// Description: Saves the data member task to the task scheduler
//
// Arguments: None
//
// Returns: S_OK, S_XXX
//
//////////////////////////////////////////////////////////////////////////////////////////////

HRESULT
CSchdTask::Save (void)
{
    WsbTraceIn( L"CSchdTask::Save", L"" );
    HRESULT hr = S_OK;

    try {

        CComPtr<IPersistFile> pPersist;
        WsbAffirmHr( m_pTask->QueryInterface( IID_IPersistFile, (void**)&pPersist ) );
        WsbAffirmHr( pPersist->Save( 0, 0 ) );

    } WsbCatch (hr);

    WsbTraceOut( L"CSchdTask::Save", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\schedsht.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    SchedSht.cpp

Abstract:

    CScheduleSheet - Class that allows a schedule to be edited
                     in a property sheet of its own.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include "SchedSht.h"


/////////////////////////////////////////////////////////////////////////////
// CScheduleSheet

CScheduleSheet::CScheduleSheet(UINT nIDCaption, ITask * pTask, CWnd* pParentWnd, DWORD /*dwFlags*/)
    :CPropertySheet(nIDCaption, pParentWnd, 0)
{
    HRESULT hr = S_OK;

    try {

        //
        // Save the scheduled task pointer
        //

        WsbAffirmPointer( pTask );
        m_pTask = pTask;

        //
        // Get the property page structures
        //

        CComPtr<IProvideTaskPage> pProvideTaskPage;
        WsbAffirmHr( pTask->QueryInterface( IID_IProvideTaskPage, (void**)&pProvideTaskPage ) );
        WsbAffirmHr( pProvideTaskPage->GetPage( TASKPAGE_SCHEDULE, FALSE, &m_hSchedulePage ) );
//      WsbAffirmHr( pProvideTaskPage->GetPage( TASKPAGE_SETTINGS, FALSE, &m_hSettingsPage ) );

    } WsbCatch( hr );

}

CScheduleSheet::~CScheduleSheet()
{
    //
    // Set the pointer to the PROPSHEETHEADER array to
    // null since MFC will try to free it when we are
    // destroyed.
    //

    m_psh.ppsp = 0;
}


BEGIN_MESSAGE_MAP(CScheduleSheet, CPropertySheet)
    //{{AFX_MSG_MAP(CScheduleSheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


void 
CScheduleSheet::BuildPropPageArray
(
    void
    )
{
    CPropertySheet::BuildPropPageArray( );

    //
    // We put in a dummy set of pages to keep MFC happy.
    // Here we will substitute our own array of HPROPSHEETPAGE's
    // instead, since this is all Task Scheduler gives us.
    //

    m_psh.dwFlags &= ~PSH_PROPSHEETPAGE;
    m_psh.dwFlags |= PSH_NOAPPLYNOW;
    m_psh.phpage = &m_hSchedulePage;
    m_psh.nPages = 1;
}

BOOL CScheduleSheet::OnInitDialog() 
{
    BOOL bResult = CPropertySheet::OnInitDialog();
    
    LONG style = ::GetWindowLong( m_hWnd, GWL_EXSTYLE );
    style |= WS_EX_CONTEXTHELP;
    ::SetWindowLong( m_hWnd, GWL_EXSTYLE, style );
    
    return bResult;
}

#ifdef _DEBUG
void CScheduleSheet::AssertValid() const
{
    //
    // Need to override so that CPropSheet is happy
    // Note that this code duplicates what is in 
    // CPropertySheet::AssertValid except the assertion
    // the dwFlags has the PSH_PROPSHEETPAGE bit set
    // We assert that it is not set
    //
    CWnd::AssertValid();
    m_pages.AssertValid();
    ASSERT(m_psh.dwSize == sizeof(PROPSHEETHEADER));
    //ASSERT((m_psh.dwFlags & PSH_PROPSHEETPAGE) == PSH_PROPSHEETPAGE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\schedsht.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    SchedSht.h

Abstract:

    CScheduleSheet - Class that allows a schedule to be edited
                     in a property sheet of its own.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/


#ifndef _SCHEDSHT_H
#define _SCHEDSHT_H

#include <mstask.h>

/////////////////////////////////////////////////////////////////////////////
// CScheduleSheet

class CScheduleSheet : public CPropertySheet
{

// Construction
public:
    CScheduleSheet(UINT nIDCaption, ITask * pTask, CWnd* pParentWnd = NULL, DWORD dwFlags = 0 );

// Attributes
public:
    CComPtr<ITask> m_pTask;
    HPROPSHEETPAGE m_hSchedulePage;
    HPROPSHEETPAGE m_hSettingsPage;

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CScheduleSheet)
    public:
    virtual BOOL OnInitDialog();
    //}}AFX_VIRTUAL

    virtual void BuildPropPageArray();

// Implementation
public:
    virtual ~CScheduleSheet();
#ifdef _DEBUG
    virtual void AssertValid() const;
#endif

    // Generated message map functions
protected:
    //{{AFX_MSG(CScheduleSheet)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\sakvlls.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    SakVlLs.cpp

Abstract:

    Managed Volume node implementation.

Author:

    Michael Moore [mmoore]   30-Sep-1998

Revision History:

--*/

#include "stdafx.h"
#include "SakVlLs.h"

CSakVolList::CSakVolList() 
    : CListCtrl(),
      m_nVolumeIcon(-1)
{
}

CSakVolList::~CSakVolList()
{
}

//-----------------------------------------------------------------------------
//
//                      PreSubclassWindow
//
//  Create the image list for the list control.  Set the desired 
//  extended styles.  Finally, Initilize the list header.
//
//
void
CSakVolList::PreSubclassWindow()
{
    CreateImageList( );

    // 
    // The style we want to see it Checkboxes and full row select
    //
    SetExtendedStyle( LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT );

    //
    // Create the columns for the list box
    //
    CString temp;       
    INT index;
    LV_COLUMN col;
    INT column = 0;

    //
    // Also need to calculate some buffer space
    // Use 4 dialog units (for numeral)
    //
    CRect padRect( 0, 0, 8, 8 );
    ::MapDialogRect( GetParent()->m_hWnd, &padRect );

    //
    // Name Column
    //
    temp.LoadString(IDS_NAME);
    col.mask =  ( LVCF_FMT | LVCF_WIDTH | LVCF_TEXT );
    col.fmt = LVCFMT_LEFT;
    col.cx = GetStringWidth( temp ) + padRect.Width( ) * 10;
    col.pszText = (LPTSTR)(LPCTSTR)temp;
    index = InsertColumn( column, &col );
    column++;

    //
    // Capacity Column
    //
    temp.LoadString( IDS_CAPACITY );
    col.cx = GetStringWidth( temp ) + padRect.Width( );
    col.pszText = (LPTSTR)(LPCTSTR)temp;    
    InsertColumn( column, &col );
    column++;

    //
    // Free Space Column
    //
    temp.LoadString( IDS_FREESPACE );
    col.cx = GetStringWidth( temp ) + padRect.Width( );
    col.pszText = (LPTSTR)(LPCTSTR)temp;
    InsertColumn( column, &col );
    column++;

    CListCtrl::PreSubclassWindow();    
}

//-----------------------------------------------------------------------------
//
//                      CreateImageList
//
//  Load an image list with a single icon to represent a volume
//  and set the image list to be the newly created list.
//
//
BOOL CSakVolList::CreateImageList ( )
{
    BOOL bRet = TRUE;
    HICON hIcon;

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    CWinApp* pApp = AfxGetApp( );

    bRet = m_imageList.Create( ::GetSystemMetrics( SM_CXSMICON ),
                            ::GetSystemMetrics( SM_CYSMICON ),
                            ILC_COLOR | ILC_MASK, 2,5 );

    if ( bRet ) 
    {
        hIcon = pApp->LoadIcon( IDI_NODEMANVOL );
        if ( hIcon != NULL ) 
        {
            m_nVolumeIcon = m_imageList.Add( hIcon );
            ::DeleteObject( hIcon );
            SetImageList( &m_imageList, LVSIL_SMALL );
        }
        else
        {
            bRet = FALSE;
        }
    }

    return( bRet ); 
}

//-----------------------------------------------------------------------------
//
//                      SetExtendedStyle
//
//  The alternatives that are #if'd out are to call CListCtrl::SetExtendedStyle
//  or the ComCtrl.h declared ListView_SetExtendedListViewStyle.  We will
//  eventually get rid of this function when the mfc headers and libs are
//  updated from then NT group. 
//  
//
DWORD 
CSakVolList::SetExtendedStyle( DWORD dwNewStyle )
{
#if 0 // (_WIN32_IE >= 0x0400)
    return CListCtrl::SetExtendeStyle( dwNewStyle );
#elif 0 //(_WIN32_IE >= 0x0300)
    return ListView_SetExtendedListViewStyle( m_hWnd, dwNewStyle );
#else
    ASSERT(::IsWindow(m_hWnd)); 
    return (DWORD) ::SendMessage(m_hWnd, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, (LPARAM) dwNewStyle); 
#endif
}

//-----------------------------------------------------------------------------
//
//                      GetCheck
//
//  The alternatives that are #if'd out are to call CListCtrl::GetCheck
//  or the ComCtrl.h declared ListView_GetCheckState.  We will
//  eventually get rid of this function when the mfc headers and libs are
//  updated from then NT group. 
//
//  Note: I could not get the ListView_Get... to compile under our current
//  environment.
//  
//
BOOL
CSakVolList::GetCheck ( int nItem ) const
{
#if 0 //(_WIN32_IE >= 0x0400)
    return CListCtrl::GetCheck( nItem );
#elif 0 //(_WIN32_IE >= 0x0300)
    return ListView_GetCheckState( m_hWnd, nItem );
#else
    ASSERT(::IsWindow(m_hWnd));
    int nState = (int)::SendMessage(m_hWnd, LVM_GETITEMSTATE, (WPARAM)nItem,
          (LPARAM)LVIS_STATEIMAGEMASK);
    // Return zero if it's not checked, or nonzero otherwise.
    return ((BOOL)(nState >> 12) -1);
#endif
}

//-----------------------------------------------------------------------------
//
//                      SetCheck
//
//  The alternatives that are #if'd out are to call CListCtrl::SetCheck
//  or the ComCtrl.h declared ListView_SetCheckState.  We will
//  eventually get rid of this function when the mfc headers and libs are
//  updated from then NT group. 
//
//  Note: I could not get the ListView_Set... to compile under our current
//  environment.
//  
//
BOOL
CSakVolList::SetCheck( int nItem, BOOL fCheck )
{
#if 0 //(_WIN32_IE >= 0x0400)
    return CListCtrl::SetCheck( nItem, fCheck );
#elif 0 //(_WIN32_IE >= 0x0300)
    return ListView_SetCheckState( m_hWnd, nItem, fCheck );
#else
    ASSERT(::IsWindow(m_hWnd));
    LVITEM lvi;
    lvi.stateMask = LVIS_STATEIMAGEMASK;

    /*
    Since state images are one-based, 1 in this macro turns the check off, and
    2 turns it on.
    */
    lvi.state = INDEXTOSTATEIMAGEMASK((fCheck ? 2 : 1));
    return (BOOL) ::SendMessage(m_hWnd, LVM_SETITEMSTATE, nItem, (LPARAM)&lvi);
#endif
}

//-----------------------------------------------------------------------------
//
//                      AppendItem
//
//  Insert an item into the list with the Volume Icon with name, capacity
//  and free space.  Return TRUE if successful and set pIndex = to the 
//  index of the inserted list item.  
//  
//
BOOL
CSakVolList::AppendItem( LPCTSTR name, LPCTSTR capacity, LPCTSTR freeSpace , int * pIndex)
{
    BOOL bRet = FALSE;
    int subItem = 1;
    int index = InsertItem( GetItemCount(), name, m_nVolumeIcon );                   
    if ( index != -1 )
    {
        LVITEM capItem;
        capItem.mask = LVIF_TEXT;
        capItem.pszText = (LPTSTR)capacity;
        capItem.iItem = index;
        capItem.iSubItem = subItem;
        subItem++;

        LVITEM freeItem;
        freeItem.mask = LVIF_TEXT;
        freeItem.pszText = (LPTSTR)freeSpace;
        freeItem.iItem = index;
        freeItem.iSubItem = subItem;
        subItem++;

        bRet = ( SetItem( &capItem ) && SetItem ( &freeItem) );
    }     

    if ( pIndex != NULL ) 
        *pIndex = index;

    return bRet;
}

BEGIN_MESSAGE_MAP(CSakVolList, CListCtrl)
    //{{AFX_MSG_MAP(CSakVolList)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=gui
MINORCOMP=HsmMMC

INCLUDES=$(SDK_INC_PATH);$(BASEP_HSM_DIR)\inc;$(BASEP_HSM_DIR)\inc\$(O);..;..\$(O);..\computer;..\device;..\job;..\volume;..\..\inc;$(ADMIN_INC_PATH)

C_DEFINES=$(C_DEFINES) -D_MERGE_PROXYSTUB

UMTYPE=windows

USE_NATIVE_EH=1

USE_MFCUNICODE=1
MFC_USRDLL=1
MFC_VER=42
USE_ATL=1

MSC_WARNING_LEVEL=/W3 /WX

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_OBJ=precomp.obj
PRECOMPILED_PCH=precomp.pch
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\computer\hsmcom.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    HsmCom.h

Abstract:

    Root node of snapin - represents the Computer.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#ifndef _HSMCOM_H
#define _HSMCOM_H

#include "prhsmcom.h"
#include "SakNodeI.h"

class ATL_NO_VTABLE CUiHsmCom : 
    public CSakNodeImpl<CUiHsmCom>,
    public CComCoClass<CUiHsmCom,&CLSID_CUiHsmCom>
{

public:
// constructor/destructor
    CUiHsmCom(void) {};
BEGIN_COM_MAP(CUiHsmCom)
    COM_INTERFACE_ENTRY2(IDispatch, ISakNodeProp)
    COM_INTERFACE_ENTRY(ISakNode)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(ISakNodeProp)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CUiHsmCom)

    HRESULT FinalConstruct( void );
    void    FinalRelease( void );

public: 

    // ISakNode methods
    STDMETHOD( InvokeCommand )        ( SHORT sCmd, IDataObject *pDataObject );
    STDMETHOD( GetContextMenu )       ( BOOL bMultiSelect, HMENU *phMenu );
    STDMETHOD( CreateChildren )       ( ); 
    STDMETHOD( InitNode )             ( ISakSnapAsk* pSakSnapAsk, IUnknown* pHsmObj, ISakNode* pParent );
    STDMETHOD( AddPropertyPages)      ( RS_NOTIFY_HANDLE handle, IUnknown* pUnkPropSheetCallback, IEnumGUID* pEnumObjectId, IEnumUnknown *pEnumUnkNode );

    // data members
    // static, class-wide variables
    static INT  m_nScopeOpenIconIndex;  // virtual scope index of Open Icon
    static INT  m_nScopeCloseIconIndex; // virtual scope index of Close Icon
    static INT  m_nResultIconIndex;     // virtual scope index of Close Icon

    // data member unique to this class.
    CWsbStringPtr m_szHsmName;              // name of Hsm

    // property pages
    CPropHsmComStat* m_pPageStat;
    CPropHsmComStat* m_pPageServices;
    
    // Private helper functions
    HRESULT GetEngineStatus (HSM_SYS_STS *status);
    HRESULT SetEngineStatus (HSM_SYS_STS status);
    HRESULT CheckStatusChange (HSM_SYS_STS oldStatus, HSM_SYS_STS newStatus, BOOL *fOk);

};

class CUiHsmComSheet : public CSakPropertySheet
{
public:
    CUiHsmComSheet( ) { };

    HRESULT AddPropertyPages( );
    HRESULT InitSheet(
            RS_NOTIFY_HANDLE handle, 
            IUnknown *pUnkPropSheetCallback, 
            CSakNode *pSakNode,
            ISakSnapAsk *pSakSnapAsk,
            IEnumGUID *pEnumObjectId,
            IEnumUnknown *pEnumUnkNode);
    CString m_NodeTitle;

private:
};



#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\stdafx.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    StdAfx.cpp

Abstract:

    This module declares the global constants used within the
    snapin, as well as including standard implementations from ATL.

Author:

    John Biard [jrb]   04-Mar-1997

Revision History:

--*/

#include "stdafx.h"

#pragma warning(4:4701)
#include <atlimpl.cpp> 
#pragma warning(3:4701)

#include "RsUtil.cpp"

// Internal private clipboard format.
const wchar_t* SAKSNAP_INTERNAL        = L"SAKSNAP_INTERNAL"; 
const wchar_t* MMC_SNAPIN_MACHINE_NAME = L"MMC_SNAPIN_MACHINE_NAME"; 
const wchar_t* CF_EV_VIEWS             = L"CF_EV_VIEWS"; 

/////////////////////////////////////////////////////////////////////////////
//
//  GUIDs for all UI nodes in the system (used as type identifiers)
//
/////////////////////////////////////////////////////////////////////////////

// HsmCom UI node - 
// This is the static node known by the snapin manager. This is the only one that is 
// actually registered (see hsmadmin.rgs). 
const GUID cGuidHsmCom    = { 0x8b4bac42, 0x85ff, 0x11d0, { 0x8f, 0xca, 0x0, 0xa0, 0xc9, 0x19, 0x4, 0x47 } };

// The rest of the UI nodes -
const GUID cGuidManVol    = { 0x39982290, 0x8691, 0x11d0, { 0x8f, 0xca, 0x0, 0xa0, 0xc9, 0x19, 0x4, 0x47 } };
const GUID cGuidCar       = { 0x39982296, 0x8691, 0x11d0, { 0x8f, 0xca, 0x0, 0xa0, 0xc9, 0x19, 0x4, 0x47 } };
const GUID cGuidMedSet    = { 0x29e5be12, 0x8abd, 0x11d0, { 0x8f, 0xcd, 0x0, 0xa0, 0xc9, 0x19, 0x4, 0x47 } };
const GUID cGuidManVolLst = { 0x39982298, 0x8691, 0x11d0, { 0x8f, 0xca, 0x0, 0xa0, 0xc9, 0x19, 0x4, 0x47 } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\computer\hsmcom.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    HsmCom.cpp

Abstract:

    Root node of snapin - represents the Computer.

Author:

    Rohde Wakefield [rohde]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"

#include "HsmCom.h"
#include "WzQstart.h"
#include "PrMrLsRc.h"
#include "PrMedSet.h"
#include "PrSched.h"


int CUiHsmCom::m_nScopeCloseIcon  = AddScopeImage( IDI_BLUESAKKARA );
int CUiHsmCom::m_nScopeCloseIconX = CUiHsmCom::m_nScopeCloseIcon;
int CUiHsmCom::m_nScopeOpenIcon   = CUiHsmCom::m_nScopeCloseIcon;
int CUiHsmCom::m_nScopeOpenIconX  = CUiHsmCom::m_nScopeCloseIconX;
int CUiHsmCom::m_nResultIcon      = AddResultImage( IDI_BLUESAKKARA );
int CUiHsmCom::m_nResultIconX     = CUiHsmCom::m_nResultIcon;


/////////////////////////////////////////////////////////////////////////////
//
// CoComObjectRoot
//
/////////////////////////////////////////////////////////////////////////////


//---------------------------------------------------------------------------
//
//         FinalConstruct
//
//  Initialize this level of the object hierarchy
//

HRESULT CUiHsmCom::FinalConstruct( )
{
    WsbTraceIn( L"CUiHsmCom::FinalConstruct", L"" );

    m_rTypeGuid = &cGuidHsmCom;

    HRESULT hr = CSakNode::FinalConstruct( );

    m_bSupportsPropertiesSingle     = TRUE;
    m_bSupportsPropertiesMulti      = FALSE;
    m_bSupportsPropertiesNoEngine   = TRUE;
    m_bSupportsDeleteSingle         = FALSE;
    m_bSupportsDeleteMulti          = FALSE;
    m_bSupportsRefreshSingle        = TRUE;
    m_bSupportsRefreshMulti         = FALSE;
    m_bSupportsRefreshNoEngine      = TRUE;
    m_bIsContainer                  = TRUE;

    m_pPageStat = NULL;
    m_pPageServices = NULL;

    WsbTraceOut( L"CUiHsmCom::FinalConstruct", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


//---------------------------------------------------------------------------
//
//         FinalRelease
//
//  Clean up this level of the object hierarchy
//

void CUiHsmCom::FinalRelease( )
{
    WsbTraceIn( L"CUiHsmCom::FinalRelease", L"" );


    CSakNode::FinalRelease( );

    WsbTraceOut( L"CUiHsmCom::FinalRelease", L"" );
}


/////////////////////////////////////////////////////////////////////////////
//
// ISakNode
//
/////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------
//
//         GetContextMenu
//
//  Return an HMENU to be used for context menus on this node.
//

STDMETHODIMP 
CUiHsmCom::GetContextMenu( BOOL /*bMultiSelect*/, HMENU* phMenu )
{
    WsbTraceIn( L"CUiHsmCom::GetContextMenu", L"" );

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    CMenu* pRootMenu, *pNewMenu, *pTaskMenu;

    try {

        //
        // Get the context menu from the resource
        //
        WsbAffirmHr( LoadContextMenu( IDR_HSMCOM, phMenu ) );

        CMenu menu;
        menu.Attach( *phMenu );
        pRootMenu = menu.GetSubMenu( MENU_INDEX_ROOT );
        pNewMenu  = menu.GetSubMenu( MENU_INDEX_NEW );
        pTaskMenu = menu.GetSubMenu( MENU_INDEX_TASK );

        //
        // If we are not configured locally, allow the option to setup
        // Remote Storage Server. If we are setup, allow them to reconnect
        // if not connected.
        //
        BOOL deleteMenu = TRUE;

        if( S_FALSE == m_pSakSnapAsk->GetHsmName( 0 ) ) {

            CComPtr<IHsmServer> pServer;
            HRESULT hrConn = m_pSakSnapAsk->GetHsmServer( &pServer );

            if( RS_E_NOT_CONFIGURED == hrConn ) {

                deleteMenu = FALSE;

            }
        }

        if( deleteMenu ) {

            pRootMenu->DeleteMenu( ID_HSMCOM_ROOT_SETUPWIZARD, MF_BYCOMMAND );

        }
        if( !deleteMenu || ( S_OK != m_pSakSnapAsk->GetState( ) ) ) {

            pRootMenu->EnableMenuItem( ID_HSMCOM_ROOT_SCHEDULE, MF_GRAYED | MF_BYCOMMAND );

        }

        menu.Detach( );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiHsmCom::GetContextMenu", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


//---------------------------------------------------------------------------
//
//         InvokeCommand
//
//  User has selected a command from the menu. Process it here.
//

STDMETHODIMP 
CUiHsmCom::InvokeCommand( SHORT sCmd, IDataObject* pDataObject )
{
    WsbTraceIn( L"CUiHsmCom::InvokeCommand", L"sCmd = <%d>", sCmd );

    CString theString;
    HRESULT hr = S_OK;

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    try {

        switch( sCmd ) {

        case ID_HSMCOM_ROOT_SETUPWIZARD:
            {
                //
                // use wizard to create manage volume
                //
                CComObject<CQuickStartWizard>* pWizard = new CComObject<CQuickStartWizard>;
                WsbAffirmAlloc( pWizard );

                CComPtr<ISakWizard> pSakWizard = (ISakWizard*)pWizard;
                WsbAffirmHr( m_pSakSnapAsk->CreateWizard( pSakWizard ) );

                    //
                // RS_E_CANCELED indicates canceled, and FAILEd indicates error.
                // If so, then throw "Not set up"
                    //
                if( S_OK == pWizard->m_HrFinish ) {

                    WsbAffirmHr( RefreshScopePane( ) );

                }
            }
            break;


        case ID_HSMCOM_ROOT_SCHEDULE:

            WsbAffirmHr( m_pSakSnapAsk->ShowPropertySheet( this, pDataObject, 1 ) );
            break;

        case MMC_VERB_REFRESH:

            WsbAffirmHr( RefreshScopePane( ) );
            break;

        default:
            break;
        } 

    } WsbCatch( hr );

    WsbTraceOut( L"CUiHsmCom::InvokeCommand", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         CreateChildren
//
//  Create and initialize all the children of the Hsm Computer node.
//

STDMETHODIMP CUiHsmCom::CreateChildren( )
{
    WsbTraceIn( L"CUiHsmCom::CreateChildren", L"" );

    //
    // Initialize the children of this node (no recursion. Decendents of children
    // are NOT created here)
    //

    HRESULT hr = S_OK;

    try {

        CComPtr<IUnknown> pUnkChild;  // IUnknown pointer to new child.
        CComPtr<ISakNode> pSakNode;   // creation interface for new child node.

        //
        // Create a Managed Resource list UI node to be the parent of all managed volumes.
        //

        WsbAffirmHr( NewChild( cGuidManVolLst, &pUnkChild ) );

        //
        // Initialize the child UI COM object, putting the Hsm Managed Resource collection object inside the UI object.
        //

        WsbAffirmHr( RsQueryInterface( pUnkChild, ISakNode, pSakNode ) );
        WsbAffirmHr( pSakNode->InitNode( m_pSakSnapAsk, NULL, this ) );
        
        //
        // Add the child COM object to the parent's list of children.
        //
        WsbAffirmHr( AddChild( pSakNode ) );

        // Free up resources
        pUnkChild.Release( );
        pSakNode.Release( );


        
        ///////////////////////////////
        // CREATE MEDIA SET NODE

        //
        // Create a Remote Storage UI node to be the parent of all remote storage sub-nodes.
        //

        WsbAffirmHr( NewChild( cGuidMedSet, &pUnkChild ) );

        //
        // Initialize the child UI COM object, putting the Rms Server object inside the UI object.
        //

        WsbAffirmHr( RsQueryInterface( pUnkChild, ISakNode, pSakNode ) );
        WsbAffirmHr( pSakNode->InitNode( m_pSakSnapAsk, NULL, this ) );
        
        //
        // Add the child COM object to the parent's list of children.
        //

        WsbAffirmHr( AddChild( pSakNode ) );
    } WsbCatch( hr );

    //
    // Indicate that this node's children are valid and up-to-date (even if there ARE
    // no children - at least now we know it).
    //

    m_bChildrenAreValid = TRUE;

    //
    // indicate that this parent node needs to be re-enumerated
    //

    m_bEnumState = FALSE;

    WsbTraceOut( L"CUiHsmCom::CreateChildren", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
} 


//---------------------------------------------------------------------------
//
//         InitNode
//
//  Initialize single COM object without using the registry. Derived
//  objects frequently augment this method by implementing it themselves.
//

STDMETHODIMP
CUiHsmCom::InitNode(
    ISakSnapAsk* pSakSnapAsk,
    IUnknown*    pHsmObj,
    ISakNode*    pParent
    )
{
    WsbTraceIn( L"CUiHsmCom::InitNode", L"pSakSnapAsk = <0x%p>, pHsmObj = <0x%p>, pParent = <0x%p>", pSakSnapAsk, pHsmObj, pParent );

    HRESULT hr = S_OK;
    try {

        //
        // Note: The Hsm computer node no longer owns a server pointer
        //
        WsbAffirmHr( CSakNode::InitNode( pSakSnapAsk, NULL, pParent ));

        //
        // Set Display Type and Description. 
        //
        CString tempString;
        tempString.LoadString( IDS_HSMCOM_TYPE );
        WsbAffirmHr( put_Type( (OLECHAR *)(LPCWSTR)tempString ) );
        tempString.LoadString( IDS_HSMCOM_DESCRIPTION );
        WsbAffirmHr( put_Description( (OLECHAR *)(LPCWSTR)tempString ) );

        //
        // Set up the result view columns
        //
        WsbAffirmHr( SetChildProps( RS_STR_RESULT_PROPS_COM_IDS, IDS_RESULT_PROPS_COM_TITLES, IDS_RESULT_PROPS_COM_WIDTHS ) );

        RefreshObject();

    } WsbCatch( hr );

    WsbTraceOut( L"CUiHsmCom::InitNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP 
CUiHsmCom::AddPropertyPages( RS_NOTIFY_HANDLE handle, IUnknown* pUnkPropSheetCallback, IEnumGUID *pEnumObjectId, IEnumUnknown *pEnumUnkNode)
{
    WsbTraceIn( L"CUiHsmCom::AddPropertyPages", L"" );

    HRESULT hr = S_OK;

    try {

        //
        // Create an object to hold the pages
        //
        CUiHsmComSheet *pHsmComPropertySheet = new CUiHsmComSheet;
        WsbAffirmAlloc( pHsmComPropertySheet );

        WsbAffirmHr( pHsmComPropertySheet->InitSheet( 
            handle, 
            pUnkPropSheetCallback, 
            this,
            m_pSakSnapAsk,
            pEnumObjectId,
            pEnumUnkNode
            ) );

        //
        // Tell the object to add it's pages
        //
        WsbAffirmHr( pHsmComPropertySheet->AddPropertyPages( ) );

    } WsbCatch ( hr );

    WsbTraceOut( L"CUiHsmCom::AddPropertyPages", L"hr = <%ls>", WsbHrAsString( hr ) );
    return ( hr );
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// class CUiManVolSheet
//
HRESULT
CUiHsmComSheet::InitSheet(
            RS_NOTIFY_HANDLE handle,
            IUnknown*        pUnkPropSheetCallback,
            CSakNode*        pSakNode,
            ISakSnapAsk*     pSakSnapAsk,
            IEnumGUID*       pEnumObjectId,
            IEnumUnknown*    pEnumUnkNode
            )
{

    WsbTraceIn( L"CUiHsmComSheet::InitSheet", L"handle = <%ld>, pUnkPropSheetCallback = <0x%p>, pSakNode = <0x%p>, pSakSnapAsk = <0x%p>, pEnumObjectId = <0x%p>, ", 
        handle, pUnkPropSheetCallback, pSakNode, pSakSnapAsk, pEnumObjectId );
    HRESULT hr = S_OK;

    try {


        WsbAffirmHr( CSakPropertySheet::InitSheet( handle, pUnkPropSheetCallback, pSakNode,
                    pSakSnapAsk, pEnumObjectId, pEnumUnkNode ) );

        CWsbBstrPtr nodeName;
        WsbAffirmHr( pSakNode->get_DisplayName( &nodeName ) );
        m_NodeTitle = nodeName;

    } WsbCatch( hr );

    WsbTraceOut( L"CUiHsmComSheet::InitSheet", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT CUiHsmComSheet::AddPropertyPages ( )
{
    WsbTraceIn( L"CUiHsmComSheet::AddPropertyPages", L"" ); 
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;

    try {

        HPROPSHEETPAGE hPage = NULL; // Windows property page handle

        // --------------------- Statistics Page ----------------------------------
        // Create the Hsm Statistics property page.
        CPropHsmComStat* pPageStats = new CPropHsmComStat();
        WsbAffirmAlloc( pPageStats );

        pPageStats->m_NodeTitle = m_NodeTitle;

        AddPage( pPageStats );

        // 
        // Add the Schedule, Recall, and Media Copies pages
        // if setup has happened and the Remote Storage Service
        // is running.
        //

        if( S_OK == m_pSakNode->m_pSakSnapAsk->GetState() ) {

            //--------------------- Schedule Page --------------------------------------
            CPrSchedule* pPageSched = new CPrSchedule();
            WsbAffirmAlloc( pPageSched );

            AddPage( pPageSched );

            //--------------------- Recall Limit Page --------------------------------------
            // Create the Hsm Recall property page.
            CPrMrLsRec* pPageRecall = new CPrMrLsRec();
            WsbAffirmAlloc( pPageRecall );

            AddPage( pPageRecall );

            // --------------------- Media Copies Page ----------------------------------
            CPrMedSet *pPageMediaCopies = new CPrMedSet();
            WsbAffirmAlloc( pPageMediaCopies )

            AddPage( pPageMediaCopies );

            // Add more pages here.
            // ....

        }

    } WsbCatch( hr );

    

    WsbTraceOut( L"CUiHsmComSheet::AddPropertyPages", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\computer\prhsmcom.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    PrHsmCom.cpp

Abstract:

    Implements all the property page interface to the individual nodes,
    including creating the property page, and adding it to the property sheet.

Author:

    Rohde Wakefield [rohde]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"

#include "HsmCom.h"
#include "PrHsmCom.h"
#include "ca.h"
#include "intshcut.h"

static DWORD pHelpIds[] = 
{

    IDC_SNAPIN_TITLE,                   idh_instance,
    IDC_STATIC_STATUS,                  idh_status,
    IDC_STATIC_STATUS_LABEL,            idh_status,
    IDC_STATIC_MANAGED_VOLUMES,         idh_total_managed_volumes,
    IDC_STATIC_MANAGED_VOLUMES_LABEL,   idh_total_managed_volumes,
    IDC_STATIC_CARTS_USED,              idh_total_cartridges_used,
    IDC_STATIC_CARTS_USED_LABEL,        idh_total_cartridges_used,
    IDC_STATIC_DATA_IN_RS,              idh_total_data_remote_storage,
    IDC_STATIC_DATA_IN_RS_LABEL,        idh_total_data_remote_storage,
    IDC_STATIC_GROUP,                   idh_version,
    IDC_STATIC_BUILD_LABEL_HSM,         idh_version,
    IDC_STATIC_ENGINE_BUILD_HSM,        idh_version,

    0, 0
};


CPropHsmComStat::CPropHsmComStat() : CSakPropertyPage(CPropHsmComStat::IDD)
    
{
    //{{AFX_DATA_INIT(CPropHsmComStat)
    //}}AFX_DATA_INIT

    m_hConsoleHandle = 0;
    m_pParent        = 0;
    m_bUpdate        = FALSE;
    m_pHelpIds       = pHelpIds;
}

CPropHsmComStat::~CPropHsmComStat()
{
}

BOOL CPropHsmComStat::OnInitDialog() 
{
    WsbTraceIn( L"CPropHsmComStat::OnInitDialog", L"" );
    HRESULT hr = S_OK;
    ULONG volCount = 0; // number of managed Resources in server
    LONGLONG totalTotal = 0;
    LONGLONG totalFree = 0;         
    LONGLONG totalUsed = 0;         
    LONGLONG totalPremigrated = 0;
    LONGLONG totalTruncated = 0;
    LONGLONG remoteStorage = 0;
    LONGLONG total = 0;
    LONGLONG free = 0;
    LONGLONG premigrated = 0;
    LONGLONG truncated = 0;
    CMediaInfoObject mio;
    int             i;
    int             mediaCount = 0;
    CComPtr<IWsbIndexedCollection> pManResCollection;
    CComPtr<IHsmServer>            pHsmServer;
    CComPtr<IFsaServer>            pFsaServer;
    CComPtr<IRmsServer>            pRmsServer;
    CComPtr<IFsaResource>          pFsaRes;
    CComPtr<IUnknown>              pUnkFsaRes;  // unknown pointer to managed resource list
    CComPtr<IHsmManagedResource>   pHsmManRes;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    try {

#if DBG
        //
        // For checked builds, make visible the version info
        //
        GetDlgItem( IDC_STATIC_GROUP            )->ShowWindow( SW_SHOWNA );
        GetDlgItem( IDC_STATIC_BUILD_LABEL_HSM  )->ShowWindow( SW_SHOWNA );
        GetDlgItem( IDC_STATIC_ENGINE_BUILD_HSM )->ShowWindow( SW_SHOWNA );
#endif

        //
        // Put the title up
        //
        SetDlgItemText( IDC_SNAPIN_TITLE, m_NodeTitle );

        //
        // Show service status
        //
        GetAndShowServiceStatus();

        //
        // Contact the engine
        //
        HRESULT hrInternal = m_pParent->GetHsmServer( &pHsmServer );
        if( hrInternal == S_OK ) {

            //
            // The engine is up
            //
            WsbAffirmHr ( ( (CUiHsmComSheet *)m_pParent )->GetRmsServer( &pRmsServer ) );
            WsbAffirmHr ( ( (CUiHsmComSheet *)m_pParent )->GetFsaServer( &pFsaServer ) );

            //
            // Get the number of managed volumes
            //
            WsbAffirmHr( pHsmServer->GetManagedResources( &pManResCollection ) );
            WsbAffirmHr( pManResCollection->GetEntries( &volCount ));

            //
            // Iterate through the collection
            //
            for( i = 0; i < (int)volCount; i++ ) {

                //
                // Protect against bad volumes with try statement.
                // Otherwise we bail initializing whole dialog
                //
                HRESULT hrLocal = S_OK;
                try {

                    //
                    // Get the FsaResource
                    //
                    pHsmManRes.Release( );
                    pUnkFsaRes.Release( );
                    pFsaRes.Release( );
                    WsbAffirmHr( pManResCollection->At( i, IID_IHsmManagedResource, ( void** ) &pHsmManRes ) );
                    WsbAffirmHr( pHsmManRes->GetFsaResource( &pUnkFsaRes ) );
                    WsbAffirmHr( RsQueryInterface( pUnkFsaRes, IFsaResource, pFsaRes ) );

                    // Total up statistics
                    WsbAffirmHr( pFsaRes->GetSizes( &total, &free, &premigrated, &truncated ) );
                    totalPremigrated    += premigrated;
                    totalTruncated      += truncated;

                    remoteStorage = totalPremigrated + totalTruncated;

                } WsbCatch( hrLocal );
            }

            HRESULT hrLocal = S_OK;
            try {

                //
                // Count the number of media used
                // Initialize media object
                //
                WsbAffirmHr( mio.Initialize( GUID_NULL, pHsmServer, pRmsServer ) );

                // Did we get a node?
                if( mio.m_MediaId != GUID_NULL ) {
                    HRESULT hrEnum = S_OK;
                    while( SUCCEEDED( hrEnum ) ) {

                        if( S_OK == mio.DoesMasterExist( ) ) {

                            mediaCount++;
                        }

                        for( INT index = 0; index < mio.m_NumMediaCopies; index++ ) {

                            if( S_OK == mio.DoesCopyExist( index ) ) {

                                mediaCount++;
                            }
                        }

                        hrEnum = mio.Next();
                    }
                }

            } WsbCatch( hrLocal );


            CString sText;
            // Set number of managed volumes
            SetDlgItemInt( IDC_STATIC_MANAGED_VOLUMES, volCount, FALSE );

            // Show data in Remote Storage - text is same for singular and plural
            CString sFormattedNumber;
            RsGuiFormatLongLong4Char (remoteStorage, sFormattedNumber );
            SetDlgItemText( IDC_STATIC_DATA_IN_RS, sFormattedNumber );

            SetDlgItemInt( IDC_STATIC_CARTS_USED, mediaCount, FALSE );

            CWsbStringPtr pNtProductVersionHsm;
            ULONG buildVersionHsm;
            ULONG ntProductBuildHsm;

            //
            // Get service versions
            // Note: Fsa version is NOT in use at the moment, it may be used as an HSM 
            //  client version in a future C/S HSM
            //
            {

                CComPtr <IWsbServer> pWsbHsmServer;
                WsbAffirmHr( RsQueryInterface( pHsmServer, IWsbServer, pWsbHsmServer ) );
                WsbAffirmHr( pWsbHsmServer->GetNtProductBuild( &ntProductBuildHsm ) );
                WsbAffirmHr( pWsbHsmServer->GetNtProductVersion( &pNtProductVersionHsm, 0 ) );
                WsbAffirmHr( pWsbHsmServer->GetBuildVersion( &buildVersionHsm ) );

            }
    
            sText.Format( L"%ls.%d [%ls]", (WCHAR*)pNtProductVersionHsm, ntProductBuildHsm, RsBuildVersionAsString( buildVersionHsm ) );
            SetDlgItemText( IDC_STATIC_ENGINE_BUILD_HSM, sText );

            //
            // The engine is up.  Show the controls
            //
            GetDlgItem( IDC_STATIC_MANAGED_VOLUMES_LABEL )->ShowWindow( SW_SHOW );
            GetDlgItem( IDC_STATIC_MANAGED_VOLUMES )->ShowWindow( SW_SHOW );
            GetDlgItem( IDC_STATIC_DATA_IN_RS_LABEL )->ShowWindow( SW_SHOW );
            GetDlgItem( IDC_STATIC_DATA_IN_RS )->ShowWindow( SW_SHOW );
            GetDlgItem( IDC_STATIC_CARTS_USED_LABEL )->ShowWindow( SW_SHOW );
            GetDlgItem( IDC_STATIC_CARTS_USED )->ShowWindow( SW_SHOW );
            GetDlgItem( IDC_STATIC_GROUP )->ShowWindow( SW_SHOW );
            GetDlgItem( IDC_STATIC_BUILD_LABEL_HSM )->ShowWindow( SW_SHOW );
            GetDlgItem( IDC_STATIC_ENGINE_BUILD_HSM )->ShowWindow( SW_SHOW );

        } else {

            // The engine is down.  Hide the controls
            GetDlgItem( IDC_STATIC_MANAGED_VOLUMES_LABEL )->ShowWindow( SW_HIDE );
            GetDlgItem( IDC_STATIC_MANAGED_VOLUMES )->ShowWindow( SW_HIDE );
            GetDlgItem( IDC_STATIC_DATA_IN_RS )->ShowWindow( SW_HIDE );
            GetDlgItem( IDC_STATIC_DATA_IN_RS_LABEL )->ShowWindow( SW_HIDE );
            GetDlgItem( IDC_STATIC_CARTS_USED_LABEL )->ShowWindow( SW_HIDE );
            GetDlgItem( IDC_STATIC_CARTS_USED )->ShowWindow( SW_HIDE );
            GetDlgItem( IDC_STATIC_GROUP )->ShowWindow( SW_HIDE );
            GetDlgItem( IDC_STATIC_BUILD_LABEL_HSM )->ShowWindow( SW_HIDE );
            GetDlgItem( IDC_STATIC_ENGINE_BUILD_HSM )->ShowWindow( SW_HIDE );

        }

    } WsbCatch( hr );

    CSakPropertyPage::OnInitDialog();
 
    WsbTraceOut( L"CPropHsmComStat::OnInitDialog", L"" );
    return TRUE;
}


BOOL CPropHsmComStat::OnCommand(WPARAM wParam, LPARAM lParam) 
{
    // Page is dirty, mark it.
    // SetModified();   
    // m_bUpdate = TRUE;
    return CSakPropertyPage::OnCommand(wParam, lParam);
}

void CPropHsmComStat::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CPropHsmComStat::DoDataExchange", L"" );
    CSakPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPropHsmComStat)
    //}}AFX_DATA_MAP
    WsbTraceOut( L"CPropHsmComStat::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CPropHsmComStat, CSakPropertyPage)
    //{{AFX_MSG_MAP(CPropHsmComStat)
    ON_WM_DESTROY()
    ON_WM_DRAWITEM()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropHsmComStat message handlers

BOOL CPropHsmComStat::OnApply() 
{
    if (m_bUpdate == TRUE)
    {
        // Do the work of making the change here.

        m_bUpdate = FALSE;
    }
    
    return CSakPropertyPage::OnApply();
}



HRESULT CPropHsmComStat::GetAndShowServiceStatus()
{
    WsbTraceIn( L"CPropHsmComStat::GetAndShowServiceStatus", L"" );
    HRESULT hr = S_OK;
    try {

        //
        // Get and display service statuses
        //
        DWORD   serviceStatus;
        CString sStatus;
        
        // Engine
        HRESULT hrSetup = S_FALSE;
        WsbAffirmHr( WsbGetServiceStatus( m_pszName, APPID_RemoteStorageEngine, &serviceStatus ) );
        if( SERVICE_RUNNING == serviceStatus ) {

            CComPtr<IHsmServer> pHsmServer;
            hr = ( m_pParent->GetHsmServer( &pHsmServer ) );
            if ( hr == RS_E_NOT_CONFIGURED ) {

                hrSetup = S_FALSE;

            }
            else {

                hrSetup = S_OK;
                WsbAffirmHr( hr );

            }

        }

        RsGetStatusString( serviceStatus, hrSetup, sStatus );
        SetDlgItemText( IDC_STATIC_STATUS, sStatus );

    } WsbCatch( hr );

    WsbTraceOut( L"CPropHsmComStat::GetAndShowServiceStatus", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}



/////////////////////////////////////////////////////////////////////////////
// CRsWebLink

CRsWebLink::CRsWebLink()
{
}

CRsWebLink::~CRsWebLink()
{
}


BEGIN_MESSAGE_MAP(CRsWebLink, CStatic)
    //{{AFX_MSG_MAP(CRsWebLink)
    ON_WM_LBUTTONDOWN()
    ON_WM_CTLCOLOR_REFLECT()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRsWebLink message handlers

void CRsWebLink::PreSubclassWindow() 
{
    //
    // Need to set up font correctly
    //
    LOGFONT logfont;
    CFont*  tempFont = GetFont( );
    tempFont->GetLogFont( &logfont );

//    logfont.lfWeight    = FW_BOLD;
    logfont.lfUnderline = TRUE;

    m_Font.CreateFontIndirect( &logfont );
    
    SetFont( &m_Font );

    //
    // Resize based on font
    //
    CRect       rect;
    CWindowDC   dc( this );
    CString     title;
    GetClientRect( rect );
    GetWindowText( title );

    dc.SelectObject( m_Font );
    CSize size = dc.GetTextExtent( title );
    SetWindowPos( 0, 0, 0, size.cx, rect.bottom, SWP_NOMOVE | SWP_NOZORDER );

    //
    // And set the class cursor
    //
    HCURSOR hCur = AfxGetApp( )->LoadStandardCursor( IDC_HAND );
    SetClassLongPtr( GetSafeHwnd( ), GCLP_HCURSOR, (LONG_PTR)hCur );

    CStatic::PreSubclassWindow();
}

void CRsWebLink::OnLButtonDown(UINT nFlags, CPoint point) 
{
    WsbTraceIn( L"CRsWebLink::OnLButtonDown", L"" );

    CString caption;
    CString addr;

    GetWindowText( caption );
    addr = TEXT( "http://" );
    addr += caption;

    AfxGetApp()->BeginWaitCursor( );

    OpenURL( addr );

    AfxGetApp( )->EndWaitCursor( );

    CStatic::OnLButtonDown( nFlags, point );

    WsbTraceOut( L"CRsWebLink::OnLButtonDown", L"" );
}

HRESULT CRsWebLink::OpenURL(CString &Url)
{
    HRESULT hr = S_OK;

    try {

        CComPtr<IUniformResourceLocator> pURL;
        WsbAffirmHr( CoCreateInstance( CLSID_InternetShortcut, 0, CLSCTX_ALL, IID_IUniformResourceLocator, (void**)&pURL ) );
        WsbAffirmHr( pURL->SetURL( Url, IURL_SETURL_FL_GUESS_PROTOCOL ) );

        //
        // Open the URL by calling InvokeCommand
        //
        URLINVOKECOMMANDINFO ivci;
        ivci.dwcbSize   = sizeof( URLINVOKECOMMANDINFO );
        ivci.dwFlags    = IURL_INVOKECOMMAND_FL_ALLOW_UI;
        ivci.hwndParent = 0;
        ivci.pcszVerb   = TEXT( "open" );

        WsbAffirmHr( pURL->InvokeCommand( &ivci ) );

    } WsbCatch( hr );

    return( hr );
}

HBRUSH CRsWebLink::CtlColor(CDC* pDC, UINT /* nCtlColor */ )
{
    HBRUSH hBrush = (HBRUSH)GetStockObject( HOLLOW_BRUSH );
    pDC->SetTextColor( RGB( 0, 0, 255 ) );
    pDC->SetBkMode( TRANSPARENT ); 
    return( hBrush );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\stdafx.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    StdAfx.h

Abstract:

    Top level header file so we can take advantage of precompiled
    headers..

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#ifndef _STDAFX_H
#define _STDAFX_H

//
// These NT header files must be included before any Win32 stuff or you
// get lots of compiler errors
//
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
// Undefine ASSSERT because the MFC also defines it and we don't 
// want the warning.
#undef ASSERT
}

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#include <afxcmn.h>         // MFC support for Windows Common Controls
#include <afxtempl.h>   
#include <mmc.h>

#define WSB_TRACE_IS        WSB_TRACE_BIT_UI

#define CComPtr CComPtrAtl21

#include "wsb.h"
#include "rslimits.h"

#undef  CComPtr

//
// Temp Hack until using newer ATL
//
#undef  ATLASSERT
#define ATLASSERT _ASSERTE
template <class T>
class _NoAddRefReleaseOnCComPtr : public T
{
    private:
        virtual ULONG STDMETHODCALLTYPE AddRef()=0;
        virtual ULONG STDMETHODCALLTYPE Release()=0;
};

template <class T>
class CComPtr
{
public:
    typedef T _PtrClass;
    CComPtr()
    {
        p=NULL;
    }
    CComPtr(T* lp)
    {
        if ((p = lp) != NULL)
            p->AddRef();
    }
    CComPtr(const CComPtr<T>& lp)
    {
        if ((p = lp.p) != NULL)
            p->AddRef();
    }
    ~CComPtr()
    {
        if (p)
            p->Release();
    }
    void Release()
    {
        IUnknown* pTemp = p;
        if (pTemp)
        {
            p = NULL;
            pTemp->Release();
        }
    }
    operator T*() const
    {
        return (T*)p;
    }
    T& operator*() const
    {
        ATLASSERT(p!=NULL);
        return *p;
    }
    //The assert on operator& usually indicates a bug.  If this is really
    //what is needed, however, take the address of the p member explicitly.
    T** operator&()
    {
        ATLASSERT(p==NULL);
        return &p;
    }
    _NoAddRefReleaseOnCComPtr<T>* operator->() const
    {
        ATLASSERT(p!=NULL);
        return (_NoAddRefReleaseOnCComPtr<T>*)p;
    }
    T* operator=(T* lp)
    {
        return (T*)AtlComPtrAssign((IUnknown**)&p, lp);
    }
    T* operator=(const CComPtr<T>& lp)
    {
        return (T*)AtlComPtrAssign((IUnknown**)&p, lp.p);
    }
    bool operator!() const
    {
        return (p == NULL);
    }
    bool operator<(T* pT) const
    {
        return p < pT;
    }
    bool operator==(T* pT) const
    {
        return p == pT;
    }
    // Compare two objects for equivalence
    bool IsEqualObject(IUnknown* pOther)
    {
        if (p == NULL && pOther == NULL)
            return true; // They are both NULL objects

        if (p == NULL || pOther == NULL)
            return false; // One is NULL the other is not

        CComPtr<IUnknown> punk1;
        CComPtr<IUnknown> punk2;
        p->QueryInterface(IID_IUnknown, (void**)&punk1);
        pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
        return punk1 == punk2;
    }
    void Attach(T* p2)
    {
        if (p)
            p->Release();
        p = p2;
    }
    T* Detach()
    {
        T* pt = p;
        p = NULL;
        return pt;
    }
    HRESULT CopyTo(T** ppT)
    {
        ATLASSERT(ppT != NULL);
        if (ppT == NULL)
            return E_POINTER;
        *ppT = p;
        if (p)
            p->AddRef();
        return S_OK;
    }
    HRESULT SetSite(IUnknown* punkParent)
    {
        return AtlSetChildSite(p, punkParent);
    }
    HRESULT Advise(IUnknown* pUnk, const IID& iid, LPDWORD pdw)
    {
        return AtlAdvise(p, pUnk, iid, pdw);
    }
    HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
    {
        ATLASSERT(p == NULL);
        return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
    }
    HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
    {
        CLSID clsid;
        HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
        ATLASSERT(p == NULL);
        if (SUCCEEDED(hr))
            hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
        return hr;
    }
    template <class Q>
    HRESULT QueryInterface(Q** pp) const
    {
        ATLASSERT(pp != NULL && *pp == NULL);
        return p->QueryInterface(__uuidof(Q), (void**)pp);
    }
    T* p;
};

//
// End Temp Hack
//

#include "Engine.h"
#include "Fsa.h"
#include "Rms.h"
#include "Job.h"

#define RsQueryInterface( pUnk, interf, pNew )  (pUnk)->QueryInterface( IID_##interf, (void**) static_cast<interf **>( &pNew ) )
#define RsQueryInterface2( pUnk, interf, pNew ) (pUnk)->QueryInterface( IID_##interf, (void**) static_cast<interf **>( pNew ) )

#include "hsmadmin.h"
#include "resource.h"
#include "BaseHsm.h"
#include "RsUtil.h"
#include "RsAdUtil.h"
#include "PropPage.h"
#include "CPropSht.h"
#include "rshelpid.h"

class CHsmAdminApp : public CWinApp
{
public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
    void CHsmAdminApp::ParseCommandLine(CCommandLineInfo& rCmdInfo);
};

extern CHsmAdminApp       g_App;

#if 1

// Turn on In-Your-Trace error messages for debugging.

class CWsbThrowContext {
public:
    CWsbThrowContext( char * File, long Line, HRESULT Hr ) :
        m_File(File), m_Line(Line), m_Hr(Hr) { }
    char *  m_File;
    long    m_Line;
    HRESULT m_Hr;
};

#undef WsbThrow
#define WsbThrow(hr) throw( CWsbThrowContext( __FILE__, __LINE__, hr ) );

#undef WsbCatchAndDo
#define WsbCatchAndDo(hr, code)         \
    catch(CWsbThrowContext context) {   \
        hr = context.m_Hr;                  \
        CString msg;                    \
        msg.Format( L"Throw '%ls' on line [%ld] of %hs\n", WsbHrAsString( hr ), (long)context.m_Line, context.m_File ); \
        WsbTrace( (LPWSTR)(LPCWSTR)msg ); \
        { code }                        \
    }

#undef WsbCatch
#define WsbCatch(hr)                    \
    catch(CWsbThrowContext context) {   \
        hr = context.m_Hr;                  \
        CString msg;                    \
        msg.Format( L"Throw '%ls' on line [%ld] of %hs\n", WsbHrAsString( hr ), (long)context.m_Line, context.m_File ); \
        WsbTrace( (LPWSTR)(LPCWSTR)msg ); \
    }

#endif


// constant values used throughout
#define UNINITIALIZED (-1)
#define HSM_MAX_NAME MAX_COMPUTERNAME_LENGTH
#define ONE_MEG (1048576)

// Clipboard formats
extern const wchar_t* SAKSNAP_INTERNAL;
extern const wchar_t* MMC_SNAPIN_MACHINE_NAME;
extern const wchar_t* CF_EV_VIEWS;

#define ELT_SYSTEM            (101)
#define ELT_APPLICATION       (103)
#define VIEWINFO_FILTERED     (0x0002)
#define VIEWINFO_USER_CREATED (0x0008)
#define LOGINFO_DONT_PERSIST  (0x0800)
#define EVENTLOG_ALL_EVENTS   (EVENTLOG_ERROR_TYPE|EVENTLOG_WARNING_TYPE|EVENTLOG_INFORMATION_TYPE|EVENTLOG_AUDIT_SUCCESS|EVENTLOG_AUDIT_FAILURE)


#define HSMADMIN_CURRENT_VERSION    1 // Current version for use in IPersist

///////////////////////////////////////////////////////////////////////////
//
// Menu constants
//
//
// Menubar's submenu order for adding into MMC context menu:
//

#define MENU_INDEX_ROOT   0
#define MENU_INDEX_NEW    1
#define MENU_INDEX_TASK   2

#define MENU_HSMCOM_ROOT_PAUSE      0
#define MENU_HSMCOM_ROOT_CONTINUE   1

#define MENU_HSMCOM_TASK_PAUSE      0
#define MENU_HSMCOM_TASK_CONTINUE   1

#define EXTENSION_RS_FOLDER_PARAM -1
#define HSMADMIN_NO_HSM_NAME L"No Hsm Name"

#ifndef IDC_HAND
#define IDC_HAND            MAKEINTRESOURCE(32649)
#endif

#define RS_STR_KICKOFF_PARAMS               _T("run manage")
#define RS_STR_RESULT_PROPS_MANRESLST_IDS   _T("DisplayName:Capacity:FreeSpace:DesiredFreeSpaceP")
#define RS_STR_RESULT_PROPS_DEFAULT_IDS     _T("DisplayName:Type:Description")
#define RS_STR_RESULT_PROPS_COM_IDS         _T("DisplayName:Description")
#define RS_STR_RESULT_PROPS_MEDSET_IDS      _T("DisplayName:Description:CapacityP:FreeSpaceP:StatusP:CopySet1P:CopySet2P:CopySet3P")

///////////////////////////////////////////////////////////////////////////
//
// Common Flags
//

#define RS_MB_ERROR    (MB_OK|MB_ICONSTOP)
#define RS_WINDIR_SIZE (2*MAX_PATH)


///////////////////////////////////////////////////////////////////////////
//
// Common internal errors
//

#define RS_E_NOT_CONFIGURED HRESULT_FROM_WIN32( ERROR_BAD_CONFIGURATION )
#define RS_E_NOT_INSTALLED  HRESULT_FROM_WIN32( ERROR_PRODUCT_UNINSTALLED )
#define RS_E_DISABLED       HRESULT_FROM_WIN32( ERROR_RESOURCE_DISABLED )
#define RS_E_CANCELLED      HRESULT_FROM_WIN32( ERROR_CANCELLED )



/////////////////////////////////////////////////////////////////////////////
//
//  GUIDs for all UI nodes in the system (used as type identifiers)
//
/////////////////////////////////////////////////////////////////////////////

// HsmCom UI node - 
// This is the static node known by the snapin manager. This is the only one that is 
// actually registered (see hsmadmin.rgs). 
extern const GUID cGuidHsmCom;

// The rest of the UI nodes - 
extern const GUID cGuidManVol;
extern const GUID cGuidCar;
extern const GUID cGuidMedSet;
extern const GUID cGuidManVolLst;


#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\computer\prhsmcom.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    PrHsmCom.cpp

Abstract:

    Implements all the property page interface to the individual nodes,
    including creating the property page, and adding it to the property sheet.

Author:

    Rohde Wakefield [rohde]   08-Aug-1997

Revision History:

--*/

#ifndef _PROPHSMCOM_H
#define _PROPHSMCOM_H

/////////////////////////////////////////////////////////////////////////////
// CRsWebLink window

class CRsWebLink : public CStatic
{
// Construction
public:
    CRsWebLink();

// Attributes
public:
    CFont m_Font;

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRsWebLink)
    protected:
    virtual void PreSubclassWindow();
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CRsWebLink();

    // Generated message map functions
protected:
    //{{AFX_MSG(CRsWebLink)
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg HBRUSH CtlColor(CDC* pDC, UINT nCtlColor);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
private:
    HRESULT OpenURL( CString& Url );
};

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CPropHsmComStat dialog

class CPropHsmComStat : public CSakPropertyPage
{
// Construction
public:
    CPropHsmComStat();
    ~CPropHsmComStat();

// Dialog Data
    //{{AFX_DATA(CPropHsmComStat)
    enum { IDD = IDD_PROP_HSMCOM_STAT };
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPropHsmComStat)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CPropHsmComStat)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    CString            m_NodeTitle;

private:
    BOOL    m_bUpdate;
    CWsbStringPtr m_pszName;

    // Helper functions
    HRESULT GetAndShowServiceStatus();

};


/////////////////////////////////////////////////////////////////////////////
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\computer\wzqstart.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    WzQStart.cpp

Abstract:

    Setup Wizard implementation.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#include "stdafx.h"

#include "HsmConn.h"
#include "RpFilt.h"
#include "rsstrdef.h"

#include "WzQStart.h"
#include "SchedSht.h"

#define CHECK_SYSTEM_TIMER_ID 9284
#define CHECK_SYSTEM_TIMER_MS 1000

#define QSHEET ((CQuickStartWizard*)m_pSheet)

const HRESULT E_INVALID_DOMAINNAME = HRESULT_FROM_WIN32( ERROR_INVALID_DOMAINNAME );
const HRESULT E_ACCESS_DENIED      = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );


/////////////////////////////////////////////////////////////////////////////
// CQuickStartWizard

CQuickStartWizard::CQuickStartWizard( )
{
    WsbTraceIn( L"CQuickStartWizard::CQuickStartWizard", L"" );

    m_TitleId     = IDS_WIZ_QSTART_TITLE;
    m_HeaderId    = IDB_QSTART_HEADER;
    m_WatermarkId = IDB_QSTART_WATERMARK;

    //
    // Init So that we know what checks we have done
    //
    m_CheckSysState    = CST_NOT_STARTED;
    m_hrCheckSysResult = S_OK;

    WsbTraceOut( L"CQuickStartWizard::CQuickStartWizard", L"" );
}

CQuickStartWizard::~CQuickStartWizard( )
{
    WsbTraceIn( L"CQuickStartWizard::~CQuickStartWizard", L"" );

    WsbTraceOut( L"CQuickStartWizard::~CQuickStartWizard", L"" );
}

STDMETHODIMP
CQuickStartWizard::AddWizardPages(
    IN RS_PCREATE_HANDLE Handle,
    IN IUnknown*         pCallback,
    IN ISakSnapAsk*      pSakSnapAsk
    )
{
    WsbTraceIn( L"CQuickStartWizard::AddWizardPages", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // Initialize the Sheet
        //
        WsbAffirmHr( InitSheet( Handle, pCallback, 0, pSakSnapAsk, 0, 0 ) );

        //
        // Load pages 
        //
        WsbAffirmHr( AddPage( &m_IntroPage ) );
        WsbAffirmHr( AddPage( &m_CheckPage ) );
        WsbAffirmHr( AddPage( &m_ManageRes ) );
        WsbAffirmHr( AddPage( &m_ManageResX ) );
        WsbAffirmHr( AddPage( &m_InitialValues ) );
        WsbAffirmHr( AddPage( &m_MediaSel ) );
        WsbAffirmHr( AddPage( &m_SchedulePage ) );
        WsbAffirmHr( AddPage( &m_FinishPage ) );
        
    } WsbCatch( hr );

    WsbTraceOut( L"CQuickStartWizard::AddWizardPages", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CQuickStartWizard::InitTask( )
{
    WsbTraceIn( L"CQuickStartWizard::InitTask", L"" );

    HRESULT hr = S_OK;

    try {

        //
        // Need to connect to the scheduling agent to get a page
        // to show. Do that up front
        //
        
        WsbAffirmHr( m_pSchedAgent.CoCreateInstance( CLSID_CSchedulingAgent ) );
        
        CString jobTitle;
        jobTitle.LoadString( IDS_SCHED_TASK_TEMP_TITLE );

        //
        // If it exists already, blow it away (assume doing fresh install)
        // Ignore error in case not exist.
        //
        m_pSchedAgent->Delete( jobTitle );

        WsbAffirmHr( m_pSchedAgent->NewWorkItem( jobTitle, CLSID_CTask, IID_ITask, (IUnknown**)&m_pTask ) );

        TASK_TRIGGER taskTrigger;
        SYSTEMTIME sysTime;
        WORD triggerNumber;
        WsbAffirmHr( m_pTask->CreateTrigger( &triggerNumber, &m_pTrigger ) );
        
        memset( &taskTrigger, 0, sizeof( taskTrigger ) );
        taskTrigger.cbTriggerSize = sizeof( taskTrigger );

        GetSystemTime( &sysTime );
        taskTrigger.wBeginYear  = sysTime.wYear;
        taskTrigger.wBeginMonth = sysTime.wMonth;
        taskTrigger.wBeginDay   = sysTime.wDay;

        taskTrigger.wStartHour  = 2;
        taskTrigger.TriggerType = TASK_TIME_TRIGGER_DAILY;
        taskTrigger.Type.Daily.DaysInterval = 1;

        WsbAffirmHr( m_pTrigger->SetTrigger( &taskTrigger ) );

    } WsbCatchAndDo( hr,
    
        CString errString;
        AfxFormatString1( errString, IDS_ERR_CREATE_TASK, WsbHrAsString( hr ) );

        AfxMessageBox( errString, RS_MB_ERROR ); 
        PressButton( PSBTN_FINISH );

    );

    WsbTraceOut( L"CQuickStartWizard::InitTask", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CQuickStartWizard::OnCancel( ) 
{
    WsbTraceIn( L"CQuickStartWizard::OnCancel", L"" );

    //
    // Need to delete the task
    //

    if( m_pSchedAgent ) {

        if( m_pTrigger )  m_pTrigger.Release( );
        if( m_pTask )     m_pTask.Release( );

        CWsbStringPtr jobTitle;
        WsbAffirmHr(WsbGetResourceString(IDS_HSM_SCHED_TASK_TITLE, &jobTitle));

        m_pSchedAgent->Delete( jobTitle );

        //
        // Delete the temporary tesk
        //
        CString tempTitle;
        tempTitle.LoadString( IDS_SCHED_TASK_TEMP_TITLE );

        m_pSchedAgent->Delete( tempTitle );

    }

    WsbTraceOut( L"CQuickStartWizard::OnCancel", L"" );
    return( S_OK );
}

HRESULT 
CQuickStartWizard::OnFinish(
    )
{
    WsbTraceIn( L"CQuickStartWizard::OnFinish", L"" );
    BOOL doAll = FALSE;

    //
    // The sheet really owns the process as a whole,
    // so it will do the final assembly
    //

    HRESULT hr     = S_OK;
    HRESULT hrLoop = S_OK;
    BOOL    completedAll = FALSE;

    try {

        //
        // Show the Wait cursor so that they know we are busy
        //
        CWaitCursor wait;

        //
        // Get the HSM service interface for creating local objects
        //

        CComPtr<IWsbCreateLocalObject>  pCreateLocal;
        CComPtr<IHsmServer> pServer;
        CComPtr<IFsaServer> pFsa;
        CComPtr<IRmsServer> pRms;
        CComPtr<IWsbIndexedCollection> pResCollection;
        CComPtr<IHsmManagedResource> pHsmResource;
        CComPtr <IWsbIndexedCollection> pStoPoCollection;
        CComPtr <IHsmStoragePool> pStoragePool;

        WsbAffirmHr( GetHsmServer( pServer ) );
        WsbAffirmHr( GetFsaServer( pFsa ) );
        WsbAffirmHr( GetRmsServer( pRms ) );
        WsbAffirmHr( pServer->QueryInterface( IID_IWsbCreateLocalObject, (void **) &pCreateLocal ) );
        WsbAffirmHr( pServer->GetManagedResources( &pResCollection ) );

        WsbAffirmHr( pResCollection->RemoveAllAndRelease( ) );

        //
        // Pull out the default levels for all resources to be managed
        //

        ULONG    defaultFreeSpace = CONVERT_TO_HSMNUM( m_InitialValues.m_FreeSpaceSpinner.GetPos( ) );
        LONGLONG defaultMinSize = ( (LONGLONG)m_InitialValues.m_MinSizeSpinner.GetPos( ) ) * ((LONGLONG)1024);
        FILETIME defaultAccess = WsbLLtoFT( ( (LONGLONG)m_InitialValues.m_AccessSpinner.GetPos( ) ) * (LONGLONG)WSB_FT_TICKS_PER_DAY );
    
        // Is the "all" radio button selected?
        if( !m_ManageRes.m_RadioSelect.GetCheck() ) {

            doAll = TRUE;

        }


        //
        // Go through the listbox and pull out the checked resources.
        // Create HSM managed volumes for them
        //

        CSakVolList &listBox = m_ManageRes.m_ListBox;

        INT index;
        for( index = 0; index < listBox.GetItemCount( ); index++ ) {

            if( ( doAll ) || ( listBox.GetCheck( index ) ) ) {

                CResourceInfo* pResInfo = (CResourceInfo*)listBox.GetItemData( index );
                WsbAffirmPointer( pResInfo );

                try {

                    //
                    // Create Local to server since it will eventually own it.
                    //

                    pHsmResource.Release( );
                    WsbAffirmHr( pCreateLocal->CreateInstance( 
                        CLSID_CHsmManagedResource, 
                        IID_IHsmManagedResource, 
                        (void**)&pHsmResource ) );

                    //
                    // Initialize Fsa object to its initial values.
                    //

                    WsbAffirmHr( (pResInfo->m_pResource)->SetHsmLevel( defaultFreeSpace ) );
                    WsbAffirmHr( (pResInfo->m_pResource)->SetManageableItemLogicalSize( defaultMinSize ) );
                    WsbAffirmHr( (pResInfo->m_pResource)->SetManageableItemAccessTime( TRUE, defaultAccess ) );

                    //
                    // Associate HSM Managed Resource with the FSA resource
                    // (also adds to HSM collection)
                    //

                    WsbAffirmHr( pHsmResource->InitFromFsaResource( pResInfo->m_pResource ) );
                    WsbAffirmHr( pResCollection->Add( pHsmResource ) );

                } WsbCatch( hrLoop );

            }

        }

        //
        // And now that all configuration of services is done, 
        // save it all
        //

        WsbAffirmHr( RsServerSaveAll( pServer ) );
        WsbAffirmHr( RsServerSaveAll( pFsa ) );

        //
        // Set up the schedule. We have created a temporary object that
        // will never be saved to disk. Instead, we need the service to
        // create the task so that it has the correct account. We then
        // grab it and copy over the triggers from the temp job.
        //
        CWsbStringPtr taskTitle, commentString;
        WsbAffirmHr(WsbGetResourceString(IDS_HSM_SCHED_TASK_TITLE, &taskTitle));
        WsbAffirmHr(WsbGetResourceString(IDS_HSM_SCHED_COMMENT, &commentString));

        CComPtr<ITask> pTask;
        WsbAffirmHr( pServer->CreateTask( taskTitle, L"", commentString, TASK_TIME_TRIGGER_DAILY, 0, 0, TRUE ) );
        WsbAffirmHr( m_pSchedAgent->Activate( taskTitle, IID_ITask, (IUnknown**)&pTask ) );

        // Nuke the temporary one created for us.
        WsbAffirmHr( pTask->DeleteTrigger( 0 ) );

        CComPtr<ITaskTrigger> pTrigger1, pTrigger2;
        WORD triggerCount, triggerIndex, newTriggerIndex;
        TASK_TRIGGER taskTrigger;
        WsbAffirmHr( m_pTask->GetTriggerCount( &triggerCount ) );
        for( triggerIndex = 0; triggerIndex < triggerCount; triggerIndex++ ) {

            WsbAffirmHr( m_pTask->GetTrigger( triggerIndex, &pTrigger1 ) );
            WsbAffirmHr( pTrigger1->GetTrigger( &taskTrigger ) );

            WsbAffirmHr( pTask->CreateTrigger( &newTriggerIndex, &pTrigger2 ) );
            // Just to note - WsbAffirm( newTriggerIndex == triggerIndex, E_UNEXPECTED );
            WsbAffirmHr( pTrigger2->SetTrigger( &taskTrigger ) );

            pTrigger1.Release( );
            pTrigger2.Release( );

        }

        // Set real parameters since we have a real schedule now.
        CString parameters;
        parameters = RS_STR_KICKOFF_PARAMS;
        WsbAffirmHr( pTask->SetParameters( parameters ) );

        CComPtr<IPersistFile> pPersist;
        WsbAffirmHr( pTask->QueryInterface( IID_IPersistFile, (void**)&pPersist ) );

        WsbAffirmHr( pPersist->Save( 0, 0 ) );

        //
        // Do last since it is what we key off of for being "Set up"
        //
        // Configure the selected media set
        //
        INT curSel = m_MediaSel.m_ListMediaSel.GetCurSel ();
        WsbAffirm( (curSel != LB_ERR), E_FAIL );
        IRmsMediaSet* pMediaSet = (IRmsMediaSet *)  m_MediaSel.m_ListMediaSel.GetItemDataPtr( curSel );

        //
        // Get the storage pool.
        //
        WsbAffirmHr( RsGetStoragePool( pServer, &pStoragePool ) );

        //
        // Set the media set info in the storage pool
        //
        WsbAffirmHr( pStoragePool->InitFromRmsMediaSet( pMediaSet ) );

        //
        // Set the media set info in the storage pool
        //
        WsbAffirmHr( pStoragePool->InitFromRmsMediaSet( pMediaSet ) );
        WsbAffirmHr( RsServerSaveAll( pServer ) );

        //
        // Delete the temporary tesk
        //
        CString tempTitle;
        tempTitle.LoadString( IDS_SCHED_TASK_TEMP_TITLE );

        m_pSchedAgent->Delete( tempTitle );

        //
        // Show any error that occurred while managing volumes
        //
        completedAll = TRUE;
        WsbAffirmHr( hrLoop );

    } WsbCatchAndDo( hr,

        CString errString;
        AfxFormatString1( errString, IDS_ERROR_QSTART_ONFINISH, WsbHrAsString( hr ) );
        AfxMessageBox( errString, RS_MB_ERROR ); 

    );

    //
    // Set result so invoking code knows what our result is.
    // The constructor set this to RS_E_CANCELED, so an S_FALSE would
    // indicate a canceled wizard.
    //
    m_HrFinish = ( completedAll ) ? S_OK : hr;

    WsbTraceOut( L"CQuickStartWizard::OnFinish", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CQuickStartWizard::GetHsmServer(
    CComPtr<IHsmServer> &pServ
    )
{
    WsbTraceIn( L"CQuickStartWizard::GetHsmServer", L"" );

    HRESULT hr = S_OK;

    try {

        if( !m_pHsmServer ) {

            CWsbStringPtr computerName;
            WsbAffirmHr( WsbGetComputerName( computerName ) );

            WsbAffirmHr( HsmConnectFromName( HSMCONN_TYPE_HSM, computerName, IID_IHsmServer, (void**)&m_pHsmServer ) );

        }

        pServ = m_pHsmServer;

    } WsbCatch( hr );

    WsbTraceOut( L"CQuickStartWizard::GetHsmServer", L"hr = <%ls>, pServ = <0x%p>", WsbHrAsString( hr ), pServ.p );
    return( hr );
}

HRESULT
CQuickStartWizard::GetFsaServer(
    CComPtr<IFsaServer> &pServ
    )
{
    WsbTraceIn( L"CQuickStartWizard::GetFsaServer", L"" );

    HRESULT hr = S_OK;

    try {

        if( !m_pFsaServer ) {

            CWsbStringPtr computerName;
            WsbAffirmHr( WsbGetComputerName( computerName ) );
            WsbAffirmHr(computerName.Append("\\NTFS"));

            WsbAffirmHr( HsmConnectFromName( HSMCONN_TYPE_FSA, computerName, IID_IFsaServer, (void**)&m_pFsaServer ) );

        }

        pServ = m_pFsaServer;

    } WsbCatch( hr );

    WsbTraceOut( L"CQuickStartWizard::GetFsaServer", L"hr = <%ls>, pServ = <0x%p>", WsbHrAsString( hr ), pServ.p );
    return( hr );
}

HRESULT
CQuickStartWizard::GetRmsServer(
    CComPtr<IRmsServer> &pServ
    )
{
    WsbTraceIn( L"CQuickStartWizard::GetRmsServer", L"" );

    HRESULT hr = S_OK;

    try {

        if( !m_pRmsServer ) {

            CWsbStringPtr computerName;
            WsbAffirmHr( WsbGetComputerName( computerName ) );

            CComPtr<IHsmServer>     pHsmServer;
            WsbAffirmHr( HsmConnectFromName( HSMCONN_TYPE_HSM, computerName, IID_IHsmServer, (void**)&pHsmServer ) );
            WsbAffirmPointer(pHsmServer);
            WsbAffirmHr(pHsmServer->GetHsmMediaMgr(&m_pRmsServer));
        }

        pServ = m_pRmsServer;

    } WsbCatch( hr );

    WsbTraceOut( L"CQuickStartWizard::GetRmsServer", L"hr = <%ls>, pServ = <0x%p>", WsbHrAsString( hr ), pServ.p );
    return( hr );
}

HRESULT
CQuickStartWizard::ReleaseServers( 
    void
    )
{
    WsbTraceIn( L"CQuickStartWizard::ReleaseServers", L"" );

    HRESULT hr = S_OK;

    m_pHsmServer.Release( );
    m_pFsaServer.Release( );
    m_pRmsServer.Release( );

    WsbTraceOut( L"CQuickStartWizard::ReleaseServers", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( S_OK );
}

DWORD WINAPI
CQuickStartWizard::CheckSysThreadStart(
    LPVOID pv
    )
{
    WsbTraceIn( L"CQuickStartWizard::CheckSysThreadStart", L"" );
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;
    HRESULT hrInternal = S_OK;
    HRESULT hrCom = S_OK;

    CQuickStartWizard * pWiz = (CQuickStartWizard*)pv;

    try {
        hrCom = CoInitialize( 0 );
        WsbAffirmHr( hrCom );

        WsbAffirmPointer( pv );

        pWiz->m_hrCheckSysResult = S_OK;
        do {
        
            WsbTrace( L"Checking Account Security\n" );
            pWiz->m_CheckSysState = CST_ACCOUNT;

            //
            // Do they have admin privs?
            //

            WsbAffirmHr( hrInternal = WsbCheckAccess( WSB_ACCESS_TYPE_ADMINISTRATOR ) );
            if( hrInternal == E_ACCESSDENIED ) {

                hr = S_FALSE;
                continue;


            }

            // Is media suppported?
            WsbTrace( L"Account Security OK\n" );
        
            WsbTrace( L"Checking for Supported Media\n" );
            pWiz->m_CheckSysState = CST_SUPP_MEDIA;

            WsbAffirmHr(hrInternal = RsIsSupportedMediaAvailable( ) );
            if( hrInternal == S_FALSE ) {

                hr = S_FALSE;
                continue;

            }

            WsbTrace( L"Supported Media Found\n" );
            pWiz->m_CheckSysState    = CST_DONE;

        
        } while( 0 );
    } WsbCatch( hr );
            
    //
    // And report back what our results are
    //
    
    pWiz->m_hrCheckSysResult = hr;
    
    //
    // We'll exit and end thread, so hide the main threads handle of us.
    //
    
    pWiz->m_hCheckSysThread = 0;

    if (SUCCEEDED(hrCom)) {
        CoUninitialize( );
    }

    WsbTraceOut( L"CQuickStartWizard::CheckSysThreadStart", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


/////////////////////////////////////////////////////////////////////////////
// CQuickStartIntro property page

BEGIN_MESSAGE_MAP(CQuickStartIntro, CSakWizardPage)
    //{{AFX_MSG_MAP(CQuickStartIntro)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP( )

CQuickStartIntro::CQuickStartIntro() :
    CSakWizardPage_InitBaseExt( WIZ_QSTART_INTRO )
{
    WsbTraceIn( L"CQuickStartIntro::CQuickStartIntro", L"" );
    //{{AFX_DATA_INIT(CQuickStartIntro)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    WsbTraceOut( L"CQuickStartIntro::CQuickStartIntro", L"" );
}

HRESULT
CQuickStartIntro::IsDriverRunning()
{
    HRESULT hr = S_FALSE;

    //
    // Ensure the filter is installed and running.
    //

    SC_HANDLE hSCM    = 0;
    SC_HANDLE hDriver = 0;
    SERVICE_STATUS serviceStatus;

    try {

        hSCM = OpenSCManager( 0, 0, GENERIC_READ );
        WsbAffirmPointer( hSCM );

        hDriver = OpenService( hSCM, TEXT( RSFILTER_SERVICENAME ), SERVICE_QUERY_STATUS );
        WsbAffirmStatus( 0 != hDriver );

        WsbAffirmStatus( QueryServiceStatus( hDriver, &serviceStatus ) );

        if( SERVICE_RUNNING == serviceStatus.dwCurrentState ) {

            //
            // Things look good, set flag so Wizard will allow conitue.
            //
            hr = S_OK;

        }


    } WsbCatch( hr );

    if( hSCM )    CloseServiceHandle( hSCM );
    if( hDriver ) CloseServiceHandle( hDriver );

    return( hr );
}

HRESULT
CQuickStartIntro::CheckLastAccessDateState(
    LAD_STATE* ladState
    )
{
    WsbTraceIn( L"CQuickStartIntro::CheckLastAccessDateState", L"" );

    const OLECHAR* localMachine = 0;
    const OLECHAR* regPath      = L"System\\CurrentControlSet\\Control\\FileSystem";
    const OLECHAR* regValue     = L"NtfsDisableLastAccessUpdate";

    HRESULT hr   = S_OK;
    DWORD   pVal = 0;

    try {

        // Install might have changed this registry value from 1 to 0. If the value
        // is not 1, we assume that the registry was 1 at one time and install
        // changed it to 0. This is a one time check, so the value is removed from
        // the registry if not 1.

        // If the following fails we assume that the value is not in the registry,
        // the normal case.

        if( S_OK == WsbGetRegistryValueDWORD( localMachine,
                                              regPath,
                                              regValue,
                                              &pVal ) ) {

            if( pVal == (DWORD)1 ) {

                *ladState = LAD_DISABLED;

            } else {

                *ladState = LAD_ENABLED;

                WsbAffirmHr( WsbRemoveRegistryValue ( localMachine,
                                                      regPath,
                                                      regValue ) );
            }

        } else {

            *ladState = LAD_UNSET;
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CQuickStartIntro::CheckLastAccessDateState",
                 L"HRESULT = %ls, *ladState = %d",
                 WsbHrAsString( hr ),
                 *ladState );

    return( hr );
}

LRESULT 
CQuickStartIntro::OnWizardNext()
{
    LAD_STATE ladState = LAD_UNSET;

    HRESULT hr = IsDriverRunning( );
    
    if( S_FALSE == hr ) {

        //
        // And the final restart dialog so the filter can load
        // In order to shut down we must enable a privilege.
        //

        if( IDYES == AfxMessageBox( IDS_QSTART_RESTART_NT, MB_YESNO | MB_ICONEXCLAMATION ) ) {

            HANDLE hToken;
            if( OpenProcessToken( GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken ) ) {

                TOKEN_PRIVILEGES privs;

                LookupPrivilegeValue( 0, SE_SHUTDOWN_NAME, &privs.Privileges[0].Luid );
                privs.PrivilegeCount = 1;
                privs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

                AdjustTokenPrivileges( hToken, FALSE, &privs, 0, 0, 0 );

                ExitWindowsEx( EWX_REBOOT, 0 );

            }
        }
        return( -1 );

    } else if( HRESULT_FROM_WIN32( ERROR_SERVICE_DOES_NOT_EXIST ) == hr ) {

        AfxMessageBox( IDS_ERR_QSTART_NO_FILTER, RS_MB_ERROR );
        return( -1 );

    } else if( FAILED( hr ) ) {

        CString message;
        AfxFormatString1( message, IDS_ERR_QSTART_FILTER_ERROR, WsbHrAsString( hr ) );
        AfxMessageBox( message, RS_MB_ERROR );
        return( -1 );

    } else {

        WsbAffirmHr( CheckLastAccessDateState( &ladState ) );

        if( ladState == LAD_DISABLED ) {

            AfxMessageBox( IDS_WIZ_LAST_ACCESS_DATE_DISABLED, MB_OK | MB_ICONEXCLAMATION );

        } else if( ladState == LAD_ENABLED ) {

            AfxMessageBox( IDS_WIZ_LAST_ACCESS_DATE_ENABLED, MB_OK | MB_ICONEXCLAMATION );
        }
    }
    
    //
    // Last check is if we can create temp task
    //
    if( FAILED( QSHEET->InitTask( ) ) ) {

        return( -1 );        

    }

    //
    // If we got through it, must be OK to continue
    //
    return( 0 );
}

CQuickStartIntro::~CQuickStartIntro( )
{
    WsbTraceIn( L"CQuickStartIntro::~CQuickStartIntro", L"" );
    WsbTraceOut( L"CQuickStartIntro::~CQuickStartIntro", L"" );
}

void CQuickStartIntro::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CQuickStartIntro::DoDataExchange", L"" );

    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CQuickStartIntro)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP

    WsbTraceOut( L"CQuickStartIntro::DoDataExchange", L"" );
}

BOOL CQuickStartIntro::OnInitDialog( ) 
{
    WsbTraceIn( L"CQuickStartIntro::OnInitDialog", L"" );

    CSakWizardPage::OnInitDialog( );

    WsbTraceOut( L"CQuickStartIntro::OnInitDialog", L"" );
    return TRUE;
}

BOOL CQuickStartIntro::OnSetActive( ) 
{
    WsbTraceIn( L"CQuickStartIntro::OnSetActive", L"" );

    BOOL retval = CSakWizardPage::OnSetActive( );

    m_pSheet->SetWizardButtons( PSWIZB_NEXT );

    WsbTraceOut( L"CQuickStartIntro::OnSetActive", L"retval = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}

/////////////////////////////////////////////////////////////////////////////
// CQuickStartInitialValues property page

CQuickStartInitialValues::CQuickStartInitialValues() :
    CSakWizardPage_InitBaseInt( WIZ_QSTART_INITIAL_VAL )
{
    WsbTraceIn( L"CQuickStartInitialValues::CQuickStartInitialValues", L"" );
    //{{AFX_DATA_INIT(CQuickStartInitialValues)
    //}}AFX_DATA_INIT
    WsbTraceOut( L"CQuickStartInitialValues::CQuickStartInitialValues", L"" );
}

CQuickStartInitialValues::~CQuickStartInitialValues( )
{
    WsbTraceIn( L"CQuickStartInitialValues::~CQuickStartInitialValues", L"" );
    WsbTraceOut( L"CQuickStartInitialValues::~CQuickStartInitialValues", L"" );
}

void CQuickStartInitialValues::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CQuickStartInitialValues::DoDataExchange", L"" );

    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CQuickStartInitialValues)
    DDX_Control(pDX, IDC_MINSIZE_BUDDY, m_MinSizeEdit);
    DDX_Control(pDX, IDC_FREESPACE_BUDDY, m_FreeSpaceEdit);
    DDX_Control(pDX, IDC_ACCESS_BUDDY, m_AccessEdit);
    DDX_Control(pDX, IDC_MINSIZE_SPIN, m_MinSizeSpinner);
    DDX_Control(pDX, IDC_FREESPACE_SPIN, m_FreeSpaceSpinner);
    DDX_Control(pDX, IDC_ACCESS_SPIN, m_AccessSpinner);
    //}}AFX_DATA_MAP

    WsbTraceOut( L"CQuickStartInitialValues::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CQuickStartInitialValues, CSakWizardPage)
    //{{AFX_MSG_MAP(CQuickStartInitialValues)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP( )

/////////////////////////////////////////////////////////////////////////////
// CQuickStartInitialValues message handlers

BOOL CQuickStartInitialValues::OnInitDialog( ) 
{
    WsbTraceIn( L"CQuickStartInitialValues::OnInitDialog", L"" );

    CSakWizardPage::OnInitDialog( );

    HRESULT hr = S_OK;

    try {

        //
        // Set up the spinners
        //

        m_FreeSpaceSpinner.SetRange( HSMADMIN_MIN_FREESPACE, HSMADMIN_MAX_FREESPACE );
        m_MinSizeSpinner.SetRange( HSMADMIN_MIN_MINSIZE, HSMADMIN_MAX_MINSIZE );
        m_AccessSpinner.SetRange( HSMADMIN_MIN_INACTIVITY, HSMADMIN_MAX_INACTIVITY );

        m_FreeSpaceSpinner.SetPos( HSMADMIN_DEFAULT_FREESPACE );
        m_MinSizeSpinner.SetPos( HSMADMIN_DEFAULT_MINSIZE );
        m_AccessSpinner.SetPos( HSMADMIN_DEFAULT_INACTIVITY );

        m_FreeSpaceEdit.SetLimitText( 2 );
        m_MinSizeEdit.SetLimitText( 5 );
        m_AccessEdit.SetLimitText( 3 );

    } WsbCatch( hr );
    

    WsbTraceOut( L"CQuickStartInitialValues::OnInitDialog", L"" );
    return TRUE;
}

BOOL CQuickStartInitialValues::OnSetActive( ) 
{
    WsbTraceIn( L"CQuickStartInitialValues::OnSetActive", L"" );

    BOOL retval = FALSE;

    //
    // Make sure at least one item is checked before allowing active
    //

    BOOL check = FALSE;
    CSakVolList &listBox = QSHEET->m_ManageRes.m_ListBox;
    for( INT i = 0; ( i < listBox.GetItemCount( ) ) && !check; i++  ) {
    
        if( listBox.GetCheck( i ) )    check = TRUE;
    
    }

    if( check ) {

        retval = CSakWizardPage::OnSetActive( );

        m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );

    }
    
    WsbTraceOut( L"CQuickStartInitialValues::OnSetActive", L"retval = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}

BOOL CQuickStartInitialValues::OnKillActive( ) 
{
    WsbTraceIn( L"CQuickStartInitialValues::OnKillActive", L"" );

    BOOL retval = FALSE;

    //
    // Need to handle strange case where a user can enter a value within
    // the parameters of the number of digits allowed, but the value can
    // be out of range. This is detected by the spin box which will
    // return an error if its buddy control is out of range.
    //
    if( HIWORD( m_MinSizeSpinner.GetPos( ) ) > 0 ) {

        // Control reports on error...
        retval = FALSE;

        CString message;
        AfxFormatString2( message, IDS_ERR_MINSIZE_RANGE, 
            CString( WsbLongAsString( (LONG)HSMADMIN_MIN_MINSIZE ) ),
            CString( WsbLongAsString( (LONG)HSMADMIN_MAX_MINSIZE ) ) );
        AfxMessageBox( message, MB_OK | MB_ICONWARNING );

    } else {

        retval = CSakWizardPage::OnKillActive();

    }
    
    WsbTraceOut( L"CQuickStartInitialValues::OnKillActive", L"retval = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}


/////////////////////////////////////////////////////////////////////////////
// CQuickStartManageRes property page

CQuickStartManageRes::CQuickStartManageRes() :
    CSakWizardPage_InitBaseInt( WIZ_QSTART_MANRES_SEL )
{
    WsbTraceIn( L"CQuickStartManageRes::CQuickStartManageRes", L"" );
    //{{AFX_DATA_INIT(CQuickStartManageRes)
    //}}AFX_DATA_INIT
    WsbTraceOut( L"CQuickStartManageRes::CQuickStartManageRes", L"" );
}

CQuickStartManageRes::~CQuickStartManageRes( )
{
    WsbTraceIn( L"CQuickStartManageRes::~CQuickStartManageRes", L"" );
    WsbTraceOut( L"CQuickStartManageRes::~CQuickStartManageRes", L"" );
}

void CQuickStartManageRes::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CQuickStartManageRes::DoDataExchange", L"" );

    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CQuickStartManageRes)
    DDX_Control(pDX, IDC_MANRES_SELECT, m_ListBox);
    DDX_Control(pDX, IDC_RADIO_SELECT, m_RadioSelect);
    //}}AFX_DATA_MAP

    WsbTraceOut( L"CQuickStartManageRes::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CQuickStartManageRes, CSakWizardPage)
    //{{AFX_MSG_MAP(CQuickStartManageRes)
    ON_WM_DESTROY( )
    ON_LBN_DBLCLK(IDC_MANRES_SELECT, OnDblclkSelect)
    ON_BN_CLICKED(IDC_RADIO_MANAGE_ALL, OnRadioQsManageAll)
    ON_BN_CLICKED(IDC_RADIO_SELECT, OnQsRadioSelect)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_MANRES_SELECT, OnItemchanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP( )

/////////////////////////////////////////////////////////////////////////////
// CQuickStartManageRes message handlers

BOOL CQuickStartManageRes::OnInitDialog( ) 
{
    WsbTraceIn( L"CQuickStartManageRes::OnInitDialog", L"" );

    CSakWizardPage::OnInitDialog( );
    
    BOOL           gotOne   = FALSE;
    HRESULT        hr       = S_OK;
    CResourceInfo* pResInfo = 0;

    try {

        //
        // Connect to the FSA for this machine
        //

        CWsbStringPtr computerName;
        WsbAffirmHr( WsbGetComputerName( computerName ) );
        
        CComPtr<IFsaServer> pFsaServer;
        WsbAffirmHr( QSHEET->GetFsaServer( pFsaServer ) );

        CComPtr<IWsbEnum> pEnum;
        WsbAffirmHr( pFsaServer->EnumResources( &pEnum ) );

        HRESULT hrEnum;
        CComPtr<IFsaResource> pResource;

        hrEnum = pEnum->First( IID_IFsaResource, (void**)&pResource );
        WsbAffirm( SUCCEEDED( hrEnum ) || ( WSB_E_NOTFOUND == hrEnum ), hrEnum );

        INT index = 0;
        while( SUCCEEDED( hrEnum ) ) {

            //
            // If path is blank, do not show this volume
            //
            if( S_OK == RsIsVolumeAvailable( pResource ) ) {

                gotOne = TRUE;

                pResInfo = new CResourceInfo( pResource );
                WsbAffirmAlloc( pResInfo );
                WsbAffirmHr( pResInfo->m_HrConstruct );

                //
                // Set Name, Capacity and Free Space columns.
                //
                WsbAffirm( LB_ERR != index, E_FAIL );
                LONGLONG    totalSpace  = 0;
                LONGLONG    freeSpace   = 0;
                LONGLONG    premigrated = 0;
                LONGLONG    truncated   = 0;
                WsbAffirmHr( pResource->GetSizes( &totalSpace, &freeSpace, &premigrated, &truncated ) );
                CString totalString, freeString;
                RsGuiFormatLongLong4Char( totalSpace, totalString );
                RsGuiFormatLongLong4Char( freeSpace, freeString );                  

                WsbAffirm( m_ListBox.AppendItem( pResInfo->m_DisplayName, totalString, freeString, &index ), E_FAIL );
                WsbAffirm( -1 != index, E_FAIL );

                //
                // Store struct pointer in listbox
                //
                WsbAffirm( m_ListBox.SetItemData( index, (DWORD_PTR)pResInfo ), E_FAIL );
                pResInfo = 0;

                //
                // Initialize selected array
                //
                m_ListBoxSelected[ index ] = FALSE;
            }

            //
            // Prepare for next iteration
            //
            pResource.Release( );
            hrEnum = pEnum->Next( IID_IFsaResource, (void**)&pResource );

        }

        m_ListBox.SortItems( CResourceInfo::Compare, 0 );

        //
        // Set the button AFTER we fill the box
        //
        CheckRadioButton( IDC_RADIO_MANAGE_ALL, IDC_RADIO_SELECT, IDC_RADIO_SELECT );
        OnQsRadioSelect( );
    } WsbCatch( hr );

    if( pResInfo )  delete pResInfo;
    
    WsbTraceOut( L"CQuickStartManageRes::OnInitDialog", L"" );
    return TRUE;
}

BOOL CQuickStartManageRes::OnSetActive( ) 
{
    WsbTraceIn( L"CQuickStartManageRes::OnSetActive", L"" );

    BOOL retval = CSakWizardPage::OnSetActive( );

    if( m_ListBox.GetItemCount( ) <= 0 ) {

        retval = FALSE;

    }

    SetButtons( );

    WsbTraceOut( L"CQuickStartManageRes::OnSetActive", L"retval = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}

void CQuickStartManageRes::OnItemchanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
    WsbTraceIn( L"CQuickStartManageRes::OnItemchanged", L"" );

    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    SetButtons();
    
    *pResult = 0;

    WsbTraceOut( L"CQuickStartManageRes::OnItemchanged", L"" );
}
   
void CQuickStartManageRes::OnDblclkSelect( ) 
{
    WsbTraceIn( L"CQuickStartManageRes::OnDblclkSelect", L"" );

    SetButtons( );

    WsbTraceOut( L"CQuickStartManageRes::OnDblclkSelect", L"" );
}

void CQuickStartManageRes::SetButtons( )
{
    WsbTraceIn( L"CQuickStartManageRes::SetButtons", L"" );

    BOOL fChecked = FALSE;
    INT count;

    // Is the "all" radio checked?
    if( !m_RadioSelect.GetCheck() ) {

        fChecked = TRUE;

    } else {

        // If one or more selected in the list box, set next button
        count = m_ListBox.GetItemCount();
        for( INT index = 0; index < count; index++ ) {

            if( m_ListBox.GetCheck( index ) ) {

                fChecked = TRUE;

            }
        }
    }

    m_pSheet->SetWizardButtons( PSWIZB_NEXT );

    WsbTraceOut( L"CQuickStartManageRes::SetButtons", L"" );
}

void CQuickStartManageRes::OnDestroy( ) 
{
    WsbTraceIn( L"CQuickStartManageRes::OnDestroy", L"" );

    CSakWizardPage::OnDestroy( );

    //
    // Cleanup the listbox's interface pointers
    // happens when the CResourceInfo is destructed
    //

    INT index;

    for( index = 0; index < m_ListBox.GetItemCount( ); index++ ) {

        CResourceInfo* pResInfo = (CResourceInfo*)m_ListBox.GetItemData( index );
        delete pResInfo;

    }
    
    WsbTraceOut( L"CQuickStartManageRes::OnDestroy", L"" );
}

void CQuickStartManageRes::OnRadioQsManageAll() 
{
    INT i;

    //
    // Save the current selection in the itemData array
    // Check all the boxes for display purposes only
    //
    for( i = 0; i < m_ListBox.GetItemCount(); i++ ) {

        m_ListBoxSelected[ i ] = m_ListBox.GetCheck( i );
        m_ListBox.SetCheck( i, TRUE );

    }

    m_ListBox.EnableWindow( FALSE );

    SetButtons();
}

void CQuickStartManageRes::OnQsRadioSelect() 
{
    INT i;

    // Get saved selection from itemdata array
    for( i = 0; i < m_ListBox.GetItemCount(); i++ ) {

        m_ListBox.SetCheck( i, m_ListBoxSelected[ i ] );

    }

    m_ListBox.EnableWindow( TRUE );

    SetButtons();
}

/////////////////////////////////////////////////////////////////////////////
// CQuickStartManageResX property page

CQuickStartManageResX::CQuickStartManageResX() :
    CSakWizardPage_InitBaseInt( WIZ_QSTART_MANRES_SELX )
{
    WsbTraceIn( L"CQuickStartManageResX::CQuickStartManageResX", L"" );
    //{{AFX_DATA_INIT(CQuickStartManageResX)
    //}}AFX_DATA_INIT
    WsbTraceOut( L"CQuickStartManageResX::CQuickStartManageResX", L"" );
}

CQuickStartManageResX::~CQuickStartManageResX( )
{
    WsbTraceIn( L"CQuickStartManageResX::~CQuickStartManageResX", L"" );
    WsbTraceOut( L"CQuickStartManageResX::~CQuickStartManageResX", L"" );
}

void CQuickStartManageResX::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CQuickStartManageResX::DoDataExchange", L"" );

    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CQuickStartManageResX)
    //}}AFX_DATA_MAP

    WsbTraceOut( L"CQuickStartManageResX::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CQuickStartManageResX, CSakWizardPage)
    //{{AFX_MSG_MAP(CQuickStartManageResX)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP( )

/////////////////////////////////////////////////////////////////////////////
// CQuickStartManageResX message handlers

BOOL CQuickStartManageResX::OnSetActive( ) 
{
    WsbTraceIn( L"CQuickStartManageResX::OnSetActive", L"" );

    BOOL retval = CSakWizardPage::OnSetActive( );

    if( QSHEET->m_ManageRes.m_ListBox.GetItemCount( ) > 0 ) {

        retval = FALSE;

    }

    m_pSheet->SetWizardButtons( PSWIZB_NEXT );

    WsbTraceOut( L"CQuickStartManageResX::OnSetActive", L"retval = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}

/////////////////////////////////////////////////////////////////////////////
// CQuickStartMediaSel property page

CQuickStartMediaSel::CQuickStartMediaSel() :
    CSakWizardPage_InitBaseInt( WIZ_QSTART_MEDIA_SEL )
{
    WsbTraceIn( L"CQuickStartMediaSel::CQuickStartMediaSel", L"" );
    //{{AFX_DATA_INIT(CQuickStartMediaSel)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    WsbTraceOut( L"CQuickStartMediaSel::CQuickStartMediaSel", L"" );
}

CQuickStartMediaSel::~CQuickStartMediaSel( )
{
    WsbTraceIn( L"CQuickStartMediaSel::~CQuickStartMediaSel", L"" );
    WsbTraceOut( L"CQuickStartMediaSel::~CQuickStartMediaSel", L"" );
}

void CQuickStartMediaSel::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CQuickStartMediaSel::DoDataExchange", L"" );

    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CQuickStartMediaSel)
    DDX_Control(pDX, IDC_MEDIA_SEL, m_ListMediaSel);
    //}}AFX_DATA_MAP

    WsbTraceOut( L"CQuickStartMediaSel::DoDataExchange", L"" );
}

BEGIN_MESSAGE_MAP(CQuickStartMediaSel, CSakWizardPage)
    //{{AFX_MSG_MAP(CQuickStartMediaSel)
    ON_WM_DESTROY()
    ON_LBN_SELCHANGE(IDC_MEDIA_SEL, OnSelchangeMediaSel)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP( )

BOOL CQuickStartMediaSel::OnInitDialog() 
{
    WsbTraceIn( L"CQuickStartMediaSel::OnInitDialog", L"" );

    HRESULT hr = 0;
    ULONG numEntries;

    CSakWizardPage::OnInitDialog();
    
    try {
        //
        // Get IRmsServer
        //
        CComPtr<IRmsServer> pRmsServer;
        WsbAffirmHr( QSHEET->GetRmsServer( pRmsServer ) );

        //
        // Get collection of Rms media sets
        //
        CComPtr<IRmsMediaSet> pMediaSet;
        CComPtr<IWsbIndexedCollection> pMediaSets;
        pRmsServer->GetMediaSets (&pMediaSets);

        WsbAffirmHr( pMediaSets->GetEntries( &numEntries ) );

        
        for( ULONG i = 0; i < numEntries; i++ ) {

            CWsbBstrPtr szMediaType;
            pMediaSet.Release();
            WsbAffirmHr( pMediaSets->At( i, IID_IRmsMediaSet, (void**) &pMediaSet ) );
            WsbAffirmHr( pMediaSet->GetName ( &szMediaType ) );

            //
            // Add the string to the listbox
            //
            INT index = m_ListMediaSel.AddString (szMediaType);

            //
            // Add the interface pointer to the list box
            //
            m_ListMediaSel.SetItemDataPtr( index, pMediaSet.Detach( ) );

        }

        //
        // And automatically select the first entry
        //
        m_ListMediaSel.SetCurSel( 0 );

    } WsbCatch (hr);
    

    WsbTraceOut( L"CQuickStartMediaSel::OnInitDialog", L"" );
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CQuickStartMediaSel message handlers

void CQuickStartMediaSel::OnDestroy() 
{
    WsbTraceIn( L"CQuickStartMediaSel::OnDestroy", L"" );

    CSakWizardPage::OnDestroy();
    //
    // Cleanup the listbox's interface pointers
    //

    INT index;
    for( index = 0; index < m_ListMediaSel.GetCount( ); index++ ) {

        IRmsMediaSet* pMediaSet = (IRmsMediaSet*) (m_ListMediaSel.GetItemDataPtr( index ));
        pMediaSet->Release( );

    }

    WsbTraceOut( L"CQuickStartMediaSel::OnDestroy", L"" );
}

void CQuickStartMediaSel::SetButtons( )
{
    WsbTraceIn( L"CQuickStartMediaSel::SetButtons", L"" );

    //
    // Make sure at least one item is checked before allowing "next"
    //

    if( m_ListMediaSel.GetCurSel() != LB_ERR ) {

        //
        // Something is selected
        //
        m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );

    } else {

        //
        // Nothing selected - don't allow to pass
        //
        m_pSheet->SetWizardButtons( PSWIZB_BACK );

    }

    WsbTraceOut( L"CQuickStartMediaSel::SetButtons", L"" );
}

BOOL CQuickStartMediaSel::OnSetActive( ) 
{
    WsbTraceIn( L"CQuickStartMediaSel::OnSetActive", L"" );

    SetButtons( );

    BOOL retval = CSakWizardPage::OnSetActive( );
    WsbTraceOut( L"CQuickStartMediaSel::OnSetActive", L"retval = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}

void CQuickStartMediaSel::OnSelchangeMediaSel() 
{
    WsbTraceIn( L"CQuickStartMediaSel::OnSelchangeMediaSel", L"" );

    SetButtons( );

    WsbTraceOut( L"CQuickStartMediaSel::OnSelchangeMediaSel", L"" );
}

/////////////////////////////////////////////////////////////////////////////
// CQuickStartSchedule property page

CQuickStartSchedule::CQuickStartSchedule() :
    CSakWizardPage_InitBaseInt( WIZ_QSTART_SCHEDULE )
{
    WsbTraceIn( L"CQuickStartSchedule::CQuickStartSchedule", L"" );
    //{{AFX_DATA_INIT(CQuickStartSchedule)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    WsbTraceOut( L"CQuickStartSchedule::CQuickStartSchedule", L"" );
}

CQuickStartSchedule::~CQuickStartSchedule()
{
    WsbTraceIn( L"CQuickStartSchedule::~CQuickStartSchedule", L"" );
    WsbTraceOut( L"CQuickStartSchedule::~CQuickStartSchedule", L"" );
}

void CQuickStartSchedule::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CQuickStartSchedule::DoDataExchange", L"" );

    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CQuickStartSchedule)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP

    WsbTraceOut( L"CQuickStartSchedule::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CQuickStartSchedule, CSakWizardPage)
    //{{AFX_MSG_MAP(CQuickStartSchedule)
    ON_BN_CLICKED(IDC_CHANGE_SCHED, OnChangeSchedule)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CQuickStartSchedule message handlers

void CQuickStartSchedule::OnChangeSchedule() 
{
    WsbTraceIn( L"CQuickStartSchedule::OnChangeSchedule", L"" );

    CScheduleSheet scheduleSheet( IDS_SCHED_MANAGE_TITLE, QSHEET->m_pTask, 0, 0 );

    scheduleSheet.DoModal( );

    UpdateDescription( );

    WsbTraceOut( L"CQuickStartSchedule::OnChangeSchedule", L"" );
}

BOOL CQuickStartSchedule::OnSetActive() 
{
    WsbTraceIn( L"CQuickStartSchedule::OnSetActive", L"" );

    CSakWizardPage::OnSetActive();

    //
    // Enable buttons
    //

    m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );
    
    //
    // Update the text box which has the description
    //

    UpdateDescription( );

    WsbTraceOut( L"CQuickStartSchedule::OnSetActive", L"" );
    return TRUE;
}

HRESULT
CQuickStartSchedule::UpdateDescription
(
    void
    )
{
    WsbTraceIn( L"CQuickStartSchedule::UpdateDescription", L"" );

    HRESULT hr = S_OK;

    try {

        //
        // And set schedule text into the text box.
        //
        
        CString buildString;
        WORD triggerCount, triggerIndex;

        WsbAffirmHr( QSHEET->m_pTask->GetTriggerCount( &triggerCount ) );
        
        CWsbStringPtr scheduleString;
        
        for( triggerIndex = 0; triggerIndex < triggerCount; triggerIndex++ ) {
        
            WsbAffirmHr( QSHEET->m_pTask->GetTriggerString( triggerIndex, &scheduleString ) );
            buildString += scheduleString;
            buildString += L"\r\n";

            scheduleString.Free( );
        
        }
        
        CEdit *pEdit = (CEdit *) GetDlgItem( IDC_SCHED_TEXT );
        pEdit->SetWindowText( buildString );
        
        //
        // Now check to see if we should add a scroll bar
        //
        
        //
        // It seems the only way to know that an edit control needs a scrollbar
        // is to force it to scroll to the bottom and see if the first
        // visible line is the first actual line
        //
        
        pEdit->LineScroll( MAXSHORT );
        if( pEdit->GetFirstVisibleLine( ) > 0 ) {
        
            //
            // Add the scroll styles
            //
        
            pEdit->ModifyStyle( 0, WS_VSCROLL | ES_AUTOVSCROLL, SWP_DRAWFRAME );
        
        
        } else {
        
            //
            // Remove the scrollbar (set range to 0)
            //
        
            pEdit->SetScrollRange( SB_VERT, 0, 0, TRUE );
        
        }
        
        //
        // Remove selection
        //
        
        pEdit->PostMessage( EM_SETSEL, -1, 0 );

    } WsbCatch( hr );

    WsbTraceOut( L"CQuickStartSchedule::UpdateDescription", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


/////////////////////////////////////////////////////////////////////////////
// CQuickStartFinish property page

CQuickStartFinish::CQuickStartFinish() :
    CSakWizardPage_InitBaseExt( WIZ_QSTART_FINISH )
{
    WsbTraceIn( L"CQuickStartFinish::CQuickStartFinish", L"" );
    //{{AFX_DATA_INIT(CQuickStartFinish)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    WsbTraceOut( L"CQuickStartFinish::CQuickStartFinish", L"" );
}

CQuickStartFinish::~CQuickStartFinish( )
{
    WsbTraceIn( L"CQuickStartFinish::~CQuickStartFinish", L"" );
    WsbTraceOut( L"CQuickStartFinish::~CQuickStartFinish", L"" );
}

void CQuickStartFinish::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CQuickStartFinish::DoDataExchange", L"" );

    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CQuickStartFinish)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP

    WsbTraceOut( L"CQuickStartFinish::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CQuickStartFinish, CSakWizardPage)
    //{{AFX_MSG_MAP(CQuickStartFinish)
    ON_EN_SETFOCUS(IDC_WIZ_FINAL_TEXT, OnSetFocusFinalText)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP( )

/////////////////////////////////////////////////////////////////////////////
// CQuickStartFinish message handlers

BOOL CQuickStartFinish::OnInitDialog( ) 
{
    WsbTraceIn( L"CQuickStartFinish::OnInitDialog", L"" );

    //
    // Set up the fonts that we use for this page
    //

    CSakWizardPage::OnInitDialog( );

    WsbTraceOut( L"CQuickStartFinish::OnInitDialog", L"" );
    return TRUE;
}

BOOL CQuickStartFinish::OnSetActive( ) 
{
    WsbTraceIn( L"CQuickStartFinish::OnSetActive", L"" );

    CSakWizardPage::OnSetActive( );

    m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_FINISH );
    
    //
    // Fill in text of configuration
    //

    CString formatString, formattedString, buildString, tempString, indentString;
    indentString.LoadString( IDS_QSTART_FINISH_INDENT );

#define FORMAT_TEXT( cid, arg )              \
    AfxFormatString1( formattedString, cid, arg ); \
    buildString += formattedString;

    FORMAT_TEXT( IDS_QSTART_MANRES_TEXT,    0 );
    buildString += L"\r\n";

    //
    // Add Resources
    //

    CSakVolList *pListBox = &(QSHEET->m_ManageRes.m_ListBox);

    INT index, managedCount = 0;
    for( index = 0; index < pListBox->GetItemCount( ); index++ ) {

        if( pListBox->GetCheck( index ) ) {

            buildString += indentString;
            tempString = pListBox->GetItemText( index, 0 );
            buildString += tempString;
            buildString += L"\r\n";

            managedCount++;

        }

    }

    if( 0 == managedCount ) {

        FORMAT_TEXT( IDS_QSTART_MANAGE_NO_VOLUMES, 0 );
        buildString += L"\r\n\r\n";

    } else {

        buildString += L"\r\n";

        //
        // The levels
        //
        
        FORMAT_TEXT( IDS_QSTART_FREESPACE_TEXT, WsbLongAsString( QSHEET->m_InitialValues.m_FreeSpaceSpinner.GetPos( ) ) );
        buildString += L"\r\n\r\n";
        
        AfxFormatString2( formattedString, IDS_QSTART_CRITERIA_TEXT,
            CString( WsbLongAsString( QSHEET->m_InitialValues.m_MinSizeSpinner.GetPos( ) ) ),
            CString( WsbLongAsString( QSHEET->m_InitialValues.m_AccessSpinner.GetPos( ) ) ) );
        buildString += formattedString;
        buildString += L"\r\n\r\n";

    }

    //
    // Media Type
    //

    QSHEET->m_MediaSel.m_ListMediaSel.GetWindowText( tempString );
    FORMAT_TEXT( IDS_QSTART_MEDIA_TEXT, tempString );
    buildString += L"\r\n\r\n";

    //
    // And Schedule
    //

    FORMAT_TEXT( IDS_QSTART_SCHED_TEXT,     0 );
    buildString += L"\r\n";

    WORD triggerCount, triggerIndex;
    QSHEET->m_pTask->GetTriggerCount( &triggerCount );
    
    CWsbStringPtr scheduleString;
    for( triggerIndex = 0; triggerIndex < triggerCount; triggerIndex++ ) {
    
        QSHEET->m_pTask->GetTriggerString( triggerIndex, &scheduleString );
        buildString += indentString;
        buildString += scheduleString;
        if( triggerIndex < triggerCount - 1 ) {

            buildString += L"\r\n";

        }

        scheduleString.Free( );

    }

    CEdit * pEdit = (CEdit*)GetDlgItem( IDC_WIZ_FINAL_TEXT );
    pEdit->SetWindowText( buildString );

    // Set the margins
    pEdit->SetMargins( 4, 4 );

    pEdit->PostMessage( EM_SETSEL, 0, 0 );
    pEdit->PostMessage( EM_SCROLLCARET, 0, 0 );
    pEdit->PostMessage( EM_SETSEL, -1, 0 );

    WsbTraceOut( L"CQuickStartFinish::OnSetActive", L"" );
    return TRUE;
}

void CQuickStartFinish::OnSetFocusFinalText() 
{
    WsbTraceIn( L"CQuickStartFinish::OnSetFocusFinalText", L"" );

    //
    // Deselect the text
    //

    CEdit *pEdit = (CEdit *) GetDlgItem( IDC_WIZ_FINAL_TEXT );
    pEdit->SetSel( -1, 0, FALSE );

    WsbTraceOut( L"CQuickStartFinish::OnSetFocusFinalText", L"" );
}


/////////////////////////////////////////////////////////////////////////////
// CQuickStartCheck property page

CQuickStartCheck::CQuickStartCheck() :
    CSakWizardPage_InitBaseInt( WIZ_QSTART_CHECK )
{
    WsbTraceIn( L"CQuickStartCheck::CQuickStartCheck", L"" );

    m_TimerStarted = FALSE;

    //{{AFX_DATA_INIT(CQuickStartCheck)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    WsbTraceOut( L"CQuickStartCheck::CQuickStartCheck", L"" );
}

CQuickStartCheck::~CQuickStartCheck()
{
    WsbTraceIn( L"CQuickStartCheck::~CQuickStartCheck", L"" );
    WsbTraceOut( L"CQuickStartCheck::~CQuickStartCheck", L"" );
}

void CQuickStartCheck::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CQuickStartCheck::DoDataExchange", L"" );

    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CQuickStartCheck)
    //}}AFX_DATA_MAP

    WsbTraceOut( L"CQuickStartCheck::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CQuickStartCheck, CSakWizardPage)
    //{{AFX_MSG_MAP(CQuickStartCheck)
    ON_WM_TIMER()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CQuickStartCheck message handlers

BOOL CQuickStartCheck::OnSetActive() 
{
    WsbTraceIn( L"CQuickStartCheck::OnSetActive", L"" );

    BOOL retval = CSakWizardPage::OnSetActive();

    m_pSheet->SetWizardButtons( PSWIZB_BACK );

    //
    // Kick off the thread which will check the system
    //

    DWORD threadId;
    QSHEET->m_CheckSysState = CST_NOT_STARTED;
    QSHEET->m_hCheckSysThread =
            CreateThread( 0, 1024, CQuickStartWizard::CheckSysThreadStart, QSHEET, 0, &threadId );

    StartTimer( );

    WsbTraceOut( L"CQuickStartCheck::OnSetActive", L"" );
    return( retval );
}

BOOL CQuickStartCheck::OnKillActive() 
{
    WsbTraceIn( L"CQuickStartCheck::OnKillActive", L"" );

    StopTimer( );
    
    BOOL retval = CSakWizardPage::OnKillActive();

    WsbTraceOut( L"CQuickStartCheck::OnKillActive", L"" );
    return( retval );}

BOOL CQuickStartCheck::OnInitDialog() 
{
    WsbTraceIn( L"CQuickStartCheck::OnInitDialog", L"" );

    CSakWizardPage::OnInitDialog();

    GetDlgItem( IDC_CHECK_LOGON_BOX      )->SetFont( GetWingDingFont( ) );
    GetDlgItem( IDC_CHECK_SUPP_MEDIA_BOX )->SetFont( GetWingDingFont( ) );

    m_CheckString = GetWingDingCheckChar( );
    m_ExString    = GetWingDingExChar( );

    WsbTraceOut( L"CQuickStartCheck::OnInitDialog", L"" );
    return TRUE;
}

void CQuickStartCheck::StartTimer( )
{
    WsbTraceIn( L"CQuickStartCheck::StartTimer", L"" );

    if( !m_TimerStarted ) {

        m_TimerStarted = TRUE;
        SetTimer( CHECK_SYSTEM_TIMER_ID, CHECK_SYSTEM_TIMER_MS, 0 );

    }

    WsbTraceOut( L"CQuickStartCheck::StartTimer", L"" );
}

void CQuickStartCheck::StopTimer( )
{
    WsbTraceIn( L"CQuickStartCheck::StopTimer", L"" );

    if( m_TimerStarted ) {

        m_TimerStarted = FALSE;
        KillTimer( CHECK_SYSTEM_TIMER_ID );

        if( CST_DONE != QSHEET->m_CheckSysState ) {

            TerminateThread( QSHEET->m_hCheckSysThread, 0 );

        }

    }

    WsbTraceOut( L"CQuickStartCheck::StopTimer", L"" );
}


void CQuickStartCheck::OnTimer(UINT nIDEvent) 
{
    WsbTraceIn( L"CQuickStartCheck::OnTimer", L"" );

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if( CHECK_SYSTEM_TIMER_ID == nIDEvent ) {

        HRESULT hr = S_OK;

        try {

            //
            // First update the checkmarks
            //

            HRESULT   hrThread = QSHEET->m_hrCheckSysResult;
            CST_STATE state = QSHEET->m_CheckSysState;

            SetDlgItemText( IDC_CHECK_LOGON_BOX, state > CST_ACCOUNT ? m_CheckString : L"" );
            SetDlgItemText( IDC_CHECK_SUPP_MEDIA_BOX, state > CST_SUPP_MEDIA ? m_CheckString : L"" );

            GetDlgItem( IDC_CHECK_LOGON_TEXT )->SetFont( CST_ACCOUNT == state ? GetBoldShellFont( ) : GetShellFont( ) );
            GetDlgItem( IDC_CHECK_SUPP_MEDIA_TEXT )->SetFont( CST_SUPP_MEDIA == state ? GetBoldShellFont( ) : GetShellFont( ) );

            switch( QSHEET->m_CheckSysState ) {

            case CST_ACCOUNT:
                if( hrThread == S_FALSE ) {
                    StopTimer( );
                    AfxMessageBox( IDS_ERR_NO_ADMIN_PRIV, RS_MB_ERROR );
                    m_pSheet->PressButton( PSBTN_CANCEL );
//                    m_pSheet->SetWizardButtons( PSWIZB_BACK );
                }
                break;

            case CST_SUPP_MEDIA:
                if( hrThread == S_FALSE ) {
                    StopTimer( );
                    AfxMessageBox( IDS_ERR_NO_SUPP_MEDIA, RS_MB_ERROR );
                    m_pSheet->PressButton( PSBTN_CANCEL );
//                    m_pSheet->SetWizardButtons( PSWIZB_BACK );
                }
                break;

            case CST_DONE:
                StopTimer( );
                m_pSheet->PressButton( PSBTN_NEXT );
                break;

            }

            if( FAILED( hrThread ) ) {
                StopTimer( );

                // Report any errors
                RsReportError( hrThread, IDS_ERROR_SYSTEM_CHECK ); 

                m_pSheet->PressButton( PSBTN_CANCEL );
//                m_pSheet->SetWizardButtons( PSWIZB_BACK );

            }

        } WsbCatch( hr );

    }
    
    CSakWizardPage::OnTimer(nIDEvent);

    WsbTraceOut( L"CQuickStartCheck::OnTimer", L"" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\computer\wzqstart.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    WzQStart.h

Abstract:

    Setup Wizard implementation.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#ifndef _WZQSTART_H
#define _WZQSTART_H

#pragma once

#include <mstask.h>
#include "SakVlLs.h"

class CQuickStartWizard;

/////////////////////////////////////////////////////////////////////////////
// CQuickStartIntro dialog

class CQuickStartIntro : public CSakWizardPage
{
// Construction
public:
    CQuickStartIntro();
    ~CQuickStartIntro();
    virtual LRESULT OnWizardNext();

public:
// Dialog Data
    //{{AFX_DATA(CQuickStartIntro)
    enum { IDD = IDD_WIZ_QSTART_INTRO };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CQuickStartIntro)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CQuickStartIntro)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    enum LAD_STATE {

        LAD_ENABLED,
        LAD_DISABLED,
        LAD_UNSET
    };

    HRESULT IsDriverRunning();
    HRESULT CheckLastAccessDateState( LAD_STATE* );

};

/////////////////////////////////////////////////////////////////////////////
// CQuickStartCheck dialog

class CQuickStartCheck : public CSakWizardPage
{
// Construction
public:
    CQuickStartCheck();
    ~CQuickStartCheck();

// Dialog Data
    //{{AFX_DATA(CQuickStartCheck)
    enum { IDD = IDD_WIZ_QSTART_CHECK };
    //}}AFX_DATA



// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CQuickStartCheck)
    public:
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
    CString m_ExString, m_CheckString;

    BOOL      m_TimerStarted;

    void StartTimer( );
    void StopTimer( );

protected:
    // Generated message map functions
    //{{AFX_MSG(CQuickStartCheck)
    virtual BOOL OnInitDialog();
    afx_msg void OnTimer(UINT nIDEvent);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CQuickStartFinish dialog

class CQuickStartFinish : public CSakWizardPage
{
// Construction
public:
    CQuickStartFinish();
    ~CQuickStartFinish();

// Dialog Data
    //{{AFX_DATA(CQuickStartFinish)
    enum { IDD = IDD_WIZ_QSTART_FINISH };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CQuickStartFinish)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CQuickStartFinish)
    virtual BOOL OnInitDialog();
    afx_msg void OnSetFocusFinalText();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CQuickStartInitialValues dialog

class CQuickStartInitialValues : public CSakWizardPage
{
// Construction
public:
    CQuickStartInitialValues();
    ~CQuickStartInitialValues();

// Dialog Data
    //{{AFX_DATA(CQuickStartInitialValues)
    enum { IDD = IDD_WIZ_QSTART_INITIAL_VAL };
    CEdit   m_MinSizeEdit;
    CEdit   m_FreeSpaceEdit;
    CEdit   m_AccessEdit;
    CSpinButtonCtrl m_MinSizeSpinner;
    CSpinButtonCtrl m_FreeSpaceSpinner;
    CSpinButtonCtrl m_AccessSpinner;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CQuickStartInitialValues)
    public:
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CQuickStartInitialValues)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};
/////////////////////////////////////////////////////////////////////////////
// CQuickStartManageRes dialog

class CQuickStartManageRes : public CSakWizardPage
{
// Construction
public:
    CQuickStartManageRes();
    ~CQuickStartManageRes();

// Dialog Data
    //{{AFX_DATA(CQuickStartManageRes)
    enum { IDD = IDD_WIZ_QSTART_MANRES_SEL };
    CSakVolList   m_ListBox;
    CButton m_RadioSelect;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CQuickStartManageRes)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
    void SetButtons( );

protected:
    // Generated message map functions
    //{{AFX_MSG(CQuickStartManageRes)
    virtual BOOL OnInitDialog();
    afx_msg void OnDestroy();
    afx_msg void OnDblclkSelect();
    afx_msg void OnRadioQsManageAll();
    afx_msg void OnQsRadioSelect();
    afx_msg void OnItemchanged(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
private:
    BOOL m_ListBoxSelected[HSMADMIN_MAX_VOLUMES];

};

/////////////////////////////////////////////////////////////////////////////
// CQuickStartManageRes dialog

class CQuickStartManageResX : public CSakWizardPage
{
// Construction
public:
    CQuickStartManageResX();
    ~CQuickStartManageResX();

// Dialog Data
    //{{AFX_DATA(CQuickStartManageResX)
    enum { IDD = IDD_WIZ_QSTART_MANRES_SELX };
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CQuickStartManageResX)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CQuickStartManageResX)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CQuickStartMediaSel dialog

class CQuickStartMediaSel : public CSakWizardPage
{
// Construction
public:
    CQuickStartMediaSel();
    ~CQuickStartMediaSel();

// Dialog Data
    //{{AFX_DATA(CQuickStartMediaSel)
    enum { IDD = IDD_WIZ_QSTART_MEDIA_SEL };
    CComboBox    m_ListMediaSel;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CQuickStartMediaSel)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CQuickStartMediaSel)
    virtual BOOL OnInitDialog();
    afx_msg void OnDestroy();
    afx_msg void OnSelchangeMediaSel();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
private:
    void SetButtons( );
};


/////////////////////////////////////////////////////////////////////////////
// CQuickStartSchedule dialog

class CQuickStartSchedule : public CSakWizardPage
{
// Construction
public:
    CQuickStartSchedule();
    ~CQuickStartSchedule();

// Dialog Data
    //{{AFX_DATA(CQuickStartSchedule)
    enum { IDD = IDD_WIZ_QSTART_SCHEDULE };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CQuickStartSchedule)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
    HRESULT UpdateDescription( );

protected:
    // Generated message map functions
    //{{AFX_MSG(CQuickStartSchedule)
    afx_msg void OnChangeSchedule();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CQuickStartWizard

// Enumeration of states of checking system worker thread
enum CST_STATE {

    CST_NOT_STARTED,
    CST_ACCOUNT,
    CST_NTMS_INSTALL,
    CST_SUPP_MEDIA,
    CST_DONE,

};

class CQuickStartWizard : public CSakWizardSheet
{
// Construction
public:
    CQuickStartWizard( );

// Attributes
public:
    CQuickStartIntro          m_IntroPage;
    CQuickStartCheck          m_CheckPage;
    CQuickStartManageRes      m_ManageRes;
    CQuickStartManageResX     m_ManageResX;
    CQuickStartInitialValues  m_InitialValues;
    CQuickStartSchedule       m_SchedulePage;
    CQuickStartMediaSel       m_MediaSel;
    CQuickStartFinish         m_FinishPage;



// Operations
public:

// Implementation
public:
    virtual ~CQuickStartWizard();

public:
///////////////////////////////
// Used across multiple pages:
    CWsbStringPtr       m_ComputerName;

    HRESULT GetHsmServer( CComPtr<IHsmServer> &pServ );
    HRESULT GetFsaServer( CComPtr<IFsaServer> &pServ );
    HRESULT GetRmsServer( CComPtr<IRmsServer> &pServ );

    HRESULT ReleaseServers( void );

    virtual HRESULT OnCancel( void );
    virtual HRESULT OnFinish( void );

    STDMETHOD( AddWizardPages ) ( IN RS_PCREATE_HANDLE Handle, IN IUnknown* pPropSheetCallback, IN ISakSnapAsk* pSakSnapAsk );
    HRESULT InitTask( void );


    CComPtr<ISchedulingAgent> m_pSchedAgent;
    CComPtr<ITask>            m_pTask;
    CComPtr<ITaskTrigger>     m_pTrigger;

    CWsbStringPtr m_HsmServiceName;
    CWsbStringPtr m_FsaServiceName;
    CWsbStringPtr m_RmsServiceName;

    HANDLE    m_hCheckSysThread;
    CST_STATE m_CheckSysState;
    HRESULT   m_hrCheckSysResult;

    static DWORD WINAPI CheckSysThreadStart( LPVOID pv );

private:
    CComPtr<IHsmServer> m_pHsmServer;
    CComPtr<IFsaServer> m_pFsaServer;
    CComPtr<IRmsServer> m_pRmsServer;

};



//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\device\ca.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Ca.h

Abstract:

    Cartridge node implementation. Represents a piece of media.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/
#ifndef _CAR_H
#define _CAR_H

#include "saknodei.h"
#include "PrCar.h"

// Forward declaration
// class CMediaInfoObject;
class   CPropCartStatus;
class   CPropCartCopies;
class   CPropCartRecover;
class   CRecreateChooseCopy;


///////////////////////////////////////////////////////////////////////////////////
//
//
//  Property Sheet container class for media
//

// Media information object

class CMediaInfoObject 
{
// Construction
public:
    CMediaInfoObject();
    ~CMediaInfoObject();

protected:

private:
    CComPtr<IWsbDb>         m_pDb;
    CComPtr<IWsbDbSession>  m_pDbSession;
    CComPtr<IMediaInfo>     m_pMediaInfo;
    CComPtr<IHsmServer>     m_pHsmServer;
    CComPtr<IRmsServer>     m_pRmsServer;

public:
    HRESULT Initialize( GUID nMediaId, IHsmServer *pHsmServer, IRmsServer *pRmsServer );
    HRESULT First( );
    HRESULT Next( );
    HRESULT DeleteCopy( int Copy );
    HRESULT RecreateMaster( );


public:
	HRESULT IsCopyInSync( INT Copy );
    HRESULT DoesMasterExist( );
	HRESULT DoesCopyExist( INT Copy );
    HRESULT IsViewable( BOOL ConsiderInactiveCopies );
    GUID                m_MediaId;
    GUID                m_RmsIdMaster;
    CCopySetInfo        m_CopyInfo[HSMADMIN_MAX_COPY_SETS];

    CString             m_Name,
                        m_Description;
    CString             m_MasterName,
                        m_MasterDescription;

    HRESULT             m_LastHr;
    HSM_JOB_MEDIA_TYPE  m_Type;
    LONGLONG            m_FreeSpace,
                        m_Capacity;

    SHORT               m_NextDataSet;
    FILETIME            m_Modify;
    BOOL                m_ReadOnly,
                        m_Recreating,
                        m_Disabled;

    SHORT               m_LastGoodNextDataSet;

    USHORT              m_NumMediaCopies;



    // Helper functions
private:
    HRESULT InternalGetInfo();

    friend class CRecreateChooseCopy;
};


class CUiCarSheet : public CSakPropertySheet
{
public:
    CUiCarSheet( ) { };
    HRESULT AddPropertyPages( );
    HRESULT InitSheet(
            RS_NOTIFY_HANDLE handle, 
            IUnknown*        pUnkPropSheetCallback, 
            CSakNode*        pSakNode,
            ISakSnapAsk*     pSakSnapAsk,
            IEnumGUID*       pEnumObjectId,
            IEnumUnknown*    pEnumUnkNode);
    HRESULT GetNumMediaCopies( USHORT *pNumMediaCopies );
    HRESULT GetMediaId( GUID *pMediaId );


private:
    USHORT      m_pNumMediaCopies;
    GUID        m_mediaId;
    CPropCartStatus     *m_pPropPageStatus;
    CPropCartCopies     *m_pPropPageCopies;
    CPropCartRecover    *m_pPropPageRecover;

public:
    HRESULT OnPropertyChange( RS_NOTIFY_HANDLE hNotifyHandle );
};


class ATL_NO_VTABLE CUiCar : 
    public CSakNodeImpl<CUiCar>,
    public CComCoClass<CUiCar,&CLSID_CUiCar>,
    public CComDualImpl<ICartridge, &IID_ICartridge, &LIBID_HSMADMINLib>
{


public:
// constructor/destructor
    CUiCar(void) {};
BEGIN_COM_MAP(CUiCar)
    COM_INTERFACE_ENTRY2(IDispatch,    ICartridge)
    COM_INTERFACE_ENTRY2(ISakNodeProp, ICartridge)

    COM_INTERFACE_ENTRY(ISakNode)
    COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CUiCar)

    // for multiple-inheritance, forward all base implementations to CSakNode.
    FORWARD_BASEHSM_IMPLS 

    HRESULT FinalConstruct( void );
    void    FinalRelease( void );

public: 
    STDMETHOD( InvokeCommand )          ( SHORT sCmd, IDataObject *pDataObject );
    STDMETHOD( GetContextMenu )         ( BOOL bMultiSelect, HMENU *phMenu );
    STDMETHOD( AddPropertyPages )       ( RS_NOTIFY_HANDLE handle, IUnknown* pUnkPropSheetCallback, IEnumGUID* pEnumObjectId, IEnumUnknown *pEnumUnkNode );

    // ISakNode methods
    STDMETHOD( InitNode )               ( ISakSnapAsk* pSakSnapAsk, IUnknown* pHsmObj, ISakNode* pParent );
    STDMETHOD( RefreshObject )          ();
    STDMETHOD( OnToolbarButtonClick )   ( IDataObject *pDataObject, long cmdId );
    STDMETHOD( GetResultIcon )          ( IN BOOL bOK, OUT int* pIconIndex );

    // ICartridge methods
    STDMETHOD( get_MediaTypeP )         ( BSTR * pszValue );
    STDMETHOD( get_CapacityP )          ( BSTR * pszValue );
    STDMETHOD( get_CapacityP_SortKey )  ( BSTR * pszValue );
    STDMETHOD( get_FreeSpaceP )         ( BSTR * pszValue );
    STDMETHOD( get_FreeSpaceP_SortKey ) ( BSTR * pszValue );
    STDMETHOD( get_StatusP )            ( BSTR * pszValue );
    STDMETHOD( get_StatusP_SortKey )    ( BSTR * pszValue );
    STDMETHOD( get_CopySet1P )          ( BSTR * pszValue );
    STDMETHOD( get_CopySet2P )          ( BSTR * pszValue );
    STDMETHOD( get_CopySet3P )          ( BSTR * pszValue );
    STDMETHOD( get_CopySet1P_SortKey )  ( BSTR * pszValue );
    STDMETHOD( get_CopySet2P_SortKey )  ( BSTR * pszValue );
    STDMETHOD( get_CopySet3P_SortKey )  ( BSTR * pszValue );


    // Interal Copy set access functions
    HRESULT GetCopySetP                 ( int CopySet, BSTR * pszValue );

    // private store of media info
private:

    GUID                m_RmsIdMaster;
    HSM_JOB_MEDIA_TYPE  m_Type;
    LONGLONG            m_FreeSpace,
                        m_Capacity;
    HRESULT             m_LastHr;
    BOOL                m_ReadOnly;
    BOOL                m_Recreating;
    CString             m_MasterName;
    FILETIME            m_Modify;
    SHORT               m_NextDataSet;
    SHORT               m_LastGoodNextDataSet;
    BOOL                m_Disabled;

    CCopySetInfo  m_CopyInfo[HSMADMIN_MAX_COPY_SETS];
    HRESULT ShowCarProperties (IDataObject *pDataObject, int initialPage);
    
    // static, class-wide variables
    static INT  m_nResultIconD;
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CRecreateChooseCopy dialog

class CRecreateChooseCopy : public CDialog
{
// Construction
public:
    CRecreateChooseCopy( CMediaInfoObject * pMio, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CRecreateChooseCopy)
    enum { IDD = IDD_DLG_RECREATE_CHOOSE_COPY };
    CListCtrl   m_List;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRecreateChooseCopy)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
    CMediaInfoObject * m_pMio;
    SHORT m_CopyToUse;
    int   m_ColCopy;
    int   m_ColName;
    int   m_ColDate;
    int   m_ColStatus;

public:
    SHORT CopyToUse( void );

protected:

    // Generated message map functions
    //{{AFX_MSG(CRecreateChooseCopy)
    afx_msg void OnClickList(NMHDR* pNMHDR, LRESULT* pResult);
    virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\device\mese.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    ChooHsm.cpp

Abstract:

    Node representing our Media Set (Media Pool) within NTMS.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#ifndef _MEDSET_H
#define _MEDSET_H

#include "SakNodeI.h"

class ATL_NO_VTABLE CUiMedSet : 
    public CSakNodeImpl<CUiMedSet>,
    public CComCoClass<CUiMedSet,&CLSID_CUiMedSet>
{

public:
// constructor/destructor
    CUiMedSet(void) {};
BEGIN_COM_MAP(CUiMedSet)
    COM_INTERFACE_ENTRY2(IDispatch, ISakNodeProp)
    COM_INTERFACE_ENTRY(ISakNode)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(ISakNodeProp)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CUiMedSet)

    HRESULT FinalConstruct( void );
    void    FinalRelease( void );

public: 
    STDMETHOD( InvokeCommand )             ( SHORT sCmd, IDataObject *pDataObject );
    STDMETHOD( GetContextMenu )            ( BOOL bMultiSelect, HMENU *phMenu );

    // ISakNode methods
    STDMETHOD( CreateChildren )            ( void ); 
    STDMETHOD( InitNode )                  ( ISakSnapAsk* pSakSnapAsk, IUnknown* pHsmObj, ISakNode* pParent );
    STDMETHOD( TerminateNode )             ( void );
    STDMETHOD( RefreshObject )             ( );
    STDMETHOD( SetupToolbar )               ( IToolbar *pToolbar );
    STDMETHOD( OnToolbarButtonClick )      ( IDataObject *pDataObject, long cmdId );

    // static, class-wide variables
    static INT  m_nScopeOpenIconIndex;  // virtual scope index of Open Icon
    static INT  m_nScopeCloseIconIndex; // virtual scope index of Close Icon
    static INT  m_nResultIconIndex; // virtual scope index of Close Icon

private:

    CComPtr <IHsmStoragePool> m_pStoragePool;
    CComPtr <IHsmServer>      m_pHsmServer;
    CComPtr <IRmsServer>      m_pRmsServer;
    USHORT                    m_NumCopySets;
    BOOL                      m_MediaCopiesEnabled;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\device\mese.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    MeSe.cpp

Abstract:

    Node representing our Media Set (Media Pool) within NTMS.

Author:

    Rohde Wakefield [rohde]   04-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include "MeSe.h"
#include "WzMedSet.h"
#include "ca.h"



int CUiMedSet::m_nScopeCloseIcon  = AddScopeImage( IDI_NODELIB );
int CUiMedSet::m_nScopeCloseIconX = AddScopeImage( IDI_NODELIBX );
int CUiMedSet::m_nScopeOpenIcon   = AddScopeImage( IDI_NODEOPENFOLDER );
int CUiMedSet::m_nScopeOpenIconX  = CUiMedSet::m_nScopeCloseIconX;
int CUiMedSet::m_nResultIcon      = AddResultImage( IDI_NODELIB );
int CUiMedSet::m_nResultIconX     = AddResultImage( IDI_NODELIBX );


/////////////////////////////////////////////////////////////////////////////
//
// CoComObjectRoot
//
/////////////////////////////////////////////////////////////////////////////


//---------------------------------------------------------------------------
//
//         FinalConstruct
//
//  Initialize this level of the object hierarchy
//

HRESULT CUiMedSet::FinalConstruct( )
{
    WsbTraceIn( L"CUiMedSet::FinalConstruct", L"" );

    m_rTypeGuid    = &cGuidMedSet;
    m_NumCopySets  = 0;

    HRESULT hr = CSakNode::FinalConstruct( );

    m_bSupportsPropertiesSingle = FALSE;
    m_bSupportsPropertiesMulti  = FALSE;
    m_bSupportsDeleteSingle     = FALSE;
    m_bSupportsDeleteMulti      = FALSE;
    m_bSupportsRefreshSingle    = TRUE;
    m_bSupportsRefreshMulti     = FALSE;
    m_bIsContainer              = TRUE;
    m_bHasDynamicChildren       = TRUE;


    // Toolbar values
    INT i = 0;

    m_ToolbarButtons[i].nBitmap = 0;
    m_ToolbarButtons[i].idCommand =     TB_CMD_MESE_COPY;
    m_ToolbarButtons[i].idButtonText =  IDS_TB_TEXT_MESE_COPY;
    m_ToolbarButtons[i].idTooltipText = IDS_TB_TIP_MESE_COPY;
    i++;

    m_ToolbarBitmap             = IDB_TOOLBAR_MESE;
    m_cToolbarButtons           = i;

    WsbTraceOut( L"CUiMedSet::FinalConstruct", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


//---------------------------------------------------------------------------
//
//         FinalRelease
//
//  Clean up this level of the object hierarchy
//

void CUiMedSet::FinalRelease( )
{
    WsbTraceIn( L"CUiMedSet::FinalRelease", L"" );

//  if( m_pDbSession ) {
//
//      m_pDb->Close( m_pDbSession );
//
//  }

    CSakNode::FinalRelease( );

    WsbTraceOut( L"CUiMedSet::FinalRelease", L"" );
}


/////////////////////////////////////////////////////////////////////////////
//
// ISakNode
//
/////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------
//
//         GetContextMenu
//
//  Return an HMENU to be used for context menus on this node.
//

STDMETHODIMP 
CUiMedSet::GetContextMenu( BOOL bMultiSelect, HMENU* phMenu )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    try {

        CMenu* pRootMenu;
        LoadContextMenu( IDR_MEDSET, phMenu );
        CMenu menu;
        menu.Attach( *phMenu );
        pRootMenu = menu.GetSubMenu( MENU_INDEX_ROOT );

        pRootMenu->EnableMenuItem( ID_MEDSET_ROOT_COPY, MF_GRAYED | MF_BYCOMMAND );
        //
        // If not multi-select, and media copies are supported, 
        // and If engine up, enable copy
        //
        if( !bMultiSelect && ( m_pSakSnapAsk->GetState() == S_OK ) ) {

            if( m_MediaCopiesEnabled ) {

                pRootMenu->EnableMenuItem( ID_MEDSET_ROOT_COPY, MF_BYCOMMAND );
            }
        }

        menu.Detach();

    } WsbCatch( hr );

    return( hr );
}


//---------------------------------------------------------------------------
//
//         InvokeCommand
//
//  User has selected a command from the menu. Process it here.
//

STDMETHODIMP 
CUiMedSet::InvokeCommand( SHORT sCmd, IDataObject* /*pDataObject*/ )
{
    WsbTraceIn( L"CUiMedSet::InvokeCommand", L"sCmd = <%d>", sCmd );

    HRESULT hr = S_OK;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CComPtr<IHsmServer> pHsm;

    try {

        
        switch (sCmd) {

            case ID_MEDSET_ROOT_COPY:
                {
                //
                // use wizard to sync media copies
                //
                CComObject<CMediaCopyWizard>* pWizard = new CComObject<CMediaCopyWizard>;
                WsbAffirmAlloc( pWizard );

                CComPtr<ISakWizard> pSakWizard = (ISakWizard*)pWizard;
                WsbAffirmHr( m_pSakSnapAsk->CreateWizard( pSakWizard ) );
                }
                break;
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiMedSet::InvokeCommand", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

HRESULT CUiMedSet::SetupToolbar( IToolbar *pToolbar ) 
{
    WsbTraceIn( L"CUiMedSet::SetupToolbar", L"pToolbar = <0x%p>", pToolbar );
    HRESULT hr = S_OK;

    try {

        BOOL state = ( S_OK == m_pSakSnapAsk->GetState( ) ) ? TRUE : FALSE;

        for( INT i = 0; i < m_cToolbarButtons; i++ ) {

            m_ToolbarButtons[i].fsState = (UCHAR)( state ? TBSTATE_ENABLED : 0 );

            //
            // If media copy button, need to check if should be enabled
            //
            if( state && ( TB_CMD_MESE_COPY == m_ToolbarButtons[i].idCommand ) ) {

                if( m_MediaCopiesEnabled ) {
                    
                    m_ToolbarButtons[i].fsState = TBSTATE_ENABLED;

                } else {

                    m_ToolbarButtons[i].fsState = 0;
                }
            }
        }

        WsbAffirmHr( CSakNode::SetupToolbar( pToolbar ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiMedSet::SetupToolbar", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

HRESULT CUiMedSet::OnToolbarButtonClick( IDataObject * /* pDataObject */, long cmdId )
{
    WsbTraceIn( L"CUiMedSet::OnToolbarButtonClick", L"cmdId = <%d>", cmdId );
    HRESULT hr = S_OK;
    try {

        switch ( cmdId ) {

        case TB_CMD_MESE_COPY:
            {
                //
                // use wizard to sync media copies
                //
                CComObject<CMediaCopyWizard>* pWizard = new CComObject<CMediaCopyWizard>;
                WsbAffirmAlloc( pWizard );

                CComPtr<ISakWizard> pSakWizard = (ISakWizard*)pWizard;
                WsbAffirmHr( m_pSakSnapAsk->CreateWizard( pSakWizard ) );
            }
            break;
        }
    } WsbCatch( hr );

    WsbTraceOut( L"CUiMedSet::OnToolbarButtonClick", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         CreateChildren
//
//  Create and initialize all the children of the media node.
//

STDMETHODIMP CUiMedSet::CreateChildren( )
{
    CMediaInfoObject mio;
    WsbTraceIn( L"CUiMedSet::CreateChildren", L"" );

    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( m_pHsmServer );
        WsbAffirmPointer( m_pRmsServer );

        HRESULT hrEnum;

        // Get media info
        WsbAffirmHr( mio.Initialize( GUID_NULL, m_pHsmServer, m_pRmsServer ) );

        // Did we get a node?
        if( mio.m_MediaId != GUID_NULL ) {

            hrEnum = S_OK;
            while( SUCCEEDED( hrEnum ) ) {

                if( S_OK == mio.IsViewable( FALSE ) ) {

                    //
                    // Create the coresponding node
                    //

                    CComPtr<IUnknown> pUnkChild;
                    CComPtr<ISakNode> pNode;

                    WsbAffirmHr( NewChild( cGuidCar, &pUnkChild ) );
                    WsbAffirmHr( RsQueryInterface( pUnkChild, ISakNode, pNode ) );

                    //
                    // And initialize
                    //

                    // The media node now initializes based on the media id.  Assign it in
                    // the base class.
                    pNode->SetObjectId( mio.m_MediaId );
                    WsbAffirmHr( pNode->InitNode( m_pSakSnapAsk, 0, this ) );

                    //
                    // Add the child COM object to the parent's list of children.
                    //
                    WsbAffirmHr( AddChild( pNode ) );
                }

                hrEnum = mio.Next();
            }

            WsbAffirm( SUCCEEDED( hrEnum ) || ( WSB_E_NOTFOUND == hrEnum ), hrEnum );
        }
    } WsbCatch( hr );

    //
    // Indicate that this node's children are valid and up-to-date (even if there ARE
    // no children - at least now we know it).
    //
    m_bChildrenAreValid = TRUE;

    //
    // indicate that this parent node needs to be re-enumerated
    //
    m_bEnumState = FALSE;

    WsbTraceOut( L"CUiMedSet::CreateChildren", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//
//         InitNode
//
//  Initialize single COM object. Derived objects frequently augment this method 
//  by implementing it themselves.
//

STDMETHODIMP
CUiMedSet::InitNode(
    ISakSnapAsk* pSakSnapAsk,
    IUnknown*    pHsmObj,
    ISakNode*    pParent
    )
{
    WsbTraceIn( L"CUiMedSet::InitNode", L"pSakSnapAsk = <0x%p>, pHsmObj = <0x%p>, pParent = <0x%p>", pSakSnapAsk, pHsmObj, pParent );
    HRESULT hr = S_OK;

    try {

        WsbAffirmHr( CSakNode::InitNode( pSakSnapAsk, pHsmObj, pParent ) );


        //
        // Set Display Type and Description
        //

        CString tempString;
        tempString.LoadString( IDS_MEDSET_DISPLAYNAME );
        WsbAffirmHr( put_DisplayName( (OLECHAR *)(LPCWSTR)tempString ) );
        tempString.LoadString( IDS_MEDSET_TYPE );
        WsbAffirmHr( put_Type( (OLECHAR *)(LPCWSTR)tempString ) );
        tempString.LoadString( IDS_MEDSET_DESCRIPTION );
        WsbAffirmHr( put_Description( (OLECHAR *)(LPCWSTR)tempString ) );

        WsbAffirmHr( RefreshObject() );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiMedSet::InitNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP
CUiMedSet::TerminateNode(
    )
/*++

Routine Description:

    Free any interface connections or other resources
    that would prevent correct shutdown of node (would
    keep ref count from going to 0).

Arguments:

    CopySet - copy set of interest.

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_* - Some error occurred. 

--*/
{
    WsbTraceIn( L"CUiMedSet::TerminateNode", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // Release any interface pointers kept so that circular references
        // are broken
        //
        m_pStoragePool.Release( );
        m_pHsmServer.Release( );
        m_pRmsServer.Release( );


        //
        // And call the base class for it's pieces
        //
        WsbAffirmHr( CSakNode::TerminateNode( ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiMedSet::TerminateNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CUiMedSet::RefreshObject()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;

    try {

        m_NumCopySets        = 0;
        m_MediaCopiesEnabled = FALSE;

        WsbAssertPointer( m_pSakSnapAsk );

        //
        // If the engine is down, we want to create the node anyway
        // Need to release smart pointers so that interfaces are
        // correctly reference counted. IOW, if they already have
        // an interface pointer stored, it will not get released
        // before being clobbered here in the Get functions.
        //
        m_pHsmServer.Release( );
        m_pRmsServer.Release( );
        m_pStoragePool.Release( );

        if( m_pSakSnapAsk->GetHsmServer( &m_pHsmServer ) == S_OK ) {

            if( m_pSakSnapAsk->GetRmsServer( &m_pRmsServer ) == S_OK ) {

                //
                // Get the storage pool of interest
                //
                if( RsGetStoragePool( m_pHsmServer, &m_pStoragePool ) == S_OK ) {

                    //
                    // Contact data base and store necessary info
                    //
                    CMediaInfoObject mio;
                    mio.Initialize( GUID_NULL, m_pHsmServer, m_pRmsServer );
                    m_NumCopySets = mio.m_NumMediaCopies;

                    //
                    // Find out if media copies are supported
                    //
                    GUID mediaSetId;
                    CWsbBstrPtr mediaName;
                    WsbAffirmHr( m_pStoragePool->GetMediaSet( &mediaSetId, &mediaName ) );

                    CComPtr<IRmsMediaSet> pMediaSet;
                    WsbAffirmHr( m_pRmsServer->CreateObject( mediaSetId, CLSID_CRmsMediaSet, IID_IRmsMediaSet, RmsOpenExisting, (void**)&pMediaSet ) );

                    m_MediaCopiesEnabled = ( pMediaSet->IsMediaCopySupported( ) == S_OK );
                }
            }
        }

        //
        // Set up the result view columns
        // This changes with the number of media copies, so can't
        // do once in Init()
        //
        WsbAffirmHr( SetChildProps( RS_STR_RESULT_PROPS_MEDSET_IDS,
            IDS_RESULT_PROPS_MEDSET_TITLES, IDS_RESULT_PROPS_MEDSET_WIDTHS ) );
        m_cChildPropsShow = m_cChildProps - HSMADMIN_MAX_COPY_SETS + m_NumCopySets;

    } WsbCatch( hr );

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\device\prcar.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    PrCar.cpp

Abstract:

    Cartridge Property Pages.

Author:

    Rohde Wakefield [rohde]   15-Sep-1997

Revision History:

--*/

#include "stdafx.h"

#include "metalib.h"

#include "PrCar.h"
#include "ca.h"

static void RsAddDisabledText( CString & StatusString, BOOL Disabled )
{
    if( Disabled ) {

        CString disabledText;
        CString tempText;
        disabledText.LoadString( IDS_RECREATE_LOCATION_DISABLED );

        AfxFormatString2( tempText, IDS_RECREATE_STATUS_FORMAT, StatusString, disabledText );
        StatusString = tempText;

    }
}

static DWORD pStatusHelpIds[] = 
{

    IDC_NAME,               idh_media_master_name,
    IDC_NAME_LABEL,         idh_media_master_name,
    IDC_STATUS,             idh_media_master_status,
    IDC_STATUS_LABEL,       idh_media_master_status,
    IDC_CAPACITY,           idh_media_master_capacity,
    IDC_CAPACITY_LABEL,     idh_media_master_capacity,
    IDC_FREESPACE,          idh_media_master_free_space,
    IDC_FREESPACE_LABEL,    idh_media_master_free_space,
    IDC_MODIFIED,           idh_media_master_last_modified,
    IDC_MODIFIED_LABEL,     idh_media_master_last_modified,
    IDC_STATUS_1,           idh_media_copy1_status,
    IDC_COPY_1,             idh_media_copy1_status,
    IDC_STATUS_2,           idh_media_copy2_status,
    IDC_COPY_2,             idh_media_copy2_status,
    IDC_STATUS_3,           idh_media_copy3_status,
    IDC_COPY_3,             idh_media_copy3_status,

    0, 0
};

static DWORD pCopiesHelpIds[] = 
{

    IDC_MODIFIED,           idh_media_master_last_modified,
    IDC_MODIFIED_LABEL,     idh_media_master_last_modified,
    IDC_NAME_1_LABEL,       idh_media_copy1_name,
    IDC_NAME_1,             idh_media_copy1_name,
    IDC_NAME_2_LABEL,       idh_media_copy2_name,
    IDC_NAME_2,             idh_media_copy2_name,
    IDC_NAME_3_LABEL,       idh_media_copy3_name,
    IDC_NAME_3,             idh_media_copy3_name,
    IDC_STATUS_1,           idh_media_copy1_status,
    IDC_STATUS_1_LABEL,     idh_media_copy1_status,
    IDC_STATUS_2,           idh_media_copy2_status,
    IDC_STATUS_2_LABEL,     idh_media_copy2_status,
    IDC_STATUS_3,           idh_media_copy3_status,
    IDC_STATUS_3_LABEL,     idh_media_copy3_status,
    IDC_DELETE_1,           idh_media_copy1_delete_button,
    IDC_DELETE_2,           idh_media_copy2_delete_button,
    IDC_DELETE_3,           idh_media_copy3_delete_button,
    IDC_MODIFIED_1,         idh_media_copy1_last_modified,
    IDC_MODIFIED_1_LABEL,   idh_media_copy1_last_modified,
    IDC_MODIFIED_2,         idh_media_copy2_last_modified,
    IDC_MODIFIED_2_LABEL,   idh_media_copy2_last_modified,
    IDC_MODIFIED_3,         idh_media_copy3_last_modified,
    IDC_MODIFIED_3_LABEL,   idh_media_copy3_last_modified,

    0, 0
};

static DWORD pRecoverHelpIds[] = 
{
    IDC_RECREATE_MASTER,    idh_media_recreate_master_button,

    0, 0
};

/////////////////////////////////////////////////////////////////////////////
// CPropCartStatus property page

CPropCartStatus::CPropCartStatus( long resourceId ) : CSakPropertyPage( resourceId )
{
    //{{AFX_DATA_INIT(CPropCartStatus)
    //}}AFX_DATA_INIT

    m_pHelpIds = pStatusHelpIds;
    m_DlgID    = resourceId;
}


CPropCartStatus::~CPropCartStatus()
{
}

void CPropCartStatus::DoDataExchange(CDataExchange* pDX)
{
    CSakPropertyPage::DoDataExchange(pDX );
    //{{AFX_DATA_MAP(CPropCartStatus)
	//}}AFX_DATA_MAP
    if( IDD_PROP_CAR_STATUS == m_DlgID ) {

        DDX_Control(pDX, IDC_DESCRIPTION, m_Description);
        DDX_Control(pDX, IDC_NAME,        m_Name);

    }
}


BEGIN_MESSAGE_MAP(CPropCartStatus, CSakPropertyPage)
    //{{AFX_MSG_MAP(CPropCartStatus)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropCartStatus message handlers

typedef struct {
    int label, status;
} CONTROL_SET_GENERAL;

CONTROL_SET_GENERAL copyGeneral[] = {
    { IDC_COPY_1, IDC_STATUS_1 },
    { IDC_COPY_2, IDC_STATUS_2 },
    { IDC_COPY_3, IDC_STATUS_3 }
};

BOOL CPropCartStatus::OnInitDialog( )
{
    WsbTraceIn( L"CPropCartStatus::OnInitDialog", L"" );
    HRESULT hr = S_OK;
    CSakPropertyPage::OnInitDialog( );

    try {

        //
        // Get the Hsm Server
        //
        WsbAffirmHr( m_pParent->GetHsmServer( &m_pHsmServer ) );

        //
        // Get the Rms Server
        //
        WsbAffirmHr( ( (CUiCarSheet *)m_pParent )->GetRmsServer( &m_pRmsServer ) );

        //
        // Set multi-select boolean
        //
        m_bMultiSelect = ( m_pParent->IsMultiSelect() == S_OK );
        
        Refresh();

    } WsbCatch( hr );

    WsbTraceOut( L"CPropCartStatus::OnInitDialog", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( TRUE );
}

HRESULT CPropCartStatus::Refresh () 
{
    WsbTraceIn( L"CPropCartStatus::Refresh", L"" );

    GUID mediaId;
    USHORT status;
    CString statusString;
    CMediaInfoObject mio;
    CString sText;
    HRESULT hr = S_OK;
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    try {

        //
        // If refresh is called and the node is not initialized, do nothing
        //
        if( m_pHsmServer ) {

            //
            // Get the number of media copies from the sheet object
            //
            WsbAffirmHr( ( (CUiCarSheet *)m_pParent )->GetNumMediaCopies( &m_NumMediaCopies ) );

            if( !m_bMultiSelect ) {

                //
                // SINGLE SELECT
                //

                //
                // Get media info
                //
                ( (CUiCarSheet *)m_pParent )->GetMediaId( &mediaId );

                mio.Initialize( mediaId, m_pHsmServer, m_pRmsServer );

                //
                // Get info and set controls
                //
                SetDlgItemText( IDC_DESCRIPTION, mio.m_MasterDescription );
                SetDlgItemText( IDC_NAME,        mio.m_MasterName );
                
                status = RsGetCartStatus( mio.m_LastHr, mio.m_ReadOnly, mio.m_Recreating, mio.m_NextDataSet, mio.m_LastGoodNextDataSet );
                WsbAffirmHr( RsGetCartStatusString( status, statusString ) );
                RsAddDisabledText( statusString, mio.m_Disabled );

                SetDlgItemText( IDC_STATUS, statusString );

                //
                // Show capacity statistics
                //
                WsbAffirmHr( RsGuiFormatLongLong4Char( mio.m_Capacity, sText ) );
                SetDlgItemText( IDC_CAPACITY, sText );

                WsbAffirmHr( RsGuiFormatLongLong4Char( mio.m_FreeSpace, sText ) );
                SetDlgItemText( IDC_FREESPACE, sText );

                CTime time( mio.m_Modify );
                SetDlgItemText( IDC_MODIFIED, time.Format( L"%#c" ) );

                for( int index = 0; index < HSMADMIN_MAX_COPY_SETS; index++ ) {

                    GetDlgItem( copyGeneral[index].label )->EnableWindow( index < m_NumMediaCopies );
                    GetDlgItem( copyGeneral[index].status )->EnableWindow( index < m_NumMediaCopies );

                    status = RsGetCopyStatus( mio.m_CopyInfo[index].m_RmsId, mio.m_CopyInfo[index].m_Hr, mio.m_CopyInfo[index].m_NextDataSet, mio.m_LastGoodNextDataSet );
                    WsbAffirmHr( RsGetCopyStatusString( status, statusString ) );
                    RsAddDisabledText( statusString, mio.m_CopyInfo[index].m_Disabled );
                    SetDlgItemText( copyGeneral[index].status, statusString );

                }

            } else {

                //
                // Multi-Select
                //
                GUID mediaId;
                LONGLONG totalCapacity  = 0;
                LONGLONG totalFreeSpace = 0;
                USHORT statusCartRecreate  = 0;
                USHORT statusCartReadOnly  = 0;
                USHORT statusCartNormal    = 0;
                USHORT statusCartRO        = 0;
                USHORT statusCartRW        = 0;
                USHORT statusCartMissing   = 0;
                USHORT statusCopyNone[ HSMADMIN_MAX_COPY_SETS ];
                USHORT statusCopyError[ HSMADMIN_MAX_COPY_SETS ];
                USHORT statusCopyMissing[ HSMADMIN_MAX_COPY_SETS ];
                USHORT statusCopyOutSync[ HSMADMIN_MAX_COPY_SETS ];
                USHORT statusCopyInSync[ HSMADMIN_MAX_COPY_SETS ];

                //
                // initialize copy totals
                //
                for( int i = 0; i < HSMADMIN_MAX_COPY_SETS; i++ ) {

                    statusCopyNone[i]    = 0; 
                    statusCopyError[i]   = 0; 
                    statusCopyOutSync[i] = 0; 
                    statusCopyInSync[i]  = 0;

                }

                int bookMark = 0;
                int numMedia = 0;
                while( m_pParent->GetNextObjectId( &bookMark, &mediaId ) == S_OK ) {

                    numMedia++;
                    mio.Initialize( mediaId, m_pHsmServer, m_pRmsServer  );

                    //
                    // total up statuses
                    //
                    status = RsGetCartStatus( mio.m_LastHr, mio.m_ReadOnly, mio.m_Recreating, mio.m_NextDataSet, mio.m_LastGoodNextDataSet );
                    switch( status ) {

                    case RS_MEDIA_STATUS_RECREATE:
                        statusCartRecreate++;
                        break;

                    case RS_MEDIA_STATUS_READONLY:
                        statusCartReadOnly++;
                        break;

                    case RS_MEDIA_STATUS_NORMAL:
                        statusCartNormal++;
                        break;

                    case RS_MEDIA_STATUS_ERROR_RO:
                        statusCartRO++;
                        break;

                    case RS_MEDIA_STATUS_ERROR_RW:
                        statusCartRW++;
                        break;

                    case RS_MEDIA_STATUS_ERROR_MISSING:
                        statusCartMissing++;
                        break;

                    }

                    for( int index = 0; index < HSMADMIN_MAX_COPY_SETS; index++ ) {

                        int status = RsGetCopyStatus( mio.m_CopyInfo[index].m_RmsId, mio.m_CopyInfo[index].m_Hr, mio.m_CopyInfo[index].m_NextDataSet, mio.m_LastGoodNextDataSet );

                        //
                        // Total up the statuses
                        //
                        switch( status ) {

                        case RS_MEDIA_COPY_STATUS_NONE:
                            statusCopyNone[index]++;
                            break;

                        case RS_MEDIA_COPY_STATUS_ERROR:
                            statusCopyError[index]++;
                            break;

                        case RS_MEDIA_COPY_STATUS_MISSING:
                            statusCopyMissing[index]++;
                            break;

                        case RS_MEDIA_COPY_STATUS_OUTSYNC:
                            statusCopyOutSync[index]++;
                            break;

                        case RS_MEDIA_COPY_STATUS_INSYNC:
                            statusCopyInSync[index]++;
                            break;

                        }

                    }

                    totalCapacity  += mio.m_Capacity;
                    totalFreeSpace += mio.m_FreeSpace;

                } // While

                //
                // Display number of media selected
                //
                sText.Format( IDS_MEDIA, numMedia );
                SetDlgItemText( IDC_DESCRIPTION_MULTI, sText );

                //
                // Show the accumulated statistics
                //
                CString sText;
                WsbAffirmHr( RsGuiFormatLongLong4Char( totalCapacity, sText ) );
                SetDlgItemText( IDC_CAPACITY, sText );

                WsbAffirmHr( RsGuiFormatLongLong4Char( totalFreeSpace, sText ) );
                SetDlgItemText( IDC_FREESPACE, sText );

                //
                // Show the accumulated cart statuses
                //
                RsGetCartMultiStatusString( statusCartRecreate, statusCartReadOnly, 
                    statusCartNormal, statusCartRO, statusCartRW, statusCartMissing,
                    statusString );
                SetDlgItemText( IDC_STATUS, statusString );

                for( i = 0; i < HSMADMIN_MAX_COPY_SETS; i++ ) {

                    WsbAffirmHr( RsGetCopyMultiStatusString( statusCopyNone[i], 
                            statusCopyError[i], statusCopyOutSync[i], statusCopyInSync[i], statusString ) );
                    SetDlgItemText( copyGeneral[i].status, statusString );

                    GetDlgItem( copyGeneral[i].label )->EnableWindow( i < m_NumMediaCopies );
                    GetDlgItem( copyGeneral[i].status )->EnableWindow( i < m_NumMediaCopies );

                } // for
            }
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CPropCartStatus::Refresh", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

BOOL CPropCartStatus::OnApply( )
{
    WsbTraceIn( L"CPropCartStatus::OnApply", L"" );

    BOOL retVal = CSakPropertyPage::OnApply( );

    WsbTraceOut( L"CPropCartStatus::OnApply", L"" );
    return( retVal );
}


/////////////////////////////////////////////////////////////////////////////
// CPropCartCopies property page

CPropCartCopies::CPropCartCopies( long resourceId ) : CSakPropertyPage( resourceId )
{
    //{{AFX_DATA_INIT(CPropCartCopies)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    m_pHelpIds = pCopiesHelpIds;
    m_DlgID    = resourceId;
}

CPropCartCopies::~CPropCartCopies()
{
}

void CPropCartCopies::DoDataExchange(CDataExchange* pDX)
{
    CSakPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPropCartCopies)
	//}}AFX_DATA_MAP
    if( IDD_PROP_CAR_COPIES == m_DlgID ) {

        DDX_Control(pDX, IDC_NAME_3, m_Name3);
        DDX_Control(pDX, IDC_NAME_2, m_Name2);
        DDX_Control(pDX, IDC_NAME_1, m_Name1);

        DDX_Control(pDX, IDC_STATUS_3, m_Status3);
        DDX_Control(pDX, IDC_STATUS_2, m_Status2);
        DDX_Control(pDX, IDC_STATUS_1, m_Status1);
    }
}


BEGIN_MESSAGE_MAP(CPropCartCopies, CSakPropertyPage)
    //{{AFX_MSG_MAP(CPropCartCopies)
    ON_BN_CLICKED(IDC_DELETE_1, OnDelete1)
    ON_BN_CLICKED(IDC_DELETE_2, OnDelete2)
    ON_BN_CLICKED(IDC_DELETE_3, OnDelete3)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropCartCopies message handlers

typedef struct {

    int group,
        nameLabel,
        name,
        statusLabel,
        status,
        modifyLabel,
        modify,
        deleteCopy;

} CONTROL_SET_COPIES;

CONTROL_SET_COPIES copyCopies[] = {
    { IDC_COPY_1, IDC_NAME_1_LABEL, IDC_NAME_1, IDC_STATUS_1_LABEL, IDC_STATUS_1, IDC_MODIFIED_1_LABEL, IDC_MODIFIED_1, IDC_DELETE_1 },
    { IDC_COPY_2, IDC_NAME_2_LABEL, IDC_NAME_2, IDC_STATUS_2_LABEL, IDC_STATUS_2, IDC_MODIFIED_2_LABEL, IDC_MODIFIED_2, IDC_DELETE_2 },
    { IDC_COPY_3, IDC_NAME_3_LABEL, IDC_NAME_3, IDC_STATUS_3_LABEL, IDC_STATUS_3, IDC_MODIFIED_3_LABEL, IDC_MODIFIED_3, IDC_DELETE_3 }
};

BOOL CPropCartCopies::OnInitDialog() 
{
    WsbTraceIn( L"CPropCartCopies::OnInitDialog", L"" );
    HRESULT hr = S_OK;

    CSakPropertyPage::OnInitDialog( );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    try {

        //
        // Get the Hsm Server
        //
        WsbAffirmHr( m_pParent->GetHsmServer( &m_pHsmServer ) );

        //
        // Get the Rms Server
        //
        WsbAffirmHr( ( (CUiCarSheet* ) m_pParent )->GetRmsServer( &m_pRmsServer ) );

        //
        // Set multi-select boolean
        //
        m_bMultiSelect = ( m_pParent->IsMultiSelect() == S_OK );    

        Refresh();

    } WsbCatch( hr );

    WsbTraceOut( L"CPropCartCopies::OnInitDialog", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( TRUE );
}

HRESULT CPropCartCopies::Refresh( ) 
{
    WsbTraceIn( L"CPropCartCopies::Refresh", L"" );
    HRESULT hr = S_OK;

    GUID mediaId;
    CMediaInfoObject mio;

    try {
        //
        // Only refresh if we've been intialized
        //
        if( m_pHsmServer ) {

            //
            // Get the number of media copies from the sheet object
            //
            WsbAffirmHr( ( (CUiCarSheet *)m_pParent )->GetNumMediaCopies( &m_NumMediaCopies ) );

            if( !m_bMultiSelect ) {

                //
                // SINGLE SELECT
                //

                //
                // Get the media Id and initialize the info object
                //
                ( (CUiCarSheet *)m_pParent )->GetMediaId( &mediaId );
                mio.Initialize( mediaId,  m_pHsmServer, m_pRmsServer );

                //
                // Get info and set controls
                //
                CTime time( mio.m_Modify );
                SetDlgItemText( IDC_MODIFIED, time.Format( L"%#c" ) );


                //
                // Disable the controls for displaying info on non-existant
                // Copies. Fill in the info for copies that exist.
                //
                for( int index = 0; index < HSMADMIN_MAX_COPY_SETS; index++ ) {

                    BOOL mediaMissing = IsEqualGUID( mio.m_CopyInfo[index].m_RmsId, GUID_NULL );

                    GetDlgItem( copyCopies[index].group )->EnableWindow( index < m_NumMediaCopies );
                    GetDlgItem( copyCopies[index].nameLabel )->EnableWindow( index < m_NumMediaCopies );
                    GetDlgItem( copyCopies[index].name )->EnableWindow( index < m_NumMediaCopies );
                    GetDlgItem( copyCopies[index].statusLabel )->EnableWindow( index < m_NumMediaCopies );
                    GetDlgItem( copyCopies[index].status )->EnableWindow( index < m_NumMediaCopies );
                    GetDlgItem( copyCopies[index].modifyLabel )->EnableWindow( index < m_NumMediaCopies );
                    GetDlgItem( copyCopies[index].modify )->EnableWindow( index < m_NumMediaCopies );
                    GetDlgItem( copyCopies[index].deleteCopy )->EnableWindow( ! mediaMissing );

                    SetDlgItemText( copyCopies[index].name, L"" );
                    SetDlgItemText( copyCopies[index].status, L"" );
                    SetDlgItemText( copyCopies[index].modify, L"" );

                    USHORT status;
                    CString statusString;
                    status = RsGetCopyStatus( mio.m_CopyInfo[index].m_RmsId, mio.m_CopyInfo[index].m_Hr, mio.m_CopyInfo[index].m_NextDataSet, mio.m_LastGoodNextDataSet );
                    WsbAffirmHr( RsGetCopyStatusString( status, statusString ) );
                    RsAddDisabledText( statusString, mio.m_CopyInfo[index].m_Disabled );
                    SetDlgItemText( copyCopies[index].status, statusString );

                    if( !mediaMissing ) {

                        time = mio.m_CopyInfo[index].m_ModifyTime;
                        SetDlgItemText( copyCopies[index].modify, time.Format( L"%#c" ) );

                        CComPtr<IRmsCartridge> pCart;
                        CWsbBstrPtr name;
                        if( SUCCEEDED( m_pRmsServer->FindCartridgeById( mio.m_CopyInfo[index].m_RmsId, &pCart ) ) ) {

                            WsbAffirmHr( pCart->GetName( &name ) );

                        }
                        SetDlgItemText( copyCopies[index].name, name );

                    }

                }

            } else {

                //
                // MULTI-SELECT
                //
                BOOL bGotOne [HSMADMIN_MAX_COPY_SETS];
                int bookMark = 0;
                USHORT statusCopyNone [HSMADMIN_MAX_COPY_SETS];
                USHORT statusCopyError [HSMADMIN_MAX_COPY_SETS];
                USHORT statusCopyMissing [HSMADMIN_MAX_COPY_SETS];
                USHORT statusCopyOutSync [HSMADMIN_MAX_COPY_SETS];
                USHORT statusCopyInSync [HSMADMIN_MAX_COPY_SETS];

                //
                // initialize copy totals
                //
                for( int i = 0; i < HSMADMIN_MAX_COPY_SETS; i++ ) {
                    statusCopyNone[i] = 0; 
                    statusCopyError[i] = 0; 
                    statusCopyOutSync[i] = 0; 
                    statusCopyInSync[i] = 0;
                    bGotOne[i] = FALSE;
                }

                //
                // For each selected medium...
                //
                while( m_pParent->GetNextObjectId( &bookMark, &mediaId ) == S_OK ) {
                    mio.Initialize( mediaId,  m_pHsmServer, m_pRmsServer );

                    //
                    // Tally up the statuses for all valid copy sets
                    //
                    for( int index = 0; index < HSMADMIN_MAX_COPY_SETS; index++ ) {

                        //
                        //  Is there is at least one valid copy in this copyset
                        // for any of the selected media?
                        //
                        if( ! IsEqualGUID( mio.m_CopyInfo[index].m_RmsId, GUID_NULL ) ) {

                            bGotOne[index] = TRUE;

                        }

                        USHORT status;
                        CString statusString;
                        status = RsGetCopyStatus( mio.m_CopyInfo[index].m_RmsId, mio.m_CopyInfo[index].m_Hr, mio.m_CopyInfo[index].m_NextDataSet, mio.m_LastGoodNextDataSet );
                        // Total up the statuses
                        switch( status ) {

                        case RS_MEDIA_COPY_STATUS_NONE:
                            statusCopyNone[index]++;
                            break;

                        case RS_MEDIA_COPY_STATUS_ERROR:
                            statusCopyError[index]++;
                            break;

                        case RS_MEDIA_COPY_STATUS_MISSING:
                            statusCopyMissing[index]++;
                            break;

                        case RS_MEDIA_COPY_STATUS_OUTSYNC:
                            statusCopyOutSync[index]++;
                            break;

                        case RS_MEDIA_COPY_STATUS_INSYNC:
                            statusCopyInSync[index]++;
                            break;

                        } 
                    }
                } // while

                //
                // Show accumlated statuses for each valid copy set
                //
                CString statusString;
                for( i = 0; i < HSMADMIN_MAX_COPY_SETS; i++ ) {

                    WsbAffirmHr( RsGetCopyMultiStatusString( statusCopyNone[i], 
                            statusCopyError[i], statusCopyOutSync[i], statusCopyInSync[i], statusString ) );
                    SetDlgItemText( copyCopies[i].status, statusString );

                }

                //
                // Set control states
                //
                for( i = 0; i < HSMADMIN_MAX_COPY_SETS; i++ ) {

                    GetDlgItem( copyCopies[i].group )->EnableWindow( i < m_NumMediaCopies );
                    GetDlgItem( copyCopies[i].statusLabel )->EnableWindow( i < m_NumMediaCopies );
                    GetDlgItem( copyCopies[i].status )->EnableWindow( i < m_NumMediaCopies );
                    GetDlgItem( copyCopies[i].deleteCopy )->EnableWindow( bGotOne[i] );

                }
            }
        }
    } WsbCatch( hr );

    WsbTraceOut( L"CPropCartCopies::Refresh", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

void CPropCartCopies::OnDelete1() 
{
    OnDelete( 1 );
}

void CPropCartCopies::OnDelete2() 
{
    OnDelete( 2 );
}

void CPropCartCopies::OnDelete3() 
{
    OnDelete( 3 );
}

void CPropCartCopies::OnDelete( int Copy ) 
{
    WsbTraceIn( L"CPropCartCopies::OnDelete", L"Copy = <%d>", Copy );
    HRESULT hr = S_OK;

    CMediaInfoObject mio;
    GUID mediaId;

    try {

        if( !m_bMultiSelect ) {

            //
            // Single Select
            //
            CString confirm;

            //
            // Get the media Id and initialize the info object
            //
            ( (CUiCarSheet *)m_pParent )->GetMediaId( &mediaId );
            mio.Initialize( mediaId,  m_pHsmServer, m_pRmsServer );
            confirm.Format( IDS_CONFIRM_MEDIA_COPY_DELETE, Copy, mio.m_Description );

            if( IDYES == AfxMessageBox( confirm, MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2 ) ) {

                WsbAffirmHr( mio.DeleteCopy( Copy ) );

            }

        } else {

            //
            // Multi-Select
            // tally up the names of the selected media
            //
            int bookMark = 0;
            GUID mediaId;
            CString szMediaList = L"";
            BOOL bFirst = TRUE;
            while( m_pParent->GetNextObjectId( &bookMark, &mediaId ) == S_OK ) {

                mio.Initialize( mediaId,  m_pHsmServer, m_pRmsServer );
                
                //
                // Does the copy exist?
                //
                if( !IsEqualGUID( mio.m_CopyInfo[Copy - 1].m_RmsId, GUID_NULL ) ) {

                    //
                    // Put in commas after the first Id
                    //
                    if( !bFirst ) {

                        szMediaList += L", ";

                    } else {

                        bFirst = FALSE;

                    }
                    szMediaList += mio.m_Description;
                }
            }

            CString confirm;
            confirm.Format( IDS_CONFIRM_MEDIA_COPY_DELETE_MULTI, Copy, szMediaList );

            if( IDYES == AfxMessageBox( confirm, MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2 ) ) {

                bookMark = 0;
                while( m_pParent->GetNextObjectId( &bookMark, &mediaId ) == S_OK ) {

                    WsbAffirmHr( mio.Initialize( mediaId,  m_pHsmServer, m_pRmsServer ) );

                    //
                    // Does the copy exist?
                    //
                    if( !IsEqualGUID( mio.m_CopyInfo[Copy - 1].m_RmsId, GUID_NULL ) ) {

                        WsbAffirmHr( mio.DeleteCopy( Copy ) ); 

                    }
                }
            }
        }
        
        //
        // Now notify all the nodes
        //
        ( (CUiCarSheet *) m_pParent )-> OnPropertyChange( m_hConsoleHandle );

    } WsbCatch( hr );

    WsbTraceOut( L"CPropCartCopies::OnDelete", L"hr = <%ls>", WsbHrAsString( hr ) );
}

/////////////////////////////////////////////////////////////////////////////
// CPropCartRecover property page

CPropCartRecover::CPropCartRecover() : CSakPropertyPage(CPropCartRecover::IDD)
{
    //{{AFX_DATA_INIT(CPropCartRecover)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    m_pHelpIds = pRecoverHelpIds;
}

CPropCartRecover::~CPropCartRecover()
{
}

void CPropCartRecover::DoDataExchange(CDataExchange* pDX)
{
    CSakPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPropCartRecover)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropCartRecover, CSakPropertyPage)
    //{{AFX_MSG_MAP(CPropCartRecover)
        ON_BN_CLICKED(IDC_RECREATE_MASTER, OnRecreateMaster)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CPropCartRecover::OnRecreateMaster() 
{
    WsbTraceIn( L"CPropCartRecover::OnRecreateMaster", L"" );
    HRESULT hr = S_OK;

    CMediaInfoObject mio;
    GUID mediaId;

    try {

        //
        // For single select only!
        //
        WsbAssert( !m_bMultiSelect, E_FAIL );

        //
        // Get the media Id and initialize the info object
        //
        ( (CUiCarSheet *)m_pParent )->GetMediaId( &mediaId );
        mio.Initialize( mediaId,  m_pHsmServer, m_pRmsServer );
        WsbAffirmHr( mio.RecreateMaster() );

        //
        // Now notify all the nodes
        //
        ( (CUiCarSheet *) m_pParent )->OnPropertyChange( m_hConsoleHandle );

    } WsbCatch( hr );

    WsbTraceOut( L"CPropCartRecover::OnRecreateMaster", L"hr = <%ls>", WsbHrAsString( hr ) );
}

/////////////////////////////////////////////////////////////////////////////
// CPropCartRecover message handlers

BOOL CPropCartRecover::OnInitDialog() 
{
    WsbTraceIn( L"CPropCartRecover::OnInitDialog", L"" );
    HRESULT hr = S_OK;

    CSakPropertyPage::OnInitDialog();

    try {

        //
        // Set multi-select boolean
        //
        m_bMultiSelect = ( m_pParent->IsMultiSelect() == S_OK );    

        //
        // Get the Hsm Server
        //
        WsbAffirmHr( m_pParent->GetHsmServer( &m_pHsmServer ) );

        //
        // Get the Rms Server
        //
        WsbAffirmHr( ( (CUiCarSheet *) m_pParent )->GetRmsServer( &m_pRmsServer ) );

        Refresh( );

    } WsbCatch( hr );

    WsbTraceOut( L"CPropCartRecover::OnInitDialog", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( TRUE );
}
HRESULT CPropCartRecover::Refresh() 
{
    WsbTraceIn( L"CPropCartRecover::Refresh", L"" );
    HRESULT hr = S_OK;

    GUID mediaId;
    CMediaInfoObject mio;

    try {

        //
        // Only refresh if we've been initialized
        //
        if( m_pHsmServer ) {

            if( ! m_bMultiSelect ) {

                //
                // Get the number of media copies from the sheet object
                //
                WsbAffirmHr( ( (CUiCarSheet *) m_pParent )->GetNumMediaCopies( &m_NumMediaCopies ) );

                //
                // Get the media Id and initialize the info object
                //
                ( (CUiCarSheet *)m_pParent )->GetMediaId( &mediaId );
                mio.Initialize( mediaId,  m_pHsmServer, m_pRmsServer );

                //
                // SINGLE SELECT (this page is implemented for single-select only
                //
                BOOL enableRecreate = FALSE;
                for( int index = 0; index < HSMADMIN_MAX_COPY_SETS; index++ ) {

                    if( index < m_NumMediaCopies ) {

                        if( !IsEqualGUID( mio.m_CopyInfo[index].m_RmsId, GUID_NULL ) ) {

                            enableRecreate = TRUE;

                        }

                    } else {

                        SetDlgItemText( copyGeneral[index].status, L"" );

                    }

                }

                GetDlgItem( IDC_RECREATE_MASTER )->EnableWindow( enableRecreate );
            }
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CPropCartRecover::Refresh", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\device\ca.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Ca.cpp

Abstract:

    Cartridge Node Implementation.

Author:

    Rohde Wakefield   [rohde]   07-Aug-97

Revision History:

--*/



#include "stdafx.h"
#include "Ca.h"
#include "PrCar.h"

int CUiCar::m_nResultIcon      = AddResultImage( IDI_NODETAPE );
int CUiCar::m_nResultIconX     = AddResultImage( IDI_NODETAPEX );
int CUiCar::m_nResultIconD     = AddResultImage( IDI_NODETAPED );
// Not used
int CUiCar::m_nScopeCloseIcon  = AddScopeImage( IDI_NODETAPE );
int CUiCar::m_nScopeCloseIconX = AddScopeImage( IDI_NODETAPE );
int CUiCar::m_nScopeOpenIcon   = CUiCar::m_nScopeCloseIcon;
int CUiCar::m_nScopeOpenIconX  = CUiCar::m_nScopeCloseIconX;

/////////////////////////////////////////////////////////////////////////////
//
// CoComObjectRoot
//
/////////////////////////////////////////////////////////////////////////////


//---------------------------------------------------------------------------
//
//         FinalConstruct
//
//  Initialize this level of the object hierarchy
//

HRESULT CUiCar::FinalConstruct( )
{
    WsbTraceIn( L"CUiCar::FinalConstruct", L"" );

    m_rTypeGuid    = &cGuidCar;
    m_bIsContainer = FALSE;

    HRESULT hr = CSakNode::FinalConstruct( );

    m_bSupportsPropertiesSingle    = TRUE;
    m_bSupportsPropertiesMulti = TRUE;
    m_bSupportsDeleteSingle = FALSE;
    m_bSupportsDeleteMulti = FALSE;
    m_bSupportsRefreshSingle = TRUE;
    m_bSupportsRefreshMulti = FALSE;

    // Toolbar values
    INT i = 0;

#if 0 // MS does not want this button to show
    m_ToolbarButtons[i].nBitmap = 0;
    m_ToolbarButtons[i].idCommand = TB_CMD_CAR_COPIES;
    m_ToolbarButtons[i].idButtonText = IDS_TB_TEXT_CAR_COPIES;
    m_ToolbarButtons[i].idTooltipText = IDS_TB_TIP_CAR_COPIES;
    i++;
#endif

    m_ToolbarBitmap             = IDB_TOOLBAR_CAR;
    m_cToolbarButtons           = i;

    WsbTraceOut( L"CUiCar::FinalConstruct", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


//---------------------------------------------------------------------------
//
//         FinalRelease
//
//  Clean up this level of the object hierarchy
//

void CUiCar::FinalRelease( )
{
    WsbTraceIn( L"CUiCar::FinalRelease", L"" );

    CSakNode::FinalRelease( );

    WsbTraceOut( L"CUiCar::FinalRelease", L"" );
}

/////////////////////////////////////////////////////////////////////////////
//
// ISakNode
//
/////////////////////////////////////////////////////////////////////////////


//---------------------------------------------------------------------------
//
//         GetContextMenu
//
//  Return an HMENU to be used for context menus on this node.
//

STDMETHODIMP 
CUiCar::GetContextMenu( BOOL /*bMultiSelect*/, HMENU* phMenu )
{
    return( LoadContextMenu( IDR_CAR, phMenu ) );
}


//---------------------------------------------------------------------------
//
//         InvokeCommand
//
//  User has selected a command from the menu. Process it here.
//

STDMETHODIMP 
CUiCar::InvokeCommand( SHORT sCmd, IDataObject* pDataObject )
{
    WsbTraceIn( L"CUiCar::InvokeCommand", L"sCmd = <%d>", sCmd );

    CString theString;
    HRESULT hr = S_OK;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    switch (sCmd) {
    case ID_CAR_COPIES:
        ShowCarProperties( pDataObject, 1 );
        break;
    }

#if 0
    switch (sCmd) {
        case ID_CAR_ROOT_DELCARTRIDGE:
            theString.Format (L"Del Cartridge menu command for Car: %d", sCmd);
            AfxMessageBox(theString);
            break;
        
        default:
            theString.Format (L"Unknown menu command for Car: %d", sCmd);
            AfxMessageBox(theString);
            break;
    }
#endif

    WsbTraceOut( L"CUiCar::InvokeCommand", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CUiCar::OnToolbarButtonClick( IDataObject *pDataObject, long cmdId )
{
    WsbTraceIn( L"CUiCar::OnToolbarButtonClick", L"cmdId = <%d>", cmdId );
    HRESULT hr = S_OK;
    try {
        switch ( cmdId ) {
        case TB_CMD_CAR_COPIES:
            ShowCarProperties( pDataObject, 1 );
            break;
        }
    } WsbCatch( hr );
    WsbTraceOut( L"CUiCar::OnToolbarButtonClick", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

HRESULT CUiCar::ShowCarProperties (IDataObject *pDataObject, int initialPage)
{
    WsbTraceIn( L"CUiCar::ShowCarProperties", L"initialPage = <%d>", initialPage );

    HRESULT hr = S_OK;
    try {

        CComPtr<ISakNode> pSakNode;
        WsbAffirmHr( _InternalQueryInterface( IID_ISakNode, (void **) &pSakNode ) );
        WsbAffirmHr( m_pSakSnapAsk->ShowPropertySheet( pSakNode, pDataObject, initialPage ) );

    } WsbCatch (hr);

    WsbTraceOut( L"CUiCar::ShowCarProperties", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

//---------------------------------------------------------------------------
//
//         InitNode
//
//  Initialize single COM object.
//

STDMETHODIMP
CUiCar::InitNode(
    ISakSnapAsk* pSakSnapAsk,
    IUnknown*    pHsmObj,
    ISakNode*    pParent
    )
{
    WsbTraceIn( L"CUiCar::InitNode", L"pSakSnapAsk = <0x%p>, pHsmObj = <0x%p>, pParent = <0x%p>", pSakSnapAsk, pHsmObj, pParent );
    HRESULT hr = S_OK;

    try {

        // Note that this node must have it's objectId set before initnode is called.
        //
        // Init the lower layers. 
        //

        WsbAffirmHr( CSakNode::InitNode( pSakSnapAsk, 0, pParent ) );

        //
        // Set Display Type
        //
        CString tempString;
        tempString.LoadString( IDS_CAR_TYPE );
        WsbAffirmHr( put_Type( (OLECHAR *)(LPCWSTR)tempString ) );

        WsbAffirmHr( RefreshObject() );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiCar::InitNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP CUiCar::RefreshObject()
{
    WsbTraceIn( L"CUiCar::RefreshObject", L"" );
    HRESULT hr = S_OK;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CMediaInfoObject mio;
    try {

        CComPtr<IHsmServer> pHsmServer;
        WsbAffirmHrOk( m_pSakSnapAsk->GetHsmServer( &pHsmServer ) );

        CComPtr<IRmsServer> pRmsServer;
        WsbAffirmHrOk( m_pSakSnapAsk->GetRmsServer( &pRmsServer ) );

        //
        // Create a GUI media object and initialize it with the info
        //
        WsbAffirmHr( mio.Initialize( m_ObjectId, pHsmServer, pRmsServer ) );

        //
        // Copy information from the media info object to the node object
        //
        m_RmsIdMaster           = mio.m_RmsIdMaster;
        m_Type                  = mio.m_Type;
        m_FreeSpace             = mio.m_FreeSpace,
        m_Capacity              = mio.m_Capacity;
        m_LastHr                = mio.m_LastHr;
        m_ReadOnly              = mio.m_ReadOnly;
        m_Recreating            = mio.m_Recreating;
        m_MasterName            = mio.m_MasterName;
        m_Modify                = mio.m_Modify;
        m_NextDataSet           = mio.m_NextDataSet;
        m_LastGoodNextDataSet   = mio.m_LastGoodNextDataSet;
        m_Disabled              = mio.m_Disabled;

        WsbAffirmHr( put_Description( (LPWSTR)(LPCWSTR)mio.m_MasterDescription ) );
        WsbAffirmHr( put_DisplayName( (LPWSTR)(LPCWSTR)mio.m_Description ) );

        //
        // Update the media copy info
        //
        for( int i = 0; i < HSMADMIN_MAX_COPY_SETS; i++ ) {

            m_CopyInfo[i] = mio.m_CopyInfo[i];

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiCar::RefreshObject", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}




HRESULT
CUiCar::GetCopySetP(
    IN  int CopySet,
    OUT BSTR * pszValue
    )

/*++

Routine Description:

    Returns a string (BSTR) that describes the state of the
    given copy set.

Arguments:

    CopySet - copy set of interest.

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    WsbTraceIn( L"CUiCar::GetCopySetP", L"CopySet = <%d>, pszValue = <0x%p>", CopySet, pszValue );

    //
    // Three states - Up-to-date, Out-of-date, Error
    //

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    
    try {
        
        USHORT status;
        CString statusString;

        status = RsGetCopyStatus( m_CopyInfo[ CopySet - 1 ].m_RmsId, m_CopyInfo[ CopySet - 1 ].m_Hr, m_CopyInfo[ CopySet - 1 ].m_NextDataSet, m_LastGoodNextDataSet );
        WsbAffirmHr( RsGetCopyStatusString( status, statusString ) );

        *pszValue = SysAllocString( statusString );
        WsbAffirmPointer( *pszValue );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiCar::GetCopySetP", L"hr = <%ls>, pszValue = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( pszValue ) );
    return( hr );
}


STDMETHODIMP
CUiCar::get_CopySet1P_SortKey(
    OUT BSTR * pszValue
    )
{
    return( get_CopySet1P( pszValue ) );
}

STDMETHODIMP
CUiCar::get_CopySet2P_SortKey(
    OUT BSTR * pszValue
    )
{
    return( get_CopySet2P( pszValue ) );
}

STDMETHODIMP
CUiCar::get_CopySet3P_SortKey(
    OUT BSTR * pszValue
    )
{
    return( get_CopySet3P( pszValue ) );
}


STDMETHODIMP
CUiCar::get_CopySet1P(
    OUT BSTR * pszValue
    )

/*++

Routine Description:

    Returns a string (BSTR) that describes the state of the
    first copy set.

Arguments:

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    return( GetCopySetP( 1, pszValue ) );
}


STDMETHODIMP
CUiCar::get_CopySet2P(
    OUT BSTR * pszValue
    )

/*++

Routine Description:

    Returns a string (BSTR) that describes the state of the
    second copy set.

Arguments:

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    return( GetCopySetP( 2, pszValue ) );
}


STDMETHODIMP
CUiCar::get_CopySet3P(
    OUT BSTR * pszValue
    )

/*++

Routine Description:

    Returns a string (BSTR) that describes the state of the
    third copy set.

Arguments:

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    return( GetCopySetP( 3, pszValue ) );
}


STDMETHODIMP
CUiCar::get_MediaTypeP(
    OUT BSTR * pszValue
    )

/*++

Routine Description:

    Returns a string (BSTR) that describes the type of media.

Arguments:

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    
    try {
        
        CString retval;
        int resourceId = IDS_MEDTYPE_UNKNOWN;

        switch( m_Type ) {
        case HSM_JOB_MEDIA_TYPE_FIXED_MAG:
            resourceId = IDS_MEDTYPE_FIXED;
            break;

        case HSM_JOB_MEDIA_TYPE_REMOVABLE_MAG:
            resourceId = IDS_MEDTYPE_REMOVABLE;
            break;

        case HSM_JOB_MEDIA_TYPE_OPTICAL:
            resourceId = IDS_MEDTYPE_OPTICAL;
            break;

        case HSM_JOB_MEDIA_TYPE_TAPE:
            resourceId = IDS_MEDTYPE_TAPE;
            break;
        }

        retval.LoadString( resourceId );
        *pszValue = SysAllocString( retval );
        WsbAffirmPointer( *pszValue );

    } WsbCatch( hr );

    return( hr );
}


STDMETHODIMP
CUiCar::get_CapacityP(
    OUT BSTR * pszValue
    )

/*++

Routine Description:

    Returns a string (BSTR) that describes the capacity of 
    the cartridge.

Arguments:

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    HRESULT hr = S_OK;
    
    try {
        
        CString retval;
        WsbAffirmHr( RsGuiFormatLongLong4Char( m_Capacity, retval ) );

        *pszValue = SysAllocString( retval );
        WsbAffirmPointer( *pszValue );

    } WsbCatch( hr );

    return( hr );
}


STDMETHODIMP
CUiCar::get_CapacityP_SortKey(
    OUT BSTR * pszValue
    )

/*++

Routine Description:

    Returns a string (BSTR) that describes the capacity of 
    the cartridge.

Arguments:

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    HRESULT hr = S_OK;
    
    try {
        
        *pszValue = SysAlloc64BitSortKey( m_Capacity );
        WsbAffirmPointer( *pszValue );

    } WsbCatch( hr );

    return( hr );
}

STDMETHODIMP
CUiCar::get_FreeSpaceP(
    OUT BSTR * pszValue
    )

/*++

Routine Description:

    Returns a string (BSTR) that describes the free space on 
    the cartridge.

Arguments:

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    HRESULT hr = S_OK;
    
    try {
        
        CString retval;
        WsbAffirmHr( RsGuiFormatLongLong4Char( m_FreeSpace, retval ) );

        *pszValue = SysAllocString( retval );
        WsbAffirmPointer( *pszValue );

    } WsbCatch( hr );

    return( hr );
}


STDMETHODIMP
CUiCar::get_FreeSpaceP_SortKey(
    OUT BSTR * pszValue
    )

/*++

Routine Description:

    Returns a string (BSTR) that describes the free space on 
    the cartridge.

Arguments:

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    HRESULT hr = S_OK;
    
    try {
        
        *pszValue = SysAlloc64BitSortKey( m_FreeSpace );
        WsbAffirmPointer( *pszValue );

    } WsbCatch( hr );

    return( hr );
}


STDMETHODIMP
CUiCar::get_StatusP(
    OUT BSTR * pszValue
    )

/*++

Routine Description:

    Returns a string (BSTR) that describes the state of the media.

Arguments:

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_UNEXPECTED - Some error occurred. 

--*/

{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    
    try {
        USHORT status;
        CString statusString;
        status = RsGetCartStatus( m_LastHr, m_ReadOnly, m_Recreating, m_NextDataSet, m_LastGoodNextDataSet );
        WsbAffirmHr( RsGetCartStatusString( status, statusString ) );

        *pszValue = SysAllocString( statusString );
        WsbAffirmPointer( *pszValue );

    } WsbCatch( hr );

    return( hr );
}


STDMETHODIMP
CUiCar::get_StatusP_SortKey(
    OUT BSTR * pszValue
    )
{
    return( get_StatusP( pszValue ) );
}

//----------------------------------------------------------------------------
//
//      AddPropertyPages
//

STDMETHODIMP 
CUiCar::AddPropertyPages(
    IN  RS_NOTIFY_HANDLE handle,
    IN  IUnknown*        pUnkPropSheetCallback,
    IN  IEnumGUID*       pEnumObjectId, 
    IN  IEnumUnknown*    pEnumUnkNode
    )
{
    WsbTraceIn( L"CUiCar::AddPropertyPages", L"" );

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;

    try {

        //
        // Make sure we can still contact the engine before doing this
        // If not running, we shouldn't even exist so update parent
        //
        CComPtr<IHsmServer> pHsmServer;
        HRESULT hrRunning = m_pSakSnapAsk->GetHsmServer( &pHsmServer );
        if( S_FALSE == hrRunning ) {

            m_pSakSnapAsk->UpdateAllViews( m_pParent );

        }
        WsbAffirmHrOk( hrRunning );

        // Create an object to hold the pages
        CUiCarSheet *pCarPropertySheet = new CUiCarSheet;
        WsbAffirmAlloc( pCarPropertySheet );
        WsbAffirmHr( pCarPropertySheet->InitSheet( 
            handle, 
            pUnkPropSheetCallback, 
            (CSakNode *) this,
            m_pSakSnapAsk,
            pEnumObjectId,
            pEnumUnkNode
            ) );

        // Tell the object to add it's pages
        WsbAffirmHr( pCarPropertySheet->AddPropertyPages( ) );

    } WsbCatch ( hr );

    WsbTraceOut( L"CUiCar::AddPropertyPages", L"hr = <%ls>", WsbHrAsString( hr ) );
    return ( hr );
}

STDMETHODIMP
CUiCar::GetResultIcon(
    IN  BOOL bOK,
    OUT int* pIconIndex
    )
{
    WsbTraceIn( L"CUiCar::GetResultIcon", L"" ); 

    HRESULT hr = S_OK;

    try {

        if( m_Disabled ) {

            *pIconIndex = m_nResultIconD;

        } else {

            //
            // Check to make sure it's not deleted (or being deleted)
            // If so, put on the X
            //
            USHORT status;
            status = RsGetCartStatus( m_LastHr, m_ReadOnly, m_Recreating, m_NextDataSet, m_LastGoodNextDataSet );
            switch( status ) {
    
            case RS_MEDIA_STATUS_ERROR_MISSING:
                bOK = FALSE;
                break;

            }
            WsbAffirmHr( CSakNodeImpl<CUiCar>::GetResultIcon( bOK, pIconIndex ) );

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiCar::GetResultIcon", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//
// Class CUiCarSheet
//

HRESULT
CUiCarSheet::InitSheet(
            RS_NOTIFY_HANDLE handle, 
            IUnknown*        pUnkPropSheetCallback, 
            CSakNode*        pSakNode,
            ISakSnapAsk*     pSakSnapAsk,
            IEnumGUID*       pEnumObjectId,
            IEnumUnknown*    pEnumUnkNode
            ) 
{
    WsbTraceIn( L"CUiCarSheet::InitSheet", 
        L"handle <0x%p>, pUnkPropSheetCallback <0x%p>, pSakNode <0x%p>, pSakSnapAsk <0x%p>, pEnumObjectId <0x%p>, pEnumUnkNode <0x%p>",
        handle, pUnkPropSheetCallback, pSakNode, pSakSnapAsk, pEnumObjectId, pEnumUnkNode);

    HRESULT hr = S_OK;
    try {

        WsbAffirmHr( CSakPropertySheet::InitSheet( handle, pUnkPropSheetCallback, pSakNode, pSakSnapAsk, pEnumObjectId, pEnumUnkNode ) );

        m_pPropPageStatus = NULL;
        m_pPropPageCopies = NULL;
        m_pPropPageRecover = NULL;

        //
        // Save the object id (used in single select)
        //
        WsbAffirmHr( pSakNode->GetObjectId ( & m_mediaId ) );

        //
        // Get the Hsm Server
        //
        CComPtr <IHsmServer> pHsmServer;
        WsbAffirmHrOk( pSakSnapAsk->GetHsmServer( &pHsmServer ) );

        //
        // Get Number of Media Copies from engine and save
        //
        CComPtr<IHsmStoragePool> pPool;
        WsbAffirmHr( RsGetStoragePool( pHsmServer, &pPool ) );
        WsbAffirmHr( pPool->GetNumMediaCopies( &m_pNumMediaCopies ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiCarSheet::InitSheet", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}
    

HRESULT CUiCarSheet::GetNumMediaCopies (USHORT *pNumMediaCopies)
{
    WsbTraceIn( L"CUiCarSheet::GetNumMediaCopies", L"pNumMediaCopies = <0x%p>", pNumMediaCopies);
    *pNumMediaCopies = m_pNumMediaCopies;
    WsbTraceOut( L"CUiCarSheet::GetNumMediaCopies", L"*pNumMediaCopies = <%hu>", *pNumMediaCopies );
    return( S_OK );
}

HRESULT CUiCarSheet::AddPropertyPages()
{
    WsbTraceIn( L"CUiCarSheet::AddPropertyPages", L"");
    HRESULT hr = S_OK;
    try {
        // set the dll context so that MMC can find the resource.
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // --------------------- Status Page ----------------------------------
        long resourceId = ( IsMultiSelect() != S_OK ) ? IDD_PROP_CAR_STATUS : IDD_PROP_CAR_STATUS_MULTI;
        m_pPropPageStatus = new CPropCartStatus( resourceId );
        WsbAffirmAlloc( m_pPropPageStatus );

        WsbAffirmHr( AddPage( m_pPropPageStatus ) );

        // --------------------- Copies Page ----------------------------------
        resourceId = ( IsMultiSelect() != S_OK ) ? IDD_PROP_CAR_COPIES : IDD_PROP_CAR_COPIES_MULTI;
        m_pPropPageCopies = new CPropCartCopies( resourceId );
        WsbAffirmAlloc( m_pPropPageCopies );

        WsbAffirmHr( AddPage( m_pPropPageCopies ) );

        // --------------------- Recovery Page ----------------------------------

        // Only show this page for single select

        if( IsMultiSelect() != S_OK ) {

            m_pPropPageRecover = new CPropCartRecover();
            WsbAffirmAlloc( m_pPropPageRecover );

            WsbAffirmHr( AddPage( m_pPropPageRecover ) );
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiCarSheet::AddPropertyPages",  L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CUiCarSheet::GetMediaId (GUID *pMediaId)
{
    WsbTraceIn( L"CUiCarSheet::GetMediaId", L"");
    *pMediaId = m_mediaId;
    WsbTraceOut( L"CUiCarSheet::GetMediaId",  L"*pMediaId <%ls>", WsbGuidAsString( *pMediaId ));
    return S_OK;
}

HRESULT CUiCarSheet::OnPropertyChange( RS_NOTIFY_HANDLE hNotifyHandle )
{
    HRESULT hr = S_OK;
    try {

        //
        // Call the base class to notify MMC and refresh the result pane
        //
        CSakPropertySheet::OnPropertyChange( hNotifyHandle );

        // Refresh all our pages
        if( m_pPropPageStatus )  m_pPropPageStatus->Refresh();
        if( m_pPropPageCopies )  m_pPropPageCopies->Refresh();
        if( m_pPropPageRecover ) m_pPropPageRecover->Refresh();

    } WsbCatch( hr );

    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// CMediaInfoObject

CMediaInfoObject::CMediaInfoObject(  )
{
    WsbTraceIn( L"CMediaInfoObject::CMediaInfoObject", L"");
    m_MediaId        = GUID_NULL;
    m_RmsIdMaster    = GUID_NULL;
    m_NumMediaCopies = 0;
    for( int index = 0; index < HSMADMIN_MAX_COPY_SETS; index++ ) {

        m_CopyInfo[ index ].m_ModifyTime = WsbLLtoFT( 0 );
        m_CopyInfo[ index ].m_Hr = S_OK;
        m_CopyInfo[ index ].m_RmsId = GUID_NULL;

    }
    WsbTraceOut( L"CMediaInfoObject::CMediaInfoObject",  L"");
}

CMediaInfoObject::~CMediaInfoObject( )
{
    WsbTraceIn( L"CMediaInfoObject::~CMediaInfoObject", L"");

    // Release the entity first
    if( m_pMediaInfo ) {
        m_pMediaInfo = 0;
    }

    // Close the DB
    if( m_pDb ) {
        m_pDb->Close( m_pDbSession );
    }

    WsbTraceOut( L"CMediaInfoObject::~CMediaInfoObject",  L"");
}

HRESULT CMediaInfoObject::First( )
{
    HRESULT hr = S_OK;
    try {

        WsbAffirmPointer( m_pMediaInfo );
        WsbAffirmHr( m_pMediaInfo->First( ) );

        //
        // Get information
        //
        WsbAffirmHr( InternalGetInfo( ) );

    } WsbCatch ( hr );
    return( hr );
}

HRESULT CMediaInfoObject::Next( )
{
    HRESULT hr = S_OK;
    try {
        WsbAffirmPointer( m_pMediaInfo );
        WsbAffirmHr( m_pMediaInfo->Next() );

        // Get information
        WsbAffirmHr( InternalGetInfo() );

    } WsbCatch ( hr );
    return hr;
}
HRESULT CMediaInfoObject::DeleteCopy( int Copy )
{
    HRESULT hr = S_OK;
    try {
        GUID mediaSubsystemId;
        WsbAffirmHr( m_pMediaInfo->GetCopyMediaSubsystemId( (USHORT)Copy, &mediaSubsystemId ));

        // If the cartridge cannot be found we assume it
        // was already deallocated through the media manager UI.
        HRESULT hrRecycle = m_pRmsServer->RecycleCartridge( mediaSubsystemId, 0 );
        WsbAffirm( S_OK == hrRecycle || RMS_E_CARTRIDGE_NOT_FOUND == hrRecycle, hrRecycle );

        WsbAffirmHr( m_pMediaInfo->DeleteCopy( (USHORT)Copy ) );
        WsbAffirmHr( m_pMediaInfo->Write( ) );
    } WsbCatch (hr);
    return hr;
}

HRESULT CMediaInfoObject::RecreateMaster( )
{
    HRESULT hr = S_OK;
    try {

        SHORT copyToUse = 0;
        //
        // Before we do recreate master, let's make sure there
        // is an up-to-date copy available
        //
        BOOL goodCopyAvailable = FALSE;
        USHORT status;
        CComPtr<IRmsCartridge> pRmsCart;
        LONG type;

        for( int index = 0; index < m_NumMediaCopies && !goodCopyAvailable; index++ ) {

            status = RsGetCopyStatus( m_CopyInfo[ index ].m_RmsId, m_CopyInfo[ index ].m_Hr, m_CopyInfo[ index ].m_NextDataSet, m_LastGoodNextDataSet );

            if( RS_MEDIA_COPY_STATUS_INSYNC == status ) {

                //
                // Enabled?
                //
                if( ! m_CopyInfo[ index ].m_Disabled ) {

                    pRmsCart.Release( );
                    HRESULT hrFind = m_pRmsServer->FindCartridgeById( m_CopyInfo[ index ].m_RmsId, &pRmsCart );
                    if( SUCCEEDED( hrFind ) ) {

                        //
                        // Available without user intervention?
                        //
                        WsbAffirmHr( pRmsCart->GetLocation( &type, 0, 0, 0, 0, 0, 0, 0 ) );

                        switch( (RmsElement) type ) {

                        case RmsElementShelf:
                        case RmsElementOffSite:
                        case RmsElementUnknown:
                            break;

                        default:
                            goodCopyAvailable = TRUE;

                        }
                    }
                }
            }
        }

        if( !goodCopyAvailable ) {

            CRecreateChooseCopy dlg( this );
            if( IDOK == dlg.DoModal( ) ) {

                copyToUse = dlg.CopyToUse( );

            } else {

                //
                // Otherwise, cancel
                //
                WsbThrow( E_FAIL );

            }

        }

        WsbAffirmHr( RsCreateAndRunMediaRecreateJob( m_pHsmServer, m_pMediaInfo, m_MediaId, m_Description, copyToUse ) );

    } WsbCatch ( hr );
    return hr;
}


HRESULT CMediaInfoObject::Initialize( GUID mediaId, IHsmServer *pHsmServer, IRmsServer *pRmsServer )
{

//  Initialize can be called any number of times
//  Note: Initialize with GUID_NULL to start with the first record

    WsbTraceIn( L"CMediaInfoObject::Initialize", L"mediaId = <%ls>, pHsmServer = <0x%p>, pRmsServer = <%0x%0.8x>",
        WsbGuidAsString( mediaId ), pHsmServer, pRmsServer );
    HRESULT hr = S_OK;
    HRESULT hrInternal = S_OK;

    try {

        m_pHsmServer = pHsmServer;
        m_pRmsServer = pRmsServer;

        // If already initialized, don't re-open
        if( !m_pDb ) {
            WsbAffirmHr( pHsmServer->GetSegmentDb( &m_pDb ) );
            WsbAffirmHr( m_pDb->Open( &m_pDbSession ) );
            WsbAffirmHr( m_pDb->GetEntity( m_pDbSession, HSM_MEDIA_INFO_REC_TYPE,  IID_IMediaInfo, (void**)&m_pMediaInfo ) );
        }

        // Get the number of media sets
        CComPtr<IHsmStoragePool> pPool;
        WsbAffirmHr( RsGetStoragePool( m_pHsmServer, &pPool ) );
        WsbAffirmHr( pPool->GetNumMediaCopies( &m_NumMediaCopies ) );

        // If the caller supplied a GUID, find the corresponding record.  If not, start at
        // the beginning.
        if( IsEqualGUID( mediaId, GUID_NULL ) ) {
            // Don't throw an error on First, it's OK to not have any media
            try {

                if( SUCCEEDED( m_pMediaInfo->First() ) ) {

                    WsbAffirmHr( InternalGetInfo () );
                }

            } WsbCatch( hrInternal );
            
        } else {

            WsbAffirmHr( m_pMediaInfo->SetId( mediaId ) );
            WsbAffirmHr( m_pMediaInfo->FindEQ( ) );

            WsbAffirmHr( InternalGetInfo () );
        }
    } WsbCatch( hr );

    WsbTraceOut( L"CMediaInfoObject::Initialize", L"hr = <%ls>", WsbHrAsString( hr ) );

    return( hr );
}

HRESULT CMediaInfoObject::InternalGetInfo( )
{
    HRESULT            hr = S_OK;
    CWsbStringPtr      name;
    CWsbStringPtr      description;
    LONGLONG           logicalValidBytes;
    GUID               storagePool;

    try {

        //
        // Get information about the last known good master so that we
        // have a true reference whether a copy is up-to-date or not,
        // and whether a recreated master is complete or not.
        //
        GUID        unusedGuid1;
        GUID        unusedGuid2; // NOTE: Use multiples so the trace in GetLastKnownGoodMasterInfo works
        GUID        unusedGuid3; // NOTE: Use multiples so the trace in GetLastKnownGoodMasterInfo works
        LONGLONG    unusedLL1;
        LONGLONG    unusedLL2;   // NOTE: Use multiples so the trace in GetLastKnownGoodMasterInfo works
        BOOL        unusedBool;
        HRESULT     unusedHr;
        FILETIME    unusedFt;
        HSM_JOB_MEDIA_TYPE unusedJMT;

        m_Disabled = FALSE;

        WsbAffirmHr( m_pMediaInfo->GetLastKnownGoodMasterInfo(
            &unusedGuid1, &unusedGuid2, &unusedGuid3, &unusedLL1, &unusedLL2,
            &unusedHr, &description, 0, &unusedJMT, &name, 0, &unusedBool, &unusedFt,
            &m_LastGoodNextDataSet ) );
        name.Free( );
        description.Free( );

        //
        // Get the standard media info
        //
        WsbAffirmHr( m_pMediaInfo->GetMediaInfo( 
            &m_MediaId,        &m_RmsIdMaster,      &storagePool,
            &m_FreeSpace,      &m_Capacity,         &m_LastHr,
            &m_NextDataSet,    &description, 0,     &m_Type,
            &name, 0,          &m_ReadOnly,         &m_Modify,
            &logicalValidBytes, &m_Recreating ) );

        m_Name        = name;
        m_Description = description;

        //
        // Get info about the copy sets. Note that we grab all
        // info, not just up to the number of copys set by user
        //
        USHORT index;
        USHORT status;
        for( index = 0; index < HSMADMIN_MAX_COPY_SETS; index++ ) {

            description.Free( );
            name.Free( );

            m_CopyInfo[index].m_Disabled = FALSE;

            //
            // copy sets are 1 based.
            //
            WsbAffirmHr( m_pMediaInfo->GetCopyInfo( (USHORT)( index + 1 ),
                &(m_CopyInfo[index].m_RmsId), &description, 0, &name, 0,
                &(m_CopyInfo[index].m_ModifyTime),
                &(m_CopyInfo[index].m_Hr),
                &(m_CopyInfo[index].m_NextDataSet) ) );


            status = RsGetCopyStatus( m_CopyInfo[ index ].m_RmsId, m_CopyInfo[ index ].m_Hr, m_CopyInfo[ index ].m_NextDataSet, m_LastGoodNextDataSet );

            if ( status != RS_MEDIA_COPY_STATUS_NONE ) {

                if( m_pRmsServer ) {

                    //
                    // Make sure the cartridge is still available.
                    //
                    CComPtr<IRmsCartridge> pRmsCart;
                    HRESULT hrFind = m_pRmsServer->FindCartridgeById( m_CopyInfo[index].m_RmsId, &pRmsCart );
                    if( FAILED( hrFind ) ) {

                        //
                        // Didn't find cartridge, may have been deallocated
                        // Show that there is a problem and use what info we have
                        //
                        m_CopyInfo[index].m_Hr = hrFind;

                    } else {

                        //
                        // Is Cartridge disabled?
                        //
                        CComPtr<IRmsComObject> pCartCom;
                        WsbAffirmHr( pRmsCart.QueryInterface( &pCartCom ) );
                        if( pCartCom->IsEnabled( ) == S_FALSE ) {

                            m_CopyInfo[index].m_Disabled = TRUE;

                        }
                    }
                }
            }
        }

        if( m_pRmsServer ) {

            //
            // Get the corresponding RmsCartridge object
            //
            CComPtr<IRmsCartridge> pRmsCart;
            HRESULT hrFind = m_pRmsServer->FindCartridgeById( m_RmsIdMaster, &pRmsCart );

            if( SUCCEEDED( hrFind ) ) {


                //
                // Is Cartridge disabled?
                //
                CComPtr<IRmsComObject> pCartCom;
                WsbAffirmHr( pRmsCart.QueryInterface( &pCartCom ) );
                if( pCartCom->IsEnabled( ) == S_FALSE ) {

                    m_Disabled = TRUE;

                }

                //
                // Fill out internal info
                //
                CWsbBstrPtr bstr;
                WsbAffirmHr( pRmsCart->GetName( &bstr ) );
                if( wcscmp( bstr, L"" ) == 0 ) {

                    m_MasterName.Format( IDS_CAR_NAME_UNKNOWN );

                } else {

                    m_MasterName = bstr;

                }

                bstr.Free( );
                WsbAffirmHr( pRmsCart->GetDescription( &bstr ) );
                m_MasterDescription = bstr;

            } else {

                //
                // Didn't find cartridge, may have been deallocated
                // Show that there is a problem and use what info we have
                //
                m_LastHr = hrFind;

            }
        }

    } WsbCatch( hr );
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// CRecreateChooseCopy dialog


CRecreateChooseCopy::CRecreateChooseCopy(CMediaInfoObject * pMio, CWnd* pParent /*=NULL*/)
    : CDialog(CRecreateChooseCopy::IDD, pParent), m_pMio( pMio ), m_CopyToUse( 0 )
{
    //{{AFX_DATA_INIT(CRecreateChooseCopy)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}


void CRecreateChooseCopy::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRecreateChooseCopy)
    DDX_Control(pDX, IDC_RECREATE_COPY_LIST, m_List);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRecreateChooseCopy, CDialog)
    //{{AFX_MSG_MAP(CRecreateChooseCopy)
    ON_NOTIFY(NM_CLICK, IDC_RECREATE_COPY_LIST, OnClickList)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRecreateChooseCopy message handlers
SHORT CRecreateChooseCopy::CopyToUse( void )
{
    WsbTraceIn( L"CRecreateChooseCopy::CopyToUse", L"" );

    SHORT copyToUse = m_CopyToUse;

    WsbTraceOut( L"CRecreateChooseCopy::CopyToUse", L"copyToUse = <%hd>", copyToUse );
    return( copyToUse );
}

void CRecreateChooseCopy::OnClickList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    WsbTraceIn( L"CRecreateChooseCopy::OnClickList", L"" );

    NMLISTVIEW *pNMLV = (NMLISTVIEW*)pNMHDR;    

    int index = pNMLV->iItem;
    BOOL enableOk = FALSE;

    if( ( index >= 0 ) && ( index < m_pMio->m_NumMediaCopies ) ) {

        if( ! m_pMio->m_CopyInfo[ index ].m_Disabled ) {

            USHORT status;
            status = RsGetCopyStatus( m_pMio->m_CopyInfo[ index ].m_RmsId, m_pMio->m_CopyInfo[ index ].m_Hr, m_pMio->m_CopyInfo[ index ].m_NextDataSet, m_pMio->m_LastGoodNextDataSet );

            switch( status ) {

            case RS_MEDIA_COPY_STATUS_NONE:
            case RS_MEDIA_COPY_STATUS_MISSING:

                //
                // Do not allow
                //
                break;


            case RS_MEDIA_COPY_STATUS_OUTSYNC:
            case RS_MEDIA_COPY_STATUS_INSYNC:
            case RS_MEDIA_COPY_STATUS_ERROR:

                enableOk = TRUE;
                m_CopyToUse = (USHORT)( index + 1 );
                break;

            }
        }
    }

    GetDlgItem( IDOK )->EnableWindow( enableOk );

    *pResult = 0;
    WsbTraceOut( L"CRecreateChooseCopy::OnClickList", L"" );
}

BOOL CRecreateChooseCopy::OnInitDialog() 
{
    WsbTraceIn( L"CRecreateChooseCopy::OnInitDialog", L"" );
    HRESULT hr = S_OK;

    try {

        CDialog::OnInitDialog();

        //
        // Disable the OK button until something appropriate is selected
        //
        GetDlgItem( IDOK )->EnableWindow( FALSE );

        //
        // Set the style appropriately
        //
        ListView_SetExtendedListViewStyle( m_List.GetSafeHwnd( ), LVS_EX_FULLROWSELECT );

        //
        // Also need to calculate some buffer space
        // Use 8 dialog units (for numeral)
        //
        CRect padRect( 0, 0, 8, 8 );
        MapDialogRect( padRect );

        //
        // Set up columns
        //
        CString title;
        int column = 0;
        int width, widthDateTitle, widthSum = 0;

        m_ColCopy = column++;
        title.LoadString( IDS_RECREATE_COL_COPY_WIDTH );
        width = m_List.GetStringWidth( title ) + padRect.Width( );
        widthSum += width;
        title.LoadString( IDS_RECREATE_COL_COPY_TITLE );
        m_List.InsertColumn( m_ColCopy, title, LVCFMT_LEFT, width );

        m_ColName = column++;
        title.LoadString( IDS_RECREATE_COL_NAME_WIDTH );
        width = m_List.GetStringWidth( title ) + padRect.Width( );
        widthSum += width;
        title.LoadString( IDS_RECREATE_COL_NAME_TITLE );
        m_List.InsertColumn( m_ColName, title, LVCFMT_LEFT, width );

        m_ColStatus = column++;
        title.LoadString( IDS_RECREATE_COL_STATUS_WIDTH );
        width = m_List.GetStringWidth( title ) + padRect.Width( );
        widthSum += width;
        title.LoadString( IDS_RECREATE_COL_STATUS_TITLE );
        m_List.InsertColumn( m_ColStatus, title, LVCFMT_LEFT, width );

        m_ColDate = column++;
        title.LoadString( IDS_RECREATE_COL_DATE_TITLE );
        m_List.InsertColumn( m_ColDate, title );
        widthDateTitle = m_List.GetStringWidth( title );

        //
        // Date gets what is left in width
        //
        CRect viewRect;
        m_List.GetClientRect( &viewRect );
        m_List.SetColumnWidth( m_ColDate, max( widthDateTitle, viewRect.Width( ) - widthSum ) );

        //
        // Fill in list view
        //
        CComPtr<IRmsCartridge> pRmsCart;
        CWsbBstrPtr name;
        USHORT status;
        CString statusString1, statusString2;
        LONG type;
        for( int index = 0; index < m_pMio->m_NumMediaCopies; index++ ) {

            title.Format( IDS_RECREATE_COPY_FORMAT, index + 1 );
            m_List.InsertItem( index, title );

            status = RsGetCopyStatus(
                m_pMio->m_CopyInfo[ index ].m_RmsId,
                m_pMio->m_CopyInfo[ index ].m_Hr,
                m_pMio->m_CopyInfo[ index ].m_NextDataSet,
                m_pMio->m_LastGoodNextDataSet );
            WsbAffirmHr( RsGetCopyStatusString( status, statusString1 ) );

            if( RS_MEDIA_COPY_STATUS_NONE == status ) {

                title = statusString1;

            } else {

                type = RmsElementUnknown;
                pRmsCart.Release( );
                HRESULT hrFind = m_pMio->m_pRmsServer->FindCartridgeById( m_pMio->m_CopyInfo[ index ].m_RmsId, &pRmsCart );

                if( SUCCEEDED( hrFind ) ) {

                    name.Free( );
                    WsbAffirmHr( pRmsCart->GetName( &name ) );
                    m_List.SetItemText( index, m_ColName, name );

                    WsbAffirmHr( pRmsCart->GetLocation( &type, 0, 0, 0, 0, 0, 0, 0 ) );

                }

                if( m_pMio->m_CopyInfo[ index ].m_Disabled ) {

                    statusString2.LoadString( IDS_RECREATE_LOCATION_DISABLED );

                } else {

                    switch( (RmsElement) type ) {

                    case RmsElementShelf:
                    case RmsElementOffSite:
                        statusString2.LoadString( IDS_RECREATE_LOCATION_OFFLINE );
                        break;

                    case RmsElementUnknown:
                        statusString2.LoadString( IDS_RECREATE_LOCATION_UNKNOWN );
                        break;

                    default:
                        statusString2.LoadString( IDS_RECREATE_LOCATION_ONLINE );

                    }

                }

                AfxFormatString2( title, IDS_RECREATE_STATUS_FORMAT, statusString1, statusString2 );

                CTime time( m_pMio->m_CopyInfo[ index ].m_ModifyTime );
                m_List.SetItemText( index, m_ColDate, time.Format( L"%c" ) );

            }
            m_List.SetItemText( index, m_ColStatus, title );

        }

    } WsbCatch( hr );
    
    WsbTraceOut( L"CRecreateChooseCopy::OnInitDialog", L"" );
    return TRUE;
}

void CRecreateChooseCopy::OnOK() 
{
    //
    // Before passing on the OK, check to see if the selected copy is
    // cause for one last warning before continuing i.e. out-of-date or
    // errored copy
    //
    BOOL okToContinue = FALSE;
    int index = m_CopyToUse - 1;

    if( ( index >= 0 ) && ( index < m_pMio->m_NumMediaCopies ) ) {

        if( ! m_pMio->m_CopyInfo[ index ].m_Disabled ) {

            USHORT status;
            status = RsGetCopyStatus( m_pMio->m_CopyInfo[ index ].m_RmsId, m_pMio->m_CopyInfo[ index ].m_Hr, m_pMio->m_CopyInfo[ index ].m_NextDataSet, m_pMio->m_LastGoodNextDataSet );

            switch( status ) {

            case RS_MEDIA_COPY_STATUS_NONE:
            case RS_MEDIA_COPY_STATUS_MISSING:

                //
                // Do not allow
                //
                break;


            case RS_MEDIA_COPY_STATUS_INSYNC:

                okToContinue = TRUE;
                break;


            case RS_MEDIA_COPY_STATUS_OUTSYNC:
            case RS_MEDIA_COPY_STATUS_ERROR:
                {

                    CString confirm, format;
                    format.LoadString( IDS_CONFIRM_MEDIA_RECREATE );
                    LPCWSTR description = m_pMio->m_Description;
                    AfxFormatStrings( confirm, format, &description, 1 );

                    if( IDYES == AfxMessageBox( confirm, MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2 ) ) {

                        okToContinue = TRUE;

                    }
                }
                break;

            }
        }
    }

    if( okToContinue ) {

        CDialog::OnOK();

    }
}

HRESULT CMediaInfoObject::DoesMasterExist( )
{
    return( 
        ( GUID_NULL != m_MediaId ) && 
        ( RMS_E_CARTRIDGE_NOT_FOUND != m_LastHr ) ? S_OK : S_FALSE );
}
HRESULT CMediaInfoObject::DoesCopyExist(INT Copy)
{
    return( 
        ( GUID_NULL != m_CopyInfo[Copy].m_RmsId ) && 
        ( RMS_E_CARTRIDGE_NOT_FOUND != m_CopyInfo[Copy].m_Hr ) ? S_OK : S_FALSE );
}

HRESULT CMediaInfoObject::IsCopyInSync(INT Copy)
{
    if( RS_MEDIA_COPY_STATUS_INSYNC ==
        RsGetCopyStatus(
            m_CopyInfo[Copy].m_RmsId,
            S_OK, // ignore errors in copy
            m_CopyInfo[Copy].m_NextDataSet,
            m_LastGoodNextDataSet ) ) {

        return S_OK;

    }

    return( S_FALSE );
}

HRESULT CMediaInfoObject::IsViewable( BOOL ConsiderInactiveCopies )
{
    HRESULT hr = S_FALSE;

    if( S_OK == DoesMasterExist( ) ) {

        hr = S_OK;

    } else {

        //
        // Look to see if any of the copies exist
        //
        INT lastCopy = ConsiderInactiveCopies ? HSMADMIN_MAX_COPY_SETS : m_NumMediaCopies;

        for( INT index = 0; index < lastCopy; index++ ) {

            if( S_OK == DoesCopyExist( index ) ) {

                hr = S_OK;
                break;

            }
        }
    }

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\device\prcar.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    PrCar.cpp

Abstract:

    Cartridge Property Pages.

Author:

    Rohde Wakefield [rohde]   15-Sep-1997

Revision History:

--*/

#ifndef _PRCAR_H
#define _PRCAR_H

#include "Ca.h"

class CMediaInfoObject;
/////////////////////////////////////////////////////////////////////////////
// CPropCartStatus dialog

class CPropCartStatus : public CSakPropertyPage
{
// Construction
public:
    CPropCartStatus( long resourceId );
    ~CPropCartStatus();

// Dialog Data
    //{{AFX_DATA(CPropCartStatus)
	enum { IDD = IDD_PROP_CAR_STATUS };
	CRsGuiOneLiner	m_Description;
	CRsGuiOneLiner	m_Name;
	//}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPropCartStatus)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CPropCartStatus)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    CComPtr <IHsmServer> m_pHsmServer;
    CComPtr <IRmsServer> m_pRmsServer;
    HRESULT Refresh();

private:
    USHORT m_NumMediaCopies;
    BOOL   m_bMultiSelect;
    UINT   m_DlgID;

};

/////////////////////////////////////////////////////////////////////////////
// CPropCartCopies dialog

class CPropCartCopies : public CSakPropertyPage
{
// Construction
public:
    CPropCartCopies( long resourceId );
    ~CPropCartCopies();

// Dialog Data
    //{{AFX_DATA(CPropCartCopies)
	enum { IDD = IDD_PROP_CAR_COPIES };
	//}}AFX_DATA
	CRsGuiOneLiner	m_Name3;
	CRsGuiOneLiner	m_Name2;
	CRsGuiOneLiner	m_Name1;
	CRsGuiOneLiner	m_Status3;
	CRsGuiOneLiner	m_Status2;
	CRsGuiOneLiner	m_Status1;


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPropCartCopies)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CPropCartCopies)
    virtual BOOL OnInitDialog();
    afx_msg void OnDelete1();
    afx_msg void OnDelete2();
    afx_msg void OnDelete3();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    CComPtr <IHsmServer> m_pHsmServer;
    CComPtr <IRmsServer> m_pRmsServer;
    HRESULT Refresh();

private:
    USHORT m_NumMediaCopies;
    void   OnDelete( int Copy );
    BOOL   m_bMultiSelect;
    UINT   m_DlgID;
};
/////////////////////////////////////////////////////////////////////////////
// CPropCartRecover dialog

class CPropCartRecover : public CSakPropertyPage
{
// Construction
public:
    CPropCartRecover();
    ~CPropCartRecover();

// Dialog Data
    //{{AFX_DATA(CPropCartRecover)
    enum { IDD = IDD_PROP_CAR_RECOVER };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPropCartRecover)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CPropCartRecover)
    virtual BOOL OnInitDialog();
    afx_msg void OnRecreateMaster();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    USHORT m_NumMediaCopies;
    BOOL   m_bMultiSelect;

public:
    CComPtr <IHsmServer>    m_pHsmServer;
    CComPtr <IRmsServer>    m_pRmsServer;
    HRESULT Refresh();
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX
#endif // _PRCAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\device\prmedset.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    PrMedSet.h

Abstract:

    Media Set Property Pages.

Author:

    Rohde Wakefield [rohde]   15-Sep-1997

Revision History:

--*/

#ifndef _PRMEDSET_H
#define _PRMEDSET_H

/////////////////////////////////////////////////////////////////////////////
// CPrMedSet dialog

class CPrMedSet : public CSakPropertyPage
{
// Construction
public:
    CPrMedSet();
    ~CPrMedSet();

// Dialog Data
    //{{AFX_DATA(CPrMedSet)
    enum { IDD = IDD_PROP_MEDIA_COPIES };
    CSpinButtonCtrl m_spinMediaCopies;
    UINT    m_numMediaCopies;
    CString m_szDescription;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPrMedSet)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CPrMedSet)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeEditMediaCopies();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    CComPtr<IHsmStoragePool> m_pStoragePool;
    CComPtr<IRmsServer>      m_pRmsServer;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\device\prmedset.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    PrMedSet.cpp

Abstract:

    Media Set Property Page.

Author:

    Art Bragg [abragg]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include "PrMedSet.h"
#include "WzMedSet.h"

static DWORD pHelpIds[] = 
{

    IDC_EDIT_MEDIA_COPIES,      idh_media_number_of_copy_sets,
    IDC_SPIN_MEDIA_COPIES,      idh_media_number_of_copy_sets,
    IDC_TEXT_MEDIA_COPIES,      idh_media_number_of_copy_sets,

    0, 0
};

/////////////////////////////////////////////////////////////////////////////
// CPrMedSet property page

CPrMedSet::CPrMedSet() : CSakPropertyPage(CPrMedSet::IDD)
{
    //{{AFX_DATA_INIT(CPrMedSet)
    m_numMediaCopies = 0;
    //}}AFX_DATA_INIT
    m_pHelpIds = pHelpIds;
}

CPrMedSet::~CPrMedSet()
{
}

void CPrMedSet::DoDataExchange(CDataExchange* pDX)
{
    CSakPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPrMedSet)
    DDX_Control(pDX, IDC_SPIN_MEDIA_COPIES, m_spinMediaCopies);
    DDX_Text(pDX, IDC_EDIT_MEDIA_COPIES, m_numMediaCopies);
    DDV_MinMaxUInt(pDX, m_numMediaCopies, 0, 3);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPrMedSet, CSakPropertyPage)
    //{{AFX_MSG_MAP(CPrMedSet)
    ON_WM_DESTROY()
    ON_EN_CHANGE(IDC_EDIT_MEDIA_COPIES, OnChangeEditMediaCopies)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPrMedSet message handlers

BOOL CPrMedSet::OnInitDialog() 
{
    HRESULT hr = S_OK;
    HRESULT hrSupported = S_OK;
    CSakPropertyPage::OnInitDialog();
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    try {

        //
        // Set the limit on the spinner
        //
        m_spinMediaCopies.SetRange( 0, 3 );

        //
        // Get the single storage pool pointer
        //
        CComPtr<IHsmServer> pEngine;
        WsbAffirmHr( m_pParent->GetHsmServer( &pEngine ) );
        WsbAffirmHr( RsGetStoragePool( pEngine, &m_pStoragePool ) );
        WsbAffirmHr( m_pParent->GetRmsServer( &m_pRmsServer ) );

        GUID mediaSetId;
        CWsbBstrPtr mediaName;
        WsbAffirmHr( m_pStoragePool->GetMediaSet( &mediaSetId, &mediaName ) );

        CComPtr<IRmsMediaSet> pMediaSet;
        WsbAffirmHr( m_pRmsServer->CreateObject( mediaSetId, CLSID_CRmsMediaSet, IID_IRmsMediaSet, RmsOpenExisting, (void**)&pMediaSet ) );

        //
        // Set up control states
        // If we support media copies, enable controls
        // If we don't support media copies, disable and show reason text
        // If error, disable and don't show reason text
        //
        hrSupported = pMediaSet->IsMediaCopySupported( );
        GetDlgItem( IDC_TEXT_MEDIA_COPIES )->EnableWindow( S_OK == hrSupported );
        GetDlgItem( IDC_EDIT_MEDIA_COPIES )->EnableWindow( S_OK == hrSupported );
        GetDlgItem( IDC_SPIN_MEDIA_COPIES )->EnableWindow( S_OK == hrSupported );

        //
        // And initialize control
        //
        USHORT numMediaCopies;
        WsbAffirmHr( m_pStoragePool->GetNumMediaCopies( &numMediaCopies ) );
        m_numMediaCopies = numMediaCopies;
        UpdateData( FALSE );

    } WsbCatch( hr );

    GetDlgItem( IDC_TEXT_DISABLED )->ShowWindow( S_FALSE == hrSupported ? SW_SHOW : SW_HIDE );
    return TRUE;
}

void CPrMedSet::OnChangeEditMediaCopies() 
{
    SetModified( TRUE );
}

BOOL CPrMedSet::OnApply() 
{
    HRESULT hr = 0;

    UpdateData( TRUE );
    try {

        WsbAffirmHr( m_pStoragePool->SetNumMediaCopies( (USHORT)m_numMediaCopies ) );
        
        //
        // Tell it to save
        //
        CComPtr<IHsmServer> pServer;
        WsbAffirmHr( m_pParent->GetHsmServer( &pServer ) );
        WsbAffirmHr( pServer->SavePersistData( ) );

        //
        // Find the media node - updating the root node is useless
        // since we need to change the media node contents.
        //
        CComPtr<ISakSnapAsk> pAsk;
        CComPtr<ISakNode>    pNode;
        WsbAffirmHr( m_pParent->GetSakSnapAsk( &pAsk ) );
        WsbAffirmHr( pAsk->GetNodeOfType( cGuidMedSet, &pNode ) );

        //
        // Now notify the nodes
        //
        m_pParent->OnPropertyChange( m_hConsoleHandle, pNode );

    } WsbCatch( hr );

    return CSakPropertyPage::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\device\wzmedset.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    WzMedSet.cpp

Abstract:

    Wizard for Media Set - Copy Set Wizard.

Author:

    Rohde Wakefield [rohde]   23-09-1997

Revision History:

--*/

#include "stdafx.h"

#include "MeSe.h"
#include "WzMedSet.h"

/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizard

CMediaCopyWizard::CMediaCopyWizard()
{
    WsbTraceIn( L"CMediaCopyWizard::CMediaCopyWizard", L"" );

    m_TitleId     = IDS_WIZ_CAR_COPY_TITLE;
    m_HeaderId    = IDB_MEDIA_SYNC_HEADER;
    m_WatermarkId = IDB_MEDIA_SYNC_WATERMARK;

    WsbTraceOut( L"CMediaCopyWizard::CMediaCopyWizard", L"" );
}

CMediaCopyWizard::~CMediaCopyWizard()
{
    WsbTraceIn( L"CMediaCopyWizard::~CMediaCopyWizard", L"" );
    WsbTraceOut( L"CMediaCopyWizard::~CMediaCopyWizard", L"" );
}

STDMETHODIMP
CMediaCopyWizard::AddWizardPages(
    IN RS_PCREATE_HANDLE Handle,
    IN IUnknown*         pCallback,
    IN ISakSnapAsk*      pSakSnapAsk
    )
{
    WsbTraceIn( L"CMediaCopyWizard::AddWizardPages", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // Initialize the Sheet
        //
        WsbAffirmHr( InitSheet( Handle, pCallback, 0, pSakSnapAsk, 0, 0 ) );

        //
        // Get the number of media copies. If 0, we put up the media copies
        // page.
        //
        CComPtr<IHsmServer> pHsmServer;
        CComPtr<IHsmStoragePool> pStoragePool;
        WsbAffirmHrOk( pSakSnapAsk->GetHsmServer( &pHsmServer ) );
        WsbAffirmHr( RsGetStoragePool( pHsmServer, &pStoragePool ) );

        WsbAffirmHr( pStoragePool->GetNumMediaCopies( &m_numMediaCopiesOrig ) );

        //
        // Load pages 
        //
        WsbAffirmHr( AddPage( &m_pageIntro ) );

        if ( m_numMediaCopiesOrig == 0 ) {

            WsbAffirmHr( AddPage( &m_pageNumCopies ) );

        }

        WsbAffirmHr( AddPage( &m_pageSelect ) );
        WsbAffirmHr( AddPage( &m_pageFinish ) );


    } WsbCatch( hr );

    WsbTraceOut( L"CMediaCopyWizard::AddWizardPages", L"" );
    return( hr );
}

HRESULT CMediaCopyWizard::OnFinish( )
{
    WsbTraceIn( L"CMediaCopyWizard::OnFinish", L"" );
    //
    // The sheet really owns the process as a whole,
    // so it will do the final assembly
    //

    HRESULT hr = S_OK;
    HRESULT hrInternal = S_OK;

    try {

        USHORT numMediaCopies;

        CComPtr<IHsmServer> pHsmServer;
        CComPtr<IHsmStoragePool> pStoragePool;
        WsbAffirmHrOk( GetHsmServer( &pHsmServer ) );
        WsbAffirmHr( RsGetStoragePool( pHsmServer, &pStoragePool ) );

        //
        // If we changed the number of media copies (i.e. it was orignally 0),
        // reset it in Engine
        //
        if( m_numMediaCopiesOrig == 0 ) {

            hrInternal = m_pageNumCopies.GetNumMediaCopies( &numMediaCopies );
            if( S_OK == hrInternal ) {


                WsbAffirmHr( pStoragePool->SetNumMediaCopies( numMediaCopies ) );
                WsbAffirmHr( pHsmServer->SavePersistData( ) );

                HRESULT hrUpdate = S_OK;
                try {

                    //
                    // Find the media node - updating the root node is useless
                    // since we need to change the media node contents.
                    //
                    CComPtr<ISakSnapAsk> pAsk;
                    CComPtr<ISakNode>    pNode;
                    WsbAffirmHr( GetSakSnapAsk( &pAsk ) );
                    WsbAffirmHr( pAsk->GetNodeOfType( cGuidMedSet, &pNode ) );

                    //
                    // Now notify the node
                    //
                    OnPropertyChange( m_Handle, pNode );

                } WsbCatch( hrUpdate );
            }
        }

        //
        // And run the job for the selected copy set
        //

        INT copyNum = m_pageSelect.m_List.GetSelectedSet( );
        WsbAffirmHr( RsCreateAndRunMediaCopyJob( pHsmServer, copyNum, FALSE ) );

    } WsbCatch( hr );

    m_HrFinish = hr;

    WsbTraceOut( L"CMediaCopyWizard::OnFinish", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizardIntro property page

CMediaCopyWizardIntro::CMediaCopyWizardIntro() :
    CSakWizardPage_InitBaseExt( WIZ_CAR_COPY_INTRO )
{
    WsbTraceIn( L"CMediaCopyWizardIntro::CMediaCopyWizardIntro", L"" );
    //{{AFX_DATA_INIT(CMediaCopyWizardIntro)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    WsbTraceOut( L"CMediaCopyWizardIntro::CMediaCopyWizardIntro", L"" );
}

CMediaCopyWizardIntro::~CMediaCopyWizardIntro()
{
    WsbTraceIn( L"CMediaCopyWizardIntro::~CMediaCopyWizardIntro", L"" );
    WsbTraceOut( L"CMediaCopyWizardIntro::~CMediaCopyWizardIntro", L"" );
}

void CMediaCopyWizardIntro::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CMediaCopyWizardIntro::DoDataExchange", L"" );
    CSakWizardPage::DoDataExchange(pDX );
    //{{AFX_DATA_MAP(CMediaCopyWizardIntro)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
    WsbTraceOut( L"CMediaCopyWizardIntro::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CMediaCopyWizardIntro, CSakWizardPage)
    //{{AFX_MSG_MAP(CMediaCopyWizardIntro)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizardIntro message handlers

BOOL CMediaCopyWizardIntro::OnInitDialog( )
{
    WsbTraceIn( L"CMediaCopyWizardIntro::OnInitDialog", L"" );
    CSakWizardPage::OnInitDialog( );
    
    WsbTraceOut( L"CMediaCopyWizardIntro::OnInitDialog", L"" );
    return TRUE;
}

BOOL CMediaCopyWizardIntro::OnSetActive( )
{
    WsbTraceIn( L"CMediaCopyWizardIntro::OnSetActive", L"" );
    m_pSheet->SetWizardButtons( PSWIZB_NEXT );
    
    BOOL retval = CSakWizardPage::OnSetActive( );

    WsbTraceOut( L"CMediaCopyWizardIntro::OnSetActive", L"" );
    return( retval );
}

/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizardSelect property page

CMediaCopyWizardSelect::CMediaCopyWizardSelect():
    CSakWizardPage_InitBaseInt( WIZ_CAR_COPY_SELECT ),
    m_List( this )

{
    WsbTraceIn( L"CMediaCopyWizardSelect::CMediaCopyWizardSelect", L"" );
    //{{AFX_DATA_INIT(CMediaCopyWizardSelect)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    WsbTraceOut( L"CMediaCopyWizardSelect::CMediaCopyWizardSelect", L"" );
}

CMediaCopyWizardSelect::~CMediaCopyWizardSelect()
{
    WsbTraceIn( L"CMediaCopyWizardSelect::~CMediaCopyWizardSelect", L"" );
    WsbTraceOut( L"CMediaCopyWizardSelect::~CMediaCopyWizardSelect", L"" );
}

void CMediaCopyWizardSelect::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CMediaCopyWizardSelect::DoDataExchange", L"" );
    CSakWizardPage::DoDataExchange(pDX );
    //{{AFX_DATA_MAP(CMediaCopyWizardSelect)
    DDX_Control(pDX, IDC_COPY_LIST, m_List);
    //}}AFX_DATA_MAP
    WsbTraceOut( L"CMediaCopyWizardSelect::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CMediaCopyWizardSelect, CSakWizardPage)
    //{{AFX_MSG_MAP(CMediaCopyWizardSelect)
    ON_CBN_SELCHANGE(IDC_COPY_LIST, OnSelchangeCopyList)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizardSelect message handlers


BOOL CMediaCopyWizardSelect::OnInitDialog( )
{
    WsbTraceIn( L"CMediaCopyWizardSelect::OnInitDialog", L"" );
    CSakWizardPage::OnInitDialog( );

    WsbTraceOut( L"CMediaCopyWizardSelect::OnInitDialog", L"" );
    return TRUE;
}

BOOL CMediaCopyWizardSelect::OnSetActive( )
{
    WsbTraceIn( L"CMediaCopyWizardSelect::OnSetActive", L"" );

    m_List.UpdateView( );
    SetButtons( );

    BOOL retval = CSakWizardPage::OnSetActive( );

    WsbTraceOut( L"CMediaCopyWizardSelect::OnSetActive", L"" );
    return( retval );
}

void
CMediaCopyWizardSelect::SetButtons()
{
    WsbTraceIn( L"CMediaCopyWizardSelect::SetButtons", L"" );

    INT curSel = m_List.GetSelectedSet( );
    if( curSel > 0 ) {

        m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );

    } else {

        m_pSheet->SetWizardButtons( PSWIZB_BACK );

    }
    WsbTraceOut( L"CMediaCopyWizardSelect::SetButtons", L"" );
}

void CMediaCopyWizardSelect::OnSelchangeCopyList() 
{
    WsbTraceIn( L"CMediaCopyWizardSelect::OnSelchangeCopyList", L"" );

    SetButtons();
    
    WsbTraceOut( L"CMediaCopyWizardSelect::OnSelchangeCopyList", L"" );
}

/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizardFinish property page

CMediaCopyWizardFinish::CMediaCopyWizardFinish() :
    CSakWizardPage_InitBaseExt( WIZ_CAR_COPY_FINISH )
{
    WsbTraceIn( L"CMediaCopyWizardFinish::CMediaCopyWizardFinish", L"" );
    //{{AFX_DATA_INIT(CMediaCopyWizardFinish)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    WsbTraceOut( L"CMediaCopyWizardFinish::CMediaCopyWizardFinish", L"" );
}

CMediaCopyWizardFinish::~CMediaCopyWizardFinish()
{
    WsbTraceIn( L"CMediaCopyWizardFinish::~CMediaCopyWizardFinish", L"" );
    WsbTraceOut( L"CMediaCopyWizardFinish::~CMediaCopyWizardFinish", L"" );
}

void CMediaCopyWizardFinish::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CMediaCopyWizardFinish::DoDataExchange", L"" );
    CSakWizardPage::DoDataExchange(pDX );
    //{{AFX_DATA_MAP(CMediaCopyWizardFinish)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
    WsbTraceOut( L"CMediaCopyWizardFinish::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CMediaCopyWizardFinish, CSakWizardPage)
    //{{AFX_MSG_MAP(CMediaCopyWizardFinish)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizardFinish message handlers




BOOL CMediaCopyWizardFinish::OnInitDialog( )
{
    WsbTraceIn( L"CMediaCopyWizardFinish::OnInitDialog", L"" );
    CSakWizardPage::OnInitDialog( );

//    GetDlgItem( IDC_REQUESTS_IN_NTMS )->SetFont( GetBoldShellFont( ) );

    WsbTraceOut( L"CMediaCopyWizardFinish::OnInitDialog", L"" );
    return TRUE;
}

BOOL CMediaCopyWizardFinish::OnSetActive( )
{
    HRESULT hrInternal = S_OK;
    WsbTraceIn( L"CMediaCopyWizardFinish::OnSetActive", L"" );
    BOOL fRet = CSakWizardPage::OnSetActive( );

    //
    // Update the text on the page according to what is selected.
    //

    CString tmpString, tmpString2, newText;
    USHORT numMediaCopies = 0, oldMediaCopies = 0;

    CMediaCopyWizard* pSheet = (CMediaCopyWizard*)m_pSheet;
    oldMediaCopies = pSheet->m_numMediaCopiesOrig;

    // If we were originally set to 0, then we must have a new setting
    // in the media copies page
    if( oldMediaCopies == 0 ) {

        hrInternal = pSheet->m_pageNumCopies.GetNumMediaCopies( &numMediaCopies );

    } else {

        numMediaCopies = oldMediaCopies;

    }

    //
    // If we are changing the number of media copies, show it here
    //

    if( ( S_OK == hrInternal ) && ( numMediaCopies != oldMediaCopies ) ) {

        tmpString.LoadString( IDS_WIZ_CAR_COPY_NEW_NUM );
        tmpString2.Format( tmpString, (INT)numMediaCopies, (INT)oldMediaCopies );

    }

    //
    // Grab the copy set description - make so that it fits within a sentence.
    //
    INT setNum = pSheet->m_pageSelect.m_List.GetSelectedSet( );
    tmpString.Format( L"%d", setNum );
    AfxFormatString2( newText, IDS_WIZ_CAR_COPY_SELECT, tmpString, tmpString2 );
    SetDlgItemText( IDC_SELECT_TEXT, newText );

    //
    // And fill in the task notification from the resource strings used
    // to present the dialog normally.
    //

    newText.LoadString( IDS_JOB_MEDIA_COPY_TITLE );
    tmpString.Format( newText, pSheet->m_pageSelect.m_List.GetSelectedSet( ) );

    CWsbStringPtr computerName;

    HRESULT hr = S_OK;
    try {

        CComPtr<IHsmServer> pHsmServer;
        WsbAffirmHrOk( m_pSheet->GetHsmServer( &pHsmServer ) );
        WsbAffirmHr( pHsmServer->GetName( &computerName ) );

    } WsbCatch( hr );

    AfxFormatString2( newText, IDS_WIZ_FINISH_RUN_JOB, tmpString, computerName );
    SetDlgItemText( IDC_TASK_TEXT, newText );

    m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_FINISH );
    
    WsbTraceOut( L"CMediaCopyWizardFinish::OnSetActive", L"" );
    return( fRet );
}


/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizardNumCopies property page

CMediaCopyWizardNumCopies::CMediaCopyWizardNumCopies() :
    CSakWizardPage_InitBaseInt( WIZ_CAR_COPY_NUM_COPIES )
{
    //{{AFX_DATA_INIT(CMediaCopyWizardNumCopies)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

CMediaCopyWizardNumCopies::~CMediaCopyWizardNumCopies()
{
}

void CMediaCopyWizardNumCopies::DoDataExchange(CDataExchange* pDX)
{
    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMediaCopyWizardNumCopies)
    DDX_Control(pDX, IDC_SPIN_MEDIA_COPIES, m_SpinMediaCopies);
    DDX_Control(pDX, IDC_EDIT_MEDIA_COPIES, m_EditMediaCopies);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMediaCopyWizardNumCopies, CSakWizardPage)
    //{{AFX_MSG_MAP(CMediaCopyWizardNumCopies)
    ON_EN_CHANGE(IDC_EDIT_MEDIA_COPIES, OnChangeEditMediaCopies)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizardNumCopies message handlers

BOOL CMediaCopyWizardNumCopies::OnInitDialog() 
{
    CSakWizardPage::OnInitDialog();

    //
    // Set the limit on the spinner, and initial value.
    //
    CMediaCopyWizard* pSheet = (CMediaCopyWizard*)m_pSheet;

    m_SpinMediaCopies.SetRange (0, 3);
    m_SpinMediaCopies.SetPos( pSheet->m_numMediaCopiesOrig );
    m_EditMediaCopies.LimitText( 1 );

    return TRUE;
}

HRESULT CMediaCopyWizardNumCopies::GetNumMediaCopies( USHORT* pNumMediaCopies, USHORT* pEditMediaCopies )
{
    WsbTraceIn( L"CMediaCopyWizardSelect::GetNumMediaCopies", L"" );
    
    HRESULT hr = S_OK;

    BOOL translated = TRUE;
    UINT editVal = GetDlgItemInt( IDC_EDIT_MEDIA_COPIES, &translated );

    //
    // Need to be careful since we get called here before dialog object
    // is constructed
    //
    if( translated && m_SpinMediaCopies.m_hWnd ) {

        //
        // If Ok, always return what the spin says.
        //

        *pNumMediaCopies = (USHORT)m_SpinMediaCopies.GetPos( );
        if( pEditMediaCopies ) {

            *pEditMediaCopies = (USHORT)editVal;

        }
    }

    WsbTraceOut( L"CMediaCopyWizardNumCopies::GetNumMediaCopies", L"hr = <%ls>, *pNumMediaCopies = <%hd>", WsbHrAsString( hr ), *pNumMediaCopies  );
    return( hr );
}

void
CMediaCopyWizardNumCopies::SetButtons()
{
    WsbTraceIn( L"CMediaCopyWizardSelect::SetButtons", L"" );

    USHORT numMediaCopies = 0;
    GetNumMediaCopies( &numMediaCopies );

    if( numMediaCopies > 0 ) {

        m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );

    } else {

        m_pSheet->SetWizardButtons( PSWIZB_BACK );

    }

    WsbTraceOut( L"CMediaCopyWizardNumCopies::SetButtons", L""  );
}


BOOL CMediaCopyWizardNumCopies::OnSetActive() 
{
    WsbTraceIn( L"CMediaCopyWizardSelect::OnSetActive", L"" );

    BOOL retval = CSakWizardPage::OnSetActive();
    SetButtons();

    WsbTraceOut( L"CMediaCopyWizardNumCopies::OnSetActive", L""  );
    return( retval );
}

BOOL CMediaCopyWizardNumCopies::OnKillActive() 
{
    WsbTraceIn( L"CMediaCopyWizardSelect::OnKillActive", L"" );

    BOOL retval = FALSE;

    //
    // Need to handle  case where a user can enter a value within
    // the parameters of the number of digits allowed, but the value can
    // be out of range. This is detected by the spin box which will
    // return an error if its buddy control is out of range.
    //
    if( HIWORD( m_SpinMediaCopies.GetPos( ) ) > 0 ) {

        // Control reports on error...
        retval = FALSE;

        CString message;
        AfxFormatString2( message, IDS_ERR_COPYSET_RANGE, 
            CString( WsbLongAsString( (LONG)(HSMADMIN_MIN_COPY_SETS+1) ) ),
            CString( WsbLongAsString( (LONG)HSMADMIN_MAX_COPY_SETS ) ) );
        AfxMessageBox( message, MB_OK | MB_ICONWARNING );

    } else {

        retval = CSakWizardPage::OnKillActive();

    }

    WsbTraceOut( L"CMediaCopyWizardNumCopies::OnKillActive", L""  );
    return( retval );
}   


void CMediaCopyWizardNumCopies::OnChangeEditMediaCopies() 
{
    WsbTraceIn( L"CMediaCopyWizardSelect::OnChangeEditMediaCopies", L"" );

    SetButtons();

    WsbTraceOut( L"CMediaCopyWizardNumCopies::OnChangeEditMediaCopies", L""  );
}
/////////////////////////////////////////////////////////////////////////////
// CCopySetList

CCopySetList::CCopySetList( CMediaCopyWizardSelect * pPage )
{
    WsbTraceIn( L"CCopySetList::CCopySetList", L"" );

    for( INT index = 0; index < HSMADMIN_MAX_COPY_SETS; index++ ) {

        m_CopySetInfo[index].m_Updated      = WsbLLtoFT( 0 );
        m_CopySetInfo[index].m_NumOutOfDate = 0;
        m_CopySetInfo[index].m_NumMissing   = 0;

    }

    m_pPage   = pPage;

    WsbTraceOut( L"CCopySetList::CCopySetList", L"" );
}

CCopySetList::~CCopySetList()
{
    WsbTraceIn( L"CCopySetList::~CCopySetList", L"" );
    WsbTraceOut( L"CCopySetList::~CCopySetList", L"" );
}


BEGIN_MESSAGE_MAP(CCopySetList, CListCtrl)
    //{{AFX_MSG_MAP(CCopySetList)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCopySetList message handlers
void
CCopySetList::UpdateView(
    )
{
    WsbTraceIn( L"CCopySetList::UpdateView", L"" );
    HRESULT hr = S_OK;

    try {


        USHORT numMediaCopies;
        CMediaCopyWizard* pSheet = (CMediaCopyWizard*)(m_pPage->m_pSheet);
 
        //
        // Get the number of media copies from either the media copies
        // page or RMS.
        //
        if( pSheet->m_numMediaCopiesOrig == 0 ) {

            pSheet->m_pageNumCopies.GetNumMediaCopies( &numMediaCopies );

        } else {

            numMediaCopies = pSheet->m_numMediaCopiesOrig;

        }

        CString tmpString;

        INT oldCurSel = GetSelectedSet( );
        INT newCurSel = oldCurSel;
        LockWindowUpdate( );

        DeleteAllItems( );

        for( INT index = 0; index < numMediaCopies; index++ ) {

            //
            // Add the entries to each column
            //
            tmpString.Format( IDS_WIZ_CAR_COPY_SEL_TEXT, index + 1 );
            this->InsertItem( index, tmpString, 0 );
            tmpString.Format( L"%d", m_CopySetInfo[index].m_NumOutOfDate );
            this->SetItemText( index, m_UpdateCol, tmpString );
            tmpString.Format( L"%d", m_CopySetInfo[index].m_NumMissing );
            this->SetItemText( index, m_CreateCol, tmpString );

        }

        if( CB_ERR == oldCurSel ) {

            //
            // No selection before, find the most likely to need updating - most out of date
            //

            newCurSel = 1;
            FILETIME latestTime = WsbLLtoFT( (LONGLONG)-1 );

            for( INT index = 0; index < numMediaCopies; index++ ) {

                if( CompareFileTime( &latestTime, &(m_CopySetInfo[index].m_Updated) ) > 0 ) {

                    latestTime = m_CopySetInfo[index].m_Updated;
                    newCurSel  = index + 1;

                }

            }

        } else if( oldCurSel > numMediaCopies ) {

            newCurSel = numMediaCopies;

        }

        SelectSet( newCurSel );
        UnlockWindowUpdate( );

    } WsbCatch( hr );

    WsbTraceOut( L"CCopySetList::UpdateView", L"" );
}

INT
CCopySetList::GetSelectedSet(
    )
{
    INT retval = GetNextItem( -1, LVIS_SELECTED );

    if( CB_ERR != retval ) {

        retval++;

    }

    return( retval );
}

void
CCopySetList::SelectSet(
    INT SetNum
    )
{
    if( SetNum > 0 ) {

        SetItemState( SetNum - 1, LVIS_SELECTED, LVIS_SELECTED );

    }
}

void CCopySetList::PreSubclassWindow() 
{
    WsbTraceIn( L"CCopySetList::PreSubclassWindow", L"" );
    HRESULT hr = S_OK;

    CComPtr<IWsbDb> pDb;
    CComPtr<IWsbDbSession> pDbSession;
    CComPtr<IMediaInfo> pMediaInfo;

    try {

        //
        // Set the style appropriately
        //
        ListView_SetExtendedListViewStyle( GetSafeHwnd( ), LVS_EX_FULLROWSELECT );

        //
        // Also need to calculate some buffer space
        // Use 4 dialog units (for numeral)
        //
        CRect padRect( 0, 0, 8, 8 );
        m_pPage->MapDialogRect( padRect );

        //
        // Set up columns
        //
        INT column = 0;
        CString titleString;
        LVCOLUMN lvc;
        memset( &lvc, 0, sizeof( lvc ) );
        lvc.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
        lvc.fmt  = LVCFMT_CENTER;


        m_CopySetCol = column;
        titleString.LoadString( IDS_COPYSET_COPYSET );
        lvc.cx      = GetStringWidth( titleString ) + padRect.Width( ) * 2;
        lvc.pszText = (LPTSTR)(LPCTSTR)titleString;
        InsertColumn( m_CopySetCol, &lvc );
        column++;

        m_UpdateCol = column;
        titleString.LoadString( IDS_COPYSET_OUT_OF_DATE );
        lvc.cx      = GetStringWidth( titleString ) + padRect.Width( );
        lvc.pszText = (LPTSTR)(LPCTSTR)titleString;
        InsertColumn( m_UpdateCol, &lvc );
        column++;

        m_CreateCol = column;
        titleString.LoadString( IDS_COPYSET_DO_NOT_EXIST );
        lvc.cx      = GetStringWidth( titleString ) + padRect.Width( );
        lvc.pszText = (LPTSTR)(LPCTSTR)titleString;
        InsertColumn( m_CreateCol, &lvc );
        column++;

        //
        // Hook up to DB and get info
        //

        CComPtr<IHsmServer> pHsmServer;
        CComPtr<IRmsServer> pRmsServer;
        WsbAffirmHrOk( m_pPage->m_pSheet->GetHsmServer( &pHsmServer ) );
        WsbAffirmHrOk( m_pPage->m_pSheet->GetRmsServer( &pRmsServer ) );

        CMediaInfoObject mio;
        mio.Initialize( GUID_NULL, pHsmServer, pRmsServer );

        HRESULT hrEnum = mio.First( );
        WsbAffirm( SUCCEEDED( hrEnum ) || ( WSB_E_NOTFOUND == hrEnum ), hrEnum );

        while( SUCCEEDED( hrEnum ) ) {

            if( S_OK == mio.IsViewable( FALSE ) ) {

                for( INT index = 0; index < HSMADMIN_MAX_COPY_SETS; index++ ) {

                    if( S_OK != mio.DoesCopyExist( index ) ) {

                        m_CopySetInfo[index].m_NumMissing++;

                    } else {

                        //
                        // And check to see if out of date
                        //
                        if( S_OK != mio.IsCopyInSync( index ) ) {

                            m_CopySetInfo[index].m_NumOutOfDate++;

                        }

                        //
                        // Look for latest date of update per set
                        //
                        if( CompareFileTime( &(m_CopySetInfo[index].m_Updated), &(mio.m_CopyInfo[index].m_ModifyTime) ) < 0 ) {

                            m_CopySetInfo[index].m_Updated = (mio.m_CopyInfo[index].m_ModifyTime);

                        }

                    }

                }
            }


            hrEnum = mio.Next( );
        }
    
    } WsbCatch( hr );

    CListCtrl::PreSubclassWindow();

    WsbTraceOut( L"CCopySetList::PreSubclassWindow", L"" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\mergeps\dlldatax.c ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    dlldataX.c

Abstract:

    wrapper for dlldata.c

Author:

    Rohde Wakefield [rohde]   19-Aug-1997

Revision History:

--*/

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define USE_STUBLESS_PROXY  //defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#undef  _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#define _purecall _purecallx

#include "dlldata.c"
#include "hsmadmin_p.c"


#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\dll\makefile.inc ===
$(O)\hsmadmin.res:                        \
                   ..\res\BlueSakk.ico    \
                   ..\res\ContOpen.ico    \
                   ..\res\devlst.ico      \
                   ..\res\devlstX.ico     \
                   ..\res\Li.ico          \
                   ..\res\LiX.ico         \
                   ..\res\manvol.ico      \
                   ..\res\manvolD.ico     \
                   ..\res\manvolX.ico     \
                   ..\res\Media.ico       \
                   ..\res\MoveUp.ico      \
                   ..\res\MoveUp2.ico     \
                   ..\res\MoveDown.ico    \
                   ..\res\MoveDwn2.ico    \
                   ..\res\about.rgs       \
                   ..\res\Ca.rgs          \
                   ..\res\HsmCom.rgs      \
                   ..\res\ManVol.rgs      \
                   ..\res\ManVolLs.rgs    \
                   ..\res\Mese.rgs        \
                   ..\res\hsmadmin.rgs    \
                   ..\res\hsmdatax.rgs    \
                   ..\res\hsmdata.rgs     \
                   ..\res\QStartEx.bmp    \
                   ..\res\QStartIn.bmp    \
                   ..\res\ManageEx.bmp    \
                   ..\res\ManageIn.bmp    \
                   ..\res\MdSyncEx.bmp    \
                   ..\res\MdSyncIn.bmp    \
                   ..\res\UnMngExt.bmp    \
                   ..\res\UnMngInt.bmp    \
                   ..\res\RedSakLg.bmp    \
                   ..\res\RedSakSm.bmp    \
                   ..\res\TbCar.bmp       \
                   ..\res\TbMese.bmp      \
                   ..\res\TbVolume.bmp    \
                   ..\res\TbVolLst.bmp    \
                   ..\$(O)\HsmAdmin.tlb 

..\stdafx.cpp: ..\..\inc\rsutil.cpp
..\stdafx.h: ..\..\inc\rsutil.h

$(O)\hsmadmin_i.c: ..\mergeps\$(O)\hsmadmin_i.c
    copy ..\mergeps\$(O)\hsmadmin_i.c $(O)\.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\volume\ielist.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    IeList.cpp

Abstract:

    CIeList is a subclassed (owner-draw) list control that groups items into
    a 3D panel that have the same information in the indicated 
    sortColumn.

    The panels are created from tiles.  Each tile corresponds to one subitem
    in the list, and has the appropriate 3D edges so that the tiles together
    make up a panel.

    NOTE: The control must be initialized with the number of columns and the
    sort column.  The parent dialog must implement OnMeasureItem and call
    GetItemHeight to set the row height for the control.

Author:

    Art Bragg [artb]   01-DEC-1997

Revision History:

--*/

#include "stdafx.h"
#include "IeList.h"

// Position of a tile in it's panel
#define POS_LEFT        100
#define POS_RIGHT       101
#define POS_TOP         102
#define POS_BOTTOM      103
#define POS_MIDDLE      104
#define POS_SINGLE      105


/////////////////////////////////////////////////////////////////////////////
// CIeList

BEGIN_MESSAGE_MAP(CIeList, CListCtrl)
    //{{AFX_MSG_MAP(CIeList)
    ON_NOTIFY_REFLECT(NM_CLICK, OnClick)
    ON_WM_SETFOCUS()
    ON_WM_KILLFOCUS()
    //}}AFX_MSG_MAP
    ON_WM_SYSCOLORCHANGE()

END_MESSAGE_MAP()

CIeList::CIeList()
/*++

Routine Description:

    Sets default dimensions for the control.

Arguments:

    none.

Return Value:

    none.

--*/
{
    //
    // Initializations
    //
    m_ColCount = 0;
    m_SortCol = 0;
    m_pVertPos = NULL;
    //
    // Drawing dimensions
    //
    // If these are altered, the visual aspects of the control
    // should be checked (especially the focus rectangle), 
    // as some minor adjustments may need to be made.
    //
    m_VertRaisedSpace           = 1;
    m_BorderThickness           = 2;
    m_VerticalTextOffsetTop     = 1;

    // The text height will be set later (based on the font size)
    m_Textheight                = 0;
    m_VerticalTextOffsetBottom  = 1;

    // Total height will be set later
    m_TotalHeight               = 0;
    m_HorzRaisedSpace           = 1;
    m_HorzTextOffset            = 3;

}

CIeList::~CIeList()
/*++

Routine Description:

    Cleanup.

Arguments:

    none.

Return Value:

    none.

--*/
{
    // Cleanup the array of vertical positions
    if( m_pVertPos ) free ( m_pVertPos );
}

/////////////////////////////////////////////////////////////////////////////
// CIeList message handlers

void CIeList::Initialize( 
    IN int colCount, 
    IN int sortCol 
    )
/*++

Routine Description:

    Sets the number of columns (not easily available from MFC) and
    the sort column.

Arguments:

    colCount        - number of columns to display
    sortCol         - column to sort on

Return Value:

    none.

--*/
{

    m_ColCount = colCount;
    m_SortCol = sortCol;
}

void CIeList::DrawItem(
    IN LPDRAWITEMSTRUCT lpDrawItemStruct
    ) 
/*++

Routine Description:

    This is the callback for an owner draw control.
    Draws the appropriate text and/or 3D lines depending on the
    item number and clipping rectangle supplied by MFC in lpDrawItemStruct 

Arguments:

    lpDrawItemStruct - MFC structure that tells us what and where to draw

Return Value:

    none.

--*/
{
    CDC dc;
    int saveDc;

    int colWidth = 0;                   // Width of current column
    int horzPos = POS_MIDDLE;           // Horz position in the panel
    int vertPos = POS_SINGLE;           // Vert position in the panel
    BOOL bSelected = FALSE;             // Is this item selected
    CRect rcAllLabels;                  // Used to find left position of focus rectangle
    CRect itemRect;                     // Rectangle supplied in lpDrawItemStruct
    CRect textRect;                     // Rectangle for text
    CRect boxRect;                      // Rectangle for 3D box (the panel)
    CRect clipRect;                     // Current clipping rectangle
    LPCTSTR pszText;                    // Text to display
    COLORREF clrTextSave = 0;           // Save the current color
    COLORREF clrBkSave = 0;             // Save the background color
    int leftStart = 0;                  // Left edge of where we're currently drawing
    BOOL bFocus = (GetFocus() == this); // Do we have focus?

    //
    // Get the current scroll position
    //
    int nHScrollPos = GetScrollPos( SB_HORZ );

    //
    // Get the item ID from the list for the item we're drawing
    //
    int itemID = lpDrawItemStruct->itemID;

    //
    // Get item data for the item we're drawing
    //
    LV_ITEM lvi;
    lvi.mask = LVIF_IMAGE | LVIF_STATE;
    lvi.iItem = itemID;
    lvi.iSubItem = 0;
    lvi.stateMask = 0xFFFF;     // get all state flags
    GetItem(&lvi);

    //
    // Determine focus and selected states
    //
    bSelected = (bFocus || (GetStyle() & LVS_SHOWSELALWAYS)) && lvi.state & LVIS_SELECTED;

    //
    // Get the rectangle to draw in
    //
    itemRect = lpDrawItemStruct->rcItem;

    dc.Attach( lpDrawItemStruct->hDC );
    saveDc = dc.SaveDC();
    //
    // Get the clipping rectangle - we use it's vertical edges
    // to optimize what we draw
    //
    dc.GetClipBox( &clipRect );
    boxRect = clipRect;

    //
    // For each column, paint it's text and the section of the 3D panel
    //
    for ( int col = 0; col < m_ColCount; col++ ) {

        colWidth = GetColumnWidth( col );
        //
        // Only paint this column if it's in the clipping rectangle
        //
        if( ( ( leftStart + colWidth ) > clipRect.left ) || ( leftStart < clipRect.right ) ) {

            //
            // Determine the horizontal position based on the column
            //
            horzPos = POS_MIDDLE;
            if( col == 0 )                  horzPos = POS_LEFT;
            if( col == m_ColCount - 1 )     horzPos = POS_RIGHT;

            //
            // Calculate the rectangle for this tile
            //
            boxRect.top = itemRect.top;
            boxRect.bottom = itemRect.bottom;
            boxRect.left = itemRect.left + leftStart;
            boxRect.right = itemRect.left + leftStart + colWidth;

            //
            // Get the vertical position from the array.  It was saved there
            // during SortItem for performance reasons.
            //
            if( m_pVertPos ) { 

                vertPos = m_pVertPos[ itemID ];

            }

            //
            // Draw the tile for this item.
            //
            Draw3dRectx ( &dc, boxRect, horzPos, vertPos, bSelected );

            //
            // If this item is selected, change the text colors
            //
            if( bSelected ) {

                clrTextSave = dc.SetTextColor( m_clrHighlightText );
                clrBkSave = dc.SetBkColor( m_clrHighlight );

            }

            //
            // Calculate the text rectangle
            //
            textRect.top =      itemRect.top + m_VertRaisedSpace + m_BorderThickness + m_VerticalTextOffsetTop;
            textRect.bottom =   itemRect.bottom;    // Text is top justified, no need to adjust bottom
            textRect.left =     leftStart - nHScrollPos + m_HorzRaisedSpace + m_BorderThickness + m_HorzTextOffset;
            textRect.right =    itemRect.right;

            //
            // Get the text and put in the "..." if we need them
            //
            CString pszLongText = GetItemText( itemID, col );
            pszText = MakeShortString(&dc, (LPCTSTR) pszLongText,
                textRect.right - textRect.left, 4);
            //
            // Now draw the text using the correct color
            //
            COLORREF saveTextColor;
            if( bSelected ) {

                saveTextColor = dc.SetTextColor( m_clrHighlightText );

            } else {

                saveTextColor = dc.SetTextColor( m_clrText );

            }
            int textheight = dc.DrawText( pszText, textRect, DT_NOCLIP | DT_LEFT | DT_TOP | DT_SINGLELINE  );
            dc.SetTextColor( saveTextColor );

        }

        //
        // Move to the next column
        //
        leftStart += colWidth;
    }
    //
    // draw focus rectangle if item has focus.  Use LVIR_BOUNDS rectangle
    // to bound it.
    //
    GetItemRect(itemID, rcAllLabels, LVIR_BOUNDS);
    if( lvi.state & LVIS_FOCUSED && bFocus ) {

        CRect focusRect;
        focusRect.left = rcAllLabels.left + m_HorzRaisedSpace + m_BorderThickness;
        focusRect.right = min( rcAllLabels.right, (itemRect.right - m_HorzRaisedSpace * 2 - 3) );
        focusRect.top = boxRect.top + m_VertRaisedSpace + m_BorderThickness;
        focusRect.bottom = boxRect.top + m_TotalHeight - m_BorderThickness + 1;

        dc.DrawFocusRect( focusRect );

    }

    // Restore colors
    if( bSelected ) {

        dc.SetTextColor( clrTextSave );
        dc.SetBkColor( clrBkSave );

    }

    dc.RestoreDC( saveDc );
    dc.Detach();
}


LPCTSTR CIeList::MakeShortString(
    IN CDC* pDC, 
    IN LPCTSTR lpszLong, 
    IN int nColumnLen, 
    IN int nDotOffset
    )
/*++

Routine Description:

    Determines it the supplied string fits in it's column.  If not truncates
    it and adds "...".  From MS sample code.

Arguments:

    pDC         - Device context
    lpszLong    - Original String
    nColumnLen  - Width of column
    nDotOffset  - Space before dots

Return Value:

    Shortened string

--*/
{
    static const _TCHAR szThreeDots[] = _T("...");

    int nStringLen = lstrlen(lpszLong);

    if(nStringLen == 0 ||
        (pDC->GetTextExtent(lpszLong, nStringLen).cx + nDotOffset) <= nColumnLen)
    {
        return(lpszLong);
    }

    static _TCHAR szShort[MAX_PATH];

    lstrcpy(szShort,lpszLong);
    int nAddLen = pDC->GetTextExtent(szThreeDots,sizeof(szThreeDots)).cx;

    for(int i = nStringLen-1; i > 0; i--)
    {
        szShort[i] = 0;
        if((pDC->GetTextExtent(szShort, i).cx + nDotOffset + nAddLen)
            <= nColumnLen)
        {
            break;
        }
    }

    lstrcat(szShort, szThreeDots);
    return(szShort);
}

void CIeList::Draw3dRectx ( 
    IN CDC *pDc, 
    IN CRect &rect, 
    IN int horzPos, 
    IN int vertPos, 
    IN BOOL bSelected 
) 
/*++

Routine Description:

    Draws the appropriate portion (tile) of a panel for a given cell in the
    list.  The edges of the panel portion are determined by the horzPos
    and vertPos parameters.

Arguments:

    pDc         - Device context
    rect        - Rectangle to draw the panel portion in
    horzPos     - Where the portion is horizontally
    vertPos     - Where the portion is vertically
    bSelected   - Is the item selected

Return Value:

    none.

--*/

{

    CPen *pSavePen;
    int topOffset = 0;
    int rightOffset = 0;
    int leftOffset = 0;

    //
    // If a given edge of the tile is to be drawn, set an offset to that
    // edge.  If we don't draw a given edge, the offset is 0.
    //
    switch ( horzPos )
    {
    case POS_LEFT:
        leftOffset = m_HorzRaisedSpace;
        rightOffset = 0;
        break;
    case POS_MIDDLE:
        leftOffset = 0;
        rightOffset = 0;
        break;
    case POS_RIGHT:
        leftOffset = 0;
        rightOffset = m_HorzRaisedSpace + 3;
        break;
    }
    
    switch ( vertPos )
    {

    case POS_TOP:
        topOffset = m_VertRaisedSpace;
        break;
    case POS_MIDDLE:
        topOffset = 0;
        break;
    case POS_BOTTOM:
        topOffset = 0;
        break;
    case POS_SINGLE:
        topOffset = m_VertRaisedSpace;
        break;

    }
    //
    // Erase 
    //
    if( !bSelected ) pDc->FillSolidRect( rect, m_clrBkgnd );
    //
    // Highlight the selected area
    //
    if (bSelected)
    {
        CRect selectRect;
        if (leftOffset == 0)
            selectRect.left = rect.left;
        else
            selectRect.left = rect.left + leftOffset + m_BorderThickness;
        if (rightOffset == 0)
            selectRect.right = rect.right;
        else
            selectRect.right = rect.right - rightOffset - m_BorderThickness + 1;
        selectRect.top = rect.top + m_VertRaisedSpace + m_BorderThickness;
        selectRect.bottom = rect.top + m_TotalHeight - m_BorderThickness + 1;

        pDc->FillSolidRect( selectRect, m_clrHighlight );
    }

    // Select a pen to save the original pen
    pSavePen = pDc->SelectObject( &m_ShadowPen );

    // left edge
    if( horzPos == POS_LEFT ) {
        // Outside lighter line
        pDc->SelectObject( &m_ShadowPen );
        pDc->MoveTo( rect.left + leftOffset, rect.top + topOffset );
        pDc->LineTo( rect.left + leftOffset, rect.top + m_TotalHeight + 1);
        // Inside edge - darker line
        pDc->SelectObject( &m_DarkShadowPen );
        pDc->MoveTo( rect.left + leftOffset + 1, rect.top + topOffset);
        pDc->LineTo( rect.left + leftOffset + 1, rect.top + m_TotalHeight + 1);
    }
    // right edge
    if( horzPos == POS_RIGHT ) {
        // Outside line
        pDc->SelectObject( &m_HiLightPen );
        pDc->MoveTo( rect.right - rightOffset, rect.top + topOffset );
        pDc->LineTo( rect.right - rightOffset, rect.top + m_TotalHeight + 1 );
        // Inside line
        pDc->SelectObject( &m_LightPen );// note - this is usually the same color as btnface
        if( vertPos == POS_TOP )
            pDc->MoveTo( rect.right - rightOffset - 1, rect.top + topOffset + 1 );
        else
            pDc->MoveTo( rect.right - rightOffset - 1, rect.top + topOffset );
        pDc->LineTo( rect.right - rightOffset - 1, rect.top + m_TotalHeight + 2 );
    }
    // top edge
    if( ( vertPos == POS_TOP ) || ( vertPos == POS_SINGLE ) ) {
        // Outside lighter
        pDc->SelectObject( &m_ShadowPen );
        pDc->MoveTo( rect.left + leftOffset, rect.top + topOffset );
        pDc->LineTo( rect.right - rightOffset + 1, rect.top + topOffset );
        // Inside edge darker
        pDc->SelectObject( &m_DarkShadowPen );
        if( horzPos == POS_LEFT )
            pDc->MoveTo( rect.left + leftOffset + 1, rect.top + topOffset + 1 );
        else
            pDc->MoveTo( rect.left + leftOffset - 3, rect.top + topOffset + 1 );
        pDc->LineTo( rect.right - rightOffset, rect.top + topOffset + 1);
    }
    // bottom edge
    if( ( vertPos == POS_BOTTOM ) || ( vertPos == POS_SINGLE ) ) {
        // Outside line
        pDc->SelectObject( &m_HiLightPen );
        if( horzPos == POS_LEFT )
            pDc->MoveTo( rect.left + leftOffset + 1, rect.top + m_TotalHeight );
        else
            pDc->MoveTo( rect.left + leftOffset - 1, rect.top + m_TotalHeight );
        pDc->LineTo( rect.right - rightOffset, rect.top + m_TotalHeight );
        // Inside line
        pDc->SelectObject( &m_LightPen );
        if( horzPos == POS_LEFT )
            pDc->MoveTo( rect.left + leftOffset + 2, rect.top + m_TotalHeight - 1 );
        else
            pDc->MoveTo( rect.left + leftOffset - 2, rect.top + m_TotalHeight - 1 );
        pDc->LineTo( rect.right - rightOffset - 1, rect.top + m_TotalHeight - 1 );

    }
    pDc->SelectObject( pSavePen );

}

void CIeList::OnClick(
    NMHDR* /* pNMHDR */, LRESULT* pResult
) 
/*++

Routine Description:
    When the list is clicked, we invalidate the 
    rectangle for the currently selected item

Arguments:

    pResult     - ununsed

Return Value:

    none.

--*/
{
    CRect rect;

    // Get the selected item
    int curIndex = GetNextItem( -1, LVNI_SELECTED );
    if( curIndex != -1 ) {
        GetItemRect( curIndex, &rect, LVIR_BOUNDS );
        InvalidateRect( rect );
        UpdateWindow();
    }

    *pResult = 0;
}
/*++

Routine Description:
    Repaint the currently selected item if the style is LVS_SHOWSELALWAYS.

Arguments:

    none.

Return Value:

    none.

--*/

void CIeList::RepaintSelectedItems()
{
    CRect rcItem, rcLabel;
    //
    // invalidate focused item so it can repaint properly
    //
    int nItem = GetNextItem(-1, LVNI_FOCUSED);

    if(nItem != -1)
    {
        GetItemRect(nItem, rcItem, LVIR_BOUNDS);
        GetItemRect(nItem, rcLabel, LVIR_LABEL);
        rcItem.left = rcLabel.left;

        InvalidateRect(rcItem, FALSE);
    }
    //
    // if selected items should not be preserved, invalidate them
    //
    if(!(GetStyle() & LVS_SHOWSELALWAYS))
    {
        for(nItem = GetNextItem(-1, LVNI_SELECTED);
            nItem != -1; nItem = GetNextItem(nItem, LVNI_SELECTED))
        {
            GetItemRect(nItem, rcItem, LVIR_BOUNDS);
            GetItemRect(nItem, rcLabel, LVIR_LABEL);
            rcItem.left = rcLabel.left;

            InvalidateRect(rcItem, FALSE);
        }
    }

    // update changes 

    UpdateWindow();
}

int CIeList::GetItemHeight(
    IN LONG fontHeight
    ) 
/*++

Routine Description:
    Calculates the item height (the height of each drawing
    rectangle in the control) based on the supplied fontHeight.  This
    function is used by the parent to set the item height for the
    control.

Arguments:

    fontHeight - The height of the current font.

Return Value:

    Item height.

--*/

{


     int itemHeight = 
         m_VertRaisedSpace +
         m_BorderThickness +
         m_VerticalTextOffsetTop +
         fontHeight +
         2 +
         m_VerticalTextOffsetBottom +
         m_BorderThickness + 
         1;
     return itemHeight;
    
}

void CIeList::OnSetFocus(
    CWnd* pOldWnd
    ) 
/*++

Routine Description:
    Repaint the selected item.

Arguments:

    pOldWnd - Not used by this function

Return Value:

    none

--*/
{
    CListCtrl::OnSetFocus(pOldWnd);
    
    // repaint items that should change appearance
    RepaintSelectedItems();
        
}

void CIeList::OnKillFocus(
    CWnd* pNewWnd
) 
/*++

Routine Description:
    Repaint the selected item.

Arguments:

    pOldWnd - Not used by this function

Return Value:

    none

--*/
{
    CListCtrl::OnKillFocus(pNewWnd);
    
    // repaint items that should change appearance
    RepaintSelectedItems();
}

void CIeList::PreSubclassWindow() 
/*++

Routine Description:
    Calculate height parameters based on the font size.  Set
    colors for the control.

Arguments:

    none.

Return Value:

    none

--*/
{
    CFont *pFont;
    LOGFONT logFont; 

    pFont = GetFont( );
    pFont->GetLogFont( &logFont );

    LONG fontHeight = abs ( logFont.lfHeight );

    m_Textheight = fontHeight + 2;

    m_TotalHeight = 
         m_VertRaisedSpace +
         m_BorderThickness +
         m_VerticalTextOffsetTop +
         m_Textheight +
         m_VerticalTextOffsetBottom +
         m_BorderThickness; 

    SetColors();
    CListCtrl::PreSubclassWindow();
}

void CIeList::OnSysColorChange() 
/*++

Routine Description:
    Set the system colors and invalidate the control.

Arguments:

    none.

Return Value:

    none

--*/
{
    SetColors();
    Invalidate();
}

void CIeList::SetColors()
/*++

Routine Description:
    Store the system colors and create pens.

Arguments:

    none.

Return Value:

    none

--*/
{

    // Text colors
    m_clrText =             ::GetSysColor(COLOR_WINDOWTEXT);
    m_clrTextBk =           ::GetSysColor(COLOR_BTNFACE);
    m_clrBkgnd =            ::GetSysColor(COLOR_BTNFACE);
    m_clrHighlightText =    ::GetSysColor(COLOR_HIGHLIGHTTEXT);
    m_clrHighlight  =       ::GetSysColor(COLOR_HIGHLIGHT);

    // Line colors
    m_clr3DDkShadow =       ::GetSysColor( COLOR_3DDKSHADOW );
    m_clr3DShadow =         ::GetSysColor( COLOR_3DSHADOW );
    m_clr3DLight =          ::GetSysColor( COLOR_3DLIGHT );
    m_clr3DHiLight =        ::GetSysColor( COLOR_3DHIGHLIGHT );

    SetBkColor( m_clrBkgnd );
    SetTextColor( m_clrText );
    SetTextBkColor( m_clrTextBk );

    // Pens for 3D rectangles
    if( m_DarkShadowPen.GetSafeHandle() != NULL )
        m_DarkShadowPen.DeleteObject();
    m_DarkShadowPen.CreatePen ( PS_SOLID, 1, m_clr3DDkShadow );

    if( m_ShadowPen.GetSafeHandle() != NULL )
        m_ShadowPen.DeleteObject();
    m_ShadowPen.CreatePen ( PS_SOLID, 1, m_clr3DShadow );

    if( m_LightPen.GetSafeHandle() != NULL )
        m_LightPen.DeleteObject();
    m_LightPen.CreatePen ( PS_SOLID, 1, m_clr3DLight );

    if( m_HiLightPen.GetSafeHandle() != NULL )
        m_HiLightPen.DeleteObject();
    m_HiLightPen.CreatePen ( PS_SOLID, 1, m_clr3DHiLight );

}

BOOL CIeList::SortItems( 
    IN PFNLVCOMPARE pfnCompare, 
    IN DWORD dwData 
    )
/*++

Routine Description:
    Override for SortItems.  Checks the text of the sortColumn
    for each line in the control against it's neighbors (above and
    below) and assigns each line a position within it's panel.

Arguments:

    pfnCompare          - sort callback function
    dwData              - Unused

Return Value:

    TRUE, FALSE

--*/
{
    BOOL retVal = FALSE;
    BOOL bEqualAbove = FALSE;
    BOOL bEqualBelow = FALSE;
    CString thisText;
    CString aboveText;
    CString belowText;

    int numItems = GetItemCount();
    //
    // Call the base class to sort the items
    //
    if( CListCtrl::SortItems( pfnCompare, dwData ) ) {
        //
        // Get the vertical position (position within a panel) by comparing the text
        // of the sort column and stash it in the array of vertical positions
        //
        if( m_pVertPos ) {

            free( m_pVertPos );

        }
        m_pVertPos = (int *) malloc( numItems * sizeof( int ) );
        if( m_pVertPos ) {

            retVal = TRUE;

            for( int itemID = 0; itemID < numItems; itemID++ ) {
                //
                // Get the text of the item and it's neighbors
                //
                thisText = GetItemText( itemID, m_SortCol );
                aboveText = GetItemText( itemID - 1, m_SortCol );
                belowText = GetItemText( itemID + 1, m_SortCol );
                //
                // Set booleans for the relationship of this item to it's
                // neighbors
                //
                if( ( itemID == 0) || (  thisText.CompareNoCase( aboveText ) != 0 ) ){

                    bEqualAbove = FALSE;

                } else {

                    bEqualAbove = TRUE;

                }
                if( ( itemID == GetItemCount() - 1 ) || ( thisText.CompareNoCase( belowText ) != 0 ) ) {

                    bEqualBelow = FALSE;

                } else {

                    bEqualBelow = TRUE;

                }
                //
                // Determine the position in the panel
                //
                if      ( bEqualAbove && bEqualBelow )  m_pVertPos[ itemID ] = POS_MIDDLE;
                else if( bEqualAbove && !bEqualBelow ) m_pVertPos[ itemID ] = POS_BOTTOM;
                else if( !bEqualAbove && bEqualBelow ) m_pVertPos[ itemID ] = POS_TOP;
                else                                    m_pVertPos[ itemID ] = POS_SINGLE;
            }
        }
    }
    return( retVal );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\volume\ielist.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    IeList.h

Abstract:

    CIeList is a subclassed (owner-draw) list control that groups items into
    a 3D panel that have the same information in the indicated 
    sortColumn.

    The panels are created from tiles.  Each tile corresponds to one subitem
    in the list, and has the appropriate 3D edges so that the tiles together
    make up a panel.

    NOTE: The control must be initialized with the number of columns and the
    sort column.  The parent dialog must implement OnMeasureItem and call
    GetItemHeight to set the row height for the control.

Author:

    Art Bragg [artb]   01-DEC-1997

Revision History:

--*/


#ifndef IELIST_H
#define IELIST_H

#pragma once

/////////////////////////////////////////////////////////////////////////////
// CIeList window

class CIeList : public CListCtrl
{

// Construction
public:
    CIeList();

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CIeList)
    protected:
    virtual void PreSubclassWindow();
    //}}AFX_VIRTUAL

    virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

// Implementation
public:
    virtual ~CIeList();
    int GetItemHeight( LONG fontHeight );
    BOOL SortItems( PFNLVCOMPARE pfnCompare, DWORD dwData );

    // Generated message map functions
protected:
    //{{AFX_MSG(CIeList)
    afx_msg void OnClick(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnKillFocus(CWnd* pNewWnd);
    //}}AFX_MSG
    afx_msg void OnSysColorChange();
    DECLARE_MESSAGE_MAP()

private:
    // functions
    void Draw3dRectx ( CDC *pDc, CRect &rect, int horzPos, int vertPos, BOOL bSelected );
    void SetColors();
    LPCTSTR CIeList::MakeShortString(CDC* pDC, LPCTSTR lpszLong, int nColumnLen, int nOffset);
    void RepaintSelectedItems();

    // Dimensions for creating panels (in pixels)
    int m_VertRaisedSpace;              // Vertical size of raised space between panels
    int m_BorderThickness;              // Thickness of border in pixels
    int m_VerticalTextOffsetTop;        // Distance between top of text and border
    int m_Textheight;                   // Height of text
    int m_VerticalTextOffsetBottom;     // Distance between bottom of text and border
    int m_HorzRaisedSpace;              // Horiz raised space between panels
    int m_HorzTextOffset;               // Distance between left edge of text and border
    int m_TotalHeight;                  // Total height of line (for convenience)
    int m_ColCount;                     // Number of columns
    int m_SortCol;                      // Which column to use when sorting into panels

    int *m_pVertPos;                    // Array of vertical positions within a panel

    // Colors
    COLORREF m_clrText;
    COLORREF m_clrTextBk;
    COLORREF m_clrBkgnd;
    COLORREF m_clrHighlightText;
    COLORREF m_clrHighlight;
    COLORREF m_clr3DDkShadow;
    COLORREF m_clr3DShadow;
    COLORREF m_clr3DLight;
    COLORREF m_clr3DHiLight;

    // Pens for 3D rectangles
    CPen m_DarkShadowPen;
    CPen m_ShadowPen;
    CPen m_LightPen;
    CPen m_HiLightPen;

public:
    void CIeList::Initialize( int colCount, int sortCol = 0 );


};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#endif // !defined(IELIST_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\device\wzmedset.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    WzMedSet.h

Abstract:

    Wizard for Media Set - Copy Set Wizard.

Author:

    Rohde Wakefield [rohde]   23-09-1997

Revision History:

--*/

#ifndef _WZMEDSET_H
#define _WZMEDSET_H

//
// Use CMediaInfoObject
//
#include "ca.h"

// Pre-declare
class CMediaCopyWizard;
class CMediaCopyWizardSelect;

/////////////////////////////////////////////////////////////////////////////
// CCopySetList window

class CCopySetList : public CListCtrl
{
// Construction
public:
    CCopySetList( CMediaCopyWizardSelect * pPage );

// Attributes
public:

// Operations
public:
    void UpdateView( );
    INT GetSelectedSet( );
    void SelectSet( INT SetNum );

private:
    INT m_CopySetCol;
    INT m_UpdateCol;
    INT m_CreateCol;

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CCopySetList)
    protected:
    virtual void PreSubclassWindow();
    //}}AFX_VIRTUAL

// Implementation
    struct CopySetInfo {
        
        FILETIME m_Updated;
        INT      m_NumOutOfDate;
        INT      m_NumMissing;

    };

    CopySetInfo m_CopySetInfo[HSMADMIN_MAX_COPY_SETS];

private:
    CMediaCopyWizardSelect * m_pPage;

public:
    virtual ~CCopySetList();

    // Generated message map functions
protected:
    //{{AFX_MSG(CCopySetList)
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizardSelect dialog

class CMediaCopyWizardSelect : public CSakWizardPage
{
// Construction
public:
    CMediaCopyWizardSelect();
    ~CMediaCopyWizardSelect();

// Dialog Data
    //{{AFX_DATA(CMediaCopyWizardSelect)
    enum { IDD = IDD_WIZ_CAR_COPY_SELECT };
    CCopySetList m_List;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CMediaCopyWizardSelect)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation

protected:
    // Generated message map functions
    //{{AFX_MSG(CMediaCopyWizardSelect)
    virtual BOOL OnInitDialog();
    afx_msg void OnSelchangeCopyList();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    void SetButtons();

public:

};

/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizardNumCopies dialog

class CMediaCopyWizardNumCopies : public CSakWizardPage
{
// Construction
public:
    CMediaCopyWizardNumCopies();
    ~CMediaCopyWizardNumCopies();

// Dialog Data
    //{{AFX_DATA(CMediaCopyWizardNumCopies)
    enum { IDD = IDD_WIZ_CAR_COPY_NUM_COPIES };
    CSpinButtonCtrl m_SpinMediaCopies;
    CEdit   m_EditMediaCopies;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CMediaCopyWizardNumCopies)
    public:
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
public:
    HRESULT GetNumMediaCopies( USHORT* pNumMediaCopies, USHORT* pEditMediaCopies = 0 );

private:
    void SetButtons();

protected:
    // Generated message map functions
    //{{AFX_MSG(CMediaCopyWizardNumCopies)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeEditMediaCopies();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizardIntro dialog

class CMediaCopyWizardIntro : public CSakWizardPage
{
// Construction
public:
    CMediaCopyWizardIntro();
    ~CMediaCopyWizardIntro();

// Dialog Data
    //{{AFX_DATA(CMediaCopyWizardIntro)
    enum { IDD = IDD_WIZ_CAR_COPY_INTRO };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CMediaCopyWizardIntro)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation

protected:
    // Generated message map functions
    //{{AFX_MSG(CMediaCopyWizardIntro)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CMediaCopyWizardFinish dialog

class CMediaCopyWizardFinish : public CSakWizardPage
{
// Construction
public:
    CMediaCopyWizardFinish();
    ~CMediaCopyWizardFinish();

// Dialog Data
    //{{AFX_DATA(CMediaCopyWizardFinish)
    enum { IDD = IDD_WIZ_CAR_COPY_FINISH };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CMediaCopyWizardFinish)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation

protected:
    // Generated message map functions
    //{{AFX_MSG(CMediaCopyWizardFinish)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};


class CMediaCopyWizard : public CSakWizardSheet
{
// Construction
public:
    CMediaCopyWizard();
    virtual ~CMediaCopyWizard();

public:
    // Property Pages
    CMediaCopyWizardIntro       m_pageIntro;
    CMediaCopyWizardNumCopies   m_pageNumCopies;
    CMediaCopyWizardSelect      m_pageSelect;
    CMediaCopyWizardFinish      m_pageFinish;

// Attributes
public:
    USHORT m_numMediaCopiesOrig;  // Number of media copies from RMS
        
// Operations
public:

// Implementation
public:
    virtual HRESULT OnFinish( void );
    STDMETHOD( AddWizardPages ) ( IN RS_PCREATE_HANDLE Handle, IN IUnknown* pPropSheetCallback, IN ISakSnapAsk* pSakSnapAsk );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\volume\manvol.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    ManVol.h

Abstract:

    Node representing a Managed Volume.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#ifndef _MANVOL_H
#define _MANVOL_H

#include "PrMrSts.h"
#include "PrMrIE.h"
#include "PrMrLvl.h"
#include "SakNodeI.h"

class ATL_NO_VTABLE CUiManVol : 
    public CSakNodeImpl<CUiManVol>,
    public CComCoClass<CUiManVol,&CLSID_CUiManVol>,
    public CComDualImpl<IManVolProp, &IID_IManVolProp, &LIBID_HSMADMINLib>
{

public:
// constructor/destructor
    CUiManVol(void) {};
BEGIN_COM_MAP(CUiManVol)
    COM_INTERFACE_ENTRY2(IDispatch, IManVolProp)
    COM_INTERFACE_ENTRY2(ISakNodeProp, IManVolProp)
    COM_INTERFACE_ENTRY(IHsmEvent)
    COM_INTERFACE_ENTRY(ISakNode)
    COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CUiManVol)

    // for multiple-inheritance, forward all base implementations to CSakNode.
    FORWARD_BASEHSM_IMPLS 

    HRESULT FinalConstruct( void );
    void    FinalRelease( void );

public: 
    STDMETHOD( InvokeCommand )        ( SHORT sCmd, IDataObject *pDataObject );
    STDMETHOD( GetContextMenu )       ( BOOL bMultiSelect, HMENU *phMenu );

    // ISakNode methods
    STDMETHOD( InitNode )                  ( ISakSnapAsk* pSakSnapAsk, IUnknown* pHsmObj, ISakNode* pParent );
    STDMETHOD( TerminateNode )             ( void );
    STDMETHOD( AddPropertyPages )          ( RS_NOTIFY_HANDLE handle, IUnknown* pUnkPropSheetCallback, IEnumGUID* pEnumObjectId, IEnumUnknown *pEnumUnkNode );
    STDMETHOD( RefreshObject )             ( );
    STDMETHOD( OnToolbarButtonClick )      ( IDataObject *pDataObject, long cmdId );
    STDMETHOD( GetResultIcon )             ( IN BOOL bOK, OUT int* pIconIndex );
    STDMETHOD( SupportsProperties )        ( BOOL bMutliSelec );
    STDMETHOD( SupportsRefresh )           ( BOOL bMutliSelect );
    STDMETHOD( IsValid )                   ( );


    // IManVolProp methods
    STDMETHOD( get_DesiredFreeSpaceP )  ( BSTR *pszValue );
    STDMETHOD( get_DesiredFreeSpaceP_SortKey )( BSTR *pszValue );
    STDMETHOD( get_MinFileSizeKb )      ( BSTR *pszValue );
    STDMETHOD( get_AccessDays )         ( BSTR *pszValue );
    STDMETHOD( get_FreeSpaceP )         ( BSTR *pszValue );
    STDMETHOD( get_Capacity )           ( BSTR *pszValue );
    STDMETHOD( get_Capacity_SortKey )   ( BSTR *pszValue );
    STDMETHOD( get_FreeSpace )          ( BSTR *pszValue );
    STDMETHOD( get_FreeSpace_SortKey )  ( BSTR *pszValue );
    STDMETHOD( get_Premigrated )        ( BSTR *pszValue );
    STDMETHOD( get_Truncated )          ( BSTR *pszValue );

    // static, class-wide variables
    static INT  m_nScopeOpenIconIndex;  // virtual scope index of Open Icon
    static INT  m_nScopeCloseIconIndex; // virtual scope index of Close Icon
    static INT  m_nResultIconIndex; // virtual scope index of Close Icon

private:
    HRESULT RemoveObject( );
    HRESULT ShowManVolProperties (IDataObject *pDataObject, int initialPage);
    HRESULT CreateAndRunManVolJob (HSM_JOB_DEF_TYPE jobType);
    HRESULT HandleTask(IDataObject * pDataObject, HSM_JOB_DEF_TYPE jobType);
    HRESULT IsDataObjectMs              ( IDataObject *pDataObject );
    HRESULT IsDataObjectOt              ( IDataObject *pDataObject );
    HRESULT IsDataObjectMultiSelect     ( IDataObject *pDataObject );
    HRESULT GetOtFromMs                 ( IDataObject *pDataObject, IDataObject ** pOtDataObject );
    HRESULT GetTaskTypeMessageId        ( HSM_JOB_DEF_TYPE jobType, BOOL multiSelect, UINT* msgId );
    HRESULT IsAvailable                 ( );

    // Put properties
    HRESULT put_DesiredFreeSpaceP (int percent); 
    HRESULT put_MinFileSizeKb (LONG minFileSizeKb);
    HRESULT put_AccessDays (int accessTimeDays);
    HRESULT put_FreeSpaceP (int percent);
    HRESULT put_Capacity (LONGLONG capacity);
    HRESULT put_FreeSpace (LONGLONG freeSpace);
    HRESULT put_Premigrated (LONGLONG premigrated);
    HRESULT put_Truncated (LONGLONG truncated);
    HRESULT put_IsAvailable( BOOL Available );


    // Properties for display
    int m_DesiredFreeSpaceP;
    LONG m_MinFileSizeKb;
    int m_AccessDays;
    int m_FreeSpaceP;
    LONGLONG m_Capacity;
    LONGLONG m_FreeSpace;
    LONGLONG m_Premigrated;
    LONGLONG m_Truncated;
    HRESULT  m_HrAvailable;

    static int m_nResultIconD;    
    static UINT    m_MultiSelect;
    static UINT    m_ObjectTypes;


public:
    CComPtr <IFsaResource> m_pFsaResource;

};

class CUiManVolSheet : public CSakVolPropSheet
{
public:
    HRESULT AddPropertyPages( );
    HRESULT GetNextFsaResource( int *pBookMark, IFsaResource ** ppFsaResource );
    CUiManVolSheet( ) { };

private:
};


#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\volume\manvolls.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    ManVolLs.cpp

Abstract:

    Node representing Managed Volumes as a whole.

Author:

    Rohde Wakefield [rohde]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"

#include "WzMnVlLs.h"           // managed Resource creation wizard
#include "PrMrSts.h"
#include "ManVolLs.h"

int CUiManVolLst::m_nScopeCloseIcon  = AddScopeImage( IDI_DEVLST );
int CUiManVolLst::m_nScopeCloseIconX = AddScopeImage( IDI_DEVLSTX );
int CUiManVolLst::m_nScopeOpenIcon   = AddScopeImage( IDI_NODEOPENFOLDER );
int CUiManVolLst::m_nScopeOpenIconX  = CUiManVolLst::m_nScopeCloseIconX;
int CUiManVolLst::m_nResultIcon      = AddResultImage( IDI_DEVLST );
int CUiManVolLst::m_nResultIconX     = AddResultImage( IDI_DEVLSTX );

/////////////////////////////////////////////////////////////////////////////
//
// CoComObjectRoot
//
/////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------
//
//         FinalConstruct
//
//  Initialize this level of the object hierarchy
//

HRESULT CUiManVolLst::FinalConstruct( )
{
    WsbTraceIn( L"CUiManVolLst::FinalConstruct", L"" );

    m_rTypeGuid = &cGuidManVolLst;

    HRESULT hr = CSakNode::FinalConstruct( );
    m_bSupportsPropertiesSingle = TRUE;
    m_bSupportsPropertiesMulti  = FALSE;
    m_bSupportsDeleteSingle     = FALSE;
    m_bSupportsDeleteMulti      = FALSE;
    m_bSupportsRefreshSingle    = TRUE;
    m_bSupportsRefreshMulti     = FALSE;
    m_bIsContainer              = TRUE;
    m_bHasDynamicChildren       = TRUE;

    // Toolbar values
    INT i = 0;
#if 0 // MS does not want us to have schedule toolbar button
    m_ToolbarButtons[i].nBitmap = 0;
    m_ToolbarButtons[i].idCommand =     TB_CMD_VOLUME_LIST_SCHED;
    m_ToolbarButtons[i].idButtonText =  IDS_TB_TEXT_VOLUME_LIST_SCHED;
    m_ToolbarButtons[i].idTooltipText = IDS_TB_TIP_VOLUME_LIST_SCHED;
    i++;
#endif

    m_ToolbarButtons[i].nBitmap       = 0;
    m_ToolbarButtons[i].idCommand     = TB_CMD_VOLUME_LIST_NEW;
    m_ToolbarButtons[i].idButtonText  = IDS_TB_TEXT_VOLUME_LIST_NEW;
    m_ToolbarButtons[i].idTooltipText = IDS_TB_TIP_VOLUME_LIST_NEW;
    i++;

    m_ToolbarBitmap             = IDB_TOOLBAR_VOLUME_LIST;
    m_cToolbarButtons           = i;

    WsbTraceOut( L"CUiManVolLst::FinalConstruct", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


//---------------------------------------------------------------------------
//
//         FinalRelease
//
//  Clean up this level of the object hierarchy
//

void CUiManVolLst::FinalRelease( )
{
    WsbTraceIn( L"CUiManVolLst::FinalRelease", L"" );

    CSakNode::FinalRelease( );

    WsbTraceOut( L"CUiManVolLst::FinalRelease", L"" );
}


/////////////////////////////////////////////////////////////////////////////
//
// ISakNode
//
/////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------
//
//         GetContextMenu
//
//  Return an HMENU to be used for context menus on this node.
//  Set the state of the menus according to the engine state.
//

STDMETHODIMP 
CUiManVolLst::GetContextMenu( BOOL /* bMultiSelect */, HMENU* phMenu )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    try {
        LoadContextMenu( IDR_MANVOLLST, phMenu );
        CMenu* pRootMenu, *pNewMenu, *pTaskMenu;
        CMenu menu;
        menu.Attach( *phMenu );
        pRootMenu = menu.GetSubMenu( MENU_INDEX_ROOT );
        pNewMenu  = menu.GetSubMenu( MENU_INDEX_NEW );
        pTaskMenu = menu.GetSubMenu( MENU_INDEX_TASK );

        //
        // If engine down, disable these items
        //
        if ( m_pSakSnapAsk->GetState() != S_OK ) {

            pNewMenu->EnableMenuItem( ID_MANVOLLST_NEW_MANVOL, MF_GRAYED | MF_BYCOMMAND );

        }
        menu.Detach();

    } WsbCatch( hr );
    return( hr );
}


//---------------------------------------------------------------------------
//
//         InvokeCommand
//
//  User has selected a command from the menu. Process it here.
//

STDMETHODIMP 
CUiManVolLst::InvokeCommand( SHORT sCmd, IDataObject* /* pDataObject */ )
{
    WsbTraceIn( L"CUiManVolLst::InvokeCommand", L"sCmd = <%d>", sCmd );

    CString theString;
    HRESULT hr = S_OK;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    try {
        switch (sCmd) {

            case MMC_VERB_REFRESH:
                RefreshObject( );
                RefreshScopePane( );
                break;

            case ID_MANVOLLST_ROOT_MANVOL:
            case ID_MANVOLLST_NEW_MANVOL:
            {
                //
                // use wizard to create manage volume
                //
                CComObject<CWizManVolLst>* pWizard = new CComObject<CWizManVolLst>;
                WsbAffirmAlloc( pWizard );

                CComPtr<ISakWizard> pSakWizard = (ISakWizard*)pWizard;
                WsbAffirmHr( m_pSakSnapAsk->CreateWizard( pSakWizard ) );

                if( S_OK == pWizard->m_HrFinish ) {

                    WsbAffirmHr( RefreshScopePane( ) );

                }
                break;
            }
            
            default:
                WsbThrow( S_FALSE );
                break;
        }

    } WsbCatch( hr ); 

    WsbTraceOut( L"CUiManVolLst::InvokeCommand", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CUiManVolLst::SetupToolbar( IToolbar *pToolbar ) 
{
    WsbTraceIn( L"CUiManVolLst::SetupToolbar", L"pToolbar = <0x%p>", pToolbar );
    HRESULT hr = S_OK;

    try {

        for( INT i = 0; i < m_cToolbarButtons; i++ ) {

            m_ToolbarButtons[i].fsState = (UCHAR)( ( S_OK == m_pSakSnapAsk->GetState( ) ) ? TBSTATE_ENABLED : 0 );

        }

        WsbAffirmHr( CSakNode::SetupToolbar( pToolbar ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVolLst::SetupToolbar", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

HRESULT CUiManVolLst::OnToolbarButtonClick( IDataObject* /* pDataObject */, long cmdId )
{
    WsbTraceIn( L"CUiManVolLst::OnToolbarButtonClick", L"cmdId = <%d>", cmdId );
    HRESULT hr = S_OK;
    try {

        switch ( cmdId ) {
        
        case TB_CMD_VOLUME_LIST_NEW:

            {
                //
                // use wizard to create manage volume
                //
                CComObject<CWizManVolLst>* pWizard = new CComObject<CWizManVolLst>;
                WsbAffirmAlloc( pWizard );

                CComPtr<ISakWizard> pSakWizard = (ISakWizard*)pWizard;
                WsbAffirmHr( m_pSakSnapAsk->CreateWizard( pSakWizard ) );

                if( S_OK == pWizard->m_HrFinish ) {

                WsbAffirmHr( RefreshScopePane() );

            }
            break;
        }
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVolLst::OnToolbarButtonClick", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


//---------------------------------------------------------------------------------
//
//                  RefreshObject
//
//  Refresh data in the object.  This function is used for data that can change
//  (for example, volume utilization).
//
STDMETHODIMP CUiManVolLst::RefreshObject ()
{
    WsbTraceIn( L"CUiManVolLst::RefreshObject", L"" );

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;

    try {

        //
        // Get the server objects
        //
        m_pHsmServer.Release( );
        m_pFsaServer.Release( );
        m_pFsaFilter.Release( );
        m_pManResCollection.Release( );

        if( m_pSakSnapAsk->GetHsmServer( &m_pHsmServer ) == S_OK) {

            // Get the FsaServer object
            if ( m_pSakSnapAsk->GetFsaServer( &m_pFsaServer ) == S_OK) {

                // Get the Fsa Filter object
                WsbAffirmHr( m_pFsaServer->GetFilter( &m_pFsaFilter ) );

                // Tell FSA to rescan (updates properties)
                WsbAffirmHr( m_pFsaServer->ScanForResources( ) );

                // Get Managed Volumes collection from HSM server
                WsbAffirmHr( m_pHsmServer->GetManagedResources( &m_pManResCollection ) );

            }
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVolLst::RefreshObject", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CUiManVolLst::ShowManVolLstProperties (IDataObject *pDataObject, int initialPage)
{
    WsbTraceIn( L"CUiManVolLst::ShowManVolLstProperties", L"initialPage = <%d>", initialPage );

    HRESULT hr = S_OK;
    try {

        CComPtr <ISakNode> pSakNode;
        WsbAffirmHr( _InternalQueryInterface( IID_ISakNode, (void **) &pSakNode ) );
        WsbAffirmHr( m_pSakSnapAsk->ShowPropertySheet( pSakNode, pDataObject, initialPage ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVolLst::ShowManVolLstProperties", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//----------------------------------------------------------------------------
//
//      AddPropertyPages
//
STDMETHODIMP 
CUiManVolLst::AddPropertyPages( RS_NOTIFY_HANDLE handle, IUnknown* pUnkPropSheetCallback, IEnumGUID *pEnumObjectId, IEnumUnknown *pEnumUnkNode )
{
    WsbTraceIn( L"CUiManVolLst::AddPropertyPages", L"handle = <%ld>, pUnkPropSheetCallback = <0x%0.l8x>, pEnumObjectId = <0x%p>", 
        handle, pUnkPropSheetCallback, pEnumObjectId );
    HRESULT hr = S_OK;
    try {

        //
        // Create an object to hold the pages
        //
        CUiManVolLstSheet *pManVolPropertySheet = new CUiManVolLstSheet;
        WsbAffirmAlloc( pManVolPropertySheet );
        WsbAffirmHr( pManVolPropertySheet->InitSheet(
            handle, 
            pUnkPropSheetCallback, 
            (CSakNode *) this,
            m_pSakSnapAsk,
            pEnumObjectId,
            pEnumUnkNode
            ) );

        //
        // Tell the object to add it's pages
        //
        WsbAffirmHr( pManVolPropertySheet->AddPropertyPages( ) );

    } WsbCatch ( hr );

    WsbTraceOut( L"CUiManVolLst::AddPropertyPages", L"hr = <%ls>", WsbHrAsString( hr ) );
    return ( hr );
}



//---------------------------------------------------------------------------
//
//         CreateChildren
//
//  Create and initialize all the children of the Managed Resource List node.
//

STDMETHODIMP CUiManVolLst::CreateChildren( )
{
    WsbTraceIn( L"CUiManVolLst::CreateChildren", L"" );


    // Initialize the children of this node (no recursion. Decendents of children
    // are NOT created here)
    CComPtr<IUnknown> pUnkChild;            // IUnknown pointer to new child.
    CComPtr<ISakNode> pNode;
    HRESULT hr = S_OK;

    try {

        //
        // Get pointer to Hsm Managed Resource Collection object stored
        // in this UI node. This may be NULL in the case of the service
        // being down, in which case we don't want to do anything.
        //
        if( m_pManResCollection ) {

            ULONG count = 0;    // number of managed Resources in server
            WsbAffirmHr( m_pManResCollection->GetEntries( &count ) );

            CComPtr<IUnknown> pUnkHsmManRes;                // unknown pointer to Hsm volume
            for( int i = 0; i < (int)count; i++ ) {

                pUnkChild.Release( );
                pNode.Release( );
                pUnkHsmManRes.Release( );

                // Create a managed Resource UI node for each managed volume in the HsmServer.
                WsbAffirmHr( NewChild( cGuidManVol, &pUnkChild ) );
                WsbAffirmHr( RsQueryInterface( pUnkChild, ISakNode, pNode ) );

                WsbAffirmHr( m_pManResCollection->At( i, IID_IUnknown, (void**)&pUnkHsmManRes ) );
                // Initialize the child UI COM object, putting the Hsm managed Resource 
                // object inside the UI object.
                WsbAffirmHr( pNode->InitNode( m_pSakSnapAsk, pUnkHsmManRes, this ) );
    
                // Add the child COM object to the parent's list of children.
                WsbAffirmHr( AddChild( pNode ) );

            }

        }

    } WsbCatch( hr );

    // Indicate that this node's children are valid and up-to-date (even if there ARE
    // no children - at least now we know it).
    m_bChildrenAreValid = TRUE;

    // indicate that this parent node needs to be re-enumerated
    m_bEnumState = FALSE;

    WsbTraceOut( L"CUiManVolLst::CreateChildren", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

//---------------------------------------------------------------------------
//
//         InitNode
//
//  Initialize single COM object without using the registry. Derived
//  objects frequently augment this method by implementing it themselves.
//

STDMETHODIMP CUiManVolLst::InitNode(
    ISakSnapAsk* pSakSnapAsk,
    IUnknown*    pHsmObj,
    ISakNode*    pParent
    )
{
    WsbTraceIn( L"CUiManVolLst::InitNode", L"pSakSnapAsk = <0x%p>, pHsmObj = <0x%p>, pParent = <0x%p>", pSakSnapAsk, pHsmObj, pParent );

    HRESULT hr = S_OK;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    try {

        WsbAffirmHr( CSakNode::InitNode( pSakSnapAsk, NULL, pParent ) );

        //
        // Set the object properties
        // Display Name
        //
        CString sDisplayName;
        sDisplayName.LoadString( IDS_MANVOLLST_DISPLAY_NAME );
        CWsbStringPtr szWsbDisplayName( sDisplayName );
        WsbAffirmHr( put_DisplayName( szWsbDisplayName ) );

        //
        // Description
        //
        CString sDescription;
        sDescription.LoadString( IDS_MANVOLLST_DESCRIPTION );
        CWsbStringPtr szWsbDescription( sDescription );
        WsbAffirmHr( put_Description( szWsbDescription ) );

        //
        // Set up the result view columns
        //
        WsbAffirmHr( SetChildProps( RS_STR_RESULT_PROPS_MANRESLST_IDS,
                                    IDS_RESULT_PROPS_MANRESLST_TITLES,
                                    IDS_RESULT_PROPS_MANRESLST_WIDTHS));
        
        
        WsbAffirmHr( RefreshObject( ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVolLst::InitNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP
CUiManVolLst::TerminateNode(
    )
/*++

Routine Description:

    Free any interface connections or other resources
    that would prevent correct shutdown of node (would
    keep ref count from going to 0).

Arguments:

    CopySet - copy set of interest.

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_* - Some error occurred. 

--*/
{
    WsbTraceIn( L"CUiManVolLst::TerminateNode", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // Release any interface pointers kept so that circular references
        // are broken
        //
        m_pFsaServer.Release( ); 
        m_pManResCollection.Release( );
        m_pHsmServer.Release( );
        m_pFsaFilter.Release( );
        m_pSchedAgent.Release( );
        m_pTask.Release( );
        m_pTrigger.Release( );


        //
        // And call the base class for it's pieces
        //
        WsbAffirmHr( CSakNode::TerminateNode( ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVolLst::TerminateNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// class CUiManVolLstSheet
//
HRESULT CUiManVolLstSheet::AddPropertyPages ( )
{
    WsbTraceIn( L"CUiManVolLstSheet::AddPropertyPages", L"" ); 
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;

    try {

        // --------------------- Statistics Page ----------------------------------

        // NOTE: We now use the same page as the volume property sheet !!

        CPrMrSts *pPropPageStatus = new CPrMrSts( TRUE );
        WsbAffirmAlloc( pPropPageStatus );

        AddPage( pPropPageStatus );


        // Add more pages here.
        // ....

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVolLstSheet::AddPropertyPages", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CUiManVolLstSheet::GetNextFsaResource ( int *pBookMark, IFsaResource **ppFsaResource )
{
    WsbTraceIn( L"CUiManVolLstSheet::GetNextFsaResource", L"*pBookMark = <%d>", *pBookMark ); 

    HRESULT hr = S_OK;
    HRESULT hrInternal = S_OK;

    try {

        WsbAffirm ( *pBookMark >= 0, E_FAIL );

        CComPtr <IWsbIndexedCollection> pManResCollection;
        WsbAffirmHr( GetManResCollection( &pManResCollection ) );

        CComPtr <IHsmManagedResource> pHsmManRes;
        CComPtr <IUnknown> pUnkFsaRes;
        hr = pManResCollection->At(*pBookMark, IID_IHsmManagedResource, (void**) &pHsmManRes);
        if ( hr == S_OK ) {

            (*pBookMark)++;
            WsbAffirmHr( pHsmManRes->GetFsaResource( &pUnkFsaRes ));
            WsbAffirmHr( pUnkFsaRes->QueryInterface( IID_IFsaResource, (void**) ppFsaResource ) );

        }

    } WsbCatch (hr);

    WsbTraceOut( L"CUiManVolLstSheet::GetNextFsaResource", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}


// This function is to be called from the page thread
HRESULT CUiManVolLstSheet::GetManResCollection( IWsbIndexedCollection **ppManResCollection )
{
    WsbTraceIn( L"CUiManVolLstSheet::GetManResCollection", L"" ); 
    HRESULT hr = S_OK;

    try {

        CComPtr <IHsmServer> pHsmServer;
        WsbAffirmHrOk( GetHsmServer( &pHsmServer ) );

        //
        // Get Managed Volumes collection from HSM server
        // 
        WsbAffirmHr( pHsmServer->GetManagedResources( ppManResCollection ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVolLstSheet::GetManResCollection", L"hr = <%ls>, *ppManResCollection = <0x%p>", 
        WsbHrAsString( hr ), *ppManResCollection );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\volume\manvol.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    ManVol.cpp

Abstract:

    Managed Volume node implementation.

Author:

    Rohde Wakefield [rohde]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include <mstask.h>

#include "ManVol.h"

#include "PrMrSts.h"
#include "PrMrIe.h"

#include "WzUnmang.h"

int CUiManVol::m_nResultIcon      = AddResultImage( IDI_NODEMANVOL );
int CUiManVol::m_nResultIconX     = AddResultImage( IDI_NODEMANVOLX );
int CUiManVol::m_nResultIconD     = AddResultImage( IDI_NODEMANVOLD );
// Not used
int CUiManVol::m_nScopeCloseIcon  = AddScopeImage( IDI_NODEMANVOL );
int CUiManVol::m_nScopeCloseIconX = AddScopeImage( IDI_NODEMANVOLX );
int CUiManVol::m_nScopeOpenIcon   = CUiManVol::m_nScopeCloseIcon;
int CUiManVol::m_nScopeOpenIconX  = CUiManVol::m_nScopeCloseIconX;

UINT CUiManVol::m_ObjectTypes    = RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);
UINT CUiManVol::m_MultiSelect    = RegisterClipboardFormat(CCF_MULTI_SELECT_SNAPINS);


/////////////////////////////////////////////////////////////////////////////
//
// CoComObjectRoot
//
/////////////////////////////////////////////////////////////////////////////


//---------------------------------------------------------------------------
//
//         FinalConstruct
//
//  Initialize this level of the object hierarchy
//

HRESULT CUiManVol::FinalConstruct( )
{
    WsbTraceIn( L"CUiManVol::FinalConstruct", L"" );

    m_rTypeGuid = &cGuidManVol;

    HRESULT hr = CSakNode::FinalConstruct( );
    m_bSupportsPropertiesSingle = TRUE;
    m_bSupportsPropertiesMulti  = TRUE;
    m_bSupportsDeleteSingle     = FALSE;
    m_bSupportsDeleteMulti      = FALSE;
    m_bSupportsRefreshSingle    = TRUE;
    m_bSupportsRefreshMulti     = FALSE;
    m_bIsContainer              = FALSE;
    m_pFsaResource              = NULL;
    m_HrAvailable               = S_FALSE;

    // Toolbar values
    INT i = 0;
#if 0 // MS does not want these toolbar buttons to show up
    m_ToolbarButtons[i].nBitmap = 0;
    m_ToolbarButtons[i].idCommand = TB_CMD_VOLUME_SETTINGS;
    m_ToolbarButtons[i].idButtonText = IDS_TB_TEXT_VOLUME_SETTINGS;
    m_ToolbarButtons[i].idTooltipText = IDS_TB_TIP_VOLUME_SETTINGS;
    i++;

    m_ToolbarButtons[i].nBitmap = 1;
    m_ToolbarButtons[i].idCommand = TB_CMD_VOLUME_TOOLS;
    m_ToolbarButtons[i].idButtonText = IDS_TB_TEXT_VOLUME_TOOLS;
    m_ToolbarButtons[i].idTooltipText = IDS_TB_TIP_VOLUME_TOOLS;
    i++;

    m_ToolbarButtons[i].nBitmap = 2;
    m_ToolbarButtons[i].idCommand = TB_CMD_VOLUME_RULES;
    m_ToolbarButtons[i].idButtonText = IDS_TB_TEXT_VOLUME_RULES;
    m_ToolbarButtons[i].idTooltipText = IDS_TB_TIP_VOLUME_RULES;
    i++;
#endif

    m_ToolbarBitmap             = IDB_TOOLBAR_VOLUME;
    m_cToolbarButtons           = i;

    WsbTraceOut( L"CUiManVol::FinalConstruct", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


//---------------------------------------------------------------------------
//
//         FinalRelease
//
//  Clean up this level of the object hierarchy
//

void CUiManVol::FinalRelease( )
{
    WsbTraceIn( L"CUiManVol::FinalRelease", L"" );

    CSakNode::FinalRelease( );

    WsbTraceOut( L"CUiManVol::FinalRelease", L"" );
}


/////////////////////////////////////////////////////////////////////////////
//
// ISakNode
//
/////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------
//
//         GetContextMenu
//
//  Return an HMENU to be used for context menus on this node.
//

STDMETHODIMP
CUiManVol::GetContextMenu( BOOL bMultiSelect, HMENU* phMenu )
{
    WsbTraceIn( L"CUiManVol::GetContextMenu", L"" );
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    try {

        WsbAffirmPointer( m_pFsaResource );

        LoadContextMenu( IDR_MANVOL, phMenu );

        CMenu* pRootMenu;
        CMenu* pTaskMenu;
        CMenu menu;
        menu.Attach( *phMenu );
        pRootMenu = menu.GetSubMenu( MENU_INDEX_ROOT );
        pTaskMenu = menu.GetSubMenu( MENU_INDEX_TASK );

        //
        // If multi-select, disable these items
        //
        //
        // else if engine down or resource is being unmanaged, or appears to be missing
        // (formatted new?), disable these items
        //

        BOOL bState = ( m_pSakSnapAsk->GetState( ) == S_OK );
        BOOL bDeletePending = ( m_pFsaResource->IsDeletePending( ) == S_OK );
        BOOL bAvailable = ( IsAvailable( ) == S_OK );

        if( bMultiSelect ) {

            pRootMenu->EnableMenuItem( ID_MANVOL_ROOT_RULES,  MF_GRAYED | MF_BYCOMMAND );
            pRootMenu->EnableMenuItem( ID_MANVOL_ROOT_REMOVE, MF_GRAYED | MF_BYCOMMAND );

        }
        else {

            pRootMenu->EnableMenuItem( ID_MANVOL_ROOT_LEVELS, MF_BYCOMMAND |
                ( ( !bState || bDeletePending || !bAvailable ) ? MF_GRAYED : MF_ENABLED ) );

            pRootMenu->EnableMenuItem( ID_MANVOL_ROOT_TASKS,  MF_BYCOMMAND |
                ( ( !bState || bDeletePending || !bAvailable ) ? MF_GRAYED : MF_ENABLED ) );

            pRootMenu->EnableMenuItem( ID_MANVOL_ROOT_RULES,  MF_BYCOMMAND |
                ( ( !bState || bDeletePending || !bAvailable ) ? MF_GRAYED : MF_ENABLED ) );

            pRootMenu->EnableMenuItem( ID_MANVOL_ROOT_REMOVE, MF_BYCOMMAND |
                ( ( !bState || bDeletePending ) ? MF_GRAYED : MF_ENABLED ) );

            pTaskMenu->EnableMenuItem( ID_MANVOL_ROOT_TOOLS_COPY, MF_BYCOMMAND |
                ( ( !bState || bDeletePending || !bAvailable ) ? MF_GRAYED : MF_ENABLED ) );

            pTaskMenu->EnableMenuItem( ID_MANVOL_ROOT_TOOLS_VALIDATE, MF_BYCOMMAND |
                ( ( !bState || bDeletePending || !bAvailable ) ? MF_GRAYED : MF_ENABLED ) );

            pTaskMenu->EnableMenuItem( ID_MANVOL_ROOT_TOOLS_CREATE_FREESPACE, MF_BYCOMMAND |
                ( ( !bState || bDeletePending || !bAvailable ) ? MF_GRAYED : MF_ENABLED ) );

        }

        menu.Detach( );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::GetContextMenu", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


//---------------------------------------------------------------------------
//
//         InvokeCommand
//
//  User has selected a command from the menu. Process it here.
//

STDMETHODIMP
CUiManVol::InvokeCommand( SHORT sCmd, IDataObject* pDataObject )
{
    WsbTraceIn( L"CUiManVol::InvokeCommand", L"sCmd = <%d>", sCmd );

    CString theString;
    HRESULT hr = S_OK;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    try {

        WsbAffirmPointer( m_pFsaResource );

        if( S_OK != m_pFsaResource->IsDeletePending( ) ) {

            switch( sCmd ) {

                case ID_MANVOL_ROOT_REMOVE:
                    //
                    // Should not be called for multi-select
                    //
                    RemoveObject();
                    break;

                case ID_MANVOL_ROOT_LEVELS:
                case ID_MANVOL_TASK_LEVELS:
                    ShowManVolProperties( pDataObject, 1 );
                    break;

                case ID_MANVOL_ROOT_RULES:
                case ID_MANVOL_TASK_RULES:
                    //
                    // Should not be called for multi-select
                    //
                    ShowManVolProperties( pDataObject, 2 );
                    break;

                case ID_MANVOL_ROOT_TOOLS_COPY :
                    HandleTask( pDataObject, HSM_JOB_DEF_TYPE_MANAGE );
                    break;

                case ID_MANVOL_ROOT_TOOLS_VALIDATE :
                    HandleTask( pDataObject, HSM_JOB_DEF_TYPE_VALIDATE );
                    break;

                case ID_MANVOL_ROOT_TOOLS_CREATE_FREESPACE :
                    HandleTask( pDataObject, HSM_JOB_DEF_TYPE_TRUNCATE );
                    break;

                default:
                    break;
            }

        } else {

            CString message;
            AfxFormatString1( message, IDS_ERR_VOLUME_DELETE_PENDING, m_szName );
            AfxMessageBox( message, RS_MB_ERROR );

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::InvokeCommand", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CUiManVol::OnToolbarButtonClick( IDataObject *pDataObject, long cmdId )
{
    WsbTraceIn( L"CUiManVol::OnToolbarButtonClick", L"cmdId = <%d>", cmdId );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( m_pFsaResource );

        if( S_OK != m_pFsaResource->IsDeletePending( ) ) {

            try {

                switch( cmdId ) {

                case TB_CMD_VOLUME_SETTINGS:
                    ShowManVolProperties( pDataObject, 1 );
                    break;

                case TB_CMD_VOLUME_TOOLS:
                    ShowManVolProperties( pDataObject, 2 );
                    break;

                case TB_CMD_VOLUME_RULES:
                    ShowManVolProperties( pDataObject, 3 );
                    break;
                }

            } WsbCatch( hr );


        } else {

            CString message;
            AfxFormatString1( message, IDS_ERR_VOLUME_DELETE_PENDING, m_szName );
            AfxMessageBox( message, RS_MB_ERROR );

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::OnToolbarButtonClick", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


HRESULT CUiManVol::ShowManVolProperties( IDataObject *pDataObject, int initialPage )
{
    WsbTraceIn( L"CUiManVol::ShowManVolProperties", L"initialPage = <%d>", initialPage );

    HRESULT hr = S_OK;
    try {

        CComPtr<ISakNode> pSakNode;
        WsbAffirmHr( _InternalQueryInterface( IID_ISakNode, (void **) &pSakNode ) );
        WsbAffirmHr( m_pSakSnapAsk->ShowPropertySheet( pSakNode, pDataObject, initialPage ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::ShowManVolProperties", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

HRESULT CUiManVol::CreateAndRunManVolJob( HSM_JOB_DEF_TYPE jobType )
{
    WsbTraceIn( L"CUiManVol::CreateAndRunManVolJob", L"jobType = <0x%p>", jobType );

    HRESULT hr = 0;
    try {

        WsbAffirmPointer( m_pFsaResource );

        //
        // Get a pointer to the FsaResource interface
        //
        CComPtr<IHsmServer>   pHsmServer;

        WsbAffirmHrOk( m_pSakSnapAsk->GetHsmServer( &pHsmServer ) );

        RsCreateAndRunFsaJob( jobType, pHsmServer, m_pFsaResource );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::CreateAndRunManVolJob", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

HRESULT CUiManVol::HandleTask( IDataObject * pDataObject, HSM_JOB_DEF_TYPE jobType )
{
    WsbTraceIn( L"CUiManVol::HandleTask", L"pDataObject = <0x%p>, jobType = <0x%p>", pDataObject, jobType );

    HRESULT hr = 0;
    try {

        UINT nMsgId = 0;

        CComPtr<IHsmServer>   pHsmServer;

        WsbAffirmHrOk( m_pSakSnapAsk->GetHsmServer( &pHsmServer ) );

        //
        // Submit jobs for all selected FsaResource's
        //
        if ( IsDataObjectMultiSelect( pDataObject ) == S_OK )
        {
            CComPtr<IDataObject> pOtDataObject;

            if ( IsDataObjectMs( pDataObject ) == S_OK ) {
                WsbAffirmHr( GetOtFromMs( pDataObject, &pOtDataObject ) );
            }
            else {
                pOtDataObject = pDataObject;
            }

            // Get a pointer to a FsaResource attribute out of the data
            ULONG nElem = 1;
            CComPtr<IMsDataObject> pMsDataObject;
            CComPtr<IUnknown> pUnkNode;
            CComPtr<IEnumUnknown> pEnumUnkNode;

            WsbAffirmHr( pOtDataObject.QueryInterface( &pMsDataObject ) );
            WsbAffirmHr( pMsDataObject->GetNodeEnumerator( &pEnumUnkNode ) );

            // Prompt the user that we are about to submit the jobs.
            CString tempString;
            UINT msgId = 0;
            WsbAffirmHr( GetTaskTypeMessageId( jobType, TRUE, &msgId ) );
            CWsbStringPtr computerName;
            WsbAffirmHr( pHsmServer->GetName( &computerName ) );
            CString message;
            AfxFormatString1( message, msgId, computerName );

            tempString.LoadString( IDS_RUN_JOB_MULTI2 );
            message += tempString;

            if ( AfxMessageBox( message, MB_ICONINFORMATION | MB_OKCANCEL | MB_DEFBUTTON2 ) == IDOK )
            {

                while ( pEnumUnkNode->Next( nElem, &pUnkNode, NULL ) == S_OK )
                {
                    CComPtr<ISakNode> pNode;
                    WsbAffirmHr( pUnkNode.QueryInterface( &pNode ) );
                    pUnkNode.Release();

                    CComPtr<IUnknown> pUnk;
                    WsbAffirmHr( pNode->GetHsmObj( &pUnk ) );
                    CComPtr<IHsmManagedResource> pManRes;
                    WsbAffirmHr( pUnk.QueryInterface( &pManRes ) );

                    //
                    // Then Get Coresponding FSA resource
                    //
                    CComPtr<IUnknown> pUnkFsaRes;
                    WsbAffirmHr( pManRes->GetFsaResource( &pUnkFsaRes ) );
                    CComPtr<IFsaResource> pFsaResource;
                    WsbAffirmHr( pUnkFsaRes.QueryInterface( &pFsaResource ) );

                    RsCreateAndRunFsaJob( jobType, pHsmServer, pFsaResource, FALSE );

                }
            }
        }
        else
        {
            WsbAffirmPointer( m_pFsaResource );

            // Prompt the user that we are about to submit the jobs.
            UINT msgId = 0;
            WsbAffirmHr( GetTaskTypeMessageId( jobType, FALSE, &msgId ) );
            CWsbStringPtr computerName;
            WsbAffirmHr( pHsmServer->GetName( &computerName ) );

            CString message;
            AfxFormatString1( message, msgId, computerName );

            CString jobName;
            WsbAffirmHr( RsCreateJobName( jobType, m_pFsaResource, jobName ) );
            CString tempString;
            AfxFormatString1( tempString, IDS_MONITOR_TASK, jobName );

            message += tempString;

            if ( AfxMessageBox( message, MB_ICONINFORMATION | MB_OKCANCEL | MB_DEFBUTTON2 ) == IDOK ) {

              RsCreateAndRunFsaJob( jobType, pHsmServer, m_pFsaResource, FALSE );

            }
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::HandleTask", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

HRESULT
CUiManVol::GetTaskTypeMessageId( HSM_JOB_DEF_TYPE jobType, BOOL multiSelect, UINT* msgId ) {
    WsbTraceIn( L"CUiManVol::GetTaskTypeMessageId", L"jobType = <%d>, msgId = <%d>, multiSelect = <%d>", jobType, msgId, multiSelect );

    HRESULT hr = 0;
    try {

        WsbAffirmPointer( msgId );

        switch ( jobType ) {

        case HSM_JOB_DEF_TYPE_MANAGE :
            if ( multiSelect )

                *msgId = IDS_RUN_MULTI_COPY_JOBS;

            else

                *msgId = IDS_RUN_COPY_JOB;

            break;

        case HSM_JOB_DEF_TYPE_VALIDATE :
            if ( multiSelect )

                *msgId = IDS_RUN_MULTI_VALIDATE_JOBS;

            else

                *msgId = IDS_RUN_VALIDATE_JOB;

            break;

        case HSM_JOB_DEF_TYPE_TRUNCATE :
            if ( multiSelect )

                *msgId = IDS_RUN_MULTI_CFS_JOBS;

            else

                *msgId = IDS_RUN_CFS_JOB;

            break;

        default:
            break;
        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::GetTaskTypeMessageId", L"jobType = <%d>, msgId = <%d>, multiSelect = <%d>", jobType, msgId, multiSelect );

    return hr;
}

// Is the dataobject either type of multi-select dataobject?
HRESULT
CUiManVol::IsDataObjectMultiSelect   ( IDataObject *pDataObject )
{
    HRESULT hr = S_OK;
    hr = ( ( (IsDataObjectOt( pDataObject ) ) == S_OK ) ||
        ( (IsDataObjectMs( pDataObject ) ) == S_OK ) ) ? S_OK : S_FALSE;
    return hr;
}

// Is the dataobject an Object Types dataobject?
HRESULT
CUiManVol::IsDataObjectOt ( IDataObject *pDataObject )
{
    HRESULT hr = S_FALSE;

    // Is this a mutli-select data object?
    FORMATETC fmt = {(CLIPFORMAT)m_ObjectTypes, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgm = {TYMED_HGLOBAL, NULL};

    if ( pDataObject->GetData( &fmt, &stgm ) == S_OK ) {
        hr = S_OK;
    }

    ReleaseStgMedium( &stgm );

    return hr;
}

// Is the dataobject a Mutli-Select dataobject?
HRESULT
CUiManVol::IsDataObjectMs ( IDataObject *pDataObject )
{
    HRESULT hr = S_FALSE;

    // Is this a mutli-select data object?
    FORMATETC fmt = {(CLIPFORMAT)m_MultiSelect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgm = {TYMED_HGLOBAL, NULL};

    if ( pDataObject->GetData( &fmt, &stgm ) == S_OK ) {
        hr = S_OK;
    }

    ReleaseStgMedium( &stgm );

    return hr;
}

HRESULT
CUiManVol::GetOtFromMs( IDataObject * pDataObject, IDataObject ** ppOtDataObject )
{
    WsbTraceIn( L"CUiManVol::GetOtFromMs", L"pDataObject = <0x%p>, ppOtDataObject = <0x%p>", pDataObject, ppOtDataObject );

    HRESULT hr = S_OK;

    try {

        // We've got an MMC mutli-select data object.  Get the first
        // data object from it's array of data objects

        FORMATETC fmt = {(CLIPFORMAT)m_MultiSelect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        STGMEDIUM stgm = {TYMED_HGLOBAL, NULL};

        WsbAffirmHr ( pDataObject->GetData( &fmt, &stgm ) == S_OK );
        DWORD count;
        memcpy( &count, stgm.hGlobal, sizeof (DWORD) );
        if ( count > 0 ) {

            //
            // The following code is admittedly UGLY
            // We have a data stream where we need to skip past the
            // first DWORD count and grab an interface pointer.
            // Other snapins code does it as follows:

//            IDataObject * pDO;
//            memcpy( &pDO, (DWORD *) stgm.hGlobal + 1, sizeof(IDataObject*) );

            //
            // However, since this code does an indirect cast (via memcpy)
            // from DWORD to IDataObject*, and does not keep a true reference
            // on the interface pointer, we will use a smart pointer.
            // The (DWORD*) and +1 operation bump our pointer past the count.
            // We then need to grab the next bytes in the buffer and use them
            // as a IDataObject *.
            //
            CComPtr<IDataObject> pOtDataObject;
            pOtDataObject = *( (IDataObject**)( (DWORD *) stgm.hGlobal + 1 ) );

            WsbAffirmHr( pOtDataObject->QueryInterface( IID_IDataObject, (void**) ppOtDataObject ) );

        }

        ReleaseStgMedium( &stgm );

    } WsbCatch ( hr );

    WsbTraceOut( L"CUiManVol::GetOtFromMs", L"pDataObject = <0x%p>, ppOtDataObject = <0x%p>", pDataObject, ppOtDataObject );
    return ( hr );
}

STDMETHODIMP
CUiManVol::AddPropertyPages( RS_NOTIFY_HANDLE handle, IUnknown* pUnkPropSheetCallback, IEnumGUID *pEnumObjectId, IEnumUnknown *pEnumUnkNode )
{
    WsbTraceIn( L"CUiManVol::AddPropertyPages", L"handle = <%ld>, pUnkPropSheetCallback = <0x%0.l8x>, pEnumObjectId = <0x%p>",
        handle, pUnkPropSheetCallback, pEnumObjectId );
    HRESULT hr = S_OK;
    try {

        //
        // Make sure we can still contact the engine before doing this
        // If not running, we shouldn't even exist so update parent
        //
        CComPtr<IHsmServer> pHsmServer;
        HRESULT hrRunning = m_pSakSnapAsk->GetHsmServer( &pHsmServer );
        if( S_FALSE == hrRunning ) {

            m_pSakSnapAsk->UpdateAllViews( m_pParent );

        }
        WsbAffirmHrOk( hrRunning );

        //
        // Create an object to hold the pages
        //
        CUiManVolSheet *pManVolPropertySheet = new CUiManVolSheet;
        WsbAffirmAlloc( pManVolPropertySheet );
        WsbAffirmHr( pManVolPropertySheet->InitSheet(
            handle,
            pUnkPropSheetCallback,
            this,
            m_pSakSnapAsk,
            pEnumObjectId,
            pEnumUnkNode
            ) );

        //
        // Tell the object to add it's pages
        //
        WsbAffirmHr( pManVolPropertySheet->AddPropertyPages( ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::AddPropertyPages", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}




//---------------------------------------------------------------------------
//
//         InitNode
//
//  Initialize single COM object. Derived objects frequently augment this
//  method by implementing it themselves.
//

STDMETHODIMP CUiManVol::InitNode(
    ISakSnapAsk* pSakSnapAsk,
    IUnknown*    pHsmObj,
    ISakNode*    pParent
    )
{
    WsbTraceIn( L"CUiManVol::InitNode", L"pSakSnapAsk = <0x%p>, pHsmObj = <0x%p>, pParent = <0x%p>", pSakSnapAsk, pHsmObj, pParent );

    HRESULT hr = S_OK;
    try {

        WsbAffirmHr( CSakNode::InitNode( pSakSnapAsk, pHsmObj, pParent ));

        //
        // Get the Fsa object pointer
        //
        CComQIPtr<IHsmManagedResource, &IID_IHsmManagedResource> pHsmManRes = m_pHsmObj;
        WsbAffirmPointer( pHsmManRes );
        CComPtr<IUnknown> pUnkFsaRes;
        WsbAffirmHr( pHsmManRes->GetFsaResource( &pUnkFsaRes ) );
        m_pFsaResource.Release( );
        WsbAffirmHr( RsQueryInterface( pUnkFsaRes, IFsaResource, m_pFsaResource ) );

        //
        // Get and save the unique Id for this volume
        //
        WsbAffirmHr( m_pFsaResource->GetIdentifier( &m_ObjectId ) );

        //
        // Set up the connection point
        //
        CSakNode::SetConnection( pUnkFsaRes );

        //
        // Set object properties
        //
        RefreshObject();

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::InitNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


STDMETHODIMP
CUiManVol::TerminateNode(
    )
/*++

Routine Description:

    Free any interface connections or other resources
    that would prevent correct shutdown of node (would
    keep ref count from going to 0).

Arguments:

    CopySet - copy set of interest.

    pszValue - return string representing the state.

Return Value:

    S_OK - Handled.

    E_* - Some error occurred.

--*/
{
    WsbTraceIn( L"CUiManVol::TerminateNode", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // Release any interface pointers kept so that circular references
        // are broken
        //
        m_pFsaResource.Release( );

        //
        // call the base class for it's pieces
        //
        CSakNode::TerminateNode( );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::TerminateNode", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT
CUiManVol::RemoveObject()
{
    WsbTraceIn( L"CUiManVol::RemoveObject", L"" );

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    try {

        //
        // use wizard to create manage volume
        //
        CComObject<CUnmanageWizard>* pWizard = new CComObject<CUnmanageWizard>;
        WsbAffirmAlloc( pWizard );

        WsbAffirmHr( pWizard->SetNode( this ) );

        CComPtr<ISakWizard> pSakWizard = (ISakWizard*)pWizard;
        WsbAffirmHr( m_pSakSnapAsk->CreateWizard( pSakWizard ) );

        //
        // Refresh will take place when called back from FSA
        //

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::RemoveObject", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

//---------------------------------------------------------------------------------
//
//                  RefreshObject
//
//  Refresh data in the object.  This function is used for data that can change
//  (for example, volume utilization).
//
//
STDMETHODIMP
CUiManVol::RefreshObject()
{
    WsbTraceIn( L"CUiManVol::RefreshObject", L"" );

    HRESULT     hr = S_OK;
    ULONG       hsmLevel = 0;
    LONGLONG    fileSize = 0;
    BOOL        isRelative = TRUE; // assumed to be TRUE
    FILETIME    accessTime;
    UINT        accessTimeDays;
    LONGLONG    total = 0;
    LONGLONG    free = 0;
    LONGLONG    premigrated = 0;
    LONGLONG    truncated = 0;
    int         percent;

    CString sFormat;

    try {

        WsbAffirmPointer( m_pFsaResource );

        // Get and format the volume name and label
        CString addString;
        WsbAffirmHr( RsGetVolumeDisplayName( m_pFsaResource, addString ) );
        WsbAffirmHr( put_DisplayName( (LPTSTR)(LPCTSTR)addString ) );

        WsbAffirmHr( RsGetVolumeSortKey( m_pFsaResource, addString ) );
        WsbAffirmHr( put_DisplayName_SortKey( (LPTSTR)(LPCTSTR)addString ) );

        // Get level settings
        WsbAffirmHr( m_pFsaResource->GetHsmLevel( &hsmLevel ) );
        put_DesiredFreeSpaceP( hsmLevel / FSA_HSMLEVEL_1 );

        WsbAffirmHr( m_pFsaResource->GetManageableItemLogicalSize( &fileSize ) );
        put_MinFileSizeKb( (LONG) (fileSize / 1024) );  // Show KBytes

        WsbAffirmHr( m_pFsaResource->GetManageableItemAccessTime( &isRelative, &accessTime ) );
        WsbAssert( isRelative, E_FAIL );  // We only do relative time

        // Convert FILETIME to days
        LONGLONG temp = WSB_FT_TICKS_PER_DAY;
        accessTimeDays = (UINT) ( WsbFTtoLL( accessTime ) / temp );

        if (accessTimeDays > 999 ) {
            accessTimeDays = 0;
        }
        put_AccessDays( accessTimeDays );

        // Get statistics
        WsbAffirmHr( m_pFsaResource->GetSizes( &total, &free, &premigrated, &truncated ) );
        percent = (int) ( ( free * 100 ) / total );

        put_FreeSpaceP( percent );
        put_Capacity( total );
        put_FreeSpace( free );
        put_Premigrated( premigrated );
        put_Truncated( truncated );
        put_IsAvailable( IsAvailable( ) == S_OK );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::RefreshObject", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}

//-----------------------------------------------------------------------------
//
//  get and put functions for object properties
//
HRESULT CUiManVol::put_DesiredFreeSpaceP( int percent )
{
    m_DesiredFreeSpaceP = percent;
    return S_OK;
}
HRESULT CUiManVol::put_MinFileSizeKb( LONG minFileSizeKb )
{
    m_MinFileSizeKb = minFileSizeKb;
    return S_OK;
}
HRESULT CUiManVol::put_AccessDays( int accessTimeDays )
{
    m_AccessDays = accessTimeDays;
    return S_OK;
}
HRESULT CUiManVol::put_FreeSpaceP( int percent )
{
    m_FreeSpaceP = percent;
    return S_OK;
}
HRESULT CUiManVol::put_Capacity( LONGLONG capacity )
{
    m_Capacity = capacity;
    return S_OK;
}
HRESULT CUiManVol::put_FreeSpace( LONGLONG freeSpace )
{
    m_FreeSpace = freeSpace;
    return S_OK;
}
HRESULT CUiManVol::put_Premigrated( LONGLONG premigrated )
{
    m_Premigrated = premigrated;
    return S_OK;
}
HRESULT CUiManVol::put_Truncated( LONGLONG truncated )
{
    m_Truncated = truncated;
    return S_OK;
}

STDMETHODIMP CUiManVol::get_DesiredFreeSpaceP( BSTR *pszValue )
{
    HRESULT hr = S_OK;

    try {

        if( S_OK == IsAvailable( ) ) {

            CString sFormat;
            WCHAR buffer[256];

            // Format the byte value
            RsGuiFormatLongLong4Char( ( m_Capacity / (LONGLONG)100 ) * (LONGLONG)(m_DesiredFreeSpaceP), sFormat );

            // Format the percent value
            _itow( m_DesiredFreeSpaceP, buffer, 10 );
            sFormat = sFormat + L"  (" + buffer + L"%)";

            // Allocate the string
            *pszValue = SysAllocString( sFormat );

        } else {

            *pszValue = SysAllocString( L"" );

        }

        WsbAffirmAlloc( *pszValue );

    } WsbCatch( hr );

    return( hr );
}

STDMETHODIMP CUiManVol::get_DesiredFreeSpaceP_SortKey( BSTR *pszValue )
{
    HRESULT hr = S_OK;

    try {

        if( S_OK == IsAvailable( ) ) {

            *pszValue = SysAlloc64BitSortKey( ( m_Capacity / (LONGLONG)100 ) * (LONGLONG)(m_DesiredFreeSpaceP) );

        } else {

            *pszValue = SysAllocString( L"" );

        }

        WsbAffirmAlloc( *pszValue );

    } WsbCatch( hr );

    return( hr );
}

STDMETHODIMP CUiManVol::get_MinFileSizeKb( BSTR *pszValue )
{
    HRESULT hr = S_OK;

    try {

        if( S_OK == IsAvailable( ) ) {

            WCHAR buffer[256];

            // Format the value
            _ltow( m_MinFileSizeKb, buffer, 10 );
            wcscat( buffer, L"KB" );

            // Allocate the string
            *pszValue = SysAllocString( buffer );

        } else {

            *pszValue = SysAllocString( L"" );

        }

        WsbAffirmAlloc( *pszValue );

    } WsbCatch( hr );

    return( hr );
}

STDMETHODIMP CUiManVol::get_AccessDays( BSTR *pszValue )
{
    HRESULT hr = S_OK;
    WCHAR buffer[256];

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    try {

        if( S_OK == IsAvailable( ) ) {

            // Format the value
            _itow( m_AccessDays, buffer, 10 );
            CString sDays;
            sDays.LoadString( IDS_DAYS );
            wcscat( buffer, L" " );
            wcscat( buffer, sDays );

            // Allocate the string
            *pszValue = SysAllocString( buffer );

        } else {

            *pszValue = SysAllocString( L"" );

        }

        WsbAffirmAlloc( *pszValue );

    } WsbCatch( hr );

    return( hr );
}

STDMETHODIMP CUiManVol::get_FreeSpaceP( BSTR *pszValue )
{
    HRESULT hr = S_OK;

    try {

        if( S_OK == IsAvailable( ) ) {

            WCHAR buffer[256];

            // Format the value
            _itow( m_FreeSpaceP, buffer, 10 );
            wcscat( buffer, L"%" );

            // Allocate the string
            *pszValue = SysAllocString( buffer );

        } else {

            *pszValue = SysAllocString( L"" );

        }

        WsbAffirmAlloc( *pszValue );

    } WsbCatch( hr );

    return( hr );
}

STDMETHODIMP CUiManVol::get_Capacity( BSTR *pszValue )
{
    WsbTraceIn( L"CUiManVol::get_Capacity", L"" );
    HRESULT hr = S_OK;

    try {

        if( S_OK == IsAvailable( ) ) {

            CString sFormat;

            // Format the value
            WsbAffirmHr( RsGuiFormatLongLong4Char( m_Capacity, sFormat ) );

            // Allocate the string
            *pszValue = SysAllocString( sFormat );

        } else {

            *pszValue = SysAllocString( L"" );

        }

        WsbAffirmAlloc( *pszValue );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::get_Capacity", L"hr = <%ls>, *pszValue = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( pszValue ) );
    return( hr );
}

STDMETHODIMP CUiManVol::get_Capacity_SortKey( BSTR *pszValue )
{
    WsbTraceIn( L"CUiManVol::get_Capacity_SortKey", L"" );
    HRESULT hr = S_OK;

    try {

        if( S_OK == IsAvailable( ) ) {

            *pszValue = SysAlloc64BitSortKey( m_Capacity );

        } else {

            *pszValue = SysAllocString( L"" );

        }

        WsbAffirmAlloc( *pszValue );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::get_Capacity_SortKey", L"hr = <%ls>, *pszValue = <%ls>", WsbHrAsString( hr ), WsbPtrToStringAsString( pszValue ) );
    return( hr );
}

STDMETHODIMP CUiManVol::get_FreeSpace( BSTR *pszValue )
{
    HRESULT hr = S_OK;

    try {

        if( S_OK == IsAvailable( ) ) {

            CString sFormat;
            WCHAR buffer[256];

            // Format the byte value
            WsbAffirmHr( RsGuiFormatLongLong4Char( m_FreeSpace, sFormat ) );

            // Format the percent value
            _itow( m_FreeSpaceP, buffer, 10 );
            sFormat = sFormat + L"  (" + buffer + L"%)";

            // Allocate the string
            *pszValue = SysAllocString( sFormat );

        } else {

            *pszValue = SysAllocString( L"" );

        }

        WsbAffirmAlloc( *pszValue );

    } WsbCatch( hr );

    return( hr );
}

STDMETHODIMP CUiManVol::get_FreeSpace_SortKey( BSTR *pszValue )
{
    HRESULT hr = S_OK;

    try {

        if( S_OK == IsAvailable( ) ) {

            *pszValue = SysAlloc64BitSortKey( m_FreeSpace );

        } else {

            *pszValue = SysAllocString( L"" );

        }

        WsbAffirmAlloc( *pszValue );

    } WsbCatch( hr );

    return( hr );
}


STDMETHODIMP CUiManVol::get_Premigrated( BSTR *pszValue )
{
    HRESULT hr = S_OK;

    try {

        if( S_OK == IsAvailable( ) ) {

            CString sFormat;

            // Format the value
            WsbAffirmHr( RsGuiFormatLongLong4Char( m_Premigrated, sFormat ) );

            // Allocate the string
            *pszValue = SysAllocString( sFormat );

        } else {

            *pszValue = SysAllocString( L"" );

        }

        WsbAffirmAlloc( *pszValue );

    } WsbCatch( hr );

    return( hr );
}

STDMETHODIMP CUiManVol::get_Truncated( BSTR *pszValue )
{
    HRESULT hr = S_OK;

    try {

        if( S_OK == IsAvailable( ) ) {

            CString sFormat;

            // Format the value
            WsbAffirmHr( RsGuiFormatLongLong4Char( m_Truncated, sFormat ) );

            // Allocate the string
            *pszValue = SysAllocString( sFormat );

        } else {

            *pszValue = SysAllocString( L"" );

        }

        WsbAffirmAlloc( *pszValue );

    } WsbCatch( hr );

    return( hr );
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// class CUiManVolSheet
//
HRESULT CUiManVolSheet::AddPropertyPages( )
{
    WsbTraceIn( L"CUiManVolSheet::AddPropertyPages", L"" );

    HRESULT hr = S_OK;

    try {

        AFX_MANAGE_STATE( AfxGetStaticModuleState() );

        //
        //-----------------------------------------------------------
        // Create the Hsm Statistics property page.
        //
        CPrMrSts *pPropPageStatus = new CPrMrSts();
        WsbAffirmAlloc( pPropPageStatus );

        AddPage( pPropPageStatus );

        //
        //----------------------------------------------------------
        // Create the Hsm levels property page.
        //
        CPrMrLvl *pPropPageLevels = new CPrMrLvl();
        WsbAffirmAlloc( pPropPageLevels );

        AddPage( pPropPageLevels );

        if( IsMultiSelect() != S_OK ) {

            //
            //----------------------------------------------------------
            // Create the Hsm Include/Exclude property page.
            //
            CPrMrIe *pPropPageIncExc = new CPrMrIe();
            WsbAffirmAlloc( pPropPageIncExc );

            AddPage( pPropPageIncExc );

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVolSheet::AddPropertyPages", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CUiManVolSheet::GetNextFsaResource( int *pBookMark, IFsaResource **ppFsaResource )
{
    WsbTraceIn( L"CUiManVolSheet::GetNextFsaResource", L"*pBookMark = <%ld>", WsbPtrToLongAsString( (LONG*)pBookMark ) );

    HRESULT hr = S_OK;
    GUID objectId;

    try {

        WsbAffirmPointer( pBookMark );
        WsbAffirm( *pBookMark >= 0, E_FAIL );

        //
        // Get the Fsa Server so we can get Fsa Resources
        //
        CComPtr <IFsaServer> pFsaServer;
        WsbAffirmHr( GetFsaServer( &pFsaServer ) );

        if( *pBookMark <= m_ObjectIdList.GetUpperBound( ) ) {

            objectId = m_ObjectIdList[ *pBookMark ];
            (*pBookMark)++;
            WsbAffirmHr( pFsaServer->FindResourceById( objectId, ppFsaResource ) );

        } else {

            hr = S_FALSE;

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVolSheet::GetNextFsaResource", L"hr = <%ls>", WsbHrAsString( hr ) );
    return hr;
}


STDMETHODIMP
CUiManVol::GetResultIcon(
    IN  BOOL bOK,
    OUT int* pIconIndex
    )
{
    WsbTraceIn( L"CUiManVol::GetResultIcon", L"" );

    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( m_pFsaResource );

        if( S_OK == IsAvailable( ) ) {

            //
            // Check to make sure it's not deleted (or being deleted)
            // If so, put on the X
            //
            bOK = ( S_FALSE == m_pFsaResource->IsDeletePending( ) && S_OK == m_pFsaResource->IsManaged( ) );
            WsbAffirmHr( CSakNodeImpl<CUiManVol>::GetResultIcon( bOK, pIconIndex ) );

        } else {

            *pIconIndex = m_nResultIconD;

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::GetResultIcon", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );

}

STDMETHODIMP
CUiManVol::SupportsProperties(
    BOOL bMultiSelect
    )
{
    WsbTraceIn( L"CUiManVol::SupportsProperties", L"" );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( m_pFsaResource );

        if( !bMultiSelect &&
            ( S_OK == m_pFsaResource->IsDeletePending( ) || S_OK != IsAvailable( ) ) ) {

            hr = S_FALSE;

        } else {

            hr = CSakNode::SupportsProperties( bMultiSelect );

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::SupportsProperties", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CUiManVol::SupportsRefresh( BOOL bMultiSelect )
{
    WsbTraceIn( L"CUiManVol::SupportsRefresh", L"" );
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( m_pFsaResource );

        if( !bMultiSelect && S_OK == m_pFsaResource->IsDeletePending( ) ) {

            hr = S_FALSE;

        } else {

            hr = CSakNode::SupportsRefresh( bMultiSelect );

        }

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::SupportsRefresh", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

STDMETHODIMP CUiManVol::IsValid( void )
{
    WsbTraceIn( L"CUiManVol::IsValid", L"" );

    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer( m_pFsaResource );

        //
        // Still valid if managed.
        //
        WsbAffirmHrOk( m_pFsaResource->IsManaged( ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::IsValid", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CUiManVol::IsAvailable( void )
{
    WsbTraceIn( L"CUiManVol::IsAvailable", L"" );

    HRESULT hr = S_FALSE;

    try {

        WsbAffirmPointer( m_pFsaResource );

        //
        // Under certain circumstances we can't get a good answer back, so
        // we have to rely on the last answer we got.
        //
        HRESULT hrAvailable = m_pFsaResource->IsAvailable( );
        if( RPC_E_CANTCALLOUT_ININPUTSYNCCALL == hrAvailable ) {

            hrAvailable = m_HrAvailable;

        }

        hr = hrAvailable;
        m_HrAvailable = hrAvailable;

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::IsAvailable", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

HRESULT CUiManVol::put_IsAvailable( BOOL Available )
{
    WsbTraceIn( L"CUiManVol::put_IsAvailable", L"Available = <%ls>", WsbBoolAsString( Available ) );

    HRESULT hr = S_FALSE;

    try {

        m_HrAvailable = Available ? S_OK : S_FALSE;

    } WsbCatch( hr );

    WsbTraceOut( L"CUiManVol::put_IsAvailable", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\volume\prmrie.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    PrMrIe.cpp

Abstract:

    Inclusion / Exclusion property Page.

Author:

    Art Bragg [abragg]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include "PrMrIe.h"
#include "Rule.h"
#include "joblib.h"
#include "manvol.h"
#include "IeList.h"

static DWORD pHelpIds[] = 
{

    IDC_LIST_IE_LABEL,  idh_rule_list,
    IDC_LIST_IE,        idh_rule_list,
    IDC_BTN_ADD,        idh_new_rule_button,    
    IDC_BTN_REMOVE,     idh_rule_delete_button, 
    IDC_BTN_EDIT,       idh_rule_edit_button,   
    IDC_BTN_UP,         idh_rule_up_button, 
    IDC_BTN_DOWN,       idh_rule_down_button,   

    0, 0
};

// Columns for listview control
#define IE_COLUMN_ACTION        0
#define IE_COLUMN_FILE_TYPE     1
#define IE_COLUMN_PATH          2
#define IE_COLUMN_ATTRS         3

int CALLBACK CompareFunc( LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort );
int PathCollate( CString PathA, CString PathB );

/////////////////////////////////////////////////////////////////////////////
// CPrMrIe property page

CPrMrIe::CPrMrIe( ) : CSakVolPropPage( CPrMrIe::IDD )
{
    //{{AFX_DATA_INIT( CPrMrIe )
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    m_hConsoleHandle = NULL;
    m_LineCount      = 0;
    m_pHelpIds       = pHelpIds;
}

CPrMrIe::~CPrMrIe( )
{
    int i;
    // Clean up old lines
    for( i = 0; i < m_LineCount; i++ ) {
        if( m_LineList[ i ] ) {
            delete m_LineList[ i ];
        }
    }
    m_LineCount = 0;
}

void CPrMrIe::DoDataExchange( CDataExchange* pDX )
{
    CSakVolPropPage::DoDataExchange( pDX );
    //{{AFX_DATA_MAP( CPrMrIe )
    DDX_Control( pDX, IDC_BTN_UP, m_BtnUp );
    DDX_Control( pDX, IDC_BTN_REMOVE, m_BtnRemove );
    DDX_Control( pDX, IDC_BTN_EDIT, m_BtnEdit );
    DDX_Control( pDX, IDC_BTN_DOWN, m_BtnDown );
    DDX_Control( pDX, IDC_BTN_ADD, m_BtnAdd );
    DDX_Control( pDX, IDC_LIST_IE, m_listIncExc );
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP( CPrMrIe, CSakVolPropPage )
    //{{AFX_MSG_MAP( CPrMrIe )
    ON_BN_CLICKED( IDC_BTN_ADD, OnBtnAdd )
    ON_BN_CLICKED( IDC_BTN_DOWN, OnBtnDown )
    ON_BN_CLICKED( IDC_BTN_REMOVE, OnBtnRemove )
    ON_BN_CLICKED( IDC_BTN_UP, OnBtnUp )
    ON_BN_CLICKED( IDC_BTN_EDIT, OnBtnEdit )
    ON_WM_DESTROY( )
    ON_NOTIFY( NM_DBLCLK, IDC_LIST_IE, OnDblclkListIe )
    ON_NOTIFY( NM_CLICK, IDC_LIST_IE, OnClickListIe )
    ON_NOTIFY( LVN_ITEMCHANGED, IDC_LIST_IE, OnItemchangedListIe )
    ON_WM_VSCROLL( )
    ON_WM_DRAWITEM( )
    ON_WM_MEASUREITEM( )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP( )

/////////////////////////////////////////////////////////////////////////////
// CPrMrIe message handlers

BOOL CPrMrIe::OnApply( ) 
{
    ULONG           count = 0;  
    int             i;
    CComPtr<IHsmRule> pLocalRule;
    CString         path;
    CString         name;
    BOOL            bInclude;
    BOOL            bSubdirs;
    BOOL            bUserDefined;
    HRESULT         hr;
    CComPtr<IHsmRule>               pRemoteRule;
    CComPtr<IWsbCreateLocalObject>  pLocalObject;
    CComPtr<IHsmCriteria>           pCriteria;
    CComPtr<IWsbCollection>         pCriteriaCollection;
    CComPtr <IUnknown>              pUnkRule;
    CComPtr <IWsbCollection>        pRulesCollection;

    try {

        // Empty the collection of rules
        WsbAffirmPointer( m_pRulesIndexedCollection );
        WsbAffirmHr( m_pRulesIndexedCollection->QueryInterface( IID_IWsbCollection,( void ** ) &pRulesCollection ) );
        pRulesCollection->RemoveAllAndRelease( );

        //
        // Get a CreateLocalobject interface with which to create the
        // new rule( s ).
        //
        WsbAffirmPointer( m_pFsaServer );
        WsbAffirmHr( m_pFsaServer->QueryInterface( IID_IWsbCreateLocalObject,( void ** ) &pLocalObject ) );

        //
        // Now go through the list box and add the rules in the list box to the 
        // collection. Must do this backwards to be considered correctly by 
        // job mechanism
        //
        int listCount = m_listIncExc.GetItemCount( );
        int insertIndex = 0;

        for( i = listCount - 1; i >= 0; i-- ) {

            //
            // Get the pointer to the rule from the list box
            //
            pLocalRule.Release( );
            pLocalRule = (IHsmRule *) m_listIncExc.GetItemData( i );
            if( pLocalRule ) {

                //
                // Get rule data from the local object
                //
                WsbAffirmHr( GetRuleFromObject( pLocalRule, path,
                    name, &bInclude, &bSubdirs, &bUserDefined ) );
                
                //
                // Create a new remote rule object in the Fsa
                //
                pRemoteRule.Release( );
                WsbAffirmHr( pLocalObject->CreateInstance( CLSID_CHsmRule, IID_IHsmRule,( void** ) &pRemoteRule ) );
                
                //
                // Set the data in the remote rule object
                //
                WsbAffirmHr( SetRuleInObject( pRemoteRule, path, name, bInclude, bSubdirs, bUserDefined ) );
                
                //
                // Add the rule pointer to the collection of rules
                //
                pUnkRule.Release( );
                WsbAffirmHr( pRemoteRule->QueryInterface( IID_IUnknown, (void **) &pUnkRule ) );
                WsbAffirmHr( m_pRulesIndexedCollection->AddAt( pUnkRule, insertIndex++ ) );
                
                //
                // Get the criteria collection pointer
                //
                pCriteriaCollection.Release( );
                WsbAffirmHr( pRemoteRule->Criteria( &pCriteriaCollection ) );
                
                //
                // Add the appropriate criterion to the rule
                //
                pCriteria.Release( );
                switch( bInclude ) {
                case TRUE:
                    //
                    // Include 
                    //
                    WsbAffirmHr( pLocalObject->CreateInstance( CLSID_CHsmCritManageable, IID_IHsmCriteria,( void** ) &pCriteria ) );
                    WsbAffirmHr( pCriteria->SetIsNegated( FALSE ) );
                    break;
                
                case FALSE:
                    //
                    // Exclude
                    //
                    WsbAffirmHr( pLocalObject->CreateInstance( CLSID_CHsmCritAlways, IID_IHsmCriteria,( void** ) &pCriteria ) );
                    WsbAffirmHr( pCriteria->SetIsNegated( FALSE ) );
                    break;

                }
                
                WsbAffirmHr( pCriteriaCollection->Add( pCriteria ) );

            }


        }

        //
        // Tell the FSA to save itself.
        //
        WsbAffirmHr( RsServerSaveAll( m_pFsaServer ) );

    } WsbCatch( hr );

    return CSakVolPropPage::OnApply( );
}
HRESULT CPrMrIe::SetRuleInObject( 
                    IHsmRule *pHsmRule, 
                    CString Path, 
                    CString Name, 
                    BOOL bInclude, 
                    BOOL bSubdirs, 
                    BOOL bUserDefined )
{
    HRESULT hr = S_OK;

    try {
        CWsbStringPtr wsbPath = Path;
        CWsbStringPtr wsbName = Name;
        WsbAffirmHr( pHsmRule->SetPath( ( OLECHAR * )wsbPath ) );
        WsbAffirmHr( pHsmRule->SetName( ( OLECHAR * )wsbName ) );
        WsbAffirmHr( pHsmRule->SetIsInclude( bInclude ) );
        WsbAffirmHr( pHsmRule->SetIsUsedInSubDirs( bSubdirs ) );
        WsbAffirmHr( pHsmRule->SetIsUserDefined( bUserDefined ) );
    } WsbCatch( hr );
    return( hr );
}

BOOL CPrMrIe::OnInitDialog( ) 
{
    CSakVolPropPage::OnInitDialog( );

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    ULONG           count = 0;  
    int             index = 0;
    HRESULT         hr = S_OK;
    CString path;
    CString name;
    BOOL bInclude;
    BOOL bSubdirs;
    BOOL bUserDefined;
    RECT rect;
    CString *columnWidths[20];
    int cColumns;
    int columnWidth[20];
    CString *columnTitles[20];
    CSize size;

    try {
    
        //
        // Set the icons into the buttons
        //
        HRESULT hrAlternateIcon = RsIsWhiteOnBlack( );
        HICON downIcon, upIcon;
        downIcon = (HICON)LoadImage( _Module.m_hInstResource,
            S_OK == hrAlternateIcon ? MAKEINTRESOURCE( IDI_MOVEDOWN2 ) : MAKEINTRESOURCE( IDI_MOVEDOWN ),
            IMAGE_ICON, 16, 16, 0 );
        upIcon   = (HICON)LoadImage( _Module.m_hInstResource,
            S_OK == hrAlternateIcon ? MAKEINTRESOURCE( IDI_MOVEUP2 ) : MAKEINTRESOURCE( IDI_MOVEUP ),
            IMAGE_ICON, 16, 16, 0 );

        m_BtnDown.SetIcon( downIcon );
        m_BtnUp.SetIcon( upIcon );

        //
        // Setup up rules listview
        //
        CString sTitle;
        m_listIncExc.GetClientRect( &rect );
        ULONG totalWidth = rect.right;

        RsGetInitialLVColumnProps( 
            IDS_LISTVIEW_WIDTHS_IE,
            IDS_LISTVIEW_TITLES_IE,
            columnWidths, 
            columnTitles,
            &cColumns
            );

        //
        // NOTE: We shouldn't throw any errors until the DC is released
        //
        for( int col = 0; col < cColumns; col++ ) {

            size = m_listIncExc.GetStringWidth( *columnWidths[col] );
            columnWidth[col] = size.cx + 12;
            m_listIncExc.InsertColumn( col, *columnTitles[col], LVCFMT_LEFT, columnWidth[col] );

            // Free the CStrings
            delete columnTitles[col];
            delete columnWidths[col];

        }

        m_listIncExc.Initialize( cColumns, IE_COLUMN_PATH );

        // Set the Path column to fit
        int leftOver = totalWidth - columnWidth[IE_COLUMN_ACTION] - 
            columnWidth[IE_COLUMN_FILE_TYPE] - columnWidth[IE_COLUMN_ATTRS]; 
        m_listIncExc.SetColumnWidth( IE_COLUMN_PATH, leftOver );

        // Note: this page is only implemented for single select
        WsbAffirm( ( m_pParent->IsMultiSelect( ) != S_OK ), E_FAIL );

        // Get the FsaServer interface - Apply will need it
        WsbAffirmHr( m_pParent->GetFsaServer( &m_pFsaServer ) );
        // Get the resource pointer from the sheet object
        WsbAffirmHr( m_pVolParent->GetFsaResource( &m_pFsaResource ) );

        // Get the rules collection from the resource
        CComPtr <IWsbCollection> pRulesCollection;
        WsbAffirmHr( m_pFsaResource->GetDefaultRules( &pRulesCollection ) );
        WsbAffirmHr( pRulesCollection->QueryInterface( IID_IWsbIndexedCollection, (void **) &m_pRulesIndexedCollection ) );

        CString resourceName;
        WsbAffirmHr( RsGetVolumeDisplayName( m_pFsaResource, resourceName ) );
        m_pResourceName = resourceName;

        // Itterate through the indexed collection
        WsbAffirmHr( m_pRulesIndexedCollection->GetEntries( &count ) );

        CComPtr <IHsmRule> pLocalRule;
        CComPtr <IHsmRule> pHsmRule;

        // Put the rules in the collection in reverse order
        for( INT i =( int ) count - 1; i >= 0; i-- ) {

            pHsmRule.Release( );
            pLocalRule.Release( );
            WsbAffirmHr( m_pRulesIndexedCollection->At( i, IID_IHsmRule,( void** )&pHsmRule ) );

            //
            // Create a local rule object and copy the remote object to it
            //
            WsbAffirmHr( pLocalRule.CoCreateInstance( CLSID_CHsmRule ) );
            WsbAffirmHr( GetRuleFromObject( pHsmRule, path, name, &bInclude, &bSubdirs, &bUserDefined ) );
            WsbAffirmHr( SetRuleInObject( pLocalRule, path, name, bInclude, bSubdirs, bUserDefined ) );

            //
            // Insert rule in list box
            //
            index = m_listIncExc.InsertItem( count - 1 - i, TEXT( "" ) );

            //
            // Set the item data to the local object
            //
            m_listIncExc.SetItemData( index, (UINT_PTR) pLocalRule.Detach( ) );

            //
            // Show the rule in the list box
            //
            WsbAffirmHr( DisplayUserRuleText( &m_listIncExc, index ) );

        } // for

        SortList( );

    } WsbCatch( hr );

    SetBtnState( );
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

//HRESULT CPrMrIe::CreateImageList( )
//{
//  HICON hIcon;
//  int nImage;
//  HRESULT hr;
//
//  AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
//
//  try {
//  
//      CWinApp* pApp = AfxGetApp( );
//
//      WsbAffirm( m_ImageList.Create( ::GetSystemMetrics( SM_CXSMICON ),
//                              ::GetSystemMetrics( SM_CYSMICON ),
//                              ILC_COLOR | ILC_MASK, 2,5 ), E_FAIL );
//
//      hIcon = pApp->LoadIcon( IDI_LOCKED );
//      WsbAffirm( hIcon, E_FAIL );
//      nImage = m_ImageList.Add( hIcon );
//      ::DeleteObject( hIcon );
//
//      hIcon = pApp->LoadIcon( IDI_UNLOCKED );
//      WsbAffirm( hIcon, E_FAIL );
//      nImage = m_ImageList.Add( hIcon );
//      ::DeleteObject( hIcon );
//
//      m_listIncExc.SetImageList( &m_ImageList, LVSIL_SMALL );
//  } WsbCatch( hr );
//  return( hr );
//}

/////////////////////////////////////////////////////////////////////////////////////////////
//
// Display the rule contained in the supplied object in the supplied list at the indicated
// index.  The itemdata must be set to the object with correct data in it.
//
HRESULT  CPrMrIe::DisplayUserRuleText( 
        CListCtrl *pListControl,
        int index )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    HRESULT hr = S_OK;
    try {

        CString textString, tempString;
        CString path, name;
        BOOL bInclude;
        BOOL bSubdirs;
        BOOL bUserDefined;
        CComPtr<IHsmRule> pHsmRule;

        //
        // Get the rule from the object 
        //
        pHsmRule = (IHsmRule *) m_listIncExc.GetItemData( index );
        WsbAssertPointer( pHsmRule );
        WsbAffirmHr( GetRuleFromObject( pHsmRule, path, name, &bInclude, &bSubdirs, &bUserDefined ) );

        //
        // Show the values in the list box
        //

        // ACTION
        textString.LoadString( bInclude ? IDS_INCLUDE : IDS_EXCLUDE );
        WsbAffirm( pListControl->SetItemText( index, IE_COLUMN_ACTION, textString ), E_FAIL );

        // FILE TYPE
        WsbAffirm( pListControl->SetItemText( index, IE_COLUMN_FILE_TYPE, name ), E_FAIL );

        // PATH
        WsbAffirm( pListControl->SetItemText( index, IE_COLUMN_PATH, path ), E_FAIL );

        // ATTRS
        textString.LoadString( bSubdirs ? IDS_RULE_SUBDIRS_USE : IDS_RULE_SUBDIRS_IGNORE );
        tempString.LoadString( bUserDefined ? IDS_RULE_TYPE_USER : IDS_RULE_TYPE_SYSTEM );
        textString.TrimLeft( );
        tempString.TrimLeft( );
        textString += tempString;
        WsbAffirm( pListControl->SetItemText( index, IE_COLUMN_ATTRS, textString ), E_FAIL );

    } WsbCatch( hr );

    return( hr );
}

HRESULT CPrMrIe::GetRuleFromObject( 
        IHsmRule *pHsmRule, 
        CString& Path,
        CString& Name,
        BOOL *bInclude,
        BOOL *bSubdirs,
        BOOL *bUserDefined )
{
    CWsbStringPtr wsbName;
    CWsbStringPtr wsbPath;
    HRESULT hr = S_OK;

    try {

        // Get the values from the object
        WsbAffirmHr( pHsmRule->GetName( &wsbName, 0 ) );
        Name = wsbName;
        WsbAffirmHr ( pHsmRule->GetPath( &wsbPath, 0 ) );
        Path = wsbPath;
        *bInclude =( pHsmRule->IsInclude( ) == S_OK ) ? TRUE : FALSE;
        *bSubdirs =( pHsmRule->IsUsedInSubDirs( ) == S_OK ) ? TRUE : FALSE;
        *bUserDefined =( pHsmRule->IsUserDefined( ) == S_OK ) ? TRUE : FALSE;
    } WsbCatch( hr );
    return( hr );
}
void CPrMrIe::OnBtnAdd( ) 
{
    LRESULT nRet;
    int index;
    BOOL fDone = FALSE;
    HRESULT hr;

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    CRule ruleDlg;
    ruleDlg.m_subDirs = FALSE;
    ruleDlg.m_includeExclude = 0; // Exclude
    ruleDlg.m_path = TEXT( "" );
    ruleDlg.m_fileSpec = TEXT( "" );
    ruleDlg.m_pResourceName = m_pResourceName;

    try {
        while( !fDone )
        {
            nRet = ruleDlg.DoModal( );
            if( nRet == IDOK ) {

                //
                // OK was pressed
                // Check for dupes( in entire list )
                //
                if( !IsRuleInList( ruleDlg.m_path,  ruleDlg.m_fileSpec, -1 ) ) {

                    fDone = TRUE;

                    //
                    // Create a new local rule object
                    //
                    CComPtr <IHsmRule> pLocalRule;
                    WsbAffirmHr( pLocalRule.CoCreateInstance( CLSID_CHsmRule ) );

                    //
                    // Set the data in the local object
                    //
                    WsbAffirmHr( SetRuleInObject( pLocalRule, ruleDlg.m_path, ruleDlg.m_fileSpec,
                                ruleDlg.m_includeExclude, ruleDlg.m_subDirs, TRUE ) );

                    //
                    // Insert the rule and put the pointer in the list.
                    // We will sort the list later
                    //
                    index = m_listIncExc.InsertItem( 0, TEXT( "" ) );

                    //
                    // Set the item data to the local object
                    //
                    m_listIncExc.SetItemData( index, (UINT_PTR) pLocalRule.Detach( ) );
            
                    //
                    // Show the rule in the list box
                    //
                    WsbAffirmHr( DisplayUserRuleText( &m_listIncExc, index ) );

                    //
                    // Sort the list
                    //
                    SortList( );
                    SetSelectedItem( (ULONG_PTR)(void *) pLocalRule );
                    SetModified( );

                } else {

                    //
                    // Rule is a duplicate
                    //
                    CString sText;
                    AfxFormatString2( sText, IDS_ERR_RULE_DUPLICATE, ruleDlg.m_path, ruleDlg.m_fileSpec );
                    AfxMessageBox( sText, RS_MB_ERROR );

                }

            } else {

                //
                // Cancel was pressed
                //
                fDone = TRUE;

            }

        } // while
    } WsbCatch( hr )

    SetBtnState( );
}

// Select the item corresponding to the supplied item data
void CPrMrIe::SetSelectedItem( ULONG_PTR itemData )
{

    int listCount = m_listIncExc.GetItemCount( );
    for( int i = 0; i < listCount; i++ ) {

        // Get the pointer to the rule from the list box
        if( itemData ==( m_listIncExc.GetItemData( i ) ) ) {

            // Mark the item as selected
            m_listIncExc.SetItemState( i, LVIS_SELECTED, LVIS_SELECTED );
            m_listIncExc.EnsureVisible( i, FALSE );
            break;

        }
    }
}

void CPrMrIe::OnBtnDown( ) 
{

    MoveSelectedListItem( &m_listIncExc, + 1 );
    SetBtnState( );
}

void CPrMrIe::SortList( )
{
    m_listIncExc.SortItems( CompareFunc, NULL );
}

int CALLBACK CompareFunc( LPARAM lParam1, LPARAM lParam2, 
    LPARAM /*lParamSort*/ )
{
    CComPtr<IHsmRule> pHsmRule;
    CWsbStringPtr   wsbPathA;
    CWsbStringPtr   wsbPathB;

    // Get data for RuleA
    pHsmRule = (IHsmRule *) lParam1;
    WsbAffirmHr( pHsmRule->GetPath( &wsbPathA, 0 ) );
    CString pathA = wsbPathA;

    // Get data for RuleB
    pHsmRule = (IHsmRule *) lParam2;
    WsbAffirmHr ( pHsmRule->GetPath( &wsbPathB, 0 ) );
    CString pathB = wsbPathB;

    // Upper case the paths
    pathA.MakeUpper( );
    pathB.MakeUpper( );

    // Compare the two paths
    int rVal = PathCollate( pathA, pathB );
//  int rVal = pathA.Collate( pathB );
//  int rVal = pathB.Compare( pathA );

    return rVal;
}

int PathCollate( CString PathA, CString PathB )
{
    CString charA;
    CString charB;
    int compareLen;
    int rVal;

    int lenA = PathA.GetLength( );
    int lenB = PathB.GetLength( );

    compareLen = min( lenA, lenB );

    for( int i = 0; i < compareLen; i++ )
    {
        charA = PathA.GetAt( i );
        charB = PathB.GetAt( i );

        // If either is a \, we bypass Collate
        if( ( charA == L"\\" ) &( charB != L"\\" ) ) {

            // A is \ and B is not - A is less than B
            return -1;

        }
        if( ( charA != L"\\" ) &( charB == L"\\" ) ) {

            // A is not \ and B is - B is less than A
            return 1;

        }

        // NOTE: If both are \, the CString Collate result is correct

        rVal = charA.Collate( charB );
        if( rVal != 0 )  {

            return rVal;

        }

    }
    // If we get here, the strings are equal as far as the shorter string.
    rVal = ( lenA < lenB ) ? -1 : ( lenB < lenA ) ? 1 : 0;

    return rVal;
}

void CPrMrIe::MoveSelectedListItem( CListCtrl *pList, int moveAmount )
{

    int curIndex = -1;
    int itemCount = 0;
    CString         pathA;
    CString         pathB;
    CString         path;
    CString         name;
    BOOL            bInclude;
    BOOL            bSubdirs;
    BOOL            bUserDefined;
    CComPtr<IHsmRule> pLocalRule;

    // Get the current index
    curIndex = pList->GetNextItem( -1, LVNI_SELECTED );

    // Is an item selected?
    if( curIndex != -1 ) {

        // Is this a user-defined rule?
        pLocalRule =( IHsmRule * ) m_listIncExc.GetItemData( curIndex );

        GetRuleFromObject( pLocalRule, path, name, &bInclude, &bSubdirs, &bUserDefined );
        if( bUserDefined ) 
        {
            // Get the item count
            itemCount = pList->GetItemCount( );

            // Is there more than one item in the list?
            if( itemCount > 1 )
            {
                // Make sure where we're moving to is in range
                if( ( ( curIndex + moveAmount ) < itemCount ) &&
                   ( ( curIndex + moveAmount ) >= 0 ) ) {

                    // Does the rule we're moving to have the same path?
                    pathA = pList->GetItemText( curIndex, IE_COLUMN_PATH );
                    pathB = pList->GetItemText( curIndex + moveAmount, IE_COLUMN_PATH );

                    if( pathA.CompareNoCase( pathB ) == 0 ) {
                        // Swap the lines
                        SwapLines( pList, curIndex, curIndex + moveAmount );
                        // Select the orignal line in it's new position and make
                        // sure it's shown.
                        pList->SetItemState( curIndex + moveAmount, LVIS_SELECTED, LVIS_SELECTED );
                        pList->EnsureVisible( curIndex + moveAmount, FALSE );

                        SetModified( );
                    }
                    else {
                        MessageBeep( MB_OK );
                    }

                } else {
                    MessageBeep( MB_OK );
                }
            }
            else { 
                MessageBeep( MB_OK );
            }

        } else {
            MessageBeep( MB_OK );
        }
    } else {
        MessageBeep( MB_OK );
    }
}
void CPrMrIe::SwapLines( CListCtrl *pListControl, int indexA, int indexB )
{

    CComPtr<IHsmRule> pHsmRuleA;
    CComPtr<IHsmRule> pHsmRuleB;

    //-------------------- Get data from list ----------------------------------
    // LIST A
    // Get the item data
    pHsmRuleA = (IHsmRule *) pListControl->GetItemData( indexA );

    // LIST B
    // Get the item data
    pHsmRuleB = (IHsmRule *) pListControl->GetItemData( indexB );

    //--------------------- Show data in list ------------------------------------

    // Set the item data
    m_listIncExc.SetItemData( indexA,( DWORD_PTR )( void * ) pHsmRuleB );

    // Show the rule
    DisplayUserRuleText( pListControl,  indexA );

    // Set the item data
    m_listIncExc.SetItemData( indexB,( DWORD_PTR )( void * ) pHsmRuleA );

    // Show the rule
    DisplayUserRuleText( pListControl,  indexB );

}
    
void CPrMrIe::SetBtnState( )
{
    CString         path;
    CString         name;
    CWsbStringPtr   pathAbove;
    CWsbStringPtr   pathBelow;
    BOOL            bInclude;
    BOOL            bSubdirs;
    BOOL            bUserDefined;
    int             curIndex;
    CComPtr<IHsmRule> pLocalRule;
    CComPtr<IHsmRule> pLocalRuleAbove;
    CComPtr<IHsmRule> pLocalRuleBelow;


    curIndex = m_listIncExc.GetNextItem( -1, LVNI_SELECTED ); 
    if( curIndex != -1 ) {
        // An item is selected.  Is it User-Defined?
        pLocalRule =( IHsmRule * ) m_listIncExc.GetItemData( curIndex );
        if( !pLocalRule ) {

            // Seperator
            m_BtnRemove.EnableWindow( FALSE );
            m_BtnEdit.EnableWindow( FALSE );
            m_BtnAdd.EnableWindow( TRUE );
            m_BtnUp.EnableWindow( FALSE );
            m_BtnDown.EnableWindow( FALSE );

        } else {

            GetRuleFromObject( pLocalRule, path, name, &bInclude, &bSubdirs, &bUserDefined );
            if( bUserDefined ) {
                // User-Defined Rule is editable
                m_BtnRemove.EnableWindow( TRUE );
                m_BtnEdit.EnableWindow( TRUE );
                m_BtnAdd.EnableWindow( TRUE );
                // Are we at the top?
                if( curIndex == 0 ) {

                    m_BtnUp.EnableWindow( FALSE );

                } else {

                    // Does the rule above have the same path? or is separator
                    pLocalRuleAbove =( IHsmRule * ) m_listIncExc.GetItemData( curIndex - 1 );
                    if( pLocalRuleAbove ) {
                        pLocalRuleAbove->GetPath( &pathAbove, 0 );
                        if( path.CompareNoCase( pathAbove ) == 0 ) {
                            m_BtnUp.EnableWindow( TRUE );
                        } else {
                            m_BtnUp.EnableWindow( FALSE );
                        }
                    } else {
                        m_BtnUp.EnableWindow( FALSE );
                    }

                }
                // Are we at the bottom?
                if( curIndex ==( m_listIncExc.GetItemCount( ) - 1 ) ) {
                    m_BtnDown.EnableWindow( FALSE );
                } else {
                    // Does the rule below have the same path?
                    pLocalRuleBelow =( IHsmRule * ) m_listIncExc.GetItemData( curIndex + 1 );
                    if( pLocalRuleBelow ) {
                        pLocalRuleBelow->GetPath( &pathBelow, 0 );
                        if( path.CompareNoCase( pathBelow ) == 0 ) {
                            m_BtnDown.EnableWindow( TRUE );
                        } else {
                            m_BtnDown.EnableWindow( FALSE );
                        }
                    } else {
                        m_BtnDown.EnableWindow( FALSE );
                    }
                }
            }
            else {
                // System rule.  Cannot be moved or modified.
                m_BtnUp.EnableWindow( FALSE );
                m_BtnRemove.EnableWindow( FALSE );
                m_BtnEdit.EnableWindow( FALSE );
                m_BtnDown.EnableWindow( FALSE );
                m_BtnAdd.EnableWindow( TRUE );
            }
        }
    }
    else {
        // No items selected
        m_BtnUp.EnableWindow( FALSE );
        m_BtnRemove.EnableWindow( FALSE );
        m_BtnEdit.EnableWindow( FALSE );
        m_BtnDown.EnableWindow( FALSE );
        m_BtnAdd.EnableWindow( TRUE );
    }
}
    
void CPrMrIe::OnBtnRemove( ) 
{
    int curIndex;
    CString         path;
    CString         name;
    BOOL            bInclude;
    BOOL            bSubdirs;
    BOOL            bUserDefined;
    IHsmRule        *pHsmRule; // OK to not use smart pointer
    HRESULT hr;

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    try {
        // Is there an item selected?
        curIndex = m_listIncExc.GetNextItem( -1, LVNI_SELECTED ); 
        if( curIndex != -1 )
        {
            // Is the rule User-Defined?
            pHsmRule =( IHsmRule * ) m_listIncExc.GetItemData( curIndex );
            GetRuleFromObject( pHsmRule, path, name, &bInclude, &bSubdirs, &bUserDefined );

            if( bUserDefined )
            {

                // Confirm with user
                CString sMessage;
                AfxFormatString2( sMessage, IDS_CONFIRM_DELETE_RULE, path, name );
                if( AfxMessageBox( sMessage, MB_ICONQUESTION | MB_DEFBUTTON2 | MB_YESNO ) == IDYES )
                {
                    // Get and release the local object pointer
                    WsbAffirmPointer( pHsmRule );
                    pHsmRule->Release( );

                    // Remove from the list control
                    m_listIncExc.DeleteItem( curIndex );
                    int setIndex;
                    if( curIndex >= m_listIncExc.GetItemCount( ) ) {
                        setIndex = m_listIncExc.GetItemCount( ) - 1;
                    } else {
                        setIndex = curIndex;
                    }

                    // Select the item above the removed item
                    m_listIncExc.SetItemState( setIndex, LVIS_SELECTED, LVIS_SELECTED );
                    m_listIncExc.EnsureVisible( setIndex, FALSE );
                    SortList( );
                    SetModified( );
                }
            }
            else {
                MessageBeep( MB_OK );
            }
        }
        else {

            // No item selected
            AfxMessageBox( IDS_ERR_NO_ITEM_SELECTED, RS_MB_ERROR );
        }
    } WsbCatch( hr );
    SetBtnState( );
}

void CPrMrIe::OnBtnUp( ) 
{
    MoveSelectedListItem( &m_listIncExc, - 1 );
    SetBtnState( );
}

void CPrMrIe::OnBtnEdit( ) 
{
    BOOL fDone = FALSE;
    LRESULT nRet;
    int curIndex;
    CString path;
    CString name;
    BOOL bInclude;
    BOOL bSubdirs;
    BOOL bUserDefined;

    HRESULT hr;

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );


    try {

        // Get the currently selected item
        curIndex = m_listIncExc.GetNextItem( -1, LVNI_SELECTED );
        if( curIndex == -1 ) {

            // No item selected
            AfxMessageBox( IDS_ERR_NO_ITEM_SELECTED, RS_MB_ERROR );

        } else {

            // Create the rule dialog
            CRule ruleDlg;

            // Get the local object from the list itemdata
            CComPtr<IHsmRule> pLocalRule;
            pLocalRule = (IHsmRule *) m_listIncExc.GetItemData( curIndex );
            WsbAffirmPointer( pLocalRule );

            // Get the rule from the local object
            WsbAffirmHr( GetRuleFromObject( pLocalRule, path, name, &bInclude, &bSubdirs, &bUserDefined ) );

            // Is this a user-defined rule?
            if( bUserDefined ) {

                // Set the rule info in the rule dialog
                ruleDlg.m_subDirs = bSubdirs;
                ruleDlg.m_includeExclude = bInclude; 
                ruleDlg.m_path = path;
                ruleDlg.m_fileSpec = name;
                ruleDlg.m_pResourceName = m_pResourceName;


                while( !fDone ) {

                    // Show the dialog
                    nRet = ruleDlg.DoModal( );
                    if( nRet == IDOK ) {
                        // OK was pressed

                        // Check for duplicates - but don't check against the rule we edited
                        // in case the path and fileSpec are stil the same
                        
                        if( !IsRuleInList( ruleDlg.m_path, ruleDlg.m_fileSpec, curIndex ) ) {

                            fDone = TRUE;
                            SetModified( );

                            // Set the data in the local object
                            WsbAffirmHr( SetRuleInObject( pLocalRule, ruleDlg.m_path, ruleDlg.m_fileSpec,
                                ruleDlg.m_includeExclude, ruleDlg.m_subDirs, TRUE ) );
                            
                            // Show the edited rule in the list box
                            WsbAffirmHr( DisplayUserRuleText( &m_listIncExc, curIndex ) ); 

                            // Resort the list
                            SortList( );
                            SetSelectedItem( (ULONG_PTR)(IHsmRule*) pLocalRule );

                        } else {

                            CString sText;
                            AfxFormatString2( sText, IDS_ERR_RULE_DUPLICATE, ruleDlg.m_path, ruleDlg.m_fileSpec );
                            AfxMessageBox( sText, RS_MB_ERROR );

                        }

                    } else {

                        fDone = TRUE;

                    }

                } // while

            } else { // Not user defined

                MessageBeep( MB_OK );

            }

        }

    } WsbCatch( hr );
    SetBtnState( );
}

BOOL CPrMrIe::IsRuleInList( CString Path, CString Name, int ignoreIndex )
{
    int i;
    int count;
    short result;
    HRESULT hr;
    BOOL fDuplicate = FALSE;
    CWsbStringPtr wsbPath;
    CWsbStringPtr wsbName;

    count = m_listIncExc.GetItemCount( );
    for( i = 0; i < count; i++ ) {
        // Make sure we're not comparing the rule to itself
        if( i != ignoreIndex ) {

            // Get the pointer to the rule from the list box
            CComPtr<IHsmRule> pHsmRule;
            pHsmRule = (IHsmRule *) m_listIncExc.GetItemData( i );
            if( !pHsmRule ) continue;

            // Convert name and path to wsb strings
            wsbPath = Path;
            wsbName = Name;

            hr = pHsmRule->CompareToPathAndName( wsbPath, wsbName, &result );
            if( result == 0 ) {

                // The rules are the same
                fDuplicate = TRUE;
                break;
            }

        }
    } // for
    return fDuplicate;
}

void CPrMrIe::OnDestroy( ) 
{
    HRESULT hr;
    CSakVolPropPage::OnDestroy( );
    IHsmRule *pHsmRule; //OK not to be smart pointer
    ULONG lRefCount;

    try {

        //  Release all local object pointers in the list box
        int listCount = m_listIncExc.GetItemCount( );
        for( int i = 0; i < listCount; i++ )
        {
            // Get the pointer to the rule from the list box
            pHsmRule = (IHsmRule *) m_listIncExc.GetItemData( i );
            if( pHsmRule ) {

                lRefCount = pHsmRule->Release( );

            }

        }

    } WsbCatch( hr );
}

void CPrMrIe::OnDblclkListIe( NMHDR* /*pNMHDR*/, LRESULT* pResult ) 
{
    OnBtnEdit( );
    *pResult = 0;
}

void CPrMrIe::OnClickListIe( NMHDR* /*pNMHDR*/, LRESULT* pResult ) 
{
    SetBtnState( );
    *pResult = 0;
}

void CPrMrIe::OnItemchangedListIe( NMHDR* pNMHDR, LRESULT* pResult ) 
{
    NM_LISTVIEW* pNMListView =( NM_LISTVIEW* )pNMHDR;
    SetBtnState( );
    *pResult = 0;
}


void CPrMrIe::OnVScroll( UINT nSBCode, UINT nPos, CScrollBar* pScrollBar ) 
{
    // TODO: Add your message handler code here and/or call default
    
    CSakVolPropPage::OnVScroll( nSBCode, nPos, pScrollBar );
}

void CPrMrIe::OnDrawItem( int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
    // TODO: Add your message handler code here and/or call default
    
    CSakVolPropPage::OnDrawItem( nIDCtl, lpDrawItemStruct );
}

void CPrMrIe::OnMeasureItem( int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct ) 
{
    CFont *pFont;
    LOGFONT logFont; 

    pFont = GetFont( );
    pFont->GetLogFont( &logFont );

    LONG fontHeight = abs( logFont.lfHeight );

    // Ask the list how high to make each row.  It needs to know the font
    // height at this point because it's window is not yet created.
    lpMeasureItemStruct->itemHeight = m_listIncExc.GetItemHeight( fontHeight );
    
    CSakVolPropPage::OnMeasureItem( nIDCtl, lpMeasureItemStruct );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\volume\manvolls.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    ManVolLs.h

Abstract:

    Node representing Managed Volumes as a whole.

Author:

    Rohde Wakefield [rohde]   12-Aug-1997

Revision History:

--*/

#ifndef _MANVOLLST_H
#define _MANVOLLST_H

#include "PrMrLsRc.h"
#include "SakNodeI.h"

class ATL_NO_VTABLE CUiManVolLst : 
    public CSakNodeImpl<CUiManVolLst>,
    public CComCoClass<CUiManVolLst,&CLSID_CUiManVolLst>
{

public:
// constructor/destructor
    CUiManVolLst(void) {};

BEGIN_COM_MAP(CUiManVolLst)
    COM_INTERFACE_ENTRY2(IDispatch, ISakNodeProp)
    COM_INTERFACE_ENTRY(ISakNode)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(ISakNodeProp)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CUiManVolLst)

    HRESULT FinalConstruct( void );
    void    FinalRelease( void );

public: 
    STDMETHOD( InvokeCommand )        ( SHORT sCmd, IDataObject *pDataObject );
    STDMETHOD( GetContextMenu )       ( BOOL bMultiSelect, HMENU *phMenu );

    // ISakNode methods
    STDMETHOD( CreateChildren )            ( ); 
    STDMETHOD( TerminateNode )             ( void );
    STDMETHOD( InitNode )                  ( ISakSnapAsk* pSakSnapAsk, IUnknown* pHsmObj, ISakNode* pParent );
    STDMETHOD( AddPropertyPages )          ( RS_NOTIFY_HANDLE handle, IUnknown* pUnkPropSheetCallback, IEnumGUID* pEnumObjectId, IEnumUnknown *pEnumUnkNode );
    STDMETHOD( RefreshObject )             ( );
    STDMETHOD( SetupToolbar )               ( IToolbar *pToolbar );
    STDMETHOD( OnToolbarButtonClick )      ( IDataObject *pDataObject, long cmdId );

// data members
    
    // static, class-wide variables
    static INT  m_nScopeOpenIconIndex;  // virtual scope index of Open Icon
    static INT  m_nScopeCloseIconIndex; // virtual scope index of Close Icon
    static INT  m_nResultIconIndex; // virtual scope index of Close Icon

    CComPtr <IFsaServer>            m_pFsaServer; 
    CComPtr <IWsbIndexedCollection> m_pManResCollection;
    CComPtr <IHsmServer>            m_pHsmServer;
    CComPtr <IFsaFilter>            m_pFsaFilter;
    CComPtr <ISchedulingAgent>      m_pSchedAgent;
    CComPtr <ITask>                 m_pTask;
    CComPtr <ITaskTrigger>          m_pTrigger;

private:
    HRESULT ShowManVolLstProperties (IDataObject *pDataObject, int initialPage);
};

class CUiManVolLstSheet : public CSakVolPropSheet
{
public:
    HRESULT AddPropertyPages( );
    HRESULT GetNextFsaResource ( int *pBookMark, IFsaResource ** ppFsaResource );
    HRESULT GetManResCollection( IWsbIndexedCollection ** ppFsaFilter );

private:
    CComPtr <IWsbIndexedCollection> m_pManResCollection;
};

#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\volume\prmrlsrc.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    PrMrLsRc.h

Abstract:

    Managed Volume List Recall limit and schedule page.

Author:

    Rohde Wakefield [rohde]   08-Aug-1997

Revision History:

--*/

#ifndef _PRMRLSRC_H
#define _PRMRLSRC_H

#pragma once

/////////////////////////////////////////////////////////////////////////////
// CPrMrLsRec dialog

class CPrMrLsRec : public CSakPropertyPage
{
// Construction
public:
    CPrMrLsRec();
    ~CPrMrLsRec();

// Dialog Data
    //{{AFX_DATA(CPrMrLsRec)
	enum { IDD = IDD_PROP_RECALL_LIMIT };
	CSpinButtonCtrl	m_spinCopyFilesLimit;
	CEdit	m_editCopyFilesLimit;
    CEdit   m_editRecallLimit;
    CSpinButtonCtrl m_spinRecallLimit;
    ULONG   m_RecallLimit;
    BOOL    m_ExemptAdmins;
	ULONG	m_CopyFilesLimit;
	//}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPrMrLsRec)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CPrMrLsRec)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeEditRecallLimit();
    afx_msg void OnExemptAdmins();
	afx_msg void OnChangeEditCopyfilesLimit();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    // Unmarshalled pointer to Fsa Filter
    CComPtr<IFsaFilter> m_pFsaFilter;

    // pointer to Engine server
    CComPtr<IHsmServer> m_pHsmServer;

private:
    BOOL m_RecallChanged;
    BOOL m_CopyFilesChanged;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\volume\prmrlsrc.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    PrMrLsRc.cpp

Abstract:

    Recall limit Property Page

Author:

    Rohde Wakefield [rohde]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include "PrMrLsRc.h"

static DWORD pHelpIds[] = 
{

    IDC_EXEMPT_ADMINS,              idh_runaway_recall_exemption,
    IDC_EDIT_RECALL_LIMIT,          idh_runaway_recall_limit,
    IDC_SPIN_RECALL_LIMIT,          idh_runaway_recall_limit,
    IDC_EDIT_RECALL_LIMIT_LABEL,    idh_runaway_recall_limit,
    IDC_EDIT_COPYFILES_LIMIT,       idh_concurrent_drives_limit,
    IDC_SPIN_COPYFILES_LIMIT,       idh_concurrent_drives_limit,
    IDC_SPIN_COPYFILES_LIMIT_LABEL, idh_concurrent_drives_limit,

    0, 0
};

/////////////////////////////////////////////////////////////////////////////
// CPrMrLsRec property page

CPrMrLsRec::CPrMrLsRec() : CSakPropertyPage(IDD)
{
    WsbTraceIn( L"CPrMrLsRec::CPrMrLsRec", L"" );
    //{{AFX_DATA_INIT(CPrMrLsRec)
    m_RecallLimit = 0;
    m_ExemptAdmins = FALSE;
	m_CopyFilesLimit = 1;
	//}}AFX_DATA_INIT
    m_RecallChanged = FALSE;
    m_CopyFilesChanged = FALSE;
    m_pHelpIds      = pHelpIds;
    WsbTraceOut( L"CPrMrLsRec::CPrMrLsRec", L"" );
}

CPrMrLsRec::~CPrMrLsRec()
{
}

void CPrMrLsRec::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CPrMrLsRec::DoDataExchange", L"" );
    CSakPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPrMrLsRec)
	DDX_Control(pDX, IDC_SPIN_COPYFILES_LIMIT, m_spinCopyFilesLimit);
	DDX_Control(pDX, IDC_EDIT_COPYFILES_LIMIT, m_editCopyFilesLimit);
    DDX_Control(pDX, IDC_EDIT_RECALL_LIMIT, m_editRecallLimit);
    DDX_Control(pDX, IDC_SPIN_RECALL_LIMIT, m_spinRecallLimit);
    DDX_Text(pDX, IDC_EDIT_RECALL_LIMIT, m_RecallLimit);
    DDV_MinMaxUInt(pDX, m_RecallLimit, 0, 9999);
    DDX_Check(pDX, IDC_EXEMPT_ADMINS, m_ExemptAdmins);
	DDX_Text(pDX, IDC_EDIT_COPYFILES_LIMIT, m_CopyFilesLimit);
	DDV_MinMaxDWord(pDX, m_CopyFilesLimit, 1, 99);
	//}}AFX_DATA_MAP
    WsbTraceOut( L"CPrMrLsRec::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CPrMrLsRec, CSakPropertyPage)
    //{{AFX_MSG_MAP(CPrMrLsRec)
    ON_EN_CHANGE(IDC_EDIT_RECALL_LIMIT, OnChangeEditRecallLimit)
    ON_BN_CLICKED(IDC_EXEMPT_ADMINS, OnExemptAdmins)
	ON_EN_CHANGE(IDC_EDIT_COPYFILES_LIMIT, OnChangeEditCopyfilesLimit)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPrMrLsRec message handlers

BOOL CPrMrLsRec::OnInitDialog() 
{
    WsbTraceIn( L"CPrMrLsRec::OnInitDialog", L"" );
    CSakPropertyPage::OnInitDialog();
    
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    m_spinRecallLimit.SetRange( 0, 9999 );
    m_editRecallLimit.SetLimitText( 4 );

    m_spinCopyFilesLimit.SetRange( 1, 99 );
    m_editCopyFilesLimit.SetLimitText( 2 );

    HRESULT hr = S_OK;

    try {

        // Get HSM relevant objects
        WsbAffirmHr( m_pParent->GetFsaFilter( &m_pFsaFilter ) );
        WsbAffirmHr( m_pParent->GetHsmServer( &m_pHsmServer ) );

        // Set controls to values from the object
        WsbAffirmHr( m_pFsaFilter->GetAdminExemption( &m_ExemptAdmins ) );
        ULONG lMaxRecalls;
        WsbAffirmHr( m_pFsaFilter->GetMaxRecalls( &lMaxRecalls ) );
        m_RecallLimit = lMaxRecalls;
        WsbAffirmHr(m_pHsmServer->GetCopyFilesUserLimit(&m_CopyFilesLimit));

        UpdateData( FALSE );
        m_RecallChanged = FALSE;
        m_CopyFilesChanged = FALSE;

    } WsbCatch( hr );

    WsbTraceOut( L"CPrMrLsRec::OnInitDialog", L"" );
    return TRUE;
}

BOOL CPrMrLsRec::OnApply() 
{
    WsbTraceIn( L"CPrMrLsRec::OnApply", L"" );
    HRESULT hr = S_OK;
    UpdateData( TRUE );

    try {

        if( m_RecallChanged ) {
            WsbAffirmHr( m_pFsaFilter->SetMaxRecalls( m_RecallLimit ) );
            m_RecallChanged = FALSE;
            WsbAffirmHr( m_pFsaFilter->SetAdminExemption( m_ExemptAdmins ) );

            // Save it
            CComPtr<IFsaServer> pFsaServer;
            WsbAffirmHr( m_pParent->GetFsaServer( &pFsaServer ) );
            WsbAffirmHr( RsServerSaveAll( pFsaServer ) );
        } 

        if( m_CopyFilesChanged ) {
            WsbAffirmHr(m_pHsmServer->SetCopyFilesUserLimit(m_CopyFilesLimit));
            m_CopyFilesChanged = FALSE;

            // Save it
            WsbAffirmHr(RsServerSaveAll(m_pHsmServer));
        } 

    } WsbCatch( hr );

    WsbTraceOut( L"CPrMrLsRec::OnApply", L"" );
    return CSakPropertyPage::OnApply();
}

void CPrMrLsRec::OnChangeEditRecallLimit() 
{
    WsbTraceIn( L"CPrMrLsRec::OnChangeEditRecallLimit", L"" );

    SetModified( TRUE );
    m_RecallChanged = TRUE;

    WsbTraceOut( L"CPrMrLsRec::OnChangeEditRecallLimit", L"" );
}


void CPrMrLsRec::OnExemptAdmins() 
{
    WsbTraceIn( L"CPrMrLsRec::OnExemptAdmins", L"" );

    SetModified( TRUE );
    m_RecallChanged = TRUE;

    WsbTraceOut( L"CPrMrLsRec::OnExemptAdmins", L"" );
}

void CPrMrLsRec::OnChangeEditCopyfilesLimit() 
{
    WsbTraceIn( L"CPrMrLsRec::OnChangeEditCopyfilesLimit", L"" );

    SetModified( TRUE );
    m_CopyFilesChanged = TRUE;

    WsbTraceOut( L"CPrMrLsRec::OnChangeEditCopyfilesLimit", L"" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\volume\prmrie.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    PrMrIe.h

Abstract:

    Inclusion / Exclusion property Page.

Author:

    Art Bragg [abragg]   08-Aug-1997

Revision History:

--*/

#ifndef _PRMRIE_H
#define _PRMRIE_H

/////////////////////////////////////////////////////////////////////////////
// CPrMrIe dialog

#include "stdafx.h"
#include "IeList.h"

#define MAX_RULES 512

class CPrMrIe : public CSakVolPropPage
{
// Construction
public:
    CPrMrIe();
    ~CPrMrIe();

// Dialog Data
    //{{AFX_DATA(CPrMrIe)
    enum { IDD = IDD_PROP_MANRES_INCEXC };
    CButton m_BtnUp;
    CButton m_BtnRemove;
    CButton m_BtnEdit;
    CButton m_BtnDown;
    CButton m_BtnAdd;
    CIeList m_listIncExc;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPrMrIe)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CPrMrIe)
    virtual BOOL OnInitDialog();
    afx_msg void OnBtnAdd();
    afx_msg void OnBtnDown();
    afx_msg void OnBtnRemove();
    afx_msg void OnBtnUp();
    afx_msg void OnBtnEdit();
    afx_msg void OnDestroy();
    afx_msg void OnDblclkListIe(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnClickListIe(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnItemchangedListIe(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
    afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
    afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    // Unmarshalled pointer to managed resource 
    CComPtr     <IFsaResource> m_pFsaResource;

    // UnMarshalled pointer to FsaServer
    CComPtr     <IFsaServer> m_pFsaServer;

private:
    CStatic         *m_LineList[MAX_RULES];
    USHORT          m_LineCount;


    CWsbStringPtr   m_pResourceName; // Name of this resource

    // Collection of rules for this managed resource
    CComPtr <IWsbIndexedCollection> m_pRulesIndexedCollection;

//  CImageList m_ImageList;
    

    HRESULT  DisplayUserRuleText (
        CListCtrl *pListControl,
        int index);

    HRESULT GetRuleFromObject (
        IHsmRule *pHsmRule, 
        CString& szPath,
        CString& szName,
        BOOL *bInclude,
        BOOL *bSubdirs,
        BOOL *bUserDefined);

    HRESULT CPrMrIe::SetRuleInObject (
        IHsmRule *pHsmRule, 
        CString szPath, 
        CString szName, 
        BOOL bInclude, 
        BOOL bSubdirs, 
        BOOL bUserDefined);

//  HRESULT CreateImageList(void);

    void MoveSelectedListItem(CListCtrl *pList, int moveAmount);
    void SwapLines(CListCtrl *pListControl, int indexA, int indexB);
    void SetBtnState(void);
    void SortList(void);
    void FixRulePath (CString& sPath);
    BOOL IsRuleInList(CString sPath, CString sFileSpec, int ignoreIndex);
    void SetSelectedItem( ULONG_PTR itemData );

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\volume\prmrlvl.h ===
/*++

(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    PrMrLvl.h

Abstract:

    Header file for Managed Resource Level 
    property page.

Author:

    Art Bragg [abragg]   04-Aug-1997

Revision History:

--*/

#ifndef _PRMRLV_H
#define _PRMRLV_H

#pragma once


/////////////////////////////////////////////////////////////////////////////
// CPrMrLvl dialog

class CPrMrLvl : public CSakVolPropPage
{
// Construction
public:
    CPrMrLvl();
    ~CPrMrLvl();

// Dialog Data
    //{{AFX_DATA(CPrMrLvl)
    enum { IDD = IDD_PROP_MANRES_LEVELS };
    CStatic m_staticActual4Digit;
    CStatic m_staticDesired4Digit;
    CEdit   m_editTime;
    CEdit   m_editSize;
    CEdit   m_editLevel;
    CSpinButtonCtrl m_spinTime;
    CSpinButtonCtrl m_spinSize;
    CSpinButtonCtrl m_spinLevel;
    long    m_hsmLevel;
    DWORD   m_fileSize;
    UINT    m_accessTime;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPrMrLvl)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CPrMrLvl)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeEditLevel();
    afx_msg void OnChangeEditSize();
    afx_msg void OnChangeEditTime();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    CComPtr<IFsaResource> m_pFsaResource;

private:
    void        SetDesiredFreePctControl (int desiredPct);
    HRESULT     InitDialogMultiSelect();
    HRESULT     OnApplyMultiSelect();
    BOOL        m_fChangingByCode;
    LONGLONG    m_capacity;
    BOOL        m_bMultiSelect;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\volume\prmrlvl.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    PrMrLvl.cpp

Abstract:

    Managed Volume Levels Page

Author:

    Art Bragg [abragg]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include "PrMrLvl.h"
#include "manvol.h"

static DWORD pHelpIds[] = 
{

    IDC_STATIC_ACTUAL_FREE_PCT,             idh_actual_free_space_percent,
    IDC_STATIC_ACTUAL_FREE_PCT_LABEL,       idh_actual_free_space_percent,
    IDC_STATIC_ACTUAL_FREE_PCT_UNIT,        idh_actual_free_space_percent,
    IDC_STATIC_FREE_ACTUAL_4DIGIT,          idh_actual_free_space_capacity,
    IDC_EDIT_LEVEL,                         idh_desired_free_space_percent,
    IDC_SPIN_LEVEL,                         idh_desired_free_space_percent,
    IDC_EDIT_LEVEL_LABEL,                   idh_desired_free_space_percent,
    IDC_EDIT_LEVEL_UNIT,                    idh_desired_free_space_percent,
    IDC_STATIC_FREE_DESIRED_4DIGIT,         idh_desired_free_space_capacity,
    IDC_EDIT_SIZE,                          idh_min_file_size_criteria,
    IDC_SPIN_SIZE,                          idh_min_file_size_criteria,
    IDC_EDIT_SIZE_LABEL,                    idh_min_file_size_criteria,
    IDC_EDIT_SIZE_UNIT,                     idh_min_file_size_criteria,
    IDC_EDIT_TIME,                          idh_file_access_date_criteria,
    IDC_SPIN_TIME,                          idh_file_access_date_criteria,
    IDC_EDIT_TIME_LABEL,                    idh_file_access_date_criteria,
    IDC_EDIT_TIME_UNIT,                     idh_file_access_date_criteria,

    0, 0
};


/////////////////////////////////////////////////////////////////////////////
// CPrMrLvl property page

CPrMrLvl::CPrMrLvl() : CSakVolPropPage(CPrMrLvl::IDD)
{
    //{{AFX_DATA_INIT(CPrMrLvl)
    m_hsmLevel = 0;
    m_fileSize = 0;
    m_accessTime = 0;
    //}}AFX_DATA_INIT
    m_hConsoleHandle    = NULL;
    m_capacity          = 0;
    m_fChangingByCode   = FALSE;
    m_pHelpIds          = pHelpIds;
}

CPrMrLvl::~CPrMrLvl()
{
}

void CPrMrLvl::DoDataExchange(CDataExchange* pDX)
{
    CSakVolPropPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPrMrLvl)
    DDX_Control(pDX, IDC_STATIC_FREE_ACTUAL_4DIGIT, m_staticActual4Digit);
    DDX_Control(pDX, IDC_STATIC_FREE_DESIRED_4DIGIT, m_staticDesired4Digit);
    DDX_Control(pDX, IDC_EDIT_TIME, m_editTime);
    DDX_Control(pDX, IDC_EDIT_SIZE, m_editSize);
    DDX_Control(pDX, IDC_EDIT_LEVEL, m_editLevel);
    DDX_Control(pDX, IDC_SPIN_TIME, m_spinTime);
    DDX_Control(pDX, IDC_SPIN_SIZE, m_spinSize);
    DDX_Control(pDX, IDC_SPIN_LEVEL, m_spinLevel);
    //}}AFX_DATA_MAP

    // blank is valid for multi-select
    if( m_bMultiSelect ) {

        CString szLevel;
        CString szSize;
        CString szDays; 

        m_editLevel.GetWindowText( szLevel );
        m_editSize.GetWindowText( szSize );
        m_editTime.GetWindowText( szDays );

        if( szLevel != L"" ) {

            DDX_Text( pDX, IDC_EDIT_LEVEL, m_hsmLevel );
            DDV_MinMaxLong( pDX, m_hsmLevel, HSMADMIN_MIN_FREESPACE, HSMADMIN_MAX_FREESPACE );

        } else {

            m_hsmLevel = HSMADMIN_DEFAULT_MINSIZE;

        }

        if( szSize != L"" ) {

            DDX_Text( pDX, IDC_EDIT_SIZE, m_fileSize );
            DDV_MinMaxDWord( pDX, m_fileSize, HSMADMIN_MIN_MINSIZE, HSMADMIN_MAX_MINSIZE );

        } else {

            m_fileSize = HSMADMIN_DEFAULT_FREESPACE;

        }

        if( szDays != L"" ) {

            DDX_Text( pDX, IDC_EDIT_TIME, m_accessTime );
            DDV_MinMaxUInt( pDX, m_accessTime, HSMADMIN_MIN_INACTIVITY, HSMADMIN_MAX_INACTIVITY );

        } else {

            m_accessTime = HSMADMIN_DEFAULT_INACTIVITY;

        }

    } else {

        //
        // Normal validation for single select
        //
        DDX_Text( pDX, IDC_EDIT_LEVEL, m_hsmLevel );
        DDV_MinMaxLong( pDX, m_hsmLevel, HSMADMIN_MIN_FREESPACE, HSMADMIN_MAX_FREESPACE );
        DDX_Text( pDX, IDC_EDIT_TIME, m_accessTime );
        DDV_MinMaxUInt( pDX, m_accessTime, HSMADMIN_MIN_INACTIVITY, HSMADMIN_MAX_INACTIVITY );
        DDX_Text( pDX, IDC_EDIT_SIZE, m_fileSize );

        //
        // Since we limit the number of characters in the buddy edits, we 
        // don't expect the previous two DDV's to ever really kick in. 
        // However, it is possible to enter bad minumum size since both
        // '0' and '1' can be entered, but are not in the valid range.

        //
        // Code is equivalent to:
        // DDV_MinMaxDWord( pDX, m_fileSize, HSMADMIN_MIN_MINSIZE, HSMADMIN_MAX_MINSIZE );
        //

        if( pDX->m_bSaveAndValidate &&
          ( m_fileSize < HSMADMIN_MIN_MINSIZE ||
            m_fileSize > HSMADMIN_MAX_MINSIZE ) ) {

            CString message;
            AfxFormatString2( message, IDS_ERR_MINSIZE_RANGE, 
                CString( WsbLongAsString( (LONG)HSMADMIN_MIN_MINSIZE ) ),
                CString( WsbLongAsString( (LONG)HSMADMIN_MAX_MINSIZE ) ) );
            AfxMessageBox( message, MB_OK | MB_ICONWARNING );
            pDX->Fail();

        }

    }
}


BEGIN_MESSAGE_MAP(CPrMrLvl, CSakVolPropPage)
    //{{AFX_MSG_MAP(CPrMrLvl)
    ON_EN_CHANGE(IDC_EDIT_LEVEL, OnChangeEditLevel)
    ON_EN_CHANGE(IDC_EDIT_SIZE, OnChangeEditSize)
    ON_EN_CHANGE(IDC_EDIT_TIME, OnChangeEditTime)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPrMrLvl message handlers

BOOL CPrMrLvl::OnInitDialog() 
{
    HRESULT hr = 0;
    CSakVolPropPage::OnInitDialog();
    int freePct;
    try {

        m_bMultiSelect = ( m_pParent->IsMultiSelect() == S_OK );    

        // Set the spinner ranges
        m_spinTime.SetRange( HSMADMIN_MIN_INACTIVITY, HSMADMIN_MAX_INACTIVITY );
        m_spinSize.SetRange( HSMADMIN_MIN_MINSIZE, HSMADMIN_MAX_MINSIZE );
        m_spinLevel.SetRange( HSMADMIN_MIN_FREESPACE, HSMADMIN_MAX_FREESPACE );

        // Set text limits
        m_editTime.SetLimitText( 3 );
        m_editSize.SetLimitText( 5 );
        m_editLevel.SetLimitText( 2 );

        if( !m_bMultiSelect )
        {
            // Single Select
            // Show the byte display of desired free space
            m_staticDesired4Digit.ShowWindow( SW_SHOW );
            m_staticActual4Digit.ShowWindow( SW_SHOW );

            // Get the single Fsa Resource pointer
            WsbAffirmHr ( m_pVolParent->GetFsaResource( &m_pFsaResource ) );
            WsbAffirmPointer (m_pFsaResource);

            ULONG       hsmLevel = 0;
            LONGLONG    fileSize = 0;
            BOOL        isRelative = TRUE; // assumed to be TRUE
            FILETIME    accessTime;

            // Get data from the Fsa object and assign to controls
            WsbAffirmHr( m_pFsaResource->GetHsmLevel( &hsmLevel ) );
            m_hsmLevel = hsmLevel / FSA_HSMLEVEL_1;

            WsbAffirmHr( m_pFsaResource->GetManageableItemLogicalSize( &fileSize ) );
            m_fileSize = (DWORD)(fileSize / 1024);  // Show KBytes

            WsbAffirmHr( m_pFsaResource->GetManageableItemAccessTime( &isRelative, &accessTime ) );
            WsbAssert( isRelative, E_FAIL );  // We only do relative time

            // Convert FILETIME to days
            LONGLONG temp = WSB_FT_TICKS_PER_DAY;
            m_accessTime = (UINT) (WsbFTtoLL (accessTime) / temp);
            if( m_accessTime > 999 ) {

                m_accessTime = 0;

            }

            LONGLONG total = 0;
            LONGLONG free = 0;
            LONGLONG premigrated = 0;
            LONGLONG truncated = 0;

            // Get actual free space and show in % and 4-digit formats
            WsbAffirmHr( m_pFsaResource->GetSizes( &total, &free, &premigrated, &truncated ) );
            m_capacity = total;

            freePct = (int) ((free * 100) / total);
            CString sFormat;
            sFormat.Format( L"%d", freePct );
            SetDlgItemText( IDC_STATIC_ACTUAL_FREE_PCT, sFormat );

            WsbAffirmHr( RsGuiFormatLongLong4Char( free, sFormat ) );
            SetDlgItemText( IDC_STATIC_FREE_ACTUAL_4DIGIT, sFormat );

            // Show the desired in 4-digit - based on the %
            SetDesiredFreePctControl( m_hsmLevel );

            // Update the controls
            UpdateData( FALSE );

        } else {

            // MULTI-SELECT
            // Hide the byte display of desired free space
            m_staticDesired4Digit.ShowWindow( SW_HIDE );
            m_staticActual4Digit.ShowWindow( SW_HIDE );
            InitDialogMultiSelect( );

        }

    } WsbCatch (hr);

    return( TRUE );
}

BOOL CPrMrLvl::OnApply() 
{
    HRESULT hr = S_OK;

    try {

        if( !m_bMultiSelect ) {
            LONGLONG    fileSize = 0;

            // Single Select
            UpdateData( TRUE );
            WsbAffirmHr( m_pFsaResource->SetHsmLevel( m_hsmLevel * FSA_HSMLEVEL_1 ) );
            fileSize = ((LONGLONG)m_fileSize) * 1024;
            WsbAffirmHr( m_pFsaResource->SetManageableItemLogicalSize( fileSize ) );

            // Convert days to FILETIME
            FILETIME accessTime;
            LONGLONG temp = WSB_FT_TICKS_PER_DAY;
            accessTime = WsbLLtoFT( ( (LONGLONG) m_accessTime ) * temp );
            WsbAffirmHr( m_pFsaResource->SetManageableItemAccessTime( TRUE, accessTime ) );


        } else {

            // Multi-Select
            WsbAffirmHr( OnApplyMultiSelect( ) );

        }

        //
        // Tell to save
        //
        CComPtr<IFsaServer>   pFsaServer;
        WsbAffirmHr( m_pParent->GetFsaServer( &pFsaServer ) );
        WsbAffirmHr( RsServerSaveAll( pFsaServer ) );

        //
        // Now notify all the nodes
        //
        m_pParent->OnPropertyChange( m_hConsoleHandle );


    } WsbCatch( hr );

    return CSakVolPropPage::OnApply();

}

///////////////////////////////////////////////////////////////////////////////
//
// OnChangeEditLevel
//
// Change the display of actual bytes according to the percent setting
//
void CPrMrLvl::OnChangeEditLevel() 
{
    BOOL fTrans;
    int freePct;

    freePct = GetDlgItemInt( IDC_EDIT_LEVEL, &fTrans );
    if( fTrans ) {

        SetDesiredFreePctControl( freePct );

    }

    if( !m_fChangingByCode ) {

        SetModified( TRUE );

    }
}

void CPrMrLvl::OnChangeEditSize() 
{
    if( !m_fChangingByCode ) {

        SetModified( TRUE );

    }
}

void CPrMrLvl::OnChangeEditTime() 
{
    if( !m_fChangingByCode ) {

        SetModified( TRUE );

    }
}

//////////////////////////////////////////////////////////////////////////
//
//      SetDesiredFreePctControl
//
// Converts the supplied desired percent to bytes (using m_capacity) and
// displays in the appropriate edit box
//
//
void CPrMrLvl::SetDesiredFreePctControl (int desiredPct)
{
    HRESULT hr = 0;
    CString sFormat;

    LONGLONG desired = (m_capacity * desiredPct) / 100;
    try {
        WsbAffirmHr (RsGuiFormatLongLong4Char (desired, sFormat));
        SetDlgItemText (IDC_STATIC_FREE_DESIRED_4DIGIT, sFormat);

    } WsbCatch (hr)
}

//////////////////////////////////////////////////////////////////////////
//
//
HRESULT CPrMrLvl::InitDialogMultiSelect()
{
    LONGLONG    total;
    LONGLONG    free;
    LONGLONG    premigrated;
    LONGLONG    truncated;
    BOOL        fLevelSame = TRUE;
    BOOL        fSizeSame  = TRUE;
    BOOL        fDaysSame  = TRUE;
    BOOL        fFirst     = TRUE;
    CString     szLevel;
    CString     szSize;
    CString     szDays;
    ULONG       hsmLevel = 0;
    LONGLONG    fileSize = 0;
    BOOL        isRelative = TRUE; // assumed to be TRUE
    FILETIME    accessTime;
    int         hsmLevelPct;
    ULONG       fileSizeKb;
    int         accessTimeDays;
    int         hsmLevelPctSave = 0;
    ULONG       fileSizeKbSave = 0;
    int         accessTimeDaysSave = 0;
    int         freePct;

    HRESULT hr = S_OK;

    try {
        // Set this flag to true because SetEditContents will cause the edit boxes to
        // fire a change event, and we don't want that to cause the Finish button to
        // be enabled.

        m_fChangingByCode = TRUE;

        // For each managed resource

        int bookMark = 0;
        CComPtr<IFsaResource> pFsaResource;
        LONGLONG totalCapacity = 0;
        LONGLONG totalFree = 0;

        while( m_pVolParent->GetNextFsaResource( &bookMark, &pFsaResource ) == S_OK ) {

            // Total up volume statistics
            WsbAffirmHr (pFsaResource->GetSizes(&total, &free, &premigrated, &truncated));
            totalCapacity += total;
            totalFree += free;

            // Get the levels in the resource
            WsbAffirmHr( pFsaResource->GetHsmLevel( &hsmLevel) );
            hsmLevelPct = (hsmLevel / FSA_HSMLEVEL_1);

            if( ! fFirst ) {

                if( hsmLevelPct != hsmLevelPctSave ) {
                     
                    fLevelSame = FALSE;

                }
            }
            hsmLevelPctSave = hsmLevelPct;

            WsbAffirmHr( pFsaResource->GetManageableItemLogicalSize( &fileSize ) );
            fileSizeKb = (LONG) ( fileSize / 1024 );
            if( !fFirst ) {

                if( fileSizeKb != fileSizeKbSave ) {
                    
                    fSizeSame = FALSE;

                }
            }
            fileSizeKbSave = fileSizeKb;

            WsbAffirmHr( pFsaResource->GetManageableItemAccessTime( &isRelative, &accessTime ) );
            accessTimeDays = (UINT) ( WsbFTtoLL( accessTime ) / WSB_FT_TICKS_PER_DAY );

            if( ! fFirst ) {

                if( accessTimeDays != accessTimeDaysSave ) {
                    
                    fDaysSame = FALSE;

                }
            }

            accessTimeDaysSave = accessTimeDays;

            fFirst = FALSE;

            pFsaResource.Release( );

        } // While

        // If all same, put the value in
        if( fLevelSame ) {

            szLevel.Format( L"%d", hsmLevelPctSave );

        } else {

            szLevel = L"";

        }

        if( fSizeSame ) {

            szSize.Format( L"%d", fileSizeKbSave );

        } else {

            szSize = L"";

        }
        if( fDaysSame ) {

            szDays.Format( L"%d", accessTimeDaysSave );

        } else {

            szDays = L"";

        }

        // Show volume statistics
        if( totalCapacity == 0 ) {
            
            freePct = 0;
            
        } else {

            freePct = (int) ( ( totalFree * 100 ) / totalCapacity );

        }

        CString sFormat;
        sFormat.Format( L"%d", freePct );
        SetDlgItemText( IDC_STATIC_ACTUAL_FREE_PCT, sFormat );

        m_editLevel.SetWindowText( szLevel );
        m_editSize.SetWindowText( szSize );
        m_editTime.SetWindowText( szDays );
        m_fChangingByCode = FALSE;

    } WsbCatch( hr );

    return( hr );
}
    

HRESULT CPrMrLvl::OnApplyMultiSelect()
{

    HRESULT hr = S_OK;
    CComPtr <IFsaResource> pFsaResource;

    try {

        // For each managed resource

        int bookMark = 0;
        CComPtr<IFsaResource> pFsaResource;
        while( m_pVolParent->GetNextFsaResource( &bookMark, &pFsaResource ) == S_OK ) {

            // Set the levels in the resource - only if the edit box was not blank
            CString szLevel;
            CString szSize;
            CString szDays; 

            m_editLevel.GetWindowText( szLevel );
            m_editSize.GetWindowText( szSize );
            m_editTime.GetWindowText( szDays );


            if( szLevel != L"" ) {

                WsbAffirmHr( pFsaResource->SetHsmLevel( m_spinLevel.GetPos( ) * FSA_HSMLEVEL_1 ) );

            }

            if( szSize != L"" ) {

                WsbAffirmHr( pFsaResource->SetManageableItemLogicalSize( (LONGLONG) m_spinSize.GetPos( ) * 1024 ) );

            }

            if( szDays != L"" ) {

                // Convert days to FILETIME
                FILETIME accessTime;
                accessTime = WsbLLtoFT( ( (LONGLONG) m_spinTime.GetPos( ) ) * WSB_FT_TICKS_PER_DAY);
                WsbAffirmHr (pFsaResource->SetManageableItemAccessTime (TRUE, accessTime));

            }
            pFsaResource.Release( );

        }

    } WsbCatch (hr);
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\volume\prmrsts.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    PrMrSts.cpp

Abstract:

    Managed Volume Status Page.

Author:

    Art Bragg [abragg]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include "fsaint.h"
#include "PrMrSts.h"
#include "manvol.h"

//#define RS_SHOW_ALL_PCTS

static DWORD pHelpIds[] = 
{

    IDC_STATIC_VOLUME_NAME,                     idh_volume_name,
#ifdef RS_SHOW_ALL_PCTS
    IDC_STATIC_USED_PCT,                        idh_volume_percent_local_data,
    IDC_STATIC_USED_PCT_UNIT,                   idh_volume_percent_local_data,
#endif
    IDC_STATIC_USED_SPACE_4DIGIT,               idh_volume_capacity_local_data,
    IDC_STATIC_USED_SPACE_4DIGIT_LABEL,         idh_volume_capacity_local_data,
    IDC_STATIC_USED_SPACE_4DIGIT_HELP,          idh_volume_capacity_local_data,
#ifdef RS_SHOW_ALL_PCTS
    IDC_STATIC_PREMIGRATED_PCT,                 idh_volume_percent_remote_data_cached,
    IDC_STATIC_PREMIGRATED_PCT_UNIT,            idh_volume_percent_remote_data_cached,
#endif
    IDC_STATIC_PREMIGRATED_SPACE_4DIGIT,        idh_volume_capacity_remote_data_cached,
    IDC_STATIC_PREMIGRATED_SPACE_4DIGIT_LABEL,  idh_volume_capacity_remote_data_cached,
    IDC_STATIC_FREE_PCT,                        idh_volume_percent_free_space,
    IDC_STATIC_FREE_PCT_UNIT,                   idh_volume_percent_free_space,
    IDC_STATIC_FREE_SPACE_4DIGIT,               idh_volume_capacity_free_space,
    IDC_STATIC_FREE_SPACE_4DIGIT_LABEL,         idh_volume_capacity_free_space,
    IDC_STATIC_MANAGED_SPACE_4DIGIT,            idh_volume_disk_capacity,
    IDC_STATIC_MANAGED_SPACE_4DIGIT_LABEL,      idh_volume_disk_capacity,
    IDC_STATIC_REMOTE_STORAGE_4DIGIT,           idh_volume_data_remote_storage,
    IDC_STATIC_RS_DATA_LABEL,                   idh_volume_data_remote_storage,
    
    0, 0
};

/////////////////////////////////////////////////////////////////////////////
// CPrMrSts property page

CPrMrSts::CPrMrSts( BOOL doAll ) : CSakVolPropPage(CPrMrSts::IDD)
{
    //{{AFX_DATA_INIT(CPrMrSts)
    //}}AFX_DATA_INIT
    m_DoAll          = doAll;
    m_hConsoleHandle = NULL;
    m_pHelpIds       = pHelpIds;
}

CPrMrSts::~CPrMrSts()
{
}

void CPrMrSts::DoDataExchange(CDataExchange* pDX)
{
    CSakVolPropPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPrMrSts)
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPrMrSts, CSakVolPropPage)
    //{{AFX_MSG_MAP(CPrMrSts)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPrMrSts message handlers

BOOL CPrMrSts::OnInitDialog() 
{


    CSakVolPropPage::OnInitDialog();

    // set the dll context so that MMC can find the resource.
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    LONGLONG    total = 0;
    LONGLONG    free = 0;
    LONGLONG    premigrated = 0;
    LONGLONG    truncated = 0;
    LONGLONG    totalTotal = 0;
    LONGLONG    totalFree = 0;
    LONGLONG    totalPremigrated = 0;
    LONGLONG    totalTruncated = 0;
    LONGLONG    remoteStorage = 0;
    CString     sFormat;

    CString sText;

    CSakVolPropPage::OnInitDialog();

    HRESULT hr = S_OK;

    try {

        if ( ( m_pParent->IsMultiSelect() != S_OK ) && !m_DoAll ) {

            // SINGLE SELECT
            WsbAffirmHr( m_pVolParent->GetFsaResource( &m_pFsaResource ) );
            WsbAffirmPointer( m_pFsaResource );

            // Get statistics
            WsbAffirmHr( m_pFsaResource->GetSizes( &total, &free, &premigrated, &truncated ) );

            // Show the volume name
            CString sText;
            WsbAffirmHr( RsGetVolumeDisplayName( m_pFsaResource, sText ) );
            SetDlgItemText( IDC_STATIC_VOLUME_NAME, sText );

        } else {

            // MULTI_SELECT or DoAll mode
            int bookMark = 0;
            int numVols  = 0;
            CComPtr<IFsaResource> pFsaResource;
            while( m_pVolParent->GetNextFsaResource( &bookMark, &pFsaResource ) == S_OK ) {

                WsbAffirmHr( pFsaResource->GetSizes( &total, &free, &premigrated, &truncated ) );
                numVols++;
                totalTotal       += total;
                totalFree        += free;
                totalPremigrated += premigrated;
                totalTruncated   += truncated;

                pFsaResource.Release( );

            }

            total = totalTotal;
            free = totalFree;
            premigrated = totalPremigrated;
            truncated =  totalTruncated;

            // Show the number of volumes
            sText.Format( ( 1 == numVols ) ? IDS_VOLUME : IDS_VOLUMES, numVols );
            SetDlgItemText( IDC_STATIC_VOLUME_NAME, sText );

        }


        LONGLONG normal = max( ( total - free - premigrated ), (LONGLONG)0 );
        
        // Calculate percents
        int freePct;
        int premigratedPct;
        if( total == 0 ) {

            freePct = 0;
            premigratedPct = 0;

        } else {

            freePct        = (int) ((free * 100) / total);
            premigratedPct = (int) ((premigrated * 100) / total);

        }

#ifdef RS_SHOW_ALL_PCTS
        int normalPct = 100 - freePct - premigratedPct;
#endif

        remoteStorage = premigrated + truncated;

        //
        // Show the statistics in percent
        //
        sFormat.Format (L"%d", freePct);
        SetDlgItemText (IDC_STATIC_FREE_PCT, sFormat);

#ifdef RS_SHOW_ALL_PCTS
        sFormat.Format (L"%d", normalPct);
        SetDlgItemText (IDC_STATIC_USED_PCT, sFormat);

        sFormat.Format (L"%d", premigratedPct);
        SetDlgItemText (IDC_STATIC_PREMIGRATED_PCT, sFormat);

#else
        //
        // Can't change resources, so just hide the controls
        //
        GetDlgItem( IDC_STATIC_USED_PCT             )->ShowWindow( SW_HIDE );
        GetDlgItem( IDC_STATIC_USED_PCT_UNIT        )->ShowWindow( SW_HIDE );
        GetDlgItem( IDC_STATIC_PREMIGRATED_PCT      )->ShowWindow( SW_HIDE );
        GetDlgItem( IDC_STATIC_PREMIGRATED_PCT_UNIT )->ShowWindow( SW_HIDE );
#endif

        //
        // Show the statistics in 4-character format
        //
        WsbAffirmHr (RsGuiFormatLongLong4Char (total, sFormat));
        SetDlgItemText (IDC_STATIC_MANAGED_SPACE_4DIGIT, sFormat);

        WsbAffirmHr (RsGuiFormatLongLong4Char (free, sFormat));
        SetDlgItemText (IDC_STATIC_FREE_SPACE_4DIGIT, sFormat);

        WsbAffirmHr (RsGuiFormatLongLong4Char (normal, sFormat));
        SetDlgItemText (IDC_STATIC_USED_SPACE_4DIGIT, sFormat);

        WsbAffirmHr (RsGuiFormatLongLong4Char (premigrated, sFormat));
        SetDlgItemText (IDC_STATIC_PREMIGRATED_SPACE_4DIGIT, sFormat);

        WsbAffirmHr (RsGuiFormatLongLong4Char (remoteStorage, sFormat));
        SetDlgItemText (IDC_STATIC_REMOTE_STORAGE_4DIGIT, sFormat);

        UpdateData( FALSE );

    } WsbCatch ( hr );
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\volume\prsched.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    PrSched.cpp

Abstract:

    Schedule page.

Author:

    Rohde Wakefield [rohde]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include "PrSched.h"
#include "rsstrdef.h"

static DWORD pHelpIds[] = 
{

    IDC_SCHED_TEXT,                 idh_current_schedule,
    IDC_SCHED_LABEL,                idh_current_schedule,
    IDC_CHANGE_SCHED,               idh_change_schedule_button,

    0, 0
};

/////////////////////////////////////////////////////////////////////////////
// CPrSchedule property page

CPrSchedule::CPrSchedule() : CSakPropertyPage(IDD)
{
    WsbTraceIn( L"CPrSchedule::CPrSchedule", L"" );
    //{{AFX_DATA_INIT(CPrSchedule)
    //}}AFX_DATA_INIT
    m_SchedChanged  = FALSE;
    m_pHelpIds      = pHelpIds;
    WsbTraceOut( L"CPrSchedule::CPrSchedule", L"" );
}

CPrSchedule::~CPrSchedule()
{
}

void CPrSchedule::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CPrSchedule::DoDataExchange", L"" );
    CSakPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPrSchedule)
    //}}AFX_DATA_MAP
    WsbTraceOut( L"CPrSchedule::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CPrSchedule, CSakPropertyPage)
    //{{AFX_MSG_MAP(CPrSchedule)
    ON_BN_CLICKED(IDC_CHANGE_SCHED, OnChangeSched)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPrSchedule message handlers

BOOL CPrSchedule::OnInitDialog() 
{
    WsbTraceIn( L"CPrSchedule::OnInitDialog", L"" );
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CSakPropertyPage::OnInitDialog();
    
    HRESULT hr = S_OK;

    try {

        //
        // TEST
        //
        WsbAffirmHr( m_pParent->GetHsmServer( &m_pHsmServer) );

        //
        // Get the computer name
        //
        CWsbStringPtr szWsbHsmName;
        CWsbStringPtr taskName, taskComment;

        WsbAffirmHr( m_pHsmServer->GetName( &szWsbHsmName ) );
        WsbAffirmHr(WsbGetResourceString(IDS_HSM_SCHED_TASK_TITLE, &taskName));
        WsbAffirmHr(WsbGetResourceString(IDS_HSM_SCHED_COMMENT, &taskComment));

        //
        // Create the scheduled task object
        //
        CEdit *pEdit = (CEdit *) GetDlgItem( IDC_SCHED_TEXT );
        m_pCSchdTask = new CSchdTask(
                                CString(szWsbHsmName),
                                taskName, 
                                IDS_SCHED_MANAGE_TITLE,
                                RS_STR_KICKOFF_PARAMS,
                                taskComment,
                                pEdit ); 


        //
        // Create the task.  The task should exist!
        //
        WsbAffirmHr( m_pCSchdTask->CheckTaskExists( TRUE ) );

        // Show the task data
        m_pCSchdTask->UpdateDescription( );

        // ToDo: Set the users list

    } WsbCatch( hr );

    WsbTraceOut( L"CPrSchedule::OnInitDialog", L"" );
    return( TRUE );
}

BOOL CPrSchedule::OnApply() 
{
    WsbTraceIn( L"CPrSchedule::OnApply", L"" );
    HRESULT hr = S_OK;
    UpdateData( TRUE );

    if( m_SchedChanged ) {

        try {
            
            WsbAffirmHr( m_pCSchdTask->Save() );
            m_SchedChanged = FALSE;

        } WsbCatch( hr );
    }

    WsbTraceOut( L"CPrSchedule::OnApply", L"" );
    return CSakPropertyPage::OnApply();
}

void CPrSchedule::OnChangeSched() 
{
    WsbTraceIn( L"CPrSchedule::OnChangeSched", L"" );

    m_pCSchdTask->ShowPropertySheet();

    //
    // Update the property sheet
    //
    m_pCSchdTask->UpdateDescription();

    SetModified( TRUE );
    m_SchedChanged = TRUE;

    WsbTraceOut( L"CPrSchedule::OnChangeSched", L"" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\volume\prmrsts.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    PrMrSts.h

Abstract:

    Status page for single select, multiple select, and folder of volumes.

Author:

    Art Bragg [artb]   01-DEC-1997

Revision History:

--*/

#ifndef _PRMRSTS_H
#define _PRMRSTS_H

#pragma once


/////////////////////////////////////////////////////////////////////////////
// CPrMrSts dialog

class CPrMrSts : public CSakVolPropPage
{
// Construction
public:
    CPrMrSts( BOOL doAll = FALSE);
    ~CPrMrSts();

// Dialog Data
    //{{AFX_DATA(CPrMrSts)
    enum { IDD = IDD_PROP_MANRES_STATUS };
    //}}AFX_DATA

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPrMrSts)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CPrMrSts)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    // Unmarshalled pointer to managed resource 
    CComPtr     <IFsaResource> m_pFsaResource;
    CComPtr     <IFsaResource> m_pFsaResourceList;

private:
    BOOL m_DoAll;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\volume\prsched.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    PrSched.h

Abstract:

    Schedule page.

Author:

    Rohde Wakefield [rohde]   08-Aug-1997

Revision History:

--*/

#ifndef _PRSCHED_H
#define _PRSCHED_H

#pragma once

#include "schdtask.h"

/////////////////////////////////////////////////////////////////////////////
// CPrSchedule dialog

class CPrSchedule : public CSakPropertyPage
{
// Construction
public:
    CPrSchedule();
    ~CPrSchedule();

// Dialog Data
    //{{AFX_DATA(CPrSchedule)
    enum { IDD = IDD_PROP_SCHEDULE };
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPrSchedule)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CPrSchedule)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeSched();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    // Unmarshalled pointer to Hsm Server
    CComPtr<IHsmServer> m_pHsmServer;

private:
    CSchdTask* m_pCSchdTask;
    BOOL m_SchedChanged;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\volume\rule.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    Rule.cpp

Abstract:

    Rule object for use in inclusion exclusion.

Author:

    Art Bragg [abragg]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include "Rule.h"



/////////////////////////////////////////////////////////////////////////////
// CRule dialog

static DWORD pHelpIds[] = 
{

    IDC_EDIT_RESOURCE_NAME,                 idh_rule_edit_name,
    IDC_EDIT_PATH,                          idh_rule_edit_path,
    IDC_EDIT_FILESPEC,                      idh_rule_edit_file_type,
    IDC_RADIO_EXCLUDE,                      idh_rule_edit_exclude,
    IDC_RADIO_INCLUDE,                      idh_rule_edit_include,
    IDC_CHECK_SUBDIRS,                      idh_rule_edit_apply_subfolders,

    0, 0
};


CRule::CRule(CWnd* pParent /*=NULL*/)
    : CRsDialog(CRule::IDD, pParent)
{
    //{{AFX_DATA_INIT(CRule)
    m_subDirs = FALSE;
    m_fileSpec = _T("");
    m_path = _T("");
    m_includeExclude = -1;
    m_pResourceName = _T("");
    //}}AFX_DATA_INIT
    m_pHelpIds          = pHelpIds;
}


void CRule::DoDataExchange(CDataExchange* pDX)
{
    CRsDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRule)
    DDX_Check(pDX, IDC_CHECK_SUBDIRS, m_subDirs);
    DDX_Text(pDX, IDC_EDIT_FILESPEC, m_fileSpec);
    DDX_Text(pDX, IDC_EDIT_PATH, m_path);
    DDX_Radio(pDX, IDC_RADIO_EXCLUDE, m_includeExclude);
    DDX_Text(pDX, IDC_EDIT_RESOURCE_NAME, m_pResourceName);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRule, CRsDialog)
    //{{AFX_MSG_MAP(CRule)
    ON_BN_CLICKED(IDC_RADIO_EXCLUDE, OnRadioExclude)
    ON_BN_CLICKED(IDC_RADIO_INCLUDE, OnRadioInclude)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRule message handlers

void CRule::OnRadioExclude() 
{
    // TODO: Add your control notification handler code here
    
}

void CRule::OnRadioInclude() 
{
    // TODO: Add your control notification handler code here
    
}

BOOL CRule::OnInitDialog() 
{
    CRsDialog::OnInitDialog();
    
    UpdateData (FALSE);
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

//////////////////////////////////////////////////////////////////////////
//
// Returns: False if path is not legal
//
BOOL CRule::FixRulePath (CString& sPath)
{
    BOOL fOk = TRUE;
    TCHAR c;
    int length = 0;
    int i;

    // Test for illegal characters
    length = sPath.GetLength();
    for (i = 0; i < length; i++)
    {
        c = sPath[i];
        if (c == ':') {
            fOk = FALSE;
            break;
        }
    }

    if (fOk) {

        // Convert all "/" to "\"
        length = sPath.GetLength();
        for (i = 0; i < length; i++)
        {
            c = sPath[i];
            if (c == '/') sPath.SetAt (i, '\\');
        }

        // Make sure path starts with a "\"
        c = sPath[0];
        if (c != '\\')
        {
            sPath = "\\" + sPath;
        }

        // If path has at least one dir, clean up final "\" if there is one
        length = sPath.GetLength();
        if (length > 1) {
            c = sPath[length - 1];
            if (c == '\\') {
                sPath = sPath.Left (length - 1);
            }
        }
                
        
    }
    return fOk;
}
void CRule::OnOK() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    UpdateData (TRUE);

    // Verify the path and name fields
    if (m_path != "")
    {
        if (m_fileSpec != "")
        {
            // Fix up the path
            if (FixRulePath (m_path)) {
                
                // Show the new data - because when we call OnOK the variables
                // will get updated again.
                UpdateData (FALSE);
                CRsDialog::OnOK();
            } else {
                AfxMessageBox (IDS_ERR_RULE_ILLEGAL_PATH, RS_MB_ERROR);
            }
        }
        else {
            AfxMessageBox (IDS_ERR_RULE_NO_FILESPEC, RS_MB_ERROR);
        }
    }
    else {
        AfxMessageBox (IDS_ERR_RULE_NO_PATH, RS_MB_ERROR);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\volume\valwait.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    valwait.cpp

Abstract:

    Implements Validate Wait Dialog class

Author:

    Ran Kalach          [rankala]         23-May-2000

Revision History:

--*/

// valwait.cpp : implementation file
//

#include "stdafx.h"
#include "valwait.h"
#include "wzunmang.h"

/////////////////////////////////////////////////////////////////////////////
// CValWaitDlg dialog


CValWaitDlg::CValWaitDlg(CUnmanageWizard *pSheet, CWnd* pParent)
	: CDialog(CValWaitDlg::IDD, pParent)
{
    WsbTraceIn( L"CValWaitDlg::CValWaitDlg", L"" );

	//{{AFX_DATA_INIT(CValWaitDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    // Store volume name
    m_pSheet = pSheet;

    WsbTraceOut( L"CValWaitDlg::CValWaitDlg", L"" );
}


void CValWaitDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CValWaitDlg)
	DDX_Control(pDX, IDC_ANIMATE_VALIDATE, m_Animation);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CValWaitDlg, CDialog)
	//{{AFX_MSG_MAP(CValWaitDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CValWaitDlg message handlers

void CValWaitDlg::OnCancel() 
{
    WsbTraceIn( L"CValWaitDlg::OnCancel", L"" );

    HRESULT         hr = S_OK;

    try {
        CComPtr<IHsmServer>  pHsmServer;

	    // Cancel the Validate job - the wizard will close this dialog when the job finishes
        WsbAffirmPointer(m_pSheet);
        WsbAffirmHrOk(m_pSheet->GetHsmServer(&pHsmServer));
        WsbAffirmHr(RsCancelDirectFsaJob(HSM_JOB_DEF_TYPE_VALIDATE, pHsmServer, 
                        m_pSheet->m_pFsaResource));

    } WsbCatch(hr);

    WsbTraceOut( L"CValWaitDlg::OnCancel", L"" );
}

void CValWaitDlg::PostNcDestroy() 
{
	CDialog::PostNcDestroy();

    // Delete the object - required for modeless dialogbox
    delete( this );
}

BOOL CValWaitDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    // Start up the animation
    if (m_Animation.Open( IDR_VALIDATE_ANIM )) {
        m_Animation.Play( 0, -1, -1 );
    }
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\volume\wzmnvlls.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    WzMnVlLs.cpp

Abstract:

    Managed Volume wizard.

Author:

    Rohde Wakefield [rohde]   08-Aug-1997

Revision History:

--*/

#include "stdafx.h"

#include "ManVolLs.h"
#include "WzMnVlLs.h"

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLst

CWizManVolLst::CWizManVolLst( )
{
    m_TitleId     = IDS_WIZ_MANVOLLST_TITLE;
    m_HeaderId    = IDB_MANAGE_HEADER;
    m_WatermarkId = IDB_MANAGE_WATERMARK;
}

STDMETHODIMP
CWizManVolLst::AddWizardPages(
    IN RS_PCREATE_HANDLE Handle,
    IN IUnknown*         pCallback,
    IN ISakSnapAsk*      pSakSnapAsk
    )
{
    WsbTraceIn( L"CWizManVolLst::AddWizardPages", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // Initialize the Sheet
        //
        WsbAffirmHr( InitSheet( Handle, pCallback, 0, pSakSnapAsk, 0, 0 ) );

        //
        // Load pages 
        //
        WsbAffirmHr( AddPage( &m_PageIntro ) );
        WsbAffirmHr( AddPage( &m_PageSelect ) );
        WsbAffirmHr( AddPage( &m_PageSelectX ) );
        WsbAffirmHr( AddPage( &m_PageLevels ) );
        WsbAffirmHr( AddPage( &m_PageFinish ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CWizManVolLst::AddWizardPages", L"" );
    return( hr );
}

CWizManVolLst::~CWizManVolLst()
{
    WsbTraceIn( L"CWizManVolLst::~CWizManVolLst", L"" );
    WsbTraceOut( L"CWizManVolLst::~CWizManVolLst", L"" );
}

HRESULT CWizManVolLst::OnFinish( )
{
    WsbTraceIn( L"CWizManVolLst::OnFinish", L"" );

    BOOL doAll = FALSE;
    //
    // The sheet really owns the process as a whole,
    // so it will do the final assembly
    //

    HRESULT hr = S_OK;

    try {

        //
        // Get the HSM service interface for creating local objects
        //
        CComPtr<IWsbCreateLocalObject>  pCreateLocal;
        CComPtr<IWsbIndexedCollection> pCollection;
        CComPtr<IHsmManagedResource> pHsmResource;

        CComPtr<IHsmServer> pHsmServer;
        WsbAffirmHrOk( m_pSakSnapAsk->GetHsmServer( &pHsmServer ) );

        WsbAffirmHr( pHsmServer.QueryInterface( &pCreateLocal ) );
        WsbAffirmHr( pHsmServer->GetManagedResources( &pCollection ) );

        //
        // Pull out the default levels for all resources to be managed
        //
        ULONG    defaultFreeSpace =  (m_PageLevels.GetHsmLevel() * FSA_HSMLEVEL_1);
        LONGLONG defaultMinSize = ( (LONGLONG)m_PageLevels.GetFileSize()) * ((LONGLONG)1024);
        FILETIME defaultAccess = WsbLLtoFT ((LONGLONG)m_PageLevels.GetAccessDays() * (LONGLONG)WSB_FT_TICKS_PER_DAY );
    
        // Is the "all" radio button selected?
        if( !m_PageSelect.m_radioSelect.GetCheck() ) {

            doAll = TRUE;

        }

        //
        // Make sure FSA has most up-to-date status on resources
        //
        CComPtr<IFsaServer> pFsaServer;
        WsbAffirmHrOk( m_pSakSnapAsk->GetFsaServer( &pFsaServer ) );
        WsbAffirmHr( pFsaServer->ScanForResources( ) );

        //
        // Go through the listbox and pull out the checked resources.
        // Create HSM managed volumes for them.
        //
        // Note that we wrap the management in a try/catch so that if an error
        // occurs (like a volume not available) that we still do the rest
        // of the volumes. We will throw the error after attempting all volumes.
        //
        HRESULT hrLoop = S_OK;
        CSakVolList *pListBox = &(m_PageSelect.m_listBox);

        INT index;
        for( index = 0; index < pListBox->GetItemCount( ); index++ ) {

            if( ( pListBox->GetCheck( index ) ) || ( doAll ) ) {

                try {

                    CResourceInfo* pResInfo = (CResourceInfo*)pListBox->GetItemData( index );

                    //
                    // Create Local to server since it will eventually own it.
                    //

                    WsbAffirmHr( pCreateLocal->CreateInstance( 
                        CLSID_CHsmManagedResource, 
                        IID_IHsmManagedResource, 
                        (void**)&pHsmResource ) );

                    //
                    // Initialize Fsa object to its initial values.
                    //

                    WsbAffirmHr( (pResInfo->m_pResource)->SetHsmLevel( defaultFreeSpace ) );
                    WsbAffirmHr( (pResInfo->m_pResource)->SetManageableItemLogicalSize( defaultMinSize ) );
                    WsbAffirmHr( (pResInfo->m_pResource)->SetManageableItemAccessTime( TRUE, defaultAccess ) );

                    //
                    // Associate HSM Managed Resource with the FSA resource
                    // (also adds to HSM collection)
                    //

                    WsbAffirmHr( pHsmResource->InitFromFsaResource( pResInfo->m_pResource ) );
                    WsbAffirmHr( pCollection->Add( pHsmResource ) );

                } WsbCatch( hrLoop );

                pHsmResource.Release( );
            }

        }

        //
        // Force a persistant save of the hsm man vol list
        //
        WsbAffirmHr( RsServerSaveAll( pHsmServer ) );
        WsbAffirmHr( RsServerSaveAll( pFsaServer ) );

        //
        // And check to see if there were any problems doing the manage
        //
        WsbAffirmHr( hrLoop );

    } WsbCatchAndDo( hr,

        CString errString;
        AfxFormatString1( errString, IDS_ERR_MANVOLWIZ_FINISH, WsbHrAsString( hr ) );
        AfxMessageBox( errString, RS_MB_ERROR ); 

    );

    m_HrFinish = S_OK;

    WsbTraceOut( L"CWizManVolLst::OnFinish", L"hr = <%ls>", WsbHrAsString( m_HrFinish ) );
    return(m_HrFinish);
}

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstLevels property page

CWizManVolLstLevels::CWizManVolLstLevels()
    : CSakWizardPage_InitBaseInt( WIZ_MANVOLLST_LEVELS )
{
    //{{AFX_DATA_INIT(CWizManVolLstLevels)
    m_HsmLevel = 0;
    m_AccessDays = 0;
    m_FileSize = 0;
    //}}AFX_DATA_INIT

}

CWizManVolLstLevels::~CWizManVolLstLevels()
{
    WsbTraceIn( L"CWizManVolLst::~CWizManVolLstLevels", L"" );
    WsbTraceOut( L"CWizManVolLst::~CWizManVolLstLevels", L"" );
}

void CWizManVolLstLevels::DoDataExchange(CDataExchange* pDX)
{
    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWizManVolLstLevels)
    DDX_Control(pDX, IDC_WIZ_MANVOLLST_SPIN_SIZE, m_SpinSize);
    DDX_Control(pDX, IDC_WIZ_MANVOLLST_SPIN_LEVEL, m_SpinLevel);
    DDX_Control(pDX, IDC_WIZ_MANVOLLST_SPIN_DAYS, m_SpinDays);
    DDX_Control(pDX, IDC_WIZ_MANVOLLST_EDIT_SIZE, m_EditSize);
    DDX_Control(pDX, IDC_WIZ_MANVOLLST_EDIT_LEVEL, m_EditLevel);
    DDX_Control(pDX, IDC_WIZ_MANVOLLST_EDIT_DAYS, m_EditDays);
    DDX_Text(pDX, IDC_WIZ_MANVOLLST_EDIT_LEVEL, m_HsmLevel);
    DDX_Text(pDX, IDC_WIZ_MANVOLLST_EDIT_DAYS, m_AccessDays);
    DDX_Text(pDX, IDC_WIZ_MANVOLLST_EDIT_SIZE, m_FileSize);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWizManVolLstLevels, CSakWizardPage)
    //{{AFX_MSG_MAP(CWizManVolLstLevels)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstLevels message handlers

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstIntro property page

CWizManVolLstIntro::CWizManVolLstIntro()
    : CSakWizardPage_InitBaseExt( WIZ_MANVOLLST_INTRO )
{
    //{{AFX_DATA_INIT(CWizManVolLstIntro)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

CWizManVolLstIntro::~CWizManVolLstIntro()
{
    WsbTraceIn( L"CWizManVolLst::~CWizManVolLstIntro", L"" );
    WsbTraceOut( L"CWizManVolLst::~CWizManVolLstIntro", L"" );
}

void CWizManVolLstIntro::DoDataExchange(CDataExchange* pDX)
{
    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWizManVolLstIntro)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWizManVolLstIntro, CSakWizardPage)
    //{{AFX_MSG_MAP(CWizManVolLstIntro)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstIntro message handlers

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstFinish property page

CWizManVolLstFinish::CWizManVolLstFinish()
    : CSakWizardPage_InitBaseExt( WIZ_MANVOLLST_FINISH )
{
    //{{AFX_DATA_INIT(CWizManVolLstFinish)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

CWizManVolLstFinish::~CWizManVolLstFinish()
{
    WsbTraceIn( L"CWizManVolLst::~CWizManVolLstFinish", L"" );
    WsbTraceOut( L"CWizManVolLst::~CWizManVolLstFinish", L"" );
}

void CWizManVolLstFinish::DoDataExchange(CDataExchange* pDX)
{
    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWizManVolLstFinish)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWizManVolLstFinish, CSakWizardPage)
    //{{AFX_MSG_MAP(CWizManVolLstFinish)
    ON_EN_SETFOCUS(IDC_WIZ_FINAL_TEXT, OnSetfocusWizManvollstFinalEdit)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstFinish message handlers



/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstSelect property page

CWizManVolLstSelect::CWizManVolLstSelect()
    : CSakWizardPage_InitBaseInt( WIZ_MANVOLLST_SELECT )
{
    //{{AFX_DATA_INIT(CWizManVolLstSelect)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

CWizManVolLstSelect::~CWizManVolLstSelect()
{
    WsbTraceIn( L"CWizManVolLst::~CWizManVolLstSelect", L"" );

    WsbTraceOut( L"CWizManVolLst::~CWizManVolLstSelect", L"" );
}

void CWizManVolLstSelect::DoDataExchange(CDataExchange* pDX)
{
    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWizManVolLstSelect)
    DDX_Control(pDX, IDC_RADIO_SELECT, m_radioSelect);
    DDX_Control(pDX, IDC_MANVOLLST_FSARESLBOX, m_listBox);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWizManVolLstSelect, CSakWizardPage)
    //{{AFX_MSG_MAP(CWizManVolLstSelect)
    ON_BN_CLICKED(IDC_RADIO_SELECT, OnRadioSelect)
    ON_BN_CLICKED(IDC_RADIO_MANAGE_ALL, OnRadioManageAll)
    ON_WM_DESTROY()
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_MANVOLLST_FSARESLBOX, OnItemchangedManVollstFsareslbox)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CWizManVolLstIntro::OnInitDialog() 
{
    CSakWizardPage::OnInitDialog();
    
    return TRUE;
}

BOOL CWizManVolLstLevels::OnInitDialog() 
{
    CSakWizardPage::OnInitDialog();

    CString titleText;

    // Set the default initial values for management
    // levels

    m_SpinLevel.SetRange( HSMADMIN_MIN_FREESPACE, HSMADMIN_MAX_FREESPACE );
    m_SpinSize.SetRange( HSMADMIN_MIN_MINSIZE, HSMADMIN_MAX_MINSIZE );
    m_SpinDays.SetRange( HSMADMIN_MIN_INACTIVITY, HSMADMIN_MAX_INACTIVITY );

    m_SpinLevel.SetPos( HSMADMIN_DEFAULT_FREESPACE );
    m_SpinSize.SetPos( HSMADMIN_DEFAULT_MINSIZE );
    m_SpinDays.SetPos( HSMADMIN_DEFAULT_INACTIVITY );

    m_EditLevel.SetLimitText( 2 );
    m_EditSize.SetLimitText( 5 );
    m_EditDays.SetLimitText( 3 );

    m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );

    return( TRUE );
}


void CWizManVolLstLevels::SetWizardFinish()
{
}

BOOL CWizManVolLstSelect::OnInitDialog() 
{
    WsbTraceIn( L"CWizManVolLstSelect::OnInitDialog", L"" );

    CSakWizardPage::OnInitDialog();
    HRESULT hr = S_OK;


    try {

        CComPtr<IFsaServer> pFsaServer;
        WsbAffirmHr( m_pSheet->GetFsaServer( &pFsaServer ) );
        WsbAffirmHr( FillListBoxSelect( pFsaServer, &m_listBox ) );

        // Check the "Select" radio button
        CheckRadioButton( IDC_RADIO_MANAGE_ALL, IDC_RADIO_SELECT, 
            IDC_RADIO_SELECT );

    } WsbCatch (hr);

    WsbTraceOut( L"CWizManVolLstSelect::OnInitDialog", L"hr = <%ls>", WsbHrAsString( hr ) );
    return TRUE;
}

//-----------------------------------------------------------------------------
//
//                      FillListBoxSelect
//
//  Fill the selection list box with non-configured managed resources
//
//
HRESULT CWizManVolLstSelect::FillListBoxSelect (IFsaServer *pFsaServer, CSakVolList *pListBox)
{
    WsbTraceIn( L"CWizManVolLstSelect::FillListBoxSelect", L"" );

    BOOL           gotOne   = FALSE;
    HRESULT        hr       = S_OK;
    CResourceInfo* pResInfo = 0;

    try {
        //
        // Connect to the FSA for this machine
        //

        WsbAffirmPointer( pFsaServer );

        CComPtr<IWsbEnum> pEnum;
        WsbAffirmHr(pFsaServer->EnumResources( &pEnum ) );

        HRESULT hrEnum;
        CComPtr<IFsaResource> pResource;

        hrEnum = pEnum->First( IID_IFsaResource, (void**)&pResource );
        WsbAffirm( SUCCEEDED( hrEnum ) || ( WSB_E_NOTFOUND == hrEnum ), hrEnum );

        INT index = 0;
        while( SUCCEEDED( hrEnum ) ) {

            //
            // Is the volume managed?
            //
            if( pResource->IsManaged() != S_OK ) {

                //
                // If path is blank, do not show this volume
                //
                if( S_OK == RsIsVolumeAvailable( pResource ) ) {

                    gotOne = TRUE;

                    pResInfo = new CResourceInfo( pResource );
                    WsbAffirmAlloc( pResInfo );
                    WsbAffirmHr( pResInfo->m_HrConstruct );

                    //
                    // Set Name, Capacity and Free Space columns.
                    //                    
                    LONGLONG    totalSpace  = 0;
                    LONGLONG    freeSpace   = 0;
                    LONGLONG    premigrated = 0;
                    LONGLONG    truncated   = 0;
                    WsbAffirmHr( pResource->GetSizes( &totalSpace, &freeSpace, &premigrated, &truncated ) );
                    CString totalString, freeString;
                    RsGuiFormatLongLong4Char( totalSpace, totalString );
                    RsGuiFormatLongLong4Char( freeSpace, freeString );                  

                    WsbAffirm( pListBox->AppendItem( pResInfo->m_DisplayName, totalString, freeString, &index ), E_FAIL );
                    WsbAffirm( -1 != index, E_FAIL );

                    //
                    // Store struct pointer in listbox
                    //                                      
                    WsbAffirm( pListBox->SetItemData( index, (DWORD_PTR)pResInfo ), E_FAIL );
                    pResInfo = 0;

                    //
                    // Initialize selected array
                    //
                    m_listBoxSelected[ index ] = FALSE;

                }
            }

            //
            // Prepare for next iteration
            //
            pResource.Release( );
            hrEnum = pEnum->Next( IID_IFsaResource, (void**)&pResource );
        }

        m_listBox.SortItems( CResourceInfo::Compare, 0 );

        //
        // Set the button AFTER we fill the box
        //
        CheckRadioButton( IDC_RADIO_MANAGE_ALL, IDC_RADIO_SELECT, IDC_RADIO_SELECT );

    } WsbCatch( hr );

    if( pResInfo )  delete pResInfo;
    
    WsbTraceOut( L"CWizManVolLstSelect::FillListBoxSelect", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}


BOOL CWizManVolLstIntro::OnSetActive() 
{
    WsbTraceIn( L"CWizManVolLstIntro::OnSetActive", L"" );

    m_pSheet->SetWizardButtons( PSWIZB_NEXT );

    BOOL retval = CSakWizardPage::OnSetActive();

    WsbTraceOut( L"CWizManVolLstIntro::OnSetActive", L"retval = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}

BOOL CWizManVolLstLevels::OnSetActive() 
{
    WsbTraceIn( L"CWizManVolLstLevels::OnSetActive", L"" );

    m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );

    BOOL retval = CSakWizardPage::OnSetActive();

    WsbTraceOut( L"CWizManVolLstLevels::OnSetActive", L"retval = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}

BOOL CWizManVolLstLevels::OnKillActive() 
{
    WsbTraceIn( L"CWizManVolLstLevels::OnKillActive", L"" );

    BOOL retval = FALSE;

    //
    // Need to handle strange case where a user can enter a value within
    // the parameters of the number of digits allowed, but the value can
    // be out of range. This is detected by the spin box which will
    // return an error if its buddy control is out of range.
    //
    if( HIWORD( m_SpinSize.GetPos( ) ) > 0 ) {

        // Control reports on error...
        retval = FALSE;

        CString message;
        AfxFormatString2( message, IDS_ERR_MINSIZE_RANGE, 
            CString( WsbLongAsString( (LONG)HSMADMIN_MIN_MINSIZE ) ),
            CString( WsbLongAsString( (LONG)HSMADMIN_MAX_MINSIZE ) ) );
        AfxMessageBox( message, MB_OK | MB_ICONWARNING );

    } else {

        retval = CSakWizardPage::OnKillActive();

    }

    WsbTraceOut( L"CWizManVolLstLevels::OnKillActive", L"retval = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}

BOOL CWizManVolLstSelect::OnSetActive() 
{
    WsbTraceIn( L"CWizManVolLstSelect::OnSetActive", L"" );

    BOOL retval = CSakWizardPage::OnSetActive( );

    if( m_listBox.GetItemCount( ) <= 0 ) {

        retval = FALSE;

    }

    SetBtnStates( );

    WsbTraceOut( L"CWizManVolLstSelect::OnSetActive", L"retval = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}

BOOL CWizManVolLstFinish::OnSetActive() 
{
    BOOL doAll = FALSE;
    m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_FINISH );
    
    //
    // Fill in text of configuration
    //

    CString formattedString, buildString, tempString, indentString;
    indentString.LoadString( IDS_QSTART_FINISH_INDENT );

#define FORMAT_TEXT( cid, arg )              \
    AfxFormatString1( formattedString, cid, arg ); \
    buildString += formattedString;

    //
    // Add Resources
    //

    FORMAT_TEXT( IDS_QSTART_MANRES_TEXT,    0 );
    buildString += L"\r\n";

    CWizManVolLst* pSheet = (CWizManVolLst*) m_pSheet;
    CSakVolList *pListBox = &(pSheet->m_PageSelect.m_listBox);

    INT index, managedCount = 0;
    for( index = 0; index < pListBox->GetItemCount( ); index++ ) {

        if( pListBox->GetCheck( index ) ) {

            buildString += indentString;
            tempString = pListBox->GetItemText( index, 0);
            buildString += tempString;
            buildString += L"\r\n";

            managedCount++;

        }

    }

    if( 0 == managedCount ) {

        FORMAT_TEXT( IDS_QSTART_MANAGE_NO_VOLUMES, 0 );
        buildString += L"\r\n\r\n";

    } else {

        buildString += L"\r\n";

        //
        // The levels
        //
        
        FORMAT_TEXT( IDS_QSTART_FREESPACE_TEXT, WsbLongAsString( pSheet->m_PageLevels.m_SpinLevel.GetPos( ) ) );
        buildString += L"\r\n\r\n";
        
        AfxFormatString2( formattedString, IDS_QSTART_CRITERIA_TEXT,
            CString( WsbLongAsString( pSheet->m_PageLevels.m_SpinSize.GetPos( ) ) ),
            CString( WsbLongAsString( pSheet->m_PageLevels.m_SpinDays.GetPos( ) ) ) );
        buildString += formattedString;

    }

    CEdit * pEdit = (CEdit*)GetDlgItem( IDC_WIZ_FINAL_TEXT );
    pEdit->SetWindowText( buildString );

    //
    // Now check to see if we should add a scroll bar
    //

    pEdit->SetMargins( 4, 4 );

    //
    // It seems the only way to know that an edit control needs a scrollbar
    // is to force it to scroll to the bottom and see if the first
    // visible line is the first actual line
    //

    pEdit->LineScroll( MAXSHORT );
    if( pEdit->GetFirstVisibleLine( ) > 0 ) {

        //
        // Add the scroll styles
        //

        pEdit->ModifyStyle( 0, WS_VSCROLL | ES_AUTOVSCROLL, SWP_DRAWFRAME );


    } else {

        //
        // Remove the scrollbar (set range to 0)
        //

        pEdit->SetScrollRange( SB_VERT, 0, 0, TRUE );

    }

    // Scroll to the top
    pEdit->PostMessage( EM_SETSEL, 0, 0 );
    pEdit->PostMessage( EM_SCROLLCARET, 0, 0 );
    pEdit->PostMessage( EM_SETSEL, -1, 0 );

    BOOL fRet = CSakWizardPage::OnSetActive();


    return fRet;
}

void CWizManVolLstFinish::OnSetfocusWizManvollstFinalEdit() 
{

    // Deselect the text
    CEdit *pEdit = (CEdit *) GetDlgItem( IDC_WIZ_FINAL_TEXT );
    pEdit->SetSel( -1, 0, FALSE );
    
}

ULONG CWizManVolLstLevels::GetFileSize()
{
    return( m_SpinSize.GetPos( ) );
}
        
INT CWizManVolLstLevels::GetHsmLevel() 
{
    return( m_SpinLevel.GetPos( ) );
}

INT CWizManVolLstLevels::GetAccessDays() 
{
    return( m_SpinDays.GetPos( ) );
}

void CWizManVolLstSelect::OnItemchangedManVollstFsareslbox(NMHDR* pNMHDR, LRESULT* pResult) 
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    SetBtnStates();
    
    *pResult = 0;
}

void CWizManVolLstSelect::SetBtnStates()
{
    BOOL fChecked = FALSE;
    INT count;

    // Is the "all" radio checked?
    if( !( m_radioSelect.GetCheck() == 1 ) ) {

        fChecked = TRUE;

    } else {

        // If one or more selected in the list box, set next button
        count = m_listBox.GetItemCount();
        for( INT index = 0; index < count; index++ ) {
            if( m_listBox.GetCheck( index ) == 1 ) {

                fChecked = TRUE;

            }
        }
    }

    if( fChecked ) {

        m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );

    } else {

        m_pSheet->SetWizardButtons( PSWIZB_BACK );

    }
}


void CWizManVolLstSelect::OnRadioSelect() 
{
    INT i;

    //
    // Get saved selection from itemdata array
    //
    for( i = 0; i < m_listBox.GetItemCount(); i++ ) {

        m_listBox.SetCheck( i, m_listBoxSelected[ i ] );

    }

    m_listBox.EnableWindow( TRUE );

    SetBtnStates();
}


void CWizManVolLstSelect::OnRadioManageAll() 
{
    INT i;

    //
    // Save the current selection in the itemData array
    // Check all the boxes for display purposes only
    //
    for( i = 0; i < m_listBox.GetItemCount(); i++ ) {

        m_listBoxSelected[ i ] = m_listBox.GetCheck( i );
        m_listBox.SetCheck( i, TRUE );

    }

    m_listBox.EnableWindow( FALSE );

    SetBtnStates();
}

void CWizManVolLstSelect::OnDestroy() 
{
    WsbTraceIn( L"CWizManVolLstSelect::OnDestroy", L"" );
    CSakWizardPage::OnDestroy();
    
    //
    // Need to free info held by list box
    //

    INT index;
    for( index = 0; index < m_listBox.GetItemCount( ); index++ ) {

        CResourceInfo* pResInfo = (CResourceInfo*)m_listBox.GetItemData( index );
        delete pResInfo;

    }

    WsbTraceOut( L"CWizManVolLstSelect::OnDestroy", L"" );
}
/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstSelectX property page

CWizManVolLstSelectX::CWizManVolLstSelectX()
    : CSakWizardPage_InitBaseInt( WIZ_MANVOLLST_SELECTX )
{
    //{{AFX_DATA_INIT(CWizManVolLstSelectX)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

CWizManVolLstSelectX::~CWizManVolLstSelectX()
{
    WsbTraceIn( L"CWizManVolLst::~CWizManVolLstSelectX", L"" );

    WsbTraceOut( L"CWizManVolLst::~CWizManVolLstSelectX", L"" );
}

void CWizManVolLstSelectX::DoDataExchange(CDataExchange* pDX)
{
    CSakWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWizManVolLstSelectX)
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWizManVolLstSelectX, CSakWizardPage)
    //{{AFX_MSG_MAP(CWizManVolLstSelectX)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CWizManVolLstSelectX::OnSetActive() 
{
    WsbTraceIn( L"CWizManVolLstSelectX::OnSetActive", L"" );

    BOOL retval = CSakWizardPage::OnSetActive( );

    CWizManVolLst* pSheet = (CWizManVolLst*) m_pSheet;
    if( pSheet->m_PageSelect.m_listBox.GetItemCount( ) > 0 ) {

        retval = FALSE;

    }

    m_pSheet->SetWizardButtons( PSWIZB_BACK );

    WsbTraceOut( L"CWizManVolLstSelectX::OnSetActive", L"retval = <%ls>", WsbBoolAsString( retval ) );
    return( retval );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\volume\wzmnvlls.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    WzMnVlLs.h

Abstract:

    Managed Volume wizard.

Author:

    Rohde Wakefield [rohde]   08-Aug-1997

Revision History:

--*/

#ifndef _WZMNVLLS_H
#define _WZMNVLLS_H

#include "SakVlLs.h"

// Pre-declare
class CWizManVolLst;

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstLevels dialog

class CWizManVolLstLevels : public CSakWizardPage
{
// Construction
public:
    CWizManVolLstLevels( );
    ~CWizManVolLstLevels();

// Dialog Data
    //{{AFX_DATA(CWizManVolLstLevels)
    enum { IDD = IDD_WIZ_MANVOLLST_LEVELS };
    CSpinButtonCtrl m_SpinSize;
    CSpinButtonCtrl m_SpinLevel;
    CSpinButtonCtrl m_SpinDays;
    CEdit   m_EditSize;
    CEdit   m_EditLevel;
    CEdit   m_EditDays;
    long    m_HsmLevel;
    UINT    m_AccessDays;
    DWORD   m_FileSize;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWizManVolLstLevels)
    public:
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    // Generated message map functions
    //{{AFX_MSG(CWizManVolLstLevels)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    void SetWizardFinish(void);

public:
    ULONG GetFileSize();
    int GetHsmLevel();
    int GetAccessDays();

};

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstIntro dialog

class CWizManVolLstIntro : public CSakWizardPage
{
// Construction
public:
    CWizManVolLstIntro( );
    ~CWizManVolLstIntro();

// Dialog Data
    //{{AFX_DATA(CWizManVolLstIntro)
    enum { IDD = IDD_WIZ_MANVOLLST_INTRO };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWizManVolLstIntro)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    // Generated message map functions
    //{{AFX_MSG(CWizManVolLstIntro)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstFinish dialog

class CWizManVolLstFinish : public CSakWizardPage
{
// Construction
public:
    CWizManVolLstFinish( );
    ~CWizManVolLstFinish();

// Dialog Data
    //{{AFX_DATA(CWizManVolLstFinish)
    enum { IDD = IDD_WIZ_MANVOLLST_FINISH };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWizManVolLstFinish)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    // Generated message map functions
    //{{AFX_MSG(CWizManVolLstFinish)
    afx_msg void OnSetfocusWizManvollstFinalEdit();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstSelect dialog

class CWizManVolLstSelect : public CSakWizardPage
{
// Construction
public:
    CWizManVolLstSelect( );
    ~CWizManVolLstSelect();

// Dialog Data
    //{{AFX_DATA(CWizManVolLstSelect)
    enum { IDD = IDD_WIZ_MANVOLLST_SELECT };
    CButton m_radioSelect;
    CSakVolList   m_listBox;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWizManVolLstSelect)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    // Generated message map functions
    //{{AFX_MSG(CWizManVolLstSelect)
    virtual BOOL OnInitDialog();
    afx_msg void OnItemchangedManVollstFsareslbox(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnRadioSelect();
    afx_msg void OnRadioManageAll();
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    BOOL m_fChangingByCode;
    void SetBtnStates();
    BOOL m_listBoxSelected[HSMADMIN_MAX_VOLUMES];
    HRESULT FillListBoxSelect (IFsaServer *pFsaServer,CSakVolList *pListBox);
};

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLstSelectX dialog

class CWizManVolLstSelectX : public CSakWizardPage
{
// Construction
public:
    CWizManVolLstSelectX( );
    ~CWizManVolLstSelectX();

// Dialog Data
    //{{AFX_DATA(CWizManVolLstSelectX)
    enum { IDD = IDD_WIZ_MANVOLLST_SELECTX };
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWizManVolLstSelectX)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    // Generated message map functions
    //{{AFX_MSG(CWizManVolLstSelectX)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CWizManVolLst

class CUiManVolLst;


class CWizManVolLst : public CSakWizardSheet
{
// Construction
public:
    CWizManVolLst();
    virtual ~CWizManVolLst();

public:
// Property Pages
    CWizManVolLstIntro    m_PageIntro;
    CWizManVolLstSelect   m_PageSelect;
    CWizManVolLstSelectX  m_PageSelectX;
    CWizManVolLstLevels   m_PageLevels;
    CWizManVolLstFinish   m_PageFinish;

// Attributes
public:
    ULONG m_defMgtLevel;    // default management level percentage - 100% == 1 billion

// Operations
public:
    virtual HRESULT OnFinish( void );
    STDMETHOD( AddWizardPages ) ( IN RS_PCREATE_HANDLE Handle, IN IUnknown* pPropSheetCallback, IN ISakSnapAsk* pSakSnapAsk );



};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\volume\wzunmang.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    WzUnmang.cpp

Abstract:

    Wizard for Unmanaging media - Copy Set Wizard.

Author:

    Rohde Wakefield [rohde]   26-09-1997

Revision History:

--*/

#include "stdafx.h"

#include "ManVol.h"
#include "WzUnmang.h"
#include "valwait.h"
#include "objidl.h"

// Thread function for running Validate job
static DWORD   RunValidateJob(void* pVoid);

typedef struct {
    DWORD dwResourceCookie;
    DWORD dwHsmServerCookie;
} RUN_VALIDATE_PARAM;

/////////////////////////////////////////////////////////////////////////////
// CUnmanageWizard

CUnmanageWizard::CUnmanageWizard( )
{
    WsbTraceIn( L"CUnmanageWizard::CUnmanageWizard", L"" );

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    HRESULT hr = S_OK;

    //
    // Get interfaces to needed objects
    //
    try {

        m_TitleId     = IDS_WIZ_UNMANAGE_TITLE;
        m_HeaderId    = IDB_UNMANAGE_HEADER;
        m_WatermarkId = IDB_UNMANAGE_WATERMARK;

    } WsbCatch( hr );

    WsbTraceOut( L"CUnmanageWizard::CUnmanageWizard", L"" );
}

STDMETHODIMP
CUnmanageWizard::AddWizardPages(
    IN RS_PCREATE_HANDLE Handle,
    IN IUnknown*         pCallback,
    IN ISakSnapAsk*      pSakSnapAsk
    )
{
    WsbTraceIn( L"CUnmanageWizard::AddWizardPages", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // Initialize the Sheet
        //
        WsbAffirmHr( InitSheet( Handle, pCallback, 0, pSakSnapAsk, 0, 0 ) );

        //
        // Load pages 
        //
        WsbAffirmHr( AddPage( &m_IntroPage  ) );
        WsbAffirmHr( AddPage( &m_SelectPage ) );
        WsbAffirmHr( AddPage( &m_FinishPage ) );


    } WsbCatch( hr );

    WsbTraceOut( L"CUnmanageWizard::AddWizardPages", L"" );
    return( hr );
}

CUnmanageWizard::~CUnmanageWizard()
{
    WsbTraceIn( L"CUnmanageWizard::~CUnmanageWizard", L"" );
    WsbTraceOut( L"CUnmanageWizard::~CUnmanageWizard", L"" );
}

void
CUnmanageWizard::DoThreadSetup(
    )
{
    WsbTraceIn( L"CUnmanageWizard::DoThreadSetup", L"" );
    HRESULT hr = S_OK;

    try {

        //
        // Get the HSM and FSA objects for resource
        //
        CComPtr<IUnknown> pUnkHsmResource;
        WsbAffirmHr( GetHsmObj( &pUnkHsmResource ) );
        WsbAffirmHr( pUnkHsmResource.QueryInterface( &m_pHsmResource) );

        CComPtr<IUnknown> pUnkFsaResource;
        WsbAffirmHr( m_pHsmResource->GetFsaResource( &pUnkFsaResource ) );
        WsbAffirmHr( pUnkFsaResource.QueryInterface( &m_pFsaResource ) );

        //
        // Grab the name of resource
        //
        WsbAffirmHr( RsGetVolumeDisplayName( m_pFsaResource, m_DisplayName ) );

    } WsbCatch( hr );

    WsbTraceOut( L"CUnmanageWizard::DoThreadSetup", L"hr = <%ls>", WsbHrAsString( hr ) );
}

HRESULT CUnmanageWizard::OnFinish( )
{
    WsbTraceIn( L"CUnmanageWizard::OnFinish", L"" );
    //
    // The sheet really owns the process as a whole,
    // so it will do the final assembly
    //

    HRESULT hr = S_OK;

    try {

        CComPtr<IHsmServer> pHsmServer;
        WsbAffirmHrOk( GetHsmServer( &pHsmServer ) );

        int selected = m_SelectPage.GetCheckedRadioButton( IDC_NOMANAGE, IDC_FULL );
        switch( selected ) {
        
        case IDC_NOMANAGE:
            //
            // Get the Engine's managed resource collection
            //
            {

                CComPtr<IWsbIndexedCollection> pCollection;
                WsbAffirmHr( pHsmServer->GetManagedResources( &pCollection ) );
                WsbAffirmHr( pCollection->RemoveAndRelease( m_pHsmResource ) );
                WsbAffirmHr( pHsmServer->SavePersistData( ) );

                CComPtr<IFsaServer> pFsaServer;
                WsbAffirmHr( GetFsaServer( &pFsaServer ) );
                WsbAffirmHr( RsServerSaveAll( pFsaServer ) );

            }
            break;
        
        case IDC_FULL:
            WsbAffirmHr( RsCreateAndRunFsaJob( HSM_JOB_DEF_TYPE_FULL_UNMANAGE, pHsmServer, m_pFsaResource, FALSE ) );
            break;
        
        }

    } WsbCatch( hr );

    m_HrFinish = hr;

    WsbTraceOut( L"CUnmanageWizard::OnFinish", L"hr = <%ls>", WsbHrAsString( hr ) );
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// CUnmanageWizardIntro property page

CUnmanageWizardIntro::CUnmanageWizardIntro()
    : CSakWizardPage_InitBaseExt( WIZ_UNMANAGE_INTRO )
{
    WsbTraceIn( L"CUnmanageWizardIntro::CUnmanageWizardIntro", L"" );
    //{{AFX_DATA_INIT(CUnmanageWizardIntro)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    WsbTraceOut( L"CUnmanageWizardIntro::CUnmanageWizardIntro", L"" );
}

CUnmanageWizardIntro::~CUnmanageWizardIntro()
{
    WsbTraceIn( L"CUnmanageWizardIntro::~CUnmanageWizardIntro", L"" );
    WsbTraceOut( L"CUnmanageWizardIntro::~CUnmanageWizardIntro", L"" );
}

void CUnmanageWizardIntro::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CUnmanageWizardIntro::DoDataExchange", L"" );
    CSakWizardPage::DoDataExchange(pDX );
    //{{AFX_DATA_MAP(CUnmanageWizardIntro)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
    WsbTraceOut( L"CUnmanageWizardIntro::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CUnmanageWizardIntro, CSakWizardPage)
    //{{AFX_MSG_MAP(CUnmanageWizardIntro)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CUnmanageWizardIntro message handlers

BOOL CUnmanageWizardIntro::OnInitDialog( )
{
    WsbTraceIn( L"CUnmanageWizardIntro::OnInitDialog", L"" );
    CSakWizardPage::OnInitDialog( );

    //
    // Really, first chance that we know we're in the new thread
    // Get sheet to initialize as needed
    //
    CUnmanageWizard* pSheet = (CUnmanageWizard*) m_pSheet;
    pSheet->DoThreadSetup( );
    
    WsbTraceOut( L"CUnmanageWizardIntro::OnInitDialog", L"" );
    return( TRUE );
}

BOOL CUnmanageWizardIntro::OnSetActive( )
{
    WsbTraceIn( L"CUnmanageWizardIntro::OnSetActive", L"" );
    m_pSheet->SetWizardButtons( PSWIZB_NEXT );
    
    BOOL retval = CSakWizardPage::OnSetActive( );

    WsbTraceOut( L"CUnmanageWizardIntro::OnSetActive", L"" );
    return( retval );
}

/////////////////////////////////////////////////////////////////////////////
// CUnmanageWizardSelect property page

CUnmanageWizardSelect::CUnmanageWizardSelect()
    : CSakWizardPage_InitBaseInt( WIZ_UNMANAGE_SELECT )
{
    WsbTraceIn( L"CUnmanageWizardSelect::CUnmanageWizardSelect", L"" );
    //{{AFX_DATA_INIT(CUnmanageWizardSelect)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    WsbTraceOut( L"CUnmanageWizardSelect::CUnmanageWizardSelect", L"" );
}

CUnmanageWizardSelect::~CUnmanageWizardSelect()
{
    WsbTraceIn( L"CUnmanageWizardSelect::~CUnmanageWizardSelect", L"" );
    WsbTraceOut( L"CUnmanageWizardSelect::~CUnmanageWizardSelect", L"" );
}

void CUnmanageWizardSelect::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CUnmanageWizardSelect::DoDataExchange", L"" );
    CSakWizardPage::DoDataExchange(pDX );
    //{{AFX_DATA_MAP(CUnmanageWizardSelect)
    //}}AFX_DATA_MAP
    WsbTraceOut( L"CUnmanageWizardSelect::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CUnmanageWizardSelect, CSakWizardPage)
    //{{AFX_MSG_MAP(CUnmanageWizardSelect)
	ON_BN_CLICKED(IDC_BUTTON_REFRESH, OnButtonRefresh)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CUnmanageWizardSelect message handlers


BOOL CUnmanageWizardSelect::OnInitDialog( )
{
    WsbTraceIn( L"CUnmanageWizardSelect::OnInitDialog", L"" );
    CSakWizardPage::OnInitDialog( );
    HRESULT hr = S_OK;

    try {

        m_hrAvailable = ((CUnmanageWizard*)m_pSheet)->m_pFsaResource->IsAvailable( );
        CheckRadioButton( IDC_NOMANAGE, IDC_FULL, IDC_FULL );

    } WsbCatch( hr );

    WsbTraceOut( L"CUnmanageWizardSelect::OnInitDialog", L"" );
    return TRUE;
}

BOOL CUnmanageWizardSelect::OnSetActive( )
{
    WsbTraceIn( L"CUnmanageWizardSelect::OnSetActive", L"" );

    BOOL retval = CSakWizardPage::OnSetActive( );

    SetButtons( );

    WsbTraceOut( L"CUnmanageWizardSelect::OnSetActive", L"" );
    return( retval );
}

void CUnmanageWizardSelect::SetButtons()
{
    WsbTraceIn( L"CUnmanageWizardSelect::SetButtons", L"" );

    HRESULT hr = S_OK;

    try {

        CUnmanageWizard * pSheet = (CUnmanageWizard*)m_pSheet;

        //
        // Check if volume is still around (could be formatted now).
        // If it is not available, then we don't want to let a job
        // be started against it, so set up radio buttons appropriately.
        //
        if( S_OK == m_hrAvailable ) {

            CString  string;
            LONGLONG total, free, premigrated, truncated;
            WsbAffirmHr( pSheet->m_pFsaResource->GetSizes( &total, &free, &premigrated, &truncated ) );

            WsbAffirmHr( RsGuiFormatLongLong4Char( free, string ) );
            SetDlgItemText( IDC_UNMANAGE_FREE_SPACE, string );

            WsbAffirmHr( RsGuiFormatLongLong4Char( truncated, string ) );
            SetDlgItemText( IDC_UNMANAGE_TRUNCATE, string );

            //
            // See if there is enough room to bring everything back
            //

            BOOL disableRecall = free < truncated;

            if( disableRecall ) {

                switch( GetCheckedRadioButton( IDC_NOMANAGE, IDC_FULL ) ) {

                case IDC_FULL:
                    CheckRadioButton( IDC_NOMANAGE, IDC_FULL, IDC_NOMANAGE );

                    break;
                }

                // Show the Refresh button and related items on every selection
                GetDlgItem( IDC_BUTTON_REFRESH )->ShowWindow( SW_SHOW );
                GetDlgItem( IDC_REFRESH_DESCRIPTION )->ShowWindow( SW_SHOW );

            } else {

                // Hide the Refresh button and related items
                GetDlgItem( IDC_BUTTON_REFRESH )->ShowWindow( SW_HIDE );
                GetDlgItem( IDC_REFRESH_DESCRIPTION )->ShowWindow( SW_HIDE );
            }

            GetDlgItem( IDC_FULL )->EnableWindow( !disableRecall );
            GetDlgItem( IDC_UNMANAGE_FULL_DESCRIPTION )->EnableWindow( !disableRecall );

        } else {

            CheckRadioButton( IDC_NOMANAGE, IDC_FULL, IDC_NOMANAGE );
            GetDlgItem( IDC_FULL )->EnableWindow( FALSE );
            GetDlgItem( IDC_UNMANAGE_FULL_DESCRIPTION )->EnableWindow( FALSE );
            GetDlgItem( IDC_UNMANAGE_FREE_SPACE_LABEL )->ShowWindow( SW_HIDE );
            GetDlgItem( IDC_UNMANAGE_TRUNCATE_LABEL )->ShowWindow( SW_HIDE );

            // Hide the Refresh button and related items
            GetDlgItem( IDC_BUTTON_REFRESH )->ShowWindow( SW_HIDE );
            GetDlgItem( IDC_REFRESH_DESCRIPTION )->ShowWindow( SW_HIDE );
        }

        //
        // Enable the next / back buttons
        //

        m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );

    } WsbCatchAndDo( hr,
        
        m_pSheet->SetWizardButtons( PSWIZB_BACK );

    );

    WsbTraceOut( L"CUnmanageWizardSelect::SetButtons", L"" );
}


LRESULT CUnmanageWizardSelect::OnWizardNext() 
{
    WsbTraceIn( L"CUnmanageWizardSelect::SetDescription", L"" );

    LRESULT retval = -1;

    CUnmanageWizard * pSheet = (CUnmanageWizard*)m_pSheet;

    if( S_OK == m_hrAvailable ) {

        int boxReturn = IDNO;
        const UINT type = MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON2;
        CString warning;

        switch( GetCheckedRadioButton( IDC_NOMANAGE, IDC_FULL ) ) {

        case IDC_NOMANAGE:
            AfxFormatString1( warning, IDS_WIZ_UNMANAGE_CONFIRM_NOMANAGE, pSheet->m_DisplayName );
            break;

        case IDC_FULL:
            AfxFormatString1( warning, IDS_WIZ_UNMANAGE_CONFIRM_FULL, pSheet->m_DisplayName );
            break;

        }

        boxReturn = AfxMessageBox( warning, type );
        if( boxReturn == IDYES ) {

            retval = CSakWizardPage::OnWizardNext();

        }

    } else {

        //
        // Assume the only action was to delete and the volume
        // doesn't exist, so this is OK.
        //
        retval = 0;

    }

    WsbTraceOut( L"CUnmanageWizardSelect::SetDescription", L"retval = <%ld>", retval );
    return( retval );
}

/////////////////////////////////////////////////////////////////////////////
// CUnmanageWizardFinish property page

CUnmanageWizardFinish::CUnmanageWizardFinish()
    : CSakWizardPage_InitBaseExt( WIZ_UNMANAGE_FINISH )
{
    WsbTraceIn( L"CUnmanageWizardFinish::CUnmanageWizardFinish", L"" );
    //{{AFX_DATA_INIT(CUnmanageWizardFinish)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    WsbTraceOut( L"CUnmanageWizardFinish::CUnmanageWizardFinish", L"" );
}

CUnmanageWizardFinish::~CUnmanageWizardFinish()
{
    WsbTraceIn( L"CUnmanageWizardFinish::~CUnmanageWizardFinish", L"" );
    WsbTraceOut( L"CUnmanageWizardFinish::~CUnmanageWizardFinish", L"" );
}

void CUnmanageWizardFinish::DoDataExchange(CDataExchange* pDX)
{
    WsbTraceIn( L"CUnmanageWizardFinish::DoDataExchange", L"" );
    CSakWizardPage::DoDataExchange(pDX );
    //{{AFX_DATA_MAP(CUnmanageWizardFinish)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
    WsbTraceOut( L"CUnmanageWizardFinish::DoDataExchange", L"" );
}


BEGIN_MESSAGE_MAP(CUnmanageWizardFinish, CSakWizardPage)
    //{{AFX_MSG_MAP(CUnmanageWizardFinish)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CUnmanageWizardFinish message handlers




BOOL CUnmanageWizardFinish::OnInitDialog( )
{
    WsbTraceIn( L"CUnmanageWizardFinish::OnInitDialog", L"" );
    CSakWizardPage::OnInitDialog( );
    HRESULT hr = S_OK;

    WsbTraceOut( L"CUnmanageWizardFinish::OnInitDialog", L"" );
    return TRUE;
}

BOOL CUnmanageWizardFinish::OnSetActive( )
{
    WsbTraceIn( L"CUnmanageWizardFinish::OnSetActive", L"" );

    HRESULT hr = S_OK;
    BOOL fRet = CSakWizardPage::OnSetActive( );

    try {

        CUnmanageWizard * pSheet = (CUnmanageWizard*)m_pSheet;
        int selected = pSheet->m_SelectPage.GetCheckedRadioButton( IDC_NOMANAGE, IDC_FULL );
        
        CString actionString, jobName, taskString;
        BOOL    entersTask = TRUE;
        
        switch( selected ) {
        
        case IDC_NOMANAGE:
            AfxFormatString1( actionString, IDS_WIZ_UNMANAGE_SEL_NOMANAGE, pSheet->m_DisplayName );
            entersTask = FALSE;
            taskString.LoadString( IDS_WIZ_UNMANAGE_NOMANAGE_TASK_TEXT );
            break;
        
        case IDC_FULL:
            AfxFormatString1( actionString, IDS_WIZ_UNMANAGE_SEL_FULL, pSheet->m_DisplayName );
            RsCreateJobName( HSM_JOB_DEF_TYPE_FULL_UNMANAGE, pSheet->m_pFsaResource, jobName );
            break;
        
        }

        CString selectString;
        AfxFormatString1( selectString, IDS_WIZ_UNMANAGE_SELECT, actionString );
        SetDlgItemText( IDC_SELECT_TEXT, selectString );

        if( entersTask ) {

            CWsbStringPtr        computerName;
            CComPtr<IHsmServer>  pHsmServer;
            WsbAffirmHrOk( pSheet->GetHsmServer( &pHsmServer ) );

            WsbAffirmHr( pHsmServer->GetName( &computerName ) );
            AfxFormatString2( taskString, IDS_WIZ_FINISH_RUN_JOB, jobName, computerName );

        }
        SetDlgItemText( IDC_TASK_TEXT, taskString );


    } WsbCatch( hr );

    m_pSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_FINISH );
    
    WsbTraceOut( L"CUnmanageWizardFinish::OnSetActive", L"" );
    return fRet;
}




void CUnmanageWizardSelect::OnButtonRefresh() 
{
    WsbTraceIn( L"CUnmanageWizardFinish::OnButtonRefresh", L"" );

    HRESULT                         hr = S_OK;
    CValWaitDlg*                    pWaitDlg = 0;
    HANDLE                          hJobThread[1] = { NULL };
    BOOL                            bRunning = TRUE;

    CComPtr<IGlobalInterfaceTable>  pGIT;
    RUN_VALIDATE_PARAM*             pThreadParam = NULL;
    BOOL                            bResCookieCreated = FALSE;
    BOOL                            bHsmCookieCreated = FALSE;
    CComPtr<IHsmServer>             pHsmServer;


    try {
        CUnmanageWizard* pSheet = (CUnmanageWizard*)m_pSheet;
        WsbAffirmHrOk(pSheet->GetHsmServer(&pHsmServer));

        // Register interfaces so they can be used in other threads
        pThreadParam = new RUN_VALIDATE_PARAM;
        WsbAffirm(pThreadParam, E_OUTOFMEMORY);
        WsbAffirmHr(CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, 
                        CLSCTX_INPROC_SERVER, IID_IGlobalInterfaceTable, (void **)&pGIT));
        WsbAffirmHr(pGIT->RegisterInterfaceInGlobal((IUnknown *)(IFsaResource *)(pSheet->m_pFsaResource),
                                IID_IFsaResource, &(pThreadParam->dwResourceCookie)));
        bResCookieCreated = TRUE;
        WsbAffirmHr(pGIT->RegisterInterfaceInGlobal((IUnknown *)(IHsmServer *)pHsmServer,
                                IID_IHsmServer, &(pThreadParam->dwHsmServerCookie)));
        bHsmCookieCreated = TRUE;

        // Create a thread that runs a Validate job
        hJobThread[0] = CreateThread(0, 0, RunValidateJob, (void *)pThreadParam, 0, 0);
        if (!hJobThread[0]) {
            WsbThrow(HRESULT_FROM_WIN32(GetLastError()));
        }

        // Open Validate Wait dialog
        pWaitDlg = new CValWaitDlg(pSheet, this);
        WsbAffirm(pWaitDlg, E_OUTOFMEMORY);
        if (! pWaitDlg->Create(CValWaitDlg::IDD, this)) {
            // Dialog creation failed
            WsbThrow(E_FAIL);
        }

        while (bRunning) {
            DWORD dwStatus;

            // Wait for that thread to finish, dispatch messages while it's working
            dwStatus = MsgWaitForMultipleObjects(1, hJobThread, FALSE, INFINITE, QS_ALLEVENTS);

            switch (dwStatus) {
                case WAIT_OBJECT_0: {
                    //  The thread ended get it's exit code
                    DWORD dwExitCode;
                    if (GetExitCodeThread(hJobThread[0], &dwExitCode)) {
                        if (STILL_ACTIVE == dwExitCode) {
                            //  This shouldn't happen
                            hr = E_FAIL;
                        } else {
                            // Thread return code
                            hr = static_cast<HRESULT>(dwExitCode);
                        }
                    } else {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }

                    bRunning = FALSE;

                    break;
                }

                case (WAIT_OBJECT_0 + 1): {
                    // Message in the queue
                    MSG   msg;

                    while (PeekMessage(&msg, pWaitDlg->m_hWnd, 0, 0, PM_REMOVE)) {
                        DispatchMessage(&msg);
                    }

                    while (PeekMessage(&msg, NULL, 0, 0, (PM_REMOVE | PM_QS_PAINT))) {
                        DispatchMessage(&msg);
                    }

                    break;
                }

                case 0xFFFFFFFF:
                default:
                    // Error
                    hr = HRESULT_FROM_WIN32(GetLastError());

                    bRunning = FALSE;

                    break;
            }
        }

        // Close Wait dialog
        pWaitDlg->DestroyWindow( );

        // Reset buttons
        SetButtons();

    } WsbCatch(hr);

    // Check err code
    if (SUCCEEDED(hr)) {
        WsbTrace(L"CUnmanageWizardFinish::OnButtonRefresh: hr = <%ls>\n", WsbHrAsString(hr));
    } else {
        // Failure should happen only under sever resource conditions so 
        // display a messagebox on Refresh failure
        WsbTraceAlways(L"CUnmanageWizardFinish::OnButtonRefresh: hr = <%ls>\n", WsbHrAsString(hr));
        CString errString;
        AfxFormatString1(errString, IDS_ERR_REFRESH_FAILED, WsbHrAsString(hr));
        AfxMessageBox(errString, RS_MB_ERROR); 
    }

    if (hJobThread[0]) {
        CloseHandle(hJobThread[0]);
    }

    // Clean object registration staff
    if (bResCookieCreated) {
        pGIT->RevokeInterfaceFromGlobal(pThreadParam->dwResourceCookie);
    }
    if (bHsmCookieCreated) {
        pGIT->RevokeInterfaceFromGlobal(pThreadParam->dwHsmServerCookie);
    }
    if (pThreadParam) {
        delete pThreadParam;
    }

    WsbTraceOut( L"CUnmanageWizardFinish::OnButtonRefresh", L"" );
}

static DWORD RunValidateJob(void* pVoid)
{
    WsbTraceIn( L"RunValidateJob", L"" );

    HRESULT             hr = S_OK;
    HRESULT             hrCom = S_OK;

    try {
        RUN_VALIDATE_PARAM*             pThreadParam = NULL;
        CComPtr<IHsmServer>             pHsmServer;
        CComPtr<IFsaResource>           pFsaResource;
        CComPtr<IGlobalInterfaceTable>  pGIT;

        hrCom = CoInitialize( 0 );
        WsbAffirmHr( hrCom );

        pThreadParam = (RUN_VALIDATE_PARAM*)pVoid;
        WsbAffirmPointer(pThreadParam);

        // Get Fsa Resource & HSM Server interface pointers for this thread
        WsbAffirmHr(CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, 
                        CLSCTX_INPROC_SERVER, IID_IGlobalInterfaceTable, (void **)&pGIT));
        WsbAffirmHr(pGIT->GetInterfaceFromGlobal(pThreadParam->dwResourceCookie,
                                IID_IFsaResource, (void **)&pFsaResource));
        WsbAffirmHr(pGIT->GetInterfaceFromGlobal(pThreadParam->dwHsmServerCookie,
                                IID_IHsmServer, (void **)&pHsmServer));

        // Run job
        WsbTrace(L"RunValidateJob: Got interface pointers, running Validate job\n");
        WsbAffirmHr(RsCreateAndRunDirectFsaJob(HSM_JOB_DEF_TYPE_VALIDATE, pHsmServer,
                        pFsaResource, TRUE));

    } WsbCatch(hr);

    if (SUCCEEDED(hrCom)) {
        CoUninitialize();
    }
 
    WsbTraceOut( L"RunValidateJob", L"hr = <%ls>", WsbHrAsString( hr ) );

    return(static_cast<DWORD>(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\volume\rule.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Rule.h

Abstract:

    Rule functionality

Author:

    Art Bragg 10/8/97

Revision History:

--*/

#ifndef RULE_H
#define RULE_H

#pragma once

/////////////////////////////////////////////////////////////////////////////
// CRule dialog

class CRule : public CRsDialog
{
// Construction
public:
    CRule(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CRule)
    enum { IDD = IDD_DLG_RULE_EDIT };
    BOOL    m_subDirs;
    CString m_fileSpec;
    CString m_path;
    int     m_includeExclude;
    CString m_pResourceName;
    //}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRule)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation

protected:

    // Generated message map functions
    //{{AFX_MSG(CRule)
    afx_msg void OnRadioExclude();
    afx_msg void OnRadioInclude();
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
private:
    BOOL FixRulePath (CString& sPath);

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\volume\valwait.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    valwait.h

Abstract:

    Implements Validate Wait Dialog class

Author:

    Ran Kalach          [rankala]         23-May-2000

Revision History:

--*/
#ifndef _VALWAIT_
#define _VALWAIT_

#pragma once

/////////////////////////////////////////////////////////////////////////////
// CValWaitDlg dialog
class CUnmanageWizard;

class CValWaitDlg : public CDialog
{
// Construction
public:
	CValWaitDlg(CUnmanageWizard *pSheet, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CValWaitDlg)
	enum { IDD = IDD_VALIDATE_WAIT };
	CAnimateCtrl	m_Animation;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CValWaitDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void PostNcDestroy();
	//}}AFX_VIRTUAL

// Implementation
protected:

    CUnmanageWizard *m_pSheet;

	// Generated message map functions
	//{{AFX_MSG(CValWaitDlg)
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
//}}AFX

#endif // _VALWAIT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\inc\wizsht.h ===
// WizSht.h: interface for the CRsWizardSheet class.
//
//////////////////////////////////////////////////////////////////////
#include "PropPage.h"

#if !defined(AFX_WIZSHT_H__A4135C61_8B78_11D1_B9A1_00A0C9190447__INCLUDED_)
#define AFX_WIZSHT_H__A4135C61_8B78_11D1_B9A1_00A0C9190447__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CRsWizardSheet : public CPropertySheet  
{
public:
    CRsWizardSheet( UINT nIDCaption, CWnd *pParentWnd = NULL, UINT iSelectPage = 0 );
    virtual ~CRsWizardSheet();
protected:
    void AddPage( CRsWizardPage* pPage );
private:
    UINT m_IdCaption;
};

#endif // !defined(AFX_WIZSHT_H__A4135C61_8B78_11D1_B9A1_00A0C9190447__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\inc\rshelpid.h ===
/*++

Module Name:

    rshelpid.h

Abstract:

    Help ids for all of HSM UI

Author:

    Ran Kalach [rankala]   11-Sep-2000

Revision History:

--*/

#ifndef _RSHELPID_H
#define _RSHELPID_H

/////////////////////////////////////////////////////////////////////////////
//
//  Help IDs - these should be removed before final ship and use an rsadmin.hm
//
/////////////////////////////////////////////////////////////////////////////
#define idh_status 9047
#define idh_total_managed_volumes 9069
#define idh_total_cartridges_used 9071
#define idh_total_data_remote_storage 9073
#define idh_version 9088
#define idh_change_schedule_button 9003
#define idh_runaway_recall_limit 1106
#define idh_concurrent_drives_limit 1107
#define idh_volume_name 9087
#define idh_volume_percent_local_data 1174
#define idh_volume_capacity_local_data 1169
#define idh_volume_percent_remote_data_cached 1175
#define idh_volume_capacity_remote_data_cached 1167
#define idh_volume_percent_free_space 1173
#define idh_volume_capacity_free_space 1166
#define idh_volume_disk_capacity 1165
#define idh_volume_data_remote_storage 1171
#define idh_actual_free_space_capacity 1177
#define idh_actual_free_space_percent 1117
#define idh_desired_free_space_percent 1176
#define idh_desired_free_space_capacity 1118
#define idh_min_file_size_criteria 1119
#define idh_file_access_date_criteria 9057
#define idh_new_rule_button 1128
#define idh_rule_delete_button 1132
#define idh_rule_edit_button 1129
#define idh_rule_up_button 1130
#define idh_rule_down_button 9015
#define idh_media_master_name 9017
#define idh_media_master_status 9018
#define idh_media_master_capacity 9019
#define idh_media_master_free_space 9045
#define idh_media_master_last_modified 9028
#define idh_media_copy1_name 9030
#define idh_media_copy2_name 9036
#define idh_media_copy3_name 9000
#define idh_media_number_of_copy_sets 9025
#define idh_media_copy1_status 9033
#define idh_media_copy2_status 9039
#define idh_media_copy3_status 9029
#define idh_media_copy1_delete_button 9035
#define idh_media_copy2_delete_button 9041
#define idh_media_copy3_delete_button 9026
#define idh_media_copy1_last_modified 9034
#define idh_media_copy2_last_modified 9040
#define idh_media_copy3_last_modified 9023
#define idh_instance 9093
#define idh_current_schedule 9002
#define idh_runaway_recall_exemption 9090
#define idh_media_synch_copies_now_button 9137
#define idh_media_recreate_master_button 9021
#define idh_rule_list 1180
#define idh_rule_edit_name 1143
#define idh_rule_edit_path 1136
#define idh_rule_edit_file_type 1137
#define idh_rule_edit_exclude 1139
#define idh_rule_edit_include 1138
#define idh_rule_edit_apply_subfolders 1140

#endif // _RSHELPID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\inc\rsutil.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsUtil.cpp

Abstract:

    Utility functions for GUI

    NOTENOTENOTENOTE:

    Do not use any WSB functions in this file, as it is included in
    recall notify which must run without WSB. It must also be able to
    build as UNICODE or non-UNICODE

Author:

    Art Bragg [abragg]   08-Aug-1997

Revision History:

--*/

#include "shlwapi.h"

#define HIDWORD(_qw)    (DWORD)((_qw)>>32)
#define LODWORD(_qw)    (DWORD)(_qw)
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#define HINST_THISDLL   AfxGetInstanceHandle()

// Local function prototypes

HRESULT ShortSizeFormat64(__int64 dw64, LPTSTR szBuf);
LPTSTR AddCommas(DWORD dw, LPTSTR pszResult, int nResLen);
HRESULT RsGuiFormatLongLong (
        IN LONGLONG number, 
        IN BOOL bIncludeUnits,
        OUT CString& sFormattedNumber)

/*++

Routine Description:

    Formats a LONGLONG number into a locale-sensitive string with no decimal
    fraction.  Option is given for adding units at the end.

Arguments:

    number              I: Number to format
    bIncludeUnits       I: TRUE - add "bytes" at the end
    sFormattedNumber    O: Formatted number

Return Value:

    S_OK - Success.
    E_* - Failure occured 

--*/
{

    HRESULT hr = S_OK;
    TCHAR sBuf [256];
    TCHAR lpLCData [256];
    TCHAR lpLCDataDecimal[256];
    TCHAR lpLCDataThousand[256];
    LPTSTR pBuffer;
    int bufSize;
    NUMBERFMT format;

    try {
        // Set up the parameters for the conversion function.

        // Don't show fractions
        format.NumDigits = 0;
    
        // Get current setting for the rest of the parameters
        WsbAffirmStatus (GetLocaleInfo( LOCALE_SYSTEM_DEFAULT, LOCALE_ILZERO, lpLCData, 256 ));
        format.LeadingZero = _ttoi(lpLCData);
    
        WsbAffirmStatus (GetLocaleInfo( LOCALE_SYSTEM_DEFAULT, LOCALE_SGROUPING, lpLCData, 256 ));
        lpLCData[1] = 0;
        format.Grouping = _ttoi(lpLCData);

        WsbAffirmStatus (GetLocaleInfo( LOCALE_SYSTEM_DEFAULT, LOCALE_SDECIMAL, lpLCDataDecimal, 256 ));
        format.lpDecimalSep = lpLCDataDecimal; 

        WsbAffirmStatus (GetLocaleInfo( LOCALE_SYSTEM_DEFAULT, LOCALE_STHOUSAND, lpLCDataThousand, 256 ));
        format.lpThousandSep = lpLCDataThousand; 
    
        WsbAffirmStatus (GetLocaleInfo( LOCALE_SYSTEM_DEFAULT, LOCALE_INEGNUMBER, lpLCData, 256 ));
        format.NegativeOrder = _ttoi(lpLCData);

        // Convert the number to a non-localized string
        _i64tot( number, sBuf, 10 );

        // Get the size of the localized converted number
        bufSize = GetNumberFormat (LOCALE_SYSTEM_DEFAULT, 0, sBuf, &format, NULL, 0);
        WsbAffirmStatus (bufSize);

        // Allocate the buffer in the CString
        pBuffer = sFormattedNumber.GetBufferSetLength( bufSize );

        // Convert non-localized string to a localized string
        WsbAffirmStatus (GetNumberFormat (LOCALE_SYSTEM_DEFAULT, 0, sBuf, &format, pBuffer, bufSize));

        // Release the CString buffer
        sFormattedNumber.ReleaseBuffer (-1);

        // If caller requested, append units
        if (bIncludeUnits) {
            sFormattedNumber = sFormattedNumber + L" bytes";
        }
    } WsbCatch (hr);
    return hr;
}


HRESULT RsGuiFormatLongLong4Char (
        IN LONGLONG number,                 // in bytes
        OUT CString& sFormattedNumber)
/*++

Routine Description:

    Formats a LONGLONG number into a locale-sensitive string that can be
    displayed in 4 chars.  Option is given for adding units at the end.

Arguments:

    number              I: Number to format
    sFormattedNumber    O: Formatted number

Return Value:

    S_OK - Success.
    E_* - Failure occured 

--*/
{

    // We call a function cloned from MS code

    LPTSTR p;
    p = sFormattedNumber.GetBuffer( 30 );
    HRESULT hr = ShortSizeFormat64(number, p);
    sFormattedNumber.ReleaseBuffer();
    return hr;

}   

const int pwOrders[] = {IDS_BYTES, IDS_ORDERKB, IDS_ORDERMB,
                          IDS_ORDERGB, IDS_ORDERTB, IDS_ORDERPB, IDS_ORDEREB};

/* converts numbers into sort formats
 *      532     -> 523 bytes
 *      1340    -> 1.3KB
 *      23506   -> 23.5KB
 *              -> 2.4MB
 *              -> 5.2GB
 */

// NOTE: This code is cloned from MS source /shell/shelldll/util.c - AHB

HRESULT ShortSizeFormat64(__int64 dw64, LPTSTR szBuf)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    int i;
    UINT wInt, wLen, wDec;
    TCHAR szTemp[10], szOrder[20], szFormat[5];

    if (dw64 < 1000) {
        wsprintf(szTemp, TEXT("%d"), LODWORD(dw64));
        i = 0;
        goto AddOrder;
    }

    for (i = 1; i<ARRAYSIZE(pwOrders)-1 && dw64 >= 1000L * 1024L; dw64 >>= 10, i++);
        /* do nothing */

    wInt = LODWORD(dw64 >> 10);
    AddCommas(wInt, szTemp, 10);
    wLen = lstrlen(szTemp);
    if (wLen < 3)
    {
        wDec = LODWORD(dw64 - (__int64)wInt * 1024L) * 1000 / 1024;
        // At this point, wDec should be between 0 and 1000
        // we want get the top one (or two) digits.
        wDec /= 10;
        if (wLen == 2)
            wDec /= 10;

        // Note that we need to set the format before getting the
        // intl char.
        lstrcpy(szFormat, TEXT("%02d"));

        szFormat[2] = (TCHAR)( TEXT('0') + 3 - wLen );
        GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL,
                szTemp+wLen, ARRAYSIZE(szTemp)-wLen);
        wLen = lstrlen(szTemp);
        wLen += wsprintf(szTemp+wLen, szFormat, wDec);
    }

AddOrder:
    LoadString(HINST_THISDLL, pwOrders[i], szOrder, ARRAYSIZE(szOrder));
    wsprintf(szBuf, szOrder, (LPTSTR)szTemp);

    return S_OK;
}

void RsGuiMakeVolumeName (CString szName, CString szLabel, CString& szDisplayName)
/*++

Routine Description:

    Formats a string showing the drive letter and volume label for a volume.

Arguments:

    szName          I: Name of volume i.e. "E:"
    szLabel         I: Volume label i.i "Art's Volume"
    szDisplayName   O: "Art's Volume (E:)"

Return Value: None
_* - Failure occured 

--*/
{
    szDisplayName.Format( TEXT ("%ls (%.1ls:)"), szLabel, szName );
}


// NOTE: This code is cloned from MS source /shell/shelldll/util.c - AHB

// takes a DWORD add commas etc to it and puts the result in the buffer
LPTSTR AddCommas(DWORD dw, LPTSTR pszResult, int nResLen)
{
    TCHAR  szTemp[20];  // more than enough for a DWORD
    TCHAR  szSep[5];
    NUMBERFMT nfmt;

    nfmt.NumDigits=0;
    nfmt.LeadingZero=0;
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szSep, ARRAYSIZE(szSep));
    nfmt.Grouping = _tcstol(szSep, NULL, 10);
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, ARRAYSIZE(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder= 0;

    wsprintf(szTemp, TEXT("%lu"), dw);

    if (GetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, &nfmt, pszResult, nResLen) == 0)
        lstrcpy(pszResult, szTemp);

    return pszResult;
}


CString RsGuiMakeShortString(
    IN CDC* pDC, 
    IN const CString& StrLong,
    IN int Width
    )
/*++

Routine Description:

    Determines if the supplied string fits in it's column.  If not truncates
    it and adds "...".  From MS sample code.

Arguments:

    pDC         - Device context
    str         - Original String
    width       - Width of column

Return Value:

    Shortened string

--*/
{

    CString strShort  = StrLong;
    int     stringLen = strShort.GetLength( );

    //
    // See if we need to shorten the string
    //
    if( ( stringLen > 0 ) &&
        ( pDC->GetTextExtent( strShort, stringLen ).cx > Width ) ) {

        CString threeDots = _T("...");
        int     addLen    = pDC->GetTextExtent( threeDots, threeDots.GetLength( ) ).cx;

        for( int i = stringLen - 1; i > 0; i-- ) {

            if( ( pDC->GetTextExtent( strShort, i ).cx + addLen ) <= Width ) {

                break;

            }
        }

        strShort = strShort.Left( i ) + threeDots;

    }

    return( strShort );
}

/////////////////////////////////////////////////////////////////////////////
// CRsGuiOneLiner

CRsGuiOneLiner::CRsGuiOneLiner()
{
    m_pToolTip = 0;
}

CRsGuiOneLiner::~CRsGuiOneLiner()
{
    EnableToolTip( FALSE );
}


BEGIN_MESSAGE_MAP(CRsGuiOneLiner, CStatic)
	//{{AFX_MSG_MAP(CRsGuiOneLiner)
	//}}AFX_MSG_MAP
    ON_MESSAGE( WM_SETTEXT, OnSetText )
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRsGuiOneLiner message handlers

LRESULT
CRsGuiOneLiner::OnSetText(
    WPARAM /*wParam*/,
    LPARAM lParam
    )
{
    LRESULT lResult = 0;
	ASSERT(lParam == 0 || AfxIsValidString((LPCTSTR)lParam));

    m_LongTitle = (LPCTSTR)lParam;
    m_Title = m_LongTitle;

    //
    // See if this is too long to show, and shorten if so
    //
    CRect rect;
    GetClientRect( &rect );

    CDC* pDc = GetDC( );
    if( pDc ) {

        CFont* pFont = GetFont( );
        CFont* pSaveFont = pDc->SelectObject( pFont );
        if( pSaveFont ) {

            m_Title = RsGuiMakeShortString( pDc, m_LongTitle, rect.right );
            pDc->SelectObject( pSaveFont );

        }
        ReleaseDC( pDc );

    }
    if( m_hWnd ) {

        lResult = DefWindowProc( WM_SETTEXT, 0, (LPARAM)(LPCTSTR)m_Title );

    }

    //
    // Enable the tooltip if the titles are not the same
    //
    EnableToolTip( m_Title != m_LongTitle, m_LongTitle );

    return( lResult );
}

void CRsGuiOneLiner::EnableToolTip( BOOL Enable, const TCHAR* pTipText )
{
    if( Enable ) {

        //
        // Make sure the tooltip does not exist before creating new one
        //
        EnableToolTip( FALSE );

        m_pToolTip = new CToolTipCtrl;
        if( m_pToolTip ) {

            m_pToolTip->Create( this );

            //
            // Can't use the CToolTipCtrl methods for adding tool
            // since these tie the control into sending messages
            // to the parent, and don't allow subclassing option
            //
            // BTW, the subclassing option allows the control to
            // automatically see our messages. Otherwise, we have
            // to go through complicated message interception and
            // relaying these to the tooltip (which doesn't work
            // anyway)
            //
            TOOLINFO ti;
            ZeroMemory( &ti, sizeof( ti ) );
            ti.cbSize   = sizeof( ti );
            ti.uFlags   = TTF_IDISHWND|TTF_CENTERTIP|TTF_SUBCLASS;
            ti.hwnd     = GetSafeHwnd( );
            ti.uId      = (WPARAM)GetSafeHwnd( );
            ti.lpszText = (LPTSTR)(LPCTSTR)pTipText;
            m_pToolTip->SendMessage( TTM_ADDTOOL, 0, (LPARAM)&ti );

            //
            // Set delays so that the tooltip comes up right away
            // and doesn't go away until 15 seconds.
            //
            m_pToolTip->SendMessage( TTM_SETDELAYTIME, TTDT_AUTOPOP, 15000 );
            m_pToolTip->SendMessage( TTM_SETDELAYTIME, TTDT_INITIAL, 0 );

            //
            // And activate and top the tooltip
            //
            m_pToolTip->Activate( TRUE );
			m_pToolTip->SetWindowPos( &wndTop, 0, 0, 0, 0,
				SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOMOVE|SWP_NOOWNERZORDER );

        }

    } else if( !Enable && m_pToolTip ) {

        m_pToolTip->Activate( FALSE );

        delete m_pToolTip;
        m_pToolTip = 0;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\inc\rstrace.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsTrace.h

Abstract:

    Simple tracing functionality for components that cannot use standard
    WsbTrace in RsCommon.dll

Author:

    Rohde Wakefield   [rohde]   20-Feb-1998

Revision History:

--*/

#pragma once

#ifndef _RSTRACE_H
#define _RSTRACE_H

#define RsBoolAsString(b) ((b) ? "TRUE" : "FALSE" )

#ifdef TRACE
#undef TRACE 
#endif
#define TRACE if( CRsFuncTrace::m_TraceEnabled ) CRsFuncTrace::Trace

#define TRACEFN( __FuncName )      CRsFuncTrace __FnTrace( __FuncName );
#define TRACEFNHR( __FuncName )    HRESULT hrRet   = S_OK;  CRsFuncTraceHr    __FnTrace( __FuncName, &hrRet );
#define TRACEFNDW( __FuncName )    DWORD   dwRet   = 0;     CRsFuncTraceDw    __FnTrace( __FuncName, &dwRet );
#define TRACEFNLONG( __FuncName )  LONG    lRet    = 0;     CRsFuncTraceLong  __FnTrace( __FuncName, &lRet );
#define TRACEFNSHORT( __FuncName ) SHORT   sRet    = 0;     CRsFuncTraceShort __FnTrace( __FuncName, &sRet );
#define TRACEFNBOOL( __FuncName )  BOOL    boolRet = FALSE; CRsFuncTraceBool  __FnTrace( __FuncName, &boolRet );

/////////////////////////////////////////////////////////////////////////////
// CRsRegKey - A minimal subset of ATL's CRegKey class

class CRsRegKey
{
public:
    CRsRegKey()  {m_hKey = NULL;}
    ~CRsRegKey() {Close();}

// Attributes
public:
    operator HKEY() const {return m_hKey;}

    HKEY m_hKey;

// Operations
public:
    LONG QueryValue(DWORD& dwValue, LPCTSTR lpszValueName)
    {
        DWORD dwType = NULL;
        DWORD dwCount = sizeof(DWORD);
        LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
            (LPBYTE)&dwValue, &dwCount);
#if 0  // we check for sometimes non-existent values
        _ASSERTE((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD));
        _ASSERTE((lRes!=ERROR_SUCCESS) || (dwCount == sizeof(DWORD)));
#endif
        
        return lRes;
    }

    LONG QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount)
    {
        _ASSERTE(pdwCount != NULL);
        DWORD dwType = NULL;
        LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
            (LPBYTE)szValue, pdwCount);
#if 0  // we check for sometimes non-existent values
        _ASSERTE((lRes!=ERROR_SUCCESS) || (dwType == REG_SZ) ||
                 (dwType == REG_MULTI_SZ) || (dwType == REG_EXPAND_SZ));
#endif
        return lRes;
    }

    LONG SetValue(DWORD dwValue, LPCTSTR lpszValueName)
    {
	    _ASSERTE(m_hKey != NULL);
	    return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_DWORD,
		    (BYTE * const)&dwValue, sizeof(DWORD));
    }

    LONG DeleteValue(LPCTSTR lpszValue)
    {
	    ATLASSERT(m_hKey != NULL);
	    return RegDeleteValue(m_hKey, (LPTSTR)lpszValue);
    }

    LONG Open(HKEY hKeyParent, LPCTSTR lpszKeyName,
        REGSAM samDesired = KEY_ALL_ACCESS)
    {
        _ASSERTE(hKeyParent != NULL);
        HKEY hKey = NULL;
        LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);
        if (lRes == ERROR_SUCCESS)
        {
            lRes = Close();
            _ASSERTE(lRes == ERROR_SUCCESS);
            m_hKey = hKey;
        }
        return lRes;
    }

    LONG Close()
    {
        LONG lRes = ERROR_SUCCESS;
        if (m_hKey != NULL)
        {
            lRes = RegCloseKey(m_hKey);
            m_hKey = NULL;
        }
        return lRes;
    }
};

//
// Base class for function tracing. Core tracing behavior.
//
class CRsFuncTraceBase
{
public:
    CRsFuncTraceBase( const char * FuncName ) : m_FuncName( FuncName )
    {
        m_IndentLevel++;
    }

    ~CRsFuncTraceBase( void )
    {
        m_IndentLevel--;
    }

    static void TraceInner( const _TCHAR * Fmt, ... )
    {
        va_list list;
        va_start( list, Fmt );

        TraceV( 1, Fmt, list );

        va_end( list );
    }

    static void TraceOuter( const _TCHAR * Fmt, ... )
    {
        va_list list;
        va_start( list, Fmt );

        TraceV( -1, Fmt, list );

        va_end( list );
    }

    static void Trace( const _TCHAR * Fmt, ... )
    {
        va_list list;
        va_start( list, Fmt );

        TraceV( 0, Fmt, list );

        va_end( list );
    }

    static void TraceV( LONG IndentMod, const _TCHAR * Fmt, va_list List )
    {
        _TCHAR buf[1024];

        LONG charIndent =  max( 0, ( m_IndentLevel  + IndentMod ) * m_IndentChars );

        for( LONG i = 0; i < charIndent; i++ ) {
 
            *(buf + i) = _T(' ');

        }

        _vstprintf( buf + charIndent, Fmt, List );

        OutputDebugString( buf );
        OutputDebugString( _T("\n") );
    }

    static BOOL CheckRegEnabled( _TCHAR * Module )
    {
        BOOL retval = FALSE;
        CRsRegKey keySoftware, keyCompany, keyModule, keyModule2;

        if( ERROR_SUCCESS == keySoftware.Open( HKEY_LOCAL_MACHINE, _T("Software")  )   &&
            ERROR_SUCCESS == keyCompany.Open(  keySoftware,        _T("Microsoft") )   &&
            ERROR_SUCCESS == keyModule.Open(   keyCompany,         _T("RemoteStorage") ) &&
            ERROR_SUCCESS == keyModule2.Open(  keyModule,          Module ) ) {

            DWORD dw;
            if( ERROR_SUCCESS == keyModule2.QueryValue( dw, _T("Trace") ) ) {

                if( dw != 0 ) {

                    retval = TRUE;

                }
            } else {
                
                TCHAR buf[128];
                dw = 128;
                if( ERROR_SUCCESS == keyModule2.QueryValue( buf, _T("Trace"), &dw ) ) {

                    if( ( dw > 0 ) && ( _T('0') != buf[0] ) ) {

                        retval = TRUE;

                    }
                }
            }
        }
        return( retval );
    }

protected:
    const char * m_FuncName;

private:
    static LONG m_IndentLevel;
    static const LONG m_IndentChars;

public:
    static BOOL m_TraceEnabled;
};

//
// Trace Functions w/o any result data printed
//
class CRsFuncTrace : public CRsFuncTraceBase
{
public:
    CRsFuncTrace( const char * FuncName ) :
        CRsFuncTraceBase( FuncName )
    {
        if( m_TraceEnabled )
            TraceOuter( m_TraceInFmt, m_FuncName );
    }

    ~CRsFuncTrace( void )
    {
        if( m_TraceEnabled )
            TraceOuter( m_TraceOutFmt, m_FuncName );
    }

private:
    static const _TCHAR * m_TraceInFmt;
    static const _TCHAR * m_TraceOutFmt;

};

//
// Trace Functions with HRESULT
//
class CRsFuncTraceHr : public CRsFuncTraceBase
{
public:
    CRsFuncTraceHr( const char * FuncName, const HRESULT * pHr ) :
        CRsFuncTraceBase( FuncName ), m_pHr( pHr )
    {
        if( m_TraceEnabled )
            TraceOuter( m_TraceInFmt, m_FuncName );
    }

    ~CRsFuncTraceHr( void )
    {
        if( m_TraceEnabled )
            TraceOuter( m_TraceOutFmt, m_FuncName, *m_pHr );
    }

private:
    const HRESULT * m_pHr;

    static const _TCHAR * m_TraceInFmt;
    static const _TCHAR * m_TraceOutFmt;

};

//
// Trace Functions with DWORD return
//
class CRsFuncTraceDw : public CRsFuncTraceBase
{
public:
    CRsFuncTraceDw( const char * FuncName, const DWORD * pDw ) :
        CRsFuncTraceBase( FuncName ), m_pDw( pDw )
    {
        if( m_TraceEnabled )
            TraceOuter( m_TraceInFmt, m_FuncName );
    }

    ~CRsFuncTraceDw( void )
    {
        if( m_TraceEnabled )
            TraceOuter( m_TraceOutFmt, m_FuncName, *m_pDw, *m_pDw );
    }

private:
    const DWORD * m_pDw;

    static const _TCHAR * m_TraceInFmt;
    static const _TCHAR * m_TraceOutFmt;

};

//
// Trace Functions with LONG return
//
class CRsFuncTraceLong : public CRsFuncTraceBase
{
public:
    CRsFuncTraceLong( const char * FuncName, const LONG * pLong ) :
        CRsFuncTraceBase( FuncName ), m_pLong( pLong )
    {
        if( m_TraceEnabled )
            TraceOuter( m_TraceInFmt, m_FuncName );
    }

    ~CRsFuncTraceLong( void )
    {
        if( m_TraceEnabled )
            TraceOuter( m_TraceOutFmt, m_FuncName, *m_pLong );
    }

private:
    const LONG * m_pLong;

    static const _TCHAR * m_TraceInFmt;
    static const _TCHAR * m_TraceOutFmt;

};

//
// Trace Functions with SHORT return
//
class CRsFuncTraceShort : public CRsFuncTraceBase
{
public:
    CRsFuncTraceShort( const char * FuncName, const SHORT * pShort ) :
        CRsFuncTraceBase( FuncName ), m_pShort( pShort )
    {
        if( m_TraceEnabled )
            TraceOuter( m_TraceInFmt, m_FuncName );
    }

    ~CRsFuncTraceShort( void )
    {
        if( m_TraceEnabled )
            TraceOuter( m_TraceOutFmt, m_FuncName, *m_pShort );
    }

private:
    const SHORT * m_pShort;

    static const _TCHAR * m_TraceInFmt;
    static const _TCHAR * m_TraceOutFmt;

};

//
// Trace Functions with BOOL return
//
class CRsFuncTraceBool : public CRsFuncTraceBase
{
public:
    CRsFuncTraceBool( const char * FuncName, const BOOL * pBool ) :
        CRsFuncTraceBase( FuncName ), m_pBool( pBool )
    {
        if( m_TraceEnabled )
            TraceOuter( m_TraceInFmt, m_FuncName );
    }

    ~CRsFuncTraceBool( void )
    {
        if( m_TraceEnabled )
            TraceOuter( m_TraceOutFmt, m_FuncName, RsBoolAsString( *m_pBool ) );
    }

private:
    const BOOL * m_pBool;

    static const _TCHAR * m_TraceInFmt;
    static const _TCHAR * m_TraceOutFmt;

};


#define RSTRACE_INIT(Module)                                                             \
    LONG CRsFuncTrace::m_IndentLevel = 0;                                                \
    const LONG CRsFuncTrace::m_IndentChars = 2;                                          \
    BOOL CRsFuncTrace::m_TraceEnabled = CRsFuncTrace::CheckRegEnabled( _T(Module) );     \
    const _TCHAR * CRsFuncTrace::m_TraceInFmt       = _T("Enter <%hs>");                  \
    const _TCHAR * CRsFuncTrace::m_TraceOutFmt      = _T("Exit  <%hs>");       \
    const _TCHAR * CRsFuncTraceHr::m_TraceInFmt     = _T("Enter <%hs>");                  \
    const _TCHAR * CRsFuncTraceHr::m_TraceOutFmt    = _T("Exit  <%hs> <0x%p>");       \
    const _TCHAR * CRsFuncTraceDw::m_TraceInFmt     = _T("Enter <%hs>");                  \
    const _TCHAR * CRsFuncTraceDw::m_TraceOutFmt    = _T("Exit  <%hs> <0x%p><%lu>");  \
    const _TCHAR * CRsFuncTraceLong::m_TraceInFmt   = _T("Enter <%hs>");                  \
    const _TCHAR * CRsFuncTraceLong::m_TraceOutFmt  = _T("Exit  <%hs> <%ld>");  \
    const _TCHAR * CRsFuncTraceShort::m_TraceInFmt  = _T("Enter <%hs>");                  \
    const _TCHAR * CRsFuncTraceShort::m_TraceOutFmt = _T("Exit  <%hs> <%hd>");  \
    const _TCHAR * CRsFuncTraceBool::m_TraceInFmt   = _T("Enter <%hs>");                  \
    const _TCHAR * CRsFuncTraceBool::m_TraceOutFmt  = _T("Exit  <%hs> <%hs>");            \

#endif // _RSTRACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\hsmadmin\volume\wzunmang.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    WzUnmang.h

Abstract:

    Wizard for Unmanaging media - Copy Set Wizard.

Author:

    Rohde Wakefield [rohde]   26-09-1997

Revision History:

--*/

#ifndef _WZUNMANG_H
#define _WZUNMANG_H

// Pre-declare
class CUnmanageWizard;

/////////////////////////////////////////////////////////////////////////////
// CUnmanageWizardSelect dialog

class CUnmanageWizardSelect : public CSakWizardPage
{
// Construction
public:
    CUnmanageWizardSelect( );
    ~CUnmanageWizardSelect();

// Dialog Data
    //{{AFX_DATA(CUnmanageWizardSelect)
    enum { IDD = IDD_WIZ_UNMANAGE_SELECT };
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CUnmanageWizardSelect)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

    HRESULT           m_hrAvailable;

protected:
    // Generated message map functions
    //{{AFX_MSG(CUnmanageWizardSelect)
    virtual BOOL OnInitDialog();
	afx_msg void OnButtonRefresh();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    void SetButtons();

public:

};

/////////////////////////////////////////////////////////////////////////////
// CUnmanageWizardIntro dialog

class CUnmanageWizardIntro : public CSakWizardPage
{
// Construction
public:
    CUnmanageWizardIntro( );
    ~CUnmanageWizardIntro();

// Dialog Data
    //{{AFX_DATA(CUnmanageWizardIntro)
    enum { IDD = IDD_WIZ_UNMANAGE_INTRO };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CUnmanageWizardIntro)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    // Generated message map functions
    //{{AFX_MSG(CUnmanageWizardIntro)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CUnmanageWizardFinish dialog

class CUnmanageWizardFinish : public CSakWizardPage
{
// Construction
public:
    CUnmanageWizardFinish( );
    ~CUnmanageWizardFinish();

// Dialog Data
    //{{AFX_DATA(CUnmanageWizardFinish)
    enum { IDD = IDD_WIZ_UNMANAGE_FINISH };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CUnmanageWizardFinish)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    // Generated message map functions
    //{{AFX_MSG(CUnmanageWizardFinish)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};


class CUnmanageWizard : public CSakWizardSheet
{
// Construction
public:
    CUnmanageWizard();
    virtual ~CUnmanageWizard();

public:
    // Property Pages
    CUnmanageWizardIntro         m_IntroPage;
    CUnmanageWizardSelect        m_SelectPage;
    CUnmanageWizardFinish        m_FinishPage;

    CString                      m_DisplayName;

// Attributes
public:
    CComPtr<IHsmManagedResource> m_pHsmResource;
    CComPtr<IFsaResource>        m_pFsaResource;

// Operations
public:
    virtual HRESULT OnFinish( void );
    STDMETHOD( AddWizardPages ) ( IN RS_PCREATE_HANDLE Handle, IN IUnknown* pPropSheetCallback, IN ISakSnapAsk* pSakSnapAsk );
    void DoThreadSetup( );



};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\inc\proppage.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    PropPage.h

Abstract:

    Generic Property Page base class.

Author:

    Rohde Wakefield [rohde]   04-Aug-1997

Revision History:

--*/

#ifndef _PROPPAGE_H
#define _PROPPAGE_H

#pragma once

#define IDC_WIZ_TITLE                    32000
#define IDC_WIZ_SUBTITLE                 32001
#define IDC_WIZ_FINAL_TEXT               32006

#define IDS_WIZ_WINGDING_FONTSIZE        32100
#define IDS_WIZ_TITLE1_FONTNAME          32101
#define IDS_WIZ_TITLE1_FONTSIZE          32102

#ifndef RC_INVOKED

/////////////////////////////////////////////////////////////////////////////
// CRsDialog dialog

class CRsDialog : public CDialog
{
// Construction
public:
    CRsDialog( UINT nIDTemplate, CWnd* pParent = NULL);   // standard constructor
    ~CRsDialog();

// Dialog Data
    //{{AFX_DATA(CRsDialog)
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CRsDialog)
    protected:
    //}}AFX_VIRTUAL

protected:
    const DWORD * m_pHelpIds;
    // Generated message map functions
    //{{AFX_MSG(CRsDialog)
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CRsPropertyPage dialog

class CRsPropertyPage : public CPropertyPage
{
// Construction
public:
    CRsPropertyPage( UINT nIDTemplate, UINT nIDCaption = 0 );
    ~CRsPropertyPage();

// Dialog Data
    //{{AFX_DATA(CRsPropertyPage)
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CRsPropertyPage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
    LPFNPSPCALLBACK      m_pMfcCallback; // Original MFC callback from psp
    static UINT CALLBACK PropPageCallback( HWND hWnd, UINT uMessage, LPPROPSHEETPAGE  ppsp );
    virtual void OnPageCreate( ) { };
    virtual void OnPageRelease( ) { delete this; };

#define RSPROPPAGE_FONT_DECL(name) \
    static CFont m_##name##Font;   \
    CFont* Get##name##Font( void );\
    void   Init##name##Font( void );

    RSPROPPAGE_FONT_DECL( Shell )
    RSPROPPAGE_FONT_DECL( BoldShell )
    RSPROPPAGE_FONT_DECL( WingDing )
    RSPROPPAGE_FONT_DECL( LargeTitle )
    RSPROPPAGE_FONT_DECL( SmallTitle )

    LPCTSTR GetWingDingFontName( )  { return( _T("Marlett") ); };
    LPCTSTR GetWingDingCheckChar( ) { return( _T("b") ); };
    LPCTSTR GetWingDingExChar( )    { return( _T("r") ); };

protected:
    const DWORD * m_pHelpIds;
    // Generated message map functions
    //{{AFX_MSG(CRsPropertyPage)
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

//
// The following is to work around MFC not supporting Wiz97 pages.
// We create our own struct which is the correct Wiz97 struct and
// on creation do the "right thing" (copy over old PSP into new PSP
// and do the create). This is adapted from prsht.h in sdk\inc
//

typedef struct _PROPSHEETPAGEW97 {
        DWORD           dwSize;
        DWORD           dwFlags;
        HINSTANCE       hInstance;
        union {
            LPCWSTR          pszTemplate;
#ifdef _WIN32
            LPCDLGTEMPLATE  pResource;
#else
            const VOID FAR *pResource;
#endif
        }DUMMYUNIONNAME;
        union {
            HICON       hIcon;
            LPCWSTR      pszIcon;
        }DUMMYUNIONNAME2;
        LPCWSTR          pszTitle;
        DLGPROC         pfnDlgProc;
        LPARAM          lParam;
        LPFNPSPCALLBACKW pfnCallback;
        UINT FAR * pcRefParent;

//#if (_WIN32_IE >= 0x0400)
        LPCWSTR pszHeaderTitle;    // this is displayed in the header
        LPCWSTR pszHeaderSubTitle; ///
//#endif
} PROPSHEETPAGEW97, FAR *LPPROPSHEETPAGEW97;

#ifndef PSP_HIDEHEADER
#  define PSP_HIDEHEADER             0x00000800
#  define PSP_USEHEADERTITLE         0x00001000
#  define PSP_USEHEADERSUBTITLE      0x00002000
#endif

//
// Constructor wrapper macros to allow easy description of dialog resource and
// associated string resources
//

#define CRsWizardPage_InitBaseInt( DlgId )  CRsWizardPage( IDD_##DlgId, FALSE, IDS_##DlgId##_TITLE, IDS_##DlgId##_SUBTITLE )
#define CRsWizardPage_InitBaseExt( DlgId )  CRsWizardPage( IDD_##DlgId, TRUE )

class CRsWizardPage : public CRsPropertyPage  
{
public:
    CRsWizardPage( UINT nIDTemplate, BOOL bExterior = FALSE, UINT nIdTitle = 0, UINT nIdSubtitle = 0 );
    virtual ~CRsWizardPage();

// Dialog Data
    //{{AFX_DATA(CRsWizardPage)
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CRsWizardPage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

    PROPSHEETPAGEW97 m_psp97;

    BOOL    m_ExteriorPage;
    UINT    m_TitleId,
            m_SubtitleId;
    CString m_Title,
            m_SubTitle;

protected:

    // Generated message map functions
    //{{AFX_MSG(CRsWizardPage)
    virtual BOOL OnInitDialog();
    afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
        
public:
    void SetCaption( CString& strCaption );
    HPROPSHEETPAGE CreatePropertyPage( );

};




//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#endif // !RC_INVOKED


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsntfy\clientob.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    clientob.cpp

Abstract:

    This component is the client object the recall filter system contacts
    to notify when a recall starts.

Author:

    Rohde Wakefield   [rohde]   27-May-1997

Revision History:

--*/

#include "stdafx.h"
#include "fsantfy.h"

static BOOL VerifyPipeName(IN OLECHAR * szPipeName);


HRESULT
CNotifyClient::IdentifyWithServer(
    IN OLECHAR * szPipeName
    )

/*++

Implements:

  IFsaRecallNotifyClient::IdentifyWithServer

--*/
{
TRACEFNHR( "IdentifyWithServer" );

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    try {

        HANDLE handle = INVALID_HANDLE_VALUE;

        //
        // Parse the object and verify it looks like an HSM server named pipe
        // Note that we cannot assume anything on the string besides it being null-terminated
        //
        if (! VerifyPipeName(szPipeName)) {
            // Wrong name - possible attack - abort
            RecThrow(E_INVALIDARG);
        }

        //
        // Open the pipe and send a response
        //
        handle = CreateFileW( szPipeName, // Pipe name.
                GENERIC_WRITE,              // Generic access, read/write.
                FILE_SHARE_WRITE,
                NULL,                       // No security.
                OPEN_EXISTING,              // Fail if not existing.
                SECURITY_SQOS_PRESENT   | 
                SECURITY_IDENTIFICATION,    // No overlap, No pipe impersonation
                NULL );                     // No template.
        
        RecAffirmHandle( handle );

        //
        // Verify that what we just opened is a pipe
        //
        DWORD dwType = GetFileType(handle);
        if (dwType != FILE_TYPE_PIPE) {
            // Object is not a pipe - close and abort
            CloseHandle(handle);
            handle = INVALID_HANDLE_VALUE;
            RecThrow(E_INVALIDARG);
        }

        WSB_PIPE_MSG        pmsg;
        DWORD               len, bytesWritten;

        pmsg.msgType = WSB_PMSG_IDENTIFY;
        len = MAX_COMPUTERNAME_LENGTH + 1;
    
        GetComputerNameW( pmsg.msg.idrp.clientName, &len );
        BOOL code = WriteFile( handle, &pmsg, sizeof(WSB_PIPE_MSG),
               &bytesWritten, 0 );
        
        CloseHandle(handle);

    } RecCatch( hrRet );

    return(hrRet);
}


HRESULT
CNotifyClient::OnRecallStarted(
    IN IFsaRecallNotifyServer * pRecall
    )

/*++

Implements:

  IFsaRecallNotifyClient::OnRecallStarted

--*/
{
TRACEFNHR( "OnRecallStarted" );

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    hrRet = RecApp->AddRecall( pRecall );

    return( hrRet );
}


HRESULT
CNotifyClient::OnRecallFinished(
    IN IFsaRecallNotifyServer * pRecall,
    IN HRESULT                  hrError
    )

/*++

Implements:

  IFsaRecallNotifyClient::OnRecallFinished

--*/
{
TRACEFNHR( "CNotifyClient::OnRecallFinished" );

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    hrRet = RecApp->RemoveRecall( pRecall );

    return( hrRet );
}


HRESULT
CNotifyClient::FinalConstruct(
    void
    )

/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
TRACEFNHR( "CNotifyClient::FinalConstruct" );
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
        
    try {

        RecAffirmHr( CComObjectRoot::FinalConstruct( ) );

    } RecCatch( hrRet );

    return( hrRet );
}
    

void
CNotifyClient::FinalRelease(
    void
    )

/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
TRACEFN( "CNotifyClient::FinalRelease" );
        
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
    CComObjectRoot::FinalRelease( );
}
    
//
// Verifies that pipe name matches the expected RSS named pipe
//   \\<machine-name>\pipe\HSM_PIPE
//
// Returns TRUE for a valid pipe name and FALSE otherwise
//
static BOOL VerifyPipeName(IN OLECHAR * szPipeName)
{
    if (wcslen(szPipeName) < 3)
        return FALSE;
    if ((szPipeName[0] != L'\\') || (szPipeName[1] != L'\\'))
        return FALSE;

    OLECHAR *pTemp1 = NULL;
    OLECHAR *pTemp2 = NULL;

    pTemp1 = wcschr(&(szPipeName[2]), L'/');
    if (pTemp1 != NULL)
        return FALSE;

    pTemp1 = wcschr(&(szPipeName[2]), L'\\');
    if (pTemp1 == NULL)
        return FALSE;
    pTemp1++;

    pTemp2 = wcschr(pTemp1, L'\\');
    if (pTemp2 == NULL)
        return FALSE;
    *pTemp2 = L'\0';

    if (0 != _wcsicmp(pTemp1, L"pipe")) {
        *pTemp2 = L'\\';
        return FALSE;
    }
    *pTemp2 = L'\\';

    pTemp2++;
    if (0 != _wcsicmp(pTemp2, WSB_PIPE_NAME))
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\inc\rsutil.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsUtil.h

Abstract:

    Utility formatting functions.

Author:

    Art Bragg 10/8/97

Revision History:

--*/

#define IDS_BYTES       33000
#define IDS_ORDERKB     33001
#define IDS_ORDERMB     33002
#define IDS_ORDERGB     33003
#define IDS_ORDERTB     33004
#define IDS_ORDERPB     33005
#define IDS_ORDEREB     33006

#ifndef RC_INVOKED

HRESULT RsGuiFormatLongLong(
    IN LONGLONG number, 
    IN BOOL bIncludeUnits,
    OUT CString& sFormattedNumber
    );

HRESULT RsGuiFormatLongLong4Char(
    IN LONGLONG number,                 // in bytes
    OUT CString& sFormattedNumber
    );

void RsGuiMakeVolumeName(
    CString szName,
    CString szLabel,
    CString& szDisplayName
    );

CString RsGuiMakeShortString(
    IN CDC* pDC, 
    IN const CString& StrLong,
    IN int Width
    );


/////////////////////////////////////////////////////////////////////////////
// CRsGuiOneLiner window

class CRsGuiOneLiner : public CStatic
{
// Construction
public:
	CRsGuiOneLiner();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRsGuiOneLiner)
	protected:
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CRsGuiOneLiner();
    CToolTipCtrl* m_pToolTip;
    void EnableToolTip( BOOL enable, const TCHAR* pTipText = 0 );


	// Generated message map functions
protected:
	//{{AFX_MSG(CRsGuiOneLiner)
	//}}AFX_MSG
    LRESULT OnSetText( WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()

    CString m_LongTitle;
    CString m_Title;
};

/////////////////////////////////////////////////////////////////////////////

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsntfy\clientob.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    clientob.h

Abstract:

    This component is the client object the recall filter system contacts
    to notify when a recall starts.

Author:

    Rohde Wakefield   [rohde]   27-May-1997

Revision History:

--*/

#include "fsaint.h"
#include "fsalib.h"

#ifndef _CLIENTOBJ_
#define _CLIENTOBJ_

/*++

Class Name:
    
    CWsbShort

Class Description:

    An object representations of the SHORT standard type. It
    is both persistable and collectable.

--*/

class CNotifyClient : 
    public IFsaRecallNotifyClient,
    public CComCoClass<CNotifyClient,&CLSID_CFsaRecallNotifyClient >,
    public CComObjectRoot
{
public:
    CNotifyClient() {}
BEGIN_COM_MAP( CNotifyClient )
    COM_INTERFACE_ENTRY( IFsaRecallNotifyClient )
END_COM_MAP()

#ifdef _USRDLL
DECLARE_REGISTRY_RESOURCEID( IDR_CNotifyClientDll )
#else
DECLARE_REGISTRY_RESOURCEID( IDR_CNotifyClient )
#endif

// CComObjectRoot
public:
    HRESULT FinalConstruct(void);
    void FinalRelease(void);


// IFsaRecallNotifyClient
public:
    STDMETHOD(IdentifyWithServer)( IN OLECHAR * szServerName );
    STDMETHOD(OnRecallStarted)   ( IN IFsaRecallNotifyServer * pRecall );
    STDMETHOD(OnRecallFinished)  ( IN IFsaRecallNotifyServer * pRecall, HRESULT hr );

protected:

};

#endif // _CLIENTOBJ_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsntfy\note.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Note.h

Abstract:

    This class represents the notify dialog that is shown to the user.

Author:

    Rohde Wakefield   [rohde]   27-May-1997

Revision History:

--*/

#ifndef _NOTE_H_
#define _NOTE_H_

#pragma once

/////////////////////////////////////////////////////////////////////////////
// CRecallNote dialog

class CRecallNote : public CDialog
{
// Construction
public:
    CRecallNote( IFsaRecallNotifyServer * pRecall, CWnd * pParent = NULL );

// Dialog Data
    //{{AFX_DATA(CRecallNote)
    enum { IDD = IDD_RECALL_NOTE };
    CStatic m_Progress;
    CEdit   m_FileName;
    CAnimateCtrl    m_Animation;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRecallNote)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual void PostNcDestroy();
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CRecallNote();
    CComPtr<IFsaRecallNotifyServer> m_pRecall;
    GUID                            m_RecallId;
    HRESULT                         m_hrCreate;
    BOOL                            m_bCancelled;

private:
    CString                   m_Name;
    LONGLONG                  m_Size;

    HICON                     m_hIcon;

protected:

    // Generated message map functions
    //{{AFX_MSG(CRecallNote)
    virtual BOOL OnInitDialog();
    afx_msg void OnClose();
    afx_msg void OnTimer(UINT nIDEvent);
    virtual void OnCancel();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsntfy\note.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    Note.cpp

Abstract:

    Main module file - defines the overall COM server.

Author:

    Rohde Wakefield [rohde]   04-Mar-1997

Revision History:

--*/



#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
// CRecallNote dialog


CRecallNote::CRecallNote( IFsaRecallNotifyServer * pRecall, CWnd * pParent )
    : CDialog( CRecallNote::IDD, pParent )
{
    //{{AFX_DATA_INIT(CRecallNote)
    //}}AFX_DATA_INIT

TRACEFNHR( "CRecallNote::CRecallNote" );

    RecApp->LockApp( );

    try {

        //
        // Store the interface pointer back to the recall object
        //
        m_pRecall = pRecall;
        RecAffirmHr( pRecall->GetIdentifier( &m_RecallId ) );

        //
        // Get the file size and its name
        //

        RecAffirmHr( pRecall->GetSize( &m_Size ) );

        RecComString pathName, drive;
        RecAffirmHr( pRecall->GetPath( &pathName, 0 ) );

#if 0
        CComPtr<IFsaResource> pResource;
        RecAffirmHr( pRecall->GetResource( &pResource ) );
        RecAffirmHr( pResource->GetPath( &drive, 0 ) );

        m_Name.Format( TEXT( "%.1ls:%ls" ), drive, pathName );
#else
        m_Name = pathName;
#endif

        //
        // Create the dialog
        //

        Create( CRecallNote::IDD, pParent );

    } RecCatch( hrRet );

    m_hrCreate = hrRet;
    m_bCancelled = FALSE;
}

CRecallNote::~CRecallNote( )
{
TRACEFN( "CRecallNote::~CRecallNote" );
    //
    // Remove the lock count on the app
    //

    RecApp->UnlockApp( );

    CDialog::~CDialog( );
}

void CRecallNote::DoDataExchange(CDataExchange* pDX)
{
TRACEFN( "CRecallNote::DoDataExchange" );

    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRecallNote)
    DDX_Control(pDX, IDC_FILENAME, m_FileName);
    DDX_Control(pDX, IDC_ANIMATION, m_Animation);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRecallNote, CDialog)
    //{{AFX_MSG_MAP(CRecallNote)
    ON_WM_CLOSE()
    ON_WM_TIMER()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRecallNote message handlers

BOOL CRecallNote::OnInitDialog() 
{
TRACEFNBOOL( "CRecallNote::OnInitDialog" );
    CDialog::OnInitDialog();

    boolRet = TRUE;
    CString fileName;

    //  Set a timer to delay displaying myself in case the
    //  recall is quick and the dialog is unnecessary
    SetTimer( 2, RSRECALL_TIME_DELAY_DISPLAY * 1000, 0 );

    //
    // Initialize all the text
    //

    int pos = m_Name.ReverseFind( TEXT( '\\' ) );
    if( pos >= 0 ) {

        fileName = m_Name.Mid( pos + 1 );

    } else {

        fileName = m_Name;

    }
    m_FileName.SetWindowText( fileName );

    //
    // Set up the icon for the dialog (big and small)
    //

    m_hIcon = RecApp->LoadIcon( IDR_MAINFRAME );
    SetIcon( m_hIcon, TRUE );
    SetIcon( m_hIcon, FALSE );

    //
    // Start up the animation
    //

    m_Animation.Open( IDR_RECALL_ANIM );
    m_Animation.Play( 0, -1, -1 );

    return( boolRet );
}

void CRecallNote::OnClose() 
{
TRACEFNHR( "CRecallNote::OnClose" );

    hrRet = RecApp->RemoveRecall( m_pRecall );

    //
    // If we failed to find and remove the recall from our list,
    // destroy the window anyway.
    //

    if( hrRet != S_OK ) {

        DestroyWindow( );

    }
}

void CRecallNote::PostNcDestroy() 
{
TRACEFNHR( "CRecallNote::PostNcDestroy" );
    //
    // Delete the object (CDialogs don't automatically do this)
    //

    CDialog::PostNcDestroy();

    delete( this );
}

void CRecallNote::OnTimer(UINT nIDEvent) 
{
TRACEFNHR( "CRecallNote::OnTimer" );

    //  Kill the timer so we don't get called again
    KillTimer( nIDEvent );

    //  Display the window
    EnableWindow( );
    ShowWindow( SW_SHOW );
    SetForegroundWindow( );

    CDialog::OnTimer( nIDEvent );
}

void CRecallNote::OnCancel() 
{
TRACEFNHR( "CRecallNote::OnCancel" );

    // Use a local pointer because m_pRecall may not be valid after the call to RemoveRecall
    CComPtr<IFsaRecallNotifyServer> pRecall = m_pRecall;

    // Remove recall from queue.
    // This ensure that the popup is closed and the recall is removed even if there are 
    // connection problems with FSA
    RecApp->RemoveRecall( pRecall );

    // The object might be already destroyed here but it shouldn't matter 
    // because we use only local data
    pRecall->Cancel( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsntfy\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rsrecall.rc
//
#define IDS_CANCEL_ERROR                1
#define IDS_CANCEL_ERROR2               2
#define IDR_MAINFRAME                   128
#define IDR_CNotifyClient               133
#define IDR_CNotifyClientDll            134
#define IDR_CNotifyClientApp            135
#define IDR_CNotifyClientAppDll         136
#define IDR_RECALL_ANIM                 137
#define IDD_RECALL_NOTE                 4352
#define IDC_ANIMATION                   4353
#define IDC_FILENAME                    4354

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        139
#define _APS_NEXT_COMMAND_VALUE         32778
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsntfy\sources.inc ===
!IF 0

Copyright (c) 1989 Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETPATH=$(BASEP_HSM_DIR)\bin\$(_OBJ_DIR)
NTTARGETFILE0=

INCLUDES=$(BASEP_HSM_DIR)\inc;$(BASEP_HSM_DIR)\inc\$(O);..\..\inc

UMTYPE=windows
UMENTRY=winmain

#
# Fusionized
# 
SXS_ASSEMBLY_NAME=Microsoft.Windows.RsNotify
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=rsnotify.Manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1


TARGETLIBS= \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\ntdll.lib    \
    $(SDK_LIB_PATH)\ole32.lib    \
    $(SDK_LIB_PATH)\oleaut32.lib \
    $(SDK_LIB_PATH)\user32.lib   \
    $(SDK_LIB_PATH)\uuid.lib     \
    $(SDK_LIB_PATH)\comctl32.lib \
    $(BASEP_HSM_DIR)\lib\$(O)\FsaGuid.lib \

USE_NATIVE_EH=1
USE_MFCUNICODE=1
MFC_VER=42
USE_ATL=1

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_SOURCEFILE=..\stdafx.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsntfy\rsrecall.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    rsrecall.h

Abstract:

    This class represents the recall application.

Author:

    Rohde Wakefield   [rohde]   27-May-1997

Revision History:

--*/

#ifndef _RSRECALL_H_
#define _RSRECALL_H_

#pragma once

//  Times are in seconds
#define RSRECALL_TIME_DELAY_DISPLAY   3   // Delay showing dialog
#define RSRECALL_TIME_FOR_STARTUP     5   // Time to allow for app. startup
#define RSRECALL_TIME_MAX_IDLE        3   // Idle time before shutting down app.

// Max concurrent recall popups
#define RSNTFY_REGISTRY_STRING                  (_T("Software\\Microsoft\\RemoteStorage\\RsNotify"))
#define MAX_CONCURRENT_RECALL_NOTES             (_T("ConcurrentRecallNotes"))  
#define MAX_CONCURRENT_RECALL_NOTES_DEFAULT     5   

/////////////////////////////////////////////////////////////////////////////
// CRecallWnd window

class CRecallWnd : public CFrameWnd
{
// Construction
public:
    CRecallWnd();

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRecallWnd)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CRecallWnd();

    // Generated message map functions
protected:
    //{{AFX_MSG(CRecallWnd)
    afx_msg void OnTimer(UINT nIDEvent);
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CRecallApp:
// See rsrecall.cpp for the implementation of this class
//

class CRecallNote;

class CRecallApp : public CWinApp
{
public:
    CRecallApp();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRecallApp)
    public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
    //}}AFX_VIRTUAL

// Implementation
//  CRecallWnd m_Wnd;  // Hidden window needed for MFC to hang around
    UINT       m_IdleCount;  // Number of seconds we've been idle

    //{{AFX_MSG(CRecallApp)
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    CList<CRecallNote*, CRecallNote*> m_Recalls;

    DWORD   m_dwMaxConcurrentNotes;

    HRESULT AddRecall( IFsaRecallNotifyServer* );
    HRESULT RemoveRecall( IFsaRecallNotifyServer* );

    void    LockApp( );
    void    UnlockApp( );

    void    Tick(void);
};

#define RecApp ((CRecallApp*)AfxGetApp())

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsntfy\stdafx.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    StdAfx.cpp

Abstract:

    Takes care of implementation (.cpp) includes (atlimpl.cpp, statreg.cpp)

Author:

    Rohde Wakefield   [rohde]   20-Feb-1998

Revision History:

--*/

#include "stdafx.h"

#define WsbAffirmStatus RecAffirmStatus
#define WsbCatch        RecCatch
#define WsbThrow        RecThrow

#pragma warning(4:4701)
#include <atlimpl.cpp>
#include <statreg.cpp>
#pragma warning(3:4701)

#include "rsutil.cpp"

CComModule _Module;
RSTRACE_INIT( "RsNotify" )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsntfy\dll\makefile.inc ===
$(O)\RsRecall.res: \
    ..\RsRecall.rc2      \
    ..\RsRecall.ico      \
    ..\recall1.avi       \
    ..\ClientOb.rgs      \
    ..\ClntDll.rgs       \
    ..\RsRecall.rgs      \
    ..\RsRecDll.rgs      \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsntfy\stdafx.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    StdAfx.cpp

Abstract:

    Precompiled header root.

Author:

    Rohde Wakefield   [rohde]   20-Feb-1998

Revision History:

--*/

#ifndef RECALL_STDAFX_H
#define RECALL_STDAFX_H

#pragma once

//#define VC_EXTRALEAN      // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>
#include <afxext.h>
#include <afxcmn.h>
#include <afxtempl.h>

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <statreg.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#include "RsTrace.h"
#include "resource.h"
#include "rsutil.h"
#include "fsaint.h"
#include "RsRecall.h"
#include "clientob.h"
#include "note.h"

// Don't do module state tracking if just an exe
#ifndef _USRDLL
#undef AFX_MANAGE_STATE
#define AFX_MANAGE_STATE(a)
#endif

#define RecDebugOut CRsFuncTrace::Trace

#define RecAssert(cond, hr)             if (!(cond)) RecThrow(hr)
#define RecThrow(hr)                    throw( CRecThrowContext( __FILE__, __LINE__, hr ) );

#define RecAffirm(cond, hr)             if (!(cond)) RecThrow(hr)
#define RecAffirmHr(hr)                 \
    {                                   \
        HRESULT     lHr;                \
        lHr = (hr);                     \
        RecAffirm(SUCCEEDED(lHr), lHr); \
    }

#define RecAffirmHrOk(hr)               \
    {                                   \
        HRESULT     lHr;                \
        lHr = (hr);                     \
        RecAffirm(S_OK == lHr, lHr);    \
    }

#define RecAssertHr(hr)                 \
    {                                   \
        HRESULT     lHr;                \
        lHr = (hr);                     \
        RecAssert(SUCCEEDED(lHr), lHr); \
    }

#define RecAssertStatus(status)         \
    {                                   \
        BOOL bStatus;                   \
        bStatus = (status);             \
        if (!bStatus) {                 \
            DWORD dwErr = GetLastError();               \
            HRESULT lHr = HRESULT_FROM_WIN32(dwErr);    \
            RecAssert(SUCCEEDED(lHr), lHr);             \
        }                               \
    }

#define RecAssertHandle(hndl)           \
    {                                   \
        HANDLE hHndl;                   \
        hHndl = (hndl);                 \
        if (hHndl == INVALID_HANDLE_VALUE) {            \
            DWORD dwErr = GetLastError();               \
            HRESULT lHr = HRESULT_FROM_WIN32(dwErr);    \
            RecAssert(SUCCEEDED(lHr), lHr);             \
        }                               \
    }

#define RecAssertPointer( ptr )         \
    {                                   \
        RecAssert( ptr != 0, E_POINTER);\
    }

#define RecAffirmStatus(status)         \
    {                                   \
        BOOL bStatus;                   \
        bStatus = (status);             \
        if (!bStatus) {                 \
            DWORD dwErr = GetLastError();               \
            HRESULT lHr = HRESULT_FROM_WIN32(dwErr);    \
            RecAffirm(SUCCEEDED(lHr), lHr);             \
        }                               \
    }

#define RecAffirmHandle(hndl)           \
    {                                   \
        HANDLE hHndl;                   \
        hHndl = (hndl);                 \
        if (hHndl == INVALID_HANDLE_VALUE) {          \
            DWORD dwErr = GetLastError();             \
            HRESULT lHr = HRESULT_FROM_WIN32(dwErr);  \
            RecAffirm(SUCCEEDED(lHr), lHr);           \
        }                               \
    }

#define RecAffirmPointer( ptr )         \
    {                                   \
        RecAffirm( ptr != 0, E_POINTER);\
    }

#define RecCatchAndDo(hr, code)         \
    catch(CRecThrowContext context) {   \
        hr = context.m_Hr;              \
        TRACE( _T("Throw <0x%p> on line [%ld] of %hs"), context.m_Hr, (long)context.m_Line, context.m_File); \
        { code }                        \
    }

// Turn on In-Your-Trace error messages for debugging.

class CRecThrowContext {
public:
    CRecThrowContext( char * File, long Line, HRESULT Hr ) :
        m_File(File), m_Line(Line), m_Hr(Hr) { }
    char *  m_File;
    long    m_Line;
    HRESULT m_Hr;
};

#define RecCatch(hr)                    \
    catch(CRecThrowContext context) {   \
        hr = context.m_Hr;              \
        TRACE( _T("Throw <0x%p> on line [%ld] of %hs"), context.m_Hr, (long)context.m_Line, context.m_File); \
    }


class RecComString {
public:
    RecComString( ) : m_sz( 0 ) { }
    RecComString( const OLECHAR * sz ) { m_sz = (OLECHAR*)CoTaskMemAlloc( ( wcslen( sz ) + 1 ) * sizeof( OLECHAR ) ); }
    ~RecComString( ) { Free( ); }

    void Free( ) { if( m_sz ) CoTaskMemFree( m_sz ); }

    operator OLECHAR * () { return( m_sz ); }
    OLECHAR** operator &() { return( &m_sz ); }

private:
    OLECHAR * m_sz;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsntfy\exe\makefile.inc ===
$(O)\RsRecall.res: \
    ..\RsRecall.rc2      \
    ..\RsRecall.ico      \
    ..\recall1.avi       \
    ..\ClientOb.rgs      \
    ..\ClntDll.rgs       \
    ..\RsRecall.rgs      \
    ..\RsRecDll.rgs      \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsntfy\rsrecall.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RsRecall.cpp

Abstract:

    Main module file - defines the overall COM server.

Author:

    Rohde Wakefield [rohde]   04-Mar-1997

Revision History:

--*/


#include "stdafx.h"

#include "aclapi.h"


BEGIN_OBJECT_MAP( ObjectMap )
    OBJECT_ENTRY( CLSID_CFsaRecallNotifyClient, CNotifyClient )
END_OBJECT_MAP()

const CString regString   = TEXT( "reg" );
const CString unregString = TEXT( "unreg" );
HRESULT RegisterServer(void);
HRESULT UnregisterServer(void);


#ifdef _USRDLL

/////////////////////////////////////////////////////////////////////////////
// Setup to use if we are a DLL /////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#define RecRegId IDR_CNotifyClientAppDll

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
TRACEFNHR( "DllCanUnloadNow" );

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
    hrRet = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
    return( hrRet );
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
TRACEFNHR( "DllGetClassObject" );

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
    hrRet = _Module.GetClassObject(rclsid, riid, ppv);
    return( hrRet );
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
TRACEFNHR( "DllRegisterServer" );

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // registers object, typelib and all interfaces in typelib
    hrRet = RegisterServer( );
    return( hrRet );
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
TRACEFNHR( "DllUnregisterServer" );

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    hrRet = UnregisterServer( );
    return( hrRet );
}



#else

/////////////////////////////////////////////////////////////////////////////
// Setup to use if we are a standalone app //////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#define RecRegId IDR_CNotifyClientApp

class CRecallParse : public CCommandLineInfo {

    virtual void ParseParam( LPCTSTR lpszParam, BOOL bFlag, BOOL bLast );

public:
    BOOL m_RegAction;
    CRecallParse( ) { m_RegAction = FALSE; };

};

void CRecallParse::ParseParam( LPCTSTR lpszParam, BOOL bFlag, BOOL bLast )
{
TRACEFN( "CRecallParse::ParseParam" );

    CString cmdLine = lpszParam;
    if( bFlag ) {

        if( cmdLine.Left( unregString.GetLength( ) ) == unregString ) {

            UnregisterServer( );
            m_RegAction = TRUE;


        } else if( cmdLine.Left( regString.GetLength( ) ) == regString ) {

            RegisterServer( );
            m_RegAction = TRUE;

        }
    }
}

#endif

/////////////////////////////////////////////////////////////////////////////
// RegisterServer - Adds entries to the system registry

HRESULT RegisterServer(void)
{
TRACEFNHR( "RegisterServer" );

    try {

        //
        // Add the object entries
        //

        RecAffirmHr( _Module.RegisterServer( FALSE ) );

        //
        // Add server entries
        //

        RecAffirmHr( _Module.UpdateRegistryFromResource( RecRegId, TRUE ) );

        //
        // Set up access to be allowed by everyone (NULL DACL)
        // Appears we need some owner and group, so use the current one.
        //
        CSecurityDescriptor secDesc;
        PSECURITY_DESCRIPTOR pSDSelfRelative = 0;

        RecAffirmHr( secDesc.InitializeFromProcessToken( ) );

        DWORD secDescSize = 0;
        MakeSelfRelativeSD( secDesc, pSDSelfRelative, &secDescSize );
        pSDSelfRelative = (PSECURITY_DESCRIPTOR) new char[secDescSize];
        if( MakeSelfRelativeSD( secDesc, pSDSelfRelative, &secDescSize ) ) {

            CString keyName = TEXT( "AppID\\{D68BD5B2-D6AA-11d0-9EDA-00A02488FCDE}" );
            CRegKey regKey;
            regKey.Open( HKEY_CLASSES_ROOT, keyName, KEY_SET_VALUE );
            RegSetValueEx( regKey.m_hKey, TEXT( "LaunchPermission" ), 0, REG_BINARY, (LPBYTE)pSDSelfRelative, secDescSize );

        }

    } RecCatch( hrRet );

    return( hrRet );
}

/////////////////////////////////////////////////////////////////////////////
// UnregisterServer - Removes entries from the system registry

HRESULT UnregisterServer(void)
{
TRACEFNHR( "UnregisterServer" );
    try {

        RecAffirmHr( _Module.UnregisterServer() );

        //
        // Remove server entries
        //

        RecAffirmHr( _Module.UpdateRegistryFromResource( RecRegId, FALSE ) );

    } RecCatch( hrRet );

    return( hrRet );
}

/////////////////////////////////////////////////////////////////////////////
// CRecallApp

BEGIN_MESSAGE_MAP(CRecallApp, CWinApp)
    //{{AFX_MSG_MAP(CRecallApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRecallApp construction

CRecallApp::CRecallApp()
{
TRACEFN( "CRecallApp::CRecallApp" );

    m_IdleCount = 0;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CRecallApp object

CRecallApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CRecallApp initialization

BOOL CRecallApp::InitInstance()
{
TRACEFNHR( "CRecallApp::InitInstance" );

LPTSTR cmdLine = GetCommandLine( );
TRACE( cmdLine );

    try {

        _Module.Init( ObjectMap, m_hInstance );

        m_dwMaxConcurrentNotes = MAX_CONCURRENT_RECALL_NOTES_DEFAULT;
        
        InitCommonControls();

#ifndef _USRDLL
        //
        // Initialize the COM module (no point to continue if it fails)
        //

        hrRet = CoInitialize( 0 );
        if (!SUCCEEDED(hrRet)) {

            return FALSE;

        }

        //
        // Parse the command line
        //

        CRecallParse parse;
        ParseCommandLine( parse );

        if( parse.m_RegAction ) {

            return FALSE;

        }

        //
        // This provides a NULL DACL which will allow access to everyone.
        //

        RecAffirmHr( CoInitializeSecurity( 0, -1, 0, 0, RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IDENTIFY, 0, EOAC_NONE, 0 ) );

        //
        // Register the Fsa callback object
        //

        RecAffirmHr( _Module.RegisterClassObjects( CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER, REGCLS_MULTIPLEUSE ) );

#endif

//      m_Wnd.Create( 0, TEXT( "Remote Storage Recall Notification Wnd" ) );
//      m_pMainWnd = &m_Wnd;

        CRecallWnd *pWnd = new CRecallWnd; // will auto delete
        RecAffirmPointer( pWnd );

        pWnd->Create( 0, TEXT( "Remote Storage Recall Notification Wnd" ) );
        m_pMainWnd = pWnd;

        // Check to see if there is any custom setting in the Registry for max recall popups 
        // (ignore errors - just use default)
        HKEY hRegKey;
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, RSNTFY_REGISTRY_STRING, 0, KEY_QUERY_VALUE, &hRegKey) == ERROR_SUCCESS) {
            DWORD dwType, dwValue;
            DWORD cbData = sizeof(DWORD);
            if (RegQueryValueEx(hRegKey, MAX_CONCURRENT_RECALL_NOTES, 0, &dwType, (BYTE*)&dwValue, &cbData) == ERROR_SUCCESS) {
                if (REG_DWORD == dwType) {
                    // custom setting
                    m_dwMaxConcurrentNotes = dwValue;
                }
            }

            RegCloseKey(hRegKey);
        }

    } RecCatch( hrRet );

    return TRUE;
}

int CRecallApp::ExitInstance()
{
TRACEFN("CRecallApp::ExitInstance");

    _Module.Term();

#ifndef _USRDLL

    CoUninitialize();

#endif

    return CWinApp::ExitInstance();
}

void CRecallApp::LockApp( )
{
TRACEFNLONG( "CRecallApp::LockApp" );

    lRet = _Module.Lock( );
}

void CRecallApp::UnlockApp( )
{
TRACEFNLONG( "CRecallApp::UnlockApp" );

    lRet = _Module.Unlock( );

    // Don't call AfxPostQuitMessage when ref. count drops to zero
    // The timer mechanism is responsible for terminating this application.
    // Also, when the ref count drops to zero, COM terminates the process after some time.
}


HRESULT CRecallApp::AddRecall( IFsaRecallNotifyServer* pRecall )
{
TRACEFNHR( "CRecallApp::AddRecall" );

    CRecallNote * pNote = 0;

    try {

        //
        // Create a new note to show - only if we didn't pass the max number for concurrent notes
        // Note: We return S_OK and not S_FALSE even if the recall popup is not displayed in order
        //       not to break the server (S_FALSE will cause unnecessary retries)
        //
        if (m_Recalls.GetCount() < (int)m_dwMaxConcurrentNotes) {

            pNote = new CRecallNote( pRecall, CWnd::GetDesktopWindow( ) );

            RecAffirmHr( pNote->m_hrCreate );

            m_Recalls.AddTail( pNote );

        } else {
            TRACE( _T("Recall not added - reached max number of recalls"));
        }

    } RecCatchAndDo( hrRet,

        if( 0 != pNote ) delete pNote;

    );

    return( hrRet );
}

//
// Note: 
// No CS is used here because the RsNotify is initialized as a single threaded application
//
HRESULT CRecallApp::RemoveRecall( IFsaRecallNotifyServer* pRecall )
{
TRACEFNHR( "CRecallApp::RemoveRecall" );

    hrRet = S_FALSE;

    if( ( m_Recalls.IsEmpty() ) ) {

        return( hrRet );

    }

    CRecallNote* pNote = 0; 
    POSITION     pos = m_Recalls.GetHeadPosition( );
    POSITION     currentPos = 0;

    //
    // Look through the list and find this one
    //
    GUID recallId;
    pRecall->GetIdentifier( &recallId );
    while( pos != 0 ) {
        currentPos = pos;
        pNote = m_Recalls.GetNext( pos );

        if( IsEqualGUID( recallId, pNote->m_RecallId ) ) {
            if (pNote->m_bCancelled)  {
                //
                // This means that somebody is already removing this recall 
                // The Remove may be called up to 3 times for the same recall in case
                // of a recall cancellation
                //
                hrRet = S_OK;
                pos = 0; // exit loop

            } else {
                pNote->m_bCancelled = TRUE;
                //
                // Remove and delete. Return OK.
                //
                m_Recalls.RemoveAt( currentPos );

                pNote->DestroyWindow( );
                pos = 0; // exit loop
                hrRet = S_OK;
            }
        }
    }

    return( hrRet );
}

//  CRecallApp::Tick - called every second (after an initial delay
//    for startup) to keep track of idle time
void CRecallApp::Tick( )
{
TRACEFN( "CRecallApp::Tick");

    // Check for pending recalls
    if( m_Recalls.GetCount( ) ) {

        //  We have pending recalls, reset the idle count
        TRACE( _T("m_Recalls.GetCount != 0") );
        m_IdleCount = 0;

    } else {

        //  We don't have pending recalls, increment the idle count
        TRACE( _T("m_Recalls.GetCount == 0") );
        m_IdleCount++;

        if( m_IdleCount > RSRECALL_TIME_MAX_IDLE ) {

            TRACE( _T("m_IdleCount > 0") );
            // Nothing's happin', say "Goodbye"
            m_pMainWnd->PostMessage( WM_CLOSE );
            TRACE( _T("after PostMessage(WM_CLOSE)") );
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// CRecallWnd

CRecallWnd::CRecallWnd()
{
TRACEFN( "CRecallWnd::CRecallWnd" );
}

CRecallWnd::~CRecallWnd()
{
TRACEFN( "CRecallWnd::~CRecallWnd" );
}


BEGIN_MESSAGE_MAP(CRecallWnd, CWnd)
    //{{AFX_MSG_MAP(CRecallWnd)
    ON_WM_TIMER()
    ON_WM_CREATE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CRecallWnd message handlers

void CRecallWnd::OnTimer(UINT nIDEvent)
{
TRACEFN("CRecallWnd::OnTimer");

    if (1 == nIDEvent) {

        // Initial timer. Kill it and start one for every second
        TRACE( _T("nIDEvent == 1") );
        KillTimer( nIDEvent );
        SetTimer( 2, 1000, NULL );

    } else {

        // One second timer. Notify the app object
        RecApp->Tick();

    }
    CWnd::OnTimer( nIDEvent );
}

int CRecallWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
TRACEFN("CRecallWnd::OnCreate" );

    if (CWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    // Set the initial timer to allow time for startup
    if (!SetTimer(1, RSRECALL_TIME_FOR_STARTUP * 1000, NULL))
        return -1;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsoptcom\ladate.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    LaDate.h

Abstract:

    Definition of CLaDate, a class representing the enabled or
    disabled state of last access date updating of NTFS files.
    See the implementation file for more details.

Author:

    Carl Hagerstrom [carlh]   01-Sep-1998

--*/

#ifndef _LADATE_H
#define _LADATE_H

class CLaDate
{
private:

    WCHAR* m_regPath;
    WCHAR* m_regEntry;
    HKEY   m_regKey;

public:

    enum LAD_STATE  {

        LAD_ENABLED,  // registry value is not one
        LAD_DISABLED, // registry value is one
        LAD_UNSET     // registry value does not exist
    };

    CLaDate( );
    ~CLaDate( );

    HRESULT
    UnsetLadState( );

    HRESULT
    SetLadState( 
        IN LAD_STATE
        );

    HRESULT
    GetLadState( 
        OUT LAD_STATE*
        );
};

#endif // _LADATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsoptcom\opcommon.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    OpCommon.cpp

Abstract:

    Nada.

Author:

    Rohde Wakefield [rohde]   09-Oct-1997

Revision History:

--*/

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsoptcom\ladate.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    LaDate.cpp

Abstract:

    Implementation of CLaDate, a class representing the enabled or
    disabled state of last access date updating of NTFS files. Last
    access date updating on NTFS files can be disabled through the
    registry for performance reasons. This class implements updating
    and reporting of the state of the registry value that contols last
    access date. The following states are used to represent the registry
    value:

        LAD_DISABLED: last access date is disabled, registry value is 1
        LAD_ENABLED: last access date is enabled, registry value is not 1
        LAD_UNSET: last access date is enabled, no registry value

Author:

    Carl Hagerstrom [carlh]   01-Sep-1998

--*/

#include <StdAfx.h>
#include <LaDate.h>

/*++

    Implements: 

        CLaDate Constructor

    Routine Description: 

        Initialize object state and open registry key. If the registry key cannot
        be opened, we will assume that the last access state is LAD_UNSET.

--*/

CLaDate::CLaDate( )
{
TRACEFN( "CLaDate::CLaDate" );

    HKEY regKey = 0;

    m_regPath  = L"System\\CurrentControlSet\\Control\\FileSystem";
    m_regEntry = L"NtfsDisableLastAccessUpdate";
    m_regKey   = (HKEY)0;

    if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                       m_regPath,
                                       (DWORD)0,
                                       KEY_ALL_ACCESS,
                                       &regKey ) ) {

        m_regKey = regKey;
    }
}

/*++

    Implements: 

        CLaDate Destructor

    Routine Description: 

        Close registry key.

--*/

CLaDate::~CLaDate( )
{
TRACEFN( "CLaDate::~CLaDate" );

    if ( m_regKey ) {

        RegCloseKey( m_regKey );
    }
}

/*++

    Implements: 

        CLaDate::UnsetLadState

    Routine Description: 

        Removes the registry value.

    Arguments: 

        None

    Return Value:

        S_OK - Success
        E_*  - Any unexpected exceptions from lower level routines

--*/

HRESULT
CLaDate::UnsetLadState( )
{
TRACEFNHR( "CLaDate::UnsetLadState" );

    try {
        if( m_regKey ) {

            RsOptAffirmWin32( RegDeleteValue( m_regKey, m_regEntry ) );
        }
    } RsOptCatch( hrRet );

    return( hrRet );
}

/*++

    Implements: 

        CLaDate::SetLadState

    Routine Description: 

        Sets the registry value according to the input parameter.

    Arguments: 

        ladState - LAD_ENABLED or LAD_DISABLED

    Return Value:

        S_OK - Success
        E_NOTIMPL - Operation not supported
        E_*  - Any unexpected exceptions from lower level routines

--*/

HRESULT
CLaDate::SetLadState( 
    IN LAD_STATE ladState
    )
{
TRACEFNHR( "CLaDate::SetLadState" );

    DWORD newVal = (DWORD)0;

    try {
        if ( !m_regKey ) {

            RsOptThrow( E_NOTIMPL );
        }

        if ( ladState == LAD_DISABLED ) {

            newVal = (DWORD)1;
        }

        RsOptAffirmWin32( RegSetValueEx( m_regKey,
                                         m_regEntry,
                                         (DWORD)0,
                                         REG_DWORD,
                                         (BYTE*)&newVal,
                                         (DWORD)sizeof( DWORD ) ) );

    } RsOptCatch( hrRet );

    return( hrRet );
}

/*++

    Implements: 

        CLaDate::GetLadState

    Routine Description: 

        Returns the current state of registry value.

    Arguments: 

        ladState - LAD_ENABLED, LAD_DISABLED or LAD_UNSET

    Return Value:

        S_OK - Success
        E_FAIL - Registry value is of bad type or size
        E_*  - Any unexpected exceptions from lower level routines

--*/

HRESULT
CLaDate::GetLadState(
    OUT LAD_STATE* ladState
    )
{
TRACEFNHR( "CLaDate::GetLadState" );

    DWORD regType;
    BYTE  regData[sizeof( DWORD )];
    DWORD dataSize = sizeof( DWORD );

    try {
        if( !m_regKey ) {

            *ladState = LAD_UNSET;

        } else {

            RsOptAffirmWin32( RegQueryValueEx( m_regKey,
                                               m_regEntry,
                                               (LPDWORD)0,
                                               &regType,
                                               regData,
                                               &dataSize ) );

            if( regType != REG_DWORD || dataSize != sizeof( DWORD ) ) {

                   *ladState = LAD_ENABLED;

            } else {

                if ( (DWORD)1 == *( (DWORD*)regData ) ) {

                    *ladState = LAD_DISABLED;

                } else {

                   *ladState = LAD_ENABLED;
                }
            }
        }
    } RsOptCatch( hrRet );

    return( hrRet );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsoptcom\optcom.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    OptCom.cpp

Abstract:

    Base Class for optional component work.

Author:

    Rohde Wakefield [rohde]   09-Oct-1997

Revision History:

--*/


#ifndef _OPTCOM_H
#define _OPTCOM_H

#pragma once

class CRsOptCom
{
public:

    CRsOptCom();
    virtual ~CRsOptCom();

    DWORD
    SetupProc(
        IN     LPCVOID  ComponentId,
        IN     LPCVOID  SubcomponentId,
        IN     UINT     Function,
        IN     UINT_PTR Param1,
        IN OUT PVOID    Param2
        );

    virtual DWORD PreInitialize( IN DWORD Flags );
    virtual DWORD InitComponent( IN PSETUP_INIT_COMPONENT SetupInitComponent );
    virtual SubComponentState DetectInitialState( IN SHORT SubcomponentId );
    virtual SubComponentState QueryState( IN SHORT SubcomponentId );
    virtual BOOL SetLanguage( WORD LangId );
    virtual HBITMAP QueryImage( IN SHORT SubcomponentId, IN SubComponentInfo WhichImage, IN WORD Width, IN WORD Height );
    virtual BOOL QueryImageEx( IN SHORT SubcomponentId, IN OC_QUERY_IMAGE_INFO *pQueryImageInfo, OUT HBITMAP *phBitmap );
    virtual LONG RequestPages( IN WizardPagesType Type, IN OUT PSETUP_REQUEST_PAGES RequestPages );
    virtual BOOL QuerySkipPage( IN OcManagerPage Page );
    virtual BOOL QueryChangeSelState( IN SHORT SubcomponentId, IN BOOL NewState, IN DWORD Flags );
    virtual DWORD CalcDiskSpace( IN SHORT SubcomponentId, IN BOOL AddSpace, IN HDSKSPC hDiskSpace );
    virtual DWORD QueueFileOps( IN SHORT SubcomponentId, IN HSPFILEQ hFileQueue );
    virtual LONG QueryStepCount( IN SHORT SubcomponentId );
    virtual DWORD AboutToCommitQueue( IN SHORT SubcomponentId );
    virtual DWORD CompleteInstallation( IN SHORT SubcomponentId );
    virtual void CleanUp( void );

    //
    // Maps from string to constant ID and back
    //
    virtual SHORT IdFromString( LPCTSTR SubcomponentId ) = 0;
    virtual LPCTSTR StringFromId( SHORT SubcomponentId ) = 0;


    //
    // Helper functions to wrap functionality
    //
    DWORD DoCalcDiskSpace( IN BOOL AddSpace, IN HDSKSPC hDiskSpace, IN LPCTSTR SectionName );
    DWORD DoQueueFileOps( IN SHORT SubcomponentId, IN HSPFILEQ hFileQueue, IN LPCTSTR InstallSectionName, IN LPCTSTR UninstallSectionName );
    DWORD DoRegistryOps( IN SHORT SubcomponentId, IN RSOPTCOM_ACTION actionForReg, IN LPCTSTR SectionName );

    LPCWSTR StringFromFunction( UINT Function );
    LPCWSTR StringFromPageType( WizardPagesType PageType );
    LPCWSTR StringFromAction( RSOPTCOM_ACTION );

    RSOPTCOM_ACTION GetSubAction( SHORT SubcomponentId );

    HRESULT CreateLink( LPCTSTR lpszProgram, LPCTSTR lpszArgs, LPTSTR lpszLink, LPCTSTR lpszDir, LPCTSTR lpszDesc, 
                        int nItemDescId, int nDescId, LPCTSTR lpszIconPath, int iIconIndex );
    BOOL    DeleteLink( LPTSTR lpszShortcut );
    HRESULT GetGroupPath( int nFolder, LPTSTR szPath );
    void    AddItem( int nFolder, LPCTSTR szItemDesc, LPCTSTR szProgram, LPCTSTR szArgs, LPCTSTR szDir, LPCTSTR szDesc, 
                        int nItemDescId, int nDescId, LPCTSTR szIconPath = 0, int iIconIndex = 0 );
    void    DeleteItem( int nFolder, LPCTSTR szAppName );

    typedef HRESULT (WINAPI *PFN_DLLENTRYPOINT)( void );
    HRESULT CallDllEntryPoint( LPCTSTR pszDLLName, LPCSTR pszEntryPoint );

    //
    // Information for SETUP_INIT_COMPONENT
    //
    UINT       m_OCManagerVersion;
    UINT       m_ComponentVersion;
    HINF       m_OCInfHandle;
    HINF       m_ComponentInfHandle;
    SETUP_DATA m_SetupData;

    OCMANAGER_ROUTINES m_HelperRoutines;

    //
    // Quick access to manager routines
    //
    void TickGauge( void )
            { m_HelperRoutines.TickGauge( m_HelperRoutines.OcManagerContext ); };

    void SetProgressText( IN LPCTSTR Text )
            { m_HelperRoutines.SetProgressText( m_HelperRoutines.OcManagerContext, Text ); };

    void SetPrivateData( IN LPTSTR Name, PVOID Data, IN UINT Size, IN UINT Type )
            { m_HelperRoutines.SetPrivateData( m_HelperRoutines.OcManagerContext, Name, Data, Size, Type ); };

    UINT GetPrivateData( IN SHORT SubcomponentId OPTIONAL, IN LPTSTR Name, PVOID Data OPTIONAL, IN OUT PUINT pSize, OUT PUINT pType )
            { return m_HelperRoutines.GetPrivateData( m_HelperRoutines.OcManagerContext, StringFromId( SubcomponentId ), Name, Data, pSize, pType ); };

    UINT SetSetupMode( IN DWORD SetupMode )
            { return m_HelperRoutines.SetSetupMode( m_HelperRoutines.OcManagerContext, SetupMode ); };

    UINT GetSetupMode( void )
            { return m_HelperRoutines.GetSetupMode( m_HelperRoutines.OcManagerContext ); };

    BOOL QuerySelectionState( IN SHORT SubcomponentId, IN UINT StateType )
            { return m_HelperRoutines.QuerySelectionState( m_HelperRoutines.OcManagerContext, StringFromId( SubcomponentId ), StateType ); };

    BOOL ConfirmCancel( IN HWND ParentWindow )
            { return m_HelperRoutines.ConfirmCancelRoutine( ParentWindow ); };

    HWND QueryWizardDialogHandle( void )
            { return m_HelperRoutines.QueryWizardDialogHandle( m_HelperRoutines.OcManagerContext ); };

    BOOL SetReboot( void )
            { return m_HelperRoutines.SetReboot( m_HelperRoutines.OcManagerContext, FALSE ); };


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsoptcom\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rsoptcom.rc
//
#define IDS_ITEM_DESCRIPTION            8
#define IDS_POSSIBLE_DATA_LOSS          11
#define IDS_LA_DATE_CHANGE              12
#define IDS_CANNOT_STOP_SERVICES        13
#define IDS_PRODUCT_NAME                14
#define IDD_SCAN_WAIT                   110
#define IDB_RSTORAGE_SMALL              132
#define IDB_HOURGLASS                   135
#define IDD_UNINSTALL_ERROR_FILES       156
#define IDC_DIRTY_VOLUMES               1002
#define IDC_REMOVE_EXECUTABLES          1003
#define IDC_REMOVE_EVERYTHING           1004
#define IDC_STATIC_REM_OPTS             1009
#define IDC_FILELIST                    1010
#define IDD_WIZ_UNINSTALL_CHECK         7004
#define IDS_RS_INSTALL_SVCS             32103
#define IDS_RS_REMOVE_SVCS              32104
#define IDS_RS_UPGRADE_SVCS             32105
#define IDS_RS_DESCRIPTION              32110

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        157
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsoptcom\rsopt.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsOpt.h

Abstract:

    Special error handling macros for RsOptCom and RsCln.

Author:

    Carl Hagerstrom [carlh]   20-Aug-1998

Revision History:

--*/

#ifndef _RSOPT_H
#define _RSOPT_H

#define RsOptThrow(hr)          throw ((HRESULT)hr)
#define RsOptLastError          (HRESULT_FROM_WIN32(GetLastError()))
#define RsOptAffirm(cond,hr)    if (!(cond)) RsOptThrow(hr)
#define RsOptAffirmStatus(stat) RsOptAffirm(stat, RsOptLastError)
#define RsOptAffirmPointer(ptr) RsOptAffirm(ptr, E_POINTER)
#define RsOptAffirmAlloc(ptr)   RsOptAffirm(ptr, E_OUTOFMEMORY)
#define RsOptAffirmHr(hr)                 \
    {                                     \
        HRESULT     lHr;                  \
        lHr = (hr);                       \
        RsOptAffirm(SUCCEEDED(lHr), lHr); \
    }

      
#define RsOptAffirmHandle(hndl)                                              \
    {                                                                        \
        HANDLE _hndl;                                                        \
        _hndl = (hndl);                                                      \
        RsOptAffirm(_hndl && _hndl != INVALID_HANDLE_VALUE, RsOptLastError); \
    }

#define RsOptAffirmNtStatus(ntstat)                                          \
    {                                                                        \
        NTSTATUS _ntstat;                                                    \
        _ntstat = (ntstat);                                                  \
        RsOptAffirm(NT_SUCCESS(_ntstat), HRESULT_FROM_NT(_ntstat));          \
    }

#define RsOptAffirmDw(hr)                                                    \
    {                                                                        \
        HRESULT _hr;                                                         \
        _hr = (hr);                                                          \
        RsOptAffirm(SUCCEEDED(_hr), _hr);                                    \
    }

#define RsOptAffirmWin32(stat)                                               \
    {                                                                        \
        LONG _stat;                                                          \
        _stat = (stat);                                                      \
        RsOptAffirm(_stat == ERROR_SUCCESS, HRESULT_FROM_WIN32(_stat));      \
    }

#define RsOptCatch(retval)                                                   \
    catch(HRESULT _retval)                                                   \
    {                                                                        \
        retval = _retval;                                                    \
    }

#endif // _RSOPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsoptcom\optcom.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    OptCom.cpp

Abstract:

    Base Class for optional component work.

Author:

    Rohde Wakefield [rohde]   09-Oct-1997

Revision History:

--*/



#include "stdafx.h"
#include "rsoptcom.h"
#include "OptCom.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRsOptCom::CRsOptCom()
{
TRACEFN( "CRsOptCom::CRsOptCom" );
}

CRsOptCom::~CRsOptCom()
{
TRACEFN( "CRsOptCom::CRsOptCom" );

}

DWORD
CRsOptCom::SetupProc(
    IN     LPCVOID  /*ComponentId*/,
    IN     LPCVOID  SubcomponentId,
    IN     UINT     Function,
    IN     UINT_PTR Param1,
    IN OUT PVOID    Param2
    )
{
TRACEFN( "CRsOptCom::SetupProc" );
TRACE( L"Function = <%ls><%p>", StringFromFunction( Function ), Function );

    SHORT subcomponentId = IdFromString( (LPCTSTR)SubcomponentId );

    DWORD dwRet = 0;

    switch( Function ) {
    case OC_PREINITIALIZE:
        dwRet = PreInitialize( (DWORD)Param1 );
        break;

    case OC_INIT_COMPONENT:
        dwRet = InitComponent( (PSETUP_INIT_COMPONENT)Param2 );
        break;

    case OC_SET_LANGUAGE:
        dwRet = (DWORD)SetLanguage( (WORD)Param1 );
        break;

#ifndef _WIN64
    case OC_QUERY_IMAGE:
        // Note: The casting of the return value from HBITMAP to DWORD is broken on IA64,
        //  however, Setup avoids calling with OC_QUERY_IMAGE on IA64, rather it uses OC_QUERY_IMAGE_EX
        dwRet = (DWORD)QueryImage( subcomponentId, (SubComponentInfo)Param1, LOWORD(Param2), HIWORD(Param2) );
        break;
#endif

#ifdef _WIN64
    case OC_QUERY_IMAGE_EX:
        dwRet = (DWORD)QueryImageEx( subcomponentId, (OC_QUERY_IMAGE_INFO *)Param1, (HBITMAP *)Param2 );
        break;
#endif

    case OC_REQUEST_PAGES:
        dwRet = (DWORD)RequestPages( (WizardPagesType)Param1, (PSETUP_REQUEST_PAGES)Param2 );
        break;

    case OC_QUERY_CHANGE_SEL_STATE:
        dwRet = (DWORD)QueryChangeSelState( subcomponentId, Param1 != 0, (ULONG)((ULONG_PTR)Param2) );
        break;

    case OC_CALC_DISK_SPACE:
        dwRet = CalcDiskSpace( subcomponentId, Param1 != 0, (HDSKSPC)Param2 );
        break;

    case OC_QUEUE_FILE_OPS:
        dwRet = QueueFileOps( subcomponentId, (HSPFILEQ)Param2 );
        break;

    case OC_QUERY_STEP_COUNT:
        dwRet = (DWORD)QueryStepCount( subcomponentId );
        break;

    case OC_COMPLETE_INSTALLATION:
        dwRet = CompleteInstallation( subcomponentId );
        break;

    case OC_CLEANUP:
        CleanUp( );
        break;

    case OC_ABOUT_TO_COMMIT_QUEUE:
        dwRet = AboutToCommitQueue( subcomponentId );
        break;

    case OC_QUERY_SKIP_PAGE:
        dwRet = (DWORD)QuerySkipPage( (OcManagerPage)Param1 );
        break;

    case OC_QUERY_STATE:
        dwRet = (DWORD)QueryState( subcomponentId );
        break;

    case OC_NOTIFICATION_FROM_QUEUE:
    case OC_NEED_MEDIA:
    case OC_WIZARD_CREATED:
        break;

    default:
        break;
    }

    return( dwRet );
}

DWORD
CRsOptCom::PreInitialize(
    IN DWORD /*Flags*/
    )
{
TRACEFNDW( "CRsOptCom::PreInitialize" );

#ifdef UNICODE
    dwRet = OCFLAG_UNICODE;
#else
    dwRet = OCFLAG_ANSI;
#endif

    return( dwRet );
}

DWORD
CRsOptCom::InitComponent(
    IN PSETUP_INIT_COMPONENT SetupInitComponent )
{
TRACEFNDW( "CRsOptCom::InitComponent" );

    dwRet = NO_ERROR;

    m_OCManagerVersion   = SetupInitComponent->OCManagerVersion;
    m_ComponentVersion   = SetupInitComponent->ComponentVersion;
    m_OCInfHandle        = SetupInitComponent->OCInfHandle;
    m_ComponentInfHandle = SetupInitComponent->ComponentInfHandle;
    m_SetupData          = SetupInitComponent->SetupData;
    m_HelperRoutines     = SetupInitComponent->HelperRoutines;

    return( dwRet );
}


SubComponentState
CRsOptCom::DetectInitialState(
    IN SHORT /*SubcomponentId*/
    )
{
TRACEFN( "CRsOptCom::DetectInitialState" );
    SubComponentState retval = SubcompUseOcManagerDefault;
    return( retval );
}


SubComponentState
CRsOptCom::QueryState(
    IN SHORT /*SubcomponentId*/
    )
{
TRACEFN( "CRsOptCom::QueryState" );
    SubComponentState retval = SubcompUseOcManagerDefault;
    return( retval );
}


BOOL
CRsOptCom::SetLanguage(
    WORD /*LangId*/
    )
{
TRACEFNBOOL( "CRsOptCom::SetLanguage" );

    boolRet = TRUE;
    return( boolRet );
}


HBITMAP
CRsOptCom::QueryImage(
    IN SHORT /*SubcomponentId*/,
    IN SubComponentInfo /*WhichImage*/,
    IN WORD /*Width*/,
    IN WORD /*Height*/
    )
{
TRACEFN( "CRsOptCom::QueryImage" );
    HBITMAP retval = 0;
    return( retval );
}

BOOL
CRsOptCom::QueryImageEx( 
    IN SHORT /*SubcomponentId*/, 
    IN OC_QUERY_IMAGE_INFO* /*pQueryImageInfo*/, 
    OUT HBITMAP *phBitmap
    )
{
TRACEFNBOOL( "CRsOptCom::QueryImageEx" );

    if (phBitmap) {
        *phBitmap = NULL;
    }

    boolRet = FALSE;
    return( boolRet );
}

LONG
CRsOptCom::RequestPages(
    IN WizardPagesType /*Type*/,
    IN OUT PSETUP_REQUEST_PAGES /*RequestPages*/
    )
{
TRACEFNLONG( "CRsOptCom::RequestPages" );
    lRet = 0;
    return( lRet );
}


BOOL
CRsOptCom::QuerySkipPage(
    IN OcManagerPage /*Page*/
    )
{
TRACEFNBOOL( "CRsOptCom::QuerySkipPage" );
    boolRet = FALSE;
    return( boolRet );
}


BOOL
CRsOptCom::QueryChangeSelState(
    IN SHORT /*SubcomponentId*/,
    IN BOOL  /*NewState*/,
    IN DWORD /*Flags*/
    )
{
TRACEFNBOOL( "CRsOptCom::QueryChangeSelState" );
    boolRet = TRUE;
    return( boolRet );
}


DWORD
CRsOptCom::CalcDiskSpace(
    IN SHORT   /*SubcomponentId*/,
    IN BOOL    /*AddSpace*/,
    IN HDSKSPC /*hDiskSpace*/
    )
{
TRACEFNDW( "CRsOptCom::CalcDiskSpace" );
    dwRet = 0;
    return( dwRet );
}


DWORD
CRsOptCom::QueueFileOps(
    IN SHORT    /*SubcomponentId*/,
    IN HSPFILEQ /*hFileQueue*/
    )
{
TRACEFNDW( "CRsOptCom::QueueFileOps" );
    dwRet = 0;
    return( dwRet );
}


LONG
CRsOptCom::QueryStepCount(
    IN SHORT /*SubcomponentId*/
    )
{
TRACEFNLONG( "CRsOptCom::QueryStepCount" );
    lRet = 0;
    return( lRet );
}


DWORD
CRsOptCom::AboutToCommitQueue(
    IN SHORT /*SubcomponentId*/
    )
{
TRACEFNDW( "CRsOptCom::AboutToCommitQueue" );
    dwRet = 0;
    return( dwRet );
}


DWORD
CRsOptCom::CompleteInstallation(
    IN SHORT /*SubcomponentId*/
    )
{
TRACEFNDW( "CRsOptCom::CompleteInstallation" );
    dwRet = 0;
    return( dwRet );
}


void
CRsOptCom::CleanUp(
    void
    )
{
TRACEFN( "CRsOptCom::CleanUp" );
}


DWORD
CRsOptCom::DoCalcDiskSpace(
    IN BOOL AddSpace,
    IN HDSKSPC hDiskSpace,
    IN LPCTSTR SectionName
    )
{
TRACEFNDW( "CRsOptCom::DoCalcDiskSpace" );

    dwRet = NO_ERROR;

    HINF hLayoutInf = SetupOpenInfFile( L"layout.inf", 0, INF_STYLE_WIN4 | INF_STYLE_OLDNT , 0 );

    if( INVALID_HANDLE_VALUE == hLayoutInf) {

        dwRet = GetLastError( );
        TRACE( _T("CRsOptCom::AboutToCommitQueue Error opening LAYOUT.INF") );

    }

    if( NO_ERROR == dwRet ) {

        if( AddSpace ) {

            if( SetupAddInstallSectionToDiskSpaceList( hDiskSpace, m_ComponentInfHandle, hLayoutInf, SectionName, 0, 0 ) ) {

                dwRet = GetLastError( );

            }

        } else {

            if ( SetupRemoveInstallSectionFromDiskSpaceList( hDiskSpace, m_ComponentInfHandle, hLayoutInf, SectionName, 0, 0 ) ) {

                dwRet = GetLastError( );

            }
        }
    }

    if( INVALID_HANDLE_VALUE != hLayoutInf) {

        SetupCloseInfFile( hLayoutInf );

    }

    return( dwRet );
}

DWORD
CRsOptCom::DoQueueFileOps(
    IN SHORT SubcomponentId,
    IN HSPFILEQ hFileQueue,
    IN LPCTSTR InstallSectionName,
    IN LPCTSTR UninstallSectionName
    )
{
TRACEFNDW( "CRsOptCom::DoQueueFileOps" );

    BOOL success = TRUE;
    RSOPTCOM_ACTION action = GetSubAction( SubcomponentId );

    switch( action ) {
    case ACTION_INSTALL:

        success = SetupInstallFilesFromInfSection( m_ComponentInfHandle, 0, hFileQueue, InstallSectionName, 0, SP_COPY_FORCE_NEWER );
        break;

    case ACTION_UNINSTALL:

        success = SetupInstallFilesFromInfSection( m_ComponentInfHandle, 0, hFileQueue, UninstallSectionName, 0, 0 );
        break;

    case ACTION_UPGRADE:

       success = SetupInstallFilesFromInfSection( m_ComponentInfHandle, 0, hFileQueue, InstallSectionName, 0, SP_COPY_FORCE_NEWER );
       break;

    }

    dwRet = success ? NO_ERROR : GetLastError( );
    return( dwRet );
}

DWORD
CRsOptCom::DoRegistryOps(
    IN SHORT SubcomponentId,
    IN RSOPTCOM_ACTION actionForReg,
    IN LPCTSTR SectionName
    )
{
TRACEFNDW( "CRsOptCom::DoRegistryOps" );

    BOOL success = TRUE;
    RSOPTCOM_ACTION action = GetSubAction( SubcomponentId );

    if ( action == actionForReg ) {
        success = SetupInstallFromInfSection(
                                NULL, m_ComponentInfHandle, SectionName,
                                SPINST_REGISTRY, NULL, NULL,
                                0, NULL, NULL, NULL, NULL );
    }

    dwRet = success ? NO_ERROR : GetLastError( );
    return( dwRet );
}

LPCWSTR
CRsOptCom::StringFromFunction(
    UINT Function
    )
{
#define CASE_FUNCTION( a ) case a: return( OLESTR( #a ) );

    switch( Function ) {

        CASE_FUNCTION( OC_PREINITIALIZE           )
        CASE_FUNCTION( OC_INIT_COMPONENT          )
        CASE_FUNCTION( OC_SET_LANGUAGE            )
        CASE_FUNCTION( OC_QUERY_IMAGE             )
        CASE_FUNCTION( OC_REQUEST_PAGES           )
        CASE_FUNCTION( OC_QUERY_CHANGE_SEL_STATE  )
        CASE_FUNCTION( OC_CALC_DISK_SPACE         )
        CASE_FUNCTION( OC_QUEUE_FILE_OPS          )
        CASE_FUNCTION( OC_NOTIFICATION_FROM_QUEUE )
        CASE_FUNCTION( OC_QUERY_STEP_COUNT        )
        CASE_FUNCTION( OC_COMPLETE_INSTALLATION   )
        CASE_FUNCTION( OC_CLEANUP                 )
        CASE_FUNCTION( OC_QUERY_STATE             )
        CASE_FUNCTION( OC_NEED_MEDIA              )
        CASE_FUNCTION( OC_ABOUT_TO_COMMIT_QUEUE   )
        CASE_FUNCTION( OC_QUERY_SKIP_PAGE         )
        CASE_FUNCTION( OC_WIZARD_CREATED          )

    }
    return( TEXT( "Unknown" ) );
}

LPCWSTR
CRsOptCom::StringFromPageType(
    WizardPagesType PageType
    )
{
#define CASE_PAGETYPE( a ) case a: return( OLESTR( #a ) );

    switch( PageType ) {

        CASE_PAGETYPE( WizPagesWelcome )
        CASE_PAGETYPE( WizPagesMode    )
        CASE_PAGETYPE( WizPagesEarly   )
        CASE_PAGETYPE( WizPagesPrenet  )
        CASE_PAGETYPE( WizPagesPostnet )
        CASE_PAGETYPE( WizPagesLate    )
        CASE_PAGETYPE( WizPagesFinal   )
        CASE_PAGETYPE( WizPagesTypeMax )

    }
    return( TEXT( "Unknown" ) );
}


LPCWSTR
CRsOptCom::StringFromAction(
    RSOPTCOM_ACTION Action
    )
{
#define CASE_ACTION( a ) case a: return( OLESTR( #a ) );

    switch( Action ) {

        CASE_ACTION( ACTION_NONE )
        CASE_ACTION( ACTION_INSTALL )
        CASE_ACTION( ACTION_UNINSTALL )
        CASE_ACTION( ACTION_REINSTALL )
        CASE_ACTION( ACTION_UPGRADE )

    }
    return( TEXT( "Unknown" ) );
}

RSOPTCOM_ACTION
CRsOptCom::GetSubAction(
    SHORT SubcomponentId
    )
{
TRACEFN( "CRsOptCom::GetSubAction" );

    RSOPTCOM_ACTION retval = ACTION_NONE;
    UINT setupMode = GetSetupMode( );
    DWORDLONG operationFlags = m_SetupData.OperationFlags;

    BOOL originalState = QuerySelectionState( SubcomponentId, OCSELSTATETYPE_ORIGINAL );
    BOOL currentState = QuerySelectionState( SubcomponentId, OCSELSTATETYPE_CURRENT );

    if( !originalState && currentState ) {

        retval = ACTION_INSTALL;

    } else if( originalState && !currentState ) {

        retval = ACTION_UNINSTALL;

    } else if( ( SETUPOP_NTUPGRADE & operationFlags ) && originalState && currentState ) {

        retval = ACTION_UPGRADE;

    }

    TRACE( L"SubcomponentId = <%hd>, originalState = <%hs>, currentState = <%hs>", SubcomponentId, RsBoolAsString( originalState ), RsBoolAsString( currentState ) );
    TRACE( L"OperationsFlags = <0x%0.16I64x>, setupMode = <0x%p>", operationFlags, setupMode );
    TRACE( L"retval = <%ls>", StringFromAction( retval ) );
    return( retval );
}

HRESULT
CRsOptCom::CreateLink(
    LPCTSTR lpszProgram,
    LPCTSTR lpszArgs,
    LPTSTR lpszLink,
    LPCTSTR lpszDir,
    LPCTSTR lpszDesc,
    int nItemDescId, 
    int nDescId,
    LPCTSTR lpszIconPath,
    int iIconIndex
    )
{
TRACEFNHR( "CRsOptCom::CreateLink" );

    CComPtr<IShellLink> pShellLink;

    TCHAR szSystemPath[MAX_PATH];
    TCHAR szResourceString[MAX_PATH+128];
    UINT uLen = 0;

    szSystemPath[0] = _T('\0');
    szResourceString[0] = _T('\0');

    // CoInitialize must be called before this
    // Get a pointer to the IShellLink interface.
    hrRet = CoInitialize( 0 );
    if( SUCCEEDED( hrRet ) ) {
        hrRet = CoCreateInstance(   CLSID_ShellLink, 0, CLSCTX_SERVER, IID_IShellLink, (void**)&pShellLink );
        if( SUCCEEDED( hrRet ) ) {

            CComPtr<IPersistFile> pPersistFile;

            // Set the path to the shortcut target, and add the description.
            pShellLink->SetPath( lpszProgram );
            pShellLink->SetArguments( lpszArgs );
            pShellLink->SetWorkingDirectory( lpszDir );
            pShellLink->SetIconLocation( lpszIconPath, iIconIndex );

            // Description should be set using the resource id in order to support MUI
            uLen = GetSystemDirectory(szSystemPath, MAX_PATH);
            if ((uLen > 0) && (uLen < MAX_PATH)) {
                wsprintf(szResourceString, TEXT("@%s\\setup\\RsOptCom.dll,-%d"), szSystemPath, nDescId);
                pShellLink->SetDescription(szResourceString);
            } else {
                // Set English description
                pShellLink->SetDescription(lpszDesc);
            }

            // Query IShellLink for the IPersistFile interface for saving the
            // shortcut in persistent storage.
            hrRet = pShellLink->QueryInterface( IID_IPersistFile, (void**)&pPersistFile );

            if( SUCCEEDED( hrRet ) ) {

                CComBSTR wsz = lpszLink;

                // Save the link by calling IPersistFile::Save.
                hrRet = pPersistFile->Save( wsz, TRUE );

                if( SUCCEEDED(hrRet) && (uLen > 0) && (uLen < MAX_PATH)) {

                    // Shortcut created - set MUI name.
                    wsprintf(szResourceString, TEXT("%s\\setup\\RsOptCom.dll"), szSystemPath);

                    hrRet = SHSetLocalizedName(lpszLink, szResourceString, nItemDescId);
                }
            }

        }

        CoUninitialize();
    }

    return( hrRet );
}

BOOL
CRsOptCom::DeleteLink(
    LPTSTR lpszShortcut
    )
{
TRACEFNBOOL( "CRsOptCom::DeleteLink" );

    boolRet = TRUE;

    TCHAR  szFile[_MAX_PATH];
    SHFILEOPSTRUCT fos;

    ZeroMemory( szFile, sizeof(szFile) );
    lstrcpy( szFile, lpszShortcut );

    if( DoesFileExist( szFile ) ) {

        ZeroMemory( &fos, sizeof(fos) );
        fos.hwnd   = NULL;
        fos.wFunc  = FO_DELETE;
        fos.pFrom  = szFile;
        fos.fFlags = FOF_SILENT | FOF_NOCONFIRMATION;
        SHFileOperation( &fos );
    }

    return( boolRet );
}

HRESULT
CRsOptCom::GetGroupPath(
    int    nFolder,
    LPTSTR szPath
    )
{
TRACEFNHR( "CRsOptCom::GetGroupPath" );
    szPath[0] = _T('\0');
    hrRet = SHGetFolderPath( 0, nFolder | CSIDL_FLAG_CREATE, 0, 0, szPath );
    TRACE( L"szPath = <%ls>", szPath );
    return( hrRet );
}

void
CRsOptCom::AddItem(
    int     nFolder,
    LPCTSTR szItemDesc,
    LPCTSTR szProgram,
    LPCTSTR szArgs,
    LPCTSTR szDir,
    LPCTSTR szDesc,
    int nItemDescId, 
    int nDescId,
    LPCTSTR szIconPath,
    int     iIconIndex
    )
{
TRACEFN( "CRsOptCom::AddItem" );

    TCHAR szPath[_MAX_PATH];

    if( S_OK == GetGroupPath( nFolder, szPath ) ) {

        lstrcat( szPath, _T("\\") );
        lstrcat( szPath, szItemDesc );
        lstrcat( szPath, _T(".lnk") );

        CreateLink( szProgram, szArgs, szPath, szDir, szDesc, nItemDescId, nDescId, szIconPath, iIconIndex );
    }
}

void
CRsOptCom::DeleteItem(
    int     nFolder,
    LPCTSTR szAppName
    )
{
 TRACEFN( "CRsOptCom::DeleteItem" );

   TCHAR szPath[_MAX_PATH];

    if( S_OK == GetGroupPath( nFolder, szPath ) ) {

        lstrcat( szPath, _T("\\") );
        lstrcat( szPath, szAppName );
        lstrcat( szPath, _T(".lnk") );
    
        DeleteLink( szPath );
    }
}

typedef
HRESULT
(WINAPI *PFN_DLLENTRYPOINT)(
    void
    );

HRESULT
CRsOptCom::CallDllEntryPoint(
    LPCTSTR pszDLLName,
    LPCSTR pszEntryPoint
    )
{
TRACEFNHR( "CRsOptCom::CallDllEntryPoint" );
TRACE( _T("Dll <%s> Func <%hs>"), pszDLLName, pszEntryPoint );

    HINSTANCE           hDLL = 0;
    PFN_DLLENTRYPOINT   pfnEntryPoint;

    try {

        hDLL = LoadLibrary( pszDLLName );
        RsOptAffirmStatus( hDLL );

        pfnEntryPoint = (PFN_DLLENTRYPOINT)GetProcAddress( hDLL, pszEntryPoint );
        RsOptAffirmStatus( pfnEntryPoint );

        hrRet = pfnEntryPoint();

    } RsOptCatch( hrRet );

    if( hDLL ) FreeLibrary( hDLL );

    return( hrRet );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsoptcom\rsoptcom.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsOptCom.h

Abstract:

    Main module for Optional Component install

Author:

    Rohde Wakefield [rohde]   09-Oct-1997

Revision History:

--*/

#ifndef _RSOPTCOM_H
#define _RSOPTCOM_H

#pragma once

/////////////////////////////////////////////////////////////////////////////
// CRsoptcomApp
// See rsoptcom.cpp for the implementation of this class
//

class CRsoptcomApp : public CWinApp
{
public:
    CRsoptcomApp();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRsoptcomApp)
    //}}AFX_VIRTUAL

    //{{AFX_MSG(CRsoptcomApp)
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    virtual BOOL InitInstance();
    virtual int ExitInstance();
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

typedef enum {
    ACTION_NONE,
    ACTION_INSTALL,
    ACTION_UNINSTALL,
    ACTION_REINSTALL,
    ACTION_UPGRADE
} RSOPTCOM_ACTION;


#endif // !defined(AFX_RSOPTCOM_H__20A76545_40B8_11D1_9F11_00A02488FCDE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsoptcom\stdafx.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    StdAfx.h

Abstract:

    Singletons and consts placed here.

Author:

    Rohde Wakefield [rohde]   09-Oct-1997

Revision History:

--*/

#include "stdafx.h"

RSTRACE_INIT( "RsOptCom" )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsoptcom\rscln.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsCln.h

Abstract:

    This header is local to the GUI module and is referenced by the RsCln
    and RsOptCom modules.  It contains defined constants and the definition
    of class CRsClnServer. See the implementation file for a description
    of this class.

Author:

    Carl Hagerstrom   [carlh]   20-Aug-1998

Revision History:

--*/

#ifndef _RSCLN_H
#define _RSCLN_H

#define MAX_STICKY_NAME 80

#include <afxtempl.h>

/////////////////////////////////////////////////////////////////////////////
// CRsClnErrorFiles dialog

typedef CList<CString, CString&> CRsStringList;

class CRsClnErrorFiles : public CDialog
{
// Construction
public:
    CRsClnErrorFiles(CRsStringList* pFileList);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CRsClnErrorFiles)
    enum { IDD = IDD_UNINSTALL_ERROR_FILES };
    CListBox    m_FileList;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRsClnErrorFiles)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
    CRsStringList m_ErrorFileList;


protected:

    // Generated message map functions
    //{{AFX_MSG(CRsClnErrorFiles)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
    
};

class CRsClnServer
{
public:

    CRsClnServer();
    ~CRsClnServer();

    HRESULT ScanServer(DWORD*);
    HRESULT CleanServer();
    HRESULT FirstDirtyVolume(WCHAR**);
    HRESULT NextDirtyVolume(WCHAR**);
    HRESULT RemoveDirtyVolumes();
    HRESULT AddErrorFile(CString&);

private:

    struct dirtyVolume
    {
        WCHAR stickyName[MAX_STICKY_NAME];
        WCHAR bestName[MAX_STICKY_NAME];
        struct dirtyVolume* next;
    };

    HRESULT AddDirtyVolume(WCHAR*, WCHAR*);

    struct dirtyVolume* m_head;
    struct dirtyVolume* m_tail;
    struct dirtyVolume* m_current;

    CRsStringList m_ErrorFileList;

};

#endif // _RSCLN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsoptcom\rsoptcom.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsOptCom.h

Abstract:

    Main module for Optional Component install

Author:

    Rohde Wakefield [rohde]   09-Oct-1997

Revision History:

--*/

#include "stdafx.h"
#include "rsoptcom.h"
#include "OptCom.h"
#include "Uninstal.h"

/////////////////////////////////////////////////////////////////////////////
// CRsoptcomApp

BEGIN_MESSAGE_MAP(CRsoptcomApp, CWinApp)
    //{{AFX_MSG_MAP(CRsoptcomApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRsoptcomApp construction

BOOL CRsoptcomApp::InitInstance()
{
TRACEFNBOOL( "CRsoptcomApp::InitInstance" );

    //
    // Initialize COM in case we need to call back to HSM
    // 
    // This code is commented out:
    //  - There's no need today to call back to HSM
    //  - A DLL should avoid calling CoInitialize from its DLLMain
    //
/***    HRESULT hrCom = CoInitialize( 0 );
    if (!SUCCEEDED(hrCom)) {
        boolRet = FALSE;
        return( boolRet );
    }   ***/

    boolRet = CWinApp::InitInstance( );

    if (! boolRet) {
        OutputDebugString(L"RSOPTCOM: Init instance FAILED\n");
    } 
        
    return( boolRet );
}

int CRsoptcomApp::ExitInstance()
{
TRACEFN( "CRsoptcomApp::ExitInstance" );

//  _Module.Term();
    int retval = CWinApp::ExitInstance();
    return( retval );
}

CRsoptcomApp::CRsoptcomApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CRsoptcomApp object

CRsoptcomApp gApp;

CRsUninstall gOptCom;

extern "C" {

DWORD
OcEntry(
        IN     LPCVOID  ComponentId,
        IN     LPCVOID  SubcomponentId,
        IN     UINT     Function,
        IN     UINT_PTR Param1,
        IN OUT PVOID    Param2
    )
{
TRACEFN( "OcEntry" );
    return( gOptCom.SetupProc( ComponentId, SubcomponentId, Function, Param1, Param2 ) );
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsoptcom\stdafx.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    StdAfx.h

Abstract:

    Precompiled header starting point

Author:

    Rohde Wakefield [rohde]   09-Oct-1997

Revision History:

--*/

#ifndef _STDAFX_H
#define _STDAFX_H
#pragma once

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcmn.h>         // MFC support for Windows Common Controls

#include <setupapi.h>
#include <ocmanage.h>
#undef _WIN32_IE
#define _WIN32_IE 0x0500
#include <shlobj.h>

#include <rsopt.h>

#include "Wsb.h"
#include "RsTrace.h"
#include "Resource.h"
#include "RsOptCom.h"
#include "OptCom.h"

#define WsbBoolAsString( boolean ) (boolean ? OLESTR("TRUE") : OLESTR("FALSE"))
#define DoesFileExist( strFile )   (GetFileAttributes( strFile ) != 0xFFFFFFFF)

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#define RSOPTCOM_EXPORT __declspec(dllexport) /*__cdecl*/

#define RSOPTCOM_SUB_ROOT               TEXT("RSTORAGE")

#define RSOPTCOM_SECT_INSTALL_ROOT      TEXT("RSInstall")
#define RSOPTCOM_SECT_UNINSTALL_ROOT    TEXT("RSUninstall")
#define RSOPTCOM_SECT_INSTALL_FILTER    TEXT("RSInstall.Services")
#define RSOPTCOM_SECT_UNINSTALL_FILTER  TEXT("RSUninstall.Services")

#define RSOPTCOM_ID_ERROR   (-1)
#define RSOPTCOM_ID_NONE    (0)
#define RSOPTCOM_ID_ROOT    (1)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsoptcom\uninschk.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    UnInsCheck.h

Abstract:

    Dialog to check for type of uninstall.

Author:

    Rohde Wakefield [rohde]   09-Oct-1997

Revision History:

--*/

#ifndef _UNINSCHK_H
#define _UNINSCHK_H

#pragma once

#include "uninstal.h"
#include <rscln.h>

/////////////////////////////////////////////////////////////////////////////
// CUninstallCheck dialog

class CUninstallCheck : public CDialog
{
// Construction
public:
    CUninstallCheck( CRsOptCom * pOptCom );
    ~CUninstallCheck();

// Dialog Data
    //{{AFX_DATA(CUninstallCheck)
    enum { IDD = IDD_WIZ_UNINSTALL_CHECK };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CUninstallCheck)
    public:
    virtual INT_PTR DoModal();

    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
     CRsOptCom*    m_pOptCom;
     CRsUninstall* m_pUninst;  // allows access to CRsUninstall state
     BOOL          m_dataLoss; // TRUE if Remote Storage data exists
     CFont         m_boldShellFont;


protected:
    // Generated message map functions
    //{{AFX_MSG(CUninstallCheck)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    virtual void OnCancel();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsoptcom\uninschk.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    UnInsCheck.cpp

Abstract:

    Dialog to check for type of uninstall.

Author:

    Rohde Wakefield [rohde]   09-Oct-1997

Revision History:

    Carl Hagerstrom [carlh]   20-Aug-1998

        Changed the dialog for uninstalling Remote Storage. All local fixed
        volumes on the Remote Storage server are scanned for the existence
        of Remote Storage reparse points. If Remote Storage data exists, the
        user is told, on the Remote Storage Uninstall Check Wizard Page,
        which volumes contain this data. The user is given the choice of
        deleting only Remote Storage executables, deleting executables and
        Remote Storage data, or cancelling from "Add or Remove Optional
        Components".

    Mike Moore      [mmoore]  20-Oct-1998

        Changed the property page to a dialog.

--*/

#include "stdafx.h"
#include "UnInsChk.h"

/////////////////////////////////////////////////////////////////////////////
// CUninstallCheck property page

/*++

    Implements:

        CUninstallCheck Constructor

    Routine Description:

        Performs initialization.

    Arguments:

        pOptCom - points to optional component object

--*/

CUninstallCheck::CUninstallCheck(CRsOptCom* pOptCom) :
    CDialog(IDD), m_pOptCom(pOptCom)
{
    m_dataLoss = FALSE;
    m_pUninst  = (CRsUninstall*)m_pOptCom;
    //{{AFX_DATA_INIT(CUninstallCheck)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

/*++

    Implements:

        CUninstallCheck Destructor

--*/

CUninstallCheck::~CUninstallCheck()
{
}

/*++

    Implements:

        CUninstallCheck::DoDataExchange

    Routine Description:

        Calls CRsPropertyPage::DoDataExchange.

    Arguments:

        pDx - a pointer to a CDataExchange object

--*/

void CUninstallCheck::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CUninstallCheck)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CUninstallCheck, CDialog)
//BEGIN_MESSAGE_MAP(CUninstallCheck, CDialog)
    //{{AFX_MSG_MAP(CUninstallCheck)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CUninstallCheck message handlers

/*++

    Implements:

        CUninstallCheck::OnInitDialog

    Routine Description:

        Call the CDialog::OnInitDialog, check the remove executables radio button,
        uncheck the remove everything button, and fill the list box with volumes.

    Return Value:

        TRUE if no exceptions are thrown.

--*/
BOOL CUninstallCheck::OnInitDialog()
{

    BOOL bRet = CDialog::OnInitDialog();

    HRESULT hr           = S_OK;
    WCHAR*  volName      = (WCHAR*)0;
    DWORD   volCount     = 0;
    CRsClnServer* pRsCln = m_pUninst->m_pRsCln;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    try
    {
        // Set the font to bold for Remove Options
        LOGFONT logfont;
        CFont * tempFont = GetFont( );
        tempFont->GetLogFont( &logfont );

        logfont.lfWeight = FW_BOLD;

        m_boldShellFont.CreateFontIndirect( &logfont );

        CStatic* pRemOpts = (CStatic*)GetDlgItem(IDC_STATIC_REM_OPTS);
        pRemOpts->SetFont( &m_boldShellFont );

        CListBox* pListBox = (CListBox*)GetDlgItem(IDC_DIRTY_VOLUMES);
        pListBox->ResetContent();

        CButton* pBtn;
        pBtn = (CButton*)GetDlgItem(IDC_REMOVE_EXECUTABLES);
        pBtn->SetCheck(1);
        pBtn = (CButton*)GetDlgItem(IDC_REMOVE_EVERYTHING);
        pBtn->SetCheck(0);

        RsOptAffirmDw(pRsCln->FirstDirtyVolume(&volName));
        while (volName)
        {
            pListBox->AddString(volName);
            RsOptAffirmDw(pRsCln->NextDirtyVolume(&volName));
        }
    }
    RsOptCatch(hr);

    if ( FALSE == bRet )
    {
        EndDialog( IDCANCEL );
    }

    return bRet;

}
/////////////////////////////////////////////////////////////////////////////
// CUninstallCheck message handlers

/*++

    Implements:

        CUninstallCheck::DoModal

    Routine Description:

        Determine whether the Uninstall Check dialog should be made active,
        and if so, what should be displayed on it.

        The local fixed disk volumes are scanned for Remote Storage data.
        During the scan, an hourglass cursor and a modeless dialog,
        explaining that the scan is in progress, appear. If there is Remote
        Storage data, the Uninstall Check dialog will show a list box containing the
        volumes with Remote Storage data, instructions, and a set of radio buttons
        with uninstall options.

    Return Value:

        S_OK if no exceptions are thrown and the user selected OK.
        RSOPTCOM_ID_CANCELLED if the user selected cancel.

--*/
INT_PTR CUninstallCheck::DoModal()
{
    HRESULT hr           = S_OK;
    WCHAR*  volName      = (WCHAR*)0;
    DWORD   volCount     = 0;
    CRsClnServer* pRsCln = m_pUninst->m_pRsCln;
    INT_PTR nRet         = IDOK;

    try {

        //
        // Enclose wait cursor in its own block of applicable
        // code. We want it gone before we Go Modal
        //
        {
            CWaitCursor cursor;
            CDialog dialog(IDD_SCAN_WAIT);
            dialog.Create(IDD_SCAN_WAIT);
            Sleep(1000); // allow the user to see the dialog for at
                         // least a second when the scan is very fast
            RsOptAffirmDw(pRsCln->ScanServer(&volCount));
        }

        if( volCount > 0 ) {

            m_dataLoss = TRUE;
            nRet = CDialog::DoModal();

        }

    } RsOptCatch( hr );
    return( nRet );
}

/*++

    Implements:

        CUninstallCheck::OnOk

    Routine Description:

        When the OK button is pushed, check the radio button. If the
        user wants everything removed, set a flag in the uninstall object
        to reflect this.
        When this flag is set, uninstall will remove all Remote Storage
        reparse points, all truncated files and the Remote Storage directory.
        A message box will give the user a final warning before removing data.

    Return Value:

        void

--*/
void CUninstallCheck::OnOK()
{

    TRACEFN("CUninstallCheck::OnOK");

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT  hr   = S_OK;
    CButton* pBtn = (CButton*)GetDlgItem(IDC_REMOVE_EVERYTHING);

    if (m_dataLoss)
    {
        try
        {
            if (1 == pBtn->GetCheck())
            {
                if (IDCANCEL == AfxMessageBox(IDS_POSSIBLE_DATA_LOSS, MB_ICONSTOP | MB_OKCANCEL))
                {
                    m_pUninst->m_removeRsData = FALSE;
                }
                else
                {
                    m_pUninst->m_removeRsData = TRUE;
                    CDialog::OnOK();
                }
            }
            else
            {
                m_pUninst->m_removeRsData = FALSE;
                CDialog::OnOK();
            }
        }
        RsOptCatch(hr);
    }
}

/*++

    Implements:

        CUninstallCheck::OnCancel

    Routine Description:

        When the Cancel button is pushed, the user has decided to unmanaged the
        volumes himself.  So, from this point on the admin and engine pieces should not
        be removed if requested.

    Return Value:

        void

--*/
void CUninstallCheck::OnCancel()
{
    m_pUninst->m_removeRsData = FALSE;

    CDialog::OnCancel();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsoptcom\uninstal.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Uninstal.h

Abstract:

    Implementation of uninstall.

Author:

    Rohde Wakefield [rohde]   09-Oct-1997

Revision History:

--*/


#ifndef _UNINSTAL_H
#define _UNINSTAL_H

#pragma once

#include <rscln.h>
#include <ladate.h>

class CRsUninstall : public CRsOptCom
{
public:
    CRsUninstall();
    virtual ~CRsUninstall();

    virtual SHORT IdFromString( LPCTSTR SubcomponentId );
    virtual LPCTSTR StringFromId( SHORT SubcomponentId );
    void EnsureBackupSettings ();

    virtual
    HBITMAP
    QueryImage(
        IN SHORT SubcomponentId,
        IN SubComponentInfo WhichImage,
        IN WORD Width,
        IN WORD Height
        );

    virtual 
    BOOL 
    QueryImageEx( 
        IN SHORT SubcomponentId, 
        IN OC_QUERY_IMAGE_INFO *pQueryImageInfo, 
        OUT HBITMAP *phBitmap 
        );

    virtual
    DWORD
    CalcDiskSpace(
        IN SHORT SubcompentId,
        IN BOOL AddSpace,
        IN HDSKSPC hDiskSpace
        );

    virtual
    BOOL
    QueryChangeSelState(
        IN SHORT,
        IN BOOL,
        IN DWORD
    );

    virtual
    LONG
    QueryStepCount(
        IN SHORT SubcomponentId
    );

    virtual
    DWORD
    QueueFileOps(
        IN SHORT SubcomponentId,
        IN HSPFILEQ hFileQueue
        );

    virtual 
    DWORD 
    AboutToCommitQueue( 
        IN SHORT SubcomponentId 
        );

    virtual 
    DWORD 
    CompleteInstallation( 
        IN SHORT SubcomponentId 
        );

    virtual
    SubComponentState
    QueryState(
        IN SHORT SubcomponentId
        );

    CRsClnServer* m_pRsCln;
    BOOL m_removeRsData;       // TRUE if Remote Storage data should be removed.
                               // Set by CUninstallCheck.
    BOOL m_stopUninstall;      // Flag used to say the user has stopped the
                               // uninstall of the engine files
    BOOL m_win2kUpgrade;      // Flag used to indicate upgrading from Win2K services
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsoptcom\uninstal.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Uninstal.h

Abstract:

    Implementation of uninstall.

Author:

    Rohde Wakefield [rohde]   09-Oct-1997

Revision History:

    Carl Hagerstrom [carlh]   01-Sep-1998

        Added QueryChangeSelState and modified CompleteInstallation
        to force enabling of last access date updating.

    Carl Hagerstrom [carlh]   25-Sep-1998

        Added the check for and recovery from partial uninstalls when
        services will not stop.

--*/

#include "stdafx.h"
#include "Uninstal.h"
#include "UnInsChk.h"
#include "rsevents.h"
#include <mstask.h>

int StopServiceAndDependencies(LPCTSTR ServiceName);
HRESULT CallExeWithParameters(LPCTSTR pszEXEName, LPCTSTR pszParameters );


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRsUninstall::CRsUninstall()
{
    m_removeRsData = TRUE;
    m_stopUninstall = FALSE;
    m_win2kUpgrade = FALSE;
}

CRsUninstall::~CRsUninstall()
{

}

LPCTSTR
CRsUninstall::StringFromId( SHORT SubcomponentId )
{
    switch( SubcomponentId ) {

    case RSOPTCOM_ID_NONE:
    case RSOPTCOM_ID_ROOT:
        return( RSOPTCOM_SUB_ROOT );

    }

    return( TEXT("") );
}

SHORT
CRsUninstall::IdFromString( LPCTSTR SubcomponentId )
{
    if( !SubcomponentId ) {

        return( RSOPTCOM_ID_NONE );

    } else if( _tcsicmp( SubcomponentId, RSOPTCOM_SUB_ROOT ) == 0 ) {

        return( RSOPTCOM_ID_ROOT );

    }

    return( RSOPTCOM_ID_ERROR );
}

HBITMAP
CRsUninstall::QueryImage(
    IN SHORT SubcomponentId,
    IN SubComponentInfo /*WhichImage*/,
    IN WORD /*Width*/,
    IN WORD /*Height*/
    )
{
TRACEFN( "CRsUninstall::QueryImage" );
TRACE( _T("SubcomponentId = <%hd>"), SubcomponentId );

    HBITMAP retval = 0;
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );


    switch( SubcomponentId ) {

    case RSOPTCOM_ID_NONE:
    case RSOPTCOM_ID_ROOT:
        retval = ::LoadBitmap( AfxGetApp( )->m_hInstance, MAKEINTRESOURCE( IDB_RSTORAGE_SMALL ) );
        break;

    }
    return( retval );
}

BOOL 
CRsUninstall::QueryImageEx( 
    IN SHORT SubcomponentId, 
    IN OC_QUERY_IMAGE_INFO* /*pQueryImageInfo*/, 
    OUT HBITMAP *phBitmap 
    )
{
TRACEFNBOOL( "CRsUninstall::QueryImageEx" );
TRACE( _T("SubcomponentId = <%hd>, phBitmap = <0x%p>"), SubcomponentId, phBitmap );

    boolRet = FALSE;

    if (phBitmap) {
        *phBitmap = NULL;
        AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

        switch( SubcomponentId ) {

        case RSOPTCOM_ID_NONE:
        case RSOPTCOM_ID_ROOT:
            *phBitmap = ::LoadBitmap( AfxGetApp( )->m_hInstance, MAKEINTRESOURCE( IDB_RSTORAGE_SMALL ) );
            if ((*phBitmap) != NULL) {
                boolRet = TRUE;
            }
            break;
        }
    }

    return (boolRet);
}

LONG
CRsUninstall::QueryStepCount(
    IN SHORT /*SubcomponentId*/
    )
{
TRACEFNLONG( "CRsUninstall::QueryStepCount" );
    DWORD retval = 2;
    return( retval );
}

BOOL
CRsUninstall::QueryChangeSelState(
    IN SHORT SubcomponentId,
    IN BOOL  SelectedState,
    IN DWORD Flags
    )
{
TRACEFNBOOL( "CRsUninstall::QueryChangeSelState" );

    HRESULT   hrRet   = S_OK;
    DWORDLONG opFlags = m_SetupData.OperationFlags;

    boolRet = TRUE;

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    try {
        // When the user attempts to check the box for installing Remote Storage,
        // and updating last access date is disabled in the registry, force
        // the user to agree to changing the registry before the box is checked.
        // The message box does not appear during unattended install but the
        // registry will be changed anyway. The registry change occurs in
        // CompleteInstallation.

        if( SubcomponentId == RSOPTCOM_ID_ROOT
            && SelectedState
            && Flags & OCQ_ACTUAL_SELECTION ) {

            CLaDate lad;
            CLaDate::LAD_STATE ladState;

            RsOptAffirmDw( lad.GetLadState( &ladState ) );

            if( ladState == CLaDate::LAD_DISABLED ) {

                if( !( opFlags & SETUPOP_BATCH ) ) {

                    if( IDNO == AfxMessageBox( IDS_LA_DATE_CHANGE, MB_YESNO ) ) {

                        boolRet = FALSE;
                    }
                }
            }
        }
    } RsOptCatch( hrRet );

    if( hrRet != S_OK ) {

        // If the registry cannot be accessed, user will be
        // allowed to select Remote Storage install anyway.
        boolRet = TRUE;
    }

    return( boolRet );
}

DWORD
CRsUninstall::CalcDiskSpace(
    IN SHORT   SubcomponentId,
    IN BOOL    AddSpace,
    IN HDSKSPC hDiskSpace
    )
{
TRACEFNDW( "CRsUninstall::CalcDiskSpace" );

    dwRet = NO_ERROR;

    switch( SubcomponentId ) {

    case RSOPTCOM_ID_ROOT:
        dwRet = DoCalcDiskSpace( AddSpace, hDiskSpace, RSOPTCOM_SECT_INSTALL_ROOT );
        break;

    }
    return( dwRet );
}

DWORD
CRsUninstall::QueueFileOps(
    IN SHORT SubcomponentId,
    IN HSPFILEQ hFileQueue
    )
{
TRACEFNDW( "CRsUninstall::QueueFileOps" );


    HRESULT hrRet = S_OK;

    dwRet = NO_ERROR;


    RSOPTCOM_ACTION action = GetSubAction( SubcomponentId );

    if( !m_stopUninstall ) {        

        try {

            switch( SubcomponentId ) {

            case RSOPTCOM_ID_ROOT:

                switch( action ) {
    
                case ACTION_UPGRADE : 
                    {
                        CRsRegKey keyRSEngine;
    
                        // Check if Win2K services exist, if so - stop them
                        if( NO_ERROR == keyRSEngine.Open( HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Services\\Remote_Storage_Engine"), KEY_QUERY_VALUE) ) {
                            m_win2kUpgrade = TRUE;
                            RsOptAffirmDw( StopServiceAndDependencies( TEXT("Remote_Storage_Engine") ) );
                        }
                        if( NO_ERROR == keyRSEngine.Open( HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Services\\Remote_Storage_File_System_Agent"), KEY_QUERY_VALUE) ) {
                            m_win2kUpgrade = TRUE;
                            RsOptAffirmDw( StopServiceAndDependencies( TEXT("Remote_Storage_File_System_Agent") ) );
                        }
                        if( NO_ERROR == keyRSEngine.Open( HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Services\\Remote_Storage_Subsystem"), KEY_QUERY_VALUE) ) {
                            m_win2kUpgrade = TRUE;
                            RsOptAffirmDw( StopServiceAndDependencies( TEXT("Remote_Storage_Subsystem") ) );
                        }
                    
                        // Stop the current RS services
                        // Note: in case of upgrade from Win2K, these services don't exist but 
                        //  StopServiceAndDependencies ignores such a case (no error returned)
                        RsOptAffirmDw( StopServiceAndDependencies( TEXT("Remote_Storage_Server") ) );
                        RsOptAffirmDw( StopServiceAndDependencies( TEXT("Remote_Storage_User_Link") ) );
                    }

                    // fall through...
    
                case ACTION_INSTALL :                
    
                    RsOptAffirmDw( DoQueueFileOps( SubcomponentId, hFileQueue, RSOPTCOM_SECT_INSTALL_ROOT, RSOPTCOM_SECT_UNINSTALL_ROOT ) );
                    break;
                
                case ACTION_UNINSTALL :
                    {
                        AFX_MANAGE_STATE(AfxGetStaticModuleState());
                        CUninstallCheck dlg( this );
                        m_pRsCln = new CRsClnServer();
                        RsOptAffirmPointer( m_pRsCln );

                        if( dlg.DoModal() == IDOK ) {

                            // stop the services
                            RsOptAffirmDw( StopServiceAndDependencies( TEXT("Remote_Storage_Server") ) );
                            RsOptAffirmDw( StopServiceAndDependencies( TEXT("Remote_Storage_User_Link") ) );

                            // Queue the file operations
                            RsOptAffirmDw( DoQueueFileOps( SubcomponentId, hFileQueue, RSOPTCOM_SECT_INSTALL_ROOT, RSOPTCOM_SECT_UNINSTALL_ROOT ) );

                        } else {

                            m_stopUninstall = TRUE;

                        }
                    }
                    break;
    
                }

            }
    
        } RsOptCatch( hrRet );

        if( FAILED( hrRet ) ) {

            m_stopUninstall = TRUE;

        }

    }

    return( dwRet );
}

//
// On Install, register all our stuff that we want
//
DWORD
CRsUninstall::CompleteInstallation(
    IN SHORT SubcomponentId
    )
{
TRACEFNDW( "CRsUninstall::CompleteInstallation" );

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
    HRESULT hrRet = S_OK;

    dwRet = NO_ERROR;

    RSOPTCOM_ACTION action = GetSubAction( SubcomponentId );
    if( m_stopUninstall ) {

        action = ACTION_NONE;
    }

    CString szStatus;

    switch( action ) {

    case ACTION_UPGRADE:
    case ACTION_INSTALL:

        switch( SubcomponentId ) {

        case RSOPTCOM_ID_ROOT:
            
            szStatus.LoadString( ( action == ACTION_INSTALL ) ? IDS_RS_INSTALL_SVCS : IDS_RS_UPGRADE_SVCS );
            SetProgressText( szStatus );
    
            // Change NtfsDisableLastAccessUpdate registry
            // value if it was previously set. Updating last
            // access date cannot be disabled or Remote Storage
            // will not work.
    
            try {
    
                CLaDate lad;
                CLaDate::LAD_STATE ladState;
    
                RsOptAffirmDw( lad.GetLadState( &ladState ) );
    
                if( ladState == CLaDate::LAD_DISABLED ) {
    
                    RsOptAffirmDw( lad.SetLadState( CLaDate::LAD_ENABLED ) );
                }
    
            } RsOptCatch( hrRet );
    
            if( hrRet != S_OK ) {
    
                // Failure to read or update registry is not serious
                // enough to fail installation.
                dwRet = NO_ERROR;
            }
    
            // Register the filter
            HRESULT hrRegister;
            BOOL registered = SetupInstallServicesFromInfSection( m_ComponentInfHandle, RSOPTCOM_SECT_INSTALL_FILTER, SPSVCINST_TAGTOFRONT );
            hrRegister = ( registered ) ? S_OK : HRESULT_FROM_WIN32( RsOptLastError );
    
            // If Rsfilter does not register correctly we need to set the error code.
            // Usually this is caused by the user not rebooting after unregistering RsFilter.
            // If it is marked for deletion then we cannot register it again. We also don't
            // want the component manager to think everything worked.
            if( FAILED( hrRegister ) ) {
                 
                if( FACILITY_WIN32 == HRESULT_FACILITY( hrRegister ) ) {
    
                    dwRet = HRESULT_CODE( hrRegister );
                    if( ERROR_SERVICE_EXISTS == dwRet ) {
    
                        dwRet = NO_ERROR;
    
                    }
    
                } else {
    
                    dwRet = ERROR_SERVICE_NOT_FOUND;
    
                }
    
                RsOptAffirmDw( dwRet );
    
            }
    
            // Register the dlls                
            CallDllEntryPoint( TEXT("RsEngPs.dll"),  "DllRegisterServer" );
            CallDllEntryPoint( TEXT("RsSubPs.dll"),  "DllRegisterServer" );
            CallDllEntryPoint( TEXT("RsServPs.dll"), "DllRegisterServer" );
            CallDllEntryPoint( TEXT("RsAdmin.dll"),  "DllRegisterServer" );
            CallDllEntryPoint( TEXT("RsCommon.dll"), "DllRegisterServer" );
            CallDllEntryPoint( TEXT("RsShell.dll"),  "DllRegisterServer" );
            CallDllEntryPoint( TEXT("RsJob.dll"),    "DllRegisterServer" );
            CallDllEntryPoint( TEXT("RsIdb.dll"),    "DllRegisterServer" );
            CallDllEntryPoint( TEXT("RsTask.dll"),   "DllRegisterServer" );
            CallDllEntryPoint( TEXT("RsMover.dll"),  "DllRegisterServer" );
            CallDllEntryPoint( TEXT("RsSub.dll"),    "DllRegisterServer" );
            CallDllEntryPoint( TEXT("RsFsa.dll"),    "DllRegisterServer" );
            CallDllEntryPoint( TEXT("RsEng.dll"),    "DllRegisterServer" );
    
            // Register the services
            CallExeWithParameters( TEXT("RsServ.exe"), TEXT(" /regserver") );
            CallExeWithParameters( TEXT("RsLnk.exe"), TEXT(" /regserver") );
    
            // Ensure NT Backup settings (exclude some RS files from backup)
            //
            // Note: In Whistler NTBackup, these setting apply only when the backup
            //  is a non-snapshot backup. In this case, we still want to exclude the files.
            //  In case of a snapshot backup, the exclude settings are determined by
            //  the writer class in the Engine.
            EnsureBackupSettings ();

            // If we get this far,
            // we should go ahead and set to reboot if needed
            if( ( S_OK == hrRegister ) && ( ACTION_INSTALL == action ) ) {
    
                // Tell the user they do need to reboot
                SetReboot();
    
            }

            // Add shortcut to start menu
            CString itemDesc, desc;
            itemDesc.LoadString( IDS_ITEM_DESCRIPTION );
            desc.LoadString( IDS_RS_DESCRIPTION );
            AddItem( CSIDL_COMMON_ADMINTOOLS, itemDesc, TEXT("%SystemRoot%\\System32\\RsAdmin.msc"), TEXT(""), TEXT("%HOMEDRIVE%%HOMEPATH%"), desc, 
                        IDS_ITEM_DESCRIPTION, IDS_RS_DESCRIPTION, TEXT("%SystemRoot%\\System32\\RsAdmin.dll"), 0 );

            break;

        }
        break;


    case ACTION_UNINSTALL:

        switch( SubcomponentId ) {

        case RSOPTCOM_ID_ROOT:

            // removing shortcut from start menu
            CString itemDesc;
            itemDesc.LoadString( IDS_ITEM_DESCRIPTION );
            DeleteItem( CSIDL_COMMON_ADMINTOOLS, itemDesc );
    
            try {
    
                // For some reason, rscommon.dll is not getting removed. This
                // will schedule it to be removed on the next system startup.
                
                CString path( getenv( "SystemRoot" ) );
                path += "\\system32\\rscommon.dll";
                RsOptAffirmStatus( MoveFileEx( path, NULL, MOVEFILE_DELAY_UNTIL_REBOOT ) );
    
            } RsOptCatch( hrRet );
    
            if( m_removeRsData ) {
    
                // user chose to remove all data managed by Remote Storage
                szStatus.LoadString( IDS_RS_REMOVE_SVCS );
                SetProgressText( szStatus );
    
                // remove reparse points and truncated files
                m_pRsCln->CleanServer();
                delete m_pRsCln;
    
                // remove our subdirectory
                //
                // TBD (ravisp): in a clustering environment the RemoteStorage directory
                // is relocatable. We would need to get the real metadata path
                // and blow it away
                //
                CallExeWithParameters( TEXT("CMD.EXE"), TEXT(" /C del %SystemRoot%\\system32\\RemoteStorage\\*.* /q") );
                CallExeWithParameters( TEXT("CMD.EXE"), TEXT(" /C rd %SystemRoot%\\system32\\RemoteStorage /s /q") );
            
            }
            break;

        }

        break;
    }


    TickGauge(  );

    return( dwRet );
}

void RemoveTasks()
{
TRACEFNHR( "RemoveTasks" ); 

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    CComPtr <ITaskScheduler>    pSchedAgent;            // Pointer to Scheduling Agent
    CComPtr <IEnumWorkItems>    pEnumWorkItems;         // Pointer to Scheduling Agent

    LPWSTR *rgpwszName;
    ULONG   celtFetched;

    CString creatorName;
    creatorName.LoadString( IDS_PRODUCT_NAME );

    try {

        hrRet = CoInitialize ( NULL );
        RsOptAffirmHr(hrRet);

        hrRet = CoCreateInstance( CLSID_CSchedulingAgent, 0, CLSCTX_SERVER,
                IID_ISchedulingAgent, (void **) &pSchedAgent ) ;
        RsOptAffirmHr(hrRet);
        
        pSchedAgent->Enum( &pEnumWorkItems );

        pEnumWorkItems->Next( 1, &rgpwszName , &celtFetched ) ;
        while( 1 == celtFetched ) {

            CComPtr <ITask> pTask;          // Pointer to a specific task
            CComPtr <IUnknown> pIU;
            LPWSTR pwszCreator;

            // using pSchedAgent->Activate( )
            // Get the task we're interested in
            if( S_OK == pSchedAgent->Activate( *rgpwszName, IID_ITask, &pIU) ) {

                // QI to the task interface
                hrRet = pIU->QueryInterface(IID_ITask, (void **) &pTask);
                RsOptAffirmHr(hrRet);

                //
                // If it matches then we need to delete it
                //
                pTask->GetCreator( &pwszCreator );

                // dereference
                pTask.Release();

                if( 0 == creatorName.Compare( pwszCreator ) ) {

                    pSchedAgent->Delete( *rgpwszName );
                    //then delete using pSchedAgent->Delete()
                    pEnumWorkItems->Reset();

                }
                CoTaskMemFree( pwszCreator );
                pwszCreator = 0;
            }

            // Free the memory from the Next
            CoTaskMemFree( *rgpwszName );
            rgpwszName = 0;
            pEnumWorkItems->Next( 1, &rgpwszName, &celtFetched ) ;

        }

    } RsOptCatch( hrRet );
}

//
// On Uninstall, unregister everything and get us cleaned up
//
DWORD
CRsUninstall::AboutToCommitQueue(
    IN SHORT SubcomponentId
    )
{
TRACEFNHR( "CRsUninstall::AboutToCommitQueue" );

    RSOPTCOM_ACTION action = GetSubAction( SubcomponentId );
    if( m_stopUninstall ) {        

        action = ACTION_NONE;
    }

    CString szStatus;
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    try {

        switch( action ) {
        case ACTION_INSTALL:
            break;

        case ACTION_UNINSTALL:

            switch( SubcomponentId ) {

            case RSOPTCOM_ID_ROOT:

                // remove our entries from Directory Services
                // MGL: To do 
                // Remove Display specifier for our node and our node on the computer
                // CallDllEntryPoint( TEXT("RsConn.dll"),   "RsDirectoryServiceUninstall" );
    
                szStatus.LoadString( IDS_RS_REMOVE_SVCS );
                SetProgressText( szStatus );
    
                // Unregister the filter and indicate that the system must be rebooted
                SetupInstallServicesFromInfSection( m_ComponentInfHandle, RSOPTCOM_SECT_UNINSTALL_FILTER, 0 );
                SetReboot();
    
                // Unregister the services
                CallExeWithParameters( TEXT("RsServ.exe"), TEXT(" /unregserver") );
                CallExeWithParameters( TEXT("RsLnk.exe"), TEXT(" /unregserver") );
    
                // Unregister the dlls              
                CallDllEntryPoint( TEXT("RsEngPs.dll"),  "DllUnregisterServer" );
                CallDllEntryPoint( TEXT("RsSubPs.dll"),  "DllUnregisterServer" );
                CallDllEntryPoint( TEXT("RsServPs.dll"), "DllUnregisterServer" );
                CallDllEntryPoint( TEXT("RsAdmin.dll"),  "DllUnregisterServer" );
                CallDllEntryPoint( TEXT("RsShell.dll"),  "DllUnregisterServer" );
                CallDllEntryPoint( TEXT("RsJob.dll"),    "DllUnregisterServer" );
                CallDllEntryPoint( TEXT("RsIdb.dll"),    "DllUnregisterServer" );
                CallDllEntryPoint( TEXT("RsTask.dll"),   "DllUnregisterServer" );
                CallDllEntryPoint( TEXT("RsMover.dll"),  "DllUnregisterServer" );
                CallDllEntryPoint( TEXT("RsSub.dll"),    "DllUnregisterServer" );
                CallDllEntryPoint( TEXT("RsFsa.dll"),    "DllUnregisterServer" );
                CallDllEntryPoint( TEXT("RsEng.dll"),    "DllUnregisterServer" );
                CallDllEntryPoint( TEXT("RsCommon.dll"), "DllUnregisterServer" );
    
                // remove our jobs from the job scheduler if we are removing the 
                // Remote Storage Data.
                if( m_removeRsData ) {
    
                    RemoveTasks();
    
                }

                break;

            }
            break;

        case ACTION_UPGRADE:

            switch( SubcomponentId ) {

            case RSOPTCOM_ID_ROOT:

                // Check if this is an upgrade from Win2K, if so:
                //  1. Unregister obsolete services
                //  2. Delete obsolete binary files
                if (m_win2kUpgrade) {
                    CallExeWithParameters( TEXT("RsEng.exe"), TEXT(" /unregserver") );
                    CallExeWithParameters( TEXT("RsFsa.exe"), TEXT(" /unregserver") );
                    CallExeWithParameters( TEXT("RsSub.exe"), TEXT(" /unregserver") );

                    CString path( getenv( "SystemRoot" ) );
                    path += TEXT("\\system32\\");
                    CString fileName = path;
                    fileName += TEXT("RsEng.exe");
                    DeleteFile(fileName);
                    fileName = path;
                    fileName += TEXT("rsFsa.exe");
                    DeleteFile(fileName);
                    fileName = path;
                    fileName += TEXT("RsSub.exe");
                    DeleteFile(fileName);
                }

                break;

            }
            break;

        }

    } RsOptCatch( hrRet ) ;
        
    TickGauge(  );

    return( SUCCEEDED( hrRet ) ? NO_ERROR : HRESULT_CODE( hrRet ) );
}

//
// If there is a problem with install or uninstall which might leave it
// in a partially installed or uninstalled state, set the subcomponent
// state to redo this install or uninstall.
//
SubComponentState
CRsUninstall::QueryState(
    IN SHORT SubcomponentId
    )
{
TRACEFN( "CRsUninstall::QueryState" );

    SubComponentState retval = SubcompUseOcManagerDefault;
    RSOPTCOM_ACTION   action = GetSubAction( SubcomponentId );

    //
    // Need to check and see if we are upgrading from previous to
    // 393 build which had rsengine entry, but no rstorage entry.
    //
    if( RSOPTCOM_ID_ROOT == SubcomponentId ) {

        BOOL originalState = QuerySelectionState( SubcomponentId, OCSELSTATETYPE_ORIGINAL );
        if( !originalState ) {

            CRsRegKey keyRSEngine;
            LONG regRet = keyRSEngine.Open( HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents") );
            if( NO_ERROR == regRet ) {

                DWORD engineState;
                regRet = keyRSEngine.QueryValue( engineState, TEXT("rsengine") );

                if( ( NO_ERROR == regRet ) && engineState ) {

                    //
                    // Had old style engine entry, and was on, so do fix up
                    //
                    retval = SubcompOn;
                    regRet = keyRSEngine.SetValue( engineState, TEXT("rstorage") );
                    if( NO_ERROR == regRet ) {

                        keyRSEngine.DeleteValue( TEXT("rsengine") );
                        keyRSEngine.DeleteValue( TEXT("rsui") );

                    }
                }
            }
        }
    }

    switch( action ) {

    case ACTION_UPGRADE:
    case ACTION_INSTALL:

        if( m_stopUninstall ) {

            retval = SubcompOff;
        }
        break;

    case ACTION_UNINSTALL:

        if( m_stopUninstall ) {

            retval = SubcompOn;
        }
        break;
    }

    return( retval );
}

//
//Routine Description:
//    Stop the named service and all those services which depend upon it
//
//Arguments:
//    ServiceName (Name of service to stop)
//
//Return Status:
//    TRUE - Indicates service successfully stopped
//    FALSE - Timeout occurred.
//
int StopServiceAndDependencies(LPCTSTR ServiceName)
{
TRACEFNHR( "StopServiceAndDependencies" );
TRACE( _T("ServiceName <%s>"), ServiceName );

    DWORD          err = NO_ERROR;
    SC_HANDLE      hScManager = 0;
    SC_HANDLE      hService = 0;
    SERVICE_STATUS statusService;

    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

    try {

        //
        // Open a handle to the Service.
        //
        hScManager = OpenSCManager( NULL,NULL,SC_MANAGER_CONNECT );
        RsOptAffirmStatus( hScManager );

        hService = OpenService(hScManager,ServiceName,SERVICE_QUERY_STATUS | SERVICE_INTERROGATE | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_STOP | SERVICE_QUERY_CONFIG );
        if( !hService ) {

            err = GetLastError();
            RsOptAffirm( ERROR_SERVICE_DOES_NOT_EXIST == err, HRESULT_FROM_WIN32( err ) );
            RsOptThrow( S_OK );

        }


        //
        // Ask the service to stop.
        //
        if( !ControlService( hService, SERVICE_CONTROL_STOP, &statusService) ) {

            err = GetLastError();
            switch( err ) {

            case ERROR_DEPENDENT_SERVICES_RUNNING:
            {
                //
                // If there are dependent services running,
                //  determine their names and stop them.
                //

                BYTE ConfigBuffer[4096];
                LPENUM_SERVICE_STATUS ServiceConfig = (LPENUM_SERVICE_STATUS) &ConfigBuffer;
                DWORD BytesNeeded, ServiceCount, ServiceIndex;

                //
                // Get the names of the dependent services.
                //
                RsOptAffirmStatus(
                    EnumDependentServices( hService, SERVICE_ACTIVE, ServiceConfig, sizeof(ConfigBuffer), &BytesNeeded, &ServiceCount ) );

                //
                // Stop those services.
                //
                for( ServiceIndex = 0; ServiceIndex < ServiceCount; ServiceIndex++ ) {

                    StopServiceAndDependencies( ServiceConfig[ServiceIndex].lpServiceName );

                }

                //
                // Ask the original service to stop.
                //
                RsOptAffirmStatus( ControlService( hService, SERVICE_CONTROL_STOP, &statusService ) );

                break;
            }

            case ERROR_SERVICE_CANNOT_ACCEPT_CTRL:
            case ERROR_SERVICE_NOT_ACTIVE:

                //
                // check if the service is already stopped..
                //
                RsOptAffirmStatus( QueryServiceStatus( hService, &statusService ) );

                if( SERVICE_STOPPED == statusService.dwCurrentState || SERVICE_STOP_PENDING == statusService.dwCurrentState ) {

                    RsOptThrow( S_OK );

                }
                // Fall through

            default:
                RsOptThrow( HRESULT_FROM_WIN32( err ) );

            }

        }

        //
        // Loop waiting for the service to stop.
        //
        for( DWORD Timeout = 0; Timeout < 45; Timeout++ ) {

            //
            // Return or continue waiting depending on the state of
            //  the service.
            //
            if( SERVICE_STOPPED == statusService.dwCurrentState ) {

                break;

            }

            //
            // Wait a second for the service to finish stopping.
            //
            Sleep( 1000 );

            //
            // Query the status of the service again.
            //
            RsOptAffirmStatus( QueryServiceStatus( hService, &statusService ) );

        }

        if( SERVICE_STOPPED != statusService.dwCurrentState ) {

            RsOptThrow( HRESULT_FROM_WIN32( ERROR_SERVICE_REQUEST_TIMEOUT ) );

        }

    } RsOptCatch( hrRet );

    if( hScManager )  CloseServiceHandle( hScManager );
    if( hService )    CloseServiceHandle( hService );

    if ( FAILED( hrRet ) ) {

        CString message;
        AfxFormatString1( message, IDS_CANNOT_STOP_SERVICES, ServiceName );
        AfxMessageBox( message, MB_OK | MB_ICONEXCLAMATION );
    }

    return( hrRet );
}


HRESULT
CallExeWithParameters(
    LPCTSTR pszEXEName,
    LPCTSTR pszParameters
    )
{
TRACEFNHR( "CallExeWithParameters" );
TRACE( _T("Exe <%s> Params <%s>"), pszEXEName, pszParameters );

    PROCESS_INFORMATION exeInfo;
    STARTUPINFO startupInfo;
    memset( &startupInfo, 0, sizeof( startupInfo ) );
        
    startupInfo.cb          = sizeof( startupInfo );
    startupInfo.wShowWindow = SW_HIDE;
    startupInfo.dwFlags     = STARTF_USESHOWWINDOW;
        
    CString exeCmd( pszEXEName );
    exeCmd += pszParameters;

    try {

        RsOptAffirmStatus( CreateProcess( 0, (LPWSTR)(LPCWSTR)exeCmd, 0, 0, FALSE, 0, 0, 0, &startupInfo, &exeInfo ) );
        RsOptAffirmStatus( WAIT_FAILED != WaitForSingleObject( exeInfo.hProcess, 30000 ) );

    } RsOptCatch( hrRet ) ;

    return( hrRet );
}

//
//Method Description:
//    Ensure that NT Backup Registry settings exclude some RS files from backup
//     Don't check faiures since we want to install even if there are errors here
//
void CRsUninstall::EnsureBackupSettings ()
{
    HKEY regKey = 0;
    WCHAR *regPath  = L"System\\CurrentControlSet\\Control\\BackupRestore\\FilesNotToBackup";

    // open backup key
    if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, regPath, (DWORD)0, 
            KEY_ALL_ACCESS, &regKey) ) {

        // prepare strings

        //
        // Don't add the additional \0 at the end, the compiler will add 
        // the additional NULL. This ensures that when we use sizeof on the string
        // we get the right size (including 2 NULLs at the end)
        //
        WCHAR regData[] = L"%SystemRoot%\\System32\\RemoteStorage\\*.col\0"
                          L"%SystemRoot%\\System32\\RemoteStorage\\EngDb\\*\0"
                          L"%SystemRoot%\\System32\\RemoteStorage\\FsaDb\\*\0"
                          L"%SystemRoot%\\System32\\RemoteStorage\\Trace\\*\0";

        // set RS exclude values
        RegSetValueEx( regKey, RSS_BACKUP_NAME, (DWORD)0, REG_MULTI_SZ, (BYTE*)regData, sizeof(regData));
        
        // close opened key
        RegCloseKey (regKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsoptcom\dll\makefile.inc ===
$(O)\RsOptCom.res: ..\res\RsOptCom.rc2   \

$(O)\PreComp.obj: ..\resource.h

$(O)\OptCom.obj   \
$(O)\RsOptCom.obj \
$(O)\StdAfx.obj   \
$(O)\UninsChk.obj \
$(O)\Uninstal.obj : $(O)\PreComp.pch
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsoptcom\rscln\rscln2.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsCln2.h

Abstract:

    This header is local to the RsCln module.  It contains defined constants
    and the class definitions for CRsClnVolume and CRsClnFile. See the
    implementation files for descriptions of these classes.

Author:

    Carl Hagerstrom   [carlh]   20-Aug-1998

Revision History:

--*/

#ifndef _RSCLN2_H
#define _RSCLN2_H

#include <stdafx.h>

#define MAX_VOLUME_NAME 64
#define MAX_FS_NAME     16
#define MAX_DOS_NAME    4

class CRsClnVolume
{
public:

    CRsClnVolume( CRsClnServer* pServer, WCHAR* StickyName );
    ~CRsClnVolume();

    HRESULT VolumeHasRsData( BOOL* );
    CString GetBestName( );
    HRESULT RemoveRsDataFromVolume( );

    HANDLE  GetHandle( );
    CString GetStickyName( );

private:

    HRESULT GetVolumeInfo( );
    HRESULT FirstRsReparsePoint(LONGLONG*, BOOL*);
    HRESULT NextRsReparsePoint(LONGLONG*, BOOL*);

    WCHAR       m_fsName[MAX_FS_NAME];
    WCHAR       m_bestName[MAX_STICKY_NAME];
    WCHAR       m_volumeName[MAX_VOLUME_NAME];
    WCHAR       m_dosName[MAX_DOS_NAME];
    CString     m_StickyName;

    DWORD       m_fsFlags;
    HANDLE      m_hRpi;
    HANDLE      m_hVolume;

    CRsClnServer* m_pServer;

};

class CRsClnFile
{
public:

    CRsClnFile( CRsClnVolume* pVolume, LONGLONG FileID );
    ~CRsClnFile();

    HRESULT RemoveReparsePointAndFile();
    CString GetFileName( );

    HRESULT ClearReadOnly( );
    HRESULT RestoreAttributes( );

private:

    HRESULT GetFileInfo( LONGLONG FileID );

    CString                 m_FileName;
    CString                 m_FullPath;
    CRsClnVolume*           m_pVolume;

    UCHAR                   m_ReparseData[ sizeof(REPARSE_DATA_BUFFER) + sizeof(RP_DATA) ];
    PREPARSE_DATA_BUFFER    m_pReparseData;
    PRP_DATA                m_pHsmData;

    FILE_BASIC_INFORMATION  m_BasicInfo;

};

#endif // _RSCLN2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsoptcom\rscln\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#ifndef _STDAFX_H
#define _STDAFX_H

#undef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#undef _WIN32_IE
#define _WIN32_IE    0x0500
//
// These NT header files must be included before any Win32 stuff or you
// get lots of compiler errors
//
extern "C" {
#include <nt.h>
}
extern "C" {
#include <ntrtl.h>
}
extern "C" {
#include <nturtl.h>
}

#include <rpdata.h>

#undef ASSERT
#define VC_EXTRALEAN
#include <afx.h>
#include <afxwin.h>
#include <atlbase.h>

#include "resource.h"
#include "rsopt.h"
#include "rstrace.h"
#include "rscln.h"
#include "rscln2.h"

#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsoptcom\rscln\rsclnfil.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsClnFil.cpp

Abstract:

    Implementation of CRsClnFile. This class represents a file on
    a local volume of a Remote Storage server, which is going to be
    cleaned.  Cleaning means removing the file if it has been truncated
    and removing its reparse point. Each instance of CRsClnFile is created
    by CRsClnVolume.

Author:

    Carl Hagerstrom [carlh]   20-Aug-1998

Revision History:

--*/

#include <stdafx.h>

/*++

    Implements:
    
        CRsClnFile Constructor

    Routine Description: 

        Loads file information.

    Arguments: 

        hVolume - handle of volume on which this file resides
        fileReference - file reference for this file.  This is
                        a numerical handle which can be used
                        to uniquely identify and open a file.

--*/

CRsClnFile::CRsClnFile( 
    IN CRsClnVolume* pVolume,
    IN LONGLONG      FileReference
    ) :
    m_pVolume( pVolume )
{
TRACEFN( "CRsClnFile::CRsClnFile" );

    m_pReparseData = 0;
    m_pHsmData     = 0;

    RsOptAffirmDw( GetFileInfo( FileReference ) );
}

/*++

    Implements:

        CRsClnFile Destructor

--*/

CRsClnFile::~CRsClnFile( )
{
TRACEFN( "CRsClnFile::~CRsClnFile" );
}

/*++

    Implements: 

        CRsClnFile::RemoveReparsePointAndFile

    Routine Description: 

        Removes the reparse point for this file and removes
        the file itself if it has been truncated.

        - Read the reparse point for this file.
        - Determine from reparse data whether the file has been truncated.
        - If truncated, close and remove it.
        - If not truncated, remove reparse point and close file.

    Arguments: 

        stickyName - name of volume on which this file resides

    Return Value:

        S_OK - success
        E_*  - any unexpected exceptions from lower level routines

--*/

HRESULT
CRsClnFile::RemoveReparsePointAndFile(
    )
{
TRACEFNHR( "CRsClnFile::RemoveReparsePointAndFile" );
    
    DWORD  actualSize;
    BOOL   bStatus;
    HANDLE hFile = INVALID_HANDLE_VALUE;


    try {

        RsOptAffirmDw( ClearReadOnly( ) );

        if ( RP_FILE_IS_TRUNCATED( m_pHsmData->data.bitFlags ) ) {

            //
            // Clear the file attributes in case they are read only
            //
            RsOptAffirmStatus( DeleteFile( m_FullPath ) );

        } else {

            hFile = CreateFile( m_FullPath,
                                FILE_READ_DATA | FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                0,
                                OPEN_EXISTING,
                                FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT,
                                0 );

            RsOptAffirmHandle( hFile );

            //
            // Set the time flags so that when we close the handle the
            // time are not updated on the file and the FileAttributes 
            // indicate the file is offline
            //
            IO_STATUS_BLOCK         ioStatusBlock;
            FILE_BASIC_INFORMATION  basicInfo;

            RsOptAffirmNtStatus( NtQueryInformationFile( hFile,
                                                         &ioStatusBlock,
                                                         (PVOID) &basicInfo,
                                                         sizeof( basicInfo ),
                                                         FileBasicInformation ) );

            basicInfo.CreationTime.QuadPart   = -1;
            basicInfo.LastAccessTime.QuadPart = -1;
            basicInfo.LastWriteTime.QuadPart  = -1;
            basicInfo.ChangeTime.QuadPart     = -1;

            RsOptAffirmNtStatus( NtSetInformationFile( hFile,
                                                       &ioStatusBlock,
                                                       (PVOID)&basicInfo,
                                                       sizeof( basicInfo ),
                                                       FileBasicInformation ) );

            //
            // Nuke the reparse point
            //
            m_pReparseData->ReparseTag        = IO_REPARSE_TAG_HSM;
            m_pReparseData->ReparseDataLength = 0;

            bStatus = DeviceIoControl( hFile,
                                       FSCTL_DELETE_REPARSE_POINT,
                                       (LPVOID) m_pReparseData,
                                       REPARSE_DATA_BUFFER_HEADER_SIZE,
                                       (LPVOID) 0,
                                       (DWORD)  0,
                                       &actualSize,
                                       (LPOVERLAPPED) 0 );

            RsOptAffirmStatus( bStatus );

        }

    } RsOptCatch( hrRet );

    if( INVALID_HANDLE_VALUE != hFile )   CloseHandle( hFile );

    if( ! RP_FILE_IS_TRUNCATED( m_pHsmData->data.bitFlags ) ) {

        //
        // Restore file attributes
        //
        RestoreAttributes( );

    }

    return( hrRet );
}

/*++

    Implements: 

        CRsClnFile::GetFileInfo

    Routine Description: 

        Obtain file information for file specified by volume and
        file reference.

        - Open file using volume handle and file reference.
        - Obtain the file name and the length of the file name.
          Since the length of the file name is unknown the first time
          NtQueryInformationFile is called, it might have to be called
          again once the correct buffer size can be determined.

    Arguments: 

        hVolume - handle of volume on which this file resides
        fileReference - file reference for this file.  This is
                        a numerical handle which can be used
                        to uniquely identify and open a file.

    Return Value:

        S_OK - Success
        E_*  - Any unexpected exceptions from lower level routines

--*/

HRESULT
CRsClnFile::GetFileInfo( 
    IN LONGLONG fileReference
    )
{
TRACEFNHR( "CRsClnFile::GetFileInfo" );

    UNICODE_STRING         objectName;
    OBJECT_ATTRIBUTES      objectAttributes;
    NTSTATUS               ntStatus;
    IO_STATUS_BLOCK        ioStatusBlock;
    PFILE_NAME_INFORMATION pfni;
    HANDLE                 hFile = INVALID_HANDLE_VALUE;
    DWORD                  actualSize;
    ULONG                  fileNameLength;
    PVOID                  fileNameInfo = 0;

    m_pReparseData = (PREPARSE_DATA_BUFFER) m_ReparseData;
    m_pHsmData     = (PRP_DATA)&( m_pReparseData->GenericReparseBuffer.DataBuffer[0] );

    try {
        
        RtlInitUnicodeString( &objectName, (WCHAR*)&fileReference );
        objectName.Length = 8;
        objectName.MaximumLength = 8;

        HANDLE hVolume = m_pVolume->GetHandle( );
        RsOptAffirmHandle( hVolume );
        InitializeObjectAttributes( &objectAttributes,
                                    &objectName,
                                    OBJ_CASE_INSENSITIVE,
                                    hVolume,
                                    (PVOID)0 );

        ULONG desiredAccess = FILE_READ_ATTRIBUTES;
        ULONG shareAccess   = FILE_SHARE_READ | FILE_SHARE_WRITE;
        ULONG createOptions = FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_BY_FILE_ID | FILE_OPEN_REPARSE_POINT;
        ntStatus = NtCreateFile( &hFile,
                                 desiredAccess,
                                 &objectAttributes,
                                 &ioStatusBlock,
                                 (PLARGE_INTEGER)0,
                                 FILE_ATTRIBUTE_NORMAL,
                                 shareAccess,
                                 FILE_OPEN,
                                 createOptions,
                                 (PVOID)0,
                                 (ULONG)0 );
        RsOptAffirmNtStatus( ntStatus );

        RsOptAffirmNtStatus( NtQueryInformationFile( hFile,
                                                     &ioStatusBlock,
                                                     (PVOID) &m_BasicInfo,
                                                     sizeof( m_BasicInfo ),
                                                     FileBasicInformation ) );
        //
        // Get the file name
        //
        size_t bufSize  = 256;
        fileNameInfo = malloc( bufSize );
        RsOptAffirmAlloc( fileNameInfo );

        ntStatus = NtQueryInformationFile( hFile,
                                           &ioStatusBlock,
                                           fileNameInfo,
                                           bufSize - sizeof(WCHAR),
                                           FileNameInformation );

        if( ntStatus == STATUS_BUFFER_OVERFLOW ) {

            pfni = (PFILE_NAME_INFORMATION)fileNameInfo;
            bufSize = sizeof(ULONG) + pfni->FileNameLength + sizeof(WCHAR);

            PVOID tmpFileNameInfo = realloc( fileNameInfo, bufSize );
            if( !tmpFileNameInfo ) {
                
                free( fileNameInfo );
                fileNameInfo = 0;

            } else {

                fileNameInfo = tmpFileNameInfo;

            }


            RsOptAffirmAlloc( fileNameInfo );

            RsOptAffirmNtStatus( NtQueryInformationFile( hFile,
                                                         &ioStatusBlock,
                                                         fileNameInfo,
                                                         bufSize,
                                                         FileNameInformation ) );

        } else {

            RsOptAffirmNtStatus( ntStatus );
        }

        pfni = (PFILE_NAME_INFORMATION) fileNameInfo;
        fileNameLength = pfni->FileNameLength / (ULONG)sizeof(WCHAR);
        pfni->FileName[ fileNameLength ] = L'\0';
        m_FileName = pfni->FileName;
        m_FullPath = m_pVolume->GetStickyName( ) + m_FileName;

        //
        // And grab the reparse point data
        //
        BOOL bStatus = DeviceIoControl( hFile,
                                        FSCTL_GET_REPARSE_POINT,
                                        (LPVOID) 0,
                                        (DWORD)  0,
                                        (LPVOID) m_ReparseData,
                                        (DWORD)  sizeof(m_ReparseData),
                                        &actualSize,
                                        (LPOVERLAPPED) 0 );
        RsOptAffirmStatus( bStatus );

    } RsOptCatch( hrRet );

    if( INVALID_HANDLE_VALUE != hFile )    CloseHandle( hFile );
    if( fileNameInfo )                     free( fileNameInfo );

    return( hrRet );
}


CString CRsClnFile::GetFileName( )
{
    CString displayName;

    displayName = m_pVolume->GetBestName( );
    displayName += m_FileName.Mid( 1 ); // Gotta strip first backslash
    
    return( displayName );
}


HRESULT CRsClnFile::ClearReadOnly( )
{
TRACEFNHR( "CRsClnFile::ClearReadOnly" );
    
    try {

        RsOptAffirmStatus(
            SetFileAttributes( m_FullPath,
                               ( m_BasicInfo.FileAttributes & ~FILE_ATTRIBUTE_READONLY ) | FILE_ATTRIBUTE_NORMAL ) );

    } RsOptCatch( hrRet );

    return( hrRet );
}


HRESULT CRsClnFile::RestoreAttributes( )
{
TRACEFNHR( "CRsClnFile::RestoreAttributes" );
    
    try {

        RsOptAffirmStatus(
            SetFileAttributes( m_FullPath,
                               ( m_BasicInfo.FileAttributes & ~FILE_ATTRIBUTE_OFFLINE ) | FILE_ATTRIBUTE_NORMAL ) );

    } RsOptCatch( hrRet );

    return( hrRet );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\shellext\hsmshell.cpp ===
/*++

(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    HSMShell.cpp

Abstract:

    Base file for HSM shell extensions

Author:

    Art Bragg [abragg]   04-Aug-1997

Revision History:

--*/

  
#include "stdafx.h"

CComModule  _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_PrDrive, CPrDrive)
END_OBJECT_MAP()

class CHSMShellApp : public CWinApp
{
public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
};

CHSMShellApp theApp;

BOOL CHSMShellApp::InitInstance()
{
    _Module.Init(ObjectMap, m_hInstance);
    return CWinApp::InitInstance();
}

int CHSMShellApp::ExitInstance()
{
    _Module.Term();
    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    LONG lockCount = _Module.GetLockCount(); // For debugging
    return( lockCount == 0 ) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hr;

    // registers object
    hr = CoInitialize( 0 );

    if (SUCCEEDED(hr)) {
        hr = _Module.RegisterServer( FALSE );
        CoUninitialize( );
    }

    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

    hr = CoInitialize( 0 );

    if (SUCCEEDED(hr)) {
        _Module.UnregisterServer();
        CoUninitialize( );
        hr = S_OK;
    }

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\shellext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by HSMShell.rc
//
#define IDS_PROJNAME                    100
#define IDS_ERR_MINSIZE_RANGE           101
#define IDR_PRDRIVE                     102
#define IDS_PAGETITLE                   103
#define IDS_NO_FSA                      104
#define IDS_NOT_MANAGED                 105
#define IDS_NOT_NTFS                    106
#define IDS_HELPFILEPOPUP               107
#define IDD_PRDRIVE                     201
#define IDD_PRDRIVEX                    202
#define IDI_BLUESAKKARA                 203
#define IDC_EDIT_LEVEL                  205
#define IDC_EDIT_SIZE                   208
#define IDC_EDIT_TIME                   209
#define IDC_STATIC_TOTAL_4DIGIT         210
#define IDC_STATIC_FREE_4DIGIT          211
#define IDC_STATIC_REMOTE_STORAGE_4DIGIT 212
#define IDC_STATIC_CACHED_4DIGIT        213
#define IDC_STATIC_LOCAL_4DIGIT         214
#define IDC_STATIC_LOCAL_PCT            215
#define IDC_STATIC_CACHED_PCT           216
#define IDC_SPIN_LEVEL                  217
#define IDC_SPIN_SIZE                   218
#define IDC_SPIN_TIME                   219
#define IDC_STATIC_FREE_PCT             220
#define IDC_STATIC_ERROR                245
#define IDC_STATIC_STATS_LABEL          246
#define IDC_STATIC_TOTAL_4DIGIT_LABEL   250
#define IDC_STATIC_FREE_4DIGIT_LABEL    251
#define IDC_STATIC_FREE_PCT_UNIT        252
#define IDC_STATIC_CACHED_4DIGIT_LABEL  253
#define IDC_STATIC_LOCAL_4DIGIT_LABEL   254
#define IDC_STATIC_LOCAL_4DIGIT_HELP    255
#define IDC_STATIC_CACHED_PCT_UNIT      256
#define IDC_STATIC_LOCAL_PCT_UNIT       257
#define IDC_EDIT_LEVEL_LABEL            258
#define IDC_EDIT_LEVEL_UNIT             259
#define IDC_EDIT_SIZE_LABEL             260
#define IDC_EDIT_SIZE_UNIT              261
#define IDC_EDIT_TIME_LABEL             262
#define IDC_EDIT_TIME_UNIT              263

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        204
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         264
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsoptcom\rscln\rsclnsrv.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsClnSrv.cpp

Abstract:

    Implementation of CRsClnServer.  This class represents a Remote
    Storage server whose local volumes are to be scanned for Remote
    Storage data and possibly cleaned. Cleaning means removing all
    Remote Storage reparse points truncated files from all local fixed
    disk volumes. CRsClnServer creates one or more instances of
    CRsClnVolume.

Author:

    Carl Hagerstrom [carlh]   20-Aug-1998

Revision History:

--*/

#include <stdafx.h>
#include <ntseapi.h>

/*++

    Implements: 

        CRsClnServer Constructor

    Routine Description: 

        Initializes list of volumes containing Remote Storage data.

--*/

CRsClnServer::CRsClnServer()
{
    TRACEFN("CRsClnServer::CRsClnServer");

    m_head    = (struct dirtyVolume*)0;
    m_tail    = (struct dirtyVolume*)0;
    m_current = (struct dirtyVolume*)0;
}

/*++

    Implements: 

        CRsClnServer Destructor

    Routine Description: 

        Cleans up memory used by list of volumes containging Remote
        Storage data.

--*/

CRsClnServer::~CRsClnServer()
{
    TRACEFN("CRsClnServer::~CRsClnServer");

    RemoveDirtyVolumes();
}

/*++

    Implements: 

        CRsClnServer::ScanServer

    Routine Description: 

        Scans this server for volumes containing Remote Storage data.
        If so, the sticky name and a user friendly name is added to
        a list of such volumes.

    Arguments: 

        volCount - returned: number of volumes containing Remote
                   Storage data

    Return Value:

        S_OK - Success
        HRESULT - Any unexpected exceptions from lower level routines

--*/

HRESULT CRsClnServer::ScanServer(DWORD *volCount)
{
    TRACEFNHR("CRsClnServer::ScanServer");

    WCHAR   stickyName[MAX_STICKY_NAME];
    HANDLE  hScan = 0;
    BOOL    hasData;

    *volCount = 0;
    
    try {    

        for( BOOL firstLoop = TRUE;; firstLoop = FALSE ) {

            if( firstLoop ) {

                hScan = FindFirstVolume(stickyName, sizeof(stickyName));
                RsOptAffirmHandle(hScan);

            } else {

                if( !FindNextVolume(hScan, stickyName, sizeof(stickyName) ) ) {
                    break;
                }
            }

            CRsClnVolume volObj( this, stickyName );

            RsOptAffirmDw( volObj.VolumeHasRsData( &hasData ) );
            if( hasData ) {

                RsOptAffirmDw( AddDirtyVolume( stickyName, (LPTSTR)(LPCTSTR)volObj.GetBestName( ) ) );
                ++(*volCount);

            }
        }
        RsOptAffirmStatus( FindVolumeClose( hScan ) );
    }
    RsOptCatch( hrRet );

    return( hrRet );
}

/*++

    Implements: 

        CRsClnServer::FirstDirtyVolume

    Routine Description: 

        Return the name of the first volume on this server
        containing Remote Storage data.

    Arguments: 

        bestName - returned: user friendly volume name if one exists
                   or the sticky name

    Return Value:

        S_OK - Success
        HRESULT - Any unexpected exceptions from lower level routines

--*/

HRESULT CRsClnServer::FirstDirtyVolume(WCHAR** bestName)
{
    TRACEFNHR("CRsClnServer::FirstDirtyVolume");

    *bestName = (WCHAR*)0;

    m_current = m_head;

    if (m_current)
    {
        *bestName = m_current->bestName;
    }

    return hrRet;
}

/*++

    Implements: 

        CRsClnServer::NextDirtyVolume

    Routine Description: 

        Return the name of the next volume on this server
        containing Remote Storage data.

    Arguments: 

        bestName - returned: user friendly volume name if one exists
                   or the sticky name

    Return Value:

        S_OK - Success
        HRESULT - Any unexpected exceptions from lower level routines

--*/

HRESULT CRsClnServer::NextDirtyVolume(WCHAR** bestName)
{
    TRACEFNHR("CRsClnServer::NextDirtyVolume");

    m_current = m_current->next;

    if( m_current ) {

        *bestName = m_current->bestName;

    } else {

        *bestName = (WCHAR*)0;

    }

    return( hrRet );
}

/*++

    Implements: 

        CRsClnServer::RemoveDirtyVolumes()

    Routine Description: 

        Cleans up memory used by list of volumes containging Remote
        Storage data.

    Return Value:

        S_OK - Success
        HRESULT - Any unexpected exceptions from lower level routines

--*/

HRESULT CRsClnServer::RemoveDirtyVolumes()
{
    TRACEFNHR("CRsClnServer::RemoveDirtyVolumes");

    struct dirtyVolume* p;
    struct dirtyVolume* pnext;

    for( p = m_head; p; p = pnext ) {

        pnext = p->next;
        delete p;
    }

    m_head    = (struct dirtyVolume*)0;
    m_tail    = (struct dirtyVolume*)0;
    m_current = (struct dirtyVolume*)0;

    return( hrRet );
}

/*++

    Implements: 

        CRsClnServer::CleanServer

    Routine Description: 

        For each volume on this server which contains Remote Storage data,
        remove all the Remote Storage reparse points and any truncated files.

     Return Value:

        S_OK - Success
        HRESULT - Any unexpected exceptions from lower level routines

--*/

HRESULT CRsClnServer::CleanServer()
{
    TRACEFNHR("CRsClnServer::CleanServer");

    HANDLE              tokenHandle = 0;

    try {

        // Enable the backup operator privilege.  This is required to insure that we 
        // have full access to all resources on the system.
        TOKEN_PRIVILEGES    newState;
        HANDLE              pHandle;
        LUID                backupValue;
        pHandle = GetCurrentProcess();
        RsOptAffirmStatus( OpenProcessToken( pHandle, MAXIMUM_ALLOWED, &tokenHandle ) );

        // adjust backup token privileges
        RsOptAffirmStatus( LookupPrivilegeValueW( NULL, L"SeBackupPrivilege", &backupValue ) );
        newState.PrivilegeCount = 1;
        newState.Privileges[0].Luid = backupValue;
        newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        RsOptAffirmStatus( AdjustTokenPrivileges( tokenHandle, FALSE, &newState, (DWORD)0, NULL, NULL ) );


        // Do the cleaning
        for( m_current = m_head; m_current; m_current = m_current->next ) {

            CRsClnVolume volObj( this, m_current->stickyName );
            RsOptAffirmDw( volObj.RemoveRsDataFromVolume( ) );

        }

    } RsOptCatch( hrRet );

    if( tokenHandle )   CloseHandle( tokenHandle );

    //
    // And if we had errors on a file, 
    // show them up in a dialog
    //
    if( ! m_ErrorFileList.IsEmpty( ) ) {

        CRsClnErrorFiles dialog( &m_ErrorFileList );
        dialog.DoModal( );

    }

    return( hrRet );
}

/*++

    Implements: 

        CRsClnServer::AddDirtyVolume

    Routine Description: 

        Add the specified volume names to the list of volumes containing
        Remote Storage data.

    Arguments: 

        stickyName - long volume name guaranteed to exist for every volume
        bestName - user friendly volume name or sticky name if there is
                   no DOS drive letter or volume name

    Return Value:

        S_OK - Success
        E_*  - Any unexpected exceptions from lower level routines

--*/

HRESULT CRsClnServer::AddDirtyVolume(WCHAR* stickyName, WCHAR* bestName)
{
    TRACEFNHR("CRsClnServer::AddDirtyVolume");

    try {

        struct dirtyVolume* dv = new struct dirtyVolume;
        RsOptAffirmPointer(dv);

        wcscpy(dv->stickyName, stickyName);
        wcscpy(dv->bestName, bestName);
        dv->next = (struct dirtyVolume*)0;

        if (!m_head)
        {
            m_head = dv;
        }
        else
        {
            m_tail->next = dv;
        }
        m_tail = dv;

    } RsOptCatch( hrRet );

    return( hrRet );
}

/*++

    Implements: 

        CRsClnServer::AddErrorFile

    Routine Description: 

        Add the specified file name to the list of files that an error
        occurred on while trying to remove Remote Storage.

    Arguments: 

        FileName - Name of file to be added to the list

    Return Value:

        S_OK - Success
        E_*  - Any unexpected exceptions from lower level routines

--*/

HRESULT
CRsClnServer::AddErrorFile(
    CString& FileName
    )
{
TRACEFNHR( "CRsClnServer::AddErrorFile" );
TRACE( L"FileName = <%ls>", FileName );

    m_ErrorFileList.AddTail( FileName );

    return( hrRet );
}
/////////////////////////////////////////////////////////////////////////////
// CRsClnErrorFiles dialog


CRsClnErrorFiles::CRsClnErrorFiles(CRsStringList* pFileList)
    : CDialog(CRsClnErrorFiles::IDD)
{
    //{{AFX_DATA_INIT(CRsClnErrorFiles)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    m_ErrorFileList.AddHead( pFileList );
}


void CRsClnErrorFiles::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRsClnErrorFiles)
    DDX_Control(pDX, IDC_FILELIST, m_FileList);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRsClnErrorFiles, CDialog)
    //{{AFX_MSG_MAP(CRsClnErrorFiles)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRsClnErrorFiles message handlers

BOOL CRsClnErrorFiles::OnInitDialog() 
{
    CDialog::OnInitDialog();

    //
    // Need to iterate through the list, adding each element to the listbox
    // and looking for the widest string so that we can set the horizontal
    // extent
    //
    int maxWidth = 0;
    CClientDC DC( &m_FileList );
    CFont* pFont    = m_FileList.GetFont( );
    CFont* pOldFont = DC.SelectObject( pFont );

    while( ! m_ErrorFileList.IsEmpty( ) ) {

        CString fileName = m_ErrorFileList.RemoveHead( );

        m_FileList.AddString( fileName );

        CSize extent = DC.GetTextExtent( fileName );
        if( extent.cx > maxWidth )  maxWidth = extent.cx;

    }
    
    DC.SelectObject( pOldFont );
    m_FileList.SetHorizontalExtent( maxWidth );

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\rsoptcom\rscln\rsclnvol.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RsClnVol.cpp

Abstract:

    Implements CRsClnVolume. This class represents a volume on a Remote
    Storage server which might contain Remote Storage files.  This class
    examines the volume for Remote Storage files and cleans it upon request.
    Cleaning means removing all Remote Storage reparse points and truncated
    files. CRsClnVolume creates zero or more instances of CRsClnFile and is
    created by CRsClnServer.

Author:

    Carl Hagerstrom [carlh]   20-Aug-1998

Revision History:

--*/

#include <stdafx.h>

/*++

    Implements: 

        CRsClnVolume Constructor

    Routine Description: 

        Initializes object.

--*/

CRsClnVolume::CRsClnVolume( CRsClnServer* pServer, WCHAR* StickyName ) :
    m_pServer( pServer ), m_StickyName( StickyName )
{
    TRACEFN("CRsClnVolume::CRsClnVolume");

    memset((void *)m_fsName,     0, sizeof(m_fsName));
    memset((void *)m_bestName,   0, sizeof(m_bestName));
    memset((void *)m_volumeName, 0, sizeof(m_volumeName));
    memset((void *)m_dosName,    0, sizeof(m_dosName));


    m_fsFlags = 0;
    m_hRpi    = INVALID_HANDLE_VALUE;
    m_hVolume = INVALID_HANDLE_VALUE;
}

/*++

    Implements: 

        CRsClnVolume Destructor

--*/

CRsClnVolume::~CRsClnVolume()
{
    TRACEFN("CRsClnVolume::~CRsClnVolume");

    if( INVALID_HANDLE_VALUE != m_hVolume )     CloseHandle( m_hVolume );
}

/*++

    Implements: 

        CRsClnVolume::VolumeHasRsData

    Routine Description: 

        Determines whether this volume contains Remote Storage data.

        If this volume is on a fixed local disk, and it is an
        NTFS volume which supports reparse points and sparce
        files, and it has at least one Remote Storage reparse point,
        it contains Remote Storage data.

    Arguments: 

        hasData - returned: whether volume contains Remote
                  Storage data

    Return Value:

        S_OK - Success
        HRESULT - Any unexpected exceptions from lower level routines

--*/

HRESULT CRsClnVolume::VolumeHasRsData(BOOL *hasData)
{
    TRACEFNHR("CRsClnVolume::VolumeHasRsData");

    LONGLONG fileReference;
    BOOL     foundOne;

    *hasData = FALSE;

    try {

        if( DRIVE_FIXED == GetDriveType( m_StickyName ) ) {

            RsOptAffirmDw( GetVolumeInfo( ) );

            if( _wcsicmp( m_fsName, L"NTFS" ) == 0 &&
                m_fsFlags & FILE_SUPPORTS_REPARSE_POINTS &&
                m_fsFlags & FILE_SUPPORTS_SPARSE_FILES ) {

                RsOptAffirmDw( FirstRsReparsePoint( &fileReference, &foundOne ) );

                if( foundOne ) {

                    *hasData = TRUE;

                }
            }
        }
    }
    RsOptCatch( hrRet );

    return hrRet;
}

/*++

    Implements: 

        CRsClnVolume::GetBestName

    Routine Description: 

        Returns the best user friendly name for this volume.  The best
        name is either the DOS drive letter if one exists, the user
        assigned volume name if one exists, or the sticky name which
        always exists.

    Arguments: 

        bestName - returned: user friendly volume name

    Return Value:

        S_OK - Success
        HRESULT - Any unexpected exceptions from lower level routines

--*/

CString CRsClnVolume::GetBestName( )
{
    TRACEFNHR("CRsClnVolume::GetBestName");

    return( m_bestName );
}

/*++

    Implements: 

        CRsClnVolume::RemoveRsDataFromVolume

    Routine Description: 

        Removes all Remote Storage data from this volume.

        - Opens this volume using the sticky name.
        - Enumerates each file in the reparse point index
          with a Remote Storage reparse point. In the reparse
          index, each file is represented by a number called the
          file reference.
        - Removes the reparse point and the file if it is
          truncated.

    Arguments: 


    Return Value:

        S_OK - Success
        HRESULT - Any unexpected exceptions from lower level routines

--*/

HRESULT CRsClnVolume::RemoveRsDataFromVolume( )
{
    TRACEFNHR("CRsClnVolume::RemoveRsDataFromVolume");

    LONGLONG fileReference;
    BOOL     foundOne;

    try
    {
        RsOptAffirmDw( GetVolumeInfo( ) );

        for( BOOL firstLoop = TRUE;; firstLoop = FALSE ) {

            if( firstLoop ) {

                RsOptAffirmDw( FirstRsReparsePoint( &fileReference, &foundOne ) );

            } else {

                RsOptAffirmDw( NextRsReparsePoint( &fileReference, &foundOne ) );
            }

            if( !foundOne ) {

                break;
            }

            //
            // Just in case something strange happens in removing reparse
            // point or such, wrap in its own try block
            //
            HRESULT hrRemove = S_OK;
            try {

                CRsClnFile fileObj( this, fileReference );

                if( FAILED( fileObj.RemoveReparsePointAndFile( ) ) ) {

                    m_pServer->AddErrorFile( fileObj.GetFileName( ) );

                }

            } RsOptCatch( hrRemove );
            // Do not affirm hrRemove - we don't want to stop on an error

        }

    } RsOptCatch( hrRet );

    return( hrRet );
}

/*++

    Implements: 

        CRsClnVolume::GetVolumeInfo

    Routine Description: 

        Load information about this volume.

        - Get the sticky name and the user assigned volume name,
          if one exists.
        - See if there is a DOS drive letter for this volume.
          For each possible drive letter, see if it represents
          a volume whose sticky name matches this volume.
        - Choose the best user friendly volume name according
          to the following precedence: DOS drive letter, user
          assigned volume name, sticky name.

    Arguments: 


    Return Value:

        S_OK - Success
        HRESULT - Any unexpected exceptions from lower level routines

--*/

HRESULT CRsClnVolume::GetVolumeInfo( )
{
    TRACEFNHR("CRsClnVolume::GetVolumeInfo");

    WCHAR   dosName[MAX_DOS_NAME];
    WCHAR   stickyName2[MAX_STICKY_NAME];
    DWORD   volumeSerial;
    DWORD   maxCompLen;
    BOOL    bStatus;

    try {

        bStatus = GetVolumeInformation( m_StickyName,
                                       m_volumeName,
                                       sizeof(m_volumeName),
                                       &volumeSerial,
                                       &maxCompLen,
                                       &m_fsFlags,
                                       m_fsName,
                                       sizeof(m_fsName));
        RsOptAffirmStatus(bStatus);

        for (wcscpy(dosName, L"A:\\"); dosName[0] <= L'Z'; ++(dosName[0]))
        {
            if (GetVolumeNameForVolumeMountPoint(dosName,
                                                 stickyName2,
                                                 sizeof(stickyName2)))
            {
                if( m_StickyName.CompareNoCase( stickyName2 ) == 0 )
                {
                    wcscpy(m_dosName, dosName);
                    break;
                }
            }
        }

        if (*m_dosName != L'\0')
        {
            wcscpy(m_bestName, m_dosName);
        }
        else if (*m_volumeName != L'\0')
        {
            wcscpy(m_bestName, m_volumeName);
        }
        else
        {
            wcscpy(m_bestName, m_StickyName);
        }

        m_hVolume = CreateFile( m_StickyName.Left( m_StickyName.GetLength() - 1 ),
                                GENERIC_READ,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                (LPSECURITY_ATTRIBUTES)0,
                                OPEN_EXISTING,
                                (DWORD)0,
                                (HANDLE)0 );
        RsOptAffirmHandle( m_hVolume );

    }
    RsOptCatch(hrRet);

    return hrRet;
}

/*++

    Implements: 

        CRsClnVolume::FirstRsReparsePoint

    Routine Description: 

        Returns the file reference of the first file in the
        reparse point index which contains a Remote Storage
        reparse point, if one exists.

        - Construct the name of the reparse point index from
          the sticky name.
        - Open the index.
        - Read the first entry. If it is a Remote Storage
          entry, return it. Otherwise, try the next one.

    Arguments: 

        stickyName - long volume name
        fileReference - returned: file reference from first
                        Remote Storage reparse index entry.
                        The file reference is a number which
                        can be used to open a file.
        foundOne - returned: TRUE if there is at least one
                   Remote Storage reparse point

    Return Value:

        S_OK - Success
        HRESULT - Any unexpected exceptions from lower level routines

--*/

HRESULT CRsClnVolume::FirstRsReparsePoint(
    LONGLONG* fileReference,
    BOOL*     foundOne)
{
    TRACEFNHR("CRsClnVolume::FirstRsReparsePoint");

    NTSTATUS                       ntStatus;
    IO_STATUS_BLOCK                ioStatusBlock;
    FILE_REPARSE_POINT_INFORMATION reparsePointInfo;

    WCHAR rpiSuffix[] = L"\\$Extend\\$Reparse:$R:$INDEX_ALLOCATION";
    WCHAR rpiName[MAX_STICKY_NAME + (sizeof(rpiSuffix) / sizeof(WCHAR))];

    wcscpy(rpiName, m_StickyName);
    wcscat(rpiName, rpiSuffix);

    *foundOne = FALSE;

    try
    {
        m_hRpi = CreateFile(rpiName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            (LPSECURITY_ATTRIBUTES)0,
                            OPEN_EXISTING,
                            FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
                            (HANDLE)0);

        if (m_hRpi != INVALID_HANDLE_VALUE)
        {
            ntStatus = NtQueryDirectoryFile(m_hRpi,
                                            (HANDLE)0,
                                            (PIO_APC_ROUTINE)0,
                                            (PVOID)0,
                                            &ioStatusBlock,
                                            &reparsePointInfo,
                                            sizeof(reparsePointInfo),
                                            FileReparsePointInformation, 
                                            TRUE,
                                            (PUNICODE_STRING)0,
                                            TRUE);

            if (ntStatus == STATUS_NO_MORE_FILES)
            {
                RsOptAffirmStatus(CloseHandle(m_hRpi));
            }
            else
            {
                RsOptAffirmNtStatus(ntStatus);

                if (reparsePointInfo.Tag == IO_REPARSE_TAG_HSM)
                {
                    *fileReference = reparsePointInfo.FileReference;
                    *foundOne = TRUE;
                }
                else
                {
                    RsOptAffirmDw(NextRsReparsePoint(fileReference, foundOne));
                }
            }
        }
    }
    RsOptCatch(hrRet);

    return hrRet;
}

/*++

    Implements: 

        CRsClnVolume::NextRsReparsePoint

    Routine Description: 

        Continue searching the reparse point index on this volume and
        return the file reference for the next Remote Storage reparse
        point.

    Arguments: 

        fileReference - returned: file reference from first
                        Remote Storage reparse index entry.
                        The file reference is a number which
                        can be used to open a file.
        foundOne - returned: FALSE if there are no more Remote
                   Storage reparse points

    Return Value:

        S_OK - Success
        HRESULT - Any unexpected exceptions from lower level routines

--*/

HRESULT CRsClnVolume::NextRsReparsePoint(
    LONGLONG* fileReference,
    BOOL*     foundOne)
{
    TRACEFNHR("CRsClnVolume::NextRsReparsePoint");

    NTSTATUS                       ntStatus;
    IO_STATUS_BLOCK                ioStatusBlock;
    FILE_REPARSE_POINT_INFORMATION reparsePointInfo;

    *foundOne = FALSE;

    try
    {
        for (;;)
        {
            ntStatus = NtQueryDirectoryFile(m_hRpi,
                                            (HANDLE)0,
                                            (PIO_APC_ROUTINE)0,
                                            (PVOID)0,
                                            &ioStatusBlock,
                                            &reparsePointInfo,
                                            sizeof(reparsePointInfo),
                                            FileReparsePointInformation, 
                                            TRUE,
                                            (PUNICODE_STRING)0,
                                            FALSE);

            if (ntStatus == STATUS_NO_MORE_FILES)
            {
                RsOptAffirmStatus(CloseHandle(m_hRpi));
                break;
            }
            else
            {
                RsOptAffirmNtStatus(ntStatus);

                if (reparsePointInfo.Tag == IO_REPARSE_TAG_HSM)
                {
                    *fileReference = reparsePointInfo.FileReference;
                    *foundOne = TRUE;
                    break;
                }
            }
        }
    }
    RsOptCatch(hrRet);

    return hrRet;
}

/*++

    Implements: 

        CRsClnVolume::GetHandle

    Routine Description: 

        Returns a handle to the volume.

    Arguments: 


    Return Value:

        Volume HANDLE

--*/

HANDLE CRsClnVolume::GetHandle( )
{
    return( m_hVolume );
}

/*++

    Implements: 

        CRsClnVolume::GetStickyName

    Routine Description: 

        Returns the sticky name of the volume.

    Arguments: 


    Return Value:

        Volume sticky name

--*/

CString CRsClnVolume::GetStickyName( )
{
    return( m_StickyName );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\shellext\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=gui
MINORCOMP=ShellExt

INCLUDES=$(BASEP_HSM_DIR)\inc;$(BASEP_HSM_DIR)\inc\$(O);..;..\$(O);..\PropPage;..\..\inc

C_DEFINES=$(C_DEFINES)

UMTYPE=windows

USE_NATIVE_EH=1

#USE_MSVCRT40=1
USE_MFCUNICODE=1
MFC_USRDLL=1
MFC_VER=42
USE_ATL=1

MIDL_UUIDDIR=$(O)
PASS0_SOURCEDIR=$(O)
PASS0_HEADERDIR=..\$(O)
MIDL_TLBDIR=$(O)

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_OBJ=precomp.obj
PRECOMPILED_PCH=precomp.pch
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\shellext\stdafx.h ===
/*++

(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    StdAfx.h

Abstract:

    Base include file

Author:

    Art Bragg [abragg]   04-Aug-1997

Revision History:

--*/


#ifndef STDAFX_H
#define STDAFX_H

#pragma once

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcmn.h>         // MFC support for Windows Common Controls
#include <afxdisp.h>
#include <shlobj.h>
#define WSB_TRACE_IS        WSB_TRACE_BIT_UI
#include "wsb.h"
#include "Fsa.h"                    // Fsa interface
#include "HSMConn.h"
#include "RsUtil.h"

#include "resource.h"
#include "hsmshell.h"
#include "PrDrive.h"

#define HSMADMIN_MIN_MINSIZE        2
#define HSMADMIN_MAX_MINSIZE        32000

#define HSMADMIN_MIN_FREESPACE      0
#define HSMADMIN_MAX_FREESPACE      99

#define HSMADMIN_MIN_INACTIVITY     0
#define HSMADMIN_MAX_INACTIVITY     999

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\shellext\dll\makefile.inc ===
$(O)\hsmshell.res: ..\res\nodehsma.ico    \
                   ..\res\prdrive.rgs      

$(O)\hsmshell_i.c: ..\$(O)\hsmshell_i.c
    copy ..\$(O)\hsmshell_i.c $(O)\.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\shellext\stdafx.cpp ===
/*++

(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    StdAfx.cpp

Abstract:

    grab implementations for ATL and such

Author:

    Art Bragg [abragg]   04-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#pragma warning(4:4701)
#include <atlimpl.cpp>
#pragma warning(3:4701)

#include "RsUtil.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\hsmconn\makefile.inc ===
clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\utility\stdafx.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    StdAfx.h

Abstract:

    Precompiled header starting point

Author:

    Rohde Wakefield [rohde]   09-Oct-1997

Revision History:

--*/

#ifndef _STDAFX_H
#define _STDAFX_H

#pragma once

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcmn.h>         // MFC support for Windows Common Controls


#endif // !defined(_STDAFX_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\shellext\proppage\prdrive.cpp ===
/*++

(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    PrDrive.cpp

Abstract:

    Base file for HSM shell extensions on drives

Author:

    Art Bragg [abragg]   04-Aug-1997

Revision History:

--*/


#include "stdafx.h"
#include "rshelpid.h"

//#define RS_SHOW_ALL_PCTS

// Help Ids
#define RS_WINDIR_SIZE (2*MAX_PATH)
static DWORD pHelpIds[] = 
{
#ifdef RS_SHOW_ALL_PCTS
    IDC_STATIC_LOCAL_PCT,                       idh_volume_percent_local_data,
    IDC_STATIC_LOCAL_PCT_UNIT,                  idh_volume_percent_local_data,
#endif
    IDC_STATIC_LOCAL_4DIGIT,                    idh_volume_capacity_local_data,
    IDC_STATIC_LOCAL_4DIGIT_LABEL,              idh_volume_capacity_local_data,
    IDC_STATIC_LOCAL_4DIGIT_HELP,               idh_volume_capacity_local_data,
#ifdef RS_SHOW_ALL_PCTS
    IDC_STATIC_CACHED_PCT,                      idh_volume_percent_remote_data_cached,
    IDC_STATIC_CACHED_PCT_UNIT,                 idh_volume_percent_remote_data_cached,
#endif
    IDC_STATIC_CACHED_4DIGIT,                   idh_volume_capacity_remote_data_cached,
    IDC_STATIC_CACHED_4DIGIT_LABEL,             idh_volume_capacity_remote_data_cached,
    IDC_STATIC_FREE_PCT,                        idh_volume_percent_free_space,
    IDC_STATIC_FREE_PCT_UNIT,                   idh_volume_percent_free_space,
    IDC_STATIC_FREE_4DIGIT,                     idh_volume_capacity_free_space,
    IDC_STATIC_FREE_4DIGIT_LABEL,               idh_volume_capacity_free_space,
    IDC_STATIC_TOTAL_4DIGIT,                    idh_volume_disk_capacity,
    IDC_STATIC_TOTAL_4DIGIT_LABEL,              idh_volume_disk_capacity,
    IDC_STATIC_REMOTE_STORAGE_4DIGIT,           idh_volume_data_remote_storage,
    IDC_STATIC_STATS_LABEL,                     idh_volume_data_remote_storage,

    IDC_EDIT_LEVEL,                             idh_desired_free_space_percent,
    IDC_SPIN_LEVEL,                             idh_desired_free_space_percent,
    IDC_EDIT_LEVEL_LABEL,                       idh_desired_free_space_percent,
    IDC_EDIT_LEVEL_UNIT,                        idh_desired_free_space_percent,
    IDC_EDIT_SIZE,                              idh_min_file_size_criteria,
    IDC_SPIN_SIZE,                              idh_min_file_size_criteria,
    IDC_EDIT_SIZE_LABEL,                        idh_min_file_size_criteria,
    IDC_EDIT_SIZE_UNIT,                         idh_min_file_size_criteria,
    IDC_EDIT_TIME,                              idh_file_access_date_criteria,
    IDC_SPIN_TIME,                              idh_file_access_date_criteria,
    IDC_EDIT_TIME_LABEL,                        idh_file_access_date_criteria,
    IDC_EDIT_TIME_UNIT,                         idh_file_access_date_criteria,

    0, 0
};

/////////////////////////////////////////////////////////////////////////////
// CPrDrive

// IShellExtInit
STDMETHODIMP 
CPrDrive::Initialize( 
    LPCITEMIDLIST /*pidlFolder*/,
    IDataObject * pDataObj, 
    HKEY /*hkeyProgID*/
    )
{
    //
    // Initialize can be called more than once
    //
    m_pDataObj.Release(  );

    //
    // duplicate the object pointer
    //
    m_pDataObj = pDataObj;

    return( NOERROR );
}

//////////////////////////////////////////////////////////////////////////////
//
// AddPages
//
//
STDMETHODIMP CPrDrive::AddPages( 
    LPFNADDPROPSHEETPAGE lpfnAddPage, 
    LPARAM lParam
    )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState(  ) );
    HRESULT hr = S_OK;

    HPROPSHEETPAGE hPage = NULL; // Windows property page handle
    TCHAR szFileSystemName [256];
    TCHAR szDrive [MAX_PATH];
    int nState;
    CComPtr<IFsaResource> pFsaRes;

    FORMATETC fmte = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    STGMEDIUM medium;
    CPrDrivePg  * pPageDrive  = 0;
    CPrDriveXPg * pPageXDrive = 0;

    try {
        //
        // Find out how many files the user has selected...
        //
        UINT cbFiles = 0;
        BOOL bMountedVol = FALSE;
        WsbAssertPointer( m_pDataObj );  //Paranoid check, m_pDataObj should have something by now...
        hr = m_pDataObj->GetData( &fmte, &medium ) ; // Returns hr

        if (FAILED(hr)) {
            //
            // Isn't a normal volume name. Maybe it's a mounted volume.
            // Mounted volume names come in on a different clipboard format
            // so we can treat them differently from normal volume
            // names like "C:\".  A mounted volume name will be the path
            // to the folder hosting the mounted volume.
            // For mounted volumes, the DataObject provides CF "MountedVolume".
            //
            fmte.cfFormat = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_MOUNTEDVOLUME);
            WsbAffirmHr(m_pDataObj->GetData(&fmte, &medium));
            bMountedVol = TRUE;
        }

        cbFiles = DragQueryFile( ( HDROP )medium.hGlobal,( UINT )-1, NULL, 0 );

        if( 1 == cbFiles ) {

            //
            // Do we have admin privileges?
            //
            if( SUCCEEDED( WsbCheckAccess( WSB_ACCESS_TYPE_ADMINISTRATOR ) ) ) {

                //
                //OK, the user has only selected a single file, so lets go ahead
                //and get more information
                //
                //Get the name of the file the user has clicked on
                //
                DragQueryFile( (HDROP)medium.hGlobal, 
                              0, (USHORT *)szDrive,
                              sizeof( szDrive ) );

                //
                // Is this a local drive? 
                //
                if( ( GetDriveType( szDrive ) )!= DRIVE_REMOTE ) {

                    //
                    // Is this an NTFS drive?
                    //
                    GetVolumeInformation( 
                                        szDrive,
                                        NULL,
                                        0,
                                        NULL, // Serial Number
                                        NULL, // Filename length
                                        NULL, // flags
                                        szFileSystemName,
                                        256 );
                    if( wcscmp( szFileSystemName, L"NTFS" ) == 0 ) {

                        //
                        // Make sure the Fsa is running - if not do not do anything that
                        // could cause it to load.
                        //
                        if( WsbCheckService( NULL, APPID_RemoteStorageFileSystemAgent ) == S_OK ) {

                            //
                            // Try to get the FSA object for the drive.  If we fail, we don't
                            // put up the property page.
                            //
                            CWsbStringPtr computerName;

                            WsbAffirmHr( WsbGetComputerName( computerName ) );

                            CString szFullResName = computerName;
                            CString szResName = szDrive;
                            //
                            // If a drive letter is present, the format to connect is:
                            // <computer-name>\NTFS\<drive-letter>, no trailing '\' or ':'
                            // i.e. RAVI\NTFS\D
                            // If it's a sticky vol. name however the format is:
                            // <computer-name>\NTFS\<volume-name>\ (WITH the trailing '\'
                            // i.e. RAVI\NTFS\Volume{445a4110-60aa-11d3-0060b0ededdb\
                            //
                            if (bMountedVol) {
                                //
                                // Remove the leading \\?\
                                //
                                szResName = szResName.Right(szResName.GetLength() - 4);
                                szFullResName = szFullResName + "\\" + "NTFS" + "\\" + szResName;
                            } else {
                                szFullResName = szFullResName + "\\" + "NTFS" + "\\" + szDrive;                       
                                //
                                // Remove trailing \ and or :
                                //
                                if( szFullResName [szFullResName.GetLength()- 1] == '\\' ) {
                                     szFullResName = szFullResName.Left( szFullResName.GetLength(  ) - 1 );
                                }

                                if( szFullResName [szFullResName.GetLength(  )- 1] == ':' ) {
                                    szFullResName = szFullResName.Left( szFullResName.GetLength(  ) - 1 );
                                }
                            }

                            if( HsmConnectFromName( HSMCONN_TYPE_RESOURCE, szFullResName, IID_IFsaResource,( void** )&pFsaRes ) == S_OK ) {

                                //
                                // Connected to Hsm
                                // Is the resource managed?
                                //
                                if( pFsaRes->IsManaged(  ) == S_OK ) {

                                    nState = MANAGED;

                                } else {

                                    nState = NOT_MANAGED;

                                }

                            } else {

                                //
                                // Couldn't connect to Fsa
                                //
                                nState = NO_FSA;

                            }

                        } else {

                            //
                            // Fsa is not running
                            //
                            nState = NO_FSA;

                        }

                    } else {

                        nState = NOT_NTFS;

                    }

                } else {

                    //
                    // Remote volume
                    //
                    nState = REMOTE;
                }

            } else {

                nState = NOT_ADMIN;

            }

        } else {

            nState = MULTI_SELECT;

        }

        //
        // For Not admin, Remote and Multi-Select, we don't even show the page
        //
        switch( nState ) {
        
        case NOT_NTFS:
        case NOT_ADMIN:
        case REMOTE:
        case MULTI_SELECT:
            //
            // For Not admin, Remote and Multi-Select, we don't even show the page
            //
            break;

        case MANAGED:
            {
                /////////////////////////////////////////////////////////////
                // Create the property page

                WsbAssertPointer( pFsaRes );

                //
                // Create the Drive property page.
                //
                pPageDrive = new CPrDrivePg(  );
                WsbAffirmPointer( pPageDrive );

                //
                // Assign the Fsa object to the page
                //
                pPageDrive->m_pFsaResource = pFsaRes;

                //
                // Set the state
                //
                pPageDrive->m_nState = nState;

                hPage = CreatePropertySheetPage( &pPageDrive->m_psp );
                WsbAffirmHandle( hPage );

                //
                // Call the callback function with the handle to the new
                // page
                //
                WsbAffirm( lpfnAddPage( hPage, lParam ), E_UNEXPECTED );
                break;
            }

        default:
            {
                /////////////////////////////////////////////////////////////
                // Create the property page
                pPageXDrive = new CPrDriveXPg(  );
                WsbAffirmPointer( pPageXDrive );

                //
                // Set the state
                //
                pPageXDrive->m_nState = nState;
                hPage = CreatePropertySheetPage( &pPageXDrive->m_psp );
                WsbAffirmHandle( hPage );

                // Call the callback function with the handle to the new
                // page
                WsbAffirm( lpfnAddPage( hPage, lParam ), E_UNEXPECTED );
            }
        }

    } WsbCatchAndDo( hr,
             
        if( pPageDrive )  delete pPageDrive;
        if( pPageXDrive ) delete pPageXDrive;
    );

    return( hr );
}

//
//  FUNCTION: CPrDrive::ReplacePage( UINT, LPFNADDPROPSHEETPAGE, LPARAM )
//
//  PURPOSE: Called by the shell only for Control Panel property sheet 
//           extensions
//
//  PARAMETERS:
//    uPageID         -  ID of page to be replaced
//    lpfnReplaceWith -  Pointer to the Shell's Replace function
//    lParam          -  Passed as second parameter to lpfnReplaceWith
//
//  RETURN VALUE:
//
//    E_FAIL, since we don't support this function.  It should never be
//    called.

//  COMMENTS:
//

STDMETHODIMP 
CPrDrive::ReplacePage( 
    UINT /*uPageID*/, 
    LPFNADDPROPSHEETPAGE /*lpfnReplaceWith*/, 
    LPARAM /*lParam*/
    )
{
    return( E_FAIL );
}

/////////////////////////////////////////////////////////////////////////////
// CPrDrivePg property page

CPrDrivePg::CPrDrivePg(  ): CPropertyPage( CPrDrivePg::IDD )
{
    //{{AFX_DATA_INIT( CPrDrivePg )
    m_accessTime = 0;
    m_hsmLevel = 0;
    m_fileSize = 0;
    //}}AFX_DATA_INIT

    //
    // Lock the module while this object lives.
    // Otherwise, modules can call CoFreeUnusedLibraries( )
    // and cause us to unload before our page gets destroyed,
    // which causes an AV in the common control.
    //
    _Module.Lock( );

    //
    // initialize state
    //
    m_nState       = NO_STATE;

    //
    // Get and save the MFC callback function.
    // This is so we can delete the class the dialog never gets created.
    //
    m_pMfcCallback = m_psp.pfnCallback;

    //
    // Set the call back to our callback
    //
    m_psp.pfnCallback = PropPageCallback;

}

CPrDrivePg::~CPrDrivePg(  )
{
    _Module.Unlock( );
}

void CPrDrivePg::DoDataExchange( CDataExchange* pDX )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState(  ) );

    CPropertyPage::DoDataExchange( pDX );
    //{{AFX_DATA_MAP( CPrDrivePg )
    DDX_Control( pDX, IDC_EDIT_SIZE, m_editSize );
    DDX_Control( pDX, IDC_EDIT_LEVEL, m_editLevel );
    DDX_Control( pDX, IDC_EDIT_TIME, m_editTime );
    DDX_Control( pDX, IDC_SPIN_TIME, m_spinTime );
    DDX_Control( pDX, IDC_SPIN_SIZE, m_spinSize );
    DDX_Control( pDX, IDC_SPIN_LEVEL, m_spinLevel );
    DDX_Text( pDX, IDC_EDIT_TIME, m_accessTime );
    DDV_MinMaxUInt( pDX, m_accessTime, HSMADMIN_MIN_INACTIVITY, HSMADMIN_MAX_INACTIVITY );
    DDX_Text( pDX, IDC_EDIT_LEVEL, m_hsmLevel );
    DDV_MinMaxUInt( pDX, m_hsmLevel, HSMADMIN_MIN_FREESPACE, HSMADMIN_MAX_FREESPACE );
    DDX_Text( pDX, IDC_EDIT_SIZE, m_fileSize );
    //}}AFX_DATA_MAP

    //
    // Since we limit the number of characters in the buddy edits, we 
    // don't expect the previous two DDV's to ever really kick in. 
    // However, it is possible to enter bad minumum size since both
    // '0' and '1' can be entered, but are not in the valid range.
    //

    //
    // Code is equivalent to:
    // DDV_MinMaxDWord( pDX, m_fileSize, HSMADMIN_MIN_MINSIZE, HSMADMIN_MAX_MINSIZE );
    //

    if( pDX->m_bSaveAndValidate &&
      ( m_fileSize < HSMADMIN_MIN_MINSIZE ||
        m_fileSize > HSMADMIN_MAX_MINSIZE ) ) {

        CString message;
        AfxFormatString2( message, IDS_ERR_MINSIZE_RANGE, 
            CString( WsbLongAsString( (LONG)HSMADMIN_MIN_MINSIZE ) ),
            CString( WsbLongAsString( (LONG)HSMADMIN_MAX_MINSIZE ) ) );
        AfxMessageBox( message, MB_OK | MB_ICONWARNING );
        pDX->Fail();

    }

}


BEGIN_MESSAGE_MAP( CPrDrivePg, CPropertyPage )
//{{AFX_MSG_MAP( CPrDrivePg )
ON_EN_CHANGE( IDC_EDIT_TIME, OnChangeEditAccess )
ON_EN_CHANGE( IDC_EDIT_LEVEL, OnChangeEditLevel )
ON_EN_CHANGE( IDC_EDIT_SIZE, OnChangeEditSize )
ON_WM_DESTROY(  )
	ON_WM_CONTEXTMENU()
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP(  )

/////////////////////////////////////////////////////////////////////////////
// CPrDrivePg message handlers

BOOL CPrDrivePg::OnInitDialog(  )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState(  ) );

    HRESULT         hr = S_OK;

    LONGLONG total = 0;
    LONGLONG free = 0;
    LONGLONG premigrated = 0;
    LONGLONG truncated = 0;
    LONGLONG remoteStorage = 0;
    ULONG totalMB = 0;
    ULONG freeMB = 0;
    ULONG premigratedMB = 0;
    ULONG truncatedMB = 0;
    CString sFormat;
    CString sBufFormat;


    CPropertyPage::OnInitDialog(  );

    try {

        WsbAffirmPointer( m_pFsaResource );

        //
        // Set the spinner ranges
        //
        m_spinTime.SetRange( HSMADMIN_MIN_INACTIVITY, HSMADMIN_MAX_INACTIVITY );
        m_spinSize.SetRange( HSMADMIN_MIN_MINSIZE, HSMADMIN_MAX_MINSIZE );
        m_spinLevel.SetRange( HSMADMIN_MIN_FREESPACE, HSMADMIN_MAX_FREESPACE );

        //
        // Set text limits
        //
        m_editTime.SetLimitText( 3 );
        m_editSize.SetLimitText( 5 );
        m_editLevel.SetLimitText( 2 );


        //
        // Get statistics
        //
        WsbAffirmHr( m_pFsaResource->GetSizes( &total, &free, &premigrated, &truncated ) );

        //
        // "Local" data
        //
        LONGLONG local = max( ( total - free - premigrated ),( LONGLONG )0 );

        //
        // Calculate percents
        //
        int freePct;
        int premigratedPct;
        if( 0 == total ) {

            freePct = 0;
            premigratedPct = 0;

        } else {

            freePct        = (int)( ( free * 100 )/ total );
            premigratedPct = (int)( ( premigrated * 100 )/ total );

        }

        int localPct = 100 - freePct - premigratedPct;
        remoteStorage = premigrated + truncated;

        //
        // Show the statistics in 4-char format
        //
        RsGuiFormatLongLong4Char( local, sBufFormat );
        SetDlgItemText( IDC_STATIC_LOCAL_4DIGIT, sBufFormat );

        RsGuiFormatLongLong4Char( premigrated, sBufFormat );
        SetDlgItemText( IDC_STATIC_CACHED_4DIGIT, sBufFormat );

        RsGuiFormatLongLong4Char( free, sBufFormat );
        SetDlgItemText( IDC_STATIC_FREE_4DIGIT, sBufFormat );

        RsGuiFormatLongLong4Char( total, sBufFormat );
        SetDlgItemText( IDC_STATIC_TOTAL_4DIGIT, sBufFormat );

        RsGuiFormatLongLong4Char( remoteStorage, sBufFormat );
        SetDlgItemText( IDC_STATIC_REMOTE_STORAGE_4DIGIT, sBufFormat );

        //
        // Show Percents
        //
#ifdef RS_SHOW_ALL_PCTS
        sFormat.Format( L"%d", localPct );
        SetDlgItemText( IDC_STATIC_LOCAL_PCT, sFormat );

        sFormat.Format( L"%d", premigratedPct );
        SetDlgItemText( IDC_STATIC_CACHED_PCT, sFormat );
#endif

        sFormat.Format( L"%d", freePct );
        SetDlgItemText( IDC_STATIC_FREE_PCT, sFormat );

        //
        // Get levels
        //
        ULONG       hsmLevel = 0;
        LONGLONG    fileSize = 0;
        BOOL        isRelative = TRUE; // assumed to be TRUE
        FILETIME    accessTime;

        WsbAffirmHr( m_pFsaResource->GetHsmLevel( &hsmLevel ) );
        m_hsmLevel = hsmLevel / FSA_HSMLEVEL_1;
        WsbAffirmHr( m_pFsaResource->GetManageableItemLogicalSize( &fileSize ) );
        m_fileSize = (DWORD)(fileSize / 1024);  // Show KBytes
        WsbAffirmHr( m_pFsaResource->GetManageableItemAccessTime( &isRelative, &accessTime ) );
        WsbAssert( isRelative, E_FAIL );  // We only do relative time
        // Convert FILETIME to days
        m_accessTime = (UINT)( WsbFTtoLL( accessTime ) / WSB_FT_TICKS_PER_DAY );
        if(m_accessTime > HSMADMIN_MAX_INACTIVITY ) {

            m_accessTime = HSMADMIN_MAX_INACTIVITY;

        }

        UpdateData( FALSE );

        // Get help file name
        CString helpFile;
        helpFile.LoadString(IDS_HELPFILEPOPUP);

        CWsbStringPtr winDir;
        WsbAffirmHr( winDir.Alloc( RS_WINDIR_SIZE ) );
        WsbAffirmStatus( ::GetWindowsDirectory( (WCHAR*)winDir, RS_WINDIR_SIZE ) != 0 );

        m_pszHelpFilePath = CString(winDir) + L"\\help\\" + helpFile;

    } WsbCatch( hr )

    return( TRUE );
}

void CPrDrivePg::OnChangeEditAccess(  )
{
    SetModified(  );  
}

void CPrDrivePg::OnChangeEditLevel(  )
{
    SetModified(  );  
}

void CPrDrivePg::OnChangeEditSize(  )
{
    SetModified(  );  
}

BOOL CPrDrivePg::OnApply(  )
{
    HRESULT hr;

    try {

        //
        // m_pFsaResource is NULL if we didn't show any properties, in which case there is nothing
        // to apply.. Note that apply may have been enabled by another page in the sheet.
        //
        if( m_pFsaResource ) {
            LONGLONG    fileSize = 0;

            UpdateData( TRUE );
            WsbAffirmHr( m_pFsaResource->SetHsmLevel( m_hsmLevel * FSA_HSMLEVEL_1 ) );
            fileSize = ((LONGLONG)m_fileSize) * 1024;
            WsbAffirmHr( m_pFsaResource->SetManageableItemLogicalSize( fileSize ) );

            //
            // Convert days to FILETIME
            //
            FILETIME accessTime;
            accessTime = WsbLLtoFT( ( LONGLONG )m_accessTime * WSB_FT_TICKS_PER_DAY );
            WsbAffirmHr( m_pFsaResource->SetManageableItemAccessTime( TRUE, accessTime ) );

        }

    } WsbCatch( hr );

    return( CPropertyPage::OnApply(  ) );
}

UINT CALLBACK
CPrDrivePg::PropPageCallback(
    HWND hWnd,
    UINT uMessage,
    LPPROPSHEETPAGE  ppsp )
{

    UINT rVal = 0;
    HRESULT hr = S_OK;
    try {

        WsbAffirmPointer( ppsp );
        WsbAffirmPointer( ppsp->lParam );

        //
        // Get the page object from lParam
        //
        CPrDrivePg* pPage = (CPrDrivePg*)ppsp->lParam;

        WsbAssertPointer( pPage->m_pMfcCallback );

        rVal = ( pPage->m_pMfcCallback )( hWnd, uMessage, ppsp );

        switch( uMessage ) {
        case PSPCB_CREATE:
            break;

        case PSPCB_RELEASE:
            delete pPage;
            break;
        }

    } WsbCatch( hr );

    return( rVal );
}

void CPrDrivePg::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    UNREFERENCED_PARAMETER(pWnd);
    UNREFERENCED_PARAMETER(point);

    if(pHelpIds && (m_pszHelpFilePath != L"")) {

        AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
        ::WinHelp(m_hWnd, m_pszHelpFilePath, HELP_CONTEXTMENU, (DWORD_PTR)pHelpIds);

    }
	
}

BOOL CPrDrivePg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if( (HELPINFO_WINDOW == pHelpInfo->iContextType) && 
        pHelpIds                                     && 
        (m_pszHelpFilePath != L"") ) {
        
        AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

        //
        // Look through list to see if we have help for this control
        // If not, we want to avoid the "No Help Available" box
        //
        DWORD *pTmp = pHelpIds;
        DWORD helpId    = 0;
        DWORD tmpHelpId = 0;
        DWORD tmpCtrlId = 0;

        while( pTmp && *pTmp ) {
            //
            // Array is a pairing of control ID and help ID
            //
            tmpCtrlId = pTmp[0];
            tmpHelpId = pTmp[1];
            pTmp += 2;
            if(tmpCtrlId == (DWORD)pHelpInfo->iCtrlId) {
                helpId = tmpHelpId;
                break;
            }
        }

        if( helpId != 0 ) {
            ::WinHelp(m_hWnd, m_pszHelpFilePath, HELP_CONTEXTPOPUP, helpId);
        }
    }
	
	return CPropertyPage ::OnHelpInfo(pHelpInfo);
}

/////////////////////////////////////////////////////////////////////////////
// CPrDriveXPg property page

CPrDriveXPg::CPrDriveXPg(  ): CPropertyPage( CPrDriveXPg::IDD )
{
    //{{AFX_DATA_INIT( CPrDriveXPg )
    //}}AFX_DATA_INIT

    //
    // Lock the module while this object lives.
    // Otherwise, modules can call CoFreeUnusedLibraries( )
    // and cause us to unload before our page gets destroyed,
    // which causes an AV in the common control.
    //
    _Module.Lock( );
    m_nState       = NO_STATE;

    //
    // Get and save the MFC callback function.
    // This is so we can delete the class the dialog never gets created.
    //
    m_pMfcCallback = m_psp.pfnCallback;

    //
    // Set the call back to our callback
    //
    m_psp.pfnCallback = PropPageCallback;
}

CPrDriveXPg::~CPrDriveXPg(  )
{
    _Module.Unlock( );
}

BEGIN_MESSAGE_MAP( CPrDriveXPg, CPropertyPage )
//{{AFX_MSG_MAP( CPrDriveXPg )
//}}AFX_MSG_MAP
END_MESSAGE_MAP(  )

/////////////////////////////////////////////////////////////////////////////
// CPrDriveXPg message handlers

BOOL CPrDriveXPg::OnInitDialog(  )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState(  ) );

    HRESULT hr = S_OK;

    CPropertyPage::OnInitDialog(  );

    try {

        switch( m_nState ) {

        case NO_FSA:
            m_szError.LoadString( IDS_NO_FSA );
            break;
        case NOT_MANAGED:
            m_szError.LoadString( IDS_NOT_MANAGED );
            break;
        case NOT_NTFS:
            m_szError.LoadString( IDS_NOT_NTFS );
            break;
        }

        SetDlgItemText( IDC_STATIC_ERROR, m_szError );

    } WsbCatch( hr )

    return( TRUE );
}

UINT CALLBACK
CPrDriveXPg::PropPageCallback(
    HWND hWnd,
    UINT uMessage,
    LPPROPSHEETPAGE  ppsp )
{

    UINT rVal = 0;
    HRESULT hr = S_OK;
    try {

        WsbAffirmPointer( ppsp );
        WsbAffirmPointer( ppsp->lParam );

        //
        // Get the page object from lParam
        //
        CPrDriveXPg* pPage = (CPrDriveXPg*)ppsp->lParam;

        WsbAssertPointer( pPage->m_pMfcCallback );

        rVal = ( pPage->m_pMfcCallback )( hWnd, uMessage, ppsp );

        switch( uMessage ) {
        case PSPCB_CREATE:
            break;

        case PSPCB_RELEASE:
            delete pPage;
            break;
        }

    } WsbCatch( hr );

    return( rVal );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\utility\proppage.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    PropPage.cpp

Abstract:

    Node representing our Media Set (Media Pool) within NTMS.

Author:

    Rohde Wakefield [rohde]   04-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include "PropPage.h"
#include "wizsht.h"


/////////////////////////////////////////////////////////////////////////////
// CRsDialog property page

CRsDialog::CRsDialog( UINT nIDTemplate, CWnd* pParent ) : CDialog( nIDTemplate, pParent )
{
    //{{AFX_DATA_INIT(CRsDialog)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    m_pHelpIds = 0;
}

CRsDialog::~CRsDialog()
{
}

BEGIN_MESSAGE_MAP(CRsDialog, CDialog)
    //{{AFX_MSG_MAP(CRsDialog)
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CRsDialog::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if( ( HELPINFO_WINDOW == pHelpInfo->iContextType ) && m_pHelpIds ) {
        
        AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

        //
        // Look through list to see if we have help for this control
        // If not, we want to avoid the "No Help Available" box
        //
        const DWORD * pTmp = m_pHelpIds;
        DWORD helpId    = 0;
        DWORD tmpHelpId = 0;
        DWORD tmpCtrlId = 0;

        while( pTmp && *pTmp ) {

            //
            // Array is a pairing of control ID and help ID
            //
            tmpCtrlId = pTmp[0];
            tmpHelpId = pTmp[1];
            pTmp += 2;
            if( tmpCtrlId == (DWORD)pHelpInfo->iCtrlId ) {

                helpId = tmpHelpId;
                break;

            }

        }

        if( helpId != 0 ) {

            ::WinHelp( m_hWnd, AfxGetApp( )->m_pszHelpFilePath, HELP_CONTEXTPOPUP, helpId );

        }

    }
    
    return CDialog::OnHelpInfo(pHelpInfo);
}

void CRsDialog::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    if( m_pHelpIds ) {

        AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
        ::WinHelp( m_hWnd, AfxGetApp( )->m_pszHelpFilePath, HELP_CONTEXTMENU, (UINT_PTR)m_pHelpIds );

    }
}

/////////////////////////////////////////////////////////////////////////////
// CRsPropertyPage property page

CRsPropertyPage::CRsPropertyPage( UINT nIDTemplate, UINT nIDCaption ) : CPropertyPage( nIDTemplate, nIDCaption )
{
    //{{AFX_DATA_INIT(CRsPropertyPage)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    m_pHelpIds = 0;

    //
    // Get and save the MFC callback function.
    // This is so we can delete the class the dialog never gets created.
    //
    m_pMfcCallback = m_psp.pfnCallback;

    //
    // Set the call back to our callback
    //
    m_psp.pfnCallback = PropPageCallback;

}

CRsPropertyPage::~CRsPropertyPage()
{
}

void CRsPropertyPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRsPropertyPage)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRsPropertyPage, CPropertyPage)
    //{{AFX_MSG_MAP(CRsPropertyPage)
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

UINT CALLBACK
CRsPropertyPage::PropPageCallback(
    HWND hWnd,
    UINT uMessage,
    LPPROPSHEETPAGE  ppsp )
{

    UINT rVal = 0;

    if( ( ppsp ) && ( ppsp->lParam ) ) {

        //
        // Get the page object from lParam
        //
        CRsPropertyPage* pPage = (CRsPropertyPage*)ppsp->lParam;

        if( pPage->m_pMfcCallback ) {

            rVal = ( pPage->m_pMfcCallback )( hWnd, uMessage, ppsp );

        }

        switch( uMessage ) {
        
        case PSPCB_CREATE:
            pPage->OnPageCreate( );
            break;

        case PSPCB_RELEASE:
            pPage->OnPageRelease( );
            break;
        }

    }

    return( rVal );
}


/////////////////////////////////////////////////////////////////////////////
// CRsPropertyPage Font Accessor Functions

#define RSPROPPAGE_FONT_IMPL( name )    \
CFont CRsPropertyPage::m_##name##Font;  \
CFont*                                  \
CRsPropertyPage::Get##name##Font(       \
    void                                \
    )                                   \
{                                       \
    if( 0 == (HFONT)m_##name##Font ) {  \
        Init##name##Font( );            \
    }                                   \
    return( &m_##name##Font );          \
}

RSPROPPAGE_FONT_IMPL( Shell )
RSPROPPAGE_FONT_IMPL( BoldShell )
RSPROPPAGE_FONT_IMPL( WingDing )
RSPROPPAGE_FONT_IMPL( LargeTitle )
RSPROPPAGE_FONT_IMPL( SmallTitle )

void
CRsPropertyPage::InitShellFont(          
    void                                
    )                                   
{                                       
    LOGFONT logfont;
    CFont*  tempFont = GetFont( );
    tempFont->GetLogFont( &logfont );

    m_ShellFont.CreateFontIndirect( &logfont );
}

void
CRsPropertyPage::InitBoldShellFont(          
    void                                
    )                                   
{                                       
    LOGFONT logfont;
    CFont*  tempFont = GetFont( );
    tempFont->GetLogFont( &logfont );

    logfont.lfWeight = FW_BOLD;

    m_BoldShellFont.CreateFontIndirect( &logfont );
}

void
CRsPropertyPage::InitWingDingFont(          
    void                                
    )                                   
{
    CString faceName = GetWingDingFontName( );
    CString faceSize;
    faceSize.LoadString( IDS_WIZ_WINGDING_FONTSIZE );

    LONG height;
    height = _wtol( faceSize );

    LOGFONT logFont;
    memset( &logFont, 0, sizeof(LOGFONT) );
    logFont.lfCharSet = SYMBOL_CHARSET;
    logFont.lfHeight  = height;
    lstrcpyn( logFont.lfFaceName, faceName, LF_FACESIZE );

    m_WingDingFont.CreatePointFontIndirect( &logFont );
}

void
CRsPropertyPage::InitLargeTitleFont(          
    void                                
    )                                   
{                                       
    CString fontname;
    fontname.LoadString( IDS_WIZ_TITLE1_FONTNAME );

    CString faceSize;
    faceSize.LoadString( IDS_WIZ_TITLE1_FONTSIZE );

    LONG height;
    height = _wtol( faceSize );

    LOGFONT logFont;
    memset( &logFont, 0, sizeof(LOGFONT) );
    logFont.lfCharSet = DEFAULT_CHARSET;
    logFont.lfHeight  = height;
    logFont.lfWeight  = FW_BOLD;
    lstrcpyn( logFont.lfFaceName, fontname, LF_FACESIZE );

    m_LargeTitleFont.CreatePointFontIndirect( &logFont );
}

void
CRsPropertyPage::InitSmallTitleFont(          
    void                                
    )                                   
{                                       
    CString fontname;
    fontname.LoadString( IDS_WIZ_TITLE1_FONTNAME );

    LOGFONT logFont;
    memset( &logFont, 0, sizeof(LOGFONT) );
    logFont.lfCharSet = DEFAULT_CHARSET;
    logFont.lfHeight  = 80;
    logFont.lfWeight  = FW_BOLD;
    lstrcpyn( logFont.lfFaceName, fontname, LF_FACESIZE );

    m_SmallTitleFont.CreatePointFontIndirect( &logFont );
}

/////////////////////////////////////////////////////////////////////////////
// CRsPropertyPage message handlers


//////////////////////////////////////////////////////////////////////
// CRsWizardPage Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRsWizardPage::CRsWizardPage( UINT nIDTemplate, BOOL bExterior, UINT nIDTitle, UINT nIDSubtitle )
:   CRsPropertyPage( nIDTemplate, 0 ),
    m_TitleId( nIDTitle ),
    m_SubtitleId( nIDSubtitle ),
    m_ExteriorPage( bExterior )
{

    //{{AFX_DATA_INIT(CRsWizardPage)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

CRsWizardPage::~CRsWizardPage()
{
}

void CRsWizardPage::DoDataExchange(CDataExchange* pDX)
{
    CRsPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRsWizardPage)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRsWizardPage, CRsPropertyPage)
    //{{AFX_MSG_MAP(CRsWizardPage)
    ON_WM_CTLCOLOR( )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CRsWizardPage::OnInitDialog() 
{
    CRsPropertyPage::OnInitDialog();

    if( m_ExteriorPage ) {

        CWnd* pMainTitle  = GetDlgItem( IDC_WIZ_TITLE );

        //
        // Set fonts
        //
        if( pMainTitle )   pMainTitle->SetFont( GetLargeTitleFont( ) );

    }
    
    return TRUE;
}

void CRsWizardPage::SetCaption( CString& strCaption )
{
    CPropertyPage::m_strCaption = strCaption;
    CPropertyPage::m_psp.pszTitle = strCaption;
    CPropertyPage::m_psp.dwFlags |= PSP_USETITLE;
}

BOOL CRsPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if( ( HELPINFO_WINDOW == pHelpInfo->iContextType ) && m_pHelpIds ) {
        
        AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );

        //
        // Look through list to see if we have help for this control
        // If not, we want to avoid the "No Help Available" box
        //
        const DWORD * pTmp = m_pHelpIds;
        DWORD helpId    = 0;
        DWORD tmpHelpId = 0;
        DWORD tmpCtrlId = 0;

        while( pTmp && *pTmp ) {

            //
            // Array is a pairing of control ID and help ID
            //
            tmpCtrlId = pTmp[0];
            tmpHelpId = pTmp[1];
            pTmp += 2;
            if( tmpCtrlId == (DWORD)pHelpInfo->iCtrlId ) {

                helpId = tmpHelpId;
                break;

            }

        }

        if( helpId != 0 ) {

            ::WinHelp( m_hWnd, AfxGetApp( )->m_pszHelpFilePath, HELP_CONTEXTPOPUP, helpId );

        }

    }
    
    return CPropertyPage::OnHelpInfo(pHelpInfo);
}

void CRsPropertyPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    if( m_pHelpIds ) {

        AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
        ::WinHelp( m_hWnd, AfxGetApp( )->m_pszHelpFilePath, HELP_CONTEXTMENU, (UINT_PTR)m_pHelpIds );

    }
}

HPROPSHEETPAGE CRsWizardPage::CreatePropertyPage( )
{
    HPROPSHEETPAGE hRet = 0;

    //
    // Copy over values of m_psp into m_psp97
    //
    m_psp97.dwFlags     = m_psp.dwFlags;
    m_psp97.hInstance   = m_psp.hInstance;
    m_psp97.pszTemplate = m_psp.pszTemplate;
    m_psp97.pszIcon     = m_psp.pszIcon;
    m_psp97.pszTitle    = m_psp.pszTitle;
    m_psp97.pfnDlgProc  = m_psp.pfnDlgProc;
    m_psp97.lParam      = m_psp.lParam;
    m_psp97.pfnCallback = m_psp.pfnCallback;
    m_psp97.pcRefParent = m_psp.pcRefParent;

    //
    // And fill in the other values needed
    //
    m_psp97.dwSize = sizeof( m_psp97 );

    if( m_ExteriorPage ) {

        m_psp97.dwFlags |= PSP_HIDEHEADER;

    } else {

        m_Title.LoadString(    m_TitleId );
        m_SubTitle.LoadString( m_SubtitleId );
        m_psp97.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    }

    m_psp97.pszHeaderTitle    = m_Title;
    m_psp97.pszHeaderSubTitle = m_SubTitle;

    //
    // And do the create
    //
    hRet = ::CreatePropertySheetPage( (PROPSHEETPAGE*) &m_psp97 );

    return( hRet );
}

HBRUSH CRsWizardPage::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) 
{
    int controlId = pWnd->GetDlgCtrlID( );
    HBRUSH hbr = CRsPropertyPage::OnCtlColor( pDC, pWnd, nCtlColor );

    if( IDC_WIZ_FINAL_TEXT == controlId ) {

        pDC->SetBkMode( OPAQUE );
        hbr = (HBRUSH)::GetStockObject( WHITE_BRUSH );

    }

    return( hbr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\utility\wizsht.cpp ===
// WizSht.cpp: implementation of the CRsWizardSheet class.
//
//////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "WizSht.h"
#include "PropPage.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRsWizardSheet::CRsWizardSheet( UINT nIDCaption, CWnd *pParentWnd, UINT iSelectPage ) :
        CPropertySheet( nIDCaption, pParentWnd, iSelectPage )
{
    // save the caption
    m_IdCaption = nIDCaption;
}

void CRsWizardSheet::AddPage( CRsWizardPage* pPage ) 
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState( ) );
    CString strCaption;

    // Take the caption from our sheet class and put it in the page
    strCaption.LoadString( m_IdCaption );
    pPage->SetCaption( strCaption );

    CPropertySheet::AddPage( pPage );

}

CRsWizardSheet::~CRsWizardSheet()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\gui\shellext\proppage\prdrive.h ===
/*++

(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    PrDrive.h

Abstract:

    Base file for HSM shell extensions on drives

Author:

    Art Bragg [abragg]   04-Aug-1997

Revision History:

--*/


#ifndef __PRDRIVE_H_
#define __PRDRIVE_H_

#define NO_STATE        0
#define REMOTE          1
#define NO_FSA          2
#define NOT_MANAGED     3
#define MANAGED         4
#define MULTI_SELECT    5
#define NOT_NTFS        6
#define NOT_ADMIN       7

/////////////////////////////////////////////////////////////////////////////
// CPrDrive
class  CPrDrive : 
    public CComCoClass<CPrDrive, &CLSID_PrDrive>,
    public IShellPropSheetExt,
    public IShellExtInit,
    public CComObjectRoot
{
public:

DECLARE_REGISTRY_RESOURCEID( IDR_PRDRIVE )
DECLARE_NOT_AGGREGATABLE( CPrDrive )

    CPrDrive() { };

BEGIN_COM_MAP(CPrDrive)
    COM_INTERFACE_ENTRY(IShellPropSheetExt)
    COM_INTERFACE_ENTRY(IShellExtInit)
END_COM_MAP()

protected:
    CComPtr<IDataObject> m_pDataObj;

public:

    // IShellExtInit
    STDMETHOD( Initialize ) (
        LPCITEMIDLIST pidlFolder,
        IDataObject * lpdobj, 
        HKEY          hkeyProgID
        );

    // IShellPropSheetExt
    STDMETHOD( AddPages ) ( 
        LPFNADDPROPSHEETPAGE lpfnAddPage, 
        LPARAM lParam ); 

    STDMETHOD( ReplacePage ) (
        UINT uPageID, 
        LPFNADDPROPSHEETPAGE lpfnReplacePage, 
        LPARAM lParam ); 

};

/////////////////////////////////////////////////////////////////////////////
// CPrDrivePg dialog

class CPrDrivePg : public CPropertyPage
{
// Construction
public:
    CPrDrivePg();
    ~CPrDrivePg();

// Dialog Data
    //{{AFX_DATA(CPrDrivePg)
    enum { IDD = IDD_PRDRIVE };
    CEdit   m_editSize;
    CEdit   m_editLevel;
    CEdit   m_editTime;
    CSpinButtonCtrl m_spinTime;
    CSpinButtonCtrl m_spinSize;
    CSpinButtonCtrl m_spinLevel;
    UINT    m_accessTime;
    UINT    m_hsmLevel;
    DWORD   m_fileSize;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPrDrivePg)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    static UINT CALLBACK PropPageCallback( HWND hWnd, UINT uMessage, LPPROPSHEETPAGE  ppsp );
    // Generated message map functions
    //{{AFX_MSG(CPrDrivePg)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeEditAccess();
    afx_msg void OnChangeEditLevel();
    afx_msg void OnChangeEditSize();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    LPFNPSPCALLBACK       m_pMfcCallback; // Original MFC callback from psp
    int                   m_nState;
    CComPtr<IFsaResource> m_pFsaResource;

protected:
    CString               m_pszHelpFilePath;

};


/////////////////////////////////////////////////////////////////////////////
// CPrDriveXPg dialog

class CPrDriveXPg : public CPropertyPage
{
// Construction
public:
    CPrDriveXPg();
    ~CPrDriveXPg();

// Dialog Data
    //{{AFX_DATA(CPrDriveXPg)
    enum { IDD = IDD_PRDRIVEX };
    CString m_szError;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPrDriveXPg)
    public:
    protected:
    //}}AFX_VIRTUAL

// Implementation
protected:
    static UINT CALLBACK PropPageCallback( HWND hWnd, UINT uMessage, LPPROPSHEETPAGE  ppsp );
    // Generated message map functions
    //{{AFX_MSG(CPrDriveXPg)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    LPFNPSPCALLBACK m_pMfcCallback;         // Original MFC callback from psp
    int             m_nState;


};

#endif //__PRDRIVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\hsmservr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\hsmconn\stdafx.h ===
#ifndef _STDAFX_H
#define _STDAFX_H

/*++

Copyright (c) 1996  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    StdAfx.h

Abstract:

    Common include file for all of HsmConn DLL files.

Author:

    Rohde Wakefield    [rohde]   14-Oct-1997

Revision History:

--*/

#define WSB_TRACE_IS WSB_TRACE_BIT_HSMCONN



#include "Wsb.h"
#include "CName.h"
#include "HsmConn.h"
#include "FsaLib.h"

//
// This must be after the Wsb.h is include for the static registry stuff to be there.
//
#include <activeds.h>
#include <atlimpl.cpp>

#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\hsmservr\hsmconpt.h ===
// hsmconpt.h : Declaration of the CHsmConnPoint

#ifndef __HSMCONNPOINT_H_
#define __HSMCONNPOINT_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CHsmConnPoint
class ATL_NO_VTABLE CHsmConnPoint : 
	public CComObjectRoot,  //  this may change in the future to CWsbObject
	public CComCoClass<CHsmConnPoint, &CLSID_HsmConnPoint>,
	public IHsmConnPoint
{
public:
	CHsmConnPoint()	{}

DECLARE_REGISTRY_RESOURCEID(IDR_HSMCONNPOINT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CHsmConnPoint)
	COM_INTERFACE_ENTRY(IHsmConnPoint)
END_COM_MAP()

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IHsmConnPoint
public:
	STDMETHOD(GetFsaServer)(/*[out]*/ IFsaServer **ppFsaServer);
	STDMETHOD(GetEngineServer)(/*[out]*/ IHsmServer **ppHsmServer);
};

#endif //__HSMCONNPOINT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\hsmconn\cname.h ===
/*++

Copyright (c) 1996  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    CName.h

Abstract:

    This is the implementation of the CNames classes, which
    handle how server and object names and paths are put
    together.

Author:

    Rohde Wakefield    [rohde]   14-Oct-1997

Revision History:

--*/

#ifndef HSMCONN_CNAME_H
#define HSMCONN_CNAME_H



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\hsmservr\hsmconpt.cpp ===
// hsmconpt.cpp : Implementation of CHsmConnPoint
#include "stdafx.h"
#include "Hsmservr.h"
#include "hsmconpt.h"

// define for access to global server objects
extern IHsmServer *g_pEngServer;
extern IFsaServer *g_pFsaServer;

extern CRITICAL_SECTION g_FsaCriticalSection;
extern CRITICAL_SECTION g_EngCriticalSection;

extern BOOL g_bEngInitialized;
extern BOOL g_bFsaInitialized;

static USHORT iCount = 0;  // Count of existing objects

/////////////////////////////////////////////////////////////////////////////
// CHsmConnPoint


STDMETHODIMP CHsmConnPoint::FinalConstruct(void)
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT        hr = S_OK;

    WsbTraceIn(OLESTR("CHsmConnPoint::FinalConstruct"), OLESTR(""));

    try {

        WsbAffirmHr(CComObjectRoot::FinalConstruct());

        // currently, no private initialization

        //  Add class to object table
        WSB_OBJECT_ADD(CLSID_CFsaScanItemNTFS, this);

    } WsbCatch(hr);

    iCount++;

    WsbTraceOut(OLESTR("CHsmConnPoint::FinalConstruct"), OLESTR("hr = <%ls>, Count is <%d>"),
            WsbHrAsString(hr), iCount);

    return(hr);
}

STDMETHODIMP CHsmConnPoint::FinalRelease(void)
/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CHsmConnPoint::FinalRelease"), OLESTR(""));

    //  Subtract class from object table
    WSB_OBJECT_SUB(CLSID_CFsaScanItemNTFS, this);

    // currently, no private cleanup

    // Let the parent class do his thing.
    CComObjectRoot::FinalRelease();

    iCount--;

    WsbTraceOut(OLESTR("CHsmConnPoint::FinalRelease"), OLESTR("hr = <%ls>, Count is <%d>"), 
            WsbHrAsString(hr), iCount);
    return (hr);
}



STDMETHODIMP CHsmConnPoint::GetEngineServer(IHsmServer **ppHsmServer)
{
    // If Engine server has been created, return the pointer. Otherwise, fail.
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CHsmConnPoint::GetEngineServer"), OLESTR(""));

    try {
        // verify that pointers are valid
        WsbAssert (ppHsmServer !=  0, E_POINTER);
        WsbAffirm (g_pEngServer != 0, HSM_E_NOT_READY);

        // assign in a safe manner (only if manager object is already initializaed)
        EnterCriticalSection(&g_EngCriticalSection);
        if (g_bEngInitialized) {
            _ASSERTE(g_pEngServer != 0);    // shouldn't happen
            *ppHsmServer = g_pEngServer;
            g_pEngServer->AddRef();
        } else {
            hr = HSM_E_NOT_READY;
        }
        LeaveCriticalSection (&g_EngCriticalSection);

    } WsbCatch (hr);

    WsbTraceOut(OLESTR("CHsmConnPoint::GetEngineServer"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
	return (hr);
}

STDMETHODIMP CHsmConnPoint::GetFsaServer(IFsaServer **ppFsaServer)
{
    // If Fsa server has been created, return the pointer. Otherwise, fail.
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CHsmConnPoint::GetFsaServer"), OLESTR(""));

    try {
        // verify that pointers are valid
        WsbAssert (ppFsaServer !=  0, E_POINTER);
        WsbAffirm (g_pFsaServer != 0, FSA_E_NOT_READY);

        // assign in a safe manner (only if manager object is already initializaed)
        EnterCriticalSection(&g_FsaCriticalSection);
        if (g_bFsaInitialized) {
            _ASSERTE(g_pFsaServer != 0);    // shouldn't happen
            *ppFsaServer = g_pFsaServer;
            g_pFsaServer->AddRef();
        } else {
            hr = FSA_E_NOT_READY;
        }
        LeaveCriticalSection(&g_FsaCriticalSection);

    } WsbCatch (hr);

    WsbTraceOut(OLESTR("CHsmConnPoint::GetFsaServer"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
	return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\hsmservr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by hsmservr.rc
//
#define IDS_SERVICENAME                 100
#define IDR_Hsmservr                    100
#define IDS_SERVICE_DISPLAYNAME         101
#define IDS_SERVICE_DESCRIPTION         102
#define IDS_PRODUCT_NAME                103
#define IDR_HSMCONNPOINT                104
#define IDR_Serv2Proc                   105
#define IDR_Proc2Serv                   106
#define IDC_CURSOR1                     201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\idb\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\hsmservr\hsmservr.cpp ===
/*++

Module Name:

    hsmservr.cpp

Abstract:

    Provides the Service and main executable implementation.

Author:

    Ran Kalach [rankala]

Revision History:

--*/

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f hsmservrps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"

#include "engcommn.h"

// This include is here due to a MIDL bug - it should have been in the created file hsmservr.h
#include "fsalib.h"

#include "hsmservr.h"

#include <stdio.h>
#include "hsmconpt.h"

// Service dependencies for the HSM server service

#define ENG_DEPENDENCIES  L"EventLog\0RpcSs\0Schedule\0NtmsSvc\0\0"

// Service name
#define SERVICE_LOGICAL_NAME    _T("Remote_Storage_Server")
#define SERVICE_DISPLAY_NAME    L"Remote Storage Server"


CServiceModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_HsmConnPoint, CHsmConnPoint)
END_OBJECT_MAP()

// The global server objects
IHsmServer *g_pEngServer;
IFsaServer *g_pFsaServer;

BOOL g_bEngCreated = FALSE;
BOOL g_bEngInitialized = FALSE;
BOOL g_bFsaCreated = FALSE;
BOOL g_bFsaInitialized = FALSE;

CRITICAL_SECTION g_FsaCriticalSection;
CRITICAL_SECTION g_EngCriticalSection;

#define HSM_SERVER_TRACE_FILE_NAME       OLESTR("rsserv.trc")

CComPtr<IWsbTrace>  g_pTrace;

// Global functions for console handling
static void ConsoleApp(void);
BOOL WINAPI ConsoleHandler(DWORD dwCtrlType);

static void DebugRelease (void);


// Although some of these functions are big they are declared inline since they are only used once

inline HRESULT CServiceModule::RegisterServer(BOOL bRegTypeLib)
{
    WsbTraceIn ( L"CServiceModule::RegisterServer", L"bRegTypeLib = %ls", WsbBoolAsString ( bRegTypeLib ) );

    HRESULT hr = S_OK;
    try {

        WsbAssertHr ( CoInitialize ( NULL ) );

        //
        // Do not try to remove any previous service since this can cause a delay
        // in the registration to happen when another process is trying to get
        // this program to self register
        //

        //
        // Add service entries
        //
        WsbAssertHr( UpdateRegistryFromResource( IDR_Hsmservr, TRUE ) );

        //
        // Create service
        //
        WsbAssert( Install(), E_FAIL ) ;

        //
        // Add object entries
        //
        WsbAssertHr ( CComModule::RegisterServer( bRegTypeLib ) );

        CoUninitialize();

    }WsbCatch ( hr )

    WsbTraceOut ( L"CServiceModule::RegisterServer", L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return( hr );
}

inline HRESULT CServiceModule::UnregisterServer()
{
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;

    // Remove service entries
    UpdateRegistryFromResource(IDR_Hsmservr, FALSE);
    // Remove service
    Uninstall();
    // Remove object entries
    CComModule::UnregisterServer();

    CoUninitialize();
    return S_OK;
}

inline void CServiceModule::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h)
{
    WsbTraceIn ( L"CServiceModule::Init", L"" );

    CComModule::Init(p, h);

    m_bService = TRUE;

    _tcscpy(m_szServiceName, SERVICE_LOGICAL_NAME);

    // set up the initial service status
    m_hServiceStatus = NULL;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN |
                                  SERVICE_ACCEPT_POWEREVENT | SERVICE_ACCEPT_PAUSE_CONTINUE;
    m_status.dwWin32ExitCode = 0;
    m_status.dwServiceSpecificExitCode = 0;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;

    WsbTraceOut ( L"CServiceModule::Init", L"" );
}

LONG CServiceModule::Unlock()
{
    LONG l = CComModule::Unlock();

/*  This line put in comment since it causes the process to immediately exit
    if (l == 0 && !m_bService)
        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);   */

    return l;
}

BOOL CServiceModule::IsInstalled()
{
    BOOL bResult = FALSE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM != NULL) {
        SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_QUERY_CONFIG);
        if (hService != NULL) {
            bResult = TRUE;
            ::CloseServiceHandle(hService);
        }
        ::CloseServiceHandle(hSCM);
    }
    return bResult;
}

inline BOOL CServiceModule::Install()
/*++

Routine Description:

    Install service module.

Arguments:

    None.

Return Value:

    TRUE    - Service installed successfully

    FALSE   - Service install failed

--*/
{

    BOOL bResult = FALSE;
    CWsbStringPtr errorMessage;
    CWsbStringPtr displayName;
    CWsbStringPtr description;

    if (!IsInstalled()) {

        displayName = SERVICE_DISPLAY_NAME;
        description.LoadFromRsc(_Module.m_hInst, IDS_SERVICE_DESCRIPTION );

        SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
        if (hSCM) {

            // Get the executable file path
            TCHAR szFilePath[_MAX_PATH];
            ::GetModuleFileName(NULL, szFilePath, _MAX_PATH);

            SC_HANDLE hService = ::CreateService(
                                                hSCM, m_szServiceName, (OLECHAR *) displayName,
                                                SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS,
                                                SERVICE_AUTO_START, SERVICE_ERROR_NORMAL,
                                                szFilePath, NULL, NULL, ENG_DEPENDENCIES, NULL, NULL);

            if (hService) {

                // the service was successfully installed.
                bResult = TRUE;

                SERVICE_DESCRIPTION svcDesc;
                svcDesc.lpDescription = description;

                ::ChangeServiceConfig2(hService, SERVICE_CONFIG_DESCRIPTION, &svcDesc);
                ::CloseServiceHandle(hService);
                ::CloseServiceHandle(hSCM);

            } else {
                errorMessage = WsbHrAsString(HRESULT_FROM_WIN32( GetLastError() ) );
                ::CloseServiceHandle(hSCM);
                MessageBox(NULL, errorMessage, (OLECHAR *) displayName, MB_OK);
            }

        } else {
            MessageBox(NULL, WsbHrAsString(HRESULT_FROM_WIN32( GetLastError() ) ), (OLECHAR *) displayName, MB_OK);
        }

    } else {

        // service already install, just return TRUE.
        bResult = TRUE;
    }

    return bResult;
}

inline BOOL CServiceModule::Uninstall()
/*++

Routine Description:

    Uninstall service module.

Arguments:

    None.

Return Value:

    TRUE    - Service successfully uninstalled.

    FALSE   - Unable to uninstall service.

--*/
{

    BOOL bResult = FALSE;
    CWsbStringPtr errorMessage;
    CWsbStringPtr displayName;

    if (IsInstalled()) {

        displayName = SERVICE_DISPLAY_NAME;

        SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
        if (hSCM) {

            SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, DELETE);
            if (hService) {

                BOOL bDelete = ::DeleteService(hService);
                // if it did not delete then get the error message
                if (!bDelete)
                    errorMessage = WsbHrAsString(HRESULT_FROM_WIN32( GetLastError() ) );

                ::CloseServiceHandle(hService);
                ::CloseServiceHandle(hSCM);

                if (bDelete) {

                    // the service was deleted.
                    bResult = TRUE;

                } else {
                    MessageBox(NULL, errorMessage, (OLECHAR *) displayName, MB_OK);
                }

            } else {
                errorMessage = WsbHrAsString(HRESULT_FROM_WIN32( GetLastError() ) );
                ::CloseServiceHandle(hSCM);
                MessageBox(NULL, errorMessage, (OLECHAR *) displayName, MB_OK);
            }

        } else {
            MessageBox(NULL, WsbHrAsString(HRESULT_FROM_WIN32( GetLastError() ) ), (OLECHAR *) displayName, MB_OK);
        }

    } else {
        // service not installed, just return TRUE.
        bResult = TRUE;
    }

    return bResult;

}

///////////////////////////////////////////////////////////////////////////////////////
// Logging functions
//

void
CServiceModule::LogEvent(
                        DWORD       eventId,
                        ...
                        )
/*++

Routine Description:

    Log data to event log.

Arguments:

    eventId    - The message Id to log.
    Inserts    - Message inserts that are merged with the message description specified by
                   eventId.  The number of inserts must match the number specified by the
                   message description.  The last insert must be NULL to indicate the
                   end of the insert list.

Return Value:

    None.

--*/
{
    if (m_bService) {
        // Report the event.

        va_list         vaList;

        va_start(vaList, eventId);
        WsbLogEventV( eventId, 0, NULL, &vaList );
        va_end(vaList);
    } else {
        // Just write the error to the console, if we're not running as a service.

        va_list         vaList;
        const OLECHAR * facilityName = 0;
        OLECHAR *       messageText = 0;

        switch ( HRESULT_FACILITY( eventId ) ) {
        
        case WSB_FACILITY_PLATFORM:
        case WSB_FACILITY_RMS:
        case WSB_FACILITY_HSMENG:
        case WSB_FACILITY_JOB:
        case WSB_FACILITY_HSMTSKMGR:
        case WSB_FACILITY_FSA:
        case WSB_FACILITY_GUI:
        case WSB_FACILITY_MOVER:
        case WSB_FACILITY_LAUNCH:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            break;
        }

        if ( facilityName ) {
            // Print out the variable arguments

            // NOTE: Positional parameters in the inserts are not processed.  These
            //       are done by ReportEvent() only.
            HMODULE hLib =  LoadLibraryEx( facilityName, NULL, LOAD_LIBRARY_AS_DATAFILE );
            if (hLib != NULL) {
                va_start(vaList, eventId);
                FormatMessage( FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                               hLib,
                               eventId,
                               MAKELANGID ( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                               (LPTSTR) &messageText,
                               0,
                               &vaList );
                va_end(vaList);
                FreeLibrary(hLib);
            } 

            if ( messageText ) {
                _putts(messageText);
                LocalFree( messageText );
            } else {
                _tprintf( OLESTR("!!!!! ERROR !!!!! - Message <0x%08x> could not be translated.\n"), eventId );
            }

        } else {
            _tprintf( OLESTR("!!!!! ERROR !!!!! - Message File for <0x%08x> could not be found.\n"), eventId );
        }
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Service startup and registration
inline void CServiceModule::Start()
{
    SERVICE_TABLE_ENTRY st[] =
    {
        { m_szServiceName, _ServiceMain},
        { NULL, NULL}
    };
    if (!::StartServiceCtrlDispatcher(st)) {
        m_bService = FALSE;
        if (GetLastError()==ERROR_FAILED_SERVICE_CONTROLLER_CONNECT)
            Run();
    }
}

inline void CServiceModule::ServiceMain(DWORD /* dwArgc */, LPTSTR* /* lpszArgv */)
{
    SetServiceStatus(SERVICE_START_PENDING);

    // Register the control request handler
    m_status.dwCurrentState = SERVICE_START_PENDING;
    m_hServiceStatus = RegisterServiceCtrlHandlerEx(m_szServiceName, _HandlerEx,
                                                    NULL);
    if (m_hServiceStatus == NULL) {
        LogEvent( HSM_MESSAGE_SERVICE_HANDLER_NOT_INSTALLED, NULL );
        return;
    }

    m_status.dwWin32ExitCode = S_OK;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;

    // When the Run function returns, the service has stopped.
    Run();

    SetServiceStatus(SERVICE_STOPPED);
    LogEvent( HSM_MESSAGE_SERVICE_STOPPED, NULL );
}

inline DWORD CServiceModule::HandlerEx(DWORD dwOpcode, DWORD fdwEventType,
                                       LPVOID /* lpEventData */, LPVOID /* lpContext */)
{
    DWORD                    dwRetCode = 0;
    HRESULT                  hr = S_OK;
    HRESULT                  hr1 = S_OK;
    HSM_SYSTEM_STATE         SysState;

    WsbTraceIn(OLESTR("CServiceModule::HandlerEx"), OLESTR("opCode=%lx"),
               dwOpcode );

    switch (dwOpcode) {
    case SERVICE_CONTROL_STOP:  {
            SetServiceStatus(SERVICE_STOP_PENDING);
            PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
        }
        break;

    case SERVICE_CONTROL_PAUSE:
        SetServiceStatus(SERVICE_PAUSE_PENDING);
        SysState.State = HSM_STATE_SUSPEND;
        if (g_pEngServer && g_bEngInitialized) {
            g_pEngServer->ChangeSysState(&SysState);
        }
        if (g_pFsaServer && g_bFsaInitialized) {
            g_pFsaServer->ChangeSysState(&SysState);
        }
        SetServiceStatus(SERVICE_PAUSED);
        break;

    case SERVICE_CONTROL_CONTINUE:
        SetServiceStatus(SERVICE_CONTINUE_PENDING);
        SysState.State = HSM_STATE_RESUME;
        if (g_pFsaServer && g_bFsaInitialized) {
            g_pFsaServer->ChangeSysState(&SysState);
        }
        if (g_pEngServer && g_bEngInitialized) {
            g_pEngServer->ChangeSysState(&SysState);
        }
        SetServiceStatus(SERVICE_RUNNING);
        break;

    case SERVICE_CONTROL_INTERROGATE:
        break;

    case SERVICE_CONTROL_SHUTDOWN:
        // Prepare Eng server for releasing
        if (g_pEngServer && g_bEngInitialized) {
            SysState.State = HSM_STATE_SHUTDOWN;
            if (!SUCCEEDED(hr = g_pEngServer->ChangeSysState(&SysState))) {
                LogEvent( HSM_MESSAGE_SERVICE_FAILED_TO_SHUTDOWN, WsbHrAsString(hr), NULL );
            }
        }

        // Prepare Fsa server for releasing
        if (g_pFsaServer && g_bFsaInitialized) {
            CComPtr<IWsbServer> pWsbServer;
            SysState.State = HSM_STATE_SHUTDOWN;

            // If it was initialized, then we should try to save the current state.
            hr = g_pFsaServer->QueryInterface(IID_IWsbServer, (void**) &pWsbServer);
            if (hr == S_OK) {
                hr = pWsbServer->SaveAll();
            }
            if (FAILED(hr)) {
               LogEvent(FSA_MESSAGE_SERVICE_FAILED_TO_SAVE_DATABASE, WsbHrAsString(hr), NULL );
            }

            hr = g_pFsaServer->ChangeSysState(&SysState);
            if (FAILED(hr)) {
                LogEvent( FSA_MESSAGE_SERVICE_FAILED_TO_SHUTDOWN, WsbHrAsString(hr), NULL );
            }
        }

        // Release Eng server
        if (g_bEngCreated  && (g_pEngServer != 0)) {
            // Free server inside a crit. section thus avoid conflicts with accessing clients
            EnterCriticalSection(&g_EngCriticalSection);
            g_bEngInitialized = FALSE;
            g_bEngCreated = FALSE;

            // Disconnect all remote clients
            (void)CoDisconnectObject(g_pEngServer, 0);

            // Forse object destroy, ignore reference count here
            IWsbServer *pWsbServer;
            hr = g_pEngServer->QueryInterface(IID_IWsbServer, (void**) &pWsbServer);
            if (hr == S_OK) {
                pWsbServer->Release();
                pWsbServer->DestroyObject();
            }
            g_pEngServer = 0;
            LeaveCriticalSection (&g_EngCriticalSection);
        }

        // Release Fsa server
        if (g_bFsaCreated && (g_pFsaServer != 0)) {
            // Free server inside a crit. section thus avoid conflicts with accessing clients
            EnterCriticalSection(&g_FsaCriticalSection);
            g_bFsaInitialized = FALSE;
            g_bFsaCreated = FALSE;

            // Disconnect all remote clients
            (void)CoDisconnectObject(g_pFsaServer, 0);

            // Forse object destroy, ignore reference count here
            IWsbServer *pWsbServer;
            hr = g_pFsaServer->QueryInterface(IID_IWsbServer, (void**) &pWsbServer);
            if (hr == S_OK) {
                pWsbServer->Release();
                pWsbServer->DestroyObject();
            }
            g_pFsaServer = 0;
            LeaveCriticalSection(&g_FsaCriticalSection);
        }

        break;

    case SERVICE_CONTROL_POWEREVENT:
        if (S_OK == WsbPowerEventNtToHsm(fdwEventType, &SysState.State)) {
            WsbTrace(OLESTR("CServiceModule::HandlerEx: power event, fdwEventType = %lx\n"),
                     fdwEventType);

            if (g_pEngServer && g_bEngInitialized) {
                hr = g_pEngServer->ChangeSysState(&SysState);
            }
            if (g_pFsaServer && g_bFsaInitialized) {
                hr1 = g_pFsaServer->ChangeSysState(&SysState);
            }

            if ((S_FALSE == hr) || (S_FALSE == hr1)) {
                dwRetCode = BROADCAST_QUERY_DENY;
            }
        }
        break;

    default:
        LogEvent( HSM_MESSAGE_SERVICE_RECEIVED_BAD_REQUEST, NULL );
    }

    WsbTraceOut(OLESTR("CServiceModule::HandlerEx"), OLESTR("dwRetCode = %lx"),
                dwRetCode );

    return(dwRetCode);
}

void WINAPI CServiceModule::_ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
    _Module.ServiceMain(dwArgc, lpszArgv);
}

DWORD WINAPI CServiceModule::_HandlerEx(DWORD dwOpcode, DWORD fdwEventType,
                                        LPVOID lpEventData, LPVOID lpContext)
{
    return(_Module.HandlerEx(dwOpcode, fdwEventType, lpEventData, lpContext));
}

void CServiceModule::SetServiceStatus(DWORD dwState)
{
    m_status.dwCurrentState = dwState;
    ::SetServiceStatus(m_hServiceStatus, &m_status);
}

void CServiceModule::Run()
{
    HRESULT hr = S_OK;

    try {
        // Initialize both servers critical section.
        try {
            InitializeCriticalSectionAndSpinCount (&g_FsaCriticalSection, 1000);
            InitializeCriticalSectionAndSpinCount (&g_EngCriticalSection, 1000);
        } catch (DWORD status) {
            WsbLogEvent(status, 0, NULL, NULL);
            switch (status) {
            case STATUS_NO_MEMORY:
                WsbThrow(E_OUTOFMEMORY);
                break;
            default:
                WsbThrow(E_UNEXPECTED);
            }
        }

        _Module.dwThreadID = GetCurrentThreadId();

        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
        _ASSERTE(SUCCEEDED(hr));
        if (hr != S_OK) {
            m_status.dwWin32ExitCode = HRESULT_CODE(hr) ;
            LogEvent( HSM_MESSAGE_SERVICE_FAILED_COM_INIT, OLESTR("CoInitializeEx"), 
                      WsbHrAsString(hr), NULL );
            DeleteCriticalSection(&g_EngCriticalSection);
            DeleteCriticalSection(&g_FsaCriticalSection);
            return;
        }

        // This provides Admin only access.
        CWsbSecurityDescriptor sd;
        sd.InitializeFromThreadToken();
        sd.AllowRid( SECURITY_LOCAL_SYSTEM_RID, COM_RIGHTS_EXECUTE );
        sd.AllowRid( DOMAIN_ALIAS_RID_ADMINS,   COM_RIGHTS_EXECUTE );
        hr = CoInitializeSecurity(sd, -1, NULL, NULL,
                                  RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
        _ASSERTE(SUCCEEDED(hr));
        if (hr != S_OK) {
            m_status.dwWin32ExitCode = HRESULT_CODE(hr) ;
            LogEvent( HSM_MESSAGE_SERVICE_FAILED_COM_INIT, OLESTR("CoInitializeSecurity"), 
                      WsbHrAsString(hr), NULL );
            CoUninitialize();
            DeleteCriticalSection(&g_EngCriticalSection);
            DeleteCriticalSection(&g_FsaCriticalSection);
            return;
        }


        // Create the trace object and initialize it
        hr = CoCreateInstance(CLSID_CWsbTrace, 0, CLSCTX_SERVER, IID_IWsbTrace, (void **) &g_pTrace);
        _ASSERTE(SUCCEEDED(hr));
        if (hr != S_OK) {
            m_status.dwWin32ExitCode = HRESULT_CODE(hr) ;
            LogEvent( HSM_MESSAGE_SERVICE_INITIALIZATION_FAILED, WsbHrAsString(hr), NULL );
            CoUninitialize();
            DeleteCriticalSection(&g_EngCriticalSection);
            DeleteCriticalSection(&g_FsaCriticalSection);
            return;
        }

        // Figure out where to store information and initialize trace.
        //  Currently, Engine & Fsa share the same trace file
        WsbGetServiceTraceDefaults(m_szServiceName, HSM_SERVER_TRACE_FILE_NAME, g_pTrace);

        WsbTraceIn(OLESTR("CServiceModule::Run"), OLESTR(""));

        hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER, REGCLS_MULTIPLEUSE);
        if (hr != S_OK) {
            m_status.dwWin32ExitCode = HRESULT_CODE(hr) ;
            LogEvent( HSM_MESSAGE_SERVICE_FAILED_COM_INIT, OLESTR("CoRegisterClassObjects"), 
                      WsbHrAsString(hr), NULL );
            g_pTrace = 0;
            CoUninitialize();
            DeleteCriticalSection(&g_EngCriticalSection);
            DeleteCriticalSection(&g_FsaCriticalSection);
            return;
        }

        // Now we need to get the HSM Server initialized
        // First Fsa server is initialized, ONLY if it succeeds, Engine 
        // server is initialized as well
        m_status.dwCheckPoint = 1;
        m_status.dwWaitHint = 60000;
        SetServiceStatus(SERVICE_START_PENDING);

        // initialize Fsa server
        if (! g_pFsaServer) {
            try {
                //
                // Create and initialize the server.
                //
                WsbAffirmHr( CoCreateInstance(CLSID_CFsaServerNTFS, 0, CLSCTX_SERVER, IID_IFsaServer, (void**) &g_pFsaServer) );

                // Created the server, now initialize it
                g_bFsaCreated = TRUE;

                CComPtr<IWsbServer>      pWsbServer;
                WsbAffirmHr(g_pFsaServer->QueryInterface(IID_IWsbServer, (void**) &pWsbServer));
                WsbAffirmHrOk(pWsbServer->SetTrace(g_pTrace));

                hr = g_pFsaServer->Init();
                WsbAffirmHrOk(hr);

                g_bFsaInitialized = TRUE;

            }WsbCatchAndDo( hr,

                            // If the error is a Win32 make it back to a Win32 error else send
                            // the HR in the service specific exit code
                            if ( FACILITY_WIN32 == HRESULT_FACILITY(hr) ){
                            m_status.dwWin32ExitCode = HRESULT_CODE(hr) ;}else{
                          m_status.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
                          m_status.dwServiceSpecificExitCode = hr ;}
                          LogEvent( FSA_MESSAGE_SERVICE_INITIALIZATION_FAILED , WsbHrAsString(hr), NULL );
                          );

        }

        WsbTrace (OLESTR("Fsa: Created=%ls , Initialized=%ls\n"), 
                  WsbBoolAsString(g_bFsaCreated), WsbBoolAsString(g_bFsaInitialized));

        // initialize Engine server
        if ((! g_pEngServer) && (hr == S_OK)) {
            try {
                //
                // Create and initialize the server.
                //
                WsbAffirmHr( CoCreateInstance( CLSID_HsmServer, 0, CLSCTX_SERVER,  IID_IHsmServer, (void **)&g_pEngServer ) );
                g_bEngCreated = TRUE;

                CComPtr<IWsbServer>      pWsbServer;
                WsbAffirmHr(g_pEngServer->QueryInterface(IID_IWsbServer, (void**) &pWsbServer));
                WsbAffirmHrOk(pWsbServer->SetTrace(g_pTrace));

                WsbAffirmHr(g_pEngServer->Init());
                g_bEngInitialized = TRUE;

            }WsbCatchAndDo(hr,

                           // If the error is a Win32 make it back to a Win32 error else send
                           // the HR in the service specific exit code
                           if ( FACILITY_WIN32 == HRESULT_FACILITY(hr) ){
                           m_status.dwWin32ExitCode = HRESULT_CODE(hr) ;}else{
                          m_status.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
                          m_status.dwServiceSpecificExitCode = hr ;}
                          LogEvent( HSM_MESSAGE_SERVICE_CREATE_FAILED, WsbHrAsString(hr), NULL );
                          );

        }

        WsbTrace (OLESTR("Engine: Created=%ls , Initialized=%ls\n"), 
                  WsbBoolAsString(g_bEngCreated), WsbBoolAsString(g_bEngInitialized));

        if (hr == S_OK) {

            SetServiceStatus(SERVICE_RUNNING);
            LogEvent( HSM_MESSAGE_SERVICE_STARTED, NULL );

            MSG msg;
            while (GetMessage(&msg, 0, 0, 0)) {
                // If something has changed with the devices, then rescan. At somepoint we
                // may want to do a more limited scan (i.e. just update what changed), but this
                // should cover it for now.
                //
                // Since something has changed, we will also force a rewrite of the persistant data.
                if (WM_DEVICECHANGE == msg.message) {

                    CComPtr<IWsbServer> pWsbServer;
                    try {

                        WsbAffirmHr(g_pFsaServer->ScanForResources());

                        WsbAffirmHr(g_pFsaServer->QueryInterface(IID_IWsbServer, (void**) &pWsbServer));
                        WsbAffirmHr(pWsbServer->SaveAll());

                    }WsbCatchAndDo(hr,

                        // If we had a problem then log a message and exit the service. We don't
                        // want to leave the service running, since we might have invalid drive
                        // mappings.
                        LogEvent(FSA_MESSAGE_RESCANFAILED, WsbHrAsString(hr), NULL);
                        PostMessage(NULL, WM_QUIT, 0, 0);
                        );

                    pWsbServer = 0;
                }

                DispatchMessage(&msg);
            }
        }

        LogEvent( HSM_MESSAGE_SERVICE_EXITING, NULL );

        // TEMPORARY - call a function so we can break before release.
        DebugRelease ();

        // prepare for releasing Eng server
        if ((g_pEngServer != 0) && g_bEngCreated && g_bEngInitialized) {
            // Save out server data 
            HSM_SYSTEM_STATE    SysState;

            SysState.State = HSM_STATE_SHUTDOWN;
            hr = g_pEngServer->ChangeSysState(&SysState);
            if (FAILED(hr)) {
                LogEvent( HSM_MESSAGE_SERVICE_FAILED_TO_SHUTDOWN, WsbHrAsString(hr), NULL );
            }
        }

        // Prepare for releasing Fsa server
        if ((g_pFsaServer != 0) && g_bFsaCreated && g_bFsaInitialized) {
            CComPtr<IWsbServer>      pWsbServer;
            HSM_SYSTEM_STATE         SysState;

            hr = g_pFsaServer->QueryInterface(IID_IWsbServer, (void**) &pWsbServer);
            if (hr == S_OK) {
                hr = pWsbServer->SaveAll();
            }

            if (FAILED(hr)) {
                LogEvent( FSA_MESSAGE_SERVICE_FAILED_TO_SAVE_DATABASE, WsbHrAsString(hr), NULL );
            }

            pWsbServer = 0;

            // Persist the databases and release everything
            SysState.State = HSM_STATE_SHUTDOWN;
            hr =  g_pFsaServer->ChangeSysState(&SysState);
            if (FAILED(hr)) {
                LogEvent( FSA_MESSAGE_SERVICE_FAILED_TO_SHUTDOWN, WsbHrAsString(hr), NULL );
            }
        }

        // Release Eng server
        if (g_bEngCreated  && (g_pEngServer != 0)) {
            // Free server inside a crit. section thus avoid conflicts with accessing clients
            EnterCriticalSection(&g_EngCriticalSection);
            g_bEngInitialized = FALSE;
            g_bEngCreated = FALSE;

            // Disconnect all remote clients
            (void)CoDisconnectObject(g_pEngServer, 0);

            // Forse object destroy, ignore reference count here
            IWsbServer *pWsbServer;
            hr = g_pEngServer->QueryInterface(IID_IWsbServer, (void**) &pWsbServer);
            if (hr == S_OK) {
                pWsbServer->Release();
                pWsbServer->DestroyObject();
            }
            g_pEngServer = 0;
            LeaveCriticalSection (&g_EngCriticalSection);
        }

        // Release Fsa server
        if (g_bFsaCreated && (g_pFsaServer != 0)) {
            // Free server inside a crit. section thus avoid conflicts with accessing clients
            EnterCriticalSection(&g_FsaCriticalSection);
            g_bFsaInitialized = FALSE;
            g_bFsaCreated = FALSE;

            // Disconnect all remote clients
            (void)CoDisconnectObject(g_pFsaServer, 0);

            // Forse object destroy, ignore reference count here
            IWsbServer *pWsbServer;
            hr = g_pFsaServer->QueryInterface(IID_IWsbServer, (void**) &pWsbServer);
            if (hr == S_OK) {
                pWsbServer->Release();
                pWsbServer->DestroyObject();
            }
            g_pFsaServer = 0;
            LeaveCriticalSection(&g_FsaCriticalSection);
        }

        _Module.RevokeClassObjects();

        WsbTraceOut(OLESTR("CServiceModule::Run"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
        g_pTrace = 0;

        CoUninitialize();

        // Delete the server critical section
        DeleteCriticalSection(&g_EngCriticalSection);
        DeleteCriticalSection(&g_FsaCriticalSection);
    }WsbCatch(hr);
}


//
//	Tries to start the service as a console application 
//	(not through SCM calls)
//
static void ConsoleApp()
{
    HRESULT hr;

    ::SetConsoleCtrlHandler(ConsoleHandler, TRUE) ;

    // set Registry for process
    hr = CoInitialize (NULL);
    if (SUCCEEDED(hr)) {
        hr = _Module.UpdateRegistryFromResourceD(IDR_Serv2Proc, TRUE);
        CoUninitialize();

        _Module.Run();
        //
        // set Registry back for service
        hr = CoInitialize (NULL);
        if (SUCCEEDED(hr)) {
            hr = _Module.UpdateRegistryFromResourceD(IDR_Proc2Serv, TRUE);
            CoUninitialize();
        }
    }
}

//
//	Callback function for handling console events
//

BOOL WINAPI ConsoleHandler(DWORD dwCtrlType)
{
    switch (dwCtrlType) {
    
    case CTRL_BREAK_EVENT:
    case CTRL_C_EVENT:
    case CTRL_CLOSE_EVENT:
    case CTRL_LOGOFF_EVENT:
    case CTRL_SHUTDOWN_EVENT:
        PostThreadMessage(_Module.dwThreadID, WM_QUIT, 0, 0);
        return TRUE;
    }

    return FALSE ;
}


/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance,
                                HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    _Module.Init(ObjectMap, hInstance);

    TCHAR szTokens[] = _T("-/");

    LPTSTR lpszToken = _tcstok(lpCmdLine, szTokens);
    while (lpszToken != NULL) {
        if (_tcsicmp(lpszToken, _T("UnregServer"))==0) {
            return _Module.UnregisterServer();
        }
        if (_tcsicmp(lpszToken, _T("RegServer"))==0) {
            return _Module.RegisterServer(FALSE);
        }
#ifdef DBG
        if (_tcsicmp(lpszToken, _T("D"))==0) {
            _Module.m_bService = FALSE;
        }
#endif
        lpszToken = _tcstok(NULL, szTokens);
    }

    //
    // Cheap hack to force the ESE.DLL to be loaded before any other threads are started
    //
    LoadLibrary( L"RsIdb.dll" );

    if (_Module.m_bService) {
        _Module.Start();
    } else {
        ConsoleApp ();
    }

    // When we get here, the service has been stopped
    return _Module.m_status.dwWin32ExitCode;
}


void DebugRelease ()
{
    WsbTrace(OLESTR("DebugRelease in"));

    WsbTrace(OLESTR("DebugRelease out"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\hsmconn\hsmconn.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    HsmConn.cpp

Abstract:

    This is the main implementation of the HsmConn dll. This dll provides
    functions for accessing Directory Services and for connecting to
    our services.

Author:

    Rohde Wakefield    [rohde]   21-Oct-1996

Revision History:

--*/


#include "stdafx.h"
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>

// Required by SECURITY.H
#define SECURITY_WIN32
#include <security.h>

// HsmConnPoint objects are used only here
#include "hsmservr.h"

//
// Tracing information
//

#define WSB_TRACE_IS WSB_TRACE_BIT_HSMCONN

//
// _Module instantiation for ATL
//

CComModule _Module;

/////////////////////////////////////////////////////////////////////////////

#define REG_PATH        OLESTR("SOFTWARE\\Microsoft\\RemoteStorage")
#define REG_USE_DS      OLESTR("UseDirectoryServices")

//  Local data
static OLECHAR CNEqual[]                = L"CN=";
static OLECHAR ComputersNodeName[]      = L"Computers";
static OLECHAR DCsNodeName[]            = L"Domain Controllers";
static OLECHAR ContainerType[]          = L"Container";
static OLECHAR DisplaySpecifierName[]   = L"displaySpecifier";
static OLECHAR GuidAttrName[]           = L"remoteStorageGUID";
static OLECHAR RsDisplaySpecifierName[] = L"remoteStorageServicePoint-Display";
static OLECHAR RsNodeName[]             = L"RemoteStorage";
static OLECHAR RsNodeType[]             = L"remoteStorageServicePoint";
static OLECHAR ServiceBindAttrName[]    = L"serviceBindingInformation";
static OLECHAR ServiceBindValue[]       = L"Rsadmin.msc /ds ";

static ADS_ATTR_INFO   aaInfo[2];    // For use in IDirectoryObject
static ADSVALUE        adsValue[2];  // For use in IDirectoryObject
static OLECHAR         DomainName[MAX_COMPUTERNAME_LENGTH];
static BOOL            DSIsWritable = FALSE;          // Default to "NO"
static BOOL            UseDirectoryServices = FALSE;  // Default to "NO"

#if defined(HSMCONN_DEBUG)
    //  We use this and OutputDebugString when we can't use our normal 
    //  tracing.
    OLECHAR dbg_string[200];
#endif



extern "C"
{

//  Local functions
static void    GetDSState(void);
static HRESULT HsmConnectToServer(HSMCONN_TYPE type, 
        const OLECHAR * Server, REFIID riid, void ** ppv);
static const OLECHAR *HsmConnTypeAsString(HSMCONN_TYPE type);
static GUID    HsmConnTypeToGuid(IN HSMCONN_TYPE type);
static HRESULT HsmGetComputerNode(const OLECHAR * compName, 
        IADsContainer **pContainer);
static HRESULT HsmGetDsChild(IADsContainer * pContainer, const OLECHAR * Name,
        REFIID riid, void **ppv);




BOOL WINAPI
DllMain (
    IN  HINSTANCE hInst, 
    IN  ULONG     ulReason,
        LPVOID    /*lpReserved*/
    )

/*++

Routine Description:

    This routine is called whenever a new process and thread attaches
    to this DLL. Its purpose is to initialize the _Module object,
    necessary for ATL.

Arguments:

    hInst - HINSTANCE of this dll.

    ulReason - Context of the attaching/detaching

Return Value:

    non-zero - success
    
    0        - prevent action

--*/

{

    switch ( ulReason ) {

    case DLL_PROCESS_ATTACH:

        //
        // Initialize the ATL module, and prevent
        // any of the additional threads from sending
        // notifications through
        //

        _Module.Init ( 0, hInst );
        DisableThreadLibraryCalls ( hInst );
        GetDSState();
        break;

    case DLL_PROCESS_DETACH:

        //
        // Tell ATL module to terminate
        //

        _Module.Term ( );
        break;

    }

    return ( TRUE );

}


static HRESULT
HsmConnectToServer (
    IN  HSMCONN_TYPE type,
    IN  const OLECHAR * Server,
    IN  REFIID   riid,
    OUT void ** ppv
    )

/*++

Routine Description:

    Given a generic server (connected via HsmConnPoint class)
    connect to it and return back the requested interface 'riid'.

Arguments:

    type - Type of server to connect
    Server - Name of machine on which server is running.

    riid - The interface type to return.

    ppv - Returned interface pointer of the Server.

Return Value:

    S_OK - Connection made, Success.

    E_NOINTERFACE - Requested interface not supported by Server.

    E_POINTER - ppv is not a valid pointer.

    E_OUTOFMEMORY - Low memory condition prevented connection.

    HSM_E_NOT_READY - Engine is not running or not initialized yet

    FSA_E_NOT_READY - Fsa is not running or not initialized yet

--*/

{
    WsbTraceIn ( L"HsmConnectToServer",
        L"type = '%ls' , Server = '%ls', riid = '%ls', ppv = 0x%p",
        HsmConnTypeAsString ( type ), Server, WsbStringCopy ( WsbGuidAsString ( riid ) ), ppv );

    HRESULT hr = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != Server, E_POINTER );
        WsbAssert ( 0 != ppv,    E_POINTER );


        //
        // We will specify the provided HSM as the machine to contact,
        // so Construct a COSERVERINFO with Server.
        //

        REFCLSID rclsid = CLSID_HsmConnPoint;
        COSERVERINFO csi;

        memset ( &csi, 0, sizeof ( csi ) );
        csi.pwszName = (OLECHAR *) Server; // must cast to remove constness

        //
        // Build a MULTI_QI structure to obtain desired interface (necessary for 
        // CoCreateInstanceEx). In our case, we need only one interface.
        //

        MULTI_QI mqi[1];

        memset ( mqi, 0, sizeof ( mqi ) );
        mqi[0].pIID = &IID_IHsmConnPoint;

        //
        // The HsmConnPoint object ic created in the scope of the main HSM service and
        // provides access for HSM server objects
        //

        WsbAffirmHr( CoCreateInstanceEx ( rclsid, 0, CLSCTX_SERVER, &csi, 1, mqi ) );

        //
        // Put returned interfaces in smart pointers so we
        // don't leak a reference in case off throw
        //
        CComPtr<IHsmConnPoint> pConn;

        if( SUCCEEDED( mqi[0].hr ) ) {
            
            pConn = (IHsmConnPoint *)(mqi[0].pItf);
            (mqi[0].pItf)->Release( );

            hr   = mqi[0].hr;

#if 0  // This is now done at the COM process-wide security layer

        /* NOTE: In case that a per-connection security will be require,
           the method CheckAccess should be implemented in CHsmConnPoint */
                   
        //
        // Check the security first
        //
        WsbAffirmHr( mqi[1].hr );
        WsbAffirmHr( pServer->CheckAccess( WSB_ACCESS_TYPE_ADMINISTRATOR ) );
#endif

            // get the server object itself
            switch (type) {

            case HSMCONN_TYPE_HSM: {
                WsbAffirmHr( pConn->GetEngineServer((IHsmServer **)ppv) );
                break;
                }

            case HSMCONN_TYPE_FSA:
            case HSMCONN_TYPE_RESOURCE: {
                WsbAffirmHr( pConn->GetFsaServer((IFsaServer **)ppv) );
                break;
                }

            default: {
                WsbThrow ( E_INVALIDARG );
                break;
                }
            } 

        } else {

            // Make sure interface pointer is safe (NULL) when failing
            *ppv = 0;
        }

    } WsbCatchAndDo ( hr, 

        // Make sure interface pointer is safe (NULL) when failing
        *ppv = 0;
    
    ) // WsbCatchAndDo

    WsbTraceOut ( L"HsmConnectToServer",
        L"HRESULT = %ls, *ppv = %ls",
        WsbHrAsString ( hr ), WsbPtrToPtrAsString ( ppv ) );

    return ( hr );

}

HRESULT
HsmGetComputerNameFromADsPath(
    IN  const OLECHAR * szADsPath,
    OUT OLECHAR **      pszComputerName
)

/*++

Routine Description:

    Extract the computer name from the ADs path of the RemoteStorage node.
    The assumption here is that the full ADs path will contain this substring:
        "CN=RemoteStorage,CN=computername,CN=Computers"
    where computername is what we want to return.

Arguments:

    szADsPath       - The ADs path.

    pszComputerName - The returned computer name.

Return Value:

    S_OK    - Computer name returned OK.

--*/
{
    HRESULT  hr = S_FALSE;
    WCHAR*   pContainerNode;
    WCHAR*   pRSNode;

    WsbTraceIn(OLESTR("HsmGetComputerNameFromADsPath"),
        OLESTR("AdsPath = <%ls>"), szADsPath);

    //  Find the RemoteStorage node name and the computers node name
    //  in the ADs path. If the machine is a DC, then we have to 
    //  check for a "Domain Controllers" level instead.
    *pszComputerName = NULL;
    pRSNode = wcsstr(szADsPath, RsNodeName);
    pContainerNode = wcsstr(szADsPath, ComputersNodeName);
    if(!pContainerNode) {
        pContainerNode = wcsstr(szADsPath, DCsNodeName);
    }
    if (pRSNode && pContainerNode && pRSNode < pContainerNode) {
        WCHAR*  pWc;

        //  Find the "CN=" before the computer name
        pWc = wcsstr(pRSNode, CNEqual);
        if (pWc && pWc < pContainerNode) {
            WCHAR*  pComma;

            //  Skip the "CN="
            pWc += wcslen(CNEqual);

            //  Find the "," after the computer name
            pComma = wcschr(pWc, OLECHAR(','));

            //  Extract the computer name
            if (pWc < pContainerNode && pComma && pComma < pContainerNode) {
                int len;

                len = (int)(pComma - pWc);

                //  Remove '$' from end of name???
                if (0 < len && OLECHAR('$') == pWc[len - 1]) {
                    len--;
                }
                *pszComputerName = static_cast<OLECHAR *>(WsbAlloc(
                        (len + 1) * sizeof(WCHAR)));
                if (*pszComputerName) {
                    wcsncpy(*pszComputerName, pWc, len);
                    (*pszComputerName)[len] = 0;
                    hr = S_OK;
                }
            }
        }
    }

    WsbTraceOut (OLESTR("HsmGetComputerNameFromADsPath"),
        OLESTR("HRESULT = %ls, Computername = <%ls>"),
        WsbHrAsString(hr), (*pszComputerName ? *pszComputerName : OLESTR("")));

    return(hr);
}


static HRESULT HsmGetComputerNode(
    const OLECHAR * Name,
    IADsContainer **ppContainer
)

/*++

Routine Description:

    Return the computer node for the given computer name in the current Domain

Arguments:

    Name        - Computer name.

    ppContainer - Returned interface pointer of the node.

Return Value:

    S_OK - Success.

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn ( L"HsmGetComputerNode", L"Name = <%ls>", Name);

    try {
        WsbAssert(UseDirectoryServices, E_NOTIMPL);

        WCHAR         ComputerDn[MAX_PATH];
        CWsbStringPtr temp;
        ULONG         ulen;

        //  Construct the SamCompatible (whatever that means) name
        temp = DomainName;
        temp.Append("\\");
        temp.Append(Name);
        temp.Append("$");
        WsbTrace(L"HsmGetComputerNode: Domain\\computer = <%ls>\n", 
                static_cast<OLECHAR*>(temp));

        //  Translate that name to a fully qualified one
        ulen = MAX_PATH;
        ComputerDn[0] = WCHAR('\0');
        if (TranslateName(temp, NameSamCompatible,
                NameFullyQualifiedDN, ComputerDn, &ulen)) {
            WsbTrace(L"HsmGetComputerNode: ComputerDn = <%ls>\n", ComputerDn);

            //  Get the computer node
            temp = "LDAP://";
            temp.Append(ComputerDn);
            WsbTrace(L"HsmGetComputerNode: calling ADsGetObject with <%ls>\n", 
                    static_cast<OLECHAR*>(temp));
            WsbAffirmHr(ADsGetObject(temp, IID_IADsContainer, 
                    (void**)ppContainer));
        } else {
            DWORD  err = GetLastError();

            WsbTrace(L"HsmGetComputerNode: TranslateName failed; ComputerDn = <%ls>, err = %ld\n", 
                    ComputerDn, err);
            if (err) {
                WsbThrow(HRESULT_FROM_WIN32(err));
            } else {
                WsbThrow(E_UNEXPECTED);
            }
        }

        WsbTrace(OLESTR("HsmGetComputerNode: got computer node\n"));

    } WsbCatch( hr )

    WsbTraceOut ( L"HsmGetComputerNode", L"HRESULT = %ls, *ppContainer = '%ls'", 
        WsbHrAsString ( hr ), WsbPtrToPtrAsString ( (void**)ppContainer ) );

    return ( hr );
}


static HRESULT
HsmGetDsChild (
    IN  IADsContainer * pContainer,
    IN  const OLECHAR * Name,
    IN  REFIID          riid,
    OUT void **         ppv
    )

/*++

Routine Description:

    This routine returns back the requested child node.

Arguments:

    pContainer - The parent container.

    Name       - The childs name (i.e. value of Name attribute or CN=Name)

    riid       - Desired interface to return.

    ppv        - Returned interface.

Return Value:

    S_OK      - Connection made, Success.

    E_POINTER - Invalid pointer passed in as parameter.

    E_*       - Error

--*/

{
    WsbTraceIn ( L"HsmGetDsChild",
        L"pContainer = '0x%p', Name = '%ls', riid = '%ls', ppv = '0x%p'",
        pContainer, Name, WsbGuidAsString ( riid ), ppv );

    HRESULT hr = S_OK;

    try {
        CWsbStringPtr                 lName;
        CComPtr<IDispatch>            pDispatch;

        // Validate params
        WsbAssert ( 0 != pContainer, E_POINTER );
        WsbAssert ( 0 != Name,       E_POINTER );
        WsbAssert ( 0 != ppv,        E_POINTER );
        WsbAssert(UseDirectoryServices, E_NOTIMPL);

        //  Check to see if the child exists
        lName = Name;
        hr = pContainer->GetObject(NULL, lName, &pDispatch);
        if (FAILED(hr)) {
            hr = S_OK;
            lName.Prepend(CNEqual);
            WsbAffirmHr(pContainer->GetObject(NULL, lName, &pDispatch));
        }

        //  Convert to the correct interface
        WsbAffirmHr(pDispatch->QueryInterface(riid, ppv));

    } WsbCatch( hr )

    WsbTraceOut ( L"HsmGetDsChild", L"HRESULT = %ls, *ppv = '%ls'", 
        WsbHrAsString ( hr ), WsbPtrToPtrAsString ( ppv ) );

    return ( hr );
}


static const OLECHAR *
HsmConnTypeAsString (
    IN  HSMCONN_TYPE type
    )

/*++

Routine Description:

    Gives back a static string representing the connection type. 
    Note return type is strictly ANSI. This is intentional to make
    macro work possible.

Arguments:

    type - the type to return a string for.

Return Value:

    NULL - invalid type passed in.

    Otherwise, a valid char *.

--*/

{
#define STRINGIZE(_str) (OLESTR( #_str ))
#define RETURN_STRINGIZED_CASE(_case) \
case _case:                           \
    return ( STRINGIZE( _case ) );

    //
    // Do the Switch
    //

    switch ( type ) {

    RETURN_STRINGIZED_CASE( HSMCONN_TYPE_HSM );
    RETURN_STRINGIZED_CASE( HSMCONN_TYPE_FSA );
    RETURN_STRINGIZED_CASE( HSMCONN_TYPE_FILTER );
    RETURN_STRINGIZED_CASE( HSMCONN_TYPE_RESOURCE );

    default:

        return ( OLESTR("Invalid Value") );

    }
}

static GUID 
HsmConnTypeToGuid(IN HSMCONN_TYPE type)
{
    GUID serverGuid = GUID_NULL;

    switch ( type ) {
    case HSMCONN_TYPE_HSM:
        serverGuid = CLSID_HsmServer;
        break;
    case HSMCONN_TYPE_FSA:
    case HSMCONN_TYPE_RESOURCE:
        serverGuid = CLSID_CFsaServerNTFS;
        break;
    }
    return(serverGuid);
}


HRESULT
HsmConnectFromName (
    IN  HSMCONN_TYPE type,
    IN  const OLECHAR * Name,
    IN  REFIID riid,
    OUT void ** ppv
    )

/*++

Routine Description:

    When given an name, connect and return the object representing the 
    Server, providing the specified interface.

Arguments:

    type - The type of service / object we are connecting too.

    Name - UNICODE string describing the Server to connect to.

    riid - The interface type to return.

    ppv - Returned interface pointer of the Server.

Return Value:

    S_OK - Connection made, Success.

    E_NOINTERFACE - Requested interface not supported by Server.

    E_POINTER - ppv or Name is not a valid pointer.

    E_OUTOFMEMORY - Low memory condition prevented connection.

    E_INVALIDARG - The given name does not corespond to a known Server.

--*/

{
    WsbTraceIn ( L"HsmConnectFromName",
        L"type = '%ls', Name = '%ls', riid = '%ls', ppv = 0x%p",
        HsmConnTypeAsString ( type ), Name, WsbGuidAsString ( riid ), ppv );
    WsbTrace(OLESTR("HsmConnectFromName: UseDirectoryServices = %ls\n"),
        WsbBoolAsString(UseDirectoryServices));

    HRESULT hr = S_OK;

    try {
        BOOLEAN    done = FALSE;

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != Name, E_POINTER );
        WsbAssert ( 0 != ppv,    E_POINTER );

        if (!done) { // Try without Directory Services

            CWsbStringPtr ComputerName = Name;
            int           i;

            //  Get the computer/server name
            i = wcscspn(Name, OLESTR("\\"));
            ComputerName[i] = 0;

            if (HSMCONN_TYPE_RESOURCE == type) {
                CWsbStringPtr         Path;
                OLECHAR *             rscName;
                CComPtr<IFsaResource> pFsaResource;
                CComPtr<IFsaServer>   pFsaServer;

                WsbAffirmHr(HsmConnectToServer(type, ComputerName, 
                        IID_IFsaServer, (void**)&pFsaServer));

                // Determine if we have a logical name or a sticky name format.
                // The logical name is a format like ("server\NTFS\d") and a sticky name
                // format is like ("server\NTFS\Volume{GUID}\").
                // Find the start of the last section and determine if there is only a single
                // character after it or not.
                rscName = wcsstr ( Name, L"NTFS\\" );
                WsbAssert ( 0 != rscName, E_INVALIDARG );

                // Now point just past the "NTFS\" part of the string. So we are pointing at
                // either a single character, indicating the drive, or the "Volume{GUID}\".
                rscName += 5;       
                Path = rscName;
                if (wcslen (rscName) == 1)  {
                    //  Logical name ("server\NTFS\d") so convert to path and find resource
                    WsbAffirmHr(Path.Append(":\\"));
                    WsbAffirmHr(pFsaServer->FindResourceByPath(Path, &pFsaResource));
                }
                else {
                    // Sticky name ("server\NTFS\Volume{GUID}\") so find resource for it.
                    WsbAffirmHr(pFsaServer->FindResourceByStickyName(Path, &pFsaResource));
                }

                WsbAffirmHr(pFsaResource->QueryInterface(riid, ppv));

            } else {
                WsbAffirmHr(HsmConnectToServer(type, ComputerName, riid, ppv));
            }
        }

    } WsbCatch ( hr )

    WsbTraceOut ( L"HsmConnectFromName",
        L"HRESULT = %ls, *ppv = %ls",
        WsbHrAsString ( hr ), WsbPtrToPtrAsString ( ppv ) );

    return ( hr );

}


HRESULT
HsmConnectFromId (
    IN  HSMCONN_TYPE type,
    IN  REFGUID rguid,
    IN  REFIID riid,
    OUT void ** ppv
    )

/*++

Routine Description:

    Connects to the specified service or object. See HSMCONN_TYPE for
    the types of services and objects. 

Arguments:

    type - The type of service / object we are connecting too.

    rguid - The unique ID of the service / object to connect too.

    riid - The interface type to return.

    ppv - Returned interface pointer of the HSM Server.

Return Value:

    S_OK - Connection made, Success.

    E_NOINTERFACE - Requested interface not supported by HSM Server.

    E_POINTER - ppv or Hsm is not a valid pointer.

    E_OUTOFMEMORY - Low memory condition prevented connection.

    E_INVALIDARG - The given ID and type do not correspond to a known 
                   service or object.

--*/

{
    WsbTraceIn ( L"HsmConnectFromId",
        L"type = '%ls', rguid = '%ls', riid = '%ls', ppv = 0x%p",
        HsmConnTypeAsString ( type ), WsbStringCopy ( WsbGuidAsString ( rguid ) ),
        WsbStringCopy ( WsbGuidAsString ( riid ) ), ppv );
    WsbTrace(OLESTR("HsmConnectFromId: UseDirectoryServices = %ls\n"),
        WsbBoolAsString(UseDirectoryServices));

    HRESULT hr = S_OK;

    try {
        BOOLEAN          DSUsed = FALSE;
        CWsbVariant      guidVariant;
        CComPtr < IADs > pObject;
        CWsbStringPtr    serverName;
        CWsbVariant      serverVariant;

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != ppv,   E_POINTER );

        switch ( type ) {

        case HSMCONN_TYPE_HSM:
        case HSMCONN_TYPE_FSA:
        case HSMCONN_TYPE_FILTER:

            if (DSUsed) {

            } else {

                WsbAffirmHr( WsbGetComputerName( serverName ) );

            }

            //
            // Connect to the server
            //

            WsbAffirmHr ( HsmConnectToServer ( type, serverName, riid, ppv ) );

            break;

        case HSMCONN_TYPE_RESOURCE:
            {
                CComPtr< IFsaServer > pFsaServer;
                GUID serverGuid;
    
                serverGuid = HsmConnTypeToGuid(type);
                WsbAffirmHr ( HsmConnectFromId ( HSMCONN_TYPE_FSA, serverGuid, IID_IFsaServer, (void**)&pFsaServer ) );

                CComPtr< IFsaResource > pFsaResource;

                WsbAffirmHr ( pFsaServer->FindResourceById ( rguid, &pFsaResource ) );
                WsbAffirmHr ( pFsaResource->QueryInterface ( riid, ppv ) );
            }
            break;

        default:

            WsbThrow ( E_INVALIDARG );

        }

    } WsbCatch ( hr )

    WsbTraceOut ( L"HsmConnectFromId",
        L"HRESULT = %ls, *ppv = %ls",
        WsbHrAsString ( hr ), WsbPtrToPtrAsString ( ppv ) );

    return ( hr );

}


HRESULT
HsmPublish (
    IN  HSMCONN_TYPE type,
    IN  const OLECHAR * Name,
    IN  REFGUID rguidObjectId,
    IN  const OLECHAR * Server,
    IN  REFGUID rguid
    )

/*++

Routine Description:

    Publish (i.e. store) information about the service/object in
    Directory Services.

Arguments:

    type - The type of service/object.

    Name - Name (possibly preceded by a subpath) of the Service/Object.

    rguidObjectId - The ID that the object is known by.

    Server - The server (computer name) on which the service actually exists. 
            For resources, this will be NULL since it is implicit in the
            FSA specified by rguid.

    rguid - For resources, the ID of the FSA. For services, the CLSID of
            the service's class factory ie. CLSID_HsmServer.

Return Value:

    S_OK - Connection made, Success.

    E_POINTER - Name or Server is not a valid pointer.

    E_OUTOFMEMORY - Low memory condition prevented connection.

--*/

{
    HRESULT hr = S_OK;

    WsbTraceIn ( L"HsmPublish",
        L"type = '%ls', Name = '%ls', rguidObjectId = '%ls', Server = '%ls', rguid = '%ls'",
        HsmConnTypeAsString ( type ), Name, 
        WsbStringCopy ( WsbGuidAsString ( rguidObjectId ) ), Server,
        WsbStringCopy ( WsbGuidAsString ( rguid ) ) );
    WsbTrace(OLESTR("HsmPublish: UseDirectoryServices = %ls\n"),
        WsbBoolAsString(UseDirectoryServices));

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != Name, E_POINTER );
        WsbAssert ( ( HSMCONN_TYPE_RESOURCE == type ) || ( 0 != Server ), E_POINTER );

        // Perhaps we should output a log event if the DS is not writable

        //  We now only publish the Engine service.  Perhaps in the future we
        //  will publish additional information
        if (HSMCONN_TYPE_HSM == type && UseDirectoryServices && DSIsWritable) {
            CWsbStringPtr    pathToName;

            try {
                DWORD                         aSet;
                CWsbStringPtr                 guidString(rguidObjectId);
                HRESULT                       hrGetNode;
                CComPtr<IADsContainer>        pComputer;
                CComPtr<IDispatch>            pDispatch;
                CComPtr<IDirectoryObject>     pDirObj;
                CComPtr<IADs>                 pNode;

                //  Save the node name for the event log message
                pathToName = Name;
                pathToName.Append("\\");
                pathToName.Append(RsNodeName);

                //  Get the computer node
                WsbAffirmHr(HsmGetComputerNode(Name, &pComputer));

                //  See if we're already published
                hrGetNode = HsmGetDsChild(pComputer, RsNodeName, 
                        IID_IADs, (void**)&pNode);

                //  If not, add our node
                if (HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT) == hrGetNode) {
                    CWsbBstrPtr                relPath(RsNodeName);

                    relPath.Prepend(CNEqual);

                    WsbAffirmHr(pComputer->Create(RsNodeType, relPath, &pDispatch));
                    WsbAffirmHr(pDispatch->QueryInterface(IID_IADs, 
                            (void**)&pNode));

                    //  Force info out of cache
                    WsbAffirmHr(pNode->SetInfo());
                } else {
                    WsbAffirmHr(hrGetNode);
                }

                //  Set the GUID & ServiceBinding values
                adsValue[0].dwType = ADSTYPE_CASE_IGNORE_STRING;
                adsValue[0].CaseIgnoreString = (WCHAR*)guidString;

                aaInfo[0].pszAttrName = GuidAttrName;
                aaInfo[0].dwControlCode = ADS_ATTR_UPDATE;
                aaInfo[0].dwADsType = ADSTYPE_CASE_IGNORE_STRING;
                aaInfo[0].pADsValues = &adsValue[0];
                aaInfo[0].dwNumValues = 1;

                adsValue[1].dwType = ADSTYPE_CASE_IGNORE_STRING;
                adsValue[1].CaseIgnoreString = ServiceBindValue;

                aaInfo[1].pszAttrName = ServiceBindAttrName;
                aaInfo[1].dwControlCode = ADS_ATTR_UPDATE;
                aaInfo[1].dwADsType = ADSTYPE_CASE_IGNORE_STRING;
                aaInfo[1].pADsValues = &adsValue[1];
                aaInfo[1].dwNumValues = 1;

                WsbAffirmHr(pNode->QueryInterface(IID_IDirectoryObject, 
                       (void**)&pDirObj));
                WsbAffirmHr(pDirObj->SetObjectAttributes(aaInfo, 2, &aSet));
                WsbTrace(L"HsmPublish: after SetObjectAttributes, aSet = %ld\n",
                        aSet);

                WsbLogEvent(WSB_MESSAGE_PUBLISH_IN_DS, 0, NULL,
                        static_cast<OLECHAR*>(pathToName), NULL);
            } WsbCatchAndDo(hr, 
                WsbLogEvent(WSB_MESSAGE_PUBLISH_FAILED, 0, NULL,
                        static_cast<OLECHAR*>(pathToName), NULL);
                hr = S_OK;  // Don't stop service just for this
            )
        }

    } WsbCatch ( hr )

    WsbTraceOut ( L"HsmPublish", L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return ( hr );

}



//  GetDSState - determine if we're using Directory Services or not
static void GetDSState(void)
{

    BOOL                     CheckForDS = TRUE;
    DOMAIN_CONTROLLER_INFO * dc_info;
    DWORD                    size;
    OLECHAR                  vstr[32];
    DWORD                    status;

    UseDirectoryServices = FALSE;

    //  Should we attempt to use directory services in this module?
    //  (Setting the registry value to "0" allows us to avoid Directory
    //  Services completely

    if (S_OK == WsbGetRegistryValueString(NULL, REG_PATH, REG_USE_DS,
            vstr, 32, &size)) {
        OLECHAR *stop;
        ULONG   value;

        value = wcstoul(vstr,  &stop, 10 );
        if (0 == value) {
            CheckForDS = FALSE;
        }
    }

    //  Get the account domain name
    WsbGetAccountDomainName(DomainName, MAX_COMPUTERNAME_LENGTH );

#if defined(HSMCONN_DEBUG)
    swprintf(dbg_string, L"Account domain name = <%ls>\n", DomainName);
    OutputDebugString(dbg_string);
#endif

    //  Check if Directory Services is available
    if (CheckForDS) {
        status = DsGetDcName(NULL, NULL, NULL, NULL, 
                DS_DIRECTORY_SERVICE_REQUIRED | DS_IS_FLAT_NAME | 
                DS_RETURN_FLAT_NAME, &dc_info);

#if defined(HSMCONN_DEBUG)
        swprintf(dbg_string, L"DsGetDcName status = %d\n", status);
        OutputDebugString(dbg_string);
#endif

        if (NO_ERROR == status) {

#if defined(HSMCONN_DEBUG)
            swprintf(dbg_string, L"dc_info->DomainName = <%ls>\n", dc_info->DomainName);
            OutputDebugString(dbg_string);
#endif

            if (dc_info->Flags & DS_DS_FLAG) {
                wcscpy(DomainName, dc_info->DomainName);
                UseDirectoryServices = TRUE;
                if (dc_info->Flags & DS_WRITABLE_FLAG) {
                    DSIsWritable = TRUE;
                }
            }
            NetApiBufferFree(dc_info);
        }
    }

#if defined(HSMCONN_DEBUG)
    swprintf(dbg_string, L"dHsmConn - GetDSState: UseDirectoryServices = %ls\n", 
           WsbBoolAsString(UseDirectoryServices));
    OutputDebugString(dbg_string);
#endif
}

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\hsmservr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#ifndef _STDAFX_H
#define _STDAFX_H

//
// These NT header files must be included before any Win32 stuff or you
// get lots of compiler errors
//
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#define WSB_TRACE_IS WSB_TRACE_BIT_HSMSERV
#define WSB_ATL_COM_SERVICE

#include <wsb.h>
#include "resource.h"
#include "esent.h"

extern CComPtr<IWsbTrace> g_pTrace;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !ifndef _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\hsmservr\service\makefile.inc ===
$(O)\hsmservr.res: ..\hsmservr.rgs   \
	           ..\hsmconpt.rgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\idb\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Wsb.rc
//
#define IDR_CWsbDbKey                   12
#define IDS_WSBDBKEY_DESC               14
#define IDR_CWsbDbSys                   20
#define IDS_WSBDBSYS_DESC               20


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\idb\makefile.inc ===
$(O)\rsidb.res:  \
              wsbdbkey.rgs   \
              wsbdbsys.rgs

stdafx.h: ..\inc\wsb.h ..\inc\wsbdb.h

clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\idb\rsidb.cpp ===
// WsbIdb.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      Modify the custom build rule for Wsb.idl by adding the following 
//      files to the Outputs.  You can select all of the .IDL files by 
//      expanding each project and holding Ctrl while clicking on each of them.
//          Wsb_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f Wsbps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"

#include "wsb.h"
#include "wsbdbsys.h"
#include "wsbdbent.h"
#include "wsbdbkey.h"

//#include "dlldatax.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CWsbDbKey, CWsbDbKey)
    OBJECT_ENTRY(CLSID_CWsbDbSys, CWsbDbSys)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH) {

        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);

    }

    else if (dwReason == DLL_PROCESS_DETACH) {

        _Module.Term();

    }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
    // Add service entries
//    hRes = _Module.UpdateRegistryFromResourceS(IDR_Wsb, TRUE);
//  if (FAILED(hRes))
//      return hRes;

#endif
    HRESULT hr;

    // registers object, typelib and all interfaces in typelib
    hr = CoInitialize( 0 );
    if (SUCCEEDED(hr)) {
        hr = _Module.RegisterServer( FALSE );
        CoUninitialize( );
    }
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    // Remove service entries
//    _Module.UpdateRegistryFromResourceS(IDR_Wsb, FALSE);

    hr = CoInitialize( 0 );
    if (SUCCEEDED(hr)) {
        _Module.UnregisterServer();
        hr = S_OK;
    }
    CoUninitialize( );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\idb\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#ifndef _STDAFX_H
#define _STDAFX_H

#define WSB_TRACE_IS        WSB_TRACE_BIT_IDB

#include "wsb.h"

#include "esent.h"

#include "wsbdb.h"


#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\idb\wsbdbkey.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Wsbdbkey.h

Abstract:

    The CWsbDbKey class, which provides support for IDB entities.

Author:

    Ron White   [ronw]   23-Dec-1996

Revision History:

--*/


#ifndef _WSBDBKEY_
#define _WSBDBKEY_

#include "resource.h"
#include "wsbdb.h"



/*++

Class Name:
    
    CWsbDbKey

Class Description:

    A data base key object.

--*/

class CWsbDbKey : 
    public CWsbObject,
    public IWsbDbKey,
    public IWsbDbKeyPriv,
    public CComCoClass<CWsbDbKey,&CLSID_CWsbDbKey>
{
friend class CWsbDbEntity;
public:
    CWsbDbKey() {}
BEGIN_COM_MAP(CWsbDbKey)
    COM_INTERFACE_ENTRY(IWsbDbKey)
    COM_INTERFACE_ENTRY(IWsbDbKeyPriv)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CWsbDbKey)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbDbKey
public:
    STDMETHOD(AppendBool)(BOOL value);
    STDMETHOD(AppendBytes)(UCHAR* value, ULONG size);
    STDMETHOD(AppendFiletime)(FILETIME value);
    STDMETHOD(AppendGuid)(GUID value);
    STDMETHOD(AppendLonglong)(LONGLONG value);
    STDMETHOD(AppendString)(OLECHAR* value);
    STDMETHOD(GetType)(ULONG* pType);
    STDMETHOD(SetToBool)(BOOL value);
    STDMETHOD(SetToBytes)(UCHAR* value, ULONG size);
    STDMETHOD(SetToFiletime)(FILETIME value);
    STDMETHOD(SetToGuid)(GUID value);
    STDMETHOD(SetToLonglong)(LONGLONG value);
    STDMETHOD(SetToString)(OLECHAR* value);
    STDMETHOD(SetToUlong)(ULONG value);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed);

// Internal helper functions
public:
    STDMETHOD(GetBytes)(UCHAR** ppBytes, ULONG* pSize);
    STDMETHOD(SetType)(ULONG type) { 
        m_type = type; return(S_OK); }
protected:
    BOOL make_key(ULONG size);

protected:
    ULONG           m_max;   // Max size of m_value
    ULONG           m_size;  // Number of bytes in m_value being used
    UCHAR*          m_value;
    ULONG           m_type;  // Key type
};


#endif // _WSBDBKEY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\idb\wsbdbent.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Wsbdbent.cpp

Abstract:

    The CWsbDbEntity and CWsbDbKey classes.

Author:

    Ron White   [ronw]   11-Dec-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsbdbsys.h"
#include "wsbdbkey.h"


// Flags for binary search
#define BIN_EQ              0x0001
#define BIN_GT              0x0002
#define BIN_LT              0x0004
#define BIN_GTE             (BIN_EQ | BIN_GT)
#define BIN_LTE             (BIN_EQ | BIN_LT)

//  Flags for CopyValues/GetValue/SetValue functions
#define EV_DERIVED_DATA    0x0001
#define EV_INDEX           0x0002
#define EV_POS             0x0004
#define EV_ASNEW           0x0008
#define EV_USEKEY          0x0010
#define EV_SEQNUM          0x0020
#define EV_ALL             0xFFFF



HRESULT
CWsbDbEntity::Clone(
    IN REFIID riid,
    OUT void** ppEntity
    )

/*++

Implements:

  IWsbDbEntity::Clone

--*/
{
    HRESULT             hr = S_OK;
    
    WsbTraceIn(OLESTR("CWsbDbEntity::Clone(IWsbEntity)"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);

    try {
        CLSID                    clsid;
        CComPtr<IWsbDbEntity>    pEntity;
        CComPtr<IWsbDbEntityPriv> pEntityPriv;
        CComPtr<IPersistStream>  pIPersistStream;
        IUnknown*                pIUnknown;

        WsbAssert(0 != ppEntity, E_POINTER);

        // Create a new entity instance.
        pIUnknown = (IUnknown *)(IWsbPersistable *)(CWsbCollectable *)this;
        WsbAffirmHr(pIUnknown->QueryInterface(IID_IPersistStream, 
                (void**) &pIPersistStream));
        WsbAffirmHr(pIPersistStream->GetClassID(&clsid));
        WsbAffirmHr(CoCreateInstance(clsid, NULL, CLSCTX_ALL, 
                IID_IWsbDbEntity, (void**) &pEntity));
        WsbAffirmHr(pEntity->QueryInterface(IID_IWsbDbEntityPriv, 
                (void**)&pEntityPriv))

        // Initialize the clone
        if (m_pDb) {
            WsbAffirmHr(pEntityPriv->Init(m_pDb, m_pDbSys, m_RecInfo.Type, m_SessionId));
        }

        // Copy data into the clone
        WsbAffirmHr(pEntityPriv->CopyValues(EV_ALL, this));

        // Get the requested interface
        WsbAffirmHr(pEntity->QueryInterface(riid, (void**)ppEntity));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::Clone(IWbEntity)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::Copy(
    IWsbDbEntity* pEntity
    )

/*++

Implements:

  IWsbDbEntityPriv::Copy

Comments:

  Copy the data in the derived object.

--*/

{
    HRESULT             hr = S_OK;
    
    WsbTraceIn(OLESTR("CWsbDbEntity::Copy(IWsbDbEntity)"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);

    try {
        HGLOBAL                  hMem;
        CComPtr<IPersistStream>  pIPersistStream1;
        CComPtr<IPersistStream>  pIPersistStream2;
        CComPtr<IStream>         pIStream;
        IUnknown*                pIUnknown;

        WsbAssert(0 != pEntity, E_POINTER);

        // Get PersistStream interfaces for myself
        pIUnknown = (IUnknown *)(IWsbPersistable *)(CWsbCollectable *)this;
        WsbAffirmHr(pIUnknown->QueryInterface(IID_IPersistStream, (void**) &pIPersistStream1));
        WsbAffirmHr(pEntity->QueryInterface(IID_IPersistStream, (void**) &pIPersistStream2));

        // Create a memory stream
        WsbAffirmHr(getMem(&hMem));
        WsbAffirmHr(CreateStreamOnHGlobal(hMem, FALSE, &pIStream));

        // Save the other entity to the stream
        WsbAffirmHr(pIPersistStream2->Save(pIStream, FALSE));
        pIStream = 0;

        // Load myself from the memory
        WsbAffirmHr(fromMem(hMem));
        GlobalFree(hMem);

        SetIsDirty(TRUE);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::Copy(IWbEntity)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::CopyValues(
    ULONG flags,
    IWsbDbEntity* pEntity
    )

/*++

Implements:

  IWsbDbEntityPriv::CopyValues

Comments:

  Selectively copy some DBEntity values from one entity to another.

--*/

{
    HRESULT             hr = S_OK;
    
    WsbTraceIn(OLESTR("CWsbDbEntity::CopyValues(IWsbEntity)"), OLESTR(""));

    try {
        ULONG  value;

        CComPtr<IWsbDbEntityPriv> pEntityPriv;

        // Copy derived data
        if (flags & EV_DERIVED_DATA) {
            WsbAffirmHr(Copy(pEntity));
        }
        WsbAffirmHr(pEntity->QueryInterface(IID_IWsbDbEntityPriv,
                (void**)&pEntityPriv));

        // Copy DbEntity specific data
        if (flags & EV_USEKEY) {
            WsbAffirmHr(pEntityPriv->GetValue(EV_USEKEY, &value));
            if (m_pKeyInfo[m_UseKeyIndex].Type != value) {
                WsbAffirmHr(UseKey(value));
            }
        }

        if (flags & EV_SEQNUM) {
            WsbAffirmHr(pEntityPriv->GetValue(EV_SEQNUM, &value));
            m_SeqNum = (LONG)value;
        }

        if (flags & EV_ASNEW) {
            WsbAffirmHr(pEntityPriv->GetValue(EV_ASNEW, &value));
            if (value) {
                WsbAffirmHr(MarkAsNew());
            }
        }
        SetIsDirty(TRUE);
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::CopyValues(IWbEntity)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbEntity::Disconnect(
    void
    )

/*++

Implements:

  IWsbDbEntityPriv::Disconnect

Comments:

    Disconnect the entity from its database (to reduce the DBs
    reference count).

--*/

{
    HRESULT             hr = S_OK;
    
    WsbTraceIn(OLESTR("CWsbDbEntity::Disconnect()"), OLESTR(""));

    try {
        if (m_pDb) {
//          WsbAffirmHr(m_pDb->Release());
            m_pDb = NULL;   // Release is automatic
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::Disconnect()"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::GetCurKey(
    IWsbDbKey** ppKey
    )

/*++

Implements:

  IWsbDbEntityPriv::GetCurKey

Comments:

  Return the current key.

--*/

{
    HRESULT             hr = S_OK;
    
    WsbTraceIn(OLESTR("CWsbDbEntity::GetCurKey"), OLESTR(""));

    try {
        ULONG kType = 0;

        if (m_pKeyInfo) {
            kType = m_pKeyInfo[m_UseKeyIndex].Type;
        }
        WsbAffirmHr(GetKey(kType, ppKey));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::GetCurKey(IWbEntity)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbEntity::GetKey(
    ULONG       KeyType,
    IWsbDbKey** ppKey
    )

/*++

Implements:

  IWsbDbEntityPriv::GetKey

Comments:

  Return the specified key.

--*/

{
    HRESULT             hr = S_OK;
    
    WsbTraceIn(OLESTR("CWsbDbEntity::GetKey"), OLESTR(""));

    try {
        CComPtr<IWsbDbKey> pKey;
        CComPtr<IWsbDbKeyPriv> pKeyPriv;

        WsbAssert(0 != ppKey, E_POINTER);

        WsbAffirmHr(CoCreateInstance(CLSID_CWsbDbKey, 0, CLSCTX_SERVER, 
                  IID_IWsbDbKey, (void **)&pKey ));
        WsbAffirmHr(pKey->QueryInterface(IID_IWsbDbKeyPriv, 
                (void**)&pKeyPriv));
        WsbAffirmHr(pKeyPriv->SetType(KeyType));
        WsbAffirmHr(UpdateKey(pKey));
        *ppKey = pKey;
        (*ppKey)->AddRef();
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::GetKey(IWbEntity)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::FindEQ(
    void
    )

/*++

Implements:

  IWsbDbEntity::FindEQ

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbDbPriv> pDbImp;

    WsbTraceIn(OLESTR("CWsbDbEntity::FindEQ"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);
    
    try {
        CComPtr<IWsbDbEntity>          pEntity;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
        WsbAffirmHr(pDbImp->Lock());

        WsbAffirmHr(jet_seek(JET_bitSeekEQ));
        WsbAffirmHr(jet_get_data());

    } WsbCatch(hr);

    if (pDbImp) {
        WsbAffirmHr(pDbImp->Unlock());
    }
    WsbTraceOut(OLESTR("CWsbDbEntity::FindEQ"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::FindGT(
    void
    )

/*++

Implements:

  IWsbDbEntity::FindGT

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbDbPriv> pDbImp;

    WsbTraceIn(OLESTR("CWsbDbEntity::FindGT"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);
    
    try {
        CComPtr<IWsbDbEntity>          pEntity;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
        WsbAffirmHr(pDbImp->Lock());

        WsbAffirmHr(jet_seek(JET_bitSeekGT));
        WsbAffirmHr(jet_get_data());

    } WsbCatch(hr);

    if (pDbImp) {
        WsbAffirmHr(pDbImp->Unlock());
    }
    WsbTraceOut(OLESTR("CWsbDbEntity::FindGT"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::FindGTE(
    void
    )

/*++

Implements:

  IWsbDbEntity::FindGTE

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbDbPriv> pDbImp;

    WsbTraceIn(OLESTR("CWsbDbEntity::FindGTE"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);
    
    try {
        CComPtr<IWsbDbEntity>          pEntity;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
        WsbAffirmHr(pDbImp->Lock());

        WsbAffirmHr(jet_seek(JET_bitSeekGE));
        WsbAffirmHr(jet_get_data());
    } WsbCatch(hr);

    if (pDbImp) {
        WsbAffirmHr(pDbImp->Unlock());
    }
    WsbTraceOut(OLESTR("CWsbDbEntity::FindGTE"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::FindLT(
    void
    )

/*++

Implements:

  IWsbDbEntity::FindLT

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbDbPriv> pDbImp;

    WsbTraceIn(OLESTR("CWsbDbEntity::FindLT"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);
    
    try {
        CComPtr<IWsbDbEntity>          pEntity;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
        WsbAffirmHr(pDbImp->Lock());

        WsbAffirmHr(jet_seek(JET_bitSeekLT));
        WsbAffirmHr(jet_get_data());
    } WsbCatch(hr);

    if (pDbImp) {
        WsbAffirmHr(pDbImp->Unlock());
    }
    WsbTraceOut(OLESTR("CWsbDbEntity::FindLT"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::FindLTE(
    void
    )

/*++

Implements:

  IWsbDbEntity::FindLTE

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbDbPriv> pDbImp;

    WsbTraceIn(OLESTR("CWsbDbEntity::FindLTE"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);
    
    try {
        CComPtr<IWsbDbEntity>          pEntity;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
        WsbAffirmHr(pDbImp->Lock());

        WsbAffirmHr(jet_seek(JET_bitSeekLE));
        WsbAffirmHr(jet_get_data());
    } WsbCatch(hr);

    if (pDbImp) {
        WsbAffirmHr(pDbImp->Unlock());
    }
    WsbTraceOut(OLESTR("CWsbDbEntity::FindLTE"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbEntity::First(
    void
    )

/*++

Implements:

  IWsbDbEntity::First.

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbDbPriv> pDbImp;

    WsbTraceIn(OLESTR("CWsbDbEntity::First"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);
    
    try {
        CComPtr<IWsbDbEntity>          pEntity;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
        WsbAffirmHr(pDbImp->Lock());

        WsbAffirmHr(jet_move(JET_MoveFirst));
        WsbAffirmHr(jet_get_data());
        m_SaveAsNew = FALSE;

    } WsbCatch(hr);

    if (pDbImp) {
        WsbAffirmHr(pDbImp->Unlock());
    }
    WsbTraceOut(OLESTR("CWsbDbEntity::First"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::GetValue(
    ULONG flag, 
    ULONG* pValue
    )

/*++

Implements:

  IWsbDbEntityPriv::GetValue

Comments:

  Get a specific (based on flag) value from a DBEntity.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::GetValue"), OLESTR(""));
    
    try {
        switch (flag) {
        case EV_INDEX:
            break;
        case EV_POS:
            break;
        case EV_ASNEW:
            *pValue = m_SaveAsNew;
            break;
        case EV_USEKEY:
            *pValue = m_pKeyInfo[m_UseKeyIndex].Type;
            break;
        case EV_SEQNUM:
            *pValue = (ULONG)m_SeqNum;
            break;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::GetValue"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CWsbDbEntity::SetSequentialScan(
    void
    )

/*++

Implements:

  IWsbDbEntity::SetSequentialScan.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::SetSequentialScan"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"), m_SessionId, m_TableId);
    
    try {
        JET_ERR jstat = JET_errSuccess;

        // Set to sequential traversing
        jstat = JetSetTableSequential(m_SessionId, m_TableId, 0);
        WsbAffirmHr(jet_error(jstat));

        m_Sequential = TRUE;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::SetSequentialScan"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CWsbDbEntity::ResetSequentialScan(
    void
    )

/*++

Implements:

  IWsbDbEntity::ResetSequentialScan.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::ResetSequentialScan"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"), m_SessionId, m_TableId);
    
    try {
        JET_ERR jstat = JET_errSuccess;

        // Set to sequential traversing
        jstat = JetResetTableSequential(m_SessionId, m_TableId, 0);
        WsbAffirmHr(jet_error(jstat));

        m_Sequential = FALSE;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::ResetSequentialScan"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbEntity::Init(
    IN IWsbDb* pDb,
    IN IWsbDbSys *pDbSys, 
    IN ULONG   RecType,
    IN JET_SESID SessionId
    )

/*++

Implements:

  IWsbDbEntity::Init

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::Init"), OLESTR(""));
    
    try {

        WsbAssert(0 != pDb, E_POINTER);
        WsbAssert(0 != pDbSys, E_POINTER);

        // Don't allow DB Sys switch
        if (pDbSys != m_pDbSys) {
            m_pDbSys = pDbSys;  // Automatic AddRef() on Db Sys object
        }

        // Don't allow DB switch
        if (pDb != m_pDb) {
            CComPtr<IWsbDbPriv>  pDbImp;
//            CComQIPtr<IWsbDbSessionPriv, &IID_IWsbDbSessionPriv> pSessionPriv = pSession;

            WsbAssert(m_pDb == 0, WSB_E_INVALID_DATA);
            m_pDb = pDb;  // Automatic AddRef() on Db object
//            WsbAssertHr(pSessionPriv->GetJetId(&m_Session));

            //  Get info about myself from the IDB object
            WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
            WsbAffirmHr(pDbImp->GetRecInfo(RecType, &m_RecInfo));
            WsbAssert(m_RecInfo.nKeys > 0, E_INVALIDARG);

            //  Get info about my keys
            m_pKeyInfo = (COM_IDB_KEY_INFO*)WsbAlloc(sizeof(COM_IDB_KEY_INFO) * 
                    m_RecInfo.nKeys);
            WsbAffirmHr(pDbImp->GetKeyInfo(RecType, m_RecInfo.nKeys, m_pKeyInfo));

            //  Get the maximum amount of memory need to hold a streamed
            //  copy of the user data
//          ULONG                minSize;
//          WsbAffirmHr(pDbImp->GetRecSize(m_RecInfo.Type, &minSize, &m_RecInfo.MaxSize));

            m_SeqNum = -1;
            m_PosOk = FALSE;
            m_SessionId = SessionId;

            //  Get Jet IDs (and a new table ID unique to this entity)
            WsbAffirmHr(pDbImp->GetJetIds(m_SessionId, m_RecInfo.Type, 
                    &m_TableId, &m_ColId));

            WsbAffirmHr(getMem(&m_hMem));

            //  Set the first key as the default
            UseKey(m_pKeyInfo[0].Type);
        }

    } WsbCatch(hr);

    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);
    WsbTraceOut(OLESTR("CWsbDbEntity::Init"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbEntity::Last(
    void
    )

/*++

Implements:

  IWsbDbEntity::Last.

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbDbPriv> pDbImp;

    WsbTraceIn(OLESTR("CWsbDbEntity::Last"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);
    
    try {
        CComPtr<IWsbDbEntity>          pEntity;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
        WsbAffirmHr(pDbImp->Lock());

        WsbAffirmHr(jet_move(JET_MoveLast));
        WsbAffirmHr(jet_get_data());
        m_SaveAsNew = FALSE;

    } WsbCatch(hr);

    if (pDbImp) {
        WsbAffirmHr(pDbImp->Unlock());
    }
    WsbTraceOut(OLESTR("CWsbDbEntity::Last"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::MarkAsNew(
    void
    )

/*++

Implements:

  IWsbDbEntity::MarkAsNew

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::MarkAsNew"), OLESTR(""));
    
    try {

        m_SaveAsNew = TRUE;

        m_SeqNum = -1;
        m_PosOk = FALSE;
        SetIsDirty(TRUE);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::MarkAsNew"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbEntity::Next(
    void
    )

/*++

Implements:

  IWsbDbEntity::Next.

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbDbPriv> pDbImp;

    WsbTraceIn(OLESTR("CWsbDbEntity::Next"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);
    
    try {
        CComPtr<IWsbDbEntity>          pEntity;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
        WsbAffirmHr(pDbImp->Lock());

        WsbAffirmHr(jet_make_current());
        WsbAffirmHr(jet_move(JET_MoveNext));
        WsbAffirmHr(jet_get_data());
        m_SaveAsNew = FALSE;

    } WsbCatch(hr);

    if (pDbImp) {
        WsbAffirmHr(pDbImp->Unlock());
    }
    WsbTraceOut(OLESTR("CWsbDbEntity::Next"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbEntity::Previous(
    void
    )

/*++

Implements:

  IWsbDbEntity::Previous.

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbDbPriv> pDbImp;

    WsbTraceIn(OLESTR("CWsbDbEntity::Previous"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);
    
    try {
        CComPtr<IWsbDbEntity>          pEntity;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
        WsbAffirmHr(pDbImp->Lock());

        WsbAffirmHr(jet_make_current());
        WsbAffirmHr(jet_move(JET_MovePrevious));
        WsbAffirmHr(jet_get_data());
        m_SaveAsNew = FALSE;

    } WsbCatch(hr);

    if (pDbImp) {
        WsbAffirmHr(pDbImp->Unlock());
    }
    WsbTraceOut(OLESTR("CWsbDbEntity::Previous"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbEntity::Print(
    IStream* pStream
    )

/*++

Implements:

  IWsbDbEntity::Print.

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbDbPriv> pDbImp;

    WsbTraceIn(OLESTR("CWsbDbEntity::Print"), OLESTR(""));
    
    try {
        CComPtr<IWsbDbEntity>          pEntity;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));

        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR(" (IDB SeqNum = %6ld) "), m_SeqNum));

    } WsbCatch(hr);
    WsbTraceOut(OLESTR("CWsbDbEntity::Print"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::Remove(
    void
    )

/*++

Implements:

  IWsbDbEntity::Remove

--*/
{
    HRESULT              hr = S_OK;
    CComPtr<IWsbDbPriv>  pDbImp;

    WsbTraceIn(OLESTR("CWsbDbEntity::Remove"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);
    
    try {
        CComPtr<IUnknown>         pIUn;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
        WsbAffirmHr(pDbImp->Lock());

        JET_ERR                         jstat;

        //  Make sure this record is the current record.
        WsbAffirmHr(jet_make_current());

        //  Delete the record
        jstat = JetDelete(m_SessionId, m_TableId);
        WsbAffirmHr(jet_error(jstat));

        CComQIPtr<IWsbDbSysPriv, &IID_IWsbDbSysPriv> pDbSysPriv = m_pDbSys;
        WsbAffirmPointer(pDbSysPriv);
        WsbAffirmHr(pDbSysPriv->IncrementChangeCount());
    } WsbCatch(hr);

    if (pDbImp) {
        WsbAffirmHr(pDbImp->Unlock());
    }
    WsbTraceOut(OLESTR("CWsbDbEntity::Remove"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::SetValue(
    ULONG flag, 
    ULONG value
    )

/*++

Implements:

  IWsbDbEntityPriv::SetValue

Comments:

  Set a specific data value (base on flag).

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::SetValue"), OLESTR(""));
    
    try {
        CComPtr<IWsbDbPriv>             pDbImp;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));

        switch (flag) {
        case EV_INDEX:
            break;
        case EV_POS:
            break;
        case EV_ASNEW:
            if (value) {
                m_SaveAsNew = TRUE;
            } else {
                m_SaveAsNew = FALSE;
            }
            break;
        case EV_USEKEY:
            m_pKeyInfo[m_UseKeyIndex].Type = value;
            break;
        case EV_SEQNUM:
            m_SeqNum = (LONG)value;
            break;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::SetValue"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbEntity::UseKey(
    IN ULONG type
    )

/*++

Implements:

  IWsbDbEntity::UseKey

--*/
{
    HRESULT             hr = S_OK;
    
    WsbTraceIn(OLESTR("CWsbDbEntity::UseKey"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);

    try {
        CComPtr<IWsbDbPriv>    pDbImp;

        // Check that this is a valid key type
        for (int i = 0; i < m_RecInfo.nKeys; i++) {
            // Special case for type == 0; this means to use the
            // sequence number key
            if (0 == type) break;
            if (m_pKeyInfo[i].Type == type) break;
        }
        WsbAssert(i < m_RecInfo.nKeys, E_INVALIDARG);
        m_UseKeyIndex = (USHORT)i;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));

        size_t                          ilen;
        char *                          index_name_a;
        CWsbStringPtr                   index_name_w;
        JET_ERR                         jstat;

        WsbAffirmHr(index_name_w.Alloc(20));
        WsbAffirmHr(pDbImp->GetJetIndexInfo(m_SessionId, m_RecInfo.Type, type, NULL, 
                &index_name_w, 20));
        ilen = wcslen(index_name_w);
        index_name_a = (char *)WsbAlloc(sizeof(WCHAR) * ilen + 1);
        WsbAffirm(0 != index_name_a, E_FAIL);
        WsbAffirm(0 < wcstombs(index_name_a, index_name_w, ilen + 1), E_FAIL);

        //  Set the current index
        jstat = JetSetCurrentIndex(m_SessionId, m_TableId, index_name_a);
        WsbFree(index_name_a);
        WsbAffirmHr(jet_error(jstat));
        m_PosOk = FALSE;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::UseKey"), OLESTR(""));

    return(hr);
}



HRESULT
CWsbDbEntity::Write(
    void
    )

/*++

Implements:

  IWsbDbEntity::Write

--*/
{
    HRESULT               hr = S_OK;
    CComPtr<IWsbDbPriv>   pDbImp;
    UCHAR   temp_bytes1[IDB_MAX_KEY_SIZE + 4];

    WsbTraceIn(OLESTR("CWsbDbEntity::Write"), OLESTR("SaveAsNew = %ls"), 
            WsbBoolAsString(m_SaveAsNew));

    JET_ERR                         jstat;

    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);

    jstat = JetBeginTransaction(m_SessionId);
    WsbTrace(OLESTR("CWsbDbEntity::Write: JetBeginTransaction = %ld\n"), jstat);
    
    try {
        CComPtr<IWsbDbEntity>     pEntity;
        CComPtr<IWsbDbEntityPriv> pEntityPriv;
        ULONG                     save_key_type;

        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
        WsbAffirmHr(pDbImp->Lock());
        save_key_type = m_pKeyInfo[m_UseKeyIndex].Type;

        VOID*                           addr;
        ULONG                           Size;

        // Save the entity data to memory
        WsbAffirmHr(toMem(m_hMem, &Size));

        // Write the data to the current record
        addr = GlobalLock(m_hMem);
        WsbAffirm(addr, E_HANDLE);

        if (m_SaveAsNew) {
            jstat = JetPrepareUpdate(m_SessionId, m_TableId, JET_prepInsert);
        } else {
            //  Make sure this record is the current record.
            WsbAffirmHr(jet_make_current());
            jstat = JetPrepareUpdate(m_SessionId, m_TableId, JET_prepReplace);
        }
        WsbAffirmHr(jet_error(jstat));
        WsbTrace(OLESTR("Setting binary record data\n"));
        jstat = JetSetColumn(m_SessionId, m_TableId, m_ColId, addr, Size,
                0, NULL);
        WsbAffirmHr(jet_error(jstat));

        // Release the memory
        GlobalUnlock(m_hMem);

        // Set keys in current record
        for (int i = 0; i < m_RecInfo.nKeys; i++) {
            JET_COLUMNID  col_id;
            BOOL          do_set = FALSE;
            ULONG         size;

            WsbAffirmHr(pDbImp->GetJetIndexInfo(m_SessionId, m_RecInfo.Type, m_pKeyInfo[i].Type,
                    &col_id, NULL, 0));
            WsbAffirmHr(get_key(m_pKeyInfo[i].Type, temp_bytes1, &size));
            if (m_SaveAsNew) {
                do_set = TRUE;
            } else {
                HRESULT       hrEqual;

                hrEqual = jet_compare_field(col_id, temp_bytes1, size);
                WsbAffirm(S_OK == hrEqual || S_FALSE == hrEqual, hrEqual);
                if (S_FALSE == hrEqual && 
                        (m_pKeyInfo[i].Flags & IDB_KEY_FLAG_PRIMARY)) {
                    //  Changing the primary key is not allowed
                    WsbThrow(WSB_E_IDB_PRIMARY_KEY_CHANGED);
                }
                do_set = (S_FALSE == hrEqual) ? TRUE : FALSE;
            }
            if (do_set) {
                WsbTrace(OLESTR("Setting key %ld\n"), m_pKeyInfo[i].Type);
                jstat = JetSetColumn(m_SessionId, m_TableId, col_id, temp_bytes1, 
                        size, 0, NULL);
                WsbAffirmHr(jet_error(jstat));
            }
        }

        // Insert/update the record
        WsbTrace(OLESTR("Updating/writing record\n"));
        jstat = JetUpdate(m_SessionId, m_TableId, NULL, 0, NULL);
        WsbAffirmHr(jet_error(jstat));

        CComQIPtr<IWsbDbSysPriv, &IID_IWsbDbSysPriv> pDbSysPriv = m_pDbSys;
        WsbAffirmPointer(pDbSysPriv);
        WsbAffirmHr(pDbSysPriv->IncrementChangeCount());
        m_SaveAsNew = FALSE;
        SetIsDirty(FALSE);
    } WsbCatch(hr);

    if (pDbImp) {
        WsbAffirmHr(pDbImp->Unlock());
    }

    if (SUCCEEDED(hr)) {
        jstat = JetCommitTransaction(m_SessionId, 0);
        WsbTrace(OLESTR("CWsbDbEntity::Write: JetCommitTransaction = %ld\n"), jstat);
    } else {
        jstat = JetRollback(m_SessionId, 0);
        WsbTrace(OLESTR("CWsbDbEntity::Write: JetRollback = %ld\n"), jstat);
    }

    WsbTraceOut(OLESTR("CWsbDbEntity::Write"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbEntity::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::FinalConstruct"), OLESTR("") );

    try {
        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_pDb = NULL;
        m_SaveAsNew = FALSE;
        m_pKeyInfo = NULL;
        m_RecInfo.MaxSize = 0;

        m_SeqNum = -1;
        m_PosOk = FALSE;
        m_SessionId = 0;
        m_TableId = 0;
        m_hMem = 0;

        m_Sequential = FALSE;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::FinalConstruct"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



void
CWsbDbEntity::FinalRelease(
    void
    )

/*++

Routine Description:

  This method does some cleanup of the object that is necessary
  during destruction.

Arguments:

  None.

Return Value:

  None.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::FinalRelease"), OLESTR(""));
    WsbTrace(OLESTR("DbEntity SessionId = %lx, TableId = %ld\n"),
            m_SessionId, m_TableId);

    try {

        if (m_hMem) {
            GlobalFree(m_hMem);
        }
        if (m_SessionId && m_TableId) {
            if (m_Sequential) {
                (void)ResetSequentialScan();
            }
            m_SessionId = 0;
            m_TableId = 0;
        }
        if (m_pDb) {
            //  Release IDB objects
            m_pDb = 0;
            m_pDbSys = 0;
        }
        if (m_pKeyInfo) {
            WsbFree(m_pKeyInfo);
            m_pKeyInfo = NULL;
        }

        CWsbObject::FinalRelease();
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::FinalRelease"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));
}


HRESULT
CWsbDbEntity::CompareTo(
    IN IUnknown* pCollectable,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = S_FALSE;
    IWsbDbEntity*   pEntity;

    WsbTraceIn(OLESTR("CWsbDbEntity::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pCollectable, E_POINTER);

        // We need the IWsbDbEntity interface to get the value of the object.
        WsbAffirmHr(pCollectable->QueryInterface(IID_IWsbDbEntity, (void**) &pEntity));

        hr = compare(pEntity, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


// CWsbDbEntity internal helper functions


// compare - compare control key to control key of another entity
HRESULT CWsbDbEntity::compare(IWsbDbEntity* pEntity, SHORT* pResult)
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::compare"), OLESTR(""));
    
    try {
        CComPtr<IWsbCollectable>  pCollectable;
        CComPtr<IWsbDbEntityPriv> pEntityPriv;
        CComPtr<IWsbDbKey>        pKey1;
        CComPtr<IWsbDbKey>        pKey2;
        SHORT                     result;

        WsbAffirmHr(GetCurKey(&pKey1));
        WsbAffirmHr(pKey1->QueryInterface(IID_IWsbCollectable,
                (void**)&pCollectable));
        WsbAffirmHr(pEntity->QueryInterface(IID_IWsbDbEntityPriv, 
                (void**)&pEntityPriv))
        WsbAffirmHr(pEntityPriv->GetCurKey(&pKey2));
        WsbAffirmHr(pCollectable->CompareTo(pKey2, &result));
        if (pResult) {
            *pResult = result;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::compare"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

// fromMem - load entity data from memory
HRESULT CWsbDbEntity::fromMem(HGLOBAL hMem)
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::fromMem"), OLESTR(""));
    
    try {
        CComPtr<IPersistStream>  pIPersistStream;
        CComPtr<IStream>         pIStream;
        IUnknown*                pIUnknown;

        WsbAssert(0 != hMem, E_POINTER);

        // Get PersistStream interfaces for myself
        pIUnknown = (IUnknown *)(IWsbPersistable *)(CWsbCollectable *)this;
        WsbAffirmHr(pIUnknown->QueryInterface(IID_IPersistStream, 
                (void**) &pIPersistStream));

        // Create a memory stream
        WsbAffirmHr(CreateStreamOnHGlobal(hMem, FALSE, &pIStream));

        // Load myself from the stream
        WsbAffirmHr(pIPersistStream->Load(pIStream));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::fromMem"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

//  get_key - get the byte array & size for the given key
HRESULT CWsbDbEntity::get_key(ULONG key_type, UCHAR* bytes, ULONG* pSize)
{
    HRESULT   hr = S_OK;

    try {
        ULONG        expected_size;
        ULONG        size;

        if (0 != key_type) {
            UCHAR*                 pbytes;
            CComPtr<IWsbDbKey>     pKey;
            CComPtr<IWsbDbKeyPriv> pKeyPriv;

            // Check that this is a valid key type
            for (int i = 0; i < m_RecInfo.nKeys; i++) {
                if (m_pKeyInfo[i].Type == key_type) break;
            }
            WsbAssert(i < m_RecInfo.nKeys, E_INVALIDARG);
            WsbAssert(0 != bytes, E_POINTER);

            //  Create a key of the right type
            WsbAffirmHr(CoCreateInstance(CLSID_CWsbDbKey, 0, CLSCTX_SERVER, 
                      IID_IWsbDbKey, (void **)&pKey ));
            WsbAffirmHr(pKey->QueryInterface(IID_IWsbDbKeyPriv, 
                    (void**)&pKeyPriv));
            WsbAffirmHr(pKeyPriv->SetType(key_type));

            //  Get the key's value from the derived code
            WsbAffirmHr(UpdateKey(pKey));

            //  Convert key to bytes
            pbytes = bytes;
            WsbAffirmHr(pKeyPriv->GetBytes(&pbytes, &size));

            expected_size = m_pKeyInfo[i].Size;
            WsbAffirm(size <= expected_size, WSB_E_INVALID_DATA);
            while (size < expected_size) {
                //  Fill with zeros
                pbytes[size] = '\0';
                size++;
            }

        //  0 == key_type
        //  This is a special case, allowed only for Jet, to
        //  get the sequence number as a key.  We can't use
        //  WsbConvertToBytes because the bytes end up in the 
        //  wrong order.
        } else {
            size = sizeof(m_SeqNum);
            memcpy(bytes, (void*)&m_SeqNum, size);

        }

        if (pSize) {
            *pSize = size;
        }
    } WsbCatch(hr);

    return(hr);
}

//  getMem - allocate enough memory for this entity
HRESULT CWsbDbEntity::getMem(HGLOBAL* phMem)
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::getMem"), OLESTR(""));
    
    try {
        HGLOBAL                  hMem;

        WsbAssert(0 != phMem, E_POINTER);
        WsbAffirm(0 < m_RecInfo.MaxSize, WSB_E_NOT_INITIALIZED);

        hMem = GlobalAlloc(GHND, m_RecInfo.MaxSize);
        WsbAffirm(hMem, E_OUTOFMEMORY);
        *phMem = hMem;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::getMem"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

//  toMem - save this entity to memory
HRESULT CWsbDbEntity::toMem(HGLOBAL hMem, ULONG* pSize)
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::toMem"), OLESTR(""));
    
    try {
        CComPtr<IPersistStream>  pIPersistStream;
        CComPtr<IStream>         pIStream;
        IUnknown*                pIUnknown;
        ULARGE_INTEGER           seek_pos;
        LARGE_INTEGER            seek_pos_in;

        WsbAssert(0 != hMem, E_POINTER);
        WsbAssert(0 != pSize, E_POINTER);

        // Get PersistStream interfaces for myself
        pIUnknown = (IUnknown *)(IWsbPersistable *)(CWsbCollectable *)this;
        WsbAffirmHr(pIUnknown->QueryInterface(IID_IPersistStream, 
                (void**) &pIPersistStream));

        // Create a memory stream
        WsbAffirmHr(CreateStreamOnHGlobal(hMem, FALSE, &pIStream));

        // Save to the stream
        WsbAffirmHr(pIPersistStream->Save(pIStream, FALSE));

        //  Get the size
        seek_pos_in.QuadPart = 0;
        WsbAffirmHr(pIStream->Seek(seek_pos_in, STREAM_SEEK_CUR, &seek_pos));
        *pSize = seek_pos.LowPart;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::toMem"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


// jet_compare_field - compare a string of bytes to the a column
//   value in the current Jet record
//  Return S_OK for equal, S_FALSE for not equal, other for an error.
HRESULT 
CWsbDbEntity::jet_compare_field(ULONG col_id, UCHAR* bytes, ULONG size)
{
    VOID*               addr = NULL;
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::jet_compare_field"), OLESTR(""));
    
    try {
        ULONG                           actualSize;
        JET_ERR                         jstat;
        CComPtr<IWsbDbPriv>             pDbImp;

        //  Get some Jet DB info
        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));

        //  Get the column value
        addr = GlobalLock(m_hMem);
        WsbAffirm(addr, E_HANDLE);
        jstat = JetRetrieveColumn(m_SessionId, m_TableId, col_id, addr,
                size, &actualSize, 0, NULL);
        WsbAffirmHr(jet_error(jstat));

        //  Compare them
        if (memcmp(bytes, addr, size)) {
            hr = S_FALSE;
        }
    } WsbCatch(hr);

    if (NULL != addr) {
        GlobalUnlock(m_hMem);
    }

    WsbTraceOut(OLESTR("CWsbDbEntity::jet_compare_field"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

// jet_get_data - retrieve record data from the current Jet record
HRESULT 
CWsbDbEntity::jet_get_data(void)
{
    VOID*               addr = NULL;
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::jet_get_data"), OLESTR(""));
    
    try {
        ULONG                           actualSize;
        JET_COLUMNID                    col_id;
        JET_ERR                         jstat;
        CComPtr<IWsbDbPriv>             pDbImp;

        //  Get some Jet DB info
        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));

        //  Get data
        addr = GlobalLock(m_hMem);
        WsbAffirm(addr, E_HANDLE);
        jstat = JetRetrieveColumn(m_SessionId, m_TableId, m_ColId, addr,
                m_RecInfo.MaxSize, &actualSize, 0, NULL);
        WsbAffirmHr(jet_error(jstat));
        WsbAffirmHr(fromMem(m_hMem));

        //  Get the sequence number
        WsbAffirmHr(pDbImp->GetJetIndexInfo(m_SessionId, m_RecInfo.Type, 0, &col_id, NULL, 0));
        jstat = JetRetrieveColumn(m_SessionId, m_TableId, col_id, &m_SeqNum,
                sizeof(m_SeqNum), &actualSize, 0, NULL);
        WsbAffirmHr(jet_error(jstat));

    } WsbCatch(hr);

    if (NULL != addr) {
        GlobalUnlock(m_hMem);
    }

    WsbTraceOut(OLESTR("CWsbDbEntity::jet_get_data"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

// jet_make_current - make sure this is the current Jet record
//   NOTE: This function, despite its name, does not attempt to force
//   the JET "cursor" to be on the correct record because this can mess
//   up too many things that can't necessarily be controlled at this
//   level.  For one thing, if the current key allows duplicates, we can't
//   be sure to get to the correct record using the index for that key.
//   If we try to use the sequence number as the key, we'd then be using
//   the wrong index if we do a Next or Previous.  If the user code is
//   doing a Write or Remove, it's better for that code to make sure via
//   the Find functions that the cursor is position correctly.
HRESULT 
CWsbDbEntity::jet_make_current(void)
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::jet_make_current"), OLESTR(""));
    
    try {
        ULONG                           actualSize;
        JET_COLUMNID                    col_id;
        JET_ERR                         jstat;
        CComPtr<IWsbDbPriv>             pDbImp;
        LONG                            seq_num;

        //  Get some Jet DB info
        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));
        WsbAffirmHr(pDbImp->GetJetIndexInfo(m_SessionId, m_RecInfo.Type, 0, &col_id, NULL, 0));

        //  Make sure this record is still the current record.
        //  We do this by comparing the sequence numbers
        jstat = JetRetrieveColumn(m_SessionId, m_TableId, col_id, &seq_num,
                sizeof(seq_num), &actualSize, 0, NULL);
        WsbAffirmHr(jet_error(jstat));
        if (!m_PosOk || seq_num != m_SeqNum) {
            WsbThrow(WSB_E_IDB_IMP_ERROR);
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::jet_make_current"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

// jet_move - move current Jet record
HRESULT 
CWsbDbEntity::jet_move(LONG pos)
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::jet_move"), OLESTR(""));
    
    try {
        JET_ERR                         jstat;
        CComPtr<IWsbDbPriv>             pDbImp;

        //  Get some Jet DB info
        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));

        //  Do the move
        jstat = JetMove(m_SessionId, m_TableId, pos, 0);
        if (jstat == JET_errNoCurrentRecord) {
            WsbThrow(WSB_E_NOTFOUND);
        }
        WsbAffirmHr(jet_error(jstat));
        m_PosOk = TRUE;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::jet_move"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

// jet_seek - find Jet record based on current key and seek_flag;
//    sets the current Jet record on success
HRESULT 
CWsbDbEntity::jet_seek(ULONG seek_flag)
{
    UCHAR           temp_bytes1[IDB_MAX_KEY_SIZE + 4];
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbEntity::jet_seek"), OLESTR(""));
    
    try {
        JET_ERR                         jstat;
        CComPtr<IWsbDbPriv>             pDbImp;
        ULONG                           size;

        //  Get some Jet DB info
        WsbAffirm(m_pDb, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(m_pDb->QueryInterface(IID_IWsbDbPriv, (void**)&pDbImp));

        //  Get the current key & give it to Jet
        WsbAffirmHr(get_key(m_pKeyInfo[m_UseKeyIndex].Type, temp_bytes1, &size));
        jstat = JetMakeKey(m_SessionId, m_TableId, temp_bytes1, size,
                JET_bitNewKey);
        WsbAffirmHr(jet_error(jstat));

        //  Do the seek
        jstat = JetSeek(m_SessionId, m_TableId, seek_flag);
        if (jstat == JET_errRecordNotFound) {
            WsbThrow(WSB_E_NOTFOUND);
        } else if (jstat == JET_wrnSeekNotEqual) {
            jstat = JET_errSuccess;
        }
        WsbAffirmHr(jet_error(jstat));
        m_PosOk = TRUE;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbEntity::jet_seek"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\idb\wsbdbses.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Wsbdbses.cpp

Abstract:

    The CWsbDbSession class

Author:

    Ron White   [ronw]   20-Jun-1997

Revision History:

--*/

#include "stdafx.h"

#include "wsbdbsys.h"
#include "wsbdbses.h"


static USHORT iCountSes = 0;  // Count of existing objects



HRESULT
CWsbDbSession::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSession::FinalConstruct"), OLESTR("") );

    m_SessionId = JET_sesidNil;

    iCountSes++;

    WsbTraceOut(OLESTR("CWsbDbSession::FinalConstruct"), OLESTR("hr =<%ls>, Count is <%d>"), 
            WsbHrAsString(hr), iCountSes);

    return(hr);
}



void
CWsbDbSession::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSession::FinalRelease"), OLESTR(""));

    try {
        JET_ERR          jstat;

        WsbTrace(OLESTR("CWsbDbSession::FinalRelease, SessionId = %p\n"), (LONG_PTR)m_SessionId);
        if (JET_sesidNil != m_SessionId) {
            jstat = JetEndSession(m_SessionId, 0);
            WsbAffirmHr(jet_error(jstat));
            m_SessionId = JET_sesidNil;
        }
    } WsbCatch(hr);

    iCountSes--;

    WsbTraceOut(OLESTR("CWsbDbSession::FinalRelease"), OLESTR("hr =<%ls>, Count is <%d>"), 
            WsbHrAsString(hr), iCountSes);
}

HRESULT
CWsbDbSession::Init(
    JET_INSTANCE *pInstance
    )

/*++

Implements:

  IWsbDbSessionPriv::Init

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSession::Init"), OLESTR("") );

    try {
        JET_ERR          jstat;

        // Create the Jet session here instead of in FinalConstract
        // because we need the Jet instance
        WsbAffirm(NULL != pInstance, E_POINTER);
        WsbTrace(OLESTR("CWsbDbSession::Init, calling JetBeginSession, JetInstance = %p\n"),
                (LONG_PTR)*pInstance );
        jstat = JetBeginSession(*pInstance, &m_SessionId, NULL, NULL);
        WsbTrace(OLESTR("CWsbDbSession::FinalConstruct, SessionId = %p\n"), (LONG_PTR)m_SessionId);
        WsbAffirmHr(jet_error(jstat));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbSession::Init"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbSession::GetJetId(
    JET_SESID* pSessionId
    )

/*++

Implements:

  IWsbDbSessionPriv::GetJetId

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSession::GetJetId"), OLESTR("") );

    *pSessionId = m_SessionId;

    WsbTraceOut(OLESTR("CWsbDbSession::GetJetId"), OLESTR("hr =<%ls>, Id = %lx"), 
            WsbHrAsString(hr), *pSessionId);

    return(hr);
}



HRESULT
CWsbDbSession::TransactionBegin(
    void
    )

/*++

Implements:

  IWsbDbSession::TransactionBegin

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSession::TransactionBegin"), OLESTR(""));
    
    try {
        JET_ERR   jstat;

        jstat = JetBeginTransaction(m_SessionId);
        WsbAffirmHr(jet_error(jstat));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbSession::TransactionBegin"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbSession::TransactionCancel(
    void
    )

/*++

Implements:

  IWsbDbSession::TransactionCancel

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSession::TransactionCancel"), OLESTR(""));
    
    try {
        JET_ERR   jstat;

        jstat = JetRollback(m_SessionId, 0);
        WsbAffirmHr(jet_error(jstat));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbSession::TransactionCancel"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbSession::TransactionEnd(
    void
    )

/*++

Implements:

  IWsbDbSession::TransactionEnd

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSession::TransactionEnd"), OLESTR(""));
    
    try {
        JET_ERR   jstat;

        jstat = JetCommitTransaction(m_SessionId, 0);
        WsbAffirmHr(jet_error(jstat));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbSession::TransactionEnd"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\idb\wsbdb.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Wsbdb.cpp

Abstract:

    These classes provide support for data bases.

Author:

    Ron White   [ronw]   19-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsbdbsys.h"
#include "wsbdbses.h"
#include "wsbdbkey.h"


#include <mbstring.h>

#define JET_DATA_COLUMN_NAME    "Data"
#define JET_INDEX_COLUMN_NAME   "Index"
#define JET_INFO_TABLE_NAME     "Info"
#define JET_SEQNUM_COLUMN_NAME  "SeqNum"
#define SESSION_INFO_INITIAL_SIZE  4
#define SESSION_INFO_EXPANSION     6

#define JET_CURRENT_SESSION  (pDbInfo->SessionInfo[m_SessionIndex].SessionId)
#define JET_CURRENT_DB       (pDbInfo->SessionInfo[m_SessionIndex].DbId)

#define CATCH_ANY_EXCEPTION  catch (...) { \
        WsbTraceAndLogEvent(WSB_MESSAGE_IDB_EXCEPTION, 0, NULL, NULL); \
        WsbTrace(OLESTR("GetLastError = %ld\n"), GetLastError()); \
        hr = WSB_E_IDB_EXCEPTION;    }


// Local stuff

// These structures hold extra implementation data
typedef struct {
} IMP_KEY_INFO;

typedef struct {
    IMP_KEY_INFO* Key;
} IMP_REC_INFO;

// IMP_TABLE_INFO holds information for each open table
typedef struct {
    JET_TABLEID   TableId;
    JET_COLUMNID  ColId;
} IMP_TABLE_INFO;

// IMP_SESSION_INFO holds information for each thread
typedef struct {
    JET_SESID   SessionId;  // The Jet session
    JET_DBID    DbId;       // The session's DB ID for this DB
    IMP_TABLE_INFO* pTableInfo;  // Array of table information
} IMP_SESSION_INFO;


typedef struct {
    BOOL              IsLoaded;   // DB info is loaded into memory
    USHORT            OpenCount;  // Open ref. count
    IMP_REC_INFO*     RecInfo;    // Array of record info

    SHORT             nSessions;
    IMP_SESSION_INFO* SessionInfo;
} IMP_DB_INFO;

// These structures are saved in the data file
typedef struct {
    ULONG  Type;       // Key type ID
    ULONG  Size;       // Key size in bytes
    ULONG  Flags;      // IDB_KEY_FLAG_* flags
} FILE_KEY_INFO;

typedef struct {
    ULONG  Type;          // Record type ID
    CLSID  EntityClassId; // Derived entity class ID
    ULONG  Flags;         // IDB_REC_FLAG_* flags
    ULONG  MinSize;       // (Minimum) record size in bytes
    ULONG  MaxSize;       // Maximum record size
    USHORT nKeys;         // Number of keys in this record type
    FILE_KEY_INFO Key[IDB_MAX_KEYS_PER_REC];
} FILE_REC_INFO;

typedef struct {
    USHORT    nRecTypes;  // Number of record types
    ULONG     version;    // DB version
} FILE_DB_INFO;


//***************************************************************
//  Local function prototypes

static HRESULT jet_get_column_id(JET_SESID jet_session, JET_DBID DbId, 
        char* pTableName, char* pColumnName, JET_COLUMNID* pColId);



//***************************************************************
//  Function definitions


HRESULT
CWsbDb::Create(
    IN OLECHAR* path,
    ULONG flags
    )

/*++

Implements:

  IWsbDb::Create

--*/
{
    HRESULT             hr = S_OK;
    IMP_DB_INFO*        pDbInfo = NULL;

    WsbTraceIn(OLESTR("CWsbDb::Create"), OLESTR("path = <%ls>"), path);
    
    try {
        int           key_index;
        ULONG         memSize;
        int           rec_index;

        WsbAssert(0 != path, E_POINTER);
        WsbAssert(0 != m_RecInfo, WSB_E_NOT_INITIALIZED);
        WsbAssert(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;
        Lock();
        WsbAffirm(!pDbInfo->IsLoaded, WSB_E_NOT_INITIALIZED);
        WsbAffirm(!pDbInfo->RecInfo, WSB_E_NOT_INITIALIZED);

        // Save the path
        m_path = path;

        // Check validity of some info that the derived class is
        // suppose to supply.
        WsbAffirm(m_version != 0, WSB_E_NOT_INITIALIZED);
        WsbAffirm(m_nRecTypes > 0, WSB_E_NOT_INITIALIZED);
        WsbAffirm(m_nRecTypes <= IDB_MAX_REC_TYPES, WSB_E_INVALID_DATA);
        pDbInfo->IsLoaded = TRUE;

        //  Allocate the RecInfo array
        memSize = m_nRecTypes * sizeof(IMP_REC_INFO);
        pDbInfo->RecInfo = (IMP_REC_INFO*)WsbAlloc(memSize);
        WsbAffirm(pDbInfo->RecInfo, E_OUTOFMEMORY);
        ZeroMemory(pDbInfo->RecInfo, memSize);

        char             index_names[IDB_MAX_KEYS_PER_REC + 1][20];
        JET_COLUMNCREATE jet_columns[IDB_MAX_KEYS_PER_REC + 2];
        JET_INDEXCREATE  jet_indices[IDB_MAX_KEYS_PER_REC + 1];
        JET_TABLECREATE  jet_table;
        JET_ERR          jstat;
        char             key_names[IDB_MAX_KEYS_PER_REC + 1][22];
        char*            name;
        char             table_name[20];
        JET_GRBIT        createFlags = 0;

        //  Start a Jet session for this thread
        WsbAffirmHr(jet_init());

        //  Make sure there's room for another DB
        CComQIPtr<IWsbDbSysPriv, &IID_IWsbDbSysPriv> pDbSysPriv = m_pWsbDbSys;
        WsbAffirmPointer(pDbSysPriv);
        WsbAffirmHr(pDbSysPriv->DbAttachedAdd(path, FALSE));

        // Set creation flag
        if (flags & IDB_CREATE_FLAG_NO_TRANSACTION) {
            // Setting this flag stil allow transaction calls - they are just being ignored and MT-safe is not guaranteed 
            createFlags |= (JET_bitDbVersioningOff & JET_bitDbRecoveryOff);
        }     

        //  Create the DB
        WsbAffirmHr(wsb_db_jet_fix_path(path, L"." IDB_DB_FILE_SUFFIX, &name));
        jstat = JetCreateDatabase(JET_CURRENT_SESSION, name, NULL, &JET_CURRENT_DB, createFlags);
        WsbTrace(OLESTR("JetCreateDB = %ld\n"), (LONG)jstat);
        WsbFree(name);
        WsbAffirmHr(jet_error(jstat));

        //  Set up constant part of table structure
        jet_table.cbStruct = sizeof(JET_TABLECREATE);
        jet_table.szTemplateTableName = NULL;
        jet_table.ulPages = 4;  // ????
        jet_table.ulDensity = 50; // ?????
        jet_table.rgcolumncreate = jet_columns;
        jet_table.rgindexcreate = jet_indices;
        jet_table.grbit = 0;

        //  Set up the constant part of the column structures
        ZeroMemory(&jet_columns, sizeof(jet_columns));
        ZeroMemory(&jet_indices, sizeof(jet_indices));
        jet_columns[0].cbStruct = sizeof(JET_COLUMNCREATE);
        jet_columns[0].szColumnName = JET_DATA_COLUMN_NAME;
        jet_columns[1].cbStruct = sizeof(JET_COLUMNCREATE);

        //  Create a "table" to hold info about this DB
        jet_table.szTableName = JET_INFO_TABLE_NAME;
        jet_table.cColumns = 2;
        jet_table.cIndexes = 1;
        jet_columns[0].coltyp = JET_coltypLongBinary;
        jet_columns[0].cbMax = sizeof(FILE_REC_INFO);
        jet_columns[1].szColumnName = JET_INDEX_COLUMN_NAME;
        jet_columns[1].coltyp = JET_coltypShort;
        jet_columns[1].cbMax = sizeof(SHORT);
        jet_indices[0].cbStruct = sizeof(JET_INDEXCREATE);
        jet_indices[0].szIndexName = JET_INDEX_COLUMN_NAME;
        ZeroMemory(key_names[0], 22);
        sprintf(key_names[0], "+%s", JET_INDEX_COLUMN_NAME);
        jet_indices[0].szKey = key_names[0];
        jet_indices[0].cbKey  = strlen(key_names[0]) + 2;
        jet_indices[0].grbit |= JET_bitIndexPrimary;
        jet_indices[0].ulDensity = 90;
        jstat = JetCreateTableColumnIndex(JET_CURRENT_SESSION, JET_CURRENT_DB, &jet_table);
        WsbTrace(OLESTR("CWsbDb::Create: JetCreateTableColumnIndex status = %ld\n"), jstat);
        if (JET_errSuccess != jstat) {
            WsbTrace(OLESTR("CWsbDb::Create: JetCreateTableColumnIndex, cCreated = %ld\n"), jet_table.cCreated);
        }
        WsbAffirmHr(jet_error(jstat));
        jstat = JetCloseTable(JET_CURRENT_SESSION, jet_table.tableid);
        WsbTrace(OLESTR("CWsbDb::Create: close TableId = %ld, jstat = %ld\n"),
               jet_table.tableid, jstat);

        //  Write DB info
        jstat = JetBeginTransaction(JET_CURRENT_SESSION);
        WsbTrace(OLESTR("CWsbDb::Create: JetBeginTransaction = %ld\n"), jstat);
        jstat = jet_save_info();
        if (JET_errSuccess == jstat) {
            jstat = JetCommitTransaction(JET_CURRENT_SESSION, 0);
            WsbTrace(OLESTR("CWsbDb::Create: JetCommitTransaction = %ld\n"), jstat);
        } else {
            HRESULT hr2 = jet_error(jstat);

            jstat = JetRollback(JET_CURRENT_SESSION, 0);
            WsbTrace(OLESTR("CWsbDb::Create: JetRollback = %ld\n"), jstat);
            WsbThrow(hr2);
        }

        //  We create a table for each record type.  The first column of each
        //  table is the record (stored as a blob).  The second column is a
        //  unique sequence number for each record.  The rest of the columns are for
        //  key values used as indices.
        jet_columns[1].szColumnName = JET_SEQNUM_COLUMN_NAME;
        jet_columns[1].coltyp = JET_coltypLong;
        jet_columns[1].cbMax = sizeof(ULONG);
        jet_columns[1].grbit = JET_bitColumnAutoincrement;
        jet_indices[0].cbStruct = sizeof(JET_INDEXCREATE);
        strcpy(index_names[0], JET_SEQNUM_COLUMN_NAME);
        jet_indices[0].szIndexName = index_names[0];
        ZeroMemory(key_names[0], 22);
        sprintf(key_names[0], "+%s", index_names[0]);
        jet_indices[0].szKey = key_names[0];
        jet_indices[0].cbKey  = strlen(key_names[0]) + 2;
        jet_indices[0].grbit = 0;
        jet_indices[0].ulDensity = 90;

        //  Loop over record types
        for (rec_index = 0; rec_index < m_nRecTypes; rec_index++) {
            WsbAffirm(m_RecInfo[rec_index].Type > 0, WSB_E_NOT_INITIALIZED);
            WsbAffirm(m_RecInfo[rec_index].nKeys > 0, WSB_E_NOT_INITIALIZED);
            WsbAffirm(m_RecInfo[rec_index].nKeys <= IDB_MAX_KEYS_PER_REC, WSB_E_INVALID_DATA);

            //  Allocate the Key array
            memSize = m_RecInfo[rec_index].nKeys * sizeof(IMP_KEY_INFO);
            pDbInfo->RecInfo[rec_index].Key = (IMP_KEY_INFO*)WsbAlloc(memSize);
            WsbAffirm(pDbInfo->RecInfo[rec_index].Key, E_OUTOFMEMORY);
            ZeroMemory(pDbInfo->RecInfo[rec_index].Key, memSize);

            //  Fill in the table structure with info specific to this
            //  record type
            WsbAffirmHr(jet_make_table_name(m_RecInfo[rec_index].Type, table_name, 20));
            jet_table.szTableName = table_name;
            jet_table.cColumns = m_RecInfo[rec_index].nKeys + 2;
            jet_table.cIndexes = m_RecInfo[rec_index].nKeys + 1;

            //  Fill in the column structure for the record itself
            if (m_RecInfo[rec_index].MaxSize < 255) {
                jet_columns[0].coltyp = JET_coltypBinary;
            } else {
                jet_columns[0].coltyp = JET_coltypLongBinary;
            }
            jet_columns[0].cbMax = m_RecInfo[rec_index].MaxSize;


            //  Loop over keys
            for (key_index = 0; key_index < m_RecInfo[rec_index].nKeys;
                    key_index++) {
                WsbAffirm(m_RecInfo[rec_index].Key[key_index].Type > 0, WSB_E_NOT_INITIALIZED);
                WsbAffirm(m_RecInfo[rec_index].Key[key_index].Size <= IDB_MAX_KEY_SIZE, 
                        WSB_E_NOT_INITIALIZED);
                WsbAffirm(!(m_RecInfo[rec_index].Key[key_index].Flags & IDB_KEY_FLAG_PRIMARY) ||
                        !(m_RecInfo[rec_index].Key[key_index].Flags & IDB_KEY_FLAG_DUP_ALLOWED),
                        WSB_E_IDB_PRIMARY_UNIQUE);


                //  Fill in a column structure for each key
                jet_columns[key_index + 2].cbStruct = sizeof(JET_COLUMNCREATE);
                WsbAffirmHr(jet_make_index_name(m_RecInfo[rec_index].Key[key_index].Type, 
                        index_names[key_index + 1], 20));
                jet_columns[key_index + 2].szColumnName = index_names[key_index + 1];
                jet_columns[key_index + 2].grbit = JET_bitColumnFixed;
                jet_columns[key_index + 2].pvDefault = NULL;
                jet_columns[key_index + 2].cbDefault = 0;
                if (m_RecInfo[rec_index].Key[key_index].Size < 255) {
                    jet_columns[key_index + 2].coltyp = JET_coltypBinary;
                } else {
                    jet_columns[key_index + 2].coltyp = JET_coltypLongBinary;
                }
                jet_columns[key_index + 2].cbMax = m_RecInfo[rec_index].Key[key_index].Size;

                //  Fill in an index structure for each key
                jet_indices[key_index + 1].cbStruct = sizeof(JET_INDEXCREATE);
                jet_indices[key_index + 1].szIndexName = index_names[key_index + 1];
                ZeroMemory(key_names[key_index + 1], 22);
                sprintf(key_names[key_index + 1], "+%s\0", index_names[key_index + 1]);
                jet_indices[key_index + 1].szKey = key_names[key_index + 1];
                jet_indices[key_index + 1].cbKey  = strlen(key_names[key_index + 1]) + 2;
                if (m_RecInfo[rec_index].Key[key_index].Flags & IDB_KEY_FLAG_DUP_ALLOWED) {
                    jet_indices[key_index + 1].grbit = 0;
                } else {
                    jet_indices[key_index + 1].grbit = JET_bitIndexUnique;
                }
                if (m_RecInfo[rec_index].Key[key_index].Flags & IDB_KEY_FLAG_PRIMARY) {
                    jet_indices[key_index + 1].grbit |= JET_bitIndexPrimary;
                }
                jet_indices[key_index + 1].ulDensity = 50;
            }  // End of key loop

            // Set table creation flags
            if (flags & IDB_CREATE_FLAG_FIXED_SCHEMA) {
                jet_table.grbit |= JET_bitTableCreateFixedDDL;
            }

            //  Create the "table" for each record type; this call defines
            //  the columns (fields) and index keys
            jstat = JetCreateTableColumnIndex(JET_CURRENT_SESSION, JET_CURRENT_DB, &jet_table);
            WsbTrace(OLESTR("JetCreateTableColumnIndex = %ld\n"), jstat);
            WsbAffirmHr(jet_error(jstat));
            jstat = JetCloseTable(JET_CURRENT_SESSION, jet_table.tableid);
            WsbTrace(OLESTR("CWsbDb::Create: close TableId = %ld, jstat = %ld\n"),
                   jet_table.tableid, jstat);
        }  // End of record loop

        jstat = JetCloseDatabase(JET_CURRENT_SESSION, JET_CURRENT_DB, 0);
        WsbTrace(OLESTR("CWsbDb::Create: JetCloseDatabase = %ld\n"),
                (LONG)jstat);
        JET_CURRENT_DB = 0;

        pDbInfo->OpenCount = 0;

    } WsbCatchAndDo(hr, 
            WsbLogEvent(WSB_MESSAGE_IDB_CREATE_FAILED, 0, NULL,
            WsbAbbreviatePath(path, 120), NULL); 
        )
    CATCH_ANY_EXCEPTION

    if (pDbInfo) {
        Unlock();
    }
    WsbTraceOut(OLESTR("CWsbDb::Create"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDb::Delete(
    IN OLECHAR *path,
    ULONG flags
    )

/*++

Implements:

  IWsbDb::Delete

--*/
{
    HRESULT             hr = S_OK;
    char*               name = NULL;
    IMP_DB_INFO*        pDbInfo = NULL;

    WsbTraceIn(OLESTR("CWsbDb::Delete"), OLESTR("path = <%ls>"), 
            WsbStringAsString(path));
    
    try {
        CWsbStringPtr  DeletePath;

        WsbAssert(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;
        Lock();

        // Can't delete it if it's open
        WsbAffirm(pDbInfo->OpenCount == 0, E_UNEXPECTED);

        if (NULL == path) {
            path = m_path;
        }
        WsbAffirm(path && wcslen(path), S_FALSE);
        WsbAffirmHr(wsb_db_jet_fix_path(path, L"." IDB_DB_FILE_SUFFIX, &name));

        // Detach (if attached)
        CComQIPtr<IWsbDbSysPriv, &IID_IWsbDbSysPriv> pDbSysPriv = m_pWsbDbSys;
        WsbAffirmPointer(pDbSysPriv);
        WsbAffirmHr(pDbSysPriv->DbAttachedRemove(path));

        // Now delete it
        DeletePath = name;
        if (!DeleteFile(DeletePath)) {
            DWORD err = GetLastError();
            WsbTrace(OLESTR("CWsbDb::Delete: DeleteFile(%ls) failed, error = %ld\n"),
                    static_cast<OLECHAR*>(DeletePath), err);
            WsbThrow(HRESULT_FROM_WIN32(err));
        }

        // Put message in event log
        if (flags & IDB_DELETE_FLAG_NO_ERROR) {
            WsbLogEvent(WSB_E_IDB_DATABASE_DELETED_NO_ERROR, 0, NULL,
                    WsbAbbreviatePath(DeletePath, 120), NULL);
        } else {
            WsbLogEvent(WSB_E_IDB_DATABASE_DELETED, 0, NULL,
                    WsbAbbreviatePath(DeletePath, 120), NULL);
        }
    }
    WsbCatch(hr)

    if (pDbInfo) {
        Unlock();
    }
    if (name) {
        WsbFree(name);
    }

    WsbTraceOut(OLESTR("CWsbDb::Delete"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CWsbDb::Dump(
    IN OLECHAR* Filename,
    IN ULONG    Flags,
    IN ULONG    Data
    )

/*++

Implements:

  IWsbDb::Dump

--*/
{
    HANDLE              hFile = 0;       
    HRESULT             hr = S_OK;
    IMP_DB_INFO*        pDbInfo = NULL;
    CComPtr<IWsbDbSession> pSession;

    WsbTraceIn(OLESTR("CWsbDb::Dump"), OLESTR("path = <%ls>"), Filename);
    
    try {
        DWORD                 CreateFlags;
        int                   i;
        int                   index;
        CComPtr<IWsbDbEntity> pIRec;
        CComPtr<IStream>      pStream;

        WsbAssert(0 != Filename, E_POINTER);
        WsbAssert(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;
        Lock();
//        WsbAffirmHr(session_current_index(Session));

        //  Open the Db
        // SteveW
        //  added code to ensure that a database was opened
        //  if not go on to the next database, but do not 
        //  throw an exception.
        //
        hr = Open(&pSession);
        if (hr == S_OK) {

            // Open/create the output file
            if (Flags & IDB_DUMP_FLAG_APPEND_TO_FILE) {
                CreateFlags = OPEN_ALWAYS;
            } else {
                CreateFlags = CREATE_ALWAYS;
            }
            hFile = CreateFile(Filename, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                    CreateFlags, FILE_ATTRIBUTE_NORMAL, NULL);
            WsbAffirmHandle(hFile);
            if (Flags & IDB_DUMP_FLAG_APPEND_TO_FILE) {
                //  Position to the end of the file
                SetFilePointer(hFile, 0, NULL, FILE_END);
            }

            // Create the output stream
            WsbAffirmHr(CreateStreamOnHGlobal(NULL, TRUE, &pStream));

            //  Dump general DB info
            if (Flags & IDB_DUMP_FLAG_DB_INFO) {
                WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR("Dump of DB: %ls\n"),
                        static_cast<WCHAR *>(m_path)));
                WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR("  version = %ld, # record types = %d\n"),
                        m_version, m_nRecTypes));
                WsbAffirmHr(WsbStreamToFile(hFile, pStream, TRUE));
            }

            //  Loop over record types
            for (i = 0; i < m_nRecTypes; i++) {

                //  Dump record info
                if (Flags & IDB_DUMP_FLAG_REC_INFO) {
                    WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR("RecType = %8ld, Flags = %0.8lx, "),
                            m_RecInfo[i].Type, m_RecInfo[i].Flags));
                    WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR("MaxSize = %8ld, # keys = %4d\n"),
                            m_RecInfo[i].MaxSize, m_RecInfo[i].nKeys));
                    WsbAffirmHr(WsbStreamToFile(hFile, pStream, TRUE));
                }

                //  Dump key info
                if (Flags & IDB_DUMP_FLAG_KEY_INFO) {
                    for (int j = 0; j < m_RecInfo[i].nKeys; j++) {
                        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR("  KeyType = %8ld, Size = %8ld, Flags = %0.8lx\n"),
                                m_RecInfo[i].Key[j].Type, m_RecInfo[i].Key[j].Size, m_RecInfo[i].Key[j].Flags));
                    }
                    WsbAffirmHr(WsbStreamToFile(hFile, pStream, TRUE));
                }
            }

            //  Dump records
            if (Flags & (IDB_DUMP_FLAG_RECORDS | IDB_DUMP_FLAG_RECORD_TYPE)) {
                for (i = 0; i < m_nRecTypes; i++) {
                    if (!(Flags & IDB_DUMP_FLAG_RECORDS) &&
                           m_RecInfo[i].Type != Data) {
                        continue;
                    }
                    WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR("\n*** Dump of records of Type = %ld ***\n"),
                            m_RecInfo[i].Type));

                    // Get a DB entity
                    pIRec = 0;
                    WsbAffirmHr(GetEntity(pSession, m_RecInfo[i].Type, IID_IWsbDbEntity, 
                            (void**)&pIRec));

                    //  Loop over records
                    index = 0;
                    hr = pIRec->First();
                    while (S_OK == hr) {
                        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR("%0.5d "), index));
                        WsbAffirmHr(pIRec->Print(pStream));
                        WsbAffirmHr(WsbPrintfToStream(pStream, OLESTR("\n")));
                        WsbAffirmHr(WsbStreamToFile(hFile, pStream, TRUE));

                        hr = pIRec->Next();
                        index++;
                    }
                    if (WSB_E_NOTFOUND == hr) {
                        hr = S_OK;
                    } else {
                        WsbAffirmHr(hr);
                    }
                }
            }
        } 

    } WsbCatch(hr)
    CATCH_ANY_EXCEPTION

    if (hFile) {
        CloseHandle(hFile);
    }
    if (pSession) {
        Close(pSession);
    }
    if (pDbInfo) {
        Unlock();
    }
    WsbTraceOut(OLESTR("CWsbDb::Dump"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDb::Locate(
    IN OLECHAR *path
    )

/*++

Implements:

  IWsbDb::Locate

--*/
{
    HRESULT             hr = S_OK;
    IMP_DB_INFO*        pDbInfo = NULL;

    WsbTraceIn(OLESTR("CWsbDb::Locate"), OLESTR("path = <%ls>"), path);
    
    try {
        WsbAffirm(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;
        Lock();
        WsbAffirm(pDbInfo->OpenCount == 0, E_UNEXPECTED);
        m_path = path;

        JET_ERR jstat;
        char*   name;

        //  Start a Jet session for this thread
        WsbAffirmHr(jet_init());

        WsbAffirmHr(wsb_db_jet_fix_path(path, L"." IDB_DB_FILE_SUFFIX, &name));

        hr = S_OK;
        try {
            CComQIPtr<IWsbDbSysPriv, &IID_IWsbDbSysPriv> pDbSysPriv = m_pWsbDbSys;
            WsbAffirmPointer(pDbSysPriv);
            WsbAffirmHr(pDbSysPriv->DbAttachedAdd(path, TRUE));
            jstat = JetOpenDatabase(JET_CURRENT_SESSION, name, NULL, &JET_CURRENT_DB, 0);
            if (jstat == JET_errDatabaseNotFound) {
                WsbThrow(STG_E_FILENOTFOUND);
            } else {
                WsbAffirmHr(jet_error(jstat));
            }
        } WsbCatch(hr);
        WsbFree(name);
        WsbAffirmHr(hr);

        // Load information about this DB
        hr = jet_load_info();
        jstat = JetCloseDatabase(JET_CURRENT_SESSION, JET_CURRENT_DB, 0);
        WsbTrace(OLESTR("CWsbDb::Locate: JetCloseDatabase = %ld\n"),
                (LONG)jstat);
        JET_CURRENT_DB = 0;

        pDbInfo = (IMP_DB_INFO*)m_pImp;
        pDbInfo->OpenCount = 0;

    } WsbCatch(hr)
    CATCH_ANY_EXCEPTION

    if (pDbInfo) {
        Unlock();
    }
    WsbTraceOut(OLESTR("CWsbDb::Locate"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDb::Open(
    OUT IWsbDbSession** ppSession
    )

/*++

Implements:

  IWsbDb::Open

--*/
{
    HRESULT             hr = S_OK;
    IMP_DB_INFO*        pDbInfo = NULL;

    WsbTraceIn(OLESTR("CWsbDb::Open"), OLESTR(""));
    
    try {
        ULONG         Size = 0;

        WsbAffirm(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;
        Lock();

        WsbAffirmHr(m_path.GetLen(&Size));
        WsbAffirm(Size > 0, WSB_E_NOT_INITIALIZED);

        //  Make sure we have a session
        WsbAffirm(0 != ppSession, E_POINTER);
        if (0 == *ppSession) {
            WsbAffirmHr(m_pWsbDbSys->NewSession(ppSession));
            WsbTrace(OLESTR("CWsbDb::Open: session created\n"));
        }



        int               i;
        JET_ERR           jstat;
        ULONG             memSize;
        char*             name;
        JET_SESID         SessionId;
        int               s_index;
        IMP_SESSION_INFO* s_info = pDbInfo->SessionInfo;
        CComQIPtr<IWsbDbSessionPriv, &IID_IWsbDbSessionPriv> pSessionPriv = *ppSession;

        WsbAffirm(0 < pDbInfo->nSessions, WSB_E_NOT_INITIALIZED);
        WsbAffirm(pSessionPriv, E_FAIL);

        //  Get the JET session ID
        WsbAffirmHr(pSessionPriv->GetJetId(&SessionId));

        //  We need to save session info; look for an empty slot.
        WsbTrace(OLESTR("CWsbDb::Open: nSessions = %d, SessionId = %lx\n"), (
                int)pDbInfo->nSessions, SessionId);
        s_index = pDbInfo->nSessions;
        for (i = 0; i < pDbInfo->nSessions; i++) {
            WsbTrace(OLESTR("CWsbDb::Open: s_info[%d] = %lx\n"), i,
                    s_info[i].SessionId);

            //  Check for a duplicate session ID already in the table
            if (SessionId == s_info[i].SessionId) {
                s_index = i;
                break;

            //  Check for an unused slot
            } else if (0 == s_info[i].SessionId && 0 == s_info[i].DbId &&
                    s_index == pDbInfo->nSessions) {
                s_index = i;
            }
        }
        WsbTrace(OLESTR("CWsbDb::Open: s_index = %d\n"), s_index);

        if (s_index == pDbInfo->nSessions) {
            SHORT newNum;

            //  Didn't find an empty slot; expand the array
            newNum =  (SHORT) ( s_index + SESSION_INFO_EXPANSION );
            WsbTrace(OLESTR("CWsbDb::Open: expanding session table from %d to %d\n"),
                    s_index, newNum);
            memSize = newNum * sizeof(IMP_SESSION_INFO);
            s_info = (IMP_SESSION_INFO*)WsbRealloc(pDbInfo->SessionInfo, 
                    memSize);
            WsbAffirm(s_info, E_OUTOFMEMORY);
            ZeroMemory(&s_info[s_index], SESSION_INFO_EXPANSION * 
                    sizeof(IMP_SESSION_INFO));
            pDbInfo->SessionInfo = s_info;
            pDbInfo->nSessions = newNum;
        }

        //  Save the session ID and index
        m_SessionIndex = s_index;
        s_info[s_index].SessionId = SessionId;
        WsbTrace(OLESTR("CWsbDB::Open, s_info = %lx, SessionId[%d] = %lx\n"),
                (LONG)s_index, m_SessionIndex, JET_CURRENT_SESSION);

        WsbAffirmHr(wsb_db_jet_fix_path(m_path, L"." IDB_DB_FILE_SUFFIX, &name));

        CComQIPtr<IWsbDbSysPriv, &IID_IWsbDbSysPriv> pDbSysPriv = m_pWsbDbSys;
        WsbAffirmPointer(pDbSysPriv);
        WsbAffirmHr(pDbSysPriv->DbAttachedAdd(m_path, TRUE));
        jstat = JetOpenDatabase(JET_CURRENT_SESSION, name, NULL, 
                &JET_CURRENT_DB, 0);
        WsbFree(name);
        if (jstat == JET_errDatabaseNotFound) {
            WsbThrow(STG_E_FILENOTFOUND);
        } else {
            WsbAffirmHr(jet_error(jstat));
        }

        //  Allocate/zero the table info array
        memSize = m_nRecTypes * sizeof(IMP_TABLE_INFO);
        WsbTrace(OLESTR("CWsbDb::Open: pTableInfo = %lx\n"), 
            s_info[m_SessionIndex].pTableInfo);
        if (NULL == s_info[m_SessionIndex].pTableInfo) {
            s_info[m_SessionIndex].pTableInfo = (IMP_TABLE_INFO*)WsbAlloc(memSize);
            WsbAffirm(s_info[m_SessionIndex].pTableInfo, E_OUTOFMEMORY);
            WsbTrace(OLESTR("CWsbDb::Open: new pTableInfo = %lx\n"), 
                s_info[m_SessionIndex].pTableInfo);
        }
        ZeroMemory(s_info[m_SessionIndex].pTableInfo, memSize);

        pDbInfo->OpenCount++;

    } WsbCatchAndDo(hr, 
            WsbLogEvent(WSB_MESSAGE_IDB_OPEN_FAILED, 0, NULL,
            WsbAbbreviatePath(m_path, 120), NULL);
        )
    CATCH_ANY_EXCEPTION

    if (pDbInfo) {
        Unlock();
    }
    WsbTraceOut(OLESTR("CWsbDb::Open"), OLESTR("hr =<%ls>"), 
            WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDb::Close(
    IN IWsbDbSession*  pSession
    )

/*++

Implements:

  IWsbDb::Close
        - The element was added.

--*/
{
    HRESULT             hr = S_OK;
    IMP_DB_INFO*        pDbInfo = NULL;

    WsbTraceIn(OLESTR("CWsbDb::Close"), OLESTR(""));
    
    try {
        WsbAffirm(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;
        Lock();

        WsbAffirm(pDbInfo->OpenCount, WSB_E_NOT_INITIALIZED);
        WsbAffirmHr(session_current_index(pSession));

        pDbInfo->OpenCount--;

        JET_ERR           jstat;
        IMP_SESSION_INFO* s_info = pDbInfo->SessionInfo;

        WsbTrace(OLESTR("CWsbDb::Close: closing DB, SessionId = %lx, DbId = %lx\n"),
                (LONG)s_info[m_SessionIndex].SessionId, (LONG)s_info[m_SessionIndex].DbId);
        jstat = JetCloseDatabase(s_info[m_SessionIndex].SessionId, 
                s_info[m_SessionIndex].DbId, 0);
        WsbTrace(OLESTR("CWsbDb::Close: JetCloseDatabase = %ld\n"),
            (LONG)jstat);
        if (s_info[m_SessionIndex].pTableInfo) {
            WsbTrace(OLESTR("CWsbDb::Close: releasing pTableInfo\n"));
            WsbFree(s_info[m_SessionIndex].pTableInfo);
            s_info[m_SessionIndex].pTableInfo = NULL;
        }
        s_info[m_SessionIndex].SessionId = 0;
        s_info[m_SessionIndex].DbId = 0;

    } WsbCatch(hr)
    CATCH_ANY_EXCEPTION

    if (pDbInfo) {
        Unlock();
    }
    WsbTraceOut(OLESTR("CWsbDb::Close"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDb::GetEntity(
    IN IWsbDbSession* pSession,
    IN ULONG    RecId,
    IN REFIID   riid,
    OUT void**  ppEntity
    )

/*++

Implements:

  IWsbDb::GetEntity

--*/
{
    HRESULT             hr = S_OK;
    IMP_DB_INFO*        pDbInfo = NULL;
    CComPtr<IWsbDbEntityPriv> pEntity;

    WsbTraceIn(OLESTR("CWsbDb::GetEntity"), OLESTR(""));
    
    try {
        CComQIPtr<IWsbDb, &IID_IWsbDb> pIWsbDb = (IWsbDbPriv*)this;
        int               rec_index;

        WsbAssert(0 != ppEntity, E_POINTER);
        WsbAffirm(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;
        Lock();
        WsbAffirmHr(session_current_index(pSession));

        // Find the record info
        for (rec_index = 0; rec_index < m_nRecTypes; rec_index++) {
            if (m_RecInfo[rec_index].Type == RecId) break;
        }
        WsbAffirm(rec_index < m_nRecTypes, E_INVALIDARG);

        // Create the instance, initialize it to point to this DB, and
        // return the pointer to the caller.
        WsbAffirmHr(CoCreateInstance(m_RecInfo[rec_index].EntityClassId, NULL, 
                CLSCTX_SERVER | CLSCTX_INPROC_HANDLER, 
                IID_IWsbDbEntityPriv, (void**) &pEntity));
        WsbAffirmHr(pEntity->Init(pIWsbDb, m_pWsbDbSys, RecId, JET_CURRENT_SESSION));
        WsbAffirmHr(pEntity->QueryInterface(riid, (void**)ppEntity));

    } WsbCatch(hr)
    CATCH_ANY_EXCEPTION

    if (pDbInfo) {
        Unlock();
    }
    WsbTraceOut(OLESTR("CWsbDb::GetEntity"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDb::GetKeyInfo(
    IN ULONG RecType,
    IN USHORT nKeys, 
    OUT COM_IDB_KEY_INFO* pKeyInfo
    )

/*++

Implements:

  IWsbDbPriv::GetKeyInfo

--*/
{
    HRESULT             hr = E_FAIL;

    WsbTraceIn(OLESTR("CWsbDb::GetKeyInfo"), OLESTR(""));
    
    try {
        IMP_DB_INFO*  pDbInfo;
    
        WsbAssert(0 < nKeys, E_INVALIDARG);
        WsbAssert(0 != pKeyInfo, E_POINTER);
        WsbAffirm(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;
        for (int i = 0; i < m_nRecTypes; i++) {
            if (m_RecInfo[i].Type == RecType) {
                USHORT n = min(nKeys, m_RecInfo[i].nKeys);

                for (int j = 0; j < n; j++) {
                    pKeyInfo[j].Type = m_RecInfo[i].Key[j].Type;
                    pKeyInfo[j].Size = m_RecInfo[i].Key[j].Size;
                    pKeyInfo[j].Flags = m_RecInfo[i].Key[j].Flags;
                }
                hr = S_OK;
                break;
            }
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDb::GetKeyInfo"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDb::GetRecInfo(
    IN ULONG RecType,
    OUT COM_IDB_REC_INFO* pRecInfo 
    )

/*++

Implements:

  IWsbDbPriv::GetRecInfo

--*/
{
    HRESULT             hr = E_FAIL;

    WsbTraceIn(OLESTR("CWsbDb::GetRecInfo"), OLESTR(""));
    
    try {
        IMP_DB_INFO*  pDbInfo;
    
        WsbAssert(0 != pRecInfo, E_POINTER);
        WsbAffirm(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;
        for (int i = 0; i < m_nRecTypes; i++) {
            if (m_RecInfo[i].Type == RecType) {
                pRecInfo->Type = m_RecInfo[i].Type;
                pRecInfo->EntityClassId = m_RecInfo[i].EntityClassId;
                pRecInfo->Flags = m_RecInfo[i].Flags;
                pRecInfo->MinSize = m_RecInfo[i].MinSize;
                pRecInfo->MaxSize = m_RecInfo[i].MaxSize;
                pRecInfo->nKeys = m_RecInfo[i].nKeys;
                hr = S_OK;
                break;
            }
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDb::GetRecInfo"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


// GetJetIds - for a given record type, return the session ID,
//    the table ID, and the data column ID
HRESULT CWsbDb::GetJetIds(JET_SESID SessionId, ULONG RecType, 
                JET_TABLEID* pTableId, ULONG* pDataColId)
{
    HRESULT             hr = WSB_E_INVALID_DATA;

    WsbTraceIn(OLESTR("CWsbDb::GetJetIds"), OLESTR(""));
    
    try {
        JET_DBID      DbId = 0;
        IMP_DB_INFO*  pDbInfo;
    
        WsbAssert(0 != pTableId || 0 != pDataColId, E_POINTER);
        WsbAffirm(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;
        WsbTrace(OLESTR("CWsbDb::GetJetIds: this = %p, pDbInfo = %p\n"), 
                this, pDbInfo);

        for (int index = 0; index < pDbInfo->nSessions; index++) {
            if (pDbInfo->SessionInfo[index].SessionId == SessionId) {
                DbId = pDbInfo->SessionInfo[index].DbId;
                break;
            }
        }
        WsbTrace(OLESTR("CWsbDb::GetJetIds: index = %d, DbId = %ld\n"), index, (LONG)DbId);
        WsbAffirm(index < pDbInfo->nSessions, E_FAIL);
        WsbAffirm(pDbInfo->SessionInfo[index].pTableInfo, WSB_E_NOT_INITIALIZED);
        for (int i = 0; i < m_nRecTypes; i++) {
            if (m_RecInfo[i].Type == RecType) {
                JET_ERR         jstat;
                char            table_name[20];
                IMP_TABLE_INFO* t_info = pDbInfo->SessionInfo[index].pTableInfo;

                WsbAffirmHr(jet_make_table_name(m_RecInfo[i].Type,
                        table_name, 20));
                WsbTrace(OLESTR("CWsbDb::GetJetIds: t_info = %p, i = %d, table_name = <%hs>\n"), 
                        t_info, i, table_name);
                if (0 == t_info[i].TableId && 0 == t_info[i].ColId) {

                    //  Open the table for this record type
                    WsbTrace(OLESTR("CWsbDb::GetJetIds: opening Jet table, SessionId = %lx, DbId = %ld, table_name = <%hs>, &TableId = %p\n"),
                            (LONG)SessionId, (LONG)DbId, table_name, (&t_info[i].TableId));
                    jstat = JetOpenTable(SessionId, DbId, table_name,
                            NULL, 0, 0, &t_info[i].TableId);
                    WsbTrace(OLESTR("CWsbDb::GetJetIds: TableId = %ld\n"),
                            t_info[i].TableId);
                    WsbAffirmHr(jet_error(jstat));

                    //  Get the column ID for the data column
                    WsbAffirmHr(jet_get_column_id(SessionId, DbId, table_name,
                            JET_DATA_COLUMN_NAME, &t_info[i].ColId));
                }

                if (0 != pTableId) {
                    *pTableId = t_info[i].TableId;
                }
                if (0 != pDataColId) {
                    *pDataColId = t_info[i].ColId;
                }
                hr = S_OK;
                break;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDb::GetJetIds"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

// GetJetIndexInfo - for a given record type and key type, return information
//    about the key/index: the key size (in bytes), the column ID,
//    the index name
HRESULT CWsbDb::GetJetIndexInfo(JET_SESID SessionId, ULONG RecType, ULONG KeyType,
                ULONG* pColId, OLECHAR** pName, ULONG bufferSize)
{
    HRESULT             hr = WSB_E_INVALID_DATA;

    WsbTraceIn(OLESTR("CWsbDb::GetJetIndexInfo"), OLESTR(""));
    
    try {
        JET_DBID      DbId = 0;
        IMP_DB_INFO*  pDbInfo;
    
        WsbAssert(0 != pColId || 0 != pName, E_POINTER);
        WsbAffirm(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;

        for (int index = 0; index < pDbInfo->nSessions; index++) {
            if (pDbInfo->SessionInfo[index].SessionId == SessionId) {
                DbId = pDbInfo->SessionInfo[index].DbId;
                break;
            }
        }
        WsbAffirm(index < pDbInfo->nSessions, E_FAIL);
        for (int i = 0; i < m_nRecTypes; i++) {
            if (m_RecInfo[i].Type == RecType) {
                char index_name[20];
                char table_name[20];

                WsbAffirmHr(jet_make_table_name(RecType, table_name, 20));

                if (0 == KeyType) {
                    if (0 != pName) {
                        WsbAffirm(bufferSize > strlen(JET_SEQNUM_COLUMN_NAME), E_FAIL);
                        WsbAffirm(0 < mbstowcs(*pName, JET_SEQNUM_COLUMN_NAME, 
                                strlen(JET_SEQNUM_COLUMN_NAME) + 1), E_FAIL);
                    }
                    if (0 != pColId) {
                        WsbAffirmHr(jet_get_column_id(SessionId, DbId, table_name,
                                JET_SEQNUM_COLUMN_NAME, pColId));
                    }
                    hr = S_OK;
                } else {
                    //  Search for the given key type
                    for (int j = 0; j < m_RecInfo[i].nKeys; j++) {
                        if (m_RecInfo[i].Key[j].Type == KeyType) {
                            WsbAffirmHr(jet_make_index_name(KeyType, index_name, 20));
                            if (0 != pName) {
                                WsbAffirm(bufferSize > strlen(index_name), E_FAIL);
                                WsbAffirm(0 < mbstowcs(*pName, index_name, 
                                        strlen(index_name) + 1), E_FAIL);
                            }
                            if (0 != pColId) {
                                WsbAffirmHr(jet_get_column_id(SessionId, DbId, table_name,
                                        index_name, pColId));
                            }
                            hr = S_OK;
                            break;
                        }
                    }
                }
                break;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDb::GetJetIndexInfo"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDb::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDb::FinalConstruct"), OLESTR("") );

    try {
        IMP_DB_INFO*  pDbInfo;

        WsbAffirmHr(CWsbPersistable::FinalConstruct());
        m_nRecTypes = 0;
        m_version = 0;
        m_pImp = NULL;
        m_RecInfo = NULL;

        m_SessionIndex = 0;

        // Allocate space for DB info & set
        pDbInfo = (IMP_DB_INFO*)WsbAlloc(sizeof(IMP_DB_INFO));
        m_pImp = pDbInfo;
        WsbAffirm(pDbInfo, E_OUTOFMEMORY);
        ZeroMemory(pDbInfo, sizeof(IMP_DB_INFO));
        pDbInfo->IsLoaded = FALSE;
        pDbInfo->OpenCount = 0;

        pDbInfo->nSessions = 0;
        pDbInfo->SessionInfo = NULL;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDb::FinalConstruct"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



void
CWsbDb::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDb::FinalRelease"), OLESTR(""));

    try {
        if (m_pImp) {
            int          i;
            IMP_DB_INFO* pDbInfo;

            pDbInfo = (IMP_DB_INFO*)m_pImp;

            if (pDbInfo->RecInfo) {
                for (i = 0; i < m_nRecTypes; i++) {

                    if (pDbInfo->RecInfo[i].Key) {
                        WsbFree(pDbInfo->RecInfo[i].Key);
                    }
                }
                WsbFree(pDbInfo->RecInfo);
            }

            //  Make sure Jet resources are released
            if (NULL != pDbInfo->SessionInfo) {
                IMP_SESSION_INFO* s_info = pDbInfo->SessionInfo;

                for (i = 0; i < pDbInfo->nSessions; i++) {
                    if (0 != s_info[i].SessionId && 0 != s_info[i].DbId) {
                        JET_ERR       jstat;

                        jstat = JetCloseDatabase(s_info[i].SessionId, 
                                s_info[i].DbId, 0);
                        WsbTrace(OLESTR("CWsbDb::FinalRelease: JetCloseDatabase[%d] = %ld\n"),
                                i, (LONG)jstat);
                    }
                    if (s_info[i].pTableInfo) {
                        WsbFree(s_info[i].pTableInfo);
                        s_info[i].pTableInfo = NULL;
                    }
                    s_info[i].SessionId = 0;
                    s_info[i].DbId = 0;
                }

                WsbFree(pDbInfo->SessionInfo);
                pDbInfo->SessionInfo = NULL;
            }
            pDbInfo->nSessions = 0;

            WsbFree(pDbInfo);
            m_pImp = NULL;
        }


        if (m_RecInfo) {
            for (int i = 0; i < m_nRecTypes; i++) {
                if (m_RecInfo[i].Key) {
                    WsbFree(m_RecInfo[i].Key);
                }
            }
            WsbFree(m_RecInfo);
            m_RecInfo = NULL;
        }

        CWsbPersistable::FinalRelease();
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDb::FinalRelease"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));
}



HRESULT
CWsbDb::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDb::GetClassID"), OLESTR(""));

    try {
        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CWsbDb;
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CWsbDb::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CWsbDb::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT             hr = S_OK;
    OLECHAR*            name = NULL;

    WsbTraceIn(OLESTR("CWsbDb::Load"), OLESTR(""));
    
    try {
        ULONG         Bytes;
        ULONG         len = 0;
        IMP_DB_INFO*  pDbInfo;
        FILE_DB_INFO  db_file_block;   // Used to move info to/from file
        CComQIPtr<IWsbDb, &IID_IWsbDb> pIWsbDb = (IWsbDbPriv*)this;

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;

        // Don't allow loading into an already open DB
        WsbAffirm(pDbInfo->OpenCount == 0, WSB_E_INVALID_DATA);

        // Read the DB file name
        WsbAffirmHr(WsbLoadFromStream(pStream, &name, 0));
        if (name) {
            len = wcslen(name);
        }

        // If the DB name is empty, there is no more info
        if (0 < len) {
            // Alloc space and read DB info
            WsbAffirmHr(pStream->Read((void*)&db_file_block, sizeof(FILE_DB_INFO), &Bytes));
            WsbAffirm(Bytes == sizeof(FILE_DB_INFO), WSB_E_STREAM_ERROR);

            // Check DB version for match
            WsbAffirm(db_file_block.version == m_version, WSB_E_IDB_WRONG_VERSION);

            // Locate the DB
            WsbAffirmHr(db_info_from_file_block(&db_file_block));
            hr = Locate(name);
            if (S_OK != hr) {
                if (pDbInfo->RecInfo) {
                    WsbFree(pDbInfo->RecInfo);
                    pDbInfo->RecInfo = NULL;
                }
            }
        } else {
            hr = S_FALSE;
        }
    } WsbCatch(hr);

    WsbFree(name);

    WsbTraceOut(OLESTR("CWsbDb::Load"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDb::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDb::Save"), OLESTR(""));
    
    try {
        ULONG         Bytes;
        ULONG         len = 0;
        FILE_DB_INFO  db_file_block;   // Used to move info to/from file

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(m_pImp, WSB_E_NOT_INITIALIZED);

        // Save the DB name
        WsbAffirmHr(WsbSaveToStream(pStream, m_path));
        WsbAffirmHr(m_path.GetLen(&len));

        // If the name is empty, none of the other information is likely
        // to be useful
        if (0 < len) {
            // Write some DB info
            WsbAffirm(m_nRecTypes, WSB_E_NOT_INITIALIZED);
            WsbAffirmHr(db_info_to_file_block(&db_file_block));
            WsbAffirmHr(pStream->Write((void*)&db_file_block, sizeof(FILE_DB_INFO), &Bytes));
            WsbAffirm(Bytes == sizeof(FILE_DB_INFO), WSB_E_STREAM_ERROR);
        }

        if (clearDirty) {
            SetIsDirty(FALSE);
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDb::Save"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

//
// Private functions
//

//  db_info_from_file_block - copy data from DB info file block
HRESULT
CWsbDb::db_info_from_file_block(void* block)
{
    HRESULT hr = S_OK;

    try {
        IMP_DB_INFO*  pDbInfo;
        ULONG         Size;
        FILE_DB_INFO *pDbFileBlock = (FILE_DB_INFO*)block;

        WsbAffirm(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;

        WsbAssert(0 != pDbFileBlock, E_POINTER);
        m_version = pDbFileBlock->version;
        m_nRecTypes = pDbFileBlock->nRecTypes;

        //  Allocate record arrays
        if (NULL == m_RecInfo) {
            Size = m_nRecTypes * sizeof(IDB_REC_INFO);
            m_RecInfo = (IDB_REC_INFO*)WsbAlloc(Size);
            WsbAffirm(m_RecInfo, E_OUTOFMEMORY);
            ZeroMemory(m_RecInfo, Size);
        }
        if (NULL == pDbInfo->RecInfo) {
            Size = m_nRecTypes * sizeof(IMP_REC_INFO);
            pDbInfo->RecInfo = (IMP_REC_INFO*)WsbAlloc(Size);
            WsbAffirm(pDbInfo->RecInfo, E_OUTOFMEMORY);
            ZeroMemory(pDbInfo->RecInfo, Size);
        }
    } WsbCatch(hr);

    return(hr);
}

//  db_info_to_file_block - copy data to DB info file block
HRESULT 
CWsbDb::db_info_to_file_block(void* block)
{
    HRESULT hr = S_OK;

    try {
        FILE_DB_INFO *pDbFileBlock = (FILE_DB_INFO*)block;

        WsbAssert (0 != pDbFileBlock, E_POINTER);
        pDbFileBlock->version = m_version;
        pDbFileBlock->nRecTypes = m_nRecTypes;
    } WsbCatch(hr);

    return hr;
}

//  rec_info_from_file_block - copy record data from rec info file block
HRESULT
CWsbDb::rec_info_from_file_block(int index, void* block)
{
    HRESULT hr = S_OK;

    try {
        IMP_DB_INFO*  pDbInfo;
        ULONG         Size;
        FILE_REC_INFO *pRecFileBlock = (FILE_REC_INFO*)block;

        WsbAffirm(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;

        WsbAssert (0 != pRecFileBlock, E_POINTER);
        m_RecInfo[index].Type = pRecFileBlock->Type;
        m_RecInfo[index].EntityClassId = pRecFileBlock->EntityClassId;
        m_RecInfo[index].Flags = pRecFileBlock->Flags;
        m_RecInfo[index].MinSize = pRecFileBlock->MinSize;
        m_RecInfo[index].MaxSize = pRecFileBlock->MaxSize;
        m_RecInfo[index].nKeys = pRecFileBlock->nKeys;

        //  Allocate Key arrays
        if (NULL == m_RecInfo[index].Key) {
            Size = m_RecInfo[index].nKeys * sizeof(IDB_KEY_INFO);
            m_RecInfo[index].Key = (IDB_KEY_INFO*)WsbAlloc(Size);
            WsbAffirm(m_RecInfo[index].Key, E_OUTOFMEMORY);
            ZeroMemory(m_RecInfo[index].Key, Size);
        }
        if (NULL == pDbInfo->RecInfo[index].Key) {
            Size = m_RecInfo[index].nKeys * sizeof(IMP_KEY_INFO);
            pDbInfo->RecInfo[index].Key = (IMP_KEY_INFO*)WsbAlloc(Size);
            WsbAffirm(pDbInfo->RecInfo[index].Key, E_OUTOFMEMORY);
            ZeroMemory(pDbInfo->RecInfo[index].Key, Size);
        }

        for (int j = 0; j < pRecFileBlock->nKeys; j++) {
            m_RecInfo[index].Key[j].Type = pRecFileBlock->Key[j].Type;
            m_RecInfo[index].Key[j].Size = pRecFileBlock->Key[j].Size;
            m_RecInfo[index].Key[j].Flags = pRecFileBlock->Key[j].Flags;
        }
    } WsbCatch(hr);

    return(hr);
}

//  rec_info_to_file_block - copy record data to rec info file block
HRESULT 
CWsbDb::rec_info_to_file_block(int index, void* block)
{
    HRESULT hr = S_OK;
    try {
        FILE_REC_INFO *pRecFileBlock = (FILE_REC_INFO*)block;

        WsbAssert (0 != pRecFileBlock, E_POINTER);

//      pRecFileBlock->SeqNum = m_RecInfo[index].SeqNum;
        pRecFileBlock->Type = m_RecInfo[index].Type;
        pRecFileBlock->EntityClassId = m_RecInfo[index].EntityClassId;
        pRecFileBlock->Flags = m_RecInfo[index].Flags;
        pRecFileBlock->MinSize = m_RecInfo[index].MinSize;
        pRecFileBlock->MaxSize = m_RecInfo[index].MaxSize;
        pRecFileBlock->nKeys = m_RecInfo[index].nKeys;
        for (int j = 0; j < pRecFileBlock->nKeys; j++) {
            pRecFileBlock->Key[j].Type = m_RecInfo[index].Key[j].Type;
            pRecFileBlock->Key[j].Size = m_RecInfo[index].Key[j].Size;
            pRecFileBlock->Key[j].Flags = m_RecInfo[index].Key[j].Flags;
        }
    } WsbCatch(hr);

    return hr;
}

//  session_current_index - find the index into the session info array.
//    Sets m_SessionIndex if it's OK
HRESULT 
CWsbDb::session_current_index(IWsbDbSession* pSession)
{
    HRESULT       hr = WSB_E_INVALID_DATA;
    IMP_DB_INFO*  pDbInfo;
    CComQIPtr<IWsbDbSessionPriv, &IID_IWsbDbSessionPriv> pSessionPriv = pSession;

    WsbTraceIn(OLESTR("CWsbDB::session_current_index"), OLESTR(""));
    pDbInfo = (IMP_DB_INFO*)m_pImp;
    if (NULL != pDbInfo && NULL != pDbInfo->SessionInfo && pSessionPriv) {
        JET_SESID SessionId;

        if (S_OK == pSessionPriv->GetJetId(&SessionId)) {
            for (int index = 0; index < pDbInfo->nSessions; index++) {
                if (pDbInfo->SessionInfo[index].SessionId == SessionId) {
                    hr = S_OK;
                    m_SessionIndex = index;
                    break;
                }
            }
        }
    }

    WsbTraceOut(OLESTR("CWsbDB::session_current_index"), OLESTR("sessionID[%ld] = %lx"),
                m_SessionIndex, pDbInfo->SessionInfo[m_SessionIndex].SessionId);
    return(hr);
}


// jet_init - make sure this IDB object is initialized for JET
HRESULT
CWsbDb::jet_init(void)
{
    HRESULT    hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDb::jet_init"), OLESTR(""));

    try {
        IMP_DB_INFO*  pDbInfo;

        pDbInfo = (IMP_DB_INFO*)m_pImp;
        WsbTrace(OLESTR("CWsbDB::jet_init, nSessions = %d\n"),
                (int)pDbInfo->nSessions);
        if (0 == pDbInfo->nSessions) {
            ULONG        memSize;

            //  Allocate the thread info array
            WsbAffirm(m_pWsbDbSys, E_FAIL);
            memSize = SESSION_INFO_INITIAL_SIZE * sizeof(IMP_SESSION_INFO);
            pDbInfo->SessionInfo = (IMP_SESSION_INFO*)WsbAlloc(memSize);
            WsbAffirm(pDbInfo->SessionInfo, E_OUTOFMEMORY);
            pDbInfo->nSessions = SESSION_INFO_INITIAL_SIZE;
            ZeroMemory(pDbInfo->SessionInfo, memSize);
            WsbTrace(OLESTR("CWsbDB::jet_init, SessionInfo(%ld bytes) allocated & zeroed\n"),
                    memSize);

            //  Begin a JET session for the IDB
            m_SessionIndex = 0;

            JET_SESID               sid;
            CComPtr<IWsbDbSession>  pSession;
            WsbAffirmHr(m_pWsbDbSys->GetGlobalSession(&pSession));

            CComQIPtr<IWsbDbSessionPriv, &IID_IWsbDbSessionPriv> pSessionPriv = pSession;
            WsbAffirmPointer(pSessionPriv);
            WsbAffirmHr(pSessionPriv->GetJetId(&sid));
            pDbInfo->SessionInfo[m_SessionIndex].SessionId = sid;
            WsbTrace(OLESTR("CWsbDB::jet_init, SessionId[0] = %lx\n"),
                    pDbInfo->SessionInfo[m_SessionIndex].SessionId);
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDb::jet_init"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));
    return(hr);
}

// jet_load_info - load DB info from database
HRESULT
CWsbDb::jet_load_info(void)
{
    HRESULT       hr = S_OK;
    IMP_DB_INFO*  pDbInfo = NULL;
    JET_TABLEID   table_id = 0;
    JET_ERR       jstat;

    WsbTraceIn(OLESTR("CWsbDb::jet_load_info"), OLESTR(""));

    try {
        JET_COLUMNID  col_id_data;
        ULONG         size;
        FILE_DB_INFO  db_file_block;   // Used to move info to/from file
        FILE_REC_INFO rec_file_block;  // Used to move record info

        WsbAffirm(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;

        // Open the info table
        jstat = JetOpenTable(JET_CURRENT_SESSION, JET_CURRENT_DB, JET_INFO_TABLE_NAME,
                NULL, 0, 0, &table_id);
        if (jstat != JET_errSuccess) {
            table_id = 0;
        }
        WsbTrace(OLESTR("CWsbDb::jet_load_info: open TableId = %ld\n"),
               table_id);
        WsbAffirmHr(jet_error(jstat));
        WsbAffirmHr(jet_get_column_id(JET_CURRENT_SESSION, JET_CURRENT_DB, JET_INFO_TABLE_NAME,
                JET_DATA_COLUMN_NAME, &col_id_data));
        jstat = JetSetCurrentIndex(JET_CURRENT_SESSION, table_id, NULL);
        WsbAffirmHr(jet_error(jstat));

        // Get the DB info and check for match
        jstat = JetRetrieveColumn(JET_CURRENT_SESSION, table_id, col_id_data,
                &db_file_block, sizeof(FILE_DB_INFO), &size, 0, NULL);
        WsbAffirmHr(jet_error(jstat));
        WsbAffirm(db_file_block.nRecTypes > 0, WSB_E_INVALID_DATA);
        WsbAffirm(db_file_block.version == m_version, WSB_E_IDB_WRONG_VERSION);
        WsbAffirmHr(db_info_from_file_block(&db_file_block));
        
        // Get the record/key info
        for (int i = 0; i < m_nRecTypes; i++) {
            jstat = JetMove(JET_CURRENT_SESSION, table_id, JET_MoveNext, 0);
            WsbAffirmHr(jet_error(jstat));
            jstat = JetRetrieveColumn(JET_CURRENT_SESSION, table_id, col_id_data,
                    &rec_file_block, sizeof(FILE_REC_INFO), &size, 0, NULL);
            WsbAffirmHr(jet_error(jstat));
            WsbAffirmHr(rec_info_from_file_block(i, &rec_file_block));
        }
    } WsbCatch(hr);

    if (table_id) {
        jstat = JetCloseTable(JET_CURRENT_SESSION, table_id);
        WsbTrace(OLESTR("CWsbDb::jet_load_info: close TableId = %ld, jstat = %ld\n"),
               table_id, jstat);
    }

    WsbTraceOut(OLESTR("CWsbDb::jet_load_info"), OLESTR("hr =<%ls>"), 
            WsbHrAsString(hr));
    return(hr);
}

// jet_make_index_name - convert key type to index name
HRESULT 
CWsbDb::jet_make_index_name(ULONG key_type, char* pName, ULONG bufsize)
{
    HRESULT       hr = E_FAIL;
    char          lbuf[20];

    if (pName != NULL) {
        sprintf(lbuf, "%ld", key_type);
        if (bufsize > strlen(lbuf)) {
            strcpy(pName, lbuf);
            hr = S_OK;
        }
    }
    return(hr);
}

// jet_make_table_name - convert record type to table name
HRESULT 
CWsbDb::jet_make_table_name(ULONG rec_type, char* pName, ULONG bufsize)
{
    HRESULT       hr = E_FAIL;
    char          lbuf[20];

    if (pName != NULL) {
        sprintf(lbuf, "%ld", rec_type);
        if (bufsize > strlen(lbuf)) {
            strcpy(pName, lbuf);
            hr = S_OK;
        }
    }
    return(hr);
}

// jet_save_info - save DB info to database
HRESULT
CWsbDb::jet_save_info()
{
    HRESULT       hr = S_OK;
    IMP_DB_INFO*  pDbInfo = NULL;
    JET_TABLEID   table_id = 0;
    JET_ERR       jstat;

    try {
        JET_COLUMNID  col_id_data;
        JET_COLUMNID  col_id_index;
        SHORT         data_number;
        FILE_DB_INFO  db_file_block;   // Used to move info to/from file
        FILE_REC_INFO rec_file_block;  // Used to move record info

        WsbAffirm(m_pImp, WSB_E_NOT_INITIALIZED);
        pDbInfo = (IMP_DB_INFO*)m_pImp;

        // Open the table
        jstat = JetOpenTable(JET_CURRENT_SESSION, JET_CURRENT_DB, JET_INFO_TABLE_NAME,
                NULL, 0, 0, &table_id);
        WsbTrace(OLESTR("CWsbDb::jet_save_info: open TableId = %ld\n"),
               table_id);
        WsbAffirmHr(jet_error(jstat));
        WsbAffirmHr(jet_get_column_id(JET_CURRENT_SESSION, JET_CURRENT_DB, JET_INFO_TABLE_NAME,
                JET_INDEX_COLUMN_NAME, &col_id_index));
        WsbAffirmHr(jet_get_column_id(JET_CURRENT_SESSION, JET_CURRENT_DB, JET_INFO_TABLE_NAME,
                JET_DATA_COLUMN_NAME, &col_id_data));

        // Put the DB info
        jstat = JetPrepareUpdate(JET_CURRENT_SESSION, table_id, JET_prepInsert);
        WsbAffirmHr(jet_error(jstat));
        WsbAffirmHr(db_info_to_file_block(&db_file_block));
        data_number = 0;
        jstat = JetSetColumn(JET_CURRENT_SESSION, table_id, col_id_index, &data_number,
                sizeof(data_number), 0, NULL);
        WsbAffirmHr(jet_error(jstat));
        jstat = JetSetColumn(JET_CURRENT_SESSION, table_id, col_id_data, &db_file_block,
                sizeof(FILE_DB_INFO), 0, NULL);
        WsbAffirmHr(jet_error(jstat));
        jstat = JetUpdate(JET_CURRENT_SESSION, table_id, NULL, 0, NULL);
        WsbAffirmHr(jet_error(jstat));

        // Put the record/key info
        for (int i = 0; i < m_nRecTypes; i++) {
            jstat = JetPrepareUpdate(JET_CURRENT_SESSION, table_id, JET_prepInsert);
            WsbAffirmHr(jet_error(jstat));
            WsbAffirmHr(rec_info_to_file_block(i, &rec_file_block));
            data_number = (SHORT) ( i + 1 );
            jstat = JetSetColumn(JET_CURRENT_SESSION, table_id, col_id_index, &data_number,
                    sizeof(data_number), 0, NULL);
            WsbAffirmHr(jet_error(jstat));
            jstat = JetSetColumn(JET_CURRENT_SESSION, table_id, col_id_data, &rec_file_block,
                sizeof(FILE_REC_INFO), 0, NULL);
            WsbAffirmHr(jet_error(jstat));
            jstat = JetUpdate(JET_CURRENT_SESSION, table_id, NULL, 0, NULL);
            WsbAffirmHr(jet_error(jstat));
        }
    } WsbCatch(hr);

    if (table_id) {
        jstat = JetCloseTable(JET_CURRENT_SESSION, table_id);
        WsbTrace(OLESTR("CWsbDb::jet_save_info: close TableId = %ld, jstat = %ld\n"),
               table_id, jstat);
    }
    return(hr);
}

//  Local functions

//  jet_get_column_id - convert a column name to a column ID
static HRESULT jet_get_column_id(JET_SESID jet_session, JET_DBID DbId, 
        char* pTableName, char* pColumnName, JET_COLUMNID* pColId)
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("jet_get_column_id"), OLESTR("SessId = %lx, DbId = %lx"),
        (ULONG)jet_session, (ULONG)DbId);

    try {
        JET_COLUMNBASE col_base;
        JET_ERR        jstat;

        WsbAssert(NULL != pColId, E_POINTER);
        jstat = JetGetColumnInfo(jet_session, DbId, pTableName, pColumnName,
                &col_base, sizeof(col_base), JET_ColInfoBase);
        WsbAssertHr(jet_error(jstat));
        *pColId = col_base.columnid;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("jet_get_column_id"), OLESTR("col_id = %ld"),
        (LONG)*pColId);
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\idb\wsbdbkey.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Wsbdbkey.cpp

Abstract:

    The CWsbDbKey class.

Author:

    Ron White   [ronw]   1-Jul-1997

Revision History:

--*/

#include "stdafx.h"

#include "wsbdbkey.h"

// Local stuff



HRESULT
CWsbDbKey::AppendBool(
    BOOL value
    )

/*++

Implements:

  IWsbDbKey::AppendBool

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;

    WsbTraceIn(OLESTR("CWsbDbKey::AppendBool"), OLESTR("value = <%ls>"), WsbBoolAsString(value));
    
    try {
        WsbAssert(make_key(m_size + WsbByteSize(value)), WSB_E