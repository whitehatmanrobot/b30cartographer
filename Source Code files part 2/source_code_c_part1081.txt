                  in order for host-specific commands to be implemented.

RETURNED STATUS :

NOTES           : on the SG port no extensions are provided.

=======================================================================
*/

GLOBAL int host_force_yoda_extensions(char *com, long cs, long ip, long len, 
					char *str)
{
#ifdef HUNTER
int  quit_menus=FALSE;   /* some functions need to return to yoda prompt*/
char c;
char menu[] = "\tTrapper [m]ain menu\n"
              "\tTrapper [e]rror menu\n"
              "\t[Q]uit\n"
              "\t? for this menu\n\n";
#endif /* HUNTER */
    int	i,
	retvalue;

#ifdef HUNTER
/* to get to this menu, the user has to type "trap" at the Yoda prompt */

if(!strcmp(com,"trap")) /* test the input string */
   {
   printf("\nYODA EXTENSIONS\n\n");
   printf("%s",menu);
   do
      {
      trap_command("trapper",&c);
      switch(c)
         {
         case 'm':
         case 'M':
            quit_menus = host_do_trapper_main_menu();
         break;

         case 'e':
         case 'E':
            quit_menus = host_do_trapper_error_menu();
         break;

         case '?':
            printf("%s",menu);
         break;

         default:
         break;
         }
      }
   while(c != 'q' && c != 'Q' && quit_menus == FALSE );

   }
else
   {
   /* unpleasing input, so return 1 and back to main Yoda stuff */
   return(1);
   }
return(0);
#endif /* HUNTER */

    /* Check to see if we have got a command in host_yoda_command. */
    retvalue = 1;
    for (i = 0; i < sizeoftable(host_yoda_command); i++)
    {
	if (strcmp(com, host_yoda_command[i].name) == 0)
	{
	    retvalue = (*host_yoda_command[i].function)(str, com, cs, ip, len);
	    break;
	}
    }
    return(retvalue);
}

#ifdef HUNTER
/*============================================================

Function :   host_do_trapper_main_menu

Purpose  :   implements the main trapper menu under Yoda.


=============================================================*/

static int host_do_trapper_main_menu()
{
int    i,quit_menus = FALSE;
char   c,str[80],yesno;
USHORT screen_no;
BOOL   compare;

char menu[] = "\t[F]ast forward...\n"
              "\t[N]ext screen\n"
              "\t[P]rev screen\n"
              "\t[S]how screen...\n"
              "\t[C]ontinue\n"
              "\t[A]bort\n"
              "\t[Q]uit\n"
              "\t? for this menu\n\n";



char continu[] = "\n\ntype 'c' at yoda prompt to continue...\n\n";


printf("\nTRAPPER MAIN MENU\n\n");
printf("%s",menu);

do
   {
   trap_command("main",&c);
   switch(c)
      {
      case 'f': /* fast forward */
      case 'F':
         {
         printf("\n\nEnter the screen number where comparisons will start: ");
         nt_fgets(str,80,stdin);
         sscanf(str,"%d",&screen_no);
         printf("\n\nSkipping screen comparisons up to screen %d\n\n",screen_no);
         bh_start_screen(screen_no);
         }
      break;

      case 'n': /* next screen */
      case 'N':
         {
         bh_next_screen();
         printf("%s",continu);
         quit_menus = TRUE;
         }
      break;

      case 'p': /* previous screen */
      case 'P':
         {
         bh_prev_screen();
         printf("%s",continu);
         quit_menus = TRUE;
         }
      break;

      case 's': /* show screen */
      case 'S':
         {
         printf("\n\nEnter the number of the screen which you want to see: ");
         nt_fgets(str,80,stdin);
         sscanf(str,"%d",&screen_no);
         printf("\n\nDo you want to compare screen %d with one from"
                "SoftPC? (y/n): ",screen_no);
         nt_fgets(str,80,stdin);
         sscanf(str,"%c",&yesno);
         if(yesno == 'y' || yesno == 'Y')
            compare = TRUE;
         else
            compare = FALSE;

         bh_show_screen(screen_no,compare);
         }
      break;

      case 'c': /* continue */
      case 'C':
         {
         bh_continue();
         printf("%s",continu);
         quit_menus = TRUE;
         }
      break;

      case 'a': /* abort */
      case 'A':
         bh_abort();
      break;

      case '?':
         printf("%s",menu);
      break;

      default:
      break;
      }
   }
while(c != 'q' && c != 'Q' && quit_menus == FALSE);
return(quit_menus); /* match found */
}

/*============================================================

Function :   host_do_trapper_error_menu

Purpose  :   implements the trapper error menu under Yoda.

returns  :   TRUE if the user has selected a trapper function
             which requires softpc to be restarted.
             FALSE otherwise.

=============================================================*/

static int host_do_trapper_error_menu()
{
int  i,quit_menus=FALSE;
char c;
char menu[] = "\t[F]lip screen\n"
              "\t[N]ext error\n"
              "\t[P]rev error\n"
              "\t[A]ll errors\n"
              "\t[C]lear errors\n"
              "\t[Q]uit menu\n"
              "\t? for this menu\n\n";


printf("\nTRAPPER ERROR MENU\n\n");
printf("%s",menu);

do
   {
   trap_command("error",&c);
   switch(c)
      {
      case 'f':
      case 'F':
         bh_flip_screen();
         printf("\n\ntype 'c' at yoda prompt to continue...\n\n");
         quit_menus = TRUE;
      break;

      case 'n':
      case 'N':
         bh_next_error();
      break;

      case 'p':
      case 'P':
         bh_prev_error();
      break;

      case 'a':
      case 'A':
         bh_all_errors();
      break;

      case 'c':
      case 'C':
         bh_wipe_errors();
      break;

      case '?':
         printf("%s",menu);
      break;

      default:
      break;
      }
   }
while(c != 'q' && c != 'Q' && quit_menus == FALSE);

if(quit_menus == TRUE)
   return(TRUE); /* need to go to the yoda prompt */
else
   return(FALSE);  /* don't need to go to the yoda prompt */
}
#endif /* HUNTER */

/*
=========================================================================

FUNCTION        : host_yoda_check_I_extensions

PURPOSE         : this function is called by the YODA check_I code
                  in order to provide host specific extensions.

RETURNED STATUS :

NOTES           : on the SG port no extensions are provided.

=======================================================================
*/

GLOBAL void host_yoda_check_I_extensions()
{
    sys_addr addr;
    word cs,
	 ip,
	 ss,
	 sp;
    IS8 seg_override;
    IU8 opcode,
	modrm,
	mod,
	n_field,
	rm,
	i;

    /* Check to see if call-back-tracing is enabled. */
    if (call_back_tracing_enabled)
    {

	/* Check to see if call on top of stack has been popped. */
	ss = getSS();
	sp = getSP();
	check_stack(ss, sp);

	/* Get current op-code. */
	cs = getCS();
	ip = getIP();
	addr = effective_addr(cs, ip);
	seg_override = do_prefixes(&addr);
	opcode = sas_hw_at_no_check(addr);

	/* Check to see if we have a call-back-trace op-code. */
	switch (opcode)
	{
	case 0x9a:

	    /* 9a =  CALLF immediate */

	    /* Check there is room for another entry in call_stack. */
	    if (check_for_overflow() == -1)
		return;

	    /* Fill the stack entry. */
	    call_next_free->type = CT_IMM;
	    call_next_free->cs = cs;
	    call_next_free->ip = ip;
	    call_next_free->inst_addr = addr;
	    call_next_free->nbytes = 5;
	    call_next_free->cfar = TRUE;
	    call_next_free->seg = sas_w_at_no_check(addr + 3);
	    call_next_free->off = sas_w_at_no_check(addr + 1);

	    /* Save state of stack. */
	    call_next_free->ss = ss;
	    call_next_free->sp = sp;

	    /* Store instruction bytes. */
	    for (i = 0; i < 5; i++)
		call_next_free->opcode[i] = sas_hw_at_no_check(addr++);

	    /* Increment top of stack. */
	    call_next_free++;
	    break;
	case 0xe8:

	    /* e8 = CALL immediate */

	    /* Check there is room for another entry in call_stack. */
	    if (check_for_overflow() == -1)
		return;

	    /* Fill the stack entry. */
	    call_next_free->type = CT_IMM;
	    call_next_free->cs = cs;
	    call_next_free->ip = ip;
	    call_next_free->inst_addr = addr;
	    call_next_free->nbytes = 3;
	    call_next_free->cfar = FALSE;
	    call_next_free->off = ip + (word) 3 + sas_w_at_no_check(addr + 1);

	    /* Save state of stack. */
	    call_next_free->ss = ss;
	    call_next_free->sp = sp;

	    /* Store instruction bytes. */
	    for (i = 0; i < 3; i++)
		call_next_free->opcode[i] = sas_hw_at_no_check(addr++);

	    /* Increment top of stack. */
	    call_next_free++;
	    break;
	case 0xff:

	    /*
	     * ff /2 = CALL
	     * ff /3 = CALLF
	     */
	    modrm = sas_hw_at_no_check(addr + 1);
	    n_field = (modrm & 0x38) >> 3;
	    if ((n_field == 2) || (n_field == 3))
	    {

		/* Check there is room for another entry in call_stack. */
		if (check_for_overflow() == -1)
		    return;

		/* Save CS:IP of call instruction. */
		call_next_free->cs = cs;
		call_next_free->ip = ip;

		/* Store opcode address and initialise byte count. */
		call_next_free->inst_addr = addr;
		call_next_free->nbytes = 2;
		
		/* n-field: 2 = near, 3 = far. */
		call_next_free->cfar = n_field & 1;

		/* If mod is 3 we have a register rm otherwise it is EA. */
		mod = (modrm & 0xc0) >> 6;
		rm = modrm & 7;
		if (mod == 3)
		{
		    if (call_next_free->cfar)
		    {

			/* Can't have a far pointer in a register. */
			printf("Invalid mod-rm byte after ff op-code.\n");
			vader = 1;
			return;
		    }
		    else
		    {

			/* Near pointer contained in register. */
			call_next_free->type = CT_REG;
			call_next_free->off =
			    sas_w_at_no_check((*EA_reg_func[rm])());
			call_next_free->extra.regind = rm;

			/* Save state of stack. */
			call_next_free->ss = ss;
			call_next_free->sp = sp;
		    }
		}
		else
		{

		    /* We have an EA type CALL. */
		    call_next_free->type = CT_EA;
		    call_next_free->extra.ea.seg_override = seg_override;

		    /* Adjust address and count for segment override. */
		    if (seg_override != NO_OVERRIDE)
		    {
			call_next_free->inst_addr--;
			call_next_free->nbytes++;
		    }

		    /* Work out EA from mod-rm. */
		    get_ea_from_modrm(call_next_free, mod, rm, addr + 2);

		    /* Get target segment and offset from EA. */
		    if (call_next_free->cfar)
		    {
			call_next_free->seg =
			    sas_w_at_no_check(call_next_free->extra.ea.addr+2);

			/* Save state of stack. */
			call_next_free->ss = ss;
			call_next_free->sp = sp;
		    }
		    else
		    {

			/* Save state of stack. */
			call_next_free->ss = ss;
			call_next_free->sp = sp;
		    }
		    call_next_free->off =
			sas_w_at_no_check(call_next_free->extra.ea.addr);
		}

		/* Fill in the op-code bytes. */
		for (i = 0, addr = call_next_free->inst_addr;
		     i < call_next_free->nbytes;
		     i++, addr++)
		{
		    call_next_free->opcode[i] = sas_hw_at_no_check(addr);
		}

		/* Increment top of stack. */
		call_next_free++;
	    }
	    break;
	default:

	    /* Not a call-back-trace opcode so do nothing. */
	    break;
	}
    }
}

/*
=========================================================================

FUNCTION        : check_stack

PURPOSE         : Checks to see if the call on the top of the stack has
		  been popped and if so removes it from the top of the
		  call stack.

RETURNED STATUS : void

NOTES           : Originally the call stack was popped on RET instructions
		  but this did not work when apps did things like POP
		  followed by JMP. It was therefore decided to check whether
		  the stack had shrunk past the point where a call's return
		  address was stored to see if that call had returned.

=======================================================================
*/
LOCAL void check_stack IFN2(word, ss, word, sp)
{
    IU32 count = 0;

    /*
     * Pop the call stack until we have a call whose return address is still
     * on the real stack.
     */
    while ((call_next_free > call_stack) &&
	   (ss == (call_next_free - 1)->ss) &&
	   (sp >= (call_next_free - 1)->sp))
    {
	call_next_free--;
	count++;
    }

    /* Complain if more than one call gets popped. */
    if (count > 1)
	printf("Call stack warning - %d calls popped at %04x:%04x\n",
	       count, getCS(), getIP());
}

/*
=========================================================================

FUNCTION        : do_prefixes

PURPOSE         : Skips over all prefix op-codes.

RETURNED STATUS : Segment override if any.

NOTES           :

=======================================================================
*/
LOCAL IS8 do_prefixes IFN1(sys_addr *, opcode_ptr)
{
    half_word opcode;
    IS8 seg_override = NO_OVERRIDE;

    /* Skip over prefix opcodes. */
    opcode = sas_hw_at_no_check(*opcode_ptr);
    while ((opcode == 0xf2) || (opcode == 0xf3) ||
	   (opcode == 0x26) || (opcode == 0x2e) ||
	   (opcode == 0x36) || (opcode == 0x3e))
    {
	switch (opcode)
	{
	case 0x26:
	    seg_override = SEG_ES;
	    break;
	case 0x2e:
	    seg_override = SEG_CS;
	    break;
	case 0x36:
	    seg_override = SEG_SS;
	    break;
	case 0x3e:
	    seg_override = SEG_DS;
	    break;
	default:

	    /* Not sure what f2 and f3 do so do this for the time being. */
	    seg_override = NO_OVERRIDE;
	    break;
	}
	opcode = sas_hw_at_no_check(++(*opcode_ptr));
    }

    /* (*opcode_ptr) now points at the opcode. */
    return(seg_override);
}

/*
=========================================================================

FUNCTION        : check_for_overflow

PURPOSE         : Checks to see if the stack has overflowed.

RETURNED STATUS : -1 on failure, 0 on success.

NOTES           :

=======================================================================
*/
LOCAL int check_for_overflow IFN0()
{
    if (call_next_free - call_stack >= MAX_CALL_STACK)
    {
	printf("Call stack overflow.\n");
	vader = 1;
	return(-1);
    }
    return(0);
}

/*
=========================================================================

FUNCTION        : get_ea_from_modrm

PURPOSE         : Takes a mod-rm byte and works out the effective
		  address and the target segment and offset.

RETURNED STATUS : void

NOTES           :

=======================================================================
*/
LOCAL void get_ea_from_modrm IFN4(CALL_STACK_ENTRY *,	cs_ptr,
				  IU8,			mod,
				  IU8,			rm,
				  sys_addr,		disp_addr)
{
    IS16 offset = 0,
	 disp;
    IS8 seg,
	seg_override = cs_ptr->extra.ea.seg_override;
    IU8	flags;

    /* Get index to table from mod-rm byte. */
    cs_ptr->extra.ea.modrm_index = (mod << 3) | rm;
    flags = EA_table[cs_ptr->extra.ea.modrm_index];

    /* Use segment override if there is one otherwise default to DS. */
    seg = (seg_override == NO_OVERRIDE) ? SEG_DS : seg_override;

    /* Add base register value if any. */
    if (flags & MR_BX)
	offset += getBX();
    else if (flags & MR_BP)
    {
	offset += getBP();
	if (seg_override == NO_OVERRIDE)
	    seg = SEG_SS;
    }

    /* Add index register value if any. */
    if (flags & MR_SI)
	offset += getSI();
    else if (flags & MR_DI)
	offset += getDI();

    /* Add displacement if any. */
    if (flags & MR_D16)
    {
	cs_ptr->nbytes += 2;
	cs_ptr->extra.ea.disp_present = TRUE;
	cs_ptr->extra.ea.disp = (IS16) sas_w_at_no_check(disp_addr);
	offset += cs_ptr->extra.ea.disp;
    }
    else if (flags & MR_D8)
    {
	cs_ptr->nbytes++;
	cs_ptr->extra.ea.disp_present = TRUE;
	cs_ptr->extra.ea.disp = (IS16) ((IS8) sas_hw_at_no_check(disp_addr));
	offset += cs_ptr->extra.ea.disp;
    }
    else
	cs_ptr->extra.ea.disp_present = FALSE;

    /* Store segment and offset of return address. */
    cs_ptr->extra.ea.seg = (*get_seg[seg])();
    cs_ptr->extra.ea.off = (word) offset;
    cs_ptr->extra.ea.addr = effective_addr(cs_ptr->extra.ea.seg,
					   cs_ptr->extra.ea.off);
}

/*
=========================================================================

FUNCTION        : host_yoda_help_extensions

PURPOSE         : this function is called whenever the user asks for
                  YODA help to describe the host specific extensions provided
                  above.

RETURNED STATUS :

NOTES           : on the SG port no extensions are provided.

=======================================================================
*/

GLOBAL int host_yoda_help_extensions()
{
    int i;

    /* Print out the command and comment fields of host_yoda_command. */
    for(i = 0; i < sizeoftable(host_yoda_command); i++)
    {
	if (host_yoda_command[i].comment == NULL)
	    continue;
	printf("%14s %s\n",
	       host_yoda_command[i].name,
	       host_yoda_command[i].comment);
    }
}

/*
=========================================================================

FUNCTION        : do_ecbt

PURPOSE         : this function enables call-back-tracing.

RETURNED STATUS : 0 for success, 1 for failure

NOTES           :

=======================================================================
*/
LOCAL int do_ecbt	IPT5(char *, str, char *, com, long, cs,
			     long, ip, long, len)
{

    /* Enable call-back-tracing if it is currently disabled. */
    if (!call_back_tracing_enabled)
    {
	printf("Call back tracing enabled.\n");
	call_back_tracing_enabled = TRUE;
    }
    return(0);
}

/*
=========================================================================

FUNCTION        : do_dcbt

PURPOSE         : this function disables call-back-tracing.

RETURNED STATUS : 0 for success, 1 for failure

NOTES           :

=======================================================================
*/
LOCAL int do_dcbt	IPT5(char *, str, char *, com, long, cs,
			     long, ip, long, len)
{

    /* Disable call-back-tracing if it is currently enabled. */
    if (call_back_tracing_enabled)
    {

	/* Disable tracing. */
	printf("Call back tracing disabled.\n");
	call_back_tracing_enabled = FALSE;

	/* Reset the stack. */
	call_next_free = call_stack;
    }
    return(0);
}

/*
=========================================================================

FUNCTION        : do_pcbt

PURPOSE         : this function prints the call-back-trace stack.

RETURNED STATUS : 0 for success, 1 for failure

NOTES           :

=======================================================================
*/
LOCAL int do_pcbt	IPT5(char *, str, char *, com, long, cs,
			     long, ip, long, len)
{
    IU8 *opcode,
	 i;
    CALL_STACK_ENTRY *cs_ptr;

    /* Print out the current call-back-trace stack. */
    for (cs_ptr = call_stack; cs_ptr < call_next_free; cs_ptr++)
    {

	/* Print address and op-code. */
	printf("%04X:%04X", cs_ptr->cs, cs_ptr->ip);
	opcode = cs_ptr->opcode;
	for (i = 0; i < cs_ptr->nbytes; i++)
	    printf(" %02X", *opcode++);

	/* Print mnemonic. */
	printf("\tCALL");
	if (cs_ptr->cfar)
	    printf("F");
	printf("\t");

	/* Print parameters. */
	switch (cs_ptr->type)
	{
	case CT_IMM:

	    /* Immediate. */
	    if (cs_ptr->cfar)
		printf("%04X:", cs_ptr->seg);
	    printf("%04X", cs_ptr->off);
	    break;
	case CT_EA:

	    /* Effective address. */
	    if (cs_ptr->cfar)
		printf("d");
	    printf("word ptr ");

	    /* Print override if there is one. */
	    if (cs_ptr->extra.ea.seg_override != NO_OVERRIDE)
		printf("%s:", seg_strings[cs_ptr->extra.ea.seg_override]);

	    /* Print parameters. */
	    if (cs_ptr->extra.ea.disp_present)
		printf(EA_strings[cs_ptr->extra.ea.modrm_index],
		       cs_ptr->extra.ea.disp);
	    else
		printf(EA_strings[cs_ptr->extra.ea.modrm_index]);

	    /* Print effective address. */
	    printf("\t(%04X:%04X\t",
		   cs_ptr->extra.ea.seg,
		   cs_ptr->extra.ea.off);

	    /* Print contents of effective address. */
	    if (cs_ptr->cfar)
		printf("%04X:", cs_ptr->seg);
	    printf("%04X)", cs_ptr->off);
	    break;
	case CT_REG:

	    /* Print parameter and target address. */
	    printf(EA_reg_strings[cs_ptr->extra.regind]);
	    printf("\t(%04X)", cs_ptr->off);
	    break;
	default:
	    break;
	}
	printf("\n");
    }

    /* Return success. */
    return(0);
}

GLOBAL CHAR   *host_get_287_reg_as_string IFN1(int, reg_no)
{
     double reg;
     SAVED char regstr[30];
#ifdef CPU_40_STYLE
     strcpy(regstr, "STUBBED get_287_reg");
#else
     IMPORT double get_287_reg_as_double(int);

     reg = get_287_reg_as_double(reg_no);
     sprintf(regstr, "%g", reg);
#endif /* CPU_40_STYLE */
     return(&regstr[0]);
}

/*
=========================================================================

FUNCTION        : do_ntsd

PURPOSE         : this function forces a break back to ntsd

RETURNED STATUS : 0 for success, 1 for failure

NOTES           :

=======================================================================
*/
LOCAL int do_ntsd	IPT5(char *, str, char *, com, long, cs,
			     long, ip, long, len)
{
    UNUSED(str);
    UNUSED(com);
    UNUSED(cs);
    UNUSED(ip);
    UNUSED(len);
    DebugBreak();
    return(0);
}

#endif /* ndef PROD */

#endif /* YODA */

/* This stub exported as called from main() */
void    host_set_yoda_ints()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\host\src\nt_wcom.c ===
#include <windows.h>
#include <conapi.h>
#include "ptypes32.h"
#include "insignia.h"
#include "host_def.h"

/*
 *	Author : D.A.Bartlett
 *	Purpose:
 *
 *
 *	    Handle UART I/O's under windows
 *
 *
 *
 */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Include files */

#include "xt.h"
#include "rs232.h"
#include "error.h"
#include "config.h"
#include "host_com.h"
#include "host_trc.h"
#include "host_rrr.h"
#include "debug.h"
#include "idetect.h"
#include "nt_com.h"
#include "nt_graph.h"
#include "nt_uis.h"

#include <stdlib.h>
#include <string.h>
#include <stdio.h>


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::: Global Data */
GCHfn GetCommHandle;
GCSfn GetCommShadowMSR;


/*::::::::::::::::::::::::::::::::::::::::::::: Internal function protocols */

#ifndef NEC_98
#ifndef PROD
void DisplayPortAccessError(int PortOffset, BOOL ReadAccess, BOOL PortOpen);
#endif

BOOL SetupBaudRate(HANDLE FileHandle, DIVISOR_LATCH divisor_latch);
BOOL SetupLCRData(HANDLE FileHandle, LINE_CONTROL_REG LCR_reg);
#endif // NEC_98
BOOL SyncLineSettings(HANDLE FileHandle, DCB *pdcb,
		      DIVISOR_LATCH *divisor_latch,
		      LINE_CONTROL_REG *LCR_reg);

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: IMPORTS */


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: UART state */

#if defined(NEC_98)         
static struct ADAPTER_STATE
{
        BUFFER_REG      tx_buffer;
        BUFFER_REG      rx_buffer;
        DIVISOR_LATCH   divisor_latch;
        COMMAND8251     command_write_reg;
        MODE8251        mode_set_reg;
        MASK8251        int_mask_reg;
        STATUS8251      read_status_reg;
        SIGNAL8251      read_signal_reg;
        TIMER_MODE      timer_mode_set_reg;

} adapter_state[3];
#else  // NEC_98
static struct ADAPTER_STATE
{
	DIVISOR_LATCH divisor_latch;
        INT_ENABLE_REG int_enable_reg;
        INT_ID_REG int_id_reg;
        LINE_CONTROL_REG line_control_reg;
        MODEM_CONTROL_REG modem_control_reg;
        LINE_STATUS_REG line_status_reg;
        MODEM_STATUS_REG modem_status_reg;
        half_word scratch;      /* scratch register */

} adapter_state[NUM_SERIAL_PORTS];
#endif // NEC_98

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::: WOW inb function */

#if defined(NEC_98)         
void wow_com_inb(io_addr port, half_word *value)
{
    int adapter = adapter_for_port(port);
    struct ADAPTER_STATE *asp = &adapter_state[adapter];
    BOOL Invalid_port_access = FALSE;
    HANDLE FileH;
    half_word newMSR; //ADD 93.10.14

    /*........................................... Communications port open ? */

   if (GetCommHandle == NULL) {
        com_inb(port,value);
        return;
    }

   FileH = (HANDLE)(*GetCommHandle)((WORD)adapter);

    /*.................................................... Process port read */

    switch(port)
    {
        //Process read to RX register
        case RS232_CH1_TX_RX:   // CH.1 DATA READ
        case RS232_CH2_TX_RX:   // CH.2 DATA READ
        case RS232_CH3_TX_RX:   // CH.3 DATA READ
            Invalid_port_access = TRUE;
            break;

        //Process read to STATUS register
        case RS232_CH1_STATUS:  // CH.1 READ STATUS
        case RS232_CH2_STATUS:  // CH.2 READ STATUS
        case RS232_CH3_STATUS:  // CH.3 READ STATUS

            *value = (((half_word) (*GetCommShadowMSR)((WORD)adapter) & 0x20) << 2 ) + 5 ;
// CATION !!!

            break;

        //Process read to MASK register (CH.1 only)
        case RS232_CH1_MASK:    // CH.1 READ MASK (CH.1 ONLY)
            Invalid_port_access = TRUE;
            break;

        //Process read to SIGNAL register
        case RS232_CH1_SIG:             // CH.1 READ SIGNAL
        case RS232_CH2_SIG:             // CH.2 READ SIGNAL
        case RS232_CH3_SIG:             // CH.3 READ SIGNAL

            //*value = ((half_word) (*GetCommShadowMSR)((WORD)adapter) & 0xc0) + 
            //        (((half_word) (*GetCommShadowMSR)((WORD)adapter) & 0x10) << 1);
            newMSR = ~(half_word) (*GetCommShadowMSR)((WORD)adapter);
            *value = (((newMSR & 0x80) >> 2)    
                     |((newMSR & 0x10) << 2)    
                     |((newMSR & 0x40) << 1));  // ADD 93.10.14
// CATION !!!

            break;
    }

    /*.......................................... Handle invalid port accesses */
}
#else // NEC_98
void wow_com_inb(io_addr port, half_word *value)
{
    int adapter = adapter_for_port(port);
    struct ADAPTER_STATE *asp = &adapter_state[adapter];
    BOOL Invalid_port_access = FALSE;
    HANDLE FileH;


    /*........................................... Communications port open ? */

   if (GetCommHandle == NULL) {
        com_inb(port,value);
        return;
    }

   FileH = (HANDLE)(*GetCommHandle)((WORD)adapter);
#ifndef PROD
    if( FileH== NULL)
        DisplayPortAccessError(port & 0x7, TRUE, FALSE);
#endif

    /*.................................................... Process port read */

    switch(port & 0x7)
    {
	//Process read to RX register
	case RS232_TX_RX:

	    if(asp->line_control_reg.bits.DLAB == 0)
		Invalid_port_access = TRUE;
	    else
	    {
		if(SyncLineSettings(FileH,NULL,&asp->divisor_latch,&asp->line_control_reg))
		    *value = (half_word) asp->divisor_latch.byte.LSByte;
		else
		    Invalid_port_access = TRUE;
	    }
	    break;


	//Process IER read
	case RS232_IER:

	    if(asp->line_control_reg.bits.DLAB == 0)
		Invalid_port_access = TRUE;
	    else
	    {
		if(SyncLineSettings(FileH,NULL,&asp->divisor_latch,&asp->line_control_reg))
		    *value = (half_word) asp->divisor_latch.byte.MSByte;
		else
		    Invalid_port_access = TRUE;
	    }
	    break;


	//Process IIR, LSR and MCR reads
	case RS232_IIR:
	case RS232_LSR:
	case RS232_MCR:

	    Invalid_port_access = TRUE;
	    break;

	case RS232_LCR:

	    if(SyncLineSettings(FileH,NULL,&asp->divisor_latch,&asp->line_control_reg))
		*value = asp->line_control_reg.all;
	    else
		Invalid_port_access = TRUE;

	    break;

	//Process MSR read
	case RS232_MSR:

            *value = (half_word) (*GetCommShadowMSR)((WORD)adapter);
	    break;

	// Process access to Scratch register
	case RS232_SCRATCH:
	    *value = asp->scratch;
	    break;
    }

    /*.......................................... Handle invalid port accesses */

#ifndef PROD
    if(Invalid_port_access)
        DisplayPortAccessError(port & 0x7, TRUE, TRUE);
#endif


}
#endif // NEC_98

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::: WOW outb function */

#if defined(NEC_98)         
void wow_com_outb(io_addr port, half_word value)
{
    int adapter = adapter_for_port(port);
    struct ADAPTER_STATE *asp = &adapter_state[adapter];
    BOOL Invalid_port_access = FALSE;
    LINE_CONTROL_REG newLCR;
    HANDLE FileH;

    /*........................................... Communications port open ? */

    if (GetCommHandle == NULL) {
        com_outb(port,value);
        return;
    }

    FileH = (HANDLE)(*GetCommHandle)((WORD)adapter);

    /*.................................................... Process port write */

    switch(port)
    {
        //Process write to TX register
        case RS232_CH1_TX_RX:   // CH.1 DATA WRITE
        case RS232_CH2_TX_RX:   // CH.2 DATA WRITE
        case RS232_CH3_TX_RX:   // CH.3 DATA WRITE
            Invalid_port_access = TRUE;
            break;

        //Process write to COMMAND/MODE register
        case RS232_CH1_CMD_MODE:        // CH.1 WRITE COMMAND/MODE
        case RS232_CH2_CMD_MODE:        // CH.2 WRITE COMMAND/MODE
        case RS232_CH3_CMD_MODE:        // CH.3 WRITE COMMAND/MODE

// CATION !!!

            break;

        //Process write to MASK register
        case RS232_CH1_MASK:            // CH.1 SET MASK
        case RS232_CH2_MASK:            // CH.2 SET MASK
        case RS232_CH3_MASK:            // CH.3 SET MASK
            Invalid_port_access = TRUE;
            break;
        //Process write to MASK(bit set) register (CH.1 only)
        case 0x37:                                      // CH.1 SET MASK
            Invalid_port_access = TRUE;
            break;
    }

    /*.......................................... Handle invalid port accesses */

}
#else  // NEC_98
void wow_com_outb(io_addr port, half_word value)
{
    int adapter = adapter_for_port(port);
    struct ADAPTER_STATE *asp = &adapter_state[adapter];
    BOOL Invalid_port_access = FALSE;
    LINE_CONTROL_REG newLCR;
    HANDLE FileH;

    /*........................................... Communications port open ? */

    if (GetCommHandle == NULL) {
        com_outb(port,value);
        return;
    }

    FileH = (HANDLE)(*GetCommHandle)((WORD)adapter);
#ifndef PROD
    if(FileH == NULL)
        DisplayPortAccessError(port & 0x7, FALSE, FALSE);
#endif

    /*.................................................... Process port write */

    switch(port & 0x7)
    {
	//Process write to TX register
	case RS232_TX_RX:

	    if(asp->line_control_reg.bits.DLAB == 0)
		Invalid_port_access = TRUE;
	    else
		asp->divisor_latch.byte.LSByte= value;

	    break;

	//Process write to IER register
	case RS232_IER:

	    if(asp->line_control_reg.bits.DLAB == 0)
		Invalid_port_access = TRUE;
	    else
		asp->divisor_latch.byte.MSByte = value;

	    break;

	//Proces write to IIR, MCR, LSR amd MSR

	case RS232_IIR:
	case RS232_MCR:
	case RS232_LSR:
	case RS232_MSR:

	    Invalid_port_access = TRUE;
	    break;

	case RS232_LCR:

	    newLCR.all = value;
	    if(asp->line_control_reg.bits.DLAB == 1 && newLCR.bits.DLAB == 0)
	    {
		if(!SetupBaudRate(FileH,asp->divisor_latch))
		    Invalid_port_access = TRUE;
	    }

	    if(!Invalid_port_access && !SetupLCRData(FileH,newLCR))
		Invalid_port_access = TRUE;

	    asp->line_control_reg.all = newLCR.all;
	    break;

	//Scratch register write

	case RS232_SCRATCH:
	    asp->scratch = value;
	    break;
    }

    /*.......................................... Handle invalid port accesses */

#ifndef PROD
    if(Invalid_port_access)
        DisplayPortAccessError(port & 0x7, FALSE, TRUE);
#endif

}
#endif // NEC_98


/*:::::::::::::::: Synchronise Baud/Parity/Stop bits/Data bits with real UART */

BOOL SyncLineSettings(HANDLE FileHandle,
		      DCB *pdcb,
		      DIVISOR_LATCH *divisor_latch,
		      LINE_CONTROL_REG *LCR_reg )
{
    DCB dcb;	      //State of real UART
    register DCB *dcb_ptr;


    //Get current state of the real UART

    if(pdcb == NULL && !GetCommState(FileHandle, &dcb))
    {
	always_trace0("ntvdm : GetCommState failed on open\n");
	return(FALSE);
    }

    dcb_ptr = pdcb ? pdcb : &dcb;

#if defined(NEC_98)         
    // Convert BAUD rate to divisor latch setting
    divisor_latch->all = (unsigned short)(153600/dcb_ptr->BaudRate);
#else  // NEC_98
    // Convert BAUD rate to divisor latch setting
    divisor_latch->all = (unsigned short)(115200/dcb_ptr->BaudRate);
#endif // NEC_98

    //Setup parity value
    LCR_reg->bits.parity_enabled = PARITYENABLE_ON;       //Default parity on

    switch(dcb_ptr->Parity)
    {
	case EVENPARITY :
            LCR_reg->bits.even_parity = EVENPARITY_EVEN;
	    break;

	case NOPARITY :
            LCR_reg->bits.parity_enabled = PARITYENABLE_OFF;
	    break;

	case ODDPARITY :
            LCR_reg->bits.even_parity = EVENPARITY_ODD;
	    break;

	case SPACEPARITY:
	    LCR_reg->bits.stick_parity = PARITY_STICK;
            LCR_reg->bits.even_parity = EVENPARITY_EVEN;
	    break;

	case MARKPARITY :
	    LCR_reg->bits.stick_parity = PARITY_STICK;
            LCR_reg->bits.even_parity = EVENPARITY_ODD;
	    break;
    }

    //Setup stop bits
    LCR_reg->bits.no_of_stop_bits = dcb_ptr->StopBits == ONESTOPBIT ? 0 : 1;

    //Setup data byte size
    LCR_reg->bits.word_length = dcb_ptr->ByteSize-5;

    return(TRUE);
}


#ifndef NEC_98
/*::::::::::::::::::::::::::::::::::::::::::::::::::: Setup Line control data */

BOOL SetupLCRData(HANDLE FileHandle, LINE_CONTROL_REG LCR_reg)
{
    DCB dcb;		//State of real UART

    //Get current state of the real UART

    if(!GetCommState(FileHandle, &dcb))
    {
	always_trace0("ntvdm : GetCommState failed on open\n");
	return(FALSE);
    }

    //Setup data bits
    dcb.ByteSize = LCR_reg.bits.word_length+5;

    //Setup stop bits
    if(LCR_reg.bits.no_of_stop_bits == 0)
	dcb.StopBits = LCR_reg.bits.word_length == 0 ? ONE5STOPBITS:TWOSTOPBITS;
    else
	dcb.StopBits = ONESTOPBIT;

    //Setup parity
    if(LCR_reg.bits.parity_enabled == PARITYENABLE_ON)
    {
	if(LCR_reg.bits.stick_parity == PARITY_STICK)
	{
            dcb.Parity = LCR_reg.bits.even_parity == EVENPARITY_ODD ?
			 MARKPARITY : SPACEPARITY;

	}
	else
	{
            dcb.Parity = LCR_reg.bits.even_parity == EVENPARITY_ODD ?
		       ODDPARITY :EVENPARITY;
	}
    }
    else
	dcb.Parity = NOPARITY;

    //Sent the new line setting values to the serial driver
    if(!SetCommState(FileHandle, &dcb))
    {
	always_trace0("ntvdm : GetCommState failed on open\n");
	return(FALSE);
    }

    return(TRUE);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::: Set up the baud rate */

BOOL SetupBaudRate(HANDLE FileHandle, DIVISOR_LATCH divisor_latch)
{
    DCB dcb;

    //Setup the baud rate

    if(!GetCommState(FileHandle, &dcb))
    {
	always_trace0("ntvdm : GetCommState failed on open\n");
	return(FALSE);
    }

    dcb.BaudRate = divisor_latch.all ? 115200/divisor_latch.all : 115200;

    if(!SetCommState(FileHandle, &dcb))
    {
	always_trace0("ntvdm : GetCommState failed on open\n");
	return(FALSE);
    }

    return(TRUE);
}


/*::::::::::::::::::::::::::::::::::::::::::::::::: Display port access error */


#ifndef PROD
/*
 *  user warnings are not needed here, return errors and let the
 *  app handle it. message boxes are also not permitted, because
 *  it can kill WOW. 20-Feb-1993 Jonle
 */
void DisplayPortAccessError(int PortOffset, BOOL ReadAccess, BOOL PortOpen)
{
    static char *PortInError;
    static char ErrorMessage[250];
    int rtn;

    // Identify port in error

    switch(PortOffset)
    {
	case RS232_TX_RX:   PortInError = ReadAccess ? "RX" : "TX" ; break;
	case RS232_IER:     PortInError = "IER" ; break;
	case RS232_IIR:     PortInError = "IIR" ; break;
	case RS232_MCR:     PortInError = "MCR" ; break;
	case RS232_LSR:     PortInError = "LSR" ; break;
	case RS232_MSR:     PortInError = "MSR" ; break;
	case RS232_LCR:     PortInError = "LCR" ; break;
	case RS232_SCRATCH: PortInError = "Scratch" ; break;
	default:	    PortInError = "Unidentified"; break;
    }

    //Construct Error message

    sprintf(ErrorMessage, "The Application attempted to %s the %s register",
	    ReadAccess ? "read" : "write", PortInError);

    if(!PortOpen)
	strcat(ErrorMessage,", however the comm port has not yet been opened");

    //Display message box
    printf("WOW Communication Port Access Error\n%s\n",ErrorMessage);
}
#endif
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\host\src\stf_conf.c ===
/*
 * SoftPC Revision 3.0
 *
 *
 * Title        : Host dependent configuration panel functions
 *
 *
 * Description  : This module forms the host dependant side of the softpc
 *                configuration system. 
 *
 *
 * Author	: Wilf Stubs
 *
 *
 * Notes        : 
 *
 */
#include "insignia.h"
#include "host_dfs.h"

#include <stdio.h>
#include <string.h>

#include "xt.h"
#include "error.h"
#include "gfi.h"
#include "gmi.h"
#include "gfx_updt.h"
#include "config.h"
#include "rs232.h"
#include "host_lpt.h"
#include "host_cpu.h"
#include "host_com.h"
#include "nt_confg.h"

/*********** Private definitions ***********************/

/*
 * Validation routines
 */

static short validate_c_drive();
static short validate_d_drive();
static short validate_com1();
static short validate_com2();
static short validate_lpt1();
static short validate_lpt2();
#if (NUM_PARALLEL_PORTS>2)
static short validate_lpt3();
#endif
static short validate_item();
static short no_validation();

/*
 * Change action routines
 */

static short c_drive_change_action();
static short d_drive_change_action();
static short no_change_action();
static short lpt1_change_action();
static short lpt2_change_action();
#if (NUM_PARALLEL_PORTS>2)
static short lpt3_change_action();
#endif
static short com1_change_action();
static short com2_change_action();
boolean pc_initiated=FALSE;
char *pc_uif_text;

boolean use_comments = TRUE;  /* Set to true if commenting required. */

#define defaults_filename "SoftPC.rez"

static char *ends[] =
{
	"st","nd","rd","th"
};

/* Table definitions for options that take one of n 'value' strings. 
 * The table is used to look up the string and find what it means
 * to the host in this option. 
 *  Look at the tables for more explanation, they're fairly self-explanatory.
 */
name_table bool_values[] =
{
 {	"yes", TRUE },
 {	"Yes", TRUE },
 {	"YES", TRUE },
 {	"no",  FALSE },
 {	"No",  FALSE },
 {	"NO",  FALSE },
 {	NULL,  0 }
};

name_table gfx_adapter_types[] =
{
    {	"HERCULES",  HERCULES },
    {	"CGA",	     CGA },
    {	"EGA",	     EGA },
    {	"VGA",	     VGA },
    {	NULL,	     0 }
};

/* The BIG one! This is a decription of each option that the config struct
 * must have, and its requirements. Used by config for all sorts of things.
 *  For a fuller explanation look in the document:
 *           'Design Proposal for the New Config System'.
 */

option_description narrative[] =
{
	{                  /*    FOR EACH OPTION... */
		"HARD_DISK_FILENAME",		/* Name */
		C_HARD_DISK1_NAME,		/* Host name for option */
		C_STRING_RECORD,		/* Option (base) primitive type */
		C_HARD_DISKS,			/* Host option commonality type */
		FALSE,				/* Option is READ_ONLY if TRUE */
		null_table,			/* Pointer to table (null if not needed) */
		TRUE,				/* TRUE if default present, FALSE if not */
		"/usr/lib/SoftPC/hard_disk",	/* Default value as a string as if in resource file */
		TRUE,				/* TRUE if changing the option requires SoftPC reset */
		TRUE,				/* TRUE if option may be setup via the UIF */
		DISK_CONFIG,			/* Panel 'type' if you have different panels */
		validate_c_drive,		/* validation function */
		c_drive_change_action		/* function to do changing actions */
	},
	{
		"HARD_DISK_FILENAME2",
		C_HARD_DISK2_NAME,
		C_STRING_RECORD,
		C_HARD_DISKS,
		FALSE,
		null_table,
		TRUE,
		"",
		TRUE,
		TRUE,
		DISK_CONFIG,
		validate_d_drive,
		d_drive_change_action
	},
	{
		"COM_PORT_1",
		C_COM1_NAME,
		C_STRING_RECORD,
		C_SINGULARITY,
		FALSE,
		null_table,
		TRUE,
		"",
		FALSE,
		FALSE,
		COMMS_CONFIG,
		validate_com1,
		com1_change_action
	},
	{
		"COM_PORT_2",
		C_COM2_NAME,
		C_STRING_RECORD,
		C_SINGULARITY,
		FALSE,
		null_table,
		TRUE,
		"",
		FALSE,
		FALSE,
		COMMS_CONFIG,
		validate_com2,
		com2_change_action
	},
	{
		"LPT_PORT_1",
		C_LPT1_NAME,
		C_STRING_RECORD,
		C_SINGULARITY,
		FALSE,
		null_table,
		TRUE,
		"",
		FALSE,
		FALSE,
		COMMS_CONFIG,
		validate_lpt1,
		lpt1_change_action
	},
	{
		"LPT_PORT_2",
		C_LPT2_NAME,
		C_STRING_RECORD,
		C_SINGULARITY,
		FALSE,
		null_table,
		TRUE,
		"",
		FALSE,
		FALSE,
		COMMS_CONFIG,
		validate_lpt2,
		lpt2_change_action
	},
	{
		"GRAPHICS_ADAPTOR",
		C_GFX_ADAPTER,
		C_NAME_RECORD,
		C_SINGULARITY,
		FALSE,
		gfx_adapter_types,
		TRUE,
		"VGA",
		TRUE,
		TRUE,
		DISPLAY_CONFIG,
		validate_item,
		no_change_action
	},
	{
		NULL,
		0,
		0,
		C_SINGULARITY,
		FALSE,
		null_table,
		FALSE,
		NULL,
		FALSE,
		FALSE,
		NON_CONFIG,
		no_validation,
		no_change_action
	}
};

/* Runtime variables */

struct
{
		boolean mouse_attached;
		boolean config_verbose;
		boolean npx_enabled;
		boolean sound_on;
		boolean com_flow_control[2];
		int floppy_state[2];
		int floppy_active_state[2];
		int floppy_capacity[2];
		int hd_cyls[2];
		boolean lptflush1;
		boolean lptflush2;
		boolean lptflush3;
		int	flushtime1;
		int	flushtime2;
		int	flushtime3;
} runtime_status;

#define NUM_OPTS ( sizeof(narrative) / sizeof( option_description) )

/*********** Imported and exported items *************/

extern char *getenv();
extern char *malloc();

/*************** Local Declarations *****************/

void host_config_error();
static char buff[MAXPATHLEN];
static char buff1[MAXPATHLEN];
boolean item_in_table();
static char home_resource[MAXPATHLEN];
static char sys_resource[MAXPATHLEN];

/*********************************************************/

short host_runtime_inquire(what)
int what;

{
      switch(what)
		{
		case C_MOUSE_ATTACHED:
			return( runtime_status.mouse_attached );
			break;

		case C_CONFIG_VERBOSE:
			return( runtime_status.config_verbose );
			break;

		case C_NPX_ENABLED:
			return( runtime_status.npx_enabled );
			break;

		case C_HD1_CYLS:
			return( runtime_status.hd_cyls[0] );
			break;

		case C_HD2_CYLS:
			return( runtime_status.hd_cyls[1] );
			break;

		case C_FLOPPY1_STATE:
			return( runtime_status.floppy_state[0] );
			break;

		case C_FLOPPY2_STATE:
			return( runtime_status.floppy_state[1] );
			break;

		case C_FLOPPY1_ACTIVE_STATE:
			return( runtime_status.floppy_active_state[0] );
			break;

		case C_FLOPPY2_ACTIVE_STATE:
			return( runtime_status.floppy_active_state[1] );
			break;

		case C_FLOPPY1_CAPACITY:
			return( runtime_status.floppy_capacity[0] );
			break;

		case C_FLOPPY_TYPE_CHANGED:
			return( runtime_status.floppy_type_changed );
			break;

		case C_FLOPPY2_CAPACITY:
			return( runtime_status.floppy_capacity[1] );
			break;

		case C_SOUND_ON:
			return( runtime_status.sound_on );
			break;

		case C_REAL_FLOPPY_ALLOC:
			return( runtime_status.floppy_state[0] == GFI_REAL_DISKETTE_SERVER ||
					runtime_status.floppy_state[1] == GFI_REAL_DISKETTE_SERVER );
			break;

		case C_REAL_OR_SLAVE:
			return( runtime_status.floppy_A_real );
			break;

		case C_SLAVE_FLOPPY_ALLOC:
			return( runtime_status.floppy_state[0] == GFI_SLAVE_SERVER );
			break;

		case C_COM1_FLOW:
			return( runtime_status.com_flow_control[0] );
			break;

		case C_COM2_FLOW:
			return( runtime_status.com_flow_control[1] );
			break;

		case C_COM3_FLOW:
			return( FALSE );
			break;

		case C_COM4_FLOW:
			return( FALSE );
			break;

		case C_LPTFLUSH1:
			return( runtime_status.lptflush1 );
			break;

		case C_LPTFLUSH2:
			return( runtime_status.lptflush2 );
			break;

		case C_LPTFLUSH3:
			return( runtime_status.lptflush3 );
			break;

		case C_FLUSHTIME1:
			return( runtime_status.flushtime1 );
			break;

		case C_FLUSHTIME2:
			return( runtime_status.flushtime2 );
			break;

		case C_FLUSHTIME3:
			return( runtime_status.flushtime3 );
			break;

		default:
			host_error(EG_OWNUP, ERR_QUIT, "host_runtime_inquire");
		}
}

void host_runtime_set(what,value)
int what;
int value;
{
       switch(what)
		{
		case C_MOUSE_ATTACHED:
			runtime_status.mouse_attached = value;
			break;

		case C_CONFIG_VERBOSE:
			runtime_status.config_verbose = value;
			break;

		case C_NPX_ENABLED:
			runtime_status.npx_enabled = value;
			break;

		case C_HD1_CYLS:
			runtime_status.hd_cyls[0] = value;
			break;

		case C_HD2_CYLS:
			runtime_status.hd_cyls[1] = value;
			break;

		case C_FLOPPY1_STATE:
			runtime_status.floppy_state[0] = value;
			break;

		case C_FLOPPY2_STATE:
			runtime_status.floppy_state[1] = value;
			break;

		case C_FLOPPY1_ACTIVE_STATE:
			runtime_status.floppy_active_state[0] = value;
			break;

		case C_FLOPPY2_ACTIVE_STATE:
			runtime_status.floppy_active_state[1] = value;
			break;

		case C_FLOPPY1_CAPACITY:
			runtime_status.floppy_capacity[0] = value;
			break;

		case C_FLOPPY2_CAPACITY:
			runtime_status.floppy_capacity[1] = value;
			break;

		case C_FLOPPY_TYPE_CHANGED:
			runtime_status.floppy_type_changed = value;
			break;

		case C_SOUND_ON:
			runtime_status.sound_on = value;
			break;

		case C_REAL_OR_SLAVE:
			runtime_status.floppy_A_real = value;
			break;

		case C_COM1_FLOW:
			runtime_status.com_flow_control[0] = value;
			break;

		case C_COM2_FLOW:
			runtime_status.com_flow_control[1] = value;
			break;

		case C_COM3_FLOW:
		case C_COM4_FLOW:
			break;

		case C_LPTFLUSH1:
			runtime_status.lptflush1 =value;
			break;

		case C_LPTFLUSH2:
			runtime_status.lptflush2 =value;
			break;

		case C_LPTFLUSH3:
			runtime_status.lptflush3 =value;
			break;

		case C_FLUSHTIME1:
			runtime_status.flushtime1 =value;
			break;

		case C_FLUSHTIME2:
			runtime_status.flushtime2 =value;
			break;

		case C_FLUSHTIME3:
			runtime_status.flushtime3 =value;
			break;

		default:
			host_error(EG_OWNUP, ERR_QUIT, "host_runtime_set");
		}
}

void host_runtime_init()
{
    config_values var;

#ifdef NPX
		host_runtime_set(C_NPX_ENABLED,TRUE);
#else
		host_runtime_set(C_NPX_ENABLED,FALSE);
#endif

#ifndef PROD
		printf("NPX is %s\n",host_runtime_inquire(C_NPX_ENABLED)? "on.":"off.");
#endif
		host_runtime_set(C_FLUSHTIME1, 5);
		host_runtime_set(C_FLUSHTIME2, 10);
		host_runtime_set(C_FLUSHTIME3, 15);
		host_runtime_set(C_MOUSE_ATTACHED,FALSE);
		host_runtime_set(C_CONFIG_VERBOSE,TRUE);
		host_runtime_set(C_SOUND_ON,FALSE);
		host_runtime_set(C_FLOPPY1_STATE,GFI_EMPTY_SERVER);
		host_runtime_set(C_FLOPPY2_STATE,GFI_EMPTY_SERVER);
		host_runtime_set(C_FLOPPY1_ACTIVE_STATE,GFI_EMPTY_SERVER);
		host_runtime_set(C_FLOPPY2_ACTIVE_STATE,GFI_EMPTY_SERVER);
		host_runtime_set(C_REAL_OR_SLAVE,FALSE);
		host_runtime_set(C_FLOPPY_TYPE_CHANGED,FALSE);
}

/*
 *  General host initialisation function. It is called only once on startup
 * from 'config()'. It does the following (at the moment):
 *
 * 1)  Makes the 'option' field of the 'config_info' struct pointed to by 'head' *    point to all the option 'rules' - that is the 'narrative' structure
 *    initialised at the start of this file.
 *
 * 2)  Counts up the option rules in 'narrative' and stores the result in the
 *    'config_info' struct.
 *
 * 3)  Return the minimum padding length necessary.
 *
 * 4)  Derive the two path:filenames for the resource file. This file may be
 *    in the user's $HOME directory or in softpc's ROOT directory. Making up
 *    these strings now saves doing it every time 'config_store()' is called.
 */

void host_get_config_info(head)
config_description *head;
{

    char *pp, *getenv();
    option_description *option_p = narrative;

    head->option = narrative;	     /* Attach 'narrative' */
    head->option_count = NUM_OPTS - 1;
    head->min_pad_len = MIN_OPTION_ARG_DIST;

        /*
	* get system resource file from standard place
	*/
	strcpy(sys_resource, ROOT);

	strcat(sys_resource, PATH_SEPARATOR);
	strcat(sys_resource, RESOURCE_FILENAME);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::: Try and load database files ::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

static boolean try_load_database()
{
    FILE *infile = NULL;
    char in_line[MAXPATHLEN];
    char *cp;
    char *home, *getenv();

    /* Keep this the same as system for the moment	*/

   sprintf(home_resource,"%s%s%s",ROOT,PATH_SEPARATOR,RESOURCE_FILENAME);

    /*....................................... Attempt to open resource file */

    if((infile = fopen(home_resource, "r")) == NULL)
	return(FALSE);

    /*.................................................. Read resource file */

    while (fgets(in_line, MAXPATHLEN, infile) != NULL)
    {
	/*........................................ strip control characters */

	for(cp = in_line; *cp ; cp++) if(*cp < ' ') *cp = ' ';

	add_resource_node(in_line);
    }

    /*............................. Close resource file and get out of here */

    fclose(infile);
    return TRUE;
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::: Try to load system files ::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

static boolean try_load_sys_file()
{
    FILE *infile = NULL;
    char in_line[MAXPATHLEN];
    register char *cp;

    /*................................ Attempt to open system resource file */

    if((infile = fopen(sys_resource, "r")) == NULL)
	return(FALSE);

    /*................................................. read resource file */

    while (fgets(in_line, MAXPATHLEN, infile) != NULL)
    {
       /*......................................... strip control characters */

	for(cp = in_line; *cp ; cp++)
	    if(*cp < ' ') *cp = ' ';

	add_resource_node(in_line);
    }

    /*........................................ close resource file and exit */

    fclose(infile);
    return(TRUE);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::: Read resource file ::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

short host_read_resource_file(resource_data *resource)
{
    boolean bad_home=FALSE, bad_sys=FALSE;

    /* Try open users default database failing that, open the system file. */

    if(bad_home = !try_load_database())
	bad_sys = !try_load_sys_file();

    if(bad_home && bad_sys) return(EG_ALL_RESOURCE_BAD_R);

    return(bad_home ? EG_BAD_LOCAL_RESOURCE_R : C_CONFIG_OP_OK);
}

short host_write_resource_file(resource)
resource_data *resource;
{

FILE *outfile;
line_node *node;
boolean bad_home=TRUE, bad_sys=FALSE;

 /* Try to open (for writing) a resource file in the users home directory or
	 failing that, the system one. These two paths are set up once at runtime. */

 if(home_resource[0] != '\0')
		if((outfile = fopen(home_resource, "w")) != NULL)
			bad_home = FALSE;

	if(bad_home)
		if((outfile = fopen(sys_resource, "w")) == NULL)
			bad_sys = TRUE;

	if(bad_home && !bad_sys)
		return EG_ALL_RESOURCE_BAD_W;

	else 
		if(bad_home && bad_sys)
			return EG_ALL_RESOURCE_BAD_W;

	node = resource->first;
	while(node != NULL)
	{
		fputs(node->line,outfile);    
		fputc('\n',outfile);
		node = node->next;
	}
	fclose(outfile);
	return(C_CONFIG_OP_OK);

}


/* A host specific extension to config_inquire() to deal with any inquiries 
	that the base config code doesn't or shouldn't know about.                */


void host_inquire_extn(sort,identity,values)
short sort;
int identity;
config_values *values;
{
}

static char error_text[300];
static int error_locus;

host_error_query_locus(locus,text)
int *locus;
char **text;
{
        *locus = error_locus;
	*text = error_text;
}

host_error_set_locus(text, locus)
char *text;
int locus;
{
        strcpy(error_text, text);
	error_locus = locus;
}

static short no_validation(value, table, buf)
config_values *value;
name_table table[];
char	*buf;
{
	return(C_CONFIG_OP_OK);
}

static short validate_c_drive(value, table, buf)
config_values *value;
name_table table[];
char	*buf;
{
/* cheat on validation for moment as this will disapear */
	return(C_CONFIG_OP_OK);
}

static short validate_d_drive(value, table, buf)
config_values *value;
name_table table[];
char	*buf;
{
/* cheat on validation for moment as this will disapear */
	return(C_CONFIG_OP_OK);
}

static short validate_com1(value, table, buf)
config_values *value;
name_table table[];
char	*buf;
{
/* cheat on validation for moment as this will change	*/
	return(C_CONFIG_OP_OK);
}

static short validate_com2(value, table, buf)
config_values *value;
name_table table[];
char	*buf;
{
/* cheat on validation for moment as this will change	*/
	return(C_CONFIG_OP_OK);
}

static short validate_lpt1(value, table, buf)
config_values *value;
name_table table[];
char	*buf;
{
/* cheat on validation for moment as this will change	*/
	return(C_CONFIG_OP_OK);
}

static short validate_lpt2(value, table, buf)
config_values *value;
name_table table[];
char	*buf;
{
/* cheat on validation for moment as this will change	*/
	return(C_CONFIG_OP_OK);
}

static short validate_item(value, table, buf)
config_values *value;
name_table table[];
char	*buf;
{
/* cheat on validation - no table lookup	*/
	return(C_CONFIG_OP_OK);
}

boolean item_in_table(val,table)
int val;
name_table table[];
{
	int n=0;
	while(table[n].string != NULL)
		if(table[n].value == val)
			break;
		else 
			n++;
	return( table[n].string == NULL? FALSE : TRUE);
}

static short no_change_action( value, buf)
config_values	*value;
char			*buf;
{
	return( C_CONFIG_OP_OK );
}

static short c_drive_change_action( value, buf)
config_values	*value;
char			*buf;
{
	short	err;

	fdisk_iodetach ();
	fdisk_physdetach(0);

    if (err = fdisk_physattach( 0, value->string))
		strcpy(buf, narrative[C_HARD_DISK1_NAME].option_name);

	fdisk_ioattach ();	

	return (err);

}

static short d_drive_change_action( value, buf)
config_values	*value;
char			*buf;
{
	short	err;

	fdisk_iodetach ();
	fdisk_physdetach(1);

    if (err = fdisk_physattach( 1, value->string))
		strcpy(buf, narrative[C_HARD_DISK2_NAME].option_name);

	fdisk_ioattach ();	

	return (err);
}

static short lpt1_change_action( value, buf)
config_values	*value;
char			*buf;
{
#ifdef STUBBED
        	host_lpt_close(0);
	return (host_lpt_open(0, value->string, buf));
#endif /*STUBBED*/
/* cheat on validation for moment as this will change	*/
	return(C_CONFIG_OP_OK);
}

static short lpt2_change_action( value, buf)
config_values	*value;
char			*buf;
{
#ifdef STUBBED
        	host_lpt_close(1);
	return (host_lpt_open(1, value->string, buf));
#endif /*STUBBED*/
/* cheat on validation for moment as this will change	*/
	return(C_CONFIG_OP_OK);
}

static short com1_change_action( value, buf)
config_values	*value;
char			*buf;
{
#ifdef STUBBED
	host_com_close(0);
	return (host_com_open(0, value->string, buf));
#endif /*STUBBED*/
/* cheat on validation for moment as this will change	*/
	return(C_CONFIG_OP_OK);
}

static short com2_change_action( value, buf)
config_values	*value;
char			*buf;
{
#ifdef STUBBED
        	host_com_close(1);
	return (host_com_open(1, value->string, buf));
#endif /*STUBBED*/
/* cheat on validation for moment as this will change	*/
	return(C_CONFIG_OP_OK);
}

/*********** Floppy and hard disk init ****************/

void host_floppy_startup(driveno)
int driveno;
{
    host_floppy_init(driveno, GFI_EMPTY_SERVER );
}

void host_hd_startup()
{
	int error;
	config_values disk1_name,disk2_name;

	/* Start by getting the C: drive up */

		fdisk_physdetach(0);
		config_inquire(C_INQUIRE_VALUE,C_HARD_DISK1_NAME,&disk1_name);
		error = fdisk_physattach(0,disk1_name.string);
		if(error)
		{
			host_error(error, ERR_CONFIG|ERR_QUIT, disk1_name.string);
		}

/* If that went ok, try for D: */

		config_inquire(C_INQUIRE_VALUE,C_HARD_DISK2_NAME,&disk2_name);
		if(!strcmp(disk2_name.string,""))
			return;                        /* No D: drive! */

		if(!strcmp(disk2_name.string,disk1_name.string))
			host_error(EG_SAME_HD_FILE, ERR_CONFIG|ERR_QUIT, disk2_name.string);

		error = fdisk_physattach(1,disk2_name.string);
		if(error)
			host_error(error, ERR_CONFIG|ERR_QUIT, disk2_name.string);

}

/* temp hack */
char *host_get_spc_home() { return("c:\\softpc"); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\obj.vdm\cdefine.inc ===
# Check for Checked (dev) or Free (PROD) builds.

!IF $(FREEBUILD)

SPC_VAR=-DPROD

!ELSE

!IF "$(PIG)" == ""

!IF "$(HUNTER)" == ""

SPC_VAR=

!ELSE

SPC_VAR=-DHUNTER

!ENDIF

!ELSE

SPC_VAR=-DPIG

!ENDIF

!ENDIF


SOFTPC_TREE=$(PROJECT_ROOT)\mvdm\softpc.new

# Set machine specific variables. Differences are for X86 vs. RISC

!IF $(386)

!IF "$(ALT_PROJECT)" == "NEC_98"
SPC_MC_DEF=   -DMONITOR \
              -DC_VID   \
              -DX86GFX
!ELSE

SPC_MC_DEF=   -DMONITOR \
              -DC_VID   \
              -DX86GFX  \
              -DARCX86
!ENDIF

!ELSE

# not an X86.  At this point, all RISC architectures have the same defines.

!IF "$(CCPU)" == ""
CPU_DEFS=     -DCPU_40_STYLE
!ELSE
CPU_DEFS=     -DCPU_40_STYLE  -DCCPU -DC_VID
!ENDIF

SPC_MC_DEF=   $(CPU_DEFS) \
	      -DNEW_CPU \
              -DSPC386 \
              -DSIM32 \
	      -DV7VGA




#Amend include path to include CPU build system generated files
!IF $(FREEBUILD)
CPU_INCLUDES=$(SOFTPC_TREE)\host\inc\$(PROCESSOR_ARCHITECTURE)\prod
!else
CPU_INCLUDES=$(SOFTPC_TREE)\host\inc\$(PROCESSOR_ARCHITECTURE)\pig
!endif

INCLUDES=$(CPU_INCLUDES);$(INCLUDES)

!ENDIF

C_DEFINES= $(SPC_VAR) $(SPC_MC_DEF) $(C_DEFINES) -DANSI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\host\src\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=src
TARGETPATH=obj
TARGETTYPE=LIBRARY

MVDM_TREE=$(PROJECT_ROOT)\mvdm
SOFTPC_TREE=$(MVDM_TREE)\softpc.new

INCLUDES=\
    $(SOFTPC_TREE)\host\inc;\
    $(SOFTPC_TREE)\base\inc;\
    $(MVDM_TREE)\vdd\h;\
    $(MVDM_TREE)\inc;\
    $(WINDOWS_INC_PATH)

W32_SB=1
SOURCES=\
    ..\sim32.c         \
    ..\cpucstbs.c      \
    ..\nt_timer.c      \
    ..\nt_ntfun.c      \
    ..\nt_msscs.c      \
    ..\nt_error.c      \
    ..\nt_cga.c        \
    ..\nt_ega.c        \
    ..\nt_vga.c        \
    ..\nt_input.c      \
    ..\nt_graph.c      \
    ..\nt_hosts.c      \
    ..\nt_sound.c      \
    ..\nt_bop.c        \
    ..\nt_com.c        \
    ..\nt_wcom.c       \
    ..\nt_rez.c        \
    ..\nt_sas.c        \
    ..\nt_fdisk.c      \
    ..\nt_unix.c       \
    ..\nt_keycd.c      \
    ..\nt_cpu.c        \
    ..\nt_lpt.c        \
    ..\nt_yoda.c       \
    ..\nt_mouse.c      \
    ..\nt_event.c      \
    ..\nt_munge.c      \
    ..\config.c        \
    ..\nt_nls.c        \
    ..\copy_fnc.c      \
    ..\nt_msscs.c      \
    ..\stubs.c         \
    ..\nt_pif.c        \
    ..\nt_fulsc.c      \
    ..\nt_emm.c        \
    ..\x86_emm.c       \
    ..\nt_eoi.c        \
    ..\nt_vdd.c        \
    ..\nt_sec.c        \
    ..\nt_thred.c      \
    ..\nt_det.c        \
    ..\nt_umb.c        \
    ..\fprt.c          \
    ..\nt_rflop.c      \
    ..\nt_inthk.c      \
    ..\nt_reset.c      \
    ..\nt_mem.c        \
    ..\nt_98grf.c      \
    ..\nt_cgw.c        \
    ..\nt_vsync.c      \
    ..\nt_vdm.c        \
    ..\nt_sb.c         \
    ..\nt_sbdsp.c      \
    ..\nt_sbfm.c       \
    ..\nt_sbmxr.c      \
    ..\nt_sbmid.c

ALPHA_SOURCES=..\nt_aorc.c

!INCLUDE $(SOFTPC_TREE)\obj.vdm\CDEFINE.INC

UMTYPE=console
SOURCES_USED=..\sources.inc

CONDITIONAL_INCLUDES=sas4gen.h         \
                     evidgen.h         \
                     gdpvar.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\host\src\stubs.c ===
#undef ANSI     // until file tidied or better still, lost

#include <windows.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include "host_def.h"
#include "insignia.h"
#include "xt.h"
#include "debug.h"
#include "sas.h"
#include "config.h"
#include "chkmallc.h"

#ifdef X86GFX
#include "egacpu.h"
#include "egaread.h"
#endif

#ifdef MONITOR
GLOBAL void sas_loads_to_transbuf IFN3(sys_addr, src, host_addr, dest, sys_addr, len)
{
        sas_loads (src, dest, len);
}

/* write a string into M */
GLOBAL void sas_stores_from_transbuf IFN3(sys_addr, dest, host_addr, src, sys_addr, len)
{
        sas_stores (dest, src, len);
}

GLOBAL host_addr sas_transbuf_address IFN2(sys_addr, dest_intel_addr, sys_addr, length)
{
        UNUSED (dest_intel_addr);
        return (sas_scratch_address (length));
}
#endif


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: log1p */

#ifndef MONITOR
GLOBAL double log1p(x)
double x;
{
    return log(1+x);
}

#endif /* !MONITOR */


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::: SAS wrapping stubs */

#ifdef MONITOR
GLOBAL void npx_reset()
{
    return;
}

GLOBAL void initialise_npx()
{
    return;
}

GLOBAL void sas_overwrite_memory IFN2(sys_addr, addr, int, type)
{
        UNUSED(addr);
        UNUSED(type);
}

LOCAL LONG stub_q_ev_count = 0; // holder for below

/* Monitor controlled code will call quick event code immediately so the
 * following needn't be at all accurate.
 */
void host_q_ev_set_count(value)
LONG value;
{
    stub_q_ev_count = value;
}

LONG host_q_ev_get_count()
{
    return(stub_q_ev_count);
}

int host_calc_q_ev_inst_for_time(LONG time)
{
    return(time);
}

#ifndef CPU_40_STYLE
int host_calc_q_ev_time_for_inst(LONG inst)
{
    return(inst);
}
#endif

////// The following support the major surgery to remove unneeded video stuff

GLOBAL ULONG Gdp;
GLOBAL half_word bg_col_mask = 0x70;    // usually defined in cga.c
GLOBAL READ_STATE read_state;

ULONG sr_lookup[16] =   // Handy array to extract all 4 plane values in one go
{
#ifdef LITTLEND
        0x00000000,0x000000ff,0x0000ff00,0x0000ffff,
        0x00ff0000,0x00ff00ff,0x00ffff00,0x00ffffff,
        0xff000000,0xff0000ff,0xff00ff00,0xff00ffff,
        0xffff0000,0xffff00ff,0xffffff00,0xffffffff
#endif
#ifdef BIGEND
        0x00000000,0xff000000,0x00ff0000,0xffff0000,
        0x0000ff00,0xff00ff00,0x00ffff00,0xffffff00,
        0x000000ff,0xff0000ff,0x00ff00ff,0xffff00ff,
        0x0000ffff,0xff00ffff,0x00ffffff,0xffffffff
#endif
};

GLOBAL VOID glue_b_write (UTINY *addr, ULONG val)
{
    UNUSED(addr);
    UNUSED(val);
}
GLOBAL VOID glue_w_write (UTINY *addr, ULONG val)
{
    UNUSED(addr);
    UNUSED(val);
}
GLOBAL VOID glue_b_fill (UTINY *laddr, UTINY *haddr, ULONG val)
{
    UNUSED(laddr);
    UNUSED(haddr);
    UNUSED(val);
}
GLOBAL VOID glue_w_fill (UTINY *laddr, UTINY *haddr, ULONG val)
{
    UNUSED(laddr);
    UNUSED(haddr);
    UNUSED(val);
}
GLOBAL VOID glue_b_move(UTINY *laddr, UTINY *haddr, UTINY *src, UTINY src_type )
{
    UNUSED(laddr);
    UNUSED(haddr);
    UNUSED(src);
    UNUSED(src_type);
}
GLOBAL VOID glue_w_move(UTINY *laddr, UTINY *haddr, UTINY *src )
{
    UNUSED(laddr);
    UNUSED(haddr);
    UNUSED(src);
}
GLOBAL VOID glue_b_fwd_move () { }
GLOBAL VOID glue_b_bwd_move () { }
GLOBAL VOID glue_w_fwd_move () { }
GLOBAL VOID glue_w_bwd_move () { }

GLOBAL VOID _ega_gc_outb_mask(io_addr port, half_word value)
{
    UNUSED(port);
    UNUSED(value);
}

GLOBAL VOID _ega_gc_outb_mask_ff(io_addr port, half_word value)
{
    UNUSED(port);
    UNUSED(value);
}

GLOBAL VOID cga_init()
{
}

GLOBAL VOID cga_term()
{
}

GLOBAL VOID _simple_mark_lge()
{
}

GLOBAL VOID _simple_mark_sml()
{
}

GLOBAL int get_ega_switch_setting()
{
    return(0);
}

GLOBAL VOID ega_read_init()     // Do normal inits - ports will do this fully
{
    read_state.mode = 0;
    read_state.colour_compare = 0x0f;
    read_state.colour_dont_care = 0xf;
}

GLOBAL VOID ega_read_term()
{
}

GLOBAL VOID ega_read_routines_update()
{
}

GLOBAL VOID update_shift_count()
{
}

GLOBAL VOID ega_write_init()
{
}

GLOBAL VOID ega_write_term()
{
}

GLOBAL VOID ega_write_routines_update(CHANGE_TYPE reason)
{
    UNUSED(reason);
}

GLOBAL VOID set_mark_funcs()
{
}

GLOBAL ULONG setup_global_data_ptr()
{
    return(0xDefaced);
}

#if defined(NEC_98)
GLOBAL VOID setup_NEC98_globals()
{
    check_malloc(NEC98_CPU.globals, sizeof(NEC98_GLOBALS), char);
}
#else  // !NEC_98
GLOBAL VOID setup_vga_globals()
{
    check_malloc(EGA_CPU.globals, 1, VGA_GLOBALS);
}
#endif // !NEC_98

#endif  //MONITOR





/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: ASSERT CODE */


void _assert(void *exp, void *file, unsigned line)
{
    char linestr[100];

    OutputDebugString("ASSERT FAILED - ");
    OutputDebugString(exp);
    OutputDebugString("  ");
    OutputDebugString(file);

    sprintf(linestr," (%d)\n",line);
    OutputDebugString(linestr);
}

/*:::::::::::::::::::::::::::: Unix specific string functions ::::::::::::::*/

char *index(char *string, int c)
{
    return(strchr(string, c));
}

char *rindex(char *string, int c)
{
    return(strrchr(string, c));
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

host_mouse_in_use()
{
return(FALSE);
}

void redirector() {}
void reset_delta_data_structures() {}
void set_hfx_severity() {}

host_check_for_lock()
{
    assert0(NO,"host_check_for_lock stubbed\n");
    return(0);
}

host_place_lock(int dummy1)
{
    assert0(NO,"host_place_lock stubbed\n");
    return(0);
}

host_clear_lock(int fd)
{
    assert0(NO,"host_clear_lock stubbed\n");
    return(0);
}


int host_com_send_delay_done(int dummy1, int dummy2)
{
        return(0);
}
#ifndef A2CPU
delta_cpu_test_frag()
{
        assert0(NO,"delta_cpu_test_frag stubbed\n");
        return(0);
}

examine_delta_data_structs(int o, int i)
{
        assert0(NO,"examine_delta_data_structs stubbed\n");
        return(0);
}
code_gen_files_init()
{
        assert0(NO,"code_gen_files_init stubbed\n");
        return(0);
}
decode_files_init()
{
        assert0(NO,"decode_files_init stubbed\n");
        return(0);
}

#ifdef ALPHA

//
// temporary change to get Alpha CPU running
// in checked mode. Andy - 13/1/94
//

double get_287_reg_as_double(int i)
{
        extern char *GDP;
        return(*(double *)(GDP + 0x80 + i * 8));
}
#endif

#ifdef CPU_40_STYLE

GLOBAL BOOL sas_manage_xms IFN3(VOID *,start_addr, ULONG, cb, INT, a_or_f)
{
    printf("sas_manage_xms called(%lx,%lx,%lx)\n",start_addr,cb,a_or_f);
    return (TRUE);
}

#undef sas_loadw
GLOBAL void sas_loadw IFN2(sys_addr, addr, word *, val)
{
    *val = sas_w_at(addr);
}

GLOBAL void host_sigio_event IPT0()
{
}

#endif /* CPU_40_STYLE */

#ifndef GENERIC_NPX
#ifndef CPU_40_STYLE
int get_287_sp()
{
         extern char *GDP;
         return((int) (*(ULONG *)(GDP + 0x70))/8);
}
word get_287_tag_word()
{
         extern char *GDP;
         return((int) *(ULONG *)(GDP + 0x74));
}
word get_287_control_word()
{
         extern char *GDP;
         return((int) *(ULONG *)(GDP + 0x68));
}
word get_287_status_word()
{
         extern char *GDP;
        return((int) *(ULONG *)(GDP + 0x6c));
}
#endif /* CPU_40_STYLE */
#endif /* GENERIC_NPX */
#endif

int     rate_min;
int     rate_max;
int     compiling;
int     rate_delta;
int     show_stuff;
int     stat_rate;
int     compile_off[99];
int     rate_norm;
int     cut_off_level;
int     max_host_fragment_size;
int     delta_err_message[100];
int     last_destination_address;


host_flip_real_floppy_ind()
{
        assert0(NO,"host_flip_real_floppy_ind stubbed\n");
        return(0);
}

#ifndef A2CPU
int     haddr_of_src_string;
int     INTEL_STATUS;
int     R_SI;
int     R_DI;
int     R_BP;
int     R_OPA;
int     R_DEF_SS;
int     R_OPB;
int     R_SP;
int     R_DEF_DS;
int     R_AX;
int     R_BX;
int     R_CX;
int     R_DX;
int     R_IP;
int     R_ACT_CS;
int     R_ACT_SS;
int     R_OPR;
int     R_ACT_DS;
int     R_ACT_ES;
#endif
int     compile_yoda_in;
int     m_s_w;
int     trap_delay_count = 0, temp_trap_flag = 0;
int     cpui;
int     sbp;

host_EOA_hook()
{
        assert0(NO,"host_EOA_hook stubbed\n");
        return(0);
}

getsdosunit()
{
        assert0(NO,"dispatch_q_event stubbed\n");
        return(1);
}

#ifdef NOT_IN_USE
host_check_using_host_mouse()
{
        assert0(NO,"host_check_using_host_mouse stubbed\n");
        return(1);
}
host_deinstall_host_mouse()
{
        assert0(NO,"host_deinstall_host_mouse stubbed\n");
        return(1);
}
#endif

int host_timer_2_frig_factor = 20;

host_check_read_only_drive()
{
        assert0(NO,"host_check_read_only_drive stubbed\n");
        return(0);
}

host_lock_drive_and_make_writable()
{
        assert0(NO,"host_lock_drive_and_make_writable stubbed\n");
        return(1);
}

host_floppy_init()
{
        assert0(NO,"host_floppy_init stubbed\n");
        return(1);
}

SHORT validate_hfx_drive()
{
        assert0(NO,"host_lpt_valid\n");
        return C_CONFIG_OP_OK;
}

SHORT host_keymap_valid()
{
        assert0(NO,"host_keymap_valid\n");
        return C_CONFIG_OP_OK;
}

VOID host_keymap_change()
{
        assert0(NO,"host_keymap_change\n");
}

char *host_strerror(int errno)
{
    assert1(NO,"Error : host_strerror (%d)\n",errno);
    return("****** again\n");
}

int link(void)
{
return -1;
}

LOCAL ULONG   dummy()
{
        return(0);
}

GLOBAL  ULONG    (*clear_v7ptr)() = dummy;
GLOBAL  ULONG    (*paint_v7ptr)() = dummy;

GLOBAL ULONG host_speed IFN1(ULONG, temp)
{
return 10000L;
}

#ifndef MONITOR

// allows getIntelRegistersPointer to be exported bt ntvdm.def
getIntelRegistersPointer()
{
    assert0(NO,"getIntelRegistersPointer stubbed\n");
    return(0);
}

#if  0
// these two crept into WOW - they are x86 monitor'isms

word getEIP()
{
   return(c_getIP());
}

void setEIP(val)
word  val;
{
    c_setIP(val);
}
#endif

int FlatAddress[1];
int Ldt[1];
int VdmTib;
int VdmTibStruct;

void DispatchInterrupts()
{
}

#else //MONITOR

#ifndef YODA
void check_I()
{
}

void force_yoda()
{
    printf("Yoda disabled on x86\n");
}
#endif  //YODA

#endif  //MONITOR


#ifndef MONITOR

//
// davehart 9-Dec-92 HACKHACK
// Build fix -- we export cpu_createthread from ntvdm.exe,
// even though this function from v86\monitor\i386 doesn't
// exist on MIPS.
//
// If we really need to export the function, we may want to
// take the ntoskrnl.src -> obj\i386\ntoskrnl.def approach.
//

VOID
cpu_createthread(
    HANDLE Thread,
    PVDM_TIB VdmTib
    )
/*++

Routine Description:

    This routine adds a thread to the list of threads that could be executing
    in application mode.

Arguments:

    Thread -- Supplies a thread handle

    VdmContext -- Supplies a pointer to a vdm context

Return Value:

    None.

--*/
{
}

#endif // ndef MONITOR

#ifndef MONITOR
ULONG CurrentMonitorTeb;
#endif

void host_note_queue_added()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\host\src\x86_emm.c ===
/*                      INSIGNIA MODULE SPECIFICATION
                        -----------------------------

MODULE NAME     : 'Lower layer' of Expanded Memory Manager

        THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
        CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
        NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
        AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS INC.

DESIGNER        : Simon Frost
DATE            : March '92

PURPOSE         : NT specific code for EMS LIM rev 4.0
                implementation.

The Following Routines are defined:
                1. host_initialise_EM()
                2. host_deinitialise_EM()
                3. host_allocate_storage()
                4. host_free_storage()
                5. host_reallocate_storage()
                6. host_map_page()
                7. host_unmap_page()
                8. host_alloc_page()
                9. host_free_page()
                10. host_copy_con_to_con()
                11. host_copy_con_to_EM()
                12. host_copy_EM_to_con()
                13. host_copy_EM_to_EM()
                14. host_exchg_con_to_con()
                15. host_exchg_con_to_EM()
                16. host_exchg_EM_to_EM()
                17. host_get_access_key()

=========================================================================
*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "insignia.h"
#include "host_def.h"
#include "string.h"
#include "stdlib.h"

#ifdef LIM
#ifdef MONITOR  //x86 specific LIM functions

#include "xt.h"
#include "emm.h"
#include "sas.h"
#include "host_rrr.h"
#include "debug.h"
#include "umb.h"
#include "host_emm.h"
#include "nt_uis.h"

/*      Global Variables                */

/*      Forward Declarations            */
BOOL hold_lim_page(USHORT segment);
/* find this function in monitor/sas.c */
extern BOOL HoldEMMBackFillMemory(ULONG Address, ULONG Size);


/*      Local Variables                 */

LOCAL   UTINY *EM_pagemap_address = NULL;     /* address of start of pagemap */

/* pagemap requires 1 bit per 16K page - i.e. 8 bytes per meg   */
LOCAL UTINY EM_pagemap[8*32];

LOCAL VOID *BaseOfLIMMem = NULL;        // start of expanded memory
ULONG HolderBlockOffset;	// holder block offset

LOCAL HANDLE LIMSectionHandle;
LOCAL HANDLE processHandle = NULL;

LOCAL ULONG X86NumRoms = 0;

#define PAGE_SEG_SIZE	0x400	/* size of page expressed as segment */

#define CONFIG_DATA_STRING L"Configuration Data"
#define KEY_VALUE_BUFFER_SIZE 2048

#define EMMBASE 0xd0000
#define EMMTOP  0xe0000

#define SECTION_NAME        L"\\BaseNamedObjects\\LIMSection"
#define SECTION_NAME_LEN    sizeof(SECTION_NAME)

typedef struct _BIOS_BLOCK {
    ULONG PhysicalAddress;
    ULONG SizeInByte;
} BIOS_BLOCK;


/*
Defines are:
        EM_loads(from, to, length), copies length bytes from intel 24 bit
                address from, to host 32 bit address to
        EM_stores(to, from, length), copies length bytes from host 32 bit
                address from to intel 24 bit address to
        EM_moves(from, to, length), copies length bytes from intel 24 bit
                address from to intel 24 bit address to
        EM_memcpy(to, from, length), copies length bytes from host 32 bit
                address from to host 32 bit address to
*/


#define EM_loads(from, to, length) memcpy(to, get_byte_addr(from), length)
#define EM_stores(to, from, length) \
        RtlCopyMemory(get_byte_addr(to), from, length)
#define EM_moves(from,to,length) \
        RtlMoveMemory(get_byte_addr(to), get_byte_addr(from), length)
#define EM_memcpy(to, from, length) \
        RtlMoveMemory(to, from, length)

/*
===========================================================================

FUNCTION        : host_initialise_EM

PURPOSE         : allocates the area of memory that is used for
                expanded memory and sets up an area of memory to be used
                for the logical pagemap allocation table.


RETURNED STATUS : SUCCESS - memory allocated successfully
                  FAILURE - unable to allocate required space

DESCRIPTION     :


=========================================================================
*/
int host_initialise_EM(short size)
/*   IN short   size             size of area required in megabytes     */
{
    UTINY *pagemap_ptr;         /* temp ptr. to logical pagemap */
    int i;                              /* loop counter                 */
    NTSTATUS status;
    OBJECT_ATTRIBUTES objAttribs;
    LARGE_INTEGER secSize;
    ULONG viewSize;
    USHORT  PageSegment, Pages;
    LONG	 EM_size;

    SAVED UNICODE_STRING LIMSectionName =
    {
        SECTION_NAME_LEN,
        SECTION_NAME_LEN,
        SECTION_NAME
    };


    /* Nobody should call this function with size 0 */
    ASSERT(size != 0);

    EM_pagemap_address = &EM_pagemap[0];

    /* initialise pagemap to 0's        */

    pagemap_ptr = EM_pagemap_address;
    for(i = 0; i < 8*32; i++)
        *pagemap_ptr++ = 0;

    EM_size = ((long) size) * 0x100000;

    if (!(processHandle = NtCurrentProcess()))
    {
        assert0(NO, "host_initialise_EM: cant get process handle");
        return(FAILURE);
    }

    // create section for LIM

    /* Fill the fields of the OBJECT_ATTRIBUTES structure. */
    InitializeObjectAttributes(&objAttribs,
                            NULL, // was &LIMSectionName, but null means private
                            OBJ_CASE_INSENSITIVE,
                            NULL,
                            NULL);

    /* Create the section. EMM_PAGE_SIZE for holder page */
    secSize.LowPart = EM_size + EMM_PAGE_SIZE;
    secSize.HighPart = 0;
    HolderBlockOffset = EM_size;

    // improvement - just reserve  & commit as needed...
    status = NtCreateSection(&LIMSectionHandle,
                                    SECTION_MAP_WRITE|SECTION_MAP_EXECUTE,
                                    &objAttribs,
                                    &secSize,
                                    PAGE_EXECUTE_READWRITE,
                                    SEC_COMMIT,
                                    NULL);
    if (!NT_SUCCESS(status))
    {
        assert1(NO, "host_initialise_EM: LIM section creation failed (%x)", status);
        return(FAILURE);
    }

    /* Map the section to the process' address space. */
    BaseOfLIMMem = NULL;
    viewSize = 0;

    status = NtMapViewOfSection(LIMSectionHandle,
                                       processHandle,
                                       (PVOID *) &BaseOfLIMMem,
                                       0,
                                       0,
                                       NULL,
                                       &viewSize,
                                       ViewUnmap,
                                       0,       // do we need mem_top_down??
                                       PAGE_READWRITE);
    if (!NT_SUCCESS(status))
    {
        assert1(NO, "host_initialise_EM: can't map view of LIM section (%x)", status);
        return(FAILURE);
    }

    /* acquire page frame addresss space from UMB list */
    if (!GetUMBForEMM()) {
	host_deinitialise_EM();
	return FAILURE;
    }

    /* attach page to holder so that we won't get killed if applications
     * try to touch the page frames without mapping
     */

    for (Pages = get_no_phys_pages();  Pages  ; Pages--) {
	PageSegment = get_page_seg((unsigned char)(Pages - 1));
	if (PageSegment <= 640 * 1024 / 16)
	    continue;
	if (!hold_lim_page(PageSegment))
	    return FAILURE;

    }
    return(SUCCESS);
}


/*
===========================================================================

FUNCTION        : host_deinitialise_EM

PURPOSE         : frees the area of memory that was used for
                expanded memory and memory  used
                for the logical pagemap allocation table.


RETURNED STATUS : SUCCESS - memory freed successfully
                  FAILURE - error ocurred in freeing memory

DESCRIPTION     :


=========================================================================
*/
int host_deinitialise_EM()
{
    ULONG len = 0x10000;
    NTSTATUS status;

    if (BaseOfLIMMem != NULL)
    {
        if (processHandle == NULL)
        {
	    //As shutting down anyway then fail silently
            return(FAILURE);
        }

        // lose section from our memory space
        status = NtUnmapViewOfSection(processHandle, BaseOfLIMMem);
        if (!NT_SUCCESS(status))
        {
	    //As shutting down anyway then fail silently
            return(FAILURE);
        }

        status = NtClose(LIMSectionHandle);     // delete section
        if (!NT_SUCCESS(status))
        {
	    //As shutting down anyway then fail silently
            return(FAILURE);
        }

        return(SUCCESS);
    } else {
        return FAILURE;
    }
}



/*
===========================================================================

FUNCTION        : host_allocate_storage

PURPOSE         : allocates an area of memory of requested size, to be
                used as a general data storage area. The area is
                to zeros.

RETURNED STATUS : storage_ID - (in this case a pointer)
                 NULL - failure to allocate enough space.


DESCRIPTION     : returns memory initialised to zeros.
                The storage ID returned is a value used to later reference
                the storage area allocated. The macro USEBLOCK in
                "host_emm.h" is used by the manager routines to convert
                this ID into a char pointer

=========================================================================
*/
long host_allocate_storage(int no_bytes)
/*   IN  int    no_bytes                        no. of bytes required   */
{
        // should replace this (?) - dissasembling calloc seems to
        // indicate it uses win funx...
        return ((long)calloc(1, no_bytes));
}


/*
===========================================================================

FUNCTION        : host_free_storage

PURPOSE         : frees the area of memory that was used for
                data storage


RETURNED STATUS : SUCCESS - memory freed successfully
                  FAILURE - error ocurred in freeing memory

DESCRIPTION     : In this implementation storage_ID is simply a pointer


=========================================================================
*/
int host_free_storage(long storage_ID)
/*   IN  long   storage_ID                      ptr to area of memory   */
{
        if(storage_ID != (long)NULL)
                free((char *)storage_ID);

        return(SUCCESS);
}


/*
===========================================================================

FUNCTION        : host_reallocate_storage

PURPOSE         : increases the size of memory allocated, maintaining the
                contents of the original memory block


RETURNED STATUS : storage_ID - memory reallocated successfully
                  NULL - error ocurred in reallocating memory

DESCRIPTION     : In this implementation storage_ID is simply a pointer
                Note the value of storage_ID returned may or may not be the
                same as the value given

=========================================================================
*/
long host_reallocate_storage(LONG storage_ID, int size, int new_size)
/*
    IN
long    storage_ID       ptr to area of memory
int     size             original size - not used in this version
        new_size         new size required
*/
{
        return((long)realloc((char *)storage_ID, new_size));
}


/*
===========================================================================

FUNCTION        : hold_lim_page

PURPOSE         : Puts some memory in one of the LIM page gaps in 16 bit
		  memory. Ensures nothing else in the process gets that
		  via malloc.


RETURNED STATUS : TRUE - mapping OK.

DESCRIPTION     : Mapping achieved by mapping correct page from section into
                  Intel memory
=========================================================================
*/
BOOL hold_lim_page(USHORT segment)
/*   IN
int page	page (0-3) of LIM gap
*/

{
    PVOID to;
    LARGE_INTEGER sec_offset;
    ULONG viewSize;
    NTSTATUS status;

    if (BaseOfLIMMem != NULL)
    {
	to = (PVOID)effective_addr(segment, (word)0);

	sec_offset.LowPart = HolderBlockOffset;
        sec_offset.HighPart = 0;

        viewSize = EMM_PAGE_SIZE;

	status = NtMapViewOfSection(LIMSectionHandle,
                                processHandle,
                                &to,
                                0,
                                EMM_PAGE_SIZE,
                                &sec_offset,
                                &viewSize,
                                ViewUnmap,
                                MEM_DOS_LIM,
                                PAGE_EXECUTE_READWRITE);
        if (!NT_SUCCESS(status))
        {
            DisplayErrorTerm(EHS_FUNC_FAILED,status,__FILE__,__LINE__);
            return(FALSE);
        }
        return(TRUE);
    }
    return(FALSE);
}


/*
===========================================================================

FUNCTION        : host_map_page

PURPOSE         : produces mapping from an Expanded Memory page to a
                page in Intel physical address space


RETURNED STATUS : SUCCESS - mapping completed succesfully
                  FAILURE - error ocurred in mapping

DESCRIPTION     : Mapping achieved by mapping correct page from section into
                  Intel memory
=========================================================================
*/
int host_map_page(SHORT EM_page_no, USHORT segment)
/*   IN
short           EM_page_no      Expanded Memory page to be mapped in
unsigned short  segment;        segment in physical address space to map into
*/

{
    PVOID to;
    int tstpage;
    LARGE_INTEGER sec_offset;
    ULONG viewSize;
    NTSTATUS status;

    note_trace2(LIM_VERBOSE,"map page %d to segment 0x%4x", EM_page_no, segment);
#ifdef EMM_DEBUG
	printf("host_map_page, segment=%x, EMpage=%x\n",
		segment, EM_page_no);
#endif

    if (BaseOfLIMMem != NULL)
    {
        to = (PVOID)effective_addr(segment, 0);

        sec_offset.LowPart = EM_page_no * EMM_PAGE_SIZE;
        sec_offset.HighPart = 0;

        viewSize = EMM_PAGE_SIZE;

        tstpage = (segment - get_base_address()) >> 10;

	/* detach from EMM page section */
        status = NtUnmapViewOfSection(processHandle, (PVOID)to);
        if (!NT_SUCCESS(status))
        {
            DisplayErrorTerm(EHS_FUNC_FAILED,status,__FILE__,__LINE__);
            return(FALSE);
        }

        if (processHandle == NULL)
        {
            DisplayErrorTerm(EHS_FUNC_FAILED,0,__FILE__,__LINE__);
            return(FAILURE);
        }

	/* attach to the section */
        status = NtMapViewOfSection(LIMSectionHandle,
                                    processHandle,
                                    &to,
                                    0,
                                    EMM_PAGE_SIZE,
                                    &sec_offset,
                                    &viewSize,
                                    ViewUnmap,
                                    MEM_DOS_LIM,
                                    PAGE_EXECUTE_READWRITE
                                    );

        if (!NT_SUCCESS(status))
        {
            DisplayErrorTerm(EHS_FUNC_FAILED,status,__FILE__,__LINE__);
            return(FAILURE);
        }
        return(SUCCESS);
    }
    return(FAILURE);
}

/*
===========================================================================

FUNCTION        : host_unmap_page

PURPOSE         :unmaps pages from Intel physical address space to an
                Expanded Memory page

RETURNED STATUS : SUCCESS - unmapping completed succesfully
                  FAILURE - error ocurred in mapping

DESCRIPTION     : Unmapping achieved by unampping view of section from
                  Intel memory

=========================================================================
*/
int host_unmap_page(USHORT segment, SHORT EM_page_no)
/*   IN
unsigned short  segment         Segment in physical address space to unmap.
short           EM_page_no      Expanded Memory page currently mapped in
*/
{
        PVOID from;
        NTSTATUS status;
	unsigned short phys_page_no;

        note_trace2(LIM_VERBOSE,"unmap page %d from segment 0x%.4x\n",EM_page_no,segment);


        from = (PVOID)effective_addr(segment, 0);

#ifdef EMM_DEBUG
	printf("host_unmap_page, segment=%x, EMpage=%x\n",
		segment, EM_page_no);
#endif

	/* detach from the LIM section */
        status = NtUnmapViewOfSection(processHandle, from);
        if (!NT_SUCCESS(status))
        {
            DisplayErrorTerm(EHS_FUNC_FAILED,status,__FILE__,__LINE__);
            return(FAILURE);
        }

	/* hold the block to avoid AV when applications touch unmapped pages */
	if (segment < 640 * 1024 / 16) {
	    if (!HoldEMMBackFillMemory(segment * 16, EMM_PAGE_SIZE))
		return FAILURE;
	}
	else {

	    if (!hold_lim_page(segment)) {
		note_trace1(LIM_VERBOSE, "couldn't hold lim page %d",get_segment_page_no(segment));
		return FAILURE;
	    }
	}
        return(SUCCESS);
}

/*
===========================================================================

FUNCTION        : host_alloc_page

PURPOSE         : searches the pagemap looking for a free page, allocates
                that page and returns the EM page no.

RETURNED STATUS :
                  SUCCESS - Always see note below

DESCRIPTION     : Steps through the Expanded memory Pagemap looking for
                a clear bit, which indicates a free page. When found,
                sets that bit and returns the page number.
                For access purposes the pagemap is divided into long
                word(32bit) sections

NOTE            : The middle layer calling routine (alloc_page()) checks
                that all pages have not been allocated and therefore in
                this implementation the returned status will always be
                SUCCESS.
                However alloc_page still checks for a return status of
                SUCCESS, as some implementations may wish to allocate pages
                dynamically and that may fail.
=========================================================================
*/
SHORT host_alloc_page()
{
        SHORT EM_page_no;               /* page number returned         */
        LONG  *ptr;                     /* ptr to 32 bit sections in    */
                                        /* pagemap                      */
        SHORT i;                        /* index into 32 bit section    */

        ptr = (LONG *)EM_pagemap_address;
        i =0;
        EM_page_no = 0;

        while(*ptr & (MSB >> i++))
        {
                EM_page_no++;

                if(i == 32)
                /*
                 * start on next section
                 */
                {
                        ptr++;
                        i = 0;
                }
        }
        /*
         * Set bit to show that page is allocated
         */
        *ptr = *ptr | (MSB >> --i);

        return(EM_page_no);
}


/*
===========================================================================

FUNCTION        : host_free_page

PURPOSE         : marks the page indicated as being free for further
                allocation

RETURNED STATUS :
                SUCCESS - Always - see note below

DESCRIPTION     : clears the relevent bit in the pagemap.

                For access purposes the pagemap is divided into long
                word(32bit) sections.

NOTE            : The middle layer calling routine (free_page()) always
                checks for invalid page numbers so in this implementation
                the routine will always return SUCCESS.
                However free_page() still checks for a return of SUCCESS
                as other implementations may wish to use it.
=========================================================================
*/
int host_free_page(SHORT EM_page_no)
/*   IN SHORT   EM_page_no      page number to be cleared       */
{
        LONG  *ptr;                     /* ptr to 32 bit sections in    */
                                        /* pagemap                      */
        SHORT i;                        /* index into 32 bit section    */

        /*
         * Set pointer to correct 32 bit section and index to correct bit
         */

        ptr = (long *)EM_pagemap_address;
        ptr += (EM_page_no / 32);
        i = EM_page_no % 32;

        /*
         * clear bit
         */
        *ptr = *ptr & ~(MSB >> i);

        return(SUCCESS);
}


/*
===========================================================================

FUNCTION        : host_copy routines
                host_copy_con_to_con()
                host_copy_con_to_EM()
                host_copy_EM_to_con()
                host_copy_EM_to_EM()

PURPOSE         : copies between conventional and expanded memory


RETURNED STATUS :
                SUCCESS - Always - see note below

DESCRIPTION     :
                 The middle layer calling routine always checks for a
                return of SUCCESS as other implementations may
                return FAILURE.
=========================================================================
*/
int host_copy_con_to_con(int length, USHORT src_seg, USHORT src_off, USHORT dst_seg, USHORT dst_off)

/*   IN
int             length          number of bytes to copy

USHORT  src_seg         source segment address
        src_off         source offset address
        dst_seg         destination segment address
        dst_off         destination offset address
*/
{
        sys_addr from, to;      /* pointers used for copying    */

        from = effective_addr(src_seg, src_off);
        to = effective_addr(dst_seg, dst_off);

        EM_moves(from, to, length);

        return(SUCCESS);
}

int host_copy_con_to_EM(int length, USHORT src_seg, USHORT src_off, USHORT dst_page, USHORT dst_off)

/*   IN
int             length   number of bytes to copy

USHORT  src_seg         source segment address
        src_off         source offset address
        dst_page        destination page number
        dst_off         destination offset within page
*/
{
        UTINY *to;
        sys_addr from;

        from = effective_addr(src_seg, src_off);
        to = (char *)BaseOfLIMMem + dst_page * EMM_PAGE_SIZE + dst_off;

        EM_loads(from, to, length);

        return(SUCCESS);
}

int host_copy_EM_to_con(int length, USHORT src_page, USHORT src_off, USHORT dst_seg, USHORT dst_off)
/*   IN
int     length          number of bytes to copy

USHORT  src_page        source page number
        src_off         source offset within page
        dst_seg         destination segment address
        dst_off         destination offset address
*/
{
        UTINY  *from;
        sys_addr to;

        from = (char *)BaseOfLIMMem + (src_page * EMM_PAGE_SIZE + src_off);
        to = effective_addr(dst_seg, dst_off);

        EM_stores(to, from, length);

        return(SUCCESS);
}

int host_copy_EM_to_EM(int length, USHORT src_page, USHORT src_off, USHORT dst_page, USHORT dst_off)
/*   IN
int     length          number of bytes to copy

USHORT  src_page        source page number
        src_off         source offset within page
        dst_page        destination page number
        dst_off         destination offset within page
*/
{
        unsigned char *from, *to;       /* pointers used for copying    */

        from = (char *)BaseOfLIMMem + src_page * EMM_PAGE_SIZE + src_off;
        to = (char *)BaseOfLIMMem + dst_page * EMM_PAGE_SIZE + dst_off;

        EM_memcpy(to, from, length);

        return(SUCCESS);
}


/*
===========================================================================

FUNCTION        : host_exchange routines
                host_exchg_con_to_con()
                host_exchg_con_to_EM()
                host_exchg_EM_to_EM()

PURPOSE         : exchanges data between conventional and expanded memory


RETURNED STATUS :
                SUCCESS - Everything ok
                FAILURE - Memory allocation failure

DESCRIPTION     :

=========================================================================
*/
int host_exchg_con_to_con(int length, USHORT src_seg, USHORT src_off, USHORT dst_seg, USHORT dst_off)
/*   IN
int     length          number of bytes to copy

USHORT  src_seg          source segment address
        src_off          source offset address
        dst_seg          destination segment address
        dst_off          destination offset address
*/
{
        UTINY *temp, *pointer;/* pointers used for copying      */
        sys_addr to, from;

        if (length <= 64*1024)
            temp = sas_scratch_address(length);
        else
            if ((temp = (unsigned char *)host_malloc(length)) == NULL)
                return(FAILURE);

        pointer = temp;

        from = effective_addr(src_seg, src_off);
        to = effective_addr(dst_seg, dst_off);

	EM_loads(from, pointer, length);    /* source -> temp */
	EM_moves(to, from, length);	    /* dst -> source */
	EM_stores(to, pointer, length);     /* temp -> dst */

        if (length > 64*1024)
            host_free(temp);

        return(SUCCESS);
}

int host_exchg_con_to_EM(int length, USHORT src_seg, USHORT src_off, USHORT dst_page, USHORT dst_off)
/*   IN
int     length          number of bytes to copy

USHORT  src_seg         source segment address
        src_off         source offset address
        dst_page        destination page number
        dst_off         destination offset within page
*/
{
        UTINY *to, *temp, *pointer;/* pointers used for copying */
        sys_addr from;

        //STF - performance improvement: if 4k aligned & >= 4k then can use
        // (un)mapview to do exchange.

        if (length <= 64*1024)
            temp = sas_scratch_address(length);
        else
            if ((temp = (unsigned char *)host_malloc(length)) == NULL)
                return(FAILURE);

        pointer = temp;

        from = effective_addr(src_seg, src_off);
        to = (char *)BaseOfLIMMem + dst_page * EMM_PAGE_SIZE + dst_off;

        EM_loads(from, pointer, length);
        EM_stores(from, to, length);
        EM_memcpy(to, pointer, length);

        if (length > 64*1024)
            host_free(temp);

        return(SUCCESS);
}

int host_exchg_EM_to_EM(int length, USHORT src_page, USHORT src_off, USHORT dst_page, USHORT dst_off)
/*   IN
int     length  number of bytes to copy

USHORT  src_page        source page number
        src_off         source offset within page
        dst_page        destination page number
        dst_off         destination offset within page
*/
{
        UTINY *from, *to, *temp, *pointer; /* pointers used for copying */

        if (length <= 64*1024)
            temp = sas_scratch_address(length);
        else
            if ((temp = (unsigned char *)host_malloc(length)) == NULL)
                return(FAILURE);

        pointer = temp;

        from = (char *)BaseOfLIMMem + src_page * EMM_PAGE_SIZE + src_off;
        to = (char *)BaseOfLIMMem + dst_page * EMM_PAGE_SIZE + dst_off;

        EM_memcpy(pointer, from, length);
        EM_memcpy(from, to, length);
        EM_memcpy(to, pointer, length);

        if (length > 64*1024)
            host_free(temp);

        return(SUCCESS);
}


/*
===========================================================================

FUNCTION        : host_get_access_key

PURPOSE         : produces a random access key for use with LIM function 30
                'Enable/Disable OS/E Function Set Functions'

RETURNED STATUS : none

DESCRIPTION     : Two 16 bit random values are required for the 'access key'
                We use the microsecond field from the get time of day routine
                to provide this.

=========================================================================
*/
void host_get_access_key(USHORT access_key[2])
/*  OUT USHORT  access_key[2]   source segment address          */
{
        // do you think we need to seed the random # gen?
        access_key[0] = rand() & 0xffff;
        access_key[1] = rand() & 0xffff;

        return;
}
#endif /* MONITOR */
#endif /* LIM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\host\src\sim32.c ===
/*
 *      sim32.c -       Sim32 for Microsoft NT SoftPC.
 *
 *      Ade Brownlow
 *      Wed Jun 5 91
 *
 *      %W% %G% (c) Insignia Solutions 1991
 *
 *      This module provides the Microsoft sim32 interface with the additional sas
 *      functionality and some host sas routines. We also provide cpu idling facilities.
 *
 *      This module in effect provides (along with the cpu) what Microsoft term as the IEU -
 *      see documentation.
 */

#ifdef SIM32

#ifdef CPU_40_STYLE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif /* CPU_40_STYLE */

#include <windows.h>
#include "insignia.h"
#include "host_def.h"

#include <stdlib.h>
#include <stdio.h>
#include "xt.h"
#include "sim32.h"
#include "sas.h"
#include "gmi.h"
#include "ckmalloc.h"
#include CpuH


#ifdef CPU_40_STYLE
#include "nt_mem.h"
#endif /* CPU_40_STYLE */
#include "nt_vdd.h"

/********************************************************/
/* IMPORTS & EXPORTS */

/* Sas/gmi Sim32 crossovers */
GLOBAL BOOL Sim32FlushVDMPointer (double_word, word, UTINY *, BOOL);
GLOBAL BOOL Sim32FreeVDMPointer (double_word, word, UTINY *, BOOL);
GLOBAL BOOL Sim32GetVDMMemory (double_word, word, UTINY *, BOOL);
GLOBAL BOOL Sim32SetVDMMemory (double_word, word, UTINY *, BOOL);
GLOBAL sys_addr sim32_effective_addr (double_word, BOOL);
GLOBAL sys_addr sim32_effective_addr_ex (word, double_word, BOOL);

GLOBAL UTINY *sas_alter_size(sys_addr);
GLOBAL UTINY *host_sas_init(sys_addr);
GLOBAL UTINY *host_sas_term(void);

/* Microsoft sas extensions */
GLOBAL IMEMBLOCK *sas_mem_map (void);
GLOBAL void sas_clear_map(void);

IMPORT ULONG Sas_wrap_mask;



#ifndef MONITOR
//
// Pointer to a scratch video buffer. Updated by sim32 routines
// when intel video addr is requested.

IU8 *ScratchVideoBuffer = 0;
#define VIDEO_REGEN_START   0xa0000
#define VIDEO_REGEN_END     0xbffff
#define VID_BUFF_SIZE       0x20000


#define IsVideoMemory(LinAddr) \
         ((LinAddr) >= VIDEO_REGEN_START && (LinAddr) <= VIDEO_REGEN_END)


IU8 *GetVideoMemory(ULONG iaddr)
{

   //
   // If there isn't a video scratch buffer, allocate one.
   // This will stick around until ntvdm terminates. Could be
   // optimized to free the buffer when not in use.
   //
   if (!ScratchVideoBuffer) {
       ScratchVideoBuffer = malloc(VID_BUFF_SIZE);
       if (!ScratchVideoBuffer) {
          return NULL;
          }
       }

   //
   // We could do this more efficiently, by only copying
   // minimum area needed, but then we need to keep track of
   // what to update on the flush and do ref counting.
   // Since video memory access by host code is rare
   // (only seen in demWrite\demRead so far) be simple minded.
   //
   sas_loads (VIDEO_REGEN_START,
              ScratchVideoBuffer,
              VID_BUFF_SIZE
              );

   return ScratchVideoBuffer + (iaddr - VIDEO_REGEN_START);
}


BOOL SetVideoMemory(ULONG iaddr)
{
   ULONG VideoOffset = iaddr - VIDEO_REGEN_START;

   if (!ScratchVideoBuffer) {
       return FALSE;
       }

   sas_stores(iaddr,
              ScratchVideoBuffer + VideoOffset,
              VID_BUFF_SIZE - VideoOffset
              );

  return TRUE;
}

#endif



/********************************************************/
/* MACROS */
/* macro to convert the supplied address to intel address */
#define convert_addr(a,b,c,d) \
        { \
                if ((a = sim32_effective_addr (b,c)) == (sys_addr)-1)\
                {\
                        return (d);\
                }\
        }
#define convert_addr_ex(a,b,c,d,e) \
        { \
                if ((a = sim32_effective_addr_ex (b,c,d)) == (sys_addr)-1)\
                {\
                        return (e);\
                }\
        }

/********************************************************/
/*      The actual sim32 interfaces, most of these routines can be more or less mapped directly
 *      to existing routines in sas or gmi.
 *
 *      WARNING: This routine returns a pointer into M, and
 *               WILL NOT work for backward M.
 */
UCHAR *Sim32pGetVDMPointer(ULONG addr, UCHAR pm)
{
        sys_addr iaddr;

        if (pm && (addr == 0))
	    return(NULL);

        convert_addr (iaddr, addr, pm, NULL);
//STF - need sas_wrap_mask with PE....iaddr &= Sas_wrap_mask;

        if (IsVideoMemory(iaddr)) {
            return GetVideoMemory(iaddr);
            }

        return (NtGetPtrToLinAddrByte(iaddr));
}

/*
 *  See Sim32pGetVDMPointer
 *
 *  This call must be maintaned as is because it is exported for VDD's
 *  in product 1.0.
 */
UCHAR *ExpSim32GetVDMPointer IFN3(double_word, addr, double_word, size, UCHAR, pm)
{
        return Sim32pGetVDMPointer(addr, (UCHAR)pm);
}


GLOBAL BOOL Sim32FlushVDMPointer IFN4(double_word, addr, word, size, UTINY *, buff, BOOL, pm)
{
        sys_addr iaddr;
        convert_addr (iaddr, addr, pm, 0);

//STF - need sas_wrap_mask with PE....iaddr &= Sas_wrap_mask;

#ifndef MONITOR
        if (IsVideoMemory(iaddr) && !SetVideoMemory(iaddr)) {
            return FALSE;
            }
#endif   //MONITOR


        sas_overwrite_memory(iaddr, (ULONG)size);
        return (TRUE);
}


/********************************************************/
/*      The actual sim32 interfaces, most of these routines can be more or less mapped directly
 *      to existing routines in sas or gmi.
 *
 *      WARNING: This routine returns a pointer into M, and
 *               WILL NOT work for backward M.
 */
PVOID
VdmMapFlat(
    USHORT seg,
    ULONG off,
    VDM_MODE mode
    )
{
    sys_addr iaddr;
	BOOL pm = (mode == VDM_PM);

    if (pm && (seg == 0) && (off == 0))
    return(NULL);

    convert_addr_ex (iaddr, seg, off, pm, NULL);
//STF - need sas_wrap_mask with PE....iaddr &= Sas_wrap_mask;

    if (IsVideoMemory(iaddr)) {
        return GetVideoMemory(iaddr);
        }

    return (NtGetPtrToLinAddrByte(iaddr));
}

BOOL
VdmUnmapFlat(
    USHORT seg,
    ULONG off,
    PVOID buffer,
    VDM_MODE mode
    )
{
    // Just a placeholder in case we ever need it
    return TRUE;
}


BOOL
VdmFlushCache(
    USHORT seg,
    ULONG off,
    ULONG size,
    VDM_MODE mode
    )
{

    sys_addr iaddr;
    if (!size) {
        DbgBreakPoint();
        return FALSE;
    }

    convert_addr_ex (iaddr, seg, off, (mode == VDM_PM), 0);

//STF - need sas_wrap_mask with PE....iaddr &= Sas_wrap_mask;

#ifndef MONITOR
    if (IsVideoMemory(iaddr) && !SetVideoMemory(iaddr)) {
        return FALSE;
        }
#endif   //MONITOR


    //
    // Now call the emulator to inform it that memory has changed.
    //
    // Note that sas_overwrite_memory is PAGE GRANULAR, so using
    // it to flush a single LDT descriptor has a horrendous impact on
    // performance, since up to 511 other descriptors are also
    // thrown away.
    //
    // So perform an optimization here by keying off the size.
    // The dpmi code has been written to flush 1 descriptor at
    // a time, so use the sas_store functions in this case to
    // flush it.
    //

    if (size <= 8) {
        UCHAR Buffer[8];
        PUCHAR pBytes;
        USHORT i;
        //
        // Small flush - avoid sas_overwrite_memory().
        // Note that the sas_store functions optimize out calls
        // that simply replace a byte with an identical byte. So this
        // code copies out the bytes to a buffer, copies in zeroes,
        // and then copies the original bytes back in.
        //
        pBytes = NtGetPtrToLinAddrByte(iaddr);
        for (i=0; i<size; i++) {
            Buffer[i] = *pBytes++;
            sas_store(iaddr+i, 0);
        }
        sas_stores(iaddr, Buffer, size);

    } else {

        //
        // normal path - flushes PAGE GRANULAR
        //
        sas_overwrite_memory(iaddr, size);

    }

    return (TRUE);
}


GLOBAL BOOL Sim32FreeVDMPointer IFN4(double_word, addr, word, size, UTINY *, buff, BOOL, pm)
{
        /* we haven't allocated any new memory so always return success */
        return (TRUE);
}

GLOBAL BOOL Sim32GetVDMMemory IFN4(double_word, addr, word, size, UTINY *, buff, BOOL, pm)
{
        sys_addr iaddr;
        convert_addr (iaddr, addr, pm, FALSE);
        /* effectivly a sas_loads */
        sas_loads (iaddr, buff, (sys_addr)size);

        /* always return success */
        return (TRUE);
}

GLOBAL BOOL Sim32SetVDMMemory IFN4(double_word, addr, word, size, UTINY *, buff, BOOL, pm)
{
        sys_addr iaddr;
        convert_addr (iaddr, addr, pm, FALSE);
        /* effectivly a sas_stores */
        sas_stores (iaddr, buff, (sys_addr)size);

        /* always return success */
        return (TRUE);
}

/********************************************************/
/* Support routines for sim32 above */
GLOBAL sys_addr sim32_effective_addr IFN2(double_word, addr, BOOL, pm)
{
    word seg, off;
    double_word descr_addr;
    DESCR entry;

    seg = (word)(addr>>16);
    off = (word)(addr & 0xffff);

    if (pm == FALSE)
    {
	return ((double_word)seg << 4) + off;
    }
    else
    {
	if ( selector_outside_table(seg, &descr_addr) == 1 )
	{
	/*
	This should not happen, but is a check the real effective_addr
	includes. Return error -1.
	*/
#ifndef PROD
        printf("NTVDM:sim32:effective addr: Error for addr %#x (seg %#x)\n",addr, seg);
        HostDebugBreak();
#endif
            return ((sys_addr)-1);
	}
	else
	{
	    read_descriptor(descr_addr, &entry);
	    return entry.base + off;
	}
    }
}

/********************************************************/
/* Support routines for sim32 above */
GLOBAL sys_addr sim32_effective_addr_ex IFN3(word, seg, double_word, off, BOOL, pm)
{
    double_word descr_addr;
    DESCR entry;

    if (pm == FALSE) {
        return ((double_word)seg << 4) + off;
    } else {
        if ( selector_outside_table(seg, &descr_addr) == 1 ) {
            /*
            This should not happen, but is a check the real effective_addr
            includes. Return error -1.
            */
#ifndef PROD
            printf("NTVDM:sim32:effective addr: Error for addr %#x:%#x)\n", seg, off);
            HostDebugBreak();
#endif
            return ((sys_addr)-1);
        } else {
            read_descriptor(descr_addr, &entry);
            return entry.base + off;
        }
    }
}


/********************************************************/
/* Microsoft extensions to sas interface */
LOCAL IMEMBLOCK *imap_start=NULL, *imap_end=NULL;
GLOBAL IMEMBLOCK *sas_mem_map ()
{
        /* produce a memory map for the whole of intel space */
        sys_addr iaddr;
        int mem_type;

        if (imap_start)
                sas_clear_map();

        for (iaddr=0; iaddr < Length_of_M_area; iaddr++)
        {
                mem_type = sas_memory_type (iaddr);
                if (!imap_end)
                {
                        /* this is the first record */
                        check_malloc (imap_start, 1, IMEMBLOCK);
                        imap_start->Next = NULL;
                        imap_end = imap_start;
                        imap_end->Type = (IU8) mem_type;
                        imap_end->StartAddress = iaddr;
                        continue;
                }
                if (imap_end->Type != mem_type)
                {
                        /* end of a memory section & start of a new one */
                        imap_end->EndAddress = iaddr-1;
                        check_malloc (imap_end->Next, 1,IMEMBLOCK);
                        imap_end = imap_end->Next;
                        imap_end->Next = NULL;
                        imap_end->Type = (IU8) mem_type;
                        imap_end->StartAddress = iaddr;
                }
        }
        /* terminate last record */
        imap_end->EndAddress = iaddr;
        return (imap_start);
}

GLOBAL void sas_clear_map()
{
        IMEMBLOCK *p, *q;
        for (p=imap_start; p; p=q)
        {
                q=p->Next;
                free(p);
        }
        imap_start=imap_end=NULL;
}

/********************************************************/
/* Microsoft specific sas stuff (ie host sas) */

#define SIXTEENMEG 1024*1024*12

LOCAL UTINY *reserve_for_sas = NULL;

#ifndef CPU_40_STYLE

LOCAL sys_addr current_sas_size =0;		/* A local Length_of_M_area */

GLOBAL UTINY *host_sas_init IFN1(sys_addr, size)
{
	UTINY *rez;
	DWORD M_plus_type_size;

        /* allocate 16 MEG of virtual memory */
        if (!reserve_for_sas)
        {
                if (!(reserve_for_sas = (UTINY *)VirtualAlloc ((void *)NULL, SIXTEENMEG,
                        MEM_RESERVE, PAGE_READWRITE)))
                {
#ifndef PROD
                        printf ("NTVDM:Failed to reserve 16 Meg virtual memory for sas\n");
#endif
                        exit (0);
                }
        }

	/* now commit to our size */
	M_plus_type_size = size + NOWRAP_PROTECTION +
			   ((size + NOWRAP_PROTECTION) >> 12);
	rez = (UTINY *)VirtualAlloc ((void *) reserve_for_sas,
				     M_plus_type_size,
				     MEM_COMMIT,
				     PAGE_READWRITE);
	if (rez)
		Length_of_M_area = current_sas_size = size;
	return (rez);

}


GLOBAL UTINY *host_sas_term()
{
        if (!reserve_for_sas)
                return (NULL);

        /* deallocate the reserves */
        VirtualFree (reserve_for_sas, SIXTEENMEG, MEM_RELEASE);

        /* null out reserve pointer */
        reserve_for_sas = NULL;

        Length_of_M_area = current_sas_size = 0;

        return (NULL);
}

GLOBAL UTINY *sas_alter_size IFN1(sys_addr, new)
{
        UTINY *tmp;
        if (!reserve_for_sas)
        {
#ifndef PROD
                printf ("NTVDM:Sas trying to alter size before reserve setup\n");
#endif
                return (NULL);
        }

        /* if we are already at the right size return success */
        if (new == current_sas_size)
        {
                return (reserve_for_sas);
        }

        if (new > current_sas_size)
        {
                /* move to end of current commited area */
                tmp = reserve_for_sas + current_sas_size;
                if (!VirtualAlloc ((void *)tmp, (DWORD)(new - current_sas_size), MEM_COMMIT,
                        PAGE_READWRITE))
                {
                        printf ("NTVDM:Virtual Allocate for resize from %d to %d FAILED!\n",
                                current_sas_size, new);
                        return (NULL);
                }
        }
        else
        {
                /* move to the place where sas needs to end */
                tmp = reserve_for_sas + new;

                /* now decommit the unneeded memory */
                if (!VirtualFree ((void *)tmp, (DWORD)(current_sas_size - new), MEM_DECOMMIT))
                {
                        printf ("NTVDM:Virtual Allocate for resize from %d to %d FAILED!\n",
                                current_sas_size, new);
                        return (NULL);
                }
        }
        Length_of_M_area = current_sas_size = new;
        return (reserve_for_sas);
}



#else /* CPU_40_STYLE */


// Intel space allocation and deallocation control function for the A4 CPU

GLOBAL UTINY *host_sas_init IFN1(sys_addr, size)
{

    /* Initialise memory management system and allocation bottom 1M+64K */
    if(!(Start_of_M_area = InitIntelMemory(size)))
    {
	/* Initialise function failed, exit */
#ifndef PROD
       printf ("NTVDM:Failed to allocate virtual memory for sas\n");
#endif

       exit(0);
    }

    Length_of_M_area = size;
    return(Start_of_M_area);
}


GLOBAL UTINY *host_sas_term()
{
    /* Has any Intel memory been allocated ? */
    if(Start_of_M_area)
    {
	/* Free allocated intel memory and control structures */
	FreeIntelMemory();

	reserve_for_sas = NULL; 	 /* null out reserve pointer */
	Length_of_M_area = 0;
    }

    return(NULL);
}

#endif /* CPU_40_STYLE */

#endif /* SIM32 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\suballoc\debug.c ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\obj.vdm\c_regs.c ===
#ifndef MONITOR

//
// temp file for Assembler CPU which provides a simple C cpu -> A cpu register
// mapping for MS libraries (DEM/WOW32/XMS) which are linked for ccpu register
// gets & sets. STF.

#include "host_def.h"
#include "insignia.h"
#include "xt.h"
#include CpuH

#ifdef A3CPU

#ifndef CCPU
half_word c_getAL()
{
    half_word xal;    //pedantic method put in to check compiler correct etc...
    xal = a3_getAL();
    return(xal);
}

half_word c_getAH()
{
    half_word xah;
    xah = a3_getAH();
    return(xah);
}

word c_getAX()
{
    word xax;
    xax = a3_getAX();
    return(xax);
}

half_word c_getBL()
{
    half_word xbl;
    xbl = a3_getBL();
    return(xbl);
}

half_word c_getBH()
{
    half_word xbh;
    xbh = a3_getBH();
    return(xbh);
}

word c_getBP()
{
    word xbp;
    xbp = a3_getBP();
    return(xbp);
}

word c_getBX()
{
    word xbx;
    xbx = a3_getBX();
    return(xbx);
}

INT c_getCF()
{
    INT xcf;

    xcf = a3_getCF();
    return(xcf);
}

half_word c_getCH()
{
    half_word xch;
    xch = a3_getCH();
    return(xch);
}

half_word c_getCL()
{
    half_word xcl;
    xcl = a3_getCL();
    return(xcl);
}

word c_getCS()
{
    word xcs;
    xcs = a3_getCS();
    return(xcs);
}

word c_getCX()
{
    word xcx;
    xcx = a3_getCX();
    return(xcx);
}

half_word c_getDH()
{
    half_word xdh;
    xdh = a3_getDH();
    return(xdh);
}

word c_getDI()
{
    word xdi;
    xdi = a3_getDI();
    return(xdi);
}

half_word c_getDL()
{
    half_word xdl;
    xdl = a3_getDL();
    return(xdl);
}

word c_getDS()
{
    word xds;
    xds  = a3_getDS();
    return(xds);
}

word c_getDX()
{
    word xdx;
    xdx = a3_getDX();
    return(xdx);
}

word c_getES()
{
    word xes;
    xes = a3_getES();
    return(xes);
}

word c_getSI()
{
    word xsi;
    xsi = a3_getSI();
    return(xsi);
}

word c_getSP()
{
    word xsp;
    xsp = a3_getSP();
    return(xsp);
}

word c_getIP()
{
    word xip;
    xip = a3_getIP();
    return(xip);
}

word c_getSS()
{
    word xss;
    xss = a3_getSS();
    return(xss);
}

word c_getGS()
{
#ifndef PROD
    printf("NO NO NO NO NO getGS - I'm not a 386\n");
#endif
    return(0);
}

word c_getFS()
{
#ifndef PROD
    printf("NO NO NO NO NO getFS - I'm not a 386\n");
#endif
    return(0);
}

word c_getAF()
{
    return(a3_getAF());
}

word c_getDF()
{
    return(a3_getDF());
}

word c_getIF()
{
    return(a3_getIF());
}

word setMSW()
{
    return(a3_p_setMSW());
}

word c_getOF()
{
    return(a3_getOF());
}

word c_getPF()
{
    return(a3_getPF());
}

word c_getSF()
{
    return(a3_getSF());
}

word c_getZF()
{
    return(a3_getZF());
}
void c_setAL(val)
half_word val;
{
    a3_setAL(val);
}

void c_setAH(val)
half_word val;
{
    a3_setAH(val);
}

void c_setAX(val)
word val;
{
    a3_setAX(val);
}

void c_setBP(val)
word val;
{
    a3_setBP(val);
}

void c_setBL(val)
half_word val;
{
    a3_setBL(val);
}

void c_setBH(val)
half_word val;
{
    a3_setBH(val);
}

void c_setBX(val)
word val;
{
    a3_setBX(val);
}

void c_setCF(val)
INT val;
{
    a3_setCF(val);
}

void c_setCH(val)
half_word val;
{
    a3_setCH(val);
}

void c_setCL(val)
half_word val;
{
    a3_setCL(val);
}

void c_setCX(val)
word val;
{
    a3_setCX(val);
}

void c_setDH(val)
half_word val;
{
    a3_setDH(val);
}

void c_setDL(val)
half_word val;
{
    a3_setDL(val);
}

void c_setDX(val)
word val;
{
    a3_setDX(val);
}

void c_setSI(val)
word val;
{
    a3_setSI(val);
}

void c_setDI(val)
word val;
{
    a3_setDI(val);
}


void c_setAF(word val)
{
    a3_setAF(val);
}

void c_setIF(word val)
{
    a3_setIF(val);
}

void c_setOF(word val)
{
    a3_setOF(val);
}

void c_setPF(word val)
{
    a3_setPF(val);
}

void c_setSF(word val)
{
    a3_setSF(val);
}

void c_setMSW(word val)
{
    a3_p_setMSW(val);
}

void c_setZF(word val)
{
    a3_setZF(val);
}

void c_setIP(word val)
{
    a3_setIP(val);
}

void c_setDF(word val)
{
    a3_setDF(val);
}
void c_setSP(val)
word val;
{
    a3_setSP(val);
}

INT c_setSS(val)
word val;
{
    return(a3_setSS(val));
}

INT c_setES(val)
word val;
{
    return(a3_setES(val));
}

INT c_setDS(val)
word val;
{
    return(a3_setDS(val));
}

INT c_setCS(val)
word val;
{
    return(a3_setCS(val));
}

INT c_setGS(val)
word val;
{
#ifndef PROD
    printf("NO NO NO NO NO setGS - I'm not a 386\n");
#endif
    return(0);
}

INT c_setFS(val)
word val;
{
#ifndef PROD
    printf("NO NO NO NO NO setFS - I'm not a 386\n");
#endif
    return(0);
}
#endif /* CCPU */


// these two crept into WOW - they are x86 monitor'isms

word getEIP()
{
   return(a3_getIP());
}

void setEIP(val)
word  val;
{
    a3_setIP(val);
}

#endif	// A3CPU
#endif  // !MONITOR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\obj.vdm\imlibdep.c ===
//
// imlibdep.c  -- Dummy C file to include in SOURCES
//                so that build.exe will build ntvdm.lib
//                import library during compile pass,
//                ensuring MP builds don't break linking
//                wow32 or VDDs before ntvdm.lib is built
//                (in the link phase).
//

#if 0                 // build doesn't pay attention to this
#include "ntvdm.src"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\obj.vdm\ntvdm.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <vdm.h>
#include "insignia.h"
#include "host_def.h"
#include <stdlib.h>
#include "xt.h"
#include "error.h"
#include "host_rrr.h"
#include "host_nls.h"
#include "nt_timer.h"



void CpuEnvInit(void);

typedef struct _CpuEnvironmentVariable {
    struct _CpuEnvironmentVariable *Next;
    char *Data;
    char Name[1];
} CPUENVVAR, *PCPUENVVAR;

PCPUENVVAR CpuEnvVarListHead=NULL;

#if DBG
BOOLEAN verboseGetenv;
#endif


INT host_main(INT argc, CHAR **argv);  // located in base\support\main.c

__cdecl main(int argc, CHAR ** argv)
{
   int ret=-1;

    /*
     *  Intialize synchronization events for the timer\heartbeat
     *  so that we can always suspend the heartbeat when an exception
     *  occurs.
     */
    TimerInit();



    try {

        CpuEnvInit();

        /*
         *  Load in the default system error message, since a resource load
         *  will fail when we are out of memory, if this fails we must exit
         *  to avoid confusion.
         */
        nls_init();

        ret = host_main(argc, argv);
        }
    except(VdmUnhandledExceptionFilter(GetExceptionInformation())) {
        ;  // we shouldn't arrive here
        }

    return ret;
}






//
// The following function is placed here, so build will resolve references to
// DbgBreakPoint here, instead of NTDLL.
//

VOID
DbgBreakPoint(
    VOID
    )
/*++

Routine Description:

    This routine is a substitute for the NT DbgBreakPoint routine.
    If a user mode debugger is atached we invoke the real DbgBreakPoint()
    thru the win32 api DebugBreak.

    If no usermode debugger is attached:
       - free build no effect
       - checked build raise an acces violation to invoke the system
         hard error popup which will give user a chance to invoke
         ntsd.

Arguments:

    None.

Return Value:

    None.

--*/
{
HANDLE      MyDebugPort;
DWORD       dw;

         // are we being debugged ??
     dw = NtQueryInformationProcess(
                  NtCurrentProcess(),
                  ProcessDebugPort,
                  &MyDebugPort,
                  sizeof(MyDebugPort),
                  NULL );
     if (!NT_SUCCESS(dw) || MyDebugPort == NULL)  {
#ifndef PROD
           RaiseException(STATUS_ACCESS_VIOLATION, 0L, 0L, NULL);
#endif
           return;
          }

     DebugBreak();
}





/*
 *  Softpc env variables are mapped to the registry
 *
 *  "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\WOW\CpuEnv"
 *
 * The string values for the CpuEnv key are read at initialization
 * into the CpuEnv linked list. The Environment variables are defined
 * as string key values, where the name of the value is equivalent to
 * the Cpu Environment Variable name, and the string value is equivalent
 * to the value of the environment variable value. This allows the
 * emulator defaults to be overridden, by adding the appropriate value
 * to CpuEnv subkey. Under standard retail setup there won't normally
 * be a CpuEnv subkey, and NO cpu env variables defined to minimize
 * code\data on a standard retail system.
 *
 */



/*
 *  Adds a CpuEnv KEY_VALUE_FULL_INFORMATION to the CpuEnvList
 */
BOOLEAN
AddToCpuEnvList(
   PKEY_VALUE_FULL_INFORMATION KeyValueInfo
   )
{
   NTSTATUS Status;
   ULONG BufferSize;
   PCPUENVVAR CpuEnvVar;
   UNICODE_STRING UnicodeString;
   ANSI_STRING ValueName;
   ANSI_STRING ValueData;
   char NameBuffer[MAX_PATH+sizeof(WCHAR)];
   char DataBuffer[MAX_PATH+sizeof(WCHAR)];


   /*
    *  Convert Value Name and Data strings from unicode to ansi
    */

   ValueName.Buffer = NameBuffer;
   ValueName.MaximumLength = sizeof(NameBuffer) - sizeof(WCHAR);
   ValueName.Length        = 0;
   UnicodeString.Buffer = (PWSTR)KeyValueInfo->Name;
   UnicodeString.MaximumLength =
   UnicodeString.Length        = (USHORT)KeyValueInfo->NameLength;
   Status = RtlUnicodeStringToAnsiString(&ValueName, &UnicodeString,FALSE);
   if (!NT_SUCCESS(Status)) {
       return FALSE;
       }

   ValueData.Buffer = DataBuffer;
   ValueData.MaximumLength = sizeof(DataBuffer) - sizeof(WCHAR);
   ValueData.Length        = 0;
   UnicodeString.Buffer = (PWSTR)((PBYTE)KeyValueInfo + KeyValueInfo->DataOffset);
   UnicodeString.MaximumLength =
   UnicodeString.Length        = (USHORT)KeyValueInfo->DataLength;
   Status = RtlUnicodeStringToAnsiString(&ValueData, &UnicodeString, FALSE);
   if (!NT_SUCCESS(Status)) {
       return FALSE;
       }


   /*
    * Allocate CPUENVLIST structure, with space for the ansi strings
    */
   CpuEnvVar = malloc(sizeof(CPUENVVAR)+    // list structure size
                      ValueName.Length +    // strlen Name
                      ValueData.Length +    // strlen Data
                      1                     // Null for Data
                      );
   if (!CpuEnvVar) {
       return FALSE;
       }


   /*
    *  Copy in the ansi strings, and link it into CpuEnvVar List
    */
   memcpy(CpuEnvVar->Name, ValueName.Buffer, ValueName.Length);
   *(CpuEnvVar->Name + ValueName.Length) = '\0';
   CpuEnvVar->Data = CpuEnvVar->Name + ValueName.Length + 1;
   memcpy(CpuEnvVar->Data, ValueData.Buffer, ValueData.Length);
   *(CpuEnvVar->Data + ValueData.Length) = '\0';
   CpuEnvVar->Next = CpuEnvVarListHead;
   CpuEnvVarListHead = CpuEnvVar;

   return TRUE;
}




/*
 * Reads the CpuEnv values from the registry, into CpuEnvList
 */
void
CpuEnvInit(
   void
   )
{
    int Index;
    NTSTATUS Status;
    HANDLE CpuEnvKey = NULL;
    ULONG ResultLength;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PKEY_VALUE_FULL_INFORMATION KeyValueInfo;
    BYTE NameDataBuffer[sizeof(KEY_VALUE_FULL_INFORMATION) + MAX_PATH*2*sizeof(WCHAR)];




    //
    // Initialize TEB->Vdm to current version number
    //

    Index = (GetTickCount() << 16) | 0x80000000;
    Index |= sizeof(VDM_TIB) + sizeof(VDMVIRTUALICA) + sizeof(VDMICAUSERDATA);
    NtCurrentTeb()->Vdm = (PVOID)Index;

    KeyValueInfo = (PKEY_VALUE_FULL_INFORMATION) NameDataBuffer;

#ifndef MONITOR
/*
 *  BUGBUG temp hack code to add two env var, which aren't properly
 *  defaulted to in the risc cpu emulator
 *
 *  THIS is to be removed before SUR ship 19-Dec-1995 Jonle
 */
     {
     PWCHAR Data;

     wcscpy(KeyValueInfo->Name, L"Soft486Buffers");
     KeyValueInfo->NameLength = wcslen(KeyValueInfo->Name) * sizeof(WCHAR);
     Data = (PWCH)((PBYTE)KeyValueInfo->Name + KeyValueInfo->NameLength + sizeof(WCHAR));
     wcscpy(Data, L"511");
     KeyValueInfo->DataLength = wcslen(Data) * sizeof(WCHAR);
     KeyValueInfo->DataOffset =  (PBYTE)Data - (PBYTE)KeyValueInfo;
     AddToCpuEnvList(KeyValueInfo);

     wcscpy(KeyValueInfo->Name, L"LCIF_FILENAME");
     KeyValueInfo->NameLength = wcslen(KeyValueInfo->Name) * sizeof(WCHAR);
     Data = (PWCH)((PBYTE)KeyValueInfo->Name + KeyValueInfo->NameLength + sizeof(WCHAR));
     wcscpy(Data, L"R lcif");
     KeyValueInfo->DataLength = wcslen(Data) * sizeof(WCHAR);
     KeyValueInfo->DataOffset = (PBYTE)Data - (PBYTE)KeyValueInfo;
     AddToCpuEnvList(KeyValueInfo);
     }

#endif



    RtlInitUnicodeString(
        &UnicodeString,
        L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Wow\\CpuEnv"
        );

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               (HANDLE)NULL,
                               NULL
                               );

    Status = NtOpenKey(&CpuEnvKey,
                       KEY_READ,
                       &ObjectAttributes
                       );

    //
    // If there is no CpuEnv key, CpuEnvList is empty.
    //
    if (!NT_SUCCESS(Status)) {
        return;
        }

    Index = 0;
    while (TRUE) {
         Status = NtEnumerateValueKey(CpuEnvKey,
                                      Index,
                                      KeyValueFullInformation,
                                      KeyValueInfo,
                                      sizeof(NameDataBuffer),
                                      &ResultLength
                                      );

         if (!NT_SUCCESS(Status) || !AddToCpuEnvList(KeyValueInfo)) {
             break;
             }

       Index++;
       };

    NtClose(CpuEnvKey);

#if DBG
    {
    char *pEnvStr;
    pEnvStr = getenv("VERBOSE_GETENV");
    verboseGetenv = pEnvStr && !_stricmp(pEnvStr, "TRUE");
    }
#endif
}



/*
 * In order to catch all references, we define our own
 * version of the CRT getenv, which does the mapping.
 */
char * __cdecl getenv(const char *Name)
{
  PCPUENVVAR CpuEnvVar;
  char *Value = NULL;

  CpuEnvVar = CpuEnvVarListHead;
  while (CpuEnvVar) {
     if (!_stricmp(CpuEnvVar->Name, Name)) {
         Value = CpuEnvVar->Data;
         break;
         }
     CpuEnvVar = CpuEnvVar->Next;
     }

#if DBG
   if (verboseGetenv) {
       DbgPrint("getenv %s:<%s>\n", Name, Value);
       }
#endif

  return Value;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\roms\bios4.asm ===
;	SCCSID = @(#)uf.bios4.asm	1.10 7/3/95 Copyright Insignia Solutions Ltd.
;	Author:		J. Box	(copied from Williams xt original)
;			J. Kramskoy (added 1.disk parameter tables required for fixed disk.
;					   2.ROM BASIC entry point.
;					   3.Configuration parameters.)
;                       J. Koprowski (added two 2.88Mb Floppy table entries.)
;
;	Purpose:	
;			provides Intel AT BIOS
;
; DUE TO LIMITATIONS IN EXE2BIN, we define 
; the region 0 - 0xdfff (segment 0xf000) in file 'bios1.asm'
; and the region 0xe000 - 0xffff in this file 
;
; each file should be SEPARATELY put through
; MASM,LINK, and EXE2BIN to produce 2 binary image files
; which get loaded into the appropriate regions during
; SoftPC startup.
ORG2	MACRO	trueOffset
	ORG	trueOffset-0e000h
	ENDM

TRACE_BOP	MACRO	text
  LOCAL over_the_name
	BOP		0f8h
	jmp		SHORT over_the_name
	db		'&text&'
	db		10, 0
  over_the_name:
ENDM


	MODEL_BYTE		= 0fch
	SUB_MODEL_BYTE		= 1
	BIOS_LEVEL		= 0

; INT & BOP numbers
	BIOS_RESET 		= 0
	BIOS_PRINT_SCREEN	= 5
	BIOS_ILL_OP_INT		= 6
	BIOS_TIMER_INT		= 8
	BIOS_KB_INT 		= 9
	BIOS_DISK_INT 		= 0Dh
	BIOS_DISKETTE_INT	= 0Eh
	BIOS_VIDEO_IO		= 10h
	BIOS_EQUIPMENT		= 11h
	BIOS_MEMORY_SIZE	= 12h
	BIOS_DISK_IO 		= 13h
	BIOS_RS232_IO 		= 14h
	BIOS_CASSETTE_IO	= 15h
	BIOS_KEYBOARD_IO 	= 16h
	BIOS_PRINTER_IO		= 17h
	BIOS_ROM_BASIC		= 18h
	BIOS_BOOT_STRAP 	= 19h
	BIOS_TIME_OF_DAY	= 1Ah
	BIOS_KEYBOARD_BREAK	= 1Bh
	BIOS_USER_TIMER 	= 1Ch
	BIOS_IDLE_POLL	 	= 1Dh
	BIOS_DISKETTE_IO 	= 40h

; BOPs
	BIOS_BOOTSTRAP_1 	= 90h
	BIOS_BOOTSTRAP_2 	= 91h
	BIOS_BOOTSTRAP_3 	= 92h

	BIOS_FL_OPERATION_1 	= 0A0h
	BIOS_FL_OPERATION_2 	= 0A1h
	BIOS_FL_OPERATION_3 	= 0A2h
	BIOS_FL_RESET_2 	= 0A3h


	BIOS_MOUSE_INT1		= 0BAh
	BIOS_MOUSE_INT2		= 0BBh
	BIOS_MOUSE_IO_LANGUAGE	= 0BCh
	BIOS_MOUSE_IO_INTERRUPT	= 0BDh
	BIOS_MOUSE_VIDEO_IO	= 0BEh

	BIOS_CPU_QUIT		= 0FEh

; addresses
	DOS_SEGMENT			= 0
	DOS_OFFSET			= 7C00h

	BIOS_ROM_SEGMENT		= 0f000h
	DUMMY_INT_OFFSET		= 0FF4Bh
	
	BIOS_PASTE_OFFSET		= 0FF4Ch

	KB_INT_OFFSET			= 0E987h
	KEYBOARD_IO_OFFSET		= 0E82Eh
	RCPU_POLL_OFFSET		= 0e850h
	RCPU_NOP_OFFSET			= 0e950h
	RCPU_INT15_OFFSET		= 0e970h
	RCPU_WAIT_INT_OFFSET		= 00CE0h
	CASSETTE_IO_OFFSET		= 0F859h
	TIMER_INT_OFFSET		= 0FEA5h
	OLD_TIMER_INT_OFFSET		= 0FF00h
	ILL_OP_INT_OFFSET		= 0FF30h
	KEYBOARD_BREAK_INT_OFFSET	= 0FF35h
	PRINT_SCREEN_INT_OFFSET		= 0FF3Bh
	USER_TIMER_INT_OFFSET		= 0FF41h
	RESET_OFFSET			= 0E05Bh
	START_OFFSET			= 0FFF0h
	PRINTER_IO_OFFSET		= 0EFD2h


; useful stuff
	CR			= 0Dh
	LF			= 0Ah

; keyboard constants
; bits in kb_flag
	RIGHT_SHIFT = 1
	LEFT_SHIFT = 2
	CTL_SHIFT = 4
	ALT_SHIFT = 8
	
	

; bit in kb_flag_1
	HOLD_STATE = 8
	SCROLL_SHIFT = 10h
	NUM_SHIFT = 20h
	CAPS_SHIFT = 40h
	INS_SHIFT = 80h

; IBM scan codes
	CTL_KEY = 29
	LEFT_SHIFTKEY = 42
	RIGHT_SHIFTKEY = 54
	ALT_KEY = 56
	CAPS_KEY = 58
	NUM_KEY = 69
	SCROLL_KEY = 70
	INS_KEY = 82	

; CMOS registers
	CMOS_addr	= 070h
	CMOS_data	= 071h
	NMI_DISABLE	= 080h
	CMOS_StatusA	= NMI_DISABLE + 0Ah 
	CMOS_StatusB	= NMI_DISABLE + 0Bh
	CMOS_StatusC	= NMI_DISABLE + 0Ch
	CMOS_Shutdown	= 0Fh
; CMOS constants (bits in StatusB or StatusC)
	CMOS_PI		= 01000000b	; Periodic interrupt
	CMOS_AI		= 00100000b	; Alarm interrupt
; microseconds at 1024Hz
	CMOS_PERIOD_USECS = 976

; ICA registers
	ICA_MASTER_CMD	= 020h
	ICA_MASTER_IMR	= 021h
	ICA_SLAVE_CMD	= 0A0h
	ICA_SLAVE_IMR	= 0A1h
; and commands
	ICA_EOI		= 020h

; BIOS variables area
BIOS_VAR_SEGMENT	SEGMENT at 40h

	ORG	17h

kb_flag			DB	?	; 17
kb_flag_1		DB	?	; 18

	ORG	03fh

MOTOR_STATUS		DB	?	; 3f
MOTOR_COUNT		DB	?	; 40

	ORG	06ch
TIMER_COUNT		DD	?	; 6c
TIMER_OVFL		DB	?	; 70

	ORG	098h
rtc_user_flag		DD	?	; 98
rtc_micro_secs		DD	?	; 9c
rtc_wait_flag		DB	?	; a0

BIOS_VAR_SEGMENT	ENDS

;  Segment we jump to after booting
DOS_seg	SEGMENT at DOS_SEGMENT
	ORG DOS_OFFSET
	DOS_boot	LABEL FAR
DOS_seg	ENDS

; To keep the binary file down to a sensible size, the code segment
; is at fe00 instead of f000. Far jumps are correctly assembled by
; using a second 'fake' segment, that just contains labels, and DOES
; start at f000.
ref	SEGMENT at 0F000h
;
;	NB. the following addresses are allocated to SUN for DOS Windows 3.0.
;	They are not to be used by anyone else.
;	THIS AREA IS SUN PROPERTY - TRESPASSERS WILL BE PROSECUTED 
;	However please note that only the ranges below are reserved.
;	Bios2 gets loaded at 0xfe00, so the following does not have any real
;	effect other than to act as a warning.
; 
	ORG 0
	sunroms_1	LABEL	FAR 
	db	1024 dup (0)	; reserved
	ORG 04000h
	sunroms_2	LABEL	FAR
	db	512 dup (0)	; reserved
	ORG 05000h
	sunroms_3	LABEL	FAR
	db	512 dup (0)	; reserved
;
;	BACK TO INSIGNIA
;
	ORG		RESET_OFFSET
	reset_ref	LABEL	FAR; Must match reset
ref	ENDS

code	SEGMENT 
	ASSUME cs:code,ds:BIOS_VAR_SEGMENT
	ORG 0
copyright:
ifndef SOFTWINDOWS
	DB "4504512 SoftPC 4.00 (C)Copyright Insignia Solutions Inc. 1995"
else
	DB "4504512 SoftWindows 2 (C)Copyright Insignia Solutions Inc. 1995"
endif	; SOFTWINDOWS

include bebop.inc


	ORG	40h
	DB	00h, 01h	; rom serial number
	
	ORG 5Bh
reset	LABEL FAR	; Must match reset_ref
	BOP %BIOS_RESET
	PRINT_MESSAGES
	INT 19h


	; space to insert customer specific startup message
	ORG	80h
oem_msg:
	DB "                                                                                "
	ORG	100h
serial_number:
	DB	"(c) Insignia Inc"
	DB	15h, 3eh, 5fh, 20h
	; this is a cunning encryption, do not change at all

	ORG	150h
hfx_ifs_hdr:
	DB	0ffh, 0ffh, 0ffh, 0ffh
	DB	"HFXREDIR"
	DB	00h, 02ch
	DB	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h
	; this is a fake IFS header to make DOS 4.01
	; happy with HFX. Do not move/alter.

;
; Special host_unsimulate BOP to enable DEC code to do an IRET to this
; location.  In this way SoftPC can crunch some Intel and DEC can use
; the same code that works on PCs, i.e. they don't need to change the IRET
; instructions.
;
	ORG 170h
pcsa:
	INT 72h
	BOP BIOS_CPU_QUIT

signatures:
	DB CR,LF
;
; signatures removed because Microsoft don't like to find Insignia credits.
;
	ORG 401h

; 23/7/93 MG WinSleuth must have the first two entries of the standard PC
;	     BIOS at the beginning of the table, otherwise it will fall
;	     over !

disktab:

; Drive Type 1

	dw	0306
	db	04
	dw	0
	dw	0128
	db	0
	db	0
	db	0,0,0
	dw	0305
	db	17
	db	0

; Drive Type 2

	dw	615
	db	4
	dw	0
	dw	300
	db	0
	db	0
	db	0,0,0
	dw	615
	db	17
	db	0

; Drive Type 3

	dw 	0	; DISK PARAMETER BLOCK for drive type 3 (Our C: drive ALWAYS)
			; (the #.of cylinders available gets patched in by fdisk_ioattach()
			;  in fdisk.c)
	db	4	; 4 heads (for now)
	db	11 dup (0)
	db	17	; 17 sectors per track
	db	0

; Drive Type 4

	dw 	0	; DISK PARAMETER BLOCK for drive type 4 (Our D: drive
			; (if configured))
	db	4	; 4 heads (for now)
	db	11 dup (0)
	db	17	; 17 sectors per track
	db	0
			; 45 unused blocks
	db	45*16 dup (0)

	ORG 06F2h
boot_strap:
	jmp boot_strap_1

	ORG 06f5h
			; CONFIGURATION PARAMETERS as defined in '86 BIOS.
			; used for cassette i/o function
conf_table:
	db	8		; length of following table
	db	0		; Pad on length above
	db	MODEL_BYTE	; system model byte
	db	SUB_MODEL_BYTE	; system model type
	db	BIOS_LEVEL	; bios revision level
	db	70h		; 80 = DMA channel 3 used by bios
	  			; 40 = cascaded interrupt level 2
	  			; 20 = real time clock available
	  			; 10 = kybd scan code hook 1Ah
	db	4 dup (0)	; reserved


	org 0700h
boot_strap_1:
	BOP BIOS_BOOT_STRAP
	INT BIOS_DISK_IO
	BOP BIOS_BOOTSTRAP_1
	INT BIOS_DISK_IO
	BOP BIOS_BOOTSTRAP_2
	INT BIOS_DISK_IO
	BOP BIOS_BOOTSTRAP_3
	JMP DOS_boot	; To MessyDOS

	ORG 0739h
rs232_io:
	BOP BIOS_RS232_IO
	IRET

	ORG2	KEYBOARD_IO_OFFSET
keyboard_io:
 	CMP AH, 1	; Is it a "test if char available" call ?
 	JZ nerd         ; if so - to the nerd
 	CMP AH, 11h	; Is it a "extended test if char available" call ?
 	JZ nerd         ; if so - to the nerd

 	BOP BIOS_KEYBOARD_IO	; call BIOS keyboard function
 	IRET		; Int return, restoring old status flags
nerd:
	BOP BIOS_KEYBOARD_IO	; call BIOS keyboard function
	RETF 2		; Return without trampling on the status flags
	

      ; loop to wait for a keyboard int - called as a  recursive CPU
	ORG2	RCPU_POLL_OFFSET
	sti
	push	ds
	mov	ax,BIOS_VAR_SEGMENT
	mov	ds,ax
kw1:	bop	%BIOS_IDLE_POLL
	mov	ax,WORD PTR DS:[1ah]	; bios kb buffer head
	cmp	ax,WORD PTR DS:[1ch]	; bios kb buffer tail
	jz	kw1
	pop	ds
	bop	%BIOS_CPU_QUIT

	ORG 087Eh
shift_keys:
	DB INS_KEY,CAPS_KEY,NUM_KEY,SCROLL_KEY
	DB ALT_KEY,CTL_KEY,LEFT_SHIFTKEY,RIGHT_SHIFTKEY; K6 
shift_masks:
	DB INS_SHIFT,CAPS_SHIFT,NUM_SHIFT,SCROLL_SHIFT
	DB ALT_SHIFT,CTL_SHIFT,LEFT_SHIFT,RIGHT_SHIFT; K7
ctl_n_table:
	DB  27,  -1,   0,  -1,  -1,  -1,  30,  -1
	DB  -1,  -1,  -1,  31,  -1, 127, 148,  17
	DB  23,   5,  18,  20,  25,  21,   9,  15
	DB  16,  27,  29,  10,  -1,   1,  19,   4
	DB   6,   7,   8,  10,  11,  12,  -1,  -1
	DB  -1,  -1,  28,  26,  24,   3,  22,   2
	DB  14,  13,  -1,  -1,  -1,  -1, 150,  -1
	DB ' ',  -1;	 K8 
ctl_f_table:
	DB  94,  95,  96,  97,  98,  99, 100, 101
	DB 102, 103,  -1,  -1, 119, 141, 132, 142
	DB 115, 143, 116, 144, 117, 145, 118, 146
	DB 147,  -1,  -1,  -1, 137, 138;	 K9 
lowercase:
	DB  27, '1', '2', '3', '4', '5', '6', '7', '8', '9'
	DB '0', '-', '=',   8,   9, 'q', 'w', 'e', 'r', 't'
	DB 'y', 'u', 'i', 'o', 'p', '[', ']',  13, -1,  'a'
	DB 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';',  39
	DB  96,  -1,  92, 'z', 'x', 'c', 'v', 'b', 'n', 'm'
	DB ',', '.', '/',  -1, '*',  -1, ' ',  -1;  K10
lc_tbl_scan:
	DB  59,  60,  61,  62,  63,  64,  65,  66,  67,  68
	DB  -1,  -1
base_case:
	DB  71,  72,  73,  -1,  75,  -1,  77,  -1,  79,  80,  81,  82,  83 
	DB  -1,  -1,  92, 133, 134;	K15

	ORG 0940h
kb_int_1:
	sti
	push	   ax
 	bop        %BIOS_KB_INT
	pop	   ax
        iret

;	intel instructions for recursive CPU to read keyboard interrupts
;	this is used something like this:
;		while(!somecondition)
;			host_simulate();
;	or
;		while((!somecondition)&&(!timout())
;			host_simulate();
;	The conditions can only be met by something (like a keyboard event)
;	in the real world being put on the event queue and being processed.
;	BUT
;	we only process events when timer ticks go off, which only happens
;	if the CPU executes for >20ms. So we sit in a loop waiting.
;	We could exit the intel code on a particular flag, but to make this
;	code less specific, we exit when the low order timer byte changes
;	(Eg a timer tick has gone off). The C calling code from the base
;	therefore
;	a) does the real checking to see if conditions are met.
;	b) doesn't need changing in a host specific manner.
;
;	We can't just sit in C code waiting for keyboard events because then
;	timer specific stuff (comms etc) wouldn't happen.
;	We can't just do a short call to the recursive CPU because
;	the API for timer ticks won't handle it well, Eg if we just say
;		NOP
;		NOP
;		BOP %BIOS_CPU_QUIT
; 	the recursive CPU doesn't execute long enough for the timer tick
;	to go off.

	ORG2	RCPU_NOP_OFFSET	; this just allows the CPU to handle an interrupt
	sti
	push ax
	push es
	mov ax,0
	mov es,ax
	mov ax,es:[46ch]	; read low order timer byte from 0x46c
L1:	cmp ax,es:[46ch]	; if its changed exit from recursive cpu
	je L1
	pop es
	pop ax
	bop	%BIOS_CPU_QUIT

	ORG2	RCPU_INT15_OFFSET	; this specifically calls INT15
	int	15h
	jmp	w1
w3:	bop	%BIOS_CPU_QUIT
w2:	jmp	w3
w1:	jmp	w2

	ORG2	KB_INT_OFFSET
	jmp	kb_int_1

	ORG 098Ah
uppercase:
	DB  27, '!', '@', '#', '$', '%', '^', '&', '*', '('
	DB ')', '_', '+',   8,   0, 'Q', 'W', 'E', 'R', 'T'
	DB 'Y', 'U', 'I', 'O', 'P', '{', '}',  13,  -1, 'A'
	DB 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ':', '"'
	DB 126,  -1, '|', 'Z', 'X', 'C', 'V', 'B', 'N', 'M'
	DB '<', '>', '?',  -1,   0,  -1, ' ',  -1;	K11 
ucase_scan:
	DB  84,  85,  86,  87,  88,  89,  90,  91,  92,  93
	DB  -1,  -1
num_state:
	DB '7', '8', '9', '-', '4', '5', '6', '+', '1', '2', '3', '0', '.'
	DB  -1,  -1, 124, 135, 136;	K14

	ORG 0A87h
alt_table:
	DB 82,  79,  80,  81,  75,  76,  77,  71,  72,  73
	DB 16,  17,  18,  19,  20,  21,  22,  23,  24,  25
	DB 30,  31,  32,  33,  34,  35,  36,  37,  38,  44
	DB 45,  46,  47,  48,  49,  50	;  K30

	; definitions used in diskette BIOS
	MOTOR_WAIT =		25h
	WRONG_MEDIA = 		80h
	RS_500 = 		00h
	RS_300 = 		40h
	RS_250 = 		80h
	RS_1000 =               0C0h


	ORG 0C00h
rom_basic:
	BOP %BIOS_ROM_BASIC
	IRET

	ORG 0C49h
diskette_io:
	BOP %BIOS_DISKETTE_IO				
	RETF 2			; exit, keeping flags   

	ORG 0C50h
dr_type:
	DB	01
	DW	OFFSET md_tbl1
	DB	02 + WRONG_MEDIA
	DW	OFFSET md_tbl2
	DB	02
	DW	OFFSET md_tbl3
	DB	03
	DW	OFFSET md_tbl4
	DB	04 + WRONG_MEDIA
	DW	OFFSET md_tbl5
	DB	04
	DW	OFFSET md_tbl6
	DB      05 + WRONG_MEDIA
	DW      OFFSET md_tbl7
	DB      05 + WRONG_MEDIA
	DW      OFFSET md_tbl8
	DB      05
	DW      OFFSET md_tbl9

	ORG     0C6Bh
md_tbl1:
	; MEDIA = 40 track low data rate; DRIVE = 40 track low data rate
	DB 0DFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB MOTOR_WAIT	; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 9		; sectors/track
	DB 02Ah		; gap length
	DB 0FFh		; data length
	DB 050h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 39		; maximum track number
	DB RS_250	; transfer rate

	ORG     0C78h
md_tbl2:
	; MEDIA = 40 track low data rate; DRIVE = 80 track high data rate
	DB 0DFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB MOTOR_WAIT	; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 9		; sectors/track
	DB 02Ah		; gap length
	DB 0FFh		; data length
	DB 050h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 39		; maximum track number
	DB RS_300	; transfer rate

	ORG     0C85h
md_tbl3:
	; MEDIA = 80 track high data rate; DRIVE = 80 track high data rate
	DB 0DFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB MOTOR_WAIT	; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 15		; sectors/track
	DB 01Bh		; gap length
	DB 0FFh		; data length
	DB 054h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 79		; maximum track number
	DB RS_500	; transfer rate

	ORG     0C92h
md_tbl4:
	; MEDIA = 80 track low data rate; DRIVE = 80 track low data rate
	DB 0DFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB MOTOR_WAIT	; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 9		; sectors/track
	DB 02Ah		; gap length
	DB 0FFh		; data length
	DB 050h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 79		; maximum track number
	DB RS_250	; transfer rate

	ORG     0C9Fh
md_tbl5:
	; MEDIA = 80 track low data rate; DRIVE = 80 track high data rate
	DB 0DFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB MOTOR_WAIT	; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 9		; sectors/track
	DB 02Ah		; gap length
	DB 0FFh		; data length
	DB 050h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 79		; maximum track number
	DB RS_250	; transfer rate

	ORG     0CACh
md_tbl6:
	; MEDIA = 80 track high data rate; DRIVE = 80 track high data rate
	DB 0AFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB MOTOR_WAIT	; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 18		; sectors/track
	DB 01Bh		; gap length
	DB 0FFh		; data length
	DB 06Ch		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 79		; maximum track number
	DB RS_500	; transfer rate

	; new for 2.88M floppies
	ORG     0CB9h
md_tbl7:
	; MEDIA = 80 track low data rate; DRIVE = 80 track ext data rate
	DB 0AFh
	DB 2            ; 2nd specify byte (guessed from 1.4)
	DB MOTOR_WAIT   ; motor wait time
	DB 2            ; ie 2 bytes/sector
	DB 9            ; sectors/track
	DB 01Bh         ; gap length
	DB 0FFh         ; data length
	DB 053h         ; gap length for format
	DB 0F6h         ; fill byte for format
	DB 15           ; head settle time/ms
	DB 8            ; ie 1s motor start time
	DB 79           ; maximum track number
	DB RS_250	; transfer rate (guessed from 1.4)

	ORG     0CC6h
md_tbl8:
	; MEDIA = 80 track high data rate; DRIVE = 80 track ext data rate
	DB 0AFh
	DB 2            ; 2nd specify byte (guessed from 1.4)
	DB MOTOR_WAIT   ; motor wait time
	DB 2            ; ie 2 bytes/sector
	DB 18           ; sectors/track
	DB 01Bh         ; gap length
	DB 0FFh         ; data length
	DB 053h         ; gap length for format
	DB 0F6h         ; fill byte for format
	DB 15           ; head settle time/ms
	DB 8            ; ie 1s motor start time
	DB 79           ; maximum track number
	DB RS_500	; transfer rate (guessed from 1.4)

	ORG     0CD3h
md_tbl9:
	; MEDIA = 80 track ext data rate; DRIVE = 80 track ext data rate
	DB 0AFh         ; 1st specify byte (guessed from 1.4)
	DB 2            ; 2nd specify byte (guessed from 1.4)
	DB MOTOR_WAIT   ; motor wait time
	DB 2            ; ie 2 bytes/sector
	DB 36           ; sectors/track
	DB 01Bh         ; gap length
	DB 0FFh         ; data length
	DB 053h         ; gap length for format
	DB 0F6h         ; fill byte for format
	DB 15           ; head settle time/ms
	DB 8            ; ie 1s motor start time
	DB 79           ; maximum track number
	DB RS_1000	; transfer rate (guessed from 1.4)

	ORG	RCPU_WAIT_INT_OFFSET
wait_int:
	PUSH	DS
	PUSH	CX
	MOV	CX, BIOS_VAR_SEGMENT
	MOV	DS, CX
	MOV	CX, 0100H ; sufficient to take multiple interrupts
wait_int_0:
	TEST	byte ptr DS:[3EH], 80h
	LOOPZ	wait_int_0
	POP	CX
	POP	DS
	BOP	%BIOS_CPU_QUIT

	ORG 0D00h
mouse_io:
	JMP hopover
	BOP %BIOS_MOUSE_IO_LANGUAGE
	RETF 8
hopover:
	BOP %BIOS_MOUSE_IO_INTERRUPT
	IRET

	ORG 0D20h
mouse_version:			; dummy, for compatibility
	DB 042h,042h,00h,00h

	ORG 0D40h
mouse_copyright:		; dummy, for compatibility
	DB "Copyright 1987 Insignia Solutions Inc"

	ORG 0D80h
mouse_video_io:
	BOP %BIOS_MOUSE_VIDEO_IO
	IRET

	ORG 0E00h
mouse_int1:
	BOP %BIOS_MOUSE_INT1
	IRET

	ORG 0E80h
mouse_int2:
	BOP %BIOS_MOUSE_INT2
	IRET

	ORG 0F57h
diskette_int:
	BOP %BIOS_DISKETTE_INT
	IRET

	ORG 0FC7h
disk_base:
	DB 0CFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB MOTOR_WAIT	; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 18		; sectors/track
	DB 02Ah		; gap length
	DB 0FFh		; data length
	DB 050h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 25		; head settle time/ms
	DB 4		; ie 1/2s motor start time

	ORG2	PRINTER_IO_OFFSET
printer_io:
	BOP %BIOS_PRINTER_IO
	IRET

	ORG 1065h
video_io:
	BOP %BIOS_VIDEO_IO
	IRET

	ORG 106ch
	INT 10h		; allows video handler to be recursive
	BOP %BIOS_CPU_QUIT

	ORG 10A4h
vid_parm_setup:
	; 40*25
	DB 038h, 028h, 02Dh, 0Ah, 01Fh, 6, 019h, 01Ch,2,  7,  6,  7,0,0,0,0
	; 80*25						   
	DB 071h, 050h, 05Ah, 0Ah, 01Fh, 6, 019h, 01Ch,2,  7,  6,  7,0,0,0,0
	; graphics						      	     
	DB 038h, 028h, 02Dh, 0Ah, 07Fh, 6, 064h, 070h,2,  1,  6,  7,0,0,0,0
	; 80*25 BW							
	DB 061h, 050h, 052h, 0Fh, 019h, 6, 019h, 019h,2,0Dh,0Bh,0Ch,0,0,0,0
vid_len_setup:
	DW 2048	; 40*25 screen size
	DW 4096	; 80*25 screen size
	DW 16384; graphics
	DW 16384; graphics
vid_col_setup:
	DB  40,  40,  80 , 80,  40,  40,  80, 80	; screen columns
vid_mode_setup:
	DB 2Ch, 28h, 2Dh, 29h, 2Ah, 2Eh, 1Eh, 29h	;mode register?

	ORG 1841h
memory_size:
	BOP %BIOS_MEMORY_SIZE
	IRET

	ORG 184Dh
equipment:
	BOP %BIOS_EQUIPMENT
	IRET

;;=======================================================================
;; INT 15h	"Cassette IO" e.g. miscellaneous functions
;;

		ORG2	CASSETTE_IO_OFFSET
cassette_io:
		sti
		cmp	ah, 4fh ; Check frequent case (keyboard) first
		jne	int15_not_kb
		mov	ah, 86h	; AH = INVALID option code
int15_fail:	stc		; CF = 1, implies not OK
		retf	2


; Int 15h function 83h (other than the frequent kb enquiry)
;
int15_not_kb:	cmp	ah, 83h	; INT15_EVENT_WAIT
		je	int15_83
		cmp	ah, 86h	; INT15_WAIT
		.386
		je	int15_86
		cmp	ah, 89h	; switch to protected mode
		je	int15_89
		.286

	;; Handle other cases in tape_io.c

		or	ax, ax	; clear CF
		bop	%BIOS_CASSETTE_IO
		retf	2


; Int 15h function 83h
;
;  Change bit7 of byte at es:[bx] when cx::dx micro-seconds has passed.
;
int15_83:	cmp	al, 0
		jnz	int15_83_stop

		push	ds
		mov	ax, BIOS_VAR_SEGMENT
		mov	ds, ax		; load up DS to point to BIOS data

		test	rtc_wait_flag, 1	; Test timer-in-use ?
		jnz	int15_83_inuse

	;; Set up address of user's flag byte

		mov	word ptr ds:[rtc_user_flag], bx
		mov	word ptr ds:[rtc_user_flag+2], es

	;; Save mSec count to decrement

		mov	word ptr ds:[rtc_micro_secs], dx
		mov	word ptr ds:[rtc_micro_secs+2], cx

	;; Produce a trace message if time "large", i.e. > 1,000,000 uS

		cmp	cx, 0Fh		; 1000000. == 000F4240
		jb	int15_83_small
		TRACE_BOP	<int15/83: #cx #dx>
int15_83_small:

	;; Program the RTC to periodically interrupt at 1024Hz		

		cli

	;; Make sure PIC line for RTC is not masked

		in	al, ICA_SLAVE_IMR
		and	al, 11111110b	; RTC is slave line 0
		out	ICA_SLAVE_IMR, al

	;; Set time-of-day to 32768 Hz and periodic frequency 1024 Hz

		mov	al, CMOS_StatusA
		out	CMOS_addr, al
		mov	al, 00100110b
		out	CMOS_data, al

	;; Enable PI interrupt in CMOS

		mov	al, CMOS_StatusB
		out	CMOS_addr, al
		in	al, CMOS_data		
		or	al, 01000000b	; Enable PI interrupt
		out	CMOS_data, al

	;; Mark timer-in-use flag active

		mov	rtc_wait_flag, 1; Show wait is active

	;; All OK, return, enabling interrupts

		pop	ds
		xor	ah, ah		; AH = 0, CF = OK
		sti
		retf	2

int15_83_stop:	cli

	;; Disable PI interrupt in CMOS

		mov	al, CMOS_StatusB
		out	CMOS_addr, al
		in	al, CMOS_data		
		and	al, 10111111b	; Disable PI interrupt
		out	CMOS_data, al

	;; Clear the in-use flag, undocumented PC notes that
	;; things will go horribly wrong if this call is used
	;; at the wrong time!

		mov	rtc_wait_flag, 0

		sti
		xor	ax, ax		; and CF=0		
		retf	2

int15_83_inuse:	pop	ds
		jmp	int15_fail

;
; Int 15h function 86h
; Wait given number of uSeconds. Quick events will change
; rtc_wait_flag when done...
;
int15_86:	push	ds
		push	es
		push	bx
		mov	ax, BIOS_VAR_SEGMENT
		mov	ds, ax		; load up DS to point to BIOS data

	;; We use the INT 15/83 function to update our rtc_wait_flag
	;; when the requested number of micro-seconds has elapsed

		mov	bx, OFFSET rtc_wait_flag
		mov	ax, BIOS_VAR_SEGMENT
		mov	es, ax

		mov	ax, 8300h
		push	ax			; Push fake flags
		push	cs
		call	int15_83		; Do INT15/83
		jc	int15_86_inuse		; Wait not available


	;; Loop until rtc interrupt routine updates bit7 of
	;; our supplied user flag.

int15_wait:	test	rtc_wait_flag, 080h	; check for end of wait
		jz	int15_wait

	;; Clear the in-use flag

		mov	rtc_wait_flag, 0

	;; And return CF=0 (from test) to show completed OK

		pop	bx
		pop	es
		pop	ds
		retf	2

	;; Error exit, return with CF=1 (from jc)

int15_86_inuse:	pop	bx
		pop	es
		pop	ds
		retf	2

;
; Int 15h function 89h
; Switch to virtual (protected) mode
; See At Tech ref BIOS1 listing (11/15/85) p 5-173 and following
;
int15_89:
	BOP	%BIOS_CASSETTE_IO	           	; handles ica and a20 line
	jc	int15_89_exit				; no prot mode
	MOV	word ptr [SI+38h],0ffffh              ; seg limit
	MOV	byte ptr [SI+3ch],0fh                 ; cs seg hi
	MOV	word ptr [SI+3ah],0                   ; cs seg lo
	MOV	byte ptr [SI+3dh],10011011b           ; cpl0 code access code
	MOV	word ptr [SI+3eh],0                   ; reserved
	;LGDT   [SI+8]
	DB	0fh,1,54h,8
	;LIDT   [SI+16]
	DB	0fh,1,5ch,16
	MOV	AX,1
	;LMSW   AX
	DB	0fh,1,0f0h
	DB	0eah
; jump far to prot cs:vmode...
	DW	offset vmode+0e000h
	DW	38h
vmode:
	MOV	AX,18h
	MOV	DS,AX
	MOV	AX,20h
	MOV	ES,AX
	MOV	AX,28h
	MOV	SS,AX
	POP	BX			; get return address
	ADD	SP,4			; get rid of cs and flags
	db	6ah,30h			; push new (prot mode) cs
	PUSH    BX			; push return offset
	RETF

int15_89_exit:
	retf	2


ifndef GISP_SVGA
	ORG 1A6Eh
crt_char_gen:
	DB 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h ;  /* 0 */
	DB 07Eh, 081h, 0A5h, 081h, 0BDh, 099h, 081h, 07Eh ;  /* 1 */
	DB 07Eh, 0FFh, 0DBh, 0FFh, 0C3h, 0E7h, 0FFh, 07Eh ;  /* 2 */
	DB 06Ch, 0FEh, 0FEh, 0FEh, 07Ch, 038h, 010h, 000h ;  /* 3 */
	DB 010h, 038h, 07Ch, 0FEh, 07Ch, 038h, 010h, 000h ;  /* 4 */
	DB 038h, 07Ch, 038h, 0FEh, 0FEh, 07Ch, 038h, 07Ch ;  /* 5 */
	DB 010h, 010h, 038h, 07Ch, 0FEh, 07Ch, 038h, 07Ch ;  /* 6 */
	DB 000h, 000h, 018h, 03Ch, 03Ch, 018h, 000h, 000h ;  /* 7 */
	DB 0FFh, 0FFh, 0E7h, 0C3h, 0C3h, 0E7h, 0FFh, 0FFh ;  /* 8 */
	DB 000h, 03Ch, 066h, 042h, 042h, 066h, 03Ch, 000h ;  /* 9 */
	DB 0FFh, 0C3h, 099h, 0BDh, 0BDh, 099h, 0C3h, 0FFh ;  /* 10 */
	DB 00Fh, 007h, 00Fh, 07Dh, 0CCh, 0CCh, 0CCh, 078h ;  /* 11 */
	DB 03Ch, 066h, 066h, 066h, 03Ch, 018h, 07Eh, 018h ;  /* 12 */
	DB 03Fh, 033h, 03Fh, 030h, 030h, 030h, 070h, 0F0h ;  /* 13 */
	DB 07Fh, 063h, 07Fh, 063h, 063h, 067h, 0E6h, 0C0h ;  /* 14 */
	DB 099h, 05Ah, 03Ch, 0E7h, 0E7h, 03Ch, 05Ah, 099h ;  /* 15 */
	DB 080h, 0E0h, 0F8h, 0FEh, 0F8h, 0E0h, 080h, 000h ;  /* 16 */
	DB 002h, 00Eh, 03Eh, 0FEh, 03Eh, 00Eh, 002h, 000h ;  /* 17 */
	DB 018h, 03Ch, 07Eh, 018h, 018h, 07Eh, 03Ch, 018h ;  /* 18 */
	DB 066h, 066h, 066h, 066h, 066h, 000h, 066h, 000h ;  /* 19 */
	DB 07Fh, 0DBh, 0DBh, 07Bh, 01Bh, 01Bh, 01Bh, 000h ;  /* 20 */
	DB 03Eh, 063h, 038h, 06Ch, 06Ch, 038h, 0CCh, 078h ;  /* 21 */
	DB 000h, 000h, 000h, 000h, 07Eh, 07Eh, 07Eh, 000h ;  /* 22 */
	DB 018h, 03Ch, 07Eh, 018h, 07Eh, 03Ch, 018h, 0FFh ;  /* 23 */
	DB 018h, 03Ch, 07Eh, 018h, 018h, 018h, 018h, 000h ;  /* 24 */
	DB 018h, 018h, 018h, 018h, 07Eh, 03Ch, 018h, 000h ;  /* 25 */
	DB 000h, 018h, 00Ch, 0FEh, 00Ch, 018h, 000h, 000h ;  /* 26 */
	DB 000h, 030h, 060h, 0FEh, 060h, 030h, 000h, 000h ;  /* 27 */
	DB 000h, 000h, 0C0h, 0C0h, 0C0h, 0FEh, 000h, 000h ;  /* 28 */
	DB 000h, 024h, 066h, 0FFh, 066h, 024h, 000h, 000h ;  /* 29 */
	DB 000h, 018h, 03Ch, 07Eh, 0FFh, 0FFh, 000h, 000h ;  /* 30 */
	DB 000h, 0FFh, 0FFh, 07Eh, 03Ch, 018h, 000h, 000h ;  /* 31 */
	DB 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h ;  /* space */
	DB 030h, 078h, 078h, 030h, 030h, 000h, 030h, 000h ;  /* ! */
	DB 06Ch, 06Ch, 06Ch, 000h, 000h, 000h, 000h, 000h ;  /* " */
	DB 06Ch, 06Ch, 0FEh, 06Ch, 0FEh, 06Ch, 06Ch, 000h ;  /* # */
	DB 030h, 07Ch, 0C0h, 078h, 00Ch, 0F8h, 030h, 000h ;  /* $ */
	DB 000h, 0C6h, 0CCh, 018h, 030h, 066h, 0C6h, 000h ;  /* % */
	DB 038h, 06Ch, 038h, 076h, 0DCh, 0CCh, 076h, 000h ;  /* & */
	DB 060h, 060h, 0C0h, 000h, 000h, 000h, 000h, 000h ;  /* ' */
	DB 018h, 030h, 060h, 060h, 060h, 030h, 018h, 000h ;  /* ( */
	DB 060h, 030h, 018h, 018h, 018h, 030h, 060h, 000h ;  /* ) */
	DB 000h, 066h, 03Ch, 0FFh, 03Ch, 066h, 000h, 000h ;  /* * */
	DB 000h, 030h, 030h, 0FCh, 030h, 030h, 000h, 000h ;  /* + */
	DB 000h, 000h, 000h, 000h, 000h, 030h, 030h, 060h ;  /* , */
	DB 000h, 000h, 000h, 0FCh, 000h, 000h, 000h, 000h ;  /* - */
	DB 000h, 000h, 000h, 000h, 000h, 030h, 030h, 000h ;  /* . */
	DB 006h, 00Ch, 018h, 030h, 060h, 0C0h, 080h, 000h ;  /* / */
	DB 07Ch, 0C6h, 0CEh, 0DEh, 0F6h, 0E6h, 07Ch, 000h ;  /* 0 */
	DB 030h, 070h, 030h, 030h, 030h, 030h, 0FCh, 000h ;  /* 1 */
	DB 078h, 0CCh, 00Ch, 038h, 060h, 0CCh, 0FCh, 000h ;  /* 2 */
	DB 078h, 0CCh, 00Ch, 038h, 00Ch, 0CCh, 078h, 000h ;  /* 3 */
	DB 01Ch, 03Ch, 06Ch, 0CCh, 0FEh, 00Ch, 01Eh, 000h ;  /* 4 */
	DB 0FCh, 0C0h, 0F8h, 00Ch, 00Ch, 0CCh, 078h, 000h ;  /* 5 */
	DB 038h, 060h, 0C0h, 0F8h, 0CCh, 0CCh, 078h, 000h ;  /* 6 */
	DB 0FCh, 0CCh, 00Ch, 018h, 030h, 030h, 030h, 000h ;  /* 7 */
	DB 078h, 0CCh, 0CCh, 078h, 0CCh, 0CCh, 078h, 000h ;  /* 8 */
	DB 078h, 0CCh, 0CCh, 07Ch, 00Ch, 018h, 070h, 000h ;  /* 9 */
	DB 000h, 030h, 030h, 000h, 000h, 030h, 030h, 000h ;  /* : */
	DB 000h, 030h, 030h, 000h, 000h, 030h, 030h, 060h ;  /* ; */
	DB 018h, 030h, 060h, 0C0h, 060h, 030h, 018h, 000h ;  /* < */
	DB 000h, 000h, 0FCh, 000h, 000h, 0FCh, 000h, 000h ;  /* = */
	DB 060h, 030h, 018h, 00Ch, 018h, 030h, 060h, 000h ;  /* > */
	DB 078h, 0CCh, 00Ch, 018h, 030h, 000h, 030h, 000h ;  /* ? */
	DB 07Ch, 0C6h, 0DEh, 0DEh, 0DEh, 0C0h, 078h, 000h ;  /* @ */
	DB 030h, 078h, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh, 000h ;  /* A */
	DB 0FCh, 066h, 066h, 07Ch, 066h, 066h, 0FCh, 000h ;  /* B */
	DB 03Ch, 066h, 0C0h, 0C0h, 0C0h, 066h, 03Ch, 000h ;  /* C */
	DB 0F8h, 06Ch, 066h, 066h, 066h, 06Ch, 0F8h, 000h ;  /* D */
	DB 0FEh, 062h, 068h, 078h, 068h, 062h, 0FEh, 000h ;  /* E */
	DB 0FEh, 062h, 068h, 078h, 068h, 060h, 0F0h, 000h ;  /* F */
	DB 03Ch, 066h, 0C0h, 0C0h, 0CEh, 066h, 03Eh, 000h ;  /* G */
	DB 0CCh, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh, 0CCh, 000h ;  /* H */
	DB 078h, 030h, 030h, 030h, 030h, 030h, 078h, 000h ;  /* I */
	DB 01Eh, 00Ch, 00Ch, 00Ch, 0CCh, 0CCh, 078h, 000h ;  /* J */
	DB 0E6h, 066h, 06Ch, 078h, 06Ch, 066h, 0E6h, 000h ;  /* K */
	DB 0F0h, 060h, 060h, 060h, 062h, 066h, 0FEh, 000h ;  /* L */
	DB 0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h, 000h ;  /* M */
	DB 0C6h, 0E6h, 0F6h, 0DEh, 0CEh, 0C6h, 0C6h, 000h ;  /* N */
	DB 038h, 06Ch, 0C6h, 0C6h, 0C6h, 06Ch, 038h, 000h ;  /* O */
	DB 0FCh, 066h, 066h, 07Ch, 060h, 060h, 0F0h, 000h ;  /* P */
	DB 078h, 0CCh, 0CCh, 0CCh, 0DCh, 078h, 01Ch, 000h ;  /* Q */
	DB 0FCh, 066h, 066h, 07Ch, 06Ch, 066h, 0E6h, 000h ;  /* R */
	DB 078h, 0CCh, 0E0h, 070h, 01Ch, 0CCh, 078h, 000h ;  /* S */
	DB 0FCh, 0B4h, 030h, 030h, 030h, 030h, 078h, 000h ;  /* T */
	DB 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0FCh, 000h ;  /* U */
	DB 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 078h, 030h, 000h ;  /* V */
	DB 0C6h, 0C6h, 0C6h, 0D6h, 0FEh, 0EEh, 0C6h, 000h ;  /* W */
	DB 0C6h, 0C6h, 06Ch, 038h, 038h, 06Ch, 0C6h, 000h ;  /* X */
	DB 0CCh, 0CCh, 0CCh, 078h, 030h, 030h, 078h, 000h ;  /* Y */
	DB 0FEh, 0C6h, 08Ch, 018h, 032h, 066h, 0FEh, 000h ;  /* Z */
	DB 078h, 060h, 060h, 060h, 060h, 060h, 078h, 000h ;  /* [ */
	DB 0C0h, 060h, 030h, 018h, 00Ch, 006h, 002h, 000h ;  /* \ */
	DB 078h, 018h, 018h, 018h, 018h, 018h, 078h, 000h ;  /* ] */
	DB 010h, 038h, 06Ch, 0C6h, 000h, 000h, 000h, 000h ;  /* ^ */
	DB 000h, 000h, 000h, 000h, 000h, 000h, 000h, 0FFh ;  /* _ */
	DB 030h, 030h, 018h, 000h, 000h, 000h, 000h, 000h ;  /* ` */
	DB 000h, 000h, 078h, 00Ch, 07Ch, 0CCh, 076h, 000h ;  /* a */
	DB 0E0h, 060h, 060h, 07Ch, 066h, 066h, 0DCh, 000h ;  /* b */
	DB 000h, 000h, 078h, 0CCh, 0C0h, 0CCh, 078h, 000h ;  /* c */
	DB 01Ch, 00Ch, 00Ch, 07Ch, 0CCh, 0CCh, 076h, 000h ;  /* d */
	DB 000h, 000h, 078h, 0CCh, 0FCh, 0C0h, 078h, 000h ;  /* e */
	DB 038h, 06Ch, 060h, 0F0h, 060h, 060h, 0F0h, 000h ;  /* f */
	DB 000h, 000h, 076h, 0CCh, 0CCh, 07Ch, 00Ch, 0F8h ;  /* g */
	DB 0E0h, 060h, 06Ch, 076h, 066h, 066h, 0E6h, 000h ;  /* h */
	DB 030h, 000h, 070h, 030h, 030h, 030h, 078h, 000h ;  /* i */
	DB 00Ch, 000h, 00Ch, 00Ch, 00Ch, 0CCh, 0CCh, 078h ;  /* j */
	DB 0E0h, 060h, 066h, 06Ch, 078h, 06Ch, 0E6h, 000h ;  /* k */
	DB 070h, 030h, 030h, 030h, 030h, 030h, 078h, 000h ;  /* l */
	DB 000h, 000h, 0CCh, 0FEh, 0FEh, 0D6h, 0C6h, 000h ;  /* m */
	DB 000h, 000h, 0F8h, 0CCh, 0CCh, 0CCh, 0CCh, 000h ;  /* n */
	DB 000h, 000h, 078h, 0CCh, 0CCh, 0CCh, 078h, 000h ;  /* o */
	DB 000h, 000h, 0DCh, 066h, 066h, 07Ch, 060h, 0F0h ;  /* p */
	DB 000h, 000h, 076h, 0CCh, 0CCh, 07Ch, 00Ch, 01Eh ;  /* q */
	DB 000h, 000h, 0DCh, 076h, 066h, 060h, 0F0h, 000h ;  /* r */
	DB 000h, 000h, 07Ch, 0C0h, 078h, 00Ch, 0F8h, 000h ;  /* s */
	DB 010h, 030h, 07Ch, 030h, 030h, 034h, 018h, 000h ;  /* t */
	DB 000h, 000h, 0CCh, 0CCh, 0CCh, 0CCh, 076h, 000h ;  /* u */
	DB 000h, 000h, 0CCh, 0CCh, 0CCh, 078h, 030h, 000h ;  /* v */
	DB 000h, 000h, 0C6h, 0D6h, 0FEh, 0FEh, 06Ch, 000h ;  /* w */
	DB 000h, 000h, 0C6h, 06Ch, 038h, 06Ch, 0C6h, 000h ;  /* x */
	DB 000h, 000h, 0CCh, 0CCh, 0CCh, 07Ch, 00Ch, 0F8h ;  /* y */
	DB 000h, 000h, 0FCh, 098h, 030h, 064h, 0FCh, 000h ;  /* z */
	DB 01Ch, 030h, 030h, 0E0h, 030h, 030h, 01Ch, 000h ;  /* { */
	DB 018h, 018h, 018h, 000h, 018h, 018h, 018h, 000h ;  /* | */
	DB 0E0h, 030h, 030h, 01Ch, 030h, 030h, 0E0h, 000h ;  /* } */
	DB 076h, 0DCh, 000h, 000h, 000h, 000h, 000h, 000h ;  /* ~ */
	DB 000h, 010h, 038h, 06Ch, 0C6h, 0C6h, 0FEh, 000h ;  /* Delta */
endif	; GISP_SVGA

	ORG 1E6Eh
time_of_day:
	BOP %BIOS_TIME_OF_DAY
	IRET

	ORG2	TIMER_INT_OFFSET
; The usual int8 handler modified for optimum performance.
; - stays in Intel code (no BOP)
; - keeps interrupts off when not needed
; - calls int 1c directly
;
	push	ds		; save some registers
	push	ax

	mov	ax, BIOS_VAR_SEGMENT
	mov	ds, ax

	; inc time counters
	; check for 24 hours, wrap point

	.386
	inc	dword ptr ds:[TIMER_COUNT]
	cmp	dword ptr ds:[TIMER_COUNT], 0001800b0h
	.286
	jz	i8v1

	; check for floppy motor

	dec	byte ptr ds:[MOTOR_COUNT]
	jz	i8v2		; costly outb happens 1/256 timer tics...

	; Check for dummy_int in int1c vector

	.386
	cmp	dword ptr ds:[BIOS_USER_TIMER*4], (BIOS_ROM_SEGMENT*10000h)+DUMMY_INT_OFFSET
	.286
	jnz	i8v3	

i8v0:	; send eoi

	mov	al, ICA_EOI
	out	ICA_MASTER_CMD, al

	; restore the stack and return

	pop	ax
	pop	ds
	iret

	; handle 24-hour wrap

i8v1:	.386
	mov	dword ptr ds:[TIMER_COUNT], 0
	.286
	mov	byte ptr ds:[TIMER_OVFL], 1	; 24 hour wrap, set OVFL bit

	; handle the floppy motor stuff

i8v2:	and	byte ptr ds:[MOTOR_STATUS], 0f0h
	mov	al, 0ch
	push	dx
	mov	dx, 03f2h
	out	dx, al
	jmp	i8v4		; n.b. dx already pushed

      ; Call user's timer handler (rare)

i8v3:	push	dx
i8v4:	int	BIOS_USER_TIMER
	pop	dx

	jmp	i8v0


;For old SoftPC's (that dont like 486 instructions) we put the old slow code
; in as well, and they use the BOP

	ORG2	OLD_TIMER_INT_OFFSET
	STI 	;to let timer interrupt itself.
;Save current state just like the real thing, so that
;user timer routines know exactly which registers are
;saved and which aren't.
	PUSH DS
	PUSH AX
	PUSH DX
;Now off to our code
	BOP %BIOS_TIMER_INT
	CLI 	;to prevent interrupts until the IRET.
;Non Specific End-Of-Interrupt
	MOV AL,20h
	OUT 20h,AL
;Restore saved state
	POP DX
	POP AX
	POP DS
;Any lower priority interrupts should occur before the IRET
	IRET


;; The illegal Intel instruction handler
	ORG2	ILL_OP_INT_OFFSET
	BOP	%BIOS_ILL_OP_INT
	IRET

;Software int's called from base, keyboard break, print screen, timer int
; If one of the following three ORG's are changed, then SAS.H must also be
; changed to reflect the new values.

	ORG2	KEYBOARD_BREAK_INT_OFFSET
	INT	BIOS_KEYBOARD_BREAK
	BOP	%BIOS_CPU_QUIT

	ORG2	PRINT_SCREEN_INT_OFFSET
	INT	BIOS_PRINT_SCREEN
	BOP	%BIOS_CPU_QUIT

	ORG2	USER_TIMER_INT_OFFSET
	INT	BIOS_USER_TIMER
	BOP	%BIOS_CPU_QUIT

	ORG2	DUMMY_INT_OFFSET
	IRET
	
; Called by the macintosh host to paste into the keyboard type-ahead buffer.
; Called with AH=5, CL=scan code, and CH=ascii character.

	ORG2	BIOS_PASTE_OFFSET
 	INT	BIOS_KEYBOARD_IO	; call BIOS keyboard function
	BOP	%BIOS_CPU_QUIT


;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Print screen

	ORG 1f54h
print_screen:
	STI
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
	PUSH DS
	;::::::::::::::::::::::::::::::::: Setup DS to point to BIOS data area
	MOV AX,BIOS_VAR_SEGMENT
	MOV DS,AX
	;::::::::::::::::::::::::::::::: Print screen already in progress ????
	CMP BYTE PTR DS:[100H],1
	JE end_print
	;::::::::::::::::::::::::::::::::::::::::::::::: Set print screen busy
	MOV BYTE PTR DS:[100h],1
	;:::::::::::::::::::::::::::::::::::::::::::::::::::: Get video status
	MOV AH,15
	INT 10H
	MOV CH,AH	    ;No of columns
	;:::::::::::::::::::::::::::::::::: Setup no. of columns/rows to print
	MOV CL,BYTE PTR DS:[084h]   ; No. of rows to print is rows in current mode
	;::::::::::::::::::::::::::::::::::: Print line feed / carriage return
	CALL print_crlf
	;:::::::::::::::::::::::::::::::::::::::::: Get current cursor postion
	PUSH CX
	MOV AH,3
	INT 10H
	POP CX
	;::::::::::::::::::::::::::::::::::::::::::::::::: Save cursor postion
	PUSH DX 		    ;save current cursor postion
	XOR DH,DH		    ;current row being processed
start_print_col:
	XOR DL,DL		    ;current column being processed
	;::::::::::::::::::::::::::::::::::::::::::::::: Start printing screen
start_print_row:
	;:::::::::::::::::::::::::::::::::::::::::::::::::: Set cursor postion
	PUSH DX 		    ;save current row,column
	MOV AH,2
	INT 10H
	;::::::::::::::::::::::::::::::::::: Read character at current postion
	MOV AH,8
	INT 10H
	;::::::::::::::::::::::::::::::::::::::::::::::::::::: Print character
	OR al,al
	JNZ print_char
	MOV AL,20H
print_char:
	XOR DX,DX
	XOR AH,AH
	INT 17H
	;:::::::::::::::::::::::::::::::::::::::::::: Check for printer errors
	POP DX			;Restore current row,column
	AND AH,25H
	JZ  cont2
	MOV BYTE PTR DS:[100H],0FFH
	JMP short exit_print
	;::::::::::::::::::::::::::::::::::::::::::: Move to mext print column
cont2:
	INC DL			;Inc current column
	CMP DL,CH		;Current col compared to no. of cols
	JB start_print_row
	;:::::::::::::::::::::::::::::::::::::::::: End of column, print CR/LF
	CALL print_crlf
	;:::::::::::::::::::::::::::::::::::::::::::::::::: More rows to print
	INC DH			;Inc current row
	CMP DH,CL		;Current row compared to no. of rows
	JBE start_print_col
	MOV BYTE PTR DS:[0100H],0
	;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Exit print
exit_print:
	;:::::::::::::::::::::::::::::::::::::; Restore orginal cursor postion
	POP DX
	MOV AH,2
	INT 10H
	;:::::::::::::::::::::::::::::::::::::::::::::::::::: Tidy up and exit
end_print:
	POP DS
	POP DX
	POP CX
	POP BX
	POP AX
	IRET

	;::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Print CR/LF
print_crlf:
	PUSH DX
	XOR DX,DX
	MOV AX,0DH
	INT 17H
	XOR DX,DX
	MOV AX,0AH
	INT 17H
	POP DX
	RET


	ORG2	START_OFFSET
start_addr:
	JMP reset_ref	
date:
	DB "07/03/95"

	org 01ffeh
bios_tail:
	DB MODEL_BYTE
code	ENDS
	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\obj.vdm\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=ntvdm
EXEPROFILEINPUT=yes

MVDM_TREE=$(PROJECT_ROOT)\mvdm

SOFTPC_TREE=$(MVDM_TREE)\mvdm\softpc.new

INCLUDES=$(SOFTPC_TREE)\host\inc;$(SOFTPC_TREE)\base\inc

TARGETPATH=obj
!if "$(ALT_PROJECT)" == "daytona"
PASS1_PUBLISH={$(O)\ntvdm.lib=$(SDK_LIB_PATH)\ntvdm.lib}
!endif

TARGETTYPE=PROGLIB
NOT_TERMINAL_SERVER_AWARE=1

TARGETLIBS=\
        $(SDK_LIB_PATH)\kernl32p.lib \
        $(WINDOWS_LIB_PATH)\gdi32p.lib     \
        $(WINDOWS_LIB_PATH)\user32p.lib   \
        $(SDK_LIB_PATH)\ntdll.lib   \
!if !$(386)
        $(SDK_LIB_PATH)\binmode.obj  \
!endif
        $(SDK_LIB_PATH)\advapi32.lib
        
BACKGROUND_USE=1

!if "$(ALT_PROJECT)" == "NEC_98"
ALT_PROJECT_OBJS=NEC_98
ALT_PROJECT_LIBS=NEC_98
ALT_PROJECT_FE=NEC_98
!else
!if "$(ALT_PROJECT)" == "daytona"
ALT_PROJECT_FE=daytona
!else
ALT_PROJECT_FE=fe
!endif
ALT_PROJECT_OBJS=daytona
ALT_PROJECT_LIBS=.
!endif

!if !$(386)
LINKER_FLAGS=$(LINKER_FLAGS) -INCLUDE:__mb_cur_max -INCLUDE:_pctype
!endif

LINKLIBS = \
    $(SOFTPC_TREE)\base\support\$(ALT_PROJECT_OBJS)\$(O)\MAIN.obj \
    $(SOFTPC_TREE)\host\src\$(ALT_PROJECT)\$(O)\FPRT.OBJ     \
    $(SOFTPC_TREE)\base\system\$(ALT_PROJECT_OBJS)\$(O)\SYSTEM.LIB    \
    $(SOFTPC_TREE)\base\bios\$(ALT_PROJECT)\$(O)\BIOS.LIB    \
    $(SOFTPC_TREE)\base\video\$(ALT_PROJECT)\$(O)\VIDEO.LIB  \
    $(SOFTPC_TREE)\base\dos\$(ALT_PROJECT_OBJS)\$(O)\DOS.LIB      \
    $(SOFTPC_TREE)\base\comms\$(ALT_PROJECT_OBJS)\$(O)\COMMS.LIB  \
    $(SOFTPC_TREE)\base\debug\$(ALT_PROJECT_OBJS)\$(O)\DEBUG.LIB  \
    $(SOFTPC_TREE)\base\support\$(ALT_PROJECT_OBJS)\$(O)\SUPPORT.LIB  \
    $(SOFTPC_TREE)\base\disks\$(ALT_PROJECT_OBJS)\$(O)\DISKS.LIB  \
    $(SOFTPC_TREE)\base\keymouse\$(ALT_PROJECT)\$(O)\KEYMOUSE.LIB \
    $(SOFTPC_TREE)\host\src\$(ALT_PROJECT)\$(O)\SRC.LIB      \
!if $(386)
    $(MVDM_TREE)\v86\monitor\$(ALT_PROJECT_OBJS)\$(O)\monitor.lib      \
!else
    $(SOFTPC_TREE)\base\dasm386\$(O)\DASM386.LIB   \
    $(CPULIBS) \
!endif
    $(MVDM_TREE)\dbg\$(ALT_PROJECT_OBJS)\$(O)\dbg.lib         \
    $(MVDM_TREE)\dos\dem\$(ALT_PROJECT)\$(O)\dem.lib         \
    $(MVDM_TREE)\suballoc\$(O)\suballoc.lib         \
    $(MVDM_TREE)\dos\command\$(ALT_PROJECT)\$(O)\command.lib         \
    $(MVDM_TREE)\oemuni\$(ALT_PROJECT_FE)\$(O)\oemuni.lib     \
    $(MVDM_TREE)\xms.486\$(ALT_PROJECT_OBJS)\$(O)\xms486.lib \
    $(MVDM_TREE)\dpmi32\$(ALT_PROJECT_FE)\$(O)\dpmi32.lib

!if $(FREEBUILD)
PD = Pd
!else
PD = Pg
!endif

# Decide whether to use assembler or C CPU.

!if "$(CCPU)" == ""
CPULIBS=$(SOFTPC_TREE)\*\libs\a4$(PD).lib
!else
CPULIBS=$(SOFTPC_TREE)\obj.vdm\$(O)\ccpu486.lib
!endif

# Since we have built objs and libs in LINKLIBS above,
# we need to wait for previous directories to complete
# before building this one.  This is because build.exe
# requires LINKLIBS to exist in pass 1 (compile).

SYNCHRONIZE_DRAIN=1

SOURCES=..\ntvdm.c  \
        ..\imlibdep.c \
        ..\resource.rc

MISCFILES=..\doswow_{BA75DD62-6D62-4FCB-89F2-BC53C0659829}.sld

!INCLUDE ..\CDEFINE.INC

UMTYPE=console

#
# base at < 256 MB (0x10000000), so that softpc code buffer
# in allocated Virtual Memory (bottom up) is within
# near jump range to ntvdm's code.
#
UMBASE=0x0f000000

DLLDEF=$(O)\ntvdm.def
SOURCES_USED=..\sources.inc

!if "$(ALT_PROJECT)" != "daytona"
LINKER_FLAGS=$(LINKER_FLAGS) /pdb:$(O)\ntvdm_$(ALT_PROJECT).pdb
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\roms\bios1.asm ===
;	SCCSID = @(#)uf.bios1.asm	1.16 7/3/95
;	Author:		J. Box, Jerry Kramskoy
;
;	Purpose:	
;			provides Intel BIOS for the following:
;				RTC interrupt
;				fixed disk (on dual card)
;

; C-services (through 'bop' instruction)
	BIOS_UNEXP_INT		= 	2
	BIOS_RTC_INT		=	70h
	BIOS_REDIRECT_INT	=	71h
	BIOS_D11_INT		=	72h
	BIOS_X287_INT		=	75h
	BIOS_DISK_IO		=	13h
        BIOS_MOUSE_INT1         = 	0BAh
        BIOS_MOUSE_INT2         = 	0BBh
        BIOS_MOUSE_IO_LANGUAGE  = 	0BCh
        BIOS_MOUSE_IO_INTERRUPT = 	0BDh
        BIOS_MOUSE_VIDEO_IO     = 	0BEh
	BIOS_CPU_RETURN		=	0feh
	BIOS_IRET_HOOK		=	52h

; ICA registers
	ICA_MASTER_CMD	= 020h
	ICA_MASTER_IMR	= 021h
	ICA_SLAVE_CMD	= 0A0h
	ICA_SLAVE_IMR	= 0A1h
; and commands
	ICA_EOI		= 020h

; CMOS registers
	CMOS_addr	= 070h
	CMOS_data	= 071h
	NMI_DISABLE	= 080h
	CMOS_StatusA	= NMI_DISABLE + 0Ah 
	CMOS_StatusB	= NMI_DISABLE + 0Bh
	CMOS_StatusC	= NMI_DISABLE + 0Ch
	CMOS_Shutdown	= 0Fh
; CMOS constants (bits in StatusB or StatusC)
	CMOS_PI		= 01000000b	; Periodic interrupt
	CMOS_AI		= 00100000b	; Alarm interrupt
; microseconds at 1024Hz
	CMOS_PERIOD_USECS = 976


	include bebop.inc

	; DUE TO LIMITATIONS IN EXE2BIN, we define 
	; the region 0 - 0xdfff (segment 0xf000) in this file
	; and the region 0xe000 - 0xffff in file 'bios2.asm'
	;
	; each file should be SEPARATELY put through
	; MASM,LINK, and EXE2BIN to produce 2 binary image files
	; which get loaded into the appropriate regions during
	; SoftPC startup.


	;------------------------;
	; bios data area         ;
	;------------------------;
; BIOS variables area
BIOS_VAR_SEGMENT	SEGMENT at 40h


	ORG	098h
rtc_user_flag		DD	?	; 98
rtc_micro_secs		DD	?	; 9c
rtc_wait_flag		DB	?	; a0

	ORG	8eh
hf_int_flag		db	?	; 8e

BIOS_VAR_SEGMENT	ENDS


	code	segment

		assume cs:code, ds:BIOS_VAR_SEGMENT

	;----------------------------------------------------;
	; 	D11			                     ;
	;	services unused interrupt vectors	     ;
	;						     ;
	;----------------------------------------------------;
		ORG	01BE0h
D11:		bop	BIOS_D11_INT
		iret

	;----------------------------------------------------;
	;	IRET HOOK				     ;
	;	Return control to the monitor after an ISR   ;
	;	returns to here.			     ;
	;----------------------------------------------------;
 
		ORG	01C00h
		bop	BIOS_IRET_HOOK
		iret

	;----------------------------------------------------;
	; 	re_direct		                     ;
	;	This routine fields level 9 interrupts	     ;
	;	control is passed to Master int level 2	     ;
	;----------------------------------------------------;
		ORG	01C2Fh
re_direct:	bop	BIOS_REDIRECT_INT
		int	0ah
		iret

	;----------------------------------------------------;
	; 	int_287			                     ;
	;	service X287 interrupts			     ;
	;						     ;
	;----------------------------------------------------;
		ORG	01C38h
int_287:	bop	BIOS_X287_INT
		int	02
		iret


	;----------------------------------------------------;
	; 	rtc_int			                     ;
	;	rtc interrupt handler			     ;
	;----------------------------------------------------;
		ORG	04B1Bh

rtc_int:	push	ax
		push	ds
		mov	ax, BIOS_VAR_SEGMENT
		mov	ds, ax

rtc_test_pending:

	;; Check for pending interrupt

		mov	al, CMOS_StatusC
		out	CMOS_addr, al
		in	al, CMOS_data	; reads then clears pending interrupts

	;; Mask with enabled interrupts		

		mov	ah, al			; save pending interrupts
		mov	al, CMOS_StatusB
		out	CMOS_addr, al
		in	al, CMOS_data		
		and	ah, al		

	;; Test pending, enabled interrupts (in ah) for work to do

		test	ah, (CMOS_PI+CMOS_AI)
		jnz	rtc_test_enabled

	;; Deselecting the cmos

		mov	al, CMOS_Shutdown
		out	CMOS_addr, al

	;; Send eoi to ICA

		mov	al, ICA_EOI
		out	ICA_SLAVE_CMD, al
		out	ICA_MASTER_CMD, al

	;; And return

		pop	ds
		pop	ax
		iret

rtc_test_enabled:

	;; Test for periodic interrupt triggered

		test	ah, CMOS_PI
		jz	rtc_test_alarm

	;; Decrement the microsecond count

		.386
		sub	ds:[rtc_micro_secs], CMOS_PERIOD_USECS
		.286
		jnc	rtc_test_alarm

	;; Disable PI interrupt in CMOS if count expired

		mov	al, CMOS_StatusB
		out	CMOS_addr, al
		in	al, CMOS_data		
		and	al, 10111111b	; Disable PI interrupt
		out	CMOS_data, al

	;; Update the flag byte to say time has expired

		push	es
		push	bx
		les	bx, rtc_user_flag
		or	byte ptr es:[bx], 080h
		pop	bx
		pop	es

	;; Mark timer-in-use flag in-active

		and	rtc_wait_flag, 0feh; Show wait is not active

rtc_test_alarm:

	;; Test for alarm interrupt triggered

		test	ah, CMOS_AI
		jz	rtc_test_pending

	;; Call users alarm function (first deselecting the cmos)

		mov	al, CMOS_Shutdown
		out	CMOS_addr, al
		int	04Ah

	;; Repeat in case a new interrupt occurred

		jmp	rtc_test_pending

		

	;----------------------------------------------------;
	; disk_io                       
	;	route to disk/diskette i/o service	     ;
	;----------------------------------------------------;
		org	2e86h	;(must match DISKO_OFFSET in diskbios.c)

	disk_io	proc	far
	; is this request for fixed disk or diskette?
		cmp	dl,80h
		jae	p0

	; for diskette.
		int	40h
	bye:	
		retf	2
	p0:	
		sti
	; reset? (ah = 0). reset diskette also
		or	ah,ah
		jnz	p1
		int	40h
		sub	ah,ah
		cmp	dl,81h
		ja	bye

	p1:	
	; carry out the disk service requested from 'C'.
	; those requests which expect to cause a
	; disk interrupt will 'call' wait below,
	; which returns back to 'C'. Eventually
	; 'C' returns after the bop.

		push	ds
		bop	BIOS_DISK_IO
		pop	ds
		retf	2

	disk_io	endp	
		
	;----------------------------------------------------;
	; wait					     	     ;
	;	wait for disk interrupt			     ;
	;	('called' from waitint() in diskbios.c	     ;
	;----------------------------------------------------;
		org	329fh	;(must match DISKWAIT_OFFSET in diskbios.c)
	wate	proc	
	
		sti
		clc
		mov	ax,9000h
 		int	15h
		push    ds
		push	cx
		mov	ax, 40h
		mov	ds, ax
		xor	cx, cx
not_yet:	cmp	byte ptr ds:[8eh], 0
		loopz	not_yet
		pop	cx
		pop	ds
		bop	BIOS_CPU_RETURN
	wate	endp

	;----------------------------------------------------;
	; hd_int					     ;
	;	field fixed disk controller's interrupt	     ;
	;----------------------------------------------------;
		org	33b7h	; (must match DISKISR_OFFSET in diskbios.c)

	hd_int	proc	near
		push	ds
		mov	ax,BIOS_VAR_SEGMENT
		mov	ds,ax
	; inform everybody that a fixed disk interrupt
	; occurred
		mov	hf_int_flag,0ffh

	; clear down the interrupt with the ica's

		mov	al, ICA_EOI
		out	ICA_SLAVE_CMD, al
		out	ICA_MASTER_CMD, al

		sti
		mov	ax,9100h
		int	15h
		pop	ds
		iret

	hd_int	endp

	; read bytes 0 - 3fff in from binary image
	; when accessing bios1.rom.
	; if need more than this, change value here
	; to 'n' and in sas_init(), change read of bios1.rom
	; to have transfer count of 'n'+1

				org	3fffh
	insignia_endmark	db	0

ifdef	SUN_VA
;
;       NB. the following addresses are allocated to SUN for DOS Windows 3.0.
;       They are not to be used by anyone else.
;       THIS AREA IS SUN PROPERTY - TRESPASSERS WILL BE PROSECUTED
;       However please note that only the ranges below are reserved.
;
        ORG 04000h
        sunroms_2       LABEL   FAR
        db      512 dup (0)     ; reserved
        ORG 05000h
        sunroms_3       LABEL   FAR
        db      512 dup (0)     ; reserved
endif

        ORG     06000h

        ; this is a fake IFS header to make DOS 4.01
        ; happy with HFX. Do not move/alter.
        hfx_ifs_hdr     LABEL   FAR
        DB      0ffh, 0ffh, 0ffh, 0ffh
        DB      "HFXREDIR"
        DB      00h, 02ch
        DB      00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h

ifndef	GISP_SVGA

	ORG	06020h
ifndef	SUN_VA
write_teletype	proc far
	retf
write_teletype	endp

else

write_teletype	proc far
	push	ds
	push	si
	mov	si,	0f000h
	mov	ds,	si
	mov	si,	06400h
	push	ax
	mov	ah,	0eh
	push	bp
	mov	bp,	2
	push	dx
	push    bx
	mov bx, 0

start_write:
	cmp	bp,	[si]
	je	finish_write
	mov	al,	ds:[bp+si]
	inc	bp
	int	010h
	jmp	start_write

finish_write:
	mov	word ptr [si], 2
	pop	bx
	pop	dx
	pop	bp
	pop	ax
	pop	si
	pop	ds
	retf
write_teletype	endp

	ORG	06200h
; mouse_io_interrupt
mouse_io:
	JMP hopover
	BOP BIOS_MOUSE_IO_LANGUAGE
	RETF 8
hopover:
	BOP BIOS_MOUSE_IO_INTERRUPT
	IRET


	ORG	06220h
; mouse_int1
mouse_int1:
	BOP BIOS_MOUSE_INT1
	IRET

	ORG	06240h
; mouse_video_io
mouse_video_io:
	BOP BIOS_MOUSE_VIDEO_IO
	IRET

	ORG	06260h
; mouse_int2
mouse_int2:
	BOP BIOS_MOUSE_INT2
	IRET

	ORG	06280h
; mouse_version
mouse_version:			; dummy, for compatibility
	DB 042h,042h,00h,00h

	ORG	062a0h
; mouse_copyright
mouse_copyright:		; dummy, for compatibility
	DB "Copyright 1987-91 Insignia Solutions Inc"

	ORG	06400h
;	scratch pad area - this is where the messages go!

endif

endif	; GISP_SVGA

	;; To cope with Helix SoftWare "Netroom 2.20" DOS extender
	;; which only maps in pages of the BIOS that have vectors
	;; we must ensure that something points at page F6xxx
	;; else we end up with the scratch area on top of some
	;; DOS program or driver!

	ORG	06f00h	; UNEXP_INT_OFFSET
	BOP	BIOS_UNEXP_INT
	IRET

	.386
;	These are the virtualisation instructions needed for the 386.

	ORG	3000h		; BIOS_STI_OFFSET
	STI	
	BOP	0feh

	ORG	3010h		; BIOS_CLI_OFFSET
	CLI	
	BOP	0feh

	ORG	3020h		; BIOS_INB_OFFSET
	IN	al,dx 
	BOP	0feh 

	ORG	3030h		; BIOS_INW_OFFSET
	IN	ax,dx 
	BOP	0feh

	ORG	3040h		; BIOS_IND_OFFSET
	IN	eax,dx 
	BOP	0feh

	ORG	3050h		; BIOS_OUTB_OFFSET
	OUT	dx,al 
	BOP	0feh 

	ORG	3060h		; BIOS_OUTW_OFFSET
	OUT	dx,ax 
	BOP	0feh 

	ORG	3070h		; BIOS_OUTD_OFFSET
	OUT	dx,eax 
	BOP	0feh 

	ORG	3080h		; BIOS_WRTB_OFFSET
	MOV	[edx],al
	BOP	0feh 

	ORG	3090h		; BIOS_WRTW_OFFSET
	MOV	[edx],ax
	BOP	0feh 

	ORG	30a0h		; BIOS_WRTD_OFFSET
	MOV	[edx],eax
	BOP	0feh 

	ORG	30b0h		; BIOS_RDB_OFFSET
	MOV	al, [edx]
	BOP	0feh 

	ORG	30c0h		; BIOS_RDW_OFFSET
	MOV	ax, [edx]
	BOP	0feh 

	ORG	30d0h		; BIOS_RDD_OFFSET
	MOV	eax, [edx]
	BOP	0feh 

	ORG	30e0h		; BIOS_YIELD_VM_OFFSET
	MOV	AX, 1680h	; Yeild VM time slice
	INT	2fh
	BOP	0feh 

	ORG	30f0h		; BIOS_STOSB_OFFSET
	push	es
	push	ds
	pop	es
	xchg	edx,edi		; dest lin addr
	db	67h
	db	66h
	rep	stosb	
	xchg	edx,edi
	pop	es
	BOP	0feh 

	ORG	3110h		; BIOS_STOSW_OFFSET
	push	es
	push	ds
	pop	es
	xchg	edx,edi		; dest lin addr
	db	67h
	rep	stosw	
	xchg	edx,edi
	pop	es
	BOP	0feh 

	ORG	3130h		; BIOS_STOSD_OFFSET
	push	es
	push	ds
	pop	es
	xchg	edx,edi		; dest lin addr
	db	67h
	db	66h
	rep	stosw	
	xchg	edx,edi
	pop	es
	BOP	0feh 

        ORG     3200h           ; BIOS_BAD_OFFSET
        db	0c5h
	db	0c5h		; illegal instruction
	BOP	0feh

 ;; N.B. DISKWAIT_OFFSET is at "org 329fh"

	code	ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\rename\rename.c ===
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Include files */

#include "windows.h"

#include "stdio.h"
#include "stdlib.h"
#include "string.h"

#define MAX_NAME_SIZE   (8)
#define MAX_EXT_SIZE    (3)

char CharRemoveList[] = "AEIOUaeiou_";

int ConvertFileName(char *NameToConvert);

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::: Main entry point */

__cdecl main(int argc, char *argv[])
{
    int index;

    /*......................................... Validate input parameters */

    if(argc < 2)
    {
        printf("Invalid usage : rename <filenames>\n");
        return(1);
    }


    for(index = 1; index < argc; index++)
        ConvertFileName(argv[index]);

    return(0);
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: */

int ConvertFileName(char *NameToConvert)
{
    char *Name, *Ext, *ExtStart;
    int NameSize, ExtSize;
    char NewName[MAX_NAME_SIZE+1], NewFileName[1000];
    char *NewNamePtr;
    
    /*....................... Get the size of the file name and extension */

    for(Name = NameToConvert, NameSize = 0;
        *Name && *Name != '.';  Name++, NameSize++);

    for(ExtStart = Name, Ext = *Name == '.' ? Name+1 : Name, ExtSize = 0;
        *Ext ; Ext++, ExtSize++);

    /*................................ Validate name and extension sizes */

    if(ExtSize > MAX_EXT_SIZE) 
    {
        printf("Unable to convert '%s' to 8.3 filename\n", NameToConvert);
        return(1); 
    }


    if(NameSize <= MAX_NAME_SIZE)
    {
        /* Name does not need conversion */
        return(0);
    }

    /*................................................ Convert file name */

    NewNamePtr = &NewName[MAX_NAME_SIZE];
    *NewNamePtr-- = 0;

    do
    {
        Name--;

        if(NameSize > MAX_NAME_SIZE && strchr(CharRemoveList, *Name))
            NameSize--;         /* Remove character */
        else
            *NewNamePtr-- = *Name;
    }
    while(NewNamePtr >= NewName && Name !=  NameToConvert);

    /*............................................. Validate conversion */

    if(NameSize > MAX_NAME_SIZE) 
    {
        printf("Unable to convert '%s' to 8.3 filename\n", NameToConvert);
        return(1);
    }

    sprintf(NewFileName,"%s%s", NewNamePtr+1, ExtStart);
    printf("REN '%s' to '%s'\n", NameToConvert, NewFileName);
    rename(NameToConvert, NewFileName);

    return(0);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\cbcid.inc ===
; Whenever a module registers a group of callback thunks with win32c.dll,
; it uses a unique 16-bit Callback Client id to identify the group.
; We're using fixed numbers for the standard system dll's for convenience.
; We may add an id allocator to win32c.dll for use by third-party modules.
;
; Rules for CBC id's:
;
;    - CBC id's are 16-bits wide.
;    - The value 0 is reserved. Don't ues as an id.
;    - CBID_MAX is the largest id that win32c.dll supports.
;    - CBID_FREEUSE is the smallest id for use by third party developers.
;      All id's below this value are reserved by MS.


CBCID_KERNEL            equ     1
CBCID_GDI               equ     2
CBCID_USER              equ     3
CBCID_COMMDLG           equ     4
CBCID_SHELL             equ     5
CBCID_LZ                equ     6
CBCID_OLE               equ     7
CBCID_ADVAPI            equ     8

CBCID_WIN32C            equ     9
CBCID_PEN               equ     10


CBCID_FREEUSE           equ     20      ;Id's less than this reserved for MS
CBCID_MAX               equ     29      ;Largest id allowed.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\cctl1632.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\suballoc\suballoc.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    suballoc.c

Abstract:

    This module contains code for managing a paritially commited address
    space.  It handles allocation of chunks of memory smaller than the 
    commit granularity.  It commits and decommits memory as needed using
    the supplied function for committing and decommitting memory.  The 
    structures used for tracking the address space are allocated outside
    of the specified addresss space.

Author:

    Dave Hastings (daveh) creation-date 21-Jan-1994
    
Notes:

    Since this package does not actually access memory in the address space
    it is managing, it will work as well with real linear addresses or 
    "Intel Addresses" such as would be encountered with the Insignia Emulator
    on risc.

Revision History:


--*/
#include "suballcp.h"

PVOID
SAInitialize(
    ULONG BaseAddress,
    ULONG Size,
    PSACOMMITROUTINE CommitRoutine,
    PSACOMMITROUTINE DecommitRoutine,
    PSAMEMORYMOVEROUTINE MemoryMoveRoutine
    )
/*++

Routine Description:

    This function performs initialization of the sub allocation package
    for the specified addresss range.  It allocates the data structures
    necessary to track the allocations

Arguments:

    BaseAddress -- Supplies the base address of the address space to
        sub allocate.
    Size -- Supplies the size in bytes of the address space to sub allocate.
    CommitRoutine -- Supplies a pointer to the routine used to commit regions
        of the address space.

Return Value:

    If the function was successful it returns a pointer to the sub-allocation
    data structures.  Otherwise it returns NULL.
    
--*/
{
    PSUBALLOCATIONDATA SubAlloc;
    ULONG SASize;

    ASSERT_STEPTHROUGH;
    //
    // Asserts to insure that everything is as we expect it to be
    //
    ASSERT(((COMMIT_GRANULARITY % SUBALLOC_GRANULARITY) == 0));
        
    //
    // Allocate the tracking structure
    // 
    // SUBALLOCATIONDATA is declared with 1 uchar for the bitmap.
    // this is the reason for subtracting one from the total size
    // calculation.
    //
    SASize = sizeof(SUBALLOCATIONDATA) 
        + (Size / SUBALLOC_GRANULARITY) / sizeof(UCHAR) - 1;

    SubAlloc = malloc(SASize);
    
    if (SubAlloc == NULL) {
        return NULL;
    }
    
    //
    // Initialize the structure
    //
    RtlZeroMemory(SubAlloc, SASize);
    
    INIT_SUBALLOC_SIGNATURE(SubAlloc);
    SubAlloc->BaseAddress = BaseAddress;
    SubAlloc->Size = Size / SUBALLOC_GRANULARITY;
    SubAlloc->CommitRoutine = CommitRoutine;
    SubAlloc->DecommitRoutine = DecommitRoutine;
    SubAlloc->MoveMemRoutine = MemoryMoveRoutine;

    return SubAlloc;    
}

BOOL 
SAQueryFree(
    PVOID SubAllocation,
    PULONG FreeBytes,
    PULONG LargestFreeBlock
    )    
/*++

Routine Description:

    This routine returns the number of free bytes in the 
    sub allocated address space.

Arguments:
    
    SubAllocation -- Supplies the pointer returned by SAInitialize
    FreeBytes -- Returns the number of free bytes
   
Return Value:

    TRUE -- if successful, and FreeBytes contains the number of free bytes.
    FALSE otherwise
    
--*/
{
    ULONG i, FreeCount;
    PSUBALLOCATIONDATA SubAlloc;
    ULONG TempLargest, LargestBlock;
    
    ASSERT_STEPTHROUGH;
    
    //
    // Get a typed pointer
    //
    SubAlloc = SubAllocation;
    
    //
    // Make sure that we have what we think we do
    //
    ASSERT_SUBALLOC(SubAlloc);
    
    //
    // Count the free chunks and find largest block
    //
    FreeCount = 0;
    LargestBlock = 0;
    i = 0;
    while (i < SubAlloc->Size) {
        
        TempLargest = 0;
        while (
            (i < SubAlloc->Size) && 
            (GET_BIT_FROM_CHAR_ARRAY(SubAlloc->Allocated, i) == 0) 
        ){
            FreeCount++;
            TempLargest++;
            i++;
        }
    
        if (TempLargest > LargestBlock) {
            LargestBlock = TempLargest;
        }
        
        //
        // Skip allocated blocks
        //
        while (
            (i < SubAlloc->Size) && 
            (GET_BIT_FROM_CHAR_ARRAY(SubAlloc->Allocated, i) == 1)
        ) {
            i++;
        }
    }
    
    *FreeBytes = FreeCount * SUBALLOC_GRANULARITY;
    *LargestFreeBlock = LargestBlock * SUBALLOC_GRANULARITY;
    return TRUE;
}

BOOL
SAAllocate(
    PVOID SubAllocation,
    ULONG Size,
    PULONG Address
    )
/*++

Routine Description:

    This function allocates a portion of the address space described by 
    SubAllocation.  If necessary, it will commit additional blocks. 
    Size is rounded up to the next higher multiple of SUBALLOC_GRANULARITY.

Arguments:

    SubAllocation -- Supplies the pointer returned by SAInitialize.
    Size -- Supplies the size in bytes of the region to allocate.
    Address -- Returns the address of the region allocated.

Return Value:

    TRUE if successful.  If false is returned, no address is returned.
    
Notes:

    Zero is a valid value for the returned address.

--*/
{
    ULONG AllocateSize, i, CurrentChunk;
    BOOL Done = FALSE;
    PSUBALLOCATIONDATA SubAlloc;
    BOOL Success;
    
    ASSERT_STEPTHROUGH;
    
    //
    // Get a typed pointer.  This allows us to avoid
    // casting every time we access the pointer.
    //
    SubAlloc = SubAllocation;

    ASSERT_SUBALLOC(SubAlloc);
    
    //
    // Round size and make into number of blocks
    //
    AllocateSize = ALLOC_ROUND(Size);

    //
    // Find a chunk that is free
    //
    // We need this loop in spite of the fact that we 
    // are keeping an index to the first free block.
    // We update this pointer somewhat heuristically.
    // If we allocate the first free block, we update
    // the index to point past the block we allocated.
    // We don't repeat the free scan however, so the 
    // index may actually point to an allocated block.
    //
    CurrentChunk = SubAlloc->FirstFree;
    while (CurrentChunk < SubAlloc->Size) {
        if (GET_BIT_FROM_CHAR_ARRAY(SubAlloc->Allocated, CurrentChunk) == 0) {
            SubAlloc->FirstFree = CurrentChunk;
            break;
        }
        CurrentChunk++;
    }

    //
    // Find a block that is big enough
    //
    while (!Done && (CurrentChunk < SubAlloc->Size)){
    
        //
        // Search for a contiguous block large enough
        //
        for (i = 0; i < AllocateSize; i++){
            //
            // Insure we don't walk off the end of the data structure
            //
            if ((i + CurrentChunk) >= SubAlloc->Size){
                CurrentChunk += i; // Satisfy termination condition
                break;
            }
            
            //
            // Check to see if this chunk is free
            //
            if (
                GET_BIT_FROM_CHAR_ARRAY(
                    SubAlloc->Allocated, 
                    i + CurrentChunk
                    ) 
                    == 0
            ){
                continue;
            } else {
                //
                // Chunk is not free, so advance the search
                //
                CurrentChunk += i + 1;
                break;
            }
        }
        
        //
        // Check to see if we found a chunk 
        //
        if (i == AllocateSize) {
            Done = TRUE;
        } 
    }
    
    //
    // If we found the chunk, commit it (if necessary) and mark it allocated
    //
    // N.B.  It is important to commit it first, and mark it allocated last, 
    //       because we use the allocated bits to determine if the chunk is 
    //       committed.  If all of the allocated bits are clear, the chunk 
    //       is not commited yet.
    //
    if (Done) {

        //
        // Allocate and commit the memory
        //
        Success = AllocateChunkAt(
            SubAlloc,
            AllocateSize,
            CurrentChunk,
            FALSE
            );
        
        if (!Success) {
            return FALSE;
        }
        
        *Address = BLOCK_INDEX_TO_ADDRESS(SubAlloc, CurrentChunk);

        ASSERT((SubAlloc->BaseAddress <= *Address) && 
            ((SubAlloc->BaseAddress + SubAlloc->Size * SUBALLOC_GRANULARITY)
            > *Address));
#if 0            
        {
            char Buffer[80];
            
            sprintf(Buffer, "SAAllocate: Allocating at address %lx\n", *Address);
            OutputDebugString(Buffer);
        }
#endif        
        return TRUE;
        
    } else {
        return FALSE;
    }
}

BOOL
SAFree(
    PVOID SubAllocation,
    ULONG Size,
    ULONG Address
    )
/*++

Routine Description:

    This routine frees a sub-allocated chunk of memory.  If the 
    entire commited block (or blocks) that the specified chunk
    belongs to are free, the chunks are decommitted.  Address is 
    rounded down to the next lower SUBALLOC_GRANULARITY boundary.
    size is rounded up to the next higher multiple of SUBALLOC_GRANULARITY.

Arguments:

    SubAllocation -- Supplies the pointer returned by SAInitialize.
    Size -- Supplies the size in bytes of the region to free.
    Address -- Supplies the address of the region to free.

Return Value:

    TRUE if successful.
    
Notes:

    It is possible to free a different size at a particular 
    address than was allocated.  This will not cause the 
    SubAllocation package any problems.

    BUGBUG decommit error handling?    
--*/
{
    PSUBALLOCATIONDATA SubAlloc;
    ULONG AllocatedSize, BaseBlock;
    
    SubAlloc = SubAllocation;
    ASSERT_SUBALLOC(SubAlloc);
    
    //
    // Make sure that the space to free is really ours
    // (Entire block within range, and correctly aligned)
    if (
        (Address < SubAlloc->BaseAddress) || 
        (Address >= (SubAlloc->BaseAddress + SubAlloc->Size * SUBALLOC_GRANULARITY)) ||
        ((Address + Size) > (SubAlloc->BaseAddress + SubAlloc->Size * SUBALLOC_GRANULARITY)) ||
        (Address % SUBALLOC_GRANULARITY)
    ) {
        return FALSE;
    }
    
    //
    // Turn Address into Block #
    //
    BaseBlock = ADDRESS_TO_BLOCK_INDEX(SubAlloc, Address);
        
    //
    // Round up the size    
    //
    AllocatedSize = ALLOC_ROUND(Size);

    return FreeChunk(
        SubAlloc,
        AllocatedSize,
        BaseBlock
        );
}

BOOL
SAReallocate(
    PVOID SubAllocation,
    ULONG OriginalSize,
    ULONG OriginalAddress,
    ULONG NewSize,
    PULONG NewAddress
    )
/*++

Routine Description:

    This routine reallocates a sub allocated block of memory.
    The sizes are rounded up to the next SUBALLOC_GRANULARITY.
    The Original address is rounded down to the next SUBALLOC_GRANULARITY
    boundary.  Only min(OriginalSize, NewSize) bytes of data are copied to
    the new block.  The block changed in place if possible.
    
    The following is an enumation of the possible successful reallocs.
    
    1.  NewSize < OriginalSize
        free block tail
    2.  NewSize > OriginalSize
        a.)  Sufficient freespace at OriginalAddress + OriginalSize
                Allocate the space at the tail of the block
        b.)  Sufficient free space at OriginalAddress - size delta
                Allocate the space at the beginning of the block, and
                copy the data.
        c.)  Sufficient space elsewhere in the address space
                Allocate the space, and copy the block.
                
    If none of the above is true, the realloc fails.  The above are 
    in order of preference.

Arguments:

    SubAllocation -- Supplies the pointer returned by SAInitialize.
    OriginalSize -- Supplies the old size in bytes of the block.
    OriginalAddress -- Supplies the old address of the block.
    NewSize -- Supplies the new size in bytes of the block.
    NewAddress -- Returns the new address of the block.

Return Value:

    True if successful.  If unsucessful, no allocation is changed.
    
Notes:

    If the caller does not supply the correct original size for the block,
    some memory may be lost, and the block may be moved unnecessarily.
    
--*/
{

    ULONG OriginalSizeBlock, NewSizeBlock, OriginalIndex;
    ULONG AdditionalBlocks, Address;
    BOOL Success;
    PSUBALLOCATIONDATA SubAlloc;

    SubAlloc = SubAllocation;
    ASSERT_SUBALLOC(SubAlloc);
    
    //
    // Convert Sizes and address to blocks
    //
    OriginalSizeBlock = ALLOC_ROUND(OriginalSize);
    NewSizeBlock = ALLOC_ROUND(NewSize);
    OriginalIndex = ADDRESS_TO_BLOCK_INDEX(SubAlloc, OriginalAddress);
    
    //
    // Check to see if we are changing the size of the block
    //
    // N.B.  Because we have rounded the numbers to an allocation
    //       boundary, the following test may succeed (correctly)
    //       even though OriginalSize != NewSize
    //
    if (OriginalSizeBlock == NewSizeBlock) {
        *NewAddress = OriginalAddress;
        return TRUE;
    }
    
    //
    // Check to see if the block is getting smaller
    //
    if (OriginalSizeBlock > NewSizeBlock) {
    
        //
        // Free the tail of the block
        //
        Success = FreeChunk(
            SubAlloc, 
            OriginalSizeBlock - NewSizeBlock,
            OriginalIndex + NewSizeBlock
            );
            
        if (Success) {
            *NewAddress = OriginalAddress;
            return TRUE;
        } else {
            return FALSE;
        }
    }
    
    //
    // Try to allocate the space at the end of the block
    //
    AdditionalBlocks = NewSizeBlock - OriginalSizeBlock;
    
    Success = AllocateChunkAt(
        SubAlloc,
        AdditionalBlocks,
        OriginalIndex + OriginalSizeBlock,
        TRUE
        );
        
    //
    // If there was space, return success
    //
    if (Success) {
        *NewAddress = OriginalAddress;
        return TRUE;
    }
    
    //
    // Try to allocate space at the beginning of the block
    //
    Success = AllocateChunkAt(
        SubAlloc,
        AdditionalBlocks,
        OriginalIndex - AdditionalBlocks,
        TRUE
        );
        
    if (Success) {
        //
        // Move the data
        //
        // N.B.  We can't just call RtlMoveMemory, 
        //       because we don't know the correspondence
        //       between the address space we manage, and 
        //       real linear addresses.  In addition, for
        //       risc NTVDM, some additional work may have
        //       to be done (such as flushing caches).
        //
        SubAlloc->MoveMemRoutine(
            BLOCK_INDEX_TO_ADDRESS(
                SubAlloc, 
                (OriginalIndex - AdditionalBlocks)
                ),
            OriginalAddress,
            OriginalSize
            );
            
        *NewAddress = BLOCK_INDEX_TO_ADDRESS(
            SubAlloc,
            (OriginalIndex - AdditionalBlocks)
            );
            
        return TRUE;
    }
    
    //
    // Attempt to allocate a new block
    //
    Success = SAAllocate(
        SubAlloc,
        NewSize,
        &Address
        );
        
    if (Success) {
        //
        // Move the data
        // 
        // N.B. We could copy the data, but it would
        //      require one more function pointer.
        //
        SubAlloc->MoveMemRoutine(
            Address,
            OriginalAddress,
            OriginalSize
            );
            
        SAFree(
            SubAlloc,
            OriginalSize,
            OriginalAddress
            );
            
        //
        // Indicate success
        //
        *NewAddress = Address;
        return TRUE;
    }
    
    //
    // All reallocation strategies failed.  
    //
    return FALSE;
}

BOOL
AllocateChunkAt(
    PSUBALLOCATIONDATA SubAlloc,
    ULONG Size,
    ULONG BlockIndex,
    BOOLEAN CheckFree
    )
/*++

Routine Description:

    This routine attempts to allocate the specified chunk
    of memory.  It first checks to make sure that it is 
    free.

Arguments:

    SubAlloc -- Supplies a pointer to the suballocation data
    Size -- Supplies the size of the chunk to allocate
    BlockIndex -- Supplies the index of the beginning of the block
        to allocate
    CheckFree -- Supplies an indication of whether to check and see
        if the memory is free.  If this routine is called from 
        SAAllocate, we know the memory is free.
        
Return Value:

    True if successful
    
--*/
{
    ULONG i;

    if (CheckFree) {
        //
        // Verify that the memory is free
        //
        for (i = 0; i < Size; i++){
            //
            // Insure we don't walk off the end of the data structure
            //
            if ((i + BlockIndex) >= SubAlloc->Size){
                break;
            }
            
            //
            // Check to see if this chunk is free
            //
            if (
                GET_BIT_FROM_CHAR_ARRAY(
                    SubAlloc->Allocated, 
                    i + BlockIndex
                    ) 
                == 0
            ){
                continue;
            } else {
                //
                // Chunk is not free
                //
                break;
            }
        }
 
        //
        // If the chunk is not free
        //   
        if (i != Size) {
            return FALSE;
        }
    }

    //
    // Commit the chunk
    //
    if (!CommitChunk(SubAlloc, BlockIndex, Size, SACommit)) {
        return FALSE;
    }
    
    //
    // Mark it as allocated
    //    
    for (i = BlockIndex; i < BlockIndex + Size; i++) {
        SET_BIT_IN_CHAR_ARRAY(SubAlloc->Allocated, i);
    }
    
    //
    // Update the pointer to the first free block
    //
    if (BlockIndex == SubAlloc->FirstFree) {
        SubAlloc->FirstFree += Size;
    }
    
    return TRUE;
}


BOOL
FreeChunk(
    PSUBALLOCATIONDATA SubAlloc,
    ULONG Size,
    ULONG BlockIndex
    )
/*++

Routine Description:

    This routine actually marks the memory as free
    and decommits it as necessary.

Arguments:

    SubAlloc -- Supplies a pointer to the suballocation data
    Size -- Supplies the size (in SUBALLOC_GRANULARITY) of the 
        region to free
    BlockIndex -- Supplies the index of the begining of the region
        (in SUBALLOC_GRANULARITY)
        
Return Value:

    TRUE if successful.

--*/
{
    SUBALLOCATIONDATA LocalSubAlloc;
    ULONG CurrentBlock;
    BOOL Success;
    
    //
    // Save a copy of the suballoc data
    //
    LocalSubAlloc = *SubAlloc;
    
    //
    // reset free pointer
    //
    if (BlockIndex < SubAlloc->FirstFree) {
        SubAlloc->FirstFree = BlockIndex;
    }
    //    
    // Mark the region as free
    //
    // N.B.  We mark the block as free before decommitting it, because
    //       the decommit code will use the allocated bits to determine which
    //       parts can be decommitted.
    //
    for (CurrentBlock = BlockIndex; 
        CurrentBlock < BlockIndex + Size; 
        CurrentBlock++
    ) {
        CLEAR_BIT_IN_CHAR_ARRAY(SubAlloc->Allocated, CurrentBlock);
    }
    
    //
    // Decommit the memory
    //
    Success = CommitChunk(SubAlloc, BlockIndex, Size, SADecommit);
    
    if (!Success) {
        *SubAlloc = LocalSubAlloc;
    }
    
    return Success;
}

BOOL
CommitChunk(
    PSUBALLOCATIONDATA SubAlloc,
    ULONG StartChunk,
    ULONG Size,
    COMMIT_ACTION Action
    )
/*++

Routine Description:

    This routine commits a chunk of memory.  Part or all
    of the specified chunk may already be commited.

Arguments:

    SubAllocation -- Supplies a pointer to the suballocation data
    StartChunk -- Supplies the relative start of the region to be  
        committed (in SUBALLOCATION_GRANULARITY)
    Size -- Supplies the size of the chunk to be commited 
        (in SUBALLOCATION_GRANULARITY)
    
Return Value:

    TRUE -- If the block was successfully committed (or already committed)
    FALSE -- Otherwise

Notes:
    
    This routine depends on the allocated bits in SubAlloc to determine
    whether memory is committed.  When memory is to be committed, CommitBlock
    must be called before the Allocated bits are modified.  When memory is 
    decommitted, the Allocated bits must be modified before CommitBlock is
    called.
           
--*/
{
    ULONG FirstBlock, LastBlock, CurrentBlock;
    NTSTATUS Status;
    
    ASSERT_STEPTHROUGH;

    ASSERT_SUBALLOC(SubAlloc);
    
    //
    // Round Start down to next COMMIT_GRANULARITY and convert to block #
    //
    FirstBlock = (StartChunk * SUBALLOC_GRANULARITY) / COMMIT_GRANULARITY;
    
    //
    // Round StartChunk + size up to next COMMIT_GRANULARITY
    //
    LastBlock = ((StartChunk + Size) * SUBALLOC_GRANULARITY + 
        (COMMIT_GRANULARITY - 1)) / COMMIT_GRANULARITY;
    
    for (
        CurrentBlock = FirstBlock; 
        CurrentBlock < LastBlock; 
        CurrentBlock++
    ) {
        
        //
        // If the block is not committed, either commit it or decommit it, 
        // depending on the value of Action.
        //
        if (!IsBlockCommitted(SubAlloc, CurrentBlock)) {
            if (Action == SACommit) {
            
                Status = (SubAlloc->CommitRoutine)(
                    CurrentBlock * COMMIT_GRANULARITY + SubAlloc->BaseAddress,
                    COMMIT_GRANULARITY
                    );
                
            } else if (Action == SADecommit) {

                Status = (SubAlloc->DecommitRoutine)(
                    CurrentBlock * COMMIT_GRANULARITY + SubAlloc->BaseAddress,
                    COMMIT_GRANULARITY
                    );

            }
            if (Status != STATUS_SUCCESS) {
            //
            // Bugbug -- decommit any blocks committed here
            //
                return FALSE;
            }
        }
    }
    return TRUE;
}

BOOL
IsBlockCommitted(
    PSUBALLOCATIONDATA SubAlloc,
    ULONG Block
    )
/*++

Routine Description:

    This routine checks to see if a particular block of the
    suballocation is committed.  

Arguments:

    SubAlloc -- Supplies a pointer to the suballocation data
    Block -- Supplies the number of the block to check
    
Return Value:

    TRUE -- if the block is committed
    FALSE -- if the block is not committed

Notes:

    The return value is based on the state of the bits in the 
    suballocation data, not on information from the NT memory 
    manager.    
    
--*/
{
    BOOL Committed = FALSE;
    ULONG i;
    
    ASSERT_STEPTHROUGH;
    ASSERT_SUBALLOC(SubAlloc);
    
    //
    // Check the bits for each of the suballoc blocks in the 
    // commit block
    //
    for (i = 0; i < COMMIT_GRANULARITY / SUBALLOC_GRANULARITY; i++) {
        
        //
        // Check to see if this suballoc block is allocated
        //    
        if (
            GET_BIT_FROM_CHAR_ARRAY(
                SubAlloc->Allocated, 
                i + Block * COMMIT_GRANULARITY / SUBALLOC_GRANULARITY
                )
        ) {
            Committed = TRUE;
            break;
        }
    }
    
    return Committed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\fdthk.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\suballoc\suballcp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    suballcp.h

Abstract:

    This is the private include file for the suballocation
    package.

Author:

    Dave Hastings (daveh) creation-date 25-Jan-1994

Revision History:


--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <malloc.h>
#include <suballoc.h>


//
// Constants
// 

//
// Smallest chunk that will be sub allocated
// 1024 was chosen currently, because that is the
// smallest chunk XMS will allocate.
//
#define SUBALLOC_GRANULARITY        1024

//
// Assertions and macros
//

//
// Force code to be stepped through
//
#if 0
#define ASSERT_STEPTHROUGH DbgBreakPoint()
#else
#define ASSERT_STEPTHROUGH
#endif

//
// Signature macros for SUBALLOCATION
//
#if DBG
//
// signature is "SubA"
//
#define INIT_SUBALLOC_SIGNATURE(p) p->Signature = (ULONG)0x41627553
#define ASSERT_SUBALLOC(p) ASSERT((p->Signature == (ULONG)0x41627553))
#else
#define INIT_SUBALLOC_SIGNATURE(p)
#define ASSERT_SUBALLOC(p)
#endif

//
// Macro for extracting a bit from a bitfield of type char
//
#define GET_BIT_FROM_CHAR_ARRAY(p, i) \
((p[(i)/(sizeof(UCHAR) * 8)] >> ((i) % (sizeof(UCHAR) * 8))) & 1)

//
// Macro for setting a bit in a bitfield of type char
//
#define SET_BIT_IN_CHAR_ARRAY(p, i) \
(p[(i)/(sizeof(UCHAR) * 8)] |= (1 << ((i) % (sizeof(UCHAR) * 8))))

//
// Macro for clearing a bit in a bitfield of type char
//
#define CLEAR_BIT_IN_CHAR_ARRAY(p, i) \
(p[(i)/(sizeof(UCHAR) * 8)] &= ~(1 << ((i) % (sizeof(UCHAR) * 8))))

//
// Generate a sub alloc block index from an address
//
#define ADDRESS_TO_BLOCK_INDEX(p, i) \
((i - p->BaseAddress)/ SUBALLOC_GRANULARITY) 

//
// Generate an address from a block index
//
#define BLOCK_INDEX_TO_ADDRESS(p, i) \
(p->BaseAddress + (i) * SUBALLOC_GRANULARITY)

// Round the allocated size to next allocation
// granularity
//
#define ALLOC_ROUND(s) \
(s + SUBALLOC_GRANULARITY - 1) / SUBALLOC_GRANULARITY

//
// Types
//

//
// Enum for commit acctions
//

typedef enum {
    SACommit,
    SADecommit
} COMMIT_ACTION;

//
// Structure for tracking the address space.  Each chunk of 
// memory of SUBALLOC_GRANULARITY in size is represented by
// a bit.  Each chunk of memory of COMMIT_GRANULARITY is 
// represented by one bit of the array Allocated.
//
// ?? Should we add a field to indicate whether the chunk is 
//    committed?  We can always check for all allocated bits
//    zero, and use that as an indication that the chunk is 
//    not committed.
//
//
typedef struct _SubAllocation {
#if DBG
    ULONG Signature;
#endif
    PSACOMMITROUTINE CommitRoutine;
    PSACOMMITROUTINE DecommitRoutine;
    PSAMEMORYMOVEROUTINE MoveMemRoutine;
    ULONG BaseAddress;
    ULONG Size;                         // size in SUBALLOC_GRANULARITY
    ULONG FirstFree;                    // keeps block # of first free block
                                        // cuts alloc time in half
    //
    // bitfield with one bit per chunk.  Bit set indicates
    // allocated.  Bit clear indicates free.  All bits 
    // clear indicates un committed
    //
    UCHAR Allocated[1];
} SUBALLOCATIONDATA, *PSUBALLOCATIONDATA;

//
// Internal Routines
//
BOOL
CommitChunk(
    PSUBALLOCATIONDATA SubAllocation,
    ULONG StartChunk,
    ULONG Size,
    COMMIT_ACTION Action
    );

BOOL
IsBlockCommitted(
    PSUBALLOCATIONDATA SubAlloc,
    ULONG CurrentBlock
    );

BOOL
AllocateChunkAt(
    PSUBALLOCATIONDATA SubAlloc,
    ULONG Size,
    ULONG BlockIndex,
    BOOLEAN CheckFree
    );
    
BOOL
FreeChunk(
    PSUBALLOCATIONDATA SubAlloc,
    ULONG Size,
    ULONG BlockIndex
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\assert16.h ===
/************************************************************************/
/*                                                                      */
/*      ASSERT.H        --  Assertion Macros                            */
/*                                                                      */
/************************************************************************/
/*      Author:                                                         */
/*      Copyright:                                                      */
/************************************************************************/
/*  File Description:                                                   */
/*                                                                      */
/*                                                                      */
/************************************************************************/
/*  Revision History:                                                   */
/*                                                                      */
/*                                                                      */
/************************************************************************/


/* ------------------------------------------------------------ */
/*                                                              */
/* ------------------------------------------------------------ */

#ifndef _ASSERT_H_
#define _ASSERT_H_

//#include    <dbgflags.h>
//extern int dwDebugFlags;

/* ------------------------------------------------------------ */
/*          Debug Function Prototypes and Definitions           */
/* ------------------------------------------------------------ */

VOID PASCAL PrintFailedAssertion(int, char *);

#ifdef  DEBUG
#define SetFile() \
    static char __szSrcFile[] = __FILE__;
#else
#define SetFile()
#endif

/* ------------------------------------------------------------ */
/*                      Debug Macros                            */
/* ------------------------------------------------------------ */

#ifdef  DEBUG

#define break() _asm { _asm int 3 }

#define assert(cond) \
    if (!(cond)) {\
        PrintFailedAssertion(__LINE__,__szSrcFile);\
    }

#else

#define break()
#define assert(cond)

#endif

#endif // _ASSERT_H_



static VOID PASCAL PrintFailedAssertion(int iLine, char * szFileName)
{
    char achLocal[60];

    wsprintf(achLocal, "Assertion failed at line %d in file ", iLine);
    OutputDebugString(achLocal);
    OutputDebugString(szFileName);
    OutputDebugString("\012\015");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\suballoc\tsa.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <malloc.h>
#include <stdio.h>
#include <suballoc.h>

typedef struct _MemTrack *PMEMTRACK;

typedef struct _MemTrack {
    PMEMTRACK Next;
    ULONG Address;
    ULONG Size;
} MEMTRACK;

VOID
SimpleTest1(
    PVOID SA
    );

VOID
SimpleTest2(
    PVOID SA
    );

VOID
SimpleTest3(
    PVOID SA
    );

VOID
SimpleTest4(
    PVOID
    );

VOID
SimpleTest5(
    PVOID
    );

VOID
SimpleTest6(
    PVOID
    );

NTSTATUS
DecommitMem(
    ULONG BaseAddress,
    ULONG Size
    );

NTSTATUS
CommitMem(
    ULONG BaseAddress,
    ULONG Size
    );

VOID
MoveMem(
    ULONG Destination,
    ULONG Source,
    ULONG Size
    );

main(argv, argc)
char **argv;
int argc;
{
    NTSTATUS Status;
    PVOID BaseAddress, SA;
    ULONG Size;
    ULONG TotalFree, LargestFree;
    ULONG i,j;
    BOOL Success;

    //
    // Allocate a region of memory for SA to manage
    //
    BaseAddress = NULL;
    Size = 15*1024*1024 - 64 * 1024;
    Status = NtAllocateVirtualMemory(
        NtCurrentProcess(),
        &BaseAddress,
        0,
        &Size,
        MEM_RESERVE,
        PAGE_READWRITE
        );

    if (!NT_SUCCESS(Status)) {
        printf("Couldn't allocate memory, %lx\n", Status);
        return(0);
    }

    //
    // Initialize the suballocation stuff
    //
    SA = SAInitialize(
        (ULONG)BaseAddress,
        Size,
        CommitMem,
        DecommitMem,
        MoveMem
        );
    if (SA == NULL) {
        printf("SAInitialize Failed\n");
    }

    //
    // Find out how much free memory we have
    //
    Success = SAQueryFree(
        SA,
        &TotalFree,
        &LargestFree
        );
        
    if (!Success) {
        printf("Could not query free\n");
        return;
    }
    //
    // Run some tests
    //
    SimpleTest1(SA);

    //
    // Allocate blocks spanning two commit blocks
    //
    SimpleTest2(SA);

    //
    // Allocate and free all of memory (twice)
    //
    SimpleTest3(SA);

    //
    // More complex alloc and free test
    //
    SimpleTest4(SA);

    //
    // Test realloc
    //
    SimpleTest5(SA);
    
    //
    // Test Queryfree
    //
    SimpleTest6(SA);
    
    //
    // Make sure we didn't leak
    //
    Success = SAQueryFree(
        SA,
        &i,
        &j
        );
        
    if (!Success){
        printf("Couldn't requery free\n");
        return;
    }
    
    if ((i != TotalFree) || (j != LargestFree)) {
        printf("We leaked\n");
    }
}

VOID
SimpleTest1(
    PVOID SA
    )
{
    ULONG Address;
    BOOL Success;

    Success = SAAllocate(
        SA,
        50,
        &Address
        );

    if (!Success) {
        printf("SimpleTest1: Failed to allocate\n");
        return;
    }

    try {
        *((PULONG)(Address + 4)) = 1;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        printf("SimpleTest1: Faulted accessing memory\n");
        return;
    }

    Success = SAFree(
        SA,
        50,
        Address
        );

     if (!Success) {
        printf("SimpleTest1: Failed to free\n");
        return;
    }

    Success = TRUE;

    try {
        *((PULONG)Address + 4) = 1;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Success = FALSE;
    }

    if (Success) {
        printf("SimpleTest1: memory not decommited\n");
    }
}

VOID
SimpleTest2(
    PVOID SA
    )
{
    ULONG SmallAddress, LargeAddress;
    BOOL Success;

    Success = SAAllocate(
        SA,
        50,
        &SmallAddress
        );

    if (!Success) {
        printf("SimpleTest2: Could not alloc small block\n");
        return;
    }

    try {
        *((PULONG)(SmallAddress + 4)) = 1;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        printf("SimpleTest2: small block not committed\n");
        return;
    }

    Success = SAAllocate(
        SA,
        COMMIT_GRANULARITY + 50,
        &LargeAddress
        );

    if (!Success) {
        printf("SimpleTest2: Could not alloc large block\n");
        return;
    }

    try {
        *((PULONG)(LargeAddress + 4)) = 1;
        *((PULONG)(LargeAddress + COMMIT_GRANULARITY)) = 1;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        printf("SimpleTest2: Large block not committed\n");
        return;
    }

    Success = SAFree(
        SA,
        50,
        SmallAddress
        );

    if (!Success) {
        printf("SimpleTest2: failed to free small block\n");
        return;
    }

    try {
        *((PULONG)(LargeAddress + 4)) = 1;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        printf("SimpleTest2: LargeBlock decommited!!\n");
        return;
    }

    Success = SAFree(
        SA,
        COMMIT_GRANULARITY + 50,
        LargeAddress
        );

    if (!Success) {
        printf("SimpleTest2: failed to free Large block\n");
        return;
    }

    Success = FALSE;
    try {
        *((PULONG)(LargeAddress + 4)) = 1;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Success = TRUE;
    }

    if (!Success) {
        printf("SimpleTest2: First block not decommited\n");
    }

    Success = FALSE;
    try {
        *((PULONG)(LargeAddress + COMMIT_GRANULARITY + 4)) = 1;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Success = TRUE;
    }

    if (!Success) {
        printf("SimpleTest2: Last block not decommited\n");
    }

}

VOID
SimpleTest3(
    PVOID SA
    )
{
    ULONG BlockCount, i, Address;
    PMEMTRACK p, Head, f;
    BOOL Success;

    Head = NULL;
    BlockCount = 0;
    do {

        Success = SAAllocate(
            SA,
            3072,
            &Address
            );

        if (Success) {
            p = malloc(sizeof(MEMTRACK));
            if (p == NULL) {
                printf("SimpleTest3: malloc error\n");
                return;
            }
            p->Next = Head;
            p->Size = 3072;
            p->Address = Address;
            Head = p;
            BlockCount++;
        }
    } while (Success);

    try {
        p = Head;
        while (p != NULL) {
            *((PULONG)(p->Address + 100)) = 1;
            p = p->Next;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        printf("SimpleTest3: failed first access test\n");
        return;
    }

    p = Head;
    while (p != NULL) {

        Success = SAFree(
            SA,
            3072,
            p->Address
            );

        if (!Success) {
            printf("SimpleTest3: Failed first free test\n");
            return;
        }
        f = p;
        p = p->Next;
        free(f);
    }

    Head = NULL;

    for (i = 0; i < BlockCount; i++) {

        Success = SAAllocate(
            SA,
            3072,
            &Address
            );

        if (!Success) {
            printf("SimpleTest3: Failed second alloc test\n");
            return;
        }

        p = malloc(sizeof(MEMTRACK));
        if (p == NULL) {
            printf("SimpleTest3: malloc error\n");
            return;
        }

        p->Next = Head;
        p->Size = 3072;
        p->Address = Address;
        Head = p;
    }

    try {
        p = Head;
        while (p != NULL) {
            *((PULONG)(p->Address + 100)) = 1;
            p = p->Next;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        printf("SimpleTest3: failed second access test\n");
        return;
    }

    p = Head;
    while (p != NULL) {

        Success = SAFree(
            SA,
            3072,
            p->Address
            );

        if (!Success) {
            printf("SimpleTest3: Failed second free test\n");
            return;
        }
        f = p;
        p = p->Next;
        free(f);
    }
}

VOID
SimpleTest4(
    PVOID SA
    )
{
    ULONG i, Address;
    PMEMTRACK p, Head, f;
    BOOL Success;

    Head = NULL;
    do {

        Success = SAAllocate(
            SA,
            3072,
            &Address
            );

        if (Success) {
            p = malloc(sizeof(MEMTRACK));
            if (p == NULL) {
                printf("SimpleTest4: malloc error\n");
                return;
            }
            p->Next = Head;
            p->Size = 3072;
            p->Address = Address;
            Head = p;
        }
    } while (Success);

    p = Head;
    p = p->Next;
    p = p->Next;

    Success = SAFree(
        SA,
        3072,
        p->Next->Address
        );

    if (!Success) {
        printf("SimpleTest4: could not free\n");
        return;
    }

    f = p->Next;
    p->Next = p->Next->Next;
    free (f);

    p = p->Next;
    p = p->Next;

    Success = SAFree(
        SA,
        3072,
        p->Next->Address
        );

    if (!Success) {
        printf("SimpleTest4: could not free\n");
        return;
    }

    f = p->Next;
    p->Next = p->Next->Next;
    free (f);

    Success = SAFree(
    	SA,
    	3072,
    	p->Next->Address
    	);
    if (!Success) {
        printf("SimpleTest4: could not free\n");
        return;
    }

    f = p->Next;
    p->Next = p->Next->Next;
    free (f);

    Success = SAAllocate(
        SA,
        3072,
        &Address
        );

    try {
        *((PULONG)(Address + 4)) = 1;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        printf("SimpleTest4: failed to access\n");
        return;
    }

    if (!Success) {
        printf("SimpleTest4: could not allocate\n");
        return;
    }

    p = malloc(sizeof(MEMTRACK));
    if (!p) {
        printf("SimpleTest4: could not malloc\n");
        return;
    }

    p->Next = Head;
    p->Size = 3072;
    p->Address = Address;
    Head = p;
    
    Success = SAAllocate(
        SA,
        3072,
        &Address
        );

    try {
        *((PULONG)(Address + 4)) = 1;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        printf("SimpleTest4: failed to access\n");
        return;
    }

    if (!Success) {
        printf("SimpleTest4: could not allocate\n");
        return;
    }

    p = malloc(sizeof(MEMTRACK));
    if (!p) {
        printf("SimpleTest4: could not malloc\n");
        return;
    }

    p->Next = Head;
    p->Size = 3072;
    p->Address = Address;
    Head = p;
    
    p = Head;
    while (p != NULL) {

        Success = SAFree(
            SA,
            3072,
            p->Address
            );

        if (!Success) {
            printf("SimpleTest3: Failed second free test\n");
            return;
        }
        f = p;
        p = p->Next;
        free(f);
    }
}

VOID
SimpleTest5(
    PVOID SA
    )
{
    ULONG Address, NewAddress;
    ULONG Address1, Address2, Address3;
    ULONG Size1, Size2, Size3;
    BOOL Success;
    
    Success = SAAllocate(
        SA,
        3072,
        &Address
        );
    
    if (!Success) {
        printf("SimpleTest5: failed to allocate\n");
        return;
    }
    
    Success = SAReallocate(
        SA,
        3072,
        Address,
        3000,
        &NewAddress
        );
        
    if (!Success) {
        printf("SimpleTest5:  failed to reallocate\n");
        return;
    }
    
    if (NewAddress != Address) {
        printf("SimpleTest5: Realloc in place failed\n");
    }

    Success = SAReallocate(
        SA,
        3072,
        Address,
        200,
        &NewAddress
        );
        
    if (!Success) {
        printf("SimpleTest5:  failed to reallocate\n");
        return;
    }
    
    if (NewAddress != Address) {
        printf("SimpleTest5: Realloc in place failed\n");
        return;
    }
    
    Success = SAReallocate(
        SA,
        200,
        Address,
        6000,
        &NewAddress
        );
        
    if (!Success) {
        printf("SimpleTest5: failed to reallocate\n");
        return;
    }
    
    if (NewAddress != Address) {
        printf("SimpleTest5: realloc in place failed\n");
        return;
    }
    
    Success = SAAllocate(
        SA,
        1500,
        &Address
        );
        
    if (!Success) {
        printf("SimpleTest5: failed to allocate\n");
        return;
    }
    
    Address1 = NewAddress;
    Size1 = 6000;
    Address2 = Address;
    Size2 = 1500;
    
    Success = SAReallocate(
        SA,
        Size1,
        Address1,
        3000,
        &NewAddress
        );
        
    if (!Success) {
        printf("SimpleTest5: failed to reallocate\n");
        return;
    }

    if (Address1 != NewAddress) {
        printf("SimpleTest5: realloc in place failed\n");
        return;
    }
    Size1= 3000;
    
    Success = SAAllocate(
        SA,
        2000,
        &Address
        );
        
    if (!Success) {
        printf("SimpleTest5: failed to allocate\n");
        return;
    }

    Address3 = Address;
    Size3 = 2000;
    
    Success = SAFree(
        SA,
        Size1,
        Address1
        );
        
    if (!Success) {
        printf("SimpleTest5: failed to free\n");
        return;
    }
    
    Success = SAReallocate(
        SA,
        Size3,
        Address3,
        5000,
        &Address
        );
        
    if (!Success) {
        printf("SimpleTest5: failed to reallocate\n");
        return;
    }
    
    Address3 = Address;
    Size3 = 5000;
    
    Success = SAReallocate(
        SA,
        Size3,
        Address3,
        10000,
        &Address
        );
    
    if (!Success) {
        printf("SimpleTest5: failed to reallocate\n");
        return;
    }
    Address3 = Address;
    Size3 = 10000;
    
    Success = SAFree(
        SA,
        Size2,
        Address2
        );
        
    if (!Success) {
        printf("SimpleTest5: failed to free\n");
        return;
    }
    
    Success = SAFree(
        SA,
        Size3,
        Address3
        );
        
    if (!Success) {
        printf("SimpleTest5: failed to free\n");
        return;
    }
}

VOID
SimpleTest6(
    PVOID SA
    )
{
    ULONG LargestFree, TotalFree;
    BOOL Success;
    
    Success = SAQueryFree(
        SA,
        &TotalFree,
        &LargestFree
        );
    
}


NTSTATUS
CommitMem(
    ULONG BaseAddress,
    ULONG Size
    )
{
    NTSTATUS Status;
    PVOID Address;
    ULONG size;

    Address = (PVOID)BaseAddress;
    size = Size;
    Status = NtAllocateVirtualMemory(
        NtCurrentProcess(),
        &Address,
        0L,
        &size,
        MEM_COMMIT,
        PAGE_READWRITE
        );

    if (!NT_SUCCESS(Status)) {
        printf(
            "CommitMem failed to commit %lx, %lx, error %lx\n",
            Address,
            size,
            Status
            );
    }

    return Status;
}

NTSTATUS
DecommitMem(
    ULONG BaseAddress,
    ULONG Size
    )
{
    NTSTATUS Status;
    PVOID Address;
    ULONG size;

    Address = (PVOID)BaseAddress;
    size = Size;
    Status = NtFreeVirtualMemory(
        NtCurrentProcess(),
        &Address,
        &size,
        MEM_DECOMMIT
        );

    if (!NT_SUCCESS(Status)) {
        printf(
            "DecommitMem failed to decommit %lx, %lx, error %lx\n",
            Address,
            size,
            Status
            );
    }

    return Status;
}

VOID
MoveMem(
    ULONG Destination,
    ULONG Source,
    ULONG Size
    )
{
    RtlMoveMemory(
        (PVOID)Destination,
        (PVOID)Source,
        Size
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\dlgcbid.inc ===
; Callback-type id's for COMMDLG callbacks. All callback-type id's are
; 32-bits long and the upper 16-bits must be set to the module's
; Callback Client id.
;
; WARNING -- WARNING -- WARNING
;
;   Win32c.dll uses the lower 16 bits of CBID's to index directly into
;   the tables stored in COMDLG.EXE (dlgcb16.asm) and COMDLG32.DLL 
;   (dlgcb32.asm). Those tables *must* match these id's or callbacks 
;   will fail miserably. Do everyone a big favor and add new id's only 
;   at the end, and never change an existing id.
;   


CBID_OPENFILENAME       equ     (0 + (CBCID_COMMDLG SHL 16))
CBID_CHOOSEFONT         equ     (1 + (CBCID_COMMDLG SHL 16))
CBID_CHOOSECOLOR        equ     (2 + (CBCID_COMMDLG SHL 16))
CBID_PRINTDLG           equ     (3 + (CBCID_COMMDLG SHL 16))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\cbcheck.inc ===
IF 0

;These are the id's used by the 32-bit callback-function-prologue dispatcher.
;They must be unique across all 32-bit dll's because the same dispatcher is
;used for them all.  The dispatcher and dispatch table are in user32.dll,
;which imports the missing table entries from the other dlls.


_ipfn_ind       = 0

DEFIPFNID       macro   name
name    equ _ipfn_ind
_ipfn_ind = _ipfn_ind + 1
                endm
DEFCPFN         macro   name
name equ _ipfn_ind
        endm



; IPFN_UNIVTHUNK should be the first item of this list with value 0.
; This is because this number is also used in "ut.c" which cant
; include this file!!!.
DEFIPFNID IPFN_UNIVTHUNK

DEFCPFN   CPFN_UNIVTHUNK


DEFIPFNID IPFN_ENUMWINDOWS
DEFIPFNID IPFN_ENUMCHILDWINDOWS
DEFIPFNID IPFN_ENUMTASKWINDOWS
DEFIPFNID IPFN_GRAYSTRINGA
DEFIPFNID IPFN_ENUMPROPSA
DEFIPFNID IPFN_ENUMPROPSEXA
DEFIPFNID IPFN_WNDPROC
DEFIPFNID IPFN_TIMER

; IPFN_LOADRES is also defined in peres.c as 9. So dont
; move its number without changing peres.c
DEFIPFNID IPFN_LOADRES

DEFIPFNID IPFN_DDECALLBACK
DEFIPFNID IPFN_WORDBREAKPROC

DEFCPFN   CPFN_USRCBCHECK

DEFIPFNID IPFN_LINEDDA
DEFIPFNID IPFN_ENUMFONTFAMILIESA
DEFIPFNID IPFN_ENUMFONTSA
DEFIPFNID IPFN_ENUMMETAFILE
DEFIPFNID IPFN_ENUMPEN
DEFIPFNID IPFN_ENUMBRUSH

DEFCPFN   CPFN_GDICBCHECK

DEFIPFNID IPFN_WH_MSGFILTER
DEFIPFNID IPFN_WH_JOURNALRECORD
DEFIPFNID IPFN_WH_JOURNALPLAYBACK
DEFIPFNID IPFN_WH_KEYBOARD
DEFIPFNID IPFN_WH_GETMESSAGE
DEFIPFNID IPFN_WH_CALLWNDPROC
DEFIPFNID IPFN_WH_CBT
DEFIPFNID IPFN_WH_SYSMSGFILTER
DEFIPFNID IPFN_WH_MOUSE
DEFIPFNID IPFN_WH_HARDWARE
DEFIPFNID IPFN_WH_DEBUG
DEFIPFNID IPFN_WH_SHELL

DEFCPFN   CPFN_HOOKCBCHECK

DEFIPFNID IPFN_ABORTPROC
DEFIPFNID IPFN_OPENFILENAME
DEFIPFNID IPFN_CHOOSEFONT
DEFIPFNID IPFN_CHOOSECOLOR
DEFIPFNID IPFN_PRINTDLG

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\cvt.inc ===
;-----------------------------------------------------------------------;
; CVT.INC
;
; This module contains macros that generate 16-bit code to convert
; structures in either direction between 16-bit and 32-bit definitions.
;
; USE THIS EVERYWHERE!  USE THESE IN PACKING MACROS!  THESE ARE AS
; SMALL AND FAST AS INLINE IS EVER GOING TO BE.  DO NOT WRITE YOUR OWN.
;-----------------------------------------------------------------------;


;-----------------------------------------------------------------------;
; srcadj
;       adj     amount by which to adjust source pointer (DS:ESI)
;-----------------------------------------------------------------------;
srcadj  macro   adj
    ifnb <adj>
        add     esi,adj
    endif
endm


;-----------------------------------------------------------------------;
; dstadj
;       adj     amount by which to adjust destination pointer (ES:EDI)
;-----------------------------------------------------------------------;
dstadj  macro   adj
    ifnb <adj>
        add     edi,adj
    endif
endm




;-----------------------------------------------------------------------;
; copyw -- Copy a word
;-----------------------------------------------------------------------;
copyw   macro   adj
    srcadj  adj
    movsw   es:[edi],ds:[esi]
endm


;-----------------------------------------------------------------------;
; ncopyw -- Copy N words
;-----------------------------------------------------------------------;
ncopyw  macro   count:req
    mov     ecx, count
    rep     movsw es:[edi], ds:[esi]
endm




;-----------------------------------------------------------------------;
; copyd -- Copy a dword
;-----------------------------------------------------------------------;
copyd   macro   adj
    srcadj  adj
    movsd   es:[edi],ds:[esi]
endm


;-----------------------------------------------------------------------;
; ncopyd -- Copy N dwords
;-----------------------------------------------------------------------;
ncopyd  macro   count:req
    mov     ecx, count
    rep     movsd es:[edi],ds:[esi]
endm




;-----------------------------------------------------------------------;
; copysx -- Sign-extend an INT to a LONG
;-----------------------------------------------------------------------;
copysx  macro   adj
    srcadj  adj
    lodsw   ds:[si]
    cwde
    stosd   es:[edi]
endm


;------------------------------------------------------------------------;
; ncopysx - Sign-extend N INTs to LONGs
;------------------------------------------------------------------------;
ncopysx     macro   count:req, adj
    local   m1

    mov     cx, count
m1:
    copysx  adj
    loop    m1
endm




;-----------------------------------------------------------------------;
; copysx2 -- Copy and sign-extend a word to a dword, mapping 8000h
; to 80000000h.
;-----------------------------------------------------------------------;
copysx2  macro   adj
    local sign_extend_it
    local store_it

    srcadj  adj
    lodsw   ds:[si]
    cmp     ax,8000h
    jne     sign_extend_it

    ror     eax,16
    sub     ax,ax
    jmp     short store_it

sign_extend_it:
    cwde

store_it:
    stosd es:[edi]
endm


;-----------------------------------------------------------------------;
; ncopysx2
;-----------------------------------------------------------------------;
ncopysx2    macro   count:req, adj
    local   m1

    mov     cx, count
m1:
    copysx2 adj
    loop    m1
endm




;-----------------------------------------------------------------------;
; copyzx -- Copy and zero-extend a word to a dword
;-----------------------------------------------------------------------;
copyzx  macro   adj
    srcadj  adj
    lodsw   ds:[si]
    movzx   eax,ax
    stosd   es:[edi]
endm


;-----------------------------------------------------------------------;
; ncopyzx -- Zero-extend N WORDs to DWORDs
;-----------------------------------------------------------------------;
ncopyzx     macro   count:req
    local   m1

    xor     eax, eax
    mov     cx, count
m1:
    lodsw   ds:[si]
    stosd   es:[edi]
    loop    m1
endm




;-----------------------------------------------------------------------;
; copyt -- Copy and truncate a dword to a word
;-----------------------------------------------------------------------;
copyt   macro   adj
    srcadj  adj
    lodsd   ds:[esi]
    stosw   es:[di]
endm


;-----------------------------------------------------------------------;
; ncopyt -- Truncate N DWORDs to WORDs
;-----------------------------------------------------------------------;
ncopyt  macro   count:req
    local   m1

    mov     cx, count
m1:
    lodsd   ds:[esi]
    stosw   es:[di]
    loop    m1
endm



;-----------------------------------------------------------------------;
; copyt2 -- Copy and truncate a dword to a word, mapping 80000000
; to 8000.
;-----------------------------------------------------------------------;
copyt2   macro   adj
    local store_it

    srcadj  adj
    lodsd   ds:[esi]                ;get dword value
    cmp     eax,80000000h           ;is just the high bit set?
    jne     store_it                ;if not, just truncate
    ror     eax,16                  ;if yes, store 8000h
store_it:
    stosw   es:[di]
endm


;-----------------------------------------------------------------------;
; ncopyt2 -- Truncate N special DWORDs to WORDs
;-----------------------------------------------------------------------;
ncopyt2 macro   count:req, adj
    local   m1

    mov     cx, count
m1:
    copyt2  adj
    loop    m1
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\fltthk.inc ===
; File: fltthk.inc
;
;   Support macros and routines for the flat thunk mode of the thunk
;   compiler.
;
;   Included in *.asm files generated using the 
;   "flatthunks = true" semantic.
;





; Macro: FAPILOG16. Prints out a log message at the start of each thunk.
; Debug only.
FAPILOG16       macro   dwOffset
ifdef DEBUG
        pushd   offset FT_ThunkLogNames + dwOffset
        call    FAPILOG16_Hlp
endif ;DEBUG
endm ;FAPILOG16




ifdef DEBUG

LogApiThkLSF    proto   near stdcall, psz:dword

FAPILOG16_Hlp:
        push    ebp
        mov     ebp,[esp+8]

        invoke  LogApiThkLSF, ebp

        pop     ebp
        ret     4

endif ;DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\dlgthk.inc ===
CodeData equ <THUNK16BCodeData>

include     thkframe.inc
include     thkrp.inc
include     cbcheck.inc
include     public.inc

include     cbcid.inc
include     dlgcbid.inc

externDef FreeCallback:far16
externDef AllocCallback:far16
externDef ConvertDevModeHandleSL:far16
externDef ConvertDevNamesHandleSL:far16
externDef ConvertDevModeHandleLS:far16
externDef ConvertDevNamesHandleLS:far16


fLocalFlag      equ     fDlgLog16

; note: following size should be the same as in thunkcom\pack.h

OPENFILENAME16_SIZE         EQU  72
OPENFILENAME32_SIZE         EQU  76     ;4Ch
CHOOSECOLOR16_SIZE          EQU  32
CHOOSECOLOR32_SIZE          EQU  36     ;24h
CHOOSEFONT16_SIZE           EQU  46
CHOOSEFONT32_SIZE           EQU  60     ;3Ch
PRINTDLG16_SIZE             EQU  52
PRINTDLG32_SIZE             EQU  66     ;42h

LOGFONT16_SIZE              EQU  50

OFN16_Flags_OFFSET          EQU  48     ;30h 
CC16_rgbResult_OFFSET       EQU   8     ;08h
CF16_iPointSize_OFFSET      EQU  12     ;0Ch
CF16_Flags_OFFSET           EQU  14     ;0Dh
CF16_rgbColors_OFFSET       EQU  18     ;12h
CF16_nFontType_OFFSET       EQU  40     ;28h
PD16_hDevMode_OFFSET        EQU   6     ;06h
PD16_hDevNames_OFFSET       EQU   8     ;08h

OFN32_Flags_OFFSET          EQU  52     ;34h
OFN32_lpfnHook_OFFSET       EQU  68     ;44h
CC32_rgbResult_OFFSET       EQU  12     ;0Ch
CC32_Flags_OFFSET           EQU  20     ;14h
CC32_lpfnHook_OFFSET        EQU  28     ;1Ch
FR32_Flags_OFFSET           EQU  12     ;0CH
FR32_lpfnHook_OFFSET        EQU  32     ;20h
CF32_lpLogFont_OFFSET       EQU  12     ;0Ch
CF32_iPointSize_OFFSET      EQU  16     ;10h
CF32_Flags_OFFSET           EQU  20     ;14h
CF32_rgbColors_OFFSET       EQU  24     ;18h
CF32_lpfnHook_OFFSET        EQU  32     ;20h
CF32_nFontType_OFFSET       EQU  48     ;30h
PD32_Flags_OFFSET           EQU  20     ;1Ch
PD32_hDevMode_OFFSET        EQU   8     ;08h
PD32_hDevNames_OFFSET       EQU  12     ;0Ch
PD32_lpfnPrintHook_OFFSET   EQU  42     ;2Ah
PD32_lpfnSetupHook_OFFSET   EQU  46     ;2Eh


;---------------------------------------------------------------------------
; This macro does the work for GetOpenFilename() and GetSaveFilename().
; The argument "Flags" is a dword ptr expression denoting a thunk-compiler
; temporary that holds the Flags field of the OPENFILENAME struct.
;
; Assumption: If the hInst field is a global handle, the Win32 wrapper
; guaratees it's a (zero-extended) Win16 handle.
;---------------------------------------------------------------------------
RAWPACK__THKGETOPENORSAVEFILENAME_lpOfn    macro    iOffset,iTempOffset,Flags
    local   skip_it
    local    nohook,hook_done
    local    notemplate,template_done

    sub     sp,OPENFILENAME16_SIZE        ; alloc space for MapLS sels
    sub     sp,OPENFILENAME16_SIZE          ; alloc space on stack

    mov     eax,[bp+iOffset]             ; base address
    or      eax,eax                         ; check structure pointer
    jz      skip_it                         ; skip if null

    mov     [bp-iTempOffset],sp          ; save offset to buffer
    mov     [bp-iTempOffset+2],ss        ; save selector to buffer

    mov     di,ss
    mov     es,di
    movzx   edi,sp                          ; es:edi == destination address

    mov     esi,eax
    mov     ds,cs:CodeData                  ; need access to FlatData
    mov     ds,FlatData                     ; ds:esi == source address

    mov    eax,ds:[esi + OFN32_Flags_OFFSET]
    mov    Flags,eax

    cld


    lodsd   ds:[esi]              ;BUGBUG lStructSize should be checked here
    mov     eax,OPENFILENAME16_SIZE         ;sizeof(OPENFILENAME16)
    stosd   es:[edi]              ;lStructSize same size

; comments refer to action going 16->32

    ;hwndOwner
    copyt

    mov     ecx,Flags
    and     ecx,OFN_ENABLETEMPLATE
    lodsd   ds:[esi]        ;hInst
    MAP_CD_NULL_HINST    eax,ecx
    stosw   es:[edi]

    MAP_POINTER es:[di+OPENFILENAME16_SIZE] ;PLUGGED lpstrFilter
    MAP_POINTER es:[di+OPENFILENAME16_SIZE] ;PLUGGED lpstrCustomFilter
    ncopyd  2                               ;nMaxCustFilter,nFilterIndex
    MAP_POINTER es:[di+OPENFILENAME16_SIZE] ;PLUGGED lpstrFile
    copyd                                   ;nMaxFile
    MAP_POINTER es:[di+OPENFILENAME16_SIZE] ;PLUGGED lpstrFileTitle
    copyd                                   ;nMaxFileTitle
    MAP_POINTER es:[di+OPENFILENAME16_SIZE] ;PLUGGED lpstrInitialDir
    MAP_POINTER es:[di+OPENFILENAME16_SIZE] ;PLUGGED lpstrTitle
    copyd                                   ;Flags
    ncopyw  2                               ;nFileOffset,nFileExtension
    MAP_POINTER  es:[di+OPENFILENAME16_SIZE];PLUGGED lpstrDefExt
    copyd                                   ;lCustData

    test    Flags,OFN_ENABLEHOOK
    jz      nohook
    MAP_CALLBACK CBID_OPENFILENAME           ;PLUGGED lpfnHook
    jmp     short hook_done
nohook:
    copyd
hook_done:

    ;lpTemplate must be mapped only if OFN_ENABLETEMPLATE is set
    xor     eax,eax
    mov     es:[di+OPENFILENAME16_SIZE],eax  ;in case we skip mapping
    test    Flags, OFN_ENABLETEMPLATE         ; if OFN_ENABLETEMPLATE is set
    jz      notemplate
    MAP_POINTER  es:[di+OPENFILENAME16_SIZE] ;PLUGGED lpTemplateName
    jmp     short template_done
notemplate:
    copyd                       ;lpTemplate
template_done:
skip_it:
endm

RAWUNPACK__THKGETOPENORSAVEFILENAME_lpOfn macro    iOffset,iTempOffset,Flags
    local   skip_it
    local    nohook,hook_done
    local    notemplate,template_done

    mov     eax,[bp+iOffset]              ; base address
    or      eax,eax                          ; check structure pointer
    jz      skip_it                          ; skip if null

    mov     es,cs:CodeData
    mov     es,es:FlatData
    mov     edi,eax                          ; source in es:edi

    push    ds
    lds     si,[bp-iTempOffset]
    movzx   esi,si            ;in case code uses esi by accident

    cld

    lods    dword ptr ds:[si]               ;BUGBUG lStructSize should be checked here
    mov     eax,OPENFILENAME32_SIZE         ;sizeof(OPENFILENAME32)
    stos    dword ptr es:[edi]              ;lStructSize same size

; comments refer to action going 16->32

    copyzx
    mov     ecx,Flags
    and     ecx,OFN_ENABLETEMPLATE
    lodsw   ds:[si]         ;hInst
    UMAP_CD_NULL_HINST    ax,ecx
    stosd   es:[edi]
    UMAP_POINTER ds:[si+OPENFILENAME16_SIZE] ;lpstrFilter must be mapped
    UMAP_POINTER ds:[si+OPENFILENAME16_SIZE] ;lpstrCustomFilter must be mapped
    ncopyd  2
    UMAP_POINTER ds:[si+OPENFILENAME16_SIZE] ;lpstrFile must be mapped
    copyd
    UMAP_POINTER ds:[si+OPENFILENAME16_SIZE] ;lpstrFileTitle must be mapped
    copyd
    UMAP_POINTER ds:[si+OPENFILENAME16_SIZE] ;lpstrInitialDir must be mapped
    UMAP_POINTER ds:[si+OPENFILENAME16_SIZE] ;lpstrTitle must be mapped
    copyd
    ncopyw  2
    UMAP_POINTER ds:[si+OPENFILENAME16_SIZE] ;lpstrDefExt must be mapped
    copyd

    test    Flags,OFN_ENABLEHOOK
    jz      nohook
    lodsd   ds:[si]
    FREE_CALLBACK  CBID_OPENFILENAME
    stos    dword ptr es:[edi]
    jmp     short hook_done
nohook:
    copyd
hook_done:

    test    Flags,OFN_ENABLETEMPLATE
    jz      notemplate
    UMAP_POINTER ds:[si+OPENFILENAME16_SIZE] ;lpTemplateName must be mapped
    jmp     short template_done
notemplate:
    copyd
template_done:

    pop     ds
skip_it:

endm



;-----------------------------------------------------------------------------
; Pack/unpack OPENFILENAME struct for GetOpenFilename().
;-----------------------------------------------------------------------------
RAWPACK__THKGETOPENFILENAME_lpOfn    macro    iOffset,iTempOffset
    RAWPACK__THKGETOPENORSAVEFILENAME_lpOfn    iOffset,iTempOffset,dword ptr LOCAL__THKGETOPENFILENAME_Flags
endm

RAWUNPACK__THKGETOPENFILENAME_lpOfn    macro    iOffset,iTempOffset
    RAWUNPACK__THKGETOPENORSAVEFILENAME_lpOfn iOffset,iTempOffset,dword ptr LOCAL__THKGETOPENFILENAME_Flags
endm



;-----------------------------------------------------------------------------
; Pack/unpack OPENFILENAME struct for GetSaveFilename().
;-----------------------------------------------------------------------------
RAWPACK__THKGETSAVEFILENAME_lpOfn    macro    iOffset,iTempOffset
    RAWPACK__THKGETOPENORSAVEFILENAME_lpOfn    iOffset,iTempOffset,dword ptr LOCAL__THKGETSAVEFILENAME_Flags
endm

RAWUNPACK__THKGETSAVEFILENAME_lpOfn    macro    iOffset,iTempOffset
    RAWUNPACK__THKGETOPENORSAVEFILENAME_lpOfn iOffset,iTempOffset,dword ptr LOCAL__THKGETSAVEFILENAME_Flags
endm



;-----------------------------------------------------------------------------
; Pack CHOOSECOLOR struct for ChooseColor().
;
; Assumption: If the hInst field is a global handle, the Win32 wrapper
; guaratees it's a (zero-extended) Win16 handle.
;-----------------------------------------------------------------------------
RAWPACK__THKCHOOSECOLOR_lpcc        macro    iOffset,iTempOffset
    local        nohook,hook_done
    local        notemplate,template_done
    local        skip_it
    
    sub     sp,CHOOSECOLOR16_SIZE    ;Alloc space on stack

    mov     eax,[bp+iOffset]
    or      eax,eax
    jz      skip_it
    
    mov     [bp-iTempOffset],sp    ;Save offset to buffer
    mov     [bp-iTempOffset+2],ss    ;Save selector to buffer

    mov     di,ss
    mov     es,di
    movzx   edi,sp

    mov     esi,eax
    mov     ds,cs:CodeData
    mov     ds,FlatData

    mov     eax,ds:[esi + CC32_Flags_OFFSET]
    mov     LOCAL__THKCHOOSECOLOR_Flags,eax

    lodsd   ds:[esi]
    mov     eax,CHOOSECOLOR16_SIZE
    stosd   es:[di]    ;lStructSize

    ;hwndOwner
    copyt

    ;hInstance
    mov     ecx,LOCAL__THKCHOOSECOLOR_Flags
    and     ecx,CC_ENABLETEMPLATE
    lodsd   ds:[esi]    ;hInst
    MAP_CD_NULL_HINST    eax,ecx
    stosw   es:[di]

    ;rgbResult
    copyd

    MAP_POINTER    LOCAL__THKCHOOSECOLOR_lpCustColorsSeg  ;PLUGGED lpCustColors

    ;Flags, lCustData
    ncopyd  2

; Map hook function (only do the mapping if CC_ENABLEHOOK flag set).
    mov     eax,LOCAL__THKCHOOSECOLOR_Flags
    test    eax,CC_ENABLEHOOK
    jz      nohook
    MAP_CALLBACK    CBID_CHOOSECOLOR  ;PLUGGED lpfnHook
    jmp     short hook_done
nohook:
    copyd
hook_done:

; Map template name (only if CC_ENABLETEMPLATE flag set).
    mov     eax,LOCAL__THKCHOOSECOLOR_Flags
    test    eax,CC_ENABLETEMPLATE
    jz      notemplate
    MAP_POINTER    LOCAL__THKCHOOSECOLOR_lpTemplateNameSeg ;PLUGGED
    jmp     short template_done    ;lpTemplate
notemplate:
    copyd
template_done:
;  Finished

skip_it:
endm

;-----------------------------------------------------------------------------
; Unpack CHOOSECOLOR struct for ChooseColor().
;-----------------------------------------------------------------------------
RAWUNPACK__THKCHOOSECOLOR_lpcc    macro    iOffset,iTempOffset
    local   skip_it
    local    nohook

    mov     eax,[bp+iOffset]              ; base address
    or      eax,eax                          ; check structure pointer
    jz      skip_it                          ; skip if null

    mov     es,cs:CodeData
    mov     es,es:FlatData
    mov     edi,eax                          ; source in es:edi

; Free callback (if CC_ENABLEHOOK flag set).
    mov    eax,LOCAL__THKCHOOSECOLOR_Flags
    test    eax,CC_ENABLEHOOK
    jz    nohook
    mov     eax,es:[edi+CC32_lpfnHook_OFFSET]
    FREE_CALLBACK   CBID_CHOOSECOLOR
nohook:

; Propagate copy-outs field back to caller's struct.
    mov     si, [bp-iTempOffset]
    mov     eax,ss:[si+CC16_rgbResult_OFFSET]
    mov     es:[edi+CC32_rgbResult_OFFSET], eax

; Free up selectors (if no mapping happened, UnmapLS safely ignores
; NULL segments).
    pushd    LOCAL__THKCHOOSECOLOR_lpCustColorsSeg
    call    UnmapLS
    pushd    LOCAL__THKCHOOSECOLOR_lpTemplateNameSeg
    call    UnmapLS
skip_it:

endm




;-----------------------------------------------------------------------------
; Pack/unpack CHOOSEFONT struct for ChooseFont().
;
; Assumption: If the hInst field is a global handle, the Win32 wrapper
; guaratees it's a (zero-extended) Win16 handle.
;-----------------------------------------------------------------------------
RAWPACK__THKCHOOSEFONT_lpcf        macro    iOffset,iTempOffset
    local   skip_it
    local    nohook,hook_done
    local    notemplate,template_done
    local   no_log_font

    sub     sp,CHOOSEFONT16_SIZE+LOGFONT16_SIZE  ; alloc space on stack

    mov     eax,[bp+iOffset]             ; base address
    or      eax,eax                         ; check structure pointer
    jz      skip_it                         ; skip if null

    mov     [bp-iTempOffset],sp          ; save offset to buffer
    mov     [bp-iTempOffset+2],ss        ; save selector to buffer

    mov     di,ss
    mov     es,di
    movzx   edi,sp                          ; es:edi == destination address

    mov     esi,eax
    mov     ds,cs:CodeData                  ; need access to FlatData
    mov     ds,FlatData                     ; ds:esi == source address

    mov     eax,ds:[esi + CF32_Flags_OFFSET]
    mov     LOCAL__THKCHOOSEFONT_Flags,eax


    cld

; comments refer to action going 16->32

    lodsd   ds:[esi]              ;BUGBUG lStructSize should be checked here
    mov     eax,CHOOSEFONT16_SIZE           ;sizeof(CHOOSEFONT16)
    stosd   es:[di]                         ;lStructSize same size

    ;hwndOwner, hDC
    ncopyt  2

    lodsd   ds:[esi]
    or      eax,eax
    jz      no_log_font

    mov     ax,ss
    ror     eax,16
    mov     ax,di
    add     ax,CHOOSEFONT16_SIZE-8          ;already moved DI by 8

no_log_font:
    stosd   es:[di]                         ;lpLogFont widened (need to pack it)

    ;iPointSize
    copyt

    ;Flags, rgbColors, lCustData
    ncopyd  3
    
    test    dword ptr LOCAL__THKCHOOSEFONT_Flags,CF_ENABLEHOOK
    jz      nohook
    MAP_CALLBACK CBID_CHOOSEFONT            ;PLUGGED lpfnHook
    jmp     short hook_done
nohook:
    copyd
hook_done:

    test    dword ptr LOCAL__THKCHOOSEFONT_Flags,CF_ENABLETEMPLATE
    jz      notemplate
    MAP_POINTER  LOCAL__THKCHOOSEFONT_lpTemplateNameTemp  ;PLUGGED
    jmp     short template_done
notemplate:
    copyd
template_done:

    mov     ecx,LOCAL__THKCHOOSEFONT_Flags
    and     ecx,CF_ENABLETEMPLATE
    lodsd   ds:[esi]    ;hInst
    MAP_CD_NULL_HINST    eax,ecx
    stosw   es:[di]

    ;lpszStyle must be mapped
    MAP_POINTER LOCAL__THKCHOOSEFONT_lpszStyleTemp  ;PLUGGED

    ;nFontType, nSizeMin, nSizeMax
    ncopyt  3

    mov     esi,[bp+iOffset]             ; base address
    mov     esi,[esi].CF32_lpLogFont_OFFSET ; ds:esi == source address
    or      esi,esi                         ; check structure pointer
    jz      skip_it                         ; skip if null

    cld

; comments refer to action going 16->32

    ;lfHeight, lfWidth, lfEscapement, lfOrientation, lfWeight
    ncopyt  5

    ;lfItalic, ..., lfFaceName 
    ncopyd  (40/4)
skip_it:
endm

RAWUNPACK__THKCHOOSEFONT_lpcf        macro    iOffset,iTempOffset
    local   skip_it
    local    nohook

;!!! We're only unpacking the log font structure!  Does the rest of
;    the CHOOSEFONT structure need to be unpacked as well?

    mov     eax,[bp+iOffset]              ; base address
    or      eax,eax                          ; check structure pointer
    jz      skip_it                          ; skip if null

    

    mov     es,cs:CodeData
    mov     es,es:FlatData
    mov     edi,eax                          ; dest in es:edi

    test    dword ptr LOCAL__THKCHOOSEFONT_Flags,CF_ENABLEHOOK
    jz    nohook
    mov     eax,es:[edi+CF32_lpfnHook_OFFSET]
    FREE_CALLBACK   CBID_CHOOSEFONT
nohook:

;; The iPointSize, rgbColors, Flags & nFontType fields need to be copied back
;; to the caller's buffer.

    lds     si,dword ptr [bp-iTempOffset]
    movzx   esi,si

    mov     eax,[si+CF16_rgbColors_OFFSET]      ; rgbColors
    mov     es:[edi+CF32_rgbColors_OFFSET],eax

    mov     ax,[si+CF16_iPointSize_OFFSET]      ; iPointSize
    movsx   eax,ax
    mov     es:[edi+CF32_iPointSize_OFFSET],eax

    mov     eax,[si+CF16_Flags_OFFSET]          ; Flags
    mov     es:[edi+CF32_Flags_OFFSET],eax

    mov     ax,[si+CF16_nFontType_OFFSET]       ; nFontType
    movzx   eax,ax
    mov     es:[edi+CF32_nFontType_OFFSET],eax

    mov     edi,es:[edi+CF32_lpLogFont_OFFSET]
    or      edi,edi
    jz      skip_it

    add     si,CHOOSEFONT16_SIZE

; comments refer to action going 16->32

    cld

    ncopysx 5
    ncopyd  (40/4)

skip_it:
    pushd    LOCAL__THKCHOOSEFONT_lpszStyleTemp
    call    UnmapLS
    pushd    LOCAL__THKCHOOSEFONT_lpTemplateNameTemp
    call    UnmapLS

endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\icmthk.inc ===
;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\krnfthk.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\krnthksl.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\krnthk.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\lzfthk.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\gdicbid.inc ===
; Callback-type id's for GDI callbacks. All callback-type id's are
; 32-bits long and the upper 16-bits must be set to the module's
; Callback Client id.
;
; WARNING -- WARNING -- WARNING
;
;   Win32c.dll uses the lower 16 bits of CBID's to index directly into
;   the tables stored in GDI.EXE (gdicb16.asm) and GDI32.DLL (gdicb32.asm).
;   Those tables *must* match these id's or callbacks will fail miserably.
;   Do everyone a big favor and add new id's only at the end, and never
;   change an existing id.
;   

CBID_LINEDDA                    equ     (0 + (CBCID_GDI SHL 16))
CBID_ENUMPEN                    equ     (1 + (CBCID_GDI SHL 16))
CBID_ENUMBRUSH                  equ     (2 + (CBCID_GDI SHL 16))
CBID_ABORTPROC                  equ     (3 + (CBCID_GDI SHL 16))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\msnwapi.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\gdifthk.inc ===
; The 32-bit wrapper for GetCharWidth converted iLastChar into a nCnt
; for the thunk compiler's convenience. Here, we transform it back.
;
PUSH__GETCHARWIDTHAWRAPPER_nCnt macro   iOffset, iIgnore
        mov     eax, dword ptr [ebp + iOffset]
        add     eax, dword ptr [ebp + iOffset - 4]
        dec     eax
        push    ax
endm

PUSH__GETCHARWIDTHWWRAPPER_nCnt macro   iOffset, iIgnore
        mov     eax, dword ptr [ebp + iOffset]
        add     eax, dword ptr [ebp + iOffset - 4]
        dec     eax
        push    ax
endm



; The 32-bit wrapper for GetCharABCWidths converted iLastChar into a nCnt
; for the thunk compiler's convenience. Here, we transform it back.
;
PUSH__GETCHARABCWIDTHSAWRAPPER_nCnt macro iOffset, iIgnore
        mov     eax, dword ptr [ebp + iOffset]
        add     eax, dword ptr [ebp + iOffset - 4]
        dec     eax
        push    ax
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\mspfthk.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\mspthk.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\nwnpfthk.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\nw4fthk.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\nwpwdthk.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\lmabase.inc ===
W32S_FLAT_BASE  equ 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\gdithk.inc ===
CodeData equ <THUNK16BCodeData>

include thkrp.inc
include cbcheck.inc
include thkframe.inc
include public.inc
include thkmacro.inc
include struc.inc

include cbcid.inc
include gdicbid.inc

externDef PrivateEscape:near16
externDef CALLBACK_BODY_16:far16
externDef Escape:far16
externDef AllocCallback:far16
externDef MapLS:far16
externDef UnmapLS:far16
externDef GlobalAlloc:far16
externDef GlobalSize:far16
externDef GlobalFree:far16
externDef GlobalLock:far16
externDef GlobalUnlock:far16
externDef GetTextExtentPoint:far16
ifdef DEBUG
externDef _wsprintf:far16
externDef OutputDebugString:far16
endif

externDef AllocSelectorArray:far16
externDef SetSelectorBase:far16
externDef SetSelectorLimit:far16
externDef FreeSelector:far16
externDef SelectorAccessRights:far16
externDef GetLastError:far16


ilObjType equ 2

ObjPrivate      equ     2000H
Stock           equ     8000H
INT_OBJ_FLAGS       equ     (Stock or ObjPrivate)

INT_MIN_OBJ     equ     4f47h

INT_OBJ_PEN         equ     4f47h
INT_OBJ_BRUSH       equ     4f48h
INT_OBJ_FONT        equ     4f49h
INT_OBJ_PALETTE     equ     4f4ah

INT_OBJ_BITMAP      equ     4f4bh
INT_OBJ_RGN         equ     4f4ch
INT_OBJ_DC          equ     4f4dh
INT_OBJ_IC          equ     4f4eh
INT_OBJ_DISABLED_DC equ     4f4fh
INT_OBJ_METADC      equ     4f50h
INT_OBJ_METAFILE    equ     4f51h
INT_OBJ_MF          equ     4f52h

INT_MAX_OBJ         equ     4f52h

;; Writes message to debug port.
;;
;; Usage:
;;      DPRINT "I'm feeling buggy."
;;
DPRINT  macro   string
        local   mes, skip_mes

        jmp     skip_mes
mes     db      &string&,13,10,0
skip_mes:
        push    eax     ;Save all registers not preserved by PASCAL format.
        push    ebx
        push    ecx
        push    edx
        
        push    cs      ;Arg: OutputDebugString(lpstr)
        push    offset mes
        call    OutputDebugString

        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
endm  ;DPRINT


RECT16_SIZE             equ 8
POINT16_SIZE            equ 4
LOGFONT32_SIZE          equ 60
BITMAP32_SIZE           equ 24
DIBSECTION32_SIZE       equ 84    

BITMAP16  struc
bm16_Type       dw      ?
bm16_Width      dw      ?
bm16_Height     dw      ?
bm16_WidthBytes dw      ?
bm16_Planes     db      ?
bm16_BitsPixel  db      ?
bm16_Bits       dd      ?
BITMAP16  ends

BITMAP32  struc
bm32_Type       dd      ?
bm32_Width      dd      ?
bm32_Height     dd      ?
bm32_WidthBytes dd      ?
bm32_Planes     dw      ?
bm32_BitsPixel  dw      ?
bm32_Bits       dd      ?
BITMAP32  ends

ABC16 struc
abcA    dw      ?
abcB    dw      ?
abcC    dw      ?
ABC16 ends


fLocalFlag      equ     fGdiLog16


; Corresponds to the 32 bit BITMAPINFOHEADER structure.
BMIH32  struc
bi32_Size               dd      ?
bi32_Width              dd      ?
bi32_Height             dd      ?
bi32_Planes             dw      ?
bi32_BitCount           dw      ?
bi32_Compression        dd      ?
bi32_SizeImage          dd      ?
bi32_XPelsPerMeter      dd      ?       
bi32_YPelsPerMeter      dd      ?
bi32_ClrUsed            dd      ?
bi32_ClrImportant       dd      ?
BMIH32  ends


; Corresponds to the 32-bit BITMAPCOREHEADER structure.
BMCH32  struc
bc32_Size               dd      ?
bc32_Width              dw      ?
bc32_Height             dw      ?
bc32_Planes             dw      ?
bc32_BitCount           dw      ?
BMCH32  ends

; Corresponds to the 32-bit BITMAPV4HEADER structure.
BMV4H32  struc
bv432_Size               dd      ?
bv432_Width              dd      ?
bv432_Height             dd      ?
bv432_Planes             dw      ?
bv432_BitCount           dw      ?
bv432_Compression        dd      ?
bv432_SizeImage          dd      ?
bv432_XPelsPerMeter      dd      ?
bv432_YPelsPerMeter      dd      ?
bv432_ClrUsed            dd      ?
bv432_ClrImportant       dd      ?
bV432_RedMask            dd      ?
bV432_GreenMask          dd      ?
bV432_BlueMask           dd      ?
bV432_AlphaMask          dd      ?
bV432_CSType             dd      ?
bV4Endpoints             db  36 dup (?)
bV4GammaRed              dd      ?
bV4GammaGreen            dd      ?
bV4GammaBlue             dd      ?
BMV4H32  ends

BMV5H32  struc
bv532_Size               dd      ?
bv532_Width              dd      ?
bv532_Height             dd      ?
bv532_Planes             dw      ?
bv532_BitCount           dw      ?
bv532_Compression        dd      ?
bv532_SizeImage          dd      ?
bv532_XPelsPerMeter      dd      ?
bv532_YPelsPerMeter      dd      ?
bv532_ClrUsed            dd      ?
bv532_ClrImportant       dd      ?
bV532_RedMask            dd      ?
bV532_GreenMask          dd      ?
bV532_BlueMask           dd      ?
bV532_AlphaMask          dd      ?
bV532_CSType             dd      ?
bV5Endpoints             db  36 dup (?)
bV5GammaRed              dd      ?
bV5GammaGreen            dd      ?
bV5GammaBlue             dd      ?
bV5Intent                dd      ?
bV5ProfileData           dd      ?
bV5ProfileSize           dd      ?
bV5Reserved              dd      ?
BMV5H32  ends

THUNK16B SEGMENT WORD USE16 PUBLIC 'CODE'


IF 0

REPACK_DEVMODE_32_16 macro
externDef Repack_Devmode_32_16_Proc:near16
        call    Repack_Devmode_32_16_Proc
endm


;-----------------------------------------------------------------------;
; Repack_Pevmode_32_16_Proc
;
; Entry:
;       DS:ESI --> 32-bit source (ESI might be flat offset)
;       ES:EDI --> 16-bit destination (EDI is zero-extended from DI)
;       direction flag cleared
;-----------------------------------------------------------------------;
Repack_Devmode_32_16_Proc proc near public
;        local   done

        ;Move the common part as a single block move.
        MoveBytes       <(size DEVMODECOMMON)>

        ;Update the dmSize field
;;;;        mov     es:[di].(dmSize - (size DEVMODECOMMON)),size DEVMODE16

        ;!!!Clear out any win32-only flags
        ;and     es:[di].(dmFields - (size DEVMODECOMMON)),0FFFFh

        ;Insert win16-only fields.  EDI points to the byte after
        ;DEVMODECOMMON.  Afterwards, will point to byte after DEVMODE16.
        ;ZeroBytes       <((size DEVMODE16) - (size DEVMODECOMMON))>

        ;Skip over the extra win32 fields.  ESI still points to the byte
        ;after DEVMODECOMMON.
        add     esi,(size DEVMODE32) - (size DEVMODECOMMON)

        ;Move the driver-dependent part.  EDI points to the byte after
        ;DEVMODE16.
        mov     cx,es:[di].(dmDriverExtra - (size DEVMODE16))
        jcxz    done

        movzx   ecx,cx
        mov     edx,ecx
        shr     cx,2
        and     dx,3
        rep     movs dword ptr es:[edi],dword ptr ds:[esi]
        mov     cx,dx
        rep     movs byte ptr es:[edi],byte ptr ds:[esi]
done:
        ret
Repack_Devmode_32_16_Proc endp  

ENDIF


DIB_BITS_SIZE   macro
externDef Dib_Bits_Size_Proc:near16
        call    Dib_Bits_Size_Proc
endm

;-----------------------------------------------------------------------;
; Dib_Bits_Size_Proc
;
;   Inputs:
;       eax:  linear address of 32-bit BITMAPINFOHEADER (or BITMAPCOREHEADER)
;             struct.
;
;   Output:
;       ecx:  inferred size of bitmap data, or 0 for failure.
;
;   Formula is:
;       if bi32_Compression != (BI_RGB | BI_BITFIELDS)
;          size = bi32_SizeImage
;       else
;          size = ((Width * BitCount + 31) / 32) * 4 * Height * Planes
;-----------------------------------------------------------------------;

Dib_Bits_Size_Proc      proc near public
;       local   exit,fail_exit,use_formula
;       local   bitmapcoreheader,bitmapinfoheader
        push    ds
        mov     ds,FlatData
        mov     esi,eax

;       DPRINT  "DIB_BIT_SIZE: Computing bitmap data size."

;       int     3

        mov     eax, dword ptr [esi]
        cmp     eax, SIZEOF BMIH32
        je      bitmapinfoheader
        cmp     eax, SIZEOF BMV4H32
        je      bitmapinfoheader
        cmp     eax, SIZEOF BMV5H32
        je      bitmapinfoheader
        cmp     eax, SIZEOF BMCH32
        je      bitmapcoreheader

;       int     3
        jmp     fail_exit


bitmapcoreheader:
        movzx   eax, [esi].bc32_Width
        movzx   ebx,[esi].bc32_BitCount
        mul     ebx
        jc      fail_exit
        add     eax, 31
        jc      fail_exit
        shr     eax, 5          ;Divide by 32 (and exorcise remainder!)
        shl     eax, 2          ;Multiply by 4
        movzx   ecx, [esi].bc32_Height
        mul     ecx
        jc      fail_exit
        movzx   ebx,[esi].bc32_Planes
        mul     ebx
        mov     ecx,eax
        jnc     exit
        jmp     fail_exit

bitmapinfoheader:
        cmp     dword ptr [esi].bi32_Compression, BI_RGB
        je      use_formula
        cmp     dword ptr [esi].bi32_Compression, BI_BITFIELDS
        je      use_formula
        mov     ecx, [esi].bi32_SizeImage
        jmp     exit
use_formula:
;       DPRINT  "DIB_BIT_SIZE: Using formula."
        mov     eax, [esi].bi32_Width
        xor     ebx,ebx
        mov     bx,[esi].bi32_BitCount
        mul     ebx
        jc      fail_exit
        add     eax, 31
        jc      fail_exit
        shr     eax, 5          ;Divide by 32 (and exorcise remainder!)
        shl     eax, 2          ;Multiply by 4
        mov     ecx,[esi].bi32_Height
        test    ecx,ecx         ;top down dibs ?
        jns     got_height
        neg     ecx             ;make it positive.

got_height:
        mul     ecx
        jc      fail_exit
        xor     ebx,ebx
        mov     bx,[esi].bi32_Planes
        mul     ebx
        mov     ecx,eax
        jnc     exit

fail_exit:
        xor     ecx,ecx
exit:   
;       int     3
        pop     ds
        ret
Dib_Bits_Size_Proc      endp














THUNK16B ENDS


;-----------------------------------------------------------------------;
; UNPACK__GETTEXTMETRICSA_lpMetrics
;-----------------------------------------------------------------------;
UNPACK__GETTEXTMETRICSA_lpMetrics    macro x, y
    PACK_TEXTMETRIC_16_32
endm

;-----------------------------------------------------------------------;
; PUSH__SETABORTPROC_pfnAbort
;-----------------------------------------------------------------------;
PUSH__SETABORTPROC_pfnAbort    macro iOffset, iTempOffset
        push    dword ptr [bp+iOffset]
        push    dword ptr CBID_ABORTPROC
        call    AllocCallback
        push    dx
        push    ax
endm

;-----------------------------------------------------------------------;
; PACK__STARTDOCA_lpdi
;-----------------------------------------------------------------------;

OLD_DOCINFO_SIZE        equ     12
NEW_DOCINFO_SIZE        equ     20

PACK__STARTDOCA_lpdi macro iOffset, iTempOffset
        lods    dword ptr ds:[esi]

        ; ax == lpdi->cbSize
        ; if cbSize is not the new sizeof(DOCINFO),
        ; assume lpdi is a 3.x style DOCINFO

        cmp     ax,NEW_DOCINFO_SIZE
        je      @F
        mov     ax,OLD_DOCINFO_SIZE
@@:

        push    ax
        sub     ax,2
        stosw                   ;;cbSize (int)
        MAP_POINTER    LOCAL__STARTDOCA_lpszDocNameTemp  ;;PLUGGED lpszDocName
        MAP_POINTER    LOCAL__STARTDOCA_lpszOutputTemp   ;;PLUGGED lpszOutput

        pop     ax
        cmp     ax,OLD_DOCINFO_SIZE
        je      @F

        MAP_POINTER    LOCAL__STARTDOCA_lpszDatatypeTemp
        lods    dword ptr ds:[esi]
        stosd                   ;;fwType
@@:
endm

;-----------------------------------------------------------------------;
; UNPACK__STARTDOCA_lpdi
;-----------------------------------------------------------------------;
UNPACK__STARTDOCA_lpdi macro iOffset, iTempOffset
        pushd   LOCAL__STARTDOCA_lpszDocNameTemp
        call    UnmapLS
        pushd   LOCAL__STARTDOCA_lpszOutputTemp
        call    UnmapLS
        pushd   LOCAL__STARTDOCA_lpszDatatypeTemp
        call    UnmapLS
endm


;-----------------------------------------------------------------------;
; body_THKESCAPE
;-----------------------------------------------------------------------;
body_THKESCAPE macro
bp_hdc          equ <bp_top>
bp_nEscape      equ <bp_top+ 4>
bp_cbInput      equ <bp_top+ 8>
bp_lpInData     equ <bp_top+12>
bp_lpOutData    equ <bp_top+16>

        push    word ptr bp_hdc
        push    word ptr bp_nEscape
        push    word ptr bp_cbInput
        push    dword ptr bp_lpInData
        push    dword ptr bp_lpOutData
        call    PrivateEscape
endm

;-----------------------------------------------------------------------;
; body_SETMETAFILEBITSEX
;-----------------------------------------------------------------------;
body_SETMETAFILEBITSEX  macro
        local   exit

bp_nSize        equ <bp_top>
bp_lpvData      equ <bp_top+4>

bp_hmem         equ <[bp-2]>

        sub     sp,2            ;make space for bp_hmem

; Protect ourselves -- no pointer or no bytes to copy mean no reason to
; call Win3.1.

        mov     eax,bp_lpvData
        or      eax,eax
        jz      exit

        mov     eax,bp_nSize
        or      eax,eax
        jz      exit

; Allocate a global handle to pass to Win3.1.  If can't get handle return
; error.
;
;!!! This memory should be deleted in DeleteMetaFile.  If the app never
; calls DeletMetaFile, it will be deleted when the process dies because
; GlobalAlloc tags the memory with the process that allocated it.

        pushw   GMEM_MOVEABLE
        push    eax
        call    GlobalAlloc
        movzx   eax,ax          ;prepare for error return code
        or      ax,ax
        jz      exit

; Copy the data from the input buffer to the global memory we allocated.

        mov     bp_hmem,ax

        push    ds

        mov     ds,FlatData     ;DS:ESI --> source
        mov     esi,bp_lpvData  ;

        mov     es,ax           ;ES:EDI --> destination
        xor     edi,edi         ;


; Compute dword (ECX) and byte (DX) counts.  We can use DX because it will
; contain 0, 1, or 2.  When we copy bytes, the high word of ECX will already
; be zero from the dword-copy, so we only have to update CX for the
; byte-copy.

        mov     ecx,dword ptr bp_nSize
        mov     dx,cx
        shr     ecx,2
        and     dx,3

        cld
        rep     movs dword ptr es:[edi], dword ptr ds:[esi]
        mov     cx,dx
        rep     movs byte ptr es:[edi], byte ptr ds:[esi]

        pop     ds

; Since Win32 GetMetaFileBitsEx actually returns the bits for a disk
; metafile, we must patch the metafile header now.  (This is compatible
; with NT.)

        xor     edi,edi
        mov     word ptr es:[edi], 1    ; METAHEADER.mtType = MEMORYMETAFILE

; !!! SetMetaFileBitsBetter just returns the handle passed in.  With
; this assumption, we will be passing back the handle allocated above
; with GlobalAlloc.  

        push    word ptr bp_hmem
        call    SetMetaFileBitsBetter
        movzx   eax,ax          ;prepare return code

; EAX = return code (global memory handle)

exit:
endm



;-----------------------------------------------------------------------;
; CREATEBITMAP_COMMON:
;
;   Common thunk code for CreateBitmap() and CreateBitmapIndirect().
;   Tiles the bit buffer (if any), creates equivalent Win16 BITMAP
;   structure on stack and calls Win16 CreateBitmapIndirect(). 
;
;   Note: All device-dependent bitmap scan lines are word-padded (not
;     dword-padded) even in Win32 (decided this with DavidW: 2/93)
;
;   Entry points:
;         eax = 0:32 pointer to Win32 BITMAP structure.
;
;   Exit:
;         eax = result of Win16 CreateBitmapIndirect() if successfully 
;               thunked arguments. 0 if unsuccessful.
;
;-----------------------------------------------------------------------;
CREATEBITMAP_COMMON     macro
        local   exit,fail_exit,dwFreeInfo,wOldDS


;       DPRINT  "Just entered CREATEBITMAP_COMMON. eax -> Win32 BITMAP"
;       int     3

        push    bp
        mov     bp,sp

        push    ds              ;Save ds
        xor     edx,edx         ;New local (to store result of TILE_BUFFER)
        push    edx
wOldDS          equ     word ptr [bp - 2]
dwFreeInfo      equ     dword ptr [bp - 6]

        mov     ds,FlatData
        mov     esi,eax
        
;Infer the size of the bit buffer:
;
;   size = ((width * bitspixel + 15) / 16) * 2 * height * planes
;
        mov     ax,[esi].bm32_BitsPixel
        movzx   eax,ax
        mul     [esi].bm32_Width
        jc      fail_exit
        add     eax,15
        jc      fail_exit
        shr     eax,4
        shl     eax,1
        
        mov     ebx,eax         ;Tuck WidthBytes in safe register

        mul     [esi].bm32_Height
        jc      fail_exit
        xor     ecx,ecx
        mov     cx,[esi].bm32_Planes
        mul     ecx
        jc      fail_exit
        mov     ecx,eax

; assert(ecx == size of bm32_Bits buffer)

        sub     sp,14           ;make room for a Win16 BITMAP structure
        mov     ax,ss
        mov     es,ax
        mov     di,sp

; repack Win32 BITMAP (ds:esi) into Win16 BITMAP (es:di)

        lodsd   ds:[esi]        ;Type (DWORD->WORD)
        stosw   es:[di]
        lodsd   ds:[esi]        ;Width (DWORD->WORD)
        stosw   es:[di]
        lodsd   ds:[esi]        ;Height (DWORD->WORD)
        stosw   es:[di]
        add     esi,4           ;WidthBytes (DWORD->WORD)
        mov     ax,bx           ;  Replace with our own computed value
        stosw   es:[di]
        lodsw   ds:[esi]        ;Planes (WORD->BYTE)
        stosb   es:[di]
        lodsw   ds:[esi]        ;BitsPixel (WORD->BYTE)
        stosb   es:[di]
        lodsd   ds:[esi]        ;lpBits (0:32 -> tiled 0:16)

;       DPRINT  "CREATEBITMAP_COMMON: About to tile buffer"
;       int     3

        push    es              ;Save registers that TILE_BUFFER
        push    di              ; trashes
; assert (eax == 0:32 ptr to bit data, ecx == inferred size of bit buffer)
        TILE_BUFFER     
        pop     di
        pop     es
        jc      fail_exit       
        mov     dwFreeInfo,ecx  
        stosd   es:[di]         


        mov     bx,sp
        push    ss              ;Arg: CreateBitmapIndirect(lpbm)
        push    bx              ;^^^

;       DPRINT  "CREATEBITMAP_COMMON: About to call Win16 API."
;       int     3

        call    CreateBitmapIndirect
        movzx   eax,ax
        push    eax             ;save API result
        mov     ecx,dwFreeInfo
        UNTILE_BUFFER
        pop     eax             ;restore API result


        jmp     exit

fail_exit:
        xor     eax,eax
exit:
        mov     ds,wOldDS       ;do this before restoring sp!
        mov     sp,bp
        pop     bp


endm; CREATEBITMAP_COMMON

;-----------------------------------------------------------------------;
; body_CREATEBITMAPINDIRECT
;-----------------------------------------------------------------------;
body_CREATEBITMAPINDIRECT macro
        mov     eax,[bp_top]    ;eax == 0:32 pointer to Win32 BITMAP
        CREATEBITMAP_COMMON
endm


;-----------------------------------------------------------------------;
; body_CREATEBITMAP
;
;   Create equivalent Win32 BITMAP structure on stack and call
;     same code that CreateBitmapIndirect() does.
;-----------------------------------------------------------------------;
body_CREATEBITMAP macro

        local   bp_nWidth, bp_nHeight, bp_nPlanes, bp_nBitCount, bp_lpBits

bp_nWidth       equ     [bp_top]
bp_nHeight      equ     [bp_top+4]
bp_nPlanes      equ     [bp_top+8]
bp_nBitCount    equ     [bp_top+12]
bp_lpBits       equ     [bp_top+16]

;  Create an equivalent Win32 BITMAP structure on stack and pass it
;  to CreateBitmapIndirect
        
        pushd   bp_lpBits
        pushw   bp_nBitCount
        pushw   bp_nPlanes
        pushd   0       ;Dummy WidthBytes (CREATEBITMAPCOMMON ignores it)
        pushd   bp_nHeight
        pushd   bp_nWidth
        pushd   0       ;Type
        
        mov     ax,sp
        push    ss      ;Arg: MapSL(sel:off)
        push    ax      ;^^^
        call    MapSL   ;OK: ss is never a movable handle here.
        CREATEBITMAP_COMMON
        mov     sp,bp

endm  ;body_CREATEBITMAP



;-------------------------------------------------------------------------
; RAWPACK_GETBITMAPBITS
;-------------------------------------------------------------------------
RAWPACK__GETBITMAPBITS_lpBits   macro   lpBits,lp1616
        local   exit,fail_exit

        mov     eax,[bp + &lpBits]
        or      eax,eax
        jz      fail_exit
        mov     ecx,[bp_top + 4]        ;dwCount (size of buffer)
        or      ecx,ecx         
        jz      fail_exit       ;is this the right action??
        TILE_BUFFER
        mov     [bp - &lp1616&],eax
        mov     LOCAL__GETBITMAPBITS_dwFreeInfo,ecx
        jmp     exit

fail_exit:
        mov     sp,bp
        xor     eax,eax
        ERRCHK_EXIT     0,87,Exit_12
exit:
endm    ;RAWPACK_GETBITMAPBITS_lpBits



;-------------------------------------------------------------------------
; RAWUNPACK_GETBITMAPBITS
;-------------------------------------------------------------------------
RAWUNPACK__GETBITMAPBITS_lpBits macro   lpBits,lp1616
        mov     ecx,LOCAL__GETBITMAPBITS_dwFreeInfo
        UNTILE_BUFFER
endm ;RAWUNPACK_GETBITMAPBITS



;-------------------------------------------------------------------------
; RAWPACK_SETBITMAPBITS
;-------------------------------------------------------------------------
RAWPACK__SETBITMAPBITS_lpBits   macro   lpBits,lp1616
        local   exit,fail_exit

        mov     eax,[bp + &lpBits]
        or      eax,eax
        jz      fail_exit
        mov     ecx,[bp_top + 4]        ;dwCount (size of buffer)
        or      ecx,ecx         
        jz      fail_exit       ;(fail return or 0 bytes copied: it's the same)
        TILE_BUFFER
        mov     [bp - &lp1616&],eax
        mov     LOCAL__SETBITMAPBITS_dwFreeInfo,ecx
        jmp     exit

fail_exit:
        mov     sp,bp
        xor     eax,eax
        ERRCHK_EXIT     0,87,Exit_12
exit:  
endm  ;RAWPACK_SETBITMAPBITS



;-------------------------------------------------------------------------
; RAWUNPACK_SETBITMAPBITS
;-------------------------------------------------------------------------
RAWUNPACK__SETBITMAPBITS_lpBits macro   lpBits,lp1616
        mov     ecx,LOCAL__SETBITMAPBITS_dwFreeInfo
        UNTILE_BUFFER
endm ;RAWUNPACK_SETBITMAPBITS


;-----------------------------------------------------------------------;
; body_DELETEMETAFILE
;-----------------------------------------------------------------------;
body_DELETEMETAFILE     macro
        local   exit

bp_hmf  equ     <bp_top>

; !!! Determine whether or not to delete directly!

        push    bp_hmf
        call    DeleteMetaFile
        cwde


exit:
endm





IF 0

;-----------------------------------------------------------------------;
; body_CREATEICA
;-----------------------------------------------------------------------;
body_CREATEICA macro
        local   exit
        local   repack_devmode
        local   push_callframe

bp_lpszDriver   equ     <bp_top>
bp_lpszDevice   equ     <bp_top+4>
bp_lpszOutput   equ     <bp_top+8>
bp_lpdm         equ     <bp_top+12>


bp_lpdmTmp      equ     <dword ptr [bp-4]>
bp_hdm          equ     < word ptr [bp-6]>
bp_lpszDriverTmp   equ  <dword ptr [bp-10]>
bp_lpszDeviceTmp   equ  <dword ptr [bp-14]>
bp_lpszOutputTmp   equ  <dword ptr [bp-18]>


        sub     eax,eax
        push    eax                     ;bp_lpdmTmp
        push    ax                      ;bp_hdm
        push    eax                     ;bp_lpszDriverTmp
        push    eax                     ;bp_lpszDeviceTmp
        push    eax                     ;bp_lpszOutputTmp

        mov     ecx,bp_lpdm
        or      ecx,ecx
        jnz     repack_devmode
        jmp     push_callframe

; We have to repack the DEVMODE structure.  Compute the size needed,
; allocate it, setup pointers and invoke the macro to do the copying.
repack_devmode:

        push    word ptr GMEM_MOVEABLE

        mov     es,FlatData
        movzx   eax,es:[ecx].dmSize
        movzx   ecx,es:[ecx].dmDriverExtra
        add     eax,ecx
        push    eax

        call    GlobalAlloc
        movzx   eax,ax                  ;prepare for error
        or      ax,ax
        jz      exit
        mov     word ptr bp_hdm,ax

; Set up DS:ESI
;        ES:EDI

        push    ds
        mov     ds,FlatData
        mov     esi,bp_lpdm

        mov     es,ax
        sub     edi,edi
        mov     word ptr bp_lpdmTmp[0],di
        mov     word ptr bp_lpdmTmp[2],ax

        cld
        REPACK_DEVMODE_32_16
        pop     ds

push_callframe:
        push    dword ptr bp_lpszDriver
        call    MapLS  ;PLUGGED
        mov     bp_lpszDriverTmp,eax
        push    eax

        push    dword ptr bp_lpszDevice
        call    MapLS  ;PLUGGED
        mov     bp_lpszDeviceTmp,eax
        push    eax

        push    dword ptr bp_lpszOutput
        call    MapLS  ;PLUGGED
        mov     bp_lpszOutputTmp,eax
        push    eax

        push    bp_lpdmTmp
        call    CreateIC
        movzx   eax,ax

        push    eax

        mov     cx,bp_hdm    
        or      cx,cx
        jz      @F

        push    cx
        call    GlobalFree
@@:
        pushd   bp_lpszOutputTmp
        call    UnmapLS
        pushd   bp_lpszDeviceTmp
        call    UnmapLS
        pushd   bp_lpszDriverTmp
        call    UnmapLS
        pop     eax

exit:
endm

ENDIF


;-----------------------------------------------------------------------;
; body_GETOUTLINETEXTMETRICSA
;-----------------------------------------------------------------------;

OUTLINETEXTMETRIC16_SIZEX        equ     114+3*32+64
OUTLINETEXTMETRIC32_SIZEX        equ     212+3*32+64


body_GETOUTLINETEXTMETRICSA macro
        local   push_callframe
        local   exit

bp_hdc          equ     <bp_top>
bp_cbData       equ     <bp_top+4>
bp_lpotm        equ     <bp_top+8>

bp_lpotm16      equ     <dword ptr [bp-4]>
bp_lpotm32      equ     <dword ptr [bp-8]>

        sub     eax,eax
        push    eax                             ; Make room for lpotm16
        push    eax                             ; Make room for lpotm32

        cmp     dword ptr bp_lpotm, 0           ; Size call?
        je      push_callframe                  ; Yes, drop thru

; Make 16bit return buffer

        sub     sp, OUTLINETEXTMETRIC16_SIZEX
        mov     word ptr bp_lpotm16[0],sp
        mov     word ptr bp_lpotm16[2],ss

; Make 32bit temp buffer

        sub     sp, OUTLINETEXTMETRIC32_SIZEX
        mov     word ptr bp_lpotm32[0],sp
        mov     word ptr bp_lpotm32[2],ss

push_callframe:
        push    word ptr bp_hdc
        pushw   OUTLINETEXTMETRIC16_SIZEX
        push    dword ptr bp_lpotm16
        call    GetOutlineTextMetrics
        movzx   eax,ax

        test    eax, eax                        ; Win16 return success?
        jz      exit                            ; No, return NULL

        cmp     dword ptr bp_lpotm, 0           ; Caller really wants data?
        jne     unpackotm                       ; Yes, unpack and copy it to him
        add     eax, (OUTLINETEXTMETRIC32_SIZE - OUTLINETEXTMETRIC16_SIZE)
        jmp     exit                            ; No, add delta and return

unpackotm:
; Unpack the OUTLINETEXTMETRICS structure.

        push    eax                             ; Save rc
        push    ds                              ; Save ds

        xor     esi, esi                        ;
        lds     si, bp_lpotm16                  ; ds:[esi] -> otm16 temp
        xor     edi, edi                        ;
        les     di, bp_lpotm32                  ; es:[edi] -> otm32 temp
        cld

        PACK_OUTLINETEXTMETRIC_16_32

        pop     ds                              ; Restore ds (FlatLand)

        xor     esi, esi                        ; fs:[esi] -> otm32 temp
        lfs     si, bp_lpotm32                  ;
        mov     es, FlatData                    ; es:[edi] -> caller's buffer
        mov     edi, bp_lpotm                   ;

        mov     ecx, bp_cbData                  ; Copy amount caller requested
rep     movsb   es:[edi], fs:[esi]              ;

        pop     eax                             ; Restore rc

exit:
        mov     sp,bp
endm

;-----------------------------------------------------------------------;
; body_GETOBJECTA
;-----------------------------------------------------------------------;
body_GETOBJECTA macro
        local   exit
        local   type_palette
        local   type_brush
        local   type_pen
        local   type_font
        local   copy_bitmap
        local   copy_palette
        local   copy_brush
        local   copy_pen
        local   copy_font
        local   copy_data
        local   reload_dst
        local   GO_BUF_SIZE

bp_hObject      equ     <bp_top>
bp_nCount       equ     <bp_top+4>
bp_lpObject     equ     <bp_top+8>

bp_lpObjectTmp  equ     <dword ptr [bp-4]>

;Make the temporary buffer big enough for 32-bit DIBSECTION, the biggest
;structure returned by GetObjectA32.  We will allocate two temporary
;buffers.  The first will receive the bits from Win3.1.  The second
;will receive the repacked bits, and will then be copied to the output
;buffer.
;

GO_BUF_SIZE     equ     DIBSECTION32_SIZE

        xor     eax,eax
        push    eax                     ; ptr param #1   bp_lpObjectTmp

        sub     sp,GO_BUF_SIZE*2        ; alloc two temp buffers
        mov     word ptr bp_lpObjectTmp[0],sp   ; save buffer offset
        mov     word ptr bp_lpObjectTmp[2],ss   ; save buffer selector

; create new call frame and make the call

        push    word ptr bp_hObject
        push    word ptr GO_BUF_SIZE    ; temp buffer size     
        push    dword ptr bp_lpObjectTmp
        call    GetObject               ; call 16-bit version

        cwde

        or      ax,ax
        jz      exit                     ; nothing to unpack

        mov     si,bp_hObject           ; dereference the object & find out
        mov     cx,INT_OBJ_FONT         ; assume it's a font
        test    si,2                    ; is it a moveable handle
        jz      GO_Branch               ; if not it must be a font
        mov     si,[si]                 ; what type it is (LMHtoP)
        mov     cx,[si].ilObjType       ;
        and     ch,HIGH (NOT INT_OBJ_FLAGS) ;

GO_Branch:
        mov     si,word ptr bp_lpObjectTmp
        mov     edi,dword ptr bp_lpObject

        cld

        cmp     cx,INT_OBJ_PALETTE
        je      type_palette

        cmp     cx,INT_OBJ_BRUSH
        je      type_brush

        cmp     cx,INT_OBJ_PEN
        je      type_pen

        cmp     cx,INT_OBJ_FONT
        je      type_font

; Structure conversion code
; Each of these code fragments must leave with
; eax = computed number of bytes for return structure.

; bitmap
        or      edi,edi
        jnz     copy_bitmap

        mov     eax,DIBSECTION32_SIZE   ; sizeof DIBSECTION
        jmp     exit

copy_bitmap:
        mov     di,ss
        mov     ds,di
        mov     es,di
        lea     di,[si+GO_BUF_SIZE]

        lodsw                           ; bmType
        cwde
        stosd

        lodsw                           ; bmWidth
        mov     cx,ax
        cwde
        stosd

        lodsw                           ; bmHeight
        cwde
        stosd

        lodsw                           ; bmWidthBytes
        cwde
        stosd                           ;store it

        lodsb                           ; bmPlanes
        cbw
        stosw

        lodsb                           ; bmBitsPixel
        cbw
        stosw

; the bmBits field will be non NULL for CreateDIBSection bitmaps and we need
; to convert that to a flat pointer.

        lodsd                           ; get bmBits
        or      eax,eax                 ; is it null ?
        jz      short @f                ; yes, no translation needed.
        push    eax                     ; 16:16 pointer
        call    MapSL                   ; convert to flat.
@@:
        stosd                           ; save.

; what follows now is the DIBSECTION structure minus the BITMAP structure.
; however, all the fields here are properly aligned and can be moved in one shot.

        mov     cx,(DIBSECTION32_SIZE - BITMAP32_SIZE)/4
        .errnz  (DIBSECTION32_SIZE - BITMAP32_SIZE) and 3
        rep     movsd
        mov     eax,DIBSECTION32_SIZE   ; bytes generated thus far.
        jmp     copy_data

type_font:
        or      edi,edi
        jnz     copy_font

        mov     eax,LOGFONT32_SIZE
        jmp     exit

copy_font:
        mov     di,ss
        mov     ds,di
        mov     es,di
        lea     di,[si+GO_BUF_SIZE]
        PACK_LOGFONT_16_32
        mov     eax,LOGFONT32_SIZE
        jmp     copy_data

type_pen:
        or      edi,edi
        jnz     copy_pen

        mov     eax,LOGPEN32_SIZE
        jmp     exit

copy_pen:
        mov     di,ss
        mov     ds,di
        mov     es,di
        lea     di,[si+GO_BUF_SIZE]

        lodsw                           ; lopnStyle
        cwde
        stosd

        lodsw                           ; lopnWidth.x
        cwde
        stosd

        lodsw                           ; lopnWidth.y
        cwde
        stosd

        movsd                           ; lopnColor

        mov     eax,LOGPEN32_SIZE
        jmp     copy_data

type_brush:
        or      edi,edi
        jnz     copy_brush

        mov     eax,LOGBRUSH32_SIZE
        jmp     exit

copy_brush:
        mov     di,ss
        mov     ds,di
        mov     es,di
        lea     di,[si+GO_BUF_SIZE]

        lodsw                           ; lbStyle
        cwde
        stosd

        movsd                           ; lbColor

        lodsw                           ; lbHatch
        cwde
        stosd

        mov     eax,LOGBRUSH32_SIZE
        jmp     copy_data

type_palette:
        or      edi,edi
        jnz     copy_palette

        mov     eax,4                   ; only 4 bytes returned
        jmp     exit

copy_palette:
        mov     di,ss
        mov     ds,di
        mov     es,di
        lea     di,[si+GO_BUF_SIZE]

        lodsw
        movzx   eax,ax
        stosd

        mov     eax,4                   ; only 4 bytes returned
; Copy converted data to caller's buffer.
; eax = computed byte count
copy_data:
        mov     ecx,dword ptr bp_nCount
        cmp     ecx,eax
        jb      reload_dst
        mov     ecx,eax

reload_dst:
        push    ecx                     ; save return code
        mov     edx,ecx
        shr     ecx,2
        and     edx,3
        movzx   esi,word ptr bp_lpObjectTmp
        add     esi,GO_BUF_SIZE
        mov     es,cs:THUNK16BCodeData
        mov     es,es:FlatData
        mov     edi,dword ptr bp_lpObject
        rep     movs    dword ptr es:[edi],dword ptr ds:[esi]
        mov     ecx,edx
        rep     movs    byte ptr es:[edi],byte ptr ds:[esi]
        pop     eax                     ; restore return code directly to eax

exit:
endm



;------------------------------------------------------------------------
; RAWPACK__GETFONTDATA_lpvBuffer
;------------------------------------------------------------------------

; Special cases:
;          lpvBuffer == NULL  return size of required buffer
;          cbData    == 0     return size of required buffer

RAWPACK__GETFONTDATA_lpvBuffer  macro   lpvBufferOff, lp16Off

        local   fail_exit,exit,cbData

cbData  equ     <[bp_top + 16]>         ;size of lpvBuffer

        mov     eax,[bp + &lpvBufferOff&]
        mov     ecx,cbData
        TILE_BUFFER
        jc      fail_exit
        mov     dword ptr [bp - &lp16Off&], eax
        mov     dword ptr LOCAL__GETFONTDATA_dwFreeInfo, ecx
        
        jmp     exit

fail_exit:
        mov     sp,bp   
        xor     eax,eax         ;GetFontData() returns -1 to indicate
        dec     eax             ; failure.
        ERRCHK_EXIT     -1,87,Exit_20
        
exit:

endm    ;RAWPACK__GETFONTDATA_lpvBuffer 


;------------------------------------------------------------------------
; RAWUNPACK__GETFONTDATA_lpvBuffer
;------------------------------------------------------------------------
RAWUNPACK__GETFONTDATA_lpvBuffer macro  lpvBufferOff, lp16Off

        mov     ecx, dword ptr LOCAL__GETFONTDATA_dwFreeInfo
        UNTILE_BUFFER   

endm    ;RAWUNPACK__GETFONTDATA_lpvBuffer 






;------------------------------------------------------------------------
; RAWPACK__GETGLYPHOUTLINEA_lpvBuffer
;------------------------------------------------------------------------
;
; Special cases:
;       lpvBuffer == NULL    return size of required buffer
;       cbData    == 0       return size of required buffer
RAWPACK__GETGLYPHOUTLINEA_lpvBuffer     macro   lpvBufferOff, lp16Off

        local   fail_exit,exit,cbData

cbData  equ     <[bp_top + 16]>         ;size of user's buffer
        

        mov     eax,[bp+&lpvBufferOff&]
        mov     ecx,cbData
        TILE_BUFFER
        jc      fail_exit
        mov     dword ptr [bp - &lp16Off&], eax
        mov     dword ptr LOCAL__GETGLYPHOUTLINEA_dwFreeInfo, ecx
        jmp     exit

fail_exit:
        mov     sp,bp
        xor     eax,eax
        dec     eax
        ERRCHK_EXIT     -1,87,Exit_28
        
exit:

endm    ;RAWPACK__GETGLYPHOUTLINEA_lpvBuffer 


;------------------------------------------------------------------------
; RAWUNPACK__GETGLYPHOUTLINEA_lpvBuffer
;------------------------------------------------------------------------
RAWUNPACK__GETGLYPHOUTLINEA_lpvBuffer macro     lpvBufferOff, lp16Off

        mov     ecx, LOCAL__GETGLYPHOUTLINEA_dwFreeInfo
        UNTILE_BUFFER

endm    ;RAWUNPACK__GETGLYPHOUTLINEA_lpvBuffer 




;------------------------------------------------------------------------
; RAWPACK__GETKERNINGPAIRSA_lpkp
;------------------------------------------------------------------------
RAWPACK__GETKERNINGPAIRSA_lpkp  macro   lpkpOff, lp16Off

        local   fail_exit,exit,cPairs,tile_it
        

cPairs  equ     <[bp_top + 4]>

        mov     eax,[bp+&lpkpOff&]
        or      eax,eax
        jz      tile_it

        mov     ecx,cPairs
        or      ecx,ecx         ;if the buffer size is 0, function 
        jz      fail_exit       ; should return 0.
        cmp     ecx,10000h      ;make sure buffer size will fit in
        jae     fail_exit       ; a Win16 INT.
        shl     ecx,1
        mov     edx,ecx
        shl     ecx,1
        add     ecx,edx
; assert(ecx == cPairs * 6)
tile_it:
;       int     3
        TILE_BUFFER     
;       int     3
        jc      fail_exit
        mov     dword ptr [bp - &lp16Off&], eax
        mov     dword ptr LOCAL__GETKERNINGPAIRSA_dwFreeInfo,ecx
        jmp     exit

fail_exit:
        mov     sp,bp
        xor     eax,eax
        ERRCHK_EXIT     0,87,Exit_12
        
exit:

endm    ;RAWPACK__GETKERNINGPAIRSA_lpkp 


;------------------------------------------------------------------------
; RAWUNPACK__GETKERNINGPAIRSA_lpkp
;------------------------------------------------------------------------
RAWUNPACK__GETKERNINGPAIRSA_lpkp macro  lpkpOff, lp16Off

        local   exit,cPairs,unpack_loop

cPairs  equ     <[bp_top + 4]>

;       int     3

        test    ax, ax          ; Any pairs returned?
        jz      exit            ; No, skip out


        mov     esi,[bp + &lpkpOff&]
        or      esi,esi
        jz      exit


        push    ds
        push    es

        movzx   ecx,ax          ; Get # pairs in ecx

        mov     ds,FlatData
        mov     ax,ds
        mov     es,ax
        
        shl     ecx,1
        mov     edx,ecx
        shl     ecx,1

;  assert(edx == 2*cPairs)
;  assert(ecx == 4*cPairs)
        add     esi,edx
        add     esi,ecx
        dec     esi
        dec     esi
;  assert(esi == lpkp + 6*cPairs - 2)

        mov     edi,esi
        add     edi,edx

;       assert(edi == lpkp + 8*cPairs - 2)

        shr     ecx,2           ;Restore ecx to cPairs
        std
unpack_loop:
        lodsw   ds:[esi]
        cwde
        dec     edi
        dec     edi
        stosd   es:[edi]
        inc     edi
        inc     edi
        movsw   es:[edi],ds:[esi]
        movsw   es:[edi],ds:[esi]
        loopd   unpack_loop
        cld

        pop     es
        pop     ds


exit:
        mov     ecx,dword ptr LOCAL__GETKERNINGPAIRSA_dwFreeInfo
        UNTILE_BUFFER

;       int     3

endm    ;RAWUNPACK__GETKERNINGPAIRSA_lpkp 


IF 0

;-----------------------------------------------------------------------;
; body_RESETDCA
;-----------------------------------------------------------------------;
body_RESETDCA macro
        local   exit
        local   repack_devmode
        local   push_callframe

bp_hdc          equ     <bp_top>
bp_lpdm         equ     <bp_top+4>

bp_lpdmTmp      equ     <dword ptr [bp-4]>
bp_hdm          equ     < word ptr [bp-6]>

        sub     eax,eax
        push    eax                     ;bp_lpdmTmp
        push    ax                      ;bp_hdm

        mov     ecx,bp_lpdm
        or      ecx,ecx
        jnz     repack_devmode
        jmp     push_callframe

; We have to repack the DEVMODE structure.  Compute the size needed,
; allocate it, setup pointers and invoke the macro to do the copying.
repack_devmode:

        push    word ptr GMEM_MOVEABLE

        mov     es,FlatData
        movzx   eax,es:[ecx].dmSize
        movzx   ecx,es:[ecx].dmDriverExtra
        add     eax,ecx
        push    eax

        call    GlobalAlloc
        movzx   eax,ax                  ;prepare for error
        or      ax,ax
        jz      exit
        mov     word ptr bp_hdm,ax

; Set up DS:ESI
;        ES:EDI

        push    ds
        mov     ds,FlatData
        mov     esi,bp_lpdm

        mov     es,ax
        sub     edi,edi
        mov     word ptr bp_lpdmTmp[0],di
        mov     word ptr bp_lpdmTmp[2],ax

        cld
        REPACK_DEVMODE_32_16
        pop     ds

push_callframe:
        push    word ptr bp_hdc

        push    bp_lpdmTmp
        call    ResetDC
        movzx   eax,ax

        mov     cx,bp_hdm
        or      cx,cx
        jz      exit

        push    eax
        push    cx
        call    GlobalFree
        pop     eax

exit:
endm

ENDIF


;---------------------------------------------------------------------------;
; RAWPACK__THKCREATEDIBITMAP_lpInitBits
;---------------------------------------------------------------------------;
RAWPACK__THKCREATEDIBITMAP_lpInitBits macro     lpBits, lp1616
        
        local   exit,fail_exit

        cmp     dword ptr [bp_top+8], CBM_INIT
        jne     exit            ;lp1616 already contains 0:0 pointer

        mov     eax,[bp_top + 16]       ;Get pointer to BITMAPINFOHEADER
        DIB_BITS_SIZE
        or      ecx,ecx
        jz      fail_exit
        mov     eax,[bp + &lpBits&]
        or      eax,eax
        jz      fail_exit
        TILE_BUFFER
        jc      fail_exit
        mov     dword ptr [bp - &lp1616&], eax
        mov     dword ptr LOCAL__THKCREATEDIBITMAP_dwFreeInfo, ecx
        jmp     exit

fail_exit:
        mov     sp,bp
        xor     eax,eax
        ERRCHK_EXIT     0,87,Exit_24
exit:


endm ;RAWPACK__THKCREATEDIBITMAP_lpInitBits


;---------------------------------------------------------------------------;
; RAWUNPACK__THKCREATEDIBITMAP_lpInitBits
;---------------------------------------------------------------------------;
RAWUNPACK__THKCREATEDIBITMAP_lpInitBits macro   lpBits, lp1616
        
        mov     ecx,dword ptr LOCAL__THKCREATEDIBITMAP_dwFreeInfo
        UNTILE_BUFFER


endm ;RAWUNPACK__THKCREATEDIBITMAP_lpInitBits





;---------------------------------------------------------------------------;
; RAWPACK__STRETCHDIBITS_lpBits
;---------------------------------------------------------------------------;
RAWPACK__STRETCHDIBITS_lpBits macro     lpBits, lp1616
        
        local   exit,fail_exit

        mov     eax,[bp_top + 40]       ;Get pointer to BITMAPINFOHEADER
        DIB_BITS_SIZE
        or      ecx,ecx
        jz      fail_exit
        mov     eax,[bp + &lpBits&]
        or      eax,eax
        jz      fail_exit
        TILE_BUFFER
        jc      fail_exit
        mov     dword ptr [bp - &lp1616&], eax
        mov     dword ptr LOCAL__STRETCHDIBITS_dwFreeInfo, ecx
        jmp     exit

fail_exit:
        mov     sp,bp
        xor     eax,eax
        dec     eax
        ERRCHK_EXIT     -1,87,Exit_52
exit:


endm ;RAWPACK__STRETCHDIBITS_lpBits


;---------------------------------------------------------------------------;
; RAWUNPACK__STRETCHDIBITS_lpBits
;---------------------------------------------------------------------------;
RAWUNPACK__STRETCHDIBITS_lpBits macro   lpBits, lp1616
        
        mov     ecx,dword ptr LOCAL__STRETCHDIBITS_dwFreeInfo
        UNTILE_BUFFER


endm ;RAWUNPACK__STRETCHDIBITS_lpBits


;---------------------------------------------------------------------------;
; RAWPACK__SETDIBITS_lpBits
;---------------------------------------------------------------------------;
RAWPACK__SETDIBITS_lpBits macro lpBits, lp1616
        
        local   exit,fail_exit

        mov     eax,[bp_top + 20]       ;Get pointer to BITMAPINFOHEADER
        DIB_BITS_SIZE
        or      ecx,ecx
        jz      fail_exit
        mov     eax,[bp + &lpBits&]
        or      eax,eax
        jz      fail_exit
        TILE_BUFFER
        jc      fail_exit
        mov     dword ptr [bp - &lp1616&], eax
        mov     dword ptr LOCAL__SETDIBITS_dwFreeInfo, ecx
        jmp     exit

fail_exit:
        mov     sp,bp
        xor     eax,eax
        ERRCHK_EXIT     0,87,Exit_28
exit:


endm ;RAWPACK__SETDIBITS_lpBits


;---------------------------------------------------------------------------;
; RAWUNPACK__SETDIBITS_lpBits
;---------------------------------------------------------------------------;
RAWUNPACK__SETDIBITS_lpBits macro       lpBits, lp1616
        
        mov     ecx,dword ptr LOCAL__SETDIBITS_dwFreeInfo
        UNTILE_BUFFER


endm ;RAWUNPACK__SETDIBITS_lpBits






;---------------------------------------------------------------------------;
; RAWPACK__GETDIBITS_lpBits
;---------------------------------------------------------------------------;
RAWPACK__GETDIBITS_lpBits macro lpBits, lp1616
        
        local   exit,null_exit,fail_exit

        mov     eax,[bp + &lpBits&]
        or      eax,eax
        jz      null_exit

        mov     eax,[bp_top + 20]       ;Get pointer to BITMAPINFOHEADER
        DIB_BITS_SIZE
        or      ecx,ecx
        jz      fail_exit
        mov     eax,[bp + &lpBits&]
        TILE_BUFFER
        jc      fail_exit
        mov     dword ptr [bp - &lp1616&], eax
        mov     dword ptr LOCAL__GETDIBITS_dwFreeInfo, ecx
        jmp     exit

fail_exit:
        mov     sp,bp
        xor     eax,eax
        ERRCHK_EXIT     0,87,Exit_28
null_exit:
        xor     eax,eax
        mov     dword ptr LOCAL__GETDIBITS_dwFreeInfo,eax
exit:


endm ;RAWPACK__GETDIBITS_lpBits


;---------------------------------------------------------------------------;
; RAWUNPACK__GETDIBITS_lpBits
;---------------------------------------------------------------------------;
RAWUNPACK__GETDIBITS_lpBits macro       lpBits, lp1616
        
        mov     ecx,dword ptr LOCAL__GETDIBITS_dwFreeInfo
        UNTILE_BUFFER


endm ;RAWUNPACK__GETDIBITS_lpBits




;---------------------------------------------------------------------------;
; RAWPACK__SETDIBITSTODEVICE_lpBits
;---------------------------------------------------------------------------;
RAWPACK__SETDIBITSTODEVICE_lpBits macro lpBits, lp1616
        
        local   exit,fail_exit

        mov     eax,[bp_top + 40]       ;Get pointer to BITMAPINFOHEADER
        DIB_BITS_SIZE
        or      ecx,ecx
        jz      fail_exit
        mov     eax,[bp + &lpBits&]
        or      eax,eax
        jz      fail_exit
        TILE_BUFFER
        jc      fail_exit
        mov     dword ptr [bp - &lp1616&], eax
        mov     dword ptr LOCAL__SETDIBITSTODEVICE_dwFreeInfo, ecx
        jmp     exit

fail_exit:
        mov     sp,bp
        xor     eax,eax
        ERRCHK_EXIT     0,87,Exit_48

exit:


endm ;RAWPACK__SETDIBITSTODEVICE_lpBits


;---------------------------------------------------------------------------;
; RAWUNPACK__SETDIBITSTODEVICE_lpBits
;---------------------------------------------------------------------------;
RAWUNPACK__SETDIBITSTODEVICE_lpBits macro       lpBits, lp1616
        
        mov     ecx,dword ptr LOCAL__SETDIBITSTODEVICE_dwFreeInfo
        UNTILE_BUFFER


endm ;RAWUNPACK__SETDIBITSTODEVICE_lpBits







;---------------------------------------------------------------------------;
; RAWPACK__PLAYMETAFILERECORD_lpMetaRecord
;---------------------------------------------------------------------------;
RAWPACK__PLAYMETAFILERECORD_lpMetaRecord macro  lpMFR, lp1616
        
        local   exit,fail_exit

        mov     eax,[bp + &lpMFR&]
        or      eax,eax
        jz      fail_exit
        mov     es,FlatData
        mov     ecx,es:[eax]
        shl     ecx,1
        jc      fail_exit
        add     ecx,4                   ; add some slop in case drivers touch
        jo      fail_exit               ; a little too much... #9978,win95c
        TILE_BUFFER
        jc      fail_exit
        mov     dword ptr [bp - &lp1616&], eax
        mov     dword ptr LOCAL__PLAYMETAFILERECORD_dwFreeInfo, ecx
        jmp     exit

fail_exit:
        mov     sp,bp
        xor     eax,eax                 ;PlayMetaFileRecord doesn't return a
        ERRCHK_EXIT     0,87,Exit_16    ;a value, so fake it.
exit:


endm ;RAWPACK__PLAYMETAFILERECORD_lpMetaRecord


;---------------------------------------------------------------------------;
; RAWUNPACK__PLAYMETAFILERECORD_lpMetaRecord
;---------------------------------------------------------------------------;
RAWUNPACK__PLAYMETAFILERECORD_lpMetaRecord macro        lpMFR, lp1616
        
        mov     ecx,dword ptr LOCAL__PLAYMETAFILERECORD_dwFreeInfo
        UNTILE_BUFFER

endm ;RAWUNPACK__PLAYMETAFILERECORD_lpMetaRecord

;---------------------------------------------------------------------------;
; Return value for PlayMetaFileRecord
;---------------------------------------------------------------------------;
RET__PLAYMETAFILERECORD macro
; The 16-bit PlayMetaFileRecord API has a void return but the Win32 version
; has a BOOL return so always return success.
        mov     eax,1                   
        endm

;---------------------------------------------------------------------------
; Handling error code of STARTDOC api.
;---------------------------------------------------------------------------
err_STARTDOCA   macro
        local   exit,l1,l2,l3,l4

        cmp     eax,0   ;Avoid overhead when successful
        jge     exit

        cmp     eax,-1  ;SP_ERROR, generic error, check GetLastError()
        jne     l1
        call    GetLastError
        cmp     eax,0
        jne     l4      ;if GetLastError() != 0, exit

        pushd   87      ;if GetLastError() == 0, SetLastError(INVALID_PARAM)
        call    SetLastError
        jmp     l4

; This expands to a pretty embarrassing control structure (checks
; against all four values even after a match is found). Looking forward
; to throwing this out when we optimize the thunk layer.
;       ERRCHK_EXIT     -1,87,l1        ;SP_ERROR -> BAD_PARAM

l1:     ERRCHK_EXIT     -4,112,l2       ;SP_OUTOFDISK -> DISK_FULL
l2:     ERRCHK_EXIT     -5,8,l3         ;SP_OUTOFMEMORY -> NOT_ENOUGH_MEM
l3:     ERRCHK_EXIT     -3,63,l4        ;SP_USERABORT -> PRINT_CANCELLED
l4:     mov     eax,-1                  ;return SP_ERROR for failure
        
exit:
endm ;err_STARTDOCA


;---------------------------------------------------------------------------
; Handling error code of ESCAPE api.
;---------------------------------------------------------------------------
err_THKESCAPE   macro
        local   exit,l1,l2,l3

        cmp     eax,0   ;Avoid overhead when successful
        jge     exit

; This expands to a pretty embarrassing control structure (checks
; against all four values even after a match is found). Looking forward
; to throwing this out when we optimize the thunk layer.
        ERRCHK_EXIT     -1,87,l1        ;SP_ERROR -> BAD_PARAM
l1:     ERRCHK_EXIT     -4,112,l2       ;SP_OUTOFDISK -> DISK_FULL
l2:     ERRCHK_EXIT     -5,8,l3         ;SP_OUTOFMEMORY -> NOT_ENOUGH_MEM
l3:     ERRCHK_EXIT     -3,63,exit      ;SP_USERABORT -> PRINT_CANCELLED
        
exit:
endm ;err_ESCAPE


;--------------------------------------------------------------------------
; body_GETTEXTEXTENTEXPOINTA
;--------------------------------------------------------------------------

body_GETTEXTEXTENTEXPOINTA      macro
        local   exit,fail_exit
        local   bp_hdc, bp_lpszStr, bp_cchString, bp_nMaxExtent
        local   bp_lpnFit, bp_alpDx, bp_lpSize
        local   bp_lpszStr16,bp_lpSize16
        local   p1,loop,loop_exit,loop_exit2,unpack_size,no_alpDx

bp_hdc          equ     <[bp_top]>
bp_lpszStr      equ     <[bp_top+4]>
bp_cchString    equ     <[bp_top+8]>
bp_nMaxExtent   equ     <[bp_top+12]>
bp_lpnFit       equ     <[bp_top+16]>
bp_alpDx        equ     <[bp_top+20]>
bp_lpSize       equ     <[bp_top+24]>

bp_lpszStr16    equ     <[bp-4]>        ;16:16 lpszStr pointer
bp_lpSize16     equ     <[bp-8]>        ;16:16 lpSize pointer



        xor     eax,eax         ;Allocate 0-initialized locals
        push    eax             ;  bp_lpszStr16
        push    eax             ;  bp_lpSize16

; Convert lpszStr arg to 16:16 pointer and stuff away.
        mov     eax,dword ptr bp_lpszStr
        push    eax
        call    MapLS  ;PLUGGED
        mov     dword ptr bp_lpszStr16,eax

; Convert lpSize arg to 16:16 pointer and stuff away.
        mov     eax,dword ptr bp_lpSize
        push    eax
        call    MapLS  ;PLUGGED
        mov     dword ptr bp_lpSize16,eax

; Optimization: if lpfnFit and alpDx both NULL, degenerate to 
;   GetTextExtentPoint().
        mov     eax,dword ptr bp_lpnFit
        or      eax,dword ptr bp_alpDx
        jz      measure_whole

; If lpfnFit == 0, we're supposed to ignore nMaxExtent. To avoid dealing
; with this special case, set nMaxExtent to max.
        mov     eax,dword ptr bp_lpnFit
        or      eax,eax
        jnz     p1
        dec     eax     ;eax <-- 0xffffffff
        mov     dword ptr bp_nMaxExtent, eax

; Assert: nMaxExtent now set to valid value.
p1:
        mov     ecx,1
loop:
; Measure increasingly long prefixes until we reach the end of the
; string or exceed nMaxExtent. ecx == prefix length (ranges from 1
; to cchString inclusive).
        cmp     ecx,dword ptr bp_cchString
        ja      loop_exit
        
        push    ecx                     ;Save prefix length

; Note: Using caller's SIZE as temporary for GetTextExtentPoint().
; If this is the last call before hitting the end of the string,
; this'll put the right return value in SIZE. If not, we'll
; do a final measure to set SIZE right.
        push    word ptr bp_hdc         ;Arg: GetTextExtentPoint
        push    dword ptr bp_lpszStr16  ;Arg: GetTextExtentPoint
        push    cx                      ;Arg: GetTextExtentPoint
        push    dword ptr bp_lpSize16   ;Arg: GetTextExtentPoint
        call    GetTextExtentPoint
        pop     ecx                     ;Restore prefix length
        or      ax,ax
        jz      fail_exit

        mov     es,FlatData
        mov     esi,bp_lpSize
        mov     ax,es:[esi + 0]         ;Retrieve size.cx
        cwde
        cmp     eax,bp_nMaxExtent       ;If exceeded nMaxExtent, end of
        ja      loop_exit               ;  story.

; Store partial width in alpDx (if not NULL).
        mov     edi,dword ptr bp_alpDx
        or      edi,edi
        jz      no_alpDx
        mov     es,FlatData
        mov     es:[edi + ecx*4 - 4], eax

no_alpDx:       
        inc     ecx
        jmp     loop


; Assert: ecx - 1 == length of longest prefix not violating nMaxExtent
loop_exit:
        dec     ecx
        mov     edi,bp_lpnFit
        or      edi,edi
        jz      loop_exit2
        mov     es,FlatData
        mov     es:[edi],ecx

loop_exit2:
; Optimization: if we ran off the end of the string, SIZE already contains
;  right (16-bit) values so bypass final call to GetTextExtentPoint().
        cmp     ecx,dword ptr bp_cchString
        je      unpack_size

; Deliberate fall-through to measure_whole

measure_whole:
        push    word ptr bp_hdc
        push    dword ptr bp_lpszStr16
        push    word ptr bp_cchString
        push    dword ptr bp_lpSize16
        call    GetTextExtentPoint
        or      ax,ax
        jz      fail_exit

unpack_size:
; Unpack LPSIZE object
        mov     es,FlatData
        mov     esi,bp_lpSize
        mov     ax,es:[esi + 2]         ;Unpack Y
        cwde
        mov     es:[esi + 4],eax
        mov     ax,es:[esi + 0]         ;Unpack X
        cwde
        mov     es:[esi + 0],eax

        xor     eax,eax         ;Set success return value.
        inc     eax
        jmp     exit


fail_exit:
        xor     eax,eax
exit:
        push    eax
        pushd   bp_lpszStr16
        call    UnmapLS
        pushd   bp_lpSize16
        call    UnmapLS
        pop     eax

endm    ;body_GETTEXTEXTENTEXPOINTA

;--------------------------------------------------------------------------
; body_THKPLAYENHMETAFILERECORD
;--------------------------------------------------------------------------

body_THKPLAYENHMETAFILERECORD        macro
        local pop_exit

bp_hdc          equ     <[bp_top]>
bp_lpht         equ     <[bp_top+4]>
bp_lpby         equ     <[bp_top+8]>
bp_che          equ     <[bp_top+12]>
bp_cby          equ     <[bp_top+16]>

bp_return       equ     <[bp-4]>        ;return value
bp_tile_lpht    equ     <[bp-8]>        ;ecx from TILE_BUFFER
bp_tile_lpby    equ     <[bp-12]>       ;ecx from TILE_BUFFER

; Create zero-inited stack space for the return value.

        xor     eax, eax
        push    eax                     ;bp_return = 0

; Convert lpht arg into a selector array and create stack space.

        mov     eax, dword ptr bp_lpht
        mov     ecx, dword ptr bp_che
        test    ecx, 0C0000000h         ;so we can shift left safely
        jnz     pop_exit
        shl     ecx, 2                  ;HANDLE is 4 bytes in 16-bit and 32-bit
        TILE_BUFFER
        push    ecx
        push    eax                     ;save 16:16 ptr temporarily

; Convert lpby arg into a selector array and create stack space.

        mov     eax, dword ptr bp_lpby
        mov     ecx, dword ptr bp_cby
        TILE_BUFFER
        pop     edx                     ;get 16:16 pointer to handles
        push    ecx

; Re-pack the stack and make the 16-bit call.

        push    word ptr bp_hdc
        push    edx                     ;16:16 pointer to handles
        push    eax                     ;16:16 pointer to bytes
        push    dword ptr bp_che
        call    PlayEnhMetaFileRecord

; Save the return value on the stack.  (The high word is already zero.)

        mov     word ptr bp_return, ax

; Free the tiled selector arrays and stack space.

        pop     ecx
        UNTILE_BUFFER
        pop     ecx
        UNTILE_BUFFER

; Clean the stack and set the return value.

pop_exit:
        pop     eax

endm    ;body_THKPLAYENHMETAFILERECORD

;-------------------------------------------------------------------------
; RAWPACK_GETPATH_lpptl
;-------------------------------------------------------------------------

RAWPACK__GETPATH_lpptl  macro   lpptl,lp1616
        local   exit,fail_exit,no_check

        mov     ecx,[bp_top+12]         ;cptl (count of points)
        test    ecx, 0E0000000h         ;so we can shift left safely
        jnz     fail_exit
        shl     ecx, 3                  ;# bytes = cptl * 8
        mov     LOCAL__GETPATH_dwFreeInfo1,ecx  ;assume ecx is zero
        or      ecx,ecx
        jz      exit

        mov     eax,[bp + &lpptl]
        or      eax,eax
        jz      fail_exit

; Make sure it's writeable. If not, thunk fault handler will catch it.
        mov     es, FlatData
        or      byte ptr es:[eax],0
        mov     edx, [bp + &lpptl& + 4]
        or      edx,edx
        jz      no_check
        or      byte ptr es:[edx],0

no_check:
                

        TILE_BUFFER
        mov     [bp - &lp1616&],eax
        mov     LOCAL__GETPATH_dwFreeInfo1,ecx
        jmp     exit

fail_exit:
        mov     sp,bp
        xor     eax,eax
        dec     eax
        ERRCHK_EXIT     -1,87,Exit_16
exit:
endm    ;RAWPACK_GETPATH_lpBits

;-------------------------------------------------------------------------
; RAWUNPACK_GETPATH_lpptl
;-------------------------------------------------------------------------

RAWUNPACK__GETPATH_lpptl        macro   lpptl,lp1616
        mov     ecx,LOCAL__GETPATH_dwFreeInfo1
        UNTILE_BUFFER
endm ;RAWUNPACK_GETPATH

;-------------------------------------------------------------------------
; RAWPACK_GETPATH_lpby
;-------------------------------------------------------------------------

RAWPACK__GETPATH_lpby   macro   lpby,lp1616
        local   exit,fail_exit

        mov     ecx,[bp_top+12]         ;cptl (count of points)
        mov     LOCAL__GETPATH_dwFreeInfo2,ecx  ;assume ecx is zero
        or      ecx,ecx         
        jz      exit

        mov     eax,[bp + &lpby]
        or      eax,eax
        jz      fail_exit

        TILE_BUFFER
        mov     [bp - &lp1616&],eax
        mov     LOCAL__GETPATH_dwFreeInfo2,ecx
        jmp     exit

fail_exit:
        mov     sp,bp
        xor     eax,eax
        dec     eax
        ERRCHK_EXIT     -1,87,Exit_16
exit:
endm    ;RAWPACK_GETPATH_lpBits

;-------------------------------------------------------------------------
; RAWUNPACK_GETPATH_lpby
;-------------------------------------------------------------------------

RAWUNPACK__GETPATH_lpby macro   lpby,lp1616
        mov     ecx,LOCAL__GETPATH_dwFreeInfo2
        UNTILE_BUFFER
endm ;RAWUNPACK_GETPATH

;-------------------------------------------------------------------------
; RAWPACK_GDICOMMENT
;-------------------------------------------------------------------------

RAWPACK__GDICOMMENT_lpby        macro   lpby,lp1616
        local   exit,fail_exit

        mov     eax,[bp + &lpby]
        or      eax,eax
        jz      fail_exit
        mov     ecx,[bp_top+4]          ;cby (size of buffer)
        or      ecx,ecx         
        jz      fail_exit
        TILE_BUFFER
        mov     [bp - &lp1616&],eax
        mov     LOCAL__GDICOMMENT_dwFreeInfo,ecx
        jmp     exit

fail_exit:
        mov     sp,bp
        xor     eax,eax
        ERRCHK_EXIT     0,87,Exit_12
exit:
endm    ;RAWPACK_GDICOMMENT_lpBits

;-------------------------------------------------------------------------
; RAWUNPACK_GDICOMMENT
;-------------------------------------------------------------------------

RAWUNPACK__GDICOMMENT_lpby      macro   lpby,lp1616
        mov     ecx,LOCAL__GDICOMMENT_dwFreeInfo
        UNTILE_BUFFER
endm ;RAWUNPACK_GDICOMMENT

;-------------------------------------------------------------------------
; RAWPACK_GETENHMETAFILEBITS
;-------------------------------------------------------------------------

RAWPACK__GETENHMETAFILEBITS_lpby        macro   lpby,lp1616
        local   exit

        mov     eax,[bp + &lpby]
        mov     ecx,[bp_top+4]          ;cby (size of buffer)
        TILE_BUFFER
        mov     [bp - &lp1616&],eax
        mov     LOCAL__GETENHMETAFILEBITS_dwFreeInfo,ecx
exit:
endm    ;RAWPACK_GETENHMETAFILEBITS_lpBits

;-------------------------------------------------------------------------
; RAWUNPACK_GETENHMETAFILEBITS
;-------------------------------------------------------------------------

RAWUNPACK__GETENHMETAFILEBITS_lpby      macro   lpby,lp1616
        mov     ecx,LOCAL__GETENHMETAFILEBITS_dwFreeInfo
        UNTILE_BUFFER
endm ;RAWUNPACK_GETENHMETAFILEBITS

;-------------------------------------------------------------------------
; RAWPACK_GETENHMETAFILEDESCRIPTIONA
;-------------------------------------------------------------------------

RAWPACK__GETENHMETAFILEDESCRIPTIONA_lpby        macro   lpby,lp1616
        local   exit

        mov     eax,[bp + &lpby]
        mov     ecx,[bp_top+4]          ;cby (size of buffer)
        TILE_BUFFER
        mov     [bp - &lp1616&],eax
        mov     LOCAL__GETENHMETAFILEDESCRIPTIONA_dwFreeInfo,ecx
exit:
endm    ;RAWPACK_GETENHMETAFILEDESCRIPTIONA_lpBits

;-------------------------------------------------------------------------
; RAWUNPACK_GETENHMETAFILEDESCRIPTIONA
;-------------------------------------------------------------------------

RAWUNPACK__GETENHMETAFILEDESCRIPTIONA_lpby      macro   lpby,lp1616
        mov     ecx,LOCAL__GETENHMETAFILEDESCRIPTIONA_dwFreeInfo
        UNTILE_BUFFER
endm ;RAWUNPACK_GETENHMETAFILEDESCRIPTIONA

;-------------------------------------------------------------------------
; RAWPACK_GETENHMETAFILEPALETTEENTRIES
;-------------------------------------------------------------------------

RAWPACK__GETENHMETAFILEPALETTEENTRIES_lpby      macro   lpby,lp1616
        local   exit,fail_exit

        mov     eax,[bp + &lpby]
        mov     ecx,[bp_top+4]          ;cpe (count of PALETTEENTRYs)
        test    ecx, 0C0000000h         ;so we can shift left safely
        jnz     fail_exit
        shl     ecx,2
        TILE_BUFFER
        mov     [bp - &lp1616&],eax
        mov     LOCAL__GETENHMETAFILEPALETTEENTRIES_dwFreeInfo,ecx
        jmp     exit

fail_exit:
        mov     sp,bp
        xor     eax,eax
        dec     eax
        ERRCHK_EXIT     -1,87,Exit_12
exit:
endm    ;RAWPACK_GETENHMETAFILEPALETTEENTRIES_lpPALETTEENTRIES

;-------------------------------------------------------------------------
; RAWUNPACK_GETENHMETAFILEPALETTEENTRIES
;-------------------------------------------------------------------------

RAWUNPACK__GETENHMETAFILEPALETTEENTRIES_lpby    macro   lpby,lp1616
        mov     ecx,LOCAL__GETENHMETAFILEPALETTEENTRIES_dwFreeInfo
        UNTILE_BUFFER
endm ;RAWUNPACK_GETENHMETAFILEPALETTEENTRIES

;-------------------------------------------------------------------------
; RAWPACK_SETENHMETAFILEBITS
;-------------------------------------------------------------------------

RAWPACK__SETENHMETAFILEBITS_lpby        macro   lpby,lp1616
        local   exit,fail_exit

        mov     eax,[bp + &lpby]
        or      eax,eax
        jz      fail_exit
        mov     ecx,[bp_top]            ;cby (size of buffer)
        or      ecx,ecx         
        jz      fail_exit
        TILE_BUFFER
        mov     [bp - &lp1616&],eax
        mov     LOCAL__SETENHMETAFILEBITS_dwFreeInfo,ecx
        jmp     exit

fail_exit:
        mov     sp,bp
        xor     eax,eax
        ERRCHK_EXIT     0,87,Exit_8
exit:
endm    ;RAWPACK_SETENHMETAFILEBITS_lpBits

;-------------------------------------------------------------------------
; RAWUNPACK_SETENHMETAFILEBITS
;-------------------------------------------------------------------------

RAWUNPACK__SETENHMETAFILEBITS_lpby      macro   lpby,lp1616
        mov     ecx,LOCAL__SETENHMETAFILEBITS_dwFreeInfo
        UNTILE_BUFFER
endm ;RAWUNPACK_SETENHMETAFILEBITS

;-------------------------------------------------------------------------
; RAWPACK_ENUMOBJECTS
;-------------------------------------------------------------------------
RAWPACK__ENUMOBJECTS_lpObjectFunc       macro   iOffset,iTempOffset
        local   pen, exit

        cmp     word ptr [bp_top+4],1           ;OBJ_PEN?
        je      pen
        PACK_CALLBACK   iOffset,iTempOffset,CBID_ENUMBRUSH
        jmp     exit
pen:
        PACK_CALLBACK   iOffset,iTempOffset,CBID_ENUMPEN
exit:

endm  ;RAWPACK__ENUMOBJECTS_lpObjectFunc

;-------------------------------------------------------------------------
; RAWUNPACK_ENUMOBJECTS
;-------------------------------------------------------------------------

RAWUNPACK__ENUMOBJECTS_lpObjectFunc       macro   iOffset,iTempOffset
        local   pen, exit
                                                ;unpack don't care about CBID
                                                ;just make it readable
        cmp     word ptr [bp_top+4],1           ;OBJ_PEN?
        je      pen
        UNPACK_CALLBACK   iOffset,iTempOffset,CBID_ENUMBRUSH
        jmp     exit
pen:
        UNPACK_CALLBACK   iOffset,iTempOffset,CBID_ENUMPEN
exit:

endm  ;RAWUNPACK__ENUMOBJECTS_lpObjectFunc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\msgthk.inc ===
ifdef IS_16
include thkrp.inc
include k32share.inc
include public.inc
include cbcheck.inc
include newls.inc
include newmisc.inc
include frame.inc
include struc.inc
include cvtstruc.inc
include cbcid.inc
include usrcbid.inc

externDef GlobalAlloc:far16

externDef DefFrameProc32:far16
externDef DefDlgProc32:far16
externDef SendMessage32:far16
externDef DefWindowProc32:far16
externDef DefMDIChildProc32:far16
externDef PostMessage32:far16
externDef PostThreadMessage32:far16
externDef GetMessage32:far16
externDef PeekMessage32Ex:far16
externDef TranslateAccelerator:far16
externDef TranslateMDISysAccel:far16
externDef TranslateMessage32:far16
externDef IsDialogMessage32:far16

externDef GetNullhInst:far16
externDef MaphinstLS:far16
externDef MaphinstSL:far16
externDef GetStdCBLS:far16
externDef GetStdCBSL:far16
externDef ThkMsgLS:near16
externDef ThkMsgSL:near16
externDef CALLBACK_BODY_16:far16
externDef IsValidPostedMessage:near16

.286
externDef abWMIndex:word

.386

ifdef DEBUG
externDef _DebugOutput:far16

DBF_WARNING     equ     04000h
DBF_ERROR       equ     08000h
DBF_USER        equ     00800h
endif


;-----------------------------------------------------------------------;
; DXAX2EAX
; mov dx to eax high word
;
;-----------------------------------------------------------------------;
DXAX2EAX macro
    ror     eax,16
    xchg    ax,dx
    ror     eax,16
endm


;-----------------------------------------------------------------------;
; body_CALLMSGFILTER
;-----------------------------------------------------------------------;
body_CALLMSGFILTER       macro
bp_pMsg        equ     <bp_top>
bp_nCode       equ     <bp_top+4>
si_msg16       equ     <(si_space-(MSGSTRUCT16_SIZE))>

    mov     si,sp           ;;set up si for local variable frame

    MsgStructThkPreProc

    lea     ax,si_msg16
    push    ss
    push    ax
    push        word ptr  bp_nCode
    push    1
    call    CallMsgFilter32
    cwde

    MsgStructThkPostProc
endm

;-----------------------------------------------------------------------;
; body_SLOWCALLWINDOWPROCA
;-----------------------------------------------------------------------;
body_SLOWCALLWINDOWPROCA      macro
    local   have_stub16

bp_pfn          equ     <bp_top    >
bp_hwnd         equ     <bp_top+  4>
bp_message      equ     <bp_top+  8>
bp_wParamLo     equ     <bp_top+ 12>
bp_wParamHi     equ     <bp_top+ 14>
bp_lParam       equ     <bp_top+ 16>

    mov     si,sp           ;;set up si for local variable frame

    MsgThkPreProc       

    push        dword ptr  bp_pfn
    push    dword ptr  CBID_WNDPROC
    call    GetStdCBSL

    push    eax
    push        word ptr  bp_space.s16_hwnd
    push        word ptr  bp_space.s16_message
    push        word ptr  bp_space.s16_wParam.lo
    push        dword ptr  bp_space.s16_lParam
    push        word ptr  bp_space.s16_wParam.hi
    call    CallWindowProc32

    or      bp_space.s16_fw, TF_THUNKMSGRESULT
    MsgThkPostProc
endm



; ---------------------------------------------------------------------------
;
; body_SENDMESSAGETHINGA
;
; ---------------------------------------------------------------------------
body_SENDMESSAGETHINGA macro
    local   mpfnSendThing
    local   SendThingCleanup

bp_type         equ     <bp_top     >
bp_hwnd         equ     <bp_top+   4>
bp_hwnd2        equ     <bp_top+   8>
bp_message      equ     <bp_top+  12>
bp_wParamLo     equ     <bp_top+  16>
bp_wParamHi     equ     <bp_top+  18>
bp_lParam       equ     <bp_top+  20>

    mov     si,sp           ;;set up si for local variable frame

    MsgThkPreProc

    push        word ptr  bp_space.s16_hwnd

    cmp     word ptr bp_type, SMT_DEFFRAMEPROC
    jne     @F

    push    word ptr  bp_hwnd2

@@:
    push        word ptr  bp_space.s16_message
    push        word ptr  bp_space.s16_wParam.lo
    push   dword ptr  bp_space.s16_lParam
    push        word ptr  bp_space.s16_wParam.hi

    ;
    ; Which type of message call do we want to make?
    ;   (0) SendMesage32
    ;   (1) DefWindowProc32
    ;   (2) DefMDIChildProc32
    ;   (3) DefDlgProc32
    ;   (4) DefFrameProc32
    ;
    mov     bx, word ptr bp_type
    shl     bx, 2

    call    dword ptr cs:mpfnSendThing[bx]
    jmp     SendThingCleanup

mpfnSendThing label dword
    dd      SendMessage32       ; 0
    dd      DefWindowProc32     ; 1
    dd      DefMDIChildProc32   ; 2
    dd      DefDlgProc32        ; 3
    dd      DefFrameProc32      ; 4

SendThingCleanup:
    or      bp_space.s16_fw, TF_THUNKMSGRESULT
    MsgThkPostProc
endm


;-----------------------------------------------------------------------;
; body_TRANSLATEMESSAGETHING
;       TMT_TRANSLATEACCELERATOR    == TranslateAccelerator
;       TMT_TRANSLATEMDISYSACCEL    == TranslateMDISysAccel
;       TMT_ISDIALOGMESSAGE         == IsDialogMessage
;       TMT_TRANSLATEMESSAGE        == TranslateMessageA
;-----------------------------------------------------------------------;
body_TRANSLATEMESSAGETHING  macro
    local   not_dde
    local   exit
    local   mpfnTranslate
    local   PushMessage
    local   MakeCall
    local   Cleanup

bp_type         equ     <bp_top   >
bp_hwnd         equ     <bp_top+ 4>
bp_haccel       equ     <bp_top+ 8>
bp_pMsg         equ     <bp_top+12>

si_msg16        equ     <(si_space-(MSGSTRUCT16_SIZE))>

; Check for DDE message, in which case we know no translation will occur,
; so there's no need to call the api.

    sub     eax,eax     ;assume no translation
    mov     es,FlatData
    mov     edi,bp_pMsg
    cmp     word ptr es:[edi].ms32_message,WM_DDE_FIRST
    jb      not_dde
    cmp     word ptr es:[edi].ms32_message,WM_DDE_LAST
    jbe     exit
    cmp     word ptr es:[edi].ms32_message,WM_DROPFILES
    je      exit

not_dde:
    mov     si,sp           ;;set up si for local variable frame
    MsgStructThkPreProc     ,no_load_pmsg

    ;
    ; TranslateAccelerator(hwnd, haccel pmsg);
    ; TranslateMDISysAccel(hwnd, pmsg);
    ; IsDialogMessage32(hwnd, psmg, TRUE);
    ; TranslateMessage32(pmsg, TRUE);
    ; 
    mov     bx, word ptr bp_type
    cmp     bx, TMT_TRANSLATEMESSAGE
    je      PushMessage

    ; We push hwnd for all but TranslateMessage32()
    push        word ptr  bp_hwnd

    ; We only push haccel for TranslateAccelerator()
    cmp     bx, TMT_TRANSLATEACCELERATOR
    jne     PushMessage
    push        word ptr  bp_haccel

PushMessage:
    ; We push lpmsg for all
    lea     ax,si_msg16
    push    ss
    push    ax

    cmp     bx, TMT_ISDIALOGMESSAGE
    jb      MakeCall

    ; We push TRUE for IsDialogMessage32() and TranslateMessage32()
    push    1

MakeCall:
    shl     bx, 2
    call    dword ptr cs:mpfnTranslate[bx]
    jmp     Cleanup

mpfnTranslate   label   dword
    dd      TranslateAccelerator
    dd      TranslateMDISysAccel
    dd      IsDialogMessage32
    dd      TranslateMessage32

Cleanup:
    cwde

    MsgStructThkPostProc
exit:
endm



;-----------------------------------------------------------------------;
; body_DISPATCHMESSAGEA
;-----------------------------------------------------------------------;
body_DISPATCHMESSAGEA macro
    local DispatchExit

bp_pMsg        equ     <bp_top>
si_msg16       equ     <(si_space-(MSGSTRUCT16_SIZE))>

    ; Blow off if message implies a pointer
    mov     es, FlatData
    mov     edi, dword ptr bp_pMsg
    push    word ptr es:[edi].ms32_message
    call    IsValidPostedMessage
    or      eax, eax

ifdef DEBUG
    jnz     @F

    push    eax

    push    cs
    push    offset szDispatchError
    push    DBF_USER or DBF_ERROR
    call    _DebugOutput
    add     sp, 2+4

    pop     eax
    jmp     DispatchExit

szDispatchError label byte
    db      'DispatchMessage: ignoring retrieved message with pointer',0

@@:
else
    jz      DispatchExit
endif

    mov     si,sp           ;;set up si for local variable frame

    MsgStructThkPreProc     TF_NOTPAIRED,

    lea     ax,si_msg16
    push    ss
    push    ax
    push    1
    call    DispatchMessage32

    DXAX2EAX

    lea     sp, si_cleanup

DispatchExit:
endm


;-----------------------------------------------------------------------;
; body_GETMESSAGETHINGA
;-----------------------------------------------------------------------;
body_GETMESSAGETHINGA macro
    local   GetThingExit
    local   GetNextMessage
    local   ItsAPeekMessage
    local   GetThingCleanup
    local   MessageError

bp_fPeek        equ     <bp_top    >
bp_pMsg         equ     <bp_top+  4>
bp_hwnd         equ     <bp_top+  8>
bp_uMsgMin      equ     <bp_top+ 12>
bp_uMsgMax      equ     <bp_top+ 16>
bp_dwRemove     equ     <bp_top+ 20>

bp_msg16           equ     <(bp_space-(MSGSTRUCT16_SIZE))>
si_msg16           equ     <(si_space-(MSGSTRUCT16_SIZE))>

    sub     sp,(size THKSPACE16 + MSGSTRUCT16_SIZE)

    mov     si,sp

next_message:
    ; Repush GM/PM parms
    push    ss
    push    si
    push    word ptr bp_hwnd
    push    word ptr  bp_uMsgMin
    push    word ptr  bp_uMsgMax

    cmp     word ptr bp_fPeek, 0
    jne     ItsAPeekMessage

    push    1
    call    GetMessage32
    cwde
    jmp     GetThingCleanup

ItsAPeekMessage:
    push    dword ptr bp_dwRemove
    push    1
    call    PeekMessage32Ex
    cwde    ; Get return into EAX in case 0
    test    ax, ax
    jz      GetThingExit

GetThingCleanup:
    ; SAVE API RETURN VALUE
    push    eax

    ; Blow off if message has pointers (could've come from old 16-bit app)
    push    word ptr bp_msg16.ms16_message
    call    IsValidPostedMessage
    test    eax, eax
    jz      MessageError

    ; The message is OK to be retrieved
    mov     si,bp           ;set up frame pointer

    mov     cx,word ptr bp_dwRemove
    and     cx,PM_REMOVE
    xor     cx,PM_REMOVE    ;turn it into PM_NOREMOVE indicator
    shl     cx,5
    .errnz  PM_REMOVE - 1
    or      cx,TF_NOTPAIRED

    InitLocalSpace          cx,bp

    ; RESTORE API RETURN VALUE
    pop     eax

    MsgStructThkPostProc    bp,
    jmp     GetThingExit

MessageError:
ifdef DEBUG
    push    cs
    push    offset szGetError
    push    DBF_USER or DBF_WARNING
    call    _DebugOutput
    add     sp, 2+4

    jmp     @F

szGetError label byte
    db      'GetMessage: ignoring retrieved message with pointer',0

@@:
endif

    ; Pop off API return value to clean up stack
    pop     eax

    ; If this is PeekMessage PM_REMOVE or GetMessage, then just jump back to
    ; the top of the Peek loop and try again.  We'll skip over this one and
    ; get the next message.
    cmp     word ptr bp_fPeek, 0
    jz      next_message
    mov     eax, dword ptr bp_dwRemove
    test    eax, PM_REMOVE
    jnz     next_message

    ; OK, so this is a PeekMessage PM_NOREMOVE call.  This is a little more
    ; complicated.  We need to call PeekMessage PM_REMOVE with the other
    ; parms the same so we swallow this bad message.  THEN we want to jump
    ; back to the top of the loop and try again.  Otherwise the app will
    ; hang forever because this bad message will never get removed from the
    ; front of the message list.
    push    ss
    push    si
    push    word ptr bp_hwnd
    push    word ptr bp_uMsgMin
    push    word ptr bp_uMsgMax
    or      eax, PM_REMOVE
    push    eax
    push    1
    call    PeekMessage32Ex

    ; Now we can try this again.
    jmp     next_message

GetThingExit:
endm    



;-----------------------------------------------------------------------;
; body_POSTMESSAGETHINGA
;-----------------------------------------------------------------------;
body_POSTMESSAGETHINGA macro
    local   mpfnPostThing
    local   PostThingWord
    local   PostThingParms
    local   PostThingCleanup    
    local   exit

bp_type         equ     <bp_top    >
bp_hwnd         equ     <bp_top+  4>
bp_message      equ     <bp_top+  8>
bp_wParamLo     equ     <bp_top+ 12>
bp_wParamHi     equ     <bp_top+ 14>
bp_lParam       equ     <bp_top+ 16>

    ; Blow this off if message implies a pointer.
    push    word ptr bp_message
    call    IsValidPostedMessage
    or      eax, eax

ifdef DEBUG
    jnz     @F
    push    eax
    push    cs
    push    offset szPostError
    push    DBF_USER or DBF_ERROR
    call    _DebugOutput
    add     sp, 2+4
    pop     eax

    jmp     exit

szPostError label   byte
    db  'PostMessage: ignoring posted message with pointer',0
@@:
else
    jz      exit
endif

    mov     si,sp           ;;set up si for local variable frame

    MsgThkPreProc   TF_NOTPAIRED 

    ;
    ; Which type of message post do we want to make?
    ;   (0) PostThreadMessage32 -- dword "hwnd" (idThread really)
    ;   (1) PostMessage32
    ;
    mov     eax, bp_hwnd        
    mov     bx, word ptr bp_type    
    cmp     bx, PMT_POSTTHREADMESSAGE
    jne     PostThingWord

    push    eax
    jmp     PostThingParms

PostThingWord:
    push    ax

PostThingParms:
    push    word ptr  bp_space.s16_message
    push        word ptr  bp_space.s16_wParam.lo
    push   dword ptr  bp_space.s16_lParam
    push        word ptr  bp_space.s16_wParam.hi

    shl     bx, 2
    call    dword ptr cs:mpfnPostThing[bx]
    jmp     PostThingCleanup

mpfnPostThing label dword
    dd      PostThreadMessage32     ; PMT_POSTTHREADMESSAGE
    dd      PostMessage32           ; PMT_POSTMESSAGE

PostThingCleanup:
        cwde

exit:
endm


;-----------------------------------------------------------------------;
; body_SENDMESSAGETIMEOUTA
;-----------------------------------------------------------------------;
body_SENDMESSAGETIMEOUTA macro
bp_hwnd         equ     <bp_top    >
bp_message      equ     <bp_top+  4>
bp_wParamLo     equ     <bp_top+  8>
bp_wParamHi     equ     <bp_top+ 10>
bp_lParam       equ     <bp_top+ 12>
bp_flags        equ     <bp_top+ 16>
bp_TimeOut      equ     <bp_top+ 20>
bp_lpResult     equ     <bp_top+ 24>

bp_lRet         equ     <[bp-4]>

    xor     eax, eax
    push    eax

    mov     si,sp           ;;set up si for local variable frame

    MsgThkPreProc       , si

    push        word ptr    si_space.s16_hwnd
    push        word ptr    si_space.s16_message
    push        word ptr    si_space.s16_wParam.lo
    push        dword ptr   si_space.s16_lParam
    push        word ptr    si_space.s16_wParam.hi
        push    word ptr    bp_flags                ; Only the first word of flags is used now.
        push    dword ptr       bp_TimeOut

    ; Push FAR ptr to si_space.s16_lResult
        push    ss                      ; Push pointer to temp location.
    lea     ax, si_space.s16_lResult
    push    ax

    call   SendMessageTimeOut32

    ; Save _REAL_ result
    mov     word ptr bp_lRet, ax
    mov     word ptr bp_lRet+2, dx

    ; Replace result with one filled in by SMTO()--the "real" message return
    mov     ax, word ptr si_space.s16_lResult
    mov     dx, word ptr si_space.s16_lResult+2

    or      si_space.s16_fw, TF_THUNKMSGRESULT
    MsgThkPostProc si

    ; EAX NOW HAS "message result" return
    ;Did caller pass in a lpResult pointer?  If so, fill it in with
    ;thunked result.
    mov     edi, dword ptr bp_lpResult
    or      edi, edi
    jz      @F

    mov     es, FlatData
    stosd   es:[edi]

@@:
    ;Now put real SMTO return into eax
    mov     eax, dword ptr bp_lRet
endm


;-----------------------------------------------------------------------;
; body_SENDMESSAGECALLBACKA
;-----------------------------------------------------------------------;
body_SENDMESSAGECALLBACKA macro
        local   cleanup
    local   exit
bp_hwnd         equ     <bp_top    >
bp_message      equ     <bp_top+  4>
bp_wParamLo     equ     <bp_top+  8>
bp_wParamHi     equ     <bp_top+ 10>
bp_lParam       equ     <bp_top+ 12>
bp_fnCallback   equ     <bp_top+ 16>
bp_dwData       equ     <bp_top+ 20>

    ; Blow this off if message implies a pointer.

    ; Unless it is WM_WININICHANGE and the pointer is NULL
    cmp     word ptr bp_lParam, 0 ; NULL pointer
    jnz     check_call
    cmp     word ptr bp_message, 1ah ; WM_WININICHANGE
    jz      valid_call ; It's ok, let it through

check_call:

    push    word ptr bp_message
    call    IsValidPostedMessage
    or      eax, eax

ifdef DEBUG
    jnz     @F
    push    eax
    push    cs
    push    offset szCallbackError
    push    DBF_USER or DBF_ERROR
    call    _DebugOutput
    add     sp, 2+4
    pop     eax

    jmp     exit

szCallbackError label   byte
    db  'SendMessageCallback: message with pointer not allowed',0
@@:
else
    jz      exit
endif

valid_call:

    mov     si,sp           ;;set up si for local variable frame

    MsgThkPreProc

    push        word ptr  bp_space.s16_hwnd
    push        word ptr  bp_space.s16_message
    push        word ptr  bp_space.s16_wParam.lo
    push        dword ptr  bp_space.s16_lParam
    push        word ptr  bp_space.s16_wParam.hi

    ; Get 16:16 callback wrapper
        push    dword ptr bp_fnCallback
    push    dword ptr  CBID_SENDMSGCALLBACK            ;callback type
    call    GetStdCBSL                          ;create 16-bit callback stub
        push    eax                                 

    push    dword ptr bp_dwData 

    call    SendMessageCallback32

    ; No msg result to thunk; this will save DX:AX return & restore to EAX
    MsgThkPostProc

exit:
endm




;-----------------------------------------------------------------------;
; body_BROADCASTSYSTEMMESSAGE
;-----------------------------------------------------------------------;
body_BROADCASTSYSTEMMESSAGE macro
bp_dwFlags              equ     <bp_top>
bp_lpdwRecipientList    equ     <bp_top+4>
;; NOTE: There is no hwnd parameter here; However, to satisfy the MsgThkPre/PostProc
;; macros, we define a dummy bp_hwnd here.
bp_hwnd         equ     <bp_top+ 4 >
bp_message      equ     <bp_top+ 8>
bp_wParamLo     equ     <bp_top+ 12>
bp_wParamHi     equ     <bp_top+ 14>
bp_lParam       equ     <bp_top+ 16>

    mov     si,sp           ;;set up si for local variable frame

    MsgThkPreProc TF_INTERPROCESS
    push        dword ptr  bp_lpdwRecipientList
    call        MapLS
    push        eax                     ;; Save the mapped selector.

    push        dword ptr  bp_dwFlags
    push        eax                     ;; 16:16 lpdwRecipientList.
    push        word ptr   bp_space.s16_message
    push        word ptr   bp_space.s16_wParam.lo
    push        dword ptr  bp_space.s16_lParam

    call   BroadcastSystemMessage

    pop         ecx             ;; Restore the 16:16 mapped selector.

    ; Preserve the msg result
    push    dx
    push    ax
        
    push        ecx             ;; 16:16
    call        UnMapLS         ;; Unmap.

    ; Restore the msg result
    pop     ax
    pop     dx

    or      bp_space.s16_fw, TF_THUNKMSGRESULT
    MsgThkPostProc
endm

;-----------------------------------------------------------------------;
; body_CALLNEXTHOOKEX
;-----------------------------------------------------------------------;

; BOGUS 
; These are already defined in user.inc, but we can't include that file
; here because of conflicts with public.inc

HHOOK_MAGIC         equ ('H' or ('K' * 256))

HOOK struc
    hkMagic         dw ?
    hkPhkNext       dw ?
    hkIdHook        dw ?
    hkPpi           dw ?
    hkHq                dw ?
    hkHqCreator     dw ?
    hkFlags         dw ?
    hkAtomModule    dw ?
    hkHmodOwner     dd ?
    hkLpfn              dd ?
    hkcCalled       dw ?
HOOK ends


body_CALLNEXTHOOKEX macro
    local thk_WH_MSGFILTER
    local thk_WH_JOURNALRECORD
    local thk_WH_JOURNALPLAYBACK
    local thk_WH_JOURNAL
    local thk_WH_KEYBOARD
    local thk_WH_GETMESSAGE
    local thk_WH_CALLWNDPROC
    local thk_WH_CBT
    local thk_WH_SYSMSGFILTER
    local thk_WH_MOUSE
    local thk_WH_HARDWARE
    local thk_WH_DEBUG
    local thk_WH_SHELL
    local thk_WH_FOREGROUNDIDLE
    local thk_WH_CALLWNDPROCRET
    local hook_exit
    local npfnHookThunk
    local bad_hook_type
    local jr_null_msg
    local jp_push

bp_hhk          equ     <bp_top    >
bp_nCode        equ     <bp_top+  4>
bp_wParam       equ     <bp_top+  8>
bp_lParam       equ     <bp_top+ 12>

    ;
    ; WE ARE IN USER16 NOW
    ; We can do the same validation that our hook functions do on hook
    ; handles.
    ;

    xor     ax, ax
    cwd

    ; HIWORD of hook must be HHOOK_MAGIC
    cmp     word ptr bp_hhk+2, HHOOK_MAGIC
    jne     hook_exit

    ; LOWORD of hook is local ptr & therefore not NULL
    mov     di, word ptr bp_hhk
    or      di, di
    jz      hook_exit

    ; MAGIC field inside of hook must be HHOOK_MAGIC
    cmp     [di].hkMagic, HHOOK_MAGIC
    jne     hook_exit

    mov     ax, [di].hkIdHook
    inc     ax
    add     ax,ax
    xchg    ax,bx
    jmp     cs:npfnHookThunk[bx]

;dispatch table

npfnHookThunk label word
    dw      offset thk_WH_MSGFILTER
    dw      offset thk_WH_JOURNALRECORD
    dw      offset thk_WH_JOURNALPLAYBACK
    dw      offset thk_WH_KEYBOARD
    dw      offset thk_WH_GETMESSAGE
    dw      offset thk_WH_CALLWNDPROC
    dw      offset thk_WH_CBT
    dw      offset thk_WH_SYSMSGFILTER
    dw      offset thk_WH_MOUSE
    dw      offset thk_WH_HARDWARE
    dw      offset thk_WH_DEBUG
    dw      offset thk_WH_SHELL
    dw      offset thk_WH_FOREGROUNDIDLE
    dw      offset thk_WH_CALLWNDPROCRET


;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
thk_WH_MOUSE:
bp_pMhs            equ     <bp_lParam>
si_mhs16           equ     <(si_cleanup-(MOUSEHOOKSTRUCT16_SIZE))>
    mov     si,sp
    MhsStructThkPreProc

    push    dword ptr   bp_hhk
    push    word ptr    bp_nCode
    push        word ptr    bp_wParam
    lea     ax,si_mhs16
    push    ss
    push    ax
    call    CallNextHookEx

    MhsStructThkPostProc
    jmp     hook_exit_no_return

;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
thk_WH_JOURNALRECORD:
    xor     dx, dx
    jmp     thk_WH_JOURNAL

thk_WH_JOURNALPLAYBACK:
    xor     dx, dx
    inc     dx

thk_WH_JOURNAL:

bp_pJhs             equ     <bp_lParam>
si_type             equ     <(si_cleanup-2)>
si_jhs16            equ     <(si_cleanup-2-(EVENTMSG16_SIZE))>

    ;JhsStructThkPreProc assumes type is in DX
    mov     si,sp
    JhsStructThkPreProc

    push    dword ptr   bp_hhk
    push    word ptr    bp_nCode
    push    word ptr    bp_wParam
    mov     eax, bp_pJhs
    or      eax, eax
    jnz     @F
    push    eax
    jmp     JhsCallHook

@@:
    lea     ax, si_jhs16
    push    ss
    push    ax

JhsCallHook:
    call    CallNextHookEx
    DXAX2EAX

    JhsStructThkPostProc
    jmp     hook_exit_no_return



;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
thk_WH_MSGFILTER:
thk_WH_SYSMSGFILTER:
thk_WH_GETMESSAGE:
bp_pMsg            equ     <bp_lParam>
si_msg16           equ     <(si_space-(MSGSTRUCT16_SIZE))>
    mov     si,sp
    MsgStructThkPreProc

    push    dword ptr   bp_hhk
    push    word ptr    bp_nCode
    push        word ptr    bp_wParam
    lea     ax,si_msg16
    push    ss
    push    ax
    call    CallNextHookEx
    DXAX2EAX
    MsgStructThkPostProc

    ; MsgStructThkPostProc puts return into EAX for us.
    jmp     hook_exit_no_return


;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
thk_WH_CBT:
    mov     si,sp
    CbtStructThkPreProc
    ;!!! assumes no need to copy back structures

thk_WH_CBT_call:
    push    dword ptr   bp_hhk
    push    word ptr    bp_nCode
    push        word ptr    bp_wParam
    push        dword ptr   si_space.s16_lParam
    call    CallNextHookEx

    CbtStructThkPostProc
    jmp     hook_exit_no_return


;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
thk_WH_DEBUG:   
bp_pDhs         equ     <bp_lParam>
si_dhs16        equ     <(si_cleanup-(DEBUGHOOK16_SIZE))>
    mov     si, sp
    DhsStructThkPreProc

    push    dword ptr   bp_hhk
    push    word ptr    bp_nCode
    push    word ptr    bp_wParam
    lea     ax, si_dhs16
    push    ss
    push    ax
    call    CallNextHookEx

    DhsStructThkPostProc
    jmp     hook_exit_no_return


;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
thk_WH_CALLWNDPROC:
bp_pCwp         equ     <bp_lParam>
si_cwp16        equ     <(si_space-(CWPSTRUCT16_SIZE))>
    mov     si,sp
    CwpStructThkPreProc

    push    dword ptr   bp_hhk
    push    word ptr    bp_nCode
    push        word ptr    bp_wParam

    ; HACK 
    ; Pass lpCwp16, without wParamHi on top
    ;
    lea     ax,si_cwp16
    add     ax, 2
    push    ss
    push    ax
    call    CallNextHookEx

    CwpStructThkPostProc
    jmp     hook_exit_no_return

;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
thk_WH_CALLWNDPROCRET:
bp_pCwpRet          equ     <bp_lParam>
si_cwpret16         equ     <(si_space-(CWPRETSTRUCT16_SIZE))>
    mov     si,sp
    CwpRetStructThkPreProc

    push    dword ptr   bp_hhk
    push    word ptr    bp_nCode
    push        word ptr    bp_wParam
    lea     ax,si_cwpret16
    push    ss
    push    ax
    call    CallNextHookEx

    CwpRetStructThkPostProc
    jmp     hook_exit_no_return


;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
thk_WH_HARDWARE:
bp_pHhs            equ     <bp_lParam>
si_hhs16           equ     <(si_space-(HARDWAREHOOKSTRUCT16_SIZE))>
    mov     si,sp
    HhsStructThkPreProc

    push    dword ptr   bp_hhk
    push    word ptr    bp_nCode
    push        word ptr    bp_wParam
    lea     ax,si_hhs16
    push    ss
    push    ax
    call    CallNextHookEx

    HhsStructThkPostProc
    jmp     hook_exit_no_return


;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
thk_WH_KEYBOARD:
thk_WH_SHELL:
thk_WH_FOREGROUNDIDLE:
    push    dword ptr   bp_hhk
    push    word ptr    bp_nCode
    push        word ptr    bp_wParam
    push        dword ptr   bp_lParam
    call    CallNextHookEx

hook_exit:
    DXAX2EAX

hook_exit_no_return:
endm

endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\immfthk.inc ===
IME_CONFIG_REGISTERWORD  equ       2

REGWORD_STRUC_SIZE   equ 8

;-----------------------------------------------------------------------;
;
; bodyqt_IMMCONFIGUREIMEA
;
;-----------------------------------------------------------------------;
bodyqt_IMMCONFIGUREIMEA macro index
    local type_ok
    local get_out
    local inserted_ok
    local push_task
ebp_hKL        equ     <ebp_top>
ebp_hWnd       equ     <ebp_top+4>
ebp_hSubFunc   equ     <ebp_top+8>
ebp_dwData     equ     <ebp_top+12>

ebp_SavePtr0    equ     <[ebp-68]>
ebp_SavePtr1    equ     <[ebp-72]>
ebp_SavePtr2    equ     <[ebp-76]>

    xor     eax,eax
    push    eax         ;ebp_SavePtr0
    push    eax         ;ebp_SavePtr1
    push    eax         ;ebp_SavePtr2

    sub     esp, REGWORD_STRUC_SIZE
    mov     eax, edi
    mov     edi, esp
    push    eax      ; preserve edi

    mov     eax,dword ptr ebp_hSubFunc         ;will need more than once
    cmp     eax,IME_CONFIG_REGISTERWORD
    jnz     call_it_A

    mov     eax, dword ptr ebp_dwData
    test    eax,eax
    jz      call_it_A                            ;don't map if dwData is NULL

    push    eax      ; preserve eax
    push    [eax]    ; map lpReading
    call    MapLS
    mov     dword ptr [edi], eax
    mov     dword ptr ebp_SavePtr0, eax
    pop     eax
    push    dword ptr [eax+4]  ; map lpWord
    call    MapLS
    mov     dword ptr [edi+4], eax
    mov     dword ptr ebp_SavePtr1, eax

    push    dword ptr ebp_hKL
    push    word ptr ebp_hWnd
    push    dword ptr ebp_hSubFunc
    push    edi
    call    MapLS
    mov     dword ptr ebp_SavePtr2, eax
    push    eax
    call    dword ptr [pfnQT_Thunk_ImmFThk]

    push    dword ptr ebp_SavePtr0
    call    UnMapLS 
    push    dword ptr ebp_SavePtr1
    call    UnMapLS 
    push    dword ptr ebp_SavePtr2
    call    UnMapLS 
    jmp     get_out

call_it_A:
    push    dword ptr ebp_hKL
    push    word ptr ebp_hWnd
    push    dword ptr ebp_hSubFunc
    push    dword ptr ebp_dwData
    call    dword ptr [pfnQT_Thunk_ImmFThk]

get_out:
    pop     edi
endm

;-----------------------------------------------------------------------;
;
; bodyqt_IMMCONFIGUREIMEW
;
;-----------------------------------------------------------------------;
bodyqt_IMMCONFIGUREIMEW macro index
    local type_ok
    local get_out
    local inserted_ok
    local push_task
ebp_hKL        equ     <ebp_top>
ebp_hWnd       equ     <ebp_top+4>
ebp_hSubFunc   equ     <ebp_top+8>
ebp_dwData     equ     <ebp_top+12>

ebp_SavePtr0    equ     <[ebp-68]>
ebp_SavePtr1    equ     <[ebp-72]>
ebp_SavePtr2    equ     <[ebp-76]>

    xor     eax,eax
    push    eax         ;ebp_SavePtr0
    push    eax         ;ebp_SavePtr1
    push    eax         ;ebp_SavePtr2

    sub     esp, REGWORD_STRUC_SIZE
    mov     eax, edi
    mov     edi, esp
    push    eax      ; preserve edi

    mov     eax,dword ptr ebp_hSubFunc         ;will need more than once
    cmp     eax,IME_CONFIG_REGISTERWORD
    jnz     call_it_W

    mov     eax, dword ptr ebp_dwData
    test    eax,eax
    jz      call_it_W                            ;don't map if dwData is NULL

    push    eax      ; preserve eax
    push    [eax]    ; map lpReading
    call    MapLS
    mov     dword ptr [edi], eax
    mov     dword ptr ebp_SavePtr0, eax
    pop     eax
    push    dword ptr [eax+4]  ; map lpWord
    call    MapLS
    mov     dword ptr [edi+4], eax
    mov     dword ptr ebp_SavePtr1, eax

    push    dword ptr ebp_hKL
    push    word ptr ebp_hWnd
    push    dword ptr ebp_hSubFunc
    push    edi
    call    MapLS
    mov     dword ptr ebp_SavePtr2, eax
    push    eax
    call    dword ptr [pfnQT_Thunk_ImmFThk]

    push    dword ptr ebp_SavePtr0
    call    UnMapLS 
    push    dword ptr ebp_SavePtr1
    call    UnMapLS 
    push    dword ptr ebp_SavePtr2
    call    UnMapLS 
    jmp     get_out

call_it_W:
    push    dword ptr ebp_hKL
    push    word ptr ebp_hWnd
    push    dword ptr ebp_hSubFunc
    push    dword ptr ebp_dwData
    call    dword ptr [pfnQT_Thunk_ImmFThk]

get_out:
    pop     edi
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\pdfthk.inc ===
; pdfthk.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\imm32thk.inc ===
body_IMM32CONFIGURE  macro
; ebx+42   param1
; ebx+38   param2
; ebx+36   param3
; ebx+32   param4
; ebx+28   param5
; ebx+24   param6
; ebx+22   param7
;-------------------------------------
; temp storage

SavelpData  equ  <[ebp+4]>
SavelpRead  equ  <[ebp+8]>
SavelpWord  equ  <[ebp+12]>
lpRead      equ  <[ebp+16]>
lpWord      equ  <[ebp+20]>

        sub     esp, 8                  ; lpRead & lpWord
        xor     eax,eax                 ; storage for unmap
        push    eax                     ;     SavelpWord
        push    eax                     ;     SavelpRead
        push    eax                     ;     SavelpData
        push    ebp
        mov     ebp,esp
        push    edi
        mov     edi, [ebx+32]
        cmp     edi, 2                  ; see if it's IME_CONFIG_REGISTERWORD
        jnz     Skip_Data               ; don't map it if not.
; create new call frame and make the call
; param5  from: LPREGISTERWORD

        mov     edi, [ebx+28]             ; base address
        mov     eax, edi
        test    eax, eax
        jz      Skip_Data                 ; don't map if not given
        mov     dword ptr SavelpData, edi
        push    edi
        call    MapSLFix
        mov     edi, eax
        mov     eax, [edi]                ; eax = lpReading (16:16)
        mov     dword ptr SavelpRead, eax ;
        test    eax, eax
        jz      Skip_Read
        push    eax
        call    MapSLFix
Skip_Read:
        mov     dword ptr lpRead,eax      ; eax = lpReading (32)
        mov     eax, [edi+4]              ; eax = lpWord (16:16)
        mov     dword ptr SavelpWord, eax
        test    eax, eax
        jz      Skip_Word
        push    eax
        call    MapSLFix
Skip_Word:
        mov     dword ptr lpWord,eax
        lea     eax,lpRead
Skip_Data:                                ; Here we ger param5 in eax.

; param7  from: unsigned short
        movzx   edi,word ptr [ebx+22]
        push    edi                     ; to: unsigned long

; param6  from: unsigned long
        push    dword ptr [ebx+24]      ; to unsigned long

; param5  from: unsigned long
        push    eax

; param4  from: unsigned long
        push    dword ptr [ebx+32]      ; to unsigned long

; param3  from: unsigned short
        movzx   eax,word ptr [ebx+36]
        push    eax                     ; to: unsigned long

; param2  from: unsigned long
        push    dword ptr [ebx+38]      ; to unsigned long

; param1  from: unsigned long
        push    dword ptr [ebx+42]      ; to unsigned long

        call    K32Thk1632Prolog@0
        call    Imm32Configure@28               ; call 32-bit version
        call    K32Thk1632Epilog@0

; return code long --> short
; no conversion needed

        lea     eax,SavelpData
        push    eax
        push    dword ptr 3
        call    UnMapSLFixArray ;! Preserves eax & edx
        pop     edi
        pop     ebp
;-------------------------------------
exit:
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\olethk.inc ===
;----------------------------Module-Header------------------------------;
; Module Name: olethk.inc
;
; Win32s OLE client library include
;
; Copyright (c) 1992  Microsoft Corporation
; All rights reserved.
;
; History:
; 06-May-92  KevinR     wrote it
;
;-----------------------------------------------------------------------;
; from ole.h
;
OLE_OK                           equ 0
OLE_WAIT_FOR_RELEASE             equ 1
OLE_BUSY                         equ 2
OLE_ERROR_PROTECT_ONLY           equ 3
OLE_ERROR_MEMORY                 equ 4
OLE_ERROR_STREAM                 equ 5
OLE_ERROR_STATIC                 equ 6
OLE_ERROR_BLANK                  equ 7
OLE_ERROR_DRAW                   equ 8
OLE_ERROR_METAFILE               equ 9
OLE_ERROR_ABORT                  equ 10
OLE_ERROR_CLIPBOARD              equ 11
OLE_ERROR_FORMAT                 equ 12
OLE_ERROR_OBJECT                 equ 13
OLE_ERROR_OPTION                 equ 14
OLE_ERROR_PROTOCOL               equ 15
OLE_ERROR_ADDRESS                equ 16
OLE_ERROR_NOT_EQUAL              equ 17
OLE_ERROR_HANDLE                 equ 18
OLE_ERROR_GENERIC                equ 19
OLE_ERROR_CLASS                  equ 20
OLE_ERROR_SYNTAX                 equ 21
OLE_ERROR_DATATYPE               equ 22
OLE_ERROR_PALETTE                equ 23
OLE_ERROR_NOT_LINK               equ 24
OLE_ERROR_NOT_EMPTY              equ 25
OLE_ERROR_SIZE                   equ 26
OLE_ERROR_DRIVE                  equ 27
OLE_ERROR_NETWORK                equ 28
OLE_ERROR_NAME                   equ 29
OLE_ERROR_TEMPLATE               equ 30
OLE_ERROR_NEW                    equ 31
OLE_ERROR_EDIT                   equ 32
OLE_ERROR_OPEN                   equ 33
OLE_ERROR_NOT_OPEN               equ 34
OLE_ERROR_LAUNCH                 equ 35
OLE_ERROR_COMM                   equ 36
OLE_ERROR_TERMINATE              equ 37
OLE_ERROR_COMMAND                equ 38
OLE_ERROR_SHOW                   equ 39
OLE_ERROR_DOVERB                 equ 40
OLE_ERROR_ADVISE_NATIVE          equ 41
OLE_ERROR_ADVISE_PICT            equ 42
OLE_ERROR_ADVISE_RENAME          equ 43
OLE_ERROR_POKE_NATIVE            equ 44
OLE_ERROR_REQUEST_NATIVE         equ 45
OLE_ERROR_REQUEST_PICT           equ 46
OLE_ERROR_SERVER_BLOCKED         equ 47
OLE_ERROR_REGISTRATION           equ 48
OLE_ERROR_ALREADY_REGISTERED     equ 49
OLE_ERROR_TASK                   equ 50
OLE_ERROR_OUTOFDATE              equ 51
OLE_ERROR_CANT_UPDATE_CLIENT     equ 52
OLE_ERROR_UPDATE                 equ 53
OLE_ERROR_SETDATA_FORMAT         equ 54
OLE_ERROR_STATIC_FROM_OTHER_OS   equ 55
OLE_WARN_DELETE_DATA             equ 1000
;-----------------------------------------------------------------------;
OLE_RELEASE                      equ 5
;-----------------------------------------------------------------------;

OF_SET      equ     0001h
OF_GET      equ     0002h
OF_HANDLER  equ     0004h

f16ptr  typedef ptr far16
f32ptr  typedef ptr far32


TRUE        =       1
FALSE       =       0
MAX_STRLEN  equ     50          ; LATER: what should this be?

;-----------------------------------------
_disp_16_offset_base    = 7*4
disp_16_retaddr         equ <dword ptr [bp - _disp_16_offset_base + 0]>
disp_16_di              equ < word ptr [bp - _disp_16_offset_base + 4]>
disp_16_si              equ < word ptr [bp - _disp_16_offset_base + 6]>
disp_16_bp              equ < word ptr [bp - _disp_16_offset_base + 8]>

_saved_register_offset = (4*4)
_dispatcher_offset     = _saved_register_offset + (8*4)


;-----------------------------------------
GMEM_FLAGS      equ  0042h  ; GMEM_MOVEABLE | GMEM_ZEROINIT
GMEM_FLAGS_DDE  equ  2042h  ; GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_DDESHARE


;=======================================================================

_model_flat  = 7
_model_large = 5
_model       = @Model

;==========================================================================
_label_uniq  =  0
NEW_LABEL  macro  argName
argName     catstr  <LABEL_>, %_label_uniq
_label_uniq  =  _label_uniq + 1
endm

;==========================================================================
extLab16  macro  argName
externDef  argName      :far16
argName    label         far16
endm

extLab32  macro  argName
externDef  argName      :near32
argName    label         near32
endm

extLab  macro  argName
    if _model eq _model_large
        extLab16  argName
    else
        extLab32  argName
    endif
endm


;-----------------------------------------
DEFP_NEAR32 macro arg
P&arg   typedef near32 ptr  arg
endm

DEFP_FAR16 macro arg
LP&arg  typedef far16 ptr  arg
endm


;-----------------------------------------
DEBUGBREAK  macro  argLab
        local   nobrk16, nobrk32

    ifdef DEBUG
    if _model eq _model_large
        push    ds
        push    si
        mov     si,seg    fOleDbgBrk16
        mov     ds,si
        assume  ds:(seg   fOleDbgBrk16)
        cmp     fOleDbgBrk16,word ptr 0
        jz      nobrk16

extLab  @CatStr( %@FileName, <_>, %@Line, <_>, argLab)
        int     3
nobrk16:
        pop     si
        pop     ds
        assume  ds:nothing
    else
        cmp     fOleDbgBrk32,dword ptr 0
        jz      nobrk32

extLab  @CatStr( %@FileName, <_>, %@Line, <_>, argLab)
        int     3
nobrk32:
    endif   ; _model
    endif
endm

;-----------------------------------------
SELOFF  struct  2t
off     dw  ?
sel     dw  ?
SELOFF  ends

;==========================================================================
; 32=>16 thunk starts in flat code.  It stores the 16:16 address of
; the target function in eax and jmp's to the thunk.
; 12 bytes
;
; 90 B8 <imm32,16:16Target>     mov     eax,<16:16Target>
; 90 E9 <rel32,Thk32-$>         jmp     Thk32
;
;
;
; use AllocCallback()
; 16=>32 thunk starts in 16-bit code.  It stores the flat offset of
; the target function in eax and jmp's to the thunk.
; 12 bytes
;
; 66 B8 <imm32,Target32>        mov     eax,<Target32>
; 90 EA <ptr16:16,Thk16>        jmp     Thk16
;
;==========================================================================

OPCODE_MOV_LS  equ 0B890h
OPCODE_JMP_LS  equ 0E990h

THKLS       struct  2t
    wOpcodeMov  WORD    ?   ; OPCODE_MOV_LS
    dwTarget    DWORD   ?   ; 16:16 address we are thunking to
    wOpcodeJmp  WORD    ?   ; OPCODE_JMP_LS
    dwThk       DWORD   ?   ; common thunk for this type
THKLS       ends
DEFP_FAR16    THKLS
DEFP_FAR16  LPTHKLS
DEFP_NEAR32   THKLS
DEFP_NEAR32  PTHKLS

OPCODE_MOV_SL  equ 0B866h
OPCODE_JMP_SL  equ 0EA90h

THKSL       struct  2t
    wOpcodeMov  WORD    ?   ; OPCODE_MOV_SL
    dwTarget    DWORD   ?   ; flat address we are thunking to
    wOpcodeJmp  WORD    ?   ; OPCODE_JMP_SL
    dwThk       DWORD   ?   ; common thunk for this type
THKSL       ends
DEFP_FAR16    THKSL
DEFP_FAR16  LPTHKSL
DEFP_NEAR32   THKSL
DEFP_NEAR32  PTHKSL


PFN struct 4t
    foo         DWORD   ?
PFN ends

PFN_COUNT macro arg
    exitm   %((SIZE arg)/(SIZE PFN))
endm

;==========================================================================
; 16-bit OLEOBJECT
;===================================
OLEOBJECTVTBL    struct  4t
    QueryProtocol           PFN     <>
    Release                 PFN     <>
    Show                    PFN     <>
    DoVerb                  PFN     <>
    GetData                 PFN     <>
    SetData                 PFN     <>
    SetTargetDevice         PFN     <>
    SetBounds               PFN     <>
    EnumFormats             PFN     <>
    SetColorScheme          PFN     <>
    ; Server has to implement only the above methods.

    ; Extra methods required for client.
    Delete                  PFN     <>
    SetHostNames            PFN     <>
    SaveToStream            PFN     <>
    Clone                   PFN     <>
    CopyFromLink            PFN     <>
    Equal                   PFN     <>
    CopyToClipboard         PFN     <>
    Draw                    PFN     <>
    Activate                PFN     <>
    Execute                 PFN     <>
    Close                   PFN     <>
    Update                  PFN     <>
    Reconnect               PFN     <>
    ObjectConvert           PFN     <>
    GetLinkUpdateOptions    PFN     <>
    SetLinkUpdateOptions    PFN     <>
    Rename                  PFN     <>
    QueryName               PFN     <>
    QueryType               PFN     <>
    QueryBounds             PFN     <>
    QuerySize               PFN     <>
    QueryOpen               PFN     <>
    QueryOutOfDate          PFN     <>
    QueryReleaseStatus      PFN     <>
    QueryReleaseError       PFN     <>
    QueryReleaseMethod      PFN     <>
    RequestData             PFN     <>
    ObjectLong              PFN     <>
OLEOBJECTVTBL    ends
DEFP_FAR16  OLEOBJECTVTBL
DEFP_FAR16  LPOLEOBJECTVTBL

OLEOBJECT struct 4t
    lpvtbl      LPOLEOBJECTVTBL    ?
    ;
    ; inaccessible state information
    ;
OLEOBJECT ends
DEFP_FAR16  OLEOBJECT
DEFP_FAR16  LPOLEOBJECT

;===================================
; 32-bit OLEOBJECT
;===================================
OLEOBJECTVTBL32 typedef OLEOBJECTVTBL
DEFP_NEAR32  OLEOBJECTVTBL32
DEFP_NEAR32  POLEOBJECTVTBL32

OLEOBJECT32 struct 4t
    poov        POLEOBJECTVTBL32    ?
    ;
    ; inaccessible state information
    ;
OLEOBJECT32 ends
DEFP_NEAR32  OLEOBJECT32
DEFP_NEAR32  POLEOBJECT32


;==========================================================================
; 16-bit OLEOBJECTSVR
;===================================
OLEOBJECTSVRVTBL    struct  4t
    ; Server has to implement only these methods.
    QueryProtocol           PFN     <>
    Release                 PFN     <>
    Show                    PFN     <>
    DoVerb                  PFN     <>
    GetData                 PFN     <>
    SetData                 PFN     <>
    SetTargetDevice         PFN     <>
    SetBounds               PFN     <>
    EnumFormats             PFN     <>
    SetColorScheme          PFN     <>
OLEOBJECTSVRVTBL    ends
DEFP_FAR16  OLEOBJECTSVRVTBL
DEFP_FAR16  LPOLEOBJECTSVRVTBL

;;OLEOBJECTSVR        struct 4t
;;    lpvtbl      LPOLEOBJECTSVRVTBL    ?
;;    ;
;;    ; inaccessible state information
;;    ;
;;OLEOBJECTSVR ends
;;DEFP_FAR16  OLEOBJECTSVR
;;DEFP_FAR16  LPOLEOBJECTSVR

;===================================
; 32-bit OLEOBJECTSVR
;===================================
OLEOBJECTSVRVTBL32 typedef OLEOBJECTSVRVTBL
DEFP_NEAR32  OLEOBJECTSVRVTBL32
DEFP_NEAR32  POLEOBJECTSVRVTBL32

OLEOBJECTSVR32 struct 4t
    poov        POLEOBJECTSVRVTBL32 ?
    ;
    ; inaccessible state information
    ;
OLEOBJECTSVR32 ends
DEFP_NEAR32  OLEOBJECTSVR32
DEFP_NEAR32  POLEOBJECTSVR32


;==========================================================================
; 16-bit OLECLIENT
;===================================
OLECLIENTVTBL       struct  4t
    CallBack                PFN     <>
OLECLIENTVTBL       ends
DEFP_FAR16  OLECLIENTVTBL
DEFP_FAR16  LPOLECLIENTVTBL

OLECLIENT           struct  4t
    lpvtbl                  PFN     <>
    ;
    ; inaccessible state information
    ;
OLECLIENT           ends
DEFP_FAR16  OLECLIENT
DEFP_FAR16  LPOLECLIENT

;===================================
; 32-bit OLECLIENT
;===================================
OLECLIENTVTBL32 typedef OLECLIENTVTBL
DEFP_NEAR32  OLECLIENTVTBL32
DEFP_NEAR32  POLECLIENTVTBL32

OLECLIENT32         struct  4t
    pocv        POLECLIENTVTBL32    ?
    ;
    ; inaccessible state information
    ;
OLECLIENT32         ends
DEFP_NEAR32  OLECLIENT32
DEFP_NEAR32  POLECLIENT32

;==========================================================================
; 16-bit OLESTREAM
;===================================
OLESTREAMVTBL       struct  4t
    Get                     PFN     <>
    Put                     PFN     <>
OLESTREAMVTBL       ends
DEFP_FAR16  OLESTREAMVTBL
DEFP_FAR16  LPOLESTREAMVTBL

OLESTREAM           struct  4t
    lpvtbl                  PFN     <>
    ;
    ; inaccessible state information
    ;
OLESTREAM           ends
DEFP_FAR16  OLESTREAM
DEFP_FAR16  LPOLESTREAM

;===================================
; 32-bit OLESTREAM
;===================================
OLESTREAMVTBL32 typedef OLESTREAMVTBL
DEFP_NEAR32  OLESTREAMVTBL32
DEFP_NEAR32  POLESTREAMVTBL32

OLESTREAM32         struct  4t
    postrv      POLESTREAMVTBL32    ?
    ;
    ; inaccessible state information
    ;
OLESTREAM32         ends
DEFP_NEAR32  OLESTREAM32
DEFP_NEAR32  POLESTREAM32


;==========================================================================
; 16-bit OLESERVER
;===================================
OLESERVERVTBL       struct  4t
    Open                    PFN     <>
    Create                  PFN     <>
    CreateFromTemplate      PFN     <>
    Edit                    PFN     <>
    Exit                    PFN     <>
    Release                 PFN     <>
    Execute                 PFN     <>
OLESERVERVTBL       ends
DEFP_FAR16  OLESERVERVTBL
DEFP_FAR16  LPOLESERVERVTBL

OLESERVER           struct  4t
    lpvtbl                  PFN     <>
    ;
    ; inaccessible state information
    ;
OLESERVER           ends
DEFP_FAR16  OLESERVER
DEFP_FAR16  LPOLESERVER

;===================================
; 32-bit OLESERVER
;===================================
OLESERVERVTBL32 typedef OLESERVERVTBL
DEFP_NEAR32  OLESERVERVTBL32
DEFP_NEAR32  POLESERVERVTBL32

OLESERVER32         struct  4t
    posv        POLESERVERVTBL32    ?
    ;
    ; inaccessible state information
    ;
OLESERVER32         ends
DEFP_NEAR32  OLESERVER32
DEFP_NEAR32  POLESERVER32


;==========================================================================
; 16-bit OLESERVERDOC
;===================================
OLESERVERDOCVTBL       struct  4t
    Save                    PFN     <>
    Close                   PFN     <>
    SetHostNames            PFN     <>
    SetDocDimensions        PFN     <>
    GetObject               PFN     <>
    Release                 PFN     <>
    SetColorScheme          PFN     <>
    Execute                 PFN     <>
OLESERVERDOCVTBL       ends
DEFP_FAR16  OLESERVERDOCVTBL
DEFP_FAR16  LPOLESERVERDOCVTBL

OLESERVERDOC        struct  4t
    lpvtbl                  PFN     <>
    ;
    ; inaccessible state information
    ;
OLESERVERDOC        ends
DEFP_FAR16  OLESERVERDOC
DEFP_FAR16  LPOLESERVERDOC

;===================================
; 32-bit OLESERVERDOC
;===================================
OLESERVERDOCVTBL32 typedef OLESERVERDOCVTBL
DEFP_NEAR32  OLESERVERDOCVTBL32
DEFP_NEAR32  POLESERVERDOCVTBL32

OLESERVERDOC32         struct  4t
    podv        POLESERVERDOCVTBL32 ?
    ;
    ; inaccessible state information
    ;
OLESERVERDOC32         ends
DEFP_NEAR32  OLESERVERDOC32
DEFP_NEAR32  POLESERVERDOC32


;==========================================================================
; client-side
;==========================================================================

; created by OleCli32 for OleApp32 in OleCreateAPI32()
OLEOBJECTCLI    struct  4t
    poov               POLEOBJECTVTBL32 ?
    lpooSelf           LPOLEOBJECT      ?   ; 16:16 address of this struct
    lpoo               LPOLEOBJECT      ?   ; created by OleCli
    lpoc               LPOLECLIENT      ?   ; 16=>32 thunks to app's poc->pocv
    flStatus           DWORD            ?   ; status flags
    cfFormat           WORD             ?   ; format of pending OleSetData
    hData16            WORD             ?   ; for pending OleSetData
    hData32            DWORD            ?   ; for pending OleSetData
    oov                OLEOBJECTVTBL32  <>  ; addresses of atls[] elements
OLEOBJECTCLI    ends
OLEOBJECTCLI_HEADER_SIZE  = (6*4 + 2*2)
.errnz  OLEOBJECTCLI_HEADER_SIZE - (size OLEOBJECTCLI - size OLEOBJECTVTBL32)
DEFP_NEAR32   OLEOBJECTCLI
DEFP_NEAR32  POLEOBJECTCLI
DEFP_FAR16    OLEOBJECTCLI
DEFP_FAR16  LPOLEOBJECTCLI
OCLOBJ_DELETE_PENDING  =  00000001h
OCLOBJ_SETDATA_PENDING =  00000002h


; 16-bit
; seen by OleCli
OLECLIENTCLI    struct  2t
    lpocv              LPOLECLIENT   ?  ; &ocv
    poc                POLECLIENT32  ?  ; created by AppCli32
    ocv                OLECLIENTVTBL <> ; addresses of AllocCallback() thks
OLECLIENTCLI    ends
OLECLIENTCLI_HEADER_SIZE  = 2*4
.errnz  OLECLIENTCLI_HEADER_SIZE - (size OLECLIENTCLI - size OLECLIENTVTBL)
DEFP_FAR16  OLECLIENTCLI
DEFP_FAR16  LPOLECLIENTCLI


; 16-bit
; seen by OleCli
OLESTREAMCLI    struct  2t
    lpostrv LPOLESTREAMVTBL     ?   ; &ostrv
    postr   POLESTREAM32        ?   ; created by AppCli32
    ostrv   OLESTREAMVTBL       <>  ; addresses of atsl[] elements
;;    ; 16=>32 thunks to postr->postrv entries
;;    atsl    THKSL     PFN_COUNT( OLESTREAMVTBL) DUP (<>)
OLESTREAMCLI    ends
OLESTREAMCLI_HEADER_SIZE  = 2*4
.errnz  OLESTREAMCLI_HEADER_SIZE - (size OLESTREAMCLI - size OLESTREAMVTBL)
DEFP_FAR16  OLESTREAMCLI
DEFP_FAR16  LPOLESTREAMCLI


;==========================================================================
; server-side
;==========================================================================

; 16-bit
; created for OleSvr by OleSvr32
OLESERVERSVR  struct  2t
    lposv    LPOLESERVERVTBL     ?    ; &osv
    pos      POLESERVER32        ?    ; created by AppSvr32
    lhSvr    DWORD               ?    ; created by OleSvr
    fwStatus WORD                ?    ; various flags
    cLevel   WORD                ?    ; reentrancy level
    osv      OLESERVERVTBL       <>   ; addresses of 16=>32 thunks
OLESERVERSVR  ends
OLESERVERSVR_HEADER_SIZE  = 4*4
.errnz  OLESERVERSVR_HEADER_SIZE - (size OLESERVERSVR - size OLESERVERVTBL)
DEFP_FAR16  OLESERVERSVR
DEFP_FAR16  LPOLESERVERSVR
OSVSVR_DELETE_PENDING  =  00000001h

; 16-bit
; created for OleSvr by OleSvr32
OLESERVERDOCSVR  struct  2t
    lpodv    LPOLESERVERDOCVTBL  ?    ; &odv
    posd     POLESERVERDOC32     ?    ; created by AppSvr32
    lhDoc    DWORD               ?    ; created by OleSvr
    flStatus DWORD               ?    ; various flags
    odv      OLESERVERDOCVTBL    <>   ; addresses of 16=>32 thunks
OLESERVERDOCSVR  ends
OLESERVERDOCSVR_HEADER_SIZE  = 4*4
.errnz  OLESERVERDOCSVR_HEADER_SIZE - (size OLESERVERDOCSVR - size OLESERVERDOCVTBL)
DEFP_FAR16  OLESERVERDOCSVR
DEFP_FAR16  LPOLESERVERDOCSVR
OSVDOC_DELETE_PENDING  =  00000001h

; 16-bit
; created for OleSvr by OleSvr32
OLEOBJECTSVR  struct  2t
    lpoov   LPOLEOBJECTVTBL     ?    ; &oov
    poo     POLEOBJECTSVR32     ?    ; created by AppSvr32
    lpoc    LPOLECLIENT         ?    ; created by OleSvr32, 32=>16 thunks
    oov     OLEOBJECTSVRVTBL    <>   ; addresses of 16=>32 thunks
OLEOBJECTSVR  ends
OLEOBJECTSVR_HEADER_SIZE  = 3*4
.errnz  OLEOBJECTSVR_HEADER_SIZE - (size OLEOBJECTSVR - size OLEOBJECTSVRVTBL)
DEFP_FAR16  OLEOBJECTSVR
DEFP_FAR16  LPOLEOBJECTSVR

; 32-bit
; seen by AppSvr32, contains 32=>16 thunks
OLECLIENTSVR  struct  4t
    pocv    POLECLIENTVTBL32    ?    ; &ocv
    lpoc    LPOLECLIENT         ?    ; created by OleSvr
    ocv     OLECLIENTVTBL32     <>   ; addresses of 32=>16 thunks
OLECLIENTSVR  ends
OLECLIENTSVR_HEADER_SIZE  = 2*4
.errnz  OLECLIENTSVR_HEADER_SIZE - (size OLECLIENTSVR - size OLECLIENTVTBL32)
DEFP_FAR16  OLECLIENTSVR
DEFP_FAR16  LPOLECLIENTSVR


if 0
////////////////////////////////////////////////////////////////////////////
// OleObj
////////////////////////////////////////////////////////////////////////////

// LATER: these structs need work, they are not checked

// created by OleCli32 for OleObj in DefCreateAPI32()
typedef struct _OLEOBJECTOBJ {
    POLEOBJECTVTBL32    poov;       // &oov,    hooked  VTBL32
    POLEOBJECTVTBL32    poovDef;    // &oovDef, default 32=>16 VTBL
    LPOLEOBJECT         lpoo;
    POLECLIENTCLI       poc;
    OLEOBJECTVTBL32     oovDef;     // addresses of atlsDef[] elements
    // default 32=>16 thunks to lpoo->lpvtbl entries
    THKLS             atlsDef[THK_COUNT( OLEOBJECTVTBL32)];
} OLEOBJECTOBJ, *POLEOBJECTOBJ, **PPOLEOBJECTOBJ;


// 16-bit
// created by
typedef struct _OLEOBJECTHND {
    LPOLEOBJECTVTBL     lpoov;       // &oov,    hooked  16=>32 VTBL
    OLEOBJECTVTBL       oov;         // addresses of atsl[] elements
    THKSL             atsl[THK_COUNT( OLEOBJECTVTBL)];// hooked 16=>32 thunks
} OLEOBJECTHND, FAR *LPOLEOBJECTHND;
typedef LPOLEOBJECTHND FAR *LPLPOLEOBJECTHND;


// seen by OleCli32
typedef struct _OLECLIENTOBJ {
    POLECLIENTVTBL32    pocv;       // &ocv
    LPOLECLIENT         lpoc;       // created by AppCli API
    OLECLIENTVTBL32     ocv;        // addresses of atls[] elements
    // 32=>16 thunks to lpoc->lpvtbl entries
    THKLS             atls[THK_COUNT( OLECLIENTVTBL32)];
} OLECLIENTOBJ, *POLECLIENTOBJ, **PPOLECLIENTOBJ;


// seen by OleCli
typedef struct _OLESTREAMOBJ {
    POLESTREAMVTBL32    postrv;     // &ostrv
    OLEOBJECTVTBL32     ostrv;      // addresses of atls[] elements
    // 32=>16 thunks to lpoo->lpvtbl entries
    THKLS             atls[THK_COUNT( OLEOBJECTVTBL32)];
} OLESTREAMOBJ, *POLESTREAMOBJ, **PPOLESTREAMOBJ;




endif


;;;=======================================================================
;;OCL_PENDING_DELETE_OBJECT  struct  2t
;;    lpNext      DWORD           ?   ; next struct in the list
;;    lpooFlat    LPOLEOBJECT     ?   ; 16:16 addr of flat thunk object
;;OCL_PENDING_DELETE_OBJECT  ends
;;OCL_PENDING_DELETE_OBJECT_INITIAL_COUNT = 20    ; should be plenty
;;
;=======================================================================
CREATE_BLOCK  struct  4t
    lpoo        LPOLEOBJECT     ?
    poo         POLEOBJECTCLI   ?
CREATE_BLOCK  ends

_create_block_offset = _dispatcher_offset + SIZE(CREATE_BLOCK)
_create_block_offset_Clone              = _create_block_offset+(3*4)
_create_block_offset_CopyFromLink       = _create_block_offset+(4*4)
_create_block_offset_CopyFromLink2      = _create_block_offset+(3*4)
_create_block_offset_Create             = _create_block_offset+(5*4)
_create_block_offset_CreateInvisible    = _create_block_offset+(5*4)
_create_block_offset_CreateFromClip     = _create_block_offset+(4*4)
_create_block_offset_CreateFromFile     = _create_block_offset+(6*4)
_create_block_offset_CreateLinkFromClip = _create_block_offset+(4*4)
_create_block_offset_CreateLinkFromFile = _create_block_offset+(7*4)
_create_block_offset_LoadFromStream     = _create_block_offset+(5*4)

;-----------------------------------------

_stream_block_offset = _dispatcher_offset + SIZE(OLESTREAMCLI)
_stream_block_offset_SaveToStream  =_stream_block_offset+(1*4)
_stream_block_offset_LoadFromStream=_stream_block_offset+SIZE(CREATE_BLOCK)+(5*4)

;-----------------------------------------

_getbuff_cli_SL_count  equ  <(_curr_ipfn16 + _curr_ipfn_api)>
_getbuff_cli_LS_count  equ  <(_curr_ipfn32 + PFN_COUNT( OLEOBJECTVTBL32))>


;=======================================================================

SERVER_BLOCK  struct  2t
    lhSvr   DWORD           ?       ; created by OleSvr
    lpos    LPOLESERVER     ?       ; alloc'd by OleSvr32
    apfn    PFN     PFN_COUNT( OLESERVERVTBL) DUP (<>)
SERVER_BLOCK  ends
SERVER_BLOCK_HEADER_SIZE = 2*4

_server_block_offset  =  _dispatcher_offset + SIZE(SERVER_BLOCK) + (2*4)

;-----------------------------------------

SERVERDOC_BLOCK  struct  2t
    lhDoc   DWORD           ?       ; created by OleSvr
    lposd   LPOLESERVERDOC  ?       ; alloc'd by OleSvr32
    apfn    PFN     PFN_COUNT( OLESERVERDOCVTBL) DUP (<>)
SERVERDOC_BLOCK  ends
SERVERDOC_BLOCK_HEADER_SIZE = 2*4

_serverdoc_block_offset  =  _dispatcher_offset + SIZE(SERVERDOC_BLOCK) + (2*4)

;-----------------------------------------

_getbuff_svr_SL_count  equ  <(_curr_ipfn16 + _curr_ipfn_api)>
_getbuff_svr_LS_count  equ  <(_curr_ipfn32)>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\pdcthk.inc ===
; pdcthk.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\penthk0.inc ===
CodeData equ <THUNK16CodeData>

include thkrp.inc
include cbcheck.inc
include thkframe.inc
include public.inc
include thkmacro.inc
include struc.inc

include cbcid.inc
include pwcbid.inc

externDef PrivateEscape:near16
externDef CALLBACK_BODY_16:far16
externDef Escape:far16
externDef AllocCallback:far16
;externDef MapLS:far16
;externDef UnmapLS:far16
externDef GlobalAlloc:far16
externDef GlobalSize:far16
externDef GlobalFree:far16
externDef GlobalFix:far16
externDef GlobalUnfix:far16
externDef GlobalLock:far16
externDef GlobalUnlock:far16
externDef GetTextExtentPoint:far16
ifdef DEBUG
externDef _wsprintf:far16
externDef OutputDebugString:far16
endif

externDef AllocSelectorArray:far16
externDef SetSelectorBase:far16
externDef SetSelectorLimit:far16
externDef FreeSelector:far16
externDef SelectorAccessRights:far16

fLocalFlag      equ     fLzLog16
MAXHOTSPOT      equ     8

;===========================================================================
body_ADDPENINPUTHRC macro
        local L0, L1, L2, L3, L4, L5
bp_hrc          equ <[bp_top]>    ; bp+40   hrc
bp_rgPnt        equ <[bp_top+4]>  ; bp+44   rgPnt
bp_rgOem        equ <[bp_top+8]>  ; bp+48   rgOem
bp_fuOem        equ <[bp_top+12]> ; bp+52   fuOem
bp_lpsi         equ <[bp_top+16]> ; bp+56   lpsi

        APILOG16        ADDPENINPUTHRC, fApiLog16

;-------------------------------------
; Temp storage

        xor     eax,eax
        push    eax                     ; ptr param #1   rgPnt
        push    eax                     ; handle param #2   rgPnt
        push    eax                     ; ptr param #3   rgOem
        push    eax                     ; ptr param #4   lpsi
;-------------------------------------
; *** BEGIN parameter packing

; rgPnt
; pointer struct POINT --> struct POINT
        cld                             ; esi, edi will increment

; different pointer types
        mov     eax,bp_rgPnt            ; base address
        or      eax,eax
        jz      L0                      ; skip if null


; structures are not identical
; structures don't have pointers

        mov     ecx,dword ptr bp_lpsi   ; lpsi
        push    ds
        mov     ds,cs:THUNK16CodeData   
        mov     es, FlatData
        mov     ecx, es:[ecx+0]           ;lpsi->cPnt
        pop     ds

        or      ecx,ecx
        jle     L0                      ; skip if count negative or zero

        mov     ds,cs:THUNK16CodeData           ; LocalAlloc needs this
        mov     esi,eax

        push    ecx                     ; will get trashed by LocalAlloc
        push    byte ptr 0              ; alloc fixed
        lea     eax,[ecx*4]
        push    ax
        call    LocalAlloc
        pop     ecx
        or      ax,ax                   ; did we get a handle?
        jz      L0

        mov     [bp-8],ax               ; save handle
        MYLOCALLOCK     ax
        or      ax,ax                   ; did we get a near pointer?
        jz      L0

        mov     [bp-4],ax
        mov     [bp-2],ds
        movzx   edi,ax
        mov     es,cs:THUNK16CodeData           ; es:edi == destination
        mov     ds,es:FlatData          ; ds:esi == source
L1:
; x
; long --> short
        lods    dword ptr ds:[esi]      
        stos    word ptr es:[edi]       

; y
; long --> short
        lods    dword ptr ds:[esi]      
        stos    word ptr es:[edi]       

        loop    L1

        mov     ds,cs:THUNK16CodeData           ; es:edi == destination
L0:

; rgOem
; pointer void --> void
; same pointer types
        mov     eax,bp_rgOem            ; base address
        or      eax,eax
        jz      L2                      ; skip if null

        push    eax
; cod3216x.c, 1003
        call    MapLS
        mov     [bp-12],eax
L2:

; lpsi
; pointer struct STROKEINFO --> struct STROKEINFO
        sub     sp,12                   ; lpsi alloc space on stack

; different pointer types
        mov     eax,bp_lpsi             ; base address
        or      eax,eax
        jz      L3                      ; skip if null


; structures are not identical
; structures don't have pointers

        mov     [bp-16],sp              ; save offset to buffer
        mov     [bp-14],ss              ; save selector to buffer

        mov     di,ss
        mov     es,di
        movzx   edi,sp                  ; es:edi == destination address

        mov     esi,eax
        mov     ds,cs:THUNK16CodeData           ; need access to FlatData
        mov     ds,FlatData             ; ds:esi == source address
; cPnt
; unsigned long --> unsigned short
        lods    dword ptr ds:[esi]      
        stos    word ptr es:[edi]       

; cbPnts
; unsigned long --> unsigned short
        lods    dword ptr ds:[esi]      
        stos    word ptr es:[edi]       

; wPdk
; unsigned short --> unsigned short
        movs    word ptr es:[edi],word ptr ds:[esi]     
; dwTick
; unsigned long --> unsigned long
        movs    dword ptr es:[edi],dword ptr ds:[esi]   ; no conversion

L3:

; *** END   parameter packing
;-------------------------------------
; create new call frame and make the call

; hrc  
        push    dword ptr bp_hrc        ; 

; rgPnt  from: struct POINT
        push    dword ptr [bp-4]        ; to: struct POINT

; rgOem  from: void
        push    dword ptr [bp-12]       ; to: void

; fuOem  from: unsigned long
        push    word ptr bp_fuOem       ; to unsigned short

; lpsi  from: struct STROKEINFO
        push    dword ptr [bp-16]       ; to: struct STROKEINFO

        call    AddPenInputHRC          ; call 16-bit version

; return code short --> long
        cwde
;-------------------------------------
; *** BEGIN parameter unpacking

        push    eax                     ; save return code

; rgPnt
        mov     ax,[bp-4]               ; get pointer
        or      ax,ax
        jz      L4                      ; no pointer, but might have handle

        push    word ptr [bp-8]         ; push handle
        call    LocalUnlock

L4:
        mov     ax,[bp-8]               ; get handle again
        or      ax,ax
        jz      L5

        push    ax
        call    LocalFree

L5:
        pop     eax                     ; restore return code

; *** END   parameter unpacking
        push    eax
        push    dword ptr [bp - 12]
        call    UnmapLS
        pop     eax
;-------------------------------------
;--- If return value == -1, SetLastError(87)
        ERRCHK_EXIT     -1,87,Exit_20
endm; 


;===========================================================================
body_ADDPOINTSPENDATA macro
        local L0, L1, L2, L3, L4, L5
bp_hpndt        equ <[bp_top]>    ; bp+40   hpndt
bp_lppt         equ <[bp_top+4]>  ; bp+44   lppt
bp_lpvOemData   equ <[bp_top+8]>  ; bp+48   lpvOemData
bp_lpsi         equ <[bp_top+12]> ; bp+52   lpsi

        APILOG16        ADDPOINTSPENDATA, fApiLog16

;-------------------------------------
; Temp storage

        xor     eax,eax
        push    eax                     ; ptr param #1   lppt
        push    eax                     ; handle param #2   lppt
        push    eax                     ; ptr param #3   lpvOemData
        push    eax                     ; ptr param #4   lpsi
;-------------------------------------
; *** BEGIN parameter packing

; lppt
; pointer struct POINT --> struct POINT
        cld                             ; esi, edi will increment

; different pointer types
        mov     eax,bp_lppt             ; base address
        or      eax,eax
        jz      L0                      ; skip if null


; structures are not identical
; structures don't have pointers

        mov     ecx,dword ptr bp_lpsi   ; lpsi
        push    ds
        mov     ds,cs:THUNK16CodeData   
        mov     es, FlatData
        mov     ecx, es:[ecx+0]           ;lpsi->cPnt
        pop     ds

        or      ecx,ecx
        jle     L0                      ; skip if count negative or zero

        mov     ds,cs:THUNK16CodeData           ; LocalAlloc needs this
        mov     esi,eax

        push    ecx                     ; will get trashed by LocalAlloc
        push    byte ptr 0              ; alloc fixed
        lea     eax,[ecx*4]
        push    ax
        call    LocalAlloc
        pop     ecx
        or      ax,ax                   ; did we get a handle?
        jz      L0

        mov     [bp-8],ax               ; save handle
        MYLOCALLOCK     ax
        or      ax,ax                   ; did we get a near pointer?
        jz      L0

        mov     [bp-4],ax
        mov     [bp-2],ds
        movzx   edi,ax
        mov     es,cs:THUNK16CodeData           ; es:edi == destination
        mov     ds,es:FlatData          ; ds:esi == source
L1:
; x
; long --> short
        lods    dword ptr ds:[esi]      
        stos    word ptr es:[edi]       

; y
; long --> short
        lods    dword ptr ds:[esi]      
        stos    word ptr es:[edi]       

        loop    L1

        mov     ds,cs:THUNK16CodeData           ; es:edi == destination
L0:

; lpvOemData
; pointer void --> void
; same pointer types
        mov     eax,bp_lpvOemData               ; base address
        or      eax,eax
        jz      L2                      ; skip if null

        push    eax
; cod3216x.c, 1003
        call    MapLS
        mov     [bp-12],eax
L2:

; lpsi
; pointer struct STROKEINFO --> struct STROKEINFO
        sub     sp,12                   ; lpsi alloc space on stack

; different pointer types
        mov     eax,bp_lpsi             ; base address
        or      eax,eax
        jz      L3                      ; skip if null


; structures are not identical
; structures don't have pointers

        mov     [bp-16],sp              ; save offset to buffer
        mov     [bp-14],ss              ; save selector to buffer

        mov     di,ss
        mov     es,di
        movzx   edi,sp                  ; es:edi == destination address

        mov     esi,eax
        mov     ds,cs:THUNK16CodeData           ; need access to FlatData
        mov     ds,FlatData             ; ds:esi == source address
; cPnt
; unsigned long --> unsigned short
        lods    dword ptr ds:[esi]      
        stos    word ptr es:[edi]       

; cbPnts
; unsigned long --> unsigned short
        lods    dword ptr ds:[esi]      
        stos    word ptr es:[edi]       

; wPdk
; unsigned short --> unsigned short
        movs    word ptr es:[edi],word ptr ds:[esi]     
; dwTick
; unsigned long --> unsigned long
        movs    dword ptr es:[edi],dword ptr ds:[esi]   ; no conversion

L3:

; *** END   parameter packing
;-------------------------------------
; create new call frame and make the call

; hpndt  
        push    word ptr bp_hpndt       ; UINT conversion

; lppt  from: struct POINT
        push    dword ptr [bp-4]        ; to: struct POINT

; lpvOemData  from: void
        push    dword ptr [bp-12]       ; to: void

; lpsi  from: struct STROKEINFO
        push    dword ptr [bp-16]       ; to: struct STROKEINFO

        call    AddPointsPenData        ; call 16-bit version

; return code short --> long
        cwde
;-------------------------------------
; *** BEGIN parameter unpacking

        push    eax                     ; save return code

; lppt
        mov     ax,[bp-4]               ; get pointer
        or      ax,ax
        jz      L4                      ; no pointer, but might have handle

        push    word ptr [bp-8]         ; push handle
        call    LocalUnlock

L4:
        mov     ax,[bp-8]               ; get handle again
        or      ax,ax
        jz      L5

        push    ax
        call    LocalFree

L5:
        pop     eax                     ; restore return code

; *** END   parameter unpacking
        push    eax
        push    dword ptr [bp - 12]
        call    UnmapLS
        pop     eax
;-------------------------------------
;--- If return value == -1, SetLastError(87)
        ERRCHK_EXIT     -1,87,Exit_16
endm; 


;===========================================================================
body_INSERTPENDATASTROKE macro
        local L0, L1, L2, L3, L4, L5
bp_hpndt        equ <[bp_top]>    ; bp+40   hpndt
bp_iStrk        equ <[bp_top+4]>  ; bp+44   iStrk
bp_lppt         equ <[bp_top+8]>  ; bp+48   lppt
bp_lpvOemData   equ <[bp_top+12]> ; bp+52   lpvOemData
bp_lpsi         equ <[bp_top+16]> ; bp+56   lpsi

        APILOG16        INSERTPENDATASTROKE, fApiLog16

;-------------------------------------
; Temp storage

        xor     eax,eax
        push    eax                     ; ptr param #1   lppt
        push    eax                     ; handle param #2   lppt
        push    eax                     ; ptr param #3   lpvOemData
        push    eax                     ; ptr param #4   lpsi
;-------------------------------------
; *** BEGIN parameter packing

; lppt
; pointer struct POINT --> struct POINT
        cld                             ; esi, edi will increment

; different pointer types
        mov     eax,bp_lppt             ; base address
        or      eax,eax
        jz      L0                      ; skip if null


; structures are not identical
; structures don't have pointers

        mov     ecx,dword ptr bp_lpsi   ; lpsi
        push    ds
        mov     ds,cs:THUNK16CodeData   
        mov     es, FlatData
        mov     ecx, es:[ecx+0]           ;lpsi->cPnt
        pop     ds

        or      ecx,ecx
        jle     L0                      ; skip if count negative or zero

        mov     ds,cs:THUNK16CodeData           ; LocalAlloc needs this
        mov     esi,eax

        push    ecx                     ; will get trashed by LocalAlloc
        push    byte ptr 0              ; alloc fixed
        lea     eax,[ecx*4]
        push    ax
        call    LocalAlloc
        pop     ecx
        or      ax,ax                   ; did we get a handle?
        jz      L0

        mov     [bp-8],ax               ; save handle
        MYLOCALLOCK     ax
        or      ax,ax                   ; did we get a near pointer?
        jz      L0

        mov     [bp-4],ax
        mov     [bp-2],ds
        movzx   edi,ax
        mov     es,cs:THUNK16CodeData           ; es:edi == destination
        mov     ds,es:FlatData          ; ds:esi == source
L1:
; x
; long --> short
        lods    dword ptr ds:[esi]      
        stos    word ptr es:[edi]       

; y
; long --> short
        lods    dword ptr ds:[esi]      
        stos    word ptr es:[edi]       

        loop    L1

        mov     ds,cs:THUNK16CodeData           ; es:edi == destination
L0:

; lpvOemData
; pointer void --> void
; same pointer types
        mov     eax,bp_lpvOemData               ; base address
        or      eax,eax
        jz      L2                      ; skip if null

        push    eax
; cod3216x.c, 1003
        call    MapLS
        mov     [bp-12],eax
L2:

; lpsi
; pointer struct STROKEINFO --> struct STROKEINFO
        sub     sp,12                   ; lpsi alloc space on stack

; different pointer types
        mov     eax,bp_lpsi             ; base address
        or      eax,eax
        jz      L3                      ; skip if null


; structures are not identical
; structures don't have pointers

        mov     [bp-16],sp              ; save offset to buffer
        mov     [bp-14],ss              ; save selector to buffer

        mov     di,ss
        mov     es,di
        movzx   edi,sp                  ; es:edi == destination address

        mov     esi,eax
        mov     ds,cs:THUNK16CodeData           ; need access to FlatData
        mov     ds,FlatData             ; ds:esi == source address
; cPnt
; unsigned long --> unsigned short
        lods    dword ptr ds:[esi]      
        stos    word ptr es:[edi]       

; cbPnts
; unsigned long --> unsigned short
        lods    dword ptr ds:[esi]      
        stos    word ptr es:[edi]       

; wPdk
; unsigned short --> unsigned short
        movs    word ptr es:[edi],word ptr ds:[esi]     
; dwTick
; unsigned long --> unsigned long
        movs    dword ptr es:[edi],dword ptr ds:[esi]   ; no conversion

L3:

; *** END   parameter packing
;-------------------------------------
; create new call frame and make the call

; hpndt  
        push    word ptr bp_hpndt       ; UINT conversion

; iStrk 
        push    word ptr bp_iStrk     ; UINT conversion

; lppt  from: struct POINT
        push    dword ptr [bp-4]        ; to: struct POINT

; lpvOemData  from: void
        push    dword ptr [bp-12]       ; to: void

; lpsi  from: struct STROKEINFO
        push    dword ptr [bp-16]       ; to: struct STROKEINFO

        call    InsertPenDataStroke     ; call 16-bit version

; return code short --> long
        cwde
;-------------------------------------
; *** BEGIN parameter unpacking

        push    eax                     ; save return code

; lppt
        mov     ax,[bp-4]               ; get pointer
        or      ax,ax
        jz      L4                      ; no pointer, but might have handle

        push    word ptr [bp-8]         ; push handle
        call    LocalUnlock

L4:
        mov     ax,[bp-8]               ; get handle again
        or      ax,ax
        jz      L5

        push    ax
        call    LocalFree

L5:
        pop     eax                     ; restore return code

; *** END   parameter unpacking
        push    eax
        push    dword ptr [bp - 12]
        call    UnmapLS
        pop     eax
;-------------------------------------
;--- If return value == -1, SetLastError(87)
        ERRCHK_EXIT     -1,87,Exit_20
endm; 

body_GETPENMISCINFO macro
        local   exit, error_exit, L0, L3
        local   anpfnGPI, MAX_ACTION
        local   thk_PMI_BEDIT                   ;1
;        local   thk_PMI_IMECOLOR                ;2
        local   thk_PMI_CXTABLET                ;3
        local   thk_PMI_CYTABLET                ;4
        local   thk_PMI_COUNTRY                 ;5
        local   thk_PMI_PENTIP                  ;6
        local   thk_PMI_LENS                    ;7
        local   thk_PMI_TIMEOUT                 ;8
        local   thk_PMI_TIMEOUTGEST             ;9
        local   thk_PMI_TIMEOUTSEL              ;10
        local   thk_PMI_SYSFLAGS                ;11
        local   thk_PMI_INDEXFROMRGB            ;12
        local   thk_PMI_RGBFROMINDEX            ;13

bp_uParam       equ     <bp_top>
bp_lParam       equ     <bp_top+4>

;BP=SP upon entry

bp_pTmp equ     <dword ptr [bp-4]>

        mov     bx,word ptr bp_uParam
        cmp     bx,MAX_ACTION
        ja      error_exit

        add     bx,bx
        jmp     word ptr cs:anpfnGPI[bx]

anpfnGPI        label   word
        dw      offset error_exit                      
        dw      offset thk_PMI_BEDIT            ;1
;        dw      offset thk_PMI_IMECOLOR         ;2       
        dw      offset thk_PMI_CXTABLET         ;3       
        dw      offset thk_PMI_CYTABLET         ;4       
        dw      offset thk_PMI_COUNTRY          ;5       
        dw      offset thk_PMI_PENTIP           ;6       
        dw      offset thk_PMI_LENS             ;7       
        dw      offset thk_PMI_TIMEOUT          ;8       
        dw      offset thk_PMI_TIMEOUTGEST      ;9       
        dw      offset thk_PMI_TIMEOUTSEL       ;10       
        dw      offset thk_PMI_SYSFLAGS         ;11       
        dw      offset thk_PMI_INDEXFROMRGB     ;12       
        dw      offset thk_PMI_RGBFROMINDEX     ;13       
MAX_ACTION equ ($ - anpfnGPI)/2

error_exit:
        sub     eax,eax
        jmp     exit

;-----------------------------------------------------------------------;
; uParam = UINT
; lParam = LPUINT
;-----------------------------------------------------------------------;
thk_PMI_COUNTRY:
thk_PMI_CXTABLET:
thk_PMI_CYTABLET:
thk_PMI_LENS:
thk_PMI_SYSFLAGS:
thk_PMI_TIMEOUT:
thk_PMI_TIMEOUTGEST:
thk_PMI_TIMEOUTSEL:


        push    byte ptr 0              ;reserve and init local var
        mov     ax,sp                   ;save addr of local var

        push    word ptr bp_uParam
        mov     esi,bp_lParam
        or      esi,esi
        jz      error_exit

        push    ss
        push    ax

        call    GetPenMiscInfo
        cwde
        pop     cx                      ;recover local var value, clean stack

        mov     es,FlatData
        movzx   ecx,cx
        mov     es:[esi],ecx
        jmp     exit

;-----------------------------------------------------------------------;
; uParam = INT
; lParam = LPSTR
;-----------------------------------------------------------------------;
thk_PMI_PENTIP:
thk_PMI_RGBFROMINDEX:
thk_PMI_INDEXFROMRGB:
        push    word ptr bp_uParam
        push    dword ptr bp_lParam
        call    MapLS
        mov     dword ptr bp_lParam,eax
        push    eax
        call    GetPenMiscInfo
        cwde

        push    eax
        push    dword ptr bp_lParam
        call    UnmapLS
        pop     eax

        jmp     exit

thk_PMI_BEDIT:
;-----------------------------------------------------------------------;
; uParam = INT
; lParam = LPBOXEDITINFO
;-----------------------------------------------------------------------;

; bp+40   lpb

;-------------------------------------
; Temp storage

        xor     eax,eax
        push    eax                     ; ptr param #1   lpb
;-------------------------------------
; *** BEGIN parameter packing

; lpb
; pointer struct BOXEDITINFO --> struct BOXEDITINFO
        sub     sp,84                   ; lpb alloc space on stack

; different pointer types
        mov     eax,[bp+40]             ; base address
        or      eax,eax
        jz      L0                      ; skip if null


; structures are not identical
; structures don't have pointers

        mov     [bp-4],sp               ; save offset to buffer
        mov     [bp-2],ss               ; save selector to buffer

L0:

; *** END   parameter packing
;-------------------------------------
; create new call frame and make the call

; lpb  from: struct BOXEDITINFO
        push    dword ptr [bp-4]        ; to: struct BOXEDITINFO

        call    GetPenMiscInfo          ; call 16-bit version

; return code short --> long
        cwde
;-------------------------------------
; *** BEGIN parameter unpacking

        push    eax                     ; save return code

        cld                             ; esi, edi will increment

; lpb
; pointer struct BOXEDITINFO --> struct BOXEDITINFO
        mov     eax,[bp+40]             ; base address
        or      eax,eax
        jz      L3                      ; skip if null


; structures are not identical
; structures don't have pointers

        mov     es,cs:THUNK16CodeData
        mov     es,es:FlatData
        mov     edi,eax                 ; es:edi == destination address
        mov     si,ss
        mov     ds,si
        movzx   esi,word ptr [bp-4]             ; ds:esi == source address

; cxBox
; short --> long
        lods    word ptr ds:[esi]       
        cwde
        stos    dword ptr es:[edi]      

; cyBox
; short --> long
        lods    word ptr ds:[esi]       
        cwde
        stos    dword ptr es:[edi]      

; cxBase
; short --> long
        lods    word ptr ds:[esi]       
        cwde
        stos    dword ptr es:[edi]      

; cyBase
; short --> long
        lods    word ptr ds:[esi]       
        cwde
        stos    dword ptr es:[edi]      

; cyMid
; short --> long
        lods    word ptr ds:[esi]       
        cwde
        stos    dword ptr es:[edi]      

; box
; struct BOXLAYOUT --> struct BOXLAYOUT
; cyCusp
; short --> long
        lods    word ptr ds:[esi]       
        cwde
        stos    dword ptr es:[edi]      

; cyEndCusp
; short --> long
        lods    word ptr ds:[esi]       
        cwde
        stos    dword ptr es:[edi]      

; style
; unsigned short --> unsigned long
        xor     eax,eax
        lods    word ptr ds:[esi]       
        stos    dword ptr es:[edi]      

; dwReserved1
; unsigned long --> unsigned long
        movs    dword ptr es:[edi],dword ptr ds:[esi]   ; no conversion

; dwReserved2
; unsigned long --> unsigned long
        movs    dword ptr es:[edi],dword ptr ds:[esi]   ; no conversion

; dwReserved3
; unsigned long --> unsigned long
        movs    dword ptr es:[edi],dword ptr ds:[esi]   ; no conversion

; wFlags
; unsigned short --> unsigned short
        movs    word ptr es:[edi],word ptr ds:[esi]     
; szFaceName
; unsigned char[32] --> unsigned char[32]
        mov     ecx,8
        rep     movs    dword ptr es:[edi],dword ptr ds:[esi]   

; wFontHeight
; unsigned short --> unsigned long
        xor     eax,eax
        lods    word ptr ds:[esi]       
        stos    dword ptr es:[edi]      

; rgwReserved
; unsigned char[16] --> unsigned char[16]
        mov     ecx,4
        rep     movs    dword ptr es:[edi],dword ptr ds:[esi]   

L3:
        pop     eax                     ; restore return code

; *** END   parameter unpacking
;-------------------------------------
;--- No error checking.
        jmp     exit

exit:
        mov     sp,bp
endm


body_SETPENMISCINFO macro
        local   exit, error_exit, L0
        local   anpfnGPI, MAX_ACTION
        local   thk_PMI_BEDIT                   ;1
;        local   thk_PMI_IMECOLOR                ;2
        local   thk_PMI_CXTABLET                ;3
        local   thk_PMI_CYTABLET                ;4
        local   thk_PMI_COUNTRY                 ;5
        local   thk_PMI_PENTIP                  ;6
        local   thk_PMI_LENS                    ;7
        local   thk_PMI_TIMEOUT                 ;8
        local   thk_PMI_TIMEOUTGEST             ;9
        local   thk_PMI_TIMEOUTSEL              ;10
        local   thk_PMI_SYSFLAGS                ;11
        local   thk_PMI_INDEXFROMRGB            ;12
        local   thk_PMI_RGBFROMINDEX            ;13

bp_uParam       equ     <bp_top>
bp_lParam       equ     <bp_top+4>

;BP=SP upon entry

bp_pTmp equ     <dword ptr [bp-4]>

        mov     bx,word ptr bp_uParam
        cmp     bx,MAX_ACTION
        ja      error_exit

        add     bx,bx
        jmp     word ptr cs:anpfnGPI[bx]

anpfnGPI        label   word
        dw      offset error_exit                      
        dw      offset thk_PMI_BEDIT            ;1
        dw      offset error_exit               ;2 Deal with IME_COLOR later
;       dw      offset thk_PMI_IMECOLOR         ;2       
        dw      offset thk_PMI_CXTABLET         ;3       
        dw      offset thk_PMI_CYTABLET         ;4       
        dw      offset thk_PMI_COUNTRY          ;5       
        dw      offset thk_PMI_PENTIP           ;6       
        dw      offset thk_PMI_LENS             ;7       
        dw      offset thk_PMI_TIMEOUT          ;8       
        dw      offset thk_PMI_TIMEOUTGEST      ;9       
        dw      offset thk_PMI_TIMEOUTSEL       ;10       
        dw      offset thk_PMI_SYSFLAGS         ;11       
        dw      offset thk_PMI_INDEXFROMRGB     ;12       
        dw      offset thk_PMI_RGBFROMINDEX     ;13       
MAX_ACTION equ ($ - anpfnGPI)/2

error_exit:
        sub     eax,eax
        jmp     exit

;-----------------------------------------------------------------------;
; uParam = UINT
; lParam = LPUINT
;-----------------------------------------------------------------------;
thk_PMI_COUNTRY:
thk_PMI_CXTABLET:
thk_PMI_CYTABLET:
thk_PMI_LENS:
thk_PMI_SYSFLAGS:
thk_PMI_TIMEOUT:
thk_PMI_TIMEOUTGEST:
thk_PMI_TIMEOUTSEL:
thk_PMI_RGBFROMINDEX:
thk_PMI_INDEXFROMRGB:
        mov     eax, bp_lparam
        or      eax,eax
        jz      error_exit
        push    word ptr bp_uParam
        push    eax
        call    SetPenMiscInfo
        cwde
        jmp     exit

;-----------------------------------------------------------------------;
; uParam = INT
; lParam = PENTIP
;-----------------------------------------------------------------------;
thk_PMI_PENTIP:
        push    word ptr bp_uParam
        push    dword ptr bp_lParam
        call    MapLS
        mov     dword ptr bp_lParam,eax
        push    eax
        call    SetPenMiscInfo
        cwde

        push    eax
        push    dword ptr bp_lParam
        call    UnmapLS
        pop     eax

        jmp     exit

thk_PMI_BEDIT:
;-----------------------------------------------------------------------;
; uParam = INT
; lParam = LPBOXEDITINFO
;-----------------------------------------------------------------------;
;===========================================================================

; bp+40   lpb

;-------------------------------------
; Temp storage

        xor     eax,eax
        push    eax                     ; ptr param #1   lpb
;-------------------------------------
; *** BEGIN parameter packing

; lpb
; pointer struct BOXEDITINFO --> struct BOXEDITINFO
        cld                             ; esi, edi will increment

        sub     sp,84                   ; lpb alloc space on stack

; different pointer types
        mov     eax,[bp+40]             ; base address
        or      eax,eax
        jz      L0                      ; skip if null


; structures are not identical
; structures don't have pointers

        mov     [bp-4],sp               ; save offset to buffer
        mov     [bp-2],ss               ; save selector to buffer

        mov     di,ss
        mov     es,di
        movzx   edi,sp                  ; es:edi == destination address

        mov     esi,eax
        mov     ds,cs:THUNK16CodeData           ; need access to FlatData
        mov     ds,FlatData             ; ds:esi == source address
; cxBox
; long --> short
        lods    dword ptr ds:[esi]      
        stos    word ptr es:[edi]       

; cyBox
; long --> short
        lods    dword ptr ds:[esi]      
        stos    word ptr es:[edi]       

; cxBase
; long --> short
        lods    dword ptr ds:[esi]      
        stos    word ptr es:[edi]       

; cyBase
; long --> short
        lods    dword ptr ds:[esi]      
        stos    word ptr es:[edi]       

; cyMid
; long --> short
        lods    dword ptr ds:[esi]      
        stos    word ptr es:[edi]       

; box
; struct BOXLAYOUT --> struct BOXLAYOUT
; cyCusp
; long --> short
        lods    dword ptr ds:[esi]      
        stos    word ptr es:[edi]       

; cyEndCusp
; long --> short
        lods    dword ptr ds:[esi]      
        stos    word ptr es:[edi]       

; style
; unsigned long --> unsigned short
        lods    dword ptr ds:[esi]      
        stos    word ptr es:[edi]       

; dwReserved1
; unsigned long --> unsigned long
        movs    dword ptr es:[edi],dword ptr ds:[esi]   ; no conversion

; dwReserved2
; unsigned long --> unsigned long
        movs    dword ptr es:[edi],dword ptr ds:[esi]   ; no conversion

; dwReserved3
; unsigned long --> unsigned long
        movs    dword ptr es:[edi],dword ptr ds:[esi]   ; no conversion

; wFlags
; unsigned short --> unsigned short
        movs    word ptr es:[edi],word ptr ds:[esi]     
; szFaceName
; unsigned char[32] --> unsigned char[32]
        mov     ecx,8
        rep     movs    dword ptr es:[edi],dword ptr ds:[esi]   

; wFontHeight
; unsigned long --> unsigned short
        lods    dword ptr ds:[esi]      
        stos    word ptr es:[edi]       

; rgwReserved
; unsigned char[16] --> unsigned char[16]
        mov     ecx,4
        rep     movs    dword ptr es:[edi],dword ptr ds:[esi]   

L0:

; *** END   parameter packing
;-------------------------------------
; create new call frame and make the call

; lpb  from: struct BOXEDITINFO
        push    dword ptr [bp-4]        ; to: struct BOXEDITINFO

        call    SetPenMiscInfo          ; call 16-bit version

; return code short --> long
        cwde
;-------------------------------------
;--- No error checking.
        jmp     exit
exit:
        mov     sp,bp
endm

;===========================================================================
body_TARGETPOINTS macro
        local L0, L01, L1, L2, L3, L4, L5
bp_lpTarg       equ <[bp_top]>    ; bp+40   lpTarg
bp_rgPnt        equ <[bp_top+4]>  ; bp+44   rgPnt
bp_rgOem        equ <[bp_top+8]>  ; bp+48   rgOem
bp_fuOem        equ <[bp_top+12]> ; bp+52   fuOem
bp_lpsi         equ <[bp_top+16]> ; bp+56   lpsi

        APILOG16        TARGETPOINTS, fApiLog16

;-------------------------------------
; Temp storage

        xor     eax,eax
        push    eax                     ; ptr param #2   rgPnt
        push    eax                     ; handle param #2   rgPnt
        push    eax                     ; ptr param #3   rgOem
        push    eax                     ; ptr param #4   lpsi
        push    eax                     ; ptr param #1 lpTarg
;-------------------------------------
; *** BEGIN parameter packing

; rgPnt
; pointer struct POINT --> struct POINT
        cld                             ; esi, edi will increment

; different pointer types
        mov     eax,bp_rgPnt            ; base address
        or      eax,eax
        jz      L0                      ; skip if null


; structures are not identical
; structures don't have pointers

        mov     ecx,dword ptr bp_lpsi   ; lpsi
        push    ds
        mov     ds,cs:THUNK16CodeData   
        mov     es, FlatData
        mov     ecx, es:[ecx+0]           ;lpsi->cPnt
        pop     ds

        or      ecx,ecx
        jle     L0                      ; skip if count negative or zero

        mov     ds,cs:THUNK16CodeData           ; LocalAlloc needs this
        mov     esi,eax

        push    ecx                     ; will get trashed by LocalAlloc
        push    byte ptr 0              ; alloc fixed
        lea     eax,[ecx*4]
        push    ax
        call    LocalAlloc
        pop     ecx
        or      ax,ax                   ; did we get a handle?
        jz      L0

        mov     [bp-8],ax               ; save handle
        MYLOCALLOCK     ax
        or      ax,ax                   ; did we get a near pointer?
        jz      L0

        mov     [bp-4],ax
        mov     [bp-2],ds
        movzx   edi,ax
        mov     es,cs:THUNK16CodeData           ; es:edi == destination
        mov     ds,es:FlatData          ; ds:esi == source
L1:
; x
; long --> short
        lods    dword ptr ds:[esi]      
        stos    word ptr es:[edi]       

; y
; long --> short
        lods    dword ptr ds:[esi]      
        stos    word ptr es:[edi]       

        loop    L1

        mov     ds,cs:THUNK16CodeData           ; es:edi == destination
L0:

; lpTarg
; pointer void --> void
; same pointer types
        mov     eax,bp_lpTarg           ; base address
        or      eax,eax
        jz      L01                     ; skip if null

        push    eax
; cod3216x.c, 1003
        call    MapLS
        mov     [bp-20],eax

L01:
; rgOem
; pointer void --> void
; same pointer types
        mov     eax,bp_rgOem            ; base address
        or      eax,eax
        jz      L2                      ; skip if null

        push    eax
; cod3216x.c, 1003
        call    MapLS
        mov     [bp-12],eax

L2:

; lpsi
; pointer struct STROKEINFO --> struct STROKEINFO
        sub     sp,12                   ; lpsi alloc space on stack

; different pointer types
        mov     eax,bp_lpsi             ; base address
        or      eax,eax
        jz      L3                      ; skip if null


; structures are not identical
; structures don't have pointers

        mov     [bp-16],sp              ; save offset to buffer
        mov     [bp-14],ss              ; save selector to buffer

        mov     di,ss
        mov     es,di
        movzx   edi,sp                  ; es:edi == destination address

        mov     esi,eax
        mov     ds,cs:THUNK16CodeData           ; need access to FlatData
        mov     ds,FlatData             ; ds:esi == source address
; cPnt
; unsigned long --> unsigned short
        lods    dword ptr ds:[esi]      
        stos    word ptr es:[edi]       

; cbPnts
; unsigned long --> unsigned short
        lods    dword ptr ds:[esi]      
        stos    word ptr es:[edi]       

; wPdk
; unsigned short --> unsigned short
        movs    word ptr es:[edi],word ptr ds:[esi]     
; dwTick
; unsigned long --> unsigned long
        movs    dword ptr es:[edi],dword ptr ds:[esi]   ; no conversion

L3:

; *** END   parameter packing
;-------------------------------------
; create new call frame and make the call

; lpTarg  
        push    dword ptr [bp-20]       ; 

; rgPnt  from: struct POINT
        push    dword ptr [bp-4]        ; to: struct POINT

; rgOem  from: void
        push    dword ptr [bp-12]       ; to: void

; fuOem  from: unsigned long
        push    word ptr bp_fuOem       ; to unsigned short

; lpsi  from: struct STROKEINFO
        push    dword ptr [bp-16]       ; to: struct STROKEINFO

        call    TargetPoints            ; call 16-bit version

; return code short --> long
        cwde
;-------------------------------------
; *** BEGIN parameter unpacking

        push    eax                     ; save return code

; rgPnt
        mov     ax,[bp-4]               ; get pointer
        or      ax,ax
        jz      L4                      ; no pointer, but might have handle

        push    word ptr [bp-8]         ; push handle
        call    LocalUnlock

L4:
        mov     ax,[bp-8]               ; get handle again
        or      ax,ax
        jz      L5

        push    ax
        call    LocalFree

L5:
        pop     eax                     ; restore return code

; *** END   parameter unpacking
        push    eax
        push    dword ptr [bp - 12]
        call    UnmapLS

        push    dword ptr [bp - 20]     ; lpTarg
        call    UnmapLS
        pop     eax
;-------------------------------------
;--- If return value == -1, SetLastError(87)
        ERRCHK_EXIT     -2,87,Exit_20
endm; 

;===========================================================================
body_GETHOTSPOTSHRCRESULT macro
        local L8, L9, L10, L11, L12, L13, L14
bp_hresult      equ     <[bp_top]>      ; bp+40   hresult
bp_iSyv         equ     <[bp_top+4]>    ; bp+44   iSyv
bp_rgPnt        equ     <[bp_top+8]>    ; bp+48   rgPnt
bp_lphrgnArea   equ     <[bp_top+12]>    ; bp+52   lphrgnArea

        APILOG16        GETHOTSPOTSHRCRESULT, fApiLog16

;-------------------------------------
; Temp storage

        xor     eax,eax
        push    eax                     ; ptr param #1   rgPnt
        push    eax                     ; handle param #2   rgPnt
        push    eax                     ; ptr param #3   lphrgnArea
;-------------------------------------
; *** BEGIN parameter packing

; rgPnt
; pointer struct POINT --> struct POINT
; different pointer types
        mov     eax,bp_rgPnt            ; base address
        or      eax,eax
        jz      L8                      ; skip if null


; structures are not identical
; structures don't have pointers

        mov     ecx,MAXHOTSPOT
        mov     ds,cs:THUNK16CodeData           ; LocalAlloc needs this
        push    ecx                     ; will get trashed by LocalAlloc
        push    byte ptr 0              ; alloc fixed
        lea     eax,[ecx*4]
        push    ax
        call    LocalAlloc
        pop     ecx
        or      ax,ax                   ; did we get a handle?
        jz      L8

        mov     [bp-8],ax               ; save handle
        MYLOCALLOCK     ax
        or      ax,ax                   ; did we get a pointer?
        jz      L8

        mov     [bp-4],ax
        mov     [bp-2],ds
L8:

; lphrgnArea
; pointer unsigned long --> unsigned short
; different pointer types
        mov     eax,bp_lphrgnArea               ; base address
        or      eax,eax
        jz      L9                      ; skip if null

        push    eax
        call    MapLS
        mov     [bp-12],eax
L9:

; *** END   parameter packing
;-------------------------------------
; create new call frame and make the call

; hresult  from: unsigned long
        push    dword ptr bp_hresult    ; to unsigned long

; iSyv  from: unsigned long
        push    word ptr bp_iSyv        ; to unsigned short

; rgPnt  from: struct POINT
        push    dword ptr [bp-4]        ; to: struct POINT

; lphrgnArea  from: unsigned long
        push    dword ptr [bp-12]       ; to: unsigned short

        call    GetHotspotsHRCRESULT            ; call 16-bit version

; return code short --> long
        cwde
;-------------------------------------
; *** BEGIN parameter unpacking

        mov     ecx,eax                 ; get the return count 
        push    eax                     ; save return code

        cld                             ; esi, edi will increment

; rgPnt
; pointer struct POINT --> struct POINT
        mov     eax,bp_rgPnt            ; base address
        or      eax,eax
        jz      L12                     ; skip if null


; structures are not identical
; structures don't have pointers

        or      ecx,ecx                 
        jle     L12                     ; skip if count negative or zero

        mov     edi,eax

        movzx   esi,word ptr [bp-4]
        or      si,si
        jz      L10
        mov     ds,cs:THUNK16CodeData           ; ds:esi = src
        mov     es,FlatData             ; es:edi = dst
L13:
; x
; short --> long
        lods    word ptr ds:[esi]       
        cwde
        stos    dword ptr es:[edi]      

; y
; short --> long
        lods    word ptr ds:[esi]       
        cwde
        stos    dword ptr es:[edi]      

        loop    L13

; rgPnt
L10:
        mov     ax,[bp-4]               ; get pointer
        or      ax,ax
        jz      L11                     ; no pointer, but might have handle

        push    word ptr [bp-8]         ; push handle
        call    LocalUnlock

L11:
        mov     ax,[bp-8]               ; get handle again
        or      ax,ax
        jz      L14

        push    ax
        call    LocalFree

L14:
L12:
        pop     eax                     ; restore return code

; *** END   parameter unpacking
        push    eax
        push    dword ptr [bp - 12]
        call    UnmapLS
        pop     eax
;-------------------------------------
;--- No error checking.
        jmp     Exit_16

endm;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\shl1632.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\pwcbid.inc ===
; Callback-type id's for PENWIN callbacks. All callback-type id's are
; 32-bits long and the upper 16-bits must be set to the module's
; Callback Client id.
;
; WARNING -- WARNING -- WARNING
;
;   Win32c.dll uses the lower 16 bits of CBID's to index directly into
;   the tables stored in PENWIN.DLL (pwcb16.asm) and PENWIN32.DLL (pwcb32.asm).
;   Those tables *must* match these id's or callbacks will fail miserably.
;   Do everyone a big favor and add new id's only at the end, and never
;   change an existing id.
;   

CBID_DRAWPENDATAEX              equ     (0 + (CBCID_PEN SHL 16))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\pwcthk.inc ===
; pwcthk.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\pwfthk.inc ===
; pwfthk.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\public.inc ===
;***********************************************************************;
;!!! use public versions -- delete eventually
;
; Stuff in here should come from public include files.
;***********************************************************************;
myDWORD struc
lo  dw  ?
hi  dw  ?
myDWORD ends

MF_POPUP                equ 00000010h
MF_BITMAP                       equ 00000004h
MF_OWNERDRAW                equ 00000100h
MF_SEPARATOR                equ 00000800h

WS_CHILD                equ 40000000h
WS_EX_MDICHILD          equ 00000040h

DBWF_LPARAMPOINTER      equ    08000h

LBS_OWNERDRAWFIXED      equ     0010h
LBS_OWNERDRAWVARIABLE   equ     0020h
LBS_HASSTRINGS          equ     0040h

CBS_OWNERDRAWFIXED      equ     0010h
CBS_OWNERDRAWVARIABLE   equ     0020h
CBS_HASSTRINGS          equ     0200h

PROP_FROMWIN32          equ     0002h
GWL_STYLE               equ     (-16)

GW_CHILD        equ     05

LR_MONOCHROME   equ     00001h
LR_LOADFROMFILE equ     00010h
LR_DEFAULTSIZE  equ     00040h
LR_SHARED       equ     08000h

DI_DRAWICON     equ     0000fh

DSI_KERNEL      equ     00001h
DSI_32BIT       equ     00004h
DSI_NOTSHARED   equ     00008h

IMAGE_BITMAP    equ     0
IMAGE_ICON      equ     1
IMAGE_CURSOR    equ     2

SMT_SENDMESSAGE             equ 0
SMT_DEFWINDOWPROC           equ 1
SMT_DEFMDICHILDPROC         equ 2
SMT_DEFDLGPROC              equ 3
SMT_DEFFRAMEPROC            equ 4

PMT_POSTTHREADMESSAGE       equ 0
PMT_POSTMESSAGE             equ 1

TMT_TRANSLATEACCELERATOR    equ 0
TMT_TRANSLATEMDISYSACCEL    equ 1
TMT_ISDIALOGMESSAGE         equ 2
TMT_TRANSLATEMESSAGE        equ 3

CTLCOLOR_MSGBOX         equ 0
CTLCOLOR_EDIT           equ 1
CTLCOLOR_LISTBOX        equ 2
CTLCOLOR_BTN            equ 3
CTLCOLOR_DLG            equ 4
CTLCOLOR_SCROLLBAR      equ 5
CTLCOLOR_STATIC         equ 6

WM_CREATE               equ 001h
WM_DESTROY              equ 002h
WM_CTLCOLOR             equ 019h

WM_CTLCOLORMSGBOX       equ 132h
WM_CTLCOLOREDIT         equ WM_CTLCOLORMSGBOX + CTLCOLOR_EDIT
WM_CTLCOLORLISTBOX      equ WM_CTLCOLORMSGBOX + CTLCOLOR_LISTBOX
WM_CTLCOLORBTN          equ WM_CTLCOLORMSGBOX + CTLCOLOR_BTN
WM_CTLCOLORDLG          equ WM_CTLCOLORMSGBOX + CTLCOLOR_DLG
WM_CTLCOLORSCROLLBAR    equ WM_CTLCOLORMSGBOX + CTLCOLOR_SCROLLBAR
WM_CTLCOLORSTATIC       equ WM_CTLCOLORMSGBOX + CTLCOLOR_STATIC

WM_DDE_INITIATE         equ 3E0h
WM_DDE_TERMINATE        equ 3E1h
WM_DDE_ADVISE           equ 3E2h
WM_DDE_UNADVISE         equ 3E3h
WM_DDE_ACK              equ 3E4h
WM_DDE_DATA             equ 3E5h
WM_DDE_REQUEST          equ 3E6h
WM_DDE_POKE             equ 3E7h
WM_DDE_EXECUTE          equ 3E8h

WM_DROPFILES            equ 233h

WM_USER                 equ 400h

OBJ_BRUSH               equ 2
OBJ_FONT                equ 3
OBJ_BITMAP              equ 5
OBJ_RGN                 equ 6
OBJ_DC                  equ 7


EM_GETSEL       equ     0B0h
LB_ADDSTRING    equ     180h

GWL_WNDPROC     equ    (-4)
GWL_HINSTANCE   equ    (-6)
GWL_HWNDPARENT  equ    (-8)
GWL_ID          equ    (-12)
GWL_STYLE       equ    (-16)
GWL_EXSTYLE     equ    (-20)
GWL_USERDATA    equ    (-21)

DWL_DLGPROC     equ     4

GWW_HINSTANCE   equ    (-6)
GWW_HWNDPARENT  equ    (-8)
GWW_ID          equ    (-12)

; Class field offsets for GetClassLong() and GetClassWord()
GCL_MENUNAME      equ  (-8)
GCW_HBRBACKGROUND equ  (-10)
GCW_HCURSOR       equ  (-12)
GCW_HICON         equ  (-14)
GCW_HMODULE       equ  (-16)
GCW_CBWNDEXTRA    equ  (-18)
GCW_CBCLSEXTRA    equ  (-20)
GCL_WNDPROC       equ  (-24)
GCW_STYLE         equ  (-26)
GCL_STYLE         equ  (-26)
GCW_ATOM          equ  (-32)
GCW_HICONSM       equ  (-34)

FR_DIALOGTERM   equ    00000040h

LB_ERR          equ    (-1)

WM_DDE_FIRST    equ    3E0h
WM_DDE_LAST     equ    3EFh

XTYP_MASK       equ     00F0h
XTYP_SHIFT      equ     4

XTYP_ERROR              equ 0000h
XTYP_ADVDATA            equ 0010h
XTYP_ADVREQ             equ 0020h
XTYP_ADVSTART           equ 0030h
XTYP_ADVSTOP            equ 0040h
XTYP_EXECUTE            equ 0050h
XTYP_CONNECT            equ 0060h
XTYP_CONNECT_CONFIRM    equ 0070h
XTYP_XACT_COMPLETE      equ 0080h
XTYP_POKE               equ 0090h
XTYP_REGISTER           equ 00A0h
XTYP_REQUEST            equ 00B0h
XTYP_DISCONNECT         equ 00C0h
XTYP_UNREGISTER         equ 00D0h
XTYP_WILDCONNECT        equ 00E0h

XTYP_MASK               equ 00F0h
XTYP_SHIFT              equ    4

XCLASS_NOTIFICATION     equ 8000h
XCLASS_FLAGS            equ 4000h
XCLASS_DATA             equ 2000h
XCLASS_BOOL             equ 1000h

DDE_FNOTPROCESSED       equ 0

GMEM_DDESHARE           equ 2000h
GMEM_ZEROINIT           equ 0040h
GMEM_DISCARDED          equ 4000h
GMEM_MOVEABLE           equ 0002h

LMEM_MOVEABLE           equ     2
LPTR                    equ     40h
GHND                    equ     42h
GPTR                    equ     40h

PM_REMOVE               equ 1
PM_NOYIELD              equ 2

;This is here so krnthk.inc doesn't have to load in all of struc.inc.
POINT32 struc
x       dd      ?
y       dd      ?
POINT32 ends

DC_BINS         equ     6
DC_PAPERS       equ     2
DC_PAPERSIZE    equ     3
DC_MINEXTENT    equ     4
DC_MAXEXTENT    equ     5

CF_TEXT            equ   1
CF_BITMAP          equ   2
CF_METAFILEPICT    equ   3
CF_DIB             equ   8
CF_PALETTE         equ   9
CF_PENDATA         equ  10
CF_RIFF            equ  11
CF_WAVE            equ  12
CF_UNICODETEXT     equ  13
CF_ENHMETAFILE     equ  14
CF_DSPBITMAP       equ  82h
CF_DSPMETAFILEPICT equ  83h
CF_DSPENHMETAFILE  equ  8Eh
CF_PRIVATEFIRST    equ 200h
CF_PRIVATELAST     equ 2FFh
CF_GDIOBJFIRST     equ 300h
CF_GDIOBJLAST      equ 3FFh


HELP_CONTEXT            equ     00001h
HELP_QUIT               equ     00002h
HELP_INDEX              equ     00003h
HELP_HELPONHELP         equ     00004h
HELP_SETINDEX           equ     00005h
HELP_CONTEXTPOPUP       equ     00008h
HELP_FORCEFILE          equ     00009h

HELP_CONTEXTMENU        equ     0000Ah
HELP_FINDER             equ     0000Bh
HELP_WM_HELP            equ     0000Ch
HELP_TCARD              equ     08000h
HELP_TCARD_DATA         equ     00010h
HELP_TCARD_NEXT         equ     00011h

HELP_KEY                equ     00101h
HELP_COMMAND            equ     00102h
HELP_PARTIALKEY         equ     00105h
HELP_MULTIKEY           equ     00201h
HELP_SETWINPOS          equ     00203h

OFN_ENABLEHOOK                  equ     20h
OFN_ENABLETEMPLATE              equ     40h
OFN_ENABLETEMPLATEHANDLE        equ     80h

CC_ENABLEHOOK                   equ     10h
CC_ENABLETEMPLATE               equ     20h
CC_ENABLETEMPLATEHANDLE         equ     40h

FR_ENABLEHOOK                   equ    100h
FR_ENABLETEMPLATE               equ    200h
FR_ENABLETEMPLATEHANDLE         equ   2000h

CF_ENABLEHOOK                   equ      8h
CF_ENABLETEMPLATE               equ     10h
CF_ENABLETEMPLATEHANDLE         equ     20h

PD_ENABLEPRINTHOOK              equ   1000h
PD_ENABLEPRINTTEMPLATE          equ   4000h
PD_ENABLEPRINTTEMPLATEHANDLE    equ  10000h
PD_ENABLESETUPHOOK              equ   2000h
PD_ENABLESETUPTEMPLATE          equ   8000h
PD_ENABLESETUPTEMPLATEHANDLE    equ  20000h


BI_RGB          equ     0h
BI_BITFIELDS    equ     3h

CBM_INIT        equ     4h

SM_PENWINDOWS   equ     41

DATA_GET        equ     0
DATA_WORD       equ     0
DATA_SET        equ     0001h
DATA_DWORD      equ     0002h
DATA_FROMWIN32  equ     0004h

KEYEVENTF_EXTENDEDKEY equ 0001h
KEYEVENTF_KEYUP       equ 0002h


CS_SHORTCUT     equ     10000000h

;; MsgWaitForMultipleObjectsEx() uses these flags.
MWMO_WAITALL    equ     00000001h
MWMO_ALERTABLE  equ     00000002h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\regthk.inc ===
CodeData equ <THUNK16BCodeData>

include cbcheck.inc

HKEY_ROOT_WIN32 equ     80000000h
HKEY_ROOT_WIN31 equ     00000001h

PUSH_MAPPED_HKEY        macro   iOffset
        local   hkey_ok

        mov     eax,dword ptr [bp+iOffset]
        cmp     eax,HKEY_ROOT_WIN32
        jne     hkey_ok

        rol     eax,1

hkey_ok:
        push    eax
endm

; Entry: DS:ESI --> source
;        ES:EDI --> dest
UNPACK_MAPPED_HKEY      macro iOffset, iTempOffset
        local   hkey_ok

        lods    dword ptr ds:[esi]
        cmp     eax,HKEY_ROOT_WIN31
        jne     hkey_ok

        ror     eax,1

hkey_ok:
        stos    dword ptr es:[edi]
endm

PUSH__REGDELETEKEYA_hkey macro   iOffset, iTempOffset
        PUSH_MAPPED_HKEY        iOffset
endm

PUSH__REGENUMKEYA_hkey   macro   iOffset, iTempOffset
        PUSH_MAPPED_HKEY        iOffset
endm

PUSH__REGCREATEKEYA_hkey macro   iOffset, iTempOffset
        PUSH_MAPPED_HKEY        iOffset
endm

UNPACK__REGCREATEKEYA_phkResult macro   iOffset, iTempOffset
        UNPACK_MAPPED_HKEY      iOffset, iTempOffset
endm

PUSH__REGCLOSEKEY_hkey   macro   iOffset, iTempOffset
        PUSH_MAPPED_HKEY        iOffset
endm

PUSH__REGOPENKEYA_hkey   macro   iOffset, iTempOffset
        PUSH_MAPPED_HKEY        iOffset
endm

UNPACK__REGOPENKEYA_phkResult   macro   iOffset, iTempOffset
        UNPACK_MAPPED_HKEY      iOffset, iTempOffset
endm

PUSH__REGQUERYVALUEA_hkey macro   iOffset, iTempOffset
        PUSH_MAPPED_HKEY        iOffset
endm

PUSH__REGSETVALUEA_hkey  macro   iOffset, iTempOffset
        PUSH_MAPPED_HKEY        iOffset
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\splfthk.inc ===
;; dummy file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\shl3216.inc ===
; DWORD CallCPLEntry16(UINT hinst, DWORD lpfnEntry,
;                            HWND hwndCPL, UINT msg,
;                            DWORD lParam1, DWORD lParam2)

BODYQT_CALLCPLENTRY16 macro index

    local CPL_afMapping
    local do_callcplentry16
    local apm_map_explicit
    local before_call
    local call_the_bugger
    local no_unmapping

    hinst       equ   <[ebp_qttop]>
    lpfnEntry   equ   <[ebp_qttop+4]>
    hwndCPL     equ   <[ebp_qttop+8]>
    msg         equ   <[ebp_qttop+12]>
    lParam1     equ   <[ebp_qttop+16]>
    lParam2     equ   <[ebp_qttop+20]>

        ; skip past our table below to the meat of the routine
        jmp     do_callcplentry16

;
; This table indicates whether we need to thunk lParam2 or not.
;
CPL_afMapping   label byte
        db      0   ; CPL_INIT
        db      0   ; CPL_GETCOUNT
        db      1   ; CPL_INQUIRE      int, LPCPINFO
        db      0   ; CPL_SELECT       int, DWORD
        db      0   ; CPL_DBLCLK       int, DWORD
        db      0   ; CPL_STOP         int, DWORD
        db      0   ; CPL_EXIT
        db      1   ; CPL_NEWINQUIRE   int, LPNEWCPLINFO
        db      1   ; CPL_STARTWPARAMS int, LPSTR
CPL_MAX equ     ($-CPL_afMapping)

apm_map_explicit:
        inc     ecx                     ;explicitly set mapping flag
        jmp     before_call

do_callcplentry16:
        xor     ecx, ecx                ;ecx controls pointer mapping, init 0
        mov     edx, dword ptr msg      ;message index so we can decide

        ; HACK: OEM APM extensions use entrypoints identical to CPlApplet,
        ;       but have msgs needing special care.  Caller sets bit 15
        ;       (0x8000) on these msgs.  Both msgs needing special care
        ;       map identically to CPL_NEWINQUIRE
        test    edx, 8000h              ;special APM msg?
        jnz     apm_map_explicit        ;we will need to map

        ; use table above to determine mapping, assumes ecx is still zero
        dec     edx                     ;the table is 0 based
        cmp     edx, CPL_MAX            ;check for index within table
        jnc     before_call             ;let it through with no mapping

        ; move the correct mapping flag from our table into ecx
        mov     cl, byte ptr cs:[edx + CPL_afMapping]

before_call:
        push    ecx                     ;save mapping flag for thunk return
        jcxz    call_the_bugger         ;skip mapping if it's zero

        ; map lParam2 to 16:16
        push    dword ptr lParam2
        call    MapLS                   
        mov     dword ptr lParam2, eax  ;pass mapped result instead

call_the_bugger:
        push    word ptr hinst          ;hinst: dword->word
        push    dword ptr lpfnEntry     ;lpfnEntry: dword->dword
        push    word ptr hwndCPL        ;hwndCPL: dword->word
        push    word ptr msg            ;msg: dword->word
        push    dword ptr lParam1       ;lParam1: dword->dword
        push    dword ptr lParam2       ;lParam2: dword->dword
        mov     cl,index                ;thunk index

        call    QT_Call16_DWordToDWord

        pop     ecx                     ;restore mapping flag from above
        jcxz    no_unmapping            ;skip unmapping if it's zero

        ; free 16:16 mapping for lParam2
        push     eax                    ;save CplApplet return value
        push     dword ptr lParam2
        call     UnMapLS
        pop      eax                    ;restore CplApplet return value

no_unmapping:
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SYNCHRONIZE_DRAIN=1

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\tapicbid.inc ===
; Callback-type id's for TAPI callbacks. All callback-type id's are
; 32-bits long and the upper 16-bits must be set to the module's
; Callback Client id.
;
; WARNING -- WARNING -- WARNING
;
;   Win32c.dll uses the lower 16 bits of CBID's to index directly into
;   the tables stored in GDI.EXE (gdicb16.asm) and GDI32.DLL (gdicb32.asm).
;   Those tables *must* match these id's or callbacks will fail miserably.
;   Do everyone a big favor and add new id's only at the end, and never
;   change an existing id.
;   

ID_LINEINITIALIZE               equ     0
ID_PHONEINITIALIZE              equ     1
ID_LINESHUTDOWN                 equ     2
ID_PHONESHUTDOWN                equ     3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\tapi32.inc ===
; Callback24 PROTO NEAR STDCALL :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD
;Callback24 PROTO NEAR STDCALL :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD

include thkrp.inc
include cbcheck.inc
include thkframe.inc
include public.inc
include thkmacro.inc

externDef Callback24:far16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\usr32thk.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\struc.inc ===
;-----------------------------------------------------------------------;
; STRUC.INC
;
; This module contains macros to support private structure definitions.
; The thunk layer requires private definitions because, since it needs
; both the 32-bit and 16-bit definitions at the same time, it cannot
; use the otherwise multiply defined versions from the public include
; files.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; DefType
;
;   name
;       The type name.
;   typesize
;       The type size compared to byte, word, or dword.
;
; Define the size of a type by creating the variable name&_size.
; This macro only accepts byte, word, or dword for typesize.
;-----------------------------------------------------------------------;
DefType     macro   name,typesize
    ifidn <typesize>,<byte>
        name&_size equ 1
    else
        ifidn <typesize>,<word>
            name&_size equ 2
        else
            ifdif <typesize>,<dword>
                .err
            endif
            name&_size equ 4
        endif
    endif
endm

;-----------------------------------------------------------------------;
; beginStruct
;
;   name
;       The structure base name.
;   tag
;       The structure tag.
;   mode
;       Whether the structure is the 16 or 32-bit version.
;
; The macro marks the beginning of a structure definition.  The fieldX
; macros and the endStruct macro are also necessary to completely
; define a structure.
;
;Structure data to maintain:
;
;   structure size          <name>_size
;
; Temp variables:
;   sname   structure name
;   stag    structure tag
;   ssize   structure size
;-----------------------------------------------------------------------;
beginStruct macro   name:req,tag,mode:req
    ifb <tag>
        cat <stag equ !<?>,&mode,!>
    else
        cat <stag equ >,!<,&tag, &mode,!>
    endif

    cat <sname equ >,!<,&name,&mode,!>

    ;Initialize temporary variables.
    ssize = 0
endm

;-----------------------------------------------------------------------;
; endStruct
;
; Marks the end of a structure definition.
;-----------------------------------------------------------------------;
endStruct   macro
    ;Define structure size
    cat %sname,_size,< equ <%ssize>>
endm

;-----------------------------------------------------------------------;
; field?
;
;   name
;       The field name, without the structure tag.
;   fieldtype
;       The field type.
;   fieldsize
;       The field size.  This may be blank, in which case the macro
;       looks up the size of the given fieldtype.
;
; Defines a structure field.
;
;Field data to maintain:
;
;       Field offset = <stag>_<name>
;-----------------------------------------------------------------------;
field?  macro   name:req, fieldtype:req, fieldsize

    ;If field size is not explicitly given, look up the size.
    ifnb <fieldsize>
        fsize equ <&fieldsize>
    else
        fsize equ <fieldtype&_size>
    endif

    cat %stag,_,&name,< equ >,%ssize

    ssize = ssize + fsize       ;update structure size
endm

;-----------------------------------------------------------------------;
; fieldB
;
; Define a byte field.
;-----------------------------------------------------------------------;
fieldB  macro   name
    field?  name,BYTE,1
endm

;-----------------------------------------------------------------------;
; fieldW
;
; Define a word field.
;-----------------------------------------------------------------------;
fieldW  macro   name
    field?  name,WORD,2
endm

;-----------------------------------------------------------------------;
; fieldD
;
; Define a dword field.
;-----------------------------------------------------------------------;
fieldD  macro   name
    field?  name,DWORD,4
endm


;-----------------------------------------------------------------------;
; Define types and structures.
;-----------------------------------------------------------------------;

DefType BYTE,            byte
DefType WORD,            word
DefType DWORD,          dword

DefType SHORT,           word
DefType LONG,           dword
DefType LPSTR,          dword

DefType int16,           word
DefType HANDLE16,        word
DefType HWND16,          word
DefType HMENU16,         word
DefType HMENUX16,        word
DefType HDC16,           word
DefType HRGN16,          word
DefType LPSZ16,         dword
DefType LPLOGFONT16,   dword
DefType PFNWNDPROC16,   dword
DefType PFNOPENFILENAME16, dword
DefType PFNCHOOSEFONT16,   dword
DefType PFNCHOOSECOLOR16,  dword
DefType PFNPRINTDLG16,     dword

DefType HANDLE32,       dword
DefType HWND32,         dword
DefType HMENU32,        dword
DefType HMENUX32,       dword
DefType HDC32,          dword
DefType HRGN32,         dword
DefType LPSZ32,         dword
DefType LPLOGFONT32,    dword
DefType PFNWNDPROC32,   dword
DefType PFNOPENFILENAME32, dword
DefType PFNCHOOSEFONT32,   dword
DefType PFNCHOOSECOLOR32,  dword
DefType PFNPRINTDLG32,     dword


beginStruct  RECT,rc,16
    field?  left   ,int16
    field?  top    ,int16
    field?  right  ,int16
    field?  bottom ,int16
endStruct

beginStruct  RECT,rc,32
    field?  left   ,LONG
    field?  top    ,LONG
    field?  right  ,LONG
    field?  bottom ,LONG
endStruct

beginStruct  POINT,pt,16
    field?  x,          int16
    field?  y,          int16
endStruct

beginStruct  POINT,pt,32
    field?  x ,LONG
    field?  y ,LONG
endStruct


beginStruct CREATESTRUCT,cs_,16
    field?  wIdHi      ,int16
    fieldD  lpCreateParams
    field?  hInstance  ,HANDLE16
    field?  hMenu      ,HMENUX16
    field?  hwndParent ,HWND16
    field?  cy         ,int16
    field?  cx         ,int16
    field?  y          ,int16
    field?  x          ,int16
    field?  style      ,LONG
    field?  lpszName   ,LPSZ16
    field?  lpszClass  ,LPSZ16
    field?  dwExStyle  ,LONG
endStruct

beginStruct CREATESTRUCT,cs_,32
    fieldD  lpCreateParams
    field?  hInstance  ,HANDLE32
    field?  hMenu      ,HMENUX32
    field?  hwndParent ,HWND32
    field?  cy         ,DWORD   ;SHORT -- stored as dwords
    field?  cx         ,DWORD   ;SHORT
    field?  y          ,DWORD   ;SHORT
    field?  x          ,DWORD   ;SHORT
    field?  style      ,LONG
    field?  lpszName   ,LPSZ32
    field?  lpszClass  ,LPSZ32
    field?  dwExStyle  ,LONG
endStruct

beginStruct COMPAREITEMSTRUCT,co_,16
    fieldW  CtlType
    fieldW  CtlIDLo
    field?  hwndItem,HWND16
    fieldW  itemID1
    fieldD  itemData1
    fieldW  itemID2
    fieldD  itemData2
    fieldD  dwLocaleId
    fieldW  CtlIDHi
endStruct

beginStruct COMPAREITEMSTRUCT,co_,32
    fieldD  CtlType
    fieldD  CtlID
    field?  hwndItem,HWND32
    fieldD  itemID1
    fieldD  itemData1
    fieldD  itemID2
    fieldD  itemData2
    fieldD  dwLocaleId           ;;new field
endStruct

beginStruct DELETEITEMSTRUCT,de_,16
    fieldW  CtlType
    fieldW  CtlIDLo
    fieldW  itemID
    field?  hwndItem,HWND16
    fieldD  itemData
    fieldW  CtlIDHi
endStruct

beginStruct DELETEITEMSTRUCT,de_,32
    fieldD  CtlType
    fieldD  CtlID
    fieldD  itemID
    field?  hwndItem,HWND32
    fieldD  itemData
endStruct

beginStruct  DRAWITEMSTRUCT,dr_,16
    fieldW  CtlType
    fieldW  CtlIDLo
    fieldW  itemID
    fieldW  itemAction
    fieldW  itemState
    field?  hwndItem ,HWND16
    field?  hDC      ,HDC16
    field?  rcItem   ,RECT16
    fieldD  itemData
    fieldW  CtlIDHi
endStruct

beginStruct  DRAWITEMSTRUCT,dr_,32
    fieldD  CtlType
    fieldD  CtlID
    fieldD  itemID
    fieldD  itemAction
    fieldD  itemState
    field?  hwndItem ,HWND32
    field?  hDC      ,HDC32
    field?  rcItem   ,RECT32
    fieldD  itemData
endStruct

beginStruct MEASUREITEMSTRUCT,me_,16
    fieldW  CtlType
    fieldW  CtlIDLo
    fieldW  itemID
    fieldW  itemWidth
    fieldW  itemHeight
    fieldD  itemData
    fieldW  CtlIDHi
endStruct

beginStruct MEASUREITEMSTRUCT,me_,32
    fieldD  CtlType
    fieldD  CtlID
    fieldD  itemID
    fieldD  itemWidth
    fieldD  itemHeight
    fieldD  itemData
endStruct


beginStruct DROPSTRUCT,drp,16
    field? hwndSource ,HWND16
    field? hwndSink   ,HWND16
    fieldW wFmt
    fieldD dwData
    field? ptDrop     ,POINT16
    fieldD dwControlData
endStruct

beginStruct DROPSTRUCT,drp,32
    field? hwndSource ,HWND32
    field? hwndSink   ,HWND32
    fieldD wFmt
    fieldD dwData
    field? ptDrop     ,POINT32
    fieldD dwControlData
endStruct

beginStruct MDICREATESTRUCT,,16
    field?  szClass ,LPSZ16
    field?  szTitle ,LPSZ16
    field?  hOwner  ,HANDLE16
    field?  x       ,int16
    field?  y       ,int16
    field?  cx      ,int16
    field?  cy      ,int16
    field?  style   ,LONG
    field?  lParam  ,LPSZ16
endStruct

beginStruct MDICREATESTRUCT,,32
    field?  szClass ,LPSZ32
    field?  szTitle ,LPSZ32
    field?  hOwner  ,HANDLE32
    field?  x       ,LONG
    field?  y       ,LONG
    field?  cx      ,LONG
    field?  cy      ,LONG
    field?  style   ,LONG
    field?  lParam  ,LPSZ32
endStruct

beginStruct MINMAXINFOSTRUCT,,16
    field? pt0, POINT16
    field? pt1, POINT16
    field? pt2, POINT16
    field? pt3, POINT16
    field? pt4, POINT16
endStruct

beginStruct MINMAXINFOSTRUCT,,32
    field? pt0, POINT32
    field? pt1, POINT32
    field? pt2, POINT32
    field? pt3, POINT32
    field? pt4, POINT32
endStruct

beginStruct MSGSTRUCT,ms,16
    field? hwnd,   HWND16
    fieldW message
    fieldW wParamLo
    field? lParam, LONG
    fieldD time
    field? pt,     POINT16
    fieldW wParamHi
endStruct

beginStruct MSGSTRUCT,ms,32
    field? hwnd,   HWND32
    fieldD message
    fieldD wParam
    field? lParam, LONG
    fieldD time
    field? pt,     POINT32
endStruct

beginStruct CWPSTRUCT,cwp,16
    fieldW wParamHi
    field? lParam, LONG
    fieldW wParamLo
    fieldW message
    field? hwnd,   HWND16
endStruct

beginStruct CWPSTRUCT,cwp,32
    field? lParam, LONG
    fieldD wParam
    fieldD message
    field? hwnd,   HWND32
endStruct

beginStruct CWPRETSTRUCT,cwpret,16
    fieldD  lResult
    fieldW  wParamHi
    fieldD  lParam
    fieldW  wParamLo
    fieldW  message
    field?  hwnd,   HWND16
endStruct

beginStruct CWPRETSTRUCT,cwpret,32
    fieldD  lResult
    fieldD  lParam
    fieldD  wParam
    fieldD  message
    field?  hwnd,   HWND32
endStruct

beginStruct HARDWAREHOOKSTRUCT,hhs,16
    field? hwnd,  HWND16
    fieldW message
    fieldW wParamLo
    fieldD lParam
    FieldW wParamHi
endStruct

beginStruct HARDWAREHOOKSTRUCT,hhs,32
    field? hwnd,  HWND32
    fieldD message
    fieldD wParam
    fieldD lParam
endStruct

beginStruct MOUSEHOOKSTRUCT,mhs,16
    field? point, POINT16
    field? hwnd,  HWND16
    fieldW wHitTestCode
    fieldD dwExtraInfo
endStruct

beginStruct MOUSEHOOKSTRUCT,mhs,32
    field? point, POINT32
    field? hwnd,  HWND32
    fieldD wHitTestCode
    fieldD dwExtraInfo
endStruct

beginStruct CBTHOOKSTRUCT,cbthk,16
    fieldD wParam
    fieldD lParam
endStruct

beginStruct CBTHOOKSTRUCT,cbthk,32
    fieldD wParam
    fieldD lParam
endStruct

beginStruct WINDOWPOS,wp,16
    field? hwnd,            HWND16
    field? hwndInsertAfter, HWND16
    field? x,               int16
    field? y,               int16
    field? cx,              int16
    field? cy,              int16
    fieldW flags
endStruct

beginStruct WINDOWPOS,wp,32
    field? hwnd,            HWND32
    field? hwndInsertAfter, HWND32
    field? x,               LONG
    field? y,               LONG
    field? cx,              LONG
    field? cy,              LONG
    fieldD flags
endStruct


beginStruct NCCALCSIZE,ncs,16
    field?  rcFirst,    RECT16
    field?  rcSecond,   RECT16
    field?  rcThird,    RECT16
    field?  lpWndPos,   LPSZ16
    field?  wndPos,     WINDOWPOS16
endStruct

beginStruct NCCALCSIZE,ncs,32
    field?  rcFirst,    RECT32
    field?  rcSecond,   RECT32
    field?  rcThird,    RECT32
    field?  lpWndPos,   LPSZ32
    field?  wndPos,     WINDOWPOS32
endStruct


beginStruct EVENTMSG,em,16
    fieldW message
    fieldW paramL
    fieldW paramH
    fieldD time
    field? hwnd, HWND16
endStruct

beginStruct EVENTMSG,em,32
    fieldD message
    fieldD paramL
    fieldD paramH
    fieldD time
    field? hwnd, HWND32
endStruct

beginStruct CBTACTIVATESTRUCT,cbta,16
    field? fMouse,     int16
    field? hwndActive, HWND16
endStruct

beginStruct CBTACTIVATESTRUCT,cbta,32
    field? fMouse,     LONG
    field? hwndActive, HWND32
endStruct

beginStruct CBT_CREATEWND,cbtc,16
    fieldD lpcs            ;LPCREATESTRUCT16
    field? hwndInsertAfter, HWND16
endStruct

beginStruct CBT_CREATEWND,cbtc,32
    fieldD lpcs            ;LPCREATESTRUCT32
    field? hwndInsertAfter, HWND32
endStruct

DDEPACK struc
    uiLo dd ?
    uiHi dd ?
DDEPACK ends

beginStruct CONVCONTEXT,cc,16
    fieldW cb
    fieldW wFlags
    fieldW wCountryID
    field? iCodePage        ,int16
    fieldD dwLangID
    fieldD dwSecurity
endStruct

beginStruct CONVCONTEXT,cc,32
    fieldD cb
    fieldD wFlags
    fieldD wCountryID
    field? iCodePage        ,LONG
    fieldD dwLangID
    fieldD dwSecurity
    fieldD Length                       ;  This is the quality
    fieldW ImpersonationLevel           ;  of service field.
    fieldW ContextTrackingMode          ;
    fieldW EffectiveOnly                ;
    fieldW PaddingByte                  ;  For ZP4 packing
endStruct

beginStruct CONVINFO,ci,16
    fieldD  cb
    fieldD  hUser
    fieldD  hConvPartner
    fieldD  hszSvcPartner
    fieldD  hszServiceReq
    fieldD  hszTopic
    fieldD  hszItem
    fieldW  wFmt
    fieldW  wType
    fieldW  wStatus
    fieldW  wConvst
    fieldW  wLastError
    fieldD  hConvList
    field?  ConvCtxt ,CONVCONTEXT16
endStruct

beginStruct CONVINFO,ci,32
    fieldD  cb
    fieldD  hUser
    fieldD  hConvPartner
    fieldD  hszSvcPartner
    fieldD  hszServiceReq
    fieldD  hszTopic
    fieldD  hszItem
    fieldD  wFmt
    fieldD  wType
    fieldD  wStatus
    fieldD  wConvst
    fieldD  wLastError
    fieldD  hConvList
    field?  ConvCtxt ,CONVCONTEXT32
    fieldD  hwnd
    fieldD  hwndPartner
endStruct

;The last field is not used by the system -- vestigial.
beginStruct PAINTSTRUCT,ps,16
    field? hdc        ,HDC16
    field? fErase     ,int16
    field? rcPaint    ,RECT16
    field? fRestore   ,int16
    field? fIncUpdate ,int16
    ;BYTE        rgbReserved[16];
    fieldD reserved1
    fieldD reserved2
    fieldD reserved3
    fieldD reserved4
endStruct

;The last field is not used by the system -- vestigial.
beginStruct PAINTSTRUCT,ps,32
    field? hdc        ,HDC32
    field? fErase     ,LONG
    field? rcPaint    ,RECT32
    field? fRestore   ,LONG
    field? fIncUpdate ,LONG
    ;BYTE        rgbReserved[32];
    fieldD reserved1
    fieldD reserved2
    fieldD reserved3
    fieldD reserved4
    fieldD reserved5
    fieldD reserved6
    fieldD reserved7
    fieldD reserved8
endStruct

beginStruct CREATESTRUCT2,cs_,16
    field?  wIdHi      ,int16
    fieldD  lpCreateParams
    field?  hInstance  ,HANDLE16
    field?  hMenu      ,HMENUX16
    field?  hwndParent ,HWND16
    field?  cy         ,int16
    field?  cx         ,int16
    field?  y          ,int16
    field?  x          ,int16
    field?  style      ,LONG
    field?  lpszName   ,LPSZ16
    field?  lpszClass  ,LPSZ16
    field?  dwExStyle  ,LONG

    field?  mdi_szClass ,LPSZ16
    field?  mdi_szTitle ,LPSZ16
    field?  mdi_hOwner  ,HANDLE16
    field?  mdi_x       ,int16
    field?  mdi_y       ,int16
    field?  mdi_cx      ,int16
    field?  mdi_cy      ,int16
    field?  mdi_style   ,LONG
    fieldD  mdi_lParam
endStruct

beginStruct CREATESTRUCT2,cs_,32
    fieldD  lpCreateParams
    field?  hInstance  ,HANDLE32
    field?  hMenu      ,HMENUX32
    field?  hwndParent ,HWND32
    field?  cy         ,LONG
    field?  cx         ,LONG
    field?  y          ,LONG
    field?  x          ,LONG
    field?  style      ,LONG
    field?  lpszName   ,LPSZ32
    field?  lpszClass  ,LPSZ32
    field?  dwExStyle  ,LONG

    field?  mdi_szClass ,LPSZ32
    field?  mdi_szTitle ,LPSZ32
    field?  mdi_hOwner  ,HANDLE32
    field?  mdi_x       ,LONG
    field?  mdi_y       ,LONG
    field?  mdi_cx      ,LONG
    field?  mdi_cy      ,LONG
    field?  mdi_style   ,LONG
    fieldD  mdi_lParam
endStruct

beginStruct RECTSTRUCT,rs,16
    field? ptPosition   ,POINT16
    field? ptSize       ,POINT16
    fieldW wStyle
    fieldW wPattern
endStruct

beginStruct RECTSTRUCT,rs,32
    field? ptPosition   ,POINT32
    field? ptSize       ,POINT32
    fieldW wStyle
    fieldW wPattern
endStruct

beginStruct LOGPEN,lopn,16
    fieldW Style
    field? Width        ,POINT16
    fieldD Color
endStruct

beginStruct LOGPEN,lopn,32
    fieldD Style
    field? Width        ,POINT32
    fieldD Color
endStruct

beginStruct LOGBRUSH,lb,16
    fieldW Style
    fieldD Color
    field? Hatch        ,int16
endStruct

beginStruct LOGBRUSH,lb,32
    fieldD Style
    fieldD Color
    field? Hatch        ,LONG
endStruct

beginStruct PATH_INFO,pi,16
    fieldW RenderMode
    fieldB FillMode
    fieldB BkMode
    field? Pen          ,LOGPEN16
    field? Brush        ,LOGBRUSH16
    fieldD BkColor
endStruct

beginStruct PATH_INFO,pi,32
    fieldW RenderMode
    fieldB FillMode
    fieldB BkMode
    field? Pen          ,LOGPEN32
    field? Brush        ,LOGBRUSH32
    fieldD BkColor
endStruct

beginStruct SCREENPARAMS,sp,16
    field? angle        ,int16
    field? frequency    ,int16
endStruct

beginStruct SCREENPARAMS,sp,32
    field? angle        ,LONG
    field? frequency    ,LONG
endStruct

beginStruct OPENFILENAME,ofn,16
    fieldD  cbSize
    field?  hwndOwner              ,HWND16
    field?  hInstance              ,HANDLE16
    field?  lpstrFilter            ,LPSZ16
    field?  lpstrCustomFilter      ,LPSZ16
    fieldD  nMaxCustFilter
    fieldD  nFilterIndex
    field?  lpstrFile              ,LPSZ16
    fieldD  nMaxFile
    field?  lpstrFileTitle         ,LPSZ16
    fieldD  nMaxFileTitle
    field?  lpstrInitialDir        ,LPSZ16
    field?  lpstrTitle             ,LPSZ16
    fieldD  Flags
    fieldW  nFileOffset
    fieldW  nFileExtension
    field?  lpstrDefExt            ,LPSZ16
    fieldD  lCustData
    field?  lpfnHook               ,PFNOPENFILENAME16
    field?  lpTemplateName         ,LPSZ16
endStruct

beginStruct OPENFILENAME,ofn,32
    fieldD  cbSize
    field?  hwndOwner              ,HWND32
    field?  hInstance              ,HANDLE32
    field?  lpstrFilter            ,LPSZ32
    field?  lpstrCustomFilter      ,LPSZ32
    fieldD  nMaxCustFilter
    fieldD  nFilterIndex
    field?  lpstrFile              ,LPSZ32
    fieldD  nMaxFile
    field?  lpstrFileTitle         ,LPSZ32
    fieldD  nMaxFileTitle
    field?  lpstrInitialDir        ,LPSZ32
    field?  lpstrTitle             ,LPSZ32
    fieldD  Flags
    fieldW  nFileOffset
    fieldW  nFileExtension
    field?  lpstrDefExt            ,LPSZ32
    fieldD  lCustData
    field?  lpfnHook               ,PFNOPENFILENAME32
    field?  lpTemplateName         ,LPSZ32
endStruct

beginStruct CHOOSECOLOR,cclr,16
    fieldD  cbSize
    field?  hwndOwner          ,HWND16
    field?  hInstance          ,HANDLE16
    fieldD  rgbResult
    field?  lpCustColors       ,LPSZ16
    fieldD  Flags
    fieldD  lCustData
    field?  lpfnHook           ,PFNCHOOSECOLOR16
    field?  lpTemplateName     ,LPSZ16
endStruct

beginStruct CHOOSECOLOR,cclr,32
    fieldD  cbSize
    field?  hwndOwner          ,HWND32
    field?  hInstance          ,HANDLE32
    fieldD  rgbResult
    field?  lpCustColors       ,LPSZ32
    fieldD  Flags
    fieldD  lCustData
    field?  lpfnHook           ,PFNCHOOSECOLOR32
    field?  lpTemplateName     ,LPSZ32
endStruct

beginStruct LOGFONT,mlf,16
    fieldW    lfHeight        
    fieldW    lfWidth         
    fieldW    lfEscapement    
    fieldW    lfOrientation   
    fieldW    lfWeight        
    fieldB    lfItalic
    fieldB    lfUnderline
    fieldB    lfStrikeOut
    fieldB    lfCharSet
    fieldB    lfOutPrecision
    fieldB    lfClipPrecision
    fieldB    lfQuality
    fieldB    lfPitchAndFamily
    field?    lfFaceName,BYTE,32
endStruct

beginStruct LOGFONT,mlf,32
    fieldD    lfHeight     
    fieldD    lfWidth      
    fieldD    lfEscapement 
    fieldD    lfOrientation
    fieldD    lfWeight 
    fieldB    lfItalic
    fieldB    lfUnderline
    fieldB    lfStrikeOut
    fieldB    lfCharSet
    fieldB    lfOutPrecision
    fieldB    lfClipPrecision
    fieldB    lfQuality
    fieldB    lfPitchAndFamily
    field?    lfFaceName,BYTE,32
endStruct

beginStruct CHOOSEFONT,cfnt,16
    fieldD  cbSize
    field?  hwndOwner          ,HWND16
    field?  hDC                ,HDC16
    field?  lpLogFont          ,LPLOGFONT16
    field?  iPointSize         ,int16
    fieldD  Flags
    fieldD  rgbColors
    fieldD  lCustData
    field?  lpfnHook           ,PFNCHOOSEFONT16
    field?  lpTemplateName     ,LPSZ16
    field?  hInstance          ,HANDLE16        ;!!!
    field?  lpszStyle          ,LPSZ16
    fieldW  nFontType
    field?  nSizeMin           ,int16
    field?  nSizeMax           ,int16
endStruct

beginStruct CHOOSEFONT,cfnt,32
    fieldD  cbSize
    field?  hwndOwner          ,HWND32
    field?  hDC                ,HDC32
    field?  lpLogFont          ,LPLOGFONT32
    field?  iPointSize         ,LONG
    fieldD  Flags
    fieldD  rgbColors
    fieldD  lCustData
    field?  lpfnHook           ,PFNCHOOSEFONT32
    field?  lpTemplateName     ,LPSZ32
    field?  hInstance          ,HANDLE32        ;!!!
    field?  lpszStyle          ,LPSZ32
    fieldW  nFontType
    fieldW  padding
    field?  nSizeMin           ,LONG
    field?  nSizeMax           ,LONG
endStruct

beginStruct CHOOSEFONT2,cfnt2,16
    field?  cfnt               ,CHOOSEFONT16
    field?  lf                 ,LOGFONT16
endStruct

beginStruct CHOOSEFONT2,cfnt2,32
    field?  cfnt               ,CHOOSEFONT32
    field?  lf                 ,LOGFONT32
endStruct

beginStruct PRINTDLG,pdlg,16
    fieldD  cbSize
    field?  hwndOwner          ,HWND16
    field?  hDevMode           ,HANDLE16        ;!!!
    field?  hDevNames          ,HANDLE16        ;!!!
    field?  hDC                ,HDC16
    fieldD  Flags
    fieldW  nFromPage
    fieldW  nToPage
    fieldW  nMinPage
    fieldW  nMaxPage
    fieldW  nCopies
    field?  hInstance          ,HANDLE16        ;!!!
    fieldD  lCustData
    field?  lpfnPrintHook      ,PFNPRINTDLG16
    field?  lpfnSetupHook      ,PFNPRINTDLG16
    field?  lpPrintTemplateName,LPSZ16
    field?  lpSetupTemplateName,LPSZ16
    fieldW  hPrintTemplate 
    fieldW  hSetupTemplate 
endStruct

beginStruct PRINTDLG,pdlg,32
    fieldD  cbSize
    field?  hwndOwner          ,HWND32
    field?  hDevMode           ,HANDLE32        ;!!!
    field?  hDevNames          ,HANDLE32        ;!!!
    field?  hDC                ,HDC32
    fieldD  Flags
    fieldW  nFromPage
    fieldW  nToPage
    fieldW  nMinPage
    fieldW  nMaxPage
    fieldW  nCopies
    field?  hInstance          ,HANDLE32        ;!!!
    fieldD  lCustData
    field?  lpfnPrintHook      ,PFNPRINTDLG32
    field?  lpfnSetupHook      ,PFNPRINTDLG32
    field?  lpPrintTemplateName,LPSZ32
    field?  lpSetupTemplateName,LPSZ32
    fieldD  hPrintTemplate   
    fieldD  hSetupTemplate   
endStruct

beginStruct COPYDATASTRUCT,cd,16
    fieldD dwData
    fieldD cbData
    field? lpData              ,LPSZ16
endStruct

beginStruct COPYDATASTRUCT,cd,32
    fieldD dwData
    fieldD cbData
    field? lpData              ,LPSZ32
endStruct

beginStruct HELPINFOSTRUCT,,16
    fieldD  cbSize
    fieldW  iContextType
    fieldW  iCtrlId
    field?  hItemHandle,  HWND16
    fieldD  dwContextId;
    field?  MousePos, POINT16
endStruct

beginStruct HELPINFOSTRUCT,,32
    fieldD  cbSize
    fieldD  iContextType
    fieldD  iCtrlId
    field?  hItemHandle,  HWND32
    fieldD  dwContextId;
    field?  MousePos, POINT32
endStruct


beginStruct MENUITEMINFO,mii_,16
    fieldD  cbSize
    fieldD  fMask
    fieldW  fType
    fieldW  fState
    fieldW  wID
    field?  hSubMenu,  HMENU16
    fieldW  hbmpChecked
    fieldW  hbmpUnchecked
    fieldD  dwItemData
    field?  dwTypeData, LPSZ16
    fieldW  cch
    fieldW  hbmpItem
endStruct

beginStruct MENUITEMINFO,mii_,32
    fieldD  cbSize
    fieldD  fMask
    fieldD  fType
    fieldD  fState
    fieldD  wID
    field?  hSubMenu,   HMENU32
    fieldD  hbmpChecked
    fieldD  hbmpUnchecked
    fieldD  dwItemData
    field?  dwTypeData, LPSZ32
    fieldD  cch
    fieldD  hbmpItem
endStruct


beginStruct MENUINFO,mi_,16
    fieldD  cbSize
    fieldD  fMask
    fieldD  cyMax
    fieldD  hbrBack
    fieldD  dwContextHelpID
    fieldD  dwMenuData
endStruct

beginStruct MENUINFO,mi_,32
    fieldD  cbSize
    fieldD  fMask
    fieldD  cyMax
    fieldD  hbrBack
    fieldD  dwContextHelpID
    fieldD  dwMenuData
endStruct


beginStruct SCROLLINFO,scri_,16
    fieldD  cbSize
    fieldD  fMask
    fieldD  nMin
    fieldD  nMax
    fieldD  nPage
    fieldD  nPos
endStruct

beginStruct SCROLLINFO,scri_,32
    fieldD  cbSize
    fieldD  fMask
    fieldD  nMin
    fieldD  nMax
    fieldD  nPage
    fieldD  nPos
endStruct


beginStruct TRACKMOUSEEVENT,mi_,16
    fieldD  cbSize
    fieldD  dwFlags
    field?  hwndTrack ,HWND16
    fieldD  dwHoverTime
endStruct

beginStruct TRACKMOUSEEVENT,mi_,32
    fieldD  cbSize
    fieldD  dwFlags
    field?  hwndTrack ,HWND32
    fieldD  dwHoverTime
endStruct


beginStruct WNDCLASS,wc_,16
    fieldW  style
    fieldD  lpfnWndProc
    fieldW  cbClassExtra
    fieldW  cbWndExtra
    fieldW  hInstance
    fieldW  hIcon
    fieldW  hCursor
    fieldW  hbrBackground
    field?  lpszMenuName,LPSZ16
    field?  lpszClassName,LPSZ16
endStruct

beginStruct WNDCLASS,wc_,32
    fieldD  style
    fieldD  lpfnWndProc
    fieldD  cbClassExtra
    fieldD  cbWndExtra
    fieldW  hInstance
    fieldW  hIcon
    fieldW  hCursor
    fieldW  hbrBackground
    field?  lpszMenuName,LPSZ32
    field?  lpszClassName,LPSZ32
endStruct


beginStruct WNDCLASSEX,wce_,16
    fieldD  cbSize
    fieldD  style
    fieldD  lpfnWndProc
    fieldW  cbClassExtra
    fieldW  cbWndExtra
    fieldW  hInstance
    fieldW  hIcon
    fieldW  hCursor
    fieldW  hbrBackground
    field?  lpszMenuName,LPSZ16
    field?  lpszClassName,LPSZ16
    fieldW  hIconSm
endStruct

beginStruct WNDCLASSEX,wce_,32
    fieldD  cbSize
    fieldD  style
    fieldD  lpfnWndProc
    fieldD  cbClassExtra
    fieldD  cbWndExtra
    fieldD  hInstance
    fieldD  hIcon
    fieldD  hCursor
    fieldD  hbrBackground
    field?  lpszMenuName,LPSZ32
    field?  lpszClassName,LPSZ32
    fieldD  hIconSm
endStruct

beginStruct WINDOWPLACEMENT,wpl,16
    fieldW  length
    fieldW  flags
    fieldW  showCmd
    field?  ptMinPos, POINT16
    field?  ptMaxPos, POINT16
    field?  rcNormal, RECT16
endStruct

beginStruct WINDOWPLACMENET,wpl,32
    fieldD  length
    fieldD  flags
    fieldD  showCmd
    field?  ptMinPos, POINT32
    field?  ptMaxPos, POINT32
    field?  rcNormal, RECT32
endStruct


beginStruct DRAWTEXTPARAMS,dtp_,16
    fieldD  cbSize
    fieldW  iTabLength
    fieldW  iLeftMargin
    fieldW  iRightMargin
    fieldW  uiLengthDrawn
endStruct

beginStruct DRAWTEXTPARAMS,dtp_,32
    fieldD  cbSize
    fieldD  iTabLength
    fieldD  iLeftMargin
    fieldD  iRightMargin
    fieldD  uiLengthDrawn
endStruct


beginStruct TPMPARAMS,tpm_,16
    fieldD  cbSize
    field?  rcExclude,RECT16
endStruct

beginStruct TPMPARAMS,tpm_,32
    fieldD  cbSize
    field?  rcExclude,RECT32
endStruct


beginStruct MSGBOXPARAMS,mbx_,16
    fieldD  cbSize
    fieldW  hwndOwner
    fieldW  hInstance
    field?  lpszText,LPSZ16
    field?  lpszCaption,LPSZ16
    fieldD  dwStyle
    field?  lpszIcon,LPSZ16
    fieldD  dwContextHelpId
    fieldD  lpfnMsgBoxCallback
    fieldD  dwLanguageId
endStruct

beginStruct MSGBOXPARAMS,mbx_,32
    fieldD  cbSize
    fieldD  hwndOwner
    fieldD  hInstance
    field?  lpszText,LPSZ32
    field?  lpszCaption,LPSZ32
    fieldD  dwStyle
    field?  lpszIcon,LPSZ32
    fieldD  dwContextHelpId
    fieldD  lpfnMsgBoxCallback
    fieldD  dwLanguageId
endStruct


beginStruct NOTIFYSTRUCT,nmh,16
    fieldD  hwndFrom
    fieldD  idFrom
    fieldD  code
endStruct

beginStruct NOTIFYSTRUCT,nmh,32
    fieldD  hwndFrom
    fieldD  idFrom
    fieldD  code
endStruct


beginStruct STYLESTRUCT,sty,16
    fieldD  styleOld
    fieldD  styleNew
endStruct

beginStruct STYLESTRUCT,sty,32
    fieldD  styleOld
    fieldD  styleNew
endStruct


beginStruct MDINEXTMENU,mdin,32
    fieldD  hmenuIn
    fieldD  hmenuNext
    fieldD  hwndNext
endStruct


beginStruct DEBUGHOOK,dh,16
    fieldW  hModuleInstaller
    fieldD  idThreadInstaller
    fieldD  lParam
    fieldW  wParam
    fieldW  code
    fieldD  idThread
    fieldW  whType
endStruct

beginStruct DEBUGHOOK,dh,32
    fieldD  idThread
    fieldD  idThreadInstaller
    fieldD  lParam
    fieldD  wParam
    fieldD  code
    fieldW  hModuleInstaller
    fieldW  hTask
endStruct

beginStruct MNDRAGOVERINFO,mdoi,16
    fieldD  dwFlags
    field?  hmenu16,HMENU16
    fieldW  uItemIndex
    field?  hwnd16Notify,HWND16
endStruct

beginStruct MNDRAGOVERINFO,mdoi,32
    fieldD  dwFlags
    field?  hmenu16,HMENU32
    fieldD  uItemIndex
    field?  hwnd16Notify,HWND32
endStruct

beginstruct MENUGETOBJECTINFO,mgoi,16
    fieldD dwFlags
    fieldW uItemPos
    field? hmenu,HMENU16
    field? riid,LPSZ16
    field? pvObj,LPSZ16
endStruct

beginstruct MENUGETOBJECTINFO,mgoi,32
    fieldD dwFlags
    fieldD uItemPos
    field? hmenu,HMENU32
    field? riid,LPSZ32
    field? pvObj,LPSZ32
endStruct



ifdef FE_IME
;
;   COMPOSITIONFROM structure.
;
beginStruct COMPOSITIONFORM,ime_compform,32
    fieldD  dwStyle
    field?  ptCurrent,POINT32
    field?  rcCompArea,RECT32
endStruct

beginStruct COMPOSITIONFORM,ime_compform,16
    fieldD  dwStyle
    field?  ptCurrent,POINT16
    field?  rcCompArea,RECT16
endStruct


;
;   CANDIDATEFROM structure.
;
beginStruct CANDIDATEFORM,ime_candform,32
    fieldD  dwIndex
    fieldD  dwStyle
    field?  ptCurrent,POINT32
    field?  rcCompArea,RECT32
endStruct

beginStruct CANDIDATEFORM,ime_candform,16
    fieldD  dwIndex
    fieldD  dwStyle
    field?  ptCurrent,POINT16
    field?  rcCompArea,RECT16
endStruct
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\tapifthk.inc ===
; empty file !
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\usrf2thk.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\usrfthk.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\usrmpr.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\thkframe.inc ===
;-----------------------------------------------------------------------;
; Picture of stack upon entering 32-bit half of WNDPROC callback:
;
;       +-----------------------+
;       | callback parameters   |
;       +-----------------------+
;       | retf to Win3.0        |
;       |                       |
;       +-----------------------+
;       | 32-bit pfn            |
;       |                       |
;       +-----------------------+
;       | iCallbackType         |
;       |                       |
;       +-----------------------+
;       | bp                    | <-- bp/ebp, references up
;       +-----------------------+
;       | si                    |
;       +-----------------------+
;       | di                    |
;       +-----------------------+
;       | ds                    | <-- si/esi, references down if necessary
;       +-----------------------+
;       | THKSPACE16            |       if necessary
;       +-----------------------+
;       | MSGSTRUCT             |       if necessary
;       +-----------------------+
;       | repacked structure(s) |       if necessary
;       +-----------------------+
;       | retf to thunk cleanup |       if necessary
;       |                       |
;       +-----------------------+
;       | ss, sp                | <-- ebx, references saved ss:sp
;       |                       |
;       +-----------------------+
;       | dword alignment pad   |       if necessary
;       +-----------------------+
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; Picture of stack upon entering 32-bit half of non-WNDPROC callback:
;
;       +-----------------------+
;       | callback parameters   |
;       +-----------------------+
;       | retf to Win3.0        |
;       |                       |
;       +-----------------------+
;       | 32-bit pfn            |
;       |                       |
;       +-----------------------+
;       | iCallbackType         |
;       |                       |
;       +-----------------------+
;       | bp                    | <-- bp/ebp, references up
;       +-----------------------+
;       | si                    |
;       +-----------------------+
;       | di                    |
;       +-----------------------+
;       | ds                    |
;       +-----------------------+
;       | ss, sp                | <-- ebx, references saved ss:sp
;       |                       |
;       +-----------------------+
;       | dword alignment pad   |       if necessary
;       +-----------------------+
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; ParameterFrame
;
; base
;       The register on which to base addresses.
;
; Define the parameter frame for 16->32 callbacks. This should match
; the picture above.
;-----------------------------------------------------------------------;
ParameterFrame macro base
    base&_pParams           equ     <          [base+14]>
    ;retf                           <dword ptr [base+10]>
    base&_pCallback32       equ     <dword ptr [base+ 6]>
    base&_iCallbackType     equ     <dword ptr [base+ 2]>
    ;bp                             < word ptr [base+ 0]>
    ;si                             < word ptr [base- 2]>
    ;di                             < word ptr [base- 4]>
    ;ds                             < word ptr [base- 6]>
    ;ss,sp                          <dword ptr [base-10]>
    base&_addr_registers    equ     <          [base-10]>
endm

;-----------------------------------------------------------------------;
; LocalFrame
;
; base
;       The register on which to base addresses.
;
; segovr
;       The segment override necessary, if any.
;
; Define the local variable frame. The variables will be accessed via
; the THKSPACE16 structure offsets.  The base&_cleanup label is used
; for discarding the local variables and any extra space used by the
; thunk.
;-----------------------------------------------------------------------;
LocalFrame macro base, segovr
    base&_cleanup equ <dword ptr segovr&[base]>
    base&_space   equ <          segovr&[base - (size THKSPACE16)]>
endm

ParameterFrame  ebp
LocalFrame      esi

ParameterFrame  bp
LocalFrame      bp
LocalFrame      si, ss:
LocalFrame      bx, ss:

;-----------------------------------------------------------------------;
;Equates related to stack frame setup by thunk-compiler generated
;dispatcher.
;-----------------------------------------------------------------------;

ifdef FSAVEALL
offsetThkParams equ 72          ;must match value generated by thunk.exe
else
offsetThkParams equ 40          ;must match value generated by thunk.exe
endif

bp_top  equ     <[bp+offsetThkParams]>
bx_top  equ     <ss:[bx+offsetThkParams]>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\thkmacro.inc ===
;-----------------------------------------------------------------------;
; cat
;
; Concatenate the arguments.
;-----------------------------------------------------------------------;
cat macro   a,b,c,d,e,f,g,h,i,j,k,l,m
    a&b&c&d&e&f&g&h&i&j&k&l&m
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\thk.inc ===
f16ptr  typedef ptr far16
f32ptr  typedef ptr far32


;==============================================================================
; BODY_PARAM_16
; Macro to generate equate for parameter on stack
;
;==============================================================================

BODY_PARAM_16 macro name, offset
name    equ <[bp+offsetThkParams+offset]>
        endm

;==============================================================================
; CB_THRU_COMMON
; Push address to be called and jump to common entry to 32bit code
;
;==============================================================================

CB_THRU_COMMON macro addr
        local   ret_addr
        local   log_msg_before
        local   log_msg_after

        externDef W32S_BackTo32:near32

ifdef DEBUG
LogCBThkSL  proto  near stdcall, psz:DWORD

        push    offset log_msg_before
        call    LogCBThkSL
endif

        push    ret_addr
        push    addr

; BUGBUG [KevinR] 12-Oct-1993
; This hardcoded offset is a hack for M5.  We should use a proper kernel
; dispatcher.
        assume  fs:nothing
Win16LockCount  equ  <word ptr fs:[30]> ; BUGBUG  from k32share.inc
        mov     di,-1
        xchg    di,Win16LockCount

        ; PERFORMANCE! is is possible to jump directly thru import thunk
        ; W32S_BackTo32 just does a retn
        jmp     W32S_BackTo32

ifdef DEBUG
log_msg_before  db  "SL before",0
log_msg_after   db  "SL after",0
endif

ret_addr:
        mov     Win16LockCount,di
        assume  fs:error

ifdef DEBUG
        push    offset log_msg_after
        call    LogCBThkSL
endif

        endm



;==============================================================================
; local macro, maps 32-bit pointer to 16-bit pointer,
;
; Guarantees:
;     If &SaveAddr& referenes di, the value of di entering MAP_POINTER
;     is used.
;==============================================================================
MAP_POINTER  macro   SaveAddr
    lodsd   ds:[esi]

    push    eax
    call    MapLS

ifnb <SaveAddr>
        mov     &SaveAddr&,eax
endif
    stosd   es:[di]              ; dst in 16:16 stack
endm

;==============================================================================
; local macro, clean up after MAP_POINTER.
;
; Guarantees:
;     If &SaveAddr& references si, the value of si entering UMAP_POINTER
;     is used.
;==============================================================================
UMAP_POINTER    macro   SaveAddr
ifnb <SaveAddr>
        push    es
        pushd   &SaveAddr&
        call    UnmapLS
        pop         es
endif

    add     si,4
    add     edi,4
endm


;==============================================================================
; local macro, gets current process hInstance if null
; Win32/NT allows NULL hInstance where win3.1 doesn't
;
;==============================================================================
MAP_NULL_HINST  macro   hInst
        local   not_null
;        externDef GetNullhInst:far16
        externDef MaphInstLS:far16
        ifnb    <hInst>
        mov     eax, hInst
        endif
;        call    GetNullhInst
        call    MaphInstLS
not_null:
endm

;==============================================================================
; local macro, gets current process hInstance if null
; Win32/NT allows NULL hInstance where win3.1 doesn't
;
;==============================================================================
UMAP_NULL_HINST  macro   hInst
        local   not_null
        externDef MaphInstSL:far16
        ifnb    <hInst>
        mov     ax, hInst
        endif
        call    MaphInstSL
not_null:
endm



;==============================================================================
; Convert either an instance handle, a global Win16 handle or junk.
; Used by commdlg.
;==============================================================================
MAP_CD_NULL_HINST  macro   hInst,isInst
        local   not_inst,exit
        cmp     isInst,0
        jz      not_inst
        MAP_NULL_HINST  hinst
        jmp     exit
        
not_inst:  ;"hInst" is really 32-bit junk, or a zero-extended global handle.
        ;; No need to do anything: "ax" already contains lo-word.
exit:
endm


;==============================================================================
; Convert either an instance handle, a global Win16 handle or junk.
; Used by commdlg.
;==============================================================================
UMAP_CD_NULL_HINST  macro   hInst,isInst
        local   not_inst,exit
        cmp     isInst,0
        jz      not_inst
        UMAP_NULL_HINST hinst
        jmp     exit
        
not_inst:  ;"hInst" is really junk, or a global handle.
        ror     eax,16
        xor     ax,ax
        ror     eax,16
exit:
endm



;==============================================================================
; local macro, maps 32-bit call-back function pointer to 16-bit
; call back function pointer,
; check if it is a NULL pointer before calling AllocCallBack.
;==============================================================================
MAP_CALLBACK  macro   CallBackType:req
    lods    dword ptr ds:[esi]              ;wndproc must have a 16-bit
    push    bx                              ;save BX
    push    es                              ;save ES

    push    eax                             ;push address as parameter
    push    dword ptr CallBackType          ;push cb type as parameter
    call    AllocCallback                   ;DX:AX = 16-bit cb address
    pop     es                              ;restore ES
    pop     bx                              ;restore BX

    stos    dword ptr es:[di]               ;pass on NULL pointer
endm

;==============================================================================
; local macro, free resources allocated for a call-back function
; check if it is a NULL pointer before calling FreeCallBack.
; eax contains the 32-bit address of the mapped call-back function
;==============================================================================
FREE_CALLBACK  macro    iCallbackType:req
endm

;==============================================================================
; local macro, maps byte size field to byte size field
;==============================================================================
MAP_BYTETOBYTE  macro
    lodsb   ds:[esi]
    stosb   es:[di]
endm

;==============================================================================
; local macro, maps byte size field to byte size field
;==============================================================================
UMAP_BYTETOBYTE  macro
    lodsb   ds:[si]
    stosb   es:[edi]
endm

;==============================================================================
; local macro, maps word size field to word size field
;==============================================================================
MAP_WORDTOWORD  macro
    lodsw   ds:[esi]
    stosw   es:[di]
endm

;==============================================================================
; local macro, maps word size field to word size field
;==============================================================================
UMAP_WORDTOWORD  macro
    lodsw   ds:[si]
    stosw   es:[edi]
endm

;==============================================================================
; local macro, maps dword size field to word size field
;==============================================================================
MAP_DWORDTOWORD  macro
    lodsd   ds:[esi]
    stosw   es:[di]
endm

;==============================================================================
; local macro, maps dword size field to word size field
;==============================================================================
UMAP_WORDTODWORD  macro
    lodsw   ds:[si]
    movzx   eax,ax
    stosd   es:[edi]
endm

;==============================================================================
; local macro, maps long size field to int size field
;==============================================================================
MAP_LONGTOINT  macro
    lodsd   ds:[esi]
    stosw   es:[di]
endm

;==============================================================================
; local macro, maps int size field to long size field
;==============================================================================
UMAP_INTTOLONG  macro
    lodsw   ds:[si]
    cwde
    stosd   es:[edi]
endm

;==============================================================================
; local macro, maps dword size field to dword size field
;==============================================================================
MAP_DWORDTODWORD  macro
    movsd   es:[di], ds:[esi]
endm

;==============================================================================
; local macro, maps dword size field to dword size field
;==============================================================================
UMAP_DWORDTODWORD  macro
    movsd   es:[edi], ds:[si]
endm

;==============================================================================
; The following are variants of the above macros that are better suited for
; repacking structures in-place.
;==============================================================================

;==============================================================================
; local macro, maps 32-bit call-back function pointer to 16-bit
; call back function pointer,
; check if it is a NULL pointer before calling AllocCallBack.
;==============================================================================
MAP_CALLBACK_32_16_IP  macro   reg:=<ds>,CallBackType:req
    lods    dword ptr reg:[si]              ;wndproc must have a 16-bit

    push    bx
    push    es
    push    eax
    push    dword ptr CallBackType
    call    AllocCallback
    pop     es
    pop     bx

    stosd
endm

;==============================================================================
; local macro, maps 16-bit call-back function pointer to 32-bit
; call back function pointer,
; check if it is a NULL pointer before calling AllocCallback.
;
; ASSUMES DIRECTION FLAG DOWN, i.e. STD.
;==============================================================================
MAP_CALLBACK_16_32_IP  macro   reg:=<ds>,CallBackType:req
    lods    dword ptr reg:[si]              ;wndproc must have a 16-bit

    push    bx
    push    es
    push    eax
    push    dword ptr CallBackType
    call    AllocCallback32
    pop     es
    pop     bx

    stosd
endm

;==============================================================================
; local macro, maps 32-bit pointer to 16-bit pointer,
;==============================================================================
MAP_POINTER_32_16_IP  macro   reg:=<ds>
    lodsd   reg:[si]
    push    eax
    call    MapLS
    stosd   es:[di]
endm


;==============================================================================
; MAP_HINST_32_16_IP
; Map an instance handle from 32->16 in-place.  If the original value is 0,
; replace it with the instance handle from win32s16.dll.
;
; Assumes ds = _DATA.
;==============================================================================
MAP_HINST_32_16_IP macro reg:=<ds>
        local   have_hinst

        lods    dword ptr reg:[si]              ; convert hinst to word
        or      ax,ax                           ; translate to hComboInst if
        jnz     have_hinst                      ;     null
        mov     ax,hComboInst
have_hinst:
        stosw
endm

;==============================================================================
; MAP_HINST_16_32_IP
; Map an instance handle from 16->32 in-place.  If the original value is
; hComboInst, replace it with 0.
;
; Assumes ds = _DATA.
;==============================================================================
MAP_HINST_16_32_IP macro reg:=<ds>
        local   have_hinst

        lods    word ptr reg:[si]               ; convert hinst to word
        cmp     ax,hComboInst                   ; translate to null if
        jnz     have_hinst                      ;     hComboInst
        sub     ax,ax
have_hinst:
        movzx   eax,ax
        stosd
endm

;==============================================================================
; local macro, maps word size field to word size field
;==============================================================================
MAP_WORDTOWORD_IP  macro        reg:=<ds>
    movsw   es:[di], reg:[si]
endm

;==============================================================================
; local macro, maps dword size field to word size field
;==============================================================================
MAP_DWORDTOWORD_IP  macro reg:=<ds>
    lodsd   reg:[si]
    stosw   es:[di]
endm

;==============================================================================
; local macro, maps dword size field to word size field
;==============================================================================
MAP_LONGTOINT_IP  macro reg:=<ds>
    lodsd   reg:[si]
    stosw   es:[di]
endm

;==============================================================================
; local macro, maps dword size field to dword size field
;==============================================================================
MAP_DWORDTODWORD_IP  macro      reg:=<ds>
    movsd   es:[di], reg:[si]
endm

;==============================================================================
; local macro, maps word size field to dword size field by zero-extension
;==============================================================================
MAP_WORDTODWORD_IP  macro reg:=<ds>
    lodsw   reg:[si]
    movzx   eax,ax
    stosd   es:[di]
endm

;==============================================================================
; local macro, maps word size field to dword size field by sign-extension
;==============================================================================
MAP_INTTOLONG_IP  macro reg:=<ds>
    lodsw   reg:[si]
    cwde
    stosd   es:[di]
endm

;==============================================================================
; save all 16-bit registers, except dx:ax
;
;==============================================================================
SAVEALL     macro
    push    cx      ; save all 16-bit registers, except dx:ax
    push    bx
    push    bp
    push    si
    push    di
    push    ds
    push    es
endm


;==============================================================================
; restore all 16-bit registers, except dx:ax
;
;==============================================================================
RESTOREALL  macro  StackType:=<Stack16>
    POPW    es      ; restore all 16-bit registers, except dx:ax

    CHECKW  ds, StackType
    POPW    ds
    CHECKW  di, StackType
    pop     di

    CHECKW  si, StackType
    pop     si
    CHECKW  bp, StackType
    pop     bp

    pop     bx
    pop     cx
endm


;==============================================================================
; save all 32-bit registers, except eax
;
;==============================================================================
SAVEALL32     macro
    push    edx         ;save all 32-bit registers except eax
    push    ecx
    push    ebx
    push    ebp
    push    esi
    push    edi
    push    ds
    push    es
endm


;==============================================================================
; restore all 32-bit registers, except eax
;
;==============================================================================
RESTOREALL32  macro  StackType:=<Stack16>
    POPD    es      ; restore all 32-bit registers, except eax

    CHECKD  ds, StackType
    POPD    ds
    CHECKD  edi, StackType
    pop     edi
    CHECKD  esi, StackType
    pop     esi
    CHECKD  ebp, StackType
    pop     ebp
    CHECKD  ebx, StackType
    pop     ebx

    pop     ecx
    pop     edx
endm


;==============================================================================
; test two text macros for equality
;
;
;==============================================================================
TextEqual? macro   Text_1, Text_2
    ifidni <Text_1>, <Text_2>
        exitm <not 0>
    endif
    exitm <0>
endm


;==============================================================================
; test two text macros for difference
;
;
;==============================================================================
TextDiff? macro   Text_1, Text_2
    ifidni <Text_1>, <Text_2>
        exitm <0>
    endif
    exitm <not 0>
endm


;==============================================================================
; check a word on top of the stack
; if not equal, break
;
;==============================================================================
CHECKW    macro   CurrentReg, StackType:=<Stack16>
    local   skip_int3
    local   skip_another_int3

    if (@WordSize eq 4) and TextDiff? (&StackType&,Stack16)
    push    eax
    mov     ax,&CurrentReg&
    cmp     ax,word ptr [esp+4]
    pop     eax
    je      skip_int3
    int     3
skip_int3:
    else


    push    bp
    push    ax
    mov     ax,&CurrentReg&
    mov     bp,sp
    and     ebp,0ffffh
    cmp     ax,word ptr [ebp+4]
    pop     ax
    pop     bp
    je      skip_another_int3
    int     3
skip_another_int3:
    endif

endm


;==============================================================================
; check a dword on top of the stack
; if not equal, break
;
;==============================================================================
CHECKD    macro   CurrentReg, StackType:=<Stack32>
    local   skip_int3
    local   skip_another_int3

if 0
;!!! fix this
    if (@WordSize eq 4) and TextDiff? (&StackType&,Stack32)
    push    eax
    mov     ax,&CurrentReg&
    cmp     ax,word ptr [esp+4]
    pop     eax
    je      skip_int3
    int     3
skip_int3:
    else


    push    bp
    push    ax
    mov     ax,&CurrentReg&
    mov     bp,sp
    and     ebp,0ffffh
    cmp     ax,word ptr [ebp+4]
    pop     ax
    pop     bp
    je      skip_another_int3
    int     3
skip_another_int3:
    endif
endif
endm


;==============================================================================
; pop word
;
;==============================================================================
POPW    macro   SegReg
    if @WordSize eq 4
        db      66h
    endif
    pop     SegReg
endm


;==============================================================================
; pop dword
;
;==============================================================================
POPD    macro   SegReg
    if @WordSize eq 2
        db      66h
    endif
    pop     SegReg
endm


;==============================================================================
; operand-size override
;
;==============================================================================
OTHER_OPERAND_SIZE  macro   arg
    db  66h
    arg
endm


;==============================================================================
; address-size override
;
;==============================================================================
OTHER_ADDRESS_SIZE  macro   arg
    db  67h
    arg
endm


;==============================================================================
; pop 16
;
;==============================================================================
POP16    macro   Reg
    if @WordSize eq 4
        irp curreg,<cs,ds,ss,es,fs,gs>
           ifidni <curreg>,<Reg>
                db      66h
           endif
        endm
    endif
    pop     Reg
endm


;==============================================================================
; allocate and public a byte flag
;
;==============================================================================
PubByte  macro   name, value
    public  name
    name    db      value
endm





;==============================================================================
; log a 16=>32 api call
;
;==============================================================================
APILOGSL  macro   argName
        local   exit,szLogMsg

ifdef DEBUG

LogApiThkSL     proto   near stdcall, psz:dword

        push    offset szLogMsg
        call    LogApiThkSL
        jmp     exit

szLogMsg  db    '&argName&',13,10,0

exit:
endif
endm



;==============================================================================
; log a 32=>16 api call, non-flat
;
;==============================================================================
APILOGLS  macro   argName
        local   exit,szLogMsg

ifdef DEBUG
externDef LogApiThkLS:far16

        push    ax

        push    cs
        push    offset szLogMsg
        call    LogApiThkLS

        pop     ax
        jmp     exit

szLogMsg  db    '&argName&',13,10,0

exit:
endif
endm



;==============================================================================
; log an api call, 16-bit
;
; BUGBUG [KevinR] 26-Aug-1993
; rip out this macro when we get rid of fNewDispatcherLS
;
;==============================================================================
APILOG16  macro   argName, argUnused, argComment
        local   exit,szApiName,szComment

ifdef DEBUG
externDef Log16BitThunkCall:far16

dsOffsetInCS CATSTR @code, <CodeData>

        push    ds
        push    ax
        mov     ds,cs:dsOffsetInCS

        push    cs
        push    offset szApiName
        push    cs
        push    offset szComment
        call    Log16BitThunkCall
        pop     ax
        pop     ds
        jmp     exit

szApiName db    '&argName& ',0
szComment db    '&argComment& ',0

exit:
endif
endm



;==============================================================================
; log an api call, 32-bit
;
;==============================================================================
APILOG  macro   argName, argFlag
        local   do_it,done,szApiName
ifdef DEBUG
;externDef _DbgPrint:near32

        ;;If argFlag is nonzero, print out the message.
        cmp     argFlag&,0
        jnz     do_it
        jmp     short done
;;Define the name here so we can pass it to _DbgPrint.
szApiName db '&argName&',0
do_it:
        push    offset FLAT:szApiName
        push    offset FLAT:szApiFmt
        ;call    _DbgPrint
        add     esp,2*4
done:
endif
endm


;==============================================================================
; log 16-bit api return, in 32-bit code
;
;==============================================================================
RETLOG  macro   argFlag
endm



;==============================================================================
; conditionally break
;
;==============================================================================
SWITCHABLE_INT3 macro argLabel, argFlag
        local   skip_int3

externDef   argLabel :far16

        push    ds
        push    ax
        mov     ax,seg &argFlag
        mov     ds,ax
        cmp     &argFlag,0
        je      skip_int3
argLabel& label far16
        int     3
skip_int3:
        pop     ax
        pop     ds
endm


;==============================================================================
;
;
;==============================================================================
STUB0   macro   module, argLabel, nBytes, argComment:=<stub0>
externDef   argLabel&16 :far16
argLabel&16 label far16

ifdef FSAVEALL
        SAVEALL
endif
        APILOG16 argLabel&16, f&module&ApiLog, argComment
ifdef INT3
        SWITCHABLE_INT3 argLabel&_stub, f&module&Int3
endif
        xor     ax,ax
        cwd
ifdef FSAVEALL
        RESTOREALL
endif
        retf    &nBytes&
endm


;==============================================================================
;
;
;==============================================================================
STUB    macro   module, argLabel, nBytes, nRetAX, argComment:=<stub>
externDef   argLabel&16 :far16
externDef   PCodeDebug16 :far16
argLabel&16 label far16

ifdef FSAVEALL
        SAVEALL
endif
        APILOG16 argLabel&16, f&module&ApiLog, argComment nRetAX
ifdef INT3
        SWITCHABLE_INT3 argLabel&_stub, f&module&Int3
endif
        mov     ax,&nRetAX
ifdef FSAVEALL
        RESTOREALL
endif
        retf    nBytes
endm

;==============================================================================
; entry code for flat common callback
;
;==============================================================================
CALLBACK_PROLOGUE   macro

        pop     eax                     ; 16:16 callback
        pop     edx                     ; eip, API32

        push    cs                      ; flat cs
        push    edx                     ; eip, API32
        push    eax                     ; 16:16 callback

        push    ebp
        mov     ebp,esp

        push    ds                      ; save registers
        push    es
        push    ebx
        push    edi
        push    esi
endm


;==============================================================================
; exit code for flat common callback
;
;==============================================================================
CALLBACK_EPILOGUE   macro   size

        LOCAL   bad_esp

;--------------------------------------------------
; switch stacks and jump to 16:16 callback

; when the 16:16 callback does a retf, we will hit our cleanup routine

        push    dword ptr ADDR_THK_CLEANUP_&size

; prepare to transfer to the 16-bit callback function

        push    pCallback16

; get the ss16 we had when we entered the callback API16
; make the 16-bit ss:sp point to the same linear address as the flat ss:esp

        call    UsrQuerySS16
        mov     esi,eax                 ; save ss16
        push    eax
        call    GetSelectorBase32       ; LATER: LDT lookup
        xchg    eax,esp
        sub     eax,esp
        jb      bad_esp
        cmp     eax,65535
        ja      bad_esp

        mov     ss,si
        mov     sp,ax

; effectively, jmp to 16:16 callback
        retw

bad_esp:
        int     3

endm




;==============================================================================
; save flat stack and thunkID
;
;==============================================================================
SAVE_STACK_AND_THUNKID  macro

        lea     eax,[addr_registers]    ; save flat stack
        push    ss
        push    eax

        call    GetThunkID32
        push    eax                     ; save 16:16 thunkID
endm

;==============================================================================
; 32-bit callback cleanup code
;
;==============================================================================
CALLBACK_CLEANUP32    macro   size
externDef CALLBACK_CLEANUP_&size&:near32
CALLBACK_CLEANUP_&size&:
;;;-----------------------------------------------------------------------
;;; DO NOT REMOVE THE OVERRIDE PREFIX. IT IS NEEDED TO GET PAST A BUG
;;; IN A CERTAIN BRAND OF CLONE CHIPS.
;;;-----------------------------------------------------------------------
        lss     sp,ss:[ebx]
        POP16   ds
        POP16   di
        POP16   si
        POP16   bp

        add     sp, 8                   ; pop dispatcher ptr+index


        OTHER_OPERAND_SIZE
        retf    size                    ; return to the 16-bit API
endm


;==============================================================================
; SetLastError mechanism
;
;==============================================================================
SETERROR     macro   Value:req, Error:req
        local   done

externDef SetLastError16:far16
        cmp     ax,Value
        jne     short done

        push    dword ptr Error
        call    SetLastError16
done:
endm

;-----------------------------------------------------------------------;
; MoveBytes -- generate code to move n consecutive bytes
;
; Entry:
;       DS:ESI --> source
;       ES:EDI --> destination
;-----------------------------------------------------------------------;
MoveBytes       macro   n
    local q, r

    q = n / 4
    r = n and 3

    if q
        if q lt 256
            mov     ecx,byte ptr q
        else
            mov     ecx,q
        endif
        rep     movs dword ptr es:[edi], dword ptr ds:[esi]
    endif

    if r
        mov     ecx,byte ptr r
        rep     movs byte ptr es:[edi], byte ptr ds:[esi]
    endif
endm

;-----------------------------------------------------------------------;
; ZeroBytes -- generate optimized code to set n consecutive bytes to 0
;
; Entry:
;       ES:EDI --> address at which to start
;-----------------------------------------------------------------------;
ZeroBytes       macro   n
    local q, r

    q = n / 4
    r = n and 3

        sub     eax,eax
    if q
        if q lt 256
            mov     ecx,byte ptr q
        else
            mov     ecx,q
        endif
        rep     stos dword ptr es:[edi]
    endif

    if r
        mov     ecx,byte ptr r
        rep     stos byte ptr es:[edi]
    endif
endm

;-----------------------------------------------------------------------;
; GMH2Sel
;
; This macro encapsulates the assumption that a global memory handle
; in win3.1 is either a selector (if fixed) or a selector with the
; low bit cleared (if moveable).  Therefore, it can be turned into a
; selector by always setting the low bit.
;-----------------------------------------------------------------------;
GMH2Sel         macro   reg:req, regMask1, regMask2
    ifb <regMask1>
        or      reg,1
    else
        .errb <regMask2>

        ;The following sequence uses two mask registers to
        ;convert only non-zero values of "reg" to selectors.
        mov     regMask1,1              ;mov cx,1
        cmp     reg,regMask1            ;cmp ax,cx      C=1 if AX=0
        cmc                             ;cmc            C=0 if AX=0
        sbb     regMask2,regMask2       ;sbb dx,dx      DX=0 if AX=0
        and     regMask1,regMask2       ;and cx,dx      CX=0 if AX=0
        or      reg,regMask1            ;or  ax,cx      AX=0 if AX=0
    endif
endm



;-----------------------------------------------------------------------;
; PACK_CALLBACK 
;-----------------------------------------------------------------------;

PACK_CALLBACK   macro   iOffset,iTempOffset,dwCallbackType

        local   exit
        local   not_null

        mov     esi,[bp+&iOffset&]
        or      esi,esi
        jnz     not_null

        sub     sp,18           ;Space the thunklet would have taken
        jmp     exit

not_null:
; Push the following code on the stack:
;
;  66 68 xx xx xx xx    push  imm32 <flat lpCallback>
;  66 68 xx xx xx xx    push  imm32 <dwCallbackType>
;  90                   nop             ;for convenient
;  EA xx xx xx xx       jmp   CALLBACK_BODY_16

        mov     ax,seg CALLBACK_BODY_16
        push    ax
        mov     ax,offset CALLBACK_BODY_16
        push    ax
        push    0ea90h

        push    dword ptr &dwCallbackType&
        push    6866h

        push    esi
        push    6866h

        push    ss
        call    GetCSAlias
        mov     [bp-&iTempOffset&],sp
        mov     [bp-(&iTempOffset&)+2],ax

exit:

        
endm; PACK_CALLBACK


;-----------------------------------------------------------------------;
; UNPACK_CALLBACK 
;-----------------------------------------------------------------------;

UNPACK_CALLBACK macro   iOffset,iTempOffset,dwCallbackType


        push    word ptr [bp-&iTempOffset&+2]
        call    FreeCSAlias


endm; UNPACK_CALLBACK




;-----------------------------------------------------------------------;
; TILE_BUFFER
;
;   Allocates overlapping tiling selectors for a huge memory block.
;
;   Inputs:
;       eax:        32-bit linear address (NULL is allowed)
;       ecx:        32-bit buffer size (if 0, eax is treated as NULL)
;
;   Outputs:
;       eax:        upper 16 bits = first selector
;                   lower 16 bits = 0 (thus, eax is the 16:16 pointer)
;       ecx:        upper 16 bits = first selector (same as upper eax)
;                   lower 16 bits = # of selectors allocated
;       CF:         0 = success, 1 = failure.
;
;   Registers preserved:
;       bp, sp, all segment registers.
;
;   Special cases:
;       if buffer address is NULL or the size is 0, macro returns 
;          eax == ecx == 0, CF = 0.
;       if macro fails, it returns eax == 0, CF = 1.
;
;   Use UNTILE_BUFFER to deallocate tiling selectors.
;-----------------------------------------------------------------------;

TILE_BUFFER     macro
        extern  TileBuffer:far16        ;Dynalink to win32c.dll
        call    TileBuffer
endm    ;TILEBUFFER



;-----------------------------------------------------------------------;
; UNTILE_BUFFER
;
;   Releases tiling selectors allocated by TILE_BUFFER.
;
;   Inputs:
;       ecx == sel:count (as returned by TILE_BUFFER. 00:00 is legal).
;
;   Outputs:
;       None.
;
;   Registers preserved:
;       bp, sp, all segment registers
;
;   Special case:
;       UNTILE_BUFFER does nothing if sel:count == 00:00.
;-----------------------------------------------------------------------;
UNTILE_BUFFER   macro
        extern  UntileBuffer:far16      ;Dynalink to win32c.dll
        call    UntileBuffer
endm    ;UNTILE_BUFFER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\verthksl.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\tapithk.inc ===
CodeData equ <THUNK16BCodeData>

include thkrp.inc
include cbcheck.inc
include thkframe.inc
include public.inc
include thkmacro.inc
;include struc.inc

include cbcid.inc
include tapicbid.inc

;externDef IsBadCodePtr:far16
externDef CALLBACK_BODY_16:far16
externDef Escape:far16
externDef AllocCallback:far16
externDef MapLS:far16
externDef UnmapLS:far16
ifdef DEBUG
externDef _wsprintf:far16
externDef OutputDebugString:far16
endif

externDef FreeCallback:far16


externDef lineInitialize:far16
externDef phoneInitialize:far16
externDef lineShutdown:far16
externDef phoneShutdown:far16


public addrCBLineInit   ;Address of callback routine passed in lineInitialize
public addrCBPhoneInit  ;Address of callback routine passed in phoneInitialize
public cbcidTapi        ;Callback ID for client returned by RegisterCBClient
_DATA     SEGMENT
addrCBLineInit          dd 0
addrCBPhoneInit         dd 0
cbcidTapi               dd 0
_DATA ENDS

ifdef DEBUG
;; Writes message to debug port.
;;
;; Usage:
;;      DPRINT "I'm feeling buggy."
;;
DPRINT  macro   string
        local   mes, skip_mes

        jmp     skip_mes
mes     db      &string&,13,10,0
skip_mes:
        push    eax     ;Save all registers not preserved by PASCAL format.
        push    ebx
        push    ecx
        push    edx
        
        push    cs      ;Arg: OutputDebugString(lpstr)
        push    offset mes
        call    OutputDebugString

        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
endm  ;DPRINT
endif


;-----------------------------------------------------------------------;
; body_LINEINITIALIZE16
;-----------------------------------------------------------------------;
body_LINEINITIALIZE16 macro

;LONG lineInitialize16 (LPHLINEAPP lphLineApp,
;                     HINSTANCE hInstance,
;                     LINECALLBACK lpfnCallback,
;                     LPCSTR lpszAppName,
;                     LPDWORD lpdwNumDevs)
;
bp_lphLineApp           equ     <bp_top>
bp_hInstance            equ     <bp_top+4>
bp_lpfnCallback         equ     <bp_top+8>
bp_lpszAppName          equ     <bp_top+12>
bp_lpdwNumDevs          equ     <bp_top+16>
;

bp_lpszAppNameTmp       equ     <dword ptr [bp-4]>
bp_lpdwNumDevsTmp       equ     <dword ptr [bp-8]>
bp_lphLineAppTmp        equ     <dword ptr [bp-12]>

        ;
        ; First order of business: check the code pointer.  If it's
        ; bogus, we leave.
        ;

;        push    dword ptr bp_lpfnCallback
;        call    IsBadCodePtr
;        or      eax, eax
;        jnz     DoNothing

        sub     eax, eax
        push    eax                             ;bp_lpszAppNameTmp
        push    eax                             ;bp_lpdwNumDevsTmp
        push    eax                             ;bp_lphLineAppTmp

        push    dword ptr bp_lphLineApp
        call    MapLS
        mov     bp_lphLineAppTmp, eax
        push    eax

        mov     eax, dword ptr bp_hInstance     ; Get the hInst
        or      eax, eax                        ; Is it NULL?
        jz      @f                              ; Yup, and that's ok.
        MAP_NULL_HINST eax                      ; Needs to be mapped.
        push    ax

;       mov     ax, seg addrCBLineInit
;       mov     ds, ax
;       mov     eax, dword ptr bp_lpfnCallback
;       mov     addrCBLineInit, eax
;       push    eax
;       mov     eax, cbcidTapi
;       shl     eax, 16
;       add     eax, ID_LINEINITIALIZE
;       push    eax
;        call    AllocCallback
;        push    dx
;        push    ax

        push    dword ptr bp_lpfnCallback

        push    dword ptr bp_lpszAppName
        call    MapLS
        mov     bp_lpszAppNameTmp, eax
        push    eax

        push    dword ptr bp_lpdwNumDevs
        call    MapLS
        mov     bp_lpdwNumDevsTmp, eax
        push    eax


        call    lineInitialize


        shl     eax,16                          ; Convert the 16bit retcode...
        shrd    eax,edx,16                      ; to a 32bit retcode.

        push    eax                             ; Save the retcode for later.

        push    dword ptr bp_lpdwNumDevsTmp
        call    UnMapLS

        push    dword ptr bp_lpszAppNameTmp
        call    UnMapLS

        push    dword ptr bp_lphLineAppTmp
        call    UnMapLS

        pop     eax                             ; Get the retcode

;DoNothing:

endm


;-----------------------------------------------------------------------;
; body_PHONEINITIALIZE
;-----------------------------------------------------------------------;
body_PHONEINITIALIZE16 macro

;LONG phoneInitialize (LPHPHONEAPP lphPhoneApp,
;                      HINSTANCE hInstance,
;                      PHONECALLBACK lpfnCallback,
;                      LPCSTR lpszAppName,
;                      LPDWORD lpdwNumDevs)
;
bp_lphPhoneApp          equ     <bp_top>
bp_hInstance            equ     <bp_top+4>
bp_lpfnCallback         equ     <bp_top+8>
bp_lpszAppName          equ     <bp_top+12>
bp_lpdwNumDevs          equ     <bp_top+16>
;

bp_lpszAppNameTmp       equ     <dword ptr [bp-4]>
bp_lpdwNumDevsTmp       equ     <dword ptr [bp-8]>
bp_lphPhoneAppTmp       equ     <dword ptr [bp-12]>

        sub     eax, eax
        push    eax                             ;bp_lpszAppNameTmp
        push    eax                             ;bp_lpdwNumDevsTmp
        push    eax                             ;bp_lphPhoneAppTmp

        push    dword ptr bp_lphPhoneApp
        call    MapLS
        mov     bp_lphPhoneAppTmp, eax
        push    eax

        mov     eax, dword ptr bp_hInstance     ; Get the hInst
        or      eax, eax                        ; Is it NULL?
        jz      @f                              ; Yup, and that's ok.
        MAP_NULL_HINST eax                      ; Needs to be mapped.
        push    ax

;       mov     ax, seg addrCBPhoneInit
;       mov     ds, ax
;       mov     eax, dword ptr bp_lpfnCallback
;       mov     addrCBPhoneInit, eax
;       push    eax
;       mov     eax, cbcidTapi
;       shl     eax, 16
;       add     eax, ID_PHONEINITIALIZE
;       push    eax
;        call    AllocCallback
;        push    dx
;        push    ax
        push    dword ptr bp_lpfnCallback

        push    dword ptr bp_lpszAppName
        call    MapLS
        mov     bp_lpszAppNameTmp, eax
        push    eax

        push    dword ptr bp_lpdwNumDevs
        call    MapLS
        mov     bp_lpdwNumDevsTmp, eax
        push    eax


        call    phoneInitialize


        shl     eax,16                          ; Convert the 16bit retcode...
        shrd    eax,edx,16                      ; to a 32bit retcode.

        push    eax                             ; Save the retcode for later.

        push    dword ptr bp_lpdwNumDevsTmp
        call    UnMapLS

        push    dword ptr bp_lpszAppNameTmp
        call    UnMapLS

        push    dword ptr bp_lphPhoneAppTmp
        call    UnMapLS

        pop     eax                             ; Get the retcode

endm


;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
;PUSH__LINEINITIALIZE_hInstance macro   iOffset, iJunk
;   local   Null_OK
;       
;    mov        eax, [bp+iOffset]       ;;Allow NULL to be passed here (for now)
;    or eax, eax
;    jz Null_OK
;    MAP_NULL_HINST eax
;Null_OK:
;    push    ax
;
;endm ;PUSH__LINEINITIALIZE_hInstance
;
;
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
;PUSH__PHONEINITIALIZE_hInstance        macro   iOffset, iJunk
;   local   Null_OK
;       
;    mov        eax, [bp+iOffset]       ;;Allow NULL to be passed here (for now)
;    or eax, eax
;    jz Null_OK
;    MAP_NULL_HINST eax
;Null_OK:
;    push    ax
;
;endm ;PUSH__PHONEINITIALIZE_hInstance
;
;
;;-----------------------------------------------------------------------;
;; PUSH__LINEINITIALIZE_lpfnCallback (similar to PUSH_SetAbortProc_pfnAbort)
;;-----------------------------------------------------------------------;
;PUSH__LINEINITIALIZE_lpfnCallback    macro iOffset, iTempOffset
;;      assume  ds:DATA16
;
;       mov     ax, seg addrCBLineInit
;       mov     ds, ax
;
;       mov     eax, dword ptr [bp+iOffset]
;       mov     addrCBLineInit, eax
;       push    eax
;       mov     eax, cbcidTapi
;       shl     eax, 16
;       add     eax, ID_LINEINITIALIZE
;       push    eax
;        call    AllocCallback
;        push    dx
;        push    ax
;endm
;
;
;-----------------------------------------------------------------------;
; PUSH__PHONEINITIALIZE_lpfnCallback
;-----------------------------------------------------------------------;
;PUSH__PHONEINITIALIZE_lpfnCallback    macro iOffset, iTempOffset
;       assume  ds:DATA16
;       mov     ax, seg addrCBPhoneInit
;       mov     ds, ax
;
;       mov     eax, dword ptr [bp+iOffset]
;       mov     addrCBPhoneInit, eax
;       push    eax
;       mov     eax, cbcidTapi
;       shl     eax, 16
;       add     eax, ID_PHONEINITIALIZE
;       push    eax
;        call    AllocCallback
;        push    dx
;        push    ax
;endm


;==============================================================================
; local macro, free resources allocated for a call-back function
; check if it is a NULL pointer before calling FreeCallBack.
; eax contains the 32-bit address of the mapped call-back function
; ecx contains the callback ID ((cbcidTapi << 16) + ID[PHONE/LINE]INITIALIZE)
;==============================================================================
;FREE_CALLBACK_TAPI  macro
;        local   done
;
;        or      eax,eax
;        jz      done                            ;don't process NULL pointers
;
;        push    bx                              ;save BX
;        push    es                              ;save ES
;
;        push    eax                             ;32-bit callback address
;        push    ecx
;        call    FreeCallback
;
;        pop     es                              ;restore ES
;        pop     bx                              ;restore BX
;done:
;endm


;-----------------------------------------------------------------------;
; body_LINESHUTDOWN
; Use FREE_CALLBACK instead of directly calling FreeCallback so that we
; check for NULL pointers.
;-----------------------------------------------------------------------;
body_LINESHUTDOWN16 macro
bp_hLineApp     equ     <bp_top>
;       assume  ds:DATA16
        mov     ax, seg addrCBLineInit
        mov     ds, ax

        mov     eax, dword ptr bp_hLineApp
        push    eax
ifdef DEBUG
        int     3
endif
        call    lineShutdown

; return code long --> long
        rol     eax,16
        xchg    ax,dx
        rol     eax,16

;       push    eax     ;; Save
;       push    ecx     ;; Save
;
;       mov     eax,  addrCBLineInit
;
;       mov     ecx, cbcidTapi
;       shl     ecx, 16
;       add     ecx, ID_LINEINITIALIZE
;
;       FREE_CALLBACK_TAPI
;
;       pop     ecx
;       pop     eax
endm


;-----------------------------------------------------------------------;
; body_PHONESHUTDOWN
;-----------------------------------------------------------------------;
body_PHONESHUTDOWN16 macro
bp_hLineApp     equ     <bp_top>
;       assume  ds:DATA16
        mov     ax, seg addrCBPhoneInit
        mov     ds, ax

        mov     eax, dword ptr bp_hLineApp
        push    eax
        call    phoneShutdown

; return code long --> long
        rol     eax,16
        xchg    ax,dx
        rol     eax,16

;       push    eax     ;; Save it
;       push    ecx     ;; Save it
;
;       mov     eax,  addrCBPhoneInit
;
;       mov     ecx, cbcidTapi
;       shl     ecx, 16
;       add     ecx, ID_PHONEINITIALIZE
;
;       FREE_CALLBACK_TAPI
;
;       pop     ecx
;       pop     eax
endm


;-----------------------------------------------------------------------;
; body_LINEFORWARD
;-----------------------------------------------------------------------;
body_LINEFORWARD macro

bp_hLine                equ     <bp_top>
bp_bAllAddresses        equ     <bp_top+4>
bp_dwAddressID          equ     <bp_top+8>
bp_lpForwardList        equ     <bp_top+12>
bp_dwNumRingsNoAnswer   equ     <bp_top+16>
bp_lphConsultCall       equ     <bp_top+20>
bp_lpCallParams         equ     <bp_top+24>
;
; dword ptr [ebp+8]:  hLine
; dword ptr [ebp+12]:  bAllAddresses
; dword ptr [ebp+16]:  dwAddressID
; dword ptr [ebp+20]:  lpForwardList
; dword ptr [ebp+24]:  dwNumRingsNoAnswer
; dword ptr [ebp+28]:  lphConsultCall
; dword ptr [ebp+32]:  lpCallParams
;

bp_lpForwardListTmp     equ     <dword ptr [bp-4]>
bp_lphConsultCallTmp    equ     <dword ptr [bp-8]>
bp_lpCallParamsTmp      equ     <dword ptr [bp-12]>


        sub     eax, eax
        push    eax                             ;bp_lpForwardListTmp
        push    eax                             ;bp_lphConsultCallTmp
        push    eax                             ;bp_lpCallParams

        push    dword ptr bp_hLine              ;hLine: dword->dword
        push    dword ptr bp_bAllAddresses      ;bAllAddresses: dword->dword
        push    dword ptr bp_dwAddressID        ;dwAddressID: dword->dword
        push    dword ptr bp_lpForwardList
        call    MapLS
        mov     bp_lpForwardListTmp, eax
        push    eax
        push    dword ptr bp_dwNumRingsNoAnswer ;dwNumRingsNoAnswer: dword->dword
        push    dword ptr bp_lphConsultCall
        call    MapLS
        mov     bp_lphConsultCallTmp, eax
        push    eax
        push    dword ptr bp_lpCallParams
        call    MapLS
        mov     bp_lpCallParamsTmp, eax
        push    eax

        call    lineForward

        shl     eax,16
        shrd    eax,edx,16

        push    eax
        push    dword ptr bp_lpForwardListTmp
        call    UnMapLS
;
; Don't UnMap lphConsultCallTmp: Done in tapi.dll due to async read/write.
;
;       push    dword ptr bp_lphConsultCallTmp
;       call    UnMapLS
        push    dword ptr bp_lpCallParamsTmp
        call    UnMapLS
        pop     eax

endm


;-----------------------------------------------------------------------;
; body_LINEMAKECALL
;-----------------------------------------------------------------------;
body_LINEMAKECALL macro

bp_hLine                equ     <bp_top>
bp_lphCall              equ     <bp_top+4>
bp_lpszDestAddress      equ     <bp_top+8>
bp_dwCountryCode        equ     <bp_top+12>
bp_lpCallParams         equ     <bp_top+16>
;
; dword ptr [ebp+8]:  hLine
; dword ptr [ebp+12]:  lphCall
; dword ptr [ebp+16]:  lpszDestAddress
; dword ptr [ebp+20]:  dwCountryCode
; dword ptr [ebp+24]:  lpCallParams
;

bp_lphCallTmp           equ     <dword ptr [bp-4]>
bp_lpszDestAddressTmp   equ     <dword ptr [bp-8]>
bp_lpCallParamsTmp      equ     <dword ptr [bp-12]>


        sub     eax, eax
        push    eax                             ;bp_lphCallTmp
        push    eax                             ;bp_lpszDestAddress
        push    eax                             ;bp_lpCallParams

        push    dword ptr bp_hLine              ;hLine: dword->dword
        push    dword ptr bp_lphCall
        call    MapLS
        mov     bp_lphCallTmp, eax
        push    eax
        push    dword ptr bp_lpszDestAddress
        call    MapLS
        mov     bp_lpszDestAddressTmp, eax
        push    eax
        push    dword ptr bp_dwCountryCode      ;dwCountryCode: dword->dword
        push    dword ptr bp_lpCallParams
        call    MapLS
        mov     bp_lpCallParamsTmp, eax
        push    eax
        
        call    lineMakeCall

        shl     eax,16
        shrd    eax,edx,16

        push    eax
;
; Don't UnMap lphCallTmp: Done in tapi.dll due to async read/write.
;
;       push    dword ptr bp_lphCallTmp
;       call    UnMapLS
        push    dword ptr bp_lpszDestAddressTmp
        call    UnMapLS
        push    dword ptr bp_lpCallParamsTmp
        call    UnMapLS
        pop     eax

endm


;-----------------------------------------------------------------------;
; body_LINEUNPARK
;-----------------------------------------------------------------------;
body_LINEUNPARK macro

bp_hLine                equ     <bp_top>
bp_dwAddressID          equ     <bp_top+4>
bp_lphCall              equ     <bp_top+8>
bp_lpszDestAddress      equ     <bp_top+12>
;
; dword ptr [ebp+8]:  hLine
; dword ptr [ebp+12]:  dwAddressID
; dword ptr [ebp+16]:  lphCall
; dword ptr [ebp+20]:  lpszDestAddress
;

bp_lphCallTmp           equ     <dword ptr [bp-4]>
bp_lpszDestAddressTmp   equ     <dword ptr [bp-8]>

        sub     eax, eax
        push    eax                             ;bp_lphCallTmp
        push    eax                             ;bp_lpszDestAddress

        push    dword ptr bp_hLine              ;hLine: dword->dword
        push    dword ptr bp_dwCountryCode      ;dwCountryCode: dword->dword
        push    dword ptr bp_lphCall
        call    MapLS
        mov     bp_lphCallTmp, eax
        push    eax
        push    dword ptr bp_lpszDestAddress
        call    MapLS
        mov     bp_lpszDestAddressTmp, eax
        push    eax

        call    lineUnpark

        shl     eax,16
        shrd    eax,edx,16

        push    eax
;
; Don't UnMap lphCallTmp: Done in tapi.dll due to async read/write.
;
;       push    dword ptr bp_lphCallTmp
;       call    UnMapLS
        push    dword ptr bp_lpszDestAddressTmp
        call    UnMapLS
        pop     eax
endm


;-----------------------------------------------------------------------;
; body_LINEPICKUP
;-----------------------------------------------------------------------;
body_LINEPICKUP macro

bp_hLine                equ     <bp_top>
bp_dwAddressID          equ     <bp_top+4>
bp_lphCall              equ     <bp_top+8>
bp_lpszDestAddress      equ     <bp_top+12>
bp_lpszGroupID          equ     <bp_top+16>
;
; dword ptr [ebp+8]:  hLine
; dword ptr [ebp+12]:  dwAddressID
; dword ptr [ebp+16]:  lphCall
; dword ptr [ebp+20]:  lpszDestAddress
; dword ptr [ebp+24]:  lpszGroupID
;

bp_lphCallTmp           equ     <dword ptr [bp-4]>
bp_lpszDestAddressTmp   equ     <dword ptr [bp-8]>
bp_lpszGroupIDTmp       equ     <dword ptr [bp-12]>

        sub     eax, eax
        push    eax                             ;bp_lphCallTmp
        push    eax                             ;bp_lpszDestAddressTmp
        push    eax                             ;bp_lpszGroupIDTmp

        push    dword ptr bp_hLine              ;hLine: dword->dword
        push    dword ptr bp_dwAddressID        ;dwAddressID: dword->dword
        push    dword ptr bp_lphCall
        call    MapLS
        mov     bp_lphCallTmp, eax
        push    eax
        push    dword ptr bp_lpszDestAddress
        call    MapLS
        mov     bp_lpszDestAddressTmp, eax
        push    eax
        push    dword ptr bp_lpszGroupID
        call    MapLS
        mov     bp_lpszGroupIDTmp, eax
        push    eax

        call    linePickup

        shl     eax,16
        shrd    eax,edx,16

        push    eax
;
; Don't UnMap lphCallTmp: Done in tapi.dll due to async read/write.
;
;       push    dword ptr bp_lphCallTmp
;       call    UnMapLS
        push    dword ptr bp_lpszDestAddressTmp
        call    UnMapLS
        push    dword ptr bp_lpszGroupIDTmp
        call    UnMapLS
        pop     eax
endm

;-----------------------------------------------------------------------;
; body_LINESETUPCONFERENCE
;-----------------------------------------------------------------------;
body_LINESETUPCONFERENCE macro

bp_hCall                equ     <bp_top>
bp_hLine                equ     <bp_top+4>
bp_lphConfCall          equ     <bp_top+8>
bp_lphConsultCall       equ     <bp_top+12>
bp_dwNumParties         equ     <bp_top+16>
bp_lpCallParams         equ     <bp_top+20>
;
; dword ptr [ebp+8]:  hCall
; dword ptr [ebp+12]:  hLine
; dword ptr [ebp+16]:  lphConfCall
; dword ptr [ebp+20]:  lphConsultCall
; dword ptr [ebp+24]:  dwNumParties
; dword ptr [ebp+28]:  lpCallParams
;

bp_lphConfCallTmp       equ     <dword ptr [bp-4]>
bp_lphConsultCallTmp    equ     <dword ptr [bp-8]>
bp_lpCallParamsTmp      equ     <dword ptr [bp-12]>

        sub     eax, eax
        push    eax                             ;bp_lphConfCallTmp
        push    eax                             ;bp_lphConsultCallTmp
        push    eax                             ;bp_lpCallParamsTmp

        push    dword ptr bp_hCall              ;hCall: dword->dword
        push    dword ptr bp_hLine              ;hLine: dword->dword
        push    dword ptr bp_lphConfCall
        call    MapLS
        mov     bp_lphConfCallTmp, eax
        push    eax
        push    dword ptr bp_lphConsultCall
        call    MapLS
        mov     bp_lphConsultCallTmp, eax
        push    eax
        push    dword ptr bp_dwNumParties       ;dwNumParties: dword->dword
        push    dword ptr bp_lpCallParams
        call    MapLS
        mov     bp_lpCallParamsTmp, eax
        push    eax

        call    lineSetupConference

        shl     eax,16
        shrd    eax,edx,16

        push    eax
;
; Don't UnMap lphConfCallTmp and lphConsultCallTmp: Done in tapi.dll
; due to async read/write.
;
;       push    dword ptr bp_lphConfCallTmp
;       call    UnMapLS
;       push    dword ptr bp_lphConsultCallTmp
;       call    UnMapLS
        push    dword ptr bp_lpCallParamsTmp
        call    UnMapLS
        pop     eax
endm

;-----------------------------------------------------------------------;
; body_LINECOMPLETETRANSFER
;-----------------------------------------------------------------------;
body_LINECOMPLETETRANSFER macro

bp_hCall                equ     <bp_top>
bp_hConsultCall         equ     <bp_top+4>
bp_lphConfCall          equ     <bp_top+8>
bp_dwTransferMode       equ     <bp_top+12>
;
; dword ptr [ebp+8]:  hCall
; dword ptr [ebp+12]:  hConsultCall
; dword ptr [ebp+16]:  lphConfCall
; dword ptr [ebp+20]:  dwTransferMode
;

bp_lphConfCallTmp       equ     <dword ptr [bp-4]>

        sub     eax, eax
        push    eax                             ;bp_lphConfCallTmp
        push    dword ptr bp_hCall              ;hCall: dword->dword
        push    dword ptr bp_hConsultCall       ;hConsultCall: dword->dword
        push    dword ptr bp_lphConfCall
        call    MapLS
        mov     bp_lphConfCallTmp, eax
        push    eax
        push    dword ptr bp_dwTransferMode     ;dwTransferMode: dword->dword

        call    lineCompleteTransfer

        shl     eax,16
        shrd    eax,edx,16

;       push    eax
;
; Don't UnMap lphConfCallTmp: Done in tapi.dll due to async read/write.
;
;       push    dword ptr bp_lphConfCallTmp
;       call    UnMapLS
;       pop     eax

endm


;-----------------------------------------------------------------------;
; body_LINEPREPAREADDTOCONFERENCE
;-----------------------------------------------------------------------;
body_LINEPREPAREADDTOCONFERENCE macro

bp_hConfCall            equ     <bp_top>
bp_lphAddCall           equ     <bp_top+4>
bp_lpCallParams         equ     <bp_top+8>
;
; dword ptr [ebp+8]:  hConfCall
; dword ptr [ebp+12]:  lphAddCall
; dword ptr [ebp+16]:  lpCallParams
;

bp_lphAddCallTmp        equ     <dword ptr [bp-4]>
bp_lpCallParamsTmp      equ     <dword ptr [bp-8]>

        sub     eax, eax
        push    eax                             ;bp_lphAddCallTmp
        push    eax                             ;bp_lpCallParams

        push    dword ptr bp_hConfCall          ;hConfCall: dword->dword
        push    dword ptr bp_lphAddCall
        call    MapLS
        mov     bp_lphAddCallTmp, eax
        push    eax
        push    dword ptr bp_lpCallParams
        call    MapLS
        mov     bp_lpCallParamsTmp, eax
        push    eax

        call    linePrepareAddToConference

        shl     eax,16
        shrd    eax,edx,16

        push    eax                             ; Save it

;
; Don't UnMap lphAddCallTmp: Done in tapi.dll due to async read/write.
;
;       push    dword ptr bp_lphAddCallTmp
;       call    UnMapLS
        push    dword ptr bp_lpCallParamsTmp
        call    UnMapLS
        pop     eax

endm

;-----------------------------------------------------------------------;
; body_LINESETUPTRANSFER
;-----------------------------------------------------------------------;
body_LINESETUPTRANSFER macro

bp_hCall                equ     <bp_top>
bp_lphConsultCall       equ     <bp_top+4>
bp_lpCallParams         equ     <bp_top+8>
;
; dword ptr [ebp+8]:  hCall
; dword ptr [ebp+12]:  lphConsultCall
; dword ptr [ebp+16]:  lpCallParams
;

bp_lphConsultCallTmp    equ     <dword ptr [bp-4]>
bp_lpCallParamsTmp      equ     <dword ptr [bp-8]>

        sub     eax, eax
        push    eax                             ;bp_lphConsultCallTmp
        push    eax                             ;bp_lpCallParams

        push    dword ptr bp_hCall              ;hCall: dword->dword
        push    dword ptr bp_lphConsultCall
        call    MapLS
        mov     bp_lphConsultCallTmp, eax
        push    eax
        push    dword ptr bp_lpCallParams
        call    MapLS
        mov     bp_lpCallParamsTmp, eax
        push    eax

        call    lineSetupTransfer

        shl     eax,16
        shrd    eax,edx,16

        push    eax                             ; Save it

;
; Don't UnMap lphConsultCallTmp: Done in tapi.dll due to async read/write.
;
;       push    dword ptr bp_lphConsultCallTmp
;       call    UnMapLS
        push    dword ptr bp_lpCallParamsTmp
        call    UnMapLS
        pop     eax

endm



;-----------------------------------------------------------------------;
; body_LINECOMPLETECALL
;-----------------------------------------------------------------------;
body_LINECOMPLETECALL macro

bp_hCall                equ     <bp_top>
bp_lpdwCompletionID     equ     <bp_top+4>
bp_dwCompletionMode     equ     <bp_top+8>
bp_dwMessageID          equ     <bp_top+12>
;
; dword ptr [ebp+8]:  hCall
; dword ptr [ebp+12]:  lpdwCompletionID
; dword ptr [ebp+16]:  dwCompletionMode
; dword ptr [ebp+20]:  dwMessageID
;

bp_lpdwCompletionIDTmp  equ     <dword ptr [bp-4]>

        sub     eax, eax
        push    eax                             ;bp_lpdwCompletionID

        push    dword ptr bp_hCall              ;hCall: dword->dword
        push    dword ptr bp_lpdwCompletionID
        call    MapLS
        mov     bp_lpdwCompletionIDTmp, eax
        push    eax
        push    dword ptr bp_dwCompletionMode
        push    dword ptr bp_dwMessageID

        call    lineCompleteCall

        shl     eax,16
        shrd    eax,edx,16

;       push    eax
;
; Don't UnMap lpdwCompletionIDTmp: Done in tapi.dll due to async read/write.
;
;       push    dword ptr bp_lpdwCompletionIDTmp
;       call    UnMapLS
;       pop     eax

endm

        
;-----------------------------------------------------------------------;
; body_LINEDEVSPECIFIC
;-----------------------------------------------------------------------;
body_LINEDEVSPECIFIC macro

bp_hLine                equ     <bp_top>
bp_dwAddressID          equ     <bp_top+4>
bp_hCall                equ     <bp_top+8>
bp_lpParams             equ     <bp_top+12>
bp_dwSize               equ     <bp_top+16>
;
; dword ptr [ebp+8]:  hLine
; dword ptr [ebp+12]:  dwAddressID
; dword ptr [ebp+16]:  hCall
; dword ptr [ebp+20]:  lpParams
; dword ptr [ebp+24]:  dwSize
;

bp_lpParamsTmp          equ     <dword ptr [bp-4]>

        sub     eax, eax
        push    eax                             ;bp_lpParams

        push    dword ptr bp_hLine              ;hLine: dword->dword
        push    dword ptr bp_dwAddressID        ;dwAddressID: dword->dword
        push    dword ptr bp_hCall              ;hCall: dword->dword
        push    dword ptr bp_lpParams
        call    MapLS
        mov     bp_lpParamsTmp, eax
        push    eax
        push    dword ptr bp_dwSize             ;dwSize: dword->dword

        call    lineDevSpecific

        shl     eax,16
        shrd    eax,edx,16

;       push    eax
;
; Don't UnMap lpParams: Done in tapi.dll due to async read/write.
;
;       push    dword ptr bp_lpParamsTmp
;       call    UnMapLS
;       pop     eax

endm

;-----------------------------------------------------------------------;
; body_PHONEDEVSPECIFIC
;-----------------------------------------------------------------------;
body_PHONEDEVSPECIFIC macro

bp_hPhone               equ     <bp_top>
bp_lpParams             equ     <bp_top+4>
bp_dwSize               equ     <bp_top+8>
;
; dword ptr [ebp+8]:  hPhone
; dword ptr [ebp+12]:  lpParams
; dword ptr [ebp+16]:  dwSize
;

;bp_lpParamsTmp         equ     <dword ptr [bp-4]>
;
        sub     eax, eax
        push    eax                             ;bp_lpParams

        push    dword ptr bp_hPhone             ;hPhone: dword->dword
        push    dword ptr bp_lpParams
        call    MapLS
        mov     bp_lpParamsTmp, eax
        push    eax
        push    dword ptr bp_dwSize             ;dwSize: dword->dword

        call    phoneDevSpecific

        shl     eax,16
        shrd    eax,edx,16

;       push    eax
;
; Don't UnMap lpParams: Done in tapi.dll due to async read/write.
;
;       push    dword ptr bp_lpParamsTmp
;       call    UnMapLS
;       pop     eax

endm

;-----------------------------------------------------------------------;
; body_LINEDEVSPECIFICFEATURE
;-----------------------------------------------------------------------;
body_LINEDEVSPECIFICFEATURE macro

bp_hLine                equ     <bp_top>
bp_dwFeature            equ     <bp_top+4>
bp_lpParams             equ     <bp_top+8>
bp_dwSize               equ     <bp_top+12>
;
; dword ptr [ebp+8]:  hLine
; dword ptr [ebp+12]:  dwFeature
; dword ptr [ebp+16]:  lpParams
; dword ptr [ebp+20]:  dwSize
;

bp_lpParamsTmp          equ     <dword ptr [bp-4]>

        sub     eax, eax
        push    eax                             ;bp_lpParams

        push    dword ptr bp_hLine              ;hLine: dword->dword
        push    dword ptr bp_dwFeature          ;dwFeature: dword->dword
        push    dword ptr bp_lpParams
        call    MapLS
        mov     bp_lpParamsTmp, eax
        push    eax
        push    dword ptr bp_dwSize             ;dwSize: dword->dword

        call    lineDevSpecificFeature

        shl     eax,16
        shrd    eax,edx,16

;       push    eax
;
; Don't UnMap lpParams: Done in tapi.dll due to async read/write.
;
;       push    dword ptr bp_lpParamsTmp
;       call    UnMapLS
;       pop     eax

endm


;-----------------------------------------------------------------------;
; body_LINEGATHERDIGITS
;-----------------------------------------------------------------------;
body_LINEGATHERDIGITS macro

bp_hCall                equ     <bp_top>
bp_dwDigitModes         equ     <bp_top+4>
bp_lpsDigits            equ     <bp_top+8>
bp_dwNumDigits          equ     <bp_top+12>
bp_lpszTermDigits       equ     <bp_top+16>
bp_dwFirstDigitTimeout  equ     <bp_top+20>
bp_dwInterDigitTimeout  equ     <bp_top+24>
;
; dword ptr [ebp+8]:  hCall
; dword ptr [ebp+12]:  dwDigitModes
; dword ptr [ebp+16]:  lpsDigits
; dword ptr [ebp+20]:  dwNumDigits
; dword ptr [ebp+24]:  lpszTerminationDigits
; dword ptr [ebp+28]:  dwFirstDigitTimeout
; dword ptr [ebp+32]:  dwInterDigitTimeout
;

bp_lpsDigitsTmp         equ     <dword ptr [bp-4]>
bp_lpszTermDigitsTmp    equ     <dword ptr [bp-8]>

        sub     eax, eax
        push    eax                             ;bp_lpsDigitsTmp
        push    eax                             ;bp_lpszTerminationDigitsTmp

        push    dword ptr bp_hCall              ;hCall: dword->dword
        push    dword ptr bp_dwDigitModes       ;dwDigitModes: dword->dword
        push    dword ptr bp_lpsDigits
        call    MapLS
        mov     bp_lpsDigitsTmp, eax
        push    eax
        push    dword ptr bp_dwNumDigits        ;dwNumDigits: dword->dword
        push    dword ptr bp_lpszTermDigits
        call    MapLS
        mov     bp_lpszTermDigitsTmp, eax
        push    eax
        push    dword ptr bp_dwFirstDigitTimeout ;dwFirstDigitTimeout: dword->dword
        push    dword ptr bp_dwInterDigitTimeout ;dwInterDigitTimeout: dword->dword

        call    lineGatherDigits

        shl     eax,16
        shrd    eax,edx,16

        push    eax                             ; Save it

;
; Don't UnMap lpsDigits: Done in tapi.dll due to async read/write.
;
;       push    dword ptr bp_lpsDigitsTmp
;       call    UnMapLS
        push    dword ptr bp_lpszTermDigitsTmp
        call    UnMapLS

        pop     eax
endm

;-----------------------------------------------------------------------;
; body_LINEPARK
;-----------------------------------------------------------------------;
body_LINEPARK macro

bp_hLine                equ     <bp_top>
bp_dwParkMode           equ     <bp_top+4>
bp_lpszDirAddress       equ     <bp_top+8>
bp_lpNonDirAddress      equ     <bp_top+12>
;
; dword ptr [ebp+8]:  hLine
; dword ptr [ebp+12]:  dwParkMode
; dword ptr [ebp+16]:  lpszDirAddress
; dword ptr [ebp+20]:  lpNonDirAddress
;

bp_lpszDirAddressTmp    equ     <dword ptr [bp-4]>
bp_lpNonDirAddressTmp   equ     <dword ptr [bp-8]>

        sub     eax, eax
        push    eax                             ;bp_lpszDirAddressTmp
        push    eax                             ;bp_lpNonDirAddressTmp

        push    dword ptr bp_hLine              ;hLine: dword->dword
        push    dword ptr bp_dwParkMode         ;dwParkMode: dworkd->dword
        push    dword ptr bp_lpszDirAddress
        call    MapLS
        mov     bp_lpszDirAddressTmp, eax
        push    eax
        push    dword ptr bp_lpNonDirAddress
        call    MapLS
        mov     bp_lpNonDirAddressTmp, eax
        push    eax

        call    linePark

        shl     eax,16
        shrd    eax,edx,16

        push    eax   ; Save it

        push    dword ptr bp_lpszDirAddressTmp
        call    UnMapLS
;
; Don't UnMap lpNonDirAddressTmp: Done in tapi.dll due to async read/write.
;
;       push    dword ptr bp_lpNonDirAddressTmp
;       call    UnMapLS

        pop     eax
endm


;-----------------------------------------------------------------------;
; body_TAPIREQUESTMEDIACALL
;-----------------------------------------------------------------------;
body_TAPIREQUESTMEDIACALL macro
        mov     eax, -16
endm


;-----------------------------------------------------------------------;
; body_TAPIREQUESTDROP
;-----------------------------------------------------------------------;
body_TAPIREQUESTDROP macro
        mov     eax, -16
endm


;-----------------------------------------------------------------------;
; body_LINEREGISTERREQUESTRECIPIENT
;-----------------------------------------------------------------------;
body_LINEREGISTERREQUESTRECIPIENT macro

bp_hLine                equ     <bp_top>
bp_dwRegistrationInstance  equ  <bp_top+4>
bp_dwRequestMode        equ     <bp_top+8>
bp_dwEnable             equ     <bp_top+12>
;
; dword ptr [ebp+8]:   hLine
; dword ptr [ebp+12]:  dwRegistrationInstance
; dword ptr [ebp+16]:  dwRequestMode
; dword ptr [ebp+20]:  bEnable
;

;
;       sub     eax, eax
;       push    eax                             ;bp_lpszDirAddressTmp
;       push    eax                             ;bp_lpNonDirAddressTmp
;

;
;       If this is a 32bit app asking to register for media calls, tell 'em
;       'e's nuts.
;
        test    dword ptr bp_dwRequestMode, 2 ;*** *** ***Or should this be 6?
        jz     @f

ifdef DEBUG
        DPRINT "32bit apps aren't allowed to register for Media calls"
endif
        mov     eax, 80000038h
        jmp     Done_LRRR

@@:
        push    dword ptr bp_hLine              ;hLine: dword->dword
        push    dword ptr bp_dwRegistrationInstance
        push    dword ptr bp_dwRequestMode
        push    dword ptr bp_dwEnable

        call    lineRegisterRequestRecipient

        shl     eax,16
        shrd    eax,edx,16

Done_LRRR:

endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\wnlsfthk.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\thkrp.inc ===
;-------------------------------
; CVT.INC MUST BE INCLUDED FIRST
;-------------------------------

include     cvt.inc


;==============================================================================
; repack TEXTMETRIC from 32-bit to 16-bit
;
;==============================================================================
PACK_TEXTMETRIC_32_16   macro   fEmbedded

        lodsd                           ;tmHeight
        stosw

        lodsd                           ;tmAscent
        stosw

        lodsd                           ;tmDescent
        stosw

        lodsd                           ;tmInternalLeading
        stosw

        lodsd                           ;tmExternalLeading
        stosw

        lodsd                           ;tmAveCharWidth
        stosw

        lodsd                           ;tmMaxCharWidth
        stosw

        lodsd                           ;tmWeight
        stosw

        add     esi,(4+4+4)

;32-bit order      --> 16-bit order
;--------------------------------------
;tmFirstChar           tmItalic
;tmLastChar            tmUnderlined
;tmDefaultChar         tmStruckOut
;tmBreakChar           tmFirstChar
;tmItalic              tmLastChar
;tmUnderlined          tmDefaultChar
;tmStruckOut           tmBreakChar
;tmPitchAndFamily      tmPitchAndFamily
;tmCharSet             tmCharSet

        mov     eax,[esi+4]
        stosd                           ;;only three bytes valid
        dec     edi
        mov     eax,[esi+0]
        stosd
        mov     ax,[esi+7]
        stosw

        sub     esi,(4+4+4)

        lodsd                           ;tmOverhang
        stosw

        lodsd                           ;tmDigitizedAspectX
        stosw

        lodsd                           ;tmDigitizedAspectY
        stosw

    ifnb <fEmbedded>
;;Keep esi in sync since this macro is embedded in another.
        add     esi,9
    endif
endm


;==============================================================================
; repack TEXTMETRIC from 16-bit to 32-bit
;
;==============================================================================
PACK_TEXTMETRIC_16_32   macro   fEmbedded
        lodsw                           ;tmHeight
        cwde
        stos    dword ptr es:[edi]

        lodsw                           ;tmAscent
        cwde
        stos    dword ptr es:[edi]

        lodsw                           ;tmDescent
        cwde
        stos    dword ptr es:[edi]

        lodsw                           ;tmInternalLeading
        cwde
        stos    dword ptr es:[edi]

        lodsw                           ;tmExternalLeading
        cwde
        stos    dword ptr es:[edi]

        lodsw                           ;tmAveCharWidth
        cwde
        stos    dword ptr es:[edi]

        lodsw                           ;tmMaxCharWidth
        cwde
        stos    dword ptr es:[edi]

        lodsw                           ;tmWeight
        cwde
        stos    dword ptr es:[edi]

        add     esi,9

        lodsw                           ;tmOverhang
        cwde
        stos    dword ptr es:[edi]

        lodsw                           ;tmDigitizedAspectX
        cwde
        stos    dword ptr es:[edi]

        lodsw                           ;tmDigitizedAspectY
        cwde
        stos    dword ptr es:[edi]

        sub     esi,(2+2+2+9)

;16-bit order     --> 32-bit order
;--------------------------------------
;tmItalic             tmFirstChar
;tmUnderlined         tmLastChar
;tmStruckOut          tmDefaultChar
;tmFirstChar          tmBreakChar
;tmLastChar           tmItalic
;tmDefaultChar        tmUnderlined
;tmBreakChar          tmStruckOut
;tmPitchAndFamily     tmPitchAndFamily
;tmCharSet            tmCharSet

        mov     eax,[esi+3]             ;First Last Default Break-char
        stos    dword ptr es:[edi]
        mov     eax,[esi+0]             ;
        stos    dword ptr es:[edi]      ;Italic Underlined StruckOut
        dec     edi                     ;
        mov     ax,[esi+7]
        stos    word ptr es:[edi]       ;Pitch CharSet

    ifnb <fEmbedded>
;;Keep esi in sync since this macro is embedded in another.
        add     esi,(2+2+2+9)
    endif
endm


;==============================================================================
;==============================================================================
PACK_POINT_16_32        macro
    ncopysx 2
endm

;==============================================================================
;==============================================================================
PACK_RECT_32_16     macro
    ncopyt  4
endm

PACK_RECT_16_32     macro
    ncopysx 4
endm


;==============================================================================
;==============================================================================
PACK_PANOSE_16_32        macro
;copy ten bytes
;;;;        sub     eax,eax
;;;;        stos    dword ptr es:[edi]      ;!!! kirko says this will disappear

        lodsd
        stos    dword ptr es:[edi]
        lodsd
        stos    dword ptr es:[edi]
        lodsw
        stos    word ptr es:[edi]
endm


;==============================================================================
; repack OUTLINETEXTMETRIC from 16-bit to 32-bit
;
; Requirements:
;       DS:ESI --> source (16-bit)
;       ES:EDI --> dest (32-bit)
;==============================================================================

OUTLINETEXTMETRIC16_SIZE        equ     114
OUTLINETEXTMETRIC32_SIZE        equ     212

PACK_OUTLINETEXTMETRIC_16_32   macro

    COPY_STRING     macro
            local   loop_top
    loop_top:
            lodsb
            stos    byte ptr es:[edi]
            or      al,al
            jnz     loop_top
    endm

    COPY_OTM_STRING macro        last
        mov     cx,si                   ;;save source ptr into struct
        mov     si,[si]                 ;;get offset to chars
        add     si,bx                   ;;add in base
        COPY_STRING                     ;;copy characters
        mov     si,cx                   ;;restore source ptr into struct
        ifb <last>
            add     si,2                ;;next offset in struct
        endif
    endm

    COPY_ADJUSTED_OFFSET        macro
        lodsw
        movzx   eax,ax
        add     eax,OUTLINETEXTMETRIC32_SIZE - OUTLINETEXTMETRIC16_SIZE
        stos    dword ptr es:[edi]
    endm

        mov     bx,si                   ;;save copy for strings at end

        COPY_ADJUSTED_OFFSET                    ;otmSize

        PACK_TEXTMETRIC_16_32   embedded        ;otmTextMetrics

        lodsb                                   ;otmFiller
        stosb   es:[edi]                        ;

        add     edi, 3                          ;DWORD align otmPanoseNumber

        PACK_PANOSE_16_32                       ;otmPanoseNumber

        add     edi, 1                          ;DWORD align otmfsSelection

        UMAP_WORDTODWORD                        ;otmfsSelection;
        UMAP_WORDTODWORD                        ;otmfsType;
        UMAP_WORDTODWORD                        ;otmsCharSlopeRise;
        UMAP_WORDTODWORD                        ;otmsCharSlopeRun;
        UMAP_INTTOLONG                          ;otmItalicAngle;
        UMAP_WORDTODWORD                        ;otmEMSquare;
        UMAP_WORDTODWORD                        ;otmAscent;
        UMAP_INTTOLONG                          ;otmDescent;
        UMAP_INTTOLONG                          ;otmLineGap;
        UMAP_WORDTODWORD                        ;otmXHeight;
        UMAP_WORDTODWORD                        ;otmCapEmHeight;
        PACK_RECT_16_32                         ;otmrcFontBox;
        UMAP_INTTOLONG                          ;otmMacAscent;
        UMAP_INTTOLONG                          ;otmMacDescent;
        UMAP_WORDTODWORD                        ;otmMacLineGap;
        UMAP_WORDTODWORD                        ;otmusMinimumPPEM;
        PACK_POINT_16_32                        ;otmptSubscriptSize;
        PACK_POINT_16_32                        ;otmptSubscriptOffset;
        PACK_POINT_16_32                        ;otmptSuperscriptSize;
        PACK_POINT_16_32                        ;otmptSuperscriptOffset;
        UMAP_WORDTODWORD                        ;otmsStrikeoutSize;
        UMAP_INTTOLONG                          ;otmsStrikeoutPosition;

; Need to flip otmUnderscorePosition and otmUnderscoreSize

        movzx   eax, word ptr [si+2]            ; otmUnderscoreSize
        stosd   es:[edi]                        ;
        movsx   eax, word ptr [si]              ; otmUnderscorePosition
        stosd   es:[edi]                        ;
        add     si, 4                           ;

        COPY_ADJUSTED_OFFSET                    ;otmpFamilyName;
        COPY_ADJUSTED_OFFSET                    ;otmpFaceName;
        COPY_ADJUSTED_OFFSET                    ;otmpStyleName;
        COPY_ADJUSTED_OFFSET                    ;otmpFullName;

;;Rewind source to first of string offsets
        sub     si,2*4

        COPY_OTM_STRING
        COPY_OTM_STRING
        COPY_OTM_STRING
        COPY_OTM_STRING last

    purge COPY_STRING
    purge COPY_OTM_STRING
    purge COPY_ADJUSTED_OFFSET
endm


;==============================================================================
; repack NEWTEXTMETRIC from 16-bit to 32-bit
;
;==============================================================================
PACK_NEWTEXTMETRIC_16_32   macro
        PACK_TEXTMETRIC_16_32   embedded

        add     edi,3           ;padding bytes

        lodsd                           ;ntmFlags
        stos    dword ptr es:[edi]

        sub     eax,eax

        lodsw                           ;ntmSizeEM
        stos    dword ptr es:[edi]

        lodsw                           ;ntmCellHeight
        stos    dword ptr es:[edi]

        lodsw                           ;ntmAvgWidth
        stos    dword ptr es:[edi]
endm


;==============================================================================
; repack LOGFONT from 32-bit to 16-bit
;
;==============================================================================
PACK_LOGFONT_32_16   macro
        lodsd        ;lfHeight
        stosw
        lodsd        ;lfWidth
        stosw
        lodsd        ;lfEscapement
        stosw
        lodsd        ;lfOrientation
        stosw
        lodsd        ;lfWeight
        stosw

;These are all BYTE fields:
;lfItalic
;lfUnderline
;lfStrikeOut
;lfCharSet
;lfOutPrecision
;lfClipPrecision
;lfQuality
;lfPitchAndFamily
;lfFaceName[32]

        mov     ecx,40/4
        rep     movsd
endm


;==============================================================================
; repack LOGFONT from 16-bit to 32-bit
;
;==============================================================================
PACK_LOGFONT_16_32   macro
        lodsw        ;lfHeight
        cwde
        stosd
        lodsw        ;lfWidth
        cwde
        stosd
        lodsw        ;lfEscapement
        cwde
        stosd
        lodsw        ;lfOrientation
        cwde
        stosd
        lodsw        ;lfWeight
        cwde
        stosd

;These are all BYTE fields:
;lfItalic
;lfUnderline
;lfStrikeOut
;lfCharSet
;lfOutPrecision
;lfClipPrecision
;lfQuality
;lfPitchAndFamily
;lfFaceName[32]

        mov     ecx,40/4
        rep     movsd
endm


;==============================================================================
; Convert MLOGFONT 32->16
;
;==============================================================================
PACK_MLOGFONT_32_16   macro
    ncopyt  5
    ncopyd  40/4
endm


;==============================================================================
; Convert MLOGFONT 16->32
;
;==============================================================================
PACK_MLOGFONT_16_32   macro
    ncopysx 5    
    ncopyd  40/4
endm


;==============================================================================
; repack ENUMLOGFONT from 16-bit to 32-bit
;
;==============================================================================
PACK_ENUMLOGFONT_16_32   macro
        lodsw        ;lfHeight
        cwde
        stos    dword ptr es:[edi]
        lodsw        ;lfWidth
        cwde
        stos    dword ptr es:[edi]
        lodsw        ;lfEscapement
        cwde
        stos    dword ptr es:[edi]
        lodsw        ;lfOrientation
        cwde
        stos    dword ptr es:[edi]
        lodsw        ;lfWeight
        cwde
        stos    dword ptr es:[edi]

;These are all BYTE fields:
;lfItalic
;lfUnderline
;lfStrikeOut
;lfCharSet
;lfOutPrecision
;lfClipPrecision
;lfQuality
;lfPitchAndFamily
;lfFaceName[32]
;elfFullName[64]
;elfStyle[32]

        mov     ecx,136/4
        rep     movs dword ptr es:[edi],dword ptr ds:[esi]
endm


;==============================================================================
; repack BITMAP from 32-bit to 16-bit
;
;==============================================================================
PACK_BITMAP_32_16   macro
        lodsd                           ;bmType
        stosw

        lodsd                           ;bmWidth
        stosw

        lodsd                           ;bmHeight
        stosw

        lodsd                           ;bmWidthBytes
        stosw

        lodsw                           ;bmPlanes
        stosb

        lodsw                           ;bmBitsPixel
        stosb

        movsd                           ;bmBits
endm


;-----------------------------------------------------------------------;
; Printer api thunk stuff
;-----------------------------------------------------------------------;
DEVMODECOMMON struc
    dmDeviceName        db      32 dup (?)
    dmSpecVersion       dw      ?
    dmDriverVersion     dw      ?
    dmSize              dw      ?
    dmDriverExtra       dw      ?
    dmFields            dd      ?
    dmOrientation       dw      ?
    dmPaperSize         dw      ?
    dmPaperLength       dw      ?
    dmPaperWidth        dw      ?
    dmScale             dw      ?
    dmCopies            dw      ?
    dmDefaultSource     dw      ?
    dmPrintQuality      dw      ?
    dmColor             dw      ?
    dmDuplex            dw      ?
    dmYResolution       dw      ?
    dmTTOption          dw      ?
DEVMODECOMMON ends

DEVMODE16 struc
    dmCommon            db      size DEVMODECOMMON dup (?)
DEVMODE16 ends

DEVMODE32 struc
    dmCommon            db      size DEVMODECOMMON dup (?)
    dmCollate           dw      ?
    dmFormName          db      32 dup (?)
    dmUnusedPadding     dw      ?
    dmBitsPerPel        dw      ?
    dmPelsWidth         dd      ?
    dmPelsHeight        dd      ?
    dmDisplayMode       dd      ?
DEVMODE32 ends

;-----------------------------------------------------------------------;
; REPACK_DEVMODE_32_16
;
; Entry:
;       DS:ESI --> 32-bit source (ESI might be flat offset)
;       ES:EDI --> 16-bit destination (EDI is zero-extended from DI)
;       direction flag cleared
;-----------------------------------------------------------------------;
REPACK_DEVMODE_32_16 macro
        local   done

        ;Move the common part as a single block move.
        MoveBytes       <(size DEVMODECOMMON)>

        ;Update the dmSize field
        mov     es:[di].(dmSize - (size DEVMODECOMMON)),size DEVMODE16

        ;!!!Clear out any win32-only flags
        ;and     es:[di].(dmFields - (size DEVMODECOMMON)),0FFFFh

        ;Insert win16-only fields.  EDI points to the byte after
        ;DEVMODECOMMON.  Afterwards, will point to byte after DEVMODE16.
        ;ZeroBytes       <((size DEVMODE16) - (size DEVMODECOMMON))>

        ;Skip over the extra win32 fields.  ESI still points to the byte
        ;after DEVMODECOMMON.
        add     esi,(size DEVMODE32) - (size DEVMODECOMMON)

        ;Move the driver-dependent part.  EDI points to the byte after
        ;DEVMODE16.
        mov     cx,es:[di].(dmDriverExtra - (size DEVMODE16))
        jcxz    done

        movzx   ecx,cx
        mov     edx,ecx
        shr     cx,2
        and     dx,3
        rep     movs dword ptr es:[edi],dword ptr ds:[esi]
        mov     cx,dx
        rep     movs byte ptr es:[edi],byte ptr ds:[esi]
done:
endm

;-----------------------------------------------------------------------;
; REPACK_DEVMODE_16_32
;
; Entry:
;       DS:ESI --> 16-bit destination (ESI is zero-extended from SI)
;       ES:EDI --> 32-bit source (EDI might be flat offset)
;       direction flag cleared
;-----------------------------------------------------------------------;
REPACK_DEVMODE_16_32 macro
        local   done

        ;Move the common part as a single block move.
        MoveBytes       <(size DEVMODECOMMON)>

        ;Update the dmSize field
        mov     es:[edi].(dmSize - (size DEVMODECOMMON)),size DEVMODE32

        ;Insert the win32-only fields (advances EDI to end of DEVMODE32)
        ZeroBytes       <((size DEVMODE32) - (size DEVMODECOMMON))>

        ;Move the driver-dependent part.  SI points to the byte after
        ;DEVMODECOMMON.
        movzx   ecx,[si].(dmDriverExtra - (size DEVMODECOMMON))
        jcxz    done

        mov     edx,ecx
        shr     cx,2
        and     dx,3
        rep     movs dword ptr es:[edi],dword ptr ds:[esi]
        mov     cx,dx
        rep     movs byte ptr es:[edi],byte ptr ds:[esi]
done:
endm


OLETARGETDEVICE16 struc
otd16DeviceNameOffset    dw      ?
otd16DriverNameOffset    dw      ?
otd16PortNameOffset      dw      ?
otd16ExtDevmodeOffset    dw      ?
otd16ExtDevmodeSize      dw      ?
otd16EnvironmentOffset   dw      ?
otd16EnvironmentSize     dw      ?
;otd16Data[1]            db      1 dup (?)
OLETARGETDEVICE16 ends

OLETARGETDEVICE32 struc
otd32DeviceNameOffset    dd      ?
otd32DriverNameOffset    dd      ?
otd32PortNameOffset      dd      ?
otd32ExtDevmodeOffset    dd      ?
otd32ExtDevmodeSize      dd      ?
otd32EnvironmentOffset   dd      ?
otd32EnvironmentSize     dd      ?
;otd32Data[1]            db      1 dup (?)
OLETARGETDEVICE32 ends

;-----------------------------------------------------------------------;
; REPACK_OLETARGETDEVICE_32_16
;
; Entry:
;       DS:ESI --> 32-bit source (ESI might be flat offset)
;       ES:EDI --> 16-bit destination (EDI is zero-extended from DI)
;       direction flag cleared
;-----------------------------------------------------------------------;
REPACK_OLETARGETDEVICE_32_16 macro

; Entry:
;       DS:ESI --> 32-bit source (ESI might be flat offset)
;       ES:EDI --> 16-bit destination (EDI is zero-extended from DI)
;       ES:BX  --> 16-bit structure base
;       direction flag cleared
;
; Exit:
;       DS:ESI preserved
;       ES:EDI updated
;       ES:BX  preserved

MOVE_STRING macro foo
        local   loop_top

        push    esi                             ;save original source

        add     esi,[esi].otd32&foo&Offset
        add     esi,size OLETARGETDEVICE32

        mov     ax,di                           ;current offset
        sub     ax,bx                           ;offset from base
        sub     ax,size OLETARGETDEVICE16       ;offsets start from end
        mov     es:[bx].otd16&foo&Offset,ax     ;store new offset

loop_top:
        mov     al,[esi]
        mov     es:[di],al
        inc     esi
        inc     di
        or      al,al
        jnz     loop_top

        pop     esi
endm

; Entry:
;       DS:ESI --> 32-bit source (ESI might be flat offset)
;       ES:EDI --> 16-bit destination (EDI is zero-extended from DI)
;       ES:BX  --> 16-bit structure base
;       direction flag cleared
;
; Exit:
;       DS:ESI preserved
;       ES:EDI updated
;       ES:BX  preserved

MOVE_DEVMODE macro foo
        local   exit, empty_fields

        mov     eax,[esi].otd32&foo&Size
        or      eax,eax
        jz      empty_fields

        push    esi                             ;save original source
        push    bx                              ;base pointer

        add     esi,[esi].otd32&foo&Offset
        add     esi,size OLETARGETDEVICE32

        mov     ax,di                           ;current offset
        sub     ax,bx                           ;offset from base
        sub     ax,size OLETARGETDEVICE16       ;offsets start from end
        mov     es:[bx].otd16&foo&Offset,ax     ;store new offset

        REPACK_DEVMODE_32_16

        pop     bx                              ;restore base pointer
        pop     esi

        mov     ax,di
        sub     ax,es:[bx].otd16&foo&Offset
        mov     es:[bx].otd16&foo&Size,ax       ;store new size
        jmp     short exit

empty_fields:
        mov     es:[bx].otd16&foo&Offset,ax     ;store null offset
        mov     es:[bx].otd16&foo&Size,ax       ;store null size

exit:
endm

        mov     bx,di
        add     di,size OLETARGETDEVICE16       ;put first string here

        MOVE_STRING  DeviceName
        MOVE_STRING  DriverName
        MOVE_STRING  PortName
        MOVE_DEVMODE ExtDevmode
        MOVE_DEVMODE Environment

        purge MOVE_STRING
        purge MOVE_DEVMODE
endm


;-----------------------------------------------------------------------;
; REPACK_OLETARGETDEVICE_16_32
;
; Entry:
;       DS:ESI --> 16-bit source (ESI is zero-extended from SI)
;       ES:EDI --> 32-bit destination (EDI might be flat offset)
;       direction flag cleared
;-----------------------------------------------------------------------;
REPACK_OLETARGETDEVICE_16_32 macro

; Entry:
;       DS:ESI --> 16-bit source (ESI is zero-extended from DI)
;       ES:EDI --> 32-bit destination (EDI might be flat offset)
;       ES:EBX --> 32-bit structure base
;       direction flag cleared
;
; Exit:
;       DS:ESI preserved
;       ES:EDI updated
;       ES:EBX preserved

MOVE_STRING macro foo
        local   loop_top

        push    si                              ;save original source

        add     si,[si].otd16&foo&Offset
        add     si,size OLETARGETDEVICE16

        mov     eax,edi                         ;current offset
        sub     eax,ebx                         ;offset from base
        sub     eax,size OLETARGETDEVICE32      ;offsets start from end
        mov     es:[ebx].otd32&foo&Offset,eax   ;store new offset

loop_top:
        mov     al,[si]
        mov     es:[edi],al
        inc     si
        inc     edi
        or      al,al
        jnz     loop_top

        pop     si
endm

; Entry:
;       DS:ESI --> 16-bit source (ESI is zero-extended from DI)
;       ES:EDI --> 32-bit destination (EDI might be flat offset)
;       ES:EBX --> 32-bit structure base
;       direction flag cleared
;
; Exit:
;       DS:ESI preserved
;       ES:EDI updated
;       ES:EBX preserved

MOVE_DEVMODE macro foo
        local   exit, empty_fields

        mov     ax,[si].otd16&foo&Size
        or      ax,ax
        jz      empty_fields

        push    si                              ;save original source
        push    ebx                             ;base pointer

        add     si,[si].otd16&foo&Offset
        add     si,size OLETARGETDEVICE16

        mov     eax,edi                         ;current offset
        sub     eax,ebx                         ;offset from base
        sub     eax,size OLETARGETDEVICE32      ;offsets start from end
        mov     es:[ebx].otd32&foo&Offset,eax   ;store new offset

        REPACK_DEVMODE_16_32

        pop     ebx                             ;restore base pointer
        pop     si

        mov     eax,edi
        sub     eax,es:[ebx].otd32&foo&Offset
        mov     es:[ebx].otd32&foo&Size,eax     ;store new size
        jmp     short exit

empty_fields:
        sub     eax,eax
        mov     es:[ebx].otd32&foo&Offset,eax   ;store null offset
        mov     es:[ebx].otd32&foo&Size,eax     ;store null size

exit:
endm

        mov     ebx,edi
        add     edi,size OLETARGETDEVICE32      ;put first string here

        MOVE_STRING  DeviceName
        MOVE_STRING  DriverName
        MOVE_STRING  PortName
        MOVE_DEVMODE ExtDevmode
        MOVE_DEVMODE Environment

        purge MOVE_STRING
        purge MOVE_DEVMODE
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\usrcbid.inc ===
; Callback-type id's for USER callbacks. All callback-type id's are
; 32-bits long and the upper 16-bits must be set to the module's
; Callback Client id.
;
; WARNING -- WARNING -- WARNING
;
;   Win32c.dll uses the lower 16 bits of CBID's to index directly into
;   the tables stored in USER.EXE (usrcb16.asm) and USER32.DLL (usrcb32.asm).
;   Those tables *must* match these id's or callbacks will fail miserably.
;   Do everyone a big favor and add new id's only at the end, and never
;   change an existing id.
;



CBID_WNDPROC        equ (0 + (CBCID_USER SHL 16))
CBID_DLGPROC            equ (1 + (CBCID_USER SHL 16))
CBID_ENUMMONITORSPROC   equ (2 + (CBCID_USER SHL 16))
; EMPTY
CBID_DDECALLBACK    equ (4 + (CBCID_USER SHL 16))
CBID_GRAYSTRINGA    equ (5 + (CBCID_USER SHL 16))
CBID_WORDBREAKPROC  equ (6 + (CBCID_USER SHL 16))
CBID_TIMER          equ (7 + (CBCID_USER SHL 16))
CBID_ENUMWIN        equ (8 + (CBCID_USER SHL 16))

; Start of window hook callbacks: these must form a contiguous group

;   A fake CBID_ to mark the start of the group.
CBID_WH_START               equ (9 + (CBCID_USER SHL 16))

CBID_WH_MSGFILTER           equ (CBID_WH_START)
CBID_WH_JOURNALRECORD   equ     (CBID_WH_START+1)
CBID_WH_JOURNALPLAYBACK equ     (CBID_WH_START+2)
CBID_WH_KEYBOARD            equ (CBID_WH_START+3)
CBID_WH_GETMESSAGE          equ (CBID_WH_START+4)
CBID_WH_CALLWNDPROC         equ (CBID_WH_START+5)
CBID_WH_CBT                     equ     (CBID_WH_START+6)
CBID_WH_SYSMSGFILTER    equ     (CBID_WH_START+7)
CBID_WH_MOUSE               equ (CBID_WH_START+8)
CBID_WH_HARDWARE            equ (CBID_WH_START+9)
CBID_WH_DEBUG               equ (CBID_WH_START+10)
CBID_WH_SHELL               equ (CBID_WH_START+11)
CBID_WH_FOREGROUNDIDLE  equ (CBID_WH_START+12)
CBID_WH_CALLWNDPROCRET  equ (CBID_WH_START+13)

;   A fake CBID_ to mark the end of the group.
CBID_WH_END                     equ     (CBID_WH_CALLWNDPROCRET+1)
; End of window hook callbacks: these must form a contiguous group

CBID_SENDMSGCALLBACK        equ (CBID_WH_END)
CBID_DRAWSTATEA             equ (CBID_WH_END+1)
CBID_MESSAGEBOXINDIRECTA    equ (CBID_WH_END+2)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\meow\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
	 PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\usrthk.inc ===
;; NEWHEADER structure is used in LookupIconIdFromDir
NEWHEADER   struc
    Reserved    dw  ?
    ResType dw  ?
    ResCount    dw  ?
NEWHEADER   ends

;; RESDIR structure is used in LookupIconIdFromDir
RESDIR      struc
    IconOrCursor dd ?   ; IconDir or CursorDir structure.
    Planes   dw ?
    BitCount     dw ?
    BytesInRes   dd ?
    idIcon   dw ?
RESDIR          ends

if 0
CHECKHINULL macro x
    local   chn_ex
ifdef DEBUG
    push    eax
    mov     eax, x
    shr     eax, 16
    jz      chn_ex
    int 3
    chn_ex:
    pop     eax
endif
endm

CHECKHISIGN macro x
    local   chs_ex
ifdef DEBUG
    push    eax
    mov     eax, x
    shr     eax, 16
    inc     ax
    cmp     ax, 1
    jbe     chs_ex
    int 3
    chs_ex:
    pop     eax
endif
endm
endif


CodeData equ <THUNK16CodeData>

ifdef IS_16
include thkrp.inc
include k32share.inc
include public.inc
include cbcheck.inc
include thkmacro.inc
include thkframe.inc
include struc.inc
include cbcid.inc
include usrcbid.inc

fLocalFlag      equ     fUsrLog16
WINABLE         equ     1

TIMERINFO_TYPE struct
resolution      DWORD   ?
TIMERINFO_TYPE ends


MULTIKEYHELP32  STRUC
mk32_Size               dd      ?
mk32_Keylist            db      ?
mk32_szKeyPhrase        db      ?
MULTIKEYHELP32  ENDS

MULTIKEYHELP16  STRUC
mk16_Size               dw      ?
mk16_Keylist            db      ?
mk16_szKeyPhrase        db      ?
MULTIKEYHELP16  ENDS

HELPWININFO32   STRUC
hwi32_wStructSize       dd      ?
hwi32_x                 dd      ?
hwi32_y                 dd      ?
hwi32_dx                dd      ?
hwi32_dy                dd      ?
hwi32_wMax              dd      ?
hwi32_rgchMember        db      ?
HELPWININFO32   ENDS

HELPWININFO16   STRUC
hwi16_wStructSize       dw      ?
hwi16_x                 dw      ?
hwi16_y                 dw      ?
hwi16_dx                dw      ?
hwi16_dy                dw      ?
hwi16_wMax              dw      ?
hwi16_rgchMember        db      ?
HELPWININFO16   ENDS

FLASHWINFO16 STRUC
fw16_cbSize             dw      ?
fw16_hwnd               dw      ?
fw16_dwFlags            dd      ?
fw16_uCount             dw      ?
fw16_dwTimeout          dd      ?
FLASHWINFO16 ENDS

FLASHWINFO32 STRUC
fw32_cbSize             dd      ?
fw32_hwnd               dd      ?
fw32_dwFlags            dd      ?
fw32_uCount             dd      ?
fw32_dwTimeout          dd      ?
FLASHWINFO32 ENDS

externDef GetExePtr:far16
;;;externDef InsertPropAtom:far16
;;;externDef DeletePropAtom:far16
externDef GlobalAddAtom:far16
externDef GlobalDeleteAtom:far16
externDef GlobalFindAtom:far16
externDef ConvertDialogA:far16
externDef ConvertDialog:far16
externDef ConvertDialog32:far16
externDef CountDialogA:far16
externDef CountDialogU:far16
externDef ConvertMenuA:far16
externDef CountMenuA:far16
externDef CountMenuU:far16
externDef ConvertMenu32:far16
externDef GetNullhInst:far16

externDef GlobalAlloc:far16
externDef GlobalFree:far16
externDef GlobalLock:far16
externDef GlobalUnlock:far16
externDef GlobalFix:far16
externDef GlobalUnfix:far16

externDef MaphinstLS:far16
externDef MaphinstSL:far16

externDef IsClassNameMDICLIENT:far16
externDef ConvertDDEHandleLS:far16
externDef ConvertDDEHandleSL:far16
externDef QueryCallbackAddress:far16
externDef GetStdCBSL:far16
externDef GetStdCBLS:far16
externDef GetCurrentTask:far16 ;!!! temporary?
externDef GetCurrentThreadID:far16
externDef timerInfo:TIMERINFO_TYPE
externDef CALLBACK_BODY_16:far16
externDef GetCurrentHeap:far16
externDef ConvertMenuItemInfoLS:far16

externDef IsDialog:far16
externDef IsWindowClassType:far16

;;;externDef aUserData:dword
externDef Map32To16:far16
externDef DelMap:far16
externDef LoadLibrary32:far16
externDef ConvertCFDataLS:far16
externDef ConvertCFDataSL:far16
externDef IsThisADDEExecuteHandle:far16
externDef ConvertOleClipData:far16

externDef GetHCONVWindows:far16


;-----------------------------------------------------------------------;
; DXAX2EAX
; mov dx to eax high word
;
;-----------------------------------------------------------------------;
DXAX2EAX macro
    ror     eax,16
    xchg    ax,dx
    ror     eax,16
endm


CF_LCID equ 16

;-----------------------------------------------------------------------;
; body_SETCLIPBOARDDATA
;-----------------------------------------------------------------------;
body_SETCLIPBOARDDATA  macro
    local   exit
    local   SetData

bp_nFormat      equ     <bp_top>
bp_dwData       equ     <bp_top+4>

    mov     eax, dword ptr bp_dwData
    test    eax, eax
    jz      SetData

    push    word ptr bp_nFormat
    push    eax
    push    word ptr 1      ;Nuke old copies of hData
    call    ConvertCFDataLS
    movzx   eax, ax
    test    ax, ax
    jz      exit

SetData:
    push    word ptr bp_nFormat
    push    ax
    push    1
    call    SetClipboardData32
    movzx   eax, ax

    test    ax, ax
    jz      exit

    mov     eax, bp_dwData      ;Return original hData
exit:
endm

;-----------------------------------------------------------------------;
; body_GETCLIPBOARDDATA
;-----------------------------------------------------------------------;
body_GETCLIPBOARDDATA  macro
    local   exit
bp_nFormat      equ     <bp_top>

    push    word ptr bp_nFormat
    push    1
    call    GetClipboardData32
    movzx   eax, ax
    test    ax, ax
    jz      exit

    push    word ptr bp_nFormat
    push    ax              ;hnd16
    push    word ptr 0      ;Don't nuke old copies of hData
    call    ConvertCFDataSL

; Return now in eax.
exit:

endm



;-----------------------------------------------------------------------;
;
; body_SETWINDOWSHOOKEXA
;
;-----------------------------------------------------------------------;
body_SETWINDOWSHOOKEXA macro
    local type_ok
    local get_out
    local inserted_ok
    local push_task
bp_nType        equ     <bp_top>
bp_pfn          equ     <bp_top+4>
bp_hmod         equ     <bp_top+8>
bp_hThread      equ     <bp_top+12>

    mov     di,word ptr bp_nType            ;will need more than once
    inc     di                              ;make nType 0-based
    cmp     di,CBID_WH_END-CBID_WH_START
    jb      type_ok
    ;!!! SetExtendedError?
    sub     eax,eax                         ;error, invalid hook type
    jmp     get_out

type_ok:
    dec     di                              ;restore correct nType
    push    di                              ;push for SetWindowsHookEx

    ;map hook type onto callback type
    movsx   edi,di
    add     edi,CBID_WH_START+1             ;hook type --> callback type
    push    dword ptr bp_pfn                ;32-bit callback address
    push    edi                             ;callback type
    call    GetStdCBSL                      ;create 16-bit callback stub
    push    eax

    ;
    ; Use module's or task's _real_ instance/module
    ; We need to do this in case bp_hmod is 0L, so we get current.
    ;
    mov     eax, dword ptr bp_hmod
    call    MaphInstLS
    mov     word ptr bp_hmod, ax
    call    MaphInstSL
    push    eax

    push    dword ptr bp_hThread
    call    SetWindowsHookEx32              ;make api call
    DXAX2EAX
get_out:
endm

;-----------------------------------------------------------------------;
; body_UNHOOKWINDOWSHOOK
;-----------------------------------------------------------------------;
body_UNHOOKWINDOWSHOOK macro
bp_nCode        equ     <bp_top>
bp_pfn          equ     <bp_top+4>

    ; Save nCode in eax for CBID_ math later
    movsx   eax, word ptr bp_nCode
    push    ax

    push    dword ptr bp_pfn
    add     eax, CBID_WH_START+1
    push    eax
    call    QueryCallbackAddress
    push    eax

    call    UnhookWindowsHook
    cwde
endm



;-----------------------------------------------------------------------;
; body_GETSETWINDOWDATA
;-----------------------------------------------------------------------;
body_GETSETWINDOWDATA macro
    local exit
    local Call_GSWD
    local GSWD_return
    local SWD_wndproc
    local SWD_hinst
    local GWD_wndproc
    local GWD_hinst
    local error
    local apfnGet
    local apfnSet

bp_hwnd         equ <bp_top>
bp_nIndex       equ <bp_top+4>
bp_dwValue      equ <bp_top+8>
bp_nFlags       equ <bp_top+12>

bp_isdialog     equ <[bp-2]>

    ; Save space for bp_isdialog
    xor     ax, ax
    push    ax

    mov     bx, word ptr bp_nIndex
    cmp     bx, ax
    jl      @F

    cmp     bx, DWL_DLGPROC
    jne     Call_GSWD

    ; Is window really a dialog?  If not, skip this!
    push    word ptr bp_hwnd
    call    IsDialog
    mov     word ptr bp_isdialog, ax
    test    ax, ax
    jz      Call_GSWD

    test    word ptr bp_nFlags, DATA_SET
    jz      Call_GSWD
    jmp     SWD_wndproc

@@:
    cmp     bx,GWL_USERDATA
    je      Call_GSWD

    neg     bx
    add     bx,GWL_WNDPROC
    .errnz  GWL_WNDPROC + 4
    jl      error
    cmp     bx,MAX_INDEX
    ja      error
    test    bl, 1
    jnz     error                   ;Don't allow odd indices.

    test    word ptr bp_nFlags, DATA_SET
    jz      Call_GSWD
    jmp     cs:apfnSet[bx]

apfnSet label word
    dw      offset SWD_wndproc      ;0     ; -4 GWL_WNDPROC
    dw      offset SWD_hinst        ;2     ; -6 GWL_HINSTANCE
    dw      offset Call_GSWD        ;4     ; -8 GWL_HWNDPARENT
    dw      offset error            ;6     ;-10
    dw      offset Call_GSWD        ;8     ;-12 GWL_ID
    dw      offset error            ;10    ;-14
    dw      offset Call_GSWD        ;12    ;-16 GWL_STYLE
    dw      offset error            ;14    ;-18
    dw      offset Call_GSWD        ;16    ;-20 GWL_EXSTYLE
    ;; No need to add one more entry for -21 (GWL_USERDATA) because this is
    ;; the only Odd index we handle it as a special case eariler.
MAX_INDEX equ ($-apfnSet)

    .errnz GWL_WNDPROC    +  4
    .errnz GWL_HINSTANCE  +  6
    .errnz GWL_HWNDPARENT +  8
    .errnz GWL_ID         + 12
    .errnz GWL_STYLE      + 16
    .errnz GWL_EXSTYLE    + 20
    .errnz GWL_USERDATA   + 21

    .errnz GWW_HINSTANCE  +  6
    .errnz GWW_HWNDPARENT +  8

SWD_wndproc:
    push    dword ptr bp_dwValue
    mov     eax, CBID_WNDPROC
    cmp     word ptr bp_nIndex, DWL_DLGPROC
    jne     @F

    ; Is window really a dialog!  If not, skip this.
    mov     eax, CBID_DLGPROC
@@:
    push    eax
    call    GetStdCBSL
    mov     dword ptr bp_dwValue, eax
    jmp     Call_GSWD

SWD_hinst:
    mov     eax, dword ptr bp_dwValue
    call    MaphinstLS
    movzx   eax, ax
    mov     dword ptr bp_dwValue, eax
    ; FALL THRU

Call_GSWD:
    push    word ptr bp_hwnd
    push    word ptr bp_nIndex
    push    dword ptr bp_dwValue
    push    word ptr bp_nFlags
    call    GetSetWindowData
    DXAX2EAX

    ;
    ; Now thunk return value.  Note that up above, we already did the
    ; sanity checking on indeces < 0, so we don't have to do it again.
    ;
    mov     bx, word ptr bp_nIndex
    cmp     bx, 0
    jl      @F

    cmp     bx, DWL_DLGPROC
    jne     GSWD_return

    cmp     word ptr bp_isdialog, 0
    jz      GSWD_return

    jmp     GWD_wndproc

@@:
    cmp     bx, GWL_USERDATA
    je      GSWD_return

    neg     bx
    add     bx,GWL_WNDPROC
    jmp     cs:apfnGet[bx]

apfnGet label word
    dw      offset GWD_wndproc      ;0     ; -4 GWL_WNDPROC
    dw      offset GWD_hinst        ;2     ; -6 GWL_HINSTANCE
    dw      offset GSWD_return      ;4     ; -8 GWL_HWNDPARENT
    dw      offset error            ;6     ;-10
    dw      offset GSWD_return      ;8     ;-12 GWL_ID
    dw      offset error            ;10    ;-14
    dw      offset GSWD_return      ;12    ;-16 GWL_STYLE
    dw      offset error            ;14    ;-18
    dw      offset GSWD_return      ;16    ;-20 GWL_EXSTYLE

GWD_wndproc:
    push    eax
    mov     eax, CBID_WNDPROC
    cmp     word ptr bp_nIndex, DWL_DLGPROC
    jne     @F
    mov     eax, CBID_DLGPROC

@@:
    push    eax
    call    GetStdCBLS
    jmp     GSWD_return

GWD_hinst:
    call    MaphinstSL
    jmp     GSWD_return

error:
    xor     eax, eax

GSWD_return:
    ; Get rid of local word storage
    add     sp, 2
endm


;-----------------------------------------------------------------------;
; body_GETSETCLASSDATA
;-----------------------------------------------------------------------;
body_GETSETCLASSDATA macro
    local exit
    local Call_GCSD
    local SCD_ptr
    local SCD_hinst
    local SCD_wndproc
    local GCD_ptr
    local GCD_hinst
    local GCD_wndproc
    local error
    local apfnSet
    local apfnGet
    local have_stub
    local MAX_INDEX

bp_hwnd         equ <bp_top>
bp_nIndex       equ <bp_top+4>
bp_dwData       equ <bp_top+8>
bp_nFlags       equ <bp_top+12>

    ; We do this up front for index validation.
    ; Is index private (>= 0) or not in system range?  If so, no thunking.
    mov     bx, word ptr bp_nIndex
    cmp     bx, 0
    jge     Call_GSCD

    neg     bx
    add     bx,GCL_MENUNAME
    .errnz  GCL_MENUNAME + 8
    jl      error
    cmp     bx,MAX_INDEX
    jge     error
    test    bl, 1
    jnz     error                   ;don't allow odd indices

    test    word ptr bp_nFlags, DATA_SET
    jz      Call_GSCD
    jmp     cs:apfnSet[bx]

apfnSet label word
    dw      offset SCD_ptr          ;0      ; - 8  GCL_MENUNAME
    dw      offset Call_GSCD        ;2      ; -10  GCL_HBRBACKGROUND
    dw      offset Call_GSCD        ;4      ; -12  GCL_HCURSOR
    dw      offset Call_GSCD        ;6      ; -14  GCL_HICON
    dw      offset SCD_hinst        ;8      ; -16  GCL_HMODULE
    dw      offset Call_GSCD        ;10     ; -18  GCL_CBWNDEXTRA
    dw      offset Call_GSCD        ;12     ; -20  GCL_CBCLSEXTRA
    dw      offset error            ;14
    dw      offset SCD_wndproc      ;16     ; -24  GCL_WNDPROC
    dw      offset Call_GSCD        ;18     ; -26  GCL_STYLE
    dw      offset error            ;20
    dw      offset error            ;22
    dw      offset Call_GSCD        ;24     ; -32  GCW_ATOM
    dw      offset Call_GSCD        ;26     ; -34  GCW_HICONSM
MAX_INDEX equ ($ - apfnSet)

    .errnz    8 + GCL_MENUNAME
    .errnz   10 + GCW_HBRBACKGROUND
    .errnz   12 + GCW_HCURSOR
    .errnz   14 + GCW_HICON
    .errnz   16 + GCW_HMODULE
    .errnz   18 + GCW_CBWNDEXTRA
    .errnz   20 + GCW_CBCLSEXTRA
    .errnz   24 + GCL_WNDPROC
    .errnz   26 + GCL_STYLE
    .errnz   32 + GCW_ATOM
    .errnz   34 + GCW_HICONSM


SCD_ptr:
    push    dword ptr bp_dwData
    call    MapLS
    mov     dword ptr bp_dwData, eax
    jmp     Call_GSCD

SCD_wndproc:
    push    dword ptr bp_dwData
    push    dword ptr CBID_WNDPROC
    call    GetStdCBSL
    mov     dword ptr bp_dwData, eax
    jmp     Call_GSCD

SCD_hinst:
    mov     eax, dword ptr bp_dwData
    call    MaphinstLS
    movzx   eax, ax
    mov     dword ptr bp_dwData, eax
    ; FALL THRU

Call_GSCD:
    push    word ptr bp_hwnd
    push    word ptr bp_nIndex
    push    dword ptr bp_dwData
    push    word ptr bp_nFlags
    call    GetSetClassData
    DXAX2EAX

    ;
    ; Now thunk return value.  Note that up above, we already did the
    ; sanity checking on indeces < 0, so we don't have to do it again.
    ;
    mov     bx, word ptr bp_nIndex
    cmp     bx, 0
    jge     GSCD_return

    neg     bx
    add     bx,GCL_MENUNAME
    jmp     cs:apfnGet[bx]

apfnGet label word
    dw      offset GCD_ptr          ;0      ; - 8  GCL_MENUNAME
    dw      offset GSCD_return      ;2      ; -10  GCW_HBRBACKGROUND
    dw      offset GSCD_return      ;4      ; -12  GCW_HCURSOR
    dw      offset GSCD_return      ;6      ; -14  GCW_HICON
    dw      offset GCD_hinst        ;8      ; -16  GCW_HMODULE
    dw      offset GSCD_return      ;10     ; -18  GCW_CBWNDEXTRA
    dw      offset GSCD_return      ;12     ; -20  GCW_CBCLSEXTRA
    dw      offset error            ;14
    dw      offset GCD_wndproc      ;16     ; -24  GCL_WNDPROC
    dw      offset GSCD_return      ;18     ; -26  GCL_STYLE
    dw      offset error            ;20
    dw      offset error            ;22
    dw      offset GSCD_return      ;24     ; -32  GCW_ATOM
    dw      offset GSCD_return      ;26     ; -34  GCW_HICONSM

GCD_ptr:
    ; This is OK.
    ; User's DS doesn't move in linear memory.  And menu strings are
    ; LocalAlloced() out of User's DS.
    push    eax
    call    MapSL
    jmp     GSCD_return

GCD_hinst:
    call    MaphinstSL
    jmp     GSCD_return

GCD_wndproc:
    push    eax
    push    dword ptr CBID_WNDPROC
    call    GetStdCBLS
    jmp     GSCD_return

error:
    xor     eax, eax

GSCD_return:
endm




;-------------------------------------------------------------------------
; DdeAccessData(), DdeUnAccessData()
;
; HACK! DDEML stores the data in movable Win16 global handles, so
; *we* have to fix the handle whenever the app holds a linear address to it.
; This means groveling around in ddeml's data structures to retrieve
; the global handle from the DDE data handle.
;
; No, we can't just copy the data either. DdeAccessData() returns a
; read/write pointer.
;
; BUGBUG! Doesn't repack metafiles yet. For M6, write a support routine
; inside ddeml to handle all this stuff, and get rid of this hack.
;
;-------------------------------------------------------------------------

HDDEDATA_GHND   equ 4

PUSH__DDEACCESSDATA_hData macro iOffset, iJunk

    push    es
    les     bx, [bp + iOffset]
    mov     ax, es:[bx + HDDEDATA_GHND]
    pop     es
    push    ax
    call    GlobalFix

    push    dword ptr [bp + iOffset]


endm ;PUSH__DDEACCESSDATA_hData


PUSH__DDEUNACCESSDATA_hData macro   iOffset, iJunk

    push    es
    les     bx, [bp + iOffset]
    mov     ax, es:[bx + HDDEDATA_GHND]
    pop     es
    push    ax
    call    GlobalUnFix

    push    dword ptr [bp + iOffset]


endm ;PUSH__DDEUNACCESSDATA_hData





;***************************************************************************
;  PackDDELParam and friends.
;
;  WARNING: A lot of thunking depends on the fact that PackDDELParam requires
;  no explicit cleanup whatsoever. If you're thinking of changing that,
;  think again.
;
;  The value returned by PackDDELParam is a ready-to-be-used Win16
;  DDE lparam. The message thunks pass this through with no further
;  translation (*). Through the magic of handle grouping, FreeDDELParam
;  has to do absolutely nothing.
;
;  (*) Except for WM_DDE_EXECUTE. It will translate the handle in the
;  message thunk instead of in PackDDELParam. This allows Win32 apps
;  to neglect PackDDELParam for WM_DDE_EXECUTE: which works on both
;  NT and Win32s. (They can't ignore it on the WM_DDE_ACK, however.
;  NT & Win32s don't allow this either.)
;
;***************************************************************************

;-----------------------------------------------------------------------;
; body_PACKDDELPARAM
;-----------------------------------------------------------------------;
body_PACKDDELPARAM macro

    local   wMsg, dwLo, dwHi

    local   exit
    local   pack_execute
    local   pack_default
    local   pack_ddeack, pack_maplo

wMsg    equ [bp_top]
dwLo    equ [bp_top+4]
dwHi    equ [bp_top+8]



    mov     ax,word ptr wMsg
    cmp     ax, WM_DDE_EXECUTE
    je      pack_execute

    cmp     ax, WM_DDE_ACK
    je      pack_mapddeack
    cmp     ax, WM_DDE_ADVISE
    je      pack_maplo
    cmp     ax, WM_DDE_DATA
    je      pack_maplo
    cmp     ax, WM_DDE_POKE
    je      pack_maplo

; WM_DDE_REQUEST or WM_DDE_UNADVISE
;
;   Both dwLo & dwHi are 16-bit significant only, so just mush them
;   together. Note that a Win32 app could get away without calling
;   PackDDELParam for these messages. But NT and Win32s support this,
;   so we will too.
pack_default:
    mov ax, word ptr dwHi
    shl eax,16
    mov ax, word ptr dwLo
    jmp exit


; WM_DDE_EXECUTE: Just pass it along. Message thunk must do handle
; conversion. We'd prefer to do the conversion here but then, an app
; is forced to use PackDDElParam. But NT and Win32s allow them to
; neglect that -- so we must too.
pack_execute:
    mov eax, dword ptr dwHi
    jmp exit

; WM_DDE_ACK:
;
;   Hi dword is either a Win32 global handle or an atom. Fortunately,
;   we can distinguish the two by examining the high word.
;
;
pack_mapddeack:
    cmp word ptr dwHi+2, 0   ;Handle or atom?
    je  pack_default

    push    word ptr wMsg
    push    dword ptr dwHi
    call    ConvertDDEHandleLS   ;This routine requires no cleanup
    movzx   eax,ax
    or  ax,ax
    jz  exit
    shl eax,16
    mov ax, word ptr dwLo   ;ax == status word
    jmp exit

; WM_DDE_ADVISE, WM_DDE_DATA, WM_DDE_POKE
pack_maplo:
    push    word ptr wMsg
    push    dword ptr dwLo
    call    ConvertDDEHandleLS   ;This routine requires no cleanup
    movzx   eax,ax
    or  ax,ax
    jz  exit
    mov cx,ax
    mov ax, word ptr dwHi   ;ax == status word
    shl eax,16
    mov ax,cx
;Fall thru to exit

exit:
endm ;body_PACKDDELPARAM


;-----------------------------------------------------------------------;
; body_UNPACKDDELPARAM
;-----------------------------------------------------------------------;
body_UNPACKDDELPARAM macro
    local   exit
    local   unpack_execute
    local   unpack_default
    local   unpack_ddeack, unpack_maplo
    local   storeit
    local   didhi,didlo

    local   wMsg,dwLParam,puLo,puHi
wMsg    equ [bp_top]
dwLParam equ    [bp_top+4]
puLo    equ [bp_top+8]
puHi    equ [bp_top+12]


    mov ax,word ptr wMsg
    cmp ax, WM_DDE_EXECUTE
    je  unpack_execute

    cmp ax, WM_DDE_ACK
    je  unpack_ddeack
    cmp ax, WM_DDE_ADVISE
    je  unpack_maplo
    cmp ax, WM_DDE_DATA
    je  unpack_maplo
    cmp ax, WM_DDE_POKE
    je  unpack_maplo

; WM_DDE_REQUEST or WM_DDE_UNADVISE
;
;   Both dwLo & dwHi are 16-bit significant only, so just mush them
;   together. Note that a Win32 app could get away without calling
;   PackDDELParam for these messages. But NT and Win32s support this,
;   so we will too.
unpack_default:
    mov     eax,dwLParam
    mov     edx,eax
    and     eax,0ffffh  ;EAX = lo word
    shr     edx,16      ;EDX = hi word
    jmp     storeit


; WM_DDE_EXECUTE: Message thunk already converted handle. Put it back
; in puHi. We'd prefer to the conversion here but then, an app
; is forced to use PackDDElParam. But NT and Win32s allow them to
; neglect that -- so we must too.
unpack_execute:
    mov     edx, dwLParam
    xor     eax,eax
    jmp     storeit

; WM_DDE_ACK:
;       Hi-word is either a global Win16 handle or atom.
;
;   No easy way tell which. Pass the buck to kernel.
unpack_ddeack:
    push    dword ptr dwLParam
    call    IsThisADDEExecuteHandle
    or  ax,ax
    jz  unpack_default

; Yes, this code is unused for M5 but it's tested and we *will* be using
; it for M6 so don't you dare delete it!
    push    word ptr wMsg
    push    word ptr dwLParam+2
    call    ConvertDDEHandleSL   ;This routine requires no cleanup
    test    eax,eax
    jz      exit
    mov     edx,eax
    movzx   eax, word ptr dwLParam
    jmp     storeit


; WM_DDE_ADVISE, WM_DDE_DATA, WM_DDE_POKE
unpack_maplo:
    push    word ptr wMsg
    push    word ptr dwLParam
    call    ConvertDDEHandleSL   ;This routine requires no cleanup
    test    eax,eax
    jz      exit
    movzx   edx, word ptr dwLParam+2
; Fall through to storeit

storeit:
    mov     ds,FlatData             ; ds:esi == source address
    mov     edi, puLo
    or      edi, edi
    jz      didlo
    mov     [edi],eax
didlo:
    mov     edi, puHi
    or      edi, edi
    jz      didhi
    mov     [edi],edx
didhi:
    mov     eax,1
    jmp     exit

unpack_badparam:
    xor eax,eax
;Fall thru to exit

exit:
endm


;-----------------------------------------------------------------------;
; body_FREEDDELPARAM
;
; Through the magic of handle grouping, no action is required here.
; If you ever change this, you'll also have to make the message thunks
; thunks clean up temporary lparams.
;-----------------------------------------------------------------------;
body_FREEDDELPARAM macro
    xor     eax,eax
    inc     eax
endm



;-----------------------------------------------------------------------;
; body_DDEQUERYCONVINFO
;-----------------------------------------------------------------------;
body_DDEQUERYCONVINFO macro
    local next, L1, L2
    local bp_hConv, bp_idTransaction, bp_lpConvInfo
    local bp_hwnd, bp_hwndPartner;

bp_hConv                equ     <bp_top>
bp_idTransaction        equ     <bp_top+4>
bp_lpConvInfo           equ     <bp_top+8>

bp_hwnd         equ word ptr [bp-6]
bp_hwndPartner      equ word ptr [bp-8]



    xor     eax,eax
    push    eax                     ; ptr param #1   pConvInfo
    push    eax             ; store hwnd field
    push    eax             ; store hwndPartner field

; pConvInfo
; pointer struct CONVINFO32 --> struct CONVINFO16
    cld                             ; esi, edi will increment

    sub     sp,CONVINFO16_SIZE              ; pConvInfo alloc space on stack

; different pointer types
    mov     eax,DWORD ptr bp_lpConvInfo     ; base address
    test    eax,eax
    jz      L1                    ; skip if null


; structures are not identical
; structures don't have pointers

    mov     [bp-4],sp               ; save offset to buffer
    mov     [bp-2],ss               ; save selector to buffer

    mov     di,ss
    mov     es,di
    movzx   edi,sp                  ; es:edi == destination address

    mov     esi,eax
    mov     ds,FlatData

    ncopyd  7
    ncopyt  5
    copyd

    lodsd   ds:[esi]
    mov     ax, CONVCONTEXT16_SIZE
    stosw

    ncopyt  3
    ncopyd  2
L1:

; *** END   parameter packing
;-------------------------------------
; create new call frame and make the call

; hConv  from: unsigned long
    push    dword ptr bp_hConv       ; to unsigned long

; idTransaction  from: unsigned long
    push    dword ptr bp_idTransaction       ; to unsigned long

; pConvInfo  from: struct CONVINFO32
    mov     eax,[bp-4]
    push    eax
    test    eax,eax
    jz      next

    movzx   eax,ax
    mov     word ptr ss:[eax].ci16_cb,CONVINFO16_SIZE
    mov     word ptr ss:[eax].ci16_ConvCtxt.cc16_cb,CONVCONTEXT16_SIZE
next:
    call    DdeQueryConvInfo                ; call 16-bit version
    movzx   eax,ax
    test    eax,eax
    jz      L2

;-------------------------------------
; *** BEGIN parameter unpacking

    cld                             ; esi, edi will increment

; pConvInfo
; pointer struct CONVINFO16 --> struct CONVINFO32
    mov     eax,DWORD ptr bp_lpConvInfo             ; base address
    test    eax,eax
    jz      L2                    ; skip if null


; structures are not identical
; structures don't have pointers

    mov     si, seg FlatData
    mov     es, si
    mov     es, es:[FlatData]
    mov     edi,eax                 ; es:edi == destination address
    mov     si,ss
    mov     ds,si
    movzx   esi,word ptr [bp-4]             ; ds:esi == source address

; cb
; unsigned long --> unsigned long
    mov     dword ptr ds:[esi], CONVINFO32_SIZE

    ncopyd  7
    ncopyzx 5
    copyd

    mov     word ptr ds:[esi], CONVCONTEXT32_SIZE
    ncopyzx 3

    copysx

    ncopyd  2


    xor     eax,eax

    ; Put dummy bytes into SECURITY_QUALITY_OF_SERVICE
    mov     eax, 0ch    ;SIZEOF(SECURITY_QUALITY_OF_SERVICE)
    stosd   es:[edi]
    xor     eax,eax
    stosd   es:[edi]
    stosd   es:[edi]

    push    es
    push    edi

    push    dword ptr bp_hConv
    mov     ax, ss
    push    ax
    lea     cx, bp_hwnd
    push    cx
    mov     ax, ss
    push    ax
    lea     cx, bp_hwndPartner
    push    cx
    call    GetHCONVWindows

    pop     edi
    pop     es

    movzx   eax,ax
    or      ax,ax
    jz      L2

    movzx   eax, bp_hwnd
    stosd   es:[edi]
    movzx   eax, bp_hwndPartner
    stosd   es:[edi]



    mov     eax, CONVINFO32_SIZE

L2:
endm



;----------------------------------------------------------------------------
;
;   GetClassInfoExA()
;
;----------------------------------------------------------------------------
body_GETCLASSINFOEXA macro
    local   L238
    local   PushInstance
    local   PushClassName
    local   StoreWndProc
    local   StoreMenuName
    local   Cleanup

bp_hInstance            equ <bp_top + 0>
bp_lpszClassName        equ <bp_top + 4>
bp_lpwc32               equ <bp_top + 8>

bp_lpszClassNameTemp    equ <[bp - 4]>

    ; Skip this if lpsz32 or lpwc32 is NULL
    mov     eax, bp_lpszClassName
    test    eax,eax
    jz      L238            ; skip if null
    mov     eax, bp_lpwc32
    test    eax, eax
    jz      L238

    ; Save space for lpszClassNameTemp
    xor     eax, eax
    push    eax

    ; Get lpWndClassEx16
    sub     sp,WNDCLASSEX16_SIZE    ; lpWndClassEx alloc space on stack
    movzx   esi,sp                  ; ds:esi == destination address
    mov     dword ptr ss:[esi], WNDCLASSEX16_SIZE

    ;
    ; Push 16-bit parameters
    ;

    ; hInstance:  can be NULL (for system class)
    mov     eax, bp_hInstance
    test    eax, eax
    jz      PushInstance
    call    MaphInstLS
PushInstance:
    push    ax

    ; lpszClassName:  can be atom or string
    push    dword ptr bp_lpszClassName
    call    MapLS
    mov     bp_lpszClassNameTemp, eax
    push    eax

    ; lpwc16
    push    ss
    push    si

    ;
    ; Make 16-bit call
    ; ZERO-EXTEND return value.  Some apps know it's not really a BOOL,
    ; it's an ATOM and save the entire DWORD away to compare later.
    ;
    call    GetClassInfoEx
    movzx   eax, ax

    ; Save return value
    push    eax
    test    eax, eax
    jz      Cleanup

    ;
    ; Convert WNDCLASSEX from 16 to 32
    ;
    mov     es, FlatData
    mov     edi, bp_lpwc32

    push    ds
    mov     ax, ss
    mov     ds, ax
    cld

    ;;Skip size
    add     esi, 4
    add     edi, 4

    ; style
    copyd

    ; lpfnWndProc
    lodsd   ds:[esi]
    push    es
    push    eax
    push    dword ptr CBID_WNDPROC
    call    GetStdCBLS
    pop     es
    stosd   es:[edi]

    ; cbClsExtra, cbWndExtra
    ncopyzx 2

    ; hInstance
    lodsw   ds:[esi]                    ; hInstance
    mov     eax, bp_hInstance
    stosd   es:[edi]

    ; hIcon, hCursor, hbrBackground
    ncopyzx  3

    ; lpszMenuName
    lodsd   ds:[esi]
    push    eax
    call    MapSL   ;BUGBUG! GetClassInfo
    stosd   es:[edi]

    ; lpszClassName:  Just use what was passed in, just like User16 does!
    lodsd   ds:[esi]
    mov     eax, dword ptr bp_lpszClassName
    stosd   es:[edi]

    ; hIconSm
    copyzx

    pop     ds

Cleanup:
    pushd   bp_lpszClassNameTemp
    call    UnmapLS
    pop     eax
L238:
endm



;===========================================
; BOGUS
; Same code for mapping instances everywhere
;===========================================


;-----------------------------------------------------------------------;
; PUSH__DDECONNECT_pCC
;-----------------------------------------------------------------------;
PUSH__DDECONNECT_pCC macro iOffset, iTempOffset
    local   done

    mov     eax,[bp-iTempOffset]
    push    eax
    test    eax,eax
    jz      done

    movzx   eax,ax
    mov     word ptr ss:[eax].cc16_cb,CONVCONTEXT16_SIZE
done:
endm

;-----------------------------------------------------------------------;
; PUSH__DDECONNECTLIST_pCC
;-----------------------------------------------------------------------;
PUSH__DDECONNECTLIST_pCC macro iOffset, iTempOffset
    local   done

    mov     eax,[bp-iTempOffset]
    push    eax
    test    eax,eax
    jz      done

    movzx   eax,ax
    mov     word ptr ss:[eax].cc16_cb,CONVCONTEXT16_SIZE
done:
endm


;-----------------------------------------------------------------------;
; body_CREATEWINDOWEXA
;-----------------------------------------------------------------------;
body_CREATEWINDOWEXA macro
    local null_ptr1
    local store_ptr1
    local null_ptr2
    local have_x
    local have_width
    local ismdi
    local isnotmdi
    local done_with_lpParam

BODY_PARAM_16   bp_dwExStyle,     0
BODY_PARAM_16   bp_lpClassName,   4
BODY_PARAM_16   bp_lpWindowName,  8
BODY_PARAM_16   bp_dwStyle,       12
BODY_PARAM_16   bp_X,             16
BODY_PARAM_16   bp_Y,             20
BODY_PARAM_16   bp_nWidth,        24
BODY_PARAM_16   bp_nHeight,       28
BODY_PARAM_16   bp_hWndParent,    32
BODY_PARAM_16   bp_hMenu,         36
BODY_PARAM_16   bp_hInstance,     40
BODY_PARAM_16   bp_lpParam,       44

bp_lpClassNameTemp  equ <[bp-4]>
bp_lpWindowNameTemp equ <[bp-8]>
bp_lpParamTemp      equ <[bp-12]>
bp_couldbemdi       equ <[bp-14]>
; temp storage

    xor     eax,eax
    push    eax                     ; ptr param #1   lpClassNameTemp
    push    eax                     ; ptr param #2   lpWindowNameTemp
    push    eax                     ; ptr param #3   lpParamTemp
    inc     ax
    push    ax                      ; wrd param #4   couldbemdi (set to 1)

    mov     cx, word ptr bp_lpClassName+2
    jcxz    notmdi              ; Passed in an atom?

    mov     eax, dword ptr bp_lpClassName
    mov     es,  FlatData
    mov     eax, es:[eax]
    cmp     eax, 'CIDM'         ; Check for MDIC
    je      ismdi
    cmp     eax, 'cidm'         ; and in lower case...
    je      ismdi
notmdi:
    dec     word ptr bp_couldbemdi  ; dec to 0
ismdi:

    push    dword ptr bp_lpClassName
    call    MapLS   ;PLUGGED
    mov     bp_lpClassNameTemp,eax

    push    dword ptr bp_lpWindowName
    call    MapLS   ;PLUGGED
    mov     bp_lpWindowNameTemp,eax

; lpParam is pointer to CLIENTCREATESTRUCT if class is mdiclient, otherwise
; it's just a dword.

    mov     cx, word ptr bp_couldbemdi
    jcxz    isnotmdi
    push    dword ptr bp_lpClassNameTemp
    call    IsClassNameMDICLIENT
    test    ax,ax
    jnz     CreateMdi

isnotmdi:
    push    dword ptr bp_lpParam
    call    MapLS
    mov     bp_lpParamTemp, eax
    mov     bp_lpParam, eax
    jmp     done_with_lpParam

; lpParam points to CLIENTCREATESTRUCT, so repack it and update
; bp_lpParamTemp

CreateMdi:
;CLIENTCREATESTRUCT:
; HWND
; UINT

    mov     es, FlatData
    mov     ecx,dword ptr bp_lpParam
    push    word ptr es:[ecx+4]     ;truncate UINT
    push    word ptr es:[ecx]       ;truncate HWND
    mov     bp_lpParam[0],sp    ;store new pointer to struct
    mov     bp_lpParam[2],ss

done_with_lpParam:

    push    dword ptr bp_dwExStyle
    push    dword ptr bp_lpClassNameTemp
    push    dword ptr bp_lpWindowNameTemp
    push    dword ptr bp_dwStyle

    ; x, y, cx, cy
    mov     eax, dword ptr bp_X
    cmp     eax, 80000000h                   ; CW_USEDEFAULT
    jne     have_x
    ror     eax,16                  ; map to 8000h
have_x:
    push    ax

    mov     eax, dword ptr bp_Y
    cmp     eax, 80000000h
    jne     have_y
    ror     eax,16
have_y:
    push    ax

    mov     eax,dword ptr bp_nWidth
    cmp     eax,80000000h                   ; CW_USEDEFAULT
    jne     have_cx
    ror     eax,16                  ; map to 8000h
have_cx:
    push    ax

    mov     eax,dword ptr bp_nHeight
    cmp     eax,80000000h
    jne     have_cy
    ror     eax,16
have_cy:
    push    ax

    push    word ptr bp_hWndParent

    ; push LOWORD of hMenu
    push    word ptr bp_hMenu.lo

    ; hInstance
    MAP_NULL_HINST bp_hInstance
    push    ax

    ; lpParams
    push    dword ptr bp_lpParam

    ; push HIWORD of hMenu
    push    word ptr bp_hMenu.hi

    call    CreateWindowEx32        ; call 16-bit version
    movzx   eax,ax

    push    eax
    pushd   bp_lpParamTemp
    call    UnmapLS
    pushd   bp_lpClassNameTemp
    call    UnmapLS
    pushd   bp_lpWindowNameTemp
    call    UnmapLS
    pop eax
endm


;-----------------------------------------------------------------------;
; body_DDECLIENTTRANSACTION
;-----------------------------------------------------------------------;
body_DDECLIENTTRANSACTION macro
    local   dometafile
    local   null_ptr1
    local   null_ptr2
    local   dct_leave

BODY_PARAM_16  bp_pData,       0
BODY_PARAM_16  bp_cbData,      4
BODY_PARAM_16  bp_hConv,       8
BODY_PARAM_16  bp_hszItem,     12
BODY_PARAM_16  bp_wFmt,        16
BODY_PARAM_16  bp_wType,       20
BODY_PARAM_16  bp_dwTimeout,   24
BODY_PARAM_16  bp_pdwResult,   28

bp_pDataTemp       equ <[bp-4]>
bp_pdwResultTemp   equ <[bp-8]>
bp_pDataTempSel    equ <[bp-12]>

    xor     eax,eax
    push    dword ptr bp_pData      ; bp_pDataTemp:     ptr param #1   pData
    push    eax                     ; bp_pdwResultTemp: ptr param #2   pdwResult
    push    eax         ; bp_pDataTempSel:  Sel for pData

;If cbData == -1, then pData is a handle, not a pointer.
    cmp dword ptr bp_cbData, -1
    jz      null_ptr1
    cmp dword ptr bp_pData, 0
    jz      null_ptr1


    cmp word ptr bp_wFmt, CF_METAFILEPICT
    je  dometafile

    push    dword ptr bp_pData
    call    MapLS   ;PLUGGED
    mov     bp_pDataTemp,eax
    mov     bp_pDataTempSel,eax
    jmp null_ptr1

dometafile:
    mov     ds, FlatData
    mov     esi, bp_pData
    push    word ptr CF_METAFILEPICT
    push    dword ptr [esi]
    push    word ptr 0
    call    ConvertCFDataLS
    movzx   eax,ax
    or  ax,ax
    jz  dct_leave

; We'll use bp_pData as our (2-byte) substitute data buffer.
    mov bp_pData,ax
    mov word ptr bp_cbData,2
    mov ax,ss
    mov bp_pDataTemp,ax
    lea di,bp_pData
    mov bp_pDataTemp+2,di

null_ptr1:

    push    dword ptr bp_pdwResult
    call    MapLS   ;PLUGGED
    mov     bp_pdwResultTemp,eax
null_ptr2:

    push    dword ptr bp_pDataTemp
    push    dword ptr bp_cbData
    push    dword ptr bp_hConv
    push    dword ptr bp_hszItem
    push    word ptr bp_wFmt
    push    word ptr bp_wType
    push    dword ptr bp_dwTimeout
    push    dword ptr bp_pdwResultTemp

    call    DDECLIENTTRANSACTION
    DXAX2EAX

dct_leave:
; We can safely unmap these. The api does not hold either pointer
; after it returns.
    push    eax
    push    dword ptr bp_pDataTempSel
    call    UnMapLS
    push    dword ptr bp_pdwResultTemp
    call    UnMapLS


IF 0
;!!! BUGBUG: The following is a gross M5 workaround for B#9814.
;!!! DdeClientTransaction takes our ss and stuffs it in a long-term data
;!!! structure. To prevent a subsequent GP fault, we'll replace ss
;!!! with a new one so that the thunk dispatcher won't unmap the one
;!!! that DdeClientTransaction so rudely took.
    mov ax,ss
    push    ax
    push    word ptr 0
    call    MapSL     ;This is ok: part of M5 hack anyway
    push    eax
    call    MapLS
    mov ss,dx
;!!! End of B#9814 workaround.
ENDIF

    pop eax
endm


;-----------------------------------------------------------------------;
; body_SYSTEMPARAMETERSINFOA
;-----------------------------------------------------------------------;
body_SYSTEMPARAMETERSINFOA macro
    local   exit, error_exit
    local   anpfnSPI, MAX_ACTION
    local   push_zero_0, push_fuwinini_0
    local   push_zero_1, push_fuwinini_1
    local   push_callframe_2, push_ax_2
    local   push_callframe_3, done_3

bp_uAction      equ     <bp_top>
bp_uParam       equ     <bp_top+4>
bp_lParam       equ     <bp_top+8>
bp_fuWinIni     equ     <bp_top+12>

;BP=SP upon entry

bp_pTmp         equ     <dword ptr [bp-4]>

    mov     ebx,dword ptr bp_uAction
    cmp     ebx,MAX_ACTION
    ja      check_new_actions

    add     bx,bx
    jmp     word ptr cs:anpfnSPI[bx]

check_new_actions:
    mov     dx, bx
    shr     bx, 12
    and     bx, 2
    and     dx, 1
    add     bx, dx

    cmp     bx,MAX_NEWACTION
    ja      error_exit

    add     bx,bx
    jmp     word ptr cs:anpfnNewSPI[bx]

anpfnNewSPI        label   word
    dw      offset thk_SPI_GETBOOLUSERPREFERENCE
    dw      offset thk_SPI_SETBOOLUSERPREFERENCE
    dw      offset thk_SPI_GETDWORDUSERPREFERENCE
    dw      offset thk_SPI_SETDWORDUSERPREFERENCE
MAX_NEWACTION equ ($ - anpfnNewSPI)/2

anpfnSPI        label   word
    dw      offset error_exit
    dw      offset thk_SPI_GETBEEP
    dw      offset thk_SPI_SETBEEP
    dw      offset thk_SPI_GETMOUSE
    dw      offset thk_SPI_SETMOUSE
    dw      offset thk_SPI_GETBORDER
    dw      offset thk_SPI_SETBORDER
    dw      offset error_exit
    dw      offset error_exit
    dw      offset error_exit
    dw      offset thk_SPI_GETKEYBOARDSPEED
    dw      offset thk_SPI_SETKEYBOARDSPEED
    dw      offset thk_SPI_LANGDRIVER
    dw      offset thk_SPI_ICONHORIZONTALSPACING
    dw      offset thk_SPI_GETSCREENSAVETIMEOUT
    dw      offset thk_SPI_SETSCREENSAVETIMEOUT
    dw      offset thk_SPI_GETSCREENSAVEACTIVE
    dw      offset thk_SPI_SETSCREENSAVEACTIVE
    dw      offset thk_SPI_GETGRIDGRANULARITY
    dw      offset thk_SPI_SETGRIDGRANULARITY
    dw      offset thk_SPI_SETDESKWALLPAPER
    dw      offset thk_SPI_SETDESKPATTERN
    dw      offset thk_SPI_GETKEYBOARDDELAY
    dw      offset thk_SPI_SETKEYBOARDDELAY
    dw      offset thk_SPI_ICONVERTICALSPACING
    dw      offset thk_SPI_GETICONTITLEWRAP
    dw      offset thk_SPI_SETICONTITLEWRAP
    dw      offset thk_SPI_GETMENUDROPALIGNMENT
    dw      offset thk_SPI_SETMENUDROPALIGNMENT
    dw      offset thk_SPI_SETDOUBLECLKWIDTH
    dw      offset thk_SPI_SETDOUBLECLKHEIGHT
    dw      offset thk_SPI_GETICONTITLELOGFONT
    dw      offset thk_SPI_SETDOUBLECLICKTIME
    dw      offset thk_SPI_SETMOUSEBUTTONSWAP
    dw      offset thk_SPI_SETICONTITLELOGFONT
    dw      offset thk_SPI_GETFASTTASKSWITCH
    dw      offset thk_SPI_SETFASTTASKSWITCH
    dw      offset thk_SPI_SETDRAGFULLWINDOWS
    dw      offset thk_SPI_GETDRAGFULLWINDOWS
    dw      offset thk_SPI_GETKEYBOARDLAYOUT
    dw      offset thk_SPI_SETKEYBOARDLAYOUT
    dw      offset thk_SPI_GETNONCLIENTMETRICS
    dw      offset thk_SPI_SETNONCLIENTMETRICS
    dw      offset thk_SPI_GETMINIMIZEDMETRICS
    dw      offset thk_SPI_SETMINIMIZEDMETRICS
    dw      offset thk_SPI_GETICONMETRICS
    dw      offset thk_SPI_SETICONMETRICS
    dw      offset thk_SPI_SETWORKAREA
    dw      offset thk_SPI_GETWORKAREA
    dw      offset thk_SPI_SETPENWINDOWS
    dw      offset thk_SPI_GETFILTERKEYS
    dw      offset thk_SPI_SETFILTERKEYS
    dw      offset thk_SPI_GETTOGGLEKEYS
    dw      offset thk_SPI_SETTOGGLEKEYS
    dw      offset thk_SPI_GETMOUSEKEYS
    dw      offset thk_SPI_SETMOUSEKEYS
    dw      offset thk_SPI_GETSHOWSOUNDS
    dw      offset thk_SPI_SETSHOWSOUNDS
    dw      offset thk_SPI_GETSTICKYKEYS
    dw      offset thk_SPI_SETSTICKYKEYS
    dw      offset thk_SPI_GETACCESSTIMEOUT
    dw      offset thk_SPI_SETACCESSTIMEOUT
    dw      offset thk_SPI_GETSERIALKEYS
    dw      offset thk_SPI_SETSERIALKEYS
    dw      offset thk_SPI_GETSOUNDSENTRY
    dw      offset thk_SPI_SETSOUNDSENTRY
    dw      offset thk_SPI_GETHIGHCONTRAST
    dw      offset thk_SPI_SETHIGHCONTRAST
    dw      offset thk_SPI_GETKEYBOARDPREF
    dw      offset thk_SPI_SETKEYBOARDPREF
    dw      offset thk_SPI_GETSCREENREADER
    dw      offset thk_SPI_SETSCREENREADER
    dw      offset thk_SPI_GETANIMATION
    dw      offset thk_SPI_SETANIMATION
    dw      offset thk_SPI_GETFONTSMOOTHING
    dw      offset thk_SPI_SETFONTSMOOTHING
    dw      offset thk_SPI_SETDRAGWIDTH
    dw      offset thk_SPI_SETDRAGHEIGHT
    dw      offset thk_SPI_SETHANDHELD
    dw      offset thk_SPI_GETLOWPOWERTIMEOUT
    dw      offset thk_SPI_GETPOWEROFFTIMEOUT
    dw      offset thk_SPI_SETLOWPOWERTIMEOUT
    dw      offset thk_SPI_SETPOWEROFFTIMEOUT
    dw      offset thk_SPI_GETLOWPOWERACTIVE
    dw      offset thk_SPI_GETPOWEROFFACTIVE
    dw      offset thk_SPI_SETLOWPOWERACTIVE
    dw      offset thk_SPI_SETPOWEROFFACTIVE
    dw      offset thk_SPI_SETCURSORS
    dw      offset thk_SPI_SETICONS
    dw      offset thk_SPI_GETDEFAULTINPUTLANG
    dw      offset thk_SPI_SETDEFAULTINPUTLANG
    dw      offset thk_SPI_SETLANGTOGGLE
    dw      offset thk_SPI_GETWINDOWSEXTENSION
    dw      offset thk_SPI_SETMOUSETRAILS
    dw      offset thk_SPI_GETMOUSETRAILS
    dw      offset thk_SPI_GETSNAPTODEFBUTTON
    dw      offset thk_SPI_SETSNAPTODEFBUTTON
    dw      offset thk_SPI_SETSCREENSAVERRUNNING    ; 97
    dw      offset thk_SPI_GETMOUSEHOVERWIDTH       ; 98
    dw      offset thk_SPI_SETMOUSEHOVERWIDTH       ; 99
    dw      offset thk_SPI_GETMOUSEHOVERHEIGHT      ; 100
    dw      offset thk_SPI_SETMOUSEHOVERHEIGHT      ; 101
    dw      offset thk_SPI_GETMOUSEHOVERTIME        ; 102
    dw      offset thk_SPI_SETMOUSEHOVERTIME        ; 103
    dw      offset thk_SPI_GETWHEELSCROLLLINES      ; 104
    dw      offset thk_SPI_SETWHEELSCROLLLINES      ; 105
    dw      offset thk_SPI_GETMENUSHOWDELAY         ; 106
    dw      offset thk_SPI_SETMENUSHOWDELAY         ; 107
    dw      offset thk_SPI_GETUSERPREFERENCE        ; 108
    dw      offset thk_SPI_SETUSERPREFERENCE        ; 109

ifdef FE_IME
    dw      offset thk_SPI_GETSHOWIMEUI             ; 110
    dw      offset thk_SPI_SETSHOWIMEUI             ; 111
else
    dw      offset error_exit                       ; 110
    dw      offset error_exit                       ; 111
endif
    dw      offset thk_SPI_GETMOUSESPEED            ; 112
    dw      offset thk_SPI_SETMOUSESPEED            ; 113
    dw      offset thk_SPI_GETSCREENSAVERRUNNING    ; 114

MAX_ACTION equ ($ - anpfnSPI)/2

;-----------------------------------------------------------------------;
; UNIMPLEMENTED
;-----------------------------------------------------------------------;
thk_SPI_GETMOUSEHOVERWIDTH:
thk_SPI_SETMOUSEHOVERWIDTH:
thk_SPI_GETMOUSEHOVERHEIGHT:
thk_SPI_SETMOUSEHOVERHEIGHT:
thk_SPI_GETMOUSEHOVERTIME:
thk_SPI_SETMOUSEHOVERTIME:
thk_SPI_GETUSERPREFERENCE:
thk_SPI_SETUSERPREFERENCE:
error_exit:
    sub     eax,eax
    jmp     exit


;-----------------------------------------------------------------------;
; uParam = UINT
; lParam = LPINT
;-----------------------------------------------------------------------;
thk_SPI_GETBEEP:
thk_SPI_GETBORDER:
thk_SPI_GETFASTTASKSWITCH:
thk_SPI_GETGRIDGRANULARITY:
thk_SPI_GETICONTITLEWRAP:
thk_SPI_GETKEYBOARDDELAY:
thk_SPI_GETKEYBOARDSPEED:
thk_SPI_GETMENUDROPALIGNMENT:
thk_SPI_GETSCREENSAVEACTIVE:
thk_SPI_GETSCREENSAVETIMEOUT:
thk_SPI_ICONHORIZONTALSPACING:
thk_SPI_ICONVERTICALSPACING:
thk_SPI_GETDRAGFULLWINDOWS:
thk_SPI_GETFONTSMOOTHING:
thk_SPI_GETMOUSETRAILS:
thk_SPI_GETSNAPTODEFBUTTON:
thk_SPI_SETSCREENSAVERRUNNING:
thk_SPI_GETBOOLUSERPREFERENCE:
thk_SPI_GETSCREENSAVERRUNNING:
ifdef FE_IME
thk_SPI_GETSHOWIMEUI:
endif

    push    byte ptr 0              ;reserve and init local var
    mov     ax,sp                   ;save addr of local var

    push    dword ptr bp_uAction
    push    word ptr bp_uParam
    mov     esi,bp_lParam
    test    esi,esi
    jz      push_zero_0

    push    ss
    push    ax
    jmp     short push_fuwinini_0

push_zero_0:
    push    esi

push_fuwinini_0:
    push    word ptr bp_fuWinIni
    call    SystemParametersInfo32
    cwde

    pop     cx                      ;recover local var value, clean stack

    mov     esi,bp_lParam
    test    esi,esi
    jz      exit                    ;if 0, all done

    mov     es,FlatData
    movsx   ecx,cx
    mov     es:[esi],ecx
    jmp     exit


;-----------------------------------------------------------------------;
; uParam = UINT
; lParam = DWORD
;-----------------------------------------------------------------------;
thk_SPI_SETBEEP:
thk_SPI_SETBORDER:
thk_SPI_SETDOUBLECLKHEIGHT:
thk_SPI_SETDOUBLECLICKTIME:
thk_SPI_SETDOUBLECLKWIDTH:
thk_SPI_SETFASTTASKSWITCH:
thk_SPI_SETGRIDGRANULARITY:
thk_SPI_SETICONTITLEWRAP:
thk_SPI_SETKEYBOARDDELAY:
thk_SPI_SETKEYBOARDSPEED:
thk_SPI_SETMENUDROPALIGNMENT:
thk_SPI_SETMOUSEBUTTONSWAP:
thk_SPI_SETSCREENSAVEACTIVE:
thk_SPI_SETSCREENSAVETIMEOUT:
thk_SPI_SETLOWPOWERTIMEOUT:
thk_SPI_SETPOWEROFFTIMEOUT:
thk_SPI_SETLOWPOWERACTIVE:
thk_SPI_SETPOWEROFFACTIVE:
thk_SPI_SETDRAGFULLWINDOWS:
thk_SPI_SETFONTSMOOTHING:
thk_SPI_SETPENWINDOWS:
thk_SPI_SETSHOWSOUNDS:
thk_SPI_SETKEYBOARDPREF:
thk_SPI_SETSCREENREADER:
thk_SPI_SETDRAGWIDTH:
thk_SPI_SETDRAGHEIGHT:
thk_SPI_SETCURSORS:
thk_SPI_SETICONS:
thk_SPI_SETLANGTOGGLE:
thk_SPI_GETWINDOWSEXTENSION:
thk_SPI_SETMOUSETRAILS:
thk_SPI_SETSNAPTODEFBUTTON:
thk_SPI_SETWHEELSCROLLLINES:
thk_SPI_SETMENUSHOWDELAY:
ifdef FE_IME
thk_SPI_SETSHOWIMEUI:
endif
thk_SPI_SETBOOLUSERPREFERENCE:
thk_SPI_SETDWORDUSERPREFERENCE:
thk_SPI_SETMOUSESPEED:

    push    dword ptr bp_uAction
    push    word ptr bp_uParam
    push    dword ptr bp_lParam
    push    word ptr bp_fuWinIni
    call    SystemParametersInfo32
    cwde
    jmp     exit

;-----------------------------------------------------------------------;
; uParam = WORD
; lParam = LPRECT
;-----------------------------------------------------------------------;
thk_SPI_SETWORKAREA:
thk_SPI_GETWORKAREA:

    ; We need scratch space for RECT16
    sub     sp, RECT16_SIZE
    mov     di,sp

    push    dword ptr bp_uAction
    push    word ptr bp_uParam

    mov     esi,bp_lParam
    test    esi,esi
    jnz     pack_lprect
    push    esi
    jmp     after_lprect

pack_lprect:
    ; Stick lprect16 address on stack first
    push    ss
    push    di

    ; Convert lprect32 (ds:esi) to lprect16 (es:di) before
    push    ds
    mov     ds, FlatData
    mov     ax, ss
    mov     es, ax
    cld

    PACK_RECT_32_16
    pop     ds

after_lprect:
    push    word ptr bp_fuWinIni
    call    SystemParametersInfo32
    cwde

    test    esi, esi
    jz      stack_clean

    ; Save return value and DS
    push    eax
    push    ds

    ; Setup lprc16 in DS:SI (remember--PACK_RECT_32_16 changed DI)
    ; Setup lprc32 in ES:EDI (remember--PACK_RECT_32_16 changed ESI)
    push    ss
    sub     di, RECT16_SIZE
    push    di

    mov     edi, esi
    sub     edi, RECT32_SIZE
    mov     es, FlatData

    pop     si
    pop     ds
    cld

    PACK_RECT_16_32
    pop     ds
    pop     eax

stack_clean:
    ; Clean the stack
    add     sp, RECT16_SIZE
    jmp     exit

;-----------------------------------------------------------------------;
; uParam = 0
; lParam = INT[3]
;-----------------------------------------------------------------------;
thk_SPI_GETMOUSE:
thk_SPI_SETMOUSE:

    sub     sp,6                    ;make space for local array
    mov     bx,sp                   ;save addr of local var

    push    dword ptr bp_uAction
    push    word ptr bp_uParam
    mov     esi,bp_lParam
    test    esi,esi
    jz      push_zero_1

    mov     es,FlatData
    mov     ax,es:[esi+0]
    mov     ss:[bx+0],ax
    mov     ax,es:[esi+4]
    mov     ss:[bx+2],ax
    mov     ax,es:[esi+8]
    mov     ss:[bx+4],ax

    push    ss
    push    bx
    jmp     short push_fuwinini_1

push_zero_1:
    push    esi

push_fuwinini_1:
    push    word ptr bp_fuWinIni
    call    SystemParametersInfo32
    cwde

    pop     bx                      ;recover local vars value, clean stack
    pop     cx
    pop     dx

    mov     esi,bp_lParam
    test    esi,esi
    jz      exit                    ;if 0, all done

    mov     es,FlatData
    movsx   ebx,bx
    mov     es:[esi+0],ebx
    movsx   ecx,cx
    mov     es:[esi+4],ecx
    movsx   edx,dx
    mov     es:[esi+8],edx
    jmp     exit

;-----------------------------------------------------------------------;
; uParam = 0
; lParam = LPFN
;-----------------------------------------------------------------------;
thk_SPI_SETHANDHELD:
    push    dword ptr bp_uAction                 ;pass uAction
    push    word ptr bp_uParam                  ;pass uParam
    push    dword ptr bp_lParam                 ;convert lParam to 16:16
    push    dword ptr  CBID_SENDMSGCALLBACK     ;sendmsg-type callback stub
    call    GetStdCBSL
    push    eax                                 ;pass pfn16 as lParam
    push    word ptr bp_fuWinIni
    call    SystemParametersInfo32
    cwde
    jmp     exit


;-----------------------------------------------------------------------;
; uParam = INT      (if cbSize, 16-bit & 32-bit structs have to be ==)
; lParam = LPVOID
;-----------------------------------------------------------------------;
thk_SPI_LANGDRIVER:
thk_SPI_SETKEYBOARDLAYOUT:
thk_SPI_GETKEYBOARDLAYOUT:
thk_SPI_SETDESKPATTERN:
thk_SPI_SETDESKWALLPAPER:
thk_SPI_GETNONCLIENTMETRICS:
thk_SPI_SETNONCLIENTMETRICS:
thk_SPI_GETMINIMIZEDMETRICS:
thk_SPI_SETMINIMIZEDMETRICS:
thk_SPI_GETANIMATION:
thk_SPI_SETANIMATION:
thk_SPI_GETICONMETRICS:
thk_SPI_SETICONMETRICS:
thk_SPI_GETFILTERKEYS:
thk_SPI_SETFILTERKEYS:
thk_SPI_GETTOGGLEKEYS:
thk_SPI_SETTOGGLEKEYS:
thk_SPI_GETMOUSEKEYS:
thk_SPI_SETMOUSEKEYS:
thk_SPI_GETSHOWSOUNDS:
thk_SPI_GETSTICKYKEYS:
thk_SPI_SETSTICKYKEYS:
thk_SPI_GETACCESSTIMEOUT:
thk_SPI_SETACCESSTIMEOUT:
thk_SPI_GETSERIALKEYS:
thk_SPI_SETSERIALKEYS:
thk_SPI_GETSOUNDSENTRY:
thk_SPI_SETSOUNDSENTRY:
thk_SPI_GETHIGHCONTRAST:
thk_SPI_SETHIGHCONTRAST:
thk_SPI_GETKEYBOARDPREF:
thk_SPI_GETSCREENREADER:
thk_SPI_GETDEFAULTINPUTLANG:
thk_SPI_SETDEFAULTINPUTLANG:
thk_SPI_GETWHEELSCROLLLINES:
thk_SPI_GETMENUSHOWDELAY:
thk_SPI_GETLOWPOWERACTIVE:
thk_SPI_GETPOWEROFFACTIVE:
thk_SPI_GETLOWPOWERTIMEOUT:
thk_SPI_GETPOWEROFFTIMEOUT:
thk_SPI_GETDWORDUSERPREFERENCE:
thk_SPI_GETMOUSESPEED:

    push    dword ptr bp_uAction
    push    word ptr bp_uParam
    push    dword ptr bp_lParam
    call    MapLS   ;PLUGGED
    mov     dword ptr bp_lParam,eax
    push    eax
    push    word ptr bp_fuWinIni
    call    SystemParametersInfo32
    cwde

    push    eax
    push    dword ptr bp_lParam
    call    UnmapLS
    pop     eax

    jmp     exit

;-----------------------------------------------------------------------;
; uParam = sizeof LOGFONT or 0
; lParam = input LPLOGFONT or 0
;-----------------------------------------------------------------------;
thk_SPI_SETICONTITLELOGFONT:

    sub     eax,eax
    push    eax                     ;reserve and init bp_pTmp

    mov     esi,bp_lParam
    test    esi,esi
    jz      push_callframe_2

    sub     sp,LOGFONT16_SIZE
    mov     ax,sp
    push    ds
    mov     ds,FlatData             ;DS:ESI --> 32-bit source
    mov     di,ss
    mov     es,di
    movzx   edi,ax                  ;ES:EDI --> 16-bit dest
    mov     word ptr bp_pTmp[0],di
    mov     word ptr bp_pTmp[2],es
    cld
    PACK_MLOGFONT_32_16
    pop     ds

push_callframe_2:
    push    dword ptr bp_uAction

    mov     ax,word ptr bp_uParam
    test    ax,ax
    jz      push_ax_2
    mov     ax,LOGFONT16_SIZE
push_ax_2:
    push    ax

    push    dword ptr bp_pTmp
    push    word ptr bp_fuWinIni
    call    SystemParametersInfo32
    cwde
    jmp     short exit

;-----------------------------------------------------------------------;
; uParam = sizeof LOGFONT
; lParam = output LPLOGFONT
;-----------------------------------------------------------------------;
thk_SPI_GETICONTITLELOGFONT:

    sub     eax,eax
    push    eax                     ;reserve and init bp_pTmp

    mov     edi,bp_lParam
    test    edi,edi
    jz      push_callframe_3

    sub     sp,LOGFONT16_SIZE
    mov     word ptr bp_pTmp[0],sp
    mov     word ptr bp_pTmp[2],ss

push_callframe_3:
    push    dword ptr bp_uAction
    push    byte ptr LOGFONT16_SIZE
    push    dword ptr bp_pTmp
    push    word ptr bp_fuWinIni
    call    SystemParametersInfo32
    cwde

    mov     edi,bp_lParam
    test    edi,edi
    jz      exit

    push    ds
    mov     es,FlatData             ;ES:EDI --> 32-bit source
    lds     si,bp_pTmp              ;DS:SI --> 16-bit dest
    movzx   esi,si                  ;DS:ESI --> 16-bit dest
    cld
    PACK_MLOGFONT_16_32
    pop     ds

exit:
    mov     sp,bp
endm



;-----------------------------------------------------------------------;
; body_LOADMENUINDIRECTA
;-----------------------------------------------------------------------;
body_LOADMENUINDIRECTA macro
    local   done

bp_lpmt        equ <bp_top>

bp_lpmt32Tmp   equ <dword ptr [bp-4]>
bp_hmem16Tmp   equ < word ptr [bp-6]>
bp_cbmt        equ < word ptr [bp-8]>
bp_mem32Menu   equ <dword ptr [bp-12]>

    xor     eax,eax
    push    eax
    push    eax
    push    eax

    push    dword ptr bp_lpmt
    call    MapLS   ;PLUGGED
    mov     bp_lpmt32Tmp,eax

    push    eax
    call    CountMenuU
    mov     bp_cbmt,ax

    push    byte ptr GHND
    movzx   eax,ax
    push    eax
    call    GlobalAlloc     ;if no scratch space, return no hmenu
    movzx   eax,ax          ;prepare for error
    test    ax,ax
    jz      done

    mov     bp_hmem16Tmp,ax

    push    ax
    push    ax
    call    GlobalFix
    call    GlobalLock
    push    dx
    push    ax
    call    MapSL   ;SAFE
    mov     bp_mem32Menu, eax

    mov     eax, bp_lpmt
    push    eax
    mov     ax, bp_cbmt
    movzx   eax, ax
    push    eax
    mov     eax, bp_mem32Menu
    push    eax
    call    ConvertMenu32


    mov     ax, bp_hmem16Tmp
    GMH2Sel ax              ;push this ahead of time for LoadMenuIndirect
    push    ax
    push    byte ptr 0

    ;push    bp_cbmt         ;cbIn
    ;push    ax              ;pOut
    ;push    byte ptr 0      ;
    ;push    bp_lpmt32Tmp    ;pIn
    ;call    ConvertMenuA    ;convert menu to win3.1 format

    call    LoadMenuIndirect ;param already pushed
    movzx   eax,ax

    push    eax
    push    bp_hmem16Tmp    ;cannot be null
    push    bp_hmem16Tmp
    push    bp_hmem16Tmp
    call    GlobalUnlock
    call    GlobalUnfix
    call    GlobalFree
    pop     eax

done:
    push    eax
    pushd   bp_lpmt32Tmp
    call    UnmapLS
    pop     eax
endm

;-----------------------------------------------------------------------;
; body_CREATEDIALOGINDIRECTPARAMA
;-----------------------------------------------------------------------;
body_CREATEDIALOGINDIRECTPARAMA macro
    local   done
    local   done_with_dlgproc

bp_hInstance            equ     <bp_top>
bp_hDialogTemplate      equ     <bp_top+4>
bp_hWndParent           equ     <bp_top+8>
bp_lpDialogFunc         equ     <bp_top+12>
bp_dwInitParam          equ     <bp_top+16>

bp_lpdt32Tmp   equ <dword ptr [bp-4]>
bp_hmem16Tmp   equ < word ptr [bp-6]>
bp_cbdt        equ < word ptr [bp-8]>
bp_mem32Dlg    equ <dword ptr [bp-12]>

    xor     eax,eax
    push    eax
    push    eax
    push    eax

    push    dword ptr bp_lpDialogTemplate
    call    MapLS   ;PLUGGED
    mov     bp_lpdt32Tmp,eax

    push    eax
    call    CountDialogU
    mov     bp_cbdt,ax

    push    byte ptr GPTR
    movzx   eax,ax
    push    eax
    call    GlobalAlloc     ;if no scratch space, return no hmenu
    movzx   eax,ax          ;prepare for error
    test    ax,ax
    jz      done

    mov     bp_hmem16Tmp,ax

    ; GPTR is GMEM_FIXED, so MapSL is safe
    push    ax
    push    0
    call    MapSL
    mov     bp_mem32Dlg, eax

    ;push    bp_cbdt         ;cbIn
    ;push    ax              ;pOut
    ;push    byte ptr 0      ;
    ;push    bp_lpdt32Tmp    ;pIn
    ;call    ConvertDialogA  ;convert menu to win3.1 format

    pushd   bp_hDialogTemplate
    push    0
    push    bp_cbdt
    pushd   bp_mem32Dlg
    call    ConvertDialog32


; create new call frame and make the call

    ; hInstance
    MAP_NULL_HINST bp_hInstance
    push    ax

    ; lpDlgTemplate
    push    word ptr bp_hmem16Tmp
    push    0

    ; hwndOwner
    push    word ptr bp_hWndParent

    ; lpfnDialog
    pushd   bp_lpDialogFunc
    pushd   CBID_DLGPROC
    call    GetStdCBSL
    push    eax

    push    dword ptr bp_dwInitParam

    call    GetCurrentHeap
    ; mov     ds,ax                                 ; set by func
    call    CreateDialogIndirectParam               ; call 16-bit version

    ; Save zero-extended return value
    movzx   eax,ax
    push    eax

    push    bp_hmem16Tmp
    call    GlobalFree

    ; Restore return value
    pop     eax

done:
    ; Save return value
    push    eax

    pushd   bp_lpdt32Tmp
    call    UnmapLS

    ; Restore return value
    pop     eax

;locals discarded by next instruction
endm

;-----------------------------------------------------------------------;
; body_DIALOGBOXINDIRECTPARAMA
;-----------------------------------------------------------------------;
body_DIALOGBOXINDIRECTPARAMA macro
    local   done
    local   ret_ok
    local   cont
    local   done_with_dlgproc
    local   dlgproc_freed

bp_hInstance            equ     <bp_top>
bp_lpDialogTemplate     equ     <bp_top+4>
bp_hWndParent           equ     <bp_top+8>
bp_lpDialogFunc         equ     <bp_top+12>
bp_dwInitParam          equ     <bp_top+16>

bp_lpdt32Tmp   equ <dword ptr [bp-4]>
bp_hmem16Tmp   equ < word ptr [bp-6]>
bp_cbdt        equ < word ptr [bp-8]>
bp_mem32Dlg    equ <dword ptr [bp-12]>

    xor     eax,eax
    push    eax
    push    eax
    push    eax

    push    dword ptr bp_lpDialogTemplate
    call    MapLS   ;PLUGGED
    mov     bp_lpdt32Tmp,eax

    push    eax
    call    CountDialogU
    mov     bp_cbdt,ax

    push    byte ptr GPTR
    movzx   eax,ax
    push    eax
    call    GlobalAlloc     ;if no scratch space, return no hmenu
    movzx   eax,ax          ;prepare for error
    test    ax,ax
    jz      done

    mov     bp_hmem16Tmp,ax

    ; GPTR is GMEM_FIXED, so MapSL is safe
    push    ax
    push    0
    call    MapSL
    mov     bp_mem32Dlg, eax

    pushd   bp_lpDialogTemplate
    push    0
    push    bp_cbdt
    pushd   bp_mem32Dlg
    call    ConvertDialog32


; create new call frame and make the call

    ;hInst
    MAP_NULL_HINST bp_hInstance
    push    ax

    ; hTemplate
    push    word ptr bp_hmem16Tmp

    ; hwndOwner
    push    word ptr bp_hWndParent

    ; lpfnDialog
    push    dword ptr bp_lpDialogFunc
    push    dword ptr CBID_DLGPROC
    call    GetStdCBSL
    push    eax

    push    dword ptr bp_dwInitParam

    call    GetCurrentHeap
    ; mov     ds,ax                                 ; set by func
    call    DialogBoxIndirectParam          ; call 16-bit version

    DXAX2EAX        ;; 16-bit version returns in DX:AX.
                ;; So, move it to EAX.

cont:
    ; Save return value
    push    eax


    push    bp_hmem16Tmp    ;cannot be null
    call    GlobalFree

    ; Restore return value
    pop     eax

done:
    ; Save return value
    push    eax

    pushd   bp_lpdt32Tmp
    call    UnmapLS

    ; Restore return value
    pop     eax

;locals discarded by next instruction
endm




;----------------------------------------------------------------------;
;----------------------------------------------------------------------;

; Inputs: eax = 32-bit lpNewItem from Win32 app.
;     wFlags = MF flags passed to API (in cx for ChangeMenu!!)
;     SegVarAddr = address of thunk-created local
;
; Output: eax = mapped version:
;        -- input eax if MF_OWNERDRAW
;        -- hi-word zeroed if MF_BITMAP
;        -- MapLS's if MF_STRING
;
;     SegVarAddr set to seg:offset if MF_STRING.
;
MAP_MENU_LPNEWITEM  macro wFlags,SegVarAddr

    local   exit,isstring

; Assumes SegVarAddr initialized to 0.
    mov     dx,wFlags
    test    dx,MF_OWNERDRAW or MF_SEPARATOR
    jnz     exit
    test    dx,MF_BITMAP
    jz      isstring
    movzx   eax,ax
    jmp     exit

isstring:
    push    eax
    call    MapLS   ;PLUGGED
    mov     dword ptr SegVarAddr,eax
exit:

endm ;MAP_MENU_LPNEWITEM


;----------------------------------------------------------------------;
;----------------------------------------------------------------------;
RAWPACK__MODIFYMENUA_lpNewItem  macro   iOffset,iOffsetTemp

    mov eax,[bp+iOffset]
    MAP_MENU_LPNEWITEM  [bp_top+8],LOCAL__MODIFYMENUA_lpNewItemSeg
    mov [bp-iOffsetTemp],eax

endm; RAWPACK__MODIFYMENUA_lpNewItem


RAWUNPACK__MODIFYMENUA_lpNewItem    macro   iOffset,iOffsetTemp

    push    dword ptr LOCAL__MODIFYMENUA_lpNewItemSeg
    call    UnmapLS

endm; RAWUNPACK__MODIFYMENUA_lpNewItem


;----------------------------------------------------------------------;
;----------------------------------------------------------------------;
RAWPACK__INSERTMENUA_lpNewItem  macro   iOffset,iOffsetTemp

    mov eax,[bp+iOffset]
    MAP_MENU_LPNEWITEM  [bp_top+8],LOCAL__INSERTMENUA_lpNewItemSeg
    mov [bp-iOffsetTemp],eax

endm; RAWPACK__INSERTMENUA_lpNewItem


RAWUNPACK__INSERTMENUA_lpNewItem    macro   iOffset,iOffsetTemp

    push    dword ptr LOCAL__INSERTMENUA_lpNewItemSeg
    call    UnmapLS

endm; RAWUNPACK__INSERTMENUA_lpNewItem


;----------------------------------------------------------------------;
;----------------------------------------------------------------------;
RAWPACK__CHANGEMENUA_lpNewItem  macro   iOffset,iOffsetTemp

    mov eax,[bp+iOffset]

; HACK: The same flag bit that means MF_OWNERDRAW for
; every other *Menu() api means MF_APPEND for ChangeMenu(). To prevent
; MAP_MENU_LPNEWITEM from getting confused, turn off the bit in the
; flag we give to it.
    mov     cx,[bp_top+16]
    and     cx,not MF_OWNERDRAW
    MAP_MENU_LPNEWITEM  cx,LOCAL__CHANGEMENUA_lpNewItemSeg
    mov [bp-iOffsetTemp],eax

endm; RAWPACK__CHANGEMENUA_lpNewItem


RAWUNPACK__CHANGEMENUA_lpNewItem    macro   iOffset,iOffsetTemp

    push    dword ptr LOCAL__CHANGEMENUA_lpNewItemSeg
    call    UnmapLS

endm; RAWUNPACK__CHANGEMENUA_lpNewItem



;------------------------------------------------------------------------;
;body_WINHELPA
;------------------------------------------------------------------------;
body_WINHELPA macro
    local its_a_pointer
    local its_lpmultikeyhelp
    local its_lphelpwininfo
    local leave_alone
    local call_winhelp
    local push_with_ssdi
    local loop_top
    local loop_top_2

bp_hwnd         equ     <bp_top>
bp_lpHelpFile   equ     <bp_top+4>
bp_wCommand     equ     <bp_top+8>
bp_dwData       equ     <bp_top+12>

bp_lpHelpFileTmp    equ <[bp-4]>
bp_dwDataTmp        equ <[bp-8]>

    xor     eax,eax
    push    eax
    push    eax

;;The various HELP_* constants are not arranged nicely for a jump
;;table, so just check for each of the known types needing special
;;thunking.  If wCommand is not recognized,

    mov     bx,word ptr bp_wCommand
    and     bx, not HELP_TCARD

    cmp     bx, HELP_CONTEXTMENU
    jb      leave_alone
    je      its_a_pointer

    cmp     bx, HELP_WM_HELP
    je      its_a_pointer

    cmp     bx,HELP_KEY
    je      its_a_pointer

    cmp     bx,HELP_COMMAND
    je      its_a_pointer

    cmp     bx,HELP_PARTIALKEY
    je      its_a_pointer

    cmp     bx,HELP_MULTIKEY
    je      its_lpmultikeyhelp

    cmp     bx,HELP_SETWINPOS
    je      its_lphelpwininfo


;; Push dwData as a dword.
leave_alone:
    push    word ptr bp_hwnd
    push    dword ptr bp_lpHelpFile
    call    MapLS   ;PLUGGED
    mov     dword ptr bp_lpHelpFileTmp,eax
    push    eax
    push    word ptr bp_wCommand
    push    dword ptr bp_dwData
    jmp     call_winhelp

;; Push dwData as LPSTR, so call MapLS
its_a_pointer:
    push    word ptr bp_hwnd
    push    dword ptr bp_lpHelpFile
    call    MapLS   ;PLUGGED
    mov     dword ptr bp_lpHelpFileTmp,eax
    push    eax
    push    word ptr bp_wCommand
    push    dword ptr bp_dwData
    call    MapLS   ;PLUGGED
    mov     dword ptr bp_dwDataTmp,eax
    push    eax
    jmp     call_winhelp

;;Push dwData as LPMULTIKEYHELP, which needs to be repacked.
its_lpmultikeyhelp:
    mov     esi,bp_dwData
    test    esi,esi         ;;if zero, just push it
    jz      leave_alone

    mov     es,FlatData
    mov     ax,word ptr es:[esi].mk32_Size
    mov     cx,ax           ;;save for loop count
    add     cx,(size MULTIKEYHELP16 - size MULTIKEYHELP32)
    sub     sp,cx           ;;subtract adjusted size for 16-bit struct
    mov     di,sp           ;;will access 16-bit struct thru SS:DI
    mov     ss:[di].mk16_Size,cx
    mov     cl,es:[esi].mk32_Keylist
    mov     ss:[di].mk16_Keylist,cl

    mov     cx,ax           ;;32-bit struct size
    sub     cx,mk32_szKeyphrase     ;;skip header fields
    add     esi,mk32_szKeyphrase
    add     di,mk16_szKeyphrase

loop_top:
    mov     al,es:[esi]
    mov     ss:[di],al
    inc     esi
    inc     di
    loop    loop_top

    mov     di,sp           ;;SP --> base of structure
    jmp     short push_with_ssdi

;;Push dwData as LPHELPWININFO, which needs to be repacked.
its_lphelpwininfo:
    mov     esi,bp_dwData
    test    esi,esi         ;;if zero, just push it
    jz      leave_alone

    mov     es,FlatData
    mov     ax,word ptr es:[esi].hwi32_wStructSize
    mov     cx,ax           ;;save for loop count
    add     cx,(size HELPWININFO16 - size HELPWININFO32)
    sub     sp,cx           ;;subtract adjusted size for 16-bit struct
    mov     di,sp           ;;will access 16-bit struct thru SS:DI
    mov     ss:[di].hwi16_wStructSize,cx

    ;;Truncate all fields except for rgchMember to 16-bits.

    mov     cx,word ptr es:[esi].hwi32_x
    mov     ss:[di].hwi16_x,cx
    mov     cx,word ptr es:[esi].hwi32_y
    mov     ss:[di].hwi16_y,cx
    mov     cx,word ptr es:[esi].hwi32_dx
    mov     ss:[di].hwi16_dx,cx
    mov     cx,word ptr es:[esi].hwi32_dy
    mov     ss:[di].hwi16_dy,cx
    mov     cx,word ptr es:[esi].hwi32_wMax
    mov     ss:[di].hwi16_wMax,cx

    mov     cx,ax           ;;32-bit struct size
    sub     cx,hwi32_rgchMember     ;;skip header fields
    add     esi,hwi32_rgchMember
    add     di,hwi16_rgchMember

loop_top_2:
    mov     al,es:[esi]
    mov     ss:[di],al
    inc     esi
    inc     di
    loop    loop_top_2

    mov     di,sp           ;;SP --> base of structure

push_with_ssdi:
    push    word ptr bp_hwnd
    push    dword ptr bp_lpHelpFile
    call    MapLS   ;PLUGGED
    mov dword ptr bp_lpHelpFileTmp,eax
    push    eax
    push    word ptr bp_wCommand
    push    ss              ;;SS:DI --> thunked structure
    push    di

call_winhelp:
    call    WinHelp
    cwde


    push    eax
    push    dword ptr bp_lpHelpFileTmp
    call    UnmapLS
    push    dword ptr bp_dwDataTmp
    call    UnmapLS
    pop eax
;;The first instruction at Exit_16 clears temporary variables off stack.
endm




;==============================================================================
;
;   InsertMenuItemA()
;
;==============================================================================
body_INSERTMENUITEMA macro
    local   ConvertMiim
    local   MakeCall
bp_hMenu        equ     <bp_top+ 0>
bp_nIndex       equ     <bp_top+ 4>
bp_fByPosition  equ     <bp_top+ 8>
bp_lpMiim32     equ     <bp_top+12>

bp_SavePtr  equ <[bp-4]>

    xor     eax,eax
    push    eax     ;bp_SavePtr

    ; We need scratch space for MENUITEMINFO16
    sub     sp, MENUITEMINFO16_SIZE
    mov     di, sp

    ; Push 16bit parms
    push    word ptr bp_hMenu               ;hMenu 16
    push    word ptr bp_nIndex              ;nIndex 16
    push    word ptr bp_fByPosition         ;fByPosition 16

    ; Is lpMenuItemInfo NULL?
    mov     eax, dword ptr bp_lpMiim32
    test    eax, eax
    jnz     ConvertMiim

    push    eax
    jmp     MakeCall

ConvertMiim:
    push    ss                              ;lpMenuItemInfo 16
    push    di

    ; Convert MENUITEMINFO LS
    push    eax
    push    di
    lea     ax, bp_SavePtr
    push    ax
    call    ConvertMenuItemInfoLS

MakeCall:
    call    InsertMenuItem32
    cwde

    ;Save return value
    push    eax

    ;Cleanup
    push    dword ptr bp_SavePtr
    call    UnMapLS

    ;Restore return value
    pop     eax
endm


;==============================================================================
;
;   SetMenuItemInfoA()
;
;==============================================================================
body_SETMENUITEMINFOA macro
    local   ConvertMiim
    local   MakeCall
bp_hMenu        equ     <bp_top+ 0>
bp_nIndex       equ     <bp_top+ 4>
bp_fByPosition  equ     <bp_top+ 8>
bp_lpMiim32     equ     <bp_top+12>

bp_SavePtr  equ <[bp-4]>

    xor     eax,eax
    push    eax     ;bp_SavePtr

    ; We need scratch space for MENUITEMINFO16
    sub     sp, MENUITEMINFO16_SIZE
    mov     di, sp

    ;Push 16bit parms
    push    word ptr bp_hMenu
    push    word ptr bp_nIndex
    push    word ptr bp_fByPosition

    ; Is lpMenuItemInfo NULL?
    mov     eax, dword ptr bp_lpMiim32
    test    eax, eax
    jnz     ConvertMiim

    push    eax
    jmp     MakeCall

ConvertMiim:
    push    ss
    push    di

    ;Convert MENUITEMINFO LS
    push    eax
    push    di
    lea     ax, bp_SavePtr
    push    ax
    call    ConvertMenuItemInfoLS

MakeCall:
    call    SetMenuItemInfo32
    cwde

    ;Save return value
    push    eax

    ;Cleanup
    push    dword ptr bp_SavePtr
    call    UnMapLS

    ;Restore return value
    pop     eax
endm



;==============================================================================
;
;   GetMenuItemInfoA()
;
;==============================================================================
body_GETMENUITEMINFOA macro
    local ConvertMiim
    local MakeCall
    local GetDone
    local MenuTypeData
    local MenuItemCch
    local MenuItemEnd

bp_hMenu        equ     <bp_top+ 0>
bp_nIndex       equ     <bp_top+ 4>
bp_fByPosition  equ     <bp_top+ 8>
bp_lpMiim32     equ     <bp_top+12>

bp_SavePtr      equ     <[bp-4]>

    xor     eax,eax
    push    eax

    ; We need scratch space for MENUITEMINFO16
    sub     sp, MENUITEMINFO16_SIZE
    movzx   edi, sp

    ; Push 16bit parms
    push    word ptr bp_hMenu
    push    word ptr bp_nIndex
    push    word ptr bp_fByPosition

    ; Is lpMiim32 NULL?
    mov     eax, dword ptr bp_lpMiim32
    test    eax, eax
    jnz     ConvertMiim

    push    eax
    jmp     MakeCall

ConvertMiim:
    push    ss
    push    di

    ; HACK
    ; If MIIM_TYPE is specified in the mask for a 95-sized structure, we
    ; need to add MIIM_STRING and MIIM_BITMAP to the mask so that we fill
    ; those fields
    mov     es, FlatData
    mov     esi, bp_lpMiim32
    .errnz  mii_32_fType - mii_32_cbSize - 8
    mov     ecx, dword ptr es:[esi+4]
    test    cx, 00010h                  ; if (fMask & MIIM_TYPE)
    jz      @F
    or      cx, 001C0h                  ;     fMask |= MIIM_FTYPE |
    mov     dword ptr es:[esi+4], ecx   ;              MIIM_STRING | MIIM_BITMAP
@@:

    ; Convert MENUITEMINFO LS
    push    esi
    push    di
    lea     ax, bp_SavePtr
    push    ax
    call    ConvertMenuItemInfoLS

MakeCall:
    call    GetMenuItemInfo32
    cwde

    ; Save return value
    push    eax

    ; Is bp_lpMiim32 NULL?
    mov     eax, bp_lpMiim32
    test    eax, eax
    jz      GetDone

    mov     es, FlatData            ; DO THIS FIRST:  FlatData is DS-relative

    push    ds
    mov     cx, ss
    mov     ds, cx

    mov     esi, edi
    mov     edi, eax                ; DO THIS LAST:  We need to move DI to SI first
    cld

    ; cbSize - skip it
    add     esi, 4
    add     edi, 4

    ;fMask - save it
    lodsd   ds:[esi]
    mov     ecx, eax
    add     edi, 4

    ;fType
    xor     eax, eax            ;Zero out HIWORD
    lodsw   ds:[esi]
    mov     edx, eax            ; save fType
    stosd   es:[edi]

    ;fState,wID,hSubMenu,hbmpChecked,hbmpUnchecked
    push    ecx
    ncopyzx 5
    pop     ecx

    ;dwItemData
    copyd

    test    cx, 00010h          ; if (!(fMask & MIIM_TYPE))
    jz      SkipTypeData        ;     goto SkipTypeData
    mov     eax,es:[edi-020h]
    and     ax,0FE3Fh           ; fMask &= ~(MIIM_FTYPE | MIIM_STRING |
    mov     es:[edi-020h],eax   ;            MIIM_BITMAP);
    xor     eax,eax
    mov     ax,ds:[esi+006h]
    or      ax,ax               ; if (!lpmii16->hbmpItem)
    jz      CheckString         ;     goto CheckString
    stosd   es:[edi]            ; lpmii32->dwTypeData = lpmii16->hbmpItem

    or      dx, 00004h          ; lpmii32->fType |= MFT_BITMAP
    mov     es:[edi-020h], edx

    jmp     MenuItemCch

CheckString:
    mov     ax,ds:[esi+004h]
    or      ax,ax               ; if (!lpmii16->cch)
    jz      ZeroTypeData        ;     goto ZeroTypeData

SkipTypeData:
    add     esi, 4      ; it's a string -- so leave it as is
    add     edi, 4
    jmp     MenuItemCch

ZeroTypeData:
    add     esi, 4
    xor     eax,eax
    stosd   es:[edi]

MenuItemCch:
    copyzx

    ; Check hbmpItem
    test    cx, 00010h          ; if ((fMask & MIIM_TYPE))
    jnz     MenuItemEnd         ;    skip hbmpItem

    mov     eax,es:[edi-02ch]
    cmp     eax, 030h           ; if old MENUITEMINFO
    jc      MenuItemEnd         ;    skip hbmpItem

    mov     eax,es:[edi-028h]
    test    ax,080h             ; if not MIIM_BITMAP
    jz      MenuItemEnd         ;    skip hbmpItem

    copyzx                      ; copy hbmpItem

MenuItemEnd:
    pop     ds

    ; Unmap pointer since we mapped dwTypeData no matter what!
    push    dword ptr bp_SavePtr
    call    UnmapLS

GetDone:
    ; Restore return value
    pop     eax
endm


;------------------------------------------------------------------------------
; RET__GETDLGITEMINT
;
;   Either zero-extend or sign-extend ax into eax, depending on
;   the value of the "bSigned" argument.
;------------------------------------------------------------------------------
RET__GETDLGITEMINT  macro

    local   exit
    local   unsigned

    cmp word ptr [bp_top + 12],0  ; bSigned
    je  unsigned

    cwde
    jmp exit

unsigned:
    movzx   eax,ax

exit:

endm ;RET__GETDLGITEMINT


;==============================================================================
;
;   mouse_event
;
;==============================================================================
body_MOUSE_EVENT macro

bp_dwFlags      equ     <bp_top+ 0>
bp_dx           equ     <bp_top+ 4>
bp_dy           equ     <bp_top+ 8>
bp_cButtons     equ     <bp_top+12>
bp_dwExtraInfo  equ     <bp_top+16>

    mov ax,word ptr bp_dwFlags
    mov bx,word ptr bp_dx
    mov cx,word ptr bp_dy
    mov dx,word ptr bp_cButtons
    mov si,word ptr bp_dwExtraInfo
    mov di,word ptr bp_dwExtraInfo+2

    call mouse_event

endm


;==============================================================================
;
;   keybd_event
;
;==============================================================================
body_KEYBD_EVENT macro

bp_dwVirtualKey  equ     <bp_top+ 0>
bp_dwScanCode    equ     <bp_top+ 4>
bp_dwFlags       equ     <bp_top+ 8>
bp_dwExtraInfo   equ     <bp_top+12>

    xor ax,ax
    xor bx,bx

    mov al,byte ptr bp_dwVirtualKey
    test word ptr bp_dwFlags,KEYEVENTF_KEYUP
    jz keybd_keydown
    mov ah,80
keybd_keydown:
    mov bl,byte ptr bp_dwScanCode
    test word ptr bp_dwFlags,KEYEVENTF_EXTENDEDKEY
    jz keybd_notextendedkey
    mov bh,1
keybd_notextendedkey:
    mov si,word ptr bp_dwExtraInfo
    mov di,word ptr bp_dwExtraInfo+2

    call keybd_event

endm

;==============================================================================
;
;   AlignRects()
;
;==============================================================================
body_ALIGNRECTS macro
    local   done
    local   ar_loop1
    local   ar_loop2

bp_lprect        equ     <bp_top+ 0>
bp_count         equ     <bp_top+ 4>
bp_iPrimary      equ     <bp_top+ 8>
bp_flags         equ     <bp_top+12>

bp_hmem16Tmp   equ < word ptr [bp-2]>
bp_Ret         equ < word ptr [bp-4]>
bp_lprectTmp   equ < dword ptr [bp-8]>


    xor     eax,eax
    push    eax
    push    eax

    mov     eax,bp_count    ;prepare for error
    test    eax,eax
    jz      done

    push    byte ptr GPTR
    shl     eax, 3
    push    eax
    call    GlobalAlloc     ;if no scratch space, return no hmenu

    movzx   eax,ax          ;prepare for error
    test    ax,ax
    jz      done
    mov     bp_hmem16Tmp,ax

    push    dword ptr bp_lprect
    call    MapLS   ;PLUGGED
    mov     dword ptr bp_lprectTmp,eax
    movzx   edi, ax
    mov     ax,dx

    mov     es, bp_hmem16Tmp
    xor     esi,esi

    mov     ecx,bp_count
    shl     ecx, 2

    push    ecx
    push    edi
    push    esi
    push    ax
    push    es

    
    push    ds
    mov     ds, ax

    cld
ar_loop1:
    lodsd   ds:[esi]
    stosw   es:[di]
    loop    ar_loop1
    pop     ds

    push    bp_hmem16Tmp    ;cannot be null
    push    0
    push    word ptr bp_count
    push    word ptr bp_iPrimary
    push    word ptr bp_flags
    call    CleanUpDesktopRectangles
    mov     bp_Ret,ax

    pop     ax
    pop     es
    pop     edi
    pop     esi
    pop     ecx

    push    ds
    mov     ds, ax

    cld
ar_loop2:
    lodsw   ds:[si]
    cwde
    stosd   es:[edi]
    loop    ar_loop2
    pop     ds
    
    push    bp_hmem16Tmp    ;cannot be null
    call    GlobalFree

    push    dword ptr bp_lprectTmp
    call    UnMapLS

    movzx   eax, bp_Ret

done:

endm

;==============================================================================
;
;   FlashWindowEx()
;
;==============================================================================
body_FLASHWINDOWEX macro
    local   done

bp_lpfw     equ     <bp_top+ 0>
bp_fwSave   equ < word ptr [bp-2]>

    xor     eax,eax
    push    eax        ; lpfw->cbSize, lpfw->hwnd
    push    eax        ; lpfw->dwFlags
    push    eax        ; lpfw->uCount

    mov     esi,bp_lpfw
    test    esi,esi         ;;if zero, just push it
    jz      done

    mov     es,FlatData
    mov     ecx, es:[esi]                 ; get fw32_cbSize to ecx
    cmp     cx, size FLASHWINFO32
    jnz     done

    add     esi, 4

    mov     di, sp
    mov     ss:[di].fw16_cbSize, (size FLASHWINFO16)
    lodsd   es:[esi]                 ; get fw32_hwnd to eax
    mov     ss:[di].fw16_hwnd, ax
    lodsd   es:[esi]                 ; get fw32_dwFlags to eax
    mov     ss:[di].fw16_dwFlags, eax
    lodsd   es:[esi]                 ; get fw32_uCount to eax
    mov     ss:[di].fw16_uCount, ax

    push    ss
    push    di
    call    FlashWindowEx

done:
endm

endif   ;IS_16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\verfthk.inc ===
RAWPACKQT__VERFINDFILEA_lpdwCurDirLen macro  iOffset, iTempOffset
local   nullpointer

; We'll just clear out the HIWORD of the UINT on entrance, and not worry about
; it on exit, since this value is undefined on failure of the function.
        mov     eax,dword ptr [ebp + iOffset]
        or      eax,eax
        jz      nullpointer
        mov     word ptr [eax+2],0
nullpointer:
        push    eax
        call    MapLS
        mov     [ebp + iTempOffset], eax

endm


RAWUNPACKQT__VERFINDFILEA_lpdwCurDirLen macro  iOffset, iTempOffset

        push    eax
        push    [ebp + iTempOffset]
        call    UnMapLS
        pop     eax

endm


RAWPACKQT__VERFINDFILEA_lpdwDestDirLen macro  iOffset, iTempOffset
local   nullpointer

; We'll just clear out the HIWORD of the UINT on entrance, and not worry about
; it on exit, since this value is undefined on failure of the function.
        mov     eax,dword ptr [ebp + iOffset]
        or      eax,eax
        jz      nullpointer
        mov     word ptr [eax+2],0
nullpointer:
        push    eax
        call    MapLS
        mov     [ebp + iTempOffset], eax

endm


RAWUNPACKQT__VERFINDFILEA_lpdwDestDirLen macro  iOffset, iTempOffset

        push    eax
        push    [ebp + iTempOffset]
        call    UnMapLS
        pop     eax

endm


RAWPACKQT__VERINSTALLFILEA_lpwTmpFileLen macro  iOffset, iTempOffset
local   nullpointer

; We'll just clear out the HIWORD of the UINT on entrance, and not worry about
; it on exit, since this value is undefined on failure of the function.
        mov     eax,dword ptr [ebp + iOffset]
        or      eax,eax
        jz      nullpointer
        mov     word ptr [eax+2],0
nullpointer:
        push    eax
        call    MapLS
        mov     [ebp + iTempOffset], eax

endm


RAWUNPACKQT__VERINSTALLFILEA_lpwTmpFileLen macro  iOffset, iTempOffset

        push    eax
        push    [ebp + iTempOffset]
        call    UnMapLS
        pop     eax

endm


RAWPACKQT__VERQUERYVALUEA_lplpBuffer macro  iOffset, iTempOffset

        local   ebp_pBlock

ebp_pBlock   equ  [ebp_qttop]

        mov     eax,ebp_pBlock
        mov     LOCAL__VERQUERYVALUEA_pBlock32, eax
        push    dword ptr [ebp + iOffset]
        call    MapLS
        mov     LOCAL__VERQUERYVALUEA_lplpBufTemp, eax
        mov     [ebp + iTempOffset], eax
endm


RAWUNPACKQT__VERQUERYVALUEA_lplpBuffer macro  iOffset, iTempOffset
        local   exit
        local   ebp_pBlock

ebp_pBlock   equ  [ebp_qttop]

        push    eax
        push    dword ptr LOCAL__VERQUERYVALUEA_lplpBufTemp
        call    UnMapLS
        pop     eax

        or      eax,eax
        jz      exit

; HACK! We know that the api returns a pointer inside    pBlock.
; The thunk passed in a 16:16 pointer where the offset is 0 for pBlock
; (because that's how MapLS works.) So we can deduce the linear
; address by looking just at the offset.
;
; The code generator has already unmapped the selector, so don't use it!
                                   
        mov     ecx, [ebp + iOffset]
        movzx   edx, word ptr [ecx]
        add     edx, dword ptr LOCAL__VERQUERYVALUEA_pBlock32
        mov     [ecx], edx

exit:
endm


RAWPACKQT__VERQUERYVALUEA_lpwLen macro  iOffset, iTempOffset
local   nullpointer

; We'll just clear out the HIWORD of the UINT on entrance, and not worry about
; it on exit, since this value is undefined on failure of the function.
        mov     eax,dword ptr [ebp + iOffset]
        or      eax,eax
        jz      nullpointer
        mov     word ptr [eax+2],0
nullpointer:
        push    eax
        call    MapLS
        mov     [ebp + iTempOffset], eax

endm


RAWUNPACKQT__VERQUERYVALUEA_lpwLen macro  iOffset, iTempOffset

        push    eax
        push    [ebp + iTempOffset]
        call    UnMapLS
        pop     eax

endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
	 PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\win16.h ===
/****************************************************************************/
/*                                                                          */
/*  WINDOWS.H -                                                             */
/*                                                                          */
/*      Include file for Windows 3.0 applications                           */
/*                                                                          */
/****************************************************************************/

/*  If defined, the following flags inhibit definition
 *     of the indicated items.
 *
 *  NOGDICAPMASKS     - CC_*, LC_*, PC_*, CP_*, TC_*, RC_
 *  NOVIRTUALKEYCODES - VK_*
 *  NOWINMESSAGES     - WM_*, EM_*, LB_*, CB_*
 *  NOWINSTYLES       - WS_*, CS_*, ES_*, LBS_*, SBS_*, CBS_*
 *  NOSYSMETRICS      - SM_*
 *  NOMENUS           - MF_*
 *  NOICONS           - IDI_*
 *  NOKEYSTATES       - MK_*
 *  NOSYSCOMMANDS     - SC_*
 *  NORASTEROPS       - Binary and Tertiary raster ops
 *  NOSHOWWINDOW      - SW_*
 *  OEMRESOURCE       - OEM Resource values
 *  NOATOM            - Atom Manager routines
 *  NOCLIPBOARD       - Clipboard routines
 *  NOCOLOR           - Screen colors
 *  NOCTLMGR          - Control and Dialog routines
 *  NODRAWTEXT        - DrawText() and DT_*
 *  NOGDI             - All GDI defines and routines
 *  NOKERNEL          - All KERNEL defines and routines
 *  NOUSER            - All USER defines and routines
 *  NOMB              - MB_* and MessageBox()
 *  NOMEMMGR          - GMEM_*, LMEM_*, GHND, LHND, associated routines
 *  NOMETAFILE        - typedef METAFILEPICT
 *  NOMINMAX          - Macros min(a,b) and max(a,b)
 *  NOMSG             - typedef MSG and associated routines
 *  NOOPENFILE        - OpenFile(), OemToAnsi, AnsiToOem, and OF_*
 *  NOSCROLL          - SB_* and scrolling routines
 *  NOSOUND           - Sound driver routines
 *  NOTEXTMETRIC      - typedef TEXTMETRIC and associated routines
 *  NOWH              - SetWindowsHook and WH_*
 *  NOWINOFFSETS      - GWL_*, GCL_*, associated routines
 *  NOCOMM            - COMM driver routines
 *  NOKANJI           - Kanji support stuff.
 *  NOHELP            - Help engine interface.
 *  NOPROFILER        - Profiler interface.
 *  NODEFERWINDOWPOS  - DeferWindowPos routines
 */

#ifdef RC_INVOKED

/* Turn off a bunch of stuff to ensure that RC files compile OK. */
#define NOATOM
#define NOGDI
#define NOGDICAPMASKS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NORASTEROPS
#define NOSCROLL
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NOCOMM
#define NOKANJI

#endif /* RC_INVOKED */


/*--------------------------------------------------------------------------*/
/*  General Purpose Defines                                                 */
/*--------------------------------------------------------------------------*/

#define NULL                0
#define FALSE               0
#define TRUE                1

#define FAR                 far
#define NEAR                near
#define LONG                long
#define VOID                void
#define PASCAL              pascal

#ifndef NOMINMAX

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#endif  /* NOMINMAX */

#define MAKELONG(a, b)      ((LONG)(((WORD)(a)) | ((DWORD)((WORD)(b))) << 16))
#define LOWORD(l)           ((WORD)(l))
#define HIWORD(l)           ((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define LOBYTE(w)           ((BYTE)(w))
#define HIBYTE(w)           ((BYTE)(((WORD)(w) >> 8) & 0xFF))

typedef int                 BOOL;
typedef unsigned char       BYTE;
typedef unsigned int        WORD;
typedef unsigned long       DWORD;
typedef char near           *PSTR;
typedef char near           *NPSTR;
typedef char far            *LPSTR;
typedef BYTE near           *PBYTE;
typedef BYTE far            *LPBYTE;
typedef int near            *PINT;
typedef int far             *LPINT;
typedef WORD near           *PWORD;
typedef WORD far            *LPWORD;
typedef long near           *PLONG;
typedef long far            *LPLONG;
typedef DWORD near          *PDWORD;
typedef DWORD far           *LPDWORD;
typedef void far            *LPVOID;

#ifndef WIN_INTERNAL
typedef WORD                HANDLE;
typedef HANDLE              HWND;
#endif

typedef HANDLE              *PHANDLE;
typedef HANDLE NEAR         *SPHANDLE;
typedef HANDLE FAR          *LPHANDLE;
typedef HANDLE              GLOBALHANDLE;
typedef HANDLE              LOCALHANDLE;
typedef int (FAR PASCAL *FARPROC)();
typedef int (NEAR PASCAL *NEARPROC)();

typedef HANDLE              HSTR;
typedef HANDLE              HICON;
typedef HANDLE              HDC;
typedef HANDLE              HMENU;
typedef HANDLE              HPEN;
typedef HANDLE              HFONT;
typedef HANDLE              HBRUSH;
typedef HANDLE              HBITMAP;
typedef HANDLE              HCURSOR;
typedef HANDLE              HRGN;
typedef HANDLE              HPALETTE;

typedef DWORD               COLORREF;

#ifndef WIN_INTERNAL
typedef struct tagRECT
  {
    int         left;
    int         top;
    int         right;
    int         bottom;
  } RECT;
#endif

typedef RECT                *PRECT;
typedef RECT NEAR           *NPRECT;
typedef RECT FAR            *LPRECT;

typedef struct tagPOINT
  {
    int         x;
    int         y;
  } POINT;
typedef POINT               *PPOINT;
typedef POINT NEAR          *NPPOINT;
typedef POINT FAR           *LPPOINT;


/*--------------------------------------------------------------------------*/
/*  KERNEL Section                                                          */
/*--------------------------------------------------------------------------*/

#ifndef NOKERNEL

/* Loader Routines */
WORD    FAR PASCAL GetVersion(void);
WORD    FAR PASCAL GetNumTasks(void);
HANDLE  FAR PASCAL GetCodeHandle(FARPROC);
void    FAR PASCAL GetCodeInfo(FARPROC lpProc, LPVOID lpSegInfo);
HANDLE  FAR PASCAL GetModuleHandle(LPSTR);
int     FAR PASCAL GetModuleUsage(HANDLE);
int     FAR PASCAL GetModuleFileName(HANDLE, LPSTR, int);
int     FAR PASCAL GetInstanceData(HANDLE, NPSTR, int);
FARPROC FAR PASCAL GetProcAddress(HANDLE, LPSTR);
FARPROC FAR PASCAL MakeProcInstance(FARPROC, HANDLE);
void    FAR PASCAL FreeProcInstance(FARPROC);
HANDLE  FAR PASCAL LoadLibrary(LPSTR);
HANDLE  FAR PASCAL LoadModule(LPSTR, LPVOID);
BOOL    FAR PASCAL FreeModule(HANDLE);
void    FAR PASCAL FreeLibrary(HANDLE);
DWORD   FAR PASCAL GetFreeSpace(WORD);
WORD    FAR PASCAL WinExec(LPSTR, WORD);
void    FAR PASCAL DebugBreak();
void    FAR PASCAL OutputDebugString(LPSTR);
void    FAR PASCAL SwitchStackBack();
void    FAR PASCAL SwitchStackTo(WORD, WORD, WORD);
WORD    FAR PASCAL GetCurrentPDB(void);

#ifndef NOOPENFILE

/* OpenFile() Structure */
typedef struct tagOFSTRUCT
  {
    BYTE        cBytes;
    BYTE        fFixedDisk;
    WORD        nErrCode;
    BYTE        reserved[4];
    BYTE        szPathName[128];
  } OFSTRUCT;
typedef OFSTRUCT            *POFSTRUCT;
typedef OFSTRUCT NEAR       *NPOFSTRUCT;
typedef OFSTRUCT FAR        *LPOFSTRUCT;

/* OpenFile() Flags */
#define OF_READ             0x0000
#define OF_WRITE            0x0001
#define OF_READWRITE        0x0002
#define OF_SHARE_COMPAT     0x0000
#define OF_SHARE_EXCLUSIVE  0x0010
#define OF_SHARE_DENY_WRITE 0x0020
#define OF_SHARE_DENY_READ  0x0030
#define OF_SHARE_DENY_NONE  0x0040
#define OF_PARSE            0x0100
#define OF_DELETE           0x0200
#define OF_VERIFY           0x0400
#define OF_CANCEL           0x0800
#define OF_CREATE           0x1000
#define OF_PROMPT           0x2000
#define OF_EXIST            0x4000
#define OF_REOPEN           0x8000

int  FAR PASCAL OpenFile(LPSTR, LPOFSTRUCT, WORD);

/* GetTempFileName() Flags */
#define TF_FORCEDRIVE       (BYTE)0x80

BYTE FAR PASCAL GetTempDrive(BYTE);
int  FAR PASCAL GetTempFileName(BYTE, LPSTR, WORD, LPSTR);
WORD FAR PASCAL SetHandleCount(WORD);

WORD FAR PASCAL GetDriveType(int);
/* GetDriveType return values */
#define DRIVE_REMOVABLE 2
#define DRIVE_FIXED     3
#define DRIVE_REMOTE    4

#endif /* NOOPENFILE */

#ifndef NOMEMMGR

/* Global Memory Flags */
#define GMEM_FIXED          0x0000
#define GMEM_MOVEABLE       0x0002
#define GMEM_NOCOMPACT      0x0010
#define GMEM_NODISCARD      0x0020
#define GMEM_ZEROINIT       0x0040
#define GMEM_MODIFY         0x0080
#define GMEM_DISCARDABLE    0x0100
#define GMEM_NOT_BANKED     0x1000
#define GMEM_SHARE          0x2000
#define GMEM_DDESHARE       0x2000
#define GMEM_NOTIFY         0x4000
#define GMEM_LOWER          GMEM_NOT_BANKED

#define GHND                (GMEM_MOVEABLE | GMEM_ZEROINIT)
#define GPTR                (GMEM_FIXED | GMEM_ZEROINIT)

#define GlobalDiscard(h) GlobalReAlloc(h, 0L, GMEM_MOVEABLE)

HANDLE FAR PASCAL GlobalAlloc(WORD, DWORD);
DWORD  FAR PASCAL GlobalCompact(DWORD);
HANDLE FAR PASCAL GlobalFree(HANDLE);
DWORD  FAR PASCAL GlobalHandle(WORD);
LPSTR  FAR PASCAL GlobalLock(HANDLE);
HANDLE FAR PASCAL GlobalReAlloc(HANDLE, DWORD, WORD);
DWORD  FAR PASCAL GlobalSize(HANDLE);
BOOL   FAR PASCAL GlobalUnlock(HANDLE);
WORD   FAR PASCAL GlobalFlags(HANDLE);
LPSTR  FAR PASCAL GlobalWire(HANDLE);
BOOL   FAR PASCAL GlobalUnWire(HANDLE);
BOOL   FAR PASCAL GlobalUnlock(HANDLE);
HANDLE FAR PASCAL GlobalLRUNewest(HANDLE);
HANDLE FAR PASCAL GlobalLRUOldest(HANDLE);
VOID   FAR PASCAL GlobalNotify(FARPROC);
WORD   FAR PASCAL GlobalPageLock(HANDLE);
WORD   FAR PASCAL GlobalPageUnlock(HANDLE);
VOID   FAR PASCAL GlobalFix(HANDLE);
BOOL   FAR PASCAL GlobalUnfix(HANDLE);

/* Flags returned by GlobalFlags (in addition to GMEM_DISCARDABLE) */
#define GMEM_DISCARDED      0x4000
#define GMEM_LOCKCOUNT      0x00FF

#define LockData(dummy)     LockSegment(0xFFFF)
#define UnlockData(dummy)   UnlockSegment(0xFFFF)

HANDLE FAR PASCAL LockSegment(WORD);
HANDLE FAR PASCAL UnlockSegment(WORD);

/* Local Memory Flags */
#define LMEM_FIXED          0x0000
#define LMEM_MOVEABLE       0x0002
#define LMEM_NOCOMPACT      0x0010
#define LMEM_NODISCARD      0x0020
#define LMEM_ZEROINIT       0x0040
#define LMEM_MODIFY         0x0080
#define LMEM_DISCARDABLE    0x0F00

#define LHND                (LMEM_MOVEABLE | LMEM_ZEROINIT)
#define LPTR                (LMEM_FIXED | LMEM_ZEROINIT)

#define NONZEROLHND         (LMEM_MOVEABLE)
#define NONZEROLPTR         (LMEM_FIXED)

#define LNOTIFY_OUTOFMEM    0
#define LNOTIFY_MOVE        1
#define LNOTIFY_DISCARD     2

WORD NEAR * PASCAL pLocalHeap;

#define LocalDiscard(h)     LocalReAlloc(h, 0, LMEM_MOVEABLE)

HANDLE  FAR PASCAL LocalAlloc(WORD, WORD);
WORD    FAR PASCAL LocalCompact(WORD);
HANDLE  FAR PASCAL LocalFree(HANDLE);
HANDLE  FAR PASCAL LocalHandle(WORD);
BOOL    FAR PASCAL LocalInit( WORD, WORD, WORD);
char NEAR * FAR PASCAL LocalLock(HANDLE);
FARPROC FAR PASCAL LocalNotify(FARPROC);
HANDLE  FAR PASCAL LocalReAlloc(HANDLE, WORD, WORD);
WORD    FAR PASCAL LocalSize(HANDLE);
BOOL    FAR PASCAL LocalUnlock(HANDLE);
WORD    FAR PASCAL LocalFlags(HANDLE);
WORD    FAR PASCAL LocalShrink(HANDLE, WORD);

/* Flags returned by LocalFlags (in addition to LMEM_DISCARDABLE) */
#define LMEM_DISCARDED      0x4000
#define LMEM_LOCKCOUNT      0x00FF

#endif /* NOMEMMGR */

LONG   FAR PASCAL SetSwapAreaSize(WORD);
LPSTR  FAR PASCAL ValidateFreeSpaces(void);
VOID   FAR PASCAL LimitEmsPages(DWORD);
BOOL   FAR PASCAL SetErrorMode(WORD);
VOID   FAR PASCAL ValidateCodeSegments(void);

LPSTR  FAR PASCAL GetDOSEnvironment(void);

WORD   FAR PASCAL AllocDStoCSAlias(WORD);
WORD   FAR PASCAL AllocSelector(WORD);
WORD   FAR PASCAL ChangeSelector(WORD, WORD);
WORD   FAR PASCAL FreeSelector(WORD);

#define UnlockResource(h)   GlobalUnlock(h)

HANDLE FAR PASCAL FindResource(HANDLE, LPSTR, LPSTR);
HANDLE FAR PASCAL LoadResource(HANDLE, HANDLE);
BOOL   FAR PASCAL FreeResource(HANDLE);
LPSTR  FAR PASCAL LockResource(HANDLE);
FARPROC FAR PASCAL SetResourceHandler(HANDLE, LPSTR, FARPROC);
HANDLE FAR PASCAL AllocResource(HANDLE, HANDLE, DWORD);
WORD   FAR PASCAL SizeofResource(HANDLE, HANDLE);
int    FAR PASCAL AccessResource(HANDLE, HANDLE);

#define MAKEINTRESOURCE(i)  (LPSTR)((DWORD)((WORD)(i)))

#ifndef NORESOURCE


/* Predefined Resource Types */
#define RT_CURSOR           MAKEINTRESOURCE(1)
#define RT_BITMAP           MAKEINTRESOURCE(2)
#define RT_ICON             MAKEINTRESOURCE(3)
#define RT_MENU             MAKEINTRESOURCE(4)
#define RT_DIALOG           MAKEINTRESOURCE(5)
#define RT_STRING           MAKEINTRESOURCE(6)
#define RT_FONTDIR          MAKEINTRESOURCE(7)
#define RT_FONT             MAKEINTRESOURCE(8)
#define RT_ACCELERATOR      MAKEINTRESOURCE(9)
#define RT_RCDATA           MAKEINTRESOURCE(10)



#endif /* NORESOURCE */

void   FAR PASCAL Yield(void);
HANDLE FAR PASCAL GetCurrentTask(void);

#ifndef NOATOM
typedef WORD                ATOM;

#define MAKEINTATOM(i)      (LPSTR)((DWORD)((WORD)(i)))

BOOL   FAR PASCAL InitAtomTable(int);
ATOM   FAR PASCAL AddAtom(LPSTR);
ATOM   FAR PASCAL DeleteAtom(ATOM);
ATOM   FAR PASCAL FindAtom(LPSTR);
WORD   FAR PASCAL GetAtomName(ATOM, LPSTR, int);
ATOM   FAR PASCAL GlobalAddAtom(LPSTR);
ATOM   FAR PASCAL GlobalDeleteAtom(ATOM);
ATOM   FAR PASCAL GlobalFindAtom(LPSTR);
WORD   FAR PASCAL GlobalGetAtomName(ATOM, LPSTR, int);
HANDLE FAR PASCAL GetAtomHandle(ATOM);

#endif /* NOATOM */

/* User Profile Routines */
WORD FAR PASCAL GetProfileInt(LPSTR, LPSTR, int);
int  FAR PASCAL GetProfileString(LPSTR, LPSTR, LPSTR, LPSTR, int);
BOOL FAR PASCAL WriteProfileString(LPSTR, LPSTR, LPSTR);
WORD FAR PASCAL GetPrivateProfileInt(LPSTR, LPSTR, int, LPSTR);
int  FAR PASCAL GetPrivateProfileString(LPSTR, LPSTR, LPSTR, LPSTR, int, LPSTR);
BOOL FAR PASCAL WritePrivateProfileString(LPSTR, LPSTR, LPSTR, LPSTR);

WORD FAR PASCAL GetWindowsDirectory(LPSTR,WORD);
WORD FAR PASCAL GetSystemDirectory(LPSTR,WORD);

/* Catch() and Throw() */
typedef int                 CATCHBUF[9];
typedef int FAR             *LPCATCHBUF;

int  FAR PASCAL Catch(LPCATCHBUF);
void FAR PASCAL Throw(LPCATCHBUF, int);

void FAR PASCAL FatalExit(int);

void FAR PASCAL SwapRecording(WORD);

/* Character Translation Routines */
int   FAR PASCAL AnsiToOem(LPSTR, LPSTR);
BOOL  FAR PASCAL OemToAnsi(LPSTR, LPSTR);
void  FAR PASCAL AnsiToOemBuff(LPSTR, LPSTR, int);
void  FAR PASCAL OemToAnsiBuff(LPSTR, LPSTR, int);
LPSTR FAR PASCAL AnsiUpper(LPSTR);
WORD  FAR PASCAL AnsiUpperBuff(LPSTR, WORD);
LPSTR FAR PASCAL AnsiLower(LPSTR);
WORD  FAR PASCAL AnsiLowerBuff(LPSTR, WORD);
LPSTR FAR PASCAL AnsiNext(LPSTR);
LPSTR FAR PASCAL AnsiPrev(LPSTR, LPSTR);

/* Keyboard Information Routines */
#ifndef NOKEYBOARDINFO
DWORD FAR PASCAL OemKeyScan(WORD);
WORD  FAR PASCAL VkKeyScan(WORD);
int   FAR PASCAL GetKeyboardType(int);
WORD  FAR PASCAL MapVirtualKey(WORD, WORD);
int   FAR PASCAL GetKBCodePage();
int   FAR PASCAL GetKeyNameText(LONG, LPSTR, int);
int   FAR PASCAL ToAscii(WORD wVirtKey, WORD wScanCode, LPSTR lpKeyState, LPVOID lpChar, WORD wFlags);
#endif

#ifndef  NOLANGUAGE
/* Language dependent Routines */
BOOL  FAR  PASCAL IsCharAlpha(char);
BOOL  FAR  PASCAL IsCharAlphaNumeric(char);
BOOL  FAR  PASCAL IsCharUpper(char);
BOOL  FAR  PASCAL IsCharLower(char);
#endif

LONG FAR PASCAL GetWinFlags(void);

#define WF_PMODE        0x0001
#define WF_CPU286       0x0002
#define WF_CPU386       0x0004
#define WF_CPU486       0x0008
#define WF_STANDARD     0x0010
#define WF_WIN286       0x0010
#define WF_ENHANCED     0x0020
#define WF_WIN386       0x0020
#define WF_CPU086       0x0040
#define WF_CPU186       0x0080
#define WF_LARGEFRAME   0x0100
#define WF_SMALLFRAME   0x0200
#define WF_80x87        0x0400

/* WEP fSystemExit flag values */
#define WEP_SYSTEM_EXIT 1
#define WEP_FREE_DLL    0


#ifdef OEMRESOURCE

/* OEM Resource Ordinal Numbers */
#define OBM_CLOSE           32754
#define OBM_UPARROW         32753
#define OBM_DNARROW         32752
#define OBM_RGARROW         32751
#define OBM_LFARROW         32750
#define OBM_REDUCE          32749
#define OBM_ZOOM            32748
#define OBM_RESTORE         32747
#define OBM_REDUCED         32746
#define OBM_ZOOMD           32745
#define OBM_RESTORED        32744
#define OBM_UPARROWD        32743
#define OBM_DNARROWD        32742
#define OBM_RGARROWD        32741
#define OBM_LFARROWD        32740
#define OBM_MNARROW         32739
#define OBM_COMBO           32738

#define OBM_OLD_CLOSE       32767
#define OBM_SIZE            32766
#define OBM_OLD_UPARROW     32765
#define OBM_OLD_DNARROW     32764
#define OBM_OLD_RGARROW     32763
#define OBM_OLD_LFARROW     32762
#define OBM_BTSIZE          32761
#define OBM_CHECK           32760
#define OBM_CHECKBOXES      32759
#define OBM_BTNCORNERS      32758
#define OBM_OLD_REDUCE      32757
#define OBM_OLD_ZOOM        32756
#define OBM_OLD_RESTORE     32755

#define OCR_NORMAL          32512
#define OCR_IBEAM           32513
#define OCR_WAIT            32514
#define OCR_CROSS           32515
#define OCR_UP              32516
#define OCR_SIZE            32640
#define OCR_ICON            32641
#define OCR_SIZENWSE        32642
#define OCR_SIZENESW        32643
#define OCR_SIZEWE          32644
#define OCR_SIZENS          32645
#define OCR_SIZEALL         32646
#define OCR_ICOCUR          32647

#define OIC_SAMPLE          32512
#define OIC_HAND            32513
#define OIC_QUES            32514
#define OIC_BANG            32515
#define OIC_NOTE            32516

#endif /* OEMRESOURCE */

#endif /* NOKERNEL */


/*--------------------------------------------------------------------------*/
/*  GDI Section                                                             */
/*--------------------------------------------------------------------------*/

#ifndef NOGDI

#ifndef NORASTEROPS

/* Binary raster ops */
#define R2_BLACK            1   /*  0       */
#define R2_NOTMERGEPEN      2   /* DPon     */
#define R2_MASKNOTPEN       3   /* DPna     */
#define R2_NOTCOPYPEN       4   /* PN       */
#define R2_MASKPENNOT       5   /* PDna     */
#define R2_NOT              6   /* Dn       */
#define R2_XORPEN           7   /* DPx      */
#define R2_NOTMASKPEN       8   /* DPan     */
#define R2_MASKPEN          9   /* DPa      */
#define R2_NOTXORPEN        10  /* DPxn     */
#define R2_NOP              11  /* D        */
#define R2_MERGENOTPEN      12  /* DPno     */
#define R2_COPYPEN          13  /* P        */
#define R2_MERGEPENNOT      14  /* PDno     */
#define R2_MERGEPEN         15  /* DPo      */
#define R2_WHITE            16  /*  1       */

/*  Ternary raster operations */
#define SRCCOPY             (DWORD)0x00CC0020 /* dest = source                   */
#define SRCPAINT            (DWORD)0x00EE0086 /* dest = source OR dest           */
#define SRCAND              (DWORD)0x008800C6 /* dest = source AND dest          */
#define SRCINVERT           (DWORD)0x00660046 /* dest = source XOR dest          */
#define SRCERASE            (DWORD)0x00440328 /* dest = source AND (NOT dest )   */
#define NOTSRCCOPY          (DWORD)0x00330008 /* dest = (NOT source)             */
#define NOTSRCERASE         (DWORD)0x001100A6 /* dest = (NOT src) AND (NOT dest) */
#define MERGECOPY           (DWORD)0x00C000CA /* dest = (source AND pattern)     */
#define MERGEPAINT          (DWORD)0x00BB0226 /* dest = (NOT source) OR dest     */
#define PATCOPY             (DWORD)0x00F00021 /* dest = pattern                  */
#define PATPAINT            (DWORD)0x00FB0A09 /* dest = DPSnoo                   */
#define PATINVERT           (DWORD)0x005A0049 /* dest = pattern XOR dest         */
#define DSTINVERT           (DWORD)0x00550009 /* dest = (NOT dest)               */
#define BLACKNESS           (DWORD)0x00000042 /* dest = BLACK                    */
#define WHITENESS           (DWORD)0x00FF0062 /* dest = WHITE                    */

#endif /* NORASTEROPS */

/* StretchBlt() Modes */
#define BLACKONWHITE                 1
#define WHITEONBLACK                 2
#define COLORONCOLOR                 3

/* PolyFill() Modes */
#define ALTERNATE                    1
#define WINDING                      2

/* Text Alignment Options */
#define TA_NOUPDATECP                0
#define TA_UPDATECP                  1

#define TA_LEFT                      0
#define TA_RIGHT                     2
#define TA_CENTER                    6

#define TA_TOP                       0
#define TA_BOTTOM                    8
#define TA_BASELINE                  24

#define ETO_GRAYED                   1
#define ETO_OPAQUE                   2
#define ETO_CLIPPED                  4

#define ASPECT_FILTERING             0x0001

#ifndef NOMETAFILE

/* Metafile Functions */
#define META_SETBKCOLOR              0x0201
#define META_SETBKMODE               0x0102
#define META_SETMAPMODE              0x0103
#define META_SETROP2                 0x0104
#define META_SETRELABS               0x0105
#define META_SETPOLYFILLMODE         0x0106
#define META_SETSTRETCHBLTMODE       0x0107
#define META_SETTEXTCHAREXTRA        0x0108
#define META_SETTEXTCOLOR            0x0209
#define META_SETTEXTJUSTIFICATION    0x020A
#define META_SETWINDOWORG            0x020B
#define META_SETWINDOWEXT            0x020C
#define META_SETVIEWPORTORG          0x020D
#define META_SETVIEWPORTEXT          0x020E
#define META_OFFSETWINDOWORG         0x020F
#define META_SCALEWINDOWEXT          0x0400
#define META_OFFSETVIEWPORTORG       0x0211
#define META_SCALEVIEWPORTEXT        0x0412
#define META_LINETO                  0x0213
#define META_MOVETO                  0x0214
#define META_EXCLUDECLIPRECT         0x0415
#define META_INTERSECTCLIPRECT       0x0416
#define META_ARC                     0x0817
#define META_ELLIPSE                 0x0418
#define META_FLOODFILL               0x0419
#define META_PIE                     0x081A
#define META_RECTANGLE               0x041B
#define META_ROUNDRECT               0x061C
#define META_PATBLT                  0x061D
#define META_SAVEDC                  0x001E
#define META_SETPIXEL                0x041F
#define META_OFFSETCLIPRGN           0x0220
#define META_TEXTOUT                 0x0521
#define META_BITBLT                  0x0922
#define META_STRETCHBLT              0x0B23
#define META_POLYGON                 0x0324
#define META_POLYLINE                0x0325
#define META_ESCAPE                  0x0626
#define META_RESTOREDC               0x0127
#define META_FILLREGION              0x0228
#define META_FRAMEREGION             0x0429
#define META_INVERTREGION            0x012A
#define META_PAINTREGION             0x012B
#define META_SELECTCLIPREGION        0x012C
#define META_SELECTOBJECT            0x012D
#define META_SETTEXTALIGN            0x012E
#define META_DRAWTEXT                0x062F

#define META_CHORD                   0x0830
#define META_SETMAPPERFLAGS          0x0231
#define META_EXTTEXTOUT              0x0a32 
#define META_SETDIBTODEV             0x0d33
#define META_SELECTPALETTE           0x0234
#define META_REALIZEPALETTE          0x0035
#define META_ANIMATEPALETTE          0x0436
#define META_SETPALENTRIES           0x0037
#define META_POLYPOLYGON             0x0538
#define META_RESIZEPALETTE           0x0139

#define META_DIBBITBLT               0x0940
#define META_DIBSTRETCHBLT           0x0b41
#define META_DIBCREATEPATTERNBRUSH   0x0142
#define META_STRETCHDIB              0x0f43

#define META_DELETEOBJECT            0x01f0

#define META_CREATEPALETTE           0x00f7
#define META_CREATEBRUSH             0x00F8
#define META_CREATEPATTERNBRUSH      0x01F9
#define META_CREATEPENINDIRECT       0x02FA
#define META_CREATEFONTINDIRECT      0x02FB
#define META_CREATEBRUSHINDIRECT     0x02FC
#define META_CREATEBITMAPINDIRECT    0x02FD
#define META_CREATEBITMAP            0x06FE
#define META_CREATEREGION            0x06FF

#endif /* NOMETAFILE */

/* GDI Escapes */
#define NEWFRAME                     1
#define ABORTDOC                     2
#define NEXTBAND                     3
#define SETCOLORTABLE                4
#define GETCOLORTABLE                5
#define FLUSHOUTPUT                  6
#define DRAFTMODE                    7
#define QUERYESCSUPPORT              8
#define SETABORTPROC                 9
#define STARTDOC                     10
#define ENDDOC                       11
#define GETPHYSPAGESIZE              12
#define GETPRINTINGOFFSET            13
#define GETSCALINGFACTOR             14
#define MFCOMMENT                    15
#define GETPENWIDTH                  16
#define SETCOPYCOUNT                 17
#define SELECTPAPERSOURCE            18
#define DEVICEDATA                   19
#define PASSTHROUGH                  19
#define GETTECHNOLGY                 20
#define GETTECHNOLOGY                20
#define SETENDCAP                    21
#define SETLINEJOIN                  22
#define SETMITERLIMIT                23
#define BANDINFO                     24
#define DRAWPATTERNRECT              25
#define GETVECTORPENSIZE             26
#define GETVECTORBRUSHSIZE           27
#define ENABLEDUPLEX                 28
#define GETSETPAPERBINS              29
#define GETSETPRINTORIENT            30
#define ENUMPAPERBINS                31
#define SETDIBSCALING                32
#define EPSPRINTING                  33
#define ENUMPAPERMETRICS             34
#define GETSETPAPERMETRICS           35
#define POSTSCRIPT_DATA              37
#define POSTSCRIPT_IGNORE            38
#define GETEXTENDEDTEXTMETRICS       256
#define GETEXTENTTABLE               257
#define GETPAIRKERNTABLE             258
#define GETTRACKKERNTABLE            259
#define EXTTEXTOUT                   512
#define ENABLERELATIVEWIDTHS         768
#define ENABLEPAIRKERNING            769
#define SETKERNTRACK                 770
#define SETALLJUSTVALUES             771
#define SETCHARSET                   772

#define STRETCHBLT                   2048
#define BEGIN_PATH                   4096
#define CLIP_TO_PATH                 4097
#define END_PATH                     4098
#define EXT_DEVICE_CAPS              4099
#define RESTORE_CTM                  4100
#define SAVE_CTM                     4101
#define SET_ARC_DIRECTION            4102
#define SET_BACKGROUND_COLOR         4103
#define SET_POLY_MODE                4104
#define SET_SCREEN_ANGLE             4105
#define SET_SPREAD                   4106
#define TRANSFORM_CTM                4107
#define SET_CLIP_BOX                 4108
#define SET_BOUNDS                   4109
#define SET_MIRROR_MODE              4110

/* Spooler Error Codes */
#define SP_NOTREPORTED               0x4000
#define SP_ERROR                     (-1)
#define SP_APPABORT                  (-2)
#define SP_USERABORT                 (-3)
#define SP_OUTOFDISK                 (-4)
#define SP_OUTOFMEMORY               (-5)

#define PR_JOBSTATUS                 0x0000

/* Object Definitions for EnumObjects() */
#define OBJ_PEN                      1
#define OBJ_BRUSH                    2

/* Bitmap Header Definition */
typedef struct tagBITMAP
  {
    int         bmType;
    int         bmWidth;
    int         bmHeight;
    int         bmWidthBytes;
    BYTE        bmPlanes;
    BYTE        bmBitsPixel;
    LPSTR       bmBits;
  } BITMAP;
typedef BITMAP              *PBITMAP;
typedef BITMAP NEAR         *NPBITMAP;
typedef BITMAP FAR          *LPBITMAP;

typedef struct tagRGBTRIPLE {
        BYTE    rgbtBlue;
        BYTE    rgbtGreen;
        BYTE    rgbtRed;
} RGBTRIPLE;

typedef struct tagRGBQUAD {
        BYTE    rgbBlue;
        BYTE    rgbGreen;
        BYTE    rgbRed;
        BYTE    rgbReserved;
} RGBQUAD;

/* structures for defining DIBs */
typedef struct tagBITMAPCOREHEADER {
        DWORD   bcSize;                 /* used to get to color table */
        WORD    bcWidth;
        WORD    bcHeight;
        WORD    bcPlanes;
        WORD    bcBitCount;
} BITMAPCOREHEADER;
typedef BITMAPCOREHEADER FAR *LPBITMAPCOREHEADER;
typedef BITMAPCOREHEADER *PBITMAPCOREHEADER;


typedef struct tagBITMAPINFOHEADER{
        DWORD      biSize;
        DWORD      biWidth;
        DWORD      biHeight;
        WORD       biPlanes;
        WORD       biBitCount;

        DWORD      biCompression;
        DWORD      biSizeImage;
        DWORD      biXPelsPerMeter;
        DWORD      biYPelsPerMeter;
        DWORD      biClrUsed;
        DWORD      biClrImportant;
} BITMAPINFOHEADER;

typedef BITMAPINFOHEADER FAR *LPBITMAPINFOHEADER;
typedef BITMAPINFOHEADER *PBITMAPINFOHEADER;

/* constants for the biCompression field */
#define BI_RGB      0L
#define BI_RLE8     1L
#define BI_RLE4     2L

typedef struct tagBITMAPINFO { 
    BITMAPINFOHEADER    bmiHeader;
    RGBQUAD             bmiColors[1];
} BITMAPINFO;
typedef BITMAPINFO FAR *LPBITMAPINFO;
typedef BITMAPINFO *PBITMAPINFO;

typedef struct tagBITMAPCOREINFO { 
    BITMAPCOREHEADER    bmciHeader;
    RGBTRIPLE           bmciColors[1];
} BITMAPCOREINFO;
typedef BITMAPCOREINFO FAR *LPBITMAPCOREINFO;
typedef BITMAPCOREINFO *PBITMAPCOREINFO;

typedef struct tagBITMAPFILEHEADER {
        WORD    bfType;
        DWORD   bfSize;
        WORD    bfReserved1;
        WORD    bfReserved2;
        DWORD   bfOffBits;
} BITMAPFILEHEADER;
typedef BITMAPFILEHEADER FAR *LPBITMAPFILEHEADER;
typedef BITMAPFILEHEADER *PBITMAPFILEHEADER;


#define MAKEPOINT(l)        (*((POINT FAR *)&(l)))

#ifndef NOMETAFILE

/* Clipboard Metafile Picture Structure */
typedef struct tagHANDLETABLE
  {
    HANDLE      objectHandle[1];
  } HANDLETABLE;
typedef HANDLETABLE         *PHANDLETABLE;
typedef HANDLETABLE FAR     *LPHANDLETABLE;

typedef struct tagMETARECORD
  {
    DWORD       rdSize;
    WORD        rdFunction;
    WORD        rdParm[1];
  } METARECORD;
typedef METARECORD          *PMETARECORD;
typedef METARECORD FAR      *LPMETARECORD;

typedef struct tagMETAFILEPICT
  {
    int         mm;
    int         xExt;
    int         yExt;
    HANDLE      hMF;
  } METAFILEPICT;
typedef METAFILEPICT FAR    *LPMETAFILEPICT;

typedef struct tagMETAHEADER
{
    WORD        mtType;
    WORD        mtHeaderSize;
    WORD        mtVersion;
    DWORD       mtSize;
    WORD        mtNoObjects;
    DWORD       mtMaxRecord;
    WORD        mtNoParameters;
} METAHEADER;

#endif /* NOMETAFILE */

#ifndef NOTEXTMETRIC

typedef struct tagTEXTMETRIC
  {
    int         tmHeight;
    int         tmAscent;
    int         tmDescent;
    int         tmInternalLeading;
    int         tmExternalLeading;
    int         tmAveCharWidth;
    int         tmMaxCharWidth;
    int         tmWeight;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmFirstChar;
    BYTE        tmLastChar;
    BYTE        tmDefaultChar;
    BYTE        tmBreakChar;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
    int         tmOverhang;
    int         tmDigitizedAspectX;
    int         tmDigitizedAspectY;
  } TEXTMETRIC;
typedef TEXTMETRIC          *PTEXTMETRIC;
typedef TEXTMETRIC NEAR     *NPTEXTMETRIC;
typedef TEXTMETRIC FAR      *LPTEXTMETRIC;

#endif /* NOTEXTMETRIC */

/* GDI Logical Objects: */

/* Pel Array */
typedef struct tagPELARRAY
  {
    int         paXCount;
    int         paYCount;
    int         paXExt;
    int         paYExt;
    BYTE        paRGBs;
  } PELARRAY;
typedef PELARRAY            *PPELARRAY;
typedef PELARRAY NEAR       *NPPELARRAY;
typedef PELARRAY FAR        *LPPELARRAY;

/* Logical Brush (or Pattern) */
typedef struct tagLOGBRUSH
  {
    WORD        lbStyle;
    DWORD       lbColor;
    int       lbHatch;
  } LOGBRUSH;
typedef LOGBRUSH            *PLOGBRUSH;
typedef LOGBRUSH NEAR       *NPLOGBRUSH;
typedef LOGBRUSH FAR        *LPLOGBRUSH;

typedef LOGBRUSH            PATTERN;
typedef PATTERN             *PPATTERN;
typedef PATTERN NEAR        *NPPATTERN;
typedef PATTERN FAR         *LPPATTERN;

/* Logical Pen */
typedef struct tagLOGPEN
  {
    WORD        lopnStyle;
    POINT       lopnWidth;
    DWORD       lopnColor;
  } LOGPEN;
typedef LOGPEN              *PLOGPEN;
typedef LOGPEN NEAR         *NPLOGPEN;
typedef LOGPEN FAR          *LPLOGPEN;



typedef struct tagPALETTEENTRY {
    BYTE        peRed;
    BYTE        peGreen;
    BYTE        peBlue;
    BYTE        peFlags;
} PALETTEENTRY;
typedef PALETTEENTRY FAR  *LPPALETTEENTRY;

/* Logical Palette */
typedef struct tagLOGPALETTE {
    WORD        palVersion;
    WORD        palNumEntries;
    PALETTEENTRY        palPalEntry[1];
} LOGPALETTE;
typedef LOGPALETTE          *PLOGPALETTE;
typedef LOGPALETTE NEAR     *NPLOGPALETTE;
typedef LOGPALETTE FAR      *LPLOGPALETTE;


/* Logical Font */
#define LF_FACESIZE         32

typedef struct tagLOGFONT
  {
    int       lfHeight;
    int       lfWidth;
    int       lfEscapement;
    int       lfOrientation;
    int       lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    BYTE      lfFaceName[LF_FACESIZE];
  } LOGFONT;
typedef LOGFONT             *PLOGFONT;
typedef LOGFONT NEAR        *NPLOGFONT;
typedef LOGFONT FAR         *LPLOGFONT;

#define OUT_DEFAULT_PRECIS      0
#define OUT_STRING_PRECIS       1
#define OUT_CHARACTER_PRECIS    2
#define OUT_STROKE_PRECIS       3

#define CLIP_DEFAULT_PRECIS     0
#define CLIP_CHARACTER_PRECIS   1
#define CLIP_STROKE_PRECIS      2

#define DEFAULT_QUALITY         0
#define DRAFT_QUALITY           1
#define PROOF_QUALITY           2

#define DEFAULT_PITCH           0
#define FIXED_PITCH             1
#define VARIABLE_PITCH          2

#define ANSI_CHARSET            0
#define SYMBOL_CHARSET          2
#define SHIFTJIS_CHARSET        128
#define OEM_CHARSET             255

/* Font Families */
#define FF_DONTCARE         (0<<4)  /* Don't care or don't know. */
#define FF_ROMAN            (1<<4)  /* Variable stroke width, serifed. */
                                    /* Times Roman, Century Schoolbook, etc. */
#define FF_SWISS            (2<<4)  /* Variable stroke width, sans-serifed. */
                                    /* Helvetica, Swiss, etc. */
#define FF_MODERN           (3<<4)  /* Constant stroke width, serifed or sans-serifed. */
                                    /* Pica, Elite, Courier, etc. */
#define FF_SCRIPT           (4<<4)  /* Cursive, etc. */
#define FF_DECORATIVE       (5<<4)  /* Old English, etc. */

/* Font Weights */
#define FW_DONTCARE         0
#define FW_THIN             100
#define FW_EXTRALIGHT       200
#define FW_LIGHT            300
#define FW_NORMAL           400
#define FW_MEDIUM           500
#define FW_SEMIBOLD         600
#define FW_BOLD             700
#define FW_EXTRABOLD        800
#define FW_HEAVY            900

#define FW_ULTRALIGHT       FW_EXTRALIGHT
#define FW_REGULAR          FW_NORMAL
#define FW_DEMIBOLD         FW_SEMIBOLD
#define FW_ULTRABOLD        FW_EXTRABOLD
#define FW_BLACK            FW_HEAVY

/* EnumFonts Masks */
#define RASTER_FONTTYPE     0x0001
#define DEVICE_FONTTYPE     0X0002

#define RGB(r,g,b)          ((DWORD)(((BYTE)(r)|((WORD)(g)<<8))|(((DWORD)(BYTE)(b))<<16)))
#define PALETTERGB(r,g,b)   (0x02000000 | RGB(r,g,b))
#define PALETTEINDEX(i)     ((DWORD)(0x01000000 | (WORD)(i)))

#define GetRValue(rgb)      ((BYTE)(rgb))
#define GetGValue(rgb)      ((BYTE)(((WORD)(rgb)) >> 8))
#define GetBValue(rgb)      ((BYTE)((rgb)>>16))

/* Background Modes */
#define TRANSPARENT         1
#define OPAQUE              2

/* Mapping Modes */
#define MM_TEXT             1
#define MM_LOMETRIC         2
#define MM_HIMETRIC         3
#define MM_LOENGLISH        4
#define MM_HIENGLISH        5
#define MM_TWIPS            6
#define MM_ISOTROPIC        7
#define MM_ANISOTROPIC      8

/* Coordinate Modes */
#define ABSOLUTE            1
#define RELATIVE            2

/* Stock Logical Objects */
#define WHITE_BRUSH         0
#define LTGRAY_BRUSH        1
#define GRAY_BRUSH          2
#define DKGRAY_BRUSH        3
#define BLACK_BRUSH         4
#define NULL_BRUSH          5
#define HOLLOW_BRUSH        NULL_BRUSH
#define WHITE_PEN           6
#define BLACK_PEN           7
#define NULL_PEN            8
#define OEM_FIXED_FONT      10
#define ANSI_FIXED_FONT     11
#define ANSI_VAR_FONT       12
#define SYSTEM_FONT         13
#define DEVICE_DEFAULT_FONT 14
#define DEFAULT_PALETTE     15
#define SYSTEM_FIXED_FONT   16

/* Brush Styles */
#define BS_SOLID            0
#define BS_NULL             1
#define BS_HOLLOW           BS_NULL
#define BS_HATCHED          2
#define BS_PATTERN          3
#define BS_INDEXED          4
#define BS_DIBPATTERN       5

/* Hatch Styles */
#define HS_HORIZONTAL       0       /* ----- */
#define HS_VERTICAL         1       /* ||||| */
#define HS_FDIAGONAL        2       /* \\\\\ */
#define HS_BDIAGONAL        3       /* ///// */
#define HS_CROSS            4       /* +++++ */
#define HS_DIAGCROSS        5       /* xxxxx */

/* Pen Styles */
#define PS_SOLID            0
#define PS_DASH             1       /* -------  */
#define PS_DOT              2       /* .......  */
#define PS_DASHDOT          3       /* _._._._  */
#define PS_DASHDOTDOT       4       /* _.._.._  */
#define PS_NULL             5
#define PS_INSIDEFRAME      6

/* Device Parameters for GetDeviceCaps() */
#define DRIVERVERSION 0     /* Device driver version                    */
#define TECHNOLOGY    2     /* Device classification                    */
#define HORZSIZE      4     /* Horizontal size in millimeters           */
#define VERTSIZE      6     /* Vertical size in millimeters             */
#define HORZRES       8     /* Horizontal width in pixels               */
#define VERTRES       10    /* Vertical width in pixels                 */
#define BITSPIXEL     12    /* Number of bits per pixel                 */
#define PLANES        14    /* Number of planes                         */
#define NUMBRUSHES    16    /* Number of brushes the device has         */
#define NUMPENS       18    /* Number of pens the device has            */
#define NUMMARKERS    20    /* Number of markers the device has         */
#define NUMFONTS      22    /* Number of fonts the device has           */
#define NUMCOLORS     24    /* Number of colors the device supports     */
#define PDEVICESIZE   26    /* Size required for device descriptor      */
#define CURVECAPS     28    /* Curve capabilities                       */
#define LINECAPS      30    /* Line capabilities                        */
#define POLYGONALCAPS 32    /* Polygonal capabilities                   */
#define TEXTCAPS      34    /* Text capabilities                        */
#define CLIPCAPS      36    /* Clipping capabilities                    */
#define RASTERCAPS    38    /* Bitblt capabilities                      */
#define ASPECTX       40    /* Length of the X leg                      */
#define ASPECTY       42    /* Length of the Y leg                      */
#define ASPECTXY      44    /* Length of the hypotenuse                 */

#define LOGPIXELSX    88    /* Logical pixels/inch in X                 */
#define LOGPIXELSY    90    /* Logical pixels/inch in Y                 */

#define SIZEPALETTE  104    /* Number of entries in physical palette    */
#define NUMRESERVED  106    /* Number of reserved entries in palette    */
#define COLORRES     108    /* Actual color resolution                  */

#ifndef NOGDICAPMASKS

/* Device Capability Masks: */

/* Device Technologies */
#define DT_PLOTTER          0   /* Vector plotter                   */
#define DT_RASDISPLAY       1   /* Raster display                   */
#define DT_RASPRINTER       2   /* Raster printer                   */
#define DT_RASCAMERA        3   /* Raster camera                    */
#define DT_CHARSTREAM       4   /* Character-stream, PLP            */
#define DT_METAFILE         5   /* Metafile, VDM                    */
#define DT_DISPFILE         6   /* Display-file                     */

/* Curve Capabilities */
#define CC_NONE             0   /* Curves not supported             */
#define CC_CIRCLES          1   /* Can do circles                   */
#define CC_PIE              2   /* Can do pie wedges                */
#define CC_CHORD            4   /* Can do chord arcs                */
#define CC_ELLIPSES         8   /* Can do ellipese                  */
#define CC_WIDE             16  /* Can do wide lines                */
#define CC_STYLED           32  /* Can do styled lines              */
#define CC_WIDESTYLED       64  /* Can do wide styled lines         */
#define CC_INTERIORS        128 /* Can do interiors                 */

/* Line Capabilities */
#define LC_NONE             0   /* Lines not supported              */
#define LC_POLYLINE         2   /* Can do polylines                 */
#define LC_MARKER           4   /* Can do markers                   */
#define LC_POLYMARKER       8   /* Can do polymarkers               */
#define LC_WIDE             16  /* Can do wide lines                */
#define LC_STYLED           32  /* Can do styled lines              */
#define LC_WIDESTYLED       64  /* Can do wide styled lines         */
#define LC_INTERIORS        128 /* Can do interiors                 */

/* Polygonal Capabilities */
#define PC_NONE             0   /* Polygonals not supported         */
#define PC_POLYGON          1   /* Can do polygons                  */
#define PC_RECTANGLE        2   /* Can do rectangles                */
#define PC_WINDPOLYGON      4   /* Can do winding polygons          */
#define PC_TRAPEZOID        4   /* Can do trapezoids                */
#define PC_SCANLINE         8   /* Can do scanlines                 */
#define PC_WIDE             16  /* Can do wide borders              */
#define PC_STYLED           32  /* Can do styled borders            */
#define PC_WIDESTYLED       64  /* Can do wide styled borders       */
#define PC_INTERIORS        128 /* Can do interiors                 */

/* Polygonal Capabilities */
#define CP_NONE             0   /* No clipping of output            */
#define CP_RECTANGLE        1   /* Output clipped to rects          */

/* Text Capabilities */
#define TC_OP_CHARACTER     0x0001  /* Can do OutputPrecision   CHARACTER      */
#define TC_OP_STROKE        0x0002  /* Can do OutputPrecision   STROKE         */
#define TC_CP_STROKE        0x0004  /* Can do ClipPrecision     STROKE         */
#define TC_CR_90            0x0008  /* Can do CharRotAbility    90             */
#define TC_CR_ANY           0x0010  /* Can do CharRotAbility    ANY            */
#define TC_SF_X_YINDEP      0x0020  /* Can do ScaleFreedom      X_YINDEPENDENT */
#define TC_SA_DOUBLE        0x0040  /* Can do ScaleAbility      DOUBLE         */
#define TC_SA_INTEGER       0x0080  /* Can do ScaleAbility      INTEGER        */
#define TC_SA_CONTIN        0x0100  /* Can do ScaleAbility      CONTINUOUS     */
#define TC_EA_DOUBLE        0x0200  /* Can do EmboldenAbility   DOUBLE         */
#define TC_IA_ABLE          0x0400  /* Can do ItalisizeAbility  ABLE           */
#define TC_UA_ABLE          0x0800  /* Can do UnderlineAbility  ABLE           */
#define TC_SO_ABLE          0x1000  /* Can do StrikeOutAbility  ABLE           */
#define TC_RA_ABLE          0x2000  /* Can do RasterFontAble    ABLE           */
#define TC_VA_ABLE          0x4000  /* Can do VectorFontAble    ABLE           */
#define TC_RESERVED         0x8000

#endif /* NOGDICAPMASKS */

/* Raster Capabilities */
#define RC_BITBLT           1       /* Can do standard BLT.             */
#define RC_BANDING          2       /* Device requires banding support  */
#define RC_SCALING          4       /* Device requires scaling support  */
#define RC_BITMAP64         8       /* Device can support >64K bitmap   */
#define RC_GDI20_OUTPUT     0x0010      /* has 2.0 output calls         */
#define RC_DI_BITMAP        0x0080      /* supports DIB to memory       */
#define RC_PALETTE          0x0100      /* supports a palette           */
#define RC_DIBTODEV         0x0200      /* supports DIBitsToDevice      */
#define RC_BIGFONT          0x0400      /* supports >64K fonts          */
#define RC_STRETCHBLT       0x0800      /* supports StretchBlt          */
#define RC_FLOODFILL        0x1000      /* supports FloodFill           */
#define RC_STRETCHDIB       0x2000      /* supports StretchDIBits       */


/* palette entry flags */

#define PC_RESERVED     0x01    /* palette index used for animation */
#define PC_EXPLICIT     0x02    /* palette index is explicit to device */
#define PC_NOCOLLAPSE   0x04    /* do not match color to system palette */

/* DIB color table identifiers */

#define DIB_RGB_COLORS  0       /* color table in RGBTriples */
#define DIB_PAL_COLORS  1       /* color table in palette indices */

/* constants for Get/SetSystemPaletteUse() */

#define SYSPAL_STATIC   1
#define SYSPAL_NOSTATIC 2

/* constants for CreateDIBitmap */
#define CBM_INIT        0x04L   /* initialize bitmap */

#ifndef NODRAWTEXT

/* DrawText() Format Flags */
#define DT_TOP              0x0000
#define DT_LEFT             0x0000
#define DT_CENTER           0x0001
#define DT_RIGHT            0x0002
#define DT_VCENTER          0x0004
#define DT_BOTTOM           0x0008
#define DT_WORDBREAK        0x0010
#define DT_SINGLELINE       0x0020
#define DT_EXPANDTABS       0x0040
#define DT_TABSTOP          0x0080
#define DT_NOCLIP           0x0100
#define DT_EXTERNALLEADING  0x0200
#define DT_CALCRECT         0x0400
#define DT_NOPREFIX         0x0800
#define DT_INTERNAL         0x1000

int  FAR PASCAL DrawText(HDC, LPSTR, int, LPRECT, WORD);
BOOL FAR PASCAL DrawIcon(HDC, int, int, HICON);

#endif /* NODRAWTEXT */

/* ExtFloodFill style flags */
#define  FLOODFILLBORDER   0
#define  FLOODFILLSURFACE  1

HDC   FAR PASCAL GetWindowDC(HWND);
HDC   FAR PASCAL GetDC(HWND);
int   FAR PASCAL ReleaseDC(HWND, HDC);
HDC   FAR PASCAL CreateDC(LPSTR, LPSTR, LPSTR, LPSTR);
HDC   FAR PASCAL CreateIC(LPSTR, LPSTR, LPSTR, LPSTR);
HDC   FAR PASCAL CreateCompatibleDC(HDC);
BOOL  FAR PASCAL DeleteDC(HDC);
int   FAR PASCAL SaveDC(HDC);
BOOL  FAR PASCAL RestoreDC(HDC, int);
DWORD FAR PASCAL MoveTo(HDC, int, int);
DWORD FAR PASCAL GetCurrentPosition(HDC);
BOOL  FAR PASCAL LineTo(HDC, int, int);
DWORD FAR PASCAL GetDCOrg(HDC);

int   FAR PASCAL MulDiv(int, int, int);

BOOL FAR PASCAL ExtTextOut(HDC, int, int, WORD, LPRECT, LPSTR, WORD, LPINT);

BOOL FAR PASCAL Polyline(HDC, LPPOINT, int);
BOOL FAR PASCAL Polygon(HDC, LPPOINT, int);
BOOL FAR PASCAL PolyPolygon(HDC, LPPOINT, LPINT, int);

BOOL  FAR PASCAL Rectangle(HDC, int, int, int, int);
BOOL  FAR PASCAL RoundRect(HDC, int, int, int, int, int, int);
BOOL  FAR PASCAL Ellipse(HDC, int, int, int, int);
BOOL  FAR PASCAL Arc(HDC, int, int, int, int, int, int, int, int);
BOOL  FAR PASCAL Chord(HDC, int, int, int, int, int, int, int, int);
BOOL  FAR PASCAL Pie(HDC, int, int, int, int, int, int, int, int);
BOOL  FAR PASCAL PatBlt(HDC, int, int, int, int, DWORD);
BOOL  FAR PASCAL BitBlt(HDC, int, int, int, int, HDC, int, int, DWORD);
BOOL  FAR PASCAL StretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD);
BOOL  FAR PASCAL TextOut(HDC, int, int, LPSTR, int);
LONG  FAR PASCAL TabbedTextOut(HDC, int, int, LPSTR, int, int, LPINT, int);
BOOL  FAR PASCAL GetCharWidth(HDC, WORD, WORD, LPINT);
DWORD FAR PASCAL SetPixel( HDC, int, int, DWORD);
DWORD FAR PASCAL GetPixel( HDC, int, int);
BOOL  FAR PASCAL FloodFill( HDC, int, int, DWORD);
BOOL  FAR PASCAL ExtFloodFill(HDC, int, int, DWORD, WORD);
void  FAR PASCAL LineDDA(int, int, int, int, FARPROC, LPSTR);

HANDLE FAR PASCAL GetStockObject(int);

HPEN FAR PASCAL CreatePen(int, int, DWORD);
HPEN FAR PASCAL CreatePenIndirect(LOGPEN FAR *);

HBRUSH FAR PASCAL CreateSolidBrush(DWORD);
HBRUSH FAR PASCAL CreateHatchBrush(int,DWORD);
DWORD  FAR PASCAL SetBrushOrg(HDC, int, int);
DWORD  FAR PASCAL GetBrushOrg(HDC);
HBRUSH FAR PASCAL CreatePatternBrush(HBITMAP);
HBRUSH FAR PASCAL CreateBrushIndirect(LOGBRUSH FAR *);

HBITMAP FAR PASCAL CreateBitmap(int, int, BYTE, BYTE, LPSTR);
HBITMAP FAR PASCAL CreateBitmapIndirect(BITMAP FAR *);
HBITMAP FAR PASCAL CreateCompatibleBitmap(HDC, int, int);
HBITMAP FAR PASCAL CreateDiscardableBitmap(HDC, int, int);

LONG  FAR PASCAL SetBitmapBits(HBITMAP, DWORD, LPSTR);
LONG  FAR PASCAL GetBitmapBits(HBITMAP, LONG, LPSTR);
DWORD FAR PASCAL SetBitmapDimension(HBITMAP, int, int);
DWORD FAR PASCAL GetBitmapDimension(HBITMAP);

HFONT FAR PASCAL CreateFont(int, int, int, int, int, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, LPSTR);
HFONT FAR PASCAL CreateFontIndirect(LOGFONT FAR *);

int  FAR PASCAL SelectClipRgn(HDC, HRGN);
HRGN FAR PASCAL CreateRectRgn(int, int, int, int);
void FAR PASCAL SetRectRgn(HRGN, int, int, int, int);
HRGN FAR PASCAL CreateRectRgnIndirect(LPRECT);
HRGN FAR PASCAL CreateEllipticRgnIndirect(LPRECT);
HRGN FAR PASCAL CreateEllipticRgn(int, int, int, int);
HRGN FAR PASCAL CreatePolygonRgn(LPPOINT, int, int);
HRGN FAR PASCAL CreatePolyPolygonRgn(LPPOINT, LPINT, int, int);
HRGN FAR PASCAL CreateRoundRectRgn(int, int, int, int, int, int);

int    FAR PASCAL GetObject(HANDLE, int, LPSTR);
BOOL   FAR PASCAL DeleteObject(HANDLE);
HANDLE FAR PASCAL SelectObject(HDC, HANDLE);
BOOL   FAR PASCAL UnrealizeObject(HBRUSH);

DWORD FAR PASCAL SetBkColor(HDC, DWORD);
DWORD FAR PASCAL GetBkColor(HDC);
int   FAR PASCAL SetBkMode(HDC, int);
int   FAR PASCAL GetBkMode(HDC);
DWORD FAR PASCAL SetTextColor(HDC, DWORD);
DWORD FAR PASCAL GetTextColor(HDC);
WORD  FAR PASCAL SetTextAlign(HDC, WORD);
WORD  FAR PASCAL GetTextAlign(HDC);
DWORD FAR PASCAL SetMapperFlags(HDC, DWORD);
DWORD FAR PASCAL GetAspectRatioFilter(HDC);
DWORD FAR PASCAL GetNearestColor(HDC, DWORD);
int   FAR PASCAL SetROP2(HDC, int);
int   FAR PASCAL GetROP2(HDC);
int   FAR PASCAL SetStretchBltMode(HDC, int);
int   FAR PASCAL GetStretchBltMode(HDC);
int   FAR PASCAL SetPolyFillMode(HDC, int);
int   FAR PASCAL GetPolyFillMode(HDC);
int   FAR PASCAL SetMapMode(HDC, int);
int   FAR PASCAL GetMapMode(HDC);
DWORD FAR PASCAL SetWindowOrg(HDC, int, int);
DWORD FAR PASCAL GetWindowOrg(HDC);
DWORD FAR PASCAL SetWindowExt(HDC, int, int);
DWORD FAR PASCAL GetWindowExt(HDC);
DWORD FAR PASCAL SetViewportOrg(HDC, int, int);
DWORD FAR PASCAL GetViewportOrg(HDC);
DWORD FAR PASCAL SetViewportExt(HDC, int, int);
DWORD FAR PASCAL GetViewportExt(HDC);
DWORD FAR PASCAL OffsetViewportOrg(HDC, int, int);
DWORD FAR PASCAL ScaleViewportExt(HDC, int, int, int, int);
DWORD FAR PASCAL OffsetWindowOrg(HDC, int, int);
DWORD FAR PASCAL ScaleWindowExt(HDC, int, int, int, int);

int  FAR PASCAL GetClipBox(HDC, LPRECT);
int  FAR PASCAL IntersectClipRect(HDC, int, int, int, int);
int  FAR PASCAL OffsetClipRgn(HDC, int, int);
int  FAR PASCAL ExcludeClipRect(HDC, int, int, int, int);
BOOL FAR PASCAL PtVisible(HDC, int, int);
int  FAR PASCAL CombineRgn(HRGN, HRGN, HRGN, int);
BOOL FAR PASCAL EqualRgn(HRGN, HRGN);
int  FAR PASCAL OffsetRgn(HRGN, int, int);
int  FAR PASCAL GetRgnBox(HRGN, LPRECT);

int   FAR PASCAL SetTextJustification(HDC, int, int);
DWORD FAR PASCAL GetTextExtent(HDC, LPSTR, int);
DWORD FAR PASCAL GetTabbedTextExtent(HDC, LPSTR, int, int, LPINT);
int   FAR PASCAL SetTextCharacterExtra(HDC, int);
int   FAR PASCAL GetTextCharacterExtra(HDC);

HANDLE FAR PASCAL GetMetaFile(LPSTR);
BOOL   FAR PASCAL DeleteMetaFile(HANDLE);
HANDLE FAR PASCAL CopyMetaFile(HANDLE, LPSTR);

#ifndef NOMETAFILE
void FAR PASCAL PlayMetaFileRecord(HDC, LPHANDLETABLE, LPMETARECORD, WORD);
BOOL FAR PASCAL EnumMetaFile(HDC, LOCALHANDLE, FARPROC, BYTE FAR *);
#endif

BOOL FAR PASCAL PlayMetaFile(HDC, HANDLE);
int FAR PASCAL Escape(HDC, int, int, LPSTR, LPSTR);
int FAR PASCAL EnumFonts(HDC, LPSTR, FARPROC, LPSTR);
int FAR PASCAL EnumObjects(HDC, int, FARPROC, LPSTR);
int FAR PASCAL GetTextFace(HDC, int, LPSTR);

#ifndef NOTEXTMETRIC
BOOL FAR PASCAL GetTextMetrics(HDC, LPTEXTMETRIC );
#endif

int FAR PASCAL GetDeviceCaps(HDC, int);

int FAR PASCAL SetEnvironment(LPSTR, LPSTR, WORD);
int FAR PASCAL GetEnvironment(LPSTR, LPSTR, WORD);

BOOL FAR PASCAL DPtoLP(HDC, LPPOINT, int);
BOOL FAR PASCAL LPtoDP(HDC, LPPOINT, int);

HANDLE FAR PASCAL CreateMetaFile(LPSTR);
HANDLE FAR PASCAL CloseMetaFile(HANDLE);
HANDLE FAR PASCAL GetMetaFileBits(HANDLE);
HANDLE FAR PASCAL SetMetaFileBits(HANDLE);

int FAR PASCAL SetDIBits(HDC,HANDLE,WORD,WORD,LPSTR,LPBITMAPINFO,WORD);
int FAR PASCAL GetDIBits(HDC,HANDLE,WORD,WORD,LPSTR,LPBITMAPINFO,WORD);
int FAR PASCAL SetDIBitsToDevice(HDC,WORD,WORD,WORD,WORD,
                                        WORD,WORD,WORD,WORD,
                                        LPSTR,LPBITMAPINFO,WORD);
HBITMAP FAR PASCAL CreateDIBitmap(HDC,LPBITMAPINFOHEADER,DWORD,LPSTR,
                                                LPBITMAPINFO,WORD);
HBRUSH FAR PASCAL CreateDIBPatternBrush(HANDLE,WORD);
int FAR PASCAL StretchDIBits(HDC, WORD, WORD, WORD, WORD, WORD, 
                        WORD, WORD, WORD, LPSTR, LPBITMAPINFO, WORD, DWORD);

HPALETTE FAR PASCAL CreatePalette (LPLOGPALETTE);
HPALETTE  FAR PASCAL SelectPalette (HDC,HPALETTE, BOOL) ;
WORD FAR PASCAL RealizePalette (HDC) ;
int  FAR PASCAL UpdateColors (HDC) ;
void FAR PASCAL AnimatePalette(HPALETTE, WORD, WORD, LPPALETTEENTRY);
WORD FAR PASCAL SetPaletteEntries(HPALETTE,WORD,WORD,LPPALETTEENTRY);
WORD FAR PASCAL GetPaletteEntries(HPALETTE,WORD,WORD,LPPALETTEENTRY);
WORD FAR PASCAL GetNearestPaletteIndex(HPALETTE, DWORD);
BOOL FAR PASCAL ResizePalette(HPALETTE, WORD);

WORD FAR PASCAL GetSystemPaletteEntries(HDC,WORD,WORD,LPPALETTEENTRY);
WORD FAR PASCAL GetSystemPaletteUse(HDC, WORD);
WORD FAR PASCAL SetSystemPaletteUse(HDC, WORD);
#endif /* NOGDI */


/*--------------------------------------------------------------------------*/
/*      USER Section                                                        */
/*--------------------------------------------------------------------------*/

#ifndef NOUSER

int FAR PASCAL wvsprintf(LPSTR,LPSTR,LPSTR);
int FAR cdecl wsprintf(LPSTR,LPSTR,...);

#ifndef NOSCROLL

/* Scroll Bar Constants */
#define SB_HORZ             0
#define SB_VERT             1
#define SB_CTL              2
#define SB_BOTH             3

/* Scroll Bar Commands */
#define SB_LINEUP           0
#define SB_LINEDOWN         1
#define SB_PAGEUP           2
#define SB_PAGEDOWN         3
#define SB_THUMBPOSITION    4
#define SB_THUMBTRACK       5
#define SB_TOP              6
#define SB_BOTTOM           7
#define SB_ENDSCROLL        8

#endif /* NOSCROLL */

#ifndef NOSHOWWINDOW

/* ShowWindow() Commands */
#define SW_HIDE             0
#define SW_SHOWNORMAL       1
#define SW_NORMAL           1
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE         3
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW             5
#define SW_MINIMIZE         6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA           8
#define SW_RESTORE          9

/* Old ShowWindow() Commands */
#define HIDE_WINDOW         0
#define SHOW_OPENWINDOW     1
#define SHOW_ICONWINDOW     2
#define SHOW_FULLSCREEN     3
#define SHOW_OPENNOACTIVATE 4

/* Identifiers for the WM_SHOWWINDOW message */
#define SW_PARENTCLOSING    1
#define SW_OTHERZOOM        2
#define SW_PARENTOPENING    3
#define SW_OTHERUNZOOM      4

#endif /* NOSHOWWINDOW */

/* Region Flags */
#define ERROR               0
#define NULLREGION          1
#define SIMPLEREGION        2
#define COMPLEXREGION       3

/* CombineRgn() Styles */
#define RGN_AND             1
#define RGN_OR              2
#define RGN_XOR             3
#define RGN_DIFF            4
#define RGN_COPY            5

#ifndef NOVIRTUALKEYCODES

/* Virtual Keys, Standard Set */
#define VK_LBUTTON          0x01
#define VK_RBUTTON          0x02
#define VK_CANCEL           0x03
#define VK_MBUTTON          0x04    /* NOT contiguous with L & RBUTTON */
#define VK_BACK             0x08
#define VK_TAB              0x09
#define VK_CLEAR            0x0C
#define VK_RETURN           0x0D
#define VK_SHIFT            0x10
#define VK_CONTROL          0x11
#define VK_MENU             0x12
#define VK_PAUSE            0x13
#define VK_CAPITAL          0x14
#define VK_ESCAPE           0x1B
#define VK_SPACE            0x20
#define VK_PRIOR            0x21
#define VK_NEXT             0x22
#define VK_END              0x23
#define VK_HOME             0x24
#define VK_LEFT             0x25
#define VK_UP               0x26
#define VK_RIGHT            0x27
#define VK_DOWN             0x28
#define VK_SELECT           0x29
#define VK_PRINT            0x2A
#define VK_EXECUTE          0x2B
#define VK_SNAPSHOT         0x2C
/* #define VK_COPY          0x2C not used by keyboards. */
#define VK_INSERT           0x2D
#define VK_DELETE           0x2E
#define VK_HELP             0x2F

/* VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z' */
/* VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '0' */

#define VK_NUMPAD0          0x60
#define VK_NUMPAD1          0x61
#define VK_NUMPAD2          0x62
#define VK_NUMPAD3          0x63
#define VK_NUMPAD4          0x64
#define VK_NUMPAD5          0x65
#define VK_NUMPAD6          0x66
#define VK_NUMPAD7          0x67
#define VK_NUMPAD8          0x68
#define VK_NUMPAD9          0x69
#define VK_MULTIPLY         0x6A
#define VK_ADD              0x6B
#define VK_SEPARATOR        0x6C
#define VK_SUBTRACT         0x6D
#define VK_DECIMAL          0x6E
#define VK_DIVIDE           0x6F
#define VK_F1               0x70
#define VK_F2               0x71
#define VK_F3               0x72
#define VK_F4               0x73
#define VK_F5               0x74
#define VK_F6               0x75
#define VK_F7               0x76
#define VK_F8               0x77
#define VK_F9               0x78
#define VK_F10              0x79
#define VK_F11              0x7A
#define VK_F12              0x7B
#define VK_F13              0x7C
#define VK_F14              0x7D
#define VK_F15              0x7E
#define VK_F16              0x7F

#define VK_NUMLOCK          0x90

#endif /* NOVIRTUALKEYCODES */

#ifndef NOWH

/* SetWindowsHook() codes */
#define WH_MSGFILTER        (-1)
#define WH_JOURNALRECORD    0
#define WH_JOURNALPLAYBACK  1
#define WH_KEYBOARD         2
#define WH_GETMESSAGE       3
#define WH_CALLWNDPROC      4
#define WH_CBT              5
#define WH_SYSMSGFILTER     6
#define WH_WINDOWMGR        7

/* Hook Codes */
#define HC_LPLPFNNEXT       (-2)
#define HC_LPFNNEXT         (-1)
#define HC_ACTION           0
#define HC_GETNEXT          1
#define HC_SKIP             2
#define HC_NOREM            3
#define HC_NOREMOVE         3
#define HC_SYSMODALON       4
#define HC_SYSMODALOFF      5

/* CBT Hook Codes */
#define HCBT_MOVESIZE       0
#define HCBT_MINMAX         1
#define HCBT_QS             2

/* WH_MSGFILTER Filter Proc Codes */
#define MSGF_DIALOGBOX      0
#define MSGF_MESSAGEBOX     1
#define MSGF_MENU           2
#define MSGF_MOVE           3
#define MSGF_SIZE           4
#define MSGF_SCROLLBAR      5
#define MSGF_NEXTWINDOW     6

/* Window Manager Hook Codes */
#define WC_INIT             1
#define WC_SWP              2
#define WC_DEFWINDOWPROC    3
#define WC_MINMAX           4
#define WC_MOVE             5
#define WC_SIZE             6
#define WC_DRAWCAPTION      7

/* Message Structure used in Journaling */
typedef struct tagEVENTMSG
  {
    WORD    message;
    WORD    paramL;
    WORD    paramH;
    DWORD   time;
  } EVENTMSG;
typedef EVENTMSG            *PEVENTMSGMSG;
typedef EVENTMSG NEAR       *NPEVENTMSGMSG;
typedef EVENTMSG FAR        *LPEVENTMSGMSG;

#endif /* NOWH */

typedef struct tagWNDCLASS
  {
    WORD        style;
    LONG        (FAR PASCAL *lpfnWndProc)();
    int         cbClsExtra;
    int         cbWndExtra;
    HANDLE      hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPSTR       lpszMenuName;
    LPSTR       lpszClassName;
  } WNDCLASS;
typedef WNDCLASS            *PWNDCLASS;
typedef WNDCLASS NEAR       *NPWNDCLASS;
typedef WNDCLASS FAR        *LPWNDCLASS;

#ifndef NOMSG

/* Message structure */
typedef struct tagMSG
  {
    HWND        hwnd;
    WORD        message;
    WORD        wParam;
    LONG        lParam;
    DWORD       time;
    POINT       pt;
  } MSG;
typedef MSG                 *PMSG;
typedef MSG NEAR            *NPMSG;
typedef MSG FAR             *LPMSG;

#endif /* NOMSG */

#ifndef NOWINOFFSETS

/* Window field offsets for GetWindowLong() and GetWindowWord() */
#define GWL_WNDPROC         (-4)
#define GWW_HINSTANCE       (-6)
#define GWW_HWNDPARENT      (-8)
#define GWW_ID              (-12)
#define GWL_STYLE           (-16)
#define GWL_EXSTYLE         (-20)

/* Class field offsets for GetClassLong() and GetClassWord() */
#define GCL_MENUNAME        (-8)
#define GCW_HBRBACKGROUND   (-10)
#define GCW_HCURSOR         (-12)
#define GCW_HICON           (-14)
#define GCW_HMODULE         (-16)
#define GCW_CBWNDEXTRA      (-18)
#define GCW_CBCLSEXTRA      (-20)
#define GCL_WNDPROC         (-24)
#define GCW_STYLE           (-26)

#endif /* NOWINOFFSETS */

#ifndef NOWINMESSAGES

/* Window Messages */
#define WM_NULL             0x0000
#define WM_CREATE           0x0001
#define WM_DESTROY          0x0002
#define WM_MOVE             0x0003
#define WM_SIZE             0x0005
#define WM_ACTIVATE         0x0006
#define WM_SETFOCUS         0x0007
#define WM_KILLFOCUS        0x0008
#define WM_ENABLE           0x000A
#define WM_SETREDRAW        0x000B
#define WM_SETTEXT          0x000C
#define WM_GETTEXT          0x000D
#define WM_GETTEXTLENGTH    0x000E
#define WM_PAINT            0x000F
#define WM_CLOSE            0x0010
#define WM_QUERYENDSESSION  0x0011
#define WM_QUIT             0x0012
#define WM_QUERYOPEN        0x0013
#define WM_ERASEBKGND       0x0014
#define WM_SYSCOLORCHANGE   0x0015
#define WM_ENDSESSION       0x0016
#define WM_SHOWWINDOW       0x0018
#define WM_CTLCOLOR         0x0019
#define WM_SETTINGCHANGE    0x001A
#define WM_DEVMODECHANGE    0x001B
#define WM_ACTIVATEAPP      0x001C
#define WM_FONTCHANGE       0x001D
#define WM_TIMECHANGE       0x001E
#define WM_CANCELMODE       0x001F
#define WM_SETCURSOR        0x0020
#define WM_MOUSEACTIVATE    0x0021
#define WM_CHILDACTIVATE    0x0022
#define WM_QUEUESYNC        0x0023
#define WM_GETMINMAXINFO    0x0024
#define WM_PAINTICON        0x0026
#define WM_ICONERASEBKGND   0x0027
#define WM_NEXTDLGCTL       0x0028
#define WM_SPOOLERSTATUS    0x002A
#define WM_DRAWITEM         0x002B
#define WM_MEASUREITEM      0x002C
#define WM_DELETEITEM       0x002D
#define WM_VKEYTOITEM       0x002E
#define WM_CHARTOITEM       0x002F
#define WM_SETFONT          0x0030
#define WM_GETFONT          0x0031


#define WM_QUERYDRAGICON    0x0037

#define WM_COMPAREITEM      0x0039
#define WM_COMPACTING       0x0041

#define WM_NCCREATE         0x0081
#define WM_NCDESTROY        0x0082
#define WM_NCCALCSIZE       0x0083
#define WM_NCHITTEST        0x0084
#define WM_NCPAINT          0x0085
#define WM_NCACTIVATE       0x0086
#define WM_GETDLGCODE       0x0087
#define WM_NCMOUSEMOVE      0x00A0
#define WM_NCLBUTTONDOWN    0x00A1
#define WM_NCLBUTTONUP      0x00A2
#define WM_NCLBUTTONDBLCLK  0x00A3
#define WM_NCRBUTTONDOWN    0x00A4
#define WM_NCRBUTTONUP      0x00A5
#define WM_NCRBUTTONDBLCLK  0x00A6
#define WM_NCMBUTTONDOWN    0x00A7
#define WM_NCMBUTTONUP      0x00A8
#define WM_NCMBUTTONDBLCLK  0x00A9

#define WM_KEYFIRST         0x0100
#define WM_KEYDOWN          0x0100
#define WM_KEYUP            0x0101
#define WM_CHAR             0x0102
#define WM_DEADCHAR         0x0103
#define WM_SYSKEYDOWN       0x0104
#define WM_SYSKEYUP         0x0105
#define WM_SYSCHAR          0x0106
#define WM_SYSDEADCHAR      0x0107
#define WM_KEYLAST          0x0108

#define WM_INITDIALOG       0x0110
#define WM_COMMAND          0x0111
#define WM_SYSCOMMAND       0x0112
#define WM_TIMER            0x0113
#define WM_HSCROLL          0x0114
#define WM_VSCROLL          0x0115
#define WM_INITMENU         0x0116
#define WM_INITMENUPOPUP    0x0117
#define WM_MENUSELECT       0x011F
#define WM_MENUCHAR         0x0120
#define WM_ENTERIDLE        0x0121


#define WM_MOUSEFIRST       0x0200
#define WM_MOUSEMOVE        0x0200
#define WM_LBUTTONDOWN      0x0201
#define WM_LBUTTONUP        0x0202
#define WM_LBUTTONDBLCLK    0x0203
#define WM_RBUTTONDOWN      0x0204
#define WM_RBUTTONUP        0x0205
#define WM_RBUTTONDBLCLK    0x0206
#define WM_MBUTTONDOWN      0x0207
#define WM_MBUTTONUP        0x0208
#define WM_MBUTTONDBLCLK    0x0209
#define WM_MOUSELAST        0x0209

#define WM_PARENTNOTIFY     0x0210
#define WM_MDICREATE        0x0220
#define WM_MDIDESTROY       0x0221
#define WM_MDIACTIVATE      0x0222
#define WM_MDIRESTORE       0x0223
#define WM_MDINEXT          0x0224
#define WM_MDIMAXIMIZE      0x0225
#define WM_MDITILE          0x0226
#define WM_MDICASCADE       0x0227
#define WM_MDIICONARRANGE   0x0228
#define WM_MDIGETACTIVE     0x0229
#define WM_MDISETMENU       0x0230


#define WM_CUT              0x0300
#define WM_COPY             0x0301
#define WM_PASTE            0x0302
#define WM_CLEAR            0x0303
#define WM_UNDO             0x0304
#define WM_RENDERFORMAT     0x0305
#define WM_RENDERALLFORMATS 0x0306
#define WM_DESTROYCLIPBOARD 0x0307
#define WM_DRAWCLIPBOARD    0x0308
#define WM_PAINTCLIPBOARD   0x0309
#define WM_VSCROLLCLIPBOARD 0x030A
#define WM_SIZECLIPBOARD    0x030B
#define WM_ASKCBFORMATNAME  0x030C
#define WM_CHANGECBCHAIN    0x030D
#define WM_HSCROLLCLIPBOARD 0x030E
#define WM_QUERYNEWPALETTE  0x030F
#define WM_PALETTEISCHANGING 0x0310
#define WM_PALETTECHANGED   0x0311




/* NOTE: All Message Numbers below 0x0400 are RESERVED. */

/* Private Window Messages Start Here: */
#define WM_USER             0x0400

#ifndef NONCMESSAGES

/* WM_SYNCTASK Commands */
#define ST_BEGINSWP         0
#define ST_ENDSWP           1

/* WinWhere() Area Codes */
#define HTERROR             (-2)
#define HTTRANSPARENT       (-1)
#define HTNOWHERE           0
#define HTCLIENT            1
#define HTCAPTION           2
#define HTSYSMENU           3
#define HTGROWBOX           4
#define HTSIZE              HTGROWBOX
#define HTMENU              5
#define HTHSCROLL           6
#define HTVSCROLL           7
#define HTREDUCE            8
#define HTZOOM              9
#define HTLEFT              10
#define HTRIGHT             11
#define HTTOP               12
#define HTTOPLEFT           13
#define HTTOPRIGHT          14
#define HTBOTTOM            15
#define HTBOTTOMLEFT        16
#define HTBOTTOMRIGHT       17
#define HTSIZEFIRST         HTLEFT
#define HTSIZELAST          HTBOTTOMRIGHT

#endif /* NONCMESSAGES */

/* WM_MOUSEACTIVATE Return Codes */
#define MA_ACTIVATE         1
#define MA_ACTIVATEANDEAT   2
#define MA_NOACTIVATE       3

WORD FAR PASCAL RegisterWindowMessage(LPSTR);

/* Size Message Commands */
#define SIZENORMAL          0
#define SIZEICONIC          1
#define SIZEFULLSCREEN      2
#define SIZEZOOMSHOW        3
#define SIZEZOOMHIDE        4

#ifndef NOKEYSTATES

/* Key State Masks for Mouse Messages */
#define MK_LBUTTON          0x0001
#define MK_RBUTTON          0x0002
#define MK_SHIFT            0x0004
#define MK_CONTROL          0x0008
#define MK_MBUTTON          0x0010

#endif /* NOKEYSTATES */

#endif /* NOWINMESSAGES */

#ifndef NOWINSTYLES

/* Window Styles */
#define WS_OVERLAPPED       0x00000000L
#define WS_POPUP            0x80000000L
#define WS_CHILD            0x40000000L
#define WS_MINIMIZE         0x20000000L
#define WS_VISIBLE          0x10000000L
#define WS_DISABLED         0x08000000L
#define WS_CLIPSIBLINGS     0x04000000L
#define WS_CLIPCHILDREN     0x02000000L
#define WS_MAXIMIZE         0x01000000L
#define WS_CAPTION          0x00C00000L     /* WS_BORDER | WS_DLGFRAME  */
#define WS_BORDER           0x00800000L
#define WS_DLGFRAME         0x00400000L
#define WS_VSCROLL          0x00200000L
#define WS_HSCROLL          0x00100000L
#define WS_SYSMENU          0x00080000L
#define WS_THICKFRAME       0x00040000L
#define WS_GROUP            0x00020000L
#define WS_TABSTOP          0x00010000L

#define WS_MINIMIZEBOX      0x00020000L
#define WS_MAXIMIZEBOX      0x00010000L

#define WS_TILED            WS_OVERLAPPED
#define WS_ICONIC           WS_MINIMIZE
#define WS_SIZEBOX          WS_THICKFRAME

/* Common Window Styles */
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_POPUPWINDOW      (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW      (WS_CHILD)

#define WS_TILEDWINDOW      (WS_OVERLAPPEDWINDOW)

/* Extended Window Styles */
#define WS_EX_DLGMODALFRAME 0x00000001L
#define WS_EX_NOPARENTNOTIFY 0x00000004L

/* Class styles */
#define CS_VREDRAW          0x0001
#define CS_HREDRAW          0x0002
#define CS_KEYCVTWINDOW     0x0004
#define CS_DBLCLKS          0x0008
                        /*  0x0010 -- no longer used */
#define CS_OWNDC            0x0020
#define CS_CLASSDC          0x0040
#define CS_PARENTDC         0x0080
#define CS_NOKEYCVT         0x0100
#define CS_NOCLOSE          0x0200
#define CS_SAVEBITS         0x0800
#define CS_BYTEALIGNCLIENT  0x1000
#define CS_BYTEALIGNWINDOW  0x2000
#define CS_GLOBALCLASS      0x4000    /* Global window class */

#endif /* NOWINSTYLES */

#ifndef NOCLIPBOARD

/* Predefined Clipboard Formats */
#define CF_TEXT             1
#define CF_BITMAP           2
#define CF_METAFILEPICT     3
#define CF_SYLK             4
#define CF_DIF              5
#define CF_TIFF             6
#define CF_OEMTEXT          7
#define CF_DIB              8
#define CF_PALETTE          9

#define CF_OWNERDISPLAY     0x0080
#define CF_DSPTEXT          0x0081
#define CF_DSPBITMAP        0x0082
#define CF_DSPMETAFILEPICT  0x0083

/* "Private" formats don't get GlobalFree()'d */
#define CF_PRIVATEFIRST     0x0200
#define CF_PRIVATELAST      0x02FF

/* "GDIOBJ" formats do get DeleteObject()'d */
#define CF_GDIOBJFIRST      0x0300
#define CF_GDIOBJLAST       0x03FF

#endif /* NOCLIPBOARD */

typedef struct tagPAINTSTRUCT
  {
    HDC         hdc;
    BOOL        fErase;
    RECT        rcPaint;
    BOOL        fRestore;
    BOOL        fIncUpdate;
    BYTE        rgbReserved[16];
  } PAINTSTRUCT;
typedef PAINTSTRUCT         *PPAINTSTRUCT;
typedef PAINTSTRUCT NEAR    *NPPAINTSTRUCT;
typedef PAINTSTRUCT FAR     *LPPAINTSTRUCT;

typedef struct tagCREATESTRUCT
  {
    LPSTR       lpCreateParams;
    HANDLE      hInstance;
    HANDLE      hMenu;
    HWND        hwndParent;
    int         cy;
    int         cx;
    int         y;
    int         x;
    LONG        style;
    LPSTR       lpszName;
    LPSTR       lpszClass;
    DWORD       dwExStyle;
  } CREATESTRUCT;
typedef CREATESTRUCT FAR    *LPCREATESTRUCT;


/* Owner draw control types */
#define ODT_MENU        1
#define ODT_LISTBOX     2
#define ODT_COMBOBOX    3
#define ODT_BUTTON      4

/* Owner draw actions */
#define ODA_DRAWENTIRE  0x0001
#define ODA_SELECT      0x0002
#define ODA_FOCUS       0x0004

/* Owner draw state */
#define ODS_SELECTED    0x0001
#define ODS_GRAYED      0x0002
#define ODS_DISABLED    0x0004
#define ODS_CHECKED     0x0008
#define ODS_FOCUS       0x0010

/* MEASUREITEMSTRUCT for ownerdraw */
typedef struct tagMEASUREITEMSTRUCT
  {
    WORD        CtlType;
    WORD        CtlID;
    WORD        itemID;
    WORD        itemWidth;
    WORD        itemHeight;
    DWORD       itemData;
  } MEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT NEAR *PMEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT FAR  *LPMEASUREITEMSTRUCT;


/* DRAWITEMSTRUCT for ownerdraw */
typedef struct tagDRAWITEMSTRUCT
  {
    WORD        CtlType;
    WORD        CtlID;
    WORD        itemID;
    WORD        itemAction;
    WORD        itemState;
    HWND        hwndItem;
    HDC         hDC;
    RECT        rcItem;
    DWORD       itemData;
  } DRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT NEAR *PDRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT FAR  *LPDRAWITEMSTRUCT;

/* DELETEITEMSTRUCT for ownerdraw */
typedef struct tagDELETEITEMSTRUCT
  {
    WORD       CtlType;
    WORD       CtlID;
    WORD       itemID;
    HWND       hwndItem;
    DWORD      itemData;
  } DELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT NEAR *PDELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT FAR  *LPDELETEITEMSTRUCT;

/* COMPAREITEMSTUCT for ownerdraw sorting */
typedef struct tagCOMPAREITEMSTRUCT
  {
    WORD        CtlType;
    WORD        CtlID;
    HWND        hwndItem;
    WORD        itemID1;
    DWORD       itemData1;
    WORD        itemID2;
    DWORD       itemData2;
  } COMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT NEAR *PCOMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT FAR  *LPCOMPAREITEMSTRUCT;

#ifndef NOMSG

/* Message Function Templates */
BOOL FAR PASCAL GetMessage(LPMSG, HWND, WORD, WORD);
BOOL FAR PASCAL TranslateMessage(LPMSG);
LONG FAR PASCAL DispatchMessage(LPMSG);
BOOL FAR PASCAL PeekMessage(LPMSG, HWND, WORD, WORD, WORD);

/* PeekMessage() Options */
#define PM_NOREMOVE         0x0000
#define PM_REMOVE           0x0001
#define PM_NOYIELD          0x0002

#endif /* NOMSG */

#ifdef WIN_INTERNAL
    #ifndef LSTRING
    #define NOLSTRING
    #endif
    #ifndef LFILEIO
    #define NOLFILEIO
    #endif
#endif

#ifndef NOLSTRING
int         FAR PASCAL lstrcmp( LPSTR, LPSTR );
int         FAR PASCAL lstrcmpi( LPSTR, LPSTR );
LPSTR       FAR PASCAL lstrcpy( LPSTR, LPSTR );
LPSTR       FAR PASCAL lstrcat( LPSTR, LPSTR );
int         FAR PASCAL lstrlen( LPSTR );
#endif  /* NOLSTRING */

#ifndef NOLFILEIO
int         FAR PASCAL _lopen( LPSTR, int );
int         FAR PASCAL _lclose( int );
int         FAR PASCAL _lcreat( LPSTR, int );
LONG        FAR PASCAL _llseek( int, long, int );
WORD        FAR PASCAL _lread( int, LPSTR, int );
WORD        FAR PASCAL _lwrite( int, LPSTR, int );

#define READ        0   /* Flags for _lopen */
#define WRITE       1
#define READ_WRITE  2
#endif  /* NOLFILEIO */

BOOL  FAR PASCAL ExitWindows(DWORD dwReserved, WORD wReturnCode);

BOOL  FAR PASCAL SwapMouseButton(BOOL);
DWORD FAR PASCAL GetMessagePos(void);
LONG  FAR PASCAL GetMessageTime(void);

HWND  FAR PASCAL GetSysModalWindow(void);
HWND  FAR PASCAL SetSysModalWindow(HWND);

LONG  FAR PASCAL SendMessage(HWND, WORD, WORD, LONG);
BOOL  FAR PASCAL PostMessage(HWND, WORD, WORD, LONG);
BOOL  FAR PASCAL PostAppMessage(HANDLE, WORD, WORD, LONG);
void  FAR PASCAL ReplyMessage(LONG);
void  FAR PASCAL WaitMessage(void);
LONG  FAR PASCAL DefWindowProc(HWND, WORD, WORD, LONG);
void  FAR PASCAL PostQuitMessage(int);
LONG  FAR PASCAL CallWindowProc(FARPROC, HWND, WORD, WORD, LONG);
BOOL  FAR PASCAL InSendMessage(void);
DWORD FAR PASCAL InSendMessageEx(LPVOID);

WORD  FAR PASCAL GetDoubleClickTime(void);
void  FAR PASCAL SetDoubleClickTime(WORD);

BOOL  FAR PASCAL RegisterClass(LPWNDCLASS);
BOOL  FAR PASCAL UnregisterClass(LPSTR, HANDLE);
BOOL  FAR PASCAL GetClassInfo(HANDLE, LPSTR, LPWNDCLASS);

BOOL  FAR PASCAL SetMessageQueue(int);

#define CW_USEDEFAULT       ((int)0x8000)
HWND  FAR PASCAL CreateWindow(LPSTR, LPSTR, DWORD, int, int, int, int, HWND, HMENU, HANDLE, LPSTR);
HWND  FAR PASCAL CreateWindowEx(DWORD, LPSTR, LPSTR, DWORD, int, int, int, int, HWND, HMENU, HANDLE, LPSTR);

BOOL FAR PASCAL IsWindow(HWND);
BOOL FAR PASCAL IsChild(HWND, HWND);
BOOL FAR PASCAL DestroyWindow(HWND);

BOOL FAR PASCAL ShowWindow(HWND, int);
BOOL FAR PASCAL FlashWindow(HWND, BOOL);
void FAR PASCAL ShowOwnedPopups(HWND, BOOL);

BOOL FAR PASCAL OpenIcon(HWND);
void FAR PASCAL CloseWindow(HWND);
void FAR PASCAL MoveWindow(HWND, int, int, int, int, BOOL);
void FAR PASCAL SetWindowPos(HWND, HWND, int, int, int, int, WORD);

#ifndef NODEFERWINDOWPOS

HANDLE FAR PASCAL BeginDeferWindowPos(int nNumWindows);
HANDLE FAR PASCAL DeferWindowPos(HANDLE hWinPosInfo, HWND hWnd, HWND hWndInsertAfter, int x, int y, int cx, int cy, WORD wFlags);
void FAR PASCAL EndDeferWindowPos(HANDLE hWinPosInfo);

#endif /* NODEFERWINDOWPOS */

BOOL FAR PASCAL IsWindowVisible(HWND);
BOOL FAR PASCAL IsIconic(HWND);
BOOL FAR PASCAL AnyPopup(void);
void FAR PASCAL BringWindowToTop(HWND);
BOOL FAR PASCAL IsZoomed(HWND);

/* SetWindowPos Flags */
#define SWP_NOSIZE          0x0001
#define SWP_NOMOVE          0x0002
#define SWP_NOZORDER        0x0004
#define SWP_NOREDRAW        0x0008
#define SWP_NOACTIVATE      0x0010
#define SWP_DRAWFRAME       0x0020
#define SWP_SHOWWINDOW      0x0040
#define SWP_HIDEWINDOW      0x0080
#define SWP_NOCOPYBITS      0x0100
#define SWP_NOREPOSITION    0x0200

#ifndef NOCTLMGR

HWND FAR PASCAL CreateDialog(HANDLE, LPSTR, HWND, FARPROC);
HWND FAR PASCAL CreateDialogIndirect(HANDLE, LPSTR, HWND, FARPROC);
HWND FAR PASCAL CreateDialogParam(HANDLE, LPSTR, HWND, FARPROC, LONG);
HWND FAR PASCAL CreateDialogIndirectParam(HANDLE, LPSTR, HWND, FARPROC, LONG);
int  FAR PASCAL DialogBox(HANDLE, LPSTR, HWND, FARPROC);
int  FAR PASCAL DialogBoxIndirect(HANDLE, HANDLE, HWND, FARPROC);
int  FAR PASCAL DialogBoxParam(HANDLE, LPSTR, HWND, FARPROC, LONG);
int  FAR PASCAL DialogBoxIndirectParam(HANDLE, HANDLE, HWND, FARPROC, LONG);
void FAR PASCAL EndDialog(HWND, int);
HWND FAR PASCAL GetDlgItem(HWND, int);
void FAR PASCAL SetDlgItemInt(HWND, int, WORD, BOOL);
WORD FAR PASCAL GetDlgItemInt(HWND, int, BOOL FAR *, BOOL);
void FAR PASCAL SetDlgItemText(HWND, int, LPSTR);
int  FAR PASCAL GetDlgItemText(HWND, int, LPSTR, int);
void FAR PASCAL CheckDlgButton(HWND, int, WORD);
void FAR PASCAL CheckRadioButton(HWND, int, int, int);
WORD FAR PASCAL IsDlgButtonChecked(HWND, int);
LONG FAR PASCAL SendDlgItemMessage(HWND, int, WORD, WORD, LONG);
HWND FAR PASCAL GetNextDlgGroupItem(HWND, HWND, BOOL);
HWND FAR PASCAL GetNextDlgTabItem(HWND, HWND, BOOL);
int  FAR PASCAL GetDlgCtrlID(HWND);
long FAR PASCAL GetDialogBaseUnits(void);
LONG FAR PASCAL DefDlgProc(HWND, WORD, WORD, LONG);
#define DLGWINDOWEXTRA   30     /* Window extra byted needed for private dialog classes */

#endif /* NOCTLMGR */

#ifndef NOMSG
BOOL FAR PASCAL CallMsgFilter(LPMSG, int);
#endif

#ifndef NOCLIPBOARD

/* Clipboard Manager Functions */
BOOL   FAR PASCAL OpenClipboard(HWND);
BOOL   FAR PASCAL CloseClipboard(void);
HWND   FAR PASCAL GetClipboardOwner(void);
HWND   FAR PASCAL SetClipboardViewer(HWND);
HWND   FAR PASCAL GetClipboardViewer(void);
BOOL   FAR PASCAL ChangeClipboardChain(HWND, HWND);
HANDLE FAR PASCAL SetClipboardData(WORD, HANDLE);
HANDLE FAR PASCAL GetClipboardData(WORD);
WORD   FAR PASCAL RegisterClipboardFormat(LPSTR);
int    FAR PASCAL CountClipboardFormats(void);
WORD   FAR PASCAL EnumClipboardFormats(WORD);
int    FAR PASCAL GetClipboardFormatName(WORD, LPSTR, int);
BOOL   FAR PASCAL EmptyClipboard(void);
BOOL   FAR PASCAL IsClipboardFormatAvailable(WORD);
int    FAR PASCAL GetPriorityClipboardFormat(WORD  FAR *, int);

#endif /* NOCLIPBOARD */

HWND FAR PASCAL SetFocus(HWND);
HWND FAR PASCAL GetFocus(void);
HWND FAR PASCAL GetActiveWindow(void);
int  FAR PASCAL GetKeyState(int);
int  FAR PASCAL GetAsyncKeyState(int);
void FAR PASCAL GetKeyboardState(BYTE FAR *);
void FAR PASCAL SetKeyboardState(BYTE FAR *);
BOOL FAR PASCAL EnableHardwareInput(BOOL);
BOOL FAR PASCAL GetInputState(void);
HWND FAR PASCAL GetCapture(void);
HWND FAR PASCAL SetCapture(HWND);
void FAR PASCAL ReleaseCapture(void);

/* Windows Functions */
WORD FAR PASCAL SetTimer(HWND, int, WORD, FARPROC);
BOOL FAR PASCAL KillTimer(HWND, int);

BOOL FAR PASCAL EnableWindow(HWND,BOOL);
BOOL FAR PASCAL IsWindowEnabled(HWND);

HANDLE FAR PASCAL LoadAccelerators(HANDLE, LPSTR);

#ifndef NOMSG
int  FAR PASCAL TranslateAccelerator(HWND, HANDLE, LPMSG);
#endif

#ifndef NOSYSMETRICS

/* GetSystemMetrics() codes */
#define SM_CXSCREEN         0
#define SM_CYSCREEN         1
#define SM_CXVSCROLL        2
#define SM_CYHSCROLL        3
#define SM_CYCAPTION        4
#define SM_CXBORDER         5
#define SM_CYBORDER         6
#define SM_CXDLGFRAME       7
#define SM_CYDLGFRAME       8
#define SM_CYVTHUMB         9
#define SM_CXHTHUMB         10
#define SM_CXICON           11
#define SM_CYICON           12
#define SM_CXCURSOR         13
#define SM_CYCURSOR         14
#define SM_CYMENU           15
#define SM_CXFULLSCREEN     16
#define SM_CYFULLSCREEN     17
#define SM_CYKANJIWINDOW    18
#define SM_MOUSEPRESENT     19
#define SM_CYVSCROLL        20
#define SM_CXHSCROLL        21
#define SM_DEBUG            22
#define SM_SWAPBUTTON       23
#define SM_RESERVED1        24
#define SM_RESERVED2        25
#define SM_RESERVED3        26
#define SM_RESERVED4        27
#define SM_CXMIN            28
#define SM_CYMIN            29
#define SM_CXSIZE           30
#define SM_CYSIZE           31
#define SM_CXFRAME          32
#define SM_CYFRAME          33
#define SM_CXMINTRACK       34
#define SM_CYMINTRACK       35
#define SM_CMETRICS         36

int FAR PASCAL GetSystemMetrics(int);

#endif /* NOSYSMETRICS */

#ifndef NOMENUS

HMENU FAR PASCAL LoadMenu(HANDLE, LPSTR);
HMENU FAR PASCAL LoadMenuIndirect(LPSTR);
HMENU FAR PASCAL GetMenu(HWND);
BOOL  FAR PASCAL SetMenu(HWND, HMENU);
BOOL  FAR PASCAL ChangeMenu(HMENU, WORD, LPSTR, WORD, WORD);
BOOL  FAR PASCAL HiliteMenuItem(HWND, HMENU, WORD, WORD);
int   FAR PASCAL GetMenuString(HMENU, WORD, LPSTR, int, WORD);
WORD  FAR PASCAL GetMenuState(HMENU, WORD, WORD);
void  FAR PASCAL DrawMenuBar(HWND);
HMENU FAR PASCAL GetSystemMenu(HWND, BOOL);
HMENU FAR PASCAL CreateMenu(void);
HMENU FAR PASCAL CreatePopupMenu(void);
BOOL  FAR PASCAL DestroyMenu(HMENU);
BOOL  FAR PASCAL CheckMenuItem(HMENU, WORD, WORD);
BOOL  FAR PASCAL EnableMenuItem(HMENU, WORD, WORD);
HMENU FAR PASCAL GetSubMenu(HMENU, int);
WORD  FAR PASCAL GetMenuItemID(HMENU, int);
WORD  FAR PASCAL GetMenuItemCount(HMENU);

BOOL  FAR PASCAL InsertMenu(HMENU, WORD, WORD, WORD, LPSTR);
BOOL  FAR PASCAL AppendMenu(HMENU, WORD, WORD, LPSTR);
BOOL  FAR PASCAL ModifyMenu(HMENU, WORD, WORD, WORD, LPSTR);
BOOL  FAR PASCAL RemoveMenu(HMENU, WORD, WORD);
BOOL  FAR PASCAL DeleteMenu(HMENU, WORD, WORD);
BOOL  FAR PASCAL SetMenuItemBitmaps(HMENU, WORD, WORD, HBITMAP, HBITMAP);
LONG  FAR PASCAL GetMenuCheckMarkDimensions(void);
BOOL  FAR PASCAL TrackPopupMenu(HMENU, WORD, int, int, int, HWND, LPRECT);

#endif /* NOMENUS */

BOOL FAR PASCAL GrayString(HDC, HBRUSH, FARPROC, DWORD, int, int, int, int, int);
void FAR PASCAL UpdateWindow(HWND);
HWND FAR PASCAL SetActiveWindow(HWND);

HDC  FAR PASCAL BeginPaint(HWND, LPPAINTSTRUCT);
void FAR PASCAL EndPaint(HWND, LPPAINTSTRUCT);
BOOL FAR PASCAL GetUpdateRect(HWND, LPRECT, BOOL);
int  FAR PASCAL GetUpdateRgn(HWND, HRGN, BOOL);

int  FAR PASCAL ExcludeUpdateRgn(HDC, HWND);

void FAR PASCAL InvalidateRect(HWND, LPRECT, BOOL);
void FAR PASCAL ValidateRect(HWND, LPRECT);

void FAR PASCAL InvalidateRgn(HWND, HRGN, BOOL);
void FAR PASCAL ValidateRgn(HWND, HRGN);

void FAR PASCAL ScrollWindow(HWND, int, int, LPRECT, LPRECT);
BOOL FAR PASCAL ScrollDC(HDC, int, int, LPRECT, LPRECT, HRGN, LPRECT);

#ifndef NOSCROLL
int  FAR PASCAL SetScrollPos(HWND, int, int, BOOL);
int  FAR PASCAL GetScrollPos(HWND, int);
void FAR PASCAL SetScrollRange(HWND, int, int, int, BOOL);
void FAR PASCAL GetScrollRange(HWND, int, LPINT, LPINT);
void FAR PASCAL ShowScrollBar(HWND, WORD, BOOL);
#endif

BOOL   FAR PASCAL SetProp(HWND, LPSTR, HANDLE);
HANDLE FAR PASCAL GetProp(HWND, LPSTR);
HANDLE FAR PASCAL RemoveProp(HWND, LPSTR);
int    FAR PASCAL EnumProps(HWND, FARPROC);
void   FAR PASCAL SetWindowText(HWND, LPSTR);
int    FAR PASCAL GetWindowText(HWND, LPSTR, int);
int    FAR PASCAL GetWindowTextLength(HWND);

void FAR PASCAL GetClientRect(HWND, LPRECT);
void FAR PASCAL GetWindowRect(HWND, LPRECT);
void FAR PASCAL AdjustWindowRect(LPRECT, LONG, BOOL);
void FAR PASCAL AdjustWindowRectEx(LPRECT, LONG, BOOL, DWORD);

#ifndef NOMB

/* MessageBox() Flags */
#define MB_OK               0x0000
#define MB_OKCANCEL         0x0001
#define MB_ABORTRETRYIGNORE 0x0002
#define MB_YESNOCANCEL      0x0003
#define MB_YESNO            0x0004
#define MB_RETRYCANCEL      0x0005

#define MB_ICONHAND         0x0010
#define MB_ICONQUESTION     0x0020
#define MB_ICONEXCLAMATION  0x0030
#define MB_ICONASTERISK     0x0040

#define MB_ICONINFORMATION  MB_ICONASTERISK
#define MB_ICONSTOP         MB_ICONHAND

#define MB_DEFBUTTON1       0x0000
#define MB_DEFBUTTON2       0x0100
#define MB_DEFBUTTON3       0x0200

#define MB_APPLMODAL        0x0000
#define MB_SYSTEMMODAL      0x1000
#define MB_TASKMODAL        0x2000

#define MB_NOFOCUS          0x8000

#define MB_TYPEMASK         0x000F
#define MB_ICONMASK         0x00F0
#define MB_DEFMASK          0x0F00
#define MB_MODEMASK         0x3000
#define MB_MISCMASK         0xC000

int  FAR PASCAL MessageBox(HWND, LPSTR, LPSTR, WORD);
void FAR PASCAL MessageBeep(WORD);

#endif /* NOMB */

int     FAR PASCAL ShowCursor(BOOL);
void    FAR PASCAL SetCursorPos(int, int);
HCURSOR FAR PASCAL SetCursor(HCURSOR);
void    FAR PASCAL GetCursorPos(LPPOINT);
void    FAR PASCAL ClipCursor(LPRECT);

void FAR PASCAL CreateCaret(HWND, HBITMAP, int, int);
WORD FAR PASCAL GetCaretBlinkTime(void);
void FAR PASCAL SetCaretBlinkTime(WORD);
void FAR PASCAL DestroyCaret(void);
void FAR PASCAL HideCaret(HWND);
void FAR PASCAL ShowCaret(HWND);
void FAR PASCAL SetCaretPos(int, int);
void FAR PASCAL GetCaretPos(LPPOINT);

void FAR PASCAL ClientToScreen(HWND, LPPOINT);
void FAR PASCAL ScreenToClient(HWND, LPPOINT);
HWND FAR PASCAL WindowFromPoint(POINT);
HWND FAR PASCAL ChildWindowFromPoint(HWND, POINT);

#ifndef NOCOLOR

/* Color Types */
#define CTLCOLOR_MSGBOX         0
#define CTLCOLOR_EDIT           1
#define CTLCOLOR_LISTBOX        2
#define CTLCOLOR_BTN            3
#define CTLCOLOR_DLG            4
#define CTLCOLOR_SCROLLBAR      5
#define CTLCOLOR_STATIC         6
#define CTLCOLOR_MAX            8     /* three bits max */

#define COLOR_SCROLLBAR         0
#define COLOR_BACKGROUND        1
#define COLOR_ACTIVECAPTION     2
#define COLOR_INACTIVECAPTION   3
#define COLOR_MENU              4
#define COLOR_WINDOW            5
#define COLOR_WINDOWFRAME       6
#define COLOR_MENUTEXT          7
#define COLOR_WINDOWTEXT        8
#define COLOR_CAPTIONTEXT       9
#define COLOR_ACTIVEBORDER      10
#define COLOR_INACTIVEBORDER    11
#define COLOR_APPWORKSPACE      12
#define COLOR_HIGHLIGHT         13
#define COLOR_HIGHLIGHTTEXT     14
#define COLOR_BTNFACE           15
#define COLOR_BTNSHADOW         16
#define COLOR_GRAYTEXT          17
#define COLOR_BTNTEXT           18
#define COLOR_ENDCOLORS         COLOR_BTNTEXT

DWORD FAR PASCAL GetSysColor(int);
void  FAR PASCAL SetSysColors(int, LPINT, LONG FAR *);

#endif /* NOCOLOR */

BOOL FAR PASCAL FillRgn(HDC, HRGN, HBRUSH);
BOOL FAR PASCAL FrameRgn(HDC, HRGN, HBRUSH, int, int);
BOOL FAR PASCAL InvertRgn(HDC, HRGN);
BOOL FAR PASCAL PaintRgn(HDC, HRGN);
BOOL FAR PASCAL PtInRegion(HRGN, int, int);

void FAR PASCAL DrawFocusRect(HDC, LPRECT);
int  FAR PASCAL FillRect(HDC, LPRECT, HBRUSH);
int  FAR PASCAL FrameRect(HDC, LPRECT, HBRUSH);
void FAR PASCAL InvertRect(HDC, LPRECT);
void FAR PASCAL SetRect(LPRECT, int, int, int, int);
void FAR PASCAL SetRectEmpty(LPRECT);
int  FAR PASCAL CopyRect(LPRECT, LPRECT);
void FAR PASCAL InflateRect(LPRECT, int, int);
int  FAR PASCAL IntersectRect(LPRECT, LPRECT, LPRECT);
int  FAR PASCAL UnionRect(LPRECT, LPRECT, LPRECT);
void FAR PASCAL OffsetRect(LPRECT, int, int);
BOOL FAR PASCAL IsRectEmpty(LPRECT);
BOOL FAR PASCAL EqualRect(LPRECT, LPRECT);
BOOL FAR PASCAL PtInRect(LPRECT, POINT);
BOOL FAR PASCAL RectVisible(HDC, LPRECT);
BOOL FAR PASCAL RectInRegion(HRGN, LPRECT);

DWORD FAR PASCAL GetCurrentTime(void);
DWORD FAR PASCAL GetTickCount(void);

#ifndef NOWINOFFSETS

WORD FAR PASCAL GetWindowWord(HWND, int);
WORD FAR PASCAL SetWindowWord(HWND, int, WORD);
LONG FAR PASCAL GetWindowLong(HWND, int);
LONG FAR PASCAL SetWindowLong(HWND, int, LONG);
WORD FAR PASCAL GetClassWord(HWND, int);
WORD FAR PASCAL SetClassWord(HWND, int, WORD);
LONG FAR PASCAL GetClassLong(HWND, int);
LONG FAR PASCAL SetClassLong(HWND, int, LONG);
HWND FAR PASCAL GetDesktopHwnd(void);
HWND FAR PASCAL GetDesktopWindow(void);

#endif /* NOWINOFFSETS */

HWND   FAR PASCAL GetParent(HWND);
HWND   FAR PASCAL SetParent(HWND, HWND);
BOOL   FAR PASCAL EnumChildWindows(HWND, FARPROC, LONG);
HWND   FAR PASCAL FindWindow(LPSTR, LPSTR);
BOOL   FAR PASCAL EnumWindows(FARPROC, LONG);
BOOL   FAR PASCAL EnumTaskWindows(HANDLE, FARPROC, LONG);
int    FAR PASCAL GetClassName(HWND, LPSTR, int);
HWND   FAR PASCAL GetTopWindow(HWND);
HWND   FAR PASCAL GetNextWindow(HWND, WORD);
HANDLE FAR PASCAL GetWindowTask(HWND);
HWND   FAR PASCAL GetLastActivePopup(HWND);

/* GetWindow() Constants */
#define GW_HWNDFIRST        0
#define GW_HWNDLAST         1
#define GW_HWNDNEXT         2
#define GW_HWNDPREV         3
#define GW_OWNER            4
#define GW_CHILD            5

HWND FAR PASCAL GetWindow(HWND, WORD);

#ifndef NOWH
FARPROC FAR PASCAL SetWindowsHook(int, FARPROC);
BOOL    FAR PASCAL UnhookWindowsHook(int, FARPROC);
DWORD   FAR PASCAL DefHookProc(int, WORD, DWORD, FARPROC FAR *);
#endif

#ifndef NOMENUS

/* Menu flags for Add/Check/EnableMenuItem() */
#define MF_INSERT          0x0000
#define MF_CHANGE          0x0080
#define MF_APPEND          0x0100
#define MF_DELETE          0x0200
#define MF_REMOVE          0x1000

#define MF_BYCOMMAND       0x0000
#define MF_BYPOSITION      0x0400


#define MF_SEPARATOR       0x0800

#define MF_ENABLED         0x0000
#define MF_GRAYED          0x0001
#define MF_DISABLED        0x0002

#define MF_UNCHECKED       0x0000
#define MF_CHECKED         0x0008
#define MF_USECHECKBITMAPS 0x0200

#define MF_STRING          0x0000
#define MF_BITMAP          0x0004
#define MF_OWNERDRAW       0x0100

#define MF_POPUP           0x0010
#define MF_MENUBARBREAK    0x0020
#define MF_MENUBREAK       0x0040

#define MF_UNHILITE        0x0000
#define MF_HILITE          0x0080

#define MF_SYSMENU         0x2000
#define MF_HELP            0x4000
#define MF_MOUSESELECT     0x8000

/* Menu item resource format */
typedef struct 
  {
    WORD versionNumber;
    WORD offset;
  } MENUITEMTEMPLATEHEADER;

typedef struct
  {
    WORD  mtOption;
    WORD  mtID;
    char  mtString[1];
  } MENUITEMTEMPLATE;

#define MF_END             0x0080

#endif /* NOMENUS */

#ifndef NOSYSCOMMANDS

/* System Menu Command Values */
#define SC_SIZE         0xF000
#define SC_MOVE         0xF010
#define SC_MINIMIZE     0xF020
#define SC_MAXIMIZE     0xF030
#define SC_NEXTWINDOW   0xF040
#define SC_PREVWINDOW   0xF050
#define SC_CLOSE        0xF060
#define SC_VSCROLL      0xF070
#define SC_HSCROLL      0xF080
#define SC_MOUSEMENU    0xF090
#define SC_KEYMENU      0xF100
#define SC_ARRANGE      0xF110
#define SC_RESTORE      0xF120
#define SC_TASKLIST     0xF130

#define SC_ICON         SC_MINIMIZE
#define SC_ZOOM         SC_MAXIMIZE

#endif /* NOSYSCOMMANDS */

/* Resource Loading Routines */
HBITMAP FAR PASCAL LoadBitmap(HANDLE, LPSTR);
HCURSOR FAR PASCAL LoadCursor(HANDLE, LPSTR);
HCURSOR FAR PASCAL CreateCursor(HANDLE, int, int, int, int, LPSTR, LPSTR);
BOOL    FAR PASCAL DestroyCursor(HCURSOR);

/* Standard Cursor IDs */
#define IDC_ARROW           MAKEINTRESOURCE(32512)
#define IDC_IBEAM           MAKEINTRESOURCE(32513)
#define IDC_WAIT            MAKEINTRESOURCE(32514)
#define IDC_CROSS           MAKEINTRESOURCE(32515)
#define IDC_UPARROW         MAKEINTRESOURCE(32516)
#define IDC_SIZE            MAKEINTRESOURCE(32640)
#define IDC_ICON            MAKEINTRESOURCE(32641)
#define IDC_SIZENWSE        MAKEINTRESOURCE(32642)
#define IDC_SIZENESW        MAKEINTRESOURCE(32643)
#define IDC_SIZEWE          MAKEINTRESOURCE(32644)
#define IDC_SIZENS          MAKEINTRESOURCE(32645)

HICON FAR PASCAL LoadIcon(HANDLE, LPSTR);
HICON FAR PASCAL CreateIcon(HANDLE, int, int, BYTE, BYTE, LPSTR, LPSTR);
BOOL  FAR PASCAL DestroyIcon(HICON);


#define ORD_LANGDRIVER    1     /* The ordinal number for the entry point of
                                ** language drivers.
                                */

#ifndef NOICONS

/* Standard Icon IDs */
#define IDI_APPLICATION     MAKEINTRESOURCE(32512)
#define IDI_HAND            MAKEINTRESOURCE(32513)
#define IDI_QUESTION        MAKEINTRESOURCE(32514)
#define IDI_EXCLAMATION     MAKEINTRESOURCE(32515)
#define IDI_ASTERISK        MAKEINTRESOURCE(32516)

#endif /* NOICONS */

int  FAR PASCAL LoadString(HANDLE, WORD, LPSTR, int);

int  FAR PASCAL AddFontResource(LPSTR);
BOOL FAR PASCAL RemoveFontResource(LPSTR);

#ifndef NOKANJI

#define CP_HWND             0
#define CP_OPEN             1
#define CP_DIRECT           2

/* VK from the keyboard driver */
#define VK_KANA             0x15
#define VK_ROMAJI           0x16
#define VK_ZENKAKU          0x17
#define VK_HIRAGANA         0x18
#define VK_KANJI            0x19

/* VK to send to Applications */
#define VK_CONVERT          0x1C
#define VK_NONCONVERT       0x1D
#define VK_ACCEPT           0x1E
#define VK_MODECHANGE       0x1F

/* Conversion function numbers */
#define KNJ_START           0x01
#define KNJ_END             0x02
#define KNJ_QUERY           0x03

#define KNJ_LEARN_MODE      0x10
#define KNJ_GETMODE         0x11
#define KNJ_SETMODE         0x12

#define KNJ_CODECONVERT     0x20
#define KNJ_CONVERT         0x21
#define KNJ_NEXT            0x22
#define KNJ_PREVIOUS        0x23
#define KNJ_ACCEPT          0x24

#define KNJ_LEARN           0x30
#define KNJ_REGISTER        0x31
#define KNJ_REMOVE          0x32
#define KNJ_CHANGE_UDIC     0x33

/* NOTE: DEFAULT        = 0
 *       JIS1           = 1
 *       JIS2           = 2
 *       SJIS2          = 3
 *       JIS1KATAKANA   = 4
 *       SJIS2HIRAGANA  = 5
 *       SJIS2KATAKANA  = 6
 *       OEM            = F
 */

#define KNJ_JIS1toJIS1KATAKANA  0x14
#define KNJ_JIS1toSJIS2         0x13
#define KNJ_JIS1toSJIS2HIRAGANA 0x15
#define KNJ_JIS1toSJIS2KATAKANA 0x16
#define KNJ_JIS1toDEFAULT       0x10
#define KNJ_JIS1toSJIS2OEM      0x1F
#define KNJ_JIS2toSJIS2         0x23
#define KNJ_SJIS2toJIS2         0x32

#define KNJ_MD_ALPHA            0x01
#define KNJ_MD_HIRAGANA         0x02
#define KNJ_MD_HALF             0x04
#define KNJ_MD_JIS              0x08
#define KNJ_MD_SPECIAL          0x10

#define KNJ_CVT_NEXT            0x01
#define KNJ_CVT_PREV            0x02
#define KNJ_CVT_KATAKANA        0x03
#define KNJ_CVT_HIRAGANA        0x04
#define KNJ_CVT_JIS1            0x05
#define KNJ_CVT_SJIS2           0x06
#define KNJ_CVT_DEFAULT         0x07
#define KNJ_CVT_TYPED           0x08

typedef struct
  {
    int         fnc;
    int         wParam;
    LPSTR       lpSource;
    LPSTR       lpDest;
    int         wCount;
    LPSTR       lpReserved1;
    LPSTR       lpReserved2;
  } KANJISTRUCT, FAR *LPKANJISTRUCT;

int  FAR PASCAL ConvertRequest(HWND, LPKANJISTRUCT);
BOOL FAR PASCAL SetConvertParams(int, int);
VOID FAR PASCAL SetConvertHook(BOOL);

#endif

/* Key Conversion Window */
BOOL FAR PASCAL IsTwoByteCharPrefix(char);

/* Dialog Box Command IDs */
#define IDOK                1
#define IDCANCEL            2
#define IDABORT             3
#define IDRETRY             4
#define IDIGNORE            5
#define IDYES               6
#define IDNO                7

#ifndef NOCTLMGR

/* Control Manager Structures and Definitions */

#ifndef NOWINSTYLES

/* Edit Control Styles */
#define ES_LEFT             0x0000L
#define ES_CENTER           0x0001L
#define ES_RIGHT            0x0002L
#define ES_MULTILINE        0x0004L
#define ES_UPPERCASE        0x0008L
#define ES_LOWERCASE        0x0010L
#define ES_PASSWORD         0x0020L
#define ES_AUTOVSCROLL      0x0040L
#define ES_AUTOHSCROLL      0x0080L
#define ES_NOHIDESEL        0x0100L
#define ES_OEMCONVERT       0x0400L


#endif /* NOWINSTYLES */

/* Edit Control Notification Codes */
#define EN_SETFOCUS         0x0100
#define EN_KILLFOCUS        0x0200
#define EN_CHANGE           0x0300
#define EN_UPDATE           0x0400
#define EN_ERRSPACE         0x0500
#define EN_MAXTEXT          0x0501
#define EN_HSCROLL          0x0601
#define EN_VSCROLL          0x0602

#ifndef NOWINMESSAGES

/* Edit Control Messages */
#define EM_GETSEL          (WM_USER+0)
#define EM_SETSEL          (WM_USER+1)
#define EM_GETRECT         (WM_USER+2)
#define EM_SETRECT         (WM_USER+3)
#define EM_SETRECTNP       (WM_USER+4)
#define EM_SCROLL          (WM_USER+5)
#define EM_LINESCROLL      (WM_USER+6)
#define EM_GETMODIFY       (WM_USER+8)
#define EM_SETMODIFY       (WM_USER+9)
#define EM_GETLINECOUNT    (WM_USER+10)
#define EM_LINEINDEX       (WM_USER+11)
#define EM_SETHANDLE       (WM_USER+12)
#define EM_GETHANDLE       (WM_USER+13)
#define EM_GETTHUMB        (WM_USER+14)
#define EM_LINELENGTH      (WM_USER+17)
#define EM_REPLACESEL      (WM_USER+18)
#define EM_SETFONT         (WM_USER+19)
#define EM_GETLINE         (WM_USER+20)
#define EM_LIMITTEXT       (WM_USER+21)
#define EM_CANUNDO         (WM_USER+22)
#define EM_UNDO            (WM_USER+23)
#define EM_FMTLINES        (WM_USER+24)
#define EM_LINEFROMCHAR    (WM_USER+25)
#define EM_SETWORDBREAK    (WM_USER+26)
#define EM_SETTABSTOPS     (WM_USER+27)
#define EM_SETPASSWORDCHAR (WM_USER+28)
#define EM_EMPTYUNDOBUFFER (WM_USER+29)
#define EM_MSGMAX          (WM_USER+30)

#endif /* NOWINMESSAGES */

/* Button Control Styles */
#define BS_PUSHBUTTON      0x00L
#define BS_DEFPUSHBUTTON   0x01L
#define BS_CHECKBOX        0x02L
#define BS_AUTOCHECKBOX    0x03L
#define BS_RADIOBUTTON     0x04L
#define BS_3STATE          0x05L
#define BS_AUTO3STATE      0x06L
#define BS_GROUPBOX        0x07L
#define BS_USERBUTTON      0x08L
#define BS_AUTORADIOBUTTON 0x09L
#define BS_PUSHBOX         0x0AL
#define BS_OWNERDRAW       0x0BL
#define BS_LEFTTEXT        0x20L


/* User Button Notification Codes */
#define BN_CLICKED         0
#define BN_PAINT           1
#define BN_HILITE          2
#define BN_UNHILITE        3
#define BN_DISABLE         4
#define BN_DOUBLECLICKED   5

/* Button Control Messages */
#define BM_GETCHECK        (WM_USER+0)
#define BM_SETCHECK        (WM_USER+1)
#define BM_GETSTATE        (WM_USER+2)
#define BM_SETSTATE        (WM_USER+3)
#define BM_SETSTYLE        (WM_USER+4)

/* Static Control Constants */
#define SS_LEFT            0x00L
#define SS_CENTER          0x01L
#define SS_RIGHT           0x02L
#define SS_ICON            0x03L
#define SS_BLACKRECT       0x04L
#define SS_GRAYRECT        0x05L
#define SS_WHITERECT       0x06L
#define SS_BLACKFRAME      0x07L
#define SS_GRAYFRAME       0x08L
#define SS_WHITEFRAME      0x09L
#define SS_USERITEM        0x0AL
#define SS_SIMPLE          0x0BL
#define SS_LEFTNOWORDWRAP  0x0CL
#define SS_NOPREFIX        0x80L    /* Don't do "&" character translation */

/* Dialog Manager Routines */

#ifndef NOMSG
BOOL FAR PASCAL IsDialogMessage(HWND, LPMSG);
#endif

void FAR PASCAL MapDialogRect(HWND, LPRECT);

int  FAR PASCAL DlgDirList(HWND, LPSTR, int, int, WORD);
BOOL FAR PASCAL DlgDirSelect(HWND, LPSTR, int);
int  FAR PASCAL DlgDirListComboBox(HWND, LPSTR, int, int, WORD);
BOOL FAR PASCAL DlgDirSelectComboBox(HWND, LPSTR, int);


/* Dialog Styles */
#define DS_ABSALIGN         0x01L
#define DS_SYSMODAL         0x02L
#define DS_LOCALEDIT        0x20L   /* Edit items get Local storage. */
#define DS_SETFONT          0x40L   /* User specified font for Dlg controls */
#define DS_MODALFRAME       0x80L   /* Can be combined with WS_CAPTION  */
#define DS_NOIDLEMSG        0x100L  /* WM_ENTERIDLE message will not be sent */

#define DM_GETDEFID         (WM_USER+0)
#define DM_SETDEFID         (WM_USER+1)
#define DC_HASDEFID         0x534B

/* Dialog Codes */
#define DLGC_WANTARROWS     0x0001      /* Control wants arrow keys         */
#define DLGC_WANTTAB        0x0002      /* Control wants tab keys           */
#define DLGC_WANTALLKEYS    0x0004      /* Control wants all keys           */
#define DLGC_WANTMESSAGE    0x0004      /* Pass message to control          */
#define DLGC_HASSETSEL      0x0008      /* Understands EM_SETSEL message    */
#define DLGC_DEFPUSHBUTTON  0x0010      /* Default pushbutton               */
#define DLGC_UNDEFPUSHBUTTON 0x0020     /* Non-default pushbutton           */
#define DLGC_RADIOBUTTON    0x0040      /* Radio button                     */
#define DLGC_WANTCHARS      0x0080      /* Want WM_CHAR messages            */
#define DLGC_STATIC         0x0100      /* Static item: don't include       */
#define DLGC_BUTTON         0x2000      /* Button item: can be checked      */

#define LB_CTLCODE          0L

/* Listbox Return Values */
#define LB_OKAY             0
#define LB_ERR              (-1)
#define LB_ERRSPACE         (-2)

/*
**  The idStaticPath parameter to DlgDirList can have the following values
**  ORed if the list box should show other details of the files along with
**  the name of the files;
*/
                                  /* all other details also will be returned */


/* Listbox Notification Codes */
#define LBN_ERRSPACE        (-2)
#define LBN_SELCHANGE       1
#define LBN_DBLCLK          2
#define LBN_SELCANCEL       3
#define LBN_SETFOCUS        4
#define LBN_KILLFOCUS       5



#ifndef NOWINMESSAGES

/* Listbox messages */
#define LB_ADDSTRING           (WM_USER+1)
#define LB_INSERTSTRING        (WM_USER+2)
#define LB_DELETESTRING        (WM_USER+3)
#define LB_RESETCONTENT        (WM_USER+5)
#define LB_SETSEL              (WM_USER+6)
#define LB_SETCURSEL           (WM_USER+7)
#define LB_GETSEL              (WM_USER+8)
#define LB_GETCURSEL           (WM_USER+9)
#define LB_GETTEXT             (WM_USER+10)
#define LB_GETTEXTLEN          (WM_USER+11)
#define LB_GETCOUNT            (WM_USER+12)
#define LB_SELECTSTRING        (WM_USER+13)
#define LB_DIR                 (WM_USER+14)
#define LB_GETTOPINDEX         (WM_USER+15)
#define LB_FINDSTRING          (WM_USER+16)
#define LB_GETSELCOUNT         (WM_USER+17)
#define LB_GETSELITEMS         (WM_USER+18)
#define LB_SETTABSTOPS         (WM_USER+19)
#define LB_GETHORIZONTALEXTENT (WM_USER+20)
#define LB_SETHORIZONTALEXTENT (WM_USER+21)
#define LB_SETCOLUMNWIDTH      (WM_USER+22)
#define LB_SETTOPINDEX         (WM_USER+24)
#define LB_GETITEMRECT         (WM_USER+25)
#define LB_GETITEMDATA         (WM_USER+26)
#define LB_SETITEMDATA         (WM_USER+27)
#define LB_SELITEMRANGE        (WM_USER+28)
#define LB_MSGMAX              (WM_USER+33)

#endif /* NOWINMESSAGES */

#ifndef NOWINSTYLES

/* Listbox Styles */
#define LBS_NOTIFY            0x0001L
#define LBS_SORT              0x0002L
#define LBS_NOREDRAW          0x0004L
#define LBS_MULTIPLESEL       0x0008L
#define LBS_OWNERDRAWFIXED    0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS        0x0040L
#define LBS_USETABSTOPS       0x0080L
#define LBS_NOINTEGRALHEIGHT  0x0100L
#define LBS_MULTICOLUMN       0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL       0x0800L
#define LBS_STANDARD          (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)

#endif /* NOWINSTYLES */


/* Combo Box return Values */
#define CB_OKAY             0
#define CB_ERR              (-1)
#define CB_ERRSPACE         (-2)


/* Combo Box Notification Codes */
#define CBN_ERRSPACE        (-1)
#define CBN_SELCHANGE       1
#define CBN_DBLCLK          2
#define CBN_SETFOCUS        3
#define CBN_KILLFOCUS       4
#define CBN_EDITCHANGE      5
#define CBN_EDITUPDATE      6
#define CBN_DROPDOWN        7

/* Combo Box styles */
#ifndef NOWINSTYLES
#define CBS_SIMPLE            0x0001L
#define CBS_DROPDOWN          0x0002L
#define CBS_DROPDOWNLIST      0x0003L
#define CBS_OWNERDRAWFIXED    0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL       0x0040L
#define CBS_OEMCONVERT        0x0080L
#define CBS_SORT              0x0100L
#define CBS_HASSTRINGS        0x0200L
#define CBS_NOINTEGRALHEIGHT  0x0400L
#endif  /* NOWINSTYLES */


/* Combo Box messages */
#ifndef NOWINMESSAGES
#define CB_GETEDITSEL            (WM_USER+0)
#define CB_LIMITTEXT             (WM_USER+1)
#define CB_SETEDITSEL            (WM_USER+2)
#define CB_ADDSTRING             (WM_USER+3)
#define CB_DELETESTRING          (WM_USER+4)
#define CB_DIR                   (WM_USER+5)
#define CB_GETCOUNT              (WM_USER+6)
#define CB_GETCURSEL             (WM_USER+7)
#define CB_GETLBTEXT             (WM_USER+8)
#define CB_GETLBTEXTLEN          (WM_USER+9)
#define CB_INSERTSTRING          (WM_USER+10)
#define CB_RESETCONTENT          (WM_USER+11)
#define CB_FINDSTRING            (WM_USER+12)
#define CB_SELECTSTRING          (WM_USER+13)
#define CB_SETCURSEL             (WM_USER+14)
#define CB_SHOWDROPDOWN          (WM_USER+15)
#define CB_GETITEMDATA           (WM_USER+16)
#define CB_SETITEMDATA           (WM_USER+17)
#define CB_GETDROPPEDCONTROLRECT (WM_USER+18)
#define CB_MSGMAX                (WM_USER+19)
#endif  /* NOWINMESSAGES */



#ifndef NOWINSTYLES

/* Scroll Bar Styles */
#define SBS_HORZ                    0x0000L
#define SBS_VERT                    0x0001L
#define SBS_TOPALIGN                0x0002L
#define SBS_LEFTALIGN               0x0002L
#define SBS_BOTTOMALIGN             0x0004L
#define SBS_RIGHTALIGN              0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN     0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX                 0x0008L

#endif /* NOWINSTYLES */

#endif /* NOCTLMGR */

#ifndef NOSOUND

int   FAR PASCAL OpenSound(void);
void  FAR PASCAL CloseSound(void);
int   FAR PASCAL SetVoiceQueueSize(int, int);
int   FAR PASCAL SetVoiceNote(int, int, int, int);
int   FAR PASCAL SetVoiceAccent(int, int, int, int, int);
int   FAR PASCAL SetVoiceEnvelope(int, int, int);
int   FAR PASCAL SetSoundNoise(int, int);
int   FAR PASCAL SetVoiceSound(int, LONG, int);
int   FAR PASCAL StartSound(void);
int   FAR PASCAL StopSound(void);
int   FAR PASCAL WaitSoundState(int);
int   FAR PASCAL SyncAllVoices(void);
int   FAR PASCAL CountVoiceNotes(int);
LPINT FAR PASCAL GetThresholdEvent(void);
int   FAR PASCAL GetThresholdStatus(void);
int   FAR PASCAL SetVoiceThreshold(int, int);

/* WaitSoundState() Constants */
#define S_QUEUEEMPTY        0
#define S_THRESHOLD         1
#define S_ALLTHRESHOLD      2

/* Accent Modes */
#define S_NORMAL      0
#define S_LEGATO      1
#define S_STACCATO    2

/* SetSoundNoise() Sources */
#define S_PERIOD512   0     /* Freq = N/512 high pitch, less coarse hiss  */
#define S_PERIOD1024  1     /* Freq = N/1024                              */
#define S_PERIOD2048  2     /* Freq = N/2048 low pitch, more coarse hiss  */
#define S_PERIODVOICE 3     /* Source is frequency from voice channel (3) */
#define S_WHITE512    4     /* Freq = N/512 high pitch, less coarse hiss  */
#define S_WHITE1024   5     /* Freq = N/1024                              */
#define S_WHITE2048   6     /* Freq = N/2048 low pitch, more coarse hiss  */
#define S_WHITEVOICE  7     /* Source is frequency from voice channel (3) */

#define S_SERDVNA     (-1)  /* Device not available */
#define S_SEROFM      (-2)  /* Out of memory        */
#define S_SERMACT     (-3)  /* Music active         */
#define S_SERQFUL     (-4)  /* Queue full           */
#define S_SERBDNT     (-5)  /* Invalid note         */
#define S_SERDLN      (-6)  /* Invalid note length  */
#define S_SERDCC      (-7)  /* Invalid note count   */
#define S_SERDTP      (-8)  /* Invalid tempo        */
#define S_SERDVL      (-9)  /* Invalid volume       */
#define S_SERDMD      (-10) /* Invalid mode         */
#define S_SERDSH      (-11) /* Invalid shape        */
#define S_SERDPT      (-12) /* Invalid pitch        */
#define S_SERDFQ      (-13) /* Invalid frequency    */
#define S_SERDDR      (-14) /* Invalid duration     */
#define S_SERDSR      (-15) /* Invalid source       */
#define S_SERDST      (-16) /* Invalid state        */

#endif /* NOSOUND */

#ifndef NOCOMM

#define NOPARITY            0
#define ODDPARITY           1
#define EVENPARITY          2
#define MARKPARITY          3
#define SPACEPARITY         4

#define ONESTOPBIT          0
#define ONE5STOPBITS        1
#define TWOSTOPBITS         2

#define IGNORE              0       /* Ignore signal    */
#define INFINITE            0xFFFF  /* Infinite timeout */

/* Error Flags */
#define CE_RXOVER           0x0001  /* Receive Queue overflow       */
#define CE_OVERRUN          0x0002  /* Receive Overrun Error        */
#define CE_RXPARITY         0x0004  /* Receive Parity Error         */
#define CE_FRAME            0x0008  /* Receive Framing error        */
#define CE_BREAK            0x0010  /* Break Detected               */
#define CE_CTSTO            0x0020  /* CTS Timeout                  */
#define CE_DSRTO            0x0040  /* DSR Timeout                  */
#define CE_RLSDTO           0x0080  /* RLSD Timeout                 */
#define CE_TXFULL           0x0100  /* TX Queue is full             */
#define CE_PTO              0x0200  /* LPTx Timeout                 */
#define CE_IOE              0x0400  /* LPTx I/O Error               */
#define CE_DNS              0x0800  /* LPTx Device not selected     */
#define CE_OOP              0x1000  /* LPTx Out-Of-Paper            */
#define CE_MODE             0x8000  /* Requested mode unsupported   */

#define IE_BADID            (-1)    /* Invalid or unsupported id    */
#define IE_OPEN             (-2)    /* Device Already Open          */
#define IE_NOPEN            (-3)    /* Device Not Open              */
#define IE_MEMORY           (-4)    /* Unable to allocate queues    */
#define IE_DEFAULT          (-5)    /* Error in default parameters  */
#define IE_HARDWARE         (-10)   /* Hardware Not Present         */
#define IE_BYTESIZE         (-11)   /* Illegal Byte Size            */
#define IE_BAUDRATE         (-12)   /* Unsupported BaudRate         */

/* Events */
#define EV_RXCHAR           0x0001  /* Any Character received       */
#define EV_RXFLAG           0x0002  /* Received certain character   */
#define EV_TXEMPTY          0x0004  /* Transmitt Queue Empty        */
#define EV_CTS              0x0008  /* CTS changed state            */
#define EV_DSR              0x0010  /* DSR changed state            */
#define EV_RLSD             0x0020  /* RLSD changed state           */
#define EV_BREAK            0x0040  /* BREAK received               */
#define EV_ERR              0x0080  /* Line status error occurred   */
#define EV_RING             0x0100  /* Ring signal detected         */
#define EV_PERR             0x0200  /* Printer error occured        */

/* Escape Functions */
#define SETXOFF             1       /* Simulate XOFF received       */
#define SETXON              2       /* Simulate XON received        */
#define SETRTS              3       /* Set RTS high                 */
#define CLRRTS              4       /* Set RTS low                  */
#define SETDTR              5       /* Set DTR high                 */
#define CLRDTR              6       /* Set DTR low                  */
#define RESETDEV            7       /* Reset device if possible     */

#define LPTx                0x80    /* Set if ID is for LPT device  */

typedef struct tagDCB
  {
    BYTE Id;              /* Internal Device ID              */
    WORD BaudRate;        /* Baudrate at which runing        */
    BYTE ByteSize;        /* Number of bits/byte, 4-8        */
    BYTE Parity;          /* 0-4=None,Odd,Even,Mark,Space    */
    BYTE StopBits;        /* 0,1,2 = 1, 1.5, 2               */
    WORD RlsTimeout;      /* Timeout for RLSD to be set      */
    WORD CtsTimeout;      /* Timeout for CTS to be set       */
    WORD DsrTimeout;      /* Timeout for DSR to be set       */

    BYTE fBinary: 1;      /* Binary Mode (skip EOF check     */
    BYTE fRtsDisable:1;   /* Don't assert RTS at init time   */
    BYTE fParity: 1;      /* Enable parity checking          */
    BYTE fOutxCtsFlow:1;  /* CTS handshaking on output       */
    BYTE fOutxDsrFlow:1;  /* DSR handshaking on output       */
    BYTE fDummy: 2;       /* Reserved                        */
    BYTE fDtrDisable:1;   /* Don't assert DTR at init time   */

    BYTE fOutX: 1;        /* Enable output X-ON/X-OFF        */
    BYTE fInX: 1;         /* Enable input X-ON/X-OFF         */
    BYTE fPeChar: 1;      /* Enable Parity Err Replacement   */
    BYTE fNull: 1;        /* Enable Null stripping           */
    BYTE fChEvt: 1;       /* Enable Rx character event.      */
    BYTE fDtrflow: 1;     /* DTR handshake on input          */
    BYTE fRtsflow: 1;     /* RTS handshake on input          */
    BYTE fDummy2: 1;

    char XonChar;         /* Tx and Rx X-ON character        */
    char XoffChar;        /* Tx and Rx X-OFF character       */
    WORD XonLim;          /* Transmit X-ON threshold         */
    WORD XoffLim;         /* Transmit X-OFF threshold        */
    char PeChar;          /* Parity error replacement char   */
    char EofChar;         /* End of Input character          */
    char EvtChar;         /* Recieved Event character        */
    WORD TxDelay;         /* Amount of time between chars    */
  } DCB;

typedef struct tagCOMSTAT
  {
    BYTE fCtsHold: 1;   /* Transmit is on CTS hold         */
    BYTE fDsrHold: 1;   /* Transmit is on DSR hold         */
    BYTE fRlsdHold: 1;  /* Transmit is on RLSD hold        */
    BYTE fXoffHold: 1;  /* Received handshake              */
    BYTE fXoffSent: 1;  /* Issued handshake                */
    BYTE fEof: 1;       /* End of file character found     */
    BYTE fTxim: 1;      /* Character being transmitted     */
    WORD cbInQue;       /* count of characters in Rx Queue */
    WORD cbOutQue;      /* count of characters in Tx Queue */
  } COMSTAT;

int  FAR PASCAL OpenComm(LPSTR, WORD, WORD);
int  FAR PASCAL SetCommState(DCB FAR *);
int  FAR PASCAL GetCommState(int, DCB FAR *);
int  FAR PASCAL ReadComm(int, LPSTR, int);
int  FAR PASCAL UngetCommChar(int, char);
int  FAR PASCAL WriteComm(int, LPSTR, int);
int  FAR PASCAL CloseComm(int);
int  FAR PASCAL GetCommError(int, COMSTAT FAR *);
int  FAR PASCAL BuildCommDCB(LPSTR, DCB FAR *);
int  FAR PASCAL TransmitCommChar(int, char);
WORD FAR * FAR PASCAL SetCommEventMask(int, WORD);
WORD FAR PASCAL GetCommEventMask(int, int);
int  FAR PASCAL SetCommBreak(int);
int  FAR PASCAL ClearCommBreak(int);
int  FAR PASCAL FlushComm(int, int);
int  FAR PASCAL EscapeCommFunction(int, int);

#endif /* NOCOMM */

#ifndef NOMDI

typedef struct tagMDICREATESTRUCT
  {
    LPSTR szClass;
    LPSTR szTitle;
    HANDLE hOwner;
    int x,y;
    int cx,cy;
    LONG style;
    LONG lParam;        /* app-defined stuff */
  } MDICREATESTRUCT;

typedef MDICREATESTRUCT FAR * LPMDICREATESTRUCT;

typedef struct tagCLIENTCREATESTRUCT
  {
    HANDLE hWindowMenu;
    WORD idFirstChild;
  } CLIENTCREATESTRUCT;

typedef CLIENTCREATESTRUCT FAR * LPCLIENTCREATESTRUCT;

LONG FAR PASCAL DefFrameProc(HWND,HWND,WORD,WORD,LONG);
LONG FAR PASCAL DefMDIChildProc(HWND,WORD,WORD,LONG);

#ifndef NOMSG
BOOL FAR PASCAL TranslateMDISysAccel(HWND,LPMSG);
#endif

WORD FAR PASCAL ArrangeIconicWindows(HWND);

#endif /* NOMDI */

#endif /* NOUSER */

#ifndef NOHELP

/*  Help engine section.  */

/* Commands to pass WinHelp() */
#define HELP_CONTEXT    0x0001   /* Display topic in ulTopic */
#define HELP_QUIT       0x0002   /* Terminate help */
#define HELP_INDEX      0x0003   /* Display index */
#define HELP_HELPONHELP 0x0004   /* Display help on using help */
#define HELP_SETINDEX   0x0005   /* Set the current Index for multi index help */
#define HELP_KEY        0x0101   /* Display topic for keyword in offabData */
#define HELP_MULTIKEY   0x0201

BOOL FAR PASCAL WinHelp(HWND hwndMain, LPSTR lpszHelp, WORD usCommand, DWORD ulData);

typedef struct tagMULTIKEYHELP
  {
    WORD    mkSize;
    BYTE    mkKeylist;
    BYTE    szKeyphrase[1];
  } MULTIKEYHELP;

#endif /* NOHELP */

#ifndef NOPROFILER

/* function declarations for profiler routines contained in Windows libraries */
int  far pascal ProfInsChk(void);
void far pascal ProfSetup(int,int);
void far pascal ProfSampRate(int,int);
void far pascal ProfStart(void);
void far pascal ProfStop(void);
void far pascal ProfClear(void);
void far pascal ProfFlush(void);
void far pascal ProfFinish(void);

#endif /* NOPROFILER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\me\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
	 PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\w32cbid.inc ===
; Callback-type id's for WIN32C callbacks. All callback-type id's are
; 32-bits long and the upper 16-bits must be set to the module's
; Callback Client id.
;
; WARNING -- WARNING -- WARNING
;
;   Win32c.dll uses the lower 16 bits of CBID's to index directly into
;   the tables stored in WIN32C.EXE (w32ccb16.asm) and USER32.DLL (*)
;   (w32ccb32.asm). Those tables *must* match these id's or callbacks 
;   will fail miserably. Do everyone a big favor and add new id's only 
;   at the end, and never change an existing id.
;
;   (*) We stuck the 32-bit parts in USER32.DLL because we don't have
;   a 32-bit partner for win32c.dll
;   


CBID_UNIVTHUNK          equ     (0 + (CBCID_WIN32C SHL 16))
CBID_LOADRES            equ     (1 + (CBCID_WIN32C SHL 16))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\user\cvtstruc.inc ===
;-----------------------------------------------------------------------;
; CVTSTRUC.INC
;
; This module contains macros that generate 16-bit code to convert
; structures in either direction between 16-bit and 32-bit definitions.
;
; For use by the message thunks only.
;
; For structure definitions, see the file struc.inc.
;
; The format of the macro names is:  convert<structure-name><direction>
; where <structure-name> is the name of the structure as defined in
; struc.inc (all uppercase), and <direction> is either LS (large-to-small,
; i.e. 32-to-16) or SL (small-to-large, i.e. 16-to-32).
;-----------------------------------------------------------------------;

include     cvt.inc


;----------------------------------------------------------------------------
;
;   STRUCTURE TYPES
;
;   These are the structure types we know how to convert for messages
;   and hooks.
;
;----------------------------------------------------------------------------

RECT_STRUC                  equ     0
DROPSTRUCT_STRUC            equ     1
COMPAREITEMSTRUCT_STRUC     equ     2
DELETEITEMSTRUCT_STRUC      equ     3
DRAWITEMSTRUCT_STRUC        equ     4
MEASUREITEMSTRUCT_STRUC     equ     5
INTSARRAY_STRUC             equ     6
MINMAXINFOSTRUCT_STRUC      equ     7
CREATESTRUCT_STRUC          equ     8
MDICREATESTRUCT_STRUC       equ     9
CREATESTRUCT2_STRUC         equ     10
WINDOWPOS_STRUC             equ     11
OPENFILENAME_STRUC          equ     12
CHOOSECOLOR_STRUC           equ     13
CHOOSEFONT2_STRUC           equ     14
COPYDATASTRUCT_STRUC        equ     15
HELPINFOSTRUCT_STRUC        equ     16
MDINEXTMENU_STRUC           equ     17
MSGSTRUCT_STRUC             equ     18
PRINTDLG_STRUC              equ     19
PAINTSTRUCT_STRUC           equ     20
NCCALCSIZE_STRUC            equ     21
MENUGETOBJECTINFO_STRUC     equ     22

ifdef FE_IME
LOGFONT_STRUC               equ     23
COMPOSITIONFORM_STRUC       equ     24
CANDIDATEFORM_STRUC         equ     25
MAX_STRUC                   equ     26
else
MAX_STRUC                   equ     23
endif


externDef cvtRECTLS:near16
externDef cvtDROPSTRUCTLS:near16
externDef cvtCOMPAREITEMSTRUCTLS:near16
externDef cvtDELETEITEMSTRUCTLS:near16
externDef cvtDRAWITEMSTRUCTLS:near16
externDef cvtMEASUREITEMSTRUCTLS:near16
externDef cvtMINMAXINFOSTRUCTLS:near16
externDef cvtCREATESTRUCTLS:near16
externDef cvtMDICREATESTRUCTLS:near16
externDef cvtCREATESTRUCT2LS:near16
externDef cvtWINDOWPOSLS:near16
externDef cvtMOUSEHOOKSTRUCTLS:near16
externDef cvtEVENTMSGLS:near16
externDef cvtCBTACTIVATESTRUCTLS:near16
externDef cvtOPENFILENAMELS:near16
externDef cvtCHOOSECOLORLS:near16
externDef cvtCHOOSEFONT2LS:near16
externDef cvtLOGFONTLS:near16
externDef cvtPRINTDLGLS:near16
externDef cvtCOPYDATASTRUCTLS:near16
externDef cvtHELPINFOSTRUCTLS:near16
externDef cvtPAINTSTRUCTLS:near16
externDef cvtINTSARRAYLS:near16
externDef cvtMSGSTRUCTLS:near16
externDef cvtDEBUGHOOKLS:near16
externDef cvtNCCALCSIZELS:near16
externDef cvtMENUGETOBJECTINFOLS:near16
ifdef FE_IME
externDef cvtLOGFONTLS:near16
externDef cvtCOMPOSITIONFORMLS:near16
externDef cvtCANDIDATEFORMLS:near16
endif

externDef cvtRECTSL:near16
externDef cvtDROPSTRUCTSL:near16
externDef cvtCOMPAREITEMSTRUCTSL:near16
externDef cvtDELETEITEMSTRUCTSL:near16
externDef cvtDRAWITEMSTRUCTSL:near16
externDef cvtMEASUREITEMSTRUCTSL:near16
externDef cvtMINMAXINFOSTRUCTSL:near16
externDef cvtCREATESTRUCTSL:near16
externDef cvtMDICREATESTRUCTSL:near16
externDef cvtCREATESTRUCT2SL:near16
externDef cvtWINDOWPOSSL:near16
externDef cvtMOUSEHOOKSTRUCTSL:near16
externDef cvtEVENTMSGSL:near16
externDef cvtCBTACTIVATESTRUCTSL:near16
externDef cvtOPENFILENAMESL:near16
externDef cvtCHOOSECOLORSL:near16
externDef cvtCHOOSEFONT2SL:near16
externDef cvtLOGFONTSL:near16
externDef cvtPRINTDLGSL:near16
externDef cvtCOPYDATASTRUCTSL:near16
externDef cvtHELPINFOSTRUCTSL:near16
externDef cvtPAINTSTRUCTSL:near16
externDef cvtINTSARRAYSL:near16
externDef cvtMDINEXTMENUSL:near16
externDef cvtMSGSTRUCTSL:near16
externDef cvtDEBUGHOOKSL:near16
externDef cvtNCCALCSIZESL:near16
externDef cvtMENUGETOBJECTINFOSL:near16
ifdef FE_IME
externDef cvtLOGFONTSL:near16
externDef cvtCOMPOSITIONFORMSL:near16
externDef cvtCANDIDATEFORMSL:near16
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\user\ddepack.h ===
// TO BE DELFILED.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\user\prop.h ===
typedef struct {
   WORD pid;
   WORD atom;
} PROPDATA;
typedef PROPDATA near * NPPROPDATA;
typedef PROPDATA  far *  PPROPDATA;

#define CPD_INIT  16
#define CPD_INCR   8

#define GPD_ERROR -1

//BUGBUG!! Maybe some of the proc, have their DS already set on entry!
BOOL _loadds InitPropData(VOID);
BOOL _loadds InsertPropAtom(WORD atom);
BOOL _loadds DeletePropAtom(WORD atom);
VOID _loadds PurgeProcessPropAtoms(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\user\frame.inc ===
;-----------------------------------------------------------------------;
; Picture of stack upon entering 32-bit half of WNDPROC callback:
;
;       +-----------------------+
;       | callback parameters   |
;       +-----------------------+
;       | retf to Win3.0        |
;       |                       |
;       +-----------------------+
;       | 32-bit pfn            |
;       |                       |
;       +-----------------------+
;       | iCallbackType         |
;       |                       |
;       +-----------------------+
;       | bp                    | <-- bp/ebp, references up
;       +-----------------------+
;       | si                    |
;       +-----------------------+
;       | di                    |
;       +-----------------------+
;       | ds                    | <-- si/esi, references down if necessary
;       +-----------------------+
;       | THKSPACE16            |       if necessary
;       +-----------------------+
;       | MSGSTRUCT             |       if necessary
;       +-----------------------+
;       | repacked structure(s) |       if necessary
;       +-----------------------+
;       | retf to thunk cleanup |       if necessary
;       |                       |
;       +-----------------------+
;       | ss, sp                | <-- ebx, references saved ss:sp
;       |                       |
;       +-----------------------+
;       | dword alignment pad   |       if necessary
;       +-----------------------+
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; Picture of stack upon entering 32-bit half of non-WNDPROC callback:
;
;       +-----------------------+
;       | callback parameters   |
;       +-----------------------+
;       | retf to Win3.0        |
;       |                       |
;       +-----------------------+
;       | 32-bit pfn            |
;       |                       |
;       +-----------------------+
;       | iCallbackType         |
;       |                       |
;       +-----------------------+
;       | bp                    | <-- bp/ebp, references up
;       +-----------------------+
;       | si                    |
;       +-----------------------+
;       | di                    |
;       +-----------------------+
;       | ds                    |
;       +-----------------------+
;       | ss, sp                | <-- ebx, references saved ss:sp
;       |                       |
;       +-----------------------+
;       | dword alignment pad   |       if necessary
;       +-----------------------+
;-----------------------------------------------------------------------;

        include thkframe.inc

;-----------------------------------------------------------------------;
; Message thunk local variable space.  This is the stack frame set up
; by the API thunk before calling the message thunk dispatcher.
;-----------------------------------------------------------------------;
THKSPACE16      struc
s16_hwnd        dw  ?           ;hwnd to receive message
s16_message     dw  ?           ;message number
s16_wParam      dd  ?           ;message wParam
s16_lParam      dd  ?           ;message lParam
s16_lResult     dd  ?           ;message return result (only if TF_THUNKRESULT)
s16_fw          dw  ?           ;miscellaneous flags
s16_atomClass   dw  ?           ;atom of window class (if negative)
s16_dwExtra1    dd  ?           ;extra space
s16_dwExtra2    dd  ?           ;more extra space
THKSPACE16      ends

;s16_fw bit definitions
TF_NOTPAIRED            equ 0001h   ;indicates this call is not paired with cleanup
TF_THUNKMSGRESULT       equ 0002h   ;has a return value to thunk
TF_CLEANUP              equ 0004h   ;doing cleaning up
TF_INTERPROCESS         equ 0008h   ;send/call to window in different app

TF_OPENFILENAME         equ 0010h   ;Hook fn for GetOpen/SaveFileName dlg
TF_CHOOSEFONT           equ 0020h   ;Hook fn for ChooseFont dlg
TF_CHOOSECOLOR          equ 0030h   ;Hook fn for ChooseColor dlg
TF_PRINTDLG             equ 0040h   ;Hook fn for Print/PrintSetup dlg
TF_FINDREPLACE          equ 0050h   ;Hook fn for Find/Replace dlg
TF_INITDIALOG_MASK      equ 00F0h   ;WM_INITDIALOG values mask
    ;And flags with TF_INITDIALOG_MASK; right shift'em 4 bits, double it
    ;and you have WORD index into thunking table.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\user\obsolete.inc ===
; ---------------------------------------------------------------------------
;
;   OBSOLETE.INC
;
;   Old message thunking macros, no longer used.
;
; ---------------------------------------------------------------------------

; -------------
; FROM DISP.INC
; -------------

;-----------------------------------------------------------------------;
; DefMsgTable
;
; list
;   The list of table code-names to create table entries from.
;
; table_suffix
;   The suffix which distinguishes this table name from others.
;
; table_size
;   The size of entries in the tables that this table refers to.
;
; direction
;   The direction of thunking the table refers to.
;
; Define tables of offsets to tables indexed by message number.
; The tables self-check the accuracy of ordering of entries.
;-----------------------------------------------------------------------;

DefMsgTable     macro   list:req,table_suffix:req,table_size:req,direction:req
    local tbl, tbl_entry, table_index

    ; Create and execute a statement of the form:
    ;
    ; tbl equ <awSLIndexTable>

    cat <tbl equ >,!<,aw,&direction,&table_suffix,<Table>,!>

    ; Define the array of tables and declare its name.
    % externDef tbl:word
    % tbl label word

    table_index = 0
    for x,<list>
        if table_index NE CLASS_&x
            .err
        endif

        ; Create and execute a statement of the form:
        ;
        ; tbl_entry equ <abWMSLIndex>, or
        ; tbl_entry equ <awWMSLIndex>

        ifidni <&table_size>,<byte>
            cat <tbl_entry equ >,!<,ab,x,&direction,&table_suffix,!>
        else
        ifidni <&table_size>,<word>
            cat <tbl_entry equ >,!<,aw,x,&direction,&table_suffix,!>
        else
            ;unrecognized table size
            .err
        endif
        endif

        ; Create a table entry and declare its name.
        % externDef tbl_entry:&table_size
        % dw offset tbl_entry

        table_index = table_index + 1
    endm

endm

;-----------------------------------------------------------------------;
; DefAllExternMsgTables
;
; list
;   The list of table code-names from which to create tables.
;
; direction
;   The direction of the thunks (i.e. LS or SL).
;
; Create all the necessary tables for dispatching message thunks in
; the given direction.
;-----------------------------------------------------------------------;
DefAllExternMsgTables macro list:req, direction:req
    local symbol_name

    for x,<list>
        ; Create and execute a statement of the form:
        ;
        ; symbol_name equ <awWMSLOffset>

        cat <symbol_name equ >,!<,aw,x,&direction,Offset,!>
        % externDef symbol_name:word


        ; Create and execute a statement of the form:
        ;
        ; symbol_name equ <abWMSLIndex>

        cat <symbol_name equ >,!<,ab,x,&direction,Index,!>
        % externDef symbol_name:byte


        ; Create and execute a statement of the form:
        ;
        ; symbol_name equ <abWMSLRet>

        cat <symbol_name equ >,!<,ab,x,&direction,Ret,!>
        % externDef symbol_name:byte

    endm
endm


; ---------------
; FROM MSGTBL.INC
; ---------------

;-----------------------------------------------------------------------;
; thk
;
;   name
;       A message name.
;
;   number
;       A message number.
;
;   afSpecial
;       A list (in angle brackets) of the various directions of special
;       thunks needed for this message.  The valid codes are:
;
;       SL ==> special thunk required going short to long (16->32)
;       LS ==> special thunk required going long to short (32->16)
;
;       A message may only require a thunk in one direction, in which
;       case only the one appropriate code should be given.
;
;   ret_type
;       A code specifying the return type of the message.
;
;   fDefNoStruc
;       Indicates whether or not the default thunk applies when
;       the TF_NOSTRUC flag is set.  If so, the only action in the
;       SL direction is to combine wParamLo & wParamHi; in the LS 
;       direction, to split up wParam into wParamLo and wParamHi.
;
;   Example:
;
;       thk WM_CREATE,1,<SL,LS>,RC_BOOL
;
; Dependencies:
;   This macro depends on the definition of the two constants:
;
;       "dir"    the direction of the thunks being defined
;       "tbl"    the code name of the thunk table
;
; The thk macro creates the symbols used to check for special thunks.
; It also generates the thunk entries by invoking the add_thunk macro.
; No code is generated, but the symbols created are used to produce
; code later on by make_index_entries, make_thunk_entries, and
; make_ret_entries.
;
; This macro allows all the thunk dispatch information needed about a
; message to be defined in one place, to make maintaining the big list
; of messages easier.  The list itself is in a separate include file
; (msg.inc).
;-----------------------------------------------------------------------;
thk macro   name:req,number:req,afSpecial,ret_type:=<RC_DEFAULT>,fDefNoStruc:=<0>
    local has_thunk, msg, low_msg, high_msg

    ;; Update highest message number processed. Messages must be sorted,
    ;; so if number does not increase it's an error.  If there is a gap
    ;; of one or more messages between the previously highest number andu
    ;; the new one, fill in the index_xxyy_## values with the value
    ;; UNIMPLEMENTED_THUNK. In the debug build, if one of these messages
    ;; is used, a warning will be displayed on the debug terminal.

    if max_msg LT number
        if max_msg LT (number + 1)
            low_msg = max_msg + 1
            high_msg = number - 1
            msg = low_msg
            repeat (high_msg - low_msg + 1)
                add_null_thunk  %tbl, %msg, UNIMPLEMENTED_THUNK
                msg = msg + 1
            endm
        endif
        max_msg = number
    else
        .err
    endif


    ;;If the message has a special thunk, define the symbols necessary to
    ;;build the proper dispatch tables.

    ifnb <afSpecial>
        has_thunk = 0
        for x,<afSpecial>
            has_thunk = has_thunk or check_thunk(x)
        endm

        if has_thunk
            add_thunk %tbl, name, %max_msg, ret_type, fDefNoStruc
        else
            add_null_thunk %tbl, %max_msg, COMMON_THUNK, ret_type
        endif
    else
        add_null_thunk %tbl, %max_msg, COMMON_THUNK, ret_type
    endif
endm

;-----------------------------------------------------------------------;
; begin_thunk_table
;
; This macro initializes the variables used by thk.
;
; tbl_base      lowest message number in table
; tbl_limit     highest message number in table
; max_msg       highest message number processed so far
; max_index     next index into table of thunk procedure offsets
;-----------------------------------------------------------------------;
begin_thunk_table    macro      table_name:req
    tbl             equ <&table_name>

    DefTableLimits  table_name

    max_msg       = tbl_base - 1
    max_index     = 1
endm

;-----------------------------------------------------------------------;
; end_thunk_table
;
; This macro defines all message indices from max_msg+1 to tbl_limit as
; UNIMPLEMENTED_THUNK. This saves the message thunk dispatcher from
; having to do an extra test for the last defined message.
;-----------------------------------------------------------------------;
end_thunk_table    macro
    local high_msg, low_msg, msg

    ;;Check that our table isn't too big.
    % if max_msg GT tbl_limit
        .err
    endif

    % if max_msg LT tbl_limit
        low_msg = max_msg + 1
        high_msg = tbl_limit
        msg = low_msg
        % rept (high_msg - low_msg + 1)
            add_null_thunk  %tbl,%msg,UNIMPLEMENTED_THUNK
            msg = msg + 1
        endm
        max_msg = tbl_limit
    endif
endm

;-----------------------------------------------------------------------;
; check_thunk
;
; flag
;   An item from the list of special flags given to the thk macros
;   in msg.inc.  These flags indicate whether a message has a special
;   thunk in each direction.  "flag" is one of the flags.
;
; Macro function which returns 1 (TRUE) if "flag" has the same value as
; "dir", 0 (FALSE) otherwise.
;
; This macro is invoked by the thk macro in order to know whether to
; invoke add_thunk or add_null_thunk.
;-----------------------------------------------------------------------;
check_thunk macro flag:req
    local has_thunk
    has_thunk = 0
    % ifidni <flag>,<dir>
        has_thunk = 1
    endif
    exitm %has_thunk
endm

;-----------------------------------------------------------------------;
; add_thunk
;
; tbl
;   Code for table (i.e. WM, etc.).
;
; name
;   The name of a message for which a thunk dispatch table entry
;   should be created.
;
; number
;   The corresponding message number.
;
; ret_type
;   A code specifying the return type of the message.
;
; fDefNoStruc
;   Indicates whether or not the default thunk applies when
;   the TF_NOSTRUC flag is set.  If so, the only action in the
;   SL direction is to zero-extend wParam; in the LS direction,
;   to truncate wParam.
;
;
; This macro is invoked by the thk macro.  It creates the symbols that
; will be used by the table creation macros invoked at the end of this
; file.
;
; The labels take the form of pfn_xxyy_## and index_xxyy_## where
; xx is the table code, yy is the direction, and ## is a message number
; in decimal.
;
;   pfn_WMSL_1          equ WMSL_WM_CREATE
;   index_WMSL_1        equ 2
;   ret_WMSL_1          equ RC_BOOL
;
; The pfn_xxyy_## symbol records the thunk procedure address for
; message number ## in table xx in the yy direction, and the index_xxyy_##
; records its position in the compacted table of thunk procedure offsets. All
; messages have a corresponding index_xxyy_## symbol.  If the symbol value is
; COMMON_THUNK or UNIMPLEMENTED_THUNK, then there is no special thunk for the
; message and there is no corresponding pfn_xxyy_## symbol. If the symbol
; value is nonzero, pfn_xxyy_## is defined.
;
; The pfn_xxyy_## values are 16-bit addresses.  The address of the
; first thunk procedure is subtracted to create a 16-bit offset before
; storing in the thunk offset table.
;
; The ret_xxyy_## symbol holds the return type of the message, used for
; building a table the dispatcher will use to correctly thunk the message
; return code.
;
; The variable max_index keeps track of what the next nonzero index
; should be. The first entry in the thunk offset table is the default thunk,
; so special thunks start at index 1.  Only one table is processed at a
; time, so max_index is re-used by all.
;-----------------------------------------------------------------------;
add_thunk macro tbl:req,name:req,number:req,ret_type:=<RC_DEFAULT>,fDefNoStruc:=<0>
    ;; Create and execute statement such as:
    ;;
    ;;   pfn_WMSL_1 equ WMSL_WM_CREATE

    cat pfn_,&tbl,%dir,_,number,< equ >,&tbl,%dir,_,&name


    ;; Create and execute statement such as:
    ;;
    ;;   index_WMSL_1 equ max_index

    cat index_,&tbl,%dir,_,number,< equ max_index>

    ;; Create and execute statement such as:
    ;;
    ;;   ret_WMSL_1 equ RC_BOOL

    cat ret_,&tbl,%dir,_,number,< equ >,&ret_type

    ;; Create and execute statement such as:
    ;;
    ;;   no_struc_1 equ 0

    cat no_struc_,number,< equ >,&fDefNoStruc

    ;; Increment by 2 because it is an index into a table of words.
    max_index = max_index + 1

    ;; Index 0FFh is used to indicate unimplemented thunks.
    .erre max_index - 0FFh
endm

;-----------------------------------------------------------------------;
; add_null_thunk
;
; tbl
;   Code for table (i.e. WM, BM, etc.).
;
; number
;   The corresponding message number.
;
; value
;   The index value to give the message number.  This can be either
;   COMMON_THUNK or UNIMPLEMENTED_THUNK.
;
; ret_type
;   A code specifying the return type of the message.
;
; Same as add_thunk, except only index_xxyy_## is defined.
;-----------------------------------------------------------------------;
add_null_thunk macro tbl:req,number:req,value:=<COMMON_THUNK>,ret_type:=<RC_DEFAULT>
ifdef DEBUG
    ;; Create and execute statement such as:
    ;;
    ;;   index_WMSL_1 equ COMMON_THUNK

    cat index_,&tbl,%dir,_,number,< equ >,&value

else
;if RETAIL, no message will have index UNIMPLEMENTED_THUNK since dispatcher
;won't make special case for it
    ;; Create and execute statement such as:
    ;;
    ;;   index_WMSL_1 equ COMMON_THUNK

    cat index_,&tbl,%dir,_,number,< equ >,COMMON_THUNK

endif

    ;; Create and execute statement such as:
    ;;
    ;;   ret_WMSL_1 equ RC_BOOL

    cat ret_,&tbl,%dir,_,number,< equ >,&ret_type

    ;; Create and execute statement such as:
    ;;
    ;;   no_struc_1 equ 0

    cat no_struc_,number,< equ 0>
endm

;-----------------------------------------------------------------------;
; make_thunk_entries
;
; tbl
;   Code name of table being created.
;
; This macro uses the symbols created by thk to define the thunk
; entry tables in memory.  It enumerates all the index_xxyy_## symbols
; and makes an entry in the thunk procedure offset table for each
; nonzero value.
;-----------------------------------------------------------------------;
make_thunk_entries macro   tbl:req
    local symbol_index, symbol_pfn, msgnum

    DefTableLimits tbl

    ;;Create and execute a statement such as:
    ;;
    ;; dw offset WMLS_COMMON
    cat <dw offset >,&tbl,%dir,_COMMON

    msgnum = tbl_base
    % rept tbl_limit - tbl_base + 1
        ;; Create and execute a statement such as:
        ;;
        ;; symbol_index equ <index_WMLS_1>
        cat <symbol_index equ >,!<,index_,&tbl,%dir,_,%msgnum,!>

        % if symbol_index NE COMMON_THUNK
             % if symbol_index NE UNIMPLEMENTED_THUNK
                ;; Create and execute a statement such as:
                ;;
                ;; symbol_pfn equ <pfn_WMLS_1>
                cat <symbol_pfn equ >,!<,pfn_,&tbl,%dir,_,%msgnum,!>

                % dw offset symbol_pfn
            endif
        endif
        msgnum = msgnum + 1
    endm
endm

;-----------------------------------------------------------------------;
; make_index_entries
;
; tbl
;   Code name of table being created.
;
; This macro uses the symbols created by thk to define the index
; array in memory.  The index array is checked by the thunk dispatcher
; to determine if a message has a special thunk.  Messages without
; special thunks (most of them) go through a standard thunk.  If the
; index is nonzero, then it is used to look up the offset of the thunk
; procedure in another table.
;
; This table will have the index_xxyy_## value for each message for
; the given thunk class.
;-----------------------------------------------------------------------;
make_index_entries macro tbl:req
    local msgnum

    DefTableLimits tbl

    msgnum = tbl_base
    % rept tbl_limit - tbl_base + 1
        ;; Create and execute statement such as:
        ;;
        ;; db  index_WMLS_1

        cat <db index_>,tbl,%dir,_,%msgnum

        msgnum = msgnum + 1
    endm
endm

;-----------------------------------------------------------------------;
; make_ret_entries
;
; tbl
;   Code name of table being created.
;
; This macro uses the symbols created by thk to define the return-type
; array in memory.  The return-type array is checked by the thunk dispatcher
; to determine if a message return code requires thunking.
;
; This table will have the ret_xxyy_## value for each message for
; the given thunk class.
;-----------------------------------------------------------------------;
make_ret_entries macro tbl:req
    local msgnum

    DefTableLimits tbl

    msgnum = tbl_base
    % rept tbl_limit - tbl_base + 1
        ;; Create and execute statement such as:
        ;;
        ;; db  ret_WMLS_1

        cat <db ret_>,tbl,%dir,_,%msgnum

        msgnum = msgnum + 1
    endm
endm

;-----------------------------------------------------------------------;
; make_no_struc_entries
;
; This macro uses the symbols created by thk to define the TF_NOSTRUC
; array in memory.  The TF_NOSTRUC array is checked by the api thunk
; to determine if a message requires special thunking.
;
; This table will have the no_struc_xxyy_## value for each message
; in the WM class.
;-----------------------------------------------------------------------;
make_no_struc_entries macro
    local msgnum

    DefTableLimits WM

    msgnum = tbl_base
    % rept tbl_limit - tbl_base + 1
        ;; Create and execute statement such as:
        ;;
        ;; db  no_struc_1

        cat <db no_struc_>,%msgnum

        msgnum = msgnum + 1
    endm
endm

;-----------------------------------------------------------------------;
; DefIndexTable
;
; direction
;   The direction of thunking the table refers to.
;
; Creates a table containing indices into the corresponding table
; of thunk procedure offsets.
;-----------------------------------------------------------------------;
DefIndexTable macro
    local symbol_name

    ;; Create and execute a statement of the form:
    ;;
    ;; symbol_name equ <abWMIndex>

    cat <symbol_name equ >,!<,ab,WM,Index,!>

    ;; Define the array of tables and declare its name.
    % externDef symbol_name:byte
    % symbol_name label byte

    ;; Define the table's contents and verify that it has the right size.
    make_index_entries WM
    % .errnz  ($ - symbol_name) - C_WM
endm

;-----------------------------------------------------------------------;
; DefOffsetTable
;
; direction
;   The direction of thunking the table refers to.
;
; Creates a table containing the offsets to special thunk procedures.
; The table is packed, and many messages do not have special thunks,
; so there is another table used to map a message number to the proper
; element of this table. The dispatcher will not look in this array
; unless the message has a special thunk.
;-----------------------------------------------------------------------;
DefOffsetTable macro direction:req
    local symbol_name

    ;; Create and execute a statement of the form:
    ;;
    ;; symbol_name equ <awWMSLOffset>

    cat <symbol_name equ >,!<,aw,WM,&direction,Offset,!>

    ;; Define the array of tables and declare its name.
    % externDef symbol_name:word
    % symbol_name label word

    ;; Define the table's contents and verify that it has the right size.
    make_thunk_entries WM
endm

;-----------------------------------------------------------------------;
; DefRetTable
;
; direction
;   The direction of thunking the table refers to.
;
; Creates a table containing indices into the table of addresses of
; return-code thunks.
;-----------------------------------------------------------------------;
DefRetTable macro direction:req
    local symbol_name

    ;; Create and execute a statement of the form:
    ;;
    ;; symbol_name equ <abWMSLRet>

    cat <symbol_name equ >,!<,ab,WM&direction,Ret,!>

    ;; Define the array of return-code types and declare its name.
    % externDef symbol_name:byte
    % symbol_name label byte

    make_ret_entries WM
    % .errnz  ($ - symbol_name) - C_WM

endm

;-----------------------------------------------------------------------;
; DefNoStrucTable
;
; Creates a table containing flags indicating whether or not a message
; requires a special thunk when the TF_NOSTRUC flag is set.
;-----------------------------------------------------------------------;
DefNoStrucTable macro
    abNoStruc label byte

    ;; Define the table's contents and verify that it has the right size.
    make_no_struc_entries
    % .errnz  ($ - abNoStruc) - C_WM
endm

;-----------------------------------------------------------------------;
; DefAllMsgTables
;
; direction
;   The direction of the thunks (i.e. LS or SL).
;
; Create all the necessary tables for dispatching message thunks in
; the given direction.
;-----------------------------------------------------------------------;
DefAllMsgTables macro direction:req
    DefOffsetTable direction
    DefIndexTable
    DefRetTable direction
endm


; ----------------
; FROM NEWMISC.INC
; ----------------

;-----------------------------------------------------------------------;
; Values for non-special message thunk indices.  These indicate that
; the message goes through the common thunk, and whether or not to
; display the message "UNIMPLEMENTED MESSAGE THUNK" to the debug
; terminal.
;-----------------------------------------------------------------------;
COMMON_THUNK            equ       0
UNIMPLEMENTED_THUNK     equ     0FFh



; ---------------
; FROM NEWMSG.INC
; ---------------

;-----------------------------------------------------------------------;
; WM thunk class.  This is the main message table, comprising all
; known messages with number less than 400h.
;-----------------------------------------------------------------------;
        begin_thunk_table WM

        thk WM_CREATE               ,001h   ,<SL,LS>    ,RC_DEFAULT
        thk WM_DESTROY              ,002h   ,           ,RC_DEFAULT
        thk WM_MOVE                 ,003h   ,           ,RC_DEFAULT
        thk WM_SIZEWAIT             ,004h   ,           ,RC_DEFAULT
        thk WM_SIZE                 ,005h   ,           ,RC_DEFAULT
        thk WM_ACTIVATE             ,006h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk WM_SETFOCUS             ,007h   ,           ,RC_DEFAULT
        thk WM_KILLFOCUS            ,008h   ,           ,RC_DEFAULT
        thk WM_SETVISIBLE           ,009h   ,           ,RC_DEFAULT
        thk WM_ENABLE               ,00Ah   ,           ,RC_DEFAULT
        thk WM_SETREDRAW            ,00Bh   ,           ,RC_DEFAULT
        thk WM_SETTEXT              ,00Ch   ,<SL,LS>    ,RC_DEFAULT ,1
        thk WM_GETTEXT              ,00Dh   ,<SL,LS>    ,RC_DEFAULT ,1
        thk WM_GETTEXTLENGTH        ,00Eh   ,           ,RC_DEFAULT
        thk WM_PAINT                ,00Fh   ,           ,RC_DEFAULT

        thk WM_CLOSE                ,010h   ,           ,RC_DEFAULT
        thk WM_QUERYENDSESSION      ,011h   ,           ,RC_DEFAULT
        thk WM_QUIT                 ,012h   ,           ,RC_DEFAULT
        thk WM_QUERYOPEN            ,013h   ,           ,RC_DEFAULT
        thk WM_ERASEBKGND           ,014h   ,           ,RC_DEFAULT
        thk WM_SYSCOLORCHANGE       ,015h   ,           ,RC_DEFAULT
        thk WM_ENDSESSION           ,016h   ,           ,RC_DEFAULT
        thk WM_SYSTEMERROR          ,017h   ,           ,RC_DEFAULT
        thk WM_SHOWWINDOW           ,018h   ,           ,RC_DEFAULT
        thk WM_CTLCOLOR             ,019h   ,<SL>       ,RC_DEFAULT ,1
        thk WM_WININICHANGE         ,01Ah   ,<SL,LS>    ,RC_DEFAULT ,1
        thk WM_DEVMODECHANGE        ,01Bh   ,<SL,LS>    ,RC_DEFAULT ,1
        thk WM_ACTIVATEAPP          ,01Ch   ,           ,RC_DEFAULT ,1
        thk WM_FONTCHANGE           ,01Dh   ,           ,RC_DEFAULT
        thk WM_TIMECHANGE           ,01Eh   ,           ,RC_DEFAULT
        thk WM_CANCELMODE           ,01Fh   ,           ,RC_DEFAULT

        thk WM_SETCURSOR            ,020h   ,           ,RC_DEFAULT
        thk WM_MOUSEACTIVATE        ,021h   ,           ,RC_DEFAULT
        thk WM_CHILDACTIVATE        ,022h   ,           ,RC_DEFAULT
        thk WM_QUEUESYNC            ,023h   ,           ,RC_DEFAULT
        thk WM_GETMINMAXINFO        ,024h   ,<SL,LS>    ,RC_DEFAULT
;UNIMP: thk WM_LOGOFF,              ,025h
        thk WM_PAINTICON            ,026h   ,           ,RC_DEFAULT
        thk WM_ICONERASEBKGND       ,027h   ,           ,RC_DEFAULT
        thk WM_NEXTDLGCTL           ,028h   ,           ,RC_DEFAULT
        thk WM_ALTTABACTIVE         ,029h   ,           ,RC_DEFAULT
        thk WM_SPOOLERSTATUS        ,02Ah   ,           ,RC_DEFAULT
        thk WM_DRAWITEM             ,02Bh   ,<SL,LS>    ,RC_DEFAULT
        thk WM_MEASUREITEM          ,02Ch   ,<SL,LS>    ,RC_DEFAULT
        thk WM_DELETEITEM           ,02Dh   ,<SL,LS>    ,RC_DEFAULT
        thk WM_VKEYTOITEM           ,02Eh   ,<SL,LS>    ,RC_DEFAULT
        thk WM_CHARTOITEM           ,02Fh   ,<SL,LS>    ,RC_DEFAULT

        thk WM_SETFONT              ,030h   ,           ,RC_DEFAULT
        thk WM_GETFONT              ,031h   ,           ,RC_DEFAULT
        thk WM_SETHOTKEY            ,032h   ,           ,RC_DEFAULT
        thk WM_GETHOTKEY            ,033h   ,           ,RC_DEFAULT
        thk WM_FILESYSCHANGE        ,034h   ,           ,RC_DEFAULT
        thk WM_ISACTIVEICON         ,035h   ,           ,RC_DEFAULT
;UNIMP: thk WM_QUERYPARKICON        ,036h   ,           ,RC_DEFAULT
        thk WM_QUERYDRAGICON        ,037h   ,           ,RC_DEFAULT
        thk WM_WINHELP              ,038h   ,<SL,LS>    ,RC_DEFAULT
        thk WM_COMPAREITEM          ,039h   ,<SL,LS>    ,RC_DEFAULT
;UNIMP: thk WM_FULLSCREEN           ,03Ah
;UNIMP: thk WM_CLIENTSHUTDOWN       ,03Bh
;UNIMP: thk WM_DDEMLEVENT           ,03Ch

        thk MM_CALCSCROLL           ,03Fh   ,           ,RC_DEFAULT

;UNIMP: thk WM_TESTING              ,040h   ,           ,RC_DEFAULT
        thk WM_COMPACTING           ,041h   ,           ,RC_DEFAULT
        thk WM_OTHERWINDOWCREATED   ,042h   ,           ,RC_DEFAULT
        thk WM_OTHERWINDOWDESTROYED ,043h   ,           ,RC_DEFAULT
        thk WM_COMMNOTIFY           ,044h   ,           ,RC_DEFAULT
;UNIMP: thk WM_HOTKEYEVENT          ,045h   ,           ,RC_DEFAULT
        thk WM_WINDOWPOSCHANGING    ,046h   ,<SL,LS>    ,RC_DEFAULT
        thk WM_WINDOWPOSCHANGED     ,047h   ,<SL,LS>    ,RC_DEFAULT
        thk WM_POWER                ,048h   ,           ,RC_DEFAULT
;UNIMP: thk WM_COPYGLOBALDATA       ,049h
        thk WM_COPYDATA             ,04Ah   ,<SL,LS>    ,RC_DEFAULT
        thk WM_CANCELJOURNAL        ,04Bh
;UNIMP: thk WM_LOGONNOTIFY          ,04Ch

        thk WM_KEYF1                ,04Dh   ,           ,RC_DEFAULT
        thk WM_NOTIFY               ,04Eh   ,<SL,LS>    ,RC_DEFAULT ,1
;UNIMP: thk WM_ACCESS_WINDOW        ,04Fh
;UNIMP: thk WM_KBDCHANGEREQUEST     ,050h
;UNIMP: thk WM_KBDLAYOUTCHANGE      ,051h
        thk WM_TCARD                ,052h   ,           ,RC_DEFAULT
        thk WM_HELP                 ,053h   ,<SL,LS>    ,RC_DEFAULT

;UNIMP: thk WM_FINALDESTROY         ,070h
;UNIMP: thk WM_MEASUREITEM_CLIENTDATA   ,071h
        thk WM_CONTEXTMENU          ,07Bh   ,           ,RC_DEFAULT
        thk WM_STYLECHANGING        ,07Ch   ,<SL,LS>    ,RC_DEFAULT ,1
        thk WM_STYLECHANGED         ,07Dh   ,<SL,LS>    ,RC_DEFAULT ,1
        thk WM_DISPLAYCHANGE        ,07Eh   ,           ,RC_DEFAULT
        thk WM_GETICON              ,07Fh   ,           ,RC_DEFAULT
        thk WM_SETICON              ,080h   ,           ,RC_DEFAULT

        thk WM_NCCREATE             ,081h   ,<SL,LS>    ,RC_DEFAULT
        thk WM_NCDESTROY            ,082h   ,           ,RC_DEFAULT
        thk WM_NCCALCSIZE           ,083h   ,<SL,LS>    ,RC_DEFAULT
        thk WM_NCHITTEST            ,084h   ,           ,RC_DEFAULT
        thk WM_NCPAINT              ,085h   ,           ,RC_DEFAULT
        thk WM_NCACTIVATE           ,086h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk WM_GETDLGCODE           ,087h   ,           ,RC_DEFAULT
        thk WM_SYNCPAINT            ,088h   ,           ,RC_DEFAULT
;UNIMP: thk WM_SYNCTASK             ,089h   ,           ,RC_DEFAULT

        thk WM_NCMOUSEMOVE          ,0A0h   ,           ,RC_DEFAULT
        thk WM_NCLBUTTONDOWN        ,0A1h   ,           ,RC_DEFAULT
        thk WM_NCLBUTTONUP          ,0A2h   ,           ,RC_DEFAULT
        thk WM_NCLBUTTONDBLCLK      ,0A3h   ,           ,RC_DEFAULT
        thk WM_NCRBUTTONDOWN        ,0A4h   ,           ,RC_DEFAULT
        thk WM_NCRBUTTONUP          ,0A5h   ,           ,RC_DEFAULT
        thk WM_NCRBUTTONDBLCLK      ,0A6h   ,           ,RC_DEFAULT
        thk WM_NCMBUTTONDOWN        ,0A7h   ,           ,RC_DEFAULT
        thk WM_NCMBUTTONUP          ,0A8h   ,           ,RC_DEFAULT
        thk WM_NCMBUTTONDBLCLK      ,0A9h   ,           ,RC_DEFAULT

        ;Edit control messages.
        ;All have to be thunked because the message number changes.

        thk EM_GETSEL               ,0B0h   ,<SL,LS>    ,RC_DEFAULT
        thk EM_SETSEL               ,0B1h   ,<SL,LS>    ,RC_DEFAULT
        thk EM_GETRECT              ,0B2h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk EM_SETRECT              ,0B3h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk EM_SETRECTNP            ,0B4h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk EM_SCROLL               ,0B5h   ,           ,RC_DEFAULT
        thk EM_LINESCROLL           ,0B6h   ,<SL,LS>    ,RC_DEFAULT
        thk EM_SCROLLCARET          ,0B7h   ,<SL>       ,RC_DEFAULT
        thk EM_GETMODIFY            ,0B8h   ,           ,RC_DEFAULT
        thk EM_SETMODIFY            ,0B9h   ,           ,RC_DEFAULT
        thk EM_GETLINECOUNT         ,0BAh   ,           ,RC_DEFAULT
        thk EM_LINEINDEX            ,0BBh   ,<SL>       ,RC_DEFAULT
;UNIMP: thk EM_SETHANDLE            ,0BCh   ,<SL,LS>    ,RC_DEFAULT
;UNIMP: thk EM_GETHANDLE            ,0BDh   ,<SL,LS>    ,RC_DEFAULT
        thk EM_GETTHUMB             ,0BEh   ,           ,RC_DEFAULT
;UNIMP: *************************** ,0BFh
;UNIMP: *************************** ,0C0h
        thk EM_LINELENGTH           ,0C1h   ,<SL>       ,RC_DEFAULT ,1
        thk EM_REPLACESEL           ,0C2h   ,<SL,LS>    ,RC_DEFAULT ,1
;UNIMP: thk EM_SETFONT              ,0C3h   ,<LS>       ,RC_DEFAULT
        thk EM_GETLINE              ,0C4h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk EM_LIMITTEXT            ,0C5h   ,<SL>       ,RC_DEFAULT
        thk EM_CANUNDO              ,0C6h   ,           ,RC_DEFAULT
        thk EM_UNDO                 ,0C7h   ,           ,RC_DEFAULT
        thk EM_FMTLINES             ,0C8h   ,           ,RC_DEFAULT
        thk EM_LINEFROMCHAR         ,0C9h   ,<SL>       ,RC_DEFAULT
;UNIMP: thk EM_SETWORDBREAK         ,0CAh   ,<LS>       ,RC_DEFAULT ,1
        thk EM_SETTABSTOPS          ,0CBh   ,<SL,LS>    ,RC_DEFAULT ,1
        thk EM_SETPASSWORDCHAR      ,0CCh   ,           ,RC_DEFAULT
        thk EM_EMPTYUNDOBUFFER      ,0CDh   ,           ,RC_DEFAULT
        thk EM_GETFIRSTVISIBLELINE  ,0CEh   ,           ,RC_DEFAULT ,1
        thk EM_SETREADONLY          ,0CFh   ,           ,RC_DEFAULT
        thk EM_SETWORDBREAKPROC     ,0D0h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk EM_GETWORDBREAKPROC     ,0D1h   ,           ,RC_GETWORDBREAKPROC,1
        thk EM_GETPASSWORDCHAR      ,0D2h   ,           ,RC_DEFAULT
        thk EM_SETMARGINS           ,0D3h   ,           ,RC_DEFAULT
        thk EM_GETMARGINS           ,0D4h   ,           ,RC_DEFAULT
        thk EM_GETLIMITTEXT         ,0D5h   ,           ,RC_DEFAULT
        thk EM_POSFROMCHAR          ,0D6h   ,           ,RC_DEFAULT
        thk EM_CHARFROMPOS          ,0D7h   ,           ,RC_DEFAULT

        ;Scroll bar messages.

        thk SBM_SETPOS              ,0E0h   ,<SL>       ,RC_DEFAULT
        thk SBM_GETPOS              ,0E1h   ,           ,RC_DEFAULT
        thk SBM_SETRANGE            ,0E2h   ,<SL,LS>    ,RC_DEFAULT
        thk SBM_GETRANGE            ,0E3h   ,<SL,LS>    ,RC_DEFAULT
        thk SBM_ENABLE_ARROWS       ,0E4h   ,           ,RC_DEFAULT
        thk SBM_SETRANGEREDRAW      ,0E6h   ,<SL,LS>    ,RC_DEFAULT
        thk SBM_SETPAGE             ,0E7h   ,<SL>       ,RC_DEFAULT
        thk SBM_GETPAGE             ,0E8h   ,           ,RC_DEFAULT
        thk SBM_SETSCROLLINFO       ,0E9h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk SBM_GETSCROLLINFO       ,0EAh   ,<SL,LS>    ,RC_DEFAULT ,1

        ;Button control messages.
        ;All have to be thunked because the message number changes.

        thk BM_GETCHECK             ,0F0h   ,           ,RC_DEFAULT
        thk BM_SETCHECK             ,0F1h   ,           ,RC_DEFAULT
        thk BM_GETSTATE             ,0F2h   ,           ,RC_DEFAULT
        thk BM_SETSTATE             ,0F3h   ,           ,RC_DEFAULT
        thk BM_SETSTYLE             ,0F4h   ,           ,RC_DEFAULT
        thk BM_CLICK                ,0F5h   ,           ,RC_DEFAULT
        thk BM_GETICON              ,0F6h   ,           ,RC_DEFAULT
        thk BM_SETICON              ,0F7h   ,           ,RC_DEFAULT
        thk BM_GETBITMAP            ,0F8h   ,           ,RC_DEFAULT
        thk BM_SETBITMAP            ,0F9h   ,           ,RC_DEFAULT

        thk WM_KEYDOWN              ,100h   ,           ,RC_DEFAULT
        thk WM_KEYUP                ,101h   ,           ,RC_DEFAULT
        thk WM_CHAR                 ,102h   ,           ,RC_DEFAULT
        thk WM_DEADCHAR             ,103h   ,           ,RC_DEFAULT
        thk WM_SYSKEYDOWN           ,104h   ,           ,RC_DEFAULT
        thk WM_SYSKEYUP             ,105h   ,           ,RC_DEFAULT
        thk WM_SYSCHAR              ,106h   ,           ,RC_DEFAULT
        thk WM_SYSDEADCHAR          ,107h   ,           ,RC_DEFAULT
;UNIMP: thk WM_YOMICHAR             ,108h   ,           ,RC_DEFAULT

;UNIMP: thk WM_CONVERTREQUEST       ,10Ah   ,           ,RC_DEFAULT
;UNIMP: thk WM_CONVERTRESULT        ,10Bh   ,           ,RC_DEFAULT

        thk WM_INITDIALOG           ,110h   ,<SL,LS>    ,RC_DEFAULT
        thk WM_COMMAND              ,111h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk WM_SYSCOMMAND           ,112h   ,           ,RC_DEFAULT
        thk WM_TIMER                ,113h   ,           ,RC_DEFAULT
        thk WM_HSCROLL              ,114h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk WM_VSCROLL              ,115h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk WM_INITMENU             ,116h   ,           ,RC_DEFAULT
        thk WM_INITMENUPOPUP        ,117h   ,           ,RC_DEFAULT
        thk WM_SYSTIMER             ,118h   ,           ,RC_DEFAULT

        thk WM_MENUSELECT           ,11Fh   ,<SL,LS>    ,RC_DEFAULT ,1
        thk WM_MENUCHAR             ,120h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk WM_ENTERIDLE            ,121h   ,           ,RC_DEFAULT ,1

        thk WM_LBTRACKPOINT         ,131h   ,           ,RC_DEFAULT
        thk WM_CTLCOLORMSGBOX       ,132h   ,<LS>       ,RC_DEFAULT ,1
        thk WM_CTLCOLOREDIT         ,133h   ,<LS>       ,RC_DEFAULT ,1
        thk WM_CTLCOLORLISTBOX      ,134h   ,<LS>       ,RC_DEFAULT ,1
        thk WM_CTLCOLORBTN          ,135h   ,<LS>       ,RC_DEFAULT ,1
        thk WM_CTLCOLORDLG          ,136h   ,<LS>       ,RC_DEFAULT ,1
        thk WM_CTLCOLORSCROLLBAR    ,137h   ,<LS>       ,RC_DEFAULT ,1
        thk WM_CTLCOLORSTATIC       ,138h   ,<LS>       ,RC_DEFAULT ,1

        ;Combobox control messages.
        ;All have to be thunked because the message number changes.

        thk CB_GETEDITSEL           ,140h   ,           ,RC_DEFAULT
        thk CB_LIMITTEXT            ,141h   ,           ,RC_DEFAULT
        thk CB_SETEDITSEL           ,142h   ,           ,RC_DEFAULT
        thk CB_ADDSTRING            ,143h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk CB_DELETESTRING         ,144h   ,           ,RC_DEFAULT
        thk CB_DIR                  ,145h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk CB_GETCOUNT             ,146h   ,           ,RC_DEFAULT
        thk CB_GETCURSEL            ,147h   ,           ,RC_DEFAULT
        thk CB_GETLBTEXT            ,148h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk CB_GETLBTEXTLEN         ,149h   ,           ,RC_DEFAULT
        thk CB_INSERTSTRING         ,14Ah   ,<SL,LS>    ,RC_DEFAULT ,1
        thk CB_RESETCONTENT         ,14Bh   ,           ,RC_DEFAULT
        thk CB_FINDSTRING           ,14Ch   ,<SL,LS>    ,RC_DEFAULT ,1
        thk CB_SELECTSTRING         ,14Dh   ,<SL,LS>    ,RC_DEFAULT ,1
        thk CB_SETCURSEL            ,14Eh   ,<SL>       ,RC_DEFAULT
        thk CB_SHOWDROPDOWN         ,14Fh   ,           ,RC_DEFAULT
        thk CB_GETITEMDATA          ,150h   ,           ,RC_DEFAULT
        thk CB_SETITEMDATA          ,151h   ,           ,RC_DEFAULT
        thk CB_GETDROPPEDCONTROLRECT,152h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk CB_SETITEMHEIGHT        ,153h   ,           ,RC_DEFAULT
        thk CB_GETITEMHEIGHT        ,154h   ,           ,RC_DEFAULT
        thk CB_SETEXTENDEDUI        ,155h   ,           ,RC_DEFAULT
        thk CB_GETEXTENDEDUI        ,156h   ,           ,RC_DEFAULT
        thk CB_GETDROPPEDSTATE      ,157h   ,           ,RC_DEFAULT
        thk CB_FINDSTRINGEXACT      ,158h   ,<SL,LS>    ,RC_DEFAULT ,1
;;      thk CB_SETLOCALE            ,159h
;;      thk CB_GETLOCALE            ,15Ah
        thk CB_GETTOPINDEX          ,15Bh   ,           ,RC_DEFAULT
        thk CB_SETTOPINDEX          ,15Ch   ,           ,RC_DEFAULT
        thk CB_GETHORIZONTALEXTENT  ,15Dh   ,           ,RC_DEFAULT
        thk CB_SETHORIZONTALEXTENT  ,15Eh   ,           ,RC_DEFAULT
        thk CB_GETDROPPEDWIDTH      ,15Fh   ,           ,RC_DEFAULT
        thk CB_SETDROPPEDWIDTH      ,160h   ,           ,RC_DEFAULT
        thk CB_INITSTORAGE          ,161h   ,           ,RC_DEFAULT

;       thk CB_MSGMAX               ,162h                           ,1

        ;Static control messages.
        thk STM_SETICON             ,170h   ,           ,RC_DEFAULT ,1
        thk STM_GETICON             ,171h   ,           ,RC_DEFAULT ,1
        thk STM_SETBITMAP           ,172h   ,           ,RC_DEFAULT ,1
        thk STM_GETBITMAP           ,173h   ,           ,RC_DEFAULT ,1
        thk STM_SETMETAPICT         ,174h   ,           ,RC_DEFAULT ,1
        thk STM_GETMETAPICT         ,175h   ,           ,RC_DEFAULT ,1

        ;Listbox control messages.
        ;All have to be thunked because the message number changes.

        thk LB_ADDSTRING            ,180h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk LB_INSERTSTRING         ,181h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk LB_DELETESTRING         ,182h   ,           ,RC_DEFAULT
;UNIMP: *************************** ,183h
        thk LB_RESETCONTENT         ,184h   ,           ,RC_DEFAULT
        thk LB_SETSEL               ,185h   ,<SL>       ,RC_DEFAULT
        thk LB_SETCURSEL            ,186h   ,<SL>       ,RC_DEFAULT
        thk LB_GETSEL               ,187h   ,<SL>       ,RC_DEFAULT
        thk LB_GETCURSEL            ,188h   ,           ,RC_DEFAULT
        thk LB_GETTEXT              ,189h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk LB_GETTEXTLEN           ,18Ah   ,           ,RC_DEFAULT
        thk LB_GETCOUNT             ,18Bh   ,           ,RC_DEFAULT
        thk LB_SELECTSTRING         ,18Ch   ,<SL,LS>    ,RC_DEFAULT ,1
        thk LB_DIR                  ,18Dh   ,<SL,LS>    ,RC_DEFAULT ,1
        thk LB_GETTOPINDEX          ,18Eh   ,           ,RC_DEFAULT
        thk LB_FINDSTRING           ,18Fh   ,<SL,LS>    ,RC_DEFAULT ,1
        thk LB_GETSELCOUNT          ,190h   ,           ,RC_DEFAULT
        thk LB_GETSELITEMS          ,191h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk LB_SETTABSTOPS          ,192h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk LB_GETHORIZONTALEXTENT  ,193h   ,           ,RC_DEFAULT
        thk LB_SETHORIZONTALEXTENT  ,194h   ,           ,RC_DEFAULT
        thk LB_SETCOLUMNWIDTH       ,195h   ,           ,RC_DEFAULT
        thk LB_ADDFILE              ,196h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk LB_SETTOPINDEX          ,197h   ,           ,RC_DEFAULT
        thk LB_GETITEMRECT          ,198h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk LB_GETITEMDATA          ,199h   ,           ,RC_DEFAULT
        thk LB_SETITEMDATA          ,19Ah   ,           ,RC_DEFAULT
        thk LB_SELITEMRANGE         ,19Bh   ,           ,RC_DEFAULT
        thk LB_SETANCHORINDEX       ,19Ch   ,<SL>       ,RC_DEFAULT
        thk LB_GETANCHORINDEX       ,19Dh   ,           ,RC_DEFAULT
        thk LB_SETCARETINDEX        ,19Eh   ,<SL>       ,RC_DEFAULT
        thk LB_GETCARETINDEX        ,19Fh   ,           ,RC_DEFAULT
        thk LB_SETITEMHEIGHT        ,1A0h   ,           ,RC_DEFAULT
        thk LB_GETITEMHEIGHT        ,1A1h   ,           ,RC_DEFAULT
        thk LB_FINDSTRINGEXACT      ,1A2h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk LBCB_CARETON            ,1A3h   ,           ,RC_DEFAULT
        thk LBCB_CARETOFF           ,1A4h   ,           ,RC_DEFAULT
        thk LB_SETLOCALE            ,1A5h   ,           ,RC_DEFAULT
        thk LB_GETLOCALE            ,1A6h   ,           ,RC_DEFAULT
        thk LB_SETCOUNT             ,1A7h   ,           ,RC_DEFAULT
        thk LB_ITEMFROMPOINT        ,1A8h   ,           ,RC_DEFAULT

        thk WM_MOUSEMOVE            ,200h   ,           ,RC_DEFAULT
        thk WM_LBUTTONDOWN          ,201h   ,           ,RC_DEFAULT
        thk WM_LBUTTONUP            ,202h   ,           ,RC_DEFAULT
        thk WM_LBUTTONDBLCLK        ,203h   ,           ,RC_DEFAULT
        thk WM_RBUTTONDOWN          ,204h   ,           ,RC_DEFAULT
        thk WM_RBUTTONUP            ,205h   ,           ,RC_DEFAULT
        thk WM_RBUTTONDBLCLK        ,206h   ,           ,RC_DEFAULT
        thk WM_MBUTTONDOWN          ,207h   ,           ,RC_DEFAULT
        thk WM_MBUTTONUP            ,208h   ,           ,RC_DEFAULT
        thk WM_MBUTTONDBLCLK        ,209h   ,           ,RC_DEFAULT
        thk WM_PARENTNOTIFY         ,210h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk WM_ENTERMENULOOP        ,211h   ,           ,RC_DEFAULT
        thk WM_EXITMENULOOP         ,212h   ,           ,RC_DEFAULT
;       thk WM_NEXTMENU             ,213h   ,<SL,LS>    ,RC_NEXTMENU,1
        thk WM_NEXTMENU             ,213h   ,           ,RC_DEFAULT
        thk WM_SIZING               ,214h   ,<SL,LS>    ,RC_DEFAULT
        thk WM_CAPTURECHANGED       ,215h   ,           ,RC_DEFAULT
        thk WM_MOVING               ,216h   ,<SL,LS>    ,RC_DEFAULT
        thk WM_DEVICEBROADCAST      ,217h   ,<SL,LS>    ,RC_DEFAULT

        thk WM_MDICREATE            ,220h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk WM_MDIDESTROY           ,221h   ,           ,RC_DEFAULT
        thk WM_MDIACTIVATE          ,222h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk WM_MDIRESTORE           ,223h   ,           ,RC_DEFAULT
        thk WM_MDINEXT              ,224h   ,           ,RC_DEFAULT
        thk WM_MDIMAXIMIZE          ,225h   ,           ,RC_DEFAULT
        thk WM_MDITILE              ,226h   ,           ,RC_DEFAULT
        thk WM_MDICASCADE           ,227h   ,           ,RC_DEFAULT
        thk WM_MDIICONARRANGE       ,228h   ,           ,RC_DEFAULT
        thk WM_MDIGETACTIVE         ,229h   ,<SL,LS>    ,RC_MDIGETACTIVE
        thk WM_DROPOBJECT           ,22Ah   ,<SL,LS>    ,RC_DEFAULT
        thk WM_QUERYDROPOBJECT      ,22Bh   ,<SL,LS>    ,RC_DEFAULT
        thk WM_BEGINDRAG            ,22Ch   ,<SL,LS>    ,RC_DEFAULT
        thk WM_DRAGLOOP             ,22Dh   ,<SL,LS>    ,RC_DEFAULT
        thk WM_DRAGSELECT           ,22Eh   ,<SL,LS>    ,RC_DEFAULT
        thk WM_DRAGMOVE             ,22Fh   ,<SL,LS>    ,RC_DEFAULT
        thk WM_MDISETMENU           ,230h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk WM_ENTERSIZEMOVE        ,231h   ,           ,RC_DEFAULT
        thk WM_EXITSIZEMOVE         ,232h   ,           ,RC_DEFAULT
        thk WM_DROPFILES            ,233h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk WM_MDIREFRESHMENU       ,234h   ,           ,RC_DEFAULT

;       thk WM_KANJIFIRST           ,280h   ,           ,RC_DEFAULT
;       thk WM_KANJILAST            ,29Fh   ,           ,RC_DEFAULT

        thk WM_CUT                  ,300h   ,           ,RC_DEFAULT
        thk WM_COPY                 ,301h   ,           ,RC_DEFAULT
        thk WM_PASTE                ,302h   ,           ,RC_DEFAULT
        thk WM_CLEAR                ,303h   ,           ,RC_DEFAULT
        thk WM_UNDO                 ,304h   ,           ,RC_DEFAULT
        thk WM_RENDERFORMAT         ,305h   ,           ,RC_DEFAULT
        thk WM_RENDERALLFORMATS     ,306h   ,           ,RC_DEFAULT
        thk WM_DESTROYCLIPBOARD     ,307h   ,           ,RC_DEFAULT
        thk WM_DRAWCLIPBOARD        ,308h   ,           ,RC_DEFAULT
        thk WM_PAINTCLIPBOARD       ,309h   ,<SL,LS>    ,RC_DEFAULT ,1
        thk WM_VSCROLLCLIPBOARD     ,30Ah   ,           ,RC_DEFAULT
        thk WM_SIZECLIPBOARD        ,30Bh   ,<SL,LS>    ,RC_DEFAULT ,1
        thk WM_ASKCBFORMATNAME      ,30Ch   ,<SL,LS>    ,RC_DEFAULT ,1
        thk WM_CHANGECBCHAIN        ,30Dh   ,           ,RC_DEFAULT ,1
        thk WM_HSCROLLCLIPBOARD     ,30Eh   ,           ,RC_DEFAULT
        thk WM_QUERYNEWPALETTE      ,30Fh   ,           ,RC_DEFAULT

;UNIMP: thk WM_PALETTEISCHANGING    ,310h   ,           ,RC_DEFAULT
        thk WM_PALETTECHANGED       ,311h   ,           ,RC_DEFAULT
        thk WM_HOTKEY               ,312h   ,           ,RC_DEFAULT ,1
;UNIMP: thk WM_HOOKMSG              ,314h
;UNIMP: thk WM_EXITPROCESS          ,315h
;UNIMP: thk WM_WAKETHREAD           ,316h
        thk WM_PRINT                ,317h   ,           ,RC_DEFAULT
        thk WM_PRINTCLIENT          ,318h   ,           ,RC_DEFAULT

        thk WM_AFXFIRST             ,360h   ,           ,RC_DEFAULT
        thk WM_AFX2                 ,361h   ,           ,RC_DEFAULT
        thk WM_AFX3                 ,362h   ,           ,RC_DEFAULT
        thk WM_AFX4                 ,363h   ,           ,RC_DEFAULT
        thk WM_AFX5                 ,364h   ,           ,RC_DEFAULT
        thk WM_AFX6                 ,365h   ,           ,RC_DEFAULT
        thk WM_AFX7                 ,366h   ,           ,RC_DEFAULT
        thk WM_AFX8                 ,367h   ,           ,RC_DEFAULT
        thk WM_AFX9                 ,368h   ,           ,RC_DEFAULT
        thk WM_AFX10                ,369h   ,           ,RC_DEFAULT
        thk WM_AFX11                ,36Ah   ,           ,RC_DEFAULT
        thk WM_AFX12                ,36Bh   ,           ,RC_DEFAULT
        thk WM_AFX13                ,36Ch   ,           ,RC_DEFAULT
        thk WM_AFX14                ,36Dh   ,           ,RC_DEFAULT
        thk WM_AFX15                ,36Eh   ,           ,RC_DEFAULT
        thk WM_AFX16                ,36Fh   ,           ,RC_DEFAULT
        thk WM_AFX17                ,370h   ,           ,RC_DEFAULT
        thk WM_AFX18                ,371h   ,           ,RC_DEFAULT
        thk WM_AFX19                ,372h   ,           ,RC_DEFAULT
        thk WM_AFX20                ,373h   ,           ,RC_DEFAULT
        thk WM_AFX21                ,374h   ,           ,RC_DEFAULT
        thk WM_AFX22                ,375h   ,           ,RC_DEFAULT
        thk WM_AFX23                ,376h   ,           ,RC_DEFAULT
        thk WM_AFX24                ,377h   ,           ,RC_DEFAULT
        thk WM_AFX25                ,378h   ,           ,RC_DEFAULT
        thk WM_AFX26                ,379h   ,           ,RC_DEFAULT
        thk WM_AFX27                ,37Ah   ,           ,RC_DEFAULT
        thk WM_AFX28                ,37Bh   ,           ,RC_DEFAULT
        thk WM_AFX29                ,37Ch   ,           ,RC_DEFAULT
        thk WM_AFX30                ,37Dh   ,           ,RC_DEFAULT
        thk WM_AFX31                ,37Eh   ,           ,RC_DEFAULT
        thk WM_AFXLAST              ,37Fh   ,           ,RC_DEFAULT


;       thk WM_PENWINFIRST          ,380h   ,           ,RC_DEFAULT
;       thk WM_PENWINLAST           ,38Fh   ,           ,RC_DEFAULT
;       thk WM_COALESCE_FIRST       ,390h   ,           ,RC_DEFAULT
;       thk WM_COALESCE_LAST        ,39Fh   ,           ,RC_DEFAULT
;       thk WM_MM_RESERVED_FIRST    ,3A0h   ,           ,RC_DEFAULT
;       thk WM_MM_RESERVED_LAST     ,3DFh   ,           ,RC_DEFAULT
        thk WM_DDE_INITIATE         ,3E0h   ,           ,RC_DEFAULT
        thk WM_DDE_TERMINATE        ,3E1h   ,           ,RC_DEFAULT
        thk WM_DDE_ADVISE           ,3E2h   ,               ,RC_DEFAULT
        thk WM_DDE_UNADVISE         ,3E3h   ,           ,RC_DEFAULT
        thk WM_DDE_ACK              ,3E4h   ,               ,RC_DEFAULT
        thk WM_DDE_DATA             ,3E5h   ,               ,RC_DEFAULT
        thk WM_DDE_REQUEST          ,3E6h   ,           ,RC_DEFAULT
        thk WM_DDE_POKE             ,3E7h   ,           ,RC_DEFAULT
        thk WM_DDE_EXECUTE          ,3E8h   ,<SL,LS>    ,RC_DEFAULT,   1
;       thk WM_INTERNAL_DDE_LAST    ,3EFh   ,           ,RC_DEFAULT
;       thk WM_CBT_RESERVED_FIRST   ,3F0h   ,           ,RC_DEFAULT
;       thk WM_CBT_RESERVED_LSAT    ,3FFh   ,           ,RC_DEFAULT

end_thunk_table


; ------------
; FROM RET.INC
; ------------

BeginDefRetType macro
    ret_type_id = 0
endm

DefRetType macro name
    RC_&name equ ret_type_id

    ifdef dir
        ;Create and execute a statement of the form:
        ;
        ; RC_0 equ <RCSL_DEFAULT>

        cat RC_,%ret_type_id,< equ >,!<,RC,%dir,_,&name,!>
    endif

    ret_type_id = ret_type_id + 1
endm

EndDefRetType macro
    RC_MAX equ ret_type_id - 1
endm

MakeRetDispatchTable macro
    local ret_type_id

    ;Create and execute statements of the form:
    ;
    ; externDef awSLRetOffset:word
    ; awSLRetOffset label word
    cat <externDef >,aw,%dir,RetOffset,<:word>
    cat aw,%dir,RetOffset,< label word>

    ret_type_id = 0
    repeat RC_MAX + 1
        ;Create and execute a statement of the form:
        ;
        ; % dw offset RC_0
        ;
        ; which when executed produces a statement like:
        ;
        ; dw offset RCSL_DEFAULT
        cat <!% dw offset RC_>,%ret_type_id

        ret_type_id = ret_type_id + 1
    endm
endm

BeginDefRetType

DefRetType DEFAULT
DefRetType MDIGETACTIVE
DefRetType GETWORDBREAKPROC
;DefRetType NEXTMENU

EndDefRetType
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\user\newmisc.inc ===
include    thkmacro.inc


;-----------------------------------------------------------------------;
; publab
;
; Make a public label from the given name, and size (if specified).
;-----------------------------------------------------------------------;
publab  macro   name:req,label_size
    public  name
    ifb <label_size>
        name:
    else
        name label label_size
    endif
endm


;-----------------------------------------------------------------------;
; DefMsgTableRange
;
; tbl
;   Table code-name.
;
; min32
;   minimum 32-bit message number in table
;
; max32
;   maximum 32-bit message number in table
;
; min16
;   minimum 16-bit message number in table
;
;
; Define the message ranges for each class.
;
; For each table (e.g. WM), define the following constants:
;
; MIN32_WM      minimum 32-bit message number in table
; MAX32_WM      maximum 32-bit message number in table
; MIN16_WM      minimum 16-bit message number in table
; MAX16_WM      maximum 16-bit message number in table
; C_WM          number of messages in table
;-----------------------------------------------------------------------;

DefMsgTableRange macro tbl,min32,max32,min16
    MIN32_&tbl equ min32
    MAX32_&tbl equ max32
    C_&tbl equ max32 - min32 + 1
    MIN16_&tbl equ min16
    MAX16_&tbl equ min16 + max32 - min32
endm


;                name  min32 max32 min16
;                -----------------------
DefMsgTableRange WM,     0h, 3FFh,   0h
DefMsgTableRange BM,   0F0h, 0F7h, 400h
DefMsgTableRange CB,   140h, 161h, 400h
DefMsgTableRange DM,   400h, 402h, 400h
ifdef FE_IME
DefMsgTableRange EM,   0B0h, 0D9h, 400h
else
DefMsgTableRange EM,   0B0h, 0D7h, 400h
endif
DefMsgTableRange LB,   180h, 1A9h, 401h
DefMsgTableRange SBM,  0E0h, 0EAh, 400h
DefMsgTableRange STM,  170h, 173h, 400h
DefMsgTableRange MN,   1E0h, 1E7h, 401h   


; THESE MUST BE IN SAME ORDER AS TABLE ENTRIES BELOW
CLASS_WM        equ     00h
CLASS_BM        equ     01h
CLASS_CB        equ     02h
CLASS_EM        equ     03h
CLASS_LB        equ     04h
CLASS_SBM       equ     05h
CLASS_STM       equ     06h
CLASS_MN        equ     07h
CLASS_MAX       equ     08h

CLASS_SPECIAL   equ     0FEh
CLASS_UNDEFINED equ     0FFh


;-----------------------------------------------------------------------;
; FullClassList
;
; This is the list of all possible thunk classes.
;-----------------------------------------------------------------------;
;The DM thunk class doesn't require any special thunks.
;FullClassList   equ     <WM,BM,CB,DM,EM,LB,MN,MDI,SBM,STM>
FullClassList   equ     <WM,BM,CB,EM,LB,SBM,STM,MN>




;***********************************************************************;
; Thunk pre- and post-processing macros.  These perform any necessary
; setup prior to calling the thunking subroutines.
;***********************************************************************;
;-----------------------------------------------------------------------;
; InitLocalSpace
;
; flags
;       Indicates api-specific flags to be set in THKSPACE16.s16_fw.
;
;
; Initialize the variables in THKSPACE16 in a standard way.
;-----------------------------------------------------------------------;
InitLocalSpace macro flags:req, base:=<si>
;;Initialize local variables.
    mov     word ptr base&_space.s16_fw, flags

    xor     eax, eax

    mov     dword ptr base&_space.s16_atomClass, eax
    .errnz s16_atomClass - s16_fw - 2

    ifdef DEBUG

        mov     dword ptr base&_space.s16_message, eax
        .errnz s16_message - s16_hwnd - 2

        dec     eax
        mov     base&_space.s16_wParam,eax
        mov     base&_space.s16_lParam,eax
        mov     base&_space.s16_lResult,eax
        mov     base&_space.s16_dwExtra1,eax
        mov     base&_space.s16_dwExtra2,eax
    endif
endm


;-----------------------------------------------------------------------;
; MsgThkPreProc
;
; flags
;       Indicates api-specific flags to be set in THKSPACE16.s16_fw.
;
; base
;       Indicates which register to use for referencing stack frame.
;       If not defined, default of <bp> will be used.
;
; Requirements:
;       bp_hwnd be defined
;       bp_message be defined
;       bp_wParamLo be defined
;       bp_wParamHi
;       bp_lParam be defined
;       base&_space be defined
;
;       dir be defined as either SL or LS
;
; Results:
;       SP  =  original SP - size THKSPACE16
;              - extra space allocated by thunk, if any
; History:
;  08-07-91 BobGru
; Wrote it.
;-----------------------------------------------------------------------;
MsgThkPreProc   macro   flags:=<0>, base:=<bp>

    AssertUserDS

;;Allocate local variable space
    sub     sp,size THKSPACE16
    InitLocalSpace  flags, base

;;Thunk the message parameters.
    push     word ptr bp_hwnd
    push     word ptr bp_message
    push     word ptr bp_wParamHi
    push     word ptr bp_wParamLo
    push    dword ptr bp_lParam

    cat <call ThkMsg>,%dir
endm


;-----------------------------------------------------------------------;
; MsgThkPostProc
;
; exit_label
;       Name of label to jump to for exiting.  If not defined, macro
;       will fall out the bottom.
;
; base
;       Indicates which register to use for referencing stack frame.
;       If not defined, default of <bp> will be used.
;
; Requirements:
;       EAX  =  return code
;       bp_hwnd be defined
;       bp_message be defined
;       bp_wParamLo  be defined
;       bp_wParamHi be defined
;       bp_lParam  be defined
;       base&_cleanup be defined
;
;       dir be defined as either SL or LS
;
; Results:
;       Message parameters are unthunked, return code is left in EAX,
;       and stack frame is cleaned up.
;
; History:
;  08-07-91 BobGru
; Wrote it.
;-----------------------------------------------------------------------;
MsgThkPostProc  macro   base:=<bp>
    local   no_clean_up

    AssertUserDS

    ; Cleanup after thunking.  Except for pointers (xmovlp, xmovs), 
    ; we don't need to do anything.  This is used for sync message 
    ; sending only.

    % ifidni <dir>,<LS>
        ;Move return from 16bits into EAX
        DXAX2EAX
    % else
        ;Return from 32bits is in EAX already
    endif

    ; Save return value
    mov     dword ptr base&_space.s16_lResult, eax

    ;If any cleanup necessary from thunking, do it now.
    test    base&_space.s16_fw, TF_CLEANUP
    jz      no_clean_up

    push     word ptr base&_space.s16_hwnd          ;;original params
    push     word ptr base&_space.s16_message       ;;
    push    dword ptr base&_space.s16_wParam        ;;
    push    dword ptr base&_space.s16_lParam        ;;

    % ifidni <dir>,<SL>
        call    ThkMsgLS
    else
        call    ThkMsgSL
    endif

no_clean_up:
    ;Restore return result.
    mov     eax, dword ptr base&_space.s16_lResult

    %ifidni <dir>,<LS>
        ;Return to 32bits is in EAX already
    %else
        ;Move return from 32bits into DX:AX
        shld    edx, eax, 16
    endif
    lea     sp,base&_cleanup                  ;;clean up stack frame
endm



;----------------------------------------------------------------------------
;
;   AssertUserDS
;
;   Debug macro that asserts the current DS is User's DGROUP
;
;----------------------------------------------------------------------------
AssertUserDS macro
    local   DSOk
ifdef DEBUG
    push    ds
    pop     bx
    cmp     bx, _DATA
    je      DSOk

    int     3
DSOk:
endif
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\basedef.h ===
/***    BASEDEF.H
 *
 *      Basic constants and types for the VMM and VxDs
 *      Copyright (c) 1988,1989 Microsoft Corporation
 *
 *      NOBASEDEFS turns off the base definations
 */

#ifndef NOBASEDEFS
#define NOBASEDEFS

/*
 *  No warnings generated on non-standard usuage such as double
 *  slash for comments
 */
#pragma warning (disable:4206)
#pragma warning (disable:4214)
#pragma warning (disable:4201)
#pragma warning (disable:4505)
#pragma warning (disable:4514)
#pragma warning (disable:4001)

#ifndef FALSE
#define FALSE   0
#endif
#ifndef TRUE
#define TRUE	1
#endif
#ifndef NULL
#define NULL    '\0'                    // Null pointer
#endif

#define CDECL   _cdecl
#define PASCAL  _pascal
#define VOID    void
#define CONST   const
#define VOLATILE volatile

typedef int INT;                        // i
typedef unsigned int UINT;              // u
typedef int BOOL;                       // f

typedef unsigned char BYTE;             // b
typedef unsigned short WORD;            // w
typedef unsigned long DWORD;            // dw

#ifndef _H2INC

typedef struct qword_s {                /* qword */
   DWORD qword_lo;
   DWORD qword_hi;
} QWORD;				// qw

#endif

#ifndef	_NTDEF_

typedef char CHAR;                      // ch
typedef unsigned char UCHAR;            // uch
typedef short SHORT;                    // s
typedef unsigned short USHORT;          // us
typedef long LONG;                      // l
typedef unsigned long ULONG;            // ul

typedef UCHAR *PSZ;                     // psz
typedef VOID *PVOID;                    // p
typedef PVOID *PPVOID;                  // pp

/*XLATOFF*/

#if (_MSC_VER >= 900)

#if (!defined(MIDL_PASS) || defined(__midl))
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else
typedef double LONGLONG;
typedef double ULONGLONG;
#endif

typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;

// Update Sequence Number

typedef LONGLONG USN;

#if defined(MIDL_PASS)
struct _LARGE_INTEGER {
#else // MIDL_PASS
union _LARGE_INTEGER {
    struct _LARGE_INTERGER1 {
        ULONG LowPart;
        LONG HighPart;
    };
    struct _LARGE_INTERGER2 {
        ULONG LowPart;
        LONG HighPart;
    } u;
#endif //MIDL_PASS
    LONGLONG QuadPart;
};

#if defined(MIDL_PASS)
typedef struct _LARGE_INTEGER LARGE_INTEGER;
#else
typedef union _LARGE_INTEGER LARGE_INTEGER;
#endif

typedef LARGE_INTEGER *PLARGE_INTEGER;

#if defined(MIDL_PASS)
struct _ULARGE_INTEGER {
#else // MIDL_PASS
union _ULARGE_INTEGER {
    struct _LARGE_INTERGER3 {
        ULONG LowPart;
        ULONG HighPart;
    };
    struct _LARGE_INTERGER4 {
        ULONG LowPart;
        ULONG HighPart;
    } u;
#endif //MIDL_PASS
    ULONGLONG QuadPart;
};

#if defined(MIDL_PASS)
typedef struct _ULARGE_INTEGER ULARGE_INTEGER;
#else
typedef union _ULARGE_INTEGER ULARGE_INTEGER;
#endif

typedef ULARGE_INTEGER *PULARGE_INTEGER;

#else	// of MSC_VER > 900

#ifndef _H2INC

typedef struct _LARGE_INTEGER {
    ULONG LowPart;
    LONG HighPart;
} LARGE_INTEGER, *PLARGE_INTEGER;

typedef struct _ULARGE_INTEGER {
	ULONG LowPart;
	ULONG HighPart;
} ULARGE_INTEGER;

#endif 

#endif 

/*XLATON*/

#else

typedef PVOID *PPVOID;                  // pp

#endif 

typedef INT *PINT;                      // pi
typedef UINT *PUINT;                    // pu
typedef BYTE *PBYTE;                    // pb
typedef WORD *PWORD;                    // pw
typedef DWORD *PDWORD;                  // pdw
typedef CHAR *PCHAR;                    // pch
typedef SHORT *PSHORT;                  // ps
typedef LONG *PLONG;                    // pl
typedef UCHAR *PUCHAR;                  // puch
typedef USHORT *PUSHORT;                // pus
typedef ULONG *PULONG;                  // pul
typedef BOOL *PBOOL;                    // pf

typedef UCHAR SZ[];                     // sz
typedef UCHAR SZZ[];                    // szz
typedef UCHAR *PSZZ;                    // pszz

typedef USHORT SEL;                     // sel
typedef SEL *PSEL;                      // psel

typedef ULONG PPHYS;                    // pphys

typedef (*PFN)();                       // pfn
typedef PFN *PPFN;                      // ppfn

typedef PVOID HANDLE;                   // h
typedef HANDLE *PHANDLE;                // ph

typedef ULONG HTIMEOUT;			// timeout handle
typedef ULONG CMS;			// count of milliseconds

#ifndef NOMINMAX

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#endif  // NOMINMAX

#define MAKEWORD(a, b)      ((WORD)(((BYTE)(a)) | ((WORD)((BYTE)(b))) << 8))
#define MAKELONG(a, b)      ((LONG)(((WORD)(a)) | ((DWORD)((WORD)(b))) << 16))
#define LOWORD(l)           ((WORD)(l))
#define HIWORD(l)           ((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define LOBYTE(w)           ((BYTE)(w))
#define HIBYTE(w)           ((BYTE)(((WORD)(w) >> 8) & 0xFF))

#endif // NOBASEDEFS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\user\newsl.inc ===
;-----------------------------------------------------------------------;
; Thunk direction
;-----------------------------------------------------------------------;
dir equ <SL>

;-----------------------------------------------------------------------;
; Define the order of message thunk classes
;-----------------------------------------------------------------------;
;ClassList       equ     <WM,DM>
ClassList       equ     <WM>

;***********************************************************************;
; Thunk pre- and post-processing macros.  These perform any necessary
; setup prior to calling the thunking subroutines.
;***********************************************************************;
;-----------------------------------------------------------------------;
; MsgStructThkPreProc
;
; flags
;       Indicates api-specific flags to set in s16_fw.
;
; noprethunk
;       If non-blank, indicates that the message structure is uninitialized
;       and should not be thunked before calling the API.
;
; no_load_pmsg
;       Indicates that es:di already contains pmsg, so don't reload it.
;
; Requirements:
;       bp_pMsg be defined
;       si_space be defined
;       si_msg32 be defined
;
; Results:
;       SP  =  original SP - size THKSPACE16 - size MSGSTRUCT32
;              - extra space allocated by thunk, if any
; History:
;  08-07-91 BobGru
; Wrote it.
;-----------------------------------------------------------------------;
MsgStructThkPreProc     macro   flags:=<0>

    AssertUserDS

;;Allocate local variable space
    sub     sp,size THKSPACE16 + MSGSTRUCT32_SIZE
    InitLocalSpace  flags
    
    les     di,bp_pMsg

;;Pack the non-thunked message structure elements into the msg16 structure.
    mov     eax, dword ptr es:[di].ms16_time
    mov     dword ptr si_msg32.ms32_time, eax

    movsx   eax, word ptr es:[di].ms16_pt.pt16_x
    mov     dword ptr si_msg32.ms32_pt.pt32_x, eax

    movsx   eax, word ptr es:[di].ms16_pt.pt16_y
    mov     dword ptr si_msg32.ms32_pt.pt32_y, eax

;;Thunk the message parameters.
    push    word ptr es:[di].ms16_hwnd
    push    word ptr es:[di].ms16_message
    push    word ptr es:[di].ms16_wParamHi
    push    word ptr es:[di].ms16_wParamLo
    push   dword ptr es:[di].ms16_lParam
    call    ThkMsgSL

;;Pack the thunked parameters into the msg32 structure.
    xor     eax, eax

    mov     ax, word ptr si_space.s16_hwnd
    mov     dword ptr si_msg32.ms32_hwnd, eax

    mov     ax, word ptr si_space.s16_message
    mov     dword ptr si_msg32.ms32_message, eax

    mov     eax, dword ptr si_space.s16_wParam
    mov     dword ptr si_msg32.ms32_wParam, eax

    mov     eax, dword ptr si_space.s16_lParam
    mov     dword ptr si_msg32.ms32_lParam, eax
endm

;-----------------------------------------------------------------------;
; MsgStructThkPostProc
;
; checknull
;       If non-blank, indicates that if the return code is zero, the
;       message structure should not be unthunked, since it is uninitialized.
; noprethunk
;       If non-blank, indicates that the lParam field of the thunk space
;       should not be initialized from the value passed in, since there
;       was no value passed in.
;
; Requirements:
;       bp_pMsg  be defined
;       si_space be defined
;       si_msg32 be defined
;       si_cleanup be defined
;
; Results:
;-----------------------------------------------------------------------;
MsgStructThkPostProc    macro 

    AssertUserDS

    ; Save return from 32-bits
    mov     dword ptr si_space.s16_lResult, eax

    push     word ptr si_msg32.ms32_hwnd
    push     word ptr si_msg32.ms32_message
    push    dword ptr si_msg32.ms32_wParam
    push    dword ptr si_msg32.ms32_lParam

    call    ThkMsgLS

;;Copy the 32-bit message parameters from si_space back into the
;;MSGSTRUCT32 structure.

    les     di,bp_pMsg
    cld

    mov     ax,word ptr si_space.s16_hwnd
    stosw   es:[di]
    .errnz  ms16_hwnd

    mov     ax,word ptr si_space.s16_message
    stosw   es:[di]
    .errnz  ms16_message - ms16_hwnd - 2

    mov     ax,word ptr si_space.s16_wParam.lo
    stosw   es:[di]
    .errnz  ms16_wParamLo - ms16_message - 2

    mov     eax,si_space.s16_lParam
    stosd   es:[di]
    .errnz  ms16_lParam - ms16_wParamLo - 2

    mov     eax,si_msg32.ms32_time
    stosd   es:[di]
    .errnz  ms16_time - ms16_lParam - 4

    mov     ax,word ptr (si_msg32.ms32_pt.pt32_y)
    ror     eax,16
    mov     ax,word ptr (si_msg32.ms32_pt.pt32_x)
    stosd   es:[di]
    .errnz  ms16_pt - ms16_time - 4
    .errnz  pt16_x
    .errnz  pt16_y - pt16_x - 2
    .errnz  POINT16_SIZE - pt16_y - 2

    mov     ax,word ptr si_space.s16_wParam.hi
    stosw   es:[di]
    .errnz  ms16_wParamHi - ms16_pt - 4
    .errnz  MSGSTRUCT16_SIZE - ms16_wParamHi - 2

    ; Restore return to 16-bits DX:AX
    mov     ax, word ptr si_space.s16_lResult
    mov     dx, word ptr si_space.s16_lResult+2

    lea     sp,si_cleanup
endm


;-----------------------------------------------------------------------;
; CwpStructThkPreProc
;
; flags
;       Indicates api-specific flags to set in s16_fw.
;
; noprethunk
;       If non-blank, indicates that the message structure is uninitialized
;       and should not be thunked before calling the API.
;
; Requirements:
;       bp_pCwp be defined
;       si_space be defined
;       si_cwp32 be defined
;
; Results:
;       SP  =  original SP - size THKSPACE16 - size CWPSTRUCT32
;              - extra space allocated by thunk, if any
; History:
;  08-07-91 BobGru
; Wrote it.
;-----------------------------------------------------------------------;
CwpStructThkPreProc     macro   flags:=<0>

    AssertUserDS

;;Allocate local variable space
    sub     sp,size THKSPACE16 + CWPSTRUCT32_SIZE
    InitLocalSpace  flags

    ;Need pCwp32. User16 has wParamHi in nice place.
    les     di,bp_pCwp
    sub     di,2

;;Thunk the message parameters.
    push     word ptr es:[di].cwp16_hwnd
    push     word ptr es:[di].cwp16_message
    push     word ptr es:[di].cwp16_wParamHi
    push     word ptr es:[di].cwp16_wParamLo
    push    dword ptr es:[di].cwp16_lParam
    call    ThkMsgSL

;;Pack the thunked parameters into the cwp32 structure.
    xor     eax, eax

    mov     ax, word ptr si_space.s16_hwnd
    mov     dword ptr si_cwp32.cwp32_hwnd, eax

    mov     ax, word ptr si_space.s16_message
    mov     dword ptr si_cwp32.cwp32_message, eax

    mov     eax, dword ptr si_space.s16_wParam
    mov     dword ptr si_cwp32.cwp32_wParam, eax

    mov     eax, dword ptr si_space.s16_lParam
    mov     dword ptr si_cwp32.cwp32_lParam, eax
endm

;-----------------------------------------------------------------------;
; CwpStructThkPostProc
;
; checknull
;       If non-blank, indicates that if the return code is zero, the
;       message structure should not be unthunked, since it is uninitialized.
; noprethunk
;       If non-blank, indicates that the lParam field of the thunk space
;       should not be initialized from the value passed in, since there
;       was no value passed in.
;
; Requirements:
;       bp_pCwp  be defined
;       si_space be defined
;       si_cwp32 be defined
;       si_cleanup be defined
;
; Results:
;-----------------------------------------------------------------------;
CwpStructThkPostProc    macro

    AssertUserDS

    ; Save hook return result
    mov     dword ptr si_space.s16_lResult, eax

    push     word ptr si_cwp32.cwp32_hwnd
    push     word ptr si_cwp32.cwp32_message
    push    dword ptr si_cwp32.cwp32_wParam
    push    dword ptr si_cwp32.cwp32_lParam

    call    ThkMsgLS

;;Copy the 32-bit message parameters from si_space back into the
;;CWPSTRUCT32 structure.

    ;HACK
    ;wParamHi is nice location because of User16.
    les     di,bp_pCwp
    sub     di, 2
    cld

    ; HACK:  lpCwp is really lpCwp32 if you subtract 2 from offset.
    mov     ax, word ptr si_space.s16_wParam.hi
    stosw   es:[di]
    .errnz  cwp16_wParamHi

    mov     eax,si_space.s16_lParam
    stosd   es:[di]
    .errnz  cwp16_lParam - cwp16_wParamHi - 2

    mov     ax,word ptr si_space.s16_wParam.lo
    stosw   es:[di]
    .errnz  cwp16_wParamLo - cwp16_lParam - 4

    mov     ax,word ptr si_space.s16_message
    stosw   es:[di]
    .errnz  cwp16_message - cwp16_wParamLo - 2

    mov     ax, word ptr si_space.s16_hwnd
    stosw   es:[di]
    .errnz  cwp16_hwnd - cwp16_message - 2
    .errnz  CWPSTRUCT16_SIZE - cwp16_hwnd - 2

    ; Restore return code to 16bits DX:AX
    mov     ax, word ptr si_space.s16_lResult
    mov     dx, word ptr si_space.s16_lResult+2

    lea     sp,si_cleanup
endm


;-----------------------------------------------------------------------;
; CwpRetStructThkPreProc
;
; flags
;       Indicates api-specific flags to set in s16_fw.
;
; noprethunk
;       If non-blank, indicates that the message structure is uninitialized
;       and should not be thunked before calling the API.
;
; Requirements:
;       bp_pCwpRet be defined
;       si_space be defined
;       si_cwpret32 be defined
;
; Results:
;       SP  =  original SP - size THKSPACE16 - size CWPRETSTRUCT32
;              - extra space allocated by thunk, if any
;-----------------------------------------------------------------------;
CwpRetStructThkPreProc     macro
    AssertUserDS

;;Allocate local variable space
    sub     sp,size THKSPACE16 + CWPRETSTRUCT32_SIZE
    InitLocalSpace  TF_THUNKMSGRESULT

    les     di,bp_pCwpRet

    ; Thunk the message parameters
    mov     eax, dword ptr es:[di].cwpret16_lResult
    mov     dword ptr si_space.s16_lResult, eax

    push     word ptr es:[di].cwpret16_hwnd
    push     word ptr es:[di].cwpret16_message
    push     word ptr es:[di].cwpret16_wParamHi
    push     word ptr es:[di].cwpret16_wParamLo
    push    dword ptr es:[di].cwpret16_lParam
    call    ThkMsgSL

    ; Copy the thunked parms back
    mov     eax, dword ptr si_space.s16_lResult
    mov     dword ptr si_cwpret32.cwpret32_lResult, eax

    xor     eax, eax
    mov     ax, word ptr si_space.s16_hwnd
    mov     dword ptr si_cwpret32.cwpret32_hwnd, eax

    mov     ax, word ptr si_space.s16_message
    mov    dword ptr si_cwpret32.cwpret32_message, eax

    mov    eax, dword ptr si_space.s16_wParam
    mov    dword ptr si_cwpret32.cwpret32_wParam, eax

    mov    eax, dword ptr si_space.s16_lParam
    mov    dword ptr si_cwpret32.cwpret32_lParam, eax
endm

;-----------------------------------------------------------------------;
; CwpRetStructThkPostProc
;
; checknull
;       If non-blank, indicates that if the return code is zero, the
;       message structure should not be unthunked, since it is uninitialized.
; noprethunk
;       If non-blank, indicates that the lParam field of the thunk space
;       should not be initialized from the value passed in, since there
;       was no value passed in.
;
; Requirements:
;       bp_pCwpRet  be defined
;       si_space be defined
;       si_cwpret32 be defined
;       si_cleanup be defined
;
; Results:
;-----------------------------------------------------------------------;
CwpRetStructThkPostProc    macro

    AssertUserDS

ifdef DEBUG
    ; Better have TF_THUNKMSGRESULT set
    test    si_space.s16_fw, TF_THUNKMSGRESULT
    jnz     @F

    int     3
@@:
endif

    ; Save 32bit hook return code
    push    eax

    mov     eax, dword ptr si_cwpret32.cwpret32_lResult
    mov     dword ptr si_space.s16_lResult, eax

    push    dword ptr si_cwpret32.cwpret32_lResult
    push     word ptr si_cwpret32.cwpret32_hwnd
    push     word ptr si_cwpret32.cwpret32_message
    push    dword ptr si_cwpret32.cwpret32_wParam
    push    dword ptr si_cwpret32.cwpret32_lParam

    call    ThkMsgLS

;;Copy the 32-bit message parameters from si_space back into the
;;CWPSTRUCT32 structure.

    les     di,bp_pCwpRet
    cld

    ; Result
    mov     eax, dword ptr si_space.s16_lResult
    stosd   es:[di]
    .errnz  cwpret16_lResult

    mov     ax, word ptr si_space.s16_wParam.hi
    stosw   es:[di]
    .errnz  cwpret16_wParamHi - cwpret16_lResult - 4

    mov     eax, dword ptr si_space.s16_lParam
    stosd   es:[di]
    .errnz  cwpret16_lParam - cwpret16_wParamHi - 2

    mov     ax, word ptr si_space.s16_wParam.lo
    stosw   es:[di]
    .errnz  cwpret16_wParamLo - cwpret16_lParam - 4

    mov     ax, word ptr si_space.s16_message
    stosw   es:[di]
    .errnz  cwpret16_message - cwpret16_wParamLo - 2

    mov     ax,word ptr si_space.s16_hwnd
    stosw   es:[di]
    .errnz  cwpret16_hwnd - cwpret16_message - 2
    .errnz  CWPRETSTRUCT16_SIZE - cwpret16_hwnd - 2

    ;Restore 16bit hook return code
    pop     ax
    pop     dx

    lea     sp,si_cleanup
endm


;-----------------------------------------------------------------------;
; HhsStructThkPreProc
;
; flags
;       Indicates api-specific flags to set in s16_fw.
;
; noprethunk
;       If non-blank, indicates that the message structure is uninitialized
;       and should not be thunked before calling the API.
;
; Requirements:
;       bp_pHhs be defined
;       si_space be defined
;       si_hhs32 be defined
;
; Results:
;       SP  =  original SP - size THKSPACE16 - size HARDWAREHOOKSTRUCT32
;              - extra space allocated by thunk, if any
; History:
;  08-07-91 BobGru
; Wrote it.
;-----------------------------------------------------------------------;
HhsStructThkPreProc     macro   flags:=<0>

    AssertUserDS

;;Allocate local variable space
    sub     sp,size THKSPACE16 + HARDWAREHOOKSTRUCT32_SIZE
    InitLocalSpace  flags

    les     di,bp_pHhs

;;Thunk the message parameters.
    push     word ptr es:[di].hhs16_hwnd
    push     word ptr es:[di].hhs16_message
    push     word ptr es:[di].hhs16_wParamHi
    push     word ptr es:[di].hhs16_wParamLo
    push    dword ptr es:[di].hhs16_lParam
    call    ThkMsgSL

;;Pack the thunked parameters into the HARDWAREHOOK32 structure.
    xor     eax, eax
    mov     ax, word ptr si_space.s16_hwnd
    mov     dword ptr si_hhs32.hhs32_hwnd, eax

    mov     ax, word ptr si_space.s16_message
    mov     dword ptr si_hhs32.hhs32_message, eax

    mov     eax, dword ptr si_space.s16_wParam
    mov     dword ptr si_hhs32.hhs32_wParam, eax

    mov     eax, dword ptr si_space.s16_lParam
    mov     dword ptr si_hhs32.hhs32_lParam, eax
endm

;-----------------------------------------------------------------------;
; HhsStructThkPostProc
;
; checknull
;       If non-blank, indicates that if the return code is zero, the
;       message structure should not be unthunked, since it is uninitialized.
; noprethunk
;       If non-blank, indicates that the lParam field of the thunk space
;       should not be initialized from the value passed in, since there
;       was no value passed in.
;
; Requirements:
;       bp_pHhs  be defined
;       si_space be defined
;       si_hhs32 be defined
;       si_cleanup be defined
;
; Results:
;-----------------------------------------------------------------------;
HhsStructThkPostProc    macro 

    AssertUserDS

    ;Save 32bit hook return code
    mov     dword ptr si_space.s16_lResult, eax

    push     word ptr si_hhs32.hhs32_hwnd
    push     word ptr si_hhs32.hhs32_message
    push    dword ptr si_hhs32.hhs32_wParam
    push    dword ptr si_hhs32.hhs32_lParam

    call    ThkMsgLS

;;Copy the 32-bit message parameters from si_space back into the
;;HARDWAREHOOKSTRUCT32 structure.

    les     di,bp_pHhs
    cld

    mov     ax,word ptr si_space.s16_hwnd
    stosw   es:[di]
    .errnz  hhs16_hwnd

    mov     ax,word ptr si_space.s16_message
    stosw   es:[di]
    .errnz  hhs16_message - hhs16_hwnd - 2

    mov     ax,word ptr si_space.s16_wParam.lo
    stosw   es:[di]
    .errnz  hhs16_wParamLo - hhs16_message - 2

    mov     eax,si_space.s16_lParam
    stosd   es:[di]
    .errnz  hhs16_lParam - hhs16_wParamLo - 2

    mov     ax, word ptr si_space.s16_wParam.hi
    stosw   es:[di]
    .errnz  hhs16_wParamHi - hhs16_lParam - 4
    .errnz  HARDWAREHOOKSTRUCT16_SIZE - hhs16_wParamHi - 2
          
    ;Restore 16bit hook return code
    mov     ax, word ptr si_space.s16_lResult
    mov     dx, word ptr si_space.s16_lResult+2

    lea     sp,si_cleanup
endm


;-----------------------------------------------------------------------;
; CbtStructThkPreProc
;
; flags
;       Indicates api-specific flags to set in s16_fw.
;
; Requirements:
;       bp_nCode be defined
;       bp_wParamLo be defined
;       bp_wParamHi be defined
;       bp_pMsg be defined
;       si_space be defined
;       cbt_switch_stacks be defined
;       cbt_exit be defined
;-----------------------------------------------------------------------;
CbtStructThkPreProc     macro   flags:=<0>
    local cbt_hook_error
    local HookDispatch
    local MAX_CBT_CODE
    local thk_HCBT_MOVESIZE
    local thk_HCBT_MINMAX
    local thk_HCBT_QS
    local thk_HCBT_CREATEWND
    local thk_HCBT_DESTROYWND
    local thk_HCBT_ACTIVATE
    local thk_HCBT_CLICKSKIPPED
    local thk_HCBT_KEYSKIPPED
    local thk_HCBT_SYSCOMMAND
    local thk_HCBT_SETFOCUS
    local cbt_done

    AssertUserDS

    sub     sp,size THKSPACE16
    InitLocalSpace  flags

    ; Convert wParam -- same for all HCBT_ hooks
    movzx   eax, bp_wParamLo
    mov     dword ptr si_space.s16_wParam, eax

    mov     bx,bp_nCode
    cmp     bx,MAX_CBT_CODE
    ja      cbt_hook_error

    add     bx,bx
    jmp     cs:HookDispatch[bx]

HookDispatch label word
    dw      offset thk_HCBT_MOVESIZE
    dw      offset thk_HCBT_MINMAX
    dw      offset thk_HCBT_QS
    dw      offset thk_HCBT_CREATEWND
    dw      offset thk_HCBT_DESTROYWND
    dw      offset thk_HCBT_ACTIVATE
    dw      offset thk_HCBT_CLICKSKIPPED
    dw      offset thk_HCBT_KEYSKIPPED
    dw      offset thk_HCBT_SYSCOMMAND
    dw      offset thk_HCBT_SETFOCUS
MAX_CBT_CODE equ ($-HookDispatch)/2

;Error -- invalid CBT code.  Fall through to the minimal thunking.
cbt_hook_error:


thk_HCBT_DESTROYWND:
thk_HCBT_KEYSKIPPED:
thk_HCBT_MINMAX:
thk_HCBT_QS:
thk_HCBT_SETFOCUS:
thk_HCBT_SYSCOMMAND:
    mov     eax, dword ptr bp_pMsg
    mov     dword ptr si_space.s16_lParam, eax
    jmp     cbt_done

thk_HCBT_ACTIVATE:
    sub     sp,CBTACTIVATESTRUCT32_SIZE

    xchg    bx,si           ;save frame pointer
    mov     di,ss           ;init DS:ESI --> source, ES:EDI --> dest
    mov     es,di
    movzx   edi,sp          ;do before "push ds"
    push    ds
    lds     si,bp_pMsg
    movzx   esi,si
    cld

    call    cvtCBTACTIVATESTRUCTSL

    pop     ds
    xchg    bx,si           ;restore frame pointer
    or      si_space.s16_fw, TF_CLEANUP    

    ; Save SP since pushing SS will modify it!
    mov     bx,sp
    push    ss
    push    bx
    call    MapSL
    mov     dword ptr si_space.s16_lParam,eax

    jmp     cbt_done

thk_HCBT_MOVESIZE:
    sub     sp,RECT32_SIZE

    xchg    bx,si           ;save frame pointer
    mov     di,ss           ;init DS:ESI --> source, ES:EDI --> dest
    mov     es,di
    movzx   edi,sp          ;do before "push ds"
    push    ds
    lds     si,bp_pMsg
    movzx   esi,si
    cld

    call    cvtRECTSL

    pop     ds
    xchg    bx,si           ;restore frame pointer
    or      si_space.s16_fw, TF_CLEANUP    

    ; Save SP since pushing SS will modify it!
    mov     bx,sp
    push    ss
    push    bx
    call    MapSL
    mov     dword ptr si_space.s16_lParam,eax

    jmp     cbt_done

thk_HCBT_CREATEWND:
si_cbtc equ <(si_space - CBT_CREATEWND32_SIZE)>
    sub     sp,CBT_CREATEWND32_SIZE + CREATESTRUCT32_SIZE
    lea     ax,si_cbtc
    push    ss
    push    ax
    call    MapSL
    mov     dword ptr si_space.s16_lParam,eax

    les     di,bp_pMsg
    movzx   eax, word ptr es:[di].cbtc16_hwndInsertAfter
    mov     dword ptr si_cbtc.cbtc32_hwndInsertAfter, eax

    xchg    bx,si           ;save frame pointer
    mov     di,ss           ;init DS:ESI --> source, ES:EDI --> dest
    mov     es,di
    movzx   edi,sp          ;do before "push ds"

    push    ds
    lds     si,bp_pMsg      ;This sets up LPCBT in ds:si
    lds     si,ds:[si].cbtc16_lpcs ;This sets up LPCREATESTRUCT (1st field of cbtc16) in ds:si
    movzx   esi,si
    sub     si,2
    cld

    call    cvtCREATESTRUCTSL

    pop     ds

    ; Restore frame pointer
    xchg    bx,si          
    or      word ptr si_space.s16_fw, TF_CLEANUP

    ; Save SP since pushing SS will modify it!
    mov     bx,sp
    push    ss
    push    bx
    call    MapSL
    mov     dword ptr si_cbtc.cbtc32_lpcs,eax

    ;Safety check that we haven't forgotten any fields of the structure.
    .errnz  cbtc32_lpcs
    .errnz  cbtc32_hwndInsertAfter - cbtc32_lpcs - 4
    .errnz  CBT_CREATEWND32_SIZE - cbtc32_hwndInsertAfter - 4

    jmp     cbt_done

thk_HCBT_CLICKSKIPPED:
    sub     sp,MOUSEHOOKSTRUCT32_SIZE

    xchg    bx,si           ;save frame pointer
    mov     di,ss           ;init DS:ESI --> source, ES:EDI --> dest
    mov     es,di
    movzx   edi,sp          ;do before "push ds"
    push    ds
    lds     si,bp_pMsg
    movzx   esi,si
    cld

    call    cvtMOUSEHOOKSTRUCTSL

    pop     ds
    xchg    bx,si           ;restore frame pointer
    or      si_space.s16_fw, TF_CLEANUP    

    ; Save SP since pushing SS will modify it!
    mov     bx,sp
    push    ss
    push    bx
    call    MapSL
    mov     dword ptr si_space.s16_lParam,eax

cbt_done:
endm



;----------------------------------------------------------------------------
;
;   CbtStructThkPostProc
;
;   We need to cleanup after making 32-bit call.  Any HCBT_ codes with
;   LP to structures in lParam require cleanup.  This structure must be
;   We need to cleanup after HCBT_CREATEWND, converting back the CREATESTRUCT
;
;----------------------------------------------------------------------------
CbtStructThkPostProc macro
    local   cbt_hook_error
    local   cbt_done
    local   HookDispatch
    local   MAX_CBT_CODE
    local   thk_HCBT_MOVESIZE
    local   thk_HCBT_MINMAX
    local   thk_HCBT_QS
    local   thk_HCBT_CREATEWND
    local   thk_HCBT_DESTROYWND
    local   thk_HCBT_ACTIVATE
    local   thk_HCBT_CLICKSKIPPED
    local   thk_HCBT_KEYSKIPPED
    local   thk_HCBT_SYSCOMMAND
    local   thk_HCBT_SETFOCUS

    AssertUserDS

    ; Save 32bit return code
    mov     si_space.s16_lResult, eax

    mov     bx, bp_nCode
    cmp     bx, MAX_CBT_CODE
    ja      cbt_hook_error

    add     bx, bx
    jmp     cs:HookDispatch[bx]

HookDispatch label word
    dw      offset thk_HCBT_MOVESIZE
    dw      offset thk_HCBT_MINMAX
    dw      offset thk_HCBT_QS
    dw      offset thk_HCBT_CREATEWND
    dw      offset thk_HCBT_DESTROYWND
    dw      offset thk_HCBT_ACTIVATE
    dw      offset thk_HCBT_CLICKSKIPPED
    dw      offset thk_HCBT_KEYSKIPPED
    dw      offset thk_HCBT_SYSCOMMAND
    dw      offset thk_HCBT_SETFOCUS
MAX_CBT_CODE equ ($-HookDispatch)/2

thk_HCBT_CREATEWND:
si_cbtc equ <(si_space-CBT_CREATEWND32_SIZE)>
    ; lParam is LPCBT_CREATEWND, which contains an embedded LPCREATESTRUCT
    push    ds
    push    esi
    push    edi

    ; 16-bit LPCBT_CREATEWND
    les     di, bp_pMsg

    ; 32-bit LPCBT_CREATEWND.  Save frame pointer in BX!
    mov     bx, si
    mov     ds, FlatData
    mov     esi, dword ptr si_space.s16_lParam

    ; Copy back the HWND
    mov     ax, word ptr ds:[esi].cbtc32_hwndInsertAfter
    mov     es:[di].cbtc16_hwndInsertAfter, ax

    ; Cleanup the CREATESTRUCT

    ; 16-bit LPCREATESTRUCT
    les     di, es:[di].cbtc16_lpcs
    sub     di, 2
    movzx   edi, di

    ; 32-bit LPCREATESTRUCT
    mov     esi, dword ptr ds:[esi].cbtc32_lpcs

    cld
    call    cvtCREATESTRUCTLS

    pop     edi
    pop     esi
    pop     ds
    jmp     cbt_done

thk_HCBT_ACTIVATE:
    ; lParam is LPCBTACTIVATESTRUCT
    push    ds
    push    esi
    push    edi

    ; 16-bit LPCBTACTIVATESTRUCT
    les     di, bp_pMsg
    movzx   edi, di

    ; 32-bit LPCBTACTIVATESTRUCT
    mov     bx, si
    mov     ds, FlatData
    mov     esi, dword ptr si_space.s16_lParam

    cld
    call    cvtCBTACTIVATESTRUCTLS

    pop     edi
    pop     esi
    pop     ds
    jmp     cbt_done

thk_HCBT_MOVESIZE:
    ; lParam is LPRECT
    push    ds
    push    esi
    push    edi

    ; 16-bit LPRECT
    les     di, bp_pMsg
    movzx   edi, di

    ; 32-bit LPRECT
    mov     bx, si
    mov     ds, FlatData
    mov     esi, dword ptr si_space.s16_lParam

    cld
    call    cvtRECTLS

    pop     edi
    pop     esi
    pop     ds
    jmp     cbt_done

thk_HCBT_CLICKSKIPPED:
    ; lParam is LPMOUSEHOOKSTRUCT
    push    ds
    push    esi
    push    edi

    ; 16-bit LPMOUSEHOOKSTRUCT
    les     di, bp_pMsg
    movzx   edi, di

    ; 32-bit LPMOUSEHOOKSTRUCT
    mov     bx, si
    mov     ds, FlatData
    mov     esi, dword ptr si_space.s16_lParam

    cld
    call    cvtMOUSEHOOKSTRUCTLS

    pop     edi
    pop     esi
    pop     ds
    jmp     cbt_done

cbt_hook_error:
    ; Error -- invalid CBT code.
    ; FALL THRU

thk_HCBT_DESTROYWND:
thk_HCBT_KEYSKIPPED:
thk_HCBT_MINMAX:
thk_HCBT_QS:
thk_HCBT_SETFOCUS:
thk_HCBT_SYSCOMMAND:
    ; No cleanup required

cbt_done:
    ; Restore 16bit return code
    mov     ax, word ptr si_space.s16_lResult.lo
    mov     dx, word ptr si_space.s16_lResult.hi

    lea     sp, si_cleanup
endm


;-----------------------------------------------------------------------;
; MhsStructThkPreProc
;
; Requirements:
;       bp_pMhs be defined
;
; Results:
;       SP  =  original SP - size MOUSEHOOKSTRUCT32
; History:
;  04-10-92 BobGru
; Wrote it.
;-----------------------------------------------------------------------;
MhsStructThkPreProc     macro

    AssertUserDS

    sub     sp,MOUSEHOOKSTRUCT32_SIZE

    xchg    bx,si           ;save frame pointer
    mov     di,ss           ;init DS:ESI --> source, ES:EDI --> dest
    mov     es,di
    movzx   edi,sp          ;do before any pushes

    push    ds

    lds     si,bp_pMhs
    movzx   esi,si
    cld

    call    cvtMOUSEHOOKSTRUCTSL

    pop     ds

    xchg    bx,si           ;restore frame pointer
endm

;-----------------------------------------------------------------------;
; MhsStructThkPostProc
;
; Requirements:
;       bp_pMhs be defined
;
; Results:
;
; History:
;  04-10-92 BobGru
; Wrote it.
;-----------------------------------------------------------------------;
MhsStructThkPostProc     macro

    AssertUserDS

    xchg    bx,si           ;save frame pointer
    movzx   esi,sp          ;do before any pushes

    ;Save return code and DS
    push    eax      
    push    ds

    mov     di,ss           ;init DS:ESI --> source, ES:EDI --> dest
    mov     ds,di

    les     di,bp_pMhs
    movzx   edi,di
    cld

    call    cvtMOUSEHOOKSTRUCTLS

    ;Restore return code and DS
    pop     ds
    pop     eax

    xchg    si, bx
    lea     sp,si_cleanup
endm



;-----------------------------------------------------------------------;
; JhsStructThkPreProc
;
; Requirements:
;       bp_pJhs be defined
;       si_type ""
;       DX must be 0 or 1; 0 for JOURNALRECORD, 1 for JOURNALPLAYBACK
;
; Results:
;       SP  =  original SP - size EVENTMSG32
;-----------------------------------------------------------------------;
JhsStructThkPreProc     macro
    AssertUserDS

    ; Leave space for si_type and si_Jhs32
    push    dx
    sub     sp, EVENTMSG32_SIZE

    xchg    bx,si           ;save frame pointer
    mov     di,ss           ;init DS:ESI --> source, ES:EDI --> dest
    mov     es,di
    movzx   edi,sp          ;do before any pushes

    push    ds

    mov     ds,word ptr bp_pJhs+2
    mov     si,ds
    or      si,si
    jz      @F
    movzx   esi,word ptr bp_pJhs
    cld

    call    cvtEVENTMSGSL
@@:    
    pop     ds

    xchg    bx,si           ;restore frame pointer
endm


;-----------------------------------------------------------------------;
; JhsStructThkPostProc
;
; Requirements:
;       bp_pJhs be defined
;       si_type ""
;       DX must be 0 or 1; 0 for JOURNALRECORD, 1 for JOURNALPLAYBACK
;
; Results:
;
;-----------------------------------------------------------------------;
JhsStructThkPostProc     macro

    AssertUserDS

    ; DO THIS FIRST BEFORE SI IS TRASHED
    mov     dx, word ptr si_type

    xchg    bx,si           ;save frame pointer
    movzx   esi,sp          ;do before any pushes

    ;Save return code and DS
    push    eax
    push    ds

    mov     di,ss           ;init DS:ESI --> source, ES:EDI --> dest
    mov     ds,di
    mov     es,word ptr bp_pJhs+2
    mov     di,es
    or      di,di
    jz      @F

    mov     di,word ptr bp_pJhs
    movzx   edi,di

    cld
    call    cvtEVENTMSGLS
@@:    

    ;Restore return code and DS
    pop     ds
    pop     ax
    pop     dx

    xchg    bx,si           ;restore frame pointer
    lea     sp,si_cleanup
endm



;----------------------------------------------------------------------------
;
;   DhsStructThkPreProc
;   Thunks S->L for WH_DEBUG
; 
;----------------------------------------------------------------------------
DhsStructThkPreProc     macro

    AssertUserDS

    sub     sp, DEBUGHOOK32_SIZE
    xchg    bx, si
    mov     di, ss
    mov     es, di
    movzx   edi, sp

    push    ds
    lds     si, bp_pDhs
    movzx   esi, si
    cld

    ; EXPECTS hTask in AX
    ; RETURNS whType in AX
    mov     ax, word ptr bp_wParam
    call    cvtDEBUGHOOKSL
    mov     word ptr bp_wParam, ax

    pop     ds
    xchg    bx, si
endm


;----------------------------------------------------------------------------
;
;   DhsStructThkPostProc()
;   Cleans up L->S for WH_DEBUG
;
;----------------------------------------------------------------------------
DhsStructThkPostProc    macro

    AssertUserDS

    xchg    bx, si
    movzx   esi, sp

    ; Save return code and DS AFTER setting up ESI with SP
    push    eax
    push    ds

    mov     di, ss
    mov     ds, di

    les     di, bp_pDhs
    movzx   edi, di
    cld

    ; EXPECTS whType in AX
    ; RETURNS hTask in AX (don't need it)
    mov     ax, word ptr bp_wParam
    call    cvtDEBUGHOOKLS

    ; Restore DS and return code
    pop     ds
    pop     eax

    xchg    si, bx
    lea     sp, si_cleanup
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\thunk\user\newls.inc ===
;----------------------------------------------------------------------------
; Thunk direction
;----------------------------------------------------------------------------
dir equ <LS>

;----------------------------------------------------------------------------
; Define the order of message thunk classes
;----------------------------------------------------------------------------
;The DM thunk class doesn't require any special thunks.
;ClassList       equ     <WM,DM>
ClassList       equ     <WM>

;***********************************************************************;
; Thunk pre- and post-processing macros.  These perform any necessary
; setup prior to calling the thunking subroutines.
;***********************************************************************;
;----------------------------------------------------------------------------
; MsgStructThkPreProc
;
; flags
;       Indicates api-specific flags to set in s16_fw.
;
; noprethunk
;       If non-blank, indicates that the message structure is uninitialized
;       and should not be thunked before calling the API.
;
; no_load_pmsg
;       Indicates that es:edi already contains pmsg, so don't reload it.
;
; Requirements:
;       bp_pMsg be defined
;       si_space be defined
;       si_msg16 be defined
;
; Results:
;       SP  =  original SP - size THKSPACE16 - size MSGSTRUCT16
;              - extra space allocated by thunk, if any
; History:
;  08-07-91 BobGru
; Wrote it.
;----------------------------------------------------------------------------
MsgStructThkPreProc     macro   flags:=<0>, no_load_pmsg, base:=<si>

    AssertUserDS

;;Allocate local variable space
    sub     sp,size THKSPACE16 + MSGSTRUCT16_SIZE
    InitLocalSpace  flags, base

    ifb <no_load_pmsg>
        mov     es,  FlatData
        mov     edi, bp_pMsg
    endif

;;Pack the non-thunked message structure elements into the msg16 structure.
    mov     eax, dword ptr es:[edi].ms32_time
    mov     dword ptr base&_msg16.ms16_time, eax

    mov     ax, word ptr es:[edi].ms32_pt.pt32_x
    mov     word ptr base&_msg16.ms16_pt.pt16_x, ax

    mov     ax, word ptr es:[edi].ms32_pt.pt32_y
    mov     word ptr base&_msg16.ms16_pt.pt16_y, ax

;;Thunk the message parameters.
    push     word ptr es:[edi].ms32_hwnd
    push     word ptr es:[edi].ms32_message
    push    dword ptr es:[edi].ms32_wParam
    push    dword ptr es:[edi].ms32_lParam
    call    ThkMsgLS

;;Pack the thunked parameters into the msg16 structure.
    mov     ax, word ptr base&_space.s16_hwnd
    mov     word ptr base&_msg16.ms16_hwnd, ax

    mov     ax, word ptr base&_space.s16_message
    mov     word ptr base&_msg16.ms16_message, ax

    mov     ax, word ptr base&_space.s16_wParam.lo
    mov     word ptr base&_msg16.ms16_wParamLo, ax

    mov     eax, dword ptr base&_space.s16_lParam
    mov     dword ptr base&_msg16.ms16_lParam, eax

    mov     ax, word ptr base&_space.s16_wParam.hi
    mov     word ptr base&_msg16.ms16_wParamHi, ax
endm

;----------------------------------------------------------------------------
; MsgStructThkPostProc
;
; no_copyout_pmsg
;       If non-blank, don't unthunk the message structure since it's an
;       input-only parameter.
;
; Requirements:
;       bp_pMsg  be defined
;       si_space be defined
;       si_msg16 be defined
;       si_cleanup be defined
;
; Results:
;----------------------------------------------------------------------------
MsgStructThkPostProc    macro  base:=<si>, no_copyout_pmsg

    AssertUserDS

    ; Save return code.  We're not thunking it, but we want to save it.
    mov     dword ptr base&_space.s16_lResult, eax

    push     word ptr base&_msg16.ms16_hwnd
    push     word ptr base&_msg16.ms16_message
    push     word ptr base&_msg16.ms16_wParamHi
    push     word ptr base&_msg16.ms16_wParamLo
    push    dword ptr base&_msg16.ms16_lParam

    call    ThkMsgSL                ;;destroys EDI

    ifb <no_copyout_pmsg>
        ;;Copy the 32-bit message parameters from si_space back into the
        ;;msgstruct32 structure.

        mov     es, FlatData
        mov     edi,bp_pMsg
        cld

        xor     eax, eax
        mov     ax, word ptr base&_space.s16_hwnd
        stosd   es:[edi]
        .errnz  ms32_hwnd

        mov     ax, word ptr base&_space.s16_message
        stosd   es:[edi]
        .errnz  ms32_message - ms32_hwnd - 4

        mov     eax, dword ptr base&_space.s16_wParam
        stosd   es:[edi]
        .errnz  ms32_wParam - ms32_message - 4

        mov     eax, dword ptr base&_space.s16_lParam
        stosd   es:[edi]
        .errnz  ms32_lParam - ms32_wParam - 4

        mov     eax, base&_msg16.ms16_time
        stosd   es:[edi]
        .errnz  ms32_time - ms32_lParam - 4

        movsx   eax,word ptr (base&_msg16.ms16_pt.pt16_x)
        stosd   es:[edi]
        .errnz  ms32_pt - ms32_time - 4
        .errnz  MSGSTRUCT32_SIZE - ms32_pt - 8
        .errnz  pt32_x

        movsx   eax,word ptr (base&_msg16.ms16_pt.pt16_y)
        stosd   es:[edi]
        .errnz  pt32_y - pt32_x - 4
        .errnz  POINT32_SIZE - pt32_y - 4

    endif

    ; Put return value back
    mov     eax, dword ptr base&_space.s16_lResult

    % ifidni <base>,<si>
        lea     sp,si_cleanup
    endif
endm


;----------------------------------------------------------------------------
; CwpStructThkPreProc
;
; flags
;       Indicates api-specific flags to set in s16_fw.
;
; noprethunk
;       If non-blank, indicates that the message structure is uninitialized
;       and should not be thunked before calling the API.
;
; Requirements:
;       bp_pCwp be defined
;       si_space be defined
;       si_cwp16 be defined
;
; Results:
;       SP  =  original SP - size THKSPACE16 - size CWPSTRUCT16
;              - extra space allocated by thunk, if any
; History:
;  08-07-91 BobGru
; Wrote it.
;----------------------------------------------------------------------------
CwpStructThkPreProc     macro   flags:=<0>

    AssertUserDS

;;Allocate local variable space
    sub     sp,size THKSPACE16 + CWPSTRUCT16_SIZE
    InitLocalSpace  flags

    mov     es,FlatData
    mov     edi,bp_pCwp

;;Thunk the message parameters.
    push     word ptr es:[edi].cwp32_hwnd
    push     word ptr es:[edi].cwp32_message
    push    dword ptr es:[edi].cwp32_wParam
    push    dword ptr es:[edi].cwp32_lParam
    call    ThkMsgLS

;;Pack the thunked parameters into the cwp16 structure.
    mov     ax, word ptr si_space.s16_hwnd
    mov     word ptr si_cwp16.cwp16_hwnd, ax

    mov     ax, word ptr si_space.s16_message
    mov     word ptr si_cwp16.cwp16_message, ax

    mov     ax, word ptr si_space.s16_wParam.hi
    mov     word ptr si_cwp16.cwp16_wParamHi, ax

    mov     ax, word ptr si_space.s16_wParam.lo
    mov     word ptr si_cwp16.cwp16_wParamLo, ax

    mov     eax, dword ptr si_space.s16_lParam
    mov     dword ptr si_cwp16.cwp16_lParam, eax
endm


;----------------------------------------------------------------------------
; CwpStructThkPostProc
;
; retsize
;       Either AX or DXAX, determines the size of the return code.
; checknull
;       If non-blank, indicates that if the return code is zero, the
;       message structure should not be unthunked, since it is uninitialized.
; noprethunk
;       If non-blank, indicates that the lParam field of the thunk space
;       should not be initialized from the value passed in, since there
;       was no value passed in.
;
; Requirements:
;       bp_pCwp  be defined
;       si_space be defined
;       si_cwp16 be defined
;       si_cleanup be defined
;
; Results:
;----------------------------------------------------------------------------
CwpStructThkPostProc    macro
    AssertUserDS

    ; Save hook return result.  Since we are NOT setting TF_THUNKMSGRESULT,
    ; lResult shouldn't be touched.  We can use it as a temp buffer.
    mov      word ptr si_space.s16_lResult, ax
    mov      word ptr si_space.s16_lResult+2, dx   

    push     word ptr si_cwp16.cwp16_hwnd
    push     word ptr si_cwp16.cwp16_message
    push     word ptr si_cwp16.cwp16_wParamHi
    push     word ptr si_cwp16.cwp16_wParamLo
    push    dword ptr si_cwp16.cwp16_lParam

    call    ThkMsgSL                ;;destroys EDI

;;Copy the 32-bit message parameters from si_space back into the
;;CWPSTRUCT32 structure.

    mov     es, FlatData
    mov     edi, bp_pCwp
    cld

    mov     eax, si_space.s16_lParam
    stosd   es:[edi]
    .errnz  cwp32_lParam

    mov     eax,si_space.s16_wParam
    stosd   es:[edi]
    .errnz  cwp32_wParam - cwp32_lParam - 4

    xor     eax, eax

    mov     ax, word ptr si_space.s16_message
    stosd   es:[edi]
    .errnz  cwp32_message - cwp32_wParam - 4

    mov     ax, word ptr si_space.s16_hwnd
    stosd   es:[edi]
    .errnz  cwp32_hwnd - cwp32_message - 4
    .errnz  CWPSTRUCT32_SIZE - cwp32_hwnd - 4

    ; Restore hook return code to EAX
    mov     eax, dword ptr si_space.s16_lResult
    lea     sp,si_cleanup
endm


;----------------------------------------------------------------------------
; CwpRetStructThkPreProc
;
; flags
;       Indicates api-specific flags to set in s16_fw.
;
; noprethunk
;       If non-blank, indicates that the message structure is uninitialized
;       and should not be thunked before calling the API.
;
; Requirements:
;       bp_pCwpRet be defined
;       si_space be defined
;       si_cwpret16 be defined
;
; Results:
;       SP  =  original SP - size THKSPACE16 - size CWPRETSTRUCT16
;              - extra space allocated by thunk, if any
; History:
;  08-07-91 BobGru
; Wrote it.
;----------------------------------------------------------------------------
CwpRetStructThkPreProc     macro
    AssertUserDS

;;Allocate local variable space
    sub     sp,size THKSPACE16 + CWPRETSTRUCT16_SIZE
    InitLocalSpace  TF_THUNKMSGRESULT

    mov     es, FlatData
    mov     edi,bp_pCwpRet

    ;Thunk the message parameters.
    mov     eax, dword ptr es:[edi].cwpret32_lResult
    mov     dword ptr si_space.s16_lResult, eax

    push     word ptr es:[edi].cwpret32_hwnd
    push     word ptr es:[edi].cwpret32_message
    push    dword ptr es:[edi].cwpret32_wParam
    push    dword ptr es:[edi].cwpret32_lParam
    call    ThkMsgLS

    ; Copy the thunked parms back
    mov     eax, dword ptr si_space.s16_lResult
    mov     dword ptr si_cwpret16.cwpret16_lResult, eax

    mov     ax, word ptr si_space.s16_wParam.hi
    mov     word ptr si_cwpret16.cwpret16_wParamHi, ax

    mov     eax, dword ptr si_space.s16_lParam
    mov     dword ptr si_cwpret16.cwpret16_lParam, eax

    mov     ax, word ptr si_space.s16_wParam.lo
    mov     word ptr si_cwpret16.cwpret16_wParamLo, ax

    mov     ax, word ptr si_space.s16_message
    mov     word ptr si_cwpret16.cwpret16_message, ax

    mov     ax, word ptr si_space.s16_hwnd
    mov     word ptr si_cwpret16.cwpret16_hwnd, ax
endm


;----------------------------------------------------------------------------
; CwpRetStructThkPostProc
;
; retsize
;       Either AX or DXAX, determines the size of the return code.
; checknull
;       If non-blank, indicates that if the return code is zero, the
;       message structure should not be unthunked, since it is uninitialized.
; noprethunk
;       If non-blank, indicates that the lParam field of the thunk space
;       should not be initialized from the value passed in, since there
;       was no value passed in.
;
; Requirements:
;       bp_pCwp  be defined
;       si_space be defined
;       si_cwp16 be defined
;       si_cleanup be defined
;
; Results:
;----------------------------------------------------------------------------
CwpRetStructThkPostProc    macro

    AssertUserDS

;;Thunk the message parameters. Before calling the thunk, put the
;;original lParam value in the si_space structure, so that the xmovs
;;macro can find it.
;;
;;Push the 16-bit message parameters and copy the 32-bit lParam into
;;si_space.  Afterwards, si_space will contain the 32-bit values to
;;return to the system.

ifdef DEBUG
    ; Better have TF_THUNKMSGRESULT set
    test    si_space.s16_fw, TF_THUNKMSGRESULT
    jnz     @F

    int     3
@@:
endif

    ; Save 16bit hook return code
    push    dx
    push    ax

    ; Save message return result to be thunked.
    mov     eax, dword ptr si_cwpret16.cwpret16_lResult
    mov     dword ptr si_space.s16_lResult, eax

    push     word ptr si_cwpret16.cwpret16_hwnd
    push     word ptr si_cwpret16.cwpret16_message
    push     word ptr si_cwpret16.cwpret16_wParamHi
    push     word ptr si_cwpret16.cwpret16_wParamLo
    push    dword ptr si_cwpret16.cwpret16_lParam

    call    ThkMsgSL                ;;destroys EDI

;;Copy the 32-bit message parameters from si_space back into the
;;CWPSTRUCT32 structure.

    mov     es, FlatData
    mov     edi,bp_pCwpRet
    cld

    ; Result
    mov     eax, dword ptr si_space.s16_lResult
    stosd   es:[edi]
    .errnz  cwpret32_lResult

    mov     eax, dword ptr si_space.s16_lParam
    stosd   es:[edi]
    .errnz  cwpret32_lParam - cwpret32_lResult - 4

    mov     eax, dword ptr si_space.s16_wParam
    stosd   es:[edi]
    .errnz  cwpret32_wParam - cwpret32_lParam - 4

    xor     eax, eax
    mov     ax, word ptr si_space.s16_message
    stosd   es:[edi]
    .errnz  cwpret32_message - cwpret32_wParam - 4

    mov     ax, word ptr si_space.s16_hwnd
    stosd   es:[edi]
    .errnz  cwpret32_hwnd - cwpret32_message - 4
    .errnz  CWPRETSTRUCT32_SIZE - cwpret32_hwnd - 4

    ; Restore 32bit hook return code
    pop     eax
    lea     sp,si_cleanup
endm


;----------------------------------------------------------------------------
; HhsStructThkPreProc
;
; flags
;       Indicates api-specific flags to set in s16_fw.
;
; noprethunk
;       If non-blank, indicates that the message structure is uninitialized
;       and should not be thunked before calling the API.
;
; Requirements:
;       bp_pHhs be defined
;       si_space be defined
;       si_hhs16 be defined
;
; Results:
;       SP  =  original SP - size THKSPACE16 - size HARDWAREHOOKSTRUCT16
;              - extra space allocated by thunk, if any
; History:
;  08-07-91 BobGru
; Wrote it.
;----------------------------------------------------------------------------
HhsStructThkPreProc     macro   flags:=<0>

    AssertUserDS

;;Allocate local variable space
    sub     sp,size THKSPACE16 + HARDWAREHOOKSTRUCT16_SIZE
    InitLocalSpace  flags

    mov     es, FlatData
    mov     edi,bp_pHhs

;;Thunk the message parameters.
    push     word ptr es:[edi].hhs32_hwnd
    push     word ptr es:[edi].hhs32_message
    push    dword ptr es:[edi].hhs32_wParam
    push    dword ptr es:[edi].hhs32_lParam
    call    ThkMsgLS

;;Pack the thunked parameters into the msg16 structure.
    mov     ax, word ptr si_space.s16_hwnd
    mov     word ptr si_hhs16.hhs16_hwnd, ax

    mov     ax, word ptr si_space.s16_message
    mov     word ptr si_hhs16.hhs16_message, ax

    mov     ax, word ptr si_space.s16_wParam.lo
    mov     word ptr si_hhs16.hhs16_wParamLo, ax

    mov     eax, dword ptr si_space.s16_lParam
    mov     dword ptr si_hhs16.hhs16_lParam, eax

    mov     ax, word ptr si_space.s16_wParam.hi
    mov     word ptr si_hhs16.hhs16_wParamHi, ax
endm

;----------------------------------------------------------------------------
; HhsStructThkPostProc
;
; retsize
;       Either AX or DXAX, determines the size of the return code.
; checknull
;       If non-blank, indicates that if the return code is zero, the
;       message structure should not be unthunked, since it is uninitialized.
; noprethunk
;       If non-blank, indicates that the lParam field of the thunk space
;       should not be initialized from the value passed in, since there
;       was no value passed in.
;
; Requirements:
;       bp_pHhs  be defined
;       si_space be defined
;       si_hhs16 be defined
;       si_cleanup be defined
;
; Results:
;----------------------------------------------------------------------------
HhsStructThkPostProc    macro

    AssertUserDS

    ; Save 16bit hook return code
    mov      si_space.s16_lResult.lo, ax
    mov      si_space.s16_lResult.hi, dx

    push     word ptr si_hhs16.hhs16_hwnd
    push     word ptr si_hhs16.hhs16_message
    push     word ptr si_hhs16.hhs16_wParamHi
    push     word ptr si_hhs16.hhs16_wParamLo
    push    dword ptr si_hhs16.hhs16_lParam

    call    ThkMsgSL                ;;destroys EDI

;;Copy the 32-bit message parameters from si_space back into the
;;HARDWAREHOOKSTRUCT32 structure.

    mov     es, FlatData
    mov     edi,bp_pHhs
    cld

    xor     eax, eax
    mov     ax, word ptr si_space.s16_hwnd
    stosd   es:[edi]
    .errnz  hhs32_hwnd

    mov     ax, word ptr si_space.s16_message
    stosd   es:[edi]
    .errnz  hhs32_message - hhs32_hwnd - 4

    mov     eax,si_space.s16_wParam
    stosd   es:[edi]
    .errnz  hhs32_wParam - hhs32_message - 4

    mov     eax,si_space.s16_lParam
    stosd   es:[edi]
    .errnz  hhs32_lParam - hhs32_wParam - 4

    .errnz  HARDWAREHOOKSTRUCT32_SIZE - hhs32_lParam - 4

    ;Restore 32bit hook return code
    mov     eax, dword ptr si_space.s16_lResult    
    lea     sp,si_cleanup
endm


;----------------------------------------------------------------------------
; CbtStructThkPreProc
;
; flags
;       Indicates api-specific flags to set in s16_fw.
;
; noprethunk
;       If non-blank, indicates that the message structure is uninitialized
;       and should not be thunked before calling the API.
;
; Requirements:
;       bp_nType be defined
;       bp_pMsg be defined
;       si_space be defined
;----------------------------------------------------------------------------
CbtStructThkPreProc     macro   flags:=<0>
    local cbt_hook_error
    local HookDispatch
    local MAX_CBT_CODE
    local thk_HCBT_MOVESIZE
    local thk_HCBT_MINMAX
    local thk_HCBT_QS
    local thk_HCBT_CREATEWND
    local thk_HCBT_DESTROYWND
    local thk_HCBT_ACTIVATE
    local thk_HCBT_CLICKSKIPPED
    local thk_HCBT_KEYSKIPPED
    local thk_HCBT_SYSCOMMAND
    local thk_HCBT_SETFOCUS
    local si_cbtc

    AssertUserDS

;;Allocate local variable space
    sub     sp,size THKSPACE16
    InitLocalSpace  flags

    ; Convert wParam -- same for all HCBT_ hooks
    mov     eax, dword ptr bp_wParam
    mov     dword ptr si_space.s16_wParam, eax

    mov     bx,bp_nCode
    cmp     bx,MAX_CBT_CODE
    ja      cbt_hook_error

    add     bx,bx
    jmp     cs:HookDispatch[bx]

HookDispatch label word
    dw      offset thk_HCBT_MOVESIZE
    dw      offset thk_HCBT_MINMAX
    dw      offset thk_HCBT_QS
    dw      offset thk_HCBT_CREATEWND
    dw      offset thk_HCBT_DESTROYWND
    dw      offset thk_HCBT_ACTIVATE
    dw      offset thk_HCBT_CLICKSKIPPED
    dw      offset thk_HCBT_KEYSKIPPED
    dw      offset thk_HCBT_SYSCOMMAND
    dw      offset thk_HCBT_SETFOCUS
MAX_CBT_CODE equ ($-HookDispatch)/2

;Error -- invalid CBT code.  Fall through to the minimal thunking.
cbt_hook_error:


thk_HCBT_DESTROYWND:
thk_HCBT_KEYSKIPPED:
thk_HCBT_MINMAX:
thk_HCBT_QS:
thk_HCBT_SETFOCUS:      ;!!!need spec for this one
thk_HCBT_SYSCOMMAND:
    mov     eax, dword ptr bp_pMsg
    mov     dword ptr si_space.s16_lParam, eax
    jmp     thk_WH_CBT_call

thk_HCBT_ACTIVATE:
    sub     sp,CBTACTIVATESTRUCT16_SIZE

    xchg    bx,si           ;save frame pointer
    mov     di,ss           ;init DS:ESI --> source, ES:EDI --> dest
    mov     es,di
    movzx   edi,sp
    mov     esi,bp_pMsg
    push    ds
    mov     ds, FlatData
    cld

    call    cvtCBTACTIVATESTRUCTLS

    pop     ds
    xchg    bx,si           ;restore frame pointer

    or      word ptr si_space.s16_fw, TF_CLEANUP
    mov     word ptr si_space.s16_lParam[0],sp
    mov     word ptr si_space.s16_lParam[2],ss

    jmp     thk_WH_CBT_call

thk_HCBT_MOVESIZE:
    sub     sp,RECT16_SIZE

    xchg    bx,si           ;save frame pointer
    mov     di,ss           ;init DS:ESI --> source, ES:EDI --> dest
    mov     es,di
    movzx   edi,sp
    mov     esi,bp_pMsg
    push    ds
    mov     ds, FlatData
    cld

    call    cvtRECTLS

    pop     ds
    xchg    bx,si           ;restore frame pointer

    or      word ptr si_space.s16_fw, TF_CLEANUP
    mov     word ptr si_space.s16_lParam[0],sp
    mov     word ptr si_space.s16_lParam[2],ss

    jmp     thk_WH_CBT_call

thk_HCBT_CREATEWND:
si_cbtc equ <(si_space-CBT_CREATEWND16_SIZE)>
    sub     sp,CREATESTRUCT16_SIZE+CBT_CREATEWND16_SIZE

    lea     ax,si_cbtc
    mov     word ptr si_space.s16_lParam[0],ax
    mov     word ptr si_space.s16_lParam[2],ss

    ;Repack the CBT_CREATEWND structure here, then set up for
    ;the cvtCREATESTRUCTLS macro.

    mov     es, FlatData
    mov     edi,bp_pMsg
    mov     ax, word ptr es:[edi].cbtc32_hwndInsertAfter
    mov     word ptr si_cbtc.cbtc16_hwndInsertAfter, ax
    mov     word ptr si_cbtc.cbtc16_lpcs[0],sp
    mov     word ptr si_cbtc.cbtc16_lpcs[2],ss

    ;Space has already been allocated for the new CREATESTRUCT,
    ;and SS:SP points to it. Set up for the macro in the usual way.

    xchg    bx,si           ;save frame pointer
    mov     di,ss           ;init DS:ESI --> source, ES:EDI --> dest
    mov     es,di
    movzx   edi,sp

    push    ds
    mov     ds, FlatData
    mov     esi,bp_pMsg
    mov     esi, dword ptr ds:[esi].cbtc32_lpcs
    cld

    call    cvtCREATESTRUCTLS

    pop     ds
    xchg    bx,si           ;restore frame pointer

    ;Adjust pointer to skip wIdHi
    add     word ptr si_cbtc.cbtc16_lpcs[0],2

    ; Set TF_CLEANUP bit now so that unmaps happen when we convert
    ; createstruct back.
    or      word ptr si_space.s16_fw, TF_CLEANUP

    ;Safety check that we haven't forgotten any fields of the structure.
    .errnz  cbtc16_lpcs
    .errnz  cbtc16_hwndInsertAfter - cbtc16_lpcs - 4
    .errnz  CBT_CREATEWND16_SIZE - cbtc16_hwndInsertAfter - 2

    jmp     thk_WH_CBT_call


thk_HCBT_CLICKSKIPPED:
    sub     sp,MOUSEHOOKSTRUCT16_SIZE

    xchg    bx,si           ;save frame pointer
    mov     di,ss           ;init DS:ESI --> source, ES:EDI --> dest
    mov     es,di
    movzx   edi,sp
    mov     esi,bp_pMsg
    push    ds
    mov     ds, FlatData
    cld

    call    cvtMOUSEHOOKSTRUCTLS

    pop     ds
    xchg    bx,si           ;restore frame pointer

    or      word ptr si_space.s16_fw, TF_CLEANUP
    mov     word ptr si_space.s16_lParam[0],sp
    mov     word ptr si_space.s16_lParam[2],ss

    ;!!! am assuming don't need to unpack MOUSEHOOKSTRUCT
    jmp     thk_WH_CBT_call
endm

;----------------------------------------------------------------------------
;
;   CbtStructThkPostProc
;
;   We need to cleanup after making 16-bit call.  Any HCBT_ codes with 
;   LP to structures in lParam require cleanup.  This structure must be
;   copied and converted back.  I.E., SRC is 16-bits, DST is 32-bits.
;
;----------------------------------------------------------------------------
CbtStructThkPostProc  macro
    local   cbt_hook_error
    local   cbt_done
    local   HookDispatch
    local   MAX_CBT_CODE
    local   thk_HCBT_MOVESIZE
    local   thk_HCBT_MINMAX
    local   thk_HCBT_QS
    local   thk_HCBT_CREATEWND
    local   thk_HCBT_DESTROYWND
    local   thk_HCBT_ACTIVATE
    local   thk_HCBT_CLICKSKIPPED
    local   thk_HCBT_KEYSKIPPED
    local   thk_HCBT_SYSCOMMAND
    local   thk_HCBT_SETFOCUS

    AssertUserDS

    ; Save 16bit return code
    mov     si_space.s16_lResult.lo, ax
    mov     si_space.s16_lResult.hi, dx

    ; Copy back any structures
    mov     bx, bp_nCode
    cmp     bx, MAX_CBT_CODE
    ja      cbt_hook_error

    add     bx, bx
    jmp     cs:HookDispatch[bx]

HookDispatch label word
    dw      offset thk_HCBT_MOVESIZE
    dw      offset thk_HCBT_MINMAX
    dw      offset thk_HCBT_QS
    dw      offset thk_HCBT_CREATEWND
    dw      offset thk_HCBT_DESTROYWND
    dw      offset thk_HCBT_ACTIVATE
    dw      offset thk_HCBT_CLICKSKIPPED
    dw      offset thk_HCBT_KEYSKIPPED
    dw      offset thk_HCBT_SYSCOMMAND
    dw      offset thk_HCBT_SETFOCUS
MAX_CBT_CODE equ ($-HookDispatch)/2


thk_HCBT_CREATEWND:
si_cbtc equ <(si_space-CBT_CREATEWND16_SIZE)>
    ; lParam is an LPCBT_CREATEWND, which contains an embedded LPCREATESTRUCT
    push    ds
    push    esi
    push    edi

    ; 32-bit LPCBT_CREATEWND
    mov     es, FlatData        ; Do this before changing DS
    mov     edi, bp_pMsg

    ; 16-bit LPCBT_CREATEWND  Save frame pointer in BX!
    mov     bx, si
    lds     si, dword ptr si_space.s16_lParam

    ; Copy back the HWND
    movzx   eax, word ptr ds:[si].cbtc16_hwndInsertAfter
    mov     dword ptr es:[edi].cbtc32_hwndInsertAfter, eax

    ; Cleanup the CREATESTRUCT

    ; 32-bit LPCREATESTRUCT
    mov     edi, dword ptr es:[edi].cbtc32_lpcs

    ; 16-bit LPCREATESTRUCT
    lds     si, dword ptr ds:[si].cbtc16_lpcs
    sub     si, 2
    movzx   esi, si

    cld
    call    cvtCREATESTRUCTSL

    pop     edi
    pop     esi
    pop     ds
    jmp     cbt_done

thk_HCBT_ACTIVATE:
    ; lParam is an LPCBTACTIVATESTRUCT
    push    ds
    push    esi
    push    edi

    ; 32-bit LPCBTACTIVATESTRUCT
    mov     es, FlatData
    mov     edi, bp_pMsg

    ; 16-bit LPCBTACTIVATESTRUCT
    mov     bx, si
    lds     si, dword ptr si_space.s16_lParam
    movzx   esi, si

    cld
    call    cvtCBTACTIVATESTRUCTSL

    pop     edi
    pop     esi
    pop     ds
    jmp     cbt_done

thk_HCBT_MOVESIZE:
    ; lParam is an LPRECT
    push    ds
    push    esi
    push    edi

    ; 32-bit LPRECT
    mov     es, FlatData
    mov     edi, bp_pMsg

    ; 16-bit LPRECT
    mov     bx, si
    lds     si, dword ptr si_space.s16_lParam
    movzx   esi, si

    cld
    call    cvtRECTSL

    pop     edi
    pop     esi
    pop     ds
    jmp     cbt_done

thk_HCBT_CLICKSKIPPED:
    ; lParam is an LPMOUSEHOOKSTRUCT
    push    ds
    push    esi
    push    edi

    ; 32-bit LPMOUSEHOOKSTRUCT
    mov     es, FlatData
    mov     edi, bp_pMsg

    ; 16-bit LPMOUSEHOOKSTRUCT
    mov     bx, si
    lds     si, dword ptr si_space.s16_lParam
    movzx   esi, si

    cld
    call    cvtMOUSEHOOKSTRUCTSL

    pop     edi
    pop     esi
    pop     ds
    jmp     cbt_done

cbt_hook_error:
    ; Error -- invalid CBT code.
    ; FALL THRU

thk_HCBT_DESTROYWND:
thk_HCBT_KEYSKIPPED:
thk_HCBT_MINMAX:
thk_HCBT_QS:
thk_HCBT_SETFOCUS:
thk_HCBT_SYSCOMMAND:
    ; No cleanup required

cbt_done:
    ;Restore 32bit return code
    mov     eax, dword ptr si_space.s16_lResult
    lea     sp,si_cleanup
endm

;----------------------------------------------------------------------------
; MhsStructThkPreProc
;
; Requirements:
;       bp_pMhs be defined
;
; Results:
;       SP  =  original SP - size MOUSEHOOKSTRUCT16
; History:
;  04-10-92 BobGru
; Wrote it.
;----------------------------------------------------------------------------
MhsStructThkPreProc     macro

    AssertUserDS

    sub     sp,MOUSEHOOKSTRUCT16_SIZE
    xchg    bx,si           ;save frame pointer
    mov     di,ss           ;init DS:ESI --> source, ES:EDI --> dest
    mov     es,di
    movzx   edi,sp          ;do before any pushes
    push    ds
    mov     ds,FlatData
    mov     esi,bp_pMhs
    cld

    call    cvtMOUSEHOOKSTRUCTLS

    pop     ds
    xchg    bx,si           ;restore frame pointer
endm

;----------------------------------------------------------------------------
; MhsStructThkPostProc
;
; Requirements:
;       bp_pMhs be defined
;
; Results:
;
; History:
;  04-10-92 BobGru
; Wrote it.
;----------------------------------------------------------------------------
MhsStructThkPostProc     macro

    AssertUserDS

    xchg    bx,si           ;save frame pointer
    movzx   esi,sp          ;do before any pushes

    push    ds
    ;Save return code
    push    dx       
    push    ax


    mov     es,FlatData     ;do this while DS=DATA
    mov     di,ss           ;init DS:ESI --> source, ES:EDI --> dest
    mov     ds,di
    mov     edi,bp_pMhs
    cld
    call    cvtMOUSEHOOKSTRUCTSL

    ;Restore return code
    pop     eax         
    pop     ds          
    
    xchg    bx,si           ;restore frame pointer
    lea     sp,si_cleanup
endm



;----------------------------------------------------------------------------
; JhsStructThkPreProc
;
; Requirements:
;       bp_pJhs be defined
;       si_type ""
;       DX must be 0 or 1; 0 for JOURNALRECORD, 1 for JOURNALPLAYBACK
;
; Results:
;       SP  =  original SP - size EVENTMSG16
;----------------------------------------------------------------------------
JhsStructThkPreProc     macro

    AssertUserDS

    push    dx
    sub     sp,EVENTMSG16_SIZE

    xchg    bx,si           ;save frame pointer
    mov     di,ss           ;init DS:ESI --> source, ES:EDI --> dest
    mov     es,di
    movzx   edi,sp          ;do before any pushes
    push    ds
    mov     ds,FlatData
    mov     esi,bp_pJhs
    or      esi,esi
    jz      @F
    cld

    call    cvtEVENTMSGLS
@@:    
    pop     ds
    xchg    bx,si           ;restore frame pointer
endm

;----------------------------------------------------------------------------
; JhsStructThkPostProc
;
; Requirements:
;       bp_pJhs be defined
;       si_type ""
;       DX must be 0 or 1; 0 for JOURNALRECORD, 1 for JOURNALPLAYBACK
;
; Results:
;
;----------------------------------------------------------------------------
JhsStructThkPostProc     macro

    AssertUserDS

    ; Restore DX.  Do this first before we trash SI.
    mov     dx, word ptr si_type

    xchg    bx,si           ;save frame pointer
    movzx   esi,sp          ;do before any pushes

    push    ds
    ;Save return code
    push    eax

    mov     es,FlatData     ;do this while DS=DATA
    mov     di,ss           ;init DS:ESI --> source, ES:EDI --> dest
    mov     ds,di

    mov     edi,bp_pJhs
    or      edi,edi
    jz      @F

    cld
    call    cvtEVENTMSGSL
@@:    

    ;Restore return code
    pop     eax        
    pop     ds
    xchg    bx,si           ;restore frame pointer

    lea     sp,si_cleanup
endm


;----------------------------------------------------------------------------
;
;   DhsStructThkPreProc
;   Thunks L->S for WH_DEBUG
;
;----------------------------------------------------------------------------
DhsStructThkPreProc     macro
    
    AssertUserDS
    
    sub     sp, DEBUGHOOK16_SIZE
    xchg    bx, si
    mov     di, ss
    mov     es, di
    movzx   edi, sp
    push    ds
    mov     ds, FlatData
    mov     esi, bp_pDhs
    cld

    ; EXPECTS AX TO BE hook type
    ; RETURNS hTask in AX
    mov     ax, word ptr bp_wParam
    call    cvtDEBUGHOOKLS
    mov     word ptr bp_wParam, ax

    pop     ds
    xchg    bx, si
endm


;----------------------------------------------------------------------------
;
;   DhsStructThkPostProc
;   Cleans up S->L for WH_DEBUG
;
;----------------------------------------------------------------------------
DhsStructThkPostProc    macro
    
    AssertUserDS

    xchg    bx, si
    movzx   esi, sp
    push    ds

    ; Save return AFTER setting up ESI with SP
    push    dx
    push    ax

    mov     es, FlatData
    mov     di, ss
    mov     ds, di
    mov     edi, bp_pDhs
    cld

    ; EXPECTS AX to be hTask
    ; RETURNS whType in AX (don't need it anymore)
    mov     ax, word ptr bp_wParam
    call    cvtDEBUGHOOKSL

    ; Restore return
    pop     eax
    pop     ds

    xchg    bx, si
    lea     sp, si_cleanup
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\assert.h ===
/***
*assert.h - define the assert macro
*
*	Copyright (c) 1985-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines the assert(exp) macro.
*	[ANSI/System V]
*
*       [Public]
*
****/

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif



/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#undef	assert

#ifdef NDEBUG

#define assert(exp)	((void)0)

#else

#ifdef __cplusplus
extern "C" {
#endif

_CRTIMP void __cdecl _assert(void *, void *, unsigned);

#ifdef __cplusplus
}
#endif

#define assert(exp) (void)( (exp) || (_assert(#exp, __FILE__, __LINE__), 0) )

#endif	/* NDEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\cderr.h ===
/*****************************************************************************\
*                                                                             *
* cderr.h -     Common dialog error return codes                              *
*                                                                             *
* Version 1.0								      *
*                                                                             *
* Copyright (c) 1992-1995, Microsoft Corp.	All rights reserved.	      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_CDERR
#define _INC_CDERR

#define CDERR_DIALOGFAILURE   0xFFFF

#define CDERR_GENERALCODES     0x0000
#define CDERR_STRUCTSIZE       0x0001
#define CDERR_INITIALIZATION   0x0002
#define CDERR_NOTEMPLATE       0x0003
#define CDERR_NOHINSTANCE      0x0004
#define CDERR_LOADSTRFAILURE   0x0005
#define CDERR_FINDRESFAILURE   0x0006
#define CDERR_LOADRESFAILURE   0x0007
#define CDERR_LOCKRESFAILURE   0x0008
#define CDERR_MEMALLOCFAILURE  0x0009
#define CDERR_MEMLOCKFAILURE   0x000A
#define CDERR_NOHOOK           0x000B
#define CDERR_REGISTERMSGFAIL  0x000C

#define PDERR_PRINTERCODES     0x1000
#define PDERR_SETUPFAILURE     0x1001
#define PDERR_PARSEFAILURE     0x1002
#define PDERR_RETDEFFAILURE    0x1003
#define PDERR_LOADDRVFAILURE   0x1004
#define PDERR_GETDEVMODEFAIL   0x1005
#define PDERR_INITFAILURE      0x1006
#define PDERR_NODEVICES        0x1007
#define PDERR_NODEFAULTPRN     0x1008
#define PDERR_DNDMMISMATCH     0x1009
#define PDERR_CREATEICFAILURE  0x100A
#define PDERR_PRINTERNOTFOUND  0x100B
#define PDERR_DEFAULTDIFFERENT 0x100C

#define CFERR_CHOOSEFONTCODES  0x2000
#define CFERR_NOFONTS          0x2001
#define CFERR_MAXLESSTHANMIN   0x2002

#define FNERR_FILENAMECODES    0x3000
#define FNERR_SUBCLASSFAILURE  0x3001
#define FNERR_INVALIDFILENAME  0x3002
#define FNERR_BUFFERTOOSMALL   0x3003

#define FRERR_FINDREPLACECODES 0x4000
#define FRERR_BUFFERLENGTHZERO 0x4001

#define CCERR_CHOOSECOLORCODES 0x5000

#endif  /* !_INC_CDERR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\ctype.h ===
/***
*ctype.h - character conversion macros and ctype macros
*
*	Copyright (c) 1985-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines macros for character classification/conversion.
*	[ANSI/System V]
*
*       [Public]
*
****/

#ifndef _INC_CTYPE
#define _INC_CTYPE

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _MAC
#ifndef _WCTYPE_T_DEFINED
typedef wchar_t wint_t;
typedef wchar_t wctype_t;
#define _WCTYPE_T_DEFINED
#endif

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif
#endif /* ndef _MAC */

/*
 * These declarations allow the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */
#ifndef _CTYPE_DISABLE_MACROS

#ifdef	_NTSDK

/* Definitions and declarations compatible with the NT SDK */

#ifdef	_DLL

extern unsigned short * _ctype;
#define _pctype     (*_pctype_dll)
extern unsigned short **_pctype_dll;
#define _pwctype    (*_pwctype_dll)
extern unsigned short **_pwctype_dll;

#else	/* _DLL */


extern unsigned short _ctype[];
extern unsigned short *_pctype;
extern wctype_t *_pwctype;

#endif	/* _DLL */

#else	/* ndef _NTSDK */

/* Current declarations */
_CRTIMP extern unsigned short _ctype[];

#if	defined(_DLL) && defined(_M_IX86)

#define _pctype     (*__p__pctype())
_CRTIMP unsigned short ** __cdecl __p__pctype(void);

#define _pwctype    (*__p__pwctype())
_CRTIMP wctype_t ** __cdecl ___p__pwctype(void);

#else	/* !(defined(_DLL) && defined(_M_IX86)) */

_CRTIMP extern unsigned short *_pctype;
#ifndef _MAC
_CRTIMP extern wctype_t *_pwctype;
#endif /* ndef _MAC */

#endif	/* defined(_DLL) && defined(_M_IX86) */

#endif	/* _NTSDK */

#endif	/* _CTYPE_DISABLE_MACROS */

/* set bit masks for the possible character types */

#define _UPPER		0x1	/* upper case letter */
#define _LOWER		0x2	/* lower case letter */
#define _DIGIT		0x4	/* digit[0-9] */
#define _SPACE		0x8	/* tab, carriage return, newline, */
				/* vertical tab or form feed */
#define _PUNCT		0x10	/* punctuation character */
#define _CONTROL	0x20	/* control character */
#define _BLANK		0x40	/* space char */
#define _HEX		0x80	/* hexadecimal digit */

#define _LEADBYTE	0x8000			/* multibyte leadbyte */
#define _ALPHA		(0x0100|_UPPER|_LOWER)	/* alphabetic character */

/* character classification function prototypes */

#ifndef _CTYPE_DEFINED

_CRTIMP int __cdecl _isctype(int, int);

_CRTIMP int __cdecl isalpha(int);
_CRTIMP int __cdecl isupper(int);
_CRTIMP int __cdecl islower(int);
_CRTIMP int __cdecl isdigit(int);
_CRTIMP int __cdecl isxdigit(int);
_CRTIMP int __cdecl isspace(int);
_CRTIMP int __cdecl ispunct(int);
_CRTIMP int __cdecl isalnum(int);
_CRTIMP int __cdecl isprint(int);
_CRTIMP int __cdecl isgraph(int);
_CRTIMP int __cdecl iscntrl(int);
_CRTIMP int __cdecl toupper(int);
_CRTIMP int __cdecl tolower(int);
_CRTIMP int __cdecl _tolower(int);
_CRTIMP int __cdecl _toupper(int);
_CRTIMP int __cdecl __isascii(int);
_CRTIMP int __cdecl __toascii(int);
_CRTIMP int __cdecl __iscsymf(int);
_CRTIMP int __cdecl __iscsym(int);
#define _CTYPE_DEFINED
#endif

#ifndef _MAC
#ifndef _WCTYPE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

/* character classification function prototypes */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif
#endif /* ndef _MAC */

/* the character classification macro definitions */

#ifndef _CTYPE_DISABLE_MACROS

/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in stdlib.h).
 */
#ifndef MB_CUR_MAX

#ifdef	_NTSDK

/* definition compatible with NT SDK */
#ifdef	_DLL
#define __mb_cur_max	(*__mb_cur_max_dll)
#define MB_CUR_MAX	(*__mb_cur_max_dll)
extern	unsigned short *__mb_cur_max_dll;
#else	/* ndef _DLL */
#define MB_CUR_MAX __mb_cur_max
extern	unsigned short __mb_cur_max;
#endif	/* _DLL */

#else	/* ndef _NTSDK */

/* current definition */
#if	defined(_DLL) && defined(_M_IX86)
#define MB_CUR_MAX (*__p___mb_cur_max())
_CRTIMP int * __cdecl __p___mb_cur_max(void);
#else	/* !(defined(_DLL) && defined(_M_IX86)) */
#define MB_CUR_MAX __mb_cur_max
_CRTIMP extern int __mb_cur_max;
#endif	/* defined(_DLL) && defined(_M_IX86) */

#endif	/* _NTSDK */

#endif	/* MB_CUR_MAX */

#if defined(_M_MPPC) || defined(_M_M68K)
#define isalpha(_c)	( _pctype[_c] & (_UPPER|_LOWER) )
#define isupper(_c)	( _pctype[_c] & _UPPER )
#define islower(_c)	( _pctype[_c] & _LOWER )
#define isdigit(_c)	( _pctype[_c] & _DIGIT )
#define isxdigit(_c)( _pctype[_c] & _HEX )
#define isspace(_c)	( _pctype[_c] & _SPACE )
#define ispunct(_c)	( _pctype[_c] & _PUNCT )
#define isalnum(_c)	( _pctype[_c] & (_UPPER|_LOWER|_DIGIT) )
#define isprint(_c)	( _pctype[_c] & (_BLANK|_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define isgraph(_c)	( _pctype[_c] & (_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define iscntrl(_c)	( _pctype[_c] & _CONTROL )
#else
#define isalpha(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA) : _pctype[_c] & _ALPHA)
#define isupper(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_UPPER) : _pctype[_c] & _UPPER)
#define islower(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_LOWER) : _pctype[_c] & _LOWER)
#define isdigit(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_DIGIT) : _pctype[_c] & _DIGIT)
#define isxdigit(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_HEX)   : _pctype[_c] & _HEX)
#define isspace(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_SPACE) : _pctype[_c] & _SPACE)
#define ispunct(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT) : _pctype[_c] & _PUNCT)
#define isalnum(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA|_DIGIT) : _pctype[_c] & (_ALPHA|_DIGIT))
#define isprint(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) : _pctype[_c] & (_BLANK|_PUNCT|_ALPHA|_DIGIT))
#define isgraph(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT|_ALPHA|_DIGIT) : _pctype[_c] & (_PUNCT|_ALPHA|_DIGIT))
#define iscntrl(_c)	(MB_CUR_MAX > 1 ? _isctype(_c,_CONTROL) : _pctype[_c] & _CONTROL)
#endif	/* _M_MPPC || _M_M68K */

#define _tolower(_c)	( (_c)-'A'+'a' )
#define _toupper(_c)	( (_c)-'a'+'A' )

#define __isascii(_c)	( (unsigned)(_c) < 0x80 )
#define __toascii(_c)	( (_c) & 0x7f )

#define iswalpha(_c)	( iswctype(_c,_ALPHA) )
#define iswupper(_c)	( iswctype(_c,_UPPER) )
#define iswlower(_c)	( iswctype(_c,_LOWER) )
#define iswdigit(_c)	( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)	( iswctype(_c,_HEX) )
#define iswspace(_c)	( iswctype(_c,_SPACE) )
#define iswpunct(_c)	( iswctype(_c,_PUNCT) )
#define iswalnum(_c)	( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)	( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)	( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)	( iswctype(_c,_CONTROL) )
#define iswascii(_c)	( (unsigned)(_c) < 0x80 )

#define isleadbyte(_c)	(_pctype[(unsigned char)(_c)] & _LEADBYTE)

/* MS C version 2.0 extended ctype macros */

#define __iscsymf(_c)	(isalpha(_c) || ((_c) == '_'))
#define __iscsym(_c)	(isalnum(_c) || ((_c) == '_'))

#endif /* _CTYPE_DISABLE_MACROS */


#if	!__STDC__

/* Non-ANSI names for compatibility */

#ifdef	_NTSDK

#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym	__iscsym

#else	/* ndef _NTSDK */

#ifndef _CTYPE_DEFINED
_CRTIMP int __cdecl isascii(int);
_CRTIMP int __cdecl toascii(int);
_CRTIMP int __cdecl iscsymf(int);
_CRTIMP int __cdecl iscsym(int);
#else
#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym	__iscsym
#endif

#endif	/* _NTSDK */

#endif	/* __STDC__ */

#ifdef __cplusplus
}
#endif


#endif	/* _INC_CTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\conio.h ===
/***
*conio.h - console and port I/O declarations
*
*	Copyright (c) 1985-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for
*	the MS C V2.03 compatible console I/O routines.
*
*       [Public]
*
****/

#ifndef _INC_CONIO
#define _INC_CONIO

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifndef _MAC

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Function prototypes */

_CRTIMP char * __cdecl _cgets(char *);
_CRTIMP int __cdecl _cprintf(const char *, ...);
_CRTIMP int __cdecl _cputs(const char *);
_CRTIMP int __cdecl _cscanf(const char *, ...);
_CRTIMP int __cdecl _getch(void);
_CRTIMP int __cdecl _getche(void);
#ifdef	_M_IX86
int __cdecl _inp(unsigned short);
unsigned short __cdecl _inpw(unsigned short);
unsigned long __cdecl _inpd(unsigned short);
#endif	/* _M_IX86 */
_CRTIMP int __cdecl _kbhit(void);
#ifdef	_M_IX86
int __cdecl _outp(unsigned short, int);
unsigned short __cdecl _outpw(unsigned short, unsigned short);
unsigned long __cdecl _outpd(unsigned short, unsigned long);
#endif	/* _M_IX86 */
_CRTIMP int __cdecl _putch(int);
_CRTIMP int __cdecl _ungetch(int);


#if	!__STDC__

/* Non-ANSI names for compatibility */

#ifdef	_NTSDK

#define cgets	_cgets
#define cprintf _cprintf
#define cputs	_cputs
#define cscanf	_cscanf
#define getch	_getch
#define getche	_getche
#define kbhit	_kbhit
#define putch	_putch
#define ungetch _ungetch

#else	/* ndef _NTSDK */

_CRTIMP char * __cdecl cgets(char *);
_CRTIMP int __cdecl cprintf(const char *, ...);
_CRTIMP int __cdecl cputs(const char *);
_CRTIMP int __cdecl cscanf(const char *, ...);
#ifdef	_M_IX86
int __cdecl inp(unsigned short);
unsigned short __cdecl inpw(unsigned short);
#endif	/* _M_IX86 */
_CRTIMP int __cdecl getch(void);
_CRTIMP int __cdecl getche(void);
_CRTIMP int __cdecl kbhit(void);
#ifdef	_M_IX86
int __cdecl outp(unsigned short, int);
unsigned short __cdecl outpw(unsigned short, unsigned short);
#endif	/* _M_IX86 */
_CRTIMP int __cdecl putch(int);
_CRTIMP int __cdecl ungetch(int);

#endif	/* _NTSDK */

#endif	/* __STDC__ */

#ifdef __cplusplus
}
#endif

#endif /* _MAC */

#endif	/* _INC_CONIO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\commdlg.h ===
/************************************************************************
*                                                                       *
*   commdlg.h -- This module defines the 32-Bit Common Dialog APIs      *
*                                                                       *
*   Copyright (c) 1992-1995, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/
#ifndef _INC_COMMDLG
#define _INC_COMMDLG

#include <pshpack1.h>         /* Assume byte packing throughout */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#if(WINVER >= 0x0400)
#ifdef __cplusplus
#define SNDMSG ::SendMessage
#else   /* __cplusplus */
#define SNDMSG SendMessage
#endif  /* __cplusplus */
#endif /* WINVER >= 0x0400 */

typedef UINT (APIENTRY *LPOFNHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

#ifndef UNICODE_ONLY
typedef struct tagOFNA {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HINSTANCE    hInstance;
   LPCSTR       lpstrFilter;
   LPSTR        lpstrCustomFilter;
   DWORD        nMaxCustFilter;
   DWORD        nFilterIndex;
   LPSTR        lpstrFile;
   DWORD        nMaxFile;
   LPSTR        lpstrFileTitle;
   DWORD        nMaxFileTitle;
   LPCSTR       lpstrInitialDir;
   LPCSTR       lpstrTitle;
   DWORD        Flags;
   WORD         nFileOffset;
   WORD         nFileExtension;
   LPCSTR       lpstrDefExt;
   LPARAM       lCustData;
   LPOFNHOOKPROC lpfnHook;
   LPCSTR       lpTemplateName;
} OPENFILENAMEA, *LPOPENFILENAMEA;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct tagOFNW {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HINSTANCE    hInstance;
   LPCWSTR      lpstrFilter;
   LPWSTR       lpstrCustomFilter;
   DWORD        nMaxCustFilter;
   DWORD        nFilterIndex;
   LPWSTR       lpstrFile;
   DWORD        nMaxFile;
   LPWSTR       lpstrFileTitle;
   DWORD        nMaxFileTitle;
   LPCWSTR      lpstrInitialDir;
   LPCWSTR      lpstrTitle;
   DWORD        Flags;
   WORD         nFileOffset;
   WORD         nFileExtension;
   LPCWSTR      lpstrDefExt;
   LPARAM       lCustData;
   LPOFNHOOKPROC lpfnHook;
   LPCWSTR      lpTemplateName;
} OPENFILENAMEW, *LPOPENFILENAMEW;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef OPENFILENAMEW OPENFILENAME;
typedef LPOPENFILENAMEW LPOPENFILENAME;
#else
typedef OPENFILENAMEA OPENFILENAME;
typedef LPOPENFILENAMEA LPOPENFILENAME;
#endif // UNICODE

#ifndef UNICODE_ONLY
BOOL  APIENTRY     GetOpenFileNameA(LPOPENFILENAMEA);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL  APIENTRY     GetOpenFileNameW(LPOPENFILENAMEW);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define GetOpenFileName  GetOpenFileNameW
#else
#define GetOpenFileName  GetOpenFileNameA
#endif // !UNICODE
#ifndef UNICODE_ONLY
BOOL  APIENTRY     GetSaveFileNameA(LPOPENFILENAMEA);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL  APIENTRY     GetSaveFileNameW(LPOPENFILENAMEW);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define GetSaveFileName  GetSaveFileNameW
#else
#define GetSaveFileName  GetSaveFileNameA
#endif // !UNICODE
#ifndef UNICODE_ONLY
short APIENTRY     GetFileTitleA(LPCSTR, LPSTR, WORD);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
short APIENTRY     GetFileTitleW(LPCWSTR, LPWSTR, WORD);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define GetFileTitle  GetFileTitleW
#else
#define GetFileTitle  GetFileTitleA
#endif // !UNICODE

#define OFN_READONLY                 0x00000001
#define OFN_OVERWRITEPROMPT          0x00000002
#define OFN_HIDEREADONLY             0x00000004
#define OFN_NOCHANGEDIR              0x00000008
#define OFN_SHOWHELP                 0x00000010
#define OFN_ENABLEHOOK               0x00000020
#define OFN_ENABLETEMPLATE           0x00000040
#define OFN_ENABLETEMPLATEHANDLE     0x00000080
#define OFN_NOVALIDATE               0x00000100
#define OFN_ALLOWMULTISELECT         0x00000200
#define OFN_EXTENSIONDIFFERENT       0x00000400
#define OFN_PATHMUSTEXIST            0x00000800
#define OFN_FILEMUSTEXIST            0x00001000
#define OFN_CREATEPROMPT             0x00002000
#define OFN_SHAREAWARE               0x00004000
#define OFN_NOREADONLYRETURN         0x00008000
#define OFN_NOTESTFILECREATE         0x00010000
#define OFN_NONETWORKBUTTON          0x00020000
#define OFN_NOLONGNAMES              0x00040000     // force no long names for 4.x modules
#if(WINVER >= 0x0400)
#define OFN_EXPLORER                 0x00080000     // new look commdlg
#define OFN_NODEREFERENCELINKS       0x00100000
#define OFN_LONGNAMES                0x00200000     // force long names for 3.x modules
#endif /* WINVER >= 0x0400 */

// Return values for the registered message sent to the hook function
// when a sharing violation occurs.  OFN_SHAREFALLTHROUGH allows the
// filename to be accepted, OFN_SHARENOWARN rejects the name but puts
// up no warning (returned when the app has already put up a warning
// message), and OFN_SHAREWARN puts up the default warning message
// for sharing violations.
//
// Note:  Undefined return values map to OFN_SHAREWARN, but are
//        reserved for future use.

#define OFN_SHAREFALLTHROUGH     2
#define OFN_SHARENOWARN          1
#define OFN_SHAREWARN            0

typedef UINT (APIENTRY *LPCCHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

#if(WINVER >= 0x0400)
// Structure used for all OpenFileName notifications
#ifndef UNICODE_ONLY
typedef struct _OFNOTIFYA
{
        NMHDR           hdr;
        LPOPENFILENAMEA lpOFN;
        LPSTR           pszFile;        // May be NULL
} OFNOTIFYA, FAR *LPOFNOTIFYA;
#endif //!UNICODE_ONLY
// Structure used for all OpenFileName notifications
#ifndef ANSI_ONLY
typedef struct _OFNOTIFYW
{
        NMHDR           hdr;
        LPOPENFILENAMEW lpOFN;
        LPWSTR          pszFile;        // May be NULL
} OFNOTIFYW, FAR *LPOFNOTIFYW;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef OFNOTIFYW OFNOTIFY;
typedef LPOFNOTIFYW LPOFNOTIFY;
#else
typedef OFNOTIFYA OFNOTIFY;
typedef LPOFNOTIFYA LPOFNOTIFY;
#endif // UNICODE

#define CDN_FIRST   (0U-601U)
#define CDN_LAST    (0U-699U)

// Notifications when Open or Save dialog status changes
#define CDN_INITDONE            (CDN_FIRST - 0x0000)
#define CDN_SELCHANGE           (CDN_FIRST - 0x0001)
#define CDN_FOLDERCHANGE        (CDN_FIRST - 0x0002)
#define CDN_SHAREVIOLATION      (CDN_FIRST - 0x0003)
#define CDN_HELP                (CDN_FIRST - 0x0004)
#define CDN_FILEOK              (CDN_FIRST - 0x0005)
#define CDN_TYPECHANGE          (CDN_FIRST - 0x0006)

#define CDM_FIRST       (WM_USER + 100)
#define CDM_LAST        (WM_USER + 200)

// Messages to query information from the Open or Save dialogs

// lParam = pointer to text buffer that gets filled in
// wParam = max number of characters of the text buffer (including NULL)
// return = < 0 if error; number of characters needed (including NULL)
#define CDM_GETSPEC             (CDM_FIRST + 0x0000)
#ifndef UNICODE_ONLY
#define CommDlg_OpenSave_GetSpecA(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETSPEC, (WPARAM)_cbmax, (LPARAM)(LPSTR)_psz)
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
#define CommDlg_OpenSave_GetSpecW(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETSPEC, (WPARAM)_cbmax, (LPARAM)(LPWSTR)_psz)
#endif //!ANSI_ONLY
#ifdef UNICODE
#define CommDlg_OpenSave_GetSpec  CommDlg_OpenSave_GetSpecW
#else
#define CommDlg_OpenSave_GetSpec  CommDlg_OpenSave_GetSpecA
#endif // !UNICODE

// lParam = pointer to text buffer that gets filled in
// wParam = max number of characters of the text buffer (including NULL)
// return = < 0 if error; number of characters needed (including NULL)
#define CDM_GETFILEPATH         (CDM_FIRST + 0x0001)
#ifndef UNICODE_ONLY
#define CommDlg_OpenSave_GetFilePathA(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETFILEPATH, (WPARAM)_cbmax, (LPARAM)(LPSTR)_psz)
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
#define CommDlg_OpenSave_GetFilePathW(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETFILEPATH, (WPARAM)_cbmax, (LPARAM)(LPWSTR)_psz)
#endif //!ANSI_ONLY
#ifdef UNICODE
#define CommDlg_OpenSave_GetFilePath  CommDlg_OpenSave_GetFilePathW
#else
#define CommDlg_OpenSave_GetFilePath  CommDlg_OpenSave_GetFilePathA
#endif // !UNICODE

// lParam = pointer to text buffer that gets filled in
// wParam = max number of characters of the text buffer (including NULL)
// return = < 0 if error; number of characters needed (including NULL)
#define CDM_GETFOLDERPATH       (CDM_FIRST + 0x0002)
#ifndef UNICODE_ONLY
#define CommDlg_OpenSave_GetFolderPathA(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETFOLDERPATH, (WPARAM)_cbmax, (LPARAM)(LPSTR)_psz)
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
#define CommDlg_OpenSave_GetFolderPathW(_hdlg, _psz, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETFOLDERPATH, (WPARAM)_cbmax, (LPARAM)(LPWSTR)_psz)
#endif //!ANSI_ONLY
#ifdef UNICODE
#define CommDlg_OpenSave_GetFolderPath  CommDlg_OpenSave_GetFolderPathW
#else
#define CommDlg_OpenSave_GetFolderPath  CommDlg_OpenSave_GetFolderPathA
#endif // !UNICODE

// lParam = pointer to ITEMIDLIST buffer that gets filled in
// wParam = size of the ITEMIDLIST buffer
// return = < 0 if error; length of buffer needed
#define CDM_GETFOLDERIDLIST     (CDM_FIRST + 0x0003)
#define CommDlg_OpenSave_GetFolderIDList(_hdlg, _pidl, _cbmax) \
        (int)SNDMSG(_hdlg, CDM_GETFOLDERIDLIST, (WPARAM)_cbmax, (LPARAM)(LPVOID)_pidl)

// lParam = pointer to a string
// wParam = ID of control to change
// return = not used
#define CDM_SETCONTROLTEXT      (CDM_FIRST + 0x0004)
#define CommDlg_OpenSave_SetControlText(_hdlg, _id, _text) \
        (void)SNDMSG(_hdlg, CDM_SETCONTROLTEXT, (WPARAM)_id, (LPARAM)(LPSTR)_text)

// lParam = not used
// wParam = ID of control to change
// return = not used
#define CDM_HIDECONTROL         (CDM_FIRST + 0x0005)
#define CommDlg_OpenSave_HideControl(_hdlg, _id) \
        (void)SNDMSG(_hdlg, CDM_HIDECONTROL, (WPARAM)_id, 0)

// lParam = pointer to default extension (no dot)
// wParam = not used
// return = not used
#define CDM_SETDEFEXT           (CDM_FIRST + 0x0006)
#define CommDlg_OpenSave_SetDefExt(_hdlg, _pszext) \
        (void)SNDMSG(_hdlg, CDM_SETDEFEXT, 0, (LPARAM)(LPSTR)_pszext)
#endif /* WINVER >= 0x0400 */

#ifndef UNICODE_ONLY
typedef struct tagCHOOSECOLORA {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HWND         hInstance;
   COLORREF     rgbResult;
   COLORREF*    lpCustColors;
   DWORD        Flags;
   LPARAM       lCustData;
   LPCCHOOKPROC lpfnHook;
   LPCSTR       lpTemplateName;
} CHOOSECOLORA, *LPCHOOSECOLORA;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct tagCHOOSECOLORW {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HWND         hInstance;
   COLORREF     rgbResult;
   COLORREF*    lpCustColors;
   DWORD        Flags;
   LPARAM       lCustData;
   LPCCHOOKPROC lpfnHook;
   LPCWSTR      lpTemplateName;
} CHOOSECOLORW, *LPCHOOSECOLORW;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef CHOOSECOLORW CHOOSECOLOR;
typedef LPCHOOSECOLORW LPCHOOSECOLOR;
#else
typedef CHOOSECOLORA CHOOSECOLOR;
typedef LPCHOOSECOLORA LPCHOOSECOLOR;
#endif // UNICODE

#ifndef UNICODE_ONLY
BOOL  APIENTRY ChooseColorA(LPCHOOSECOLORA);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL  APIENTRY ChooseColorW(LPCHOOSECOLORW);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define ChooseColor  ChooseColorW
#else
#define ChooseColor  ChooseColorA
#endif // !UNICODE

#define CC_RGBINIT               0x00000001
#define CC_FULLOPEN              0x00000002
#define CC_PREVENTFULLOPEN       0x00000004
#define CC_SHOWHELP              0x00000008
#define CC_ENABLEHOOK            0x00000010
#define CC_ENABLETEMPLATE        0x00000020
#define CC_ENABLETEMPLATEHANDLE  0x00000040
#if(WINVER >= 0x0400)
#define CC_SOLIDCOLOR            0x00000080
#define CC_ANYCOLOR              0x00000100
#endif /* WINVER >= 0x0400 */

typedef UINT (APIENTRY *LPFRHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

#ifndef UNICODE_ONLY
typedef struct tagFINDREPLACEA {
   DWORD        lStructSize;        // size of this struct 0x20
   HWND         hwndOwner;          // handle to owner's window
   HINSTANCE    hInstance;          // instance handle of.EXE that
                                    //   contains cust. dlg. template
   DWORD        Flags;              // one or more of the FR_??
   LPSTR        lpstrFindWhat;      // ptr. to search string
   LPSTR        lpstrReplaceWith;   // ptr. to replace string
   WORD         wFindWhatLen;       // size of find buffer
   WORD         wReplaceWithLen;    // size of replace buffer
   LPARAM       lCustData;          // data passed to hook fn.
   LPFRHOOKPROC lpfnHook;           // ptr. to hook fn. or NULL
   LPCSTR       lpTemplateName;     // custom template name
} FINDREPLACEA, *LPFINDREPLACEA;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct tagFINDREPLACEW {
   DWORD        lStructSize;        // size of this struct 0x20
   HWND         hwndOwner;          // handle to owner's window
   HINSTANCE    hInstance;          // instance handle of.EXE that
                                    //   contains cust. dlg. template
   DWORD        Flags;              // one or more of the FR_??
   LPWSTR       lpstrFindWhat;      // ptr. to search string
   LPWSTR       lpstrReplaceWith;   // ptr. to replace string
   WORD         wFindWhatLen;       // size of find buffer
   WORD         wReplaceWithLen;    // size of replace buffer
   LPARAM       lCustData;          // data passed to hook fn.
   LPFRHOOKPROC lpfnHook;           // ptr. to hook fn. or NULL
   LPCWSTR      lpTemplateName;     // custom template name
} FINDREPLACEW, *LPFINDREPLACEW;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef FINDREPLACEW FINDREPLACE;
typedef LPFINDREPLACEW LPFINDREPLACE;
#else
typedef FINDREPLACEA FINDREPLACE;
typedef LPFINDREPLACEA LPFINDREPLACE;
#endif // UNICODE

#define FR_DOWN                         0x00000001
#define FR_WHOLEWORD                    0x00000002
#define FR_MATCHCASE                    0x00000004
#define FR_FINDNEXT                     0x00000008
#define FR_REPLACE                      0x00000010
#define FR_REPLACEALL                   0x00000020
#define FR_DIALOGTERM                   0x00000040
#define FR_SHOWHELP                     0x00000080
#define FR_ENABLEHOOK                   0x00000100
#define FR_ENABLETEMPLATE               0x00000200
#define FR_NOUPDOWN                     0x00000400
#define FR_NOMATCHCASE                  0x00000800
#define FR_NOWHOLEWORD                  0x00001000
#define FR_ENABLETEMPLATEHANDLE         0x00002000
#define FR_HIDEUPDOWN                   0x00004000
#define FR_HIDEMATCHCASE                0x00008000
#define FR_HIDEWHOLEWORD                0x00010000

#ifndef UNICODE_ONLY
HWND  APIENTRY    FindTextA(LPFINDREPLACEA);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
HWND  APIENTRY    FindTextW(LPFINDREPLACEW);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define FindText  FindTextW
#else
#define FindText  FindTextA
#endif // !UNICODE
#ifndef UNICODE_ONLY
HWND  APIENTRY    ReplaceTextA(LPFINDREPLACEA);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
HWND  APIENTRY    ReplaceTextW(LPFINDREPLACEW);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define ReplaceText  ReplaceTextW
#else
#define ReplaceText  ReplaceTextA
#endif // !UNICODE

typedef UINT (APIENTRY *LPCFHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

#ifndef UNICODE_ONLY
typedef struct tagCHOOSEFONTA {
   DWORD           lStructSize;
   HWND            hwndOwner;          // caller's window handle
   HDC             hDC;                // printer DC/IC or NULL
   LPLOGFONTA      lpLogFont;          // ptr. to a LOGFONT struct
   INT             iPointSize;         // 10 * size in points of selected font
   DWORD           Flags;              // enum. type flags
   COLORREF        rgbColors;          // returned text color
   LPARAM          lCustData;          // data passed to hook fn.
   LPCFHOOKPROC    lpfnHook;           // ptr. to hook function
   LPCSTR          lpTemplateName;     // custom template name
   HINSTANCE       hInstance;          // instance handle of.EXE that
                                       //   contains cust. dlg. template
   LPSTR           lpszStyle;          // return the style field here
                                       // must be LF_FACESIZE or bigger
   WORD            nFontType;          // same value reported to the EnumFonts
                                       //   call back with the extra FONTTYPE_
                                       //   bits added
   WORD            ___MISSING_ALIGNMENT__;
   INT             nSizeMin;           // minimum pt size allowed &
   INT             nSizeMax;           // max pt size allowed if
                                       //   CF_LIMITSIZE is used
} CHOOSEFONTA, *LPCHOOSEFONTA;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct tagCHOOSEFONTW {
   DWORD           lStructSize;
   HWND            hwndOwner;          // caller's window handle
   HDC             hDC;                // printer DC/IC or NULL
   LPLOGFONTW      lpLogFont;          // ptr. to a LOGFONT struct
   INT             iPointSize;         // 10 * size in points of selected font
   DWORD           Flags;              // enum. type flags
   COLORREF        rgbColors;          // returned text color
   LPARAM          lCustData;          // data passed to hook fn.
   LPCFHOOKPROC    lpfnHook;           // ptr. to hook function
   LPCWSTR         lpTemplateName;     // custom template name
   HINSTANCE       hInstance;          // instance handle of.EXE that
                                       //   contains cust. dlg. template
   LPWSTR          lpszStyle;          // return the style field here
                                       // must be LF_FACESIZE or bigger
   WORD            nFontType;          // same value reported to the EnumFonts
                                       //   call back with the extra FONTTYPE_
                                       //   bits added
   WORD            ___MISSING_ALIGNMENT__;
   INT             nSizeMin;           // minimum pt size allowed &
   INT             nSizeMax;           // max pt size allowed if
                                       //   CF_LIMITSIZE is used
} CHOOSEFONTW, *LPCHOOSEFONTW;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef CHOOSEFONTW CHOOSEFONT;
typedef LPCHOOSEFONTW LPCHOOSEFONT;
#else
typedef CHOOSEFONTA CHOOSEFONT;
typedef LPCHOOSEFONTA LPCHOOSEFONT;
#endif // UNICODE

#ifndef UNICODE_ONLY
BOOL APIENTRY ChooseFontA(LPCHOOSEFONTA);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL APIENTRY ChooseFontW(LPCHOOSEFONTW);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define ChooseFont  ChooseFontW
#else
#define ChooseFont  ChooseFontA
#endif // !UNICODE

#define CF_SCREENFONTS             0x00000001
#define CF_PRINTERFONTS            0x00000002
#define CF_BOTH                    (CF_SCREENFONTS | CF_PRINTERFONTS)
#define CF_SHOWHELP                0x00000004L
#define CF_ENABLEHOOK              0x00000008L
#define CF_ENABLETEMPLATE          0x00000010L
#define CF_ENABLETEMPLATEHANDLE    0x00000020L
#define CF_INITTOLOGFONTSTRUCT     0x00000040L
#define CF_USESTYLE                0x00000080L
#define CF_EFFECTS                 0x00000100L
#define CF_APPLY                   0x00000200L
#define CF_ANSIONLY                0x00000400L
#if(WINVER >= 0x0400)
#define CF_SCRIPTSONLY             CF_ANSIONLY
#endif /* WINVER >= 0x0400 */
#define CF_NOVECTORFONTS           0x00000800L
#define CF_NOOEMFONTS              CF_NOVECTORFONTS
#define CF_NOSIMULATIONS           0x00001000L
#define CF_LIMITSIZE               0x00002000L
#define CF_FIXEDPITCHONLY          0x00004000L
#define CF_WYSIWYG                 0x00008000L // must also have CF_SCREENFONTS & CF_PRINTERFONTS
#define CF_FORCEFONTEXIST          0x00010000L
#define CF_SCALABLEONLY            0x00020000L
#define CF_TTONLY                  0x00040000L
#define CF_NOFACESEL               0x00080000L
#define CF_NOSTYLESEL              0x00100000L
#define CF_NOSIZESEL               0x00200000L
#if(WINVER >= 0x0400)
#define CF_SELECTSCRIPT            0x00400000L
#define CF_NOSCRIPTSEL             0x00800000L
#define CF_NOVERTFONTS             0x01000000L
#endif /* WINVER >= 0x0400 */

// these are extra nFontType bits that are added to what is returned to the
// EnumFonts callback routine

#define SIMULATED_FONTTYPE    0x8000
#define PRINTER_FONTTYPE      0x4000
#define SCREEN_FONTTYPE       0x2000
#define BOLD_FONTTYPE         0x0100
#define ITALIC_FONTTYPE       0x0200
#define REGULAR_FONTTYPE      0x0400

#define WM_CHOOSEFONT_GETLOGFONT      (WM_USER + 1)
#define WM_CHOOSEFONT_SETLOGFONT      (WM_USER + 101)
#define WM_CHOOSEFONT_SETFLAGS        (WM_USER + 102)

// strings used to obtain unique window message for communication
// between dialog and caller

#define LBSELCHSTRINGA  "commdlg_LBSelChangedNotify"
#define SHAREVISTRINGA  "commdlg_ShareViolation"
#define FILEOKSTRINGA   "commdlg_FileNameOK"
#define COLOROKSTRINGA  "commdlg_ColorOK"
#define SETRGBSTRINGA   "commdlg_SetRGBColor"
#define HELPMSGSTRINGA  "commdlg_help"
#define FINDMSGSTRINGA  "commdlg_FindReplace"

#define LBSELCHSTRINGW  L"commdlg_LBSelChangedNotify"
#define SHAREVISTRINGW  L"commdlg_ShareViolation"
#define FILEOKSTRINGW   L"commdlg_FileNameOK"
#define COLOROKSTRINGW  L"commdlg_ColorOK"
#define SETRGBSTRINGW   L"commdlg_SetRGBColor"
#define HELPMSGSTRINGW  L"commdlg_help"
#define FINDMSGSTRINGW  L"commdlg_FindReplace"

#ifdef UNICODE
#define LBSELCHSTRING  LBSELCHSTRINGW
#define SHAREVISTRING  SHAREVISTRINGW
#define FILEOKSTRING   FILEOKSTRINGW
#define COLOROKSTRING  COLOROKSTRINGW
#define SETRGBSTRING   SETRGBSTRINGW
#define HELPMSGSTRING  HELPMSGSTRINGW
#define FINDMSGSTRING  FINDMSGSTRINGW
#else
#define LBSELCHSTRING  LBSELCHSTRINGA
#define SHAREVISTRING  SHAREVISTRINGA
#define FILEOKSTRING   FILEOKSTRINGA
#define COLOROKSTRING  COLOROKSTRINGA
#define SETRGBSTRING   SETRGBSTRINGA
#define HELPMSGSTRING  HELPMSGSTRINGA
#define FINDMSGSTRING  FINDMSGSTRINGA
#endif

// HIWORD values for lParam of commdlg_LBSelChangeNotify message
#define CD_LBSELNOITEMS -1
#define CD_LBSELCHANGE   0
#define CD_LBSELSUB      1
#define CD_LBSELADD      2

typedef UINT (APIENTRY *LPPRINTHOOKPROC) (HWND, UINT, WPARAM, LPARAM);
typedef UINT (APIENTRY *LPSETUPHOOKPROC) (HWND, UINT, WPARAM, LPARAM);

#ifndef UNICODE_ONLY
typedef struct tagPDA {
   DWORD            lStructSize;
   HWND             hwndOwner;
   HGLOBAL          hDevMode;
   HGLOBAL          hDevNames;
   HDC              hDC;
   DWORD            Flags;
   WORD             nFromPage;
   WORD             nToPage;
   WORD             nMinPage;
   WORD             nMaxPage;
   WORD             nCopies;
   HINSTANCE        hInstance;
   LPARAM           lCustData;
   LPPRINTHOOKPROC  lpfnPrintHook;
   LPSETUPHOOKPROC  lpfnSetupHook;
   LPCSTR           lpPrintTemplateName;
   LPCSTR           lpSetupTemplateName;
   HGLOBAL          hPrintTemplate;
   HGLOBAL          hSetupTemplate;
} PRINTDLGA, *LPPRINTDLGA;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct tagPDW {
   DWORD            lStructSize;
   HWND             hwndOwner;
   HGLOBAL          hDevMode;
   HGLOBAL          hDevNames;
   HDC              hDC;
   DWORD            Flags;
   WORD             nFromPage;
   WORD             nToPage;
   WORD             nMinPage;
   WORD             nMaxPage;
   WORD             nCopies;
   HINSTANCE        hInstance;
   LPARAM           lCustData;
   LPPRINTHOOKPROC  lpfnPrintHook;
   LPSETUPHOOKPROC  lpfnSetupHook;
   LPCWSTR          lpPrintTemplateName;
   LPCWSTR          lpSetupTemplateName;
   HGLOBAL          hPrintTemplate;
   HGLOBAL          hSetupTemplate;
} PRINTDLGW, *LPPRINTDLGW;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef PRINTDLGW PRINTDLG;
typedef LPPRINTDLGW LPPRINTDLG;
#else
typedef PRINTDLGA PRINTDLG;
typedef LPPRINTDLGA LPPRINTDLG;
#endif // UNICODE

#ifndef UNICODE_ONLY
BOOL  APIENTRY     PrintDlgA(LPPRINTDLGA);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL  APIENTRY     PrintDlgW(LPPRINTDLGW);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define PrintDlg  PrintDlgW
#else
#define PrintDlg  PrintDlgA
#endif // !UNICODE

#define PD_ALLPAGES                  0x00000000
#define PD_SELECTION                 0x00000001
#define PD_PAGENUMS                  0x00000002
#define PD_NOSELECTION               0x00000004
#define PD_NOPAGENUMS                0x00000008
#define PD_COLLATE                   0x00000010
#define PD_PRINTTOFILE               0x00000020
#define PD_PRINTSETUP                0x00000040
#define PD_NOWARNING                 0x00000080
#define PD_RETURNDC                  0x00000100
#define PD_RETURNIC                  0x00000200
#define PD_RETURNDEFAULT             0x00000400
#define PD_SHOWHELP                  0x00000800
#define PD_ENABLEPRINTHOOK           0x00001000
#define PD_ENABLESETUPHOOK           0x00002000
#define PD_ENABLEPRINTTEMPLATE       0x00004000
#define PD_ENABLESETUPTEMPLATE       0x00008000
#define PD_ENABLEPRINTTEMPLATEHANDLE 0x00010000
#define PD_ENABLESETUPTEMPLATEHANDLE 0x00020000
#define PD_USEDEVMODECOPIES          0x00040000
#define PD_USEDEVMODECOPIESANDCOLLATE 0x00040000
#define PD_DISABLEPRINTTOFILE        0x00080000
#define PD_HIDEPRINTTOFILE           0x00100000
#define PD_NONETWORKBUTTON           0x00200000

typedef struct tagDEVNAMES {
   WORD wDriverOffset;
   WORD wDeviceOffset;
   WORD wOutputOffset;
   WORD wDefault;
} DEVNAMES;

typedef DEVNAMES * LPDEVNAMES;

#define DN_DEFAULTPRN      0x0001

DWORD APIENTRY     CommDlgExtendedError(VOID);

#if(WINVER >= 0x0400)
#define WM_PSD_PAGESETUPDLG     (WM_USER  )
#define WM_PSD_FULLPAGERECT     (WM_USER+1)
#define WM_PSD_MINMARGINRECT    (WM_USER+2)
#define WM_PSD_MARGINRECT       (WM_USER+3)
#define WM_PSD_GREEKTEXTRECT    (WM_USER+4)
#define WM_PSD_ENVSTAMPRECT     (WM_USER+5)
#define WM_PSD_YAFULLPAGERECT   (WM_USER+6)

typedef UINT (APIENTRY* LPPAGEPAINTHOOK)( HWND, UINT, WPARAM, LPARAM );
typedef UINT (APIENTRY* LPPAGESETUPHOOK)( HWND, UINT, WPARAM, LPARAM );

#ifndef UNICODE_ONLY
typedef struct tagPSDA
{
    DWORD           lStructSize;
    HWND            hwndOwner;
    HGLOBAL         hDevMode;
    HGLOBAL         hDevNames;
    DWORD           Flags;
    POINT           ptPaperSize;
    RECT            rtMinMargin;
    RECT            rtMargin;
    HINSTANCE       hInstance;
    LPARAM          lCustData;
    LPPAGESETUPHOOK lpfnPageSetupHook;
    LPPAGEPAINTHOOK lpfnPagePaintHook;
    LPCSTR          lpPageSetupTemplateName;
    HGLOBAL         hPageSetupTemplate;
} PAGESETUPDLGA, * LPPAGESETUPDLGA;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct tagPSDW
{
    DWORD           lStructSize;
    HWND            hwndOwner;
    HGLOBAL         hDevMode;
    HGLOBAL         hDevNames;
    DWORD           Flags;
    POINT           ptPaperSize;
    RECT            rtMinMargin;
    RECT            rtMargin;
    HINSTANCE       hInstance;
    LPARAM          lCustData;
    LPPAGESETUPHOOK lpfnPageSetupHook;
    LPPAGEPAINTHOOK lpfnPagePaintHook;
    LPCWSTR         lpPageSetupTemplateName;
    HGLOBAL         hPageSetupTemplate;
} PAGESETUPDLGW, * LPPAGESETUPDLGW;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef PAGESETUPDLGW PAGESETUPDLG;
typedef LPPAGESETUPDLGW LPPAGESETUPDLG;
#else
typedef PAGESETUPDLGA PAGESETUPDLG;
typedef LPPAGESETUPDLGA LPPAGESETUPDLG;
#endif // UNICODE

#ifndef UNICODE_ONLY
BOOL APIENTRY PageSetupDlgA( LPPAGESETUPDLGA );
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL APIENTRY PageSetupDlgW( LPPAGESETUPDLGW );
#endif //!ANSI_ONLY
#ifdef UNICODE
#define PageSetupDlg  PageSetupDlgW
#else
#define PageSetupDlg  PageSetupDlgA
#endif // !UNICODE

#define PSD_DEFAULTMINMARGINS             0x00000000 // default (printer's)
#define PSD_INWININIINTLMEASURE           0x00000000 // 1st of 4 possible

#define PSD_MINMARGINS                    0x00000001 // use caller's
#define PSD_MARGINS                       0x00000002 // use caller's
#define PSD_INTHOUSANDTHSOFINCHES         0x00000004 // 2nd of 4 possible
#define PSD_INHUNDREDTHSOFMILLIMETERS     0x00000008 // 3rd of 4 possible
#define PSD_DISABLEMARGINS                0x00000010
#define PSD_DISABLEPRINTER                0x00000020
#define PSD_NOWARNING                     0x00000080 // must be same as PD_*
#define PSD_DISABLEORIENTATION            0x00000100
#define PSD_RETURNDEFAULT                 0x00000400 // must be same as PD_*
#define PSD_DISABLEPAPER                  0x00000200
#define PSD_SHOWHELP                      0x00000800 // must be same as PD_*
#define PSD_ENABLEPAGESETUPHOOK           0x00002000 // must be same as PD_*
#define PSD_ENABLEPAGESETUPTEMPLATE       0x00008000 // must be same as PD_*
#define PSD_ENABLEPAGESETUPTEMPLATEHANDLE 0x00020000 // must be same as PD_*
#define PSD_ENABLEPAGEPAINTHOOK           0x00040000
#define PSD_DISABLEPAGEPAINTING           0x00080000
#endif /* WINVER >= 0x0400 */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#include <poppack.h>
#endif  /* !_INC_COMMDLG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\dde.h ===
/*****************************************************************************\
*                                                                             *
* dde.h -       Dynamic Data Exchange structures and definitions              *
*                                                                             *
* Copyright (c) 1993-1995, Microsoft Corp.	All rights reserved	      *
*                                                                             *
\*****************************************************************************/
#ifndef _DDEHEADER_INCLUDED_
#define _DDEHEADER_INCLUDED_

#ifndef _WINDEF_
#include <windef.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* DDE window messages */

#define WM_DDE_FIRST	    0x03E0
#define WM_DDE_INITIATE     (WM_DDE_FIRST)
#define WM_DDE_TERMINATE    (WM_DDE_FIRST+1)
#define WM_DDE_ADVISE	    (WM_DDE_FIRST+2)
#define WM_DDE_UNADVISE     (WM_DDE_FIRST+3)
#define WM_DDE_ACK	        (WM_DDE_FIRST+4)
#define WM_DDE_DATA	        (WM_DDE_FIRST+5)
#define WM_DDE_REQUEST	    (WM_DDE_FIRST+6)
#define WM_DDE_POKE	        (WM_DDE_FIRST+7)
#define WM_DDE_EXECUTE	    (WM_DDE_FIRST+8)
#define WM_DDE_LAST	        (WM_DDE_FIRST+8)

/*----------------------------------------------------------------------------
|       DDEACK structure
|
|	Structure of wStatus (LOWORD(lParam)) in WM_DDE_ACK message
|       sent in response to a WM_DDE_DATA, WM_DDE_REQUEST, WM_DDE_POKE,
|       WM_DDE_ADVISE, or WM_DDE_UNADVISE message.
|
----------------------------------------------------------------------------*/

typedef struct {
        unsigned short bAppReturnCode:8,
                 reserved:6,
                 fBusy:1,
		 fAck:1;
} DDEACK;


/*----------------------------------------------------------------------------
|       DDEADVISE structure
|
|	WM_DDE_ADVISE parameter structure for hOptions (LOWORD(lParam))
|
----------------------------------------------------------------------------*/

typedef struct {
        unsigned short reserved:14,
                 fDeferUpd:1,
		 fAckReq:1;
	short     cfFormat;
} DDEADVISE;


/*----------------------------------------------------------------------------
|       DDEDATA structure
|
|       WM_DDE_DATA parameter structure for hData (LOWORD(lParam)).
|       The actual size of this structure depends on the size of
|       the Value array.
|
----------------------------------------------------------------------------*/

typedef struct {
	unsigned short unused:12,
                 fResponse:1,
                 fRelease:1,
                 reserved:1,
                 fAckReq:1;
	short	 cfFormat;
	BYTE	 Value[1];
} DDEDATA;


/*----------------------------------------------------------------------------
|	DDEPOKE structure
|
|	WM_DDE_POKE parameter structure for hData (LOWORD(lParam)).
|       The actual size of this structure depends on the size of
|       the Value array.
|
----------------------------------------------------------------------------*/

typedef struct {
	unsigned short unused:13,  /* Earlier versions of DDE.H incorrectly */
                             /* 12 unused bits.                       */
		 fRelease:1,
		 fReserved:2;
	short    cfFormat;
	BYTE	 Value[1];  /* This member was named rgb[1] in previous */
                            /* versions of DDE.H                        */

} DDEPOKE;

/*----------------------------------------------------------------------------
The following typedef's were used in previous versions of the Windows SDK.
They are still valid.  The above typedef's define exactly the same structures
as those below.  The above typedef names are recommended, however, as they
are more meaningful.

Note that the DDEPOKE structure typedef'ed in earlier versions of DDE.H did
not correctly define the bit positions.
----------------------------------------------------------------------------*/

typedef struct {
        unsigned short unused:13,
                 fRelease:1,
                 fDeferUpd:1,
		 fAckReq:1;
	short	 cfFormat;
} DDELN;

typedef struct {
	unsigned short unused:12,
                 fAck:1,
                 fRelease:1,
                 fReserved:1,
                 fAckReq:1;
	short	 cfFormat;
	BYTE	 rgb[1];
} DDEUP;


/*
 * DDE SECURITY
 */

BOOL
WINAPI
DdeSetQualityOfService(
    HWND hwndClient,
    CONST SECURITY_QUALITY_OF_SERVICE *pqosNew,
    PSECURITY_QUALITY_OF_SERVICE pqosPrev);

BOOL
WINAPI
ImpersonateDdeClientWindow(
    HWND hWndClient,
    HWND hWndServer);

/*
 * DDE message packing APIs
 */
LONG APIENTRY PackDDElParam(UINT msg, UINT uiLo, UINT uiHi);
BOOL APIENTRY UnpackDDElParam(UINT msg, LONG lParam, PUINT puiLo, PUINT puiHi);
BOOL APIENTRY FreeDDElParam(UINT msg, LONG lParam);
LONG APIENTRY ReuseDDElParam(LONG lParam, UINT msgIn, UINT msgOut, UINT uiLo, UINT uiHi);

#ifdef __cplusplus
}
#endif

#endif // _DDEHEADER_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\custcntl.h ===
/*****************************************************************************\
*                                                                             *
* custcntl.h -  Custom Control Library header file                            *
*                                                                             *
*               Copyright (c) 1992-1995, Microsoft Corp.  All rights reserved *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_CUSTCNTL
#define _INC_CUSTCNTL

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


/*
 * General size defines.
 */
#define CCHCCCLASS          32          // Max chars in a class name.
#define CCHCCDESC           32          // Max chars in a control description.
#define CCHCCTEXT           256         // Max chars in a text field.


/*
 * CCSTYLE - Custom Control Style structure.  This structure is passed
 * tp the Custom Control Style function when the user wants to edit the
 * styles of the custom control.
 */
#ifndef UNICODE_ONLY
typedef struct tagCCSTYLEA {
    DWORD   flStyle;                    // Style of the control.
    DWORD   flExtStyle;                 // Extended style of the control.
    CHAR    szText[CCHCCTEXT];          // Text of the control.
    LANGID  lgid;                       // Language Id of the control's dialog.
    WORD    wReserved1;                 // Reserved value.  Do not change.
} CCSTYLEA, *LPCCSTYLEA;
#endif //!UNICODE_ONLY

#ifndef ANSI_ONLY
typedef struct tagCCSTYLEW {
    DWORD   flStyle;                    // Style of the control.
    DWORD   flExtStyle;                 // Extended style of the control.
    WCHAR   szText[CCHCCTEXT];          // Text of the control.
    LANGID  lgid;                       // Language Id of the control's dialog.
    WORD    wReserved1;                 // Reserved value.  Do not change.
} CCSTYLEW, *LPCCSTYLEW;
#endif //!ANSI_ONLY

#ifdef UNICODE
#define CCSTYLE     CCSTYLEW
#define LPCCSTYLE   LPCCSTYLEW
#else
#define CCSTYLE     CCSTYLEA
#define LPCCSTYLE   LPCCSTYLEA
#endif // UNICODE


#ifndef UNICODE_ONLY
/*
 * The Style function prototype.  This will be called when the user
 * wants to edit the styles of a custom control.  It should display a
 * dialog to edit the styles, update the styles in the pccs structure,
 * then return TRUE for success.  If an error occurs or the user
 * cancels the dialog, FALSE should be returned.
 */
typedef BOOL (CALLBACK* LPFNCCSTYLEA)(HWND hwndParent,  LPCCSTYLEA pccs);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef BOOL (CALLBACK* LPFNCCSTYLEW)(HWND hwndParent,  LPCCSTYLEW pccs);
#endif //!ANSI_ONLY

#ifdef UNICODE
#define LPFNCCSTYLE LPFNCCSTYLEW
#else
#define LPFNCCSTYLE LPFNCCSTYLEA
#endif  // UNICODE


#ifndef UNICODE_ONLY
/*
 * The SizeToText function prototype.  This will be called if the user
 * requests that the custom control be sized to fit it's text.  It
 * should use the specified styles, text and font to determine how
 * large the control must be to accommodate the text, then return this
 * value in pixels.  The value of -1 should be returned if an error
 * occurs.
 */
typedef INT (CALLBACK* LPFNCCSIZETOTEXTA)(DWORD flStyle, DWORD flExtStyle,
    HFONT hfont, LPSTR pszText);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef INT (CALLBACK* LPFNCCSIZETOTEXTW)(DWORD flStyle, DWORD flExtStyle,
    HFONT hfont, LPWSTR pszText);
#endif //!ANSI_ONLY

#ifdef UNICODE
#define LPFNCCSIZETOTEXT    LPFNCCSIZETOTEXTW
#else
#define LPFNCCSIZETOTEXT    LPFNCCSIZETOTEXTA
#endif  // UNICODE


/*
 * CCSTYLEFLAG - Custom Control Style Flag structure.  A table of these
 * structures is used to specify the define strings that match the
 * different styles for a custom control.
 */
#ifndef UNICODE_ONLY
typedef struct tagCCSTYLEFLAGA {
    DWORD flStyle;                      // Style bits for this style.
    DWORD flStyleMask;                  // Mask for the style.  Can be zero.
    LPSTR pszStyle;                     // Points to the style define string.
} CCSTYLEFLAGA, *LPCCSTYLEFLAGA;
#endif //!UNICODE_ONLY

#ifndef ANSI_ONLY
typedef struct tagCCSTYLEFLAGW {
    DWORD flStyle;                      // Style bits for this style.
    DWORD flStyleMask;                  // Mask for the style.  Can be zero.
    LPWSTR pszStyle;                    // Points to the style define string.
} CCSTYLEFLAGW, *LPCCSTYLEFLAGW;
#endif //!ANSI_ONLY

#ifdef UNICODE
#define CCSTYLEFLAG     CCSTYLEFLAGW
#define LPCCSTYLEFLAG   LPCCSTYLEFLAGW
#else
#define CCSTYLEFLAG     CCSTYLEFLAGA
#define LPCCSTYLEFLAG   LPCCSTYLEFLAGA
#endif // UNICODE


/*
 * CCF_* defines.  These flags are used for the flOptions field of the
 * CCINFO structure, and describe some basic characteristics of the
 * custom control.
 */
#define CCF_NOTEXT          0x00000001  // Control cannot have text.


/*
 * CCINFO - Custom Control Info structure.  This structure provides
 * the dialog editor with information about the control types that the
 * DLL supports.
 */
#ifndef UNICODE_ONLY
typedef struct tagCCINFOA {
    CHAR    szClass[CCHCCCLASS];        // Class name for the control.
    DWORD   flOptions;                  // Option flags (CCF_* defines).
    CHAR    szDesc[CCHCCDESC];          // Short, descriptive text for the ctrl.
    UINT    cxDefault;                  // Default width (in dialog units).
    UINT    cyDefault;                  // Default height (in dialog units).
    DWORD   flStyleDefault;             // Default style (WS_CHILD | WS_VISIBLE).
    DWORD   flExtStyleDefault;          // Default extended style.
    DWORD   flCtrlTypeMask;             // Mask for control type styles.
    CHAR    szTextDefault[CCHCCTEXT];   // Default text.
    INT     cStyleFlags;                // Entries in the following style table.
    LPCCSTYLEFLAGA aStyleFlags;         // Points to style flag table.
    LPFNCCSTYLEA lpfnStyle;             // Pointer to the Styles function.
    LPFNCCSIZETOTEXTA lpfnSizeToText;   // Pointer to the SizeToText function.
    DWORD   dwReserved1;                // Reserved.  Must be zero.
    DWORD   dwReserved2;                // Reserved.  Must be zero.
} CCINFOA, *LPCCINFOA;
#endif //!UNICODE_ONLY

#ifndef ANSI_ONLY
typedef struct tagCCINFOW {
    WCHAR   szClass[CCHCCCLASS];        // Class name for the control.
    DWORD   flOptions;                  // Option flags (CCF_* defines).
    WCHAR   szDesc[CCHCCDESC];          // Short, descriptive text for the ctrl.
    UINT    cxDefault;                  // Default width (in dialog units).
    UINT    cyDefault;                  // Default height (in dialog units).
    DWORD   flStyleDefault;             // Default style (WS_CHILD | WS_VISIBLE).
    DWORD   flExtStyleDefault;          // Default extended style.
    DWORD   flCtrlTypeMask;             // Mask for control type styles.
    INT     cStyleFlags;                // Entries in the following style table.
    LPCCSTYLEFLAGW aStyleFlags;         // Points to style flag table.
    WCHAR   szTextDefault[CCHCCTEXT];   // Default text.
    LPFNCCSTYLEW lpfnStyle;             // Pointer to the Styles function.
    LPFNCCSIZETOTEXTW lpfnSizeToText;   // Pointer to the SizeToText function.
    DWORD   dwReserved1;                // Reserved.  Must be zero.
    DWORD   dwReserved2;                // Reserved.  Must be zero.
} CCINFOW, *LPCCINFOW;
#endif //!ANSI_ONLY

#ifdef UNICODE
#define CCINFO      CCINFOW
#define LPCCINFO    LPCCINFOW
#else
#define CCINFO      CCINFOA
#define LPCCINFO    LPCCINFOA
#endif // UNICODE


/*
 * The Info function prototype.  This function is the first one
 * called by the dialog editor.  Custom control DLL's must export
 * one or both of the following functions by name (the ordinal
 * used for the export does not matter):
 *
 *  UINT CALLBACK CustomControlInfoA(LPCCINFOA acci)
 *  UINT CALLBACK CustomControlInfoW(LPCCINFOW acci)
 *
 * This function must return the number of controls that the DLL
 * supports, or NULL if an error occurs.  If the acci parameter is
 * not NULL, it will be pointing to an array of CCINFOA or CCINFOW
 * structures that should be filled in with the information about
 * the different control types supported by the DLL.
 *
 * If both functions are present, the CustomControlInfoW function
 * will be used by the dialog editor.
 */
#ifndef UNICODE_ONLY
typedef UINT (CALLBACK* LPFNCCINFOA)(LPCCINFOA acci);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef UINT (CALLBACK* LPFNCCINFOW)(LPCCINFOW acci);
#endif //!ANSI_ONLY

#ifdef UNICODE
#define LPFNCCINFO  LPFNCCINFOW
#else
#define LPFNCCINFO  LPFNCCINFOA
#endif  // UNICODE


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _INC_CUSTCNTL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\ddeml.h ===
/*++ BUILD Version: 0001 // Increment this if a change has global effects --*/

/*****************************************************************************\
*                                                                             *
*  ddeml.h -    DDEML API header file                                         *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1993-95, Microsoft Corp.  All rights reserved.  *
*                                                                             *
\*****************************************************************************/
#ifndef _INC_DDEMLH
#define _INC_DDEMLH

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/******** public types ********/

DECLARE_HANDLE(HCONVLIST);
DECLARE_HANDLE(HCONV);
DECLARE_HANDLE(HSZ);
DECLARE_HANDLE(HDDEDATA);
#define EXPENTRY        CALLBACK

/* the following structure is for use with XTYP_WILDCONNECT processing. */

typedef struct tagHSZPAIR {
    HSZ hszSvc;
    HSZ hszTopic;
} HSZPAIR;
typedef HSZPAIR FAR *PHSZPAIR;

/* The following structure is used by DdeConnect() and DdeConnectList() and
   by XTYP_CONNECT and XTYP_WILDCONNECT callbacks. */

typedef struct tagCONVCONTEXT {
    UINT        cb;             /* set to sizeof(CONVCONTEXT) */
    UINT        wFlags;         /* none currently defined. */
    UINT        wCountryID;     /* country code for topic/item strings used. */
    int         iCodePage;      /* codepage used for topic/item strings. */
    DWORD       dwLangID;       /* language ID for topic/item strings. */
    DWORD       dwSecurity;     /* Private security code. */
    SECURITY_QUALITY_OF_SERVICE qos;  /* client side's quality of service */
} CONVCONTEXT;
typedef CONVCONTEXT FAR *PCONVCONTEXT;


/* The following structure is used by DdeQueryConvInfo(): */

typedef struct tagCONVINFO {
    DWORD   cb;            /* sizeof(CONVINFO)  */
    DWORD   hUser;         /* user specified field  */
    HCONV   hConvPartner;  /* hConv on other end or 0 if non-ddemgr partner  */
    HSZ     hszSvcPartner; /* app name of partner if obtainable  */
    HSZ     hszServiceReq; /* AppName requested for connection  */
    HSZ     hszTopic;      /* Topic name for conversation  */
    HSZ     hszItem;       /* transaction item name or NULL if quiescent  */
    UINT    wFmt;          /* transaction format or NULL if quiescent  */
    UINT    wType;         /* XTYP_ for current transaction  */
    UINT    wStatus;       /* ST_ constant for current conversation  */
    UINT    wConvst;       /* XST_ constant for current transaction  */
    UINT    wLastError;    /* last transaction error.  */
    HCONVLIST hConvList;   /* parent hConvList if this conversation is in a list */
    CONVCONTEXT ConvCtxt;  /* conversation context */
    HWND    hwnd;          /* window handle for this conversation */
    HWND    hwndPartner;   /* partner window handle for this conversation */
} CONVINFO;
typedef CONVINFO FAR *PCONVINFO;

/***** conversation states (usState) *****/

#define     XST_NULL              0  /* quiescent states */
#define     XST_INCOMPLETE        1
#define     XST_CONNECTED         2
#define     XST_INIT1             3  /* mid-initiation states */
#define     XST_INIT2             4
#define     XST_REQSENT           5  /* active conversation states */
#define     XST_DATARCVD          6
#define     XST_POKESENT          7
#define     XST_POKEACKRCVD       8
#define     XST_EXECSENT          9
#define     XST_EXECACKRCVD      10
#define     XST_ADVSENT          11
#define     XST_UNADVSENT        12
#define     XST_ADVACKRCVD       13
#define     XST_UNADVACKRCVD     14
#define     XST_ADVDATASENT      15
#define     XST_ADVDATAACKRCVD   16

/* used in LOWORD(dwData1) of XTYP_ADVREQ callbacks... */
#define     CADV_LATEACK         0xFFFF

/***** conversation status bits (fsStatus) *****/

#define     ST_CONNECTED            0x0001
#define     ST_ADVISE               0x0002
#define     ST_ISLOCAL              0x0004
#define     ST_BLOCKED              0x0008
#define     ST_CLIENT               0x0010
#define     ST_TERMINATED           0x0020
#define     ST_INLIST               0x0040
#define     ST_BLOCKNEXT            0x0080
#define     ST_ISSELF               0x0100


/* DDE constants for wStatus field */

#define DDE_FACK                0x8000
#define DDE_FBUSY               0x4000
#define DDE_FDEFERUPD           0x4000
#define DDE_FACKREQ             0x8000
#define DDE_FRELEASE            0x2000
#define DDE_FREQUESTED          0x1000
#define DDE_FAPPSTATUS          0x00ff
#define DDE_FNOTPROCESSED       0x0000

#define DDE_FACKRESERVED        (~(DDE_FACK | DDE_FBUSY | DDE_FAPPSTATUS))
#define DDE_FADVRESERVED        (~(DDE_FACKREQ | DDE_FDEFERUPD))
#define DDE_FDATRESERVED        (~(DDE_FACKREQ | DDE_FRELEASE | DDE_FREQUESTED))
#define DDE_FPOKRESERVED        (~(DDE_FRELEASE))

/***** message filter hook types *****/

#define     MSGF_DDEMGR             0x8001

/***** codepage constants ****/

#define CP_WINANSI      1004    /* default codepage for windows & old DDE convs. */
#define CP_WINUNICODE   1200

/***** transaction types *****/

#define     XTYPF_NOBLOCK            0x0002  /* CBR_BLOCK will not work */
#define     XTYPF_NODATA             0x0004  /* DDE_FDEFERUPD */
#define     XTYPF_ACKREQ             0x0008  /* DDE_FACKREQ */

#define     XCLASS_MASK              0xFC00
#define     XCLASS_BOOL              0x1000
#define     XCLASS_DATA              0x2000
#define     XCLASS_FLAGS             0x4000
#define     XCLASS_NOTIFICATION      0x8000

#define     XTYP_ERROR              (0x0000 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK )
#define     XTYP_ADVDATA            (0x0010 | XCLASS_FLAGS         )
#define     XTYP_ADVREQ             (0x0020 | XCLASS_DATA | XTYPF_NOBLOCK )
#define     XTYP_ADVSTART           (0x0030 | XCLASS_BOOL          )
#define     XTYP_ADVSTOP            (0x0040 | XCLASS_NOTIFICATION)
#define     XTYP_EXECUTE            (0x0050 | XCLASS_FLAGS         )
#define     XTYP_CONNECT            (0x0060 | XCLASS_BOOL | XTYPF_NOBLOCK)
#define     XTYP_CONNECT_CONFIRM    (0x0070 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_XACT_COMPLETE      (0x0080 | XCLASS_NOTIFICATION  )
#define     XTYP_POKE               (0x0090 | XCLASS_FLAGS         )
#define     XTYP_REGISTER           (0x00A0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_REQUEST            (0x00B0 | XCLASS_DATA          )
#define     XTYP_DISCONNECT         (0x00C0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_UNREGISTER         (0x00D0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_WILDCONNECT        (0x00E0 | XCLASS_DATA | XTYPF_NOBLOCK)

#define     XTYP_MASK                0x00F0
#define     XTYP_SHIFT               4  /* shift to turn XTYP_ into an index */

/***** Timeout constants *****/

#define     TIMEOUT_ASYNC           0xFFFFFFFF

/***** Transaction ID constants *****/

#define     QID_SYNC                0xFFFFFFFF

/****** public strings used in DDE ******/

#ifdef UNICODE
#define SZDDESYS_TOPIC         L"System"
#define SZDDESYS_ITEM_TOPICS   L"Topics"
#define SZDDESYS_ITEM_SYSITEMS L"SysItems"
#define SZDDESYS_ITEM_RTNMSG   L"ReturnMessage"
#define SZDDESYS_ITEM_STATUS   L"Status"
#define SZDDESYS_ITEM_FORMATS  L"Formats"
#define SZDDESYS_ITEM_HELP     L"Help"
#define SZDDE_ITEM_ITEMLIST    L"TopicItemList"
#else
#define SZDDESYS_TOPIC         "System"
#define SZDDESYS_ITEM_TOPICS   "Topics"
#define SZDDESYS_ITEM_SYSITEMS "SysItems"
#define SZDDESYS_ITEM_RTNMSG   "ReturnMessage"
#define SZDDESYS_ITEM_STATUS   "Status"
#define SZDDESYS_ITEM_FORMATS  "Formats"
#define SZDDESYS_ITEM_HELP     "Help"
#define SZDDE_ITEM_ITEMLIST    "TopicItemList"
#endif


/****** API entry points ******/

typedef HDDEDATA CALLBACK FNCALLBACK(UINT wType, UINT wFmt, HCONV hConv,
        HSZ hsz1, HSZ hsz2, HDDEDATA hData, DWORD dwData1, DWORD dwData2);
typedef HDDEDATA (CALLBACK *PFNCALLBACK)(UINT wType, UINT wFmt, HCONV hConv,
        HSZ hsz1, HSZ hsz2, HDDEDATA hData, DWORD dwData1, DWORD dwData2);

#define     CBR_BLOCK           ((HDDEDATA)0xffffffffL)

/* DLL registration functions */

#ifndef UNICODE_ONLY
UINT WINAPI DdeInitializeA(LPDWORD pidInst, PFNCALLBACK pfnCallback,
        DWORD afCmd, DWORD ulRes);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
UINT WINAPI DdeInitializeW(LPDWORD pidInst, PFNCALLBACK pfnCallback,
        DWORD afCmd, DWORD ulRes);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define DdeInitialize  DdeInitializeW
#else
#define DdeInitialize  DdeInitializeA
#endif // !UNICODE

/*
 * Callback filter flags for use with standard apps.
 */

#define     CBF_FAIL_SELFCONNECTIONS     0x00001000
#define     CBF_FAIL_CONNECTIONS         0x00002000
#define     CBF_FAIL_ADVISES             0x00004000
#define     CBF_FAIL_EXECUTES            0x00008000
#define     CBF_FAIL_POKES               0x00010000
#define     CBF_FAIL_REQUESTS            0x00020000
#define     CBF_FAIL_ALLSVRXACTIONS      0x0003f000

#define     CBF_SKIP_CONNECT_CONFIRMS    0x00040000
#define     CBF_SKIP_REGISTRATIONS       0x00080000
#define     CBF_SKIP_UNREGISTRATIONS     0x00100000
#define     CBF_SKIP_DISCONNECTS         0x00200000
#define     CBF_SKIP_ALLNOTIFICATIONS    0x003c0000

/*
 * Application command flags
 */
#define     APPCMD_CLIENTONLY            0x00000010L
#define     APPCMD_FILTERINITS           0x00000020L
#define     APPCMD_MASK                  0x00000FF0L

/*
 * Application classification flags
 */
#define     APPCLASS_STANDARD            0x00000000L
#define     APPCLASS_MASK                0x0000000FL



BOOL WINAPI DdeUninitialize(DWORD idInst);

/*
 * conversation enumeration functions
 */

HCONVLIST WINAPI DdeConnectList(DWORD idInst, HSZ hszService, HSZ hszTopic,
        HCONVLIST hConvList, PCONVCONTEXT pCC);
HCONV WINAPI DdeQueryNextServer(HCONVLIST hConvList, HCONV hConvPrev);
BOOL WINAPI DdeDisconnectList(HCONVLIST hConvList);

/*
 * conversation control functions
 */

HCONV WINAPI DdeConnect(DWORD idInst, HSZ hszService, HSZ hszTopic,
        PCONVCONTEXT pCC);
BOOL WINAPI DdeDisconnect(HCONV hConv);
HCONV WINAPI DdeReconnect(HCONV hConv);
UINT WINAPI DdeQueryConvInfo(HCONV hConv, DWORD idTransaction, PCONVINFO pConvInfo);
BOOL WINAPI DdeSetUserHandle(HCONV hConv, DWORD id, DWORD hUser);
BOOL WINAPI DdeAbandonTransaction(DWORD idInst, HCONV hConv, DWORD idTransaction);


/*
 * app server interface functions
 */

BOOL WINAPI DdePostAdvise(DWORD idInst, HSZ hszTopic, HSZ hszItem);
BOOL WINAPI DdeEnableCallback(DWORD idInst, HCONV hConv, UINT wCmd);
BOOL WINAPI DdeImpersonateClient(HCONV hConv);

#define EC_ENABLEALL            0
#define EC_ENABLEONE            ST_BLOCKNEXT
#define EC_DISABLE              ST_BLOCKED
#define EC_QUERYWAITING         2


HDDEDATA WINAPI DdeNameService(DWORD idInst, HSZ hsz1, HSZ hsz2, UINT afCmd);

#define DNS_REGISTER        0x0001
#define DNS_UNREGISTER      0x0002
#define DNS_FILTERON        0x0004
#define DNS_FILTEROFF       0x0008

/*
 * app client interface functions
 */

HDDEDATA WINAPI DdeClientTransaction(LPBYTE pData, DWORD cbData,
        HCONV hConv, HSZ hszItem, UINT wFmt, UINT wType,
        DWORD dwTimeout, LPDWORD pdwResult);

/*
 *data transfer functions
 */

HDDEDATA WINAPI DdeCreateDataHandle(DWORD idInst, LPBYTE pSrc, DWORD cb,
        DWORD cbOff, HSZ hszItem, UINT wFmt, UINT afCmd);
HDDEDATA WINAPI DdeAddData(HDDEDATA hData, LPBYTE pSrc, DWORD cb, DWORD cbOff);
DWORD WINAPI DdeGetData(HDDEDATA hData, LPBYTE pDst, DWORD cbMax, DWORD cbOff);
LPBYTE WINAPI DdeAccessData(HDDEDATA hData, LPDWORD pcbDataSize);
BOOL WINAPI DdeUnaccessData(HDDEDATA hData);
BOOL WINAPI DdeFreeDataHandle(HDDEDATA hData);

#define     HDATA_APPOWNED          0x0001


UINT WINAPI DdeGetLastError(DWORD idInst);

#define     DMLERR_NO_ERROR                    0       /* must be 0 */

#define     DMLERR_FIRST                       0x4000

#define     DMLERR_ADVACKTIMEOUT               0x4000
#define     DMLERR_BUSY                        0x4001
#define     DMLERR_DATAACKTIMEOUT              0x4002
#define     DMLERR_DLL_NOT_INITIALIZED         0x4003
#define     DMLERR_DLL_USAGE                   0x4004
#define     DMLERR_EXECACKTIMEOUT              0x4005
#define     DMLERR_INVALIDPARAMETER            0x4006
#define     DMLERR_LOW_MEMORY                  0x4007
#define     DMLERR_MEMORY_ERROR                0x4008
#define     DMLERR_NOTPROCESSED                0x4009
#define     DMLERR_NO_CONV_ESTABLISHED         0x400a
#define     DMLERR_POKEACKTIMEOUT              0x400b
#define     DMLERR_POSTMSG_FAILED              0x400c
#define     DMLERR_REENTRANCY                  0x400d
#define     DMLERR_SERVER_DIED                 0x400e
#define     DMLERR_SYS_ERROR                   0x400f
#define     DMLERR_UNADVACKTIMEOUT             0x4010
#define     DMLERR_UNFOUND_QUEUE_ID            0x4011

#define     DMLERR_LAST                        0x4011

#ifndef UNICODE_ONLY
HSZ  WINAPI DdeCreateStringHandleA(DWORD idInst, LPCSTR psz, int iCodePage);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
HSZ  WINAPI DdeCreateStringHandleW(DWORD idInst, LPCWSTR psz, int iCodePage);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define DdeCreateStringHandle  DdeCreateStringHandleW
#else
#define DdeCreateStringHandle  DdeCreateStringHandleA
#endif // !UNICODE
#ifndef UNICODE_ONLY
DWORD WINAPI DdeQueryStringA(DWORD idInst, HSZ hsz, LPSTR psz, DWORD cchMax, int iCodePage);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
DWORD WINAPI DdeQueryStringW(DWORD idInst, HSZ hsz, LPWSTR psz, DWORD cchMax, int iCodePage);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define DdeQueryString  DdeQueryStringW
#else
#define DdeQueryString  DdeQueryStringA
#endif // !UNICODE
BOOL WINAPI DdeFreeStringHandle(DWORD idInst, HSZ hsz);
BOOL WINAPI DdeKeepStringHandle(DWORD idInst, HSZ hsz);
int WINAPI DdeCmpStringHandles(HSZ hsz1, HSZ hsz2);


#ifndef NODDEMLSPY
/*
 * DDEML public debugging header file info
 */

typedef struct tagDDEML_MSG_HOOK_DATA {    // new for NT
    UINT uiLo;      // unpacked lo and hi parts of lParam
    UINT uiHi;
    DWORD cbData;   // amount of data in message, if any. May be > than 32 bytes.
    DWORD Data[8];  // data peeking by DDESPY is limited to 32 bytes.
} DDEML_MSG_HOOK_DATA, *PDDEML_MSG_HOOK_DATA;


typedef struct tagMONMSGSTRUCT {
    UINT    cb;
    HWND    hwndTo;
    DWORD   dwTime;
    HANDLE  hTask;
    UINT    wMsg;
    WPARAM  wParam;
    LPARAM  lParam;
    DDEML_MSG_HOOK_DATA dmhd;       // new for NT
} MONMSGSTRUCT, *PMONMSGSTRUCT;

typedef struct tagMONCBSTRUCT {
    UINT   cb;
    DWORD  dwTime;
    HANDLE hTask;
    DWORD  dwRet;
    UINT   wType;
    UINT   wFmt;
    HCONV  hConv;
    HSZ    hsz1;
    HSZ    hsz2;
    HDDEDATA hData;
    DWORD  dwData1;
    DWORD  dwData2;
    CONVCONTEXT cc;                 // new for NT for XTYP_CONNECT callbacks
    DWORD  cbData;                  // new for NT for data peeking
    DWORD  Data[8];                 // new for NT for data peeking
} MONCBSTRUCT, *PMONCBSTRUCT;

#ifndef UNICODE_ONLY
typedef struct tagMONHSZSTRUCTA {
    UINT   cb;
    BOOL   fsAction;    /* MH_ value */
    DWORD  dwTime;
    HSZ    hsz;
    HANDLE hTask;
    CHAR    str[1];
} MONHSZSTRUCTA, *PMONHSZSTRUCTA;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct tagMONHSZSTRUCTW {
    UINT   cb;
    BOOL   fsAction;    /* MH_ value */
    DWORD  dwTime;
    HSZ    hsz;
    HANDLE hTask;
    WCHAR   str[1];
} MONHSZSTRUCTW, *PMONHSZSTRUCTW;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef MONHSZSTRUCTW MONHSZSTRUCT;
typedef PMONHSZSTRUCTW PMONHSZSTRUCT;
#else
typedef MONHSZSTRUCTA MONHSZSTRUCT;
typedef PMONHSZSTRUCTA PMONHSZSTRUCT;
#endif // UNICODE

#define MH_CREATE   1
#define MH_KEEP     2
#define MH_DELETE   3
#define MH_CLEANUP  4

typedef struct tagMONERRSTRUCT {
    UINT    cb;
    UINT    wLastError;
    DWORD   dwTime;
    HANDLE  hTask;
} MONERRSTRUCT, *PMONERRSTRUCT;

typedef struct tagMONLINKSTRUCT {
    UINT    cb;
    DWORD   dwTime;
    HANDLE  hTask;
    BOOL    fEstablished;
    BOOL    fNoData;
    HSZ     hszSvc;
    HSZ     hszTopic;
    HSZ     hszItem;
    UINT    wFmt;
    BOOL    fServer;
    HCONV   hConvServer;
    HCONV   hConvClient;
} MONLINKSTRUCT, *PMONLINKSTRUCT;

typedef struct tagMONCONVSTRUCT {
    UINT    cb;
    BOOL    fConnect;
    DWORD   dwTime;
    HANDLE  hTask;
    HSZ     hszSvc;
    HSZ     hszTopic;
    HCONV   hConvClient;        // Globally unique value != apps local hConv
    HCONV   hConvServer;        // Globally unique value != apps local hConv
} MONCONVSTRUCT, *PMONCONVSTRUCT;

#define     MAX_MONITORS            4
#define     APPCLASS_MONITOR        0x00000001L
#define     XTYP_MONITOR            (0x00F0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)

/*
 * Callback filter flags for use with MONITOR apps - 0 implies no monitor
 * callbacks.
 */
#define     MF_HSZ_INFO                  0x01000000
#define     MF_SENDMSGS                  0x02000000
#define     MF_POSTMSGS                  0x04000000
#define     MF_CALLBACKS                 0x08000000
#define     MF_ERRORS                    0x10000000
#define     MF_LINKS                     0x20000000
#define     MF_CONV                      0x40000000

#define     MF_MASK                      0xFF000000
#endif /* NODDEMLSPY */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif /* _INC_DDEMLH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\dos.h ===
/***
*dos.h - definitions for MS-DOS interface routines
*
*	Copyright (c) 1985-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines the structs and unions used for the direct DOS interface
*	routines; includes macros to access the segment and offset
*	values of far pointers, so that they may be used by the routines; and
*	provides function prototypes for direct DOS interface functions.
*
*       [Public]
*
****/

#ifndef _INC_DOS
#define _INC_DOS

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef	_MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif	/* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _MAC
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif
#endif /* ndef _MAC */

#ifndef _MAC
#ifndef _DISKFREE_T_DEFINED
/* _getdiskfree structure (duplicated in DIRECT.H) */
struct _diskfree_t {
	unsigned total_clusters;
	unsigned avail_clusters;
	unsigned sectors_per_cluster;
	unsigned bytes_per_sector;
	};

#define _DISKFREE_T_DEFINED
#endif
#endif /* ndef _MAC */

/* File attribute constants */

#define _A_NORMAL	0x00	/* Normal file - No read/write restrictions */
#define _A_RDONLY	0x01	/* Read only file */
#define _A_HIDDEN	0x02	/* Hidden file */
#define _A_SYSTEM	0x04	/* System file */
#define _A_SUBDIR	0x10	/* Subdirectory */
#define _A_ARCH 	0x20	/* Archive file */

#ifdef	_NTSDK

/* External variable declarations */

/*
 * WARNING! The _osversion, _osmajor, _osminor, _baseversion, _basemajor and
 * _baseminor variables were never meaningfully defined in the C runtime
 * libraries for Win32 platforms. Any code which references these variables
 * should be revised (see the declarations for version information variables
 * in stdlib.h).
 */

#ifdef	_DLL

/* --------- The following block is OBSOLETE --------- */

#define _osversion   (*_osversion_dll)
#define _osmajor     (*_osmajor_dll)
#define _osminor     (*_osminor_dll)
#define _baseversion (*_baseversion_dll)
#define _basemajor   (*_basemajor_dll)
#define _baseminor   (*_baseminor_dll)

extern unsigned int * _osversion_dll;
extern unsigned int * _osmajor_dll;
extern unsigned int * _osminor_dll;
extern unsigned int * _baseversion_dll;
extern unsigned int * _basemajor_dll;
extern unsigned int * _baseminor_dll;

/* --------- The preceding block is OBSOLETE --------- */

#define _pgmptr      (*_pgmptr_dll)
extern char ** _pgmptr_dll;

#ifndef _MAC
#define _wpgmptr     (*_wpgmptr_dll)
extern wchar_t ** _wpgmptr_dll;
#endif /* ndef _MAC */

#else	/* ndef _DLL */

/* --------- The following block is OBSOLETE --------- */


extern unsigned int _osversion;
extern unsigned int _osmajor;
extern unsigned int _osminor;
extern unsigned int _baseversion;
extern unsigned int _basemajor;
extern unsigned int _baseminor;

/* --------- The preceding block is OBSOLETE --------- */


extern char * _pgmptr;
#ifndef _MAC
extern wchar_t * _wpgmptr;
#endif /* ndef _MAC */

#endif	/* _DLL */

#endif	/* _NTSDK */

#ifndef _MAC
/* Function prototypes */
_CRTIMP unsigned __cdecl _getdiskfree(unsigned, struct _diskfree_t *);
#endif /* ndef _MAC */

#ifdef	_M_IX86
void __cdecl _disable(void);
void __cdecl _enable(void);
#endif	/* _M_IX86 */

#ifndef _MAC
#if	!__STDC__
/* Non-ANSI name for compatibility */
#define diskfree_t  _diskfree_t
#endif	/* __STDC__ */
#endif /* ndef _MAC */

#ifdef __cplusplus
}
#endif

#ifdef	_MSC_VER
#pragma pack(pop)
#endif	/* _MSC_VER */

#endif	/* _INC_DOS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\drivinit.h ===
// All items moved to wingdi.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\direct.h ===
/***
*direct.h - function declarations for directory handling/creation
*
*	Copyright (c) 1985-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for the library
*	functions related to directory handling and creation.
*
*       [Public]
*
****/

#ifndef _INC_DIRECT
#define _INC_DIRECT

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef	_MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif	/* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _MAC
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif
#endif /* ndef _MAC */

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _MAC
/* _getdiskfree structure for _getdiskfree() */
#ifndef _DISKFREE_T_DEFINED

struct _diskfree_t {
	unsigned total_clusters;
	unsigned avail_clusters;
	unsigned sectors_per_cluster;
	unsigned bytes_per_sector;
	};

#define _DISKFREE_T_DEFINED
#endif
#endif /* ndef _MAC */

/* function prototypes */

_CRTIMP int __cdecl _chdir(const char *);
_CRTIMP char * __cdecl _getcwd(char *, int);
_CRTIMP int __cdecl _mkdir(const char *);
_CRTIMP int __cdecl _rmdir(const char *);

#ifndef _MAC
_CRTIMP int __cdecl _chdrive(int);
_CRTIMP char * __cdecl _getdcwd(int, char *, int);
_CRTIMP int __cdecl _getdrive(void);
_CRTIMP unsigned long __cdecl _getdrives(void);
_CRTIMP unsigned __cdecl _getdiskfree(unsigned, struct _diskfree_t *);
#endif /* ndef _MAC */


#ifndef _MAC
#ifndef _WDIRECT_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _wchdir(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wgetcwd(wchar_t *, int);
_CRTIMP wchar_t * __cdecl _wgetdcwd(int, wchar_t *, int);
_CRTIMP int __cdecl _wmkdir(const wchar_t *);
_CRTIMP int __cdecl _wrmdir(const wchar_t *);

#define _WDIRECT_DEFINED
#endif
#endif /* ndef _MAC */


#if	!__STDC__

/* Non-ANSI names for compatibility */

#ifdef	_NTSDK

#define chdir	_chdir
#define getcwd	_getcwd
#define mkdir	_mkdir
#define rmdir	_rmdir

#else	/* _NTSDK */

_CRTIMP int __cdecl chdir(const char *);
_CRTIMP char * __cdecl getcwd(char *, int);
_CRTIMP int __cdecl mkdir(const char *);
_CRTIMP int __cdecl rmdir(const char *);

#endif	/* _NTSDK */

#ifndef _MAC
#define diskfree_t  _diskfree_t
#endif /* ndef _MAC */

#endif	/* __STDC__ */

#ifdef __cplusplus
}
#endif

#ifdef	_MSC_VER
#pragma pack(pop)
#endif	/* _MSC_VER */

#endif	/* _INC_DIRECT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\dlgs.h ===
/*---------------------------------------------------------------------------*/
/* Dlgs.h : UI dialog header                                                 */
/*                                                                           */
/* Copyright (c) Microsoft Corporation, 1990-1995                            */
/*---------------------------------------------------------------------------*/

#ifndef _DLGSH_INCLUDED_
#define _DLGSH_INCLUDED_

/*----Constants--------------------------------------------------------------*/
#define ctlFirst    0x0400
#define ctlLast     0x04ff
    /* Push buttons */
#define psh1        0x0400
#define psh2        0x0401
#define psh3        0x0402
#define psh4        0x0403
#define psh5        0x0404
#define psh6        0x0405
#define psh7        0x0406
#define psh8        0x0407
#define psh9        0x0408
#define psh10       0x0409
#define psh11       0x040a
#define psh12       0x040b
#define psh13       0x040c
#define psh14       0x040d
#define psh15       0x040e
#define pshHelp     psh15
#define psh16       0x040f
    /* Checkboxes */
#define chx1        0x0410
#define chx2        0x0411
#define chx3        0x0412
#define chx4        0x0413
#define chx5        0x0414
#define chx6        0x0415
#define chx7        0x0416
#define chx8        0x0417
#define chx9        0x0418
#define chx10       0x0419
#define chx11       0x041a
#define chx12       0x041b
#define chx13       0x041c
#define chx14       0x041d
#define chx15       0x041e
#define chx16       0x041f
    /* Radio buttons */
#define rad1        0x0420
#define rad2        0x0421
#define rad3        0x0422
#define rad4        0x0423
#define rad5        0x0424
#define rad6        0x0425
#define rad7        0x0426
#define rad8        0x0427
#define rad9        0x0428
#define rad10       0x0429
#define rad11       0x042a
#define rad12       0x042b
#define rad13       0x042c
#define rad14       0x042d
#define rad15       0x042e
#define rad16       0x042f
    /* Groups, frames, rectangles, and icons */
#define grp1        0x0430
#define grp2        0x0431
#define grp3        0x0432
#define grp4        0x0433
#define frm1        0x0434
#define frm2        0x0435
#define frm3        0x0436
#define frm4        0x0437
#define rct1        0x0438
#define rct2        0x0439
#define rct3        0x043a
#define rct4        0x043b
#define ico1        0x043c
#define ico2        0x043d
#define ico3        0x043e
#define ico4        0x043f
    /* Static text */
#define stc1        0x0440
#define stc2        0x0441
#define stc3        0x0442
#define stc4        0x0443
#define stc5        0x0444
#define stc6        0x0445
#define stc7        0x0446
#define stc8        0x0447
#define stc9        0x0448
#define stc10       0x0449
#define stc11       0x044a
#define stc12       0x044b
#define stc13       0x044c
#define stc14       0x044d
#define stc15       0x044e
#define stc16       0x044f
#define stc17       0x0450
#define stc18       0x0451
#define stc19       0x0452
#define stc20       0x0453
#define stc21       0x0454
#define stc22       0x0455
#define stc23       0x0456
#define stc24       0x0457
#define stc25       0x0458
#define stc26       0x0459
#define stc27       0x045a
#define stc28       0x045b
#define stc29       0x045c
#define stc30       0x045d
#define stc31       0x045e
#define stc32       0x045f
    /* Listboxes */
#define lst1        0x0460
#define lst2        0x0461
#define lst3        0x0462
#define lst4        0x0463
#define lst5        0x0464
#define lst6        0x0465
#define lst7        0x0466
#define lst8        0x0467
#define lst9        0x0468
#define lst10       0x0469
#define lst11       0x046a
#define lst12       0x046b
#define lst13       0x046c
#define lst14       0x046d
#define lst15       0x046e
#define lst16       0x046f
    /* Combo boxes */
#define cmb1        0x0470
#define cmb2        0x0471
#define cmb3        0x0472
#define cmb4        0x0473
#define cmb5        0x0474
#define cmb6        0x0475
#define cmb7        0x0476
#define cmb8        0x0477
#define cmb9        0x0478
#define cmb10       0x0479
#define cmb11       0x047a
#define cmb12       0x047b
#define cmb13       0x047c
#define cmb14       0x047d
#define cmb15       0x047e
#define cmb16       0x047f
    /* Edit controls */
#define edt1        0x0480
#define edt2        0x0481
#define edt3        0x0482
#define edt4        0x0483
#define edt5        0x0484
#define edt6        0x0485
#define edt7        0x0486
#define edt8        0x0487
#define edt9        0x0488
#define edt10       0x0489
#define edt11       0x048a
#define edt12       0x048b
#define edt13       0x048c
#define edt14       0x048d
#define edt15       0x048e
#define edt16       0x048f
    /* Scroll bars */
#define scr1        0x0490
#define scr2        0x0491
#define scr3        0x0492
#define scr4        0x0493
#define scr5        0x0494
#define scr6        0x0495
#define scr7        0x0496
#define scr8        0x0497

/* These dialog resource ordinals really start at 0x0600, but the
 * RC Compiler can't handle hex for resource IDs, hence the decimal.
 */
#define FILEOPENORD      1536
#define MULTIFILEOPENORD 1537
#define PRINTDLGORD      1538
#define PRNSETUPDLGORD   1539
#define FINDDLGORD       1540
#define REPLACEDLGORD    1541
#define FONTDLGORD       1542
#define FORMATDLGORD31   1543
#define FORMATDLGORD30   1544

#if (WINVER >= 0x30a)
#define PAGESETUPDLGORD  1546
#endif /* WINVER >= 0x30a)



/*----Types------------------------------------------------------------------*/
typedef struct tagCRGB
    {
    BYTE    bRed;
    BYTE    bGreen;
    BYTE    bBlue;
    BYTE    bExtra;
    }
CRGB;           /* RGB Color */


#endif // _DLGSH_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\dlcapi.h ===
/*++

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    dlcapi.h

Abstract:

    This module defines 32-bit Windows/NT DLC structures and manifests

Revision History:

--*/

#ifndef _DLCAPI_
#define _DLCAPI_

#ifdef __cplusplus
extern "C" {
#endif

//
// DLC Command Codes
//

#define LLC_DIR_INTERRUPT               0x00
#define LLC_DIR_OPEN_ADAPTER            0x03
#define LLC_DIR_CLOSE_ADAPTER           0x04
#define LLC_DIR_SET_MULTICAST_ADDRESS   0x05
#define LLC_DIR_SET_GROUP_ADDRESS       0x06
#define LLC_DIR_SET_FUNCTIONAL_ADDRESS  0x07
#define LLC_DIR_READ_LOG                0x08
#define LLC_TRANSMIT_FRAMES             0x09
#define LLC_TRANSMIT_DIR_FRAME          0x0A
#define LLC_TRANSMIT_I_FRAME            0x0B
#define LLC_TRANSMIT_UI_FRAME           0x0D
#define LLC_TRANSMIT_XID_CMD            0x0E
#define LLC_TRANSMIT_XID_RESP_FINAL     0x0F
#define LLC_TRANSMIT_XID_RESP_NOT_FINAL 0x10
#define LLC_TRANSMIT_TEST_CMD           0x11
#define LLC_DLC_RESET                   0x14
#define LLC_DLC_OPEN_SAP                0x15
#define LLC_DLC_CLOSE_SAP               0x16
#define LLC_DLC_REALLOCATE_STATIONS     0x17
#define LLC_DLC_OPEN_STATION            0x19
#define LLC_DLC_CLOSE_STATION           0x1A
#define LLC_DLC_CONNECT_STATION         0x1B
#define LLC_DLC_MODIFY                  0x1C
#define LLC_DLC_FLOW_CONTROL            0x1D
#define LLC_DLC_STATISTICS              0x1E
#define LLC_DIR_INITIALIZE              0x20
#define LLC_DIR_STATUS                  0x21
#define LLC_DIR_TIMER_SET               0x22
#define LLC_DIR_TIMER_CANCEL            0x23
#define LLC_BUFFER_GET                  0x26
#define LLC_BUFFER_FREE                 0x27
#define LLC_RECEIVE                     0x28
#define LLC_RECEIVE_CANCEL              0x29
#define LLC_RECEIVE_MODIFY              0x2A
#define LLC_DIR_TIMER_CANCEL_GROUP      0x2C
#define LLC_DIR_SET_EXCEPTION_FLAGS     0x2D
#define LLC_BUFFER_CREATE               0x30
#define LLC_READ                        0x31
#define LLC_READ_CANCEL                 0x32
#define LLC_DLC_SET_THRESHOLD           0x33
#define LLC_DIR_CLOSE_DIRECT            0x34
#define LLC_DIR_OPEN_DIRECT             0x35
#define LLC_MAX_DLC_COMMAND             0x37

//
// forward definitions
//

union _LLC_PARMS;
typedef union _LLC_PARMS LLC_PARMS, *PLLC_PARMS;

//
// Parameters. Can be pointer to a parameter table (32-bit flat address),
// a single 32-bit ULONG, 2 16-bit USHORTs or 4 8-bit BYTEs
//

typedef union {

    PLLC_PARMS pParameterTable;     // pointer to the parameter table

    struct {
        USHORT usStationId;         // Station id
        USHORT usParameter;         // optional parameter
    } dlc;

    struct {
        USHORT usParameter0;        // first optional parameter
        USHORT usParameter1;        // second optional parameter
    } dir;

    UCHAR auchBuffer[4];            // group/functional address

    ULONG ulParameter;

} CCB_PARMS;

//
// LLC_CCB - the Command Control Block structure
//

typedef struct _LLC_CCB {
    UCHAR uchAdapterNumber;         // Adapter 0 or 1
    UCHAR uchDlcCommand;            // DLC command
    UCHAR uchDlcStatus;             // DLC command completion code
    UCHAR uchReserved1;             // reserved for DLC DLL
    struct _LLC_CCB* pNext;         // CCB chain
    ULONG ulCompletionFlag;         // used in command completion
    CCB_PARMS u;                    // parameters
    HANDLE hCompletionEvent;        // event for command completion
    UCHAR uchReserved2;             // reserved for DLC DLL
    UCHAR uchReadFlag;              // set when special READ CCB chained
    USHORT usReserved3;             // reserved for DLC DLL
} LLC_CCB, *PLLC_CCB;

//
// transmit/receive buffers
//

union _LLC_BUFFER;
typedef union _LLC_BUFFER LLC_BUFFER, *PLLC_BUFFER;

typedef struct {
    PLLC_BUFFER pNextBuffer;        // next DLC buffer in frame
    USHORT cbFrame;                 // length of the whole received frame
    USHORT cbBuffer;                // length of this segment
    USHORT offUserData;             // offset of data from descriptor header
    USHORT cbUserData;              // length of the data
} LLC_NEXT_BUFFER;

typedef struct {
    PLLC_BUFFER pNextBuffer;        // next buffer of frame
    USHORT cbFrame;                 // length of entire frame
    USHORT cbBuffer;                // length of this buffer
    USHORT offUserData;             // user data in this struct
    USHORT cbUserData;              // length of user data
    USHORT usStationId;             // ssnn station id
    UCHAR uchOptions;               // option byte from RECEIVE param tbl
    UCHAR uchMsgType;               // the message type
    USHORT cBuffersLeft;            // number of basic buffer units left
    UCHAR uchRcvFS;                 // the reveived frame status
    UCHAR uchAdapterNumber;         // adapter number
    PLLC_BUFFER pNextFrame;         // pointer to next frame
    UCHAR cbLanHeader;              // length of the lan header
    UCHAR cbDlcHeader;              // length of the DLC header
    UCHAR auchLanHeader[32];        // lan header of the received frame
    UCHAR auchDlcHeader[4];         // dlc header of the received frame
    USHORT usPadding;               // data begins from offset 64 !!!
} LLC_NOT_CONTIGUOUS_BUFFER;

typedef struct {
    PLLC_BUFFER pNextBuffer;        // next buffer of frame
    USHORT cbFrame;                 // length of entire frame
    USHORT cbBuffer;                // length of this buffer
    USHORT offUserData;             // user data in this struct
    USHORT cbUserData;              // length of user data
    USHORT usStationId;             // ssnn station id
    UCHAR uchOptions;               // option byte from RECEIVE param tbl
    UCHAR uchMsgType;               // the message type
    USHORT cBuffersLeft;            // number of basic buffer units left
    UCHAR uchRcvFS;                 // the reveived frame status
    UCHAR uchAdapterNumber;         // adapter number
    PLLC_BUFFER pNextFrame;         // pointer to next frame
} LLC_CONTIGUOUS_BUFFER;

//
// Received frames are returned in these data structures
//

union _LLC_BUFFER {

    PLLC_BUFFER pNext;

    LLC_NEXT_BUFFER Next;

    struct LlcNextBuffer {
        LLC_NEXT_BUFFER Header;
        UCHAR auchData[];
    } Buffer;

    LLC_NOT_CONTIGUOUS_BUFFER NotContiguous;

    struct {
        LLC_NOT_CONTIGUOUS_BUFFER Header;
        UCHAR auchData[];
    } NotCont;

    LLC_CONTIGUOUS_BUFFER Contiguous;

    struct {
        LLC_CONTIGUOUS_BUFFER Header;
        UCHAR auchData[];
    } Cont;

};

//
// This structure is used by BUFFER.GET, BUFFER.FREE and TRANSMIT
//

struct _LLC_XMIT_BUFFER;
typedef struct _LLC_XMIT_BUFFER LLC_XMIT_BUFFER, *PLLC_XMIT_BUFFER;

struct _LLC_XMIT_BUFFER {
    PLLC_XMIT_BUFFER pNext;         // next buffer (or NULL)
    USHORT usReserved1;             //
    USHORT cbBuffer;                // length of transmitted data
    USHORT usReserved2;             //
    USHORT cbUserData;              // length of optional header
    UCHAR auchData[];               // optional header and transmitted data
};

#define LLC_XMIT_BUFFER_SIZE sizeof(LLC_XMIT_BUFFER)

//
// CCB parameter tables
//

typedef struct {
    HANDLE hBufferPool;             // handle of new buffer pool
    PVOID pBuffer;                  // any buffer in memory
    ULONG cbBufferSize;             // buffer size in bytes
    ULONG cbMinimumSizeThreshold;   // minimum locked size
} LLC_BUFFER_CREATE_PARMS, *PLLC_BUFFER_CREATE_PARMS;

typedef struct {
    USHORT usReserved1;             // Station id is not used
    USHORT cBuffersLeft;            // free 256 buffer segments
    ULONG ulReserved;
    PLLC_XMIT_BUFFER pFirstBuffer;  // buffer chain
} LLC_BUFFER_FREE_PARMS, *PLLC_BUFFER_FREE_PARMS;

typedef struct {
    USHORT usReserved1;             // Station id is not used
    USHORT cBuffersLeft;            // free 256 buffer segments

    //
    // cBuffersToGet: number of buffers to get. If 0, the returned buffer list
    // may consist of segment of different size
    //

    USHORT cBuffersToGet;

    //
    // cbBufferSize: size of the requested buffers. This will be rounded up to
    // the next largest segment size: 256, 512, 1024, 2048 or 4096
    //

    USHORT cbBufferSize;
    PLLC_XMIT_BUFFER pFirstBuffer;
} LLC_BUFFER_GET_PARMS, *PLLC_BUFFER_GET_PARMS;

//
// parameter table for DLC.CONNECT.STATION
//

typedef struct {
    USHORT usStationId;             // SAP or direct station ID, defines the pool
    USHORT usReserved;
    PUCHAR pRoutingInfo;            // offset to the routing info
} LLC_DLC_CONNECT_PARMS, *PLLC_DLC_CONNECT_PARMS;

//
// DLC_FLOW_CONTROL Options:
//

#define LLC_RESET_LOCAL_BUSY_USER   0x80
#define LLC_RESET_LOCAL_BUSY_BUFFER 0xC0
#define LLC_SET_LOCAL_BUSY_USER     0

typedef struct {
    USHORT usRes;
    USHORT usStationId;             // SAP or link station id
    UCHAR uchT1;                    // response timer
    UCHAR uchT2;                    // aknowledgment timer
    UCHAR uchTi;                    // inactivity timer
    UCHAR uchMaxOut;                // max transmits without ack
    UCHAR uchMaxIn;                 // max receives without ack
    UCHAR uchMaxOutIncr;            // dynamic window increment value
    UCHAR uchMaxRetryCnt;           // N2 value (retries)
    UCHAR uchReserved1;
    USHORT usMaxInfoFieldLength;    // Only for link stations, NEW!!!
    UCHAR uchAccessPriority;        // token ring access priority
    UCHAR auchReserved3[4];
    UCHAR cGroupCount;              // number of group SAPs of this SAP
    PUCHAR pGroupList;              // offset to the group list
} LLC_DLC_MODIFY_PARMS, *PLLC_DLC_MODIFY_PARMS;

#define LLC_XID_HANDLING_IN_APPLICATION 0x08
#define LLC_XID_HANDLING_IN_DLC         0
#define LLC_INDIVIDUAL_SAP              0x04
#define LLC_GROUP_SAP                   0x02
#define LLC_MEMBER_OF_GROUP_SAP         0x01

typedef struct {
    USHORT usStationId;             // SAP or link station id
    USHORT usUserStatValue;         // reserved for user
    UCHAR uchT1;                    // response timer
    UCHAR uchT2;                    // aknowledgment timer
    UCHAR uchTi;                    // inactivity timer
    UCHAR uchMaxOut;                // max tramists without ack
    UCHAR uchMaxIn;                 // max receives without ack
    UCHAR uchMaxOutIncr;            // dynamic window increment value
    UCHAR uchMaxRetryCnt;           // N2 value (retries)
    UCHAR uchMaxMembers;            // maximum members for group SAP
    USHORT usMaxI_Field;            // maximum length of the Info field
    UCHAR uchSapValue;              // SAP value to be assigned
    UCHAR uchOptionsPriority;       // SAP options and access priority
    UCHAR uchcStationCount;         // maximum number of link stations in sap
    UCHAR uchReserved2[2];          //
    UCHAR cGroupCount;              // number of group SAPs of this SAP
    PUCHAR pGroupList;              // offset to the group list
    ULONG DlcStatusFlags;           // User notify flag for DLC status changes
    UCHAR uchReserved3[8];          // reserved
    UCHAR cLinkStationsAvail;       // total number of available link stations
} LLC_DLC_OPEN_SAP_PARMS, *PLLC_DLC_OPEN_SAP_PARMS;

typedef struct {
    USHORT usSapStationId;          // SAP station id
    USHORT usLinkStationId;         // Link station id
    UCHAR uchT1;                    // response timer
    UCHAR uchT2;                    // aknowledgment timer
    UCHAR uchTi;                    // inactivity timer
    UCHAR uchMaxOut;                // max tramists without ack
    UCHAR uchMaxIn;                 // max receives without ack
    UCHAR uchMaxOutIncr;            // dynamic window increment value
    UCHAR uchMaxRetryCnt;           // N2 value (retries)
    UCHAR uchRemoteSap;             // remote SAP of the link
    USHORT usMaxI_Field;            // max I field length
    UCHAR uchAccessPriority;        // token ring access priority
    PVOID pRemoteNodeAddress;       // pointer to the destination address
} LLC_DLC_OPEN_STATION_PARMS, *PLLC_DLC_OPEN_STATION_PARMS;

#define LLC_INCREASE_LINK_STATIONS  0
#define LLC_DECREASE_LINK_STATIONS  0x80

typedef struct {
    USHORT usStationId;             // ID of affected SAP
    UCHAR uchOption;                // increase of decrease indicator
    UCHAR uchStationCount;
    UCHAR uchStationsAvailOnAdapter;
    UCHAR uchStationsAvailOnSap;
    UCHAR uchTotalStationsOnAdapter;
    UCHAR uchTotalStationsOnSap;
} LLC_DLC_REALLOCATE_PARMS, *PLLC_DLC_REALLOCATE_PARMS;

typedef struct {
    USHORT usStationId;             // SAP station ID
    USHORT cBufferThreshold;        // SAP buffer pool Threshold number
    PVOID AlertEvent;               // alerting event
} LLC_DLC_SET_THRESHOLD_PARMS, *PLLC_DLC_SET_THRESHOLD_PARMS;

typedef struct {
    PVOID TraceBuffer;              // trace buffer
    ULONG TraceBufferSize;          // trace buffer size
    ULONG TraceFlags;               // various trace flags
} LLC_TRACE_INITIALIZE_PARMS, *PLLC_TRACE_INITIALIZE_PARMS;

#define LLC_DLC_RESET_STATISTICS    0x80
#define LLC_DLC_READ_STATISTICS     0

typedef struct {
    ULONG cTransmittedFrames;
    ULONG cReceivedFrames;
    ULONG cDiscardedFrames;
    ULONG cDataLost;
    USHORT cBuffersAvailable;
} DLC_SAP_LOG, *PDLC_SAP_LOG;

typedef struct {
    USHORT cI_FramesTransmitted;
    USHORT cI_FramesReceived;
    UCHAR cI_FrameReceiveErrors;
    UCHAR cI_FrameTransmissionErrors;
    USHORT cT1_ExpirationCount;     // Note: not OUT data xfer mode
    UCHAR uchLastCmdRespReceived;
    UCHAR uchLastCmdRespTransmitted;
    UCHAR uchPrimaryState;
    UCHAR uchSecondaryState;
    UCHAR uchSendStateVariable;
    UCHAR uchReceiveStateVariable;
    UCHAR uchLastNr;                // last received NR
    UCHAR cbLanHeader;
    UCHAR auchLanHeader[32];
} DLC_LINK_LOG, *PDLC_LINK_LOG;

typedef union {
    DLC_SAP_LOG Sap;
    DLC_LINK_LOG Link;
} LLC_DLC_LOG_BUFFER, *PLLC_DLC_LOG_BUFFER;

typedef struct {
    USHORT usStationId;             // ID of a SAP or a link station
    USHORT cbLogBufSize;            //
    PLLC_DLC_LOG_BUFFER pLogBuf;    // offset to the log buffer
    USHORT usActLogLength;          // length of returned log
    UCHAR uchOptions;               // command options (bit7 resets log params)
} LLC_DLC_STATISTICS_PARMS, *PLLC_DLC_STATISTICS_PARMS;

typedef struct {
    USHORT usBringUps;              // Token Ring adapter bring up error code
    UCHAR Reserved[30];             // everything else specific to DOS or OS/2
} LLC_DIR_INITIALIZE_PARMS, *PLLC_DIR_INITIALIZE_PARMS;

typedef struct {
    USHORT usOpenErrorCode;         // open adapter errors detected
    USHORT usOpenOptions;           // various options
    UCHAR auchNodeAddress[6];       // adapters LAN address
    UCHAR auchGroupAddress[4];      // multicast address added in the open
    UCHAR auchFunctionalAddress[4]; // added token ring functional address
    USHORT usReserved1;
    USHORT usReserved2;
    USHORT usMaxFrameSize;          // maximum frame size defined in NDIS
    USHORT usReserved3[4];
    USHORT usBringUps;              // Bring up errors, TR only
    USHORT InitWarnings;
    USHORT usReserved4[3];
} LLC_ADAPTER_OPEN_PARMS, *PLLC_ADAPTER_OPEN_PARMS;

typedef struct {
    UCHAR uchDlcMaxSaps;
    UCHAR uchDlcMaxStations;
    UCHAR uchDlcMaxGroupSaps;
    UCHAR uchDlcMaxGroupMembers;
    UCHAR uchT1_TickOne;            // Short timer interval (for 1 - 5)
    UCHAR uchT2_TickOne;
    UCHAR uchTi_TickOne;
    UCHAR uchT1_TickTwo;            // Long timer interval (for 6 - 10)
    UCHAR uchT2_TickTwo;
    UCHAR uchTi_TickTwo;
} LLC_DLC_PARMS, *PLLC_DLC_PARMS;

//
// The ethernet mode selects the LAN header format of ethernet. SNA
// applications should use the default parameter, that has been defined in the
// registry. The applications using connectionless DLC services should select
// the ethernet LLC LAN header format they are using (usually 802.3)
//

typedef enum {
    LLC_ETHERNET_TYPE_DEFAULT,      // use the parameter value set in registry
    LLC_ETHERNET_TYPE_AUTO,         // automatic header type selction for links
    LLC_ETHERNET_TYPE_802_3,        // use always 802.3 lan headers
    LLC_ETHERNET_TYPE_DIX           // use always LLC on DIX SNA type.
} LLC_ETHERNET_TYPE, *PLLC_ETHERNET_TYPE;

typedef struct {
    PVOID hBufferPool;
    PVOID pSecurityDescriptor;
    LLC_ETHERNET_TYPE LlcEthernetType;
} LLC_EXTENDED_ADAPTER_PARMS, *PLLC_EXTENDED_ADAPTER_PARMS;

typedef struct {
    PLLC_ADAPTER_OPEN_PARMS pAdapterParms;      // ADAPTER_PARMS
    PLLC_EXTENDED_ADAPTER_PARMS pExtendedParms; // DIRECT_PARMS
    PLLC_DLC_PARMS pDlcParms;                   // DLC_PARMS
    PVOID pReserved1;                           // NCB_PARMS
} LLC_DIR_OPEN_ADAPTER_PARMS, *PLLC_DIR_OPEN_ADAPTER_PARMS;

typedef struct {
    UCHAR auchMulticastAddress[6];  // 48 bit multicast address
} LLC_DIR_MULTICAST_ADDRESS, *PLLC_DIR_MULTICAST_ADDRESS;

#define LLC_DIRECT_OPTIONS_ALL_MACS 0x1880

typedef struct {
    USHORT Reserved[4];
    USHORT usOpenOptions;
    USHORT usEthernetType;
    ULONG ulProtocolTypeMask;
    ULONG ulProtocolTypeMatch;
    USHORT usProtocolTypeOffset;
} LLC_DIR_OPEN_DIRECT_PARMS, *PLLC_DIR_OPEN_DIRECT_PARMS;

typedef struct {
    UCHAR cLineError;
    UCHAR cInternalError;
    UCHAR cBurstError;
    UCHAR cAC_Error;
    UCHAR cAbortDelimiter;
    UCHAR uchReserved1;
    UCHAR cLostFrame;
    UCHAR cReceiveCongestion;
    UCHAR cFrameCopiedError;
    UCHAR cFrequencyError;
    UCHAR cTokenError;
    UCHAR uchReserved2;
    UCHAR uchReserved3;
    UCHAR uchReserved4;
} LLC_ADAPTER_LOG_TR, *PLLC_ADAPTER_LOG_TR;

typedef struct {
    UCHAR cCRC_Error;
    UCHAR uchReserved1;
    UCHAR cAlignmentError;
    UCHAR uchReserved2;
    UCHAR cTransmitError;
    UCHAR uchReserved3;
    UCHAR cCollisionError;
    UCHAR cReceiveCongestion;
    UCHAR uchReserved[6];
} LLC_ADAPTER_LOG_ETH, *PLLC_ADAPTER_LOG_ETH;

typedef union {
    LLC_ADAPTER_LOG_TR Tr;
    LLC_ADAPTER_LOG_ETH Eth;
} LLC_ADAPTER_LOG, *PLLC_ADAPTER_LOG;

typedef struct {
    ULONG cTransmittedFrames;
    ULONG cReceivedFrames;
    ULONG cDiscardedFrames;
    ULONG cDataLost;
    USHORT cBuffersAvailable;
} LLC_DIRECT_LOG, *PLLC_DIRECT_LOG;

typedef union {
    LLC_ADAPTER_LOG Adapter;
    LLC_DIRECT_LOG Dir;

    struct {
        LLC_ADAPTER_LOG Adapter;
        LLC_DIRECT_LOG Dir;
    } both;

} LLC_DIR_READ_LOG_BUFFER, *PLLC_DIR_READ_LOG_BUFFER;

#define LLC_DIR_READ_LOG_ADAPTER    0
#define LLC_DIR_READ_LOG_DIRECT     1
#define LLC_DIR_READ_LOG_BOTH       2

typedef struct {
    USHORT usTypeId;                    // 0=adapter, 1=direct, 2=both logs
    USHORT cbLogBuffer;                 // size of log buffer
    PLLC_DIR_READ_LOG_BUFFER pLogBuffer;// pointer to log buffer
    USHORT cbActualLength;              // returned size of log buffer
} LLC_DIR_READ_LOG_PARMS, *PLLC_DIR_READ_LOG_PARMS;

typedef struct {
    ULONG ulAdapterCheckFlag;
    ULONG ulNetworkStatusFlag;
    ULONG ulPcErrorFlag;
    ULONG ulSystemActionFlag;
} LLC_DIR_SET_EFLAG_PARMS, *PLLC_DIR_SET_EFLAG_PARMS;

#define LLC_ADAPTER_ETHERNET    0x0010
#define LLC_ADAPTER_TOKEN_RING  0x0040

typedef struct {
    UCHAR auchPermanentAddress[6];  // permanent encoded address
    UCHAR auchNodeAddress[6];       // adapter's network address
    UCHAR auchGroupAddress[4];      // adapter's group address
    UCHAR auchFunctAddr[4];         // adapter's functional address
    UCHAR uchMaxSap;                // maximum allowable SAP
    UCHAR uchOpenSaps;              // number of currently open saps
    UCHAR uchMaxStations;           // max number of stations (always 253)
    UCHAR uchOpenStation;           // number of open stations (only up to 253)
    UCHAR uchAvailStations;         // number of available stations (always 253)
    UCHAR uchAdapterConfig;         // adapter configuration flags
    UCHAR auchReserved1[10];        // microcode level
    ULONG ulReserved1;
    ULONG ulReserved2;
    ULONG ulMaxFrameLength;         // maximum frame length (only in Windows/Nt)
    USHORT usLastNetworkStatus;
    USHORT usAdapterType;           // THIS BYTE IS NOT USED IN DOS DLC !!!
} LLC_DIR_STATUS_PARMS, *PLLC_DIR_STATUS_PARMS;


#define LLC_OPTION_READ_STATION 0
#define LLC_OPTION_READ_SAP     1
#define LLC_OPTION_READ_ALL     2

#define LLC_EVENT_SYSTEM_ACTION         0x0040
#define LLC_EVENT_NETWORK_STATUS        0x0020
#define LLC_EVENT_CRITICAL_EXCEPTION    0x0010
#define LLC_EVENT_STATUS_CHANGE         0x0008
#define LLC_EVENT_RECEIVE_DATA          0x0004
#define LLC_EVENT_TRANSMIT_COMPLETION   0x0002
#define LLC_EVENT_COMMAND_COMPLETION    0x0001
#define LLC_READ_ALL_EVENTS             0x007F

//
// LLC_STATUS_CHANGE indications
// The returned status value may be an inclusive-OR of several flags
//

#define LLC_INDICATE_LINK_LOST              0x8000
#define LLC_INDICATE_DM_DISC_RECEIVED       0x4000
#define LLC_INDICATE_FRMR_RECEIVED          0x2000
#define LLC_INDICATE_FRMR_SENT              0x1000
#define LLC_INDICATE_RESET                  0x0800
#define LLC_INDICATE_CONNECT_REQUEST        0x0400
#define LLC_INDICATE_REMOTE_BUSY            0x0200
#define LLC_INDICATE_REMOTE_READY           0x0100
#define LLC_INDICATE_TI_TIMER_EXPIRED       0x0080
#define LLC_INDICATE_DLC_COUNTER_OVERFLOW   0x0040
#define LLC_INDICATE_ACCESS_PRTY_LOWERED    0x0020
#define LLC_INDICATE_LOCAL_STATION_BUSY     0x0001

typedef struct {
    USHORT usStationId;
    UCHAR uchOptionIndicator;
    UCHAR uchEventSet;
    UCHAR uchEvent;
    UCHAR uchCriticalSubset;
    ULONG ulNotificationFlag;

    union {

        struct {
            USHORT usCcbCount;
            PLLC_CCB pCcbCompletionList;
            USHORT usBufferCount;
            PLLC_BUFFER pFirstBuffer;
            USHORT usReceivedFrameCount;
            PLLC_BUFFER pReceivedFrame;
            USHORT usEventErrorCode;
            USHORT usEventErrorData[3];
        } Event;

        struct {
            USHORT usStationId;
            USHORT usDlcStatusCode;
            UCHAR uchFrmrData[5];
            UCHAR uchAccessPritority;
            UCHAR uchRemoteNodeAddress[6];
            UCHAR uchRemoteSap;
            UCHAR uchReserved;
            USHORT usUserStatusValue;
        } Status;

    } Type;

} LLC_READ_PARMS, *PLLC_READ_PARMS;

//
// This data structure gives the best performance in Windows/Nt: The DLC driver
// must copy the CCB and the parameter table. If the driver knows that the
// parameter table is concatenated to the CCB, it can copy both structures at
// once. NOTE: The pointer to the parameter table MUST still be present in the
// CCB
//

typedef struct {
    LLC_CCB Ccb;
    LLC_READ_PARMS Parms;
} LLC_READ_COMMAND, *PLLC_READ_COMMAND;

//
// New receive types for direct stations, these types are ignored if the direct
// station was opened with a specific ethernet type
//

#define LLC_DIR_RCV_ALL_TR_FRAMES       0
#define LLC_DIR_RCV_ALL_MAC_FRAMES      1
#define LLC_DIR_RCV_ALL_8022_FRAMES     2
#define LLC_DIR_RCV_ALL_FRAMES          4
#define LLC_DIR_RCV_ALL_ETHERNET_TYPES  5

#define LLC_CONTIGUOUS_MAC      0x80
#define LLC_CONTIGUOUS_DATA     0x40
#define LLC_NOT_CONTIGUOUS_DATA 0x00

//
// LLC_BREAK (0x20) is not supported by Windows/Nt
//

#define LLC_RCV_READ_INDIVIDUAL_FRAMES  0
#define LLC_RCV_CHAIN_FRAMES_ON_LINK    1
#define LLC_RCV_CHAIN_FRAMES_ON_SAP     2

typedef struct {
    USHORT usStationId;             // SAP, link station or direct id
    USHORT usUserLength;            // length of user data in buffer header
    ULONG ulReceiveFlag;            // the received data handler
    PLLC_BUFFER pFirstBuffer;       // first buffer in the pool
    UCHAR uchOptions;               // defines how the frame is received
    UCHAR auchReserved1[3];
    UCHAR uchRcvReadOption;         // defines if rcv frames are chained
} LLC_RECEIVE_PARMS, *PLLC_RECEIVE_PARMS;

#define LLC_CHAIN_XMIT_COMMANDS_ON_LINK 0
#define LLC_COMPLETE_SINGLE_XMIT_FRAME  1
#define LLC_CHAIN_XMIT_COMMANDS_ON_SAP  2

typedef struct {
    USHORT usStationId;             // SAP, link station or direct id
    UCHAR uchTransmitFs;            // token-ring frame status
    UCHAR uchRemoteSap;             // remote destination SAP
    PLLC_XMIT_BUFFER pXmitQueue1;   // first link list of frame segments
    PLLC_XMIT_BUFFER pXmitQueue2;   // another segment list returuned to pool
    USHORT cbBuffer1;               // length of buffer 1
    USHORT cbBuffer2;               // length of buffer 2
    PVOID pBuffer1;                 // yet another segment
    PVOID pBuffer2;                 // this is the last segment of frame
    UCHAR uchXmitReadOption;        // defines completion event for READ
} LLC_TRANSMIT_PARMS,  *PLLC_TRANSMIT_PARMS;

#define LLC_FIRST_DATA_SEGMENT  0x01
#define LLC_NEXT_DATA_SEGMENT   0x02

typedef struct {
    UCHAR eSegmentType;             // defines if first or next segment of frame
    UCHAR boolFreeBuffer;           // if set, this buffer is released to pool
    USHORT cbBuffer;                // length of this buffer
    PVOID pBuffer;
} LLC_TRANSMIT_DESCRIPTOR, *PLLC_TRANSMIT_DESCRIPTOR;

//
// The frames types returned in the first receive buffer or used with the
// TRANSMIT_FRAMES command.  A direct station may also send only ethernet
// frames. The ethernet types are only for transmit. Types 0x0019 - 0x05DC
// are reserved
//

enum _LLC_FRAME_TYPES {                     // Purpose:
    LLC_DIRECT_TRANSMIT         = 0x0000,   // transmit
    LLC_DIRECT_MAC              = 0x0002,   // receive
    LLC_I_FRAME                 = 0x0004,   // receive & transmit
    LLC_UI_FRAME                = 0x0006,   // receive & transmit
    LLC_XID_COMMAND_POLL        = 0x0008,   // receive & transmit
    LLC_XID_COMMAND_NOT_POLL    = 0x000A,   // receive & transmit
    LLC_XID_RESPONSE_FINAL      = 0x000C,   // receive & transmit
    LLC_XID_RESPONSE_NOT_FINAL  = 0x000E,   // receive & transmit
    LLC_TEST_RESPONSE_FINAL     = 0x0010,   // receive & transmit
    LLC_TEST_RESPONSE_NOT_FINAL = 0x0012,   // receive & transmit
    LLC_DIRECT_8022             = 0x0014,   // receive (direct station)
    LLC_TEST_COMMAND_POLL       = 0x0016,   // transmit
    LLC_DIRECT_ETHERNET_TYPE    = 0x0018,   // receive (direct station)
    LLC_LAST_FRAME_TYPE         = 0x001a,   // reserved
    LLC_FIRST_ETHERNET_TYPE     = 0x05DD    // transmit (>)
};

typedef struct {
    LLC_CCB Ccb;                    // use this as transmit CCB
    USHORT usStationId;
    USHORT usFrameType;             // DLC frame or ethernet type
    UCHAR uchRemoteSap;             // used with UI, TEST, XID frames
    UCHAR uchXmitReadOption;
    UCHAR Reserved2[2];
    ULONG cXmitBufferCount;
    LLC_TRANSMIT_DESCRIPTOR aXmitBuffer[1];
} LLC_TRANSMIT2_COMMAND, *PLLC_TRANSMIT2_COMMAND;

//
// LLC_TRANSMIT2_VAR_PARMS - this macro allocates space for variable length
// descriptor array, eg: LLC_TRANSMIT2_VAR_PARMS(8) TransmitParms;
//

#define LLC_TRANSMIT2_VAR_PARMS(a)\
struct {\
    LLC_CCB Ccb;\
    USHORT usStationId;\
    USHORT usFrameType;\
    UCHAR uchRemoteSap;\
    UCHAR uchXmitReadOption;\
    UCHAR uchReserved2[2];\
    ULONG cXmitBufferCount;\
    LLC_TRANSMIT_DESCRIPTOR XmitBuffer[(a)];\
}

//
// LLC_PARMS - All CCB parameter tables can be referred to using this union
//

union _LLC_PARMS {
    LLC_BUFFER_FREE_PARMS BufferFree;
    LLC_BUFFER_GET_PARMS BufferGet;
    LLC_DLC_CONNECT_PARMS DlcConnectStation;
    LLC_DLC_MODIFY_PARMS DlcModify;
    LLC_DLC_OPEN_SAP_PARMS DlcOpenSap;
    LLC_DLC_OPEN_STATION_PARMS DlcOpenStation;
    LLC_DLC_REALLOCATE_PARMS DlcReallocate;
    LLC_DLC_SET_THRESHOLD_PARMS DlcSetThreshold;
    LLC_DLC_STATISTICS_PARMS DlcStatistics;
    LLC_DIR_INITIALIZE_PARMS DirInitialize;
    LLC_DIR_OPEN_ADAPTER_PARMS DirOpenAdapter;
    LLC_DIR_OPEN_DIRECT_PARMS DirOpenDirect;
    LLC_DIR_READ_LOG_PARMS DirReadLog;
    LLC_DIR_SET_EFLAG_PARMS DirSetEventFlag;
    LLC_DIR_STATUS_PARMS DirStatus;
    LLC_READ_PARMS Read;
    LLC_RECEIVE_PARMS Receive;
    LLC_TRANSMIT_PARMS Transmit;
    LLC_TRANSMIT2_COMMAND Transmit2;
    LLC_TRACE_INITIALIZE_PARMS TraceInitialize;
};

//
// LLC_STATUS - enumerates the return codes which appear in the CCB uchDlcStatus
// field
//

typedef enum _LLC_STATUS {
    LLC_STATUS_SUCCESS                      = 0x00,
    LLC_STATUS_INVALID_COMMAND              = 0x01,
    LLC_STATUS_DUPLICATE_COMMAND            = 0x02,
    LLC_STATUS_ADAPTER_OPEN                 = 0x03,
    LLC_STATUS_ADAPTER_CLOSED               = 0x04,
    LLC_STATUS_PARAMETER_MISSING            = 0x05,
    LLC_STATUS_INVALID_OPTION               = 0x06,
    LLC_STATUS_COMMAND_CANCELLED_FAILURE    = 0x07,
    LLC_STATUS_ACCESS_DENIED                = 0x08,   // not used in Windows/Nt
    LLC_STATUS_ADAPTER_NOT_INITIALIZED      = 0x09,   // not used in Windows/Nt
    LLC_STATUS_CANCELLED_BY_USER            = 0x0A,
    LLC_STATUS_COMMAND_CANCELLED_CLOSED     = 0x0B,   // not used in Windows/Nt
    LLC_STATUS_SUCCESS_NOT_OPEN             = 0x0C,
    LLC_STATUS_TIMER_ERROR                  = 0x11,
    LLC_STATUS_NO_MEMORY                    = 0x12,
    LLC_STATUS_INVALID_LOG_ID               = 0x13,   // not used in Windows/Nt
    LLC_STATUS_LOST_LOG_DATA                = 0x15,
    LLC_STATUS_BUFFER_SIZE_EXCEEDED         = 0x16,
    LLC_STATUS_INVALID_BUFFER_LENGTH        = 0x18,
    LLC_STATUS_INADEQUATE_BUFFERS           = 0x19,
    LLC_STATUS_USER_LENGTH_TOO_LARGE        = 0x1A,
    LLC_STATUS_INVALID_PARAMETER_TABLE      = 0x1B,
    LLC_STATUS_INVALID_POINTER_IN_CCB       = 0x1C,
    LLC_STATUS_INVALID_ADAPTER              = 0x1D,
    LLC_STATUS_LOST_DATA_NO_BUFFERS         = 0x20,
    LLC_STATUS_LOST_DATA_INADEQUATE_SPACE   = 0x21,
    LLC_STATUS_TRANSMIT_ERROR_FS            = 0x22,
    LLC_STATUS_TRANSMIT_ERROR               = 0x23,
    LLC_STATUS_UNAUTHORIZED_MAC             = 0x24,   // not used in Windows/Nt
    LLC_STATUS_MAX_COMMANDS_EXCEEDED        = 0x25,   // not used in Windows/Nt
    LLC_STATUS_LINK_NOT_TRANSMITTING        = 0x27,
    LLC_STATUS_INVALID_FRAME_LENGTH         = 0x28,
    LLC_STATUS_INADEQUATE_RECEIVE           = 0x30,   // not used in Windows/Nt
    LLC_STATUS_INVALID_NODE_ADDRESS         = 0x32,
    LLC_STATUS_INVALID_RCV_BUFFER_LENGTH    = 0x33,
    LLC_STATUS_INVALID_XMIT_BUFFER_LENGTH   = 0x34,
    LLC_STATUS_INVALID_STATION_ID           = 0x40,
    LLC_STATUS_LINK_PROTOCOL_ERROR          = 0x41,
    LLC_STATUS_PARMETERS_EXCEEDED_MAX       = 0x42,
    LLC_STATUS_INVALID_SAP_VALUE            = 0x43,
    LLC_STATUS_INVALID_ROUTING_INFO         = 0x44,
    LLC_STATUS_RESOURCES_NOT_AVAILABLE      = 0x46,   // not used in Windows/Nt
    LLC_STATUS_LINK_STATIONS_OPEN           = 0x47,
    LLC_STATUS_INCOMPATIBLE_COMMANDS        = 0x4A,
    LLC_STATUS_OUTSTANDING_COMMANDS         = 0x4C,   // not used in Windows/Nt
    LLC_STATUS_CONNECT_FAILED               = 0x4D,
    LLC_STATUS_INVALID_REMOTE_ADDRESS       = 0x4F,
    LLC_STATUS_CCB_POINTER_FIELD            = 0x50,
    LLC_STATUS_INVALID_APPLICATION_ID       = 0x52,   // not used in Windows/Nt
    LLC_STATUS_NO_SYSTEM_PROCESS            = 0x56,   // not used in Windows/Nt
    LLC_STATUS_INADEQUATE_LINKS             = 0x57,
    LLC_STATUS_INVALID_PARAMETER_1          = 0x58,
    LLC_STATUS_DIRECT_STATIONS_NOT_ASSIGNED = 0x5C,
    LLC_STATUS_DEVICE_DRIVER_NOT_INSTALLED  = 0x5d,
    LLC_STATUS_ADAPTER_NOT_INSTALLED        = 0x5e,
    LLC_STATUS_CHAINED_DIFFERENT_ADAPTERS   = 0x5f,
    LLC_STATUS_INIT_COMMAND_STARTED         = 0x60,
    LLC_STATUS_TOO_MANY_USERS               = 0x61,   // not used in Windows/Nt
    LLC_STATUS_CANCELLED_BY_SYSTEM_ACTION   = 0x62,
    LLC_STATUS_DIR_STATIONS_NOT_AVAILABLE   = 0x63,   // not used in Windows/Nt
    LLC_STATUS_NO_GDT_SELECTORS             = 0x65,
    LLC_STATUS_MEMORY_LOCK_FAILED           = 0x69,

    //
    // New NT DLC specific error codes begin from 0x80
    // These error codes are for new Windows/Nt DLC apps.
    //

    LLC_STATUS_INVALID_BUFFER_ADDRESS       = 0x80,
    LLC_STATUS_BUFFER_ALREADY_RELEASED      = 0x81,
    LLC_STATUS_BIND_ERROR                   = 0xA0,   // not used in Windows/Nt
    LLC_STATUS_INVALID_VERSION              = 0xA1,
    LLC_STATUS_NT_ERROR_STATUS              = 0xA2,
    LLC_STATUS_PENDING                      = 0xFF
} LLC_STATUS;

#define LLC_STATUS_MAX_ERROR 0xFF

//
// ACSLAN_STATUS - status codes which are returned from AcsLan
//

typedef enum {
    ACSLAN_STATUS_COMMAND_ACCEPTED = 0,
    ACSLAN_STATUS_INVALID_CCB_POINTER = 1,
    ACSLAN_STATUS_CCB_IN_ERROR = 2,
    ACSLAN_STATUS_CHAINED_CCB_IN_ERROR = 3,
    ACSLAN_STATUS_SYSTEM_ERROR = 4,
    ACSLAN_STATUS_SYSTEM_STATUS = 5,
    ACSLAN_STATUS_INVALID_COMMAND = 6
} ACSLAN_STATUS;

//
// prototypes
//

ACSLAN_STATUS
APIENTRY
AcsLan(
    IN OUT PLLC_CCB pCcb,
    OUT PLLC_CCB* ppBadCcb
    );

#ifdef __cplusplus
}
#endif

#endif // _DLCAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\errno.h ===
/***
*errno.h - system wide error numbers (set by system calls)
*
*	Copyright (c) 1985-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines the system-wide error numbers (set by
*	system calls).	Conforms to the XENIX standard.  Extended
*	for compatibility with Uniforum standard.
*	[System V]
*
*       [Public]
*
****/

#ifndef _INC_ERRNO
#define _INC_ERRNO

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* declare reference to errno */

#if (defined(_MT) || defined(_DLL)) && (!defined(_M_MPPC) && !defined(_M_M68K))
_CRTIMP extern int * __cdecl _errno(void);
#define errno	(*_errno())
#else	/* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;
#endif	/* _MT || _DLL */

/* Error Codes */

#define EPERM		1
#define ENOENT		2
#define ESRCH		3
#define EINTR		4
#define EIO		5
#define ENXIO		6
#define E2BIG		7
#define ENOEXEC 	8
#define EBADF		9
#define ECHILD		10
#define EAGAIN		11
#define ENOMEM		12
#define EACCES		13
#define EFAULT		14
#define EBUSY		16
#define EEXIST		17
#define EXDEV		18
#define ENODEV		19
#define ENOTDIR 	20
#define EISDIR		21
#define EINVAL		22
#define ENFILE		23
#define EMFILE		24
#define ENOTTY		25
#define EFBIG		27
#define ENOSPC		28
#define ESPIPE		29
#define EROFS		30
#define EMLINK		31
#define EPIPE		32
#define EDOM		33
#define ERANGE		34
#define EDEADLK		36
#define ENAMETOOLONG	38
#define ENOLCK		39
#define ENOSYS		40
#define ENOTEMPTY	41
#define EILSEQ		42

/*
 * Support EDEADLOCK for compatibiity with older MS-C versions.
 */
#define EDEADLOCK	EDEADLK

#ifdef __cplusplus
}
#endif

#endif	/* _INC_ERRNO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\fpieee.h ===
/***
*fpieee.h - Definitions for floating point IEEE exception handling
*
*	Copyright (c) 1991-1995, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*	This file contains constant and type definitions for handling
*	floating point exceptions [ANSI/IEEE std. 754]
*
*       [Public]
*
****/

#ifndef _INC_FPIEEE
#define _INC_FPIEEE

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifndef __assembler	/* MIPS ONLY: Protect from assembler */

#ifdef	_MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif	/* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/*
 * Define floating point IEEE compare result values.
 */

typedef enum {
    _FpCompareEqual,
    _FpCompareGreater,
    _FpCompareLess,
    _FpCompareUnordered
} _FPIEEE_COMPARE_RESULT;

/*
 * Define floating point format and result precision values.
 */

typedef enum {
    _FpFormatFp32,
    _FpFormatFp64,
    _FpFormatFp80,
    _FpFormatFp128,
    _FpFormatI16,
    _FpFormatI32,
    _FpFormatI64,
    _FpFormatU16,
    _FpFormatU32,
    _FpFormatU64,
    _FpFormatBcd80,
    _FpFormatCompare,
    _FpFormatString
} _FPIEEE_FORMAT;

/*
 * Define operation code values.
 */

typedef enum {
    _FpCodeUnspecified,
    _FpCodeAdd,
    _FpCodeSubtract,
    _FpCodeMultiply,
    _FpCodeDivide,
    _FpCodeSquareRoot,
    _FpCodeRemainder,
    _FpCodeCompare,
    _FpCodeConvert,
    _FpCodeRound,
    _FpCodeTruncate,
    _FpCodeFloor,
    _FpCodeCeil,
    _FpCodeAcos,
    _FpCodeAsin,
    _FpCodeAtan,
    _FpCodeAtan2,
    _FpCodeCabs,
    _FpCodeCos,
    _FpCodeCosh,
    _FpCodeExp,
    _FpCodeFabs,
    _FpCodeFmod,
    _FpCodeFrexp,
    _FpCodeHypot,
    _FpCodeLdexp,
    _FpCodeLog,
    _FpCodeLog10,
    _FpCodeModf,
    _FpCodePow,
    _FpCodeSin,
    _FpCodeSinh,
    _FpCodeTan,
    _FpCodeTanh,
    _FpCodeY0,
    _FpCodeY1,
    _FpCodeYn,
    _FpCodeLogb,
    _FpCodeNextafter,
    _FpCodeNegate

} _FP_OPERATION_CODE;

#endif	/* #ifndef __assembler */

/*
 * Define rounding modes.
 */

#ifndef __assembler	/* MIPS ONLY: Protect from assembler */

typedef enum {
    _FpRoundNearest,
    _FpRoundMinusInfinity,
    _FpRoundPlusInfinity,
    _FpRoundChopped
} _FPIEEE_ROUNDING_MODE;

typedef enum {
    _FpPrecisionFull,
    _FpPrecision53,
    _FpPrecision24
} _FPIEEE_PRECISION;


/*
 * Define floating point context record
 */

typedef float		_FP32;
typedef double		_FP64;
typedef short		_I16;
typedef int		_I32;
typedef unsigned short	_U16;
typedef unsigned int	_U32;


typedef struct {
    unsigned short W[5];
} _FP80;

typedef struct {
    unsigned long W[4];
} _FP128;

typedef struct {
    unsigned long W[2];
} _I64;

typedef struct {
    unsigned long W[2];
} _U64;

typedef struct {
    unsigned short W[5];
} _BCD80;


typedef struct {
    union {
	_FP32	     Fp32Value;
	_FP64	     Fp64Value;
	_FP80	     Fp80Value;
	_FP128	     Fp128Value;
	_I16	     I16Value;
	_I32	     I32Value;
	_I64	     I64Value;
	_U16	     U16Value;
	_U32	     U32Value;
	_U64	     U64Value;
	_BCD80	     Bcd80Value;
	char	     *StringValue;
	int	     CompareValue;
    } Value;

    unsigned int OperandValid : 1;
    unsigned int Format : 4;

} _FPIEEE_VALUE;


typedef struct {
    unsigned int Inexact : 1;
    unsigned int Underflow : 1;
    unsigned int Overflow : 1;
    unsigned int ZeroDivide : 1;
    unsigned int InvalidOperation : 1;
} _FPIEEE_EXCEPTION_FLAGS;


typedef struct {
    unsigned int RoundingMode : 2;
    unsigned int Precision : 3;
    unsigned int Operation :12;
    _FPIEEE_EXCEPTION_FLAGS Cause;
    _FPIEEE_EXCEPTION_FLAGS Enable;
    _FPIEEE_EXCEPTION_FLAGS Status;
    _FPIEEE_VALUE Operand1;
    _FPIEEE_VALUE Operand2;
    _FPIEEE_VALUE Result;
} _FPIEEE_RECORD;


struct _EXCEPTION_POINTERS;

/*
 * Floating point IEEE exception filter routine
 */

_CRTIMP int __cdecl _fpieee_flt(
	unsigned long,
	struct _EXCEPTION_POINTERS *,
	int (__cdecl *)(_FPIEEE_RECORD *)
	);

#ifdef __cplusplus
}
#endif

#ifdef	_MSC_VER
#pragma pack(pop)
#endif	/* _MSC_VER */
#endif	/* #ifndef __assembler */

#endif	/* _INC_FPIEEE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\excpt.h ===
/***
*excpt.h - defines exception values, types and routines
*
*       Copyright (c) 1990-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the definitions and prototypes for the compiler-
*       dependent intrinsics, support functions and keywords which implement
*       the structured exception handling extensions.
*
*       [Public]
*
****/

#ifndef _INC_EXCPT
#define _INC_EXCPT

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef	_MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif	/* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if _MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if _MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else   /* ndef _NTSDK */
/* current definition */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _NTSDK */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/*
 * Exception disposition return values.
 */
typedef enum _EXCEPTION_DISPOSITION {
    ExceptionContinueExecution,
    ExceptionContinueSearch,
    ExceptionNestedException,
    ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION;


/*
 * Prototype for SEH support function.
 */

#ifdef  _M_IX86

/*
 * Declarations to keep MS C 8 (386/486) compiler happy
 */
struct _EXCEPTION_RECORD;
struct _CONTEXT;

EXCEPTION_DISPOSITION __cdecl _except_handler (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void * EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void * DispatcherContext
    );

#elif   defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC)

/*
 * Declarations to keep MIPS, ALPHA, and PPC compiler happy
 */
typedef struct _EXCEPTION_POINTERS *Exception_info_ptr;
struct _EXCEPTION_RECORD;
struct _CONTEXT;
struct _DISPATCHER_CONTEXT;


_CRTIMP EXCEPTION_DISPOSITION __C_specific_handler (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void *EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    struct _DISPATCHER_CONTEXT *DispatcherContext
    );

#endif


/*
 * Keywords and intrinsics for SEH
 */

#ifdef  _MSC_VER

#if defined(_NTSDK) && !defined(__cplusplus)
#define try                         __try
#define except                      __except
#define finally                     __finally
#define leave                       __leave
#endif  /* _NTSDK */
#define GetExceptionCode            _exception_code
#define exception_code              _exception_code
#define GetExceptionInformation     (struct _EXCEPTION_POINTERS *)_exception_info
#define exception_info              (struct _EXCEPTION_POINTERS *)_exception_info
#define AbnormalTermination         _abnormal_termination
#define abnormal_termination        _abnormal_termination

unsigned long __cdecl _exception_code(void);
void *        __cdecl _exception_info(void);
int           __cdecl _abnormal_termination(void);

#endif


/*
 * Legal values for expression in except().
 */

#define EXCEPTION_EXECUTE_HANDLER       1
#define EXCEPTION_CONTINUE_SEARCH       0
#define EXCEPTION_CONTINUE_EXECUTION    -1



#ifdef __cplusplus
}
#endif

#ifdef	_MSC_VER
#pragma pack(pop)
#endif	/* _MSC_VER */

#endif	/* _INC_EXCPT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\fstream.h ===
/***
*fstream.h - definitions/declarations for filebuf and fstream classes
*
*	Copyright (c) 1991-1995, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the classes, values, macros, and functions
*	used by the filebuf and fstream classes.
*	[AT&T C++]
*
*       [Public]
*
****/

#ifdef __cplusplus

#ifndef _INC_FSTREAM
#define _INC_FSTREAM

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef	_MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)
#endif	// _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


#include <iostream.h>

#ifdef _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)	// use this to reenable, if desired
#endif	// _MSC_VER

typedef int filedesc;

class _CRTIMP filebuf : public streambuf {
public:
static	const int	openprot;	// default share/prot mode for open

// optional share values for 3rd argument (prot) of open or constructor
static	const int	sh_none;	// exclusive mode no sharing
static	const int	sh_read;	// allow read sharing
static	const int	sh_write;	// allow write sharing
// use (sh_read | sh_write) to allow both read and write sharing

// options for setmode member function
static	const int	binary;
static	const int	text;

			filebuf();
			filebuf(filedesc);
			filebuf(filedesc, char *, int);
			~filebuf();

	filebuf*	attach(filedesc);
	filedesc	fd() const { return (x_fd==-1) ? EOF : x_fd; }
	int		is_open() const { return (x_fd!=-1); }
	filebuf*	open(const char *, int, int = filebuf::openprot);
	filebuf*	close();
	int		setmode(int = filebuf::text);

virtual	int		overflow(int=EOF);
virtual	int		underflow();

virtual	streambuf*	setbuf(char *, int);
virtual	streampos	seekoff(streamoff, ios::seek_dir, int);
// virtual	streampos	seekpos(streampos, int);
virtual	int		sync();

private:
	filedesc	x_fd;
	int		x_fOpened;
};

class _CRTIMP ifstream : public istream {
public:
	ifstream();
	ifstream(const char *, int =ios::in, int = filebuf::openprot);
	ifstream(filedesc);
	ifstream(filedesc, char *, int);
	~ifstream();

	streambuf * setbuf(char *, int);
	filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

	void attach(filedesc);
	filedesc fd() const { return rdbuf()->fd(); }

	int is_open() const { return rdbuf()->is_open(); }
	void open(const char *, int =ios::in, int = filebuf::openprot);
	void close();
	int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};

class _CRTIMP ofstream : public ostream {
public:
	ofstream();
	ofstream(const char *, int =ios::out, int = filebuf::openprot);
	ofstream(filedesc);
	ofstream(filedesc, char *, int);
	~ofstream();

	streambuf * setbuf(char *, int);
	filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

	void attach(filedesc);
	filedesc fd() const { return rdbuf()->fd(); }

	int is_open() const { return rdbuf()->is_open(); }
	void open(const char *, int =ios::out, int = filebuf::openprot);
	void close();
	int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};
	
class _CRTIMP fstream : public iostream {
public:
	fstream();
	fstream(const char *, int, int = filebuf::openprot);
	fstream(filedesc);
	fstream(filedesc, char *, int);
	~fstream();

	streambuf * setbuf(char *, int);
	filebuf* rdbuf() const { return (filebuf*) ostream::rdbuf(); }

	void attach(filedesc);
	filedesc fd() const { return rdbuf()->fd(); }

	int is_open() const { return rdbuf()->is_open(); }
	void open(const char *, int, int = filebuf::openprot);
	void close();
	int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};
	
// manipulators to dynamically change file access mode (filebufs only)
inline	ios& binary(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::binary); return _fstrm; }
inline	ios& text(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::text); return _fstrm; }

#ifdef	_MSC_VER
#pragma pack(pop)
#endif	// _MSC_VER

#endif	// _INC_FSTREAM

#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\float.h ===
/***
*float.h - constants for floating point values
*
*	Copyright (c) 1985-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file contains defines for a number of implementation dependent
*	values which are commonly used by sophisticated numerical (floating
*	point) programs.
*	[ANSI]
*
*       [Public]
*
****/

#ifndef _INC_FLOAT
#define _INC_FLOAT

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#define DBL_DIG 	15			/* # of decimal digits of precision */
#define DBL_EPSILON	2.2204460492503131e-016 /* smallest such that 1.0+DBL_EPSILON != 1.0 */
#define DBL_MANT_DIG	53			/* # of bits in mantissa */
#define DBL_MAX 	1.7976931348623158e+308 /* max value */
#define DBL_MAX_10_EXP	308			/* max decimal exponent */
#define DBL_MAX_EXP	1024			/* max binary exponent */
#define DBL_MIN 	2.2250738585072014e-308 /* min positive value */
#define DBL_MIN_10_EXP	(-307)			/* min decimal exponent */
#define DBL_MIN_EXP	(-1021) 		/* min binary exponent */
#define _DBL_RADIX	2			/* exponent radix */
#define _DBL_ROUNDS	1			/* addition rounding: near */

#define FLT_DIG 	6			/* # of decimal digits of precision */
#define FLT_EPSILON	1.192092896e-07F	/* smallest such that 1.0+FLT_EPSILON != 1.0 */
#define FLT_GUARD	0
#define FLT_MANT_DIG	24			/* # of bits in mantissa */
#define FLT_MAX 	3.402823466e+38F	/* max value */
#define FLT_MAX_10_EXP	38			/* max decimal exponent */
#define FLT_MAX_EXP	128			/* max binary exponent */
#define FLT_MIN 	1.175494351e-38F	/* min positive value */
#define FLT_MIN_10_EXP	(-37)			/* min decimal exponent */
#define FLT_MIN_EXP	(-125)			/* min binary exponent */
#define FLT_NORMALIZE	0
#define FLT_RADIX	2			/* exponent radix */
#define FLT_ROUNDS	1			/* addition rounding: near */

#ifndef _M_M68K
#define LDBL_DIG	DBL_DIG 		/* # of decimal digits of precision */
#define LDBL_EPSILON	DBL_EPSILON		/* smallest such that 1.0+LDBL_EPSILON != 1.0 */
#define LDBL_MANT_DIG	DBL_MANT_DIG		/* # of bits in mantissa */
#define LDBL_MAX	DBL_MAX 		/* max value */
#define LDBL_MAX_10_EXP DBL_MAX_10_EXP		/* max decimal exponent */
#define LDBL_MAX_EXP	DBL_MAX_EXP		/* max binary exponent */
#define LDBL_MIN	DBL_MIN 		/* min positive value */
#define LDBL_MIN_10_EXP DBL_MIN_10_EXP		/* min decimal exponent */
#define LDBL_MIN_EXP	DBL_MIN_EXP		/* min binary exponent */
#define _LDBL_RADIX	DBL_RADIX		/* exponent radix */
#define _LDBL_ROUNDS	DBL_ROUNDS		/* addition rounding: near */
#else
#define LDBL_DIG	18					/* # of decimal digits of precision */
#define LDBL_EPSILON	1.08420217248550443412e-019L 		/* smallest such that 1.0+LDBL_EPSILON != 1.0 */
#define LDBL_MANT_DIG	64					/* # of bits in mantissa */
#define LDBL_MAX	1.189731495357231765e+4932L  		/* max value */
#define LDBL_MAX_10_EXP 4932					/* max decimal exponent */
#define LDBL_MAX_EXP	16384					/* max binary exponent */
#define LDBL_MIN	3.3621031431120935063e-4932L 		/* min positive value */
#define LDBL_MIN_10_EXP (-4931) 				/* min decimal exponent */
#define LDBL_MIN_EXP	(-16381)				/* min binary exponent */
#define _LDBL_RADIX	2					/* exponent radix */
#define _LDBL_ROUNDS	1					/* addition rounding: near */
#endif

/* Function prototypes */

_CRTIMP unsigned int __cdecl _clearfp(void);
_CRTIMP unsigned int __cdecl _controlfp(unsigned int,unsigned int);
_CRTIMP unsigned int __cdecl _statusfp(void);
_CRTIMP void __cdecl _fpreset(void);

#ifndef _MAC
#define _clear87	_clearfp
#define _status87	_statusfp
#endif /* _MAC */

/*
 * Abstract User Control Word Mask and bit definitions
 */
#if !defined(_M_MPPC) && !defined(_M_M68K)
#define _MCW_EM 	0x0008001f		/* interrupt Exception Masks */
#else
#define _MCW_EM 	0x0000001f		/* interrupt Exception Masks */
#endif
#define _EM_INEXACT	0x00000001		/*   inexact (precision) */
#define _EM_UNDERFLOW	0x00000002		/*   underflow */
#define _EM_OVERFLOW	0x00000004		/*   overflow */
#define _EM_ZERODIVIDE	0x00000008		/*   zero divide */
#define _EM_INVALID	0x00000010		/*   invalid */

#define _MCW_RC 	0x00000300		/* Rounding Control */
#define _RC_NEAR	0x00000000		/*   near */
#define _RC_DOWN	0x00000100		/*   down */
#define _RC_UP		0x00000200		/*   up */
#define _RC_CHOP	0x00000300		/*   chop */

/*
 * Abstract User Status Word bit definitions
 */

#define _SW_INEXACT	0x00000001		/* inexact (precision) */
#define _SW_UNDERFLOW	0x00000002		/* underflow */
#define _SW_OVERFLOW	0x00000004		/* overflow */
#define _SW_ZERODIVIDE	0x00000008		/* zero divide */
#define _SW_INVALID	0x00000010		/* invalid */


/*
 * i386 specific definitions
 */
#define _MCW_PC 	0x00030000		/* Precision Control */
#if defined(_M_MPPC)
/*
 * PowerMac specific definitions(no precision control)
 */
#define _PC_64		0x00000000		/*    64 bits */
#define _PC_53		0x00000000		/*    53 bits */
#define _PC_24		0x00000000		/*    24 bits */
#else
#define _PC_64		0x00000000		/*    64 bits */
#define _PC_53		0x00010000		/*    53 bits */
#define _PC_24		0x00020000		/*    24 bits */
#endif

#define _MCW_IC 	0x00040000		/* Infinity Control */
#define _IC_AFFINE	0x00040000		/*   affine */
#define _IC_PROJECTIVE	0x00000000		/*   projective */

#define _EM_DENORMAL	0x00080000		/* denormal exception mask (_control87 only) */

#define _SW_DENORMAL	0x00080000		/* denormal status bit */


_CRTIMP unsigned int __cdecl _control87(unsigned int,unsigned int);


/*
 * MIPS R4000 specific definitions
 */

#define _MCW_DN 	0x01000000		/* Denormal Control (R4000) */
#define _DN_FLUSH	0x01000000		/*   flush to zero */
#define _DN_SAVE	0x00000000		/*   save */


/* initial Control Word value */

#if	defined(_M_IX86)

#define _CW_DEFAULT ( _RC_NEAR + _PC_53 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)

#elif	defined(_M_M68K) || defined(_M_MPPC)

#define _CW_DEFAULT ( _RC_NEAR + _PC_64 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT )

#elif	defined(_M_MRX000) || defined (_M_ALPHA) || defined(_M_PPC)

#define _CW_DEFAULT ( _RC_NEAR + _DN_FLUSH + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT )

#endif

/* Global variable holding floating point error code */

#if defined(_MT) || defined(_DLL)
_CRTIMP extern int * __cdecl __fpecode(void);
#define _fpecode	(*__fpecode())
#else	/* ndef _MT && ndef _DLL */
extern int _fpecode;
#endif	/* _MT || _DLL */

/* invalid subconditions (_SW_INVALID also set) */

#define _SW_UNEMULATED		0x0040	/* unemulated instruction */
#define _SW_SQRTNEG		0x0080	/* square root of a neg number */
#define _SW_STACKOVERFLOW	0x0200	/* FP stack overflow */
#define _SW_STACKUNDERFLOW	0x0400	/* FP stack underflow */

/*  Floating point error signals and return codes */

#define _FPE_INVALID		0x81
#define _FPE_DENORMAL		0x82
#define _FPE_ZERODIVIDE 	0x83
#define _FPE_OVERFLOW		0x84
#define _FPE_UNDERFLOW		0x85
#define _FPE_INEXACT		0x86

#define _FPE_UNEMULATED 	0x87
#define _FPE_SQRTNEG		0x88
#define _FPE_STACKOVERFLOW	0x8a
#define _FPE_STACKUNDERFLOW	0x8b

#define _FPE_EXPLICITGEN	0x8c	/* raise( SIGFPE ); */


/* IEEE recommended functions */

_CRTIMP double __cdecl _copysign (double, double);
_CRTIMP double __cdecl _chgsign (double);
_CRTIMP double __cdecl _scalb(double, long);
_CRTIMP double __cdecl _logb(double);
_CRTIMP double __cdecl _nextafter(double, double);
_CRTIMP int    __cdecl _finite(double);
_CRTIMP int    __cdecl _isnan(double);
_CRTIMP int    __cdecl _fpclass(double);

#define _FPCLASS_SNAN	0x0001	/* signaling NaN */
#define _FPCLASS_QNAN	0x0002	/* quiet NaN */
#define _FPCLASS_NINF	0x0004	/* negative infinity */
#define _FPCLASS_NN	0x0008	/* negative normal */
#define _FPCLASS_ND	0x0010	/* negative denormal */
#define _FPCLASS_NZ	0x0020	/* -0 */
#define _FPCLASS_PZ	0x0040	/* +0 */
#define _FPCLASS_PD	0x0080	/* positive denormal */
#define _FPCLASS_PN	0x0100	/* positive normal */
#define _FPCLASS_PINF	0x0200	/* positive infinity */


#if     !__STDC__

/* Non-ANSI names for compatibility */

#ifndef _MAC
#define clear87         _clear87
#define status87        _status87
#define control87       _control87
#endif /* _MAC */

#ifdef  _NTSDK
#define fpreset         _fpreset
#else   /* ndef _NTSDK */
_CRTIMP void __cdecl fpreset(void);
#endif  /* _NTSDK */

#define DBL_RADIX		_DBL_RADIX
#define DBL_ROUNDS		_DBL_ROUNDS

#define LDBL_RADIX		_LDBL_RADIX
#define LDBL_ROUNDS		_LDBL_ROUNDS

#define MCW_EM			_MCW_EM
#define EM_INVALID		_EM_INVALID
#define EM_DENORMAL		_EM_DENORMAL
#define EM_ZERODIVIDE		_EM_ZERODIVIDE
#define EM_OVERFLOW		_EM_OVERFLOW
#define EM_UNDERFLOW		_EM_UNDERFLOW
#define EM_INEXACT		_EM_INEXACT

#define MCW_IC			_MCW_IC
#define IC_AFFINE		_IC_AFFINE
#define IC_PROJECTIVE		_IC_PROJECTIVE

#define MCW_RC			_MCW_RC
#define RC_CHOP 		_RC_CHOP
#define RC_UP			_RC_UP
#define RC_DOWN 		_RC_DOWN
#define RC_NEAR 		_RC_NEAR

#define MCW_PC			_MCW_PC
#define PC_24			_PC_24
#define PC_53			_PC_53
#define PC_64			_PC_64

#define CW_DEFAULT		_CW_DEFAULT

#define SW_INVALID		_SW_INVALID
#define SW_DENORMAL		_SW_DENORMAL
#define SW_ZERODIVIDE		_SW_ZERODIVIDE
#define SW_OVERFLOW		_SW_OVERFLOW
#define SW_UNDERFLOW		_SW_UNDERFLOW
#define SW_INEXACT		_SW_INEXACT

#define SW_UNEMULATED		_SW_UNEMULATED
#define SW_SQRTNEG		_SW_SQRTNEG
#define SW_STACKOVERFLOW	_SW_STACKOVERFLOW
#define SW_STACKUNDERFLOW	_SW_STACKUNDERFLOW

#define FPE_INVALID		_FPE_INVALID
#define FPE_DENORMAL		_FPE_DENORMAL
#define FPE_ZERODIVIDE		_FPE_ZERODIVIDE
#define FPE_OVERFLOW		_FPE_OVERFLOW
#define FPE_UNDERFLOW		_FPE_UNDERFLOW
#define FPE_INEXACT		_FPE_INEXACT

#define FPE_UNEMULATED		_FPE_UNEMULATED
#define FPE_SQRTNEG		_FPE_SQRTNEG
#define FPE_STACKOVERFLOW	_FPE_STACKOVERFLOW
#define FPE_STACKUNDERFLOW	_FPE_STACKUNDERFLOW

#define FPE_EXPLICITGEN 	_FPE_EXPLICITGEN

#endif	/* __STDC__ */

#ifdef __cplusplus
}
#endif

#endif	/* _INC_FLOAT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\fcntl.h ===
/***
*fcntl.h - file control options used by open()
*
*	Copyright (c) 1985-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines constants for the file control options used
*	by the _open() function.
*	[System V]
*
*       [Public]
*
****/

#ifndef _INC_FCNTL
#define _INC_FCNTL

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#define _O_RDONLY	0x0000	/* open for reading only */
#define _O_WRONLY	0x0001	/* open for writing only */
#define _O_RDWR 	0x0002	/* open for reading and writing */
#define _O_APPEND	0x0008	/* writes done at eof */

#define _O_CREAT	0x0100	/* create and open file */
#define _O_TRUNC	0x0200	/* open and truncate */
#define _O_EXCL 	0x0400	/* open only if file doesn't already exist */

/* O_TEXT files have <cr><lf> sequences translated to <lf> on read()'s,
** and <lf> sequences translated to <cr><lf> on write()'s
*/

#define _O_TEXT 	0x4000	/* file mode is text (translated) */
#define _O_BINARY	0x8000	/* file mode is binary (untranslated) */

/* macro to translate the C 2.0 name used to force binary mode for files */

#define _O_RAW	_O_BINARY

/* Open handle inherit bit */

#define _O_NOINHERIT	0x0080	/* child process doesn't inherit file */

/* Temporary file bit - file is deleted when last handle is closed */

#define _O_TEMPORARY	0x0040	/* temporary file bit */

/* temporary access hint */

#define _O_SHORT_LIVED	0x1000	/* temporary storage file, try not to flush */

/* sequential/random access hints */

#define _O_SEQUENTIAL	0x0020	/* file access is primarily sequential */
#define _O_RANDOM	0x0010	/* file access is primarily random */

#if !__STDC__ || defined(_POSIX_)
/* Non-ANSI names for compatibility */
#define O_RDONLY	_O_RDONLY
#define O_WRONLY	_O_WRONLY
#define O_RDWR		_O_RDWR
#define O_APPEND	_O_APPEND
#define O_CREAT 	_O_CREAT
#define O_TRUNC 	_O_TRUNC
#define O_EXCL		_O_EXCL
#define O_TEXT		_O_TEXT
#define O_BINARY	_O_BINARY
#define O_RAW		_O_BINARY
#define O_TEMPORARY	_O_TEMPORARY
#define O_NOINHERIT	_O_NOINHERIT
#define O_SEQUENTIAL	_O_SEQUENTIAL
#define O_RANDOM	_O_RANDOM
#endif /* __STDC__ */

#endif /* _INC_FCNTL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\except.h ===
/***
*except.h - defines exception values, types and routines
*
*	Copyright (c) 1990-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines the exception values, types and declares the
*	associated functions.
*
****/

#ifndef _INC_EXCEPT

#ifdef __cplusplus
extern "C" {
#endif


#if (_MSC_VER <= 600)
#define __cdecl _cdecl
#endif

/*
 * exception codes defined by the host OS
 *
 * NOTE: THE UNDERSCORE PREFIX IN THE FOLLOWING NAMES WAS ADDED TO CONFORM
 * WITH ANSI NAMESPACE REQUIREMENTS.
 */

#define _XCPT_GUARD_PAGE_VIOLATION		0x80000001
#define _XCPT_UNABLE_TO_GROW_STACK		0x80010001
#define _XCPT_DATATYPE_MISALIGNMENT		0xC000009E
#define _XCPT_BREAKPOINT			0xC000009F
#define _XCPT_SINGLESTEP			0xC00000A0
#define _XCPT_ACCESS_VIOLATION			0xC0000005
#define _XCPT_ILLEGAL_INSTRUCTION		0xC000001C
#define _XCPT_FLOATING_DENORMAL_OPERAND 	0xC0000094
#define _XCPT_FLOATING_DIVIDE_BY_ZERO		0xC0000095
#define _XCPT_FLOATING_INEXACT_RESULT		0xC0000096
#define _XCPT_FLOATING_INVALID_OPERATION	0xC0000097
#define _XCPT_FLOATING_OVERFLOW 		0xC0000098
#define _XCPT_FLOATING_STACK_CHECK		0xC0000099
#define _XCPT_FLOATING_UNDERFLOW		0xC000009A
#define _XCPT_INTEGER_DIVIDE_BY_ZERO		0xC000009B
#define _XCPT_INTEGER_OVERFLOW			0xC000009C
#define _XCPT_PRIVILEGED_INSTRUCTION		0xC000009D
#define _XCPT_IN_PAGE_ERROR			0xC0000006
#define _XCPT_PROCESS_TERMINATE 		0xC0010001
#define _XCPT_ASYNC_PROCESS_TERMINATE		0xC0010002
#define _XCPT_NONCONTINUABLE_EXCEPTION		0xC0000024
#define _XCPT_INVALID_DISPOSITION		0xC0000025
#define _XCPT_INVALID_LOCK_SEQUENCE		0xC000001D
#define _XCPT_ARRAY_BOUNDS_EXCEEDED		0xC0000093
#define _XCPT_B1NPX_ERRATA_02			0xC0010004
#define _XCPT_UNWIND				0xC0000026
#define _XCPT_BAD_STACK 			0xC0000027
#define _XCPT_INVALID_UNWIND_TARGET		0xC0000028
#define _XCPT_SIGNAL				0xC0010003


/*
 * exception codes defined by the C runtime
 */

#define _XCPT_SIGABRT				0x20000001
#define _XCPT_SIGUSR1				0x20000002
#define _XCPT_SIGUSR2				0x20000003
#define _XCPT_SIGUSR3				0x20000004
#define _XCPT_FLOATING_EXPLICITGEN		0x20000005


/*
 * constants, structs and types used in exception handling at the OS level
 *
 * NOTE: MANY OF IDENTIFIERS DEFINED BELOW ARE FROM DCR 1024. HOWEVER, THEY
 * HAVE BEEN CHANGED TO CONFORM WITH ANSI NAMESPACE RESTRICTIONS.
 */

#define _EXCEPTION_MAXIMUM_PARAMETERS	4

struct __EXCEPTIONREPORTRECORD {
	unsigned long ExceptionNum;
	unsigned long fHandlerFlags;
	struct __EXCEPTIONREPORTRECORD * NestedExceptionReportRecord;
	void * ExceptionAddress;
	unsigned long cParameters;
	unsigned long ExceptionInfo[_EXCEPTION_MAXIMUM_PARAMETERS];
};

typedef struct __EXCEPTIONREPORTRECORD _EXCEPTIONREPORTRECORD;
typedef struct __EXCEPTIONREPORTRECORD * _PEXCEPTIONREPORTRECORD;

/*
 * values of ExceptionInfo[0] for _XCPT_SIGNAL.
 */

#define _XCPT_SIGNAL_INTR	 1	/* corresponds to SIGINT */
#define _XCPT_SIGNAL_KILLPROC	 3	/* corresponds to SIGTERM */
#define _XCPT_SIGNAL_BREAK	 4	/* corresponds to SIGBREAK */

/*
 * NOTE: THE FOLLOWING DEFINITION FOR _PCONTEXTRECORD IS INCORRECT, BUT I
 * DON'T ACTUALLY USE IT FOR ANYTHING AND REAL DEFINITION WOULD TAKE A GOOD
 * TWO PAGES. SEE PAGES 16 AND 17 OF VOL1.TXT FOR THE CORRECT DEFINITION.
 */

typedef void * _PCONTEXTRECORD;

/*
 * structure used by SEH support function and intrinsics. the information
 * passed by the exception dispatcher is repackaged in this form by the
 * runtime (_except_handler()).
 */

struct __EXCEPTION_INFO_PTRS {
	_PEXCEPTIONREPORTRECORD preport;
	_PCONTEXTRECORD pcontext;
};

typedef struct __EXCEPTION_INFO_PTRS * _PEXCEPTION_INFO_PTRS;


#ifndef _MAC_
/*
 * prototypes for intrinsic SEH functions
 */

unsigned long __cdecl _exception_code(void);
void * __cdecl _exception_info(void);
int __cdecl _abnormal_termination(void);
#endif	/* ndef _MAC_ */


#ifdef __cplusplus
}
#endif

#define _INC_EXCEPT
#endif	/* _INC_EXCEPT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\io.h ===
/***
*io.h - declarations for low-level file handling and I/O functions
*
*	Copyright (c) 1985-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file contains the function declarations for the low-level
*	file handling and I/O functions.
*
*       [Public]
*
****/

#ifndef _INC_IO
#define _INC_IO

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef	_MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif	/* _MSC_VER */

#ifndef _POSIX_

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _MAC
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif
#endif /* ndef _MAC */

#ifndef _TIME_T_DEFINED
typedef long time_t;		/* time value */
#define _TIME_T_DEFINED 	/* avoid multiple def's of time_t */
#endif

#ifndef _FSIZE_T_DEFINED
typedef unsigned long _fsize_t; /* Could be 64 bits for Win32 */
#define _FSIZE_T_DEFINED
#endif

#ifndef _MAC

#ifndef _FINDDATA_T_DEFINED

struct _finddata_t {
    unsigned	attrib;
    time_t	time_create;	/* -1 for FAT file systems */
    time_t	time_access;	/* -1 for FAT file systems */
    time_t	time_write;
    _fsize_t	size;
    char	name[260];
};

#if _INTEGRAL_MAX_BITS >= 64
struct _finddatai64_t {
    unsigned	attrib;
    time_t	time_create;	/* -1 for FAT file systems */
    time_t	time_access;	/* -1 for FAT file systems */
    time_t	time_write;
    __int64	size;
    char	name[260];
};
#endif

#define _FINDDATA_T_DEFINED
#endif

#ifndef _WFINDDATA_T_DEFINED

struct _wfinddata_t {
    unsigned	attrib;
    time_t	time_create;	/* -1 for FAT file systems */
    time_t	time_access;	/* -1 for FAT file systems */
    time_t	time_write;
    _fsize_t	size;
    wchar_t	name[260];
};

#if _INTEGRAL_MAX_BITS >= 64
struct _wfinddatai64_t {
    unsigned	attrib;
    time_t	time_create;	/* -1 for FAT file systems */
    time_t	time_access;	/* -1 for FAT file systems */
    time_t	time_write;
    __int64	size;
    wchar_t	name[260];
};
#endif

#define _WFINDDATA_T_DEFINED
#endif

/* File attribute constants for _findfirst() */

#define _A_NORMAL	0x00	/* Normal file - No read/write restrictions */
#define _A_RDONLY	0x01	/* Read only file */
#define _A_HIDDEN	0x02	/* Hidden file */
#define _A_SYSTEM	0x04	/* System file */
#define _A_SUBDIR	0x10	/* Subdirectory */
#define _A_ARCH 	0x20	/* Archive file */

#endif /* ndef _MAC */

/* function prototypes */

_CRTIMP int __cdecl _access(const char *, int);
_CRTIMP int __cdecl _chmod(const char *, int);
_CRTIMP int __cdecl _chsize(int, long);
_CRTIMP int __cdecl _close(int);
_CRTIMP int __cdecl _commit(int);
_CRTIMP int __cdecl _creat(const char *, int);
_CRTIMP int __cdecl _dup(int);
_CRTIMP int __cdecl _dup2(int, int);
_CRTIMP int __cdecl _eof(int);
_CRTIMP long __cdecl _filelength(int);
#ifndef _MAC
_CRTIMP long __cdecl _findfirst(char *, struct _finddata_t *);
_CRTIMP int __cdecl _findnext(long, struct _finddata_t *);
_CRTIMP int __cdecl _findclose(long);
#endif /* ndef _MAC */
_CRTIMP int __cdecl _isatty(int);
_CRTIMP int __cdecl _locking(int, int, long);
_CRTIMP long __cdecl _lseek(int, long, int);
_CRTIMP char * __cdecl _mktemp(char *);
_CRTIMP int __cdecl _open(const char *, int, ...);
#ifndef _MAC
_CRTIMP int __cdecl _pipe(int *, unsigned int, int);
#endif /* ndef _MAC */
_CRTIMP int __cdecl _read(int, void *, unsigned int);
_CRTIMP int __cdecl remove(const char *);
_CRTIMP int __cdecl rename(const char *, const char *);
_CRTIMP int __cdecl _setmode(int, int);
_CRTIMP int __cdecl _sopen(const char *, int, int, ...);
_CRTIMP long __cdecl _tell(int);
_CRTIMP int __cdecl _umask(int);
_CRTIMP int __cdecl _unlink(const char *);
_CRTIMP int __cdecl _write(int, const void *, unsigned int);

#if _INTEGRAL_MAX_BITS >= 64
_CRTIMP __int64 __cdecl _filelengthi64(int);
_CRTIMP long __cdecl _findfirsti64(char *, struct _finddatai64_t *);
_CRTIMP int __cdecl _findnexti64(long, struct _finddatai64_t *);
_CRTIMP __int64 __cdecl _lseeki64(int, __int64, int);
_CRTIMP __int64 __cdecl _telli64(int);
#endif

#ifndef _MAC
#ifndef _WIO_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _waccess(const wchar_t *, int);
_CRTIMP int __cdecl _wchmod(const wchar_t *, int);
_CRTIMP int __cdecl _wcreat(const wchar_t *, int);
_CRTIMP long __cdecl _wfindfirst(wchar_t *, struct _wfinddata_t *);
_CRTIMP int __cdecl _wfindnext(long, struct _wfinddata_t *);
_CRTIMP int __cdecl _wunlink(const wchar_t *);
_CRTIMP int __cdecl _wrename(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wopen(const wchar_t *, int, ...);
_CRTIMP int __cdecl _wsopen(const wchar_t *, int, int, ...);
_CRTIMP wchar_t * __cdecl _wmktemp(wchar_t *);

#if _INTEGRAL_MAX_BITS >= 64
_CRTIMP long __cdecl _wfindfirsti64(wchar_t *, struct _wfinddatai64_t *);
_CRTIMP int __cdecl _wfindnexti64(long, struct _wfinddatai64_t *);
#endif

#define _WIO_DEFINED
#endif
#endif /* ndef _MAC */


_CRTIMP long __cdecl _get_osfhandle(int);
_CRTIMP int __cdecl _open_osfhandle(long, int);

#if	!__STDC__

/* Non-ANSI names for compatibility */

#ifdef	_NTSDK

#ifndef __cplusplus
#define access      _access
#define chmod       _chmod
#define chsize      _chsize
#define close       _close
#define creat       _creat
#define dup         _dup
#define dup2        _dup2
#define eof         _eof
#define filelength  _filelength
#define isatty      _isatty
#define locking     _locking
#define lseek       _lseek
#define mktemp      _mktemp
#define open        _open
#define read        _read
#define setmode     _setmode
#define sopen       _sopen
#define tell        _tell
#define umask       _umask
#define unlink      _unlink
#define write       _write
#endif	/* __cplusplus */

#else	/* ndef _NTSDK */

_CRTIMP int __cdecl access(const char *, int);
_CRTIMP int __cdecl chmod(const char *, int);
_CRTIMP int __cdecl chsize(int, long);
_CRTIMP int __cdecl close(int);
_CRTIMP int __cdecl creat(const char *, int);
_CRTIMP int __cdecl dup(int);
_CRTIMP int __cdecl dup2(int, int);
_CRTIMP int __cdecl eof(int);
_CRTIMP long __cdecl filelength(int);
_CRTIMP int __cdecl isatty(int);
_CRTIMP int __cdecl locking(int, int, long);
_CRTIMP long __cdecl lseek(int, long, int);
_CRTIMP char * __cdecl mktemp(char *);
_CRTIMP int __cdecl open(const char *, int, ...);
_CRTIMP int __cdecl read(int, void *, unsigned int);
_CRTIMP int __cdecl setmode(int, int);
_CRTIMP int __cdecl sopen(const char *, int, int, ...);
_CRTIMP long __cdecl tell(int);
_CRTIMP int __cdecl umask(int);
_CRTIMP int __cdecl unlink(const char *);
_CRTIMP int __cdecl write(int, const void *, unsigned int);

#endif	/* _NTSDK */

#endif	/* __STDC__ */

#ifdef __cplusplus
}
#endif

#endif	/* _POSIX_ */

#ifdef	_MSC_VER
#pragma pack(pop)
#endif	/* _MSC_VER */

#endif	/* _INC_IO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\ios.h ===
/***
*ios.h - definitions/declarations for the ios class.
*
*	Copyright (c) 1990-1995, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the classes, values, macros, and functions
*	used by the ios class.
*	[AT&T C++]
*
*       [Public]
*
****/

#ifdef __cplusplus

#ifndef _INC_IOS
#define _INC_IOS

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef	_MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)
#endif	// _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */

#ifdef _MT

typedef struct __CRT_LIST_ENTRY {
   struct __CRT_LIST_ENTRY *Flink;
   struct __CRT_LIST_ENTRY *Blink;
} _CRT_LIST_ENTRY;

typedef struct _CRT_CRITICAL_SECTION_DEBUG {
    unsigned short Type;
    unsigned short CreatorBackTraceIndex;
    struct _CRT_CRITICAL_SECTION *CriticalSection;
    _CRT_LIST_ENTRY ProcessLocksList;
    unsigned long EntryCount;
    unsigned long ContentionCount;
    unsigned long Depth;
    void * OwnerBackTrace[ 5 ];
} _CRT_CRITICAL_SECTION_DEBUG, *_PCRT_CRITICAL_SECTION_DEBUG;

typedef struct _CRT_CRITICAL_SECTION {
    _PCRT_CRITICAL_SECTION_DEBUG DebugInfo;

    //
    //  The following three fields control entering and exiting the critical
    //  section for the resource
    //

    long LockCount;
    long RecursionCount;
    void * OwningThread;        // from the thread's ClientId->UniqueThread
    void * LockSemaphore;
    unsigned long Reserved;
} _CRT_CRITICAL_SECTION, *_PCRT_CRITICAL_SECTION;

extern "C" {
_CRTIMP void __cdecl _mtlock(_PCRT_CRITICAL_SECTION);
_CRTIMP void __cdecl _mtunlock(_PCRT_CRITICAL_SECTION);
}

#endif /* _MT */

#ifndef NULL
#define NULL	0
#endif

#ifndef EOF
#define EOF	(-1)
#endif

#ifdef	_MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)	// use this to reenable, if desired
#endif	// _MSC_VER

class _CRTIMP streambuf;
class _CRTIMP ostream;

class _CRTIMP ios {

public:
    enum io_state {  goodbit = 0x00,
		     eofbit  = 0x01,
		     failbit = 0x02,
		     badbit  = 0x04 };

    enum open_mode { in        = 0x01,
		     out       = 0x02,
		     ate       = 0x04,
		     app       = 0x08,
		     trunc     = 0x10,
		     nocreate  = 0x20,
		     noreplace = 0x40,
		     binary    = 0x80 };

    enum seek_dir { beg=0, cur=1, end=2 };

    enum {  skipws     = 0x0001,
	    left       = 0x0002,
	    right      = 0x0004,
	    internal   = 0x0008,
	    dec        = 0x0010,
	    oct        = 0x0020,
	    hex        = 0x0040,
	    showbase   = 0x0080,
	    showpoint  = 0x0100,
	    uppercase  = 0x0200,
	    showpos    = 0x0400,
	    scientific = 0x0800,
	    fixed      = 0x1000,
	    unitbuf    = 0x2000,
	    stdio      = 0x4000
				 };

    static const long basefield;	// dec | oct | hex
    static const long adjustfield;	// left | right | internal
    static const long floatfield;	// scientific | fixed

    ios(streambuf*);			// differs from ANSI
    virtual ~ios();

    inline long flags() const;
    inline long flags(long _l);

    inline long setf(long _f,long _m);
    inline long setf(long _l);
    inline long unsetf(long _l);

    inline int width() const;
    inline int width(int _i);

    inline ostream* tie(ostream* _os);
    inline ostream* tie() const;

    inline char fill() const;
    inline char fill(char _c);

    inline int precision(int _i);
    inline int precision() const;

    inline int rdstate() const;
    inline void clear(int _i = 0);

//  inline operator void*() const;
    operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
    inline int operator!() const;

    inline int  good() const;
    inline int  eof() const;
    inline int  fail() const;
    inline int  bad() const;

    inline streambuf* rdbuf() const;

    inline long & iword(int) const;
    inline void * & pword(int) const;

    static long bitalloc();
    static int xalloc();
    static void sync_with_stdio();

#ifdef	_MT
    inline void __cdecl setlock();
    inline void __cdecl clrlock();
    void __cdecl lock() { if (LockFlg<0) _mtlock(lockptr()); };
    void __cdecl unlock() { if (LockFlg<0) _mtunlock(lockptr()); }
    inline void __cdecl lockbuf();
    inline void __cdecl unlockbuf();
#else
    void __cdecl lock() { }
    void __cdecl unlock() { }
    void __cdecl lockbuf() { }
    void __cdecl unlockbuf() { }
#endif

protected:
    ios();
    ios(const ios&);			// treat as private
    ios& operator=(const ios&);
    void init(streambuf*);

    enum { skipping, tied };
    streambuf*	bp;

    int     state;
    int     ispecial;			// not used
    int     ospecial;			// not used
    int     isfx_special;		// not used
    int     osfx_special;		// not used
    int     x_delbuf;			// if set, rdbuf() deleted by ~ios

    ostream* x_tie;
    long    x_flags;
    int     x_precision;
    char    x_fill;
    int     x_width;

    static void (*stdioflush)();	// not used

#ifdef	_MT
    static void lockc() { _mtlock(& x_lockc); }
    static void unlockc() { _mtunlock( & x_lockc); }
    _PCRT_CRITICAL_SECTION lockptr() { return & x_lock; }
#else
    static void lockc() { }
    static void unlockc() { }
#endif

public:
    int	delbuf() const { return x_delbuf; }
    void    delbuf(int _i) { x_delbuf = _i; }

private:
    static long x_maxbit;
    static int x_curindex;
    static int sunk_with_stdio;		// make sure sync_with done only once
#ifdef	_MT
#define MAXINDEX 7
    static long x_statebuf[MAXINDEX+1];  // used by xalloc()
    static int fLockcInit;		// used to see if x_lockc initialized
    static _CRT_CRITICAL_SECTION x_lockc; // used to lock static (class) data members
    int LockFlg;			// enable locking flag
    _CRT_CRITICAL_SECTION x_lock;	// used for multi-thread lock on object
#else
    static long * x_statebuf;  // used by xalloc()
#endif
};

#include <streamb.h>

inline _CRTIMP ios& __cdecl dec(ios& _strm) { _strm.setf(ios::dec,ios::basefield); return _strm; }
inline _CRTIMP ios& __cdecl hex(ios& _strm) { _strm.setf(ios::hex,ios::basefield); return _strm; }
inline _CRTIMP ios& __cdecl oct(ios& _strm) { _strm.setf(ios::oct,ios::basefield); return _strm; }

inline long ios::flags() const { return x_flags; }
inline long ios::flags(long _l){ long _lO; _lO = x_flags; x_flags = _l; return _lO; }

inline long ios::setf(long _l,long _m){ long _lO; lock(); _lO = x_flags; x_flags = (_l&_m) | (x_flags&(~_m)); unlock(); return _lO; }
inline long ios::setf(long _l){ long _lO; lock(); _lO = x_flags; x_flags |= _l; unlock(); return _lO; }
inline long ios::unsetf(long _l){ long _lO; lock(); _lO = x_flags; x_flags &= (~_l); unlock(); return _lO; }

inline int ios::width() const { return x_width; }
inline int ios::width(int _i){ int _iO; _iO = (int)x_width; x_width = _i; return _iO; }

inline ostream* ios::tie(ostream* _os){ ostream* _osO; _osO = x_tie; x_tie = _os; return _osO; }
inline ostream* ios::tie() const { return x_tie; }
inline char ios::fill() const { return x_fill; }
inline char ios::fill(char _c){ char _cO; _cO = x_fill; x_fill = _c; return _cO; }
inline int ios::precision(int _i){ int _iO; _iO = (int)x_precision; x_precision = _i; return _iO; }
inline int ios::precision() const { return x_precision; }

inline int ios::rdstate() const { return state; }

// inline ios::operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
inline int ios::operator!() const { return state&(badbit|failbit); }

inline int  ios::bad() const { return state & badbit; }
inline void ios::clear(int _i){ lock(); state = _i; unlock(); }
inline int  ios::eof() const { return state & eofbit; }
inline int  ios::fail() const { return state & (badbit | failbit); }
inline int  ios::good() const { return state == 0; }

inline streambuf* ios::rdbuf() const { return bp; }

inline long & ios::iword(int _i) const { return x_statebuf[_i] ; }
inline void * & ios::pword(int _i) const { return (void * &)x_statebuf[_i]; }

#ifdef	_MT
    inline void ios::setlock() { LockFlg--; if (bp) bp->setlock(); }
    inline void ios::clrlock() { if (LockFlg <= 0) LockFlg++; if (bp) bp->clrlock(); }
    inline void ios::lockbuf() { bp->lock(); }
    inline void ios::unlockbuf() { bp->unlock(); }
#endif

#ifdef	_MSC_VER
// Restore default packing
#pragma pack(pop)
#endif	// _MSC_VER

#endif	// _INC_IOS

#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\iomanip.h ===
/***
*iomanip.h - definitions/declarations for iostream's parameterized manipulators
*
*	Copyright (c) 1991-1995, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the classes, values, macros, and functions
*	used by the iostream classes' paramterized manipulators.
*	[AT&T C++]
*
*       [Public]
*
****/

#ifdef __cplusplus

#ifndef _INC_IOMANIP
#define _INC_IOMANIP

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef	_MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)
#endif	// _MSC_VER

#include <iostream.h>

#ifdef	_MSC_VER
#pragma warning(disable:4514)		// disable unwanted /W4 warning
// #pragma warning(default:4514)	// use this to reenable, if necessary
#endif	// _MSC_VER

// #define __MKMANIP(X) \#define X##(T) __##X##_ \#\# T
// __MKMANIP(SMANIP);
// __MKMANIP(SAPP);
// __MKMANIP(IMANIP);
// __MKMANIP(IAPP);
// __MKMANIP(OMANIP);
// __MKMANIP(OAPP);
// __MKMANIP(IOMANIP);
// __MKMANIP(IOAPP);

#define SMANIP(T) __SMANIP_##T
#define SAPP(T) __SAPP_##T
#define IMANIP(T) __IMANIP_##T
#define IAPP(T) __IAPP_##T
#define OMANIP(T) __OMANIP_##T
#define OAPP(T) __OAPP_##T
#define IOMANIP(T) __IOMANIP_##T
#define IOAPP(T) __IOAPP_##T

#define IOMANIPdeclare(T)  \
class SMANIP(T) { \
public:	\
	SMANIP(T)(ios& (*f)(ios&,T), T t) { _fp = f; _tp = t; } \
	friend istream& operator>>(istream& s, const SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
	friend ostream& operator<<(ostream& s, const SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
private:	\
	ios& (* _fp)(ios&,T); \
	T _tp; \
};	\
class SAPP(T) {	\
public:	\
	SAPP(T)( ios& (*f)(ios&,T)) { _fp = f; }	\
	SMANIP(T) operator()(T t) { return SMANIP(T)(_fp,t); } 	\
private:	\
	ios& (* _fp)(ios&,T); \
};	\
class IMANIP(T) { \
public:	\
	IMANIP(T)(istream& (*f)(istream&,T), T t) { _fp = f; _tp = t; } \
	friend istream& operator>>(istream& s, IMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:	\
	istream& (* _fp)(istream&,T); \
	T _tp;	\
};	\
class IAPP(T) {	\
public:	\
	IAPP(T)( istream& (*f)(istream&,T)) { _fp = f; }	\
	IMANIP(T) operator()(T t) { return IMANIP(T)(_fp,t); } 	\
private:	\
	istream& (* _fp)(istream&,T); \
};	\
class OMANIP(T) { \
public:	\
	OMANIP(T)(ostream& (*f)(ostream&,T), T t) { _fp = f; _tp = t; } \
	friend ostream& operator<<(ostream& s, OMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:	\
	ostream& (* _fp)(ostream&,T); \
	T _tp; \
};	\
class OAPP(T) {	\
public:	\
	OAPP(T)(ostream& (*f)(ostream&,T)) { _fp = f; }	\
	OMANIP(T) operator()(T t) { return OMANIP(T)(_fp,t); } \
private:	\
	ostream& (* _fp)(ostream&,T); \
};	\
\
class IOMANIP(T) { \
public:	\
	IOMANIP(T)(iostream& (*f)(iostream&,T), T t) { _fp = f; _tp = t; } \
	friend istream& operator>>(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
	friend ostream& operator<<(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:	\
	iostream& (* _fp)(iostream&,T); \
	T _tp; \
};	\
class IOAPP(T) {	\
public:	\
	IOAPP(T)( iostream& (*f)(iostream&,T)) { _fp = f; }	\
	IOMANIP(T) operator()(T t) { return IOMANIP(T)(_fp,t); } 	\
private:	\
	iostream& (* _fp)(iostream&,T); \
}; \

	
IOMANIPdeclare(int)

IOMANIPdeclare(long)

inline ios& __resetiosflags(ios& s, long _flg) { s.setf(0,_flg); return s; }
inline ios& __setfill(ios& s, int _fc) { s.fill((char)_fc); return s; }
inline ios& __setiosflags(ios& s, long _flg) { s.setf(_flg); return s; }
inline ios& __setprecision(ios& s, int _pre) { s.precision(_pre); return s; }
inline ios& __setw(ios& s, int _wid) { s.width(_wid); return s; }

inline SMANIP(long)	resetiosflags(long _l) { return SMANIP(long)(__resetiosflags, _l); }
inline SMANIP(int)	setfill(int _m) {return SMANIP(int)(__setfill, _m); }
inline SMANIP(long)	setiosflags(long _l) {return SMANIP(long)(__setiosflags, _l); }
inline SMANIP(int)	setprecision(int _p) {return SMANIP(int)(__setprecision, _p); }
inline SMANIP(int)	setw(int _w) { return SMANIP(int)(__setw, _w); }

// Restore previous packing
#ifdef	_MSC_VER
#pragma pack(pop)
#endif	// _MSC_VER

#endif	// _INC_IOMANIP

#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\lm.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    lm.h

Abstract:

    This is the top level include file that includes all the files
    necessary for writing Lan Manager Application.

[Environment:]

    User Mode - Win32

--*/

#ifndef _LM_
#define _LM_

#include <lmcons.h>     // LAN Manager common definitions
#include <lmerr.h>      // LAN Manager network error definitions

#include <lmaccess.h>   // Access, Domain, Group and User classes
#include <lmalert.h>    // Alerter
#include <lmchdev.h>    // Character Device and Handle classes
#include <lmshare.h>    // Connection, File, Session and Share classes
#include <lmmsg.h>      // Message class
#include <lmremutl.h>   // Remote Utility class
#include <lmrepl.h>     // Replicator class
#include <lmserver.h>   // Server class
#include <lmsvc.h>      // Service class
#include <lmuse.h>      // Use class
#include <lmwksta.h>    // Workstation class
#include <lmapibuf.h>   // NetApiBuffer class
#include <lmerrlog.h>   // NetErrorLog class
#include <lmconfig.h>   // NetConfig class
#include <lmstats.h>    // NetStats class
#include <lmaudit.h>    // NetAudit class

#endif // _LM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\iostream.h ===
/***
*iostream.h - definitions/declarations for iostream classes
*
*	Copyright (c) 1990-1995, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the classes, values, macros, and functions
*	used by the iostream classes.
*	[AT&T C++]
*
*       [Public]
*
****/

#ifdef __cplusplus

#ifndef _INC_IOSTREAM
#define _INC_IOSTREAM

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef	_MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)
#endif	// _MSC_VER


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */

typedef long streamoff, streampos;

#include <ios.h>		// Define ios.

#include <streamb.h>		// Define streambuf.

#include <istream.h>		// Define istream.

#include <ostream.h>		// Define ostream.

#ifdef	_MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)	// use this to reenable, if desired
#endif	// _MSC_VER

class _CRTIMP iostream : public istream, public ostream {
public:
	iostream(streambuf*);
	virtual ~iostream();
protected:
	iostream();
	iostream(const iostream&);
inline iostream& operator=(streambuf*);
inline iostream& operator=(iostream&);
private:
	iostream(ios&);
	iostream(istream&);
	iostream(ostream&);
};

inline iostream& iostream::operator=(streambuf* _sb) { istream::operator=(_sb); ostream::operator=(_sb); return *this; }

inline iostream& iostream::operator=(iostream& _strm) { return operator=(_strm.rdbuf()); }

class _CRTIMP Iostream_init {
public:
	Iostream_init();
	Iostream_init(ios &, int =0);	// treat as private
	~Iostream_init();
};

// used internally
// static Iostream_init __iostreaminit;	// initializes cin/cout/cerr/clog

#ifdef	_MSC_VER
// Restore previous packing
#pragma pack(pop)
#endif	// _MSC_VER

#endif	// _INC_IOSTREAM

#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\lmaccess.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    lmaccess.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetUser, NetUserModals, NetGroup, NetAccess, and NetLogon API.

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

//
// User Class
//

#ifndef _LMUSER_
#define _LMUSER_

#ifdef __cplusplus
extern "C" {
#endif

#include <lmcons.h>     // unfortunately created a dependence on this

//
// Function Prototypes - User
//

NET_API_STATUS NET_API_FUNCTION
NetUserAdd (
    IN  LPWSTR     servername OPTIONAL,
    IN  DWORD      level,
    IN  LPBYTE     buf,
    OUT LPDWORD    parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetUserEnum (
    IN  LPWSTR     servername OPTIONAL,
    IN  DWORD      level,
    IN  DWORD      filter,
    OUT LPBYTE     *bufptr,
    IN  DWORD      prefmaxlen,
    OUT LPDWORD    entriesread,
    OUT LPDWORD    totalentries,
    IN OUT LPDWORD resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetUserGetInfo (
    IN  LPWSTR     servername OPTIONAL,
    IN  LPWSTR     username,
    IN  DWORD      level,
    OUT LPBYTE     *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetUserSetInfo (
    IN  LPWSTR    servername OPTIONAL,
    IN  LPWSTR    username,
    IN  DWORD     level,
    IN  LPBYTE    buf,
    OUT LPDWORD   parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetUserDel (
    IN  LPWSTR    servername OPTIONAL,
    IN  LPWSTR    username
    );

NET_API_STATUS NET_API_FUNCTION
NetUserGetGroups (
    IN  LPWSTR    servername OPTIONAL,
    IN  LPWSTR    username,
    IN  DWORD     level,
    OUT LPBYTE    *bufptr,
    IN  DWORD     prefmaxlen,
    OUT LPDWORD   entriesread,
    OUT LPDWORD   totalentries
    );

NET_API_STATUS NET_API_FUNCTION
NetUserSetGroups (
    IN  LPWSTR    servername OPTIONAL,
    IN  LPWSTR    username,
    IN  DWORD     level,
    IN  LPBYTE    buf,
    IN  DWORD     num_entries
    );

NET_API_STATUS NET_API_FUNCTION
NetUserGetLocalGroups (
    IN  LPWSTR    servername OPTIONAL,
    IN  LPWSTR    username,
    IN  DWORD     level,
    IN  DWORD     flags,
    OUT LPBYTE    *bufptr,
    IN  DWORD     prefmaxlen,
    OUT LPDWORD   entriesread,
    OUT LPDWORD   totalentries
    );

NET_API_STATUS NET_API_FUNCTION
NetUserModalsGet (
    IN  LPWSTR    servername OPTIONAL,
    IN  DWORD     level,
    OUT LPBYTE    *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetUserModalsSet (
    IN  LPWSTR    servername OPTIONAL,
    IN  DWORD     level,
    IN  LPBYTE    buf,
    OUT LPDWORD   parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetUserChangePassword (
    IN  LPWSTR   domainname OPTIONAL,
    IN  LPWSTR   username OPTIONAL,
    IN  LPWSTR   oldpassword,
    IN  LPWSTR   newpassword
    );


//
//  Data Structures - User
//

typedef struct _USER_INFO_0 {
    LPWSTR   usri0_name;
}USER_INFO_0, *PUSER_INFO_0, *LPUSER_INFO_0;

typedef struct _USER_INFO_1 {
    LPWSTR   usri1_name;
    LPWSTR   usri1_password;
    DWORD    usri1_password_age;
    DWORD    usri1_priv;
    LPWSTR   usri1_home_dir;
    LPWSTR   usri1_comment;
    DWORD    usri1_flags;
    LPWSTR   usri1_script_path;
}USER_INFO_1, *PUSER_INFO_1, *LPUSER_INFO_1;

typedef struct _USER_INFO_2 {
    LPWSTR   usri2_name;
    LPWSTR   usri2_password;
    DWORD    usri2_password_age;
    DWORD    usri2_priv;
    LPWSTR   usri2_home_dir;
    LPWSTR   usri2_comment;
    DWORD    usri2_flags;
    LPWSTR   usri2_script_path;
    DWORD    usri2_auth_flags;
    LPWSTR   usri2_full_name;
    LPWSTR   usri2_usr_comment;
    LPWSTR   usri2_parms;
    LPWSTR   usri2_workstations;
    DWORD    usri2_last_logon;
    DWORD    usri2_last_logoff;
    DWORD    usri2_acct_expires;
    DWORD    usri2_max_storage;
    DWORD    usri2_units_per_week;
    PBYTE    usri2_logon_hours;
    DWORD    usri2_bad_pw_count;
    DWORD    usri2_num_logons;
    LPWSTR   usri2_logon_server;
    DWORD    usri2_country_code;
    DWORD    usri2_code_page;
}USER_INFO_2, *PUSER_INFO_2, *LPUSER_INFO_2;

typedef struct _USER_INFO_3 {
    LPWSTR   usri3_name;
    LPWSTR   usri3_password;
    DWORD    usri3_password_age;
    DWORD    usri3_priv;
    LPWSTR   usri3_home_dir;
    LPWSTR   usri3_comment;
    DWORD    usri3_flags;
    LPWSTR   usri3_script_path;
    DWORD    usri3_auth_flags;
    LPWSTR   usri3_full_name;
    LPWSTR   usri3_usr_comment;
    LPWSTR   usri3_parms;
    LPWSTR   usri3_workstations;
    DWORD    usri3_last_logon;
    DWORD    usri3_last_logoff;
    DWORD    usri3_acct_expires;
    DWORD    usri3_max_storage;
    DWORD    usri3_units_per_week;
    PBYTE    usri3_logon_hours;
    DWORD    usri3_bad_pw_count;
    DWORD    usri3_num_logons;
    LPWSTR   usri3_logon_server;
    DWORD    usri3_country_code;
    DWORD    usri3_code_page;
    DWORD    usri3_user_id;
    DWORD    usri3_primary_group_id;
    LPWSTR   usri3_profile;
    LPWSTR   usri3_home_dir_drive;
    DWORD    usri3_password_expired;
}USER_INFO_3, *PUSER_INFO_3, *LPUSER_INFO_3;

typedef struct _USER_INFO_10 {
    LPWSTR   usri10_name;
    LPWSTR   usri10_comment;
    LPWSTR   usri10_usr_comment;
    LPWSTR   usri10_full_name;
}USER_INFO_10, *PUSER_INFO_10, *LPUSER_INFO_10;

typedef struct _USER_INFO_11 {
    LPWSTR   usri11_name;
    LPWSTR   usri11_comment;
    LPWSTR   usri11_usr_comment;
    LPWSTR   usri11_full_name;
    DWORD    usri11_priv;
    DWORD    usri11_auth_flags;
    DWORD    usri11_password_age;
    LPWSTR   usri11_home_dir;
    LPWSTR   usri11_parms;
    DWORD    usri11_last_logon;
    DWORD    usri11_last_logoff;
    DWORD    usri11_bad_pw_count;
    DWORD    usri11_num_logons;
    LPWSTR   usri11_logon_server;
    DWORD    usri11_country_code;
    LPWSTR   usri11_workstations;
    DWORD    usri11_max_storage;
    DWORD    usri11_units_per_week;
    PBYTE    usri11_logon_hours;
    DWORD    usri11_code_page;
}USER_INFO_11, *PUSER_INFO_11, *LPUSER_INFO_11;

typedef struct _USER_INFO_20 {
    LPWSTR   usri20_name;
    LPWSTR   usri20_full_name;
    LPWSTR   usri20_comment;
    DWORD    usri20_flags;
    DWORD    usri20_user_id;
}USER_INFO_20, *PUSER_INFO_20, *LPUSER_INFO_20;

typedef struct _USER_INFO_21 {
    BYTE     usri21_password[ENCRYPTED_PWLEN];
}USER_INFO_21, *PUSER_INFO_21, *LPUSER_INFO_21;

typedef struct _USER_INFO_22 {
    LPWSTR   usri22_name;
    BYTE     usri22_password[ENCRYPTED_PWLEN];
    DWORD    usri22_password_age;
    DWORD    usri22_priv;
    LPWSTR   usri22_home_dir;
    LPWSTR   usri22_comment;
    DWORD    usri22_flags;
    LPWSTR   usri22_script_path;
    DWORD    usri22_auth_flags;
    LPWSTR   usri22_full_name;
    LPWSTR   usri22_usr_comment;
    LPWSTR   usri22_parms;
    LPWSTR   usri22_workstations;
    DWORD    usri22_last_logon;
    DWORD    usri22_last_logoff;
    DWORD    usri22_acct_expires;
    DWORD    usri22_max_storage;
    DWORD    usri22_units_per_week;
    PBYTE    usri22_logon_hours;
    DWORD    usri22_bad_pw_count;
    DWORD    usri22_num_logons;
    LPWSTR   usri22_logon_server;
    DWORD    usri22_country_code;
    DWORD    usri22_code_page;
}USER_INFO_22, *PUSER_INFO_22, *LPUSER_INFO_22;

typedef struct _USER_INFO_1003 {
     LPWSTR  usri1003_password;
} USER_INFO_1003, *PUSER_INFO_1003, *LPUSER_INFO_1003;

typedef struct _USER_INFO_1005 {
     DWORD   usri1005_priv;
} USER_INFO_1005, *PUSER_INFO_1005, *LPUSER_INFO_1005;

typedef struct _USER_INFO_1006 {
     LPWSTR  usri1006_home_dir;
} USER_INFO_1006, *PUSER_INFO_1006, *LPUSER_INFO_1006;

typedef struct _USER_INFO_1007 {
     LPWSTR  usri1007_comment;
} USER_INFO_1007, *PUSER_INFO_1007, *LPUSER_INFO_1007;

typedef struct _USER_INFO_1008 {
     DWORD   usri1008_flags;
} USER_INFO_1008, *PUSER_INFO_1008, *LPUSER_INFO_1008;

typedef struct _USER_INFO_1009 {
     LPWSTR  usri1009_script_path;
} USER_INFO_1009, *PUSER_INFO_1009, *LPUSER_INFO_1009;

typedef struct _USER_INFO_1010 {
     DWORD   usri1010_auth_flags;
} USER_INFO_1010, *PUSER_INFO_1010, *LPUSER_INFO_1010;

typedef struct _USER_INFO_1011 {
     LPWSTR  usri1011_full_name;
} USER_INFO_1011, *PUSER_INFO_1011, *LPUSER_INFO_1011;

typedef struct _USER_INFO_1012 {
     LPWSTR  usri1012_usr_comment;
} USER_INFO_1012, *PUSER_INFO_1012, *LPUSER_INFO_1012;

typedef struct _USER_INFO_1013 {
     LPWSTR  usri1013_parms;
} USER_INFO_1013, *PUSER_INFO_1013, *LPUSER_INFO_1013;

typedef struct _USER_INFO_1014 {
     LPWSTR  usri1014_workstations;
} USER_INFO_1014, *PUSER_INFO_1014, *LPUSER_INFO_1014;

typedef struct _USER_INFO_1017 {
     DWORD   usri1017_acct_expires;
} USER_INFO_1017, *PUSER_INFO_1017, *LPUSER_INFO_1017;

typedef struct _USER_INFO_1018 {
     DWORD   usri1018_max_storage;
} USER_INFO_1018, *PUSER_INFO_1018, *LPUSER_INFO_1018;

typedef struct _USER_INFO_1020 {
    DWORD   usri1020_units_per_week;
    LPBYTE  usri1020_logon_hours;
} USER_INFO_1020, *PUSER_INFO_1020, *LPUSER_INFO_1020;

typedef struct _USER_INFO_1023 {
     LPWSTR  usri1023_logon_server;
} USER_INFO_1023, *PUSER_INFO_1023, *LPUSER_INFO_1023;

typedef struct _USER_INFO_1024 {
     DWORD   usri1024_country_code;
} USER_INFO_1024, *PUSER_INFO_1024, *LPUSER_INFO_1024;

typedef struct _USER_INFO_1025 {
     DWORD   usri1025_code_page;
} USER_INFO_1025, *PUSER_INFO_1025, *LPUSER_INFO_1025;

typedef struct _USER_INFO_1051 {
     DWORD   usri1051_primary_group_id;
} USER_INFO_1051, *PUSER_INFO_1051, *LPUSER_INFO_1051;

typedef struct _USER_INFO_1052 {
     LPWSTR  usri1052_profile;
} USER_INFO_1052, *PUSER_INFO_1052, *LPUSER_INFO_1052;

typedef struct _USER_INFO_1053 {
     LPWSTR  usri1053_home_dir_drive;
} USER_INFO_1053, *PUSER_INFO_1053, *LPUSER_INFO_1053;


//
//  Data Structures - User Modals
//

typedef struct _USER_MODALS_INFO_0 {
    DWORD    usrmod0_min_passwd_len;
    DWORD    usrmod0_max_passwd_age;
    DWORD    usrmod0_min_passwd_age;
    DWORD    usrmod0_force_logoff;
    DWORD    usrmod0_password_hist_len;
}USER_MODALS_INFO_0, *PUSER_MODALS_INFO_0, *LPUSER_MODALS_INFO_0;

typedef struct _USER_MODALS_INFO_1 {
    DWORD    usrmod1_role;
    LPWSTR   usrmod1_primary;
}USER_MODALS_INFO_1, *PUSER_MODALS_INFO_1, *LPUSER_MODALS_INFO_1;

typedef struct _USER_MODALS_INFO_2 {
    LPWSTR  usrmod2_domain_name;
    PSID    usrmod2_domain_id;
}USER_MODALS_INFO_2, *PUSER_MODALS_INFO_2, *LPUSER_MODALS_INFO_2;

typedef struct _USER_MODALS_INFO_3 {
    DWORD   usrmod3_lockout_duration;
    DWORD   usrmod3_lockout_observation_window;
    DWORD   usrmod3_lockout_threshold;
}USER_MODALS_INFO_3, *PUSER_MODALS_INFO_3, *LPUSER_MODALS_INFO_3;

typedef struct _USER_MODALS_INFO_1001 {
     DWORD   usrmod1001_min_passwd_len;
} USER_MODALS_INFO_1001, *PUSER_MODALS_INFO_1001, *LPUSER_MODALS_INFO_1001;

typedef struct _USER_MODALS_INFO_1002 {
     DWORD   usrmod1002_max_passwd_age;
} USER_MODALS_INFO_1002, *PUSER_MODALS_INFO_1002, *LPUSER_MODALS_INFO_1002;

typedef struct _USER_MODALS_INFO_1003 {
     DWORD   usrmod1003_min_passwd_age;
} USER_MODALS_INFO_1003, *PUSER_MODALS_INFO_1003, *LPUSER_MODALS_INFO_1003;

typedef struct _USER_MODALS_INFO_1004 {
     DWORD   usrmod1004_force_logoff;
} USER_MODALS_INFO_1004, *PUSER_MODALS_INFO_1004, *LPUSER_MODALS_INFO_1004;

typedef struct _USER_MODALS_INFO_1005 {
     DWORD   usrmod1005_password_hist_len;
} USER_MODALS_INFO_1005, *PUSER_MODALS_INFO_1005, *LPUSER_MODALS_INFO_1005;

typedef struct _USER_MODALS_INFO_1006 {
     DWORD   usrmod1006_role;
} USER_MODALS_INFO_1006, *PUSER_MODALS_INFO_1006, *LPUSER_MODALS_INFO_1006;

typedef struct _USER_MODALS_INFO_1007 {
     LPWSTR  usrmod1007_primary;
} USER_MODALS_INFO_1007, *PUSER_MODALS_INFO_1007, *LPUSER_MODALS_INFO_1007;


//
// Special Values and Constants - User
//

//
//  Bit masks for field usriX_flags of USER_INFO_X (X = 0/1).
//

#define UF_SCRIPT               0x0001
#define UF_ACCOUNTDISABLE       0x0002
#define UF_HOMEDIR_REQUIRED     0x0008
#define UF_LOCKOUT              0x0010
#define UF_PASSWD_NOTREQD       0x0020
#define UF_PASSWD_CANT_CHANGE   0x0040

//
// Account type bits as part of usri_flags.
//

#define UF_TEMP_DUPLICATE_ACCOUNT       0x0100
#define UF_NORMAL_ACCOUNT               0x0200
#define UF_INTERDOMAIN_TRUST_ACCOUNT    0x0800
#define UF_WORKSTATION_TRUST_ACCOUNT    0x1000
#define UF_SERVER_TRUST_ACCOUNT         0x2000

#define UF_MACHINE_ACCOUNT_MASK ( UF_INTERDOMAIN_TRUST_ACCOUNT | \
                                  UF_WORKSTATION_TRUST_ACCOUNT | \
                                  UF_SERVER_TRUST_ACCOUNT )

#define UF_ACCOUNT_TYPE_MASK         ( \
                    UF_TEMP_DUPLICATE_ACCOUNT | \
                    UF_NORMAL_ACCOUNT | \
                    UF_INTERDOMAIN_TRUST_ACCOUNT | \
                    UF_WORKSTATION_TRUST_ACCOUNT | \
                    UF_SERVER_TRUST_ACCOUNT \
                )

#define UF_DONT_EXPIRE_PASSWD           0x10000


#define UF_SETTABLE_BITS        ( \
                    UF_SCRIPT | \
                    UF_ACCOUNTDISABLE | \
                    UF_LOCKOUT | \
                    UF_HOMEDIR_REQUIRED  | \
                    UF_PASSWD_NOTREQD | \
                    UF_PASSWD_CANT_CHANGE | \
                    UF_ACCOUNT_TYPE_MASK | \
                    UF_DONT_EXPIRE_PASSWD \
                )

//
// bit masks for the NetUserEnum filter parameter.
//

#define FILTER_TEMP_DUPLICATE_ACCOUNT       (0x0001)
#define FILTER_NORMAL_ACCOUNT               (0x0002)
// #define FILTER_PROXY_ACCOUNT                (0x0004)
#define FILTER_INTERDOMAIN_TRUST_ACCOUNT    (0x0008)
#define FILTER_WORKSTATION_TRUST_ACCOUNT    (0x0010)
#define FILTER_SERVER_TRUST_ACCOUNT         (0x0020)

//
// bit masks for the NetUserGetLocalGroups flags
//
#define LG_INCLUDE_INDIRECT         (0x0001)

//
//  Bit masks for field usri2_auth_flags of USER_INFO_2.
//

#define AF_OP_PRINT             0x1
#define AF_OP_COMM              0x2
#define AF_OP_SERVER            0x4
#define AF_OP_ACCOUNTS          0x8
#define AF_SETTABLE_BITS        (AF_OP_PRINT | AF_OP_COMM | \
                                AF_OP_SERVER | AF_OP_ACCOUNTS)

//
//  UAS role manifests under NETLOGON
//

#define UAS_ROLE_STANDALONE     0
#define UAS_ROLE_MEMBER         1
#define UAS_ROLE_BACKUP         2
#define UAS_ROLE_PRIMARY        3

//
//  Values for ParmError for NetUserSetInfo.
//

#define USER_NAME_PARMNUM               1
#define USER_PASSWORD_PARMNUM           3
#define USER_PASSWORD_AGE_PARMNUM       4
#define USER_PRIV_PARMNUM               5
#define USER_HOME_DIR_PARMNUM           6
#define USER_COMMENT_PARMNUM            7
#define USER_FLAGS_PARMNUM              8
#define USER_SCRIPT_PATH_PARMNUM        9
#define USER_AUTH_FLAGS_PARMNUM         10
#define USER_FULL_NAME_PARMNUM          11
#define USER_USR_COMMENT_PARMNUM        12
#define USER_PARMS_PARMNUM              13
#define USER_WORKSTATIONS_PARMNUM       14
#define USER_LAST_LOGON_PARMNUM         15
#define USER_LAST_LOGOFF_PARMNUM        16
#define USER_ACCT_EXPIRES_PARMNUM       17
#define USER_MAX_STORAGE_PARMNUM        18
#define USER_UNITS_PER_WEEK_PARMNUM     19
#define USER_LOGON_HOURS_PARMNUM        20
#define USER_PAD_PW_COUNT_PARMNUM       21
#define USER_NUM_LOGONS_PARMNUM         22
#define USER_LOGON_SERVER_PARMNUM       23
#define USER_COUNTRY_CODE_PARMNUM       24
#define USER_CODE_PAGE_PARMNUM          25
#define USER_PRIMARY_GROUP_PARMNUM      51
#define USER_PROFILE                    52 // ?? Delete when convenient
#define USER_PROFILE_PARMNUM            52
#define USER_HOME_DIR_DRIVE_PARMNUM     53

//
// the new infolevel counterparts of the old info level + parmnum
//

#define USER_NAME_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + USER_NAME_PARMNUM)
#define USER_PASSWORD_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + USER_PASSWORD_PARMNUM)
#define USER_PASSWORD_AGE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_PASSWORD_AGE_PARMNUM)
#define USER_PRIV_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + USER_PRIV_PARMNUM)
#define USER_HOME_DIR_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + USER_HOME_DIR_PARMNUM)
#define USER_COMMENT_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + USER_COMMENT_PARMNUM)
#define USER_FLAGS_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + USER_FLAGS_PARMNUM)
#define USER_SCRIPT_PATH_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + USER_SCRIPT_PATH_PARMNUM)
#define USER_AUTH_FLAGS_INFOLEVEL       \
            (PARMNUM_BASE_INFOLEVEL + USER_AUTH_FLAGS_PARMNUM)
#define USER_FULL_NAME_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + USER_FULL_NAME_PARMNUM)
#define USER_USR_COMMENT_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + USER_USR_COMMENT_PARMNUM)
#define USER_PARMS_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + USER_PARMS_PARMNUM)
#define USER_WORKSTATIONS_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_WORKSTATIONS_PARMNUM)
#define USER_LAST_LOGON_INFOLEVEL       \
            (PARMNUM_BASE_INFOLEVEL + USER_LAST_LOGON_PARMNUM)
#define USER_LAST_LOGOFF_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + USER_LAST_LOGOFF_PARMNUM)
#define USER_ACCT_EXPIRES_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_ACCT_EXPIRES_PARMNUM)
#define USER_MAX_STORAGE_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + USER_MAX_STORAGE_PARMNUM)
#define USER_UNITS_PER_WEEK_INFOLEVEL   \
            (PARMNUM_BASE_INFOLEVEL + USER_UNITS_PER_WEEK_PARMNUM)
#define USER_LOGON_HOURS_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + USER_LOGON_HOURS_PARMNUM)
#define USER_PAD_PW_COUNT_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_PAD_PW_COUNT_PARMNUM)
#define USER_NUM_LOGONS_INFOLEVEL       \
            (PARMNUM_BASE_INFOLEVEL + USER_NUM_LOGONS_PARMNUM)
#define USER_LOGON_SERVER_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_LOGON_SERVER_PARMNUM)
#define USER_COUNTRY_CODE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_COUNTRY_CODE_PARMNUM)
#define USER_CODE_PAGE_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + USER_CODE_PAGE_PARMNUM)
#define USER_PRIMARY_GROUP_INFOLEVEL    \
            (PARMNUM_BASE_INFOLEVEL + USER_PRIMARY_GROUP_PARMNUM)
#define USER_POSIX_ID_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + USER_POSIX_ID_PARMNUM)
#define USER_HOME_DIR_DRIVE_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + USER_HOME_DIR_DRIVE_PARMNUM)

//
//  For SetInfo call (parmnum 0) when password change not required
//

#define NULL_USERSETINFO_PASSWD     "              "

#define TIMEQ_FOREVER               ((unsigned long) -1L)
#define USER_MAXSTORAGE_UNLIMITED   ((unsigned long) -1L)
#define USER_NO_LOGOFF              ((unsigned long) -1L)
#define UNITS_PER_DAY               24
#define UNITS_PER_WEEK              UNITS_PER_DAY * 7

//
// Privilege levels (USER_INFO_X field usriX_priv (X = 0/1)).
//

#define USER_PRIV_MASK      0x3
#define USER_PRIV_GUEST     0
#define USER_PRIV_USER      1
#define USER_PRIV_ADMIN     2

//
// user modals related defaults
//

#define MAX_PASSWD_LEN      PWLEN
#define DEF_MIN_PWLEN       6
#define DEF_PWUNIQUENESS    5
#define DEF_MAX_PWHIST      8

#define DEF_MAX_PWAGE       TIMEQ_FOREVER               // forever
#define DEF_MIN_PWAGE       (unsigned long) 0L          // 0 days
#define DEF_FORCE_LOGOFF    (unsigned long) 0xffffffff  // never
#define DEF_MAX_BADPW       0                           // no limit
#define ONE_DAY             (unsigned long) 01*24*3600  // 01 day

//
// User Logon Validation (codes returned)
//

#define VALIDATED_LOGON         0
#define PASSWORD_EXPIRED        2
#define NON_VALIDATED_LOGON     3

#define VALID_LOGOFF            1

//
// parmnum manifests for user modals
//

#define MODALS_MIN_PASSWD_LEN_PARMNUM       1
#define MODALS_MAX_PASSWD_AGE_PARMNUM       2
#define MODALS_MIN_PASSWD_AGE_PARMNUM       3
#define MODALS_FORCE_LOGOFF_PARMNUM         4
#define MODALS_PASSWD_HIST_LEN_PARMNUM      5
#define MODALS_ROLE_PARMNUM                 6
#define MODALS_PRIMARY_PARMNUM              7
#define MODALS_DOMAIN_NAME_PARMNUM          8
#define MODALS_DOMAIN_ID_PARMNUM            9
#define MODALS_LOCKOUT_DURATION_PARMNUM     10
#define MODALS_LOCKOUT_OBSERVATION_WINDOW_PARMNUM 11
#define MODALS_LOCKOUT_THRESHOLD_PARMNUM    12

//
// the new infolevel counterparts of the old info level + parmnum
//

#define MODALS_MIN_PASSWD_LEN_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + MODALS_MIN_PASSWD_LEN_PARMNUM)
#define MODALS_MAX_PASSWD_AGE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + MODALS_MAX_PASSWD_AGE_PARMNUM)
#define MODALS_MIN_PASSWD_AGE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + MODALS_MIN_PASSWD_AGE_PARMNUM)
#define MODALS_FORCE_LOGOFF_INFOLEVEL       \
            (PARMNUM_BASE_INFOLEVEL + MODALS_FORCE_LOGOFF_PARMNUM)
#define MODALS_PASSWD_HIST_LEN_INFOLEVEL    \
            (PARMNUM_BASE_INFOLEVEL + MODALS_PASSWD_HIST_LEN_PARMNUM)
#define MODALS_ROLE_INFOLEVEL               \
            (PARMNUM_BASE_INFOLEVEL + MODALS_ROLE_PARMNUM)
#define MODALS_PRIMARY_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + MODALS_PRIMARY_PARMNUM)
#define MODALS_DOMAIN_NAME_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + MODALS_DOMAIN_NAME_PARMNUM)
#define MODALS_DOMAIN_ID_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + MODALS_DOMAIN_ID_PARMNUM)

#endif // _LMUSER_

//
// Group Class
//

#ifndef _LMGROUP_
#define _LMGROUP_

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetGroupAdd (
    IN  LPWSTR   servername OPTIONAL,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupAddUser (
    IN  LPWSTR   servername OPTIONAL,
    IN  LPWSTR   GroupName,
    IN  LPWSTR   username
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupEnum (
    IN  LPWSTR      servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupGetInfo (
    IN  LPWSTR   servername OPTIONAL,
    IN  LPWSTR   groupname,
    IN  DWORD    level,
    OUT LPBYTE   *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupSetInfo (
    IN  LPWSTR   servername OPTIONAL,
    IN  LPWSTR   groupname,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupDel (
    IN  LPWSTR   servername OPTIONAL,
    IN  LPWSTR   groupname
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupDelUser (
    IN  LPWSTR   servername OPTIONAL,
    IN  LPWSTR   GroupName,
    IN  LPWSTR   Username
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupGetUsers (
    IN  LPWSTR     servername OPTIONAL,
    IN  LPWSTR     groupname,
    IN  DWORD      level,
    OUT LPBYTE     *bufptr,
    IN  DWORD      prefmaxlen,
    OUT LPDWORD    entriesread,
    OUT LPDWORD    totalentries,
    IN OUT LPDWORD ResumeHandle
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupSetUsers (
    IN  LPWSTR     servername OPTIONAL,
    IN  LPWSTR     groupname,
    IN  DWORD      level,
    IN  LPBYTE     buf,
    IN  DWORD      totalentries
    );

//
//  Data Structures - Group
//

typedef struct _GROUP_INFO_0 {
    LPWSTR   grpi0_name;
}GROUP_INFO_0, *PGROUP_INFO_0, *LPGROUP_INFO_0;

typedef struct _GROUP_INFO_1 {
    LPWSTR   grpi1_name;
    LPWSTR   grpi1_comment;
}GROUP_INFO_1, *PGROUP_INFO_1, *LPGROUP_INFO_1;

typedef struct _GROUP_INFO_2 {
    LPWSTR   grpi2_name;
    LPWSTR   grpi2_comment;
    DWORD    grpi2_group_id;
    DWORD    grpi2_attributes;
}GROUP_INFO_2, *PGROUP_INFO_2;

typedef struct _GROUP_INFO_1002 {
     LPWSTR  grpi1002_comment;
} GROUP_INFO_1002, *PGROUP_INFO_1002, *LPGROUP_INFO_1002;

typedef struct _GROUP_INFO_1005 {
     DWORD  grpi1005_attributes;
} GROUP_INFO_1005, *PGROUP_INFO_1005, *LPGROUP_INFO_1005;


typedef struct _GROUP_USERS_INFO_0 {
     LPWSTR  grui0_name;
} GROUP_USERS_INFO_0, *PGROUP_USERS_INFO_0, *LPGROUP_USERS_INFO_0;

typedef struct _GROUP_USERS_INFO_1 {
     LPWSTR  grui1_name;
     DWORD   grui1_attributes;
} GROUP_USERS_INFO_1, *PGROUP_USERS_INFO_1, *LPGROUP_USERS_INFO_1;

//
// Special Values and Constants - Group
//

#define GROUPIDMASK                 0x8000      // MSB set if uid refers
                                                // to a group

//
// Predefined group for all normal users, administrators and guests
// LOCAL is a special group for pinball local security.
//

#define GROUP_SPECIALGRP_USERS      L"USERS"
#define GROUP_SPECIALGRP_ADMINS     L"ADMINS"
#define GROUP_SPECIALGRP_GUESTS     L"GUESTS"
#define GROUP_SPECIALGRP_LOCAL      L"LOCAL"

//
// parmnum manifests for SetInfo calls (only comment is settable)
//

#define GROUP_ALL_PARMNUM           0
#define GROUP_NAME_PARMNUM          1
#define GROUP_COMMENT_PARMNUM       2
#define GROUP_ATTRIBUTES_PARMNUM    3

//
// the new infolevel counterparts of the old info level + parmnum
//

#define GROUP_ALL_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + GROUP_ALL_PARMNUM)
#define GROUP_NAME_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + GROUP_NAME_PARMNUM)
#define GROUP_COMMENT_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + GROUP_COMMENT_PARMNUM)
#define GROUP_ATTRIBUTES_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + GROUP_ATTRIBUTES_PARMNUM)
#define GROUP_POSIX_ID_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + GROUP_POSIX_ID_PARMNUM)

#endif  // _LMGROUP_

//
// LocalGroup Class
//

#ifndef _LMLOCALGROUP_
#define _LMLOCALGROUP_

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupAdd (
    IN  LPWSTR   servername OPTIONAL,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupAddMember (
    IN  LPWSTR   servername OPTIONAL,
    IN  LPWSTR   groupname,
    IN  PSID     membersid
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupEnum (
    IN  LPWSTR      servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resumehandle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupGetInfo (
    IN  LPWSTR   servername OPTIONAL,
    IN  LPWSTR   groupname,
    IN  DWORD    level,
    OUT LPBYTE   *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupSetInfo (
    IN  LPWSTR   servername OPTIONAL,
    IN  LPWSTR   groupname,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupDel (
    IN  LPWSTR   servername OPTIONAL,
    IN  LPWSTR   groupname
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupDelMember (
    IN  LPWSTR   servername OPTIONAL,
    IN  LPWSTR   groupname,
    IN  PSID     membersid
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupGetMembers (
    IN  LPWSTR     servername OPTIONAL,
    IN  LPWSTR     localgroupname,
    IN  DWORD      level,
    OUT LPBYTE     *bufptr,
    IN  DWORD      prefmaxlen,
    OUT LPDWORD    entriesread,
    OUT LPDWORD    totalentries,
    IN OUT LPDWORD resumehandle
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupSetMembers (
    IN  LPWSTR     servername OPTIONAL,
    IN  LPWSTR     groupname,
    IN  DWORD      level,
    IN  LPBYTE     buf,
    IN  DWORD      totalentries
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupAddMembers (
    IN  LPWSTR     servername OPTIONAL,
    IN  LPWSTR     groupname,
    IN  DWORD      level,
    IN  LPBYTE     buf,
    IN  DWORD      totalentries
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupDelMembers (
    IN  LPWSTR     servername OPTIONAL,
    IN  LPWSTR     groupname,
    IN  DWORD      level,
    IN  LPBYTE     buf,
    IN  DWORD      totalentries
    );

//
//  Data Structures - LocalGroup
//

typedef struct _LOCALGROUP_INFO_0 {
    LPWSTR   lgrpi0_name;
}LOCALGROUP_INFO_0, *PLOCALGROUP_INFO_0, *LPLOCALGROUP_INFO_0;

typedef struct _LOCALGROUP_INFO_1 {
    LPWSTR   lgrpi1_name;
    LPWSTR   lgrpi1_comment;
}LOCALGROUP_INFO_1, *PLOCALGROUP_INFO_1, *LPLOCALGROUP_INFO_1;

typedef struct _LOCALGROUP_INFO_1002 {
     LPWSTR  lgrpi1002_comment;
}LOCALGROUP_INFO_1002, *PLOCALGROUP_INFO_1002, *LPLOCALGROUP_INFO_1002;

typedef struct _LOCALGROUP_MEMBERS_INFO_0 {
     PSID    lgrmi0_sid;
} LOCALGROUP_MEMBERS_INFO_0, *PLOCALGROUP_MEMBERS_INFO_0,
  *LPLOCALGROUP_MEMBERS_INFO_0;

typedef struct _LOCALGROUP_MEMBERS_INFO_1 {
     PSID         lgrmi1_sid;
     SID_NAME_USE lgrmi1_sidusage;
     LPWSTR       lgrmi1_name;
} LOCALGROUP_MEMBERS_INFO_1, *PLOCALGROUP_MEMBERS_INFO_1,
  *LPLOCALGROUP_MEMBERS_INFO_1;

typedef struct _LOCALGROUP_MEMBERS_INFO_2 {
     PSID         lgrmi2_sid;
     SID_NAME_USE lgrmi2_sidusage;
     LPWSTR       lgrmi2_domainandname;
} LOCALGROUP_MEMBERS_INFO_2, *PLOCALGROUP_MEMBERS_INFO_2,
  *LPLOCALGROUP_MEMBERS_INFO_2;

typedef struct _LOCALGROUP_MEMBERS_INFO_3 {
     LPWSTR       lgrmi3_domainandname;
} LOCALGROUP_MEMBERS_INFO_3, *PLOCALGROUP_MEMBERS_INFO_3,
  *LPLOCALGROUP_MEMBERS_INFO_3;

typedef struct _LOCALGROUP_USERS_INFO_0 {
     LPWSTR  lgrui0_name;
} LOCALGROUP_USERS_INFO_0, *PLOCALGROUP_USERS_INFO_0,
  *LPLOCALGROUP_USERS_INFO_0;


#define LOCALGROUP_NAME_PARMNUM          1
#define LOCALGROUP_COMMENT_PARMNUM       2

//
// Display Information APIs
//

NET_API_STATUS NET_API_FUNCTION
NetQueryDisplayInformation(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD Level,
    IN DWORD Index,
    IN DWORD EntriesRequested,
    IN DWORD PreferredMaximumLength,
    OUT LPDWORD ReturnedEntryCount,
    OUT PVOID   *SortedBuffer );

NET_API_STATUS NET_API_FUNCTION
NetGetDisplayInformationIndex(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD Level,
    IN LPWSTR Prefix,
    OUT LPDWORD Index );

//
// QueryDisplayInformation levels

typedef struct _NET_DISPLAY_USER {
    LPWSTR   usri1_name;
    LPWSTR   usri1_comment;
    DWORD    usri1_flags;
    LPWSTR   usri1_full_name;
    DWORD    usri1_user_id;
    DWORD    usri1_next_index;
} NET_DISPLAY_USER, *PNET_DISPLAY_USER;

typedef struct _NET_DISPLAY_MACHINE {
    LPWSTR   usri2_name;
    LPWSTR   usri2_comment;
    DWORD    usri2_flags;
    DWORD    usri2_user_id;
    DWORD    usri2_next_index;
} NET_DISPLAY_MACHINE, *PNET_DISPLAY_MACHINE;

typedef struct _NET_DISPLAY_GROUP {
    LPWSTR   grpi3_name;
    LPWSTR   grpi3_comment;
    DWORD    grpi3_group_id;
    DWORD    grpi3_attributes;
    DWORD    grpi3_next_index;
} NET_DISPLAY_GROUP, *PNET_DISPLAY_GROUP;

#endif  // _LMLOCALGROUP_

//
// Access Class
//

#ifndef _LMACCESS_
#define _LMACCESS_



//
// Function Prototypes - Access
//
//
// The NetAccess APIs are only available to downlevel
//

#define NetAccessAdd RxNetAccessAdd

NET_API_STATUS NET_API_FUNCTION
NetAccessAdd (
    IN  LPTSTR   servername OPTIONAL,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

#define NetAccessEnum RxNetAccessEnum

NET_API_STATUS NET_API_FUNCTION
NetAccessEnum (
    IN  LPTSTR     servername OPTIONAL,
    IN  LPTSTR     BasePath,
    IN  DWORD      Recursive,
    IN  DWORD      level,
    OUT LPBYTE     *bufptr,
    IN  DWORD      prefmaxlen,
    OUT LPDWORD    entriesread,
    OUT LPDWORD    totalentries,
    IN OUT LPDWORD resume_handle OPTIONAL
    );

#define NetAccessGetInfo RxNetAccessGetInfo

NET_API_STATUS NET_API_FUNCTION
NetAccessGetInfo (
    IN  LPTSTR   servername OPTIONAL,
    IN  LPTSTR   resource,
    IN  DWORD    level,
    OUT LPBYTE   *bufptr
    );

#define NetAccessSetInfo RxNetAccessSetInfo

NET_API_STATUS NET_API_FUNCTION
NetAccessSetInfo (
    IN  LPTSTR   servername OPTIONAL,
    IN  LPTSTR   resource,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

#define NetAccessDel RxNetAccessDel

NET_API_STATUS NET_API_FUNCTION
NetAccessDel (
    IN  LPTSTR   servername OPTIONAL,
    IN  LPTSTR   resource
    );

#define NetAccessGetUserPerms RxNetAccessGetUserPerms

NET_API_STATUS NET_API_FUNCTION
NetAccessGetUserPerms (
    IN  LPTSTR   servername OPTIONAL,
    IN  LPTSTR   UGname,
    IN  LPTSTR   resource,
    OUT LPDWORD  Perms
    );

//
// Data Structures - Access
//

typedef struct _ACCESS_INFO_0 {
    LPTSTR   acc0_resource_name;
}ACCESS_INFO_0, *PACCESS_INFO_0, *LPACCESS_INFO_0;

typedef struct _ACCESS_INFO_1 {
    LPTSTR   acc1_resource_name;
    DWORD    acc1_attr;
    DWORD    acc1_count;
}ACCESS_INFO_1, *PACCESS_INFO_1, *LPACCESS_INFO_1;

typedef struct _ACCESS_INFO_1002 {
     DWORD   acc1002_attr;
} ACCESS_INFO_1002, *PACCESS_INFO_1002, *LPACCESS_INFO_1002;


typedef struct _ACCESS_LIST {
    LPTSTR   acl_ugname;
    DWORD    acl_access;
}ACCESS_LIST, *PACCESS_LIST, *LPACCESS_LIST;

//
// Special Values and Constants - Access
//

//
// Maximum number of permission entries for each resource.
//

#define MAXPERMENTRIES      64

//
//  Bit values for the access permissions.  ACCESS_ALL is a handy
//  way to specify maximum permissions.  These are used in
//  acl_access field of access_list structures.
//

#define ACCESS_NONE         0
#define ACCESS_ALL          ( ACCESS_READ | \
                                ACCESS_WRITE | \
                                ACCESS_CREATE | \
                                ACCESS_EXEC | \
                                ACCESS_DELETE | \
                                ACCESS_ATRIB | \
                                ACCESS_PERM \
                            )

#define ACCESS_READ         0x01
#define ACCESS_WRITE        0x02
#define ACCESS_CREATE       0x04
#define ACCESS_EXEC         0x08
#define ACCESS_DELETE       0x10
#define ACCESS_ATRIB        0x20
#define ACCESS_PERM         0x40

#define ACCESS_GROUP        0x8000

//
// Bit values for the acc1_attr field of the ACCESS_INFO_1 structure.
//

#define ACCESS_AUDIT        0x1

#define ACCESS_SUCCESS_OPEN         0x10
#define ACCESS_SUCCESS_WRITE        0x20
#define ACCESS_SUCCESS_DELETE       0x40
#define ACCESS_SUCCESS_ACL          0x80
#define ACCESS_SUCCESS_MASK         0xF0

#define ACCESS_FAIL_OPEN            0x100
#define ACCESS_FAIL_WRITE           0x200
#define ACCESS_FAIL_DELETE          0x400
#define ACCESS_FAIL_ACL             0x800
#define ACCESS_FAIL_MASK            0xF00

#define ACCESS_FAIL_SHIFT           4

//
// Parmnum value for NetAccessSetInfo.
//

#define ACCESS_RESOURCE_NAME_PARMNUM    1
#define ACCESS_ATTR_PARMNUM             2
#define ACCESS_COUNT_PARMNUM            3
#define ACCESS_ACCESS_LIST_PARMNUM      4

//
// the new infolevel counterparts of the old info level + parmnum
//

#define ACCESS_RESOURCE_NAME_INFOLEVEL  \
            (PARMNUM_BASE_INFOLEVEL + ACCESS_RESOURCE_NAME_PARMNUM)
#define ACCESS_ATTR_INFOLEVEL           \
            (PARMNUM_BASE_INFOLEVEL + ACCESS_ATTR_PARMNUM)
#define ACCESS_COUNT_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + ACCESS_COUNT_PARMNUM)
#define ACCESS_ACCESS_LIST_INFOLEVEL    \
            (PARMNUM_BASE_INFOLEVEL + ACCESS_ACCESS_LIST_PARMNUM)

//
// ACCESS_LETTERS defines a letter for each bit position in
// the acl_access field of struct access_list.  Note that some
// bits have a corresponding letter of ' ' (space).
//

#define ACCESS_LETTERS      "RWCXDAP         "

#endif // _LMACCESS_

//
// Domain Class
//

#ifndef _LMDOMAIN_
#define _LMDOMAIN_

//
// Function Prototypes - Domain
//

NET_API_STATUS NET_API_FUNCTION
NetGetDCName (
    IN  LPWSTR   servername OPTIONAL,
    IN  LPWSTR   domainname OPTIONAL,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetGetAnyDCName (
    IN  LPWSTR   servername OPTIONAL,
    IN  LPWSTR   domainname OPTIONAL,
    OUT LPBYTE  *bufptr
    );


NET_API_STATUS NET_API_FUNCTION
I_NetLogonControl(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD FunctionCode,
    IN DWORD QueryLevel,
    OUT LPBYTE *Buffer
    );

NET_API_STATUS NET_API_FUNCTION
I_NetLogonControl2(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD FunctionCode,
    IN DWORD QueryLevel,
    IN LPBYTE Data,
    OUT LPBYTE *Buffer
    );



//
// Special Values and Constants - Domain
//

//
// FunctionCode values for I_NetLogonControl.
//
// NOTE : if you change the following NETLOGON_CONTROL_* values,
// change them in net\svcdlls\logonsrv\logon.idl file also.
//

#define NETLOGON_CONTROL_QUERY         1    // No-op: just query
#define NETLOGON_CONTROL_REPLICATE     2    // Force replicate on BDC
#define NETLOGON_CONTROL_SYNCHRONIZE   3    // Force synchronize on BDC
#define NETLOGON_CONTROL_PDC_REPLICATE 4    // Force PDC to broadcast change
#define NETLOGON_CONTROL_REDISCOVER    5    // Force to re-discover trusted domain DCs
#define NETLOGON_CONTROL_TC_QUERY      6    // Query status of specified trusted channel status

// Debug function codes

#define NETLOGON_CONTROL_BACKUP_CHANGE_LOG  0xFFFC
#define NETLOGON_CONTROL_TRUNCATE_LOG       0xFFFD
#define NETLOGON_CONTROL_SET_DBFLAG         0xFFFE
#define NETLOGON_CONTROL_BREAKPOINT         0xFFFF

//
// Query level 1 for I_NetLogonControl
//

typedef struct _NETLOGON_INFO_1 {
        DWORD netlog1_flags;
        NET_API_STATUS netlog1_pdc_connection_status;
} NETLOGON_INFO_1, *PNETLOGON_INFO_1;

typedef struct _NETLOGON_INFO_2 {
        DWORD netlog2_flags;
        NET_API_STATUS netlog2_pdc_connection_status;
#ifdef MIDL_PASS
        [string] wchar_t * netlog2_trusted_dc_name;
#else
        LPWSTR netlog2_trusted_dc_name;
#endif // MIDL_PASS
        NET_API_STATUS netlog2_tc_connection_status;
} NETLOGON_INFO_2, *PNETLOGON_INFO_2;

typedef struct _NETLOGON_INFO_3 {
        DWORD netlog3_flags;
        DWORD netlog3_logon_attempts;
        DWORD netlog3_reserved1;
        DWORD netlog3_reserved2;
        DWORD netlog3_reserved3;
        DWORD netlog3_reserved4;
        DWORD netlog3_reserved5;
} NETLOGON_INFO_3, *PNETLOGON_INFO_3;

//
// Values of netlog1_flags
//

#define NETLOGON_REPLICATION_NEEDED       0x01  // Database is out of date
#define NETLOGON_REPLICATION_IN_PROGRESS  0x02  // Replication is happening now
#define NETLOGON_FULL_SYNC_REPLICATION    0x04  // full sync replication required/progress
#define NETLOGON_REDO_NEEDED              0x08  // Redo of previous replication needed

#ifdef __cplusplus
}
#endif

#endif // _LMDOMAIN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\limits.h ===
/***
*limits.h - implementation dependent values
*
*	Copyright (c) 1985-1995, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Contains defines for a number of implementation dependent values
*	which are commonly used in C programs.
*	[ANSI]
*
*       [Public]
*
****/

#ifndef _INC_LIMITS
#define _INC_LIMITS

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#define CHAR_BIT	  8		/* number of bits in a char */
#define SCHAR_MIN	(-128)		/* minimum signed char value */
#define SCHAR_MAX	  127		/* maximum signed char value */
#define UCHAR_MAX	  0xff		/* maximum unsigned char value */

#ifndef _CHAR_UNSIGNED
#define CHAR_MIN	SCHAR_MIN	/* mimimum char value */
#define CHAR_MAX	SCHAR_MAX	/* maximum char value */
#else
#define CHAR_MIN	  0
#define CHAR_MAX	UCHAR_MAX
#endif	/* _CHAR_UNSIGNED */

#define	MB_LEN_MAX	  2		/* max. # bytes in multibyte char */
#define SHRT_MIN	(-32768)	/* minimum (signed) short value */
#define SHRT_MAX	  32767 	/* maximum (signed) short value */
#define USHRT_MAX	  0xffff	/* maximum unsigned short value */
#define INT_MIN 	(-2147483647 - 1) /* minimum (signed) int value */
#define INT_MAX 	  2147483647	/* maximum (signed) int value */
#define UINT_MAX	  0xffffffff	/* maximum unsigned int value */
#define LONG_MIN	(-2147483647L - 1) /* minimum (signed) long value */
#define LONG_MAX	  2147483647L	/* maximum (signed) long value */
#define ULONG_MAX	  0xffffffffUL	/* maximum unsigned long value */

#if	_INTEGRAL_MAX_BITS >= 8
#define _I8_MIN 	(-127i8 - 1)	/* minimum signed 8 bit value */
#define _I8_MAX 	  127i8		/* maximum signed 8 bit value */
#define _UI8_MAX	  0xffui8	/* maximum unsigned 8 bit value */
#endif

#if	_INTEGRAL_MAX_BITS >= 16
#define _I16_MIN	(-32767i16 - 1)	/* minimum signed 16 bit value */
#define _I16_MAX	  32767i16	/* maximum signed 16 bit value */
#define _UI16_MAX	  0xffffui16	/* maximum unsigned 16 bit value */
#endif

#if	_INTEGRAL_MAX_BITS >= 32
#define _I32_MIN	(-2147483647i32 - 1) /* minimum signed 32 bit value */
#define _I32_MAX	  2147483647i32 /* maximum signed 32 bit value */
#define _UI32_MAX	  0xffffffffui32 /* maximum unsigned 32 bit value */
#endif

#if	_INTEGRAL_MAX_BITS >= 64
/* minimum signed 64 bit value */
#define _I64_MIN	(-9223372036854775807i64 - 1)
/* maximum signed 64 bit value */
#define _I64_MAX	  9223372036854775807i64
/* maximum unsigned 64 bit value */
#define _UI64_MAX	  0xffffffffffffffffui64
#endif

#if	_INTEGRAL_MAX_BITS >= 128
/* minimum signed 128 bit value */
#define _I128_MIN	(-170141183460469231731687303715884105727i128 - 1)
/* maximum signed 128 bit value */
#define _I128_MAX	  170141183460469231731687303715884105727i128
/* maximum unsigned 128 bit value */
#define _UI128_MAX	  0xffffffffffffffffffffffffffffffffui128
#endif

#ifdef _POSIX_

#define _POSIX_ARG_MAX          4096
#define _POSIX_CHILD_MAX        6
#define _POSIX_LINK_MAX         8
#define _POSIX_MAX_CANON        255
#define _POSIX_MAX_INPUT        255
#define _POSIX_NAME_MAX         14
#define _POSIX_NGROUPS_MAX      0
#define _POSIX_OPEN_MAX         16
#define _POSIX_PATH_MAX         255
#define _POSIX_PIPE_BUF         512
#define _POSIX_SSIZE_MAX	32767
#define _POSIX_STREAM_MAX	8
#define _POSIX_TZNAME_MAX	3

#define ARG_MAX                 14500	/* 16k heap, minus overhead */
#define MAX_CANON               _POSIX_MAX_CANON
#define MAX_INPUT               _POSIX_MAX_INPUT
#define NAME_MAX		255
#define NGROUPS_MAX             16
#define OPEN_MAX                32
#define PATH_MAX                512
#define PIPE_BUF                _POSIX_PIPE_BUF
#define SSIZE_MAX		_POSIX_SSIZE_MAX
#define STREAM_MAX		20
#define TZNAME_MAX		10

#endif /* POSIX */

#endif	/* _INC_LIMITS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\lmalert.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    alert.h

Abstract:

    This file contains structures for communication with the Alerter
    service.

Environment:

    User Mode - Win32

Notes:

    You must include LmCons.H before this file, since this file depends
    on values defined in LmCons.H.

    ALERT.H includes ALERTMSG.H which defines the alert message numbers


--*/


#ifndef _ALERT_
#define _ALERT_


#ifdef __cplusplus
extern "C" {
#endif

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetAlertRaise(
    IN LPTSTR AlertEventName,
    IN LPVOID Buffer,
    IN DWORD BufferSize
    );

NET_API_STATUS NET_API_FUNCTION
NetAlertRaiseEx(
    IN LPTSTR AlertEventName,
    IN LPVOID VariableInfo,
    IN DWORD VariableInfoSize,
    IN LPTSTR ServiceName
    );


//
//  Data Structures
//

typedef struct _STD_ALERT {
    DWORD  alrt_timestamp;
    TCHAR  alrt_eventname[EVLEN + 1];
    TCHAR  alrt_servicename[SNLEN + 1];
}STD_ALERT, *PSTD_ALERT, *LPSTD_ALERT;

typedef struct _ADMIN_OTHER_INFO {
    DWORD  alrtad_errcode;
    DWORD  alrtad_numstrings;
}ADMIN_OTHER_INFO, *PADMIN_OTHER_INFO, *LPADMIN_OTHER_INFO;

typedef struct _ERRLOG_OTHER_INFO {
    DWORD  alrter_errcode;
    DWORD  alrter_offset;
}ERRLOG_OTHER_INFO, *PERRLOG_OTHER_INFO, *LPERRLOG_OTHER_INFO;

typedef struct _PRINT_OTHER_INFO {
    DWORD  alrtpr_jobid;
    DWORD  alrtpr_status;
    DWORD  alrtpr_submitted;
    DWORD  alrtpr_size;
}PRINT_OTHER_INFO, *PPRINT_OTHER_INFO, *LPPRINT_OTHER_INFO;

typedef struct _USER_OTHER_INFO {
    DWORD  alrtus_errcode;
    DWORD  alrtus_numstrings;
}USER_OTHER_INFO, *PUSER_OTHER_INFO, *LPUSER_OTHER_INFO;

//
// Special Values and Constants
//

//
// Name of mailslot to send alert notifications
//
#define ALERTER_MAILSLOT          TEXT("\\\\.\\MAILSLOT\\Alerter")

//
// The following macro gives a pointer to the other_info data.
// It takes an alert structure and returns a pointer to structure
// beyond the standard portion.
//

#define ALERT_OTHER_INFO(x)    ((LPBYTE)(x) + sizeof(STD_ALERT))

//
// The following macro gives a pointer to the variable-length data.
// It takes a pointer to one of the other-info structs and returns a
// pointer to the variable data portion.
//

#define ALERT_VAR_DATA(p)      ((LPBYTE)(p) + sizeof(*p))

//
//      Names of standard Microsoft-defined alert events.
//

#define ALERT_PRINT_EVENT           TEXT("PRINTING")
#define ALERT_MESSAGE_EVENT         TEXT("MESSAGE")
#define ALERT_ERRORLOG_EVENT        TEXT("ERRORLOG")
#define ALERT_ADMIN_EVENT           TEXT("ADMIN")
#define ALERT_USER_EVENT            TEXT("USER")

//
//      Bitmap masks for prjob_status field of PRINTJOB.
//

// 2-7 bits also used in device status

#define PRJOB_QSTATUS       0x3         // Bits 0,1
#define PRJOB_DEVSTATUS     0x1fc       // 2-8 bits
#define PRJOB_COMPLETE      0x4         // Bit 2
#define PRJOB_INTERV        0x8         // Bit 3
#define PRJOB_ERROR         0x10        // Bit 4
#define PRJOB_DESTOFFLINE   0x20        // Bit 5
#define PRJOB_DESTPAUSED    0x40        // Bit 6
#define PRJOB_NOTIFY        0x80        // BIT 7
#define PRJOB_DESTNOPAPER   0x100       // BIT 8
#define PRJOB_DELETED       0x8000      // BIT 15

//
//      Values of PRJOB_QSTATUS bits in prjob_status field of PRINTJOB.
//

#define PRJOB_QS_QUEUED                 0
#define PRJOB_QS_PAUSED                 1
#define PRJOB_QS_SPOOLING               2
#define PRJOB_QS_PRINTING               3


#ifdef __cplusplus
}
#endif

#endif // _ALERT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\istream.h ===
/***
*istream.h - definitions/declarations for the istream class
*
*       Copyright (c) 1990-1995, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the istream class.
*       [AT&T C++]
*
*       [Public]
*
****/

#ifdef __cplusplus

#ifndef _INC_ISTREAM
#define _INC_ISTREAM

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)
#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else   /* ndef _NTSDK */
/* current definition */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _NTSDK */
#endif  /* _CRTIMP */


#include <ios.h>

#ifdef  _MSC_VER
// C4069: "long double != double"
#pragma warning(disable:4069)   // disable C4069 warning
// #pragma warning(default:4069)    // use this to reenable, if desired

// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)    // use this to reenable, if desired
#endif  // _MSC_VER


typedef long streamoff, streampos;

class _CRTIMP istream : virtual public ios {

public:
    istream(streambuf*);
    virtual ~istream();

    int  ipfx(int =0);
    void isfx() { unlockbuf(); unlock(); }

    inline istream& operator>>(istream& (__cdecl * _f)(istream&));
    inline istream& operator>>(ios& (__cdecl * _f)(ios&));
    istream& operator>>(char *);
    inline istream& operator>>(unsigned char *);
    inline istream& operator>>(signed char *);
    istream& operator>>(char &);
    inline istream& operator>>(unsigned char &);
    inline istream& operator>>(signed char &);
    istream& operator>>(short &);
    istream& operator>>(unsigned short &);
    istream& operator>>(int &);
    istream& operator>>(unsigned int &);
    istream& operator>>(long &);
    istream& operator>>(unsigned long &);
    istream& operator>>(float &);
    istream& operator>>(double &);
    istream& operator>>(long double &);
    istream& operator>>(streambuf*);

    int get();

    inline istream& get(         char *,int,char ='\n');
    inline istream& get(unsigned char *,int,char ='\n');
    inline istream& get(  signed char *,int,char ='\n');

    istream& get(char &);
    inline istream& get(unsigned char &);
    inline istream& get(  signed char &);

    istream& get(streambuf&,char ='\n');
    inline istream& getline(         char *,int,char ='\n');
    inline istream& getline(unsigned char *,int,char ='\n');
    inline istream& getline(  signed char *,int,char ='\n');

    inline istream& ignore(int =1,int =EOF);
    istream& read(char *,int);
    inline istream& read(unsigned char *,int);
    inline istream& read(signed char *,int);

    int gcount() const { return x_gcount; }
    int peek();
    istream& putback(char);
    int sync();

    istream& seekg(streampos);
    istream& seekg(streamoff,ios::seek_dir);
    streampos tellg();

    void eatwhite();

protected:
    istream();
    istream(const istream&);    // treat as private
    istream& operator=(streambuf* _isb); // treat as private
    istream& operator=(const istream& _is) { return operator=(_is.rdbuf()); }
    istream& get(char *, int, int);
     int do_ipfx(int);

private:
    istream(ios&);
    int getint(char *);
    int getdouble(char *, int);
    int _fGline;
    int x_gcount;
};

    inline istream& istream::operator>>(istream& (__cdecl * _f)(istream&)) { (*_f)(*this); return *this; }
    inline istream& istream::operator>>(ios& (__cdecl * _f)(ios&)) { (*_f)(*this); return *this; }

    inline istream& istream::operator>>(unsigned char * _s) { return operator>>((char *)_s); }
    inline istream& istream::operator>>(  signed char * _s) { return operator>>((char *)_s); }

    inline istream& istream::operator>>(unsigned char & _c) { return operator>>((char &) _c); }
    inline istream& istream::operator>>(  signed char & _c) { return operator>>((char &) _c); }

    inline istream& istream::get(         char * _b, int _lim, char _delim) { return get(        _b, _lim, (int)(unsigned char)_delim); }
    inline istream& istream::get(unsigned char * _b, int _lim, char _delim) { return get((char *)_b, _lim, (int)(unsigned char)_delim); }
    inline istream& istream::get(signed   char * _b, int _lim, char _delim) { return get((char *)_b, _lim, (int)(unsigned char)_delim); }

    inline istream& istream::get(unsigned char & _c) { return get((char &)_c); }
    inline istream& istream::get(  signed char & _c) { return get((char &)_c); }

    inline istream& istream::getline(         char * _b,int _lim,char _delim) { lock(); _fGline++; get(        _b, _lim, (int)(unsigned char)_delim); unlock(); return *this; }
    inline istream& istream::getline(unsigned char * _b,int _lim,char _delim) { lock(); _fGline++; get((char *)_b, _lim, (int)(unsigned char)_delim); unlock(); return *this; }
    inline istream& istream::getline(  signed char * _b,int _lim,char _delim) { lock(); _fGline++; get((char *)_b, _lim, (int)(unsigned char)_delim); unlock(); return *this; }

    inline istream& istream::ignore(int _n,int _delim) { lock(); _fGline++; get((char *)0, _n+1, _delim); unlock(); return *this; }

    inline istream& istream::read(unsigned char * _ptr, int _n) { return read((char *) _ptr, _n); }
    inline istream& istream::read(  signed char * _ptr, int _n) { return read((char *) _ptr, _n); }

class _CRTIMP istream_withassign : public istream {
        public:
            istream_withassign();
            istream_withassign(streambuf*);
            ~istream_withassign();
    istream& operator=(const istream& _is) { return istream::operator=(_is); }
    istream& operator=(streambuf* _isb) { return istream::operator=(_isb); }
};

extern _CRTIMP istream_withassign cin;

inline _CRTIMP istream& __cdecl ws(istream& _ins) { _ins.eatwhite(); return _ins; }

_CRTIMP ios&        __cdecl dec(ios&);
_CRTIMP ios&        __cdecl hex(ios&);
_CRTIMP ios&        __cdecl oct(ios&);

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_ISTREAM

#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\lmat.h ===
/*++ BUILD Version: 0006    // Increment this if a change has global effects

Copyright (c) 1992-1995  Microsoft Corporation

Module Name:

    lmat.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the schedule service API-s.

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

Revision History:

--*/

#ifndef _LMAT_
#define _LMAT_

#ifdef __cplusplus
extern "C" {
#endif

//
//  The following bits are used with Flags field in structures below.
//

//
//  Do we exec programs for this job periodically (/EVERY switch) 
//  or one time (/NEXT switch).
//
#define JOB_RUN_PERIODICALLY            0x01    //  set if EVERY


//
//  Was there an error last time we tried to exec a program on behalf of
//  this job.
//  This flag is meaningfull on output only!
//
#define JOB_EXEC_ERROR                  0x02    //  set if error

//
//  Will this job run today or tomorrow.
//  This flag is meaningfull on output only!
//
#define JOB_RUNS_TODAY                  0x04    //  set if today

//
//  Add current day of the month to DaysOfMonth input.
//  This flag is meaningfull on input only!
//
#define JOB_ADD_CURRENT_DATE            0x08    // set if to add current date


//
//  Will this job be run interactively or not.  Windows NT 3.1 do not
//  know about this bit, i.e. they submit interactive jobs only.
//
#define JOB_NONINTERACTIVE              0x10    // set for noninteractive


#define JOB_INPUT_FLAGS     (   JOB_RUN_PERIODICALLY        |   \
                                JOB_ADD_CURRENT_DATE        |   \
                                JOB_NONINTERACTIVE  )

#define JOB_OUTPUT_FLAGS    (   JOB_RUN_PERIODICALLY        |   \
                                JOB_EXEC_ERROR              |   \
                                JOB_RUNS_TODAY              |   \
                                JOB_NONINTERACTIVE  )



typedef struct _AT_INFO {
    DWORD   JobTime;
    DWORD   DaysOfMonth;
    UCHAR   DaysOfWeek;
    UCHAR   Flags;
    LPWSTR  Command;
} AT_INFO, *PAT_INFO, *LPAT_INFO;

typedef struct _AT_ENUM {
    DWORD   JobId;
    DWORD   JobTime;
    DWORD   DaysOfMonth;
    UCHAR   DaysOfWeek;
    UCHAR   Flags;
    LPWSTR  Command;
} AT_ENUM, *PAT_ENUM, *LPAT_ENUM;

NET_API_STATUS NET_API_FUNCTION
NetScheduleJobAdd(
    IN      LPWSTR          Servername  OPTIONAL,
    IN      LPBYTE          Buffer,
    OUT     LPDWORD         JobId
    );

NET_API_STATUS NET_API_FUNCTION
NetScheduleJobDel(
    IN      LPWSTR          Servername  OPTIONAL,
    IN      DWORD           MinJobId,
    IN      DWORD           MaxJobId
    );

NET_API_STATUS NET_API_FUNCTION
NetScheduleJobEnum(
    IN      LPWSTR          Servername              OPTIONAL,
    OUT     LPBYTE *        PointerToBuffer,
    IN      DWORD           PrefferedMaximumLength,
    OUT     LPDWORD         EntriesRead,
    OUT     LPDWORD         TotalEntries,
    IN OUT  LPDWORD         ResumeHandle
    );

NET_API_STATUS NET_API_FUNCTION
NetScheduleJobGetInfo(
    IN      LPWSTR          Servername              OPTIONAL,
    IN      DWORD           JobId,
    OUT     LPBYTE *        PointerToBuffer
    );

#ifdef __cplusplus
}
#endif

#endif // _LMAT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\lmbrowsr.h ===
/*++ BUILD Version: 0007    // Increment this if a change has global effects

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    lmbrowsr.h

Abstract:

    This file contains information about browser stubbed versions of the
    NetServer APIs.
        Function Prototypes
        Data Structures
        Definition of special values

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.


--*/

#ifndef _LMBROWSR_
#define _LMBROWSR_

#ifdef __cplusplus
extern "C" {
#endif


typedef struct _BROWSER_STATISTICS {
    LARGE_INTEGER   StatisticsStartTime;
    LARGE_INTEGER   NumberOfServerAnnouncements;
    LARGE_INTEGER   NumberOfDomainAnnouncements;
    ULONG           NumberOfElectionPackets;
    ULONG           NumberOfMailslotWrites;
    ULONG           NumberOfGetBrowserServerListRequests;
    ULONG           NumberOfServerEnumerations;
    ULONG           NumberOfDomainEnumerations;
    ULONG           NumberOfOtherEnumerations;
    ULONG           NumberOfMissedServerAnnouncements;
    ULONG           NumberOfMissedMailslotDatagrams;
    ULONG           NumberOfMissedGetBrowserServerListRequests;
    ULONG           NumberOfFailedServerAnnounceAllocations;
    ULONG           NumberOfFailedMailslotAllocations;
    ULONG           NumberOfFailedMailslotReceives;
    ULONG           NumberOfFailedMailslotWrites;
    ULONG           NumberOfFailedMailslotOpens;
    ULONG           NumberOfDuplicateMasterAnnouncements;
    LARGE_INTEGER   NumberOfIllegalDatagrams;
} BROWSER_STATISTICS, *PBROWSER_STATISTICS, *LPBROWSER_STATISTICS;

typedef struct _BROWSER_STATISTICS_100 {
    LARGE_INTEGER   StartTime;
    LARGE_INTEGER   NumberOfServerAnnouncements;
    LARGE_INTEGER   NumberOfDomainAnnouncements;
    ULONG           NumberOfElectionPackets;
    ULONG           NumberOfMailslotWrites;
    ULONG           NumberOfGetBrowserServerListRequests;
    LARGE_INTEGER   NumberOfIllegalDatagrams;
} BROWSER_STATISTICS_100, *PBROWSER_STATISTICS_100;

typedef struct _BROWSER_STATISTICS_101 {
    LARGE_INTEGER   StartTime;
    LARGE_INTEGER   NumberOfServerAnnouncements;
    LARGE_INTEGER   NumberOfDomainAnnouncements;
    ULONG           NumberOfElectionPackets;
    ULONG           NumberOfMailslotWrites;
    ULONG           NumberOfGetBrowserServerListRequests;
    LARGE_INTEGER   NumberOfIllegalDatagrams;

    ULONG           NumberOfMissedServerAnnouncements;
    ULONG           NumberOfMissedMailslotDatagrams;
    ULONG           NumberOfMissedGetBrowserServerListRequests;
    ULONG           NumberOfFailedServerAnnounceAllocations;
    ULONG           NumberOfFailedMailslotAllocations;
    ULONG           NumberOfFailedMailslotReceives;
    ULONG           NumberOfFailedMailslotWrites;
    ULONG           NumberOfFailedMailslotOpens;
    ULONG           NumberOfDuplicateMasterAnnouncements;
} BROWSER_STATISTICS_101, *PBROWSER_STATISTICS_101;

//
// Function Prototypes - BROWSER
//

NET_API_STATUS NET_API_FUNCTION
I_BrowserServerEnum (
    IN  LPTSTR      servername OPTIONAL,
    IN  LPTSTR      transport OPTIONAL,
    IN  LPTSTR      clientname OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN  DWORD       servertype,
    IN  LPTSTR      domain OPTIONAL,
    IN OUT LPDWORD  resume_handle OPTIONAL
    );


NET_API_STATUS
I_BrowserQueryOtherDomains (
    IN  LPTSTR      servername OPTIONAL,
    OUT LPBYTE      *bufptr,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries
    );

NET_API_STATUS
I_BrowserResetNetlogonState (
    IN  LPTSTR      servername OPTIONAL
    );

NET_API_STATUS
I_BrowserSetNetlogonState(
    IN LPWSTR ServerName OPTIONAL,
    IN LPWSTR DomainName,
    IN LPWSTR EmulatedServerName OPTIONAL,
    IN DWORD Role
    );

#define BROWSER_ROLE_PDC 0x1
#define BROWSER_ROLE_BDC 0x2

NET_API_STATUS
I_BrowserQueryStatistics (
    IN  LPTSTR      servername OPTIONAL,
    OUT LPBROWSER_STATISTICS *statistics
    );

NET_API_STATUS
I_BrowserResetStatistics (
    IN  LPTSTR      servername OPTIONAL
    );


WORD
I_BrowserServerEnumForXactsrv(
    IN LPTSTR TransportName OPTIONAL,
    IN LPTSTR ClientName OPTIONAL,

    IN ULONG NtLevel,
    IN USHORT ClientLevel,

    OUT PVOID Buffer,
    IN WORD BufferLength,
    IN DWORD PreferedMaximumLength,

    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,

    IN DWORD ServerType,
    IN LPTSTR Domain,

    OUT PWORD Converter

    );

#ifdef __cplusplus
}
#endif

#if DBG
NET_API_STATUS
I_BrowserDebugTrace(
    PWCHAR Server,
    PCHAR Buffer
    );

#endif

#endif // _LMBROWSR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\lmconfig.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    lmconfig.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetConfig

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMCONFIG_
#define _LMCONFIG_

#ifdef __cplusplus
extern "C" {
#endif

#define REVISED_CONFIG_APIS

//
// Function Prototypes - Config
//

NET_API_STATUS NET_API_FUNCTION
NetConfigGet (
    IN  LPTSTR  server OPTIONAL,
    IN  LPTSTR  component,
    IN  LPTSTR  parameter,
#ifdef REVISED_CONFIG_APIS
    OUT LPBYTE  *bufptr
#else
    OUT LPBYTE  *bufptr,
    OUT LPDWORD totalavailable
#endif
    );

NET_API_STATUS NET_API_FUNCTION
NetConfigGetAll (
    IN  LPTSTR  server OPTIONAL,
    IN  LPTSTR  component,
#ifdef REVISED_CONFIG_APIS
    OUT LPBYTE  *bufptr
#else
    OUT LPBYTE  *bufptr,
    OUT LPDWORD totalavailable
#endif
    );


NET_API_STATUS NET_API_FUNCTION
NetConfigSet (
    IN  LPTSTR  server OPTIONAL,
    IN  LPTSTR  reserved1 OPTIONAL,
    IN  LPTSTR  component,
    IN  DWORD   level,
    IN  DWORD   reserved2,
    IN  LPBYTE  buf,
    IN  DWORD   reserved3
    );

//
// Data Structures - Config
//

typedef struct _CONFIG_INFO_0 {
     LPTSTR         cfgi0_key;
     LPTSTR         cfgi0_data;
} CONFIG_INFO_0, *PCONFIG_INFO_0, *LPCONFIG_INFO_0;


#ifdef __cplusplus
}
#endif

#endif  // _LMCONFIG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\lmcons.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1990-1995  Microsoft Corporation


    LMCONS.H (was NETCONS.H in LM 2.x)

Abstract:

    This file contains constants used throughout the LAN Manager
    API header files.  It should be included in any source file
    that is going to include other LAN Manager API header files or
    call a LAN Manager API.

    NOTE:  Lengths of strings are given as the maximum lengths of the
    string in characters (not bytes).  This does not include space for the
    terminating 0-characters.  When allocating space for such an item,
    use the form:

        TCHAR username[UNLEN+1];

    Definitions of the form LN20_* define those values in effect for
    LanMan 2.0.



--*/

/*NOINC*/
#ifndef NETCONS_INCLUDED

#define NETCONS_INCLUDED
/*INC*/

#ifndef PASCAL
#define PASCAL                          // pascal on OS/2
#endif

#ifndef FAR
#define FAR                             // far on OS/2
#endif

//
// String Lengths for various LanMan names
//

#define CNLEN       15                  // Computer name length
#define LM20_CNLEN  15                  // LM 2.0 Computer name length
#define DNLEN       CNLEN               // Maximum domain name length
#define LM20_DNLEN  LM20_CNLEN          // LM 2.0 Maximum domain name length

#if (CNLEN != DNLEN)
#error CNLEN and DNLEN are not equal
#endif

#define UNCLEN      (CNLEN+2)           // UNC computer name length
#define LM20_UNCLEN (LM20_CNLEN+2)      // LM 2.0 UNC computer name length

#define NNLEN       80                  // Net name length (share name)
#define LM20_NNLEN  12                  // LM 2.0 Net name length

#define RMLEN       (UNCLEN+1+NNLEN)    // Max remote name length
#define LM20_RMLEN  (LM20_UNCLEN+1+LM20_NNLEN) // LM 2.0 Max remote name length

#define SNLEN       80                  // Service name length
#define LM20_SNLEN  15                  // LM 2.0 Service name length
#define STXTLEN     256                 // Service text length
#define LM20_STXTLEN 63                 // LM 2.0 Service text length

#define PATHLEN     256                 // Max. path (not including drive name)
#define LM20_PATHLEN 256                // LM 2.0 Max. path

#define DEVLEN      80                  // Device name length
#define LM20_DEVLEN 8                   // LM 2.0 Device name length

#define EVLEN       16                  // Event name length

//
// User, Group and Password lengths
//

#define UNLEN       256                 // Maximum user name length
#define LM20_UNLEN  20                  // LM 2.0 Maximum user name length

#define GNLEN       UNLEN               // Group name
#define LM20_GNLEN  LM20_UNLEN          // LM 2.0 Group name

#define PWLEN       256                 // Maximum password length
#define LM20_PWLEN  14                  // LM 2.0 Maximum password length

#define SHPWLEN     8                   // Share password length (bytes)


#define CLTYPE_LEN  12                  // Length of client type string


#define MAXCOMMENTSZ 256                // Multipurpose comment length
#define LM20_MAXCOMMENTSZ 48            // LM 2.0 Multipurpose comment length

#define QNLEN       NNLEN               // Queue name maximum length
#define LM20_QNLEN  LM20_NNLEN          // LM 2.0 Queue name maximum length
#if (QNLEN != NNLEN)
# error QNLEN and NNLEN are not equal
#endif

//
// The ALERTSZ and MAXDEVENTRIES defines have not yet been NT'ized.
// Whoever ports these components should change these values appropriately.
//

#define ALERTSZ     128                 // size of alert string in server
#define MAXDEVENTRIES (sizeof (int)*8)  // Max number of device entries

                                        //
                                        // We use int bitmap to represent
                                        //

#define NETBIOS_NAME_LEN  16            // NetBIOS net name (bytes)

//
// Value to be used with APIs which have a "preferred maximum length"
// parameter.  This value indicates that the API should just allocate
// "as much as it takes."
//

#define MAX_PREFERRED_LENGTH    ((DWORD) -1)

//
//        Constants used with encryption
//

#define CRYPT_KEY_LEN           7
#define CRYPT_TXT_LEN           8
#define ENCRYPTED_PWLEN         16
#define SESSION_PWLEN           24
#define SESSION_CRYPT_KLEN      21

//
//  Value to be used with SetInfo calls to allow setting of all
//  settable parameters (parmnum zero option)
//
#ifndef PARMNUM_ALL
#define PARMNUM_ALL             0
#endif

#define PARM_ERROR_UNKNOWN      ( (DWORD) (-1) )
#define PARM_ERROR_NONE         0
#define PARMNUM_BASE_INFOLEVEL  1000

//
//        Message File Names
//

#define MESSAGE_FILENAME        TEXT("NETMSG")
#define OS2MSG_FILENAME         TEXT("BASE")
#define HELP_MSG_FILENAME       TEXT("NETH")

/**INTERNAL_ONLY**/

// The backup message file named here is a duplicate of net.msg. It
// is not shipped with the product, but is used at buildtime to
// msgbind certain messages to netapi.dll and some of the services.
// This allows for OEMs to modify the message text in net.msg and
// have those changes show up.        Only in case there is an error in
// retrieving the messages from net.msg do we then get the bound
// messages out of bak.msg (really out of the message segment).

#define BACKUP_MSG_FILENAME     TEXT("BAK.MSG")

/**END_INTERNAL**/

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif

//
// Keywords used in Function Prototypes
//

#define NET_API_STATUS          DWORD
#define API_RET_TYPE            NET_API_STATUS      // Old value: do not use
#if (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define NET_API_FUNCTION    __stdcall
#else
#define NET_API_FUNCTION
#endif

// Define pseudo-keywords.
#ifndef IN
#define IN
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef OUT
#define OUT
#endif
/*INC*/



//
// The platform ID indicates the levels to use for platform-specific
// information.
//

#define PLATFORM_ID_DOS 300
#define PLATFORM_ID_OS2 400
#define PLATFORM_ID_NT  500
#define PLATFORM_ID_OSF 600
#define PLATFORM_ID_VMS 700

//
//      There message numbers assigned to different LANMAN components
//      are as defined below.
//
//      lmerr.h:        2100 - 2999     NERR_BASE
//      alertmsg.h:     3000 - 3049     ALERT_BASE
//      lmsvc.h:        3050 - 3099     SERVICE_BASE
//      lmerrlog.h:     3100 - 3299     ERRLOG_BASE
//      msgtext.h:      3300 - 3499     MTXT_BASE
//      apperr.h:       3500 - 3999     APPERR_BASE
//      apperrfs.h:     4000 - 4299     APPERRFS_BASE
//      apperr2.h:      4300 - 5299     APPERR2_BASE
//      ncberr.h:       5300 - 5499     NRCERR_BASE
//      alertmsg.h:     5500 - 5599     ALERT2_BASE
//      lmsvc.h:        5600 - 5699     SERVICE2_BASE
//      lmerrlog.h      5700 - 5799     ERRLOG2_BASE
//

#define MIN_LANMAN_MESSAGE_ID  NERR_BASE
#define MAX_LANMAN_MESSAGE_ID  5799

/*NOINC*/
#endif // NETCONS_INCLUDED
/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\lmchdev.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    lmchdev.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetCharDev
        NetCharDevQ
        NetHandle

[Environment:]

    User Mode - Win32

[Notes:]

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMCHDEV_
#define _LMCHDEV_

#ifdef __cplusplus
extern "C" {
#endif

//
// CharDev Class
//

//
// Function Prototypes - CharDev
//

NET_API_STATUS NET_API_FUNCTION
NetCharDevEnum (
    IN  LPTSTR      servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle
    );

NET_API_STATUS NET_API_FUNCTION
NetCharDevGetInfo (
    IN  LPTSTR  servername,
    IN  LPTSTR  devname,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetCharDevControl (
    IN  LPTSTR  servername,
    IN  LPTSTR  devname,
    IN  DWORD   opcode
    );

//
// Data Structures - CharDev
//

typedef struct _CHARDEV_INFO_0 {
    LPTSTR  ch0_dev;
} CHARDEV_INFO_0, *PCHARDEV_INFO_0, *LPCHARDEV_INFO_0;

typedef struct _CHARDEV_INFO_1 {
    LPTSTR  ch1_dev;
    DWORD   ch1_status;
    LPTSTR  ch1_username;
    DWORD   ch1_time;
} CHARDEV_INFO_1, *PCHARDEV_INFO_1, *LPCHARDEV_INFO_1;


//
// CharDevQ Class
//

//
// Function Prototypes - CharDevQ
//

NET_API_STATUS NET_API_FUNCTION
NetCharDevQEnum (
    IN  LPTSTR      servername,
    IN  LPTSTR      username,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle
    );

NET_API_STATUS NET_API_FUNCTION
NetCharDevQGetInfo (
    IN  LPTSTR  servername,
    IN  LPTSTR  queuename,
    IN  LPTSTR  username,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetCharDevQSetInfo (
    IN  LPTSTR  servername,
    IN  LPTSTR  queuename,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err
    );

NET_API_STATUS NET_API_FUNCTION
NetCharDevQPurge (
    IN  LPTSTR  servername,
    IN  LPTSTR  queuename
    );

NET_API_STATUS NET_API_FUNCTION
NetCharDevQPurgeSelf (
    IN  LPTSTR  servername,
    IN  LPTSTR  queuename,
    IN  LPTSTR  computername
    );

//
// Data Structures - CharDevQ
//

typedef struct _CHARDEVQ_INFO_0 {
    LPTSTR  cq0_dev;
} CHARDEVQ_INFO_0, *PCHARDEVQ_INFO_0, *LPCHARDEVQ_INFO_0;

typedef struct _CHARDEVQ_INFO_1 {
    LPTSTR  cq1_dev;
    DWORD   cq1_priority;
    LPTSTR  cq1_devs;
    DWORD   cq1_numusers;
    DWORD   cq1_numahead;
} CHARDEVQ_INFO_1, *PCHARDEVQ_INFO_1, *LPCHARDEVQ_INFO_1;

typedef struct _CHARDEVQ_INFO_1002 {
    DWORD   cq1002_priority;
} CHARDEVQ_INFO_1002, *PCHARDEVQ_INFO_1002, *LPCHARDEVQ_INFO_1002;

typedef struct _CHARDEVQ_INFO_1003 {
    LPTSTR  cq1003_devs;
} CHARDEVQ_INFO_1003, *PCHARDEVQ_INFO_1003, *LPCHARDEVQ_INFO_1003;


//
// Special Values and Constants
//

//
//      Bits for chardev_info_1 field ch1_status.
//

#define CHARDEV_STAT_OPENED             0x02
#define CHARDEV_STAT_ERROR              0x04

//
//      Opcodes for NetCharDevControl
//

#define CHARDEV_CLOSE                   0

//
// Values for parm_err parameter.
//

#define CHARDEVQ_DEV_PARMNUM        1
#define CHARDEVQ_PRIORITY_PARMNUM   2
#define CHARDEVQ_DEVS_PARMNUM       3
#define CHARDEVQ_NUMUSERS_PARMNUM   4
#define CHARDEVQ_NUMAHEAD_PARMNUM   5

//
// Single-field infolevels for NetCharDevQSetInfo.
//

#define CHARDEVQ_PRIORITY_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + CHARDEVQ_PRIORITY_PARMNUM)
#define CHARDEVQ_DEVS_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + CHARDEVQ_DEVS_PARMNUM)

//
//      Minimum, maximum, and recommended default for priority.
//

#define CHARDEVQ_MAX_PRIORITY           1
#define CHARDEVQ_MIN_PRIORITY           9
#define CHARDEVQ_DEF_PRIORITY           5

//
//      Value indicating no requests in the queue.
//

#define CHARDEVQ_NO_REQUESTS            -1

#endif // _LMCHDEV_

//
// Handle Class
//

#ifndef _LMHANDLE_
#define _LMHANDLE_

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetHandleGetInfo (
    IN  HANDLE  handle,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetHandleSetInfo (
    IN  HANDLE  handle,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    IN  DWORD   parmnum,
    OUT LPDWORD parmerr
    );

//
//  Data Structures
//

typedef struct _HANDLE_INFO_1 {
    DWORD   hdli1_chartime;
    DWORD   hdli1_charcount;
}HANDLE_INFO_1, *PHANDLE_INFO_1, *LPHANDLE_INFO_1;

//
// Special Values and Constants
//

//
//      Handle Get Info Levels
//

#define HANDLE_INFO_LEVEL_1                 1

//
//      Handle Set Info parm numbers
//

#define HANDLE_CHARTIME_PARMNUM     1
#define HANDLE_CHARCOUNT_PARMNUM    2

#ifdef __cplusplus
}
#endif

#endif // _LMHANDLE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\lmapibuf.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    lmapibuf.h

Abstract:

    This file contains information about NetApiBuffer APIs.

Environment:

    User Mode - Win32

Notes:

    You must include LMCONS.H before this file, since this file depends
    on values defined in LMCONS.H.

--*/

#ifndef _LMAPIBUF_
#define _LMAPIBUF_

#ifdef __cplusplus
extern "C" {
#endif

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetApiBufferAllocate(
    IN DWORD ByteCount,
    OUT LPVOID * Buffer
    );

NET_API_STATUS NET_API_FUNCTION
NetApiBufferFree (
    IN LPVOID Buffer
    );

NET_API_STATUS NET_API_FUNCTION
NetApiBufferReallocate(
    IN LPVOID OldBuffer OPTIONAL,
    IN DWORD NewByteCount,
    OUT LPVOID * NewBuffer
    );

NET_API_STATUS NET_API_FUNCTION
NetApiBufferSize(
    IN LPVOID Buffer,
    OUT LPDWORD ByteCount
    );


//
// The following private function will go away eventually.
// Call NetApiBufferAllocate instead.
//
NET_API_STATUS NET_API_FUNCTION
NetapipBufferAllocate (                 // Internal Function
    IN DWORD ByteCount,
    OUT LPVOID * Buffer
    );

#ifdef __cplusplus
}
#endif

#endif // _LMAPIBUF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\lmaudit.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    lmaudit.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetAudit

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMAUDIT_
#define _LMAUDIT_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _LMHLOGDEFINED_
#define _LMHLOGDEFINED_

typedef struct _HLOG {
     DWORD          time;
     DWORD          last_flags;
     DWORD          offset;
     DWORD          rec_offset;
} HLOG, *PHLOG, *LPHLOG;

#define LOGFLAGS_FORWARD	0
#define LOGFLAGS_BACKWARD	0x1
#define LOGFLAGS_SEEK		0x2

#endif

//
// Function Prototypes - Audit
//

NET_API_STATUS NET_API_FUNCTION
NetAuditClear (
    IN  LPTSTR  server OPTIONAL,
    IN  LPTSTR  backupfile OPTIONAL,
    IN  LPTSTR  service OPTIONAL  // WARNING: buggy support before LM 2.0C!!
    );

NET_API_STATUS NET_API_FUNCTION
NetAuditRead (
    IN  LPTSTR  server OPTIONAL,
    IN  LPTSTR  service OPTIONAL,  // WARNING: buggy support before LM 2.0C!!
    IN  LPHLOG  auditloghandle,
    IN  DWORD   offset,
    IN  LPDWORD reserved1 OPTIONAL,
    IN  DWORD   reserved2,
    IN  DWORD   offsetflag,
    OUT LPBYTE  *bufptr,
    IN  DWORD   prefmaxlen,
    OUT LPDWORD bytesread,
    OUT LPDWORD totalavailable
    );

NET_API_STATUS NET_API_FUNCTION
NetAuditWrite (
    IN  DWORD   type,
    IN  LPBYTE  buf,
    IN  DWORD   numbytes,
    IN  LPTSTR  service OPTIONAL,
    IN  LPBYTE  reserved OPTIONAL
    );


//
// Data Structures - Audit
//

typedef struct _AUDIT_ENTRY {
     DWORD          ae_len;
     DWORD          ae_reserved;
     DWORD          ae_time;
     DWORD          ae_type;
     DWORD          ae_data_offset;  /* Offset from beginning
                              address of audit_entry */
     DWORD          ae_data_size;  // byte count of ae_data area (not incl pad).
} AUDIT_ENTRY, *PAUDIT_ENTRY, *LPAUDIT_ENTRY;

// BUGBUG: Temporary to let users ifdef on this struct layout.
#define REVISED_AUDIT_ENTRY_STRUCT


typedef struct _AE_SRVSTATUS {
     DWORD	    ae_sv_status;
} AE_SRVSTATUS, *PAE_SRVSTATUS, *LPAE_SRVSTATUS;

typedef struct _AE_SESSLOGON {
     DWORD          ae_so_compname;
     DWORD          ae_so_username;
     DWORD          ae_so_privilege;
} AE_SESSLOGON, *PAE_SESSLOGON, *LPAE_SESSLOGON;

typedef struct _AE_SESSLOGOFF {
     DWORD          ae_sf_compname;
     DWORD          ae_sf_username;
     DWORD          ae_sf_reason;
} AE_SESSLOGOFF, *PAE_SESSLOGOFF, *LPAE_SESSLOGOFF;

typedef struct _AE_SESSPWERR {
     DWORD          ae_sp_compname;
     DWORD          ae_sp_username;
} AE_SESSPWERR, *PAE_SESSPWERR, *LPAE_SESSPWERR;

typedef struct _AE_CONNSTART {
     DWORD          ae_ct_compname;
     DWORD          ae_ct_username;
     DWORD          ae_ct_netname;
     DWORD          ae_ct_connid;
} AE_CONNSTART, *PAE_CONNSTART, *LPAE_CONNSTART;

typedef struct _AE_CONNSTOP {
     DWORD          ae_cp_compname;
     DWORD          ae_cp_username;
     DWORD          ae_cp_netname;
     DWORD          ae_cp_connid;
     DWORD          ae_cp_reason;
} AE_CONNSTOP, *PAE_CONNSTOP, *LPAE_CONNSTOP;

typedef struct _AE_CONNREJ {
     DWORD          ae_cr_compname;
     DWORD          ae_cr_username;
     DWORD          ae_cr_netname;
     DWORD          ae_cr_reason;
} AE_CONNREJ, *PAE_CONNREJ, *LPAE_CONNREJ;

typedef struct _AE_RESACCESS {
     DWORD          ae_ra_compname;
     DWORD          ae_ra_username;
     DWORD          ae_ra_resname;
     DWORD          ae_ra_operation;
     DWORD          ae_ra_returncode;
     DWORD          ae_ra_restype;
     DWORD          ae_ra_fileid;
} AE_RESACCESS, *PAE_RESACCESS, *LPAE_RESACCESS;

typedef struct _AE_RESACCESSREJ {
     DWORD          ae_rr_compname;
     DWORD          ae_rr_username;
     DWORD          ae_rr_resname;
     DWORD          ae_rr_operation;
} AE_RESACCESSREJ, *PAE_RESACCESSREJ, *LPAE_RESACCESSREJ;

typedef struct _AE_CLOSEFILE {
     DWORD          ae_cf_compname;
     DWORD          ae_cf_username;
     DWORD          ae_cf_resname;
     DWORD          ae_cf_fileid;
     DWORD          ae_cf_duration;
     DWORD          ae_cf_reason;
} AE_CLOSEFILE, *PAE_CLOSEFILE, *LPAE_CLOSEFILE;

typedef struct _AE_SERVICESTAT {
     DWORD          ae_ss_compname;
     DWORD          ae_ss_username;
     DWORD          ae_ss_svcname;
     DWORD          ae_ss_status;
     DWORD          ae_ss_code;
     DWORD          ae_ss_text;
     DWORD          ae_ss_returnval;
} AE_SERVICESTAT, *PAE_SERVICESTAT, *LPAE_SERVICESTAT;

typedef struct _AE_ACLMOD {
     DWORD          ae_am_compname;
     DWORD          ae_am_username;
     DWORD          ae_am_resname;
     DWORD          ae_am_action;
     DWORD          ae_am_datalen;
} AE_ACLMOD, *PAE_ACLMOD, *LPAE_ACLMOD;

typedef struct _AE_UASMOD {
     DWORD          ae_um_compname;
     DWORD          ae_um_username;
     DWORD          ae_um_resname;
     DWORD          ae_um_rectype;
     DWORD          ae_um_action;
     DWORD          ae_um_datalen;
} AE_UASMOD, *PAE_UASMOD, *LPAE_UASMOD;

typedef struct _AE_NETLOGON {
     DWORD          ae_no_compname;
     DWORD          ae_no_username;
     DWORD          ae_no_privilege;
     DWORD          ae_no_authflags;
} AE_NETLOGON, *PAE_NETLOGON, *LPAE_NETLOGON;

typedef struct _AE_NETLOGOFF {
     DWORD          ae_nf_compname;
     DWORD          ae_nf_username;
     DWORD          ae_nf_reserved1;
     DWORD          ae_nf_reserved2;
} AE_NETLOGOFF, *PAE_NETLOGOFF, *LPAE_NETLOGOFF;

typedef struct _AE_ACCLIM {
     DWORD          ae_al_compname;
     DWORD          ae_al_username;
     DWORD          ae_al_resname;
     DWORD          ae_al_limit;
} AE_ACCLIM, *PAE_ACCLIM, *LPAE_ACCLIM;

#define ACTION_LOCKOUT          00
#define ACTION_ADMINUNLOCK      01

typedef struct _AE_LOCKOUT {
    DWORD           ae_lk_compname;     // Ptr to computername of client.
    DWORD           ae_lk_username;     // Ptr to username of client (NULL
                                        //  if same as computername).
    DWORD           ae_lk_action;       // Action taken on account:
                                        // 0 means locked out, 1 means not.
    DWORD           ae_lk_bad_pw_count; // Bad password count at the time
                                        // of lockout.
} AE_LOCKOUT, *PAE_LOCKOUT, *LPAE_LOCKOUT;

typedef struct _AE_GENERIC {
     DWORD          ae_ge_msgfile;
     DWORD          ae_ge_msgnum;
     DWORD          ae_ge_params;
     DWORD          ae_ge_param1;
     DWORD          ae_ge_param2;
     DWORD          ae_ge_param3;
     DWORD          ae_ge_param4;
     DWORD          ae_ge_param5;
     DWORD          ae_ge_param6;
     DWORD          ae_ge_param7;
     DWORD          ae_ge_param8;
     DWORD          ae_ge_param9;
} AE_GENERIC, *PAE_GENERIC, *LPAE_GENERIC;

//
// Special Values and Constants - Audit
//

//
// 	Audit entry types (field ae_type in audit_entry).
//

#define AE_SRVSTATUS	0
#define AE_SESSLOGON	1
#define AE_SESSLOGOFF	2
#define AE_SESSPWERR	3
#define AE_CONNSTART	4
#define AE_CONNSTOP	5
#define AE_CONNREJ	6
#define AE_RESACCESS	7
#define AE_RESACCESSREJ	8
#define AE_CLOSEFILE	9
#define AE_SERVICESTAT	11
#define AE_ACLMOD	12
#define AE_UASMOD	13
#define AE_NETLOGON	14
#define AE_NETLOGOFF	15
#define AE_NETLOGDENIED 16
#define AE_ACCLIMITEXCD 17
#define AE_RESACCESS2	18
#define AE_ACLMODFAIL	19
#define AE_LOCKOUT      20
#define AE_GENERIC_TYPE 21
//
//	Values for ae_ss_status field of ae_srvstatus.
//

#define AE_SRVSTART	0
#define AE_SRVPAUSED	1
#define AE_SRVCONT	2
#define AE_SRVSTOP	3

//
// 	Values for ae_so_privilege field of ae_sesslogon.
//

#define AE_GUEST	0		
#define AE_USER		1
#define AE_ADMIN	2

//
//	Values for various ae_XX_reason fields.
//

#define AE_NORMAL	0		
#define AE_USERLIMIT	0
#define AE_GENERAL	0
#define AE_ERROR	1
#define AE_SESSDIS	1
#define AE_BADPW	1
#define AE_AUTODIS	2
#define AE_UNSHARE	2
#define AE_ADMINPRIVREQD 2
#define AE_ADMINDIS	3
#define AE_NOACCESSPERM 3
#define AE_ACCRESTRICT	4

#define	AE_NORMAL_CLOSE	0
#define	AE_SES_CLOSE	1
#define	AE_ADMIN_CLOSE	2

//
// Values for xx_subreason fields.
//

#define AE_LIM_UNKNOWN	    0
#define AE_LIM_LOGONHOURS   1
#define AE_LIM_EXPIRED	    2
#define AE_LIM_INVAL_WKSTA  3
#define AE_LIM_DISABLED     4
#define AE_LIM_DELETED	    5

//
// Values for xx_action fields
//

#define AE_MOD		0
#define AE_DELETE	1
#define AE_ADD		2

//
// Types of UAS record for um_rectype field
//

#define AE_UAS_USER	    0
#define AE_UAS_GROUP	    1
#define AE_UAS_MODALS	    2

//
// Bitmasks for auditing events
//
// The parentheses around the hex constants broke h_to_inc
// and have been purged from the face of the earth.
//

#define SVAUD_SERVICE           0x1
#define SVAUD_GOODSESSLOGON     0x6
#define SVAUD_BADSESSLOGON      0x18
#define SVAUD_SESSLOGON         (SVAUD_GOODSESSLOGON | SVAUD_BADSESSLOGON)
#define SVAUD_GOODNETLOGON      0x60
#define SVAUD_BADNETLOGON       0x180
#define SVAUD_NETLOGON          (SVAUD_GOODNETLOGON | SVAUD_BADNETLOGON)
#define SVAUD_LOGON             (SVAUD_NETLOGON | SVAUD_SESSLOGON)
#define SVAUD_GOODUSE           0x600
#define SVAUD_BADUSE            0x1800
#define SVAUD_USE               (SVAUD_GOODUSE | SVAUD_BADUSE)
#define SVAUD_USERLIST          0x2000
#define SVAUD_PERMISSIONS       0x4000
#define SVAUD_RESOURCE          0x8000
#define SVAUD_LOGONLIM		0x00010000

//
// Resource access audit bitmasks.
//

#define AA_AUDIT_ALL	    0x0001
#define AA_A_OWNER	    0x0004
#define AA_CLOSE	    0x0008
#define AA_S_OPEN	    0x0010
#define AA_S_WRITE	    0x0020
#define AA_S_CREATE	    0x0020
#define AA_S_DELETE	    0x0040
#define AA_S_ACL	    0x0080
#define AA_S_ALL	    ( AA_S_OPEN | AA_S_WRITE | AA_S_DELETE | AA_S_ACL)
#define AA_F_OPEN	    0x0100
#define AA_F_WRITE	    0x0200
#define AA_F_CREATE	    0x0200
#define AA_F_DELETE	    0x0400
#define AA_F_ACL	    0x0800
#define AA_F_ALL	    ( AA_F_OPEN | AA_F_WRITE | AA_F_DELETE | AA_F_ACL)

// Pinball-specific
#define AA_A_OPEN	    0x1000
#define AA_A_WRITE	    0x2000
#define AA_A_CREATE	    0x2000
#define AA_A_DELETE	    0x4000
#define AA_A_ACL	    0x8000
#define AA_A_ALL	    ( AA_F_OPEN | AA_F_WRITE | AA_F_DELETE | AA_F_ACL)


#ifdef __cplusplus
}
#endif

#endif  // _LMAUDIT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\lmerr.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects
*/
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1995          **/
/********************************************************************/

/***    lmerr.h - network error definitions
 *
 */


/**INTERNAL_ONLY**/

/***********WARNING ****************
 *See the comment in lmcons.h for  *
 *info on the allocation of errors *
 ***********************************/

/**END_INTERNAL**/

/*NOINC*/
#ifndef NETERR_INCLUDED

#define NETERR_INCLUDED
/*INC*/


#define NERR_Success            0       /* Success */

// ERROR_ equates can be intermixed with NERR_ equates.
#ifndef  _WINERROR_
#include <winerror.h>
#endif



/***    NERR_BASE is the base of error codes from network utilities,
 *      chosen to avoid conflict with system and redirector error codes.
 *      2100 is a value that has been assigned to us by system.
 */
#define NERR_BASE       2100


/**INTERNAL_ONLY**/

/***********WARNING ****************
 *See the comment in lmcons.h for  *
 *info on the allocation of errors *
 ***********************************/

/***********WARNING ****************
 *The range 2750-2799 has been     *
 *allocated to the IBM LAN Server  *
 ***********************************/

/***********WARNING ****************
 *The range 2900-2999 has been     *
 *reserved for Microsoft OEMs      *
 ***********************************/

/**END_INTERNAL**/

/* UNUSED BASE+0 */
/* UNUSED BASE+1 */
#define NERR_NetNotStarted      (NERR_BASE+2)   /* The workstation driver is not installed. */
#define NERR_UnknownServer      (NERR_BASE+3)   /* The server could not be located. */
#define NERR_ShareMem           (NERR_BASE+4)   /* An internal error occurred.  The network cannot access a shared memory segment. */

#define NERR_NoNetworkResource  (NERR_BASE+5)   /* A network resource shortage occurred . */
#define NERR_RemoteOnly         (NERR_BASE+6)   /* This operation is not supported on workstations. */
#define NERR_DevNotRedirected   (NERR_BASE+7)   /* The device is not connected. */
/* UNUSED BASE+8 */
/* UNUSED BASE+9 */
/* UNUSED BASE+10 */
/* UNUSED BASE+11 */
/* UNUSED BASE+12 */
/* UNUSED BASE+13 */
#define NERR_ServerNotStarted   (NERR_BASE+14)  /* The Server service is not started. */
#define NERR_ItemNotFound       (NERR_BASE+15)  /* The queue is empty. */
#define NERR_UnknownDevDir      (NERR_BASE+16)  /* The device or directory does not exist. */
#define NERR_RedirectedPath     (NERR_BASE+17)  /* The operation is invalid on a redirected resource. */
#define NERR_DuplicateShare     (NERR_BASE+18)  /* The name has already been shared. */
#define NERR_NoRoom             (NERR_BASE+19)  /* The server is currently out of the requested resource. */
/* UNUSED BASE+20 */
#define NERR_TooManyItems       (NERR_BASE+21)  /* Requested addition of items exceeds the maximum allowed. */
#define NERR_InvalidMaxUsers    (NERR_BASE+22)  /* The Peer service supports only two simultaneous users. */
#define NERR_BufTooSmall        (NERR_BASE+23)  /* The API return buffer is too small. */
/* UNUSED BASE+24 */
/* UNUSED BASE+25 */
/* UNUSED BASE+26 */
#define NERR_RemoteErr          (NERR_BASE+27)  /* A remote API error occurred.  */
/* UNUSED BASE+28 */
/* UNUSED BASE+29 */
/* UNUSED BASE+30 */
#define NERR_LanmanIniError     (NERR_BASE+31)  /* An error occurred when opening or reading the configuration file. */
/* UNUSED BASE+32 */
/* UNUSED BASE+33 */
/* UNUSED BASE+34 */
/* UNUSED BASE+35 */
#define NERR_NetworkError       (NERR_BASE+36)  /* A general network error occurred. */
#define NERR_WkstaInconsistentState (NERR_BASE+37)
    /* The Workstation service is in an inconsistent state. Restart the computer before restarting the Workstation service. */
#define NERR_WkstaNotStarted    (NERR_BASE+38)  /* The Workstation service has not been started. */
#define NERR_BrowserNotStarted  (NERR_BASE+39)  /* The requested information is not available. */
#define NERR_InternalError      (NERR_BASE+40)  /* An internal Windows NT error occurred.*/
#define NERR_BadTransactConfig  (NERR_BASE+41)  /* The server is not configured for transactions. */
#define NERR_InvalidAPI         (NERR_BASE+42)  /* The requested API is not supported on the remote server. */
#define NERR_BadEventName       (NERR_BASE+43)  /* The event name is invalid. */
#define NERR_DupNameReboot      (NERR_BASE+44)  /* The computer name already exists on the network. Change it and restart the computer. */
/*
 *      Config API related
 *              Error codes from BASE+45 to BASE+49
 */

/* UNUSED BASE+45 */
#define NERR_CfgCompNotFound    (NERR_BASE+46)  /* The specified component could not be found in the configuration information. */
#define NERR_CfgParamNotFound   (NERR_BASE+47)  /* The specified parameter could not be found in the configuration information. */
#define NERR_LineTooLong        (NERR_BASE+49)  /* A line in the configuration file is too long. */

/*
 *      Spooler API related
 *              Error codes from BASE+50 to BASE+79
 */

#define NERR_QNotFound          (NERR_BASE+50)  /* The printer does not exist. */
#define NERR_JobNotFound        (NERR_BASE+51)  /* The print job does not exist. */
#define NERR_DestNotFound       (NERR_BASE+52)  /* The printer destination cannot be found. */
#define NERR_DestExists         (NERR_BASE+53)  /* The printer destination already exists. */
#define NERR_QExists            (NERR_BASE+54)  /* The printer queue already exists. */
#define NERR_QNoRoom            (NERR_BASE+55)  /* No more printers can be added. */
#define NERR_JobNoRoom          (NERR_BASE+56)  /* No more print jobs can be added.  */
#define NERR_DestNoRoom         (NERR_BASE+57)  /* No more printer destinations can be added. */
#define NERR_DestIdle           (NERR_BASE+58)  /* This printer destination is idle and cannot accept control operations. */
#define NERR_DestInvalidOp      (NERR_BASE+59)  /* This printer destination request contains an invalid control function. */
#define NERR_ProcNoRespond      (NERR_BASE+60)  /* The print processor is not responding. */
#define NERR_SpoolerNotLoaded   (NERR_BASE+61)  /* The spooler is not running. */
#define NERR_DestInvalidState   (NERR_BASE+62)  /* This operation cannot be performed on the print destination in its current state. */
#define NERR_QInvalidState      (NERR_BASE+63)  /* This operation cannot be performed on the printer queue in its current state. */
#define NERR_JobInvalidState    (NERR_BASE+64)  /* This operation cannot be performed on the print job in its current state. */
#define NERR_SpoolNoMemory      (NERR_BASE+65)  /* A spooler memory allocation failure occurred. */
#define NERR_DriverNotFound     (NERR_BASE+66)  /* The device driver does not exist. */
#define NERR_DataTypeInvalid    (NERR_BASE+67)  /* The data type is not supported by the print processor. */
#define NERR_ProcNotFound       (NERR_BASE+68)  /* The print processor is not installed. */

/*
 *      Service API related
 *              Error codes from BASE+80 to BASE+99
 */

#define NERR_ServiceTableLocked (NERR_BASE+80)  /* The service database is locked. */
#define NERR_ServiceTableFull   (NERR_BASE+81)  /* The service table is full. */
#define NERR_ServiceInstalled   (NERR_BASE+82)  /* The requested service has already been started. */
#define NERR_ServiceEntryLocked (NERR_BASE+83)  /* The service does not respond to control actions. */
#define NERR_ServiceNotInstalled (NERR_BASE+84) /* The service has not been started. */
#define NERR_BadServiceName     (NERR_BASE+85)  /* The service name is invalid. */
#define NERR_ServiceCtlTimeout  (NERR_BASE+86)  /* The service is not responding to the control function. */
#define NERR_ServiceCtlBusy     (NERR_BASE+87)  /* The service control is busy. */
#define NERR_BadServiceProgName (NERR_BASE+88)  /* The configuration file contains an invalid service program name. */
#define NERR_ServiceNotCtrl     (NERR_BASE+89)  /* The service could not be controlled in its present state. */
#define NERR_ServiceKillProc    (NERR_BASE+90)  /* The service ended abnormally. */
#define NERR_ServiceCtlNotValid (NERR_BASE+91)  /* The requested pause or stop is not valid for this service. */
#define NERR_NotInDispatchTbl   (NERR_BASE+92)  /* The service control dispatcher could not find the service name in the dispatch table. */
#define NERR_BadControlRecv     (NERR_BASE+93)  /* The service control dispatcher pipe read failed. */
#define NERR_ServiceNotStarting (NERR_BASE+94)  /* A thread for the new service could not be created. */

/*
 *      Wksta and Logon API related
 *              Error codes from BASE+100 to BASE+118
 */

#define NERR_AlreadyLoggedOn    (NERR_BASE+100) /* This workstation is already logged on to the local-area network. */
#define NERR_NotLoggedOn        (NERR_BASE+101) /* The workstation is not logged on to the local-area network. */
#define NERR_BadUsername        (NERR_BASE+102) /* The user name or group name parameter is invalid.  */
#define NERR_BadPassword        (NERR_BASE+103) /* The password parameter is invalid. */
#define NERR_UnableToAddName_W  (NERR_BASE+104) /* @W The logon processor did not add the message alias. */
#define NERR_UnableToAddName_F  (NERR_BASE+105) /* The logon processor did not add the message alias. */
#define NERR_UnableToDelName_W  (NERR_BASE+106) /* @W The logoff processor did not delete the message alias. */
#define NERR_UnableToDelName_F  (NERR_BASE+107) /* The logoff processor did not delete the message alias. */
/* UNUSED BASE+108 */
#define NERR_LogonsPaused       (NERR_BASE+109) /* Network logons are paused. */
#define NERR_LogonServerConflict (NERR_BASE+110)/* A centralized logon-server conflict occurred. */
#define NERR_LogonNoUserPath    (NERR_BASE+111) /* The server is configured without a valid user path. */
#define NERR_LogonScriptError   (NERR_BASE+112) /* An error occurred while loading or running the logon script. */
/* UNUSED BASE+113 */
#define NERR_StandaloneLogon    (NERR_BASE+114) /* The logon server was not specified.  Your computer will be logged on as STANDALONE. */
#define NERR_LogonServerNotFound (NERR_BASE+115) /* The logon server could not be found.  */
#define NERR_LogonDomainExists  (NERR_BASE+116) /* There is already a logon domain for this computer.  */
#define NERR_NonValidatedLogon  (NERR_BASE+117) /* The logon server could not validate the logon. */

/*
 *      ACF API related (access, user, group)
 *              Error codes from BASE+119 to BASE+149
 */

#define NERR_ACFNotFound        (NERR_BASE+119) /* The security database could not be found. */
#define NERR_GroupNotFound      (NERR_BASE+120) /* The group name could not be found. */
#define NERR_UserNotFound       (NERR_BASE+121) /* The user name could not be found. */
#define NERR_ResourceNotFound   (NERR_BASE+122) /* The resource name could not be found.  */
#define NERR_GroupExists        (NERR_BASE+123) /* The group already exists. */
#define NERR_UserExists         (NERR_BASE+124) /* The user account already exists. */
#define NERR_ResourceExists     (NERR_BASE+125) /* The resource permission list already exists. */
#define NERR_NotPrimary         (NERR_BASE+126) /* This operation is only allowed on the primary domain controller of the domain. */
#define NERR_ACFNotLoaded       (NERR_BASE+127) /* The security database has not been started. */
#define NERR_ACFNoRoom          (NERR_BASE+128) /* There are too many names in the user accounts database. */
#define NERR_ACFFileIOFail      (NERR_BASE+129) /* A disk I/O failure occurred.*/
#define NERR_ACFTooManyLists    (NERR_BASE+130) /* The limit of 64 entries per resource was exceeded. */
#define NERR_UserLogon          (NERR_BASE+131) /* Deleting a user with a session is not allowed. */
#define NERR_ACFNoParent        (NERR_BASE+132) /* The parent directory could not be located. */
#define NERR_CanNotGrowSegment  (NERR_BASE+133) /* Unable to add to the security database session cache segment. */
#define NERR_SpeGroupOp         (NERR_BASE+134) /* This operation is not allowed on this special group. */
#define NERR_NotInCache         (NERR_BASE+135) /* This user is not cached in user accounts database session cache. */
#define NERR_UserInGroup        (NERR_BASE+136) /* The user already belongs to this group. */
#define NERR_UserNotInGroup     (NERR_BASE+137) /* The user does not belong to this group. */
#define NERR_AccountUndefined   (NERR_BASE+138) /* This user account is undefined. */
#define NERR_AccountExpired     (NERR_BASE+139) /* This user account has expired. */
#define NERR_InvalidWorkstation (NERR_BASE+140) /* The user is not allowed to log on from this workstation. */
#define NERR_InvalidLogonHours  (NERR_BASE+141) /* The user is not allowed to log on at this time.  */
#define NERR_PasswordExpired    (NERR_BASE+142) /* The password of this user has expired. */
#define NERR_PasswordCantChange (NERR_BASE+143) /* The password of this user cannot change. */
#define NERR_PasswordHistConflict (NERR_BASE+144) /* This password cannot be used now. */
#define NERR_PasswordTooShort   (NERR_BASE+145) /* The password is shorter than required. */
#define NERR_PasswordTooRecent  (NERR_BASE+146) /* The password of this user is too recent to change.  */
#define NERR_InvalidDatabase    (NERR_BASE+147) /* The security database is corrupted. */
#define NERR_DatabaseUpToDate   (NERR_BASE+148) /* No updates are necessary to this replicant network/local security database. */
#define NERR_SyncRequired       (NERR_BASE+149) /* This replicant database is outdated; synchronization is required. */

/*
 *      Use API related
 *              Error codes from BASE+150 to BASE+169
 */

#define NERR_UseNotFound        (NERR_BASE+150) /* The network connection could not be found. */
#define NERR_BadAsgType         (NERR_BASE+151) /* This asg_type is invalid. */
#define NERR_DeviceIsShared     (NERR_BASE+152) /* This device is currently being shared. */

/*
 *      Message Server related
 *              Error codes BASE+170 to BASE+209
 */

#define NERR_NoComputerName     (NERR_BASE+170) /* The computer name could not be added as a message alias.  The name may already exist on the network. */
#define NERR_MsgAlreadyStarted  (NERR_BASE+171) /* The Messenger service is already started. */
#define NERR_MsgInitFailed      (NERR_BASE+172) /* The Messenger service failed to start.  */
#define NERR_NameNotFound       (NERR_BASE+173) /* The message alias could not be found on the network. */
#define NERR_AlreadyForwarded   (NERR_BASE+174) /* This message alias has already been forwarded. */
#define NERR_AddForwarded       (NERR_BASE+175) /* This message alias has been added but is still forwarded. */
#define NERR_AlreadyExists      (NERR_BASE+176) /* This message alias already exists locally. */
#define NERR_TooManyNames       (NERR_BASE+177) /* The maximum number of added message aliases has been exceeded. */
#define NERR_DelComputerName    (NERR_BASE+178) /* The computer name could not be deleted.*/
#define NERR_LocalForward       (NERR_BASE+179) /* Messages cannot be forwarded back to the same workstation. */
#define NERR_GrpMsgProcessor    (NERR_BASE+180) /* An error occurred in the domain message processor. */
#define NERR_PausedRemote       (NERR_BASE+181) /* The message was sent, but the recipient has paused the Messenger service. */
#define NERR_BadReceive         (NERR_BASE+182) /* The message was sent but not received. */
#define NERR_NameInUse          (NERR_BASE+183) /* The message alias is currently in use. Try again later. */
#define NERR_MsgNotStarted      (NERR_BASE+184) /* The Messenger service has not been started. */
#define NERR_NotLocalName       (NERR_BASE+185) /* The name is not on the local computer. */
#define NERR_NoForwardName      (NERR_BASE+186) /* The forwarded message alias could not be found on the network. */
#define NERR_RemoteFull         (NERR_BASE+187) /* The message alias table on the remote station is full. */
#define NERR_NameNotForwarded   (NERR_BASE+188) /* Messages for this alias are not currently being forwarded. */
#define NERR_TruncatedBroadcast (NERR_BASE+189) /* The broadcast message was truncated. */
#define NERR_InvalidDevice      (NERR_BASE+194) /* This is an invalid device name. */
#define NERR_WriteFault         (NERR_BASE+195) /* A write fault occurred. */
/* UNUSED BASE+196 */
#define NERR_DuplicateName      (NERR_BASE+197) /* A duplicate message alias exists on the network. */
#define NERR_DeleteLater        (NERR_BASE+198) /* @W This message alias will be deleted later. */
#define NERR_IncompleteDel      (NERR_BASE+199) /* The message alias was not successfully deleted from all networks. */
#define NERR_MultipleNets       (NERR_BASE+200) /* This operation is not supported on computers with multiple networks. */

/*
 *      Server API related
 *              Error codes BASE+210 to BASE+229
 */

#define NERR_NetNameNotFound    (NERR_BASE+210) /* This shared resource does not exist.*/
#define NERR_DeviceNotShared    (NERR_BASE+211) /* This device is not shared. */
#define NERR_ClientNameNotFound (NERR_BASE+212) /* A session does not exist with that computer name. */
#define NERR_FileIdNotFound     (NERR_BASE+214) /* There is not an open file with that identification number. */
#define NERR_ExecFailure        (NERR_BASE+215) /* A failure occurred when executing a remote administration command. */
#define NERR_TmpFile            (NERR_BASE+216) /* A failure occurred when opening a remote temporary file. */
#define NERR_TooMuchData        (NERR_BASE+217) /* The data returned from a remote administration command has been truncated to 64K. */
#define NERR_DeviceShareConflict (NERR_BASE+218) /* This device cannot be shared as both a spooled and a non-spooled resource. */
#define NERR_BrowserTableIncomplete (NERR_BASE+219)  /* The information in the list of servers may be incorrect. */
#define NERR_NotLocalDomain     (NERR_BASE+220) /* The computer is not active in this domain. */

/*
 *      CharDev API related
 *              Error codes BASE+230 to BASE+249
 */

/* UNUSED BASE+230 */
#define NERR_DevInvalidOpCode   (NERR_BASE+231) /* The operation is invalid for this device. */
#define NERR_DevNotFound        (NERR_BASE+232) /* This device cannot be shared. */
#define NERR_DevNotOpen         (NERR_BASE+233) /* This device was not open. */
#define NERR_BadQueueDevString  (NERR_BASE+234) /* This device name list is invalid. */
#define NERR_BadQueuePriority   (NERR_BASE+235) /* The queue priority is invalid. */
#define NERR_NoCommDevs         (NERR_BASE+237) /* There are no shared communication devices. */
#define NERR_QueueNotFound      (NERR_BASE+238) /* The queue you specified does not exist. */
#define NERR_BadDevString       (NERR_BASE+240) /* This list of devices is invalid. */
#define NERR_BadDev             (NERR_BASE+241) /* The requested device is invalid. */
#define NERR_InUseBySpooler     (NERR_BASE+242) /* This device is already in use by the spooler. */
#define NERR_CommDevInUse       (NERR_BASE+243) /* This device is already in use as a communication device. */

/*
 *      NetICanonicalize and NetIType and NetIMakeLMFileName
 *      NetIListCanon and NetINameCheck
 *              Error codes BASE+250 to BASE+269
 */

#define NERR_InvalidComputer   (NERR_BASE+251) /* This computer name is invalid. */
/* UNUSED BASE+252 */
/* UNUSED BASE+253 */
#define NERR_MaxLenExceeded    (NERR_BASE+254) /* The string and prefix specified are too long. */
/* UNUSED BASE+255 */
#define NERR_BadComponent      (NERR_BASE+256) /* This path component is invalid. */
#define NERR_CantType          (NERR_BASE+257) /* Could not determine the type of input. */
/* UNUSED BASE+258 */
/* UNUSED BASE+259 */
#define NERR_TooManyEntries    (NERR_BASE+262) /* The buffer for types is not big enough. */

/*
 *      NetProfile
 *              Error codes BASE+270 to BASE+276
 */

#define NERR_ProfileFileTooBig  (NERR_BASE+270) /* Profile files cannot exceed 64K. */
#define NERR_ProfileOffset      (NERR_BASE+271) /* The start offset is out of range. */
#define NERR_ProfileCleanup     (NERR_BASE+272) /* The system cannot delete current connections to network resources. */
#define NERR_ProfileUnknownCmd  (NERR_BASE+273) /* The system was unable to parse the command line in this file.*/
#define NERR_ProfileLoadErr     (NERR_BASE+274) /* An error occurred while loading the profile file. */
#define NERR_ProfileSaveErr     (NERR_BASE+275) /* @W Errors occurred while saving the profile file.  The profile was partially saved. */


/*
 *      NetAudit and NetErrorLog
 *              Error codes BASE+277 to BASE+279
 */

#define NERR_LogOverflow           (NERR_BASE+277)      /* Log file %1 is full. */
#define NERR_LogFileChanged        (NERR_BASE+278)      /* This log file has changed between reads. */
#define NERR_LogFileCorrupt        (NERR_BASE+279)      /* Log file %1 is corrupt. */


/*
 *      NetRemote
 *              Error codes BASE+280 to BASE+299
 */
#define NERR_SourceIsDir   (NERR_BASE+280) /* The source path cannot be a directory. */
#define NERR_BadSource     (NERR_BASE+281) /* The source path is illegal. */
#define NERR_BadDest       (NERR_BASE+282) /* The destination path is illegal. */
#define NERR_DifferentServers   (NERR_BASE+283) /* The source and destination paths are on different servers. */
/* UNUSED BASE+284 */
#define NERR_RunSrvPaused       (NERR_BASE+285) /* The Run server you requested is paused. */
/* UNUSED BASE+286 */
/* UNUSED BASE+287 */
/* UNUSED BASE+288 */
#define NERR_ErrCommRunSrv      (NERR_BASE+289) /* An error occurred when communicating with a Run server. */
/* UNUSED BASE+290 */
#define NERR_ErrorExecingGhost  (NERR_BASE+291) /* An error occurred when starting a background process. */
#define NERR_ShareNotFound      (NERR_BASE+292) /* The shared resource you are connected to could not be found.*/
/* UNUSED BASE+293 */
/* UNUSED BASE+294 */


/*
 *  NetWksta.sys (redir) returned error codes.
 *
 *          NERR_BASE + (300-329)
 */

#define NERR_InvalidLana        (NERR_BASE+300) /* The LAN adapter number is invalid.  */
#define NERR_OpenFiles          (NERR_BASE+301) /* There are open files on the connection.    */
#define NERR_ActiveConns        (NERR_BASE+302) /* Active connections still exist. */
#define NERR_BadPasswordCore    (NERR_BASE+303) /* This share name or password is invalid. */
#define NERR_DevInUse           (NERR_BASE+304) /* The device is being accessed by an active process. */
#define NERR_LocalDrive         (NERR_BASE+305) /* The drive letter is in use locally. */

/*
 *  Alert error codes.
 *
 *          NERR_BASE + (330-339)
 */
#define NERR_AlertExists        (NERR_BASE+330) /* The specified client is already registered for the specified event. */
#define NERR_TooManyAlerts      (NERR_BASE+331) /* The alert table is full. */
#define NERR_NoSuchAlert        (NERR_BASE+332) /* An invalid or nonexistent alert name was raised. */
#define NERR_BadRecipient       (NERR_BASE+333) /* The alert recipient is invalid.*/
#define NERR_AcctLimitExceeded  (NERR_BASE+334) /* A user's session with this server has been deleted
                                                 * because the user's logon hours are no longer valid. */

/*
 *  Additional Error and Audit log codes.
 *
 *          NERR_BASE +(340-343)
 */
#define NERR_InvalidLogSeek     (NERR_BASE+340) /* The log file does not contain the requested record number. */
/* UNUSED BASE+341 */
/* UNUSED BASE+342 */
/* UNUSED BASE+343 */

/*
 *  Additional UAS and NETLOGON codes
 *
 *          NERR_BASE +(350-359)
 */
#define NERR_BadUasConfig       (NERR_BASE+350) /* The user accounts database is not configured correctly. */
#define NERR_InvalidUASOp       (NERR_BASE+351) /* This operation is not permitted when the Netlogon service is running. */
#define NERR_LastAdmin          (NERR_BASE+352) /* This operation is not allowed on the last administrative account. */
#define NERR_DCNotFound         (NERR_BASE+353) /* Could not find domain controller for this domain. */
#define NERR_LogonTrackingError (NERR_BASE+354) /* Could not set logon information for this user. */
#define NERR_NetlogonNotStarted (NERR_BASE+355) /* The Netlogon service has not been started. */
#define NERR_CanNotGrowUASFile  (NERR_BASE+356) /* Unable to add to the user accounts database. */
#define NERR_TimeDiffAtDC       (NERR_BASE+357) /* This server's clock is not synchronized with the primary domain controller's clock. */
#define NERR_PasswordMismatch   (NERR_BASE+358) /* A password mismatch has been detected. */


/*
 *  Server Integration error codes.
 *
 *          NERR_BASE +(360-369)
 */
#define NERR_NoSuchServer       (NERR_BASE+360) /* The server identification does not specify a valid server. */
#define NERR_NoSuchSession      (NERR_BASE+361) /* The session identification does not specify a valid session. */
#define NERR_NoSuchConnection   (NERR_BASE+362) /* The connection identification does not specify a valid connection. */
#define NERR_TooManyServers     (NERR_BASE+363) /* There is no space for another entry in the table of available servers. */
#define NERR_TooManySessions    (NERR_BASE+364) /* The server has reached the maximum number of sessions it supports. */
#define NERR_TooManyConnections (NERR_BASE+365) /* The server has reached the maximum number of connections it supports. */
#define NERR_TooManyFiles       (NERR_BASE+366) /* The server cannot open more files because it has reached its maximum number. */
#define NERR_NoAlternateServers (NERR_BASE+367) /* There are no alternate servers registered on this server. */
/* UNUSED BASE+368 */
/* UNUSED BASE+369 */

#define NERR_TryDownLevel       (NERR_BASE+370) /* Try down-level (remote admin protocol) version of API instead. */

/*
 *  UPS error codes.
 *
 *          NERR_BASE + (380-384)
 */
#define NERR_UPSDriverNotStarted    (NERR_BASE+380) /* The UPS driver could not be accessed by the UPS service. */
#define NERR_UPSInvalidConfig       (NERR_BASE+381) /* The UPS service is not configured correctly. */
#define NERR_UPSInvalidCommPort     (NERR_BASE+382) /* The UPS service could not access the specified Comm Port. */
#define NERR_UPSSignalAsserted      (NERR_BASE+383) /* The UPS indicated a line fail or low battery situation. Service not started. */
#define NERR_UPSShutdownFailed      (NERR_BASE+384) /* The UPS service failed to perform a system shut down. */

/*
 *  Remoteboot error codes.
 *
 *          NERR_BASE + (400-419)
 *          Error codes 400 - 405 are used by RPLBOOT.SYS.
 *          Error codes 403, 407 - 416 are used by RPLLOADR.COM,
 *          Error code 417 is the alerter message of REMOTEBOOT (RPLSERVR.EXE).
 *          Error code 418 is for when REMOTEBOOT can't start
 *          Error code 419 is for a disallowed 2nd rpl connection
 *
 */
#define NERR_BadDosRetCode      (NERR_BASE+400) /* The program below returned an MS-DOS error code:*/
#define NERR_ProgNeedsExtraMem  (NERR_BASE+401) /* The program below needs more memory:*/
#define NERR_BadDosFunction     (NERR_BASE+402) /* The program below called an unsupported MS-DOS function:*/
#define NERR_RemoteBootFailed   (NERR_BASE+403) /* The workstation failed to boot.*/
#define NERR_BadFileCheckSum    (NERR_BASE+404) /* The file below is corrupt.*/
#define NERR_NoRplBootSystem    (NERR_BASE+405) /* No loader is specified in the boot-block definition file.*/
#define NERR_RplLoadrNetBiosErr (NERR_BASE+406) /* NetBIOS returned an error: The NCB and SMB are dumped above.*/
#define NERR_RplLoadrDiskErr    (NERR_BASE+407) /* A disk I/O error occurred.*/
#define NERR_ImageParamErr      (NERR_BASE+408) /* Image parameter substitution failed.*/
#define NERR_TooManyImageParams (NERR_BASE+409) /* Too many image parameters cross disk sector boundaries.*/
#define NERR_NonDosFloppyUsed   (NERR_BASE+410) /* The image was not generated from an MS-DOS diskette formatted with /S.*/
#define NERR_RplBootRestart     (NERR_BASE+411) /* Remote boot will be restarted later.*/
#define NERR_RplSrvrCallFailed  (NERR_BASE+412) /* The call to the Remoteboot server failed.*/
#define NERR_CantConnectRplSrvr (NERR_BASE+413) /* Cannot connect to the Remoteboot server.*/
#define NERR_CantOpenImageFile  (NERR_BASE+414) /* Cannot open image file on the Remoteboot server.*/
#define NERR_CallingRplSrvr     (NERR_BASE+415) /* Connecting to the Remoteboot server...*/
#define NERR_StartingRplBoot    (NERR_BASE+416) /* Connecting to the Remoteboot server...*/
#define NERR_RplBootServiceTerm (NERR_BASE+417) /* Remote boot service was stopped; check the error log for the cause of the problem.*/
#define NERR_RplBootStartFailed (NERR_BASE+418) /* Remote boot startup failed; check the error log for the cause of the problem.*/
#define NERR_RPL_CONNECTED      (NERR_BASE+419) /* A second connection to a Remoteboot resource is not allowed.*/

/*
 *  FTADMIN API error codes
 *
 *       NERR_BASE + (425-434)
 *
 *       (Currently not used in NT)
 *
 */

/*
 *  Browser service API error codes
 *
 *       NERR_BASE + (450-475)
 *
 */
#define NERR_BrowserConfiguredToNotRun     (NERR_BASE+450) /* The browser service was configured with MaintainServerList=No. */

/*
 *  Additional Remoteboot error codes.
 *
 *          NERR_BASE + (510-550)
 */
#define NERR_RplNoAdaptersStarted          (NERR_BASE+510) /*Service failed to start since none of the network adapters started with this service.*/
#define NERR_RplBadRegistry                (NERR_BASE+511) /*Service failed to start due to bad startup information in the registry.*/
#define NERR_RplBadDatabase                (NERR_BASE+512) /*Service failed to start because its database is absent or corrupt.*/
#define NERR_RplRplfilesShare              (NERR_BASE+513) /*Service failed to start because RPLFILES share is absent.*/
#define NERR_RplNotRplServer               (NERR_BASE+514) /*Service failed to start because RPLUSER group is absent.*/
#define NERR_RplCannotEnum                 (NERR_BASE+515) /*Cannot enumerate service records.*/
#define NERR_RplWkstaInfoCorrupted         (NERR_BASE+516) /*Workstation record information has been corrupted.*/
#define NERR_RplWkstaNotFound              (NERR_BASE+517) /*Workstation record was not found.*/
#define NERR_RplWkstaNameUnavailable       (NERR_BASE+518) /*Workstation name is in use by some other workstation.*/
#define NERR_RplProfileInfoCorrupted       (NERR_BASE+519) /*Profile record information has been corrupted.*/
#define NERR_RplProfileNotFound            (NERR_BASE+520) /*Profile record was not found.*/
#define NERR_RplProfileNameUnavailable     (NERR_BASE+521) /*Profile name is in use by some other profile.*/
#define NERR_RplProfileNotEmpty            (NERR_BASE+522) /*There are workstations using this profile.*/
#define NERR_RplConfigInfoCorrupted        (NERR_BASE+523) /*Configuration record information has been corrupted.*/
#define NERR_RplConfigNotFound             (NERR_BASE+524) /*Configuration record was not found.*/
#define NERR_RplAdapterInfoCorrupted       (NERR_BASE+525) /*Adapter id record information has been corrupted.*/
#define NERR_RplInternal                   (NERR_BASE+526) /*An internal service error has occured.*/
#define NERR_RplVendorInfoCorrupted        (NERR_BASE+527) /*Vendor id record information has been corrupted.*/
#define NERR_RplBootInfoCorrupted          (NERR_BASE+528) /*Boot block record information has been corrupted.*/
#define NERR_RplWkstaNeedsUserAcct         (NERR_BASE+529) /*The user account for this workstation record is missing.*/
#define NERR_RplNeedsRPLUSERAcct           (NERR_BASE+530) /*The RPLUSER local group could not be found.*/
#define NERR_RplBootNotFound               (NERR_BASE+531) /*Boot block record was not found.*/
#define NERR_RplIncompatibleProfile        (NERR_BASE+532) /*Chosen profile is incompatible with this workstation.*/
#define NERR_RplAdapterNameUnavailable     (NERR_BASE+533) /*Chosen network adapter id is in use by some other workstation.*/
#define NERR_RplConfigNotEmpty             (NERR_BASE+534) /*There are profiles using this configuration.*/
#define NERR_RplBootInUse                  (NERR_BASE+535) /*There are workstations, profiles or configurations using this boot block.*/
#define NERR_RplBackupDatabase             (NERR_BASE+536) /*Service failed to backup remoteboot database.*/
#define NERR_RplAdapterNotFound            (NERR_BASE+537) /*Adapter record was not found.*/
#define NERR_RplVendorNotFound             (NERR_BASE+538) /*Vendor record was not found.*/
#define NERR_RplVendorNameUnavailable      (NERR_BASE+539) /*Vendor name is in use by some other vendor record.*/
#define NERR_RplBootNameUnavailable        (NERR_BASE+540) /*(boot name, vendor id) is in use by some other boot block record.*/
#define NERR_RplConfigNameUnavailable      (NERR_BASE+541) /*Configuration name is in use by some other configuration.*/

/**INTERNAL_ONLY**/

/***********WARNING ****************
 *The range 2750-2799 has been     *
 *allocated to the IBM LAN Server  *
 ***********************************/

/***********WARNING ****************
 *The range 2900-2999 has been     *
 *reserved for Microsoft OEMs      *
 ***********************************/

/**END_INTERNAL**/

#define MAX_NERR                (NERR_BASE+899) /* This is the last error in NERR range. */

/*
 * end of list
 *
 *    WARNING:  Do not exceed MAX_NERR; values above this are used by
 *              other error code ranges (errlog.h, service.h, apperr.h).
 */


/*NOINC*/
#endif /* NETERR_INCLUDED */
/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\lmrepl.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    LmRepl.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the replicator APIs.

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include LmCons.h before this file.


--*/

#ifndef _LMREPL_
#define _LMREPL_

#ifdef __cplusplus
extern "C" {
#endif

//
// Replicator Configuration APIs
//

#define REPL_ROLE_EXPORT        1
#define REPL_ROLE_IMPORT        2
#define REPL_ROLE_BOTH          3


#define REPL_INTERVAL_INFOLEVEL         (PARMNUM_BASE_INFOLEVEL + 0)
#define REPL_PULSE_INFOLEVEL            (PARMNUM_BASE_INFOLEVEL + 1)
#define REPL_GUARDTIME_INFOLEVEL        (PARMNUM_BASE_INFOLEVEL + 2)
#define REPL_RANDOM_INFOLEVEL           (PARMNUM_BASE_INFOLEVEL + 3)


typedef struct _REPL_INFO_0 {
    DWORD          rp0_role;
    LPTSTR         rp0_exportpath;
    LPTSTR         rp0_exportlist;
    LPTSTR         rp0_importpath;
    LPTSTR         rp0_importlist;
    LPTSTR         rp0_logonusername;
    DWORD          rp0_interval;
    DWORD          rp0_pulse;
    DWORD          rp0_guardtime;
    DWORD          rp0_random;
} REPL_INFO_0, *PREPL_INFO_0, *LPREPL_INFO_0;

typedef struct _REPL_INFO_1000 {
    DWORD          rp1000_interval;
} REPL_INFO_1000, *PREPL_INFO_1000, *LPREPL_INFO_1000;

typedef struct _REPL_INFO_1001 {
    DWORD          rp1001_pulse;
} REPL_INFO_1001, *PREPL_INFO_1001, *LPREPL_INFO_1001;

typedef struct _REPL_INFO_1002 {
    DWORD          rp1002_guardtime;
} REPL_INFO_1002, *PREPL_INFO_1002, *LPREPL_INFO_1002;

typedef struct _REPL_INFO_1003 {
    DWORD          rp1003_random;
} REPL_INFO_1003, *PREPL_INFO_1003, *LPREPL_INFO_1003;


NET_API_STATUS NET_API_FUNCTION
NetReplGetInfo (
    IN LPTSTR servername OPTIONAL,
    IN DWORD level,
    OUT LPBYTE * bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetReplSetInfo (
    IN LPTSTR servername OPTIONAL,
    IN DWORD level,
    IN LPBYTE buf,
    OUT LPDWORD parm_err OPTIONAL
    );


//
// Replicator Export Directory APIs
//

#define REPL_INTEGRITY_FILE     1
#define REPL_INTEGRITY_TREE     2


#define REPL_EXTENT_FILE        1
#define REPL_EXTENT_TREE        2


#define REPL_EXPORT_INTEGRITY_INFOLEVEL (PARMNUM_BASE_INFOLEVEL + 0)
#define REPL_EXPORT_EXTENT_INFOLEVEL    (PARMNUM_BASE_INFOLEVEL + 1)


typedef struct _REPL_EDIR_INFO_0 {
    LPTSTR         rped0_dirname;
} REPL_EDIR_INFO_0, *PREPL_EDIR_INFO_0, *LPREPL_EDIR_INFO_0;

typedef struct _REPL_EDIR_INFO_1 {
    LPTSTR         rped1_dirname;
    DWORD          rped1_integrity;
    DWORD          rped1_extent;
} REPL_EDIR_INFO_1, *PREPL_EDIR_INFO_1, *LPREPL_EDIR_INFO_1;

typedef struct _REPL_EDIR_INFO_2 {
    LPTSTR         rped2_dirname;
    DWORD          rped2_integrity;
    DWORD          rped2_extent;
    DWORD          rped2_lockcount;
    DWORD          rped2_locktime;
} REPL_EDIR_INFO_2, *PREPL_EDIR_INFO_2, *LPREPL_EDIR_INFO_2;

typedef struct _REPL_EDIR_INFO_1000 {
    DWORD          rped1000_integrity;
} REPL_EDIR_INFO_1000, *PREPL_EDIR_INFO_1000, *LPREPL_EDIR_INFO_1000;

typedef struct _REPL_EDIR_INFO_1001 {
    DWORD          rped1001_extent;
} REPL_EDIR_INFO_1001, *PREPL_EDIR_INFO_1001, *LPREPL_EDIR_INFO_1001;


NET_API_STATUS NET_API_FUNCTION
NetReplExportDirAdd (
    IN LPTSTR servername OPTIONAL,
    IN DWORD level,
    IN LPBYTE buf,
    OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirDel (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirEnum (
    IN LPTSTR servername OPTIONAL,
    IN DWORD level,
    OUT LPBYTE * bufptr,
    IN DWORD prefmaxlen,
    OUT LPDWORD entriesread,
    OUT LPDWORD totalentries,
    IN OUT LPDWORD resumehandle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirGetInfo (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname,
    IN DWORD level,
    OUT LPBYTE * bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirSetInfo (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname,
    IN DWORD level,
    IN LPBYTE buf,
    OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirLock (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirUnlock (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname,
    IN DWORD unlockforce
    );


#define REPL_UNLOCK_NOFORCE     0
#define REPL_UNLOCK_FORCE       1


//
// Replicator Import Directory APIs
//


typedef struct _REPL_IDIR_INFO_0 {
    LPTSTR         rpid0_dirname;
} REPL_IDIR_INFO_0, *PREPL_IDIR_INFO_0, *LPREPL_IDIR_INFO_0;

typedef struct _REPL_IDIR_INFO_1 {
    LPTSTR         rpid1_dirname;
    DWORD          rpid1_state;
    LPTSTR         rpid1_mastername;
    DWORD          rpid1_last_update_time;
    DWORD          rpid1_lockcount;
    DWORD          rpid1_locktime;
} REPL_IDIR_INFO_1, *PREPL_IDIR_INFO_1, *LPREPL_IDIR_INFO_1;


NET_API_STATUS NET_API_FUNCTION
NetReplImportDirAdd (
    IN LPTSTR servername OPTIONAL,
    IN DWORD level,
    IN LPBYTE buf,
    OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplImportDirDel (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname
    );

NET_API_STATUS NET_API_FUNCTION
NetReplImportDirEnum (
    IN LPTSTR servername OPTIONAL,
    IN DWORD level,
    OUT LPBYTE * bufptr,
    IN DWORD prefmaxlen,
    OUT LPDWORD entriesread,
    OUT LPDWORD totalentries,
    IN OUT LPDWORD resumehandle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplImportDirGetInfo (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname,
    IN DWORD level,
    OUT LPBYTE * bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetReplImportDirLock (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname
    );


NET_API_STATUS NET_API_FUNCTION
NetReplImportDirUnlock (
    IN LPTSTR servername OPTIONAL,
    IN LPTSTR dirname,
    IN DWORD unlockforce
    );


#define REPL_STATE_OK                   0
#define REPL_STATE_NO_MASTER            1
#define REPL_STATE_NO_SYNC              2
#define REPL_STATE_NEVER_REPLICATED     3


#ifdef __cplusplus
}
#endif

#endif //_LMREPL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\lmmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    lmmsg.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetMessage API.

[Environment:]

    User Mode - Win32

[Notes:]

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMMSG_
#define _LMMSG_

#ifdef __cplusplus
extern "C" {
#endif

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetMessageNameAdd (
    IN  LPTSTR  servername,
    IN  LPTSTR  msgname
    );

NET_API_STATUS NET_API_FUNCTION
NetMessageNameEnum (
    IN  LPTSTR      servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle
    );

NET_API_STATUS NET_API_FUNCTION
NetMessageNameGetInfo (
    IN  LPTSTR  servername,
    IN  LPTSTR  msgname,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetMessageNameDel (
    IN  LPTSTR   servername,
    IN  LPTSTR   msgname
    );

NET_API_STATUS NET_API_FUNCTION
NetMessageBufferSend (
    IN  LPTSTR  servername,
    IN  LPTSTR  msgname,
    IN  LPTSTR  fromname,
    IN  LPBYTE  buf,
    IN  DWORD   buflen
    );

//
//  Data Structures
//

typedef struct _MSG_INFO_0 {
    LPTSTR  msgi0_name;
}MSG_INFO_0, *PMSG_INFO_0, *LPMSG_INFO_0;

typedef struct _MSG_INFO_1 {
    LPTSTR  msgi1_name;
    DWORD   msgi1_forward_flag;
    LPTSTR  msgi1_forward;
}MSG_INFO_1, *PMSG_INFO_1, *LPMSG_INFO_1;

//
// Special Values and Constants
//

//
// Values for msgi1_forward_flag.
//

#define MSGNAME_NOT_FORWARDED   0       // Name not forwarded
#define MSGNAME_FORWARDED_TO    0x04    // Name forward to remote station
#define MSGNAME_FORWARDED_FROM  0x10    // Name forwarded from remote station

#ifdef __cplusplus
}
#endif

#endif //_LMMSG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\lmerrlog.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    lmerrlog.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetErrorLog

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMERRLOG_
#define _LMERRLOG_

//
// Data Structures - Config
//

typedef struct _ERROR_LOG {
     DWORD          el_len;
     DWORD          el_reserved;
     DWORD          el_time;
     DWORD          el_error;
     LPTSTR         el_name;             // pointer to service name
     LPTSTR         el_text;             // pointer to string array
     LPBYTE         el_data;             // pointer to BYTE array
     DWORD          el_data_size;        // byte count of el_data area
     DWORD          el_nstrings;         // number of strings in el_text.
} ERROR_LOG, *PERROR_LOG, *LPERROR_LOG;


// BUGBUG: Temporary to let users ifdef on this struct layout.
#define REVISED_ERROR_LOG_STRUCT


#ifndef _LMHLOGDEFINED_
#define _LMHLOGDEFINED_

typedef struct _HLOG {
     DWORD          time;
     DWORD          last_flags;
     DWORD          offset;
     DWORD          rec_offset;
} HLOG, *PHLOG, *LPHLOG;

#define LOGFLAGS_FORWARD    0
#define LOGFLAGS_BACKWARD   0x1
#define LOGFLAGS_SEEK       0x2

#endif

//
// Function Prototypes - ErrorLog
//

NET_API_STATUS NET_API_FUNCTION
NetErrorLogClear (
    IN LPTSTR server,
    IN LPTSTR backupfile,
    IN LPBYTE reserved
    );

NET_API_STATUS NET_API_FUNCTION
NetErrorLogRead (
    IN LPTSTR server,
    IN LPTSTR reserved1,
    IN LPHLOG errloghandle,
    IN DWORD offset,
    IN LPDWORD reserved2,
    IN DWORD reserved3,
    IN DWORD offsetflag,
    OUT LPBYTE * bufptr,
    IN DWORD prefmaxlen,
    OUT LPDWORD bytesread,
    OUT LPDWORD totalbytes
    );

NET_API_STATUS NET_API_FUNCTION
NetErrorLogWrite (
    IN LPBYTE reserved1,
    IN DWORD code,
    IN LPTSTR component,
    IN LPBYTE buffer,
    IN DWORD numbytes,
    IN LPBYTE msgbuf,
    IN DWORD strcount,
    IN LPBYTE reserved2
    );

//
// Special Values and Constants
//


//
//  Generic (could be used by more than one service)
//   error log messages from 0 to 25
//
// Do not change the comments following the manifest constants without
// understanding how mapmsg works.
//

#define ERRLOG_BASE 3100        /* NELOG errors start here */

#define NELOG_Internal_Error        (ERRLOG_BASE + 0)
    /*
    * The operation failed because a network software error occurred.
    */

#define NELOG_Resource_Shortage     (ERRLOG_BASE + 1)
    /*
    * The system ran out of a resource controlled by the %1 option.
    */

#define NELOG_Unable_To_Lock_Segment    (ERRLOG_BASE + 2)
    /*
    * The service failed to obtain a long-term lock on the
    *  segment for network control blocks (NCBs). The error code is the data.
    */

#define NELOG_Unable_To_Unlock_Segment  (ERRLOG_BASE + 3)
    /*
    * The service failed to release the long-term lock on the
    *  segment for network control blocks (NCBs). The error code is the data.
    */

#define NELOG_Uninstall_Service     (ERRLOG_BASE + 4)
    /*
    * There was an error stopping service %1.
    *  The error code from NetServiceControl is the data.
    */

#define NELOG_Init_Exec_Fail        (ERRLOG_BASE + 5)
    /*
    * Initialization failed because of a system execution failure on
    *  path %1. The system error code is the data.
    */

#define NELOG_Ncb_Error         (ERRLOG_BASE + 6)
    /*
    * An unexpected network control block (NCB) was received. The NCB is the data.
    */

#define NELOG_Net_Not_Started       (ERRLOG_BASE + 7)
    /*
    * The network is not started.
    */

#define NELOG_Ioctl_Error       (ERRLOG_BASE + 8)
    /*
    * A DosDevIoctl or DosFsCtl to NETWKSTA.SYS failed.
    * The data shown is in this format:
    *     DWORD  approx CS:IP of call to ioctl or fsctl
    *     WORD   error code
    *     WORD   ioctl or fsctl number
    */

#define NELOG_System_Semaphore      (ERRLOG_BASE + 9)
    /*
    * Unable to create or open system semaphore %1.
    *  The error code is the data.
    */

#define NELOG_Init_OpenCreate_Err   (ERRLOG_BASE + 10)
    /*
    * Initialization failed because of an open/create error on the
    *  file %1. The system error code is the data.
    */

#define NELOG_NetBios           (ERRLOG_BASE + 11)
    /*
    * An unexpected NetBIOS error occurred.
    *  The error code is the data.
    */

#define NELOG_SMB_Illegal       (ERRLOG_BASE + 12)
    /*
    * An illegal server message block (SMB) was received.
    *  The SMB is the data.
    */

#define NELOG_Service_Fail      (ERRLOG_BASE + 13)
    /*
    * Initialization failed because the requested service %1
    *  could not be started.
   */

#define NELOG_Entries_Lost      (ERRLOG_BASE + 14)
    /*
    * Some entries in the error log were lost because of a buffer
    * overflow.
    */


//
//  Server specific error log messages from 20 to 40
//

#define NELOG_Init_Seg_Overflow     (ERRLOG_BASE + 20)
    /*
    * Initialization parameters controlling resource usage other
    *  than net buffers are sized so that too much memory is needed.
    */

#define NELOG_Srv_No_Mem_Grow       (ERRLOG_BASE + 21)
    /*
    * The server cannot increase the size of a memory segment.
    */

#define NELOG_Access_File_Bad       (ERRLOG_BASE + 22)
    /*
    * Initialization failed because account file %1 is either incorrect
    * or not present.
    */

#define NELOG_Srvnet_Not_Started    (ERRLOG_BASE + 23)
    /*
    * Initialization failed because network %1 was not started.
    */

#define NELOG_Init_Chardev_Err      (ERRLOG_BASE + 24)
    /*
    * The server failed to start. Either all three chdev
    *  parameters must be zero or all three must be nonzero.
    */

#define NELOG_Remote_API        (ERRLOG_BASE + 25)
    /* A remote API request was halted due to the following
    * invalid description string: %1.
    */

#define NELOG_Ncb_TooManyErr        (ERRLOG_BASE + 26)
    /* The network %1 ran out of network control blocks (NCBs).  You may need to increase NCBs
    * for this network.  The following information includes the
    * number of NCBs submitted by the server when this error occurred:
    */

#define NELOG_Mailslot_err      (ERRLOG_BASE + 27)
    /* The server cannot create the %1 mailslot needed to send
    * the ReleaseMemory alert message.  The error received is:
    */

#define NELOG_ReleaseMem_Alert      (ERRLOG_BASE + 28)
    /* The server failed to register for the ReleaseMemory alert,
    * with recipient %1. The error code from
    * NetAlertStart is the data.
    */

#define NELOG_AT_cannot_write       (ERRLOG_BASE + 29)
    /* The server cannot update the AT schedule file. The file
    * is corrupted.
    */

#define NELOG_Cant_Make_Msg_File    (ERRLOG_BASE + 30)
    /* The server encountered an error when calling
    * NetIMakeLMFileName. The error code is the data.
    */

#define NELOG_Exec_Netservr_NoMem   (ERRLOG_BASE + 31)
    /* Initialization failed because of a system execution failure on
    * path %1. There is not enough memory to start the process.
    * The system error code is the data.
    */

#define NELOG_Server_Lock_Failure   (ERRLOG_BASE + 32)
    /* Longterm lock of the server buffers failed.
    * Check swap disk's free space and restart the system to start the server.
    */

//
//  Message service and POPUP specific error log messages from 40 to 55
//

#define NELOG_Msg_Shutdown      (ERRLOG_BASE + 40)
    /*
    * The service has stopped due to repeated consecutive
    *  occurrences of a network control block (NCB) error.  The last bad NCB follows
    *  in raw data.
    */

#define NELOG_Msg_Sem_Shutdown      (ERRLOG_BASE + 41)
    /*
    * The Message server has stopped due to a lock on the
    *  Message server shared data segment.
    */

#define NELOG_Msg_Log_Err       (ERRLOG_BASE + 50)
    /*
    * A file system error occurred while opening or writing to the
    *  system message log file %1. Message logging has been
    *  switched off due to the error. The error code is the data.
    */



#define NELOG_VIO_POPUP_ERR     (ERRLOG_BASE + 51)
    /*
    * Unable to display message POPUP due to system VIO call error.
    *  The error code is the data.
    */

#define NELOG_Msg_Unexpected_SMB_Type   (ERRLOG_BASE + 52)
    /*
    * An illegal server message block (SMB) was received.  The SMB is the data.
    */

//
//  Workstation specific error log messages from 60 to 75
//


#define NELOG_Wksta_Infoseg     (ERRLOG_BASE + 60)
    /*
    * The workstation information segment is bigger than 64K.
    *  The size follows, in DWORD format:
    */

#define NELOG_Wksta_Compname        (ERRLOG_BASE + 61)
    /*
    * The workstation was unable to get the name-number of the computer.
    */

#define NELOG_Wksta_BiosThreadFailure   (ERRLOG_BASE + 62)
    /*
    * The workstation could not initialize the Async NetBIOS Thread.
    *  The error code is the data.
    */

#define NELOG_Wksta_IniSeg      (ERRLOG_BASE + 63)
    /*
    * The workstation could not open the initial shared segment.
    *  The error code is the data.
    */

#define NELOG_Wksta_HostTab_Full    (ERRLOG_BASE + 64)
    /*
    * The workstation host table is full.
    */

#define NELOG_Wksta_Bad_Mailslot_SMB    (ERRLOG_BASE + 65)
    /*
    * A bad mailslot server message block (SMB) was received.  The SMB is the data.
    */

#define NELOG_Wksta_UASInit     (ERRLOG_BASE + 66)
    /*
    * The workstation encountered an error while trying to start the user accounts database.
    *  The error code is the data.
    */

#define NELOG_Wksta_SSIRelogon      (ERRLOG_BASE + 67)
    /*
    * The workstation encountered an error while responding to an SSI revalidation request.
    *  The function code and the error codes are the data.
    */

//
//  Alerter service specific error log messages from 70 to 79
//


#define NELOG_Build_Name        (ERRLOG_BASE + 70)
    /*
    * The Alerter service had a problem creating the list of
    * alert recipients.  The error code is %1.
    */

#define NELOG_Name_Expansion        (ERRLOG_BASE + 71)
    /*
    * There was an error expanding %1 as a group name. Try
    *  splitting the group into two or more smaller groups.
    */

#define NELOG_Message_Send      (ERRLOG_BASE + 72)
    /*
    * There was an error sending %2 the alert message -
    *  (
    *  %3 )
    *  The error code is %1.
    */

#define NELOG_Mail_Slt_Err      (ERRLOG_BASE + 73)
    /*
    * There was an error in creating or reading the alerter mailslot.
    *  The error code is %1.
    */

#define NELOG_AT_cannot_read        (ERRLOG_BASE + 74)
    /*
    * The server could not read the AT schedule file.
    */

#define NELOG_AT_sched_err      (ERRLOG_BASE + 75)
    /*
    * The server found an invalid AT schedule record.
    */

#define NELOG_AT_schedule_file_created  (ERRLOG_BASE + 76)
    /*
    * The server could not find an AT schedule file so it created one.
    */

#define NELOG_Srvnet_NB_Open        (ERRLOG_BASE + 77)
    /*
    * The server could not access the %1 network with NetBiosOpen.
    */

#define NELOG_AT_Exec_Err       (ERRLOG_BASE + 78)
    /*
    * The AT command processor could not run %1.
   */

//
//      Cache Lazy Write and HPFS386 specific error log messages from 80 to 89
//

#define NELOG_Lazy_Write_Err            (ERRLOG_BASE + 80)
        /*
        * WARNING:  Because of a lazy-write error, drive %1 now
        *  contains some corrupted data.  The cache is stopped.
        */

#define NELOG_HotFix            (ERRLOG_BASE + 81)
    /*
    * A defective sector on drive %1 has been replaced (hotfixed).
    * No data was lost.  You should run CHKDSK soon to restore full
    * performance and replenish the volume's spare sector pool.
    *
    * The hotfix occurred while processing a remote request.
    */

#define NELOG_HardErr_From_Server   (ERRLOG_BASE + 82)
    /*
    * A disk error occurred on the HPFS volume in drive %1.
    * The error occurred while processing a remote request.
    */

#define NELOG_LocalSecFail1 (ERRLOG_BASE + 83)
    /*
    * The user accounts database (NET.ACC) is corrupted.  The local security
    * system is replacing the corrupted NET.ACC with the backup
    * made at %1.
    * Any updates made to the database after this time are lost.
    *
    */

#define NELOG_LocalSecFail2 (ERRLOG_BASE + 84)
    /*
    * The user accounts database (NET.ACC) is missing.  The local
    * security system is restoring the backup database
    * made at %1.
    * Any updates made to the database made after this time are lost.
    *
    */

#define NELOG_LocalSecFail3 (ERRLOG_BASE + 85)
    /*
    * Local security could not be started because the user accounts database
    * (NET.ACC) was missing or corrupted, and no usable backup
    * database was present.
    *
    * THE SYSTEM IS NOT SECURE.
    */

#define NELOG_LocalSecGeneralFail   (ERRLOG_BASE + 86)
    /*
    * Local security could not be started because an error
    * occurred during initialization. The error code returned is %1.
    *
    * THE SYSTEM IS NOT SECURE.
    *
    */

//
//  NETWKSTA.SYS specific error log messages from 90 to 99
//

#define NELOG_NetWkSta_Internal_Error   (ERRLOG_BASE + 90)
    /*
    * A NetWksta internal error has occurred:
    *  %1
    */

#define NELOG_NetWkSta_No_Resource  (ERRLOG_BASE + 91)
    /*
    * The redirector is out of a resource: %1.
    */

#define NELOG_NetWkSta_SMB_Err      (ERRLOG_BASE + 92)
    /*
    * A server message block (SMB) error occurred on the connection to %1.
    *  The SMB header is the data.
    */

#define NELOG_NetWkSta_VC_Err       (ERRLOG_BASE + 93)
    /*
    * A virtual circuit error occurred on the session to %1.
    *  The network control block (NCB) command and return code is the data.
    */

#define NELOG_NetWkSta_Stuck_VC_Err (ERRLOG_BASE + 94)
    /*
    * Hanging up a stuck session to %1.
    */

#define NELOG_NetWkSta_NCB_Err      (ERRLOG_BASE + 95)
    /*
    * A network control block (NCB) error occurred (%1).
    *  The NCB is the data.
    */

#define NELOG_NetWkSta_Write_Behind_Err (ERRLOG_BASE + 96)
    /*
    * A write operation to %1 failed.
    *  Data may have been lost.
    */

#define NELOG_NetWkSta_Reset_Err    (ERRLOG_BASE + 97)
    /*
    * Reset of driver %1 failed to complete the network control block (NCB).
    *  The NCB is the data.
    */

#define NELOG_NetWkSta_Too_Many     (ERRLOG_BASE + 98)
    /*
    * The amount of resource %1 requested was more
    *  than the maximum. The maximum amount was allocated.
    */

//
//  Spooler specific error log messages from 100 to 103
//

#define NELOG_Srv_Thread_Failure        (ERRLOG_BASE + 104)
    /*
    * The server could not create a thread.
    *  The THREADS parameter in the CONFIG.SYS file should be increased.
    */

#define NELOG_Srv_Close_Failure         (ERRLOG_BASE + 105)
    /*
    * The server could not close %1.
    *  The file is probably corrupted.
    */

#define NELOG_ReplUserCurDir               (ERRLOG_BASE + 106)
    /*
    *The replicator cannot update directory %1. It has tree integrity
    * and is the current directory for some process.
    */

#define NELOG_ReplCannotMasterDir       (ERRLOG_BASE + 107)
    /*
    *The server cannot export directory %1 to client %2.
    * It is exported from another server.
    */

#define NELOG_ReplUpdateError           (ERRLOG_BASE + 108)
    /*
    *The replication server could not update directory %2 from the source
    * on %3 due to error %1.
    */

#define NELOG_ReplLostMaster            (ERRLOG_BASE + 109)
    /*
    *Master %1 did not send an update notice for directory %2 at the expected
    * time.
    */

#define NELOG_NetlogonAuthDCFail        (ERRLOG_BASE + 110)
    /*
    *Failed to authenticate with %2, a Windows NT domain controller for domain %1.
    */

#define NELOG_ReplLogonFailed           (ERRLOG_BASE + 111)
    /*
    *The replicator attempted to log on at %2 as %1 and failed.
    */

#define NELOG_ReplNetErr            (ERRLOG_BASE + 112)
    /*
    *  Network error %1 occurred.
    */

#define NELOG_ReplMaxFiles            (ERRLOG_BASE + 113)
    /*
    *  Replicator limit for files in a directory has been exceeded.
    */


#define NELOG_ReplMaxTreeDepth            (ERRLOG_BASE + 114)
    /*
    *  Replicator limit for tree depth has been exceeded.
    */

#define NELOG_ReplBadMsg             (ERRLOG_BASE + 115)
    /*
    *  Unrecognized message received in mailslot.
    */

#define NELOG_ReplSysErr            (ERRLOG_BASE + 116)
    /*
    *  System error %1 occurred.
    */

#define NELOG_ReplUserLoged          (ERRLOG_BASE + 117)
    /*
    *  Cannot log on. User is currently logged on and argument TRYUSER
    *  is set to NO.
    */

#define NELOG_ReplBadImport           (ERRLOG_BASE + 118)
    /*
    *  IMPORT path %1 cannot be found.
    */

#define NELOG_ReplBadExport           (ERRLOG_BASE + 119)
    /*
    *  EXPORT path %1 cannot be found.
    */

#define NELOG_ReplSignalFileErr           (ERRLOG_BASE + 120)
    /*
    *  Replicator failed to update signal file in directory %2 due to
    *  %1 system error.
    */

#define NELOG_DiskFT                (ERRLOG_BASE+121)
    /*
    * Disk Fault Tolerance Error
    *
    * %1
    */

#define NELOG_ReplAccessDenied           (ERRLOG_BASE + 122)
    /*
    *  Replicator could not access %2
    *  on %3 due to system error %1.
    */

#define NELOG_NetlogonFailedPrimary      (ERRLOG_BASE + 123)
    /*
    *The primary domain controller for domain %1 has apparently failed.
    */

#define NELOG_NetlogonPasswdSetFailed (ERRLOG_BASE + 124)
    /*
    * Changing machine account password for account %1 failed with
    * the following error: %n%2
    */

#define NELOG_NetlogonTrackingError      (ERRLOG_BASE + 125)
    /*
    *An error occurred while updating the logon or logoff information for %1.
    */

#define NELOG_NetlogonSyncError          (ERRLOG_BASE + 126)
    /*
    *An error occurred while synchronizing with primary domain controller %1
    */

//
//  UPS service specific error log messages from 130 to 135
//

#define NELOG_UPS_PowerOut      (ERRLOG_BASE + 130)
    /*
    * A power failure was detected at the server.
    */

#define NELOG_UPS_Shutdown      (ERRLOG_BASE + 131)
    /*
    * The UPS service performed server shut down.
    */

#define NELOG_UPS_CmdFileError      (ERRLOG_BASE + 132)
    /*
    * The UPS service did not complete execution of the
    * user specified shut down command file.
    */

#define NELOG_UPS_CannotOpenDriver  (ERRLOG_BASE+133)
    /*
    * The UPS driver could not be opened.  The error code is
    * the data.
    */

#define NELOG_UPS_PowerBack     (ERRLOG_BASE + 134)
    /*
    * Power has been restored.
    */

#define NELOG_UPS_CmdFileConfig     (ERRLOG_BASE + 135)
    /*
    * There is a problem with a configuration of user specified
    * shut down command file.
    */

#define NELOG_UPS_CmdFileExec       (ERRLOG_BASE + 136)
    /*
    * The UPS service failed to execute a user specified shutdown
    * command file %1.  The error code is the data.
    */

//
//  Remoteboot server specific error log messages are from 150 to 157
//

#define NELOG_Missing_Parameter     (ERRLOG_BASE + 150)
    /*
    * Initialization failed because of an invalid or missing
    *  parameter in the configuration file %1.
    */

#define NELOG_Invalid_Config_Line   (ERRLOG_BASE + 151)
    /*
    * Initialization failed because of an invalid line in the
    *  configuration file %1. The invalid line is the data.
    */

#define NELOG_Invalid_Config_File   (ERRLOG_BASE + 152)
    /*
    * Initialization failed because of an error in the configuration
    *  file %1.
    */

#define NELOG_File_Changed      (ERRLOG_BASE + 153)
    /*
    * The file %1 has been changed after initialization.
    *  The boot-block loading was temporarily terminated.
    */

#define NELOG_Files_Dont_Fit        (ERRLOG_BASE + 154)
    /*
    * The files do not fit to the boot-block configuration
    * file %1. Change the BASE and ORG definitions or the order
    * of the files.
    */

#define NELOG_Wrong_DLL_Version     (ERRLOG_BASE + 155)
    /*
    * Initialization failed because the dynamic-link
    *  library %1 returned an incorrect version number.
    */

#define NELOG_Error_in_DLL      (ERRLOG_BASE + 156)
    /*
    * There was an unrecoverable error in the dynamic-
    *  link library of the service.
    */

#define NELOG_System_Error      (ERRLOG_BASE + 157)
    /*
    * The system returned an unexpected error code.
    *  The error code is the data.
    */

#define NELOG_FT_ErrLog_Too_Large (ERRLOG_BASE + 158)
    /*
    * The fault-tolerance error log file, LANROOT\LOGS\FT.LOG,
    *  is more than 64K.
    */

#define NELOG_FT_Update_In_Progress (ERRLOG_BASE + 159)
    /*
    * The fault-tolerance error-log file, LANROOT\LOGS\FT.LOG, had the
    * update in progress bit set upon opening, which means that the
    * system crashed while working on the error log.
    */


//
// Microsoft has created a generic error log entry for OEMs to use to
// log errors from OEM value added services.  The code, which is the
// 2nd arg to NetErrorLogWrite, is 3299.  This value is manifest in
// NET/H/ERRLOG.H as NELOG_OEM_Code.  The text for error log entry
// NELOG_OEM_Code is:  "%1 %2 %3 %4 %5 %6 %7 %8 %9.".
//
// Microsoft suggests that OEMs use the insertion strings as follows:
// %1:  OEM System Name (e.g. 3+Open)
// %2:  OEM Service Name (e.g. 3+Mail)
// %3:  Severity level (e.g.  error, warning, etc.)
// %4:  OEM error log entry sub-identifier  (e.g. error code #)
// %5 - % 9:  Text.
//
// The call to NetErrorWrite must set nstrings = 9, and provide 9
// ASCIIZ strings.  If the caller does not have 9 insertion strings,
// provide null strings for the empty insertion strings.
//

#define NELOG_OEM_Code              (ERRLOG_BASE + 199)
    /*
    * %1 %2 %3 %4 %5 %6 %7 %8 %9.
    */

//
// another error log range defined for NT Lanman.
//

#define ERRLOG2_BASE 5700        /* New NT NELOG errors start here */

#define NELOG_NetlogonSSIInitError              (ERRLOG2_BASE + 0)
    /*
     * The Netlogon service could not initialize the replication data
     * structures successfully. The service was terminated.  The following
     * error occurred: %n%1
     */

#define NELOG_NetlogonFailedToUpdateTrustList   (ERRLOG2_BASE + 1)
    /*
     * The Netlogon service failed to update the domain trust list.  The
     * following error occurred: %n%1
     */

#define NELOG_NetlogonFailedToAddRpcInterface   (ERRLOG2_BASE + 2)
    /*
     * The Netlogon service could not add the RPC interface.  The
     * service was terminated. The following error occurred: %n%1
     */

#define NELOG_NetlogonFailedToReadMailslot      (ERRLOG2_BASE + 3)
    /*
     * The Netlogon service could not read a mailslot message from %1 due
     * to the following error: %n%2
     */

#define NELOG_NetlogonFailedToRegisterSC        (ERRLOG2_BASE + 4)
    /*
     * The Netlogon service failed to register the service with the
     * service controller. The service was terminated. The following
     * error occurred: %n%1
     */

#define NELOG_NetlogonChangeLogCorrupt          (ERRLOG2_BASE + 5)
    /*
     * The change log cache maintained by the Netlogon service for
     * database changes is corrupted. The Netlogon service is resetting
     * the change log.
     */

#define NELOG_NetlogonFailedToCreateShare       (ERRLOG2_BASE + 6)
    /*
     * The Netlogon service could not create server share %1.  The following
     * error occurred: %n%2
     */

#define NELOG_NetlogonDownLevelLogonFailed      (ERRLOG2_BASE + 7)
    /*
     * The down-level logon request for the user %1 from %2 failed.
     */

#define NELOG_NetlogonDownLevelLogoffFailed     (ERRLOG2_BASE + 8)
    /*
     * The down-level logoff request for the user %1 from %2 failed.
     */

#define NELOG_NetlogonNTLogonFailed             (ERRLOG2_BASE + 9)
    /*
     * The Windows NT %1 logon request for the user %2\%3 from %4 (via %5)
     * failed.
     */

#define NELOG_NetlogonNTLogoffFailed            (ERRLOG2_BASE + 10)
    /*
     * The Windows NT %1 logoff request for the user %2\%3 from %4
     * failed.
     */

#define NELOG_NetlogonPartialSyncCallSuccess    (ERRLOG2_BASE + 11)
    /*
     * The partial synchronization request from the server %1 completed
     * successfully. %2 changes(s) has(have) been returned to the
     * caller.
     */

#define NELOG_NetlogonPartialSyncCallFailed     (ERRLOG2_BASE + 12)
    /*
     * The partial synchronization request from the server %1 failed with
     * the following error: %n%2
     */

#define NELOG_NetlogonFullSyncCallSuccess       (ERRLOG2_BASE + 13)
    /*
     * The full synchronization request from the server %1 completed
     * successfully. %2 object(s) has(have) been returned to
     * the caller.
     */

#define NELOG_NetlogonFullSyncCallFailed        (ERRLOG2_BASE + 14)
    /*
     * The full synchronization request from the server %1 failed with
     * the following error: %n%2
     */

#define NELOG_NetlogonPartialSyncSuccess        (ERRLOG2_BASE + 15)
    /*
     * The partial synchronization replication of the %1 database from the
     * primary domain controller %2 completed successfully. %3 change(s) is(are)
     * applied to the database.
     */


#define NELOG_NetlogonPartialSyncFailed         (ERRLOG2_BASE + 16)
    /*
     * The partial synchronization replication of the %1 database from the
     * primary domain controller %2 failed with the following error: %n%3
     */

#define NELOG_NetlogonFullSyncSuccess           (ERRLOG2_BASE + 17)
    /*
     * The full synchronization replication of the %1 database from the
     * primary domain controller %2 completed successfully.
     */


#define NELOG_NetlogonFullSyncFailed            (ERRLOG2_BASE + 18)
    /*
     * The full synchronization replication of the %1 database from the
     * primary domain controller %2 failed with the following error: %n%3
     */

#define NELOG_NetlogonAuthNoDomainController    (ERRLOG2_BASE + 19)
    /*
     *  No Windows NT Domain Controller is available for domain %1 for
     *  the following reason: %n%2
     */

#define NELOG_NetlogonAuthNoTrustLsaSecret      (ERRLOG2_BASE + 20)
    /*
     * The session setup to the Windows NT Domain Controller %1 for the domain %2
     * failed because the computer %3 does not have a local security database account.
     */

#define NELOG_NetlogonAuthNoTrustSamAccount     (ERRLOG2_BASE + 21)
    /*
     * The session setup to the Windows NT Domain Controller %1 for the domain %2
     * failed because the Windows NT Domain Controller does not have an account
     * for the computer %3.
     */

#define NELOG_NetlogonServerAuthFailed          (ERRLOG2_BASE + 22)
    /*
     * The session setup from the computer %1 failed to authenticate.
     * The name of the account referenced in the security database is
     * %2.  The following error occurred: %n%3
     */

#define NELOG_NetlogonServerAuthNoTrustSamAccount (ERRLOG2_BASE + 23)
    /*
     * The session setup from the computer %1 failed because there is
     * no trust account in the security database for this computer. The name of
     * the account referenced in the security database is %2.
     */

//
// General log messages for NT services.
//

#define NELOG_FailedToRegisterSC                  (ERRLOG2_BASE + 24)
    /*
     * Could not register control handler with service controller %1.
     */

#define NELOG_FailedToSetServiceStatus            (ERRLOG2_BASE + 25)
    /*
     * Could not set service status with service controller %1.
     */

#define NELOG_FailedToGetComputerName             (ERRLOG2_BASE + 26)
    /*
     * Could not find the computer name %1.
     */

#define NELOG_DriverNotLoaded                     (ERRLOG2_BASE + 27)
    /*
     * Could not load %1 device driver.
     */

#define NELOG_NoTranportLoaded                    (ERRLOG2_BASE + 28)
    /*
     * Could not load any transport.
     */

//
// More Netlogon service events
//

#define NELOG_NetlogonFailedDomainDelta           (ERRLOG2_BASE + 29)
    /*
     * Replication of the %1 Domain Object "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedGlobalGroupDelta      (ERRLOG2_BASE + 30)
    /*
     * Replication of the %1 Global Group "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedLocalGroupDelta       (ERRLOG2_BASE + 31)
    /*
     * Replication of the %1 Local Group "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedUserDelta             (ERRLOG2_BASE + 32)
    /*
     * Replication of the %1 User "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedPolicyDelta           (ERRLOG2_BASE + 33)
    /*
     * Replication of the %1 Policy Object "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedTrustedDomainDelta    (ERRLOG2_BASE + 34)
    /*
     * Replication of the %1 Trusted Domain Object "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedAccountDelta          (ERRLOG2_BASE + 35)
    /*
     * Replication of the %1 Account Object "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedSecretDelta           (ERRLOG2_BASE + 36)
    /*
     * Replication of the %1 Secret "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonSystemError                 (ERRLOG2_BASE + 37)
    /*
    * The system returned the following unexpected error code: %n%1
    */

#define NELOG_NetlogonDuplicateMachineAccounts    (ERRLOG2_BASE + 38)
    /*
    * Netlogon has detected two machine accounts for server "%1".
    * The server can be either a Windows NT Server that is a member of the
    * domain or the server can be a LAN Manager server with an account in the
    * SERVERS global group.  It cannot be both.
    */

#define NELOG_NetlogonTooManyGlobalGroups         (ERRLOG2_BASE + 39)
    /*
    * This domain has more global groups than can be replicated to a LanMan
    * BDC.  Either delete some of your global groups or remove the LanMan
    * BDCs from the domain.
    */

#define NELOG_NetlogonBrowserDriver               (ERRLOG2_BASE + 40)
    /*
    * The Browser driver returned the following error to Netlogon: %n%1
    */

#define NELOG_NetlogonAddNameFailure              (ERRLOG2_BASE + 41)
    /*
    * Netlogon could not register the %1<1B> name for the following reason: %n%2
    */

//
//  More Remoteboot service events.
//
#define NELOG_RplMessages                         (ERRLOG2_BASE + 42)
    /*
    * Service failed to retrieve messages needed to boot remote boot clients.
    */

#define NELOG_RplXnsBoot                          (ERRLOG2_BASE + 43)
    /*
    * Service experienced a severe error and can no longer provide remote boot
    * for 3Com 3Start remote boot clients.
    */

#define NELOG_RplSystem                           (ERRLOG2_BASE + 44)
    /*
    * Service experienced a severe system error and will shut itself down.
    */

#define NELOG_RplWkstaTimeout                     (ERRLOG2_BASE + 45)
    /*
    * Client with computer name %1 failed to acknowledge receipt of the
    * boot data.  Remote boot of this client was not completed.
    */

#define NELOG_RplWkstaFileOpen                    (ERRLOG2_BASE + 46)
    /*
    * Client with computer name %1 was not booted due to an error in opening
    * file %2.
    */

#define NELOG_RplWkstaFileRead                    (ERRLOG2_BASE + 47)
    /*
    * Client with computer name %1 was not booted due to an error in reading
    * file %2.
    */

#define NELOG_RplWkstaMemory                      (ERRLOG2_BASE + 48)
    /*
    * Client with computer name %1 was not booted due to insufficent memory
    * at the remote boot server.
    */

#define NELOG_RplWkstaFileChecksum                (ERRLOG2_BASE + 49)
    /*
    * Client with computer name %1 will be booted without using checksums
    * because checksum for file %2 could not be calculated.
    */

#define NELOG_RplWkstaFileLineCount               (ERRLOG2_BASE + 50)
    /*
    * Client with computer name %1 was not booted due to too many lines in
    * file %2.
    */

#define NELOG_RplWkstaBbcFile                     (ERRLOG2_BASE + 51)
    /*
    * Client with computer name %1 was not booted because the boot block
    * configuration file %2 for this client does not contain boot block
    * line and/or loader line.
    */

#define NELOG_RplWkstaFileSize                    (ERRLOG2_BASE + 52)
    /*
    * Client with computer name %1 was not booted due to a bad size of
    * file %2.
    */

#define NELOG_RplWkstaInternal                    (ERRLOG2_BASE + 53)
    /*
    * Client with computer name %1 was not booted due to remote boot
    * service internal error.
    */

#define NELOG_RplWkstaWrongVersion                (ERRLOG2_BASE + 54)
    /*
    * Client with computer name %1 was not booted because file %2 has an
    * invalid boot header.
    */

#define NELOG_RplWkstaNetwork                     (ERRLOG2_BASE + 55)
    /*
    * Client with computer name %1 was not booted due to network error.
    */

#define NELOG_RplAdapterResource                  (ERRLOG2_BASE + 56)
    /*
    * Client with adapter id %1 was not booted due to lack of resources.
    */

#define NELOG_RplFileCopy                         (ERRLOG2_BASE + 57)
    /*
    * Service experienced error copying file or directory %1.
    */

#define NELOG_RplFileDelete                       (ERRLOG2_BASE + 58)
    /*
    * Service experienced error deleting file or directory %1.
    */

#define NELOG_RplFilePerms                        (ERRLOG2_BASE + 59)
    /*
    * Service experienced error setting permissions on file or directory %1.
    */
#define NELOG_RplCheckConfigs                     (ERRLOG2_BASE + 60)
    /*
    * Service experienced error evaluating RPL configurations.
    */
#define NELOG_RplCreateProfiles                   (ERRLOG2_BASE + 61)
    /*
    * Service experienced error creating RPL profiles for all configurations.
    */
#define NELOG_RplRegistry                         (ERRLOG2_BASE + 62)
    /*
    * Service experienced error accessing registry.
    */
#define NELOG_RplReplaceRPLDISK                   (ERRLOG2_BASE + 63)
    /*
    * Service experienced error replacing possibly outdated RPLDISK.SYS.
    */
#define NELOG_RplCheckSecurity                    (ERRLOG2_BASE + 64)
    /*
    * Service experienced error adding security accounts or setting
    * file permissions.  These accounts are the RPLUSER local group
    * and the user accounts for the individual RPL workstations.
    */
#define NELOG_RplBackupDatabase                   (ERRLOG2_BASE + 65)
    /*
    * Service failed to back up its database.
    */
#define NELOG_RplInitDatabase                     (ERRLOG2_BASE + 66)
    /*
    * Service failed to initialize from its database.  The database may be
    * missing or corrupted.  Service will attempt restoring the database
    * from the backup.
    */
#define NELOG_RplRestoreDatabaseFailure           (ERRLOG2_BASE + 67)
    /*
    * Service failed to restore its database from the backup.  Service
    * will not start.
    */
#define NELOG_RplRestoreDatabaseSuccess           (ERRLOG2_BASE + 68)
    /*
    * Service sucessfully restored its database from the backup.
    */
#define NELOG_RplInitRestoredDatabase             (ERRLOG2_BASE + 69)
    /*
    * Service failed to initialize from its restored database.  Service
    * will not start.
    */

//
// More Netlogon service events
//
#define NELOG_NetlogonSessionTypeWrong            (ERRLOG2_BASE + 70)
    /*
     * The session setup to the Windows NT Domain Controller %1 from computer
     * %2 using account %4 failed.  %2 is declared to be a BDC in domain %3.
     * However, %2 tried to connect as either a DC in a trusted domain,
     * a member workstation in domain %3, or as a server in domain %3.
     * Use the Server Manager to remove the BDC account for %2.
     */

#endif // _LMERRLOG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\lmshare.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    lmshare.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetShare
        NetSession
        NetFile
        NetConnection

Environment:

    User Mode - Win32

Notes:

    You must include <windef.h> and <lmcons.h> before this file.

--*/

//
// SHARE API
//

#ifndef _LMSHARE_
#define _LMSHARE_

#ifdef __cplusplus
extern "C" {
#endif

//
// Function Prototypes - Share
//

NET_API_STATUS NET_API_FUNCTION
NetShareAdd (
    IN  LPTSTR  servername,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err
    );

NET_API_STATUS NET_API_FUNCTION
NetShareEnum (
    IN  LPTSTR      servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle
    );

NET_API_STATUS NET_API_FUNCTION
NetShareEnumSticky (
    IN  LPTSTR      servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle
    );

NET_API_STATUS NET_API_FUNCTION
NetShareGetInfo (
    IN  LPTSTR  servername,
    IN  LPTSTR  netname,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetShareSetInfo (
    IN  LPTSTR  servername,
    IN  LPTSTR  netname,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err
    );

NET_API_STATUS NET_API_FUNCTION
NetShareDel     (
    IN  LPTSTR  servername,
    IN  LPTSTR  netname,
    IN  DWORD   reserved
    );

NET_API_STATUS NET_API_FUNCTION
NetShareDelSticky (
    IN  LPTSTR  servername,
    IN  LPTSTR  netname,
    IN  DWORD   reserved
    );

NET_API_STATUS NET_API_FUNCTION
NetShareCheck   (
    IN  LPTSTR  servername,
    IN  LPTSTR  device,
    OUT LPDWORD type
    );

//
// Data Structures - Share
//

typedef struct _SHARE_INFO_0 {
    LPTSTR  shi0_netname;
} SHARE_INFO_0, *PSHARE_INFO_0, *LPSHARE_INFO_0;

typedef struct _SHARE_INFO_1 {
    LPTSTR  shi1_netname;
    DWORD   shi1_type;
    LPTSTR  shi1_remark;
} SHARE_INFO_1, *PSHARE_INFO_1, *LPSHARE_INFO_1;

typedef struct _SHARE_INFO_2 {
    LPTSTR  shi2_netname;
    DWORD   shi2_type;
    LPTSTR  shi2_remark;
    DWORD   shi2_permissions;
    DWORD   shi2_max_uses;
    DWORD   shi2_current_uses;
    LPTSTR  shi2_path;
    LPTSTR  shi2_passwd;
} SHARE_INFO_2, *PSHARE_INFO_2, *LPSHARE_INFO_2;

typedef struct _SHARE_INFO_502 {
    LPTSTR  shi502_netname;
    DWORD   shi502_type;
    LPTSTR  shi502_remark;
    DWORD   shi502_permissions;
    DWORD   shi502_max_uses;
    DWORD   shi502_current_uses;
    LPTSTR  shi502_path;
    LPTSTR  shi502_passwd;
    DWORD   shi502_reserved;
    PSECURITY_DESCRIPTOR  shi502_security_descriptor;
} SHARE_INFO_502, *PSHARE_INFO_502, *LPSHARE_INFO_502;

typedef struct _SHARE_INFO_1004 {
    LPTSTR  shi1004_remark;
} SHARE_INFO_1004, *PSHARE_INFO_1004, *LPSHARE_INFO_1004;

typedef struct _SHARE_INFO_1006 {
    DWORD   shi1006_max_uses;
} SHARE_INFO_1006, *PSHARE_INFO_1006, *LPSHARE_INFO_1006;

typedef struct _SHARE_INFO_1501 {
    DWORD   shi1501_reserved;
    PSECURITY_DESCRIPTOR  shi1501_security_descriptor;
} SHARE_INFO_1501, *PSHARE_INFO_1501, *LPSHARE_INFO_1501;

//
// Special Values and Constants - Share
//

//
// Values for parm_err parameter.
//

#define SHARE_NETNAME_PARMNUM         1
#define SHARE_TYPE_PARMNUM            3
#define SHARE_REMARK_PARMNUM          4
#define SHARE_PERMISSIONS_PARMNUM     5
#define SHARE_MAX_USES_PARMNUM        6
#define SHARE_CURRENT_USES_PARMNUM    7
#define SHARE_PATH_PARMNUM            8
#define SHARE_PASSWD_PARMNUM          9
#define SHARE_FILE_SD_PARMNUM       501

//
// Single-field infolevels for NetShareSetInfo.
//

#define SHARE_REMARK_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + SHARE_REMARK_PARMNUM)
#define SHARE_MAX_USES_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + SHARE_MAX_USES_PARMNUM)
#define SHARE_FILE_SD_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SHARE_FILE_SD_PARMNUM)

#define SHI1_NUM_ELEMENTS       4
#define SHI2_NUM_ELEMENTS       10


//
// Share types (shi1_type and shi2_type fields).
//

#define STYPE_DISKTREE          0
#define STYPE_PRINTQ            1
#define STYPE_DEVICE            2
#define STYPE_IPC               3
#define STYPE_DFS               100

#define STYPE_SPECIAL           0x80000000

#define SHI_USES_UNLIMITED      (DWORD)-1

#endif // _LMSHARE_

//
// SESSION API
//

#ifndef _LMSESSION_
#define _LMSESSION_

//
// Function Prototypes Session
//

NET_API_STATUS NET_API_FUNCTION
NetSessionEnum (
    IN  LPTSTR      servername OPTIONAL,
    IN  LPTSTR      UncClientName OPTIONAL,
    IN  LPTSTR      username OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetSessionDel (
    IN  LPTSTR      servername OPTIONAL,
    IN  LPTSTR      UncClientName,
    IN  LPTSTR      username
    );

NET_API_STATUS NET_API_FUNCTION
NetSessionGetInfo (
    IN  LPTSTR      servername OPTIONAL,
    IN  LPTSTR      UncClientName,
    IN  LPTSTR      username,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr
    );


//
// Data Structures - Session
//

typedef struct _SESSION_INFO_0 {
    LPTSTR    sesi0_cname;              // client name (no backslashes)
} SESSION_INFO_0, *PSESSION_INFO_0, *LPSESSION_INFO_0;

typedef struct _SESSION_INFO_1 {
    LPTSTR    sesi1_cname;              // client name (no backslashes)
    LPTSTR    sesi1_username;
    DWORD     sesi1_num_opens;
    DWORD     sesi1_time;
    DWORD     sesi1_idle_time;
    DWORD     sesi1_user_flags;
} SESSION_INFO_1, *PSESSION_INFO_1, *LPSESSION_INFO_1;

typedef struct _SESSION_INFO_2 {
    LPTSTR    sesi2_cname;              // client name (no backslashes)
    LPTSTR    sesi2_username;
    DWORD     sesi2_num_opens;
    DWORD     sesi2_time;
    DWORD     sesi2_idle_time;
    DWORD     sesi2_user_flags;
    LPTSTR    sesi2_cltype_name;
} SESSION_INFO_2, *PSESSION_INFO_2, *LPSESSION_INFO_2;

typedef struct _SESSION_INFO_10 {
    LPTSTR    sesi10_cname;             // client name (no backslashes)
    LPTSTR    sesi10_username;
    DWORD     sesi10_time;
    DWORD     sesi10_idle_time;
} SESSION_INFO_10, *PSESSION_INFO_10, *LPSESSION_INFO_10;

typedef struct _SESSION_INFO_502 {
    LPTSTR    sesi502_cname;             // client name (no backslashes)
    LPTSTR    sesi502_username;
    DWORD     sesi502_num_opens;
    DWORD     sesi502_time;
    DWORD     sesi502_idle_time;
    DWORD     sesi502_user_flags;
    LPTSTR    sesi502_cltype_name;
    LPTSTR    sesi502_transport;
} SESSION_INFO_502, *PSESSION_INFO_502, *LPSESSION_INFO_502;


//
// Special Values and Constants - Session
//


//
// Bits defined in sesi1_user_flags.
//

#define SESS_GUEST          0x00000001  // session is logged on as a guest
#define SESS_NOENCRYPTION   0x00000002  // session is not using encryption

#define SESI1_NUM_ELEMENTS  8
#define SESI2_NUM_ELEMENTS  9

#endif // _LMSESSION_

//
// CONNECTION API
//

#ifndef _LMCONNECTION_

#define _LMCONNECTION_

//
// Function Prototypes - CONNECTION
//

NET_API_STATUS NET_API_FUNCTION
NetConnectionEnum (
    IN  LPTSTR  servername OPTIONAL,
    IN  LPTSTR  qualifier,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr,
    IN  DWORD   prefmaxlen,
    OUT LPDWORD entriesread,
    OUT LPDWORD totalentries,
    IN OUT LPDWORD resume_handle OPTIONAL
    );

//
// Data Structures - CONNECTION
//

typedef struct _CONNECTION_INFO_0 {
    DWORD   coni0_id;
} CONNECTION_INFO_0, *PCONNECTION_INFO_0, *LPCONNECTION_INFO_0;

typedef struct _CONNECTION_INFO_1 {
    DWORD   coni1_id;
    DWORD   coni1_type;
    DWORD   coni1_num_opens;
    DWORD   coni1_num_users;
    DWORD   coni1_time;
    LPTSTR  coni1_username;
    LPTSTR  coni1_netname;
} CONNECTION_INFO_1, *PCONNECTION_INFO_1, *LPCONNECTION_INFO_1;

#endif // _LMCONNECTION_

//
// FILE API
//

#ifndef _LMFILE_
#define _LMFILE_

//
// Function Prototypes - FILE
//

NET_API_STATUS NET_API_FUNCTION
NetFileClose (
    IN LPTSTR   servername OPTIONAL,
    IN DWORD    fileid
    );

NET_API_STATUS NET_API_FUNCTION
NetFileEnum (
    IN  LPTSTR      servername OPTIONAL,
    IN  LPTSTR      basepath OPTIONAL,
    IN  LPTSTR      username OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetFileGetInfo (
    IN  LPTSTR  servername OPTIONAL,
    IN  DWORD   fileid,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

//
// Data Structures - File
//

//  File APIs are available at information levels 2 & 3 only. Levels 0 &
//  1 are not supported.
//

typedef struct _FILE_INFO_2 {
    DWORD     fi2_id;
} FILE_INFO_2, *PFILE_INFO_2, *LPFILE_INFO_2;

typedef struct _FILE_INFO_3 {
    DWORD     fi3_id;
    DWORD     fi3_permissions;
    DWORD     fi3_num_locks;
    LPTSTR    fi3_pathname;
    LPTSTR    fi3_username;
} FILE_INFO_3, *PFILE_INFO_3, *LPFILE_INFO_3;

//
// Special Values and Constants - File
//

//
// bit values for permissions
//

#define PERM_FILE_READ      0x1 // user has read access
#define PERM_FILE_WRITE     0x2 // user has write access
#define PERM_FILE_CREATE    0x4 // user has create access

#ifdef __cplusplus
}
#endif

#endif // _LMFILE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\lmstats.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    lmstats.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetStatistics

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMSTATS_
#define _LMSTATS_

#ifdef __cplusplus
extern "C" {
#endif

//
// Function Prototypes - Statistics
//

NET_API_STATUS NET_API_FUNCTION
NetStatisticsGet (
    IN  LPTSTR  server,
    IN  LPTSTR  service,
    IN  DWORD   level,
    IN  DWORD   options,
    OUT LPBYTE  *bufptr
    );

//
// Data Structures - Statistics
//

#ifdef LM20_WORKSTATION_STATISTICS
typedef struct _STAT_WORKSTATION_0 {
     DWORD          stw0_start;
     DWORD          stw0_numNCB_r;
     DWORD          stw0_numNCB_s;
     DWORD          stw0_numNCB_a;
     DWORD          stw0_fiNCB_r;
     DWORD          stw0_fiNCB_s;
     DWORD          stw0_fiNCB_a;
     DWORD          stw0_fcNCB_r;
     DWORD          stw0_fcNCB_s;
     DWORD          stw0_fcNCB_a;
     DWORD          stw0_sesstart;
     DWORD          stw0_sessfailcon;
     DWORD          stw0_sessbroke;
     DWORD          stw0_uses;
     DWORD          stw0_usefail;
     DWORD          stw0_autorec;
     DWORD          stw0_bytessent_r_lo;
     DWORD          stw0_bytessent_r_hi;
     DWORD          stw0_bytesrcvd_r_lo;
     DWORD          stw0_bytesrcvd_r_hi;
     DWORD          stw0_bytessent_s_lo;
     DWORD          stw0_bytessent_s_hi;
     DWORD          stw0_bytesrcvd_s_lo;
     DWORD          stw0_bytesrcvd_s_hi;
     DWORD          stw0_bytessent_a_lo;
     DWORD          stw0_bytessent_a_hi;
     DWORD          stw0_bytesrcvd_a_lo;
     DWORD          stw0_bytesrcvd_a_hi;
     DWORD          stw0_reqbufneed;
     DWORD          stw0_bigbufneed;
} STAT_WORKSTATION_0, *PSTAT_WORKSTATION_0, *LPSTAT_WORKSTATION_0;
#else

//
// NB: The following structure is REDIR_STATISTICS in sdk\inc\ntddnfs.h. If you
//     change the structure, change it in both places
//

typedef struct _STAT_WORKSTATION_0 {
    LARGE_INTEGER   StatisticsStartTime;

    LARGE_INTEGER   BytesReceived;
    LARGE_INTEGER   SmbsReceived;
    LARGE_INTEGER   PagingReadBytesRequested;
    LARGE_INTEGER   NonPagingReadBytesRequested;
    LARGE_INTEGER   CacheReadBytesRequested;
    LARGE_INTEGER   NetworkReadBytesRequested;

    LARGE_INTEGER   BytesTransmitted;
    LARGE_INTEGER   SmbsTransmitted;
    LARGE_INTEGER   PagingWriteBytesRequested;
    LARGE_INTEGER   NonPagingWriteBytesRequested;
    LARGE_INTEGER   CacheWriteBytesRequested;
    LARGE_INTEGER   NetworkWriteBytesRequested;

    DWORD           InitiallyFailedOperations;
    DWORD           FailedCompletionOperations;

    DWORD           ReadOperations;
    DWORD           RandomReadOperations;
    DWORD           ReadSmbs;
    DWORD           LargeReadSmbs;
    DWORD           SmallReadSmbs;

    DWORD           WriteOperations;
    DWORD           RandomWriteOperations;
    DWORD           WriteSmbs;
    DWORD           LargeWriteSmbs;
    DWORD           SmallWriteSmbs;

    DWORD           RawReadsDenied;
    DWORD           RawWritesDenied;

    DWORD           NetworkErrors;

    //  Connection/Session counts
    DWORD           Sessions;
    DWORD           FailedSessions;
    DWORD           Reconnects;
    DWORD           CoreConnects;
    DWORD           Lanman20Connects;
    DWORD           Lanman21Connects;
    DWORD           LanmanNtConnects;
    DWORD           ServerDisconnects;
    DWORD           HungSessions;
    DWORD           UseCount;
    DWORD           FailedUseCount;

    //
    //  Queue Lengths (updates protected by RdrMpxTableSpinLock NOT
    //  RdrStatisticsSpinlock)
    //

    DWORD           CurrentCommands;

} STAT_WORKSTATION_0, *PSTAT_WORKSTATION_0, *LPSTAT_WORKSTATION_0;
#endif

typedef struct _STAT_SERVER_0 {
     DWORD          sts0_start;
     DWORD          sts0_fopens;
     DWORD          sts0_devopens;
     DWORD          sts0_jobsqueued;
     DWORD          sts0_sopens;
     DWORD          sts0_stimedout;
     DWORD          sts0_serrorout;
     DWORD          sts0_pwerrors;
     DWORD          sts0_permerrors;
     DWORD          sts0_syserrors;
     DWORD          sts0_bytessent_low;
     DWORD          sts0_bytessent_high;
     DWORD          sts0_bytesrcvd_low;
     DWORD          sts0_bytesrcvd_high;
     DWORD          sts0_avresponse;
     DWORD          sts0_reqbufneed;
     DWORD          sts0_bigbufneed;
} STAT_SERVER_0, *PSTAT_SERVER_0, *LPSTAT_SERVER_0;


//
// Special Values and Constants
//

#define STATSOPT_CLR    1
#define STATS_NO_VALUE  ((unsigned long) -1L)
#define STATS_OVERFLOW  ((unsigned long) -2L)


#ifdef __cplusplus
}
#endif

#endif // _LMSTATS.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\lmremutl.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    lmremutl.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetRemote API.

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

--*/

#ifndef _LMREMUTL_
#define _LMREMUTL_

#ifdef __cplusplus
extern "C" {
#endif


//
// Type Definitions
//

#ifndef DESC_CHAR_UNICODE

typedef CHAR DESC_CHAR;

#else // DESC_CHAR_UNICODE is defined

typedef WCHAR DESC_CHAR;

#endif // DESC_CHAR_UNICODE is defined


typedef DESC_CHAR * LPDESC;


//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetRemoteTOD (
    IN LPTSTR UncServerName,
    OUT LPBYTE *BufferPtr
    );

NET_API_STATUS NET_API_FUNCTION
NetRemoteComputerSupports(
    IN LPTSTR UncServerName OPTIONAL,   // Must start with "\\".
    IN DWORD OptionsWanted,             // Set SUPPORTS_ bits wanted.
    OUT LPDWORD OptionsSupported        // Supported features, masked.
    );

NET_API_STATUS
RxRemoteApi(
    IN DWORD ApiNumber,
    IN LPTSTR UncServerName,                    // Required, with \\name.
    IN LPDESC ParmDescString,
    IN LPDESC DataDesc16 OPTIONAL,
    IN LPDESC DataDesc32 OPTIONAL,
    IN LPDESC DataDescSmb OPTIONAL,
    IN LPDESC AuxDesc16 OPTIONAL,
    IN LPDESC AuxDesc32 OPTIONAL,
    IN LPDESC AuxDescSmb OPTIONAL,
    IN DWORD  Flags,
    ...                                         // rest of API's arguments
    );



//
//  Data Structures
//

typedef struct _TIME_OF_DAY_INFO {
    DWORD      tod_elapsedt;
    DWORD      tod_msecs;
    DWORD      tod_hours;
    DWORD      tod_mins;
    DWORD      tod_secs;
    DWORD      tod_hunds;
    LONG       tod_timezone;
    DWORD      tod_tinterval;
    DWORD      tod_day;
    DWORD      tod_month;
    DWORD      tod_year;
    DWORD      tod_weekday;
} TIME_OF_DAY_INFO, *PTIME_OF_DAY_INFO, *LPTIME_OF_DAY_INFO;

//
// Special Values and Constants
//

//
// Mask bits for use with NetRemoteComputerSupports:
//

#define SUPPORTS_REMOTE_ADMIN_PROTOCOL  0x00000002L
#define SUPPORTS_RPC                    0x00000004L
#define SUPPORTS_SAM_PROTOCOL           0x00000008L
#define SUPPORTS_UNICODE                0x00000010L
#define SUPPORTS_LOCAL                  0x00000020L
#define SUPPORTS_ANY                    0xFFFFFFFFL

//
// Flag bits for RxRemoteApi:
//

#define NO_PERMISSION_REQUIRED  0x00000001      // set if use NULL session
#define ALLOCATE_RESPONSE       0x00000002      // set if RxRemoteApi allocates response buffer
#define USE_SPECIFIC_TRANSPORT  0x80000000

#ifdef __cplusplus
}
#endif

#endif //_LMREMUTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\lmserver.h ===
/*++ BUILD VERSION: 0007    // INCREMENT THIS IF A CHANGE HAS GLOBAL EFFECTS

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    lmserver.h

Abstract:

    This file contains information about NetServer APIs.
        Function Prototypes
        Data Structures
        Definition of special values

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMSERVER_
#define _LMSERVER_

#ifdef __cplusplus
extern "C" {
#endif

#include <winsvc.h>     // SERVICE_STATUS_HANDLE

//
// Function Prototypes - SERVER
//

NET_API_STATUS NET_API_FUNCTION
NetServerEnum (
    IN  LPTSTR      servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN  DWORD       servertype,
    IN  LPTSTR      domain OPTIONAL,
    IN OUT LPDWORD  resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetServerGetInfo (
    IN  LPTSTR  servername OPTIONAL,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetServerSetInfo (
    IN  LPTSTR  servername OPTIONAL,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD ParmError OPTIONAL
    );

//
// Temporary hack function.
//

NET_API_STATUS
NetServerSetInfoCommandLine (
    IN WORD argc,
    IN LPTSTR argv[]
    );

NET_API_STATUS NET_API_FUNCTION
NetServerDiskEnum (
    IN  LPTSTR      servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetServerTransportAdd (
    IN  LPTSTR  servername,
    IN  DWORD   level,
    IN  LPBYTE  bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetServerTransportDel (
    IN  LPTSTR  servername,
    IN  DWORD   level,
    IN  LPBYTE  bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetServerTransportEnum (
    IN  LPTSTR      servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resumehandle
    );

//
// The following function can be called by Win NT services to register
// their service type.  This function is exported from advapi32.dll.
// Therefore, if this is the only function called by that service, then
// it is not necessary to link to netapi32.lib.
//
BOOL
SetServiceBits(
    IN SERVICE_STATUS_HANDLE    hServiceStatus,
    IN DWORD                    dwServiceBits,
    IN BOOL                     bSetBitsOn,
    IN BOOL                     bUpdateImmediately
    );

//
// Data Structures - SERVER
//

typedef struct _SERVER_INFO_100 {
    DWORD           sv100_platform_id;
    LPTSTR          sv100_name;
} SERVER_INFO_100, *PSERVER_INFO_100, *LPSERVER_INFO_100;

typedef struct _SERVER_INFO_101 {
    DWORD           sv101_platform_id;
    LPTSTR          sv101_name;
    DWORD           sv101_version_major;
    DWORD           sv101_version_minor;
    DWORD           sv101_type;
    LPTSTR          sv101_comment;
} SERVER_INFO_101, *PSERVER_INFO_101, *LPSERVER_INFO_101;

typedef struct _SERVER_INFO_102 {
     DWORD          sv102_platform_id;
     LPTSTR         sv102_name;
     DWORD          sv102_version_major;
     DWORD          sv102_version_minor;
     DWORD          sv102_type;
     LPTSTR         sv102_comment;
     DWORD          sv102_users;
     LONG           sv102_disc;
     BOOL           sv102_hidden;
     DWORD          sv102_announce;
     DWORD          sv102_anndelta;
     DWORD          sv102_licenses;
     LPTSTR         sv102_userpath;
} SERVER_INFO_102, *PSERVER_INFO_102, *LPSERVER_INFO_102;

typedef struct _SERVER_INFO_402 {
     DWORD          sv402_ulist_mtime;
     DWORD          sv402_glist_mtime;
     DWORD          sv402_alist_mtime;
     LPTSTR         sv402_alerts;
     DWORD          sv402_security;
     DWORD          sv402_numadmin;
     DWORD          sv402_lanmask;
     LPTSTR         sv402_guestacct;
     DWORD          sv402_chdevs;
     DWORD          sv402_chdevq;
     DWORD          sv402_chdevjobs;
     DWORD          sv402_connections;
     DWORD          sv402_shares;
     DWORD          sv402_openfiles;
     DWORD          sv402_sessopens;
     DWORD          sv402_sessvcs;
     DWORD          sv402_sessreqs;
     DWORD          sv402_opensearch;
     DWORD          sv402_activelocks;
     DWORD          sv402_numreqbuf;
     DWORD          sv402_sizreqbuf;
     DWORD          sv402_numbigbuf;
     DWORD          sv402_numfiletasks;
     DWORD          sv402_alertsched;
     DWORD          sv402_erroralert;
     DWORD          sv402_logonalert;
     DWORD          sv402_accessalert;
     DWORD          sv402_diskalert;
     DWORD          sv402_netioalert;
     DWORD          sv402_maxauditsz;
     LPTSTR         sv402_srvheuristics;
} SERVER_INFO_402, *PSERVER_INFO_402, *LPSERVER_INFO_402;

typedef struct _SERVER_INFO_403 {
     DWORD          sv403_ulist_mtime;
     DWORD          sv403_glist_mtime;
     DWORD          sv403_alist_mtime;
     LPTSTR         sv403_alerts;
     DWORD          sv403_security;
     DWORD          sv403_numadmin;
     DWORD          sv403_lanmask;
     LPTSTR         sv403_guestacct;
     DWORD          sv403_chdevs;
     DWORD          sv403_chdevq;
     DWORD          sv403_chdevjobs;
     DWORD          sv403_connections;
     DWORD          sv403_shares;
     DWORD          sv403_openfiles;
     DWORD          sv403_sessopens;
     DWORD          sv403_sessvcs;
     DWORD          sv403_sessreqs;
     DWORD          sv403_opensearch;
     DWORD          sv403_activelocks;
     DWORD          sv403_numreqbuf;
     DWORD          sv403_sizreqbuf;
     DWORD          sv403_numbigbuf;
     DWORD          sv403_numfiletasks;
     DWORD          sv403_alertsched;
     DWORD          sv403_erroralert;
     DWORD          sv403_logonalert;
     DWORD          sv403_accessalert;
     DWORD          sv403_diskalert;
     DWORD          sv403_netioalert;
     DWORD          sv403_maxauditsz;
     LPTSTR         sv403_srvheuristics;
     DWORD          sv403_auditedevents;
     DWORD          sv403_autoprofile;
     LPTSTR         sv403_autopath;
} SERVER_INFO_403, *PSERVER_INFO_403, *LPSERVER_INFO_403;

typedef struct _SERVER_INFO_502 {
    DWORD           sv502_sessopens;
    DWORD           sv502_sessvcs;
    DWORD           sv502_opensearch;
    DWORD           sv502_sizreqbuf;
    DWORD           sv502_initworkitems;
    DWORD           sv502_maxworkitems;
    DWORD           sv502_rawworkitems;
    DWORD           sv502_irpstacksize;
    DWORD           sv502_maxrawbuflen;
    DWORD           sv502_sessusers;
    DWORD           sv502_sessconns;
    DWORD           sv502_maxpagedmemoryusage;
    DWORD           sv502_maxnonpagedmemoryusage;
    BOOL            sv502_enablesoftcompat;
    BOOL            sv502_enableforcedlogoff;
    BOOL            sv502_timesource;
    BOOL            sv502_acceptdownlevelapis;
    BOOL            sv502_lmannounce;
} SERVER_INFO_502, *PSERVER_INFO_502, *LPSERVER_INFO_502;

typedef struct _SERVER_INFO_503 {
    DWORD           sv503_sessopens;
    DWORD           sv503_sessvcs;
    DWORD           sv503_opensearch;
    DWORD           sv503_sizreqbuf;
    DWORD           sv503_initworkitems;
    DWORD           sv503_maxworkitems;
    DWORD           sv503_rawworkitems;
    DWORD           sv503_irpstacksize;
    DWORD           sv503_maxrawbuflen;
    DWORD           sv503_sessusers;
    DWORD           sv503_sessconns;
    DWORD           sv503_maxpagedmemoryusage;
    DWORD           sv503_maxnonpagedmemoryusage;
    BOOL            sv503_enablesoftcompat;
    BOOL            sv503_enableforcedlogoff;
    BOOL            sv503_timesource;
    BOOL            sv503_acceptdownlevelapis;
    BOOL            sv503_lmannounce;
    LPTSTR          sv503_domain;
    DWORD           sv503_maxcopyreadlen;
    DWORD           sv503_maxcopywritelen;
    DWORD           sv503_minkeepsearch;
    DWORD           sv503_maxkeepsearch;
    DWORD           sv503_minkeepcomplsearch;
    DWORD           sv503_maxkeepcomplsearch;
    DWORD           sv503_threadcountadd;
    DWORD           sv503_numblockthreads;
    DWORD           sv503_scavtimeout;
    DWORD           sv503_minrcvqueue;
    DWORD           sv503_minfreeworkitems;
    DWORD           sv503_xactmemsize;
    DWORD           sv503_threadpriority;
    DWORD           sv503_maxmpxct;
    DWORD           sv503_oplockbreakwait;
    DWORD           sv503_oplockbreakresponsewait;
    BOOL            sv503_enableoplocks;
    BOOL            sv503_enableoplockforceclose;
    BOOL            sv503_enablefcbopens;
    BOOL            sv503_enableraw;
    BOOL            sv503_enablesharednetdrives;
    DWORD           sv503_minfreeconnections;
    DWORD           sv503_maxfreeconnections;
} SERVER_INFO_503, *PSERVER_INFO_503, *LPSERVER_INFO_503;

typedef struct _SERVER_INFO_599 {
    DWORD           sv599_sessopens;
    DWORD           sv599_sessvcs;
    DWORD           sv599_opensearch;
    DWORD           sv599_sizreqbuf;
    DWORD           sv599_initworkitems;
    DWORD           sv599_maxworkitems;
    DWORD           sv599_rawworkitems;
    DWORD           sv599_irpstacksize;
    DWORD           sv599_maxrawbuflen;
    DWORD           sv599_sessusers;
    DWORD           sv599_sessconns;
    DWORD           sv599_maxpagedmemoryusage;
    DWORD           sv599_maxnonpagedmemoryusage;
    BOOL            sv599_enablesoftcompat;
    BOOL            sv599_enableforcedlogoff;
    BOOL            sv599_timesource;
    BOOL            sv599_acceptdownlevelapis;
    BOOL            sv599_lmannounce;
    LPTSTR          sv599_domain;
    DWORD           sv599_maxcopyreadlen;
    DWORD           sv599_maxcopywritelen;
    DWORD           sv599_minkeepsearch;
    DWORD           sv599_maxkeepsearch;
    DWORD           sv599_minkeepcomplsearch;
    DWORD           sv599_maxkeepcomplsearch;
    DWORD           sv599_threadcountadd;
    DWORD           sv599_numblockthreads;
    DWORD           sv599_scavtimeout;
    DWORD           sv599_minrcvqueue;
    DWORD           sv599_minfreeworkitems;
    DWORD           sv599_xactmemsize;
    DWORD           sv599_threadpriority;
    DWORD           sv599_maxmpxct;
    DWORD           sv599_oplockbreakwait;
    DWORD           sv599_oplockbreakresponsewait;
    BOOL            sv599_enableoplocks;
    BOOL            sv599_enableoplockforceclose;
    BOOL            sv599_enablefcbopens;
    BOOL            sv599_enableraw;
    BOOL            sv599_enablesharednetdrives;
    DWORD           sv599_minfreeconnections;
    DWORD           sv599_maxfreeconnections;
    DWORD           sv599_initsesstable;
    DWORD           sv599_initconntable;
    DWORD           sv599_initfiletable;
    DWORD           sv599_initsearchtable;
    DWORD           sv599_alertschedule;
    DWORD           sv599_errorthreshold;
    DWORD           sv599_networkerrorthreshold;
    DWORD           sv599_diskspacethreshold;
    DWORD           sv599_reserved;
    DWORD           sv599_maxlinkdelay;
    DWORD           sv599_minlinkthroughput;
    DWORD           sv599_linkinfovalidtime;
    DWORD           sv599_scavqosinfoupdatetime;
    DWORD           sv599_maxworkitemidletime;
} SERVER_INFO_599, *PSERVER_INFO_599, *LPSERVER_INFO_599;

typedef struct _SERVER_INFO_598 {
    DWORD           sv598_maxrawworkitems;
    DWORD           sv598_maxthreadsperqueue;
    DWORD           sv598_producttype;
    DWORD           sv598_serversize;
    DWORD           sv598_connectionlessautodisc;
    DWORD           sv598_sharingviolationretries;
    DWORD           sv598_sharingviolationdelay;
    DWORD           sv598_maxglobalopensearch;
    DWORD           sv598_removeduplicatesearches;
    DWORD           sv598_lockviolationoffset;
    DWORD           sv598_lockviolationdelay;
    DWORD           sv598_mdlreadswitchover;
    DWORD           sv598_cachedopenlimit;
    DWORD           sv598_otherqueueaffinity;
    BOOL            sv598_restrictnullsessaccess;
    BOOL            sv598_enablewfw311directipx;
    DWORD           sv598_queuesamplesecs;
    DWORD           sv598_balancecount;
    DWORD           sv598_preferredaffinity;
    DWORD           sv598_maxfreerfcbs;
    DWORD           sv598_maxfreemfcbs;
    DWORD           sv598_maxfreelfcbs;
    DWORD           sv598_maxfreepagedpoolchunks;
    DWORD           sv598_minpagedpoolchunksize;
    DWORD           sv598_maxpagedpoolchunksize;
    BOOL            sv598_sendsfrompreferredprocessor;
} SERVER_INFO_598, *PSERVER_INFO_598, *LPSERVER_INFO_598;

typedef struct _SERVER_INFO_1005 {
    LPTSTR          sv1005_comment;
} SERVER_INFO_1005, *PSERVER_INFO_1005, *LPSERVER_INFO_1005;

typedef struct _SERVER_INFO_1107 {
    DWORD           sv1107_users;
} SERVER_INFO_1107, *PSERVER_INFO_1107, *LPSERVER_INFO_1107;

typedef struct _SERVER_INFO_1010 {
    LONG            sv1010_disc;
} SERVER_INFO_1010, *PSERVER_INFO_1010, *LPSERVER_INFO_1010;

typedef struct _SERVER_INFO_1016 {
    BOOL            sv1016_hidden;
} SERVER_INFO_1016, *PSERVER_INFO_1016, *LPSERVER_INFO_1016;

typedef struct _SERVER_INFO_1017 {
    DWORD           sv1017_announce;
} SERVER_INFO_1017, *PSERVER_INFO_1017, *LPSERVER_INFO_1017;

typedef struct _SERVER_INFO_1018 {
    DWORD           sv1018_anndelta;
} SERVER_INFO_1018, *PSERVER_INFO_1018, *LPSERVER_INFO_1018;

typedef struct _SERVER_INFO_1501 {
    DWORD           sv1501_sessopens;
} SERVER_INFO_1501, *PSERVER_INFO_1501, *LPSERVER_INFO_1501;

typedef struct _SERVER_INFO_1502 {
    DWORD           sv1502_sessvcs;
} SERVER_INFO_1502, *PSERVER_INFO_1502, *LPSERVER_INFO_1502;

typedef struct _SERVER_INFO_1503 {
    DWORD           sv1503_opensearch;
} SERVER_INFO_1503, *PSERVER_INFO_1503, *LPSERVER_INFO_1503;

typedef struct _SERVER_INFO_1506 {
    DWORD           sv1506_maxworkitems;
} SERVER_INFO_1506, *PSERVER_INFO_1506, *LPSERVER_INFO_1506;

typedef struct _SERVER_INFO_1509 {
    DWORD           sv1509_maxrawbuflen;
} SERVER_INFO_1509, *PSERVER_INFO_1509, *LPSERVER_INFO_1509;

typedef struct _SERVER_INFO_1510 {
    DWORD           sv1510_sessusers;
} SERVER_INFO_1510, *PSERVER_INFO_1510, *LPSERVER_INFO_1510;

typedef struct _SERVER_INFO_1511 {
    DWORD           sv1511_sessconns;
} SERVER_INFO_1511, *PSERVER_INFO_1511, *LPSERVER_INFO_1511;

typedef struct _SERVER_INFO_1512 {
    DWORD           sv1512_maxnonpagedmemoryusage;
} SERVER_INFO_1512, *PSERVER_INFO_1512, *LPSERVER_INFO_1512;

typedef struct _SERVER_INFO_1513 {
    DWORD           sv1513_maxpagedmemoryusage;
} SERVER_INFO_1513, *PSERVER_INFO_1513, *LPSERVER_INFO_1513;

typedef struct _SERVER_INFO_1514 {
    BOOL            sv1514_enablesoftcompat;
} SERVER_INFO_1514, *PSERVER_INFO_1514, *LPSERVER_INFO_1514;

typedef struct _SERVER_INFO_1515 {
    BOOL            sv1515_enableforcedlogoff;
} SERVER_INFO_1515, *PSERVER_INFO_1515, *LPSERVER_INFO_1515;

typedef struct _SERVER_INFO_1516 {
    BOOL            sv1516_timesource;
} SERVER_INFO_1516, *PSERVER_INFO_1516, *LPSERVER_INFO_1516;

typedef struct _SERVER_INFO_1518 {
    BOOL            sv1518_lmannounce;
} SERVER_INFO_1518, *PSERVER_INFO_1518, *LPSERVER_INFO_1518;

typedef struct _SERVER_INFO_1520 {
    DWORD           sv1520_maxcopyreadlen;
} SERVER_INFO_1520, *PSERVER_INFO_1520, *LPSERVER_INFO_1520;

typedef struct _SERVER_INFO_1521 {
    DWORD           sv1521_maxcopywritelen;
} SERVER_INFO_1521, *PSERVER_INFO_1521, *LPSERVER_INFO_1521;

typedef struct _SERVER_INFO_1522 {
    DWORD           sv1522_minkeepsearch;
} SERVER_INFO_1522, *PSERVER_INFO_1522, *LPSERVER_INFO_1522;

typedef struct _SERVER_INFO_1523 {
    DWORD           sv1523_maxkeepsearch;
} SERVER_INFO_1523, *PSERVER_INFO_1523, *LPSERVER_INFO_1523;

typedef struct _SERVER_INFO_1524 {
    DWORD           sv1524_minkeepcomplsearch;
} SERVER_INFO_1524, *PSERVER_INFO_1524, *LPSERVER_INFO_1524;

typedef struct _SERVER_INFO_1525 {
    DWORD           sv1525_maxkeepcomplsearch;
} SERVER_INFO_1525, *PSERVER_INFO_1525, *LPSERVER_INFO_1525;

typedef struct _SERVER_INFO_1528 {
    DWORD           sv1528_scavtimeout;
} SERVER_INFO_1528, *PSERVER_INFO_1528, *LPSERVER_INFO_1528;

typedef struct _SERVER_INFO_1529 {
    DWORD           sv1529_minrcvqueue;
} SERVER_INFO_1529, *PSERVER_INFO_1529, *LPSERVER_INFO_1529;

typedef struct _SERVER_INFO_1530 {
    DWORD           sv1530_minfreeworkitems;
} SERVER_INFO_1530, *PSERVER_INFO_1530, *LPSERVER_INFO_1530;

typedef struct _SERVER_INFO_1533 {
    DWORD           sv1533_maxmpxct;
} SERVER_INFO_1533, *PSERVER_INFO_1533, *LPSERVER_INFO_1533;

typedef struct _SERVER_INFO_1534 {
    DWORD           sv1534_oplockbreakwait;
} SERVER_INFO_1534, *PSERVER_INFO_1534, *LPSERVER_INFO_1534;

typedef struct _SERVER_INFO_1535 {
    DWORD           sv1535_oplockbreakresponsewait;
} SERVER_INFO_1535, *PSERVER_INFO_1535, *LPSERVER_INFO_1535;

typedef struct _SERVER_INFO_1536 {
    BOOL            sv1536_enableoplocks;
} SERVER_INFO_1536, *PSERVER_INFO_1536, *LPSERVER_INFO_1536;

typedef struct _SERVER_INFO_1537 {
    BOOL            sv1537_enableoplockforceclose;
} SERVER_INFO_1537, *PSERVER_INFO_1537, *LPSERVER_INFO_1537;

typedef struct _SERVER_INFO_1538 {
    BOOL            sv1538_enablefcbopens;
} SERVER_INFO_1538, *PSERVER_INFO_1538, *LPSERVER_INFO_1538;

typedef struct _SERVER_INFO_1539 {
    BOOL            sv1539_enableraw;
} SERVER_INFO_1539, *PSERVER_INFO_1539, *LPSERVER_INFO_1539;

typedef struct _SERVER_INFO_1540 {
    BOOL            sv1540_enablesharednetdrives;
} SERVER_INFO_1540, *PSERVER_INFO_1540, *LPSERVER_INFO_1540;

typedef struct _SERVER_INFO_1541 {
    BOOL            sv1541_minfreeconnections;
} SERVER_INFO_1541, *PSERVER_INFO_1541, *LPSERVER_INFO_1541;

typedef struct _SERVER_INFO_1542 {
    BOOL            sv1542_maxfreeconnections;
} SERVER_INFO_1542, *PSERVER_INFO_1542, *LPSERVER_INFO_1542;

typedef struct _SERVER_INFO_1543 {
    DWORD           sv1543_initsesstable;
} SERVER_INFO_1543, *PSERVER_INFO_1543, *LPSERVER_INFO_1543;

typedef struct _SERVER_INFO_1544 {
    DWORD           sv1544_initconntable;
} SERVER_INFO_1544, *PSERVER_INFO_1544, *LPSERVER_INFO_1544;

typedef struct _SERVER_INFO_1545 {
    DWORD           sv1545_initfiletable;
} SERVER_INFO_1545, *PSERVER_INFO_1545, *LPSERVER_INFO_1545;

typedef struct _SERVER_INFO_1546 {
    DWORD           sv1546_initsearchtable;
} SERVER_INFO_1546, *PSERVER_INFO_1546, *LPSERVER_INFO_1546;

typedef struct _SERVER_INFO_1547 {
    DWORD           sv1547_alertschedule;
} SERVER_INFO_1547, *PSERVER_INFO_1547, *LPSERVER_INFO_1547;

typedef struct _SERVER_INFO_1548 {
    DWORD           sv1548_errorthreshold;
} SERVER_INFO_1548, *PSERVER_INFO_1548, *LPSERVER_INFO_1548;

typedef struct _SERVER_INFO_1549 {
    DWORD           sv1549_networkerrorthreshold;
} SERVER_INFO_1549, *PSERVER_INFO_1549, *LPSERVER_INFO_1549;

typedef struct _SERVER_INFO_1550 {
    DWORD           sv1550_diskspacethreshold;
} SERVER_INFO_1550, *PSERVER_INFO_1550, *LPSERVER_INFO_1550;

typedef struct _SERVER_INFO_1552 {
    DWORD           sv1552_maxlinkdelay;
} SERVER_INFO_1552, *PSERVER_INFO_1552, *LPSERVER_INFO_1552;

typedef struct _SERVER_INFO_1553 {
    DWORD           sv1553_minlinkthroughput;
} SERVER_INFO_1553, *PSERVER_INFO_1553, *LPSERVER_INFO_1553;

typedef struct _SERVER_INFO_1554 {
    DWORD           sv1554_linkinfovalidtime;
} SERVER_INFO_1554, *PSERVER_INFO_1554, *LPSERVER_INFO_1554;

typedef struct _SERVER_INFO_1555 {
    DWORD           sv1555_scavqosinfoupdatetime;
} SERVER_INFO_1555, *PSERVER_INFO_1555, *LPSERVER_INFO_1555;

typedef struct _SERVER_INFO_1556 {
    DWORD           sv1556_maxworkitemidletime;
} SERVER_INFO_1556, *PSERVER_INFO_1556, *LPSERVER_INFO_1556;

typedef struct _SERVER_INFO_1557 {
    DWORD           sv1557_maxrawworkitems;
} SERVER_INFO_1557, *PSERVER_INFO_1557, *LPSERVER_INFO_1557;

typedef struct _SERVER_INFO_1560 {
    DWORD           sv1560_producttype;
} SERVER_INFO_1560, *PSERVER_INFO_1560, *LPSERVER_INFO_1560;

typedef struct _SERVER_INFO_1561 {
    DWORD           sv1561_serversize;
} SERVER_INFO_1561, *PSERVER_INFO_1561, *LPSERVER_INFO_1561;

typedef struct _SERVER_INFO_1562 {
    DWORD           sv1562_connectionlessautodisc;
} SERVER_INFO_1562, *PSERVER_INFO_1562, *LPSERVER_INFO_1562;

typedef struct _SERVER_INFO_1563 {
    DWORD           sv1563_sharingviolationretries;
} SERVER_INFO_1563, *PSERVER_INFO_1563, *LPSERVER_INFO_1563;

typedef struct _SERVER_INFO_1564 {
    DWORD           sv1564_sharingviolationdelay;
} SERVER_INFO_1564, *PSERVER_INFO_1564, *LPSERVER_INFO_1564;

typedef struct _SERVER_INFO_1565 {
    DWORD           sv1565_maxglobalopensearch;
} SERVER_INFO_1565, *PSERVER_INFO_1565, *LPSERVER_INFO_1565;

typedef struct _SERVER_INFO_1566 {
    BOOL           sv1566_removeduplicatesearches;
} SERVER_INFO_1566, *PSERVER_INFO_1566, *LPSERVER_INFO_1566;

typedef struct _SERVER_INFO_1567 {
    DWORD           sv1567_lockviolationretries;
} SERVER_INFO_1567, *PSERVER_INFO_1567, *LPSERVER_INFO_1567;

typedef struct _SERVER_INFO_1568 {
    DWORD           sv1568_lockviolationoffset;
} SERVER_INFO_1568, *PSERVER_INFO_1568, *LPSERVER_INFO_1568;

typedef struct _SERVER_INFO_1569 {
    DWORD           sv1569_lockviolationdelay;
} SERVER_INFO_1569, *PSERVER_INFO_1569, *LPSERVER_INFO_1569;

typedef struct _SERVER_INFO_1570 {
    DWORD           sv1570_mdlreadswitchover;
} SERVER_INFO_1570, *PSERVER_INFO_1570, *LPSERVER_INFO_1570;

typedef struct _SERVER_INFO_1571 {
    DWORD           sv1571_cachedopenlimit;
} SERVER_INFO_1571, *PSERVER_INFO_1571, *LPSERVER_INFO_1571;

typedef struct _SERVER_INFO_1572 {
    DWORD           sv1572_criticalthreads;
} SERVER_INFO_1572, *PSERVER_INFO_1572, *LPSERVER_INFO_1572;

typedef struct _SERVER_INFO_1573 {
    DWORD           sv1573_restrictnullsessaccess;
} SERVER_INFO_1573, *PSERVER_INFO_1573, *LPSERVER_INFO_1573;

typedef struct _SERVER_INFO_1574 {
    DWORD           sv1574_enablewfw311directipx;
} SERVER_INFO_1574, *PSERVER_INFO_1574, *LPSERVER_INFO_1574;

typedef struct _SERVER_INFO_1575 {
    DWORD           sv1575_otherqueueaffinity;
} SERVER_INFO_1575, *PSERVER_INFO_1575, *LPSERVER_INFO_1575;

typedef struct _SERVER_INFO_1576 {
    DWORD           sv1576_queuesamplesecs;
} SERVER_INFO_1576, *PSERVER_INFO_1576, *LPSERVER_INFO_1576;

typedef struct _SERVER_INFO_1577 {
    DWORD           sv1577_balancecount;
} SERVER_INFO_1577, *PSERVER_INFO_1577, *LPSERVER_INFO_1577;

typedef struct _SERVER_INFO_1578 {
    DWORD           sv1578_preferredaffinity;
} SERVER_INFO_1578, *PSERVER_INFO_1578, *LPSERVER_INFO_1578;

typedef struct _SERVER_INFO_1579 {
    DWORD           sv1579_maxfreerfcbs;
} SERVER_INFO_1579, *PSERVER_INFO_1579, *LPSERVER_INFO_1579;

typedef struct _SERVER_INFO_1580 {
    DWORD           sv1580_maxfreemfcbs;
} SERVER_INFO_1580, *PSERVER_INFO_1580, *LPSERVER_INFO_1580;

typedef struct _SERVER_INFO_1581 {
    DWORD           sv1581_maxfreemlcbs;
} SERVER_INFO_1581, *PSERVER_INFO_1581, *LPSERVER_INFO_1581;

typedef struct _SERVER_INFO_1582 {
    DWORD           sv1582_maxfreepagedpoolchunks;
} SERVER_INFO_1582, *PSERVER_INFO_1582, *LPSERVER_INFO_1582;

typedef struct _SERVER_INFO_1583 {
    DWORD           sv1583_minpagedpoolchunksize;
} SERVER_INFO_1583, *PSERVER_INFO_1583, *LPSERVER_INFO_1583;

typedef struct _SERVER_INFO_1584 {
    DWORD           sv1584_maxpagedpoolchunksize;
} SERVER_INFO_1584, *PSERVER_INFO_1584, *LPSERVER_INFO_1584;

typedef struct _SERVER_INFO_1585 {
    BOOL           sv1585_sendsfrompreferredprocessor;
} SERVER_INFO_1585, *PSERVER_INFO_1585, *LPSERVER_INFO_1585;

typedef struct _SERVER_INFO_1586 {
    BOOL           sv1586_maxthreadsperqueue;
} SERVER_INFO_1586, *PSERVER_INFO_1586, *LPSERVER_INFO_1586;

//
// A special structure definition is required in order for this
// structure to work with RPC.  The problem is that having addresslength
// indicate the number of bytes in address means that RPC must know the
// link between the two.
//

#ifdef MIDL_PASS

typedef struct _SERVER_TRANSPORT_INFO_0 {
    DWORD           svti0_numberofvcs;
    LPTSTR          svti0_transportname;
    [size_is(svti0_transportaddresslength)]  LPBYTE svti0_transportaddress;
    DWORD           svti0_transportaddresslength;
    LPTSTR          svti0_networkaddress;
} SERVER_TRANSPORT_INFO_0, *PSERVER_TRANSPORT_INFO_0, *LPSERVER_TRANSPORT_INFO_0;

#else

typedef struct _SERVER_TRANSPORT_INFO_0 {
    DWORD           svti0_numberofvcs;
    LPTSTR          svti0_transportname;
    LPBYTE          svti0_transportaddress;
    DWORD           svti0_transportaddresslength;
    LPTSTR          svti0_networkaddress;
} SERVER_TRANSPORT_INFO_0, *PSERVER_TRANSPORT_INFO_0, *LPSERVER_TRANSPORT_INFO_0;

#endif

//
// Defines - SERVER
//

//
// The platform ID indicates the levels to use for platform-specific
// information.
//

#define SV_PLATFORM_ID_OS2 400
#define SV_PLATFORM_ID_NT  500

//
//      Mask to be applied to svX_version_major in order to obtain
//      the major version number.
//

#define MAJOR_VERSION_MASK  0x0F

//
//      Bit-mapped values for svX_type fields. X = 1, 2 or 3.
//

#define SV_TYPE_WORKSTATION         0x00000001
#define SV_TYPE_SERVER              0x00000002
#define SV_TYPE_SQLSERVER           0x00000004
#define SV_TYPE_DOMAIN_CTRL         0x00000008
#define SV_TYPE_DOMAIN_BAKCTRL      0x00000010
#define SV_TYPE_TIME_SOURCE         0x00000020
#define SV_TYPE_AFP                 0x00000040
#define SV_TYPE_NOVELL              0x00000080
#define SV_TYPE_DOMAIN_MEMBER       0x00000100
#define SV_TYPE_PRINTQ_SERVER       0x00000200
#define SV_TYPE_DIALIN_SERVER       0x00000400
#define SV_TYPE_XENIX_SERVER        0x00000800
#define SV_TYPE_SERVER_UNIX         SV_TYPE_XENIX_SERVER
#define SV_TYPE_NT                  0x00001000
#define SV_TYPE_WFW                 0x00002000
#define SV_TYPE_SERVER_MFPN         0x00004000
#define SV_TYPE_SERVER_NT           0x00008000
#define SV_TYPE_POTENTIAL_BROWSER   0x00010000
#define SV_TYPE_BACKUP_BROWSER      0x00020000
#define SV_TYPE_MASTER_BROWSER      0x00040000
#define SV_TYPE_DOMAIN_MASTER       0x00080000
#define SV_TYPE_SERVER_OSF          0x00100000
#define SV_TYPE_SERVER_VMS          0x00200000
#define SV_TYPE_WINDOWS             0x00400000  /* Windows95 and above */
#define SV_TYPE_ALTERNATE_XPORT     0x20000000  /* return list for alternate transport */
#define SV_TYPE_LOCAL_LIST_ONLY     0x40000000  /* Return local list only */
#define SV_TYPE_DOMAIN_ENUM         0x80000000
#define SV_TYPE_ALL                 0xFFFFFFFF  /* handy for NetServerEnum2 */

//
//      Special value for sv102_disc that specifies infinite disconnect
//      time.
//

#define SV_NODISC           (-1L)  /* No autodisconnect timeout enforced */

//
//      Values of svX_security field. X = 2 or 3.
//

#define SV_USERSECURITY     1
#define SV_SHARESECURITY    0

//
//      Values of svX_hidden field. X = 2 or 3.
//

#define SV_HIDDEN       1
#define SV_VISIBLE      0

//
//      Values for ParmError parameter to NetServerSetInfo.
//

#define SV_PLATFORM_ID_PARMNUM          101
#define SV_NAME_PARMNUM                 102
#define SV_VERSION_MAJOR_PARMNUM        103
#define SV_VERSION_MINOR_PARMNUM        104
#define SV_TYPE_PARMNUM                 105
#define SV_COMMENT_PARMNUM              5
#define SV_USERS_PARMNUM                107
#define SV_DISC_PARMNUM                 10
#define SV_HIDDEN_PARMNUM               16
#define SV_ANNOUNCE_PARMNUM             17
#define SV_ANNDELTA_PARMNUM             18
#define SV_USERPATH_PARMNUM             112

#define SV_ULIST_MTIME_PARMNUM          401
#define SV_GLIST_MTIME_PARMNUM          402
#define SV_ALIST_MTIME_PARMNUM          403
#define SV_ALERTS_PARMNUM               11
#define SV_SECURITY_PARMNUM             405
#define SV_NUMADMIN_PARMNUM             406
#define SV_LANMASK_PARMNUM              407
#define SV_GUESTACC_PARMNUM             408
#define SV_CHDEVQ_PARMNUM               410
#define SV_CHDEVJOBS_PARMNUM            411
#define SV_CONNECTIONS_PARMNUM          412
#define SV_SHARES_PARMNUM               413
#define SV_OPENFILES_PARMNUM            414
#define SV_SESSREQS_PARMNUM             417
#define SV_ACTIVELOCKS_PARMNUM          419
#define SV_NUMREQBUF_PARMNUM            420
#define SV_NUMBIGBUF_PARMNUM            422
#define SV_NUMFILETASKS_PARMNUM         423
#define SV_ALERTSCHED_PARMNUM           37
#define SV_ERRORALERT_PARMNUM           38
#define SV_LOGONALERT_PARMNUM           39
#define SV_ACCESSALERT_PARMNUM          40
#define SV_DISKALERT_PARMNUM            41
#define SV_NETIOALERT_PARMNUM           42
#define SV_MAXAUDITSZ_PARMNUM           43
#define SV_SRVHEURISTICS_PARMNUM        431

#define SV_SESSOPENS_PARMNUM                501
#define SV_SESSVCS_PARMNUM                  502
#define SV_OPENSEARCH_PARMNUM               503
#define SV_SIZREQBUF_PARMNUM                504
#define SV_INITWORKITEMS_PARMNUM            505
#define SV_MAXWORKITEMS_PARMNUM             506
#define SV_RAWWORKITEMS_PARMNUM             507
#define SV_IRPSTACKSIZE_PARMNUM             508
#define SV_MAXRAWBUFLEN_PARMNUM             509
#define SV_SESSUSERS_PARMNUM                510
#define SV_SESSCONNS_PARMNUM                511
#define SV_MAXNONPAGEDMEMORYUSAGE_PARMNUM   512
#define SV_MAXPAGEDMEMORYUSAGE_PARMNUM      513
#define SV_ENABLESOFTCOMPAT_PARMNUM         514
#define SV_ENABLEFORCEDLOGOFF_PARMNUM       515
#define SV_TIMESOURCE_PARMNUM               516
#define SV_ACCEPTDOWNLEVELAPIS_PARMNUM      517
#define SV_LMANNOUNCE_PARMNUM               518
#define SV_DOMAIN_PARMNUM                   519
#define SV_MAXCOPYREADLEN_PARMNUM           520
#define SV_MAXCOPYWRITELEN_PARMNUM          521
#define SV_MINKEEPSEARCH_PARMNUM            522
#define SV_MAXKEEPSEARCH_PARMNUM            523
#define SV_MINKEEPCOMPLSEARCH_PARMNUM       524
#define SV_MAXKEEPCOMPLSEARCH_PARMNUM       525
#define SV_THREADCOUNTADD_PARMNUM           526
#define SV_NUMBLOCKTHREADS_PARMNUM          527
#define SV_SCAVTIMEOUT_PARMNUM              528
#define SV_MINRCVQUEUE_PARMNUM              529
#define SV_MINFREEWORKITEMS_PARMNUM         530
#define SV_XACTMEMSIZE_PARMNUM              531
#define SV_THREADPRIORITY_PARMNUM           532
#define SV_MAXMPXCT_PARMNUM                 533
#define SV_OPLOCKBREAKWAIT_PARMNUM          534
#define SV_OPLOCKBREAKRESPONSEWAIT_PARMNUM  535
#define SV_ENABLEOPLOCKS_PARMNUM            536
#define SV_ENABLEOPLOCKFORCECLOSE_PARMNUM   537
#define SV_ENABLEFCBOPENS_PARMNUM           538
#define SV_ENABLERAW_PARMNUM                539
#define SV_ENABLESHAREDNETDRIVES_PARMNUM    540
#define SV_MINFREECONNECTIONS_PARMNUM       541
#define SV_MAXFREECONNECTIONS_PARMNUM       542
#define SV_INITSESSTABLE_PARMNUM            543
#define SV_INITCONNTABLE_PARMNUM            544
#define SV_INITFILETABLE_PARMNUM            545
#define SV_INITSEARCHTABLE_PARMNUM          546
#define SV_ALERTSCHEDULE_PARMNUM            547
#define SV_ERRORTHRESHOLD_PARMNUM           548
#define SV_NETWORKERRORTHRESHOLD_PARMNUM    549
#define SV_DISKSPACETHRESHOLD_PARMNUM       550
#define SV_MAXLINKDELAY_PARMNUM             552
#define SV_MINLINKTHROUGHPUT_PARMNUM        553
#define SV_LINKINFOVALIDTIME_PARMNUM        554
#define SV_SCAVQOSINFOUPDATETIME_PARMNUM    555
#define SV_MAXWORKITEMIDLETIME_PARMNUM      556
#define SV_MAXRAWWORKITEMS_PARMNUM          557
#define SV_PRODUCTTYPE_PARMNUM              560
#define SV_SERVERSIZE_PARMNUM               561
#define SV_CONNECTIONLESSAUTODISC_PARMNUM   562
#define SV_SHARINGVIOLATIONRETRIES_PARMNUM  563
#define SV_SHARINGVIOLATIONDELAY_PARMNUM    564
#define SV_MAXGLOBALOPENSEARCH_PARMNUM      565
#define SV_REMOVEDUPLICATESEARCHES_PARMNUM  566
#define SV_LOCKVIOLATIONRETRIES_PARMNUM     567
#define SV_LOCKVIOLATIONOFFSET_PARMNUM      568
#define SV_LOCKVIOLATIONDELAY_PARMNUM       569
#define SV_MDLREADSWITCHOVER_PARMNUM        570
#define SV_CACHEDOPENLIMIT_PARMNUM          571
#define SV_CRITICALTHREADS_PARMNUM          572
#define SV_RESTRICTNULLSESSACCESS_PARMNUM   573
#define SV_ENABLEWFW311DIRECTIPX_PARMNUM    574
#define SV_OTHERQUEUEAFFINITY_PARMNUM       575
#define SV_QUEUESAMPLESECS_PARMNUM          576
#define SV_BALANCECOUNT_PARMNUM             577
#define SV_PREFERREDAFFINITY_PARMNUM        578
#define SV_MAXFREERFCBS_PARMNUM             579
#define SV_MAXFREEMFCBS_PARMNUM             580
#define SV_MAXFREELFCBS_PARMNUM             581
#define SV_MAXFREEPAGEDPOOLCHUNKS_PARMNUM   582
#define SV_MINPAGEDPOOLCHUNKSIZE_PARMNUM    583
#define SV_MAXPAGEDPOOLCHUNKSIZE_PARMNUM    584
#define SV_SENDSFROMPREFERREDPROCESSOR_PARMNUM    585
#define SV_MAXTHREADSPERQUEUE_PARMNUM       586

//
// Single-field infolevels for NetServerSetInfo.
//

#define SV_COMMENT_INFOLEVEL                    \
            (PARMNUM_BASE_INFOLEVEL + SV_COMMENT_PARMNUM)
#define SV_USERS_INFOLEVEL                      \
            (PARMNUM_BASE_INFOLEVEL + SV_USERS_PARMNUM)
#define SV_DISC_INFOLEVEL                       \
            (PARMNUM_BASE_INFOLEVEL + SV_DISC_PARMNUM)
#define SV_HIDDEN_INFOLEVEL                     \
            (PARMNUM_BASE_INFOLEVEL + SV_HIDDEN_PARMNUM)
#define SV_ANNOUNCE_INFOLEVEL                   \
            (PARMNUM_BASE_INFOLEVEL + SV_ANNOUNCE_PARMNUM)
#define SV_ANNDELTA_INFOLEVEL                   \
            (PARMNUM_BASE_INFOLEVEL + SV_ANNDELTA_PARMNUM)
#define SV_SESSOPENS_INFOLEVEL                  \
            (PARMNUM_BASE_INFOLEVEL + SV_SESSOPENS_PARMNUM)
#define SV_SESSVCS_INFOLEVEL                    \
            (PARMNUM_BASE_INFOLEVEL + SV_SESSVCS_PARMNUM)
#define SV_OPENSEARCH_INFOLEVEL                 \
            (PARMNUM_BASE_INFOLEVEL + SV_OPENSEARCH_PARMNUM)
#define SV_MAXWORKITEMS_INFOLEVEL               \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXWORKITEMS_PARMNUM)
#define SV_MAXRAWBUFLEN_INFOLEVEL               \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXRAWBUFLEN_PARMNUM)
#define SV_SESSUSERS_INFOLEVEL                  \
            (PARMNUM_BASE_INFOLEVEL + SV_SESSUSERS_PARMNUM)
#define SV_SESSCONNS_INFOLEVEL                  \
            (PARMNUM_BASE_INFOLEVEL + SV_SESSCONNS_PARMNUM)
#define SV_MAXNONPAGEDMEMORYUSAGE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXNONPAGEDMEMORYUSAGE_PARMNUM)
#define SV_MAXPAGEDMEMORYUSAGE_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXPAGEDMEMORYUSAGE_PARMNUM)
#define SV_ENABLESOFTCOMPAT_INFOLEVEL           \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLESOFTCOMPAT_PARMNUM)
#define SV_ENABLEFORCEDLOGOFF_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLEFORCEDLOGOFF_PARMNUM)
#define SV_TIMESOURCE_INFOLEVEL                 \
            (PARMNUM_BASE_INFOLEVEL + SV_TIMESOURCE_PARMNUM)
#define SV_LMANNOUNCE_INFOLEVEL                 \
            (PARMNUM_BASE_INFOLEVEL + SV_LMANNOUNCE_PARMNUM)
#define SV_MAXCOPYREADLEN_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXCOPYREADLEN_PARMNUM)
#define SV_MAXCOPYWRITELEN_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXCOPYWRITELEN_PARMNUM)
#define SV_MINKEEPSEARCH_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_MINKEEPSEARCH_PARMNUM)
#define SV_MAXKEEPSEARCH_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXKEEPSEARCH_PARMNUM)
#define SV_MINKEEPCOMPLSEARCH_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SV_MINKEEPCOMPLSEARCH_PARMNUM)
#define SV_MAXKEEPCOMPLSEARCH_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXKEEPCOMPLSEARCH_PARMNUM)
#define SV_SCAVTIMEOUT_INFOLEVEL                \
            (PARMNUM_BASE_INFOLEVEL + SV_SCAVTIMEOUT_PARMNUM)
#define SV_MINRCVQUEUE_INFOLEVEL                \
            (PARMNUM_BASE_INFOLEVEL + SV_MINRCVQUEUE_PARMNUM)
#define SV_MINFREEWORKITEMS_INFOLEVEL           \
            (PARMNUM_BASE_INFOLEVEL + SV_MINFREEWORKITEMS_PARMNUM)
#define SV_MAXMPXCT_INFOLEVEL                   \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXMPXCT_PARMNUM)
#define SV_OPLOCKBREAKWAIT_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + SV_OPLOCKBREAKWAIT_PARMNUM)
#define SV_OPLOCKBREAKRESPONSEWAIT_INFOLEVEL    \
            (PARMNUM_BASE_INFOLEVEL + SV_OPLOCKBREAKRESPONSEWAIT_PARMNUM)
#define SV_ENABLEOPLOCKS_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLEOPLOCKS_PARMNUM)
#define SV_ENABLEOPLOCKFORCECLOSE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLEOPLOCKFORCECLOSE_PARMNUM)
#define SV_ENABLEFCBOPENS_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLEFCBOPENS_PARMNUM)
#define SV_ENABLERAW_INFOLEVEL                  \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLERAW_PARMNUM)
#define SV_ENABLESHAREDNETDRIVES_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLESHAREDNETDRIVES_PARMNUM)
#define SV_MINFREECONNECTIONS_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SV_MINFREECONNECTIONS_PARMNUM)
#define SV_MAXFREECONNECTIONS_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXFREECONNECTIONS_PARMNUM)
#define SV_INITSESSTABLE_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_INITSESSTABLE_PARMNUM)
#define SV_INITCONNTABLE_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_INITCONNTABLE_PARMNUM)
#define SV_INITFILETABLE_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_INITFILETABLE_PARMNUM)
#define SV_INITSEARCHTABLE_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + SV_INITSEARCHTABLE_PARMNUM)
#define SV_ALERTSCHEDULE_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_ALERTSCHEDULE_PARMNUM)
#define SV_ERRORTHRESHOLD_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + SV_ERRORTHRESHOLD_PARMNUM)
#define SV_NETWORKERRORTHRESHOLD_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + SV_NETWORKERRORTHRESHOLD_PARMNUM)
#define SV_DISKSPACETHRESHOLD_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SV_DISKSPACETHRESHOLD_PARMNUM)
#define SV_MAXLINKDELAY_INFOLEVEL               \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXLINKDELAY_PARMNUM)
#define SV_MINLINKTHROUGHPUT_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + SV_MINLINKTHROUGHPUT_PARMNUM)
#define SV_LINKINFOVALIDTIME_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + SV_LINKINFOVALIDTIME_PARMNUM)
#define SV_SCAVQOSINFOUPDATETIME_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + SV_SCAVQOSINFOUPDATETIME_PARMNUM)
#define SV_MAXWORKITEMIDLETIME_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXWORKITEMIDLETIME_PARMNUM)
#define SV_MAXRAWWORKITEMS_INFOLOEVEL           \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXRAWWORKITEMS_PARMNUM)
#define SV_PRODUCTTYPE_INFOLOEVEL                \
            (PARMNUM_BASE_INFOLEVEL + SV_PRODUCTTYPE_PARMNUM)
#define SV_SERVERSIZE_INFOLOEVEL                \
            (PARMNUM_BASE_INFOLEVEL + SV_SERVERSIZE_PARMNUM)
#define SV_CONNECTIONLESSAUTODISC_INFOLOEVEL    \
            (PARMNUM_BASE_INFOLEVEL + SV_CONNECTIONLESSAUTODISC_PARMNUM)
#define SV_SHARINGVIOLATIONRETRIES_INFOLOEVEL   \
            (PARMNUM_BASE_INFOLEVEL + SV_SHARINGVIOLATIONRETRIES_PARMNUM)
#define SV_SHARINGVIOLATIONDELAY_INFOLOEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_SHARINGVIOLATIONDELAY_PARMNUM)
#define SV_MAXGLOBALOPENSEARCH_INFOLOEVEL       \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXGLOBALOPENSEARCH_PARMNUM)
#define SV_REMOVEDUPLICATESEARCHES_INFOLOEVEL       \
            (PARMNUM_BASE_INFOLEVEL + SV_REMOVEDUPLICATESEARCHES_PARMNUM)
#define SV_LOCKVIOLATIONRETRIES_INFOLOEVEL   \
            (PARMNUM_BASE_INFOLEVEL + SV_LOCKVIOLATIONRETRIES_PARMNUM)
#define SV_LOCKVIOLATIONOFFSET_INFOLOEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_LOCKVIOLATIONOFFSET_PARMNUM)
#define SV_LOCKVIOLATIONDELAY_INFOLOEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_LOCKVIOLATIONDELAY_PARMNUM)
#define SV_MDLREADSWITCHOVER_INFOLOEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MDLREADSWITCHOVER_PARMNUM)
#define SV_CACHEDOPENLIMIT_INFOLOEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_CACHEDOPENLIMIT_PARMNUM)
#define SV_CRITICALTHREADS_INFOLOEVEL       \
            (PARMNUM_BASE_INFOLEVEL + SV_CRITICALTHREADS_PARMNUM)
#define SV_RESTRICTNULLSESSACCESS_INFOLOEVEL       \
            (PARMNUM_BASE_INFOLEVEL + SV_RESTRICTNULLSESSACCESS_PARMNUM)
#define SV_ENABLEWFW311DIRECTIPX_INFOLOEVEL       \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLEWFW311DIRECTIPX_PARMNUM)
#define SV_OTHERQUEUEAFFINITY_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_OTHERQUEUEAFFINITY_PARMNUM)
#define SV_QUEUESAMPLESECS_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_QUEUESAMPLESECS_PARMNUM)
#define SV_BALANCECOUNT_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_BALANCECOUNT_PARMNUM)
#define SV_PREFERREDAFFINITY_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_PREFERREDAFFINITY_PARMNUM)
#define SV_MAXFREERFCBS_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXFREERFCBS_PARMNUM)
#define SV_MAXFREEMFCBS_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXFREEMFCBS_PARMNUM)
#define SV_MAXFREELFCBS_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXFREELFCBS_PARMNUM)
#define SV_MAXFREEPAGEDPOOLCHUNKS_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXFREEPAGEDPOOLCHUNKS_PARMNUM)
#define SV_MINPAGEDPOOLCHUNKSIZE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MINPAGEDPOOLCHUNKSIZE_PARMNUM)
#define SV_MAXPAGEDPOOLCHUNKSIZE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXPAGEDPOOLCHUNKSIZE_PARMNUM)
#define SV_SENDSFROMPREFERREDPROCESSOR_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_SENDSFROMPREFERREDPROCESSOR_PARMNUM)
#define SV_MAXTHREADSPERQUEUE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXTHREADSPERQUEUE_PARMNUM)

#define SVI1_NUM_ELEMENTS       5
#define SVI2_NUM_ELEMENTS       40
#define SVI3_NUM_ELEMENTS       44

//
//      Maxmimum length for command string to NetServerAdminCommand.
//

#define SV_MAX_CMD_LEN          PATHLEN

//
//      Masks describing AUTOPROFILE parameters
//

#define SW_AUTOPROF_LOAD_MASK   0x1
#define SW_AUTOPROF_SAVE_MASK   0x2

//
//      Max size of svX_srvheuristics.
//

#define SV_MAX_SRV_HEUR_LEN     32      // Max heuristics info string length.

//
//      Equate for use with sv102_licenses.
//

#define SV_USERS_PER_LICENSE    5

#ifdef __cplusplus
}
#endif

#endif // _LMSERVER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\lmsname.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    lmsname.h

Abstract:

    This file contains service name strings.  It is included by lmsvc.h.

Environment:

    User Mode -Win32


--*/

#ifndef _LMSNAME_
#define _LMSNAME_

//
//  Standard LAN Manager service names.
//

#define SERVICE_WORKSTATION       TEXT("LanmanWorkstation")
#define SERVICE_LM20_WORKSTATION  TEXT("WORKSTATION")
#define WORKSTATION_DISPLAY_NAME  TEXT("Workstation")

#define SERVICE_SERVER            TEXT("LanmanServer")
#define SERVICE_LM20_SERVER       TEXT("SERVER")
#define SERVER_DISPLAY_NAME       TEXT("Server")

#define SERVICE_BROWSER           TEXT("BROWSER")
#define SERVICE_LM20_BROWSER      SERVICE_BROWSER

#define SERVICE_MESSENGER         TEXT("MESSENGER")
#define SERVICE_LM20_MESSENGER    SERVICE_MESSENGER

#define SERVICE_NETRUN            TEXT("NETRUN")
#define SERVICE_LM20_NETRUN       SERVICE_NETRUN

#define SERVICE_SPOOLER           TEXT("SPOOLER")
#define SERVICE_LM20_SPOOLER      SERVICE_SPOOLER

#define SERVICE_ALERTER           TEXT("ALERTER")
#define SERVICE_LM20_ALERTER      SERVICE_ALERTER

#define SERVICE_NETLOGON          TEXT("NETLOGON")
#define SERVICE_LM20_NETLOGON     SERVICE_NETLOGON

#define SERVICE_NETPOPUP          TEXT("NETPOPUP")
#define SERVICE_LM20_NETPOPUP     SERVICE_NETPOPUP

#define SERVICE_SQLSERVER         TEXT("SQLSERVER")
#define SERVICE_LM20_SQLSERVER    SERVICE_SQLSERVER

#define SERVICE_REPL              TEXT("REPLICATOR")
#define SERVICE_LM20_REPL         SERVICE_REPL

#define SERVICE_RIPL              TEXT("REMOTEBOOT")
#define SERVICE_LM20_RIPL         SERVICE_RIPL

#define SERVICE_TIMESOURCE        TEXT("TIMESOURCE")
#define SERVICE_LM20_TIMESOURCE   SERVICE_TIMESOURCE

#define SERVICE_AFP               TEXT("AFP")
#define SERVICE_LM20_AFP          SERVICE_AFP

#define SERVICE_UPS               TEXT("UPS")
#define SERVICE_LM20_UPS          SERVICE_UPS

#define SERVICE_XACTSRV           TEXT("XACTSRV")
#define SERVICE_LM20_XACTSRV      SERVICE_XACTSRV

#define SERVICE_TCPIP             TEXT("TCPIP")
#define SERVICE_LM20_TCPIP        SERVICE_TCPIP

#define SERVICE_NBT               TEXT("NBT")
#define SERVICE_LM20_NBT          SERVICE_NBT

#define SERVICE_LMHOSTS           TEXT("LMHOSTS")
#define SERVICE_LM20_LMHOSTS      SERVICE_LMHOSTS

#define SERVICE_TELNET            TEXT("Telnet")
#define SERVICE_LM20_TELNET       SERVICE_TELNET

#define SERVICE_SCHEDULE          TEXT("Schedule")
#define SERVICE_LM20_SCHEDULE     SERVICE_SCHEDULE

#define SERVICE_NTLMSSP           TEXT("NtLmSsp")

#define SERVICE_DHCP              TEXT("DHCP")
#define SERVICE_LM20_DHCP         SERVICE_DHCP

#define SERVICE_NWSAP             TEXT("NwSapAgent")
#define SERVICE_LM20_NWSAP        SERVICE_NWSAP
#define NWSAP_DISPLAY_NAME        TEXT("NW Sap Agent")

#define SERVICE_NWCS           TEXT("NWCWorkstation")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\lmuseflg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    lmuseflg.h

Abstract:

    This file contains deletion force levels for deleting a connection.

Environment:

    User Mode - Win32

Notes:

    This file has no dependencies.  It is included by lmwksta.h and
    lmuse.h.

Revision History:

--*/

#ifndef _LMUSEFLG_
#define _LMUSEFLG_

//
// Definition for NetWkstaTransportDel and NetUseDel deletion force levels
//

#define USE_NOFORCE             0
#define USE_FORCE               1
#define USE_LOTS_OF_FORCE       2


#endif // _LMUSEFLG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\math.h ===
/***
*math.h - definitions and declarations for math library
*
*       Copyright (c) 1985-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains constant definitions and external subroutine
*       declarations for the math subroutine library.
*       [ANSI/System V]
*
*       [Public]
*
****/

#ifndef _INC_MATH
#define _INC_MATH

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __assembler /* Protect from assembler */

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if     _MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if     _MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else   /* ndef _NTSDK */
/* current definition */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _NTSDK */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Definition of _exception struct - this struct is passed to the matherr
 * routine when a floating point exception is detected
 */

#ifndef _EXCEPTION_DEFINED
struct _exception {
        int type;       /* exception type - see below */
        char *name;     /* name of function where error occured */
        double arg1;    /* first argument to function */
        double arg2;    /* second argument (if any) to function */
        double retval;  /* value to be returned by function */
        } ;

#define _EXCEPTION_DEFINED
#endif


/* Definition of a _complex struct to be used by those who use cabs and
 * want type checking on their argument
 */

#ifndef _COMPLEX_DEFINED
struct _complex {
        double x,y; /* real and imaginary parts */
        } ;

#if     !__STDC__
/* Non-ANSI name for compatibility */
#define complex _complex
#endif

#define _COMPLEX_DEFINED
#endif
#endif  /* __assembler */


/* Constant definitions for the exception type passed in the _exception struct
 */

#define _DOMAIN     1   /* argument domain error */
#define _SING       2   /* argument singularity */
#define _OVERFLOW   3   /* overflow range error */
#define _UNDERFLOW  4   /* underflow range error */
#define _TLOSS      5   /* total loss of precision */
#define _PLOSS      6   /* partial loss of precision */

#define EDOM        33
#define ERANGE      34


/* Definitions of _HUGE and HUGE_VAL - respectively the XENIX and ANSI names
 * for a value returned in case of error by a number of the floating point
 * math routines
 */
#ifndef __assembler /* Protect from assembler */
#ifdef  _NTSDK
/* definition compatible with NT SDK */
#ifdef  _DLL
#define _HUGE   (*_HUGE_dll)
extern double * _HUGE_dll;
#else   /* ndef _DLL */
extern double _HUGE;
#endif  /* _DLL */
#else   /* ndef _NTSDK */
/* current definition */
_CRTIMP extern double _HUGE;
#endif  /* _NTSDK */
#endif  /* __assembler */

#define HUGE_VAL _HUGE


/* Function prototypes */

#if !defined(__assembler)   /* Protect from assembler */
#if _M_MRX000
_CRTIMP int     __cdecl abs(int);
_CRTIMP double  __cdecl acos(double);
_CRTIMP double  __cdecl asin(double);
_CRTIMP double  __cdecl atan(double);
_CRTIMP double  __cdecl atan2(double, double);
_CRTIMP double  __cdecl cos(double);
_CRTIMP double  __cdecl cosh(double);
_CRTIMP double  __cdecl exp(double);
_CRTIMP double  __cdecl fabs(double);
_CRTIMP double  __cdecl fmod(double, double);
_CRTIMP long    __cdecl labs(long);
_CRTIMP double  __cdecl log(double);
_CRTIMP double  __cdecl log10(double);
_CRTIMP double  __cdecl pow(double, double);
_CRTIMP double  __cdecl sin(double);
_CRTIMP double  __cdecl sinh(double);
_CRTIMP double  __cdecl tan(double);
_CRTIMP double  __cdecl tanh(double);
_CRTIMP double  __cdecl sqrt(double);
#else
        int     __cdecl abs(int);
        double  __cdecl acos(double);
        double  __cdecl asin(double);
        double  __cdecl atan(double);
        double  __cdecl atan2(double, double);
        double  __cdecl cos(double);
        double  __cdecl cosh(double);
        double  __cdecl exp(double);
        double  __cdecl fabs(double);
        double  __cdecl fmod(double, double);
        long    __cdecl labs(long);
        double  __cdecl log(double);
        double  __cdecl log10(double);
        double  __cdecl pow(double, double);
        double  __cdecl sin(double);
        double  __cdecl sinh(double);
        double  __cdecl tan(double);
        double  __cdecl tanh(double);
        double  __cdecl sqrt(double);
#endif
_CRTIMP double  __cdecl atof(const char *);
_CRTIMP double  __cdecl _cabs(struct _complex);
_CRTIMP double  __cdecl ceil(double);
_CRTIMP double  __cdecl floor(double);
_CRTIMP double  __cdecl frexp(double, int *);
_CRTIMP double  __cdecl _hypot(double, double);
_CRTIMP double  __cdecl _j0(double);
_CRTIMP double  __cdecl _j1(double);
_CRTIMP double  __cdecl _jn(int, double);
_CRTIMP double  __cdecl ldexp(double, int);
        int     __cdecl _matherr(struct _exception *);
_CRTIMP double  __cdecl modf(double, double *);

_CRTIMP double  __cdecl _y0(double);
_CRTIMP double  __cdecl _y1(double);
_CRTIMP double  __cdecl _yn(int, double);


#ifdef _M_MRX000

/* MIPS fast prototypes for float */
/* ANSI C, 4.5 Mathematics        */

/* 4.5.2 Trigonometric functions */

_CRTIMP float  __cdecl acosf( float );
_CRTIMP float  __cdecl asinf( float );
_CRTIMP float  __cdecl atanf( float );
_CRTIMP float  __cdecl atan2f( float , float );
_CRTIMP float  __cdecl cosf( float );
_CRTIMP float  __cdecl sinf( float );
_CRTIMP float  __cdecl tanf( float );

/* 4.5.3 Hyperbolic functions */
_CRTIMP float  __cdecl coshf( float );
_CRTIMP float  __cdecl sinhf( float );
_CRTIMP float  __cdecl tanhf( float );

/* 4.5.4 Exponential and logarithmic functions */
_CRTIMP float  __cdecl expf( float );
_CRTIMP float  __cdecl logf( float );
_CRTIMP float  __cdecl log10f( float );
_CRTIMP float  __cdecl modff( float , float* );

/* 4.5.5 Power functions */
_CRTIMP float  __cdecl powf( float , float );
        float  __cdecl sqrtf( float );

/* 4.5.6 Nearest integer, absolute value, and remainder functions */
        float  __cdecl ceilf( float );
        float  __cdecl fabsf( float );
        float  __cdecl floorf( float );
_CRTIMP float  __cdecl fmodf( float , float );

_CRTIMP float  __cdecl hypotf(float, float);

#endif /* _M_MRX000 */

#if !defined(_M_M68K)
/* Macros defining long double functions to be their double counterparts
 * (long double is synonymous with double in this implementation).
 */


#define acosl(x)    ((long double)acos((double)(x)))
#define asinl(x)    ((long double)asin((double)(x)))
#define atanl(x)    ((long double)atan((double)(x)))
#define atan2l(x,y) ((long double)atan2((double)(x), (double)(y)))
#define _cabsl      _cabs
#define ceill(x)    ((long double)ceil((double)(x)))
#define cosl(x)     ((long double)cos((double)(x)))
#define coshl(x)    ((long double)cosh((double)(x)))
#define expl(x)     ((long double)exp((double)(x)))
#define fabsl(x)    ((long double)fabs((double)(x)))
#define floorl(x)   ((long double)floor((double)(x)))
#define fmodl(x,y)  ((long double)fmod((double)(x), (double)(y)))
#define frexpl(x,y) ((long double)frexp((double)(x), (y)))
#define _hypotl(x,y)    ((long double)_hypot((double)(x), (double)(y)))
#define ldexpl(x,y) ((long double)ldexp((double)(x), (y)))
#define logl(x)     ((long double)log((double)(x)))
#define log10l(x)   ((long double)log10((double)(x)))
#define _matherrl   _matherr
#define modfl(x,y)  ((long double)modf((double)(x), (double *)(y)))
#define powl(x,y)   ((long double)pow((double)(x), (double)(y)))
#define sinl(x)     ((long double)sin((double)(x)))
#define sinhl(x)    ((long double)sinh((double)(x)))
#define sqrtl(x)    ((long double)sqrt((double)(x)))
#define tanl(x)     ((long double)tan((double)(x)))
#define tanhl(x)    ((long double)tanh((double)(x)))
#endif  /* _M_M68K */
#endif  /* __assembler */

#if     !__STDC__

/* Non-ANSI names for compatibility */

#define DOMAIN      _DOMAIN
#define SING        _SING
#define OVERFLOW    _OVERFLOW
#define UNDERFLOW   _UNDERFLOW
#define TLOSS       _TLOSS
#define PLOSS       _PLOSS

#if !defined(_M_MPPC) && !defined(_M_M68K)
#define matherr     _matherr
#endif /* !defined(_M_MPPC) && !defined(_M_M68K) */

#ifndef __assembler /* Protect from assembler */

#ifdef  _NTSDK

/* Definitions and declarations compatible with NT SDK */

#ifdef  _DLL
#define HUGE    (*HUGE_dll)
extern double * HUGE_dll;
#else   /* ndef _DLL */
extern double HUGE;
#endif  /* _DLL */

#define cabs    _cabs
#define hypot   _hypot
#define j0      _j0
#define j1      _j1
#define jn      _jn
#define y0      _y0
#define y1      _y1
#define yn      _yn

#else   /* ndef _NTSDK */

/* Current definitions and declarations */

_CRTIMP extern double HUGE;

_CRTIMP double  __cdecl cabs(struct complex);
_CRTIMP double  __cdecl hypot(double, double);
_CRTIMP double  __cdecl j0(double);
_CRTIMP double  __cdecl j1(double);
_CRTIMP double  __cdecl jn(int, double);
        int     __cdecl matherr(struct _exception *);
_CRTIMP double  __cdecl y0(double);
_CRTIMP double  __cdecl y1(double);
_CRTIMP double  __cdecl yn(int, double);

#endif  /* _NTSDK */
#endif  /* __assembler */

#endif  /* __STDC__ */

#ifdef _M_M68K
/* definition of _exceptionl struct - this struct is passed to the _matherrl
 * routine when a floating point exception is detected in a long double routine
 */

#ifndef _LD_EXCEPTION_DEFINED

struct _exceptionl {
        int type;           /* exception type - see below */
        char *name;         /* name of function where error occured */
        long double arg1;   /* first argument to function */
        long double arg2;   /* second argument (if any) to function */
        long double retval; /* value to be returned by function */
} ;
#define _LD_EXCEPTION_DEFINED
#endif


/* definition of a _complexl struct to be used by those who use _cabsl and
 * want type checking on their argument
 */

#ifndef _LD_COMPLEX_DEFINED
struct _complexl {
        long double x,y;    /* real and imaginary parts */
} ;
#define _LD_COMPLEX_DEFINED
#endif


long double  __cdecl acosl(long double);
long double  __cdecl asinl(long double);
long double  __cdecl atanl(long double);
long double  __cdecl atan2l(long double, long double);
long double  __cdecl _atold(const char  *);
long double  __cdecl _cabsl(struct _complexl);
long double  __cdecl ceill(long double);
long double  __cdecl cosl(long double);
long double  __cdecl coshl(long double);
long double  __cdecl expl(long double);
long double  __cdecl fabsl(long double);
long double  __cdecl floorl(long double);
long double  __cdecl fmodl(long double, long double);
long double  __cdecl frexpl(long double, int  *);
long double  __cdecl _hypotl(long double, long double);
long double  __cdecl _j0l(long double);
long double  __cdecl _j1l(long double);
long double  __cdecl _jnl(int, long double);
long double  __cdecl ldexpl(long double, int);
long double  __cdecl logl(long double);
long double  __cdecl log10l(long double);
int          __cdecl _matherrl(struct _exceptionl  *);
long double  __cdecl modfl(long double, long double  *);
long double  __cdecl powl(long double, long double);
long double  __cdecl sinl(long double);
long double  __cdecl sinhl(long double);
long double  __cdecl sqrtl(long double);
long double  __cdecl tanl(long double);
long double  __cdecl tanhl(long double);
long double  __cdecl _y0l(long double);
long double  __cdecl _y1l(long double);
long double  __cdecl _ynl(int, long double);

#endif  /* _M_M68K */


#ifdef __cplusplus
}
#endif


#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MATH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\lzexpand.h ===
/*
** lzdos.h - Public interface to LZEXP?.LIB.
*/

#ifndef _LZEXPAND_
#define _LZEXPAND_

#ifdef __cplusplus
extern "C" {
#endif

/*
** Error Return Codes
*/

#define LZERROR_BADINHANDLE   (-1)  /* invalid input handle */
#define LZERROR_BADOUTHANDLE  (-2)  /* invalid output handle */
#define LZERROR_READ          (-3)  /* corrupt compressed file format */
#define LZERROR_WRITE         (-4)  /* out of space for output file */
#define LZERROR_GLOBALLOC     (-5)  /* insufficient memory for LZFile struct */
#define LZERROR_GLOBLOCK      (-6)  /* bad global handle */
#define LZERROR_BADVALUE      (-7)  /* input parameter out of acceptable range*/
#define LZERROR_UNKNOWNALG    (-8)  /* compression algorithm not recognized */


/*
** Prototypes
*/

INT
APIENTRY
LZStart(
	VOID
	);

VOID
APIENTRY
LZDone(
	VOID
	);

LONG
APIENTRY
CopyLZFile(
	INT,
	INT
	);

LONG
APIENTRY
LZCopy(
	INT,
	INT
	);

INT
APIENTRY
LZInit(
	INT
	);

#ifndef UNICODE_ONLY
INT
APIENTRY
GetExpandedNameA(
	LPSTR,
	LPSTR
	);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
INT
APIENTRY
GetExpandedNameW(
	LPWSTR,
	LPWSTR
	);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define GetExpandedName  GetExpandedNameW
#else
#define GetExpandedName  GetExpandedNameA
#endif // !UNICODE

#ifndef UNICODE_ONLY
INT
APIENTRY
LZOpenFileA(
	LPSTR,
	LPOFSTRUCT,
	WORD
	);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
INT
APIENTRY
LZOpenFileW(
	LPWSTR,
	LPOFSTRUCT,
	WORD
	);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define LZOpenFile  LZOpenFileW
#else
#define LZOpenFile  LZOpenFileA
#endif // !UNICODE

LONG
APIENTRY
LZSeek(
	INT,
	LONG,
	INT
	);

INT
APIENTRY
LZRead(
	INT,
	LPSTR,
	INT
	);

VOID
APIENTRY
LZClose(
	INT
	);

#ifdef __cplusplus
}
#endif


#endif // _LZEXPAND_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\locale.h ===
/***
*locale.h - definitions/declarations for localization routines
*
*	Copyright (c) 1988-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines the structures, values, macros, and functions
*	used by the localization routines.
*
*       [Public]
*
****/

#ifndef _INC_LOCALE
#define _INC_LOCALE

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef	_MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif	/* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _MAC
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif
#endif /* ndef _MAC */


/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif

/* Locale categories */

#define LC_ALL		0
#define LC_COLLATE	1
#define LC_CTYPE	2
#define LC_MONETARY	3
#define LC_NUMERIC	4
#define LC_TIME 	5

#define LC_MIN		LC_ALL
#define LC_MAX		LC_TIME

/* Locale convention structure */

#ifndef _LCONV_DEFINED
struct lconv {
	char *decimal_point;
	char *thousands_sep;
	char *grouping;
	char *int_curr_symbol;
	char *currency_symbol;
	char *mon_decimal_point;
	char *mon_thousands_sep;
	char *mon_grouping;
	char *positive_sign;
	char *negative_sign;
	char int_frac_digits;
	char frac_digits;
	char p_cs_precedes;
	char p_sep_by_space;
	char n_cs_precedes;
	char n_sep_by_space;
	char p_sign_posn;
	char n_sign_posn;
	};
#define _LCONV_DEFINED
#endif

/* ANSI: char lconv members default is CHAR_MAX which is compile time
   dependent. Defining and using _charmax here causes CRT startup code
   to initialize lconv members properly */

#ifdef	_CHAR_UNSIGNED
extern int _charmax;
extern __inline int __dummy() { return _charmax; }
#endif

/* function prototypes */

_CRTIMP char * __cdecl setlocale(int, const char *);
_CRTIMP struct lconv * __cdecl localeconv(void);

#ifndef _MAC
#ifndef _WLOCALE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wsetlocale(int, const wchar_t *);

#define _WLOCALE_DEFINED
#endif
#endif /* ndef _MAC */

#ifdef __cplusplus
}
#endif

#ifdef	_MSC_VER
#pragma pack(pop)
#endif	/* _MSC_VER */

#endif	/* _INC_LOCALE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\lmsvc.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    lmsvc.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetService API.

[Environment:]

    User Mode -Win32

[Notes:]

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMSVC_
#define _LMSVC_

#ifdef __cplusplus
extern "C" {
#endif

//
// Include the file which contains all the service name strings.
//
#include <lmsname.h>

//
//  Data Structures
//

typedef struct _SERVICE_INFO_0 {
    LPTSTR  svci0_name;
} SERVICE_INFO_0, *PSERVICE_INFO_0, * LPSERVICE_INFO_0;

typedef struct _SERVICE_INFO_1 {
    LPTSTR  svci1_name;
    DWORD   svci1_status;
    DWORD   svci1_code;
    DWORD   svci1_pid;
} SERVICE_INFO_1, *PSERVICE_INFO_1, * LPSERVICE_INFO_1;

typedef struct _SERVICE_INFO_2 {
    LPTSTR  svci2_name;
    DWORD   svci2_status;
    DWORD   svci2_code;
    DWORD   svci2_pid;
    LPTSTR  svci2_text;
    DWORD   svci2_specific_error;
    LPTSTR  svci2_display_name;
} SERVICE_INFO_2, *PSERVICE_INFO_2, * LPSERVICE_INFO_2;

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetServiceControl (
    IN  LPTSTR  servername OPTIONAL,
    IN  LPTSTR  service,
    IN  DWORD   opcode,
    IN  DWORD   arg,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetServiceEnum (
    IN  LPTSTR      servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetServiceGetInfo (
    IN  LPTSTR  servername OPTIONAL,
    IN  LPTSTR  service,
    IN  DWORD   level,
    OUT LPBYTE   *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetServiceInstall (
    IN  LPTSTR  servername OPTIONAL,
    IN  LPTSTR  service,
    IN  DWORD   argc,
    IN  LPTSTR  argv[],
    OUT LPBYTE  *bufptr
    );

//
// Special Values and Constants
//

//
//  Bitmask and bit values for svci1_status, and svci2_status
//  fields.  For each "subfield", there is a mask defined,
//  and a number of constants representing the value
//  obtained by doing (status & mask).
//

// Bits 0,1 -- general status

#define SERVICE_INSTALL_STATE       0x03
#define SERVICE_UNINSTALLED         0x00
#define SERVICE_INSTALL_PENDING     0x01
#define SERVICE_UNINSTALL_PENDING   0x02
#define SERVICE_INSTALLED           0x03

// Bits 2,3 -- paused/active status

#define SERVICE_PAUSE_STATE              0x0C
#define LM20_SERVICE_ACTIVE              0x00
#define LM20_SERVICE_CONTINUE_PENDING    0x04
#define LM20_SERVICE_PAUSE_PENDING       0x08
#define LM20_SERVICE_PAUSED              0x0C

// Bit 4 -- uninstallable indication

#define SERVICE_NOT_UNINSTALLABLE   0x00
#define SERVICE_UNINSTALLABLE       0x10

// Bit 5 -- pausable indication

#define SERVICE_NOT_PAUSABLE        0x00
#define SERVICE_PAUSABLE            0x20

// Workstation service only:
// Bits 8,9,10 -- redirection paused/active

#define SERVICE_REDIR_PAUSED        0x700
#define SERVICE_REDIR_DISK_PAUSED   0x100
#define SERVICE_REDIR_PRINT_PAUSED  0x200
#define SERVICE_REDIR_COMM_PAUSED   0x400

//
//  Additional standard LAN Manager for MS-DOS services
//

#define SERVICE_DOS_ENCRYPTION  TEXT("ENCRYPT")

//
//  NetServiceControl opcodes.
//

#define SERVICE_CTRL_INTERROGATE    0
#define SERVICE_CTRL_PAUSE          1
#define SERVICE_CTRL_CONTINUE       2
#define SERVICE_CTRL_UNINSTALL      3

//
//  Workstation service only:  Bits used in the "arg" parameter
//  to NetServiceControl in conjunction with the opcode
//  SERVICE_CTRL_PAUSE or SERVICE_CTRL_CONTINUE, to pause or
//  continue redirection.
//

#define SERVICE_CTRL_REDIR_DISK     0x1
#define SERVICE_CTRL_REDIR_PRINT    0x2
#define SERVICE_CTRL_REDIR_COMM     0x4

//
//  Values for svci1_code, and svci2_code when status
//  of the service is SERVICE_INSTALL_PENDING or
//  SERVICE_UNINSTALL_PENDING.
//  A service can optionally provide a hint to the installer
//  that the install is proceeding and how long to wait
//  (in 0.1 second increments) before querying status again.
//

#define SERVICE_IP_NO_HINT          0x0
#define SERVICE_CCP_NO_HINT         0x0

#define SERVICE_IP_QUERY_HINT       0x10000
#define SERVICE_CCP_QUERY_HINT      0x10000

//
// Mask for install proceeding checkpoint number
//

#define SERVICE_IP_CHKPT_NUM        0x0FF
#define SERVICE_CCP_CHKPT_NUM       0x0FF

//
// Mask for wait time hint before querying again
//

#define SERVICE_IP_WAIT_TIME        0x0FF00
#define SERVICE_CCP_WAIT_TIME       0x0FF00

//
// Shift count for building wait time _code values
//

#define SERVICE_IP_WAITTIME_SHIFT   8
#define SERVICE_NTIP_WAITTIME_SHIFT 12

//
// Mask used for upper and lower portions of wait hint time.
//
#define UPPER_HINT_MASK     0x0000FF00
#define LOWER_HINT_MASK     0x000000FF
#define UPPER_GET_HINT_MASK 0x0FF00000
#define LOWER_GET_HINT_MASK 0x0000FF00
#define SERVICE_NT_MAXTIME  0x0000FFFF
#define SERVICE_RESRV_MASK  0x0001FFFF
#define SERVICE_MAXTIME     0x000000FF

//
//  SERVICE_BASE is the base of service error codes,
//  chosen to avoid conflict with OS, redirector,
//  netapi, and errlog codes.
//
// Don't change the comments following the manifest constants without
// understanding how mapmsg works.
//

#define SERVICE_BASE                3050
#define SERVICE_UIC_NORMAL          0
/*
 *  Uninstall codes, to be used in high byte of 'code' on final NetStatus,
 *  which sets the status to UNINSTALLED.
 */

#define SERVICE_UIC_BADPARMVAL          (SERVICE_BASE + 1)
/*
 * The Registry or the information you just typed includes an illegal
 * value for "%1".
 */

#define SERVICE_UIC_MISSPARM            (SERVICE_BASE + 2)
/*
 * The required parameter was not provided on the command
 * line or in the configuration file.
 */

#define SERVICE_UIC_UNKPARM             (SERVICE_BASE + 3)
/*
 * LAN Manager does not recognize "%1" as a valid option.
 */

#define SERVICE_UIC_RESOURCE            (SERVICE_BASE + 4)
/*
 * A request for resource could not be satisfied.
 */

#define SERVICE_UIC_CONFIG              (SERVICE_BASE + 5)
/*
 * A problem exists with the system configuration.
 */

#define SERVICE_UIC_SYSTEM              (SERVICE_BASE + 6)
/*
 * A system error has occurred.
 */

#define SERVICE_UIC_INTERNAL            (SERVICE_BASE + 7)
/*
 * An internal consistency error has occurred.
 */

#define SERVICE_UIC_AMBIGPARM           (SERVICE_BASE + 8)
/*
 * The configuration file or the command line has an ambiguous option.
 */

#define SERVICE_UIC_DUPPARM             (SERVICE_BASE + 9)
/*
 * The configuration file or the command line has a duplicate parameter.
 */

#define SERVICE_UIC_KILL                (SERVICE_BASE + 10)
/*
 * The service did not respond to control and was stopped with
 * the DosKillProc function.
 */

#define SERVICE_UIC_EXEC                (SERVICE_BASE + 11)
/*
 * An error occurred when attempting to run the service program.
 */

#define SERVICE_UIC_SUBSERV             (SERVICE_BASE + 12)
/*
 * The sub-service failed to start.
 */

#define SERVICE_UIC_CONFLPARM           (SERVICE_BASE + 13)
/*
 * There is a conflict in the value or use of these options: %1.
 */

#define SERVICE_UIC_FILE                (SERVICE_BASE + 14)
/*
 * There is a problem with the file.
 */



//
//  The modifiers
//

//
// General:
//

#define SERVICE_UIC_M_NULL  0

//
//  RESOURCE:
//

#define SERVICE_UIC_M_MEMORY    (SERVICE_BASE + 20)     /* memory */
#define SERVICE_UIC_M_DISK      (SERVICE_BASE + 21)     /* disk space */
#define SERVICE_UIC_M_THREADS   (SERVICE_BASE + 22)     /* thread */
#define SERVICE_UIC_M_PROCESSES (SERVICE_BASE + 23)     /* process */

//
//  CONFIG:
//

//
// Security failure
//

#define SERVICE_UIC_M_SECURITY          (SERVICE_BASE + 24)
/* Security Failure. %0 */

#define SERVICE_UIC_M_LANROOT           (SERVICE_BASE + 25)
/*
 * Bad or missing LAN Manager root directory.
 */

#define SERVICE_UIC_M_REDIR             (SERVICE_BASE + 26)
/*
 * The network software is not installed.
 */

#define SERVICE_UIC_M_SERVER            (SERVICE_BASE + 27)
/*
 * The server is not started.
 */

#define SERVICE_UIC_M_SEC_FILE_ERR      (SERVICE_BASE + 28)
/*
 * The server cannot access the user accounts database (NET.ACC).
 */

#define SERVICE_UIC_M_FILES             (SERVICE_BASE + 29)
/*
 * Incompatible files are installed in the LANMAN tree.
 */

#define SERVICE_UIC_M_LOGS              (SERVICE_BASE + 30)
/*
 * The LANMAN\LOGS directory is invalid.
 */

#define SERVICE_UIC_M_LANGROUP          (SERVICE_BASE + 31)
/*
 * The domain specified could not be used.
 */

#define SERVICE_UIC_M_MSGNAME           (SERVICE_BASE + 32)
/*
 * The computer name is being used as a message alias on another computer.
 */

#define SERVICE_UIC_M_ANNOUNCE          (SERVICE_BASE + 33)
/*
 * The announcement of the server name failed.
 */

#define SERVICE_UIC_M_UAS               (SERVICE_BASE + 34)
/*
 * The user accounts database is not configured correctly.
 */

#define SERVICE_UIC_M_SERVER_SEC_ERR    (SERVICE_BASE + 35)
/*
 * The server is not running with user-level security.
 */

#define SERVICE_UIC_M_WKSTA             (SERVICE_BASE + 37)
/*
 * The workstation is not configured properly.
 */

#define SERVICE_UIC_M_ERRLOG            (SERVICE_BASE + 38)
/*
 * View your error log for details.
 */

#define SERVICE_UIC_M_FILE_UW           (SERVICE_BASE + 39)
/*
 * Unable to write to this file.
 */

#define SERVICE_UIC_M_ADDPAK            (SERVICE_BASE + 40)
/*
 * ADDPAK file is corrupted.  Delete LANMAN\NETPROG\ADDPAK.SER
 * and reapply all ADDPAKs.
 */

#define SERVICE_UIC_M_LAZY              (SERVICE_BASE + 41)
/*
 * The LM386 server cannot be started because CACHE.EXE is not running.
 */

#define SERVICE_UIC_M_UAS_MACHINE_ACCT  (SERVICE_BASE + 42)
/*
 * There is no account for this computer in the security database.
 */

#define SERVICE_UIC_M_UAS_SERVERS_NMEMB (SERVICE_BASE + 43)
/*
 * This computer is not a member of the group SERVERS.
 */

#define SERVICE_UIC_M_UAS_SERVERS_NOGRP (SERVICE_BASE + 44)
/*
 * The group SERVERS is not present in the local security database.
 */

#define SERVICE_UIC_M_UAS_INVALID_ROLE  (SERVICE_BASE + 45)
/*
 * This Windows NT computer is configured as a member of a workgroup, not as
 * a member of a domain. The Netlogon service does not need to run in this
 * configuration.
 */

#define SERVICE_UIC_M_NETLOGON_NO_DC    (SERVICE_BASE + 46)
/*
 * The Windows NT domain controller for this domain could not be located.
 */

#define SERVICE_UIC_M_NETLOGON_DC_CFLCT (SERVICE_BASE + 47)
/*
 * A primary domain controller is already running in this domain.
 */

#define SERVICE_UIC_M_NETLOGON_AUTH     (SERVICE_BASE + 48)
/*
 * The service failed to authenticate with the primary domain controller.
 */

#define SERVICE_UIC_M_UAS_PROLOG        (SERVICE_BASE + 49)
/*
 * There is a problem with the security database creation date or serial number.
 */


#define SERVICE2_BASE    5600
/* new SEVICE_UIC messages go here */

#define SERVICE_UIC_M_NETLOGON_MPATH    (SERVICE2_BASE + 0)
/*
 * Could not share the User or Script path.
 */

#define SERVICE_UIC_M_LSA_MACHINE_ACCT  (SERVICE2_BASE + 1)
/*
 * The password for this computer is not found in the local security
 * database.
 */

#define SERVICE_UIC_M_DATABASE_ERROR    (SERVICE2_BASE + 2)
/*
 * An internal error occurred while accessing the computer's 
 * local or network security database.
 */


//
//  End modifiers
//

//
// Commonly used Macros:
//

#define SERVICE_IP_CODE(tt,nn) \
  ((long)SERVICE_IP_QUERY_HINT|(long)(nn|(tt<<SERVICE_IP_WAITTIME_SHIFT)))

#define SERVICE_CCP_CODE(tt,nn) \
  ((long)SERVICE_CCP_QUERY_HINT|(long)(nn|(tt<<SERVICE_IP_WAITTIME_SHIFT)))

#define SERVICE_UIC_CODE(cc,mm) \
  ((long)(((long)cc<<16)|(long)(unsigned short)mm))

//
// This macro takes a wait hint (tt) which can have a maximum value of
// 0xFFFF and puts it into the service status code field.
// 0x0FF1FFnn  (where nn is the checkpoint information).
//
#define SERVICE_NT_CCP_CODE(tt,nn)  \
  (  \
    ((long)SERVICE_CCP_QUERY_HINT)   | \
    ((long)(nn))   | \
    (((tt)&LOWER_HINT_MASK) << SERVICE_IP_WAITTIME_SHIFT)   | \
    (((tt)&UPPER_HINT_MASK) << SERVICE_NTIP_WAITTIME_SHIFT)   \
  )

//
// This macro takes a status code field, and strips out the wait hint
// from the upper and lower sections.
// 0x0FF1FFnn results in 0x0000FFFF.
//
#define SERVICE_NT_WAIT_GET(code) \
    (   \
      (((code) & UPPER_GET_HINT_MASK) >> SERVICE_NTIP_WAITTIME_SHIFT)  |  \
      (((code) & LOWER_GET_HINT_MASK) >> SERVICE_IP_WAITTIME_SHIFT)  \
    )

#ifdef __cplusplus
}
#endif

#endif // _LMSVC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\lmuse.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    lmuse.c

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetUse API.


Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.


--*/

#ifndef _LMUSE_
#define _LMUSE_

#ifdef __cplusplus
extern "C" {
#endif

#include <lmuseflg.h>                   // Deletion force level flags

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetUseAdd (
    IN LPTSTR UncServerName OPTIONAL,
    IN DWORD Level,
    IN LPBYTE Buf,
    OUT LPDWORD ParmError OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetUseDel (
    IN LPTSTR UncServerName OPTIONAL,
    IN LPTSTR UseName,
    IN DWORD ForceCond
    );

NET_API_STATUS NET_API_FUNCTION
NetUseEnum (
    IN LPTSTR UncServerName OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE *BufPtr,
    IN DWORD PreferedMaximumSize,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle
    );

NET_API_STATUS NET_API_FUNCTION
NetUseGetInfo (
    IN LPTSTR UncServerName OPTIONAL,
    IN LPTSTR UseName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr
    );

//
//  Data Structures
//

typedef struct _USE_INFO_0 {
    LPTSTR  ui0_local;
    LPTSTR  ui0_remote;
}USE_INFO_0, *PUSE_INFO_0, *LPUSE_INFO_0;

typedef struct _USE_INFO_1 {
    LPTSTR  ui1_local;
    LPTSTR  ui1_remote;
    LPTSTR  ui1_password;
    DWORD   ui1_status;
    DWORD   ui1_asg_type;
    DWORD   ui1_refcount;
    DWORD   ui1_usecount;
}USE_INFO_1, *PUSE_INFO_1, *LPUSE_INFO_1;

typedef struct _USE_INFO_2 {
    LPTSTR   ui2_local;
    LPTSTR   ui2_remote;
    LPTSTR   ui2_password;
    DWORD    ui2_status;
    DWORD    ui2_asg_type;
    DWORD    ui2_refcount;
    DWORD    ui2_usecount;
    LPTSTR   ui2_username;
    LPTSTR   ui2_domainname;
}USE_INFO_2, *PUSE_INFO_2, *LPUSE_INFO_2;


//
// Special Values and Constants
//

//
// One of these values indicates the parameter within an information
// structure that is invalid when ERROR_INVALID_PARAMETER is returned by
// NetUseAdd.
//

#define USE_LOCAL_PARMNUM       1
#define USE_REMOTE_PARMNUM      2
#define USE_PASSWORD_PARMNUM    3
#define USE_ASGTYPE_PARMNUM     4
#define USE_USERNAME_PARMNUM    5
#define USE_DOMAINNAME_PARMNUM  6

//
// Values appearing in the ui1_status field of use_info_1 structure.
// Note that USE_SESSLOST and USE_DISCONN are synonyms.
//

#define USE_OK                  0
#define USE_PAUSED              1
#define USE_SESSLOST            2
#define USE_DISCONN             2
#define USE_NETERR              3
#define USE_CONN                4
#define USE_RECONN              5


//
// Values of the ui1_asg_type field of use_info_1 structure
//

#define USE_WILDCARD            ( (DWORD) (-1) )
#define USE_DISKDEV             0
#define USE_SPOOLDEV            1
#define USE_CHARDEV             2
#define USE_IPC                 3

#ifdef __cplusplus
}
#endif

#endif // _LMUSE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\malloc.h ===
/***
*malloc.h - declarations and definitions for memory allocation functions
*
*       Copyright (c) 1985-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the function declarations for memory allocation functions;
*       also defines manifest constants and types used by the heap routines.
*       [System V]
*
*       [Public]
*
****/

#ifndef _INC_MALLOC
#define _INC_MALLOC

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if     _MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if     _MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else   /* ndef _NTSDK */
/* current definition */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _NTSDK */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


/* Maximum heap request the heap manager will attempt */

#define _HEAP_MAXREQ    0xFFFFFFE0

/* Constants for _heapchk/_heapset/_heapwalk routines */

#define _HEAPEMPTY      (-1)
#define _HEAPOK         (-2)
#define _HEAPBADBEGIN   (-3)
#define _HEAPBADNODE    (-4)
#define _HEAPEND        (-5)
#define _HEAPBADPTR     (-6)
#define _FREEENTRY      0
#define _USEDENTRY      1

#ifndef _HEAPINFO_DEFINED
typedef struct _heapinfo {
        int * _pentry;
        size_t _size;
        int _useflag;
        } _HEAPINFO;
#define _HEAPINFO_DEFINED
#endif

#ifndef _NTSDK

/* External variable declarations */

#if     defined(_DLL) && defined(_M_IX86)

#define _amblksiz   (*__p__amblksiz())
_CRTIMP unsigned int * __cdecl __p__amblksiz(void);

#else   /* !(defined(_DLL) && defined(_M_IX86)) */

extern unsigned int _amblksiz;

#endif  /* defined(_DLL) && defined(_M_IX86) */

#endif  /* _NTSDK */


/* Function prototypes */

_CRTIMP void * __cdecl calloc(size_t, size_t);
_CRTIMP void   __cdecl free(void *);
_CRTIMP void * __cdecl malloc(size_t);
_CRTIMP void * __cdecl realloc(void *, size_t);
#if defined(_M_M68K) || defined(_M_MPPC)
_CRTIMP size_t __cdecl _stackavail(void);
#endif

#ifndef _POSIX_

void * __cdecl _alloca(size_t);
_CRTIMP void * __cdecl _expand(void *, size_t);
#ifndef _NTSDK
_CRTIMP int __cdecl _heapadd(void *, size_t);
_CRTIMP int __cdecl _heapchk(void);
_CRTIMP int __cdecl _heapmin(void);
_CRTIMP int __cdecl _heapset(unsigned int);
_CRTIMP int __cdecl _heapwalk(_HEAPINFO *);
_CRTIMP size_t __cdecl _heapused(size_t *, size_t *);
#endif  /* _NTSDK */
_CRTIMP size_t __cdecl _msize(void *);

#if     !__STDC__
/* Non-ANSI names for compatibility */
#define alloca  _alloca
#endif  /* __STDC__*/

#if defined(_M_MRX000) || defined(_M_PPC)
#pragma intrinsic(_alloca)
#endif

#endif  /* _POSIX_ */

#ifdef HEAPHOOK
#ifndef _HEAPHOOK_DEFINED
/* hook function type */
typedef int (__cdecl * _HEAPHOOK)(int, size_t, void *, void **);
#define _HEAPHOOK_DEFINED
#endif /* _HEAPHOOK_DEFINED */

/* set hook function */
_CRTIMP _HEAPHOOK __cdecl _setheaphook(_HEAPHOOK);

/* hook function must handle these types */
#define _HEAP_MALLOC    1
#define _HEAP_CALLOC    2
#define _HEAP_FREE      3
#define _HEAP_REALLOC   4
#define _HEAP_MSIZE     5
#define _HEAP_EXPAND    6
#endif /* HEAPHOOK */


#ifdef  __cplusplus
}
#endif


#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MALLOC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\lmwksta.h ===
/*++ BUILD Version: 0006    // Increment this if a change has global effects

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    lmwksta.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetWorkstation and NetWkstaTransport API.

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMWKSTA_
#define _LMWKSTA_

#ifdef __cplusplus
extern "C" {
#endif

#include <lmuseflg.h>                   // Deletion force level flags

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetWkstaGetInfo (
    IN  LPTSTR  servername OPTIONAL,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaSetInfo (
    IN  LPTSTR  servername OPTIONAL,
    IN  DWORD   level,
    IN  LPBYTE  buffer,
    OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaUserGetInfo (
    IN  LPTSTR reserved,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaUserSetInfo (
    IN  LPTSTR reserved,
    IN  DWORD   level,
    OUT LPBYTE  buf,
    OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaUserEnum (
    IN  LPTSTR      servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN  OUT LPDWORD resumehandle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaTransportAdd (
    IN  LPTSTR  servername OPTIONAL,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaTransportDel (
    IN  LPTSTR  servername OPTIONAL,
    IN  LPTSTR  transportname,
    IN  DWORD   ucond
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaTransportEnum (
    IN  LPTSTR      servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN  OUT LPDWORD resumehandle OPTIONAL
    );

//
//  Data Structures
//

//
// NetWkstaGetInfo and NetWkstaSetInfo
//

//
// NetWkstaGetInfo only.  System information - guest access
//
typedef struct _WKSTA_INFO_100 {
    DWORD   wki100_platform_id;
    LPTSTR  wki100_computername;
    LPTSTR  wki100_langroup;
    DWORD   wki100_ver_major;
    DWORD   wki100_ver_minor;
}WKSTA_INFO_100, *PWKSTA_INFO_100, *LPWKSTA_INFO_100;

//
// NetWkstaGetInfo only.  System information - user access
//
typedef struct _WKSTA_INFO_101 {
    DWORD   wki101_platform_id;
    LPTSTR  wki101_computername;
    LPTSTR  wki101_langroup;
    DWORD   wki101_ver_major;
    DWORD   wki101_ver_minor;
    LPTSTR  wki101_lanroot;
}WKSTA_INFO_101, *PWKSTA_INFO_101, *LPWKSTA_INFO_101;

//
// NetWkstaGetInfo only.  System information - admin or operator access
//
typedef struct _WKSTA_INFO_102 {
    DWORD   wki102_platform_id;
    LPTSTR  wki102_computername;
    LPTSTR  wki102_langroup;
    DWORD   wki102_ver_major;
    DWORD   wki102_ver_minor;
    LPTSTR  wki102_lanroot;
    DWORD   wki102_logged_on_users;
}WKSTA_INFO_102, *PWKSTA_INFO_102, *LPWKSTA_INFO_102;

//
// Down-level NetWkstaGetInfo and NetWkstaSetInfo.
//
// DOS specific workstation information -
//    admin or domain operator access
//
typedef struct _WKSTA_INFO_302{
    DWORD   wki302_char_wait;
    DWORD   wki302_collection_time;
    DWORD   wki302_maximum_collection_count;
    DWORD   wki302_keep_conn;
    DWORD   wki302_keep_search;
    DWORD   wki302_max_cmds;
    DWORD   wki302_num_work_buf;
    DWORD   wki302_siz_work_buf;
    DWORD   wki302_max_wrk_cache;
    DWORD   wki302_sess_timeout;
    DWORD   wki302_siz_error;
    DWORD   wki302_num_alerts;
    DWORD   wki302_num_services;
    DWORD   wki302_errlog_sz;
    DWORD   wki302_print_buf_time;
    DWORD   wki302_num_char_buf;
    DWORD   wki302_siz_char_buf;
    LPTSTR  wki302_wrk_heuristics;
    DWORD   wki302_mailslots;
    DWORD   wki302_num_dgram_buf;
}WKSTA_INFO_302, *PWKSTA_INFO_302, *LPWKSTA_INFO_302;

//
// Down-level NetWkstaGetInfo and NetWkstaSetInfo
//
// OS/2 specific workstation information -
//    admin or domain operator access
//
typedef struct _WKSTA_INFO_402{
    DWORD   wki402_char_wait;
    DWORD   wki402_collection_time;
    DWORD   wki402_maximum_collection_count;
    DWORD   wki402_keep_conn;
    DWORD   wki402_keep_search;
    DWORD   wki402_max_cmds;
    DWORD   wki402_num_work_buf;
    DWORD   wki402_siz_work_buf;
    DWORD   wki402_max_wrk_cache;
    DWORD   wki402_sess_timeout;
    DWORD   wki402_siz_error;
    DWORD   wki402_num_alerts;
    DWORD   wki402_num_services;
    DWORD   wki402_errlog_sz;
    DWORD   wki402_print_buf_time;
    DWORD   wki402_num_char_buf;
    DWORD   wki402_siz_char_buf;
    LPTSTR  wki402_wrk_heuristics;
    DWORD   wki402_mailslots;
    DWORD   wki402_num_dgram_buf;
    DWORD   wki402_max_threads;
}WKSTA_INFO_402, *PWKSTA_INFO_402, *LPWKSTA_INFO_402;

//
// Same-level NetWkstaGetInfo and NetWkstaSetInfo.
//
// NT specific workstation information -
//    admin or domain operator access
//
typedef struct _WKSTA_INFO_502{
    DWORD   wki502_char_wait;
    DWORD   wki502_collection_time;
    DWORD   wki502_maximum_collection_count;
    DWORD   wki502_keep_conn;
    DWORD   wki502_max_cmds;
    DWORD   wki502_sess_timeout;
    DWORD   wki502_siz_char_buf;
    DWORD   wki502_max_threads;

    DWORD   wki502_lock_quota;
    DWORD   wki502_lock_increment;
    DWORD   wki502_lock_maximum;
    DWORD   wki502_pipe_increment;
    DWORD   wki502_pipe_maximum;
    DWORD   wki502_cache_file_timeout;
    DWORD   wki502_dormant_file_limit;
    DWORD   wki502_read_ahead_throughput;

    DWORD   wki502_num_mailslot_buffers;
    DWORD   wki502_num_srv_announce_buffers;
    DWORD   wki502_max_illegal_datagram_events;
    DWORD   wki502_illegal_datagram_event_reset_frequency;
    BOOL    wki502_log_election_packets;

    BOOL    wki502_use_opportunistic_locking;
    BOOL    wki502_use_unlock_behind;
    BOOL    wki502_use_close_behind;
    BOOL    wki502_buf_named_pipes;
    BOOL    wki502_use_lock_read_unlock;
    BOOL    wki502_utilize_nt_caching;
    BOOL    wki502_use_raw_read;
    BOOL    wki502_use_raw_write;
    BOOL    wki502_use_write_raw_data;
    BOOL    wki502_use_encryption;
    BOOL    wki502_buf_files_deny_write;
    BOOL    wki502_buf_read_only_files;
    BOOL    wki502_force_core_create_mode;
    BOOL    wki502_use_512_byte_max_transfer;
}WKSTA_INFO_502, *PWKSTA_INFO_502, *LPWKSTA_INFO_502;


//
// The following info-levels are only valid for NetWkstaSetInfo
//

//
// The following levels are supported on down-level systems (LAN Man 2.x)
// as well as NT systems:
//
typedef struct _WKSTA_INFO_1010 {
     DWORD  wki1010_char_wait;
} WKSTA_INFO_1010, *PWKSTA_INFO_1010, *LPWKSTA_INFO_1010;

typedef struct _WKSTA_INFO_1011 {
     DWORD  wki1011_collection_time;
} WKSTA_INFO_1011, *PWKSTA_INFO_1011, *LPWKSTA_INFO_1011;

typedef struct _WKSTA_INFO_1012 {
     DWORD  wki1012_maximum_collection_count;
} WKSTA_INFO_1012, *PWKSTA_INFO_1012, *LPWKSTA_INFO_1012;

//
// The following level are supported on down-level systems (LAN Man 2.x)
// only:
//
typedef struct _WKSTA_INFO_1027 {
     DWORD  wki1027_errlog_sz;
} WKSTA_INFO_1027, *PWKSTA_INFO_1027, *LPWKSTA_INFO_1027;

typedef struct _WKSTA_INFO_1028 {
     DWORD  wki1028_print_buf_time;
} WKSTA_INFO_1028, *PWKSTA_INFO_1028, *LPWKSTA_INFO_1028;

typedef struct _WKSTA_INFO_1032 {
     DWORD  wki1032_wrk_heuristics;
} WKSTA_INFO_1032, *PWKSTA_INFO_1032, *LPWKSTA_INFO_1032;

//
// The following levels are settable on NT systems, and have no
// effect on down-level systems (i.e. LANMan 2.x) since these
// fields cannot be set on them:
//
typedef struct _WKSTA_INFO_1013 {
     DWORD  wki1013_keep_conn;
} WKSTA_INFO_1013, *PWKSTA_INFO_1013, *LPWKSTA_INFO_1013;

typedef struct _WKSTA_INFO_1018 {
     DWORD  wki1018_sess_timeout;
} WKSTA_INFO_1018, *PWKSTA_INFO_1018, *LPWKSTA_INFO_1018;

typedef struct _WKSTA_INFO_1023 {
     DWORD  wki1023_siz_char_buf;
} WKSTA_INFO_1023, *PWKSTA_INFO_1023, *LPWKSTA_INFO_1023;

typedef struct _WKSTA_INFO_1033 {
     DWORD  wki1033_max_threads;
} WKSTA_INFO_1033, *PWKSTA_INFO_1033, *LPWKSTA_INFO_1033;

//
// The following levels are only supported on NT systems:
//
typedef struct _WKSTA_INFO_1041 {
    DWORD   wki1041_lock_quota;
} WKSTA_INFO_1041, *PWKSTA_INFO_1041, *LPWKSTA_INFO_1041;

typedef struct _WKSTA_INFO_1042 {
    DWORD   wki1042_lock_increment;
} WKSTA_INFO_1042, *PWKSTA_INFO_1042, *LPWKSTA_INFO_1042;

typedef struct _WKSTA_INFO_1043 {
    DWORD   wki1043_lock_maximum;
} WKSTA_INFO_1043, *PWKSTA_INFO_1043, *LPWKSTA_INFO_1043;

typedef struct _WKSTA_INFO_1044 {
    DWORD   wki1044_pipe_increment;
} WKSTA_INFO_1044, *PWKSTA_INFO_1044, *LPWKSTA_INFO_1044;

typedef struct _WKSTA_INFO_1045 {
    DWORD   wki1045_pipe_maximum;
} WKSTA_INFO_1045, *PWKSTA_INFO_1045, *LPWKSTA_INFO_1045;

typedef struct _WKSTA_INFO_1046 {
    DWORD   wki1046_dormant_file_limit;
} WKSTA_INFO_1046, *PWKSTA_INFO_1046, *LPWKSTA_INFO_1046;

typedef struct _WKSTA_INFO_1047 {
    DWORD    wki1047_cache_file_timeout;
} WKSTA_INFO_1047, *PWKSTA_INFO_1047, *LPWKSTA_INFO_1047;

typedef struct _WKSTA_INFO_1048 {
    BOOL     wki1048_use_opportunistic_locking;
} WKSTA_INFO_1048, *PWKSTA_INFO_1048, *LPWKSTA_INFO_1048;

typedef struct _WKSTA_INFO_1049 {
    BOOL     wki1049_use_unlock_behind;
} WKSTA_INFO_1049, *PWKSTA_INFO_1049, *LPWKSTA_INFO_1049;

typedef struct _WKSTA_INFO_1050 {
    BOOL     wki1050_use_close_behind;
} WKSTA_INFO_1050, *PWKSTA_INFO_1050, *LPWKSTA_INFO_1050;

typedef struct _WKSTA_INFO_1051 {
    BOOL     wki1051_buf_named_pipes;
} WKSTA_INFO_1051, *PWKSTA_INFO_1051, *LPWKSTA_INFO_1051;

typedef struct _WKSTA_INFO_1052 {
    BOOL     wki1052_use_lock_read_unlock;
} WKSTA_INFO_1052, *PWKSTA_INFO_1052, *LPWKSTA_INFO_1052;

typedef struct _WKSTA_INFO_1053 {
    BOOL     wki1053_utilize_nt_caching;
} WKSTA_INFO_1053, *PWKSTA_INFO_1053, *LPWKSTA_INFO_1053;

typedef struct _WKSTA_INFO_1054 {
    BOOL     wki1054_use_raw_read;
} WKSTA_INFO_1054, *PWKSTA_INFO_1054, *LPWKSTA_INFO_1054;

typedef struct _WKSTA_INFO_1055 {
    BOOL     wki1055_use_raw_write;
} WKSTA_INFO_1055, *PWKSTA_INFO_1055, *LPWKSTA_INFO_1055;

typedef struct _WKSTA_INFO_1056 {
    BOOL     wki1056_use_write_raw_data;
} WKSTA_INFO_1056, *PWKSTA_INFO_1056, *LPWKSTA_INFO_1056;

typedef struct _WKSTA_INFO_1057 {
    BOOL     wki1057_use_encryption;
} WKSTA_INFO_1057, *PWKSTA_INFO_1057, *LPWKSTA_INFO_1057;

typedef struct _WKSTA_INFO_1058 {
    BOOL     wki1058_buf_files_deny_write;
} WKSTA_INFO_1058, *PWKSTA_INFO_1058, *LPWKSTA_INFO_1058;

typedef struct _WKSTA_INFO_1059 {
    BOOL     wki1059_buf_read_only_files;
} WKSTA_INFO_1059, *PWKSTA_INFO_1059, *LPWKSTA_INFO_1059;

typedef struct _WKSTA_INFO_1060 {
    BOOL     wki1060_force_core_create_mode;
} WKSTA_INFO_1060, *PWKSTA_INFO_1060, *LPWKSTA_INFO_1060;

typedef struct _WKSTA_INFO_1061 {
    BOOL     wki1061_use_512_byte_max_transfer;
} WKSTA_INFO_1061, *PWKSTA_INFO_1061, *LPWKSTA_INFO_1061;

typedef struct _WKSTA_INFO_1062 {
    DWORD   wki1062_read_ahead_throughput;
} WKSTA_INFO_1062, *PWKSTA_INFO_1062, *LPWKSTA_INFO_1062;


//
// NetWkstaUserGetInfo (local only) and NetWkstaUserEnum -
//     no access restrictions.
//
typedef struct _WKSTA_USER_INFO_0 {
    LPTSTR  wkui0_username;
}WKSTA_USER_INFO_0, *PWKSTA_USER_INFO_0, *LPWKSTA_USER_INFO_0;

//
// NetWkstaUserGetInfo (local only) and NetWkstaUserEnum -
//     no access restrictions.
//
typedef struct _WKSTA_USER_INFO_1 {
    LPTSTR  wkui1_username;
    LPTSTR  wkui1_logon_domain;
    LPTSTR  wkui1_oth_domains;
    LPTSTR  wkui1_logon_server;
}WKSTA_USER_INFO_1, *PWKSTA_USER_INFO_1, *LPWKSTA_USER_INFO_1;

//
// NetWkstaUserSetInfo - local access.
//
typedef struct _WKSTA_USER_INFO_1101 {
     LPTSTR  wkui1101_oth_domains;
} WKSTA_USER_INFO_1101, *PWKSTA_USER_INFO_1101,
  *LPWKSTA_USER_INFO_1101;


//
// NetWkstaTransportAdd - admin access
//
typedef struct _WKSTA_TRANSPORT_INFO_0 {
    DWORD   wkti0_quality_of_service;
    DWORD   wkti0_number_of_vcs;
    LPTSTR  wkti0_transport_name;
    LPTSTR  wkti0_transport_address;
    BOOL    wkti0_wan_ish;
}WKSTA_TRANSPORT_INFO_0, *PWKSTA_TRANSPORT_INFO_0,
 *LPWKSTA_TRANSPORT_INFO_0;


//
// Special Values and Constants
//

//
//  Identifiers for use as NetWkstaSetInfo parmnum parameter
//

//
// One of these values indicates the parameter within an information
// structure that is invalid when ERROR_INVALID_PARAMETER is returned by
// NetWkstaSetInfo.
//

#define WKSTA_PLATFORM_ID_PARMNUM               100
#define WKSTA_COMPUTERNAME_PARMNUM              1
#define WKSTA_LANGROUP_PARMNUM                  2
#define WKSTA_VER_MAJOR_PARMNUM                 4
#define WKSTA_VER_MINOR_PARMNUM                 5
#define WKSTA_LOGGED_ON_USERS_PARMNUM           6
#define WKSTA_LANROOT_PARMNUM                   7
#define WKSTA_LOGON_DOMAIN_PARMNUM              8
#define WKSTA_LOGON_SERVER_PARMNUM              9
#define WKSTA_CHARWAIT_PARMNUM                  10  // Supported by down-level.
#define WKSTA_CHARTIME_PARMNUM                  11  // Supported by down-level.
#define WKSTA_CHARCOUNT_PARMNUM                 12  // Supported by down-level.
#define WKSTA_KEEPCONN_PARMNUM                  13
#define WKSTA_KEEPSEARCH_PARMNUM                14
#define WKSTA_MAXCMDS_PARMNUM                   15
#define WKSTA_NUMWORKBUF_PARMNUM                16
#define WKSTA_MAXWRKCACHE_PARMNUM               17
#define WKSTA_SESSTIMEOUT_PARMNUM               18
#define WKSTA_SIZERROR_PARMNUM                  19
#define WKSTA_NUMALERTS_PARMNUM                 20
#define WKSTA_NUMSERVICES_PARMNUM               21
#define WKSTA_NUMCHARBUF_PARMNUM                22
#define WKSTA_SIZCHARBUF_PARMNUM                23
#define WKSTA_ERRLOGSZ_PARMNUM                  27  // Supported by down-level.
#define WKSTA_PRINTBUFTIME_PARMNUM              28  // Supported by down-level.
#define WKSTA_SIZWORKBUF_PARMNUM                29
#define WKSTA_MAILSLOTS_PARMNUM                 30
#define WKSTA_NUMDGRAMBUF_PARMNUM               31
#define WKSTA_WRKHEURISTICS_PARMNUM             32  // Supported by down-level.
#define WKSTA_MAXTHREADS_PARMNUM                33

#define WKSTA_LOCKQUOTA_PARMNUM                 41
#define WKSTA_LOCKINCREMENT_PARMNUM             42
#define WKSTA_LOCKMAXIMUM_PARMNUM               43
#define WKSTA_PIPEINCREMENT_PARMNUM             44
#define WKSTA_PIPEMAXIMUM_PARMNUM               45
#define WKSTA_DORMANTFILELIMIT_PARMNUM          46
#define WKSTA_CACHEFILETIMEOUT_PARMNUM          47
#define WKSTA_USEOPPORTUNISTICLOCKING_PARMNUM   48
#define WKSTA_USEUNLOCKBEHIND_PARMNUM           49
#define WKSTA_USECLOSEBEHIND_PARMNUM            50
#define WKSTA_BUFFERNAMEDPIPES_PARMNUM          51
#define WKSTA_USELOCKANDREADANDUNLOCK_PARMNUM   52
#define WKSTA_UTILIZENTCACHING_PARMNUM          53
#define WKSTA_USERAWREAD_PARMNUM                54
#define WKSTA_USERAWWRITE_PARMNUM               55
#define WKSTA_USEWRITERAWWITHDATA_PARMNUM       56
#define WKSTA_USEENCRYPTION_PARMNUM             57
#define WKSTA_BUFFILESWITHDENYWRITE_PARMNUM     58
#define WKSTA_BUFFERREADONLYFILES_PARMNUM       59
#define WKSTA_FORCECORECREATEMODE_PARMNUM       60
#define WKSTA_USE512BYTESMAXTRANSFER_PARMNUM    61
#define WKSTA_READAHEADTHRUPUT_PARMNUM          62


//
// One of these values indicates the parameter within an information
// structure that is invalid when ERROR_INVALID_PARAMETER is returned by
// NetWkstaUserSetInfo.
//

#define WKSTA_OTH_DOMAINS_PARMNUM              101


//
// One of these values indicates the parameter within an information
// structure that is invalid when ERROR_INVALID_PARAMETER is returned by
// NetWkstaTransportAdd.
//

#define TRANSPORT_QUALITYOFSERVICE_PARMNUM     201
#define TRANSPORT_NAME_PARMNUM                 202

#ifdef __cplusplus
}
#endif

#endif // _LMWKSTA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\midles.h ===
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    midles.h

Abstract:

    This module contains definitions needed for encoding/decoding
    support (serializing/deserializing a.k.a. pickling).

--*/

#ifndef __MIDLES_H__
#define __MIDLES_H__

#include <rpcndr.h>

//
// Set the packing level for RPC structures for Dos and Windows.
//

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__)
#pragma pack(2)
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 *  Pickling support
 */
typedef enum
{
    MES_ENCODE,
    MES_DECODE,
} MIDL_ES_CODE;

typedef enum
{
    MES_INCREMENTAL_HANDLE,
    MES_FIXED_BUFFER_HANDLE,
    MES_DYNAMIC_BUFFER_HANDLE
} MIDL_ES_HANDLE_STYLE;


typedef void (__RPC_USER *  MIDL_ES_ALLOC )
                ( IN OUT  void __RPC_FAR * state,
                  OUT     char __RPC_FAR *  __RPC_FAR * pbuffer,
                  IN OUT  unsigned int __RPC_FAR * psize );

typedef void (__RPC_USER *  MIDL_ES_WRITE)
                ( IN OUT  void __RPC_FAR * state,
                  IN      char __RPC_FAR * buffer,
                  IN      unsigned int  size );

typedef void (__RPC_USER *  MIDL_ES_READ)
                ( IN OUT  void __RPC_FAR * state,
                  OUT     char __RPC_FAR *  __RPC_FAR * pbuffer,
                  IN OUT     unsigned int __RPC_FAR * psize );

typedef struct _MIDL_ES_MESSAGE
{
    MIDL_STUB_MESSAGE                       StubMsg;
    MIDL_ES_CODE                            Operation;
    void __RPC_FAR *                        UserState;
    unsigned long                           MesVersion:8;
    unsigned long                           HandleStyle:8;
    unsigned long                           HandleFlags:8;
    unsigned long                           Reserve:8;
    MIDL_ES_ALLOC                           Alloc;
    MIDL_ES_WRITE                           Write;
    MIDL_ES_READ                            Read;
    unsigned char __RPC_FAR *               Buffer;
    unsigned long                           BufferSize;
    unsigned char __RPC_FAR * __RPC_FAR *   pDynBuffer;
    unsigned long __RPC_FAR *               pEncodedSize;
    RPC_SYNTAX_IDENTIFIER                   InterfaceId;
    unsigned long                           ProcNumber;
    unsigned long                           AlienDataRep;
    unsigned long                           IncrDataSize;
    unsigned long                           ByteCount;
} MIDL_ES_MESSAGE, __RPC_FAR * PMIDL_ES_MESSAGE;

typedef  PMIDL_ES_MESSAGE  MIDL_ES_HANDLE;

RPC_STATUS  RPC_ENTRY
MesEncodeIncrementalHandleCreate(
    void      __RPC_FAR *  UserState,
    MIDL_ES_ALLOC          AllocFn,
    MIDL_ES_WRITE          WriteFn,
    handle_t  __RPC_FAR *  pHandle );

RPC_STATUS  RPC_ENTRY
MesDecodeIncrementalHandleCreate(
    void      __RPC_FAR *  UserState,
    MIDL_ES_READ           ReadFn,
    handle_t  __RPC_FAR *  pHandle );


RPC_STATUS  RPC_ENTRY
MesIncrementalHandleReset(
    handle_t             Handle,
    void    __RPC_FAR *  UserState,
    MIDL_ES_ALLOC        AllocFn,
    MIDL_ES_WRITE        WriteFn,
    MIDL_ES_READ         ReadFn,
    MIDL_ES_CODE         Operation );


RPC_STATUS  RPC_ENTRY
MesEncodeFixedBufferHandleCreate(
    char __RPC_FAR *            pBuffer,
    unsigned long               BufferSize,
    unsigned long __RPC_FAR *   pEncodedSize,
    handle_t  __RPC_FAR *       pHandle );

RPC_STATUS  RPC_ENTRY
MesEncodeDynBufferHandleCreate(
    char __RPC_FAR * __RPC_FAR *    pBuffer,
    unsigned long    __RPC_FAR *    pEncodedSize,
    handle_t  __RPC_FAR *           pHandle );

RPC_STATUS  RPC_ENTRY
MesDecodeBufferHandleCreate(
    char __RPC_FAR *        pBuffer,
    unsigned long           BufferSize,
    handle_t  __RPC_FAR *   pHandle );


RPC_STATUS  RPC_ENTRY
MesBufferHandleReset(
    handle_t                        Handle,
    unsigned long                   HandleStyle,
    MIDL_ES_CODE                    Operation,
    char __RPC_FAR * __RPC_FAR *    pBuffer,
    unsigned long                   BufferSize,
    unsigned long __RPC_FAR *       pEncodedSize );


RPC_STATUS  RPC_ENTRY
MesHandleFree( handle_t  Handle );

RPC_STATUS  RPC_ENTRY
MesInqProcEncodingId(
    handle_t                    Handle,
    PRPC_SYNTAX_IDENTIFIER      pInterfaceId,
    unsigned long __RPC_FAR *   pProcNum );


#if defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)
#define __RPC_UNALIGNED   __unaligned
#else
#define __RPC_UNALIGNED
#endif

void  RPC_ENTRY    I_NdrMesMessageInit( PMIDL_STUB_MESSAGE );

size_t  RPC_ENTRY
NdrMesSimpleTypeAlignSize ( handle_t );

void  RPC_ENTRY
NdrMesSimpleTypeDecode(
    handle_t            Handle,
    void __RPC_FAR *    pObject,
    short               Size );

void  RPC_ENTRY
NdrMesSimpleTypeEncode(
    handle_t            Handle,
    PMIDL_STUB_DESC     pStubDesc,
    void __RPC_FAR *    pObject,
    short               Size );


size_t  RPC_ENTRY
NdrMesTypeAlignSize(
    handle_t            Handle,
    PMIDL_STUB_DESC     pStubDesc,
    PFORMAT_STRING      pFormatString,
    void __RPC_FAR *    pObject );

void  RPC_ENTRY
NdrMesTypeEncode(
    handle_t            Handle,
    PMIDL_STUB_DESC     pStubDesc,
    PFORMAT_STRING      pFormatString,
    void __RPC_FAR *    pObject );

void  RPC_ENTRY
NdrMesTypeDecode(
    handle_t            Handle,
    PMIDL_STUB_DESC     pStubDesc,
    PFORMAT_STRING      pFormatString,
    void __RPC_FAR *    pObject );

void  RPC_VAR_ENTRY
NdrMesProcEncodeDecode(
    handle_t            Handle,
    PMIDL_STUB_DESC     pStubDesc,
    PFORMAT_STRING      pFormatString,
    ... );


#ifdef __cplusplus
}
#endif

// Reset the packing level for DOS and Windows.

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__)
#pragma pack()
#endif

#endif /* __MIDLES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\nb30.h ===
//*++
//
// Copyright (c) 1991-1995  Microsoft Corporation
//
// Module Name:
//
//  nb30.h
//
// Abstract:
//
//  This module contains the definitions for portable NetBIOS 3.0
//  support.
//
//--*/

#ifndef NCB_INCLUDED
#define NCB_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************
 *                                                              *
 *              Data structure templates                        *
 *                                                              *
 ****************************************************************/

#define NCBNAMSZ        16    /* absolute length of a net name           */
#define MAX_LANA       254    /* lana's in range 0 to MAX_LANA inclusive */

/*
 * Network Control Block
 */

typedef struct _NCB {
    UCHAR   ncb_command;            /* command code                   */
    UCHAR   ncb_retcode;            /* return code                    */
    UCHAR   ncb_lsn;                /* local session number           */
    UCHAR   ncb_num;                /* number of our network name     */
    PUCHAR  ncb_buffer;             /* address of message buffer      */
    WORD    ncb_length;             /* size of message buffer         */
    UCHAR   ncb_callname[NCBNAMSZ]; /* blank-padded name of remote    */
    UCHAR   ncb_name[NCBNAMSZ];     /* our blank-padded netname       */
    UCHAR   ncb_rto;                /* rcv timeout/retry count        */
    UCHAR   ncb_sto;                /* send timeout/sys timeout       */
    void (CALLBACK *ncb_post)( struct _NCB * ); /* POST routine address        */
    UCHAR   ncb_lana_num;           /* lana (adapter) number          */
    UCHAR   ncb_cmd_cplt;           /* 0xff => commmand pending       */
    UCHAR   ncb_reserve[10];        /* reserved, used by BIOS         */
    HANDLE  ncb_event;              /* HANDLE to Win32 event which    */
                                    /* will be set to the signalled   */
                                    /* state when an ASYNCH command   */
                                    /* completes                      */
} NCB, *PNCB;

/*
 *  Structure returned to the NCB command NCBASTAT is ADAPTER_STATUS followed
 *  by an array of NAME_BUFFER structures.
 */

typedef struct _ADAPTER_STATUS {
    UCHAR   adapter_address[6];
    UCHAR   rev_major;
    UCHAR   reserved0;
    UCHAR   adapter_type;
    UCHAR   rev_minor;
    WORD    duration;
    WORD    frmr_recv;
    WORD    frmr_xmit;

    WORD    iframe_recv_err;

    WORD    xmit_aborts;
    DWORD   xmit_success;
    DWORD   recv_success;

    WORD    iframe_xmit_err;

    WORD    recv_buff_unavail;
    WORD    t1_timeouts;
    WORD    ti_timeouts;
    DWORD   reserved1;
    WORD    free_ncbs;
    WORD    max_cfg_ncbs;
    WORD    max_ncbs;
    WORD    xmit_buf_unavail;
    WORD    max_dgram_size;
    WORD    pending_sess;
    WORD    max_cfg_sess;
    WORD    max_sess;
    WORD    max_sess_pkt_size;
    WORD    name_count;
} ADAPTER_STATUS, *PADAPTER_STATUS;

typedef struct _NAME_BUFFER {
    UCHAR   name[NCBNAMSZ];
    UCHAR   name_num;
    UCHAR   name_flags;
} NAME_BUFFER, *PNAME_BUFFER;

//  values for name_flags bits.

#define NAME_FLAGS_MASK 0x87

#define GROUP_NAME      0x80
#define UNIQUE_NAME     0x00

#define REGISTERING     0x00
#define REGISTERED      0x04
#define DEREGISTERED    0x05
#define DUPLICATE       0x06
#define DUPLICATE_DEREG 0x07

/*
 *  Structure returned to the NCB command NCBSSTAT is SESSION_HEADER followed
 *  by an array of SESSION_BUFFER structures. If the NCB_NAME starts with an
 *  asterisk then an array of these structures is returned containing the
 *  status for all names.
 */

typedef struct _SESSION_HEADER {
    UCHAR   sess_name;
    UCHAR   num_sess;
    UCHAR   rcv_dg_outstanding;
    UCHAR   rcv_any_outstanding;
} SESSION_HEADER, *PSESSION_HEADER;

typedef struct _SESSION_BUFFER {
    UCHAR   lsn;
    UCHAR   state;
    UCHAR   local_name[NCBNAMSZ];
    UCHAR   remote_name[NCBNAMSZ];
    UCHAR   rcvs_outstanding;
    UCHAR   sends_outstanding;
} SESSION_BUFFER, *PSESSION_BUFFER;

//  Values for state

#define LISTEN_OUTSTANDING      0x01
#define CALL_PENDING            0x02
#define SESSION_ESTABLISHED     0x03
#define HANGUP_PENDING          0x04
#define HANGUP_COMPLETE         0x05
#define SESSION_ABORTED         0x06

/*
 *  Structure returned to the NCB command NCBENUM.
 *
 *  On a system containing lana's 0, 2 and 3, a structure with
 *  length =3, lana[0]=0, lana[1]=2 and lana[2]=3 will be returned.
 */

typedef struct _LANA_ENUM {
    UCHAR   length;         //  Number of valid entries in lana[]
    UCHAR   lana[MAX_LANA+1];
} LANA_ENUM, *PLANA_ENUM;

/*
 *  Structure returned to the NCB command NCBFINDNAME is FIND_NAME_HEADER followed
 *  by an array of FIND_NAME_BUFFER structures.
 */

typedef struct _FIND_NAME_HEADER {
    WORD    node_count;
    UCHAR   reserved;
    UCHAR   unique_group;
} FIND_NAME_HEADER, *PFIND_NAME_HEADER;

typedef struct _FIND_NAME_BUFFER {
    UCHAR   length;
    UCHAR   access_control;
    UCHAR   frame_control;
    UCHAR   destination_addr[6];
    UCHAR   source_addr[6];
    UCHAR   routing_info[18];
} FIND_NAME_BUFFER, *PFIND_NAME_BUFFER;

/*
 *  Structure provided with NCBACTION. The purpose of NCBACTION is to provide
 *  transport specific extensions to netbios.
 */

typedef struct _ACTION_HEADER {
    ULONG   transport_id;
    USHORT  action_code;
    USHORT  reserved;
} ACTION_HEADER, *PACTION_HEADER;

//  Values for transport_id

#define ALL_TRANSPORTS  "M\0\0\0"
#define MS_NBF          "MNBF"


/****************************************************************
 *                                                              *
 *              Special values and constants                    *
 *                                                              *
 ****************************************************************/

/*
 *      NCB Command codes
 */

#define NCBCALL         0x10            /* NCB CALL                           */
#define NCBLISTEN       0x11            /* NCB LISTEN                         */
#define NCBHANGUP       0x12            /* NCB HANG UP                        */
#define NCBSEND         0x14            /* NCB SEND                           */
#define NCBRECV         0x15            /* NCB RECEIVE                        */
#define NCBRECVANY      0x16            /* NCB RECEIVE ANY                    */
#define NCBCHAINSEND    0x17            /* NCB CHAIN SEND                     */
#define NCBDGSEND       0x20            /* NCB SEND DATAGRAM                  */
#define NCBDGRECV       0x21            /* NCB RECEIVE DATAGRAM               */
#define NCBDGSENDBC     0x22            /* NCB SEND BROADCAST DATAGRAM        */
#define NCBDGRECVBC     0x23            /* NCB RECEIVE BROADCAST DATAGRAM     */
#define NCBADDNAME      0x30            /* NCB ADD NAME                       */
#define NCBDELNAME      0x31            /* NCB DELETE NAME                    */
#define NCBRESET        0x32            /* NCB RESET                          */
#define NCBASTAT        0x33            /* NCB ADAPTER STATUS                 */
#define NCBSSTAT        0x34            /* NCB SESSION STATUS                 */
#define NCBCANCEL       0x35            /* NCB CANCEL                         */
#define NCBADDGRNAME    0x36            /* NCB ADD GROUP NAME                 */
#define NCBENUM         0x37            /* NCB ENUMERATE LANA NUMBERS         */
#define NCBUNLINK       0x70            /* NCB UNLINK                         */
#define NCBSENDNA       0x71            /* NCB SEND NO ACK                    */
#define NCBCHAINSENDNA  0x72            /* NCB CHAIN SEND NO ACK              */
#define NCBLANSTALERT   0x73            /* NCB LAN STATUS ALERT               */
#define NCBACTION       0x77            /* NCB ACTION                         */
#define NCBFINDNAME     0x78            /* NCB FIND NAME                      */
#define NCBTRACE        0x79            /* NCB TRACE                          */


#define ASYNCH          0x80            /* high bit set == asynchronous       */

/*
 *      NCB Return codes
 */

#define NRC_GOODRET     0x00    /* good return                                */
                                /* also returned when ASYNCH request accepted */
#define NRC_BUFLEN      0x01    /* illegal buffer length                      */
#define NRC_ILLCMD      0x03    /* illegal command                            */
#define NRC_CMDTMO      0x05    /* command timed out                          */
#define NRC_INCOMP      0x06    /* message incomplete, issue another command  */
#define NRC_BADDR       0x07    /* illegal buffer address                     */
#define NRC_SNUMOUT     0x08    /* session number out of range                */
#define NRC_NORES       0x09    /* no resource available                      */
#define NRC_SCLOSED     0x0a    /* session closed                             */
#define NRC_CMDCAN      0x0b    /* command cancelled                          */
#define NRC_DUPNAME     0x0d    /* duplicate name                             */
#define NRC_NAMTFUL     0x0e    /* name table full                            */
#define NRC_ACTSES      0x0f    /* no deletions, name has active sessions     */
#define NRC_LOCTFUL     0x11    /* local session table full                   */
#define NRC_REMTFUL     0x12    /* remote session table full                  */
#define NRC_ILLNN       0x13    /* illegal name number                        */
#define NRC_NOCALL      0x14    /* no callname                                */
#define NRC_NOWILD      0x15    /* cannot put * in NCB_NAME                   */
#define NRC_INUSE       0x16    /* name in use on remote adapter              */
#define NRC_NAMERR      0x17    /* name deleted                               */
#define NRC_SABORT      0x18    /* session ended abnormally                   */
#define NRC_NAMCONF     0x19    /* name conflict detected                     */
#define NRC_IFBUSY      0x21    /* interface busy, IRET before retrying       */
#define NRC_TOOMANY     0x22    /* too many commands outstanding, retry later */
#define NRC_BRIDGE      0x23    /* ncb_lana_num field invalid                 */
#define NRC_CANOCCR     0x24    /* command completed while cancel occurring   */
#define NRC_CANCEL      0x26    /* command not valid to cancel                */
#define NRC_DUPENV      0x30    /* name defined by anther local process       */
#define NRC_ENVNOTDEF   0x34    /* environment undefined. RESET required      */
#define NRC_OSRESNOTAV  0x35    /* required OS resources exhausted            */
#define NRC_MAXAPPS     0x36    /* max number of applications exceeded        */
#define NRC_NOSAPS      0x37    /* no saps available for netbios              */
#define NRC_NORESOURCES 0x38    /* requested resources are not available      */
#define NRC_INVADDRESS  0x39    /* invalid ncb address or length > segment    */
#define NRC_INVDDID     0x3B    /* invalid NCB DDID                           */
#define NRC_LOCKFAIL    0x3C    /* lock of user area failed                   */
#define NRC_OPENERR     0x3f    /* NETBIOS not loaded                         */
#define NRC_SYSTEM      0x40    /* system error                               */

#define NRC_PENDING     0xff    /* asynchronous command is not yet finished   */

/****************************************************************
 *                                                              *
 *              main user entry point for NetBIOS 3.0           *
 *                                                              *
 * Usage: result = Netbios( pncb );                             *
 ****************************************************************/

UCHAR
APIENTRY
Netbios(
    PNCB pncb
    );

/****************************************************************
 *                                                              *
 *              Prefix for callback routines                    *
 *                                                              *
 * Usage in a declaration: NCB_POST MyPostRoutine( PNCB pncb ); *
 ****************************************************************/

#define NCB_POST void CALLBACK

#ifdef __cplusplus
}
#endif

#endif /* NCB_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\memory.h ===
/***
*memory.h - declarations for buffer (memory) manipulation routines
*
*       Copyright (c) 1985-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for the
*       buffer (memory) manipulation routines.
*       [System V]
*
*       [Public]
*
****/

#ifndef _INC_MEMORY
#define _INC_MEMORY

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if     _MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if     _MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else   /* ndef _NTSDK */
/* current definition */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _NTSDK */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* Function prototypes */

_CRTIMP void *  __cdecl _memccpy(void *, const void *, int, unsigned int);
_CRTIMP void *  __cdecl memchr(const void *, int, size_t);
_CRTIMP int     __cdecl _memicmp(const void *, const void *, unsigned int);
#ifdef _M_MRX000
_CRTIMP int     __cdecl memcmp(const void *, const void *, size_t);
_CRTIMP void *  __cdecl memcpy(void *, const void *, size_t);
_CRTIMP void *  __cdecl memset(void *, int, size_t);
#else
        int     __cdecl memcmp(const void *, const void *, size_t);
        void *  __cdecl memcpy(void *, const void *, size_t);
        void *  __cdecl memset(void *, int, size_t);
#endif

#if !__STDC__

/* Non-ANSI names for compatibility */

#if     defined(_NTSDK)
/* definitions compatible with the NT SDK */
#define memccpy  _memccpy
#define memicmp  _memicmp
#else   /* _NTSDK */
/* current declarations */
_CRTIMP void * __cdecl memccpy(void *, const void *, int, unsigned int);
_CRTIMP int __cdecl memicmp(const void *, const void *, unsigned int);
#endif  /* _NTSDK */

#endif  /* __STDC__ */

#ifdef __cplusplus
}
#endif

#endif  /* _INC_MEMORY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\nddeapi.h ===
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1993.        *
*               All Rights Reserved.                                    *
* Copyright (c) Microsoft Inc. 1995                                     *
*               All Rights Reserved.                                    *
************************************************************************/

#ifndef          _INC_NDDEAPI
#define          _INC_NDDEAPI

#include <pshpack1.h>   /* Assume byte packing throughout */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif    /* __cplusplus */

#ifndef CNLEN           /* If not included with netapi header */
#define CNLEN           15                  /* Computer name length     */
#define UNCLEN          (CNLEN+2)           /* UNC computer name length */
#endif /* CNLEN */

// the choice of this char affects legal share,topic, etc. names
#define SEP_CHAR    ','
#define BAR_CHAR    "|"
#define SEP_WCHAR   L','
#define BAR_WCHAR   L"|"

/* API error codes  */
#define NDDE_NO_ERROR                   0
#define NDDE_ACCESS_DENIED              1
#define NDDE_BUF_TOO_SMALL              2
#define NDDE_ERROR_MORE_DATA            3
#define NDDE_INVALID_SERVER             4
#define NDDE_INVALID_SHARE              5
#define NDDE_INVALID_PARAMETER          6
#define NDDE_INVALID_LEVEL              7
#define NDDE_INVALID_PASSWORD           8
#define NDDE_INVALID_ITEMNAME           9
#define NDDE_INVALID_TOPIC             10
#define NDDE_INTERNAL_ERROR            11
#define NDDE_OUT_OF_MEMORY             12
#define NDDE_INVALID_APPNAME           13
#define NDDE_NOT_IMPLEMENTED           14
#define NDDE_SHARE_ALREADY_EXIST       15
#define NDDE_SHARE_NOT_EXIST           16
#define NDDE_INVALID_FILENAME          17
#define NDDE_NOT_RUNNING               18
#define NDDE_INVALID_WINDOW            19
#define NDDE_INVALID_SESSION           20
#define NDDE_INVALID_ITEM_LIST         21
#define NDDE_SHARE_DATA_CORRUPTED      22
#define NDDE_REGISTRY_ERROR            23
#define NDDE_CANT_ACCESS_SERVER        24
#define NDDE_INVALID_SPECIAL_COMMAND   25
#define NDDE_INVALID_SECURITY_DESC     26
#define NDDE_TRUST_SHARE_FAIL          27

/* string size constants */
#define MAX_NDDESHARENAME       256
#define MAX_DOMAINNAME          15
#define MAX_USERNAME            15
#define MAX_APPNAME             255
#define MAX_TOPICNAME           255
#define MAX_ITEMNAME            255

/* connectFlags bits for ndde service affix */
#define NDDEF_NOPASSWORDPROMPT  0x0001
#define NDDEF_NOCACHELOOKUP     0x0002
#define NDDEF_STRIP_NDDE        0x0004


/* NDDESHAREINFO - contains information about a NDDE share */

struct NDdeShareInfo_tag {
    LONG                    lRevision;
    LPTSTR                  lpszShareName;
    LONG                    lShareType;
    LPTSTR                  lpszAppTopicList;
    LONG                    fSharedFlag;
    LONG                    fService;
    LONG                    fStartAppFlag;
    LONG                    nCmdShow;
    LONG                    qModifyId[2];
    LONG                    cNumItems;
    LPTSTR                  lpszItemList;
};
typedef struct NDdeShareInfo_tag   NDDESHAREINFO;
typedef struct NDdeShareInfo_tag * PNDDESHAREINFO;

/*  Share Types */
#define SHARE_TYPE_OLD      0x01                // Excel|sheet1.xls
#define SHARE_TYPE_NEW      0x02                // ExcelWorksheet|sheet1.xls
#define SHARE_TYPE_STATIC   0x04                // ClipSrv|SalesData

#ifndef UNICODE_ONLY
/*
    Add new share
*/
UINT WINAPI
NDdeShareAddA (
    LPSTR                   lpszServer, // server to execute on ( must be NULL )
    UINT                    nLevel,     // info level must be 2
    PSECURITY_DESCRIPTOR    pSD,        // initial security descriptor (optional)
    LPBYTE                  lpBuffer,   // contains (NDDESHAREINFO) + data
    DWORD                   cBufSize    // sizeof supplied buffer
);
#endif //!UNICODE_ONLY

#ifndef ANSI_ONLY
UINT WINAPI
NDdeShareAddW (
    LPWSTR                  lpszServer, // server to execute on ( must be NULL )
    UINT                    nLevel,     // info level must be 2
    PSECURITY_DESCRIPTOR    pSD,        // initial security descriptor (optional)
    LPBYTE                  lpBuffer,   // contains (NDDESHAREINFO) + data
    DWORD                   cBufSize    // sizeof supplied buffer
);
#endif //!ANSI_ONLY

#ifndef UNICODE_ONLY
/*
    Delete a share
*/
UINT WINAPI
NDdeShareDelA (
    LPSTR   lpszServer,     // server to execute on ( must be NULL )
    LPSTR   lpszShareName,  // name of share to delete
    UINT    wReserved       // reserved for force level (?) 0 for now
);
#endif //!UNICODE_ONLY

#ifndef ANSI_ONLY
UINT WINAPI
NDdeShareDelW (
    LPWSTR  lpszServer,     // server to execute on ( must be NULL )
    LPWSTR  lpszShareName,  // name of share to delete
    UINT    wReserved       // reserved for force level (?) 0 for now
);
#endif //!ANSI_ONLY

/*
    Get Share Security Descriptor
*/

#ifndef UNICODE_ONLY
UINT WINAPI
NDdeGetShareSecurityA(
    LPSTR                   lpszServer,     // server to execute on ( must be NULL )
    LPSTR                   lpszShareName,  // name of share to delete
    SECURITY_INFORMATION    si,             // requested information
    PSECURITY_DESCRIPTOR    pSD,            // address of security descriptor
    DWORD                   cbSD,           // size of buffer for security descriptor
    LPDWORD                 lpcbsdRequired  // address of required size of buffer
);
#endif //!UNICODE_ONLY

#ifndef ANSI_ONLY
UINT WINAPI
NDdeGetShareSecurityW(
    LPWSTR                  lpszServer,     // server to execute on ( must be NULL )
    LPWSTR                  lpszShareName,  // name of share to delete
    SECURITY_INFORMATION    si,             // requested information
    PSECURITY_DESCRIPTOR    pSD,            // address of security descriptor
    DWORD                   cbSD,           // size of buffer for security descriptor
    LPDWORD                 lpcbsdRequired  // address of required size of buffer
);
#endif //!ANSI_ONLY

/*
    Set Share Security Descriptor
*/

#ifndef UNICODE_ONLY
UINT WINAPI
NDdeSetShareSecurityA(
    LPSTR                   lpszServer,     // server to execute on ( must be NULL )
    LPSTR                   lpszShareName,  // name of share to delete
    SECURITY_INFORMATION    si,             // type of information to set
    PSECURITY_DESCRIPTOR    pSD             // address of security descriptor
);
#endif //!UNICODE_ONLY

#ifndef ANSI_ONLY
UINT WINAPI
NDdeSetShareSecurityW(
    LPWSTR                  lpszServer,     // server to execute on ( must be NULL )
    LPWSTR                  lpszShareName,  // name of share to delete
    SECURITY_INFORMATION    si,             // type of information to set
    PSECURITY_DESCRIPTOR    pSD             // address of security descriptor
);
#endif //!ANSI_ONLY

#ifndef UNICODE_ONLY
/*
    Enumerate shares
*/
UINT WINAPI
NDdeShareEnumA (
    LPSTR   lpszServer,         // server to execute on ( NULL for local )
    UINT    nLevel,             //  0 for null separated 00 terminated list
    LPBYTE  lpBuffer,           // pointer to buffer
    DWORD   cBufSize,           // size of buffer
    LPDWORD lpnEntriesRead,     // number of names returned
    LPDWORD lpcbTotalAvailable  // number of bytes available
);
#endif //!UNICODE_ONLY

#ifndef ANSI_ONLY
UINT WINAPI
NDdeShareEnumW (
    LPWSTR  lpszServer,         // server to execute on ( NULL for local )
    UINT    nLevel,             //  0 for null separated 00 terminated list
    LPBYTE  lpBuffer,           // pointer to buffer
    DWORD   cBufSize,           // size of buffer
    LPDWORD lpnEntriesRead,     // number of names returned
    LPDWORD lpcbTotalAvailable  // number of bytes available
);
#endif //!ANSI_ONLY

#ifndef UNICODE_ONLY
/*
    Get information on a share
*/
UINT WINAPI
NDdeShareGetInfoA (
    LPSTR   lpszServer,         // server to execute on ( must be NULL )
    LPSTR   lpszShareName,      // name of share
    UINT    nLevel,             // info level must be 2
    LPBYTE  lpBuffer,           // gets struct containing (NDDESHAREINFO) + data
    DWORD   cBufSize,           // sizeof buffer
    LPDWORD lpnTotalAvailable,  // number of bytes available
    LPWORD  lpnItems            // item mask for partial getinfo (must be 0)
);
#endif //!UNICODE_ONLY

#ifndef ANSI_ONLY
UINT WINAPI
NDdeShareGetInfoW (
    LPWSTR  lpszServer,         // server to execute on ( must be NULL )
    LPWSTR  lpszShareName,      // name of share
    UINT    nLevel,             // info level must be 2
    LPBYTE  lpBuffer,           // gets struct containing (NDDESHAREINFO) + data
    DWORD   cBufSize,           // sizeof buffer
    LPDWORD lpnTotalAvailable,  // number of bytes available
    LPWORD  lpnItems            // item mask for partial getinfo (must be 0)
);
#endif //!ANSI_ONLY

#ifndef UNICODE_ONLY
/*
    Modify DDE share data
*/
UINT WINAPI
NDdeShareSetInfoA (
    LPSTR   lpszServer,         // server to execute on ( must be NULL )
    LPSTR   lpszShareName,      // name of share
    UINT    nLevel,             // info level must be 2
    LPBYTE  lpBuffer,           // points to struct with (NDDESHAREINFO) + data
    DWORD   cBufSize,           // sizeof buffer
    WORD    sParmNum            // Parameter index ( must be 0 - entire )
);
#endif //!UNICODE_ONLY

#ifndef ANSI_ONLY
UINT WINAPI
NDdeShareSetInfoW (
    LPWSTR  lpszServer,         // server to execute on ( must be NULL )
    LPWSTR  lpszShareName,      // name of share
    UINT    nLevel,             // info level must be 2
    LPBYTE  lpBuffer,           // points to struct with (NDDESHAREINFO) + data
    DWORD   cBufSize,           // sizeof buffer
    WORD    sParmNum            // Parameter index ( must be 0 - entire )
);
#endif //!ANSI_ONLY

/*
    Set/Create a trusted share
*/

#ifndef UNICODE_ONLY
UINT WINAPI
NDdeSetTrustedShareA (
    LPSTR   lpszServer,         // server to execute on ( must be NULL )
    LPSTR   lpszShareName,      // name of share to delete
    DWORD   dwTrustOptions      // trust options to apply
);
#endif //!UNICODE_ONLY

#ifndef ANSI_ONLY
UINT WINAPI
NDdeSetTrustedShareW (
    LPWSTR  lpszServer,         // server to execute on ( must be NULL )
    LPWSTR  lpszShareName,      // name of share to delete
    DWORD   dwTrustOptions      // trust options to apply
);
#endif //!ANSI_ONLY

                                            /*  Trusted share options       */
#define NDDE_TRUST_SHARE_START  0x80000000L     // Start App Allowed
#define NDDE_TRUST_SHARE_INIT   0x40000000L     // Init Conv Allowed
#define NDDE_TRUST_SHARE_DEL    0x20000000L     // Delete Trusted Share (on set)
#define NDDE_TRUST_CMD_SHOW     0x10000000L     // Use supplied cmd show
#define NDDE_CMD_SHOW_MASK      0x0000FFFFL     // Command Show mask

/*
    Get a trusted share options
*/

#ifndef UNICODE_ONLY
UINT WINAPI
NDdeGetTrustedShareA (
    LPSTR       lpszServer,         // server to execute on ( must be NULL )
    LPSTR       lpszShareName,      // name of share to query
    LPDWORD     lpdwTrustOptions,   // trust options in effect
    LPDWORD     lpdwShareModId0,    // first word of share mod id
    LPDWORD     lpdwShareModId1     // second word of share mod id
);
#endif //!UNICODE_ONLY

#ifndef ANSI_ONLY
UINT WINAPI
NDdeGetTrustedShareW (
    LPWSTR      lpszServer,         // server to execute on ( must be NULL )
    LPWSTR      lpszShareName,      // name of share to query
    LPDWORD     lpdwTrustOptions,   // trust options in effect
    LPDWORD     lpdwShareModId0,    // first word of share mod id
    LPDWORD     lpdwShareModId1     // second word of share mod id
);
#endif //!ANSI_ONLY


#ifndef UNICODE_ONLY
/*
    Enumerate trusted shares
*/
UINT WINAPI
NDdeTrustedShareEnumA (
    LPSTR   lpszServer,         // server to execute on ( NULL for local )
    UINT    nLevel,             //  0 for null separated 00 terminated list
    LPBYTE  lpBuffer,           // pointer to buffer
    DWORD   cBufSize,           // size of buffer
    LPDWORD lpnEntriesRead,     // number of names returned
    LPDWORD lpcbTotalAvailable  // number of bytes available
);
#endif //!UNICODE_ONLY

#ifndef ANSI_ONLY
UINT WINAPI
NDdeTrustedShareEnumW (
    LPWSTR  lpszServer,         // server to execute on ( NULL for local )
    UINT    nLevel,             //  0 for null separated 00 terminated list
    LPBYTE  lpBuffer,           // pointer to buffer
    DWORD   cBufSize,           // size of buffer
    LPDWORD lpnEntriesRead,     // number of names returned
    LPDWORD lpcbTotalAvailable  // number of bytes available
);
#endif //!ANSI_ONLY

#ifndef UNICODE_ONLY
/*
    Convert error code to string value
*/
UINT WINAPI
NDdeGetErrorStringA (
    UINT    uErrorCode,         // Error code to get string for
    LPSTR   lpszErrorString,    // buffer to hold error string
    DWORD   cBufSize            // sizeof buffer
);
#endif //!UNICODE_ONLY

#ifndef ANSI_ONLY
UINT WINAPI
NDdeGetErrorStringW (
    UINT    uErrorCode,         // Error code to get string for
    LPWSTR  lpszErrorString,    // buffer to hold error string
    DWORD   cBufSize            // sizeof buffer
);
#endif //!ANSI_ONLY

#ifndef UNICODE_ONLY
/*
    Validate share name format
*/
BOOL WINAPI
NDdeIsValidShareNameA (
    LPSTR shareName
);
#endif //!UNICODE_ONLY

#ifndef ANSI_ONLY
BOOL WINAPI
NDdeIsValidShareNameW (
    LPWSTR shareName
);
#endif //!ANSI_ONLY

#ifndef UNICODE_ONLY
/*
    Validate application/topic list format
*/
BOOL WINAPI
NDdeIsValidAppTopicListA (
    LPSTR targetTopic
);
#endif //!UNICODE_ONLY

#ifndef ANSI_ONLY
BOOL WINAPI
NDdeIsValidAppTopicListW (
    LPWSTR targetTopic
);
#endif //!ANSI_ONLY

#ifdef UNICODE
#define NDdeShareAdd            NDdeShareAddW
#define NDdeShareDel            NDdeShareDelW
#define NDdeSetShareSecurity    NDdeSetShareSecurityW
#define NDdeGetShareSecurity    NDdeGetShareSecurityW
#define NDdeShareEnum           NDdeShareEnumW
#define NDdeShareGetInfo        NDdeShareGetInfoW
#define NDdeShareSetInfo        NDdeShareSetInfoW
#define NDdeGetErrorString      NDdeGetErrorStringW
#define NDdeIsValidShareName    NDdeIsValidShareNameW
#define NDdeIsValidAppTopicList NDdeIsValidAppTopicListW
#define NDdeSetTrustedShare     NDdeSetTrustedShareW
#define NDdeGetTrustedShare     NDdeGetTrustedShareW
#define NDdeTrustedShareEnum    NDdeTrustedShareEnumW
#else
#define NDdeShareAdd            NDdeShareAddA
#define NDdeShareDel            NDdeShareDelA
#define NDdeSetShareSecurity    NDdeSetShareSecurityA
#define NDdeGetShareSecurity    NDdeGetShareSecurityA
#define NDdeShareEnum           NDdeShareEnumA
#define NDdeShareGetInfo        NDdeShareGetInfoA
#define NDdeShareSetInfo        NDdeShareSetInfoA
#define NDdeGetErrorString      NDdeGetErrorStringA
#define NDdeIsValidShareName    NDdeIsValidShareNameA
#define NDdeIsValidAppTopicList NDdeIsValidAppTopicListA
#define NDdeSetTrustedShare     NDdeSetTrustedShareA
#define NDdeGetTrustedShare     NDdeGetTrustedShareA
#define NDdeTrustedShareEnum    NDdeTrustedShareEnumA
#endif

#ifdef __cplusplus
}
#endif    /* __cplusplus */

#include <poppack.h>

#endif  /* _INC_NDDEAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\ntimage.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    ntimage.h

Abstract:

    This is the include file that describes all image structures.

Author:

    Mike O'Leary (mikeol) 21-Mar-1991

Revision History:

--*/

#ifndef _NTIMAGE_
#define _NTIMAGE_

//
// Define the linker version number.  This is temporary to aid
// in debugging with people trying to load images built with
// an older linker.  This is not required in the final product.
//

#define IMAGE_MAJOR_LINKER_VERSION 2

// begin_winnt


//
// Image Format
//

#ifndef RC_INVOKED
#pragma pack (1)
#endif // !RC_INVOKED

#define IMAGE_DOS_SIGNATURE                 0x5A4D      // MZ
#define IMAGE_OS2_SIGNATURE                 0x454E      // NE
#define IMAGE_OS2_SIGNATURE_LE              0x454C      // LE
#define IMAGE_NT_SIGNATURE                  0x00004550  // PE00

typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
    USHORT e_magic;                     // Magic number
    USHORT e_cblp;                      // Bytes on last page of file
    USHORT e_cp;                        // Pages in file
    USHORT e_crlc;                      // Relocations
    USHORT e_cparhdr;                   // Size of header in paragraphs
    USHORT e_minalloc;                  // Minimum extra paragraphs needed
    USHORT e_maxalloc;                  // Maximum extra paragraphs needed
    USHORT e_ss;                        // Initial (relative) SS value
    USHORT e_sp;                        // Initial SP value
    USHORT e_csum;                      // Checksum
    USHORT e_ip;                        // Initial IP value
    USHORT e_cs;                        // Initial (relative) CS value
    USHORT e_lfarlc;                    // File address of relocation table
    USHORT e_ovno;                      // Overlay number
    USHORT e_res[4];                    // Reserved words
    USHORT e_oemid;                     // OEM identifier (for e_oeminfo)
    USHORT e_oeminfo;                   // OEM information; e_oemid specific
    USHORT e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_OS2_HEADER {      // OS/2 .EXE header
    USHORT ne_magic;                    // Magic number
    CHAR   ne_ver;                      // Version number
    CHAR   ne_rev;                      // Revision number
    USHORT ne_enttab;                   // Offset of Entry Table
    USHORT ne_cbenttab;                 // Number of bytes in Entry Table
    LONG   ne_crc;                      // Checksum of whole file
    USHORT ne_flags;                    // Flag word
    USHORT ne_autodata;                 // Automatic data segment number
    USHORT ne_heap;                     // Initial heap allocation
    USHORT ne_stack;                    // Initial stack allocation
    LONG   ne_csip;                     // Initial CS:IP setting
    LONG   ne_sssp;                     // Initial SS:SP setting
    USHORT ne_cseg;                     // Count of file segments
    USHORT ne_cmod;                     // Entries in Module Reference Table
    USHORT ne_cbnrestab;                // Size of non-resident name table
    USHORT ne_segtab;                   // Offset of Segment Table
    USHORT ne_rsrctab;                  // Offset of Resource Table
    USHORT ne_restab;                   // Offset of resident name table
    USHORT ne_modtab;                   // Offset of Module Reference Table
    USHORT ne_imptab;                   // Offset of Imported Names Table
    LONG   ne_nrestab;                  // Offset of Non-resident Names Table
    USHORT ne_cmovent;                  // Count of movable entries
    USHORT ne_align;                    // Segment alignment shift count
    USHORT ne_cres;                     // Count of resource segments
    UCHAR  ne_exetyp;                   // Target Operating system
    UCHAR  ne_flagsothers;              // Other .EXE flags
    USHORT ne_pretthunks;               // offset to return thunks
    USHORT ne_psegrefbytes;             // offset to segment ref. bytes
    USHORT ne_swaparea;                 // Minimum code swap area size
    USHORT ne_expver;                   // Expected Windows version number
  } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;

//
// File header format.
//

typedef struct _IMAGE_FILE_HEADER {
    USHORT  Machine;
    USHORT  NumberOfSections;
    ULONG   TimeDateStamp;
    ULONG   PointerToSymbolTable;
    ULONG   NumberOfSymbols;
    USHORT  SizeOfOptionalHeader;
    USHORT  Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

#define IMAGE_SIZEOF_FILE_HEADER             20

#define IMAGE_FILE_RELOCS_STRIPPED           0x0001  // Relocation info stripped from file.
#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  // File is executable  (i.e. no unresolved externel references).
#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  // Line nunbers stripped from file.
#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  // Local symbols stripped from file.
#define IMAGE_FILE_MINIMAL_OBJECT            0x0010  // Reserved.
#define IMAGE_FILE_UPDATE_OBJECT             0x0020  // Reserved.
#define IMAGE_FILE_16BIT_MACHINE             0x0040  // 16 bit word machine.
#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080  // Bytes of machine word are reversed.
#define IMAGE_FILE_32BIT_MACHINE             0x0100  // 32 bit word machine.
#define IMAGE_FILE_DEBUG_STRIPPED            0x0200  // Debugging info stripped from file in .DBG file
#define IMAGE_FILE_PATCH                     0x0400  // Reserved.
#define IMAGE_FILE_SYSTEM                    0x1000  // System File.
#define IMAGE_FILE_DLL                       0x2000  // File is a DLL.
#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000  // Bytes of machine word are reversed.

#define IMAGE_FILE_MACHINE_UNKNOWN           0
#define IMAGE_FILE_MACHINE_I386              0x14c   // Intel 386.
#define IMAGE_FILE_MACHINE_R3000             0x162   // MIPS little-endian, 0540 big-endian
#define IMAGE_FILE_MACHINE_R4000             0x166   // MIPS little-endian
#define IMAGE_FILE_MACHINE_ALPHA             0x184   // Alpha_AXP

//
// Directory format.
//

typedef struct _IMAGE_DATA_DIRECTORY {
    ULONG   VirtualAddress;
    ULONG   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16

//
// Optional header format.
//

typedef struct _IMAGE_OPTIONAL_HEADER {
    //
    // Standard fields.
    //

    USHORT  Magic;
    UCHAR   MajorLinkerVersion;
    UCHAR   MinorLinkerVersion;
    ULONG   SizeOfCode;
    ULONG   SizeOfInitializedData;
    ULONG   SizeOfUninitializedData;
    ULONG   AddressOfEntryPoint;
    ULONG   BaseOfCode;
    ULONG   BaseOfData;

    //
    // NT additional fields.
    //

    ULONG   ImageBase;
    ULONG   SectionAlignment;
    ULONG   FileAlignment;
    USHORT  MajorOperatingSystemVersion;
    USHORT  MinorOperatingSystemVersion;
    USHORT  MajorImageVersion;
    USHORT  MinorImageVersion;
    USHORT  MajorSubsystemVersion;
    USHORT  MinorSubsystemVersion;
    ULONG   Reserved1;
    ULONG   SizeOfImage;
    ULONG   SizeOfHeaders;
    ULONG   CheckSum;
    USHORT  Subsystem;
    USHORT  DllCharacteristics;
    ULONG   SizeOfStackReserve;
    ULONG   SizeOfStackCommit;
    ULONG   SizeOfHeapReserve;
    ULONG   SizeOfHeapCommit;
    ULONG   LoaderFlags;
    ULONG   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;

typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
    USHORT Magic;
    UCHAR  MajorLinkerVersion;
    UCHAR  MinorLinkerVersion;
    ULONG  SizeOfCode;
    ULONG  SizeOfInitializedData;
    ULONG  SizeOfUninitializedData;
    ULONG  AddressOfEntryPoint;
    ULONG  BaseOfCode;
    ULONG  BaseOfData;
    ULONG  BaseOfBss;
    ULONG  GprMask;
    ULONG  CprMask[4];
    ULONG  GpValue;
} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;

#define IMAGE_SIZEOF_ROM_OPTIONAL_HEADER      56
#define IMAGE_SIZEOF_STD_OPTIONAL_HEADER      28
#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER      224

#define IMAGE_NT_OPTIONAL_HDR_MAGIC        0x10b
#define IMAGE_ROM_OPTIONAL_HDR_MAGIC       0x107

typedef struct _IMAGE_NT_HEADERS {
    ULONG Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER OptionalHeader;
} IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;

typedef struct _IMAGE_ROM_HEADERS {
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;

#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \
    ((ULONG)ntheader +                                                  \
     FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \
     ((PIMAGE_NT_HEADERS)(ntheader))->FileHeader.SizeOfOptionalHeader   \
    ))


// Subsystem Values

#define IMAGE_SUBSYSTEM_UNKNOWN              0   // Unknown subsystem.
#define IMAGE_SUBSYSTEM_NATIVE               1   // Image doesn't require a subsystem.
#define IMAGE_SUBSYSTEM_WINDOWS_GUI          2   // Image runs in the Windows GUI subsystem.
#define IMAGE_SUBSYSTEM_WINDOWS_CUI          3   // Image runs in the Windows character subsystem.
#define IMAGE_SUBSYSTEM_OS2_CUI              5   // image runs in the OS/2 character subsystem.
#define IMAGE_SUBSYSTEM_POSIX_CUI            7   // image run  in the Posix character subsystem.

// Dll Characteristics

#define IMAGE_LIBRARY_PROCESS_INIT           1   // Dll has a process initialization routine.
#define IMAGE_LIBRARY_PROCESS_TERM           2   // Dll has a thread termination routine.
#define IMAGE_LIBRARY_THREAD_INIT            4   // Dll has a thread initialization routine.
#define IMAGE_LIBRARY_THREAD_TERM            8   // Dll has a thread termination routine.

//
// Loader Flags
//

#define IMAGE_LOADER_FLAGS_BREAK_ON_LOAD    0x00000001
#define IMAGE_LOADER_FLAGS_DEBUG_ON_LOAD    0x00000002


// Directory Entries

#define IMAGE_DIRECTORY_ENTRY_EXPORT         0   // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT         1   // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE       2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION      3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY       4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC      5   // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG          6   // Debug Directory
#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT      7   // Description String
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR      8   // Machine Value (MIPS GP)
#define IMAGE_DIRECTORY_ENTRY_TLS            9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG   10   // Load Configuration Directory

//
// Section header format.
//

#define IMAGE_SIZEOF_SHORT_NAME              8

typedef struct _IMAGE_SECTION_HEADER {
    UCHAR   Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
            ULONG   PhysicalAddress;
            ULONG   VirtualSize;
    } Misc;
    ULONG   VirtualAddress;
    ULONG   SizeOfRawData;
    ULONG   PointerToRawData;
    ULONG   PointerToRelocations;
    ULONG   PointerToLinenumbers;
    USHORT  NumberOfRelocations;
    USHORT  NumberOfLinenumbers;
    ULONG   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

#define IMAGE_SIZEOF_SECTION_HEADER          40

#define IMAGE_SCN_TYPE_REGULAR               0x00000000  //
#define IMAGE_SCN_TYPE_DUMMY                 0x00000001  // Reserved.
#define IMAGE_SCN_TYPE_NO_LOAD               0x00000002  // Reserved.
#define IMAGE_SCN_TYPE_GROUPED               0x00000004  // Used for 16-bit offset code.
#define IMAGE_SCN_TYPE_NO_PAD                0x00000008  // Reserved.
#define IMAGE_SCN_TYPE_COPY                  0x00000010  // Reserved.

#define IMAGE_SCN_CNT_CODE                   0x00000020  // Section contains code.
#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  // Section contains initialized data.
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  // Section contains uninitialized data.

#define IMAGE_SCN_LNK_OTHER                  0x00000100  // Reserved.
#define IMAGE_SCN_LNK_INFO                   0x00000200  // Section contains comments or some other type of information.
#define IMAGE_SCN_LNK_OVERLAY                0x00000400  // Section contains an overlay.
#define IMAGE_SCN_LNK_REMOVE                 0x00000800  // Section contents will not become part of image.
#define IMAGE_SCN_LNK_COMDAT                 0x00001000  // Section contents comdat.

#define IMAGE_SCN_ALIGN_1BYTES               0x00100000  //
#define IMAGE_SCN_ALIGN_2BYTES               0x00200000  //
#define IMAGE_SCN_ALIGN_4BYTES               0x00300000  //
#define IMAGE_SCN_ALIGN_8BYTES               0x00400000  //
#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  // Default alignment if no others are specified.
#define IMAGE_SCN_ALIGN_32BYTES              0x00600000  //
#define IMAGE_SCN_ALIGN_64BYTES              0x00700000  //

#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.

//
// Symbol format.
//

typedef struct _IMAGE_SYMBOL {
    union {
        UCHAR   ShortName[8];
        struct {
            ULONG   Short;     // if 0, use LongName
            ULONG   Long;      // offset into string table
        } Name;
        PUCHAR  LongName[2];
    } N;
    ULONG   Value;
    SHORT   SectionNumber;
    USHORT  Type;
    UCHAR   StorageClass;
    UCHAR   NumberOfAuxSymbols;
} IMAGE_SYMBOL;
typedef IMAGE_SYMBOL UNALIGNED *PIMAGE_SYMBOL;

#define IMAGE_SIZEOF_SYMBOL                  18

//
// Section values.
//
// Symbols have a section number of the section in which they are
// defined. Otherwise, section numbers have the following meanings:
//

#define IMAGE_SYM_UNDEFINED           (SHORT)0           // Symbol is undefined or is common.
#define IMAGE_SYM_ABSOLUTE            (SHORT)-1          // Symbol is an absolute value.
#define IMAGE_SYM_DEBUG               (SHORT)-2          // Symbol is a special debug item.

//
// Type (fundamental) values.
//

#define IMAGE_SYM_TYPE_NULL                  0           // no type.
#define IMAGE_SYM_TYPE_VOID                  1           //
#define IMAGE_SYM_TYPE_CHAR                  2           // type character.
#define IMAGE_SYM_TYPE_SHORT                 3           // type short integer.
#define IMAGE_SYM_TYPE_INT                   4           //
#define IMAGE_SYM_TYPE_LONG                  5           //
#define IMAGE_SYM_TYPE_FLOAT                 6           //
#define IMAGE_SYM_TYPE_DOUBLE                7           //
#define IMAGE_SYM_TYPE_STRUCT                8           //
#define IMAGE_SYM_TYPE_UNION                 9           //
#define IMAGE_SYM_TYPE_ENUM                  10          // enumeration.
#define IMAGE_SYM_TYPE_MOE                   11          // member of enumeration.
#define IMAGE_SYM_TYPE_UCHAR                 12          //
#define IMAGE_SYM_TYPE_USHORT                13          //
#define IMAGE_SYM_TYPE_UINT                  14          //
#define IMAGE_SYM_TYPE_ULONG                 15          //

//
// Type (derived) values.
//

#define IMAGE_SYM_DTYPE_NULL                 0           // no derived type.
#define IMAGE_SYM_DTYPE_POINTER              1           // pointer.
#define IMAGE_SYM_DTYPE_FUNCTION             2           // function.
#define IMAGE_SYM_DTYPE_ARRAY                3           // array.

//
// Storage classes.
//

#define IMAGE_SYM_CLASS_END_OF_FUNCTION      (UCHAR)-1
#define IMAGE_SYM_CLASS_NULL                 0
#define IMAGE_SYM_CLASS_AUTOMATIC            1
#define IMAGE_SYM_CLASS_EXTERNAL             2
#define IMAGE_SYM_CLASS_STATIC               3
#define IMAGE_SYM_CLASS_REGISTER             4
#define IMAGE_SYM_CLASS_EXTERNAL_DEF         5
#define IMAGE_SYM_CLASS_LABEL                6
#define IMAGE_SYM_CLASS_UNDEFINED_LABEL      7
#define IMAGE_SYM_CLASS_MEMBER_OF_STRUCT     8
#define IMAGE_SYM_CLASS_ARGUMENT             9
#define IMAGE_SYM_CLASS_STRUCT_TAG           10
#define IMAGE_SYM_CLASS_MEMBER_OF_UNION      11
#define IMAGE_SYM_CLASS_UNION_TAG            12
#define IMAGE_SYM_CLASS_TYPE_DEFINITION      13
#define IMAGE_SYM_CLASS_UNDEFINED_STATIC     14
#define IMAGE_SYM_CLASS_ENUM_TAG             15
#define IMAGE_SYM_CLASS_MEMBER_OF_ENUM       16
#define IMAGE_SYM_CLASS_REGISTER_PARAM       17
#define IMAGE_SYM_CLASS_BIT_FIELD            18
#define IMAGE_SYM_CLASS_BLOCK                100
#define IMAGE_SYM_CLASS_FUNCTION             101
#define IMAGE_SYM_CLASS_END_OF_STRUCT        102
#define IMAGE_SYM_CLASS_FILE                 103
// new
#define IMAGE_SYM_CLASS_SECTION              104
#define IMAGE_SYM_CLASS_WEAK_EXTERNAL        105

// type packing constants

#define N_BTMASK                            017
#define N_TMASK                             060
#define N_TMASK1                            0300
#define N_TMASK2                            0360
#define N_BTSHFT                            4
#define N_TSHIFT                            2

// MACROS

// Basic Type of  x
#define BTYPE(x) ((x) & N_BTMASK)

// Is x a pointer?
#ifndef ISPTR
#define ISPTR(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_POINTER << N_BTSHFT))
#endif

// Is x a function?
#ifndef ISFCN
#define ISFCN(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_FUNCTION << N_BTSHFT))
#endif

// Is x an array?

#ifndef ISARY
#define ISARY(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_ARRAY << N_BTSHFT))
#endif

// Is x a structure, union, or enumeration TAG?
#ifndef ISTAG
#define ISTAG(x) ((x)==IMAGE_SYM_CLASS_STRUCT_TAG || (x)==IMAGE_SYM_CLASS_UNION_TAG || (x)==IMAGE_SYM_CLASS_ENUM_TAG)
#endif

#ifndef INCREF
#define INCREF(x) ((((x)&~N_BTMASK)<<N_TSHIFT)|(IMAGE_SYM_DTYPE_POINTER<<N_BTSHFT)|((x)&N_BTMASK))
#endif
#ifndef DECREF
#define DECREF(x) ((((x)>>N_TSHIFT)&~N_BTMASK)|((x)&N_BTMASK))
#endif

//
// Auxiliary entry format.
//

typedef union _IMAGE_AUX_SYMBOL {
    struct {
        ULONG    TagIndex;                      // struct, union, or enum tag index
        union {
            struct {
                USHORT  Linenumber;             // declaration line number
                USHORT  Size;                   // size of struct, union, or enum
            } LnSz;
           ULONG    TotalSize;
        } Misc;
        union {
            struct {                            // if ISFCN, tag, or .bb
                ULONG    PointerToLinenumber;
                ULONG    PointerToNextFunction;
            } Function;
            struct {                            // if ISARY, up to 4 dimen.
                USHORT   Dimension[4];
            } Array;
        } FcnAry;
        USHORT  TvIndex;                        // tv index
    } Sym;
    struct {
        UCHAR   Name[IMAGE_SIZEOF_SYMBOL];
    } File;
    struct {
        ULONG   Length;                         // section length
        USHORT  NumberOfRelocations;            // number of relocation entries
        USHORT  NumberOfLinenumbers;            // number of line numbers
        ULONG   CheckSum;                       // checksum for communal
        SHORT   Number;                         // section number to associate with
        UCHAR   Selection;                      // communal selection type
    } Section;
} IMAGE_AUX_SYMBOL;
typedef IMAGE_AUX_SYMBOL UNALIGNED *PIMAGE_AUX_SYMBOL;

#define IMAGE_SIZEOF_AUX_SYMBOL              18

//
// Communal selection types.
//

#define IMAGE_COMDAT_SELECT_UNKNOWN        0
#define IMAGE_COMDAT_SELECT_NODUPLICATES   1
#define IMAGE_COMDAT_SELECT_ANY            2
#define IMAGE_COMDAT_SELECT_SAME_SIZE      3
#define IMAGE_COMDAT_SELECT_EXACT_MATCH    4
#define IMAGE_COMDAT_SELECT_ASSOCIATIVE    5

#define IMAGE_WEAK_EXTERN_SEARCH_UNKNOWN   0
#define IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY 1
#define IMAGE_WEAK_EXTERN_SEARCH_LIBRARY   2


//
// Relocation format.
//

typedef struct _IMAGE_RELOCATION {
    ULONG   VirtualAddress;
    ULONG   SymbolTableIndex;
    USHORT  Type;
} IMAGE_RELOCATION;
typedef IMAGE_RELOCATION UNALIGNED *PIMAGE_RELOCATION;

#define IMAGE_SIZEOF_RELOCATION              10

//
// I386 relocation types.
//

#define IMAGE_REL_I386_ABSOLUTE              0           // Reference is absolute, no relocation is necessary
#define IMAGE_REL_I386_DIR16                 01          // Direct 16-bit reference to the symbols virtual address
#define IMAGE_REL_I386_REL16                 02          // PC-relative 16-bit reference to the symbols virtual address
#define IMAGE_REL_I386_DIR32                 06          // Direct 32-bit reference to the symbols virtual address
#define IMAGE_REL_I386_DIR32NB               07          // Direct 32-bit reference to the symbols virtual address, base not included
#define IMAGE_REL_I386_SEG12                 011         // Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address
#define IMAGE_REL_I386_SECTION               012
#define IMAGE_REL_I386_SECREL                013
#define IMAGE_REL_I386_REL32                 024         // PC-relative 32-bit reference to the symbols virtual address

//
// MIPS relocation types.
//

#define IMAGE_REL_MIPS_ABSOLUTE              0           // Reference is absolute, no relocation is necessary
#define IMAGE_REL_MIPS_REFHALF               01
#define IMAGE_REL_MIPS_REFWORD               02
#define IMAGE_REL_MIPS_JMPADDR               03
#define IMAGE_REL_MIPS_REFHI                 04
#define IMAGE_REL_MIPS_REFLO                 05
#define IMAGE_REL_MIPS_GPREL                 06
#define IMAGE_REL_MIPS_LITERAL               07
#define IMAGE_REL_MIPS_SECTION               012
#define IMAGE_REL_MIPS_SECREL                013
#define IMAGE_REL_MIPS_REFWORDNB             042
#define IMAGE_REL_MIPS_PAIR                  045

//
// Alpha Relocation types.
//

#define IMAGE_REL_ALPHA_ABSOLUTE             0x0
#define IMAGE_REL_ALPHA_REFLONG              0x1
#define IMAGE_REL_ALPHA_REFQUAD              0x2
#define IMAGE_REL_ALPHA_GPREL32              0x3
#define IMAGE_REL_ALPHA_LITERAL              0x4
#define IMAGE_REL_ALPHA_LITUSE               0x5
#define IMAGE_REL_ALPHA_GPDISP               0x6
#define IMAGE_REL_ALPHA_BRADDR               0x7
#define IMAGE_REL_ALPHA_HINT                 0x8
#define IMAGE_REL_ALPHA_INLINE_REFLONG       0x9
#define IMAGE_REL_ALPHA_REFHI                0xA
#define IMAGE_REL_ALPHA_REFLO                0xB
#define IMAGE_REL_ALPHA_PAIR                 0xC
#define IMAGE_REL_ALPHA_MATCH                0xD
#define IMAGE_REL_ALPHA_SECTION              0xE
#define IMAGE_REL_ALPHA_SECREL               0xF
#define IMAGE_REL_ALPHA_REFLONGNB            0x10

//
// Based relocation format.
//

typedef struct _IMAGE_BASE_RELOCATION {
    ULONG   VirtualAddress;
    ULONG   SizeOfBlock;
//  USHORT  TypeOffset[1];
} IMAGE_BASE_RELOCATION, *PIMAGE_BASE_RELOCATION;

#define IMAGE_SIZEOF_BASE_RELOCATION         8

//
// Based relocation types.
//

#define IMAGE_REL_BASED_ABSOLUTE              0
#define IMAGE_REL_BASED_HIGH                  1
#define IMAGE_REL_BASED_LOW                   2
#define IMAGE_REL_BASED_HIGHLOW               3
#define IMAGE_REL_BASED_HIGHADJ               4
#define IMAGE_REL_BASED_MIPS_JMPADDR          5

//
// Line number format.
//

typedef struct _IMAGE_LINENUMBER {
    union {
        ULONG   SymbolTableIndex;                       // Symbol table index of function name if Linenumber is 0.
        ULONG   VirtualAddress;                         // Virtual address of line number.
    } Type;
    USHORT  Linenumber;                                 // Line number.
} IMAGE_LINENUMBER;
typedef IMAGE_LINENUMBER UNALIGNED *PIMAGE_LINENUMBER;

#define IMAGE_SIZEOF_LINENUMBER              6

//
// Archive format.
//

#define IMAGE_ARCHIVE_START_SIZE             8
#define IMAGE_ARCHIVE_START                  "!<arch>\n"
#define IMAGE_ARCHIVE_END                    "`\n"
#define IMAGE_ARCHIVE_PAD                    "\n"
#define IMAGE_ARCHIVE_LINKER_MEMBER          "/               "
#define IMAGE_ARCHIVE_LONGNAMES_MEMBER       "//              "

typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
    UCHAR    Name[16];                                  // File member name - `/' terminated.
    UCHAR    Date[12];                                  // File member date - decimal.
    UCHAR    UserID[6];                                 // File member user id - decimal.
    UCHAR    GroupID[6];                                // File member group id - decimal.
    UCHAR    Mode[8];                                   // File member mode - octal.
    UCHAR    Size[10];                                  // File member size - decimal.
    UCHAR    EndHeader[2];                              // String to end header.
} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;

#define IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR      60

//
// DLL support.
//

//
// Export Format
//

typedef struct _IMAGE_EXPORT_DIRECTORY {
    ULONG   Characteristics;
    ULONG   TimeDateStamp;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    ULONG   Name;
    ULONG   Base;
    ULONG   NumberOfFunctions;
    ULONG   NumberOfNames;
    PULONG  *AddressOfFunctions;
    PULONG  *AddressOfNames;
    PUSHORT *AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

//
// Import Format
//

typedef struct _IMAGE_IMPORT_BY_NAME {
    USHORT  Hint;
    UCHAR   Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;

typedef struct _IMAGE_THUNK_DATA {
    union {
        PULONG Function;
        ULONG Ordinal;
        PIMAGE_IMPORT_BY_NAME AddressOfData;
    } u1;
} IMAGE_THUNK_DATA, *PIMAGE_THUNK_DATA;

#define IMAGE_ORDINAL_FLAG 0x80000000
#define IMAGE_SNAP_BY_ORDINAL(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG) != 0)
#define IMAGE_ORDINAL(Ordinal) (Ordinal & 0xffff)

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    ULONG   Characteristics;
    ULONG   TimeDateStamp;
    ULONG   ForwarderChain;
    ULONG   Name;
    PIMAGE_THUNK_DATA FirstThunk;
} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;

//
// Thread Local Storage
//

typedef VOID
(NTAPI *PIMAGE_TLS_CALLBACK) (
    PVOID DllHandle,
    ULONG Reason,
    PVOID Reserved
    );

typedef struct _IMAGE_TLS_DIRECTORY {
    ULONG   StartAddressOfRawData;
    ULONG   EndAddressOfRawData;
    PULONG  AddressOfIndex;
    PIMAGE_TLS_CALLBACK *AddressOfCallBacks;
    ULONG   SizeOfZeroFill;
    ULONG   Characteristics;
} IMAGE_TLS_DIRECTORY, *PIMAGE_TLS_DIRECTORY;


//
// Resource Format.
//

//
// Resource directory consists of two counts, following by a variable length
// array of directory entries.  The first count is the number of entries at
// beginning of the array that have actual names associated with each entry.
// The entries are in ascending order, case insensitive strings.  The second
// count is the number of entries that immediately follow the named entries.
// This second count identifies the number of entries that have 31-bit integer
// Ids as their name.  These entries are also sorted in ascending order.
//
// This structure allows fast lookup by either name or number, but for any
// given resource entry only one form of lookup is supported, not both.
// This is consistant with the syntax of the .RC file and the .RES file.
//

typedef struct _IMAGE_RESOURCE_DIRECTORY {
    ULONG   Characteristics;
    ULONG   TimeDateStamp;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  NumberOfNamedEntries;
    USHORT  NumberOfIdEntries;
//  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];
} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;

#define IMAGE_RESOURCE_NAME_IS_STRING        0x80000000
#define IMAGE_RESOURCE_DATA_IS_DIRECTORY     0x80000000

//
// Each directory contains the 32-bit Name of the entry and an offset,
// relative to the beginning of the resource directory of the data associated
// with this directory entry.  If the name of the entry is an actual text
// string instead of an integer Id, then the high order bit of the name field
// is set to one and the low order 31-bits are an offset, relative to the
// beginning of the resource directory of the string, which is of type
// IMAGE_RESOURCE_DIRECTORY_STRING.  Otherwise the high bit is clear and the
// low-order 31-bits are the integer Id that identify this resource directory
// entry. If the directory entry is yet another resource directory (i.e. a
// subdirectory), then the high order bit of the offset field will be
// set to indicate this.  Otherwise the high bit is clear and the offset
// field points to a resource data entry.
//

typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
    ULONG   Name;
    ULONG   OffsetToData;
} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;

//
// For resource directory entries that have actual string names, the Name
// field of the directory entry points to an object of the following type.
// All of these string objects are stored together after the last resource
// directory entry and before the first resource data object.  This minimizes
// the impact of these variable length objects on the alignment of the fixed
// size directory entry objects.
//

typedef struct _IMAGE_RESOURCE_DIRECTORY_STRING {
    USHORT  Length;
    CHAR    NameString[ 1 ];
} IMAGE_RESOURCE_DIRECTORY_STRING, *PIMAGE_RESOURCE_DIRECTORY_STRING;


typedef struct _IMAGE_RESOURCE_DIR_STRING_U {
    USHORT  Length;
    WCHAR   NameString[ 1 ];
} IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;


//
// Each resource data entry describes a leaf node in the resource directory
// tree.  It contains an offset, relative to the beginning of the resource
// directory of the data for the resource, a size field that gives the number
// of bytes of data at that offset, a CodePage that should be used when
// decoding code point values within the resource data.  Typically for new
// applications the code page would be the unicode code page.
//

typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
    ULONG   OffsetToData;
    ULONG   Size;
    ULONG   CodePage;
    ULONG   Reserved;
} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;

//
// Load Configuration Directory Entry
//

typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY {
    ULONG   Characteristics;
    ULONG   TimeDateStamp;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    ULONG   GlobalFlagsClear;
    ULONG   GlobalFlagsSet;
    ULONG   CriticalSectionDefaultTimeout;
    ULONG   DeCommitFreeBlockThreshold;
    ULONG   DeCommitTotalFreeThreshold;
    PVOID   LockPrefixTable;
    ULONG   MaximumAllocationSize;
    ULONG   VirtualMemoryThreshold;
    ULONG   Reserved[ 5 ];
} IMAGE_LOAD_CONFIG_DIRECTORY, *PIMAGE_LOAD_CONFIG_DIRECTORY;


//
// Function table entry format for MIPS/ALPHA images.  Function table is
// pointed to by the IMAGE_DIRECTORY_ENTRY_EXCEPTION directory entry.
// This definition duplicates ones in ntmips.h and ntalpha.h for use
// by portable image file mungers.
//

typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
    ULONG BeginAddress;
    ULONG EndAddress;
    PVOID ExceptionHandler;
    PVOID HandlerData;
    ULONG PrologEndAddress;
} IMAGE_RUNTIME_FUNCTION_ENTRY, *PIMAGE_RUNTIME_FUNCTION_ENTRY;

//
// Debug Format
//

typedef struct _IMAGE_DEBUG_DIRECTORY {
    ULONG   Characteristics;
    ULONG   TimeDateStamp;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    ULONG   Type;
    ULONG   SizeOfData;
    ULONG   AddressOfRawData;
    ULONG   PointerToRawData;
} IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;

#define IMAGE_DEBUG_TYPE_UNKNOWN          0
#define IMAGE_DEBUG_TYPE_COFF             1
#define IMAGE_DEBUG_TYPE_CODEVIEW         2
#define IMAGE_DEBUG_TYPE_FPO              3
#define IMAGE_DEBUG_TYPE_MISC             4
#define IMAGE_DEBUG_TYPE_EXCEPTION        5
#define IMAGE_DEBUG_TYPE_FIXUP            6
#define IMAGE_DEBUG_TYPE_OMAP_TO_SRC      7
#define IMAGE_DEBUG_TYPE_OMAP_FROM_SRC    8

typedef struct _IMAGE_COFF_SYMBOLS_HEADER {
    ULONG   NumberOfSymbols;
    ULONG   LvaToFirstSymbol;
    ULONG   NumberOfLinenumbers;
    ULONG   LvaToFirstLinenumber;
    ULONG   RvaToFirstByteOfCode;
    ULONG   RvaToLastByteOfCode;
    ULONG   RvaToFirstByteOfData;
    ULONG   RvaToLastByteOfData;
} IMAGE_COFF_SYMBOLS_HEADER, *PIMAGE_COFF_SYMBOLS_HEADER;

#define FRAME_FPO   0
#define FRAME_TRAP  1
#define FRAME_TSS   2

typedef struct _FPO_DATA {
    ULONG       ulOffStart;             // offset 1st byte of function code
    ULONG       cbProcSize;             // # bytes in function
    ULONG       cdwLocals;              // # bytes in locals/4
    USHORT      cdwParams;              // # bytes in params/4
    USHORT      cbProlog : 8;           // # bytes in prolog
    USHORT      cbRegs   : 3;           // # regs saved
    USHORT      fHasSEH  : 1;           // TRUE if SEH in func
    USHORT      fUseBP   : 1;           // TRUE if EBP has been allocated
    USHORT      reserved : 1;           // reserved for future use
    USHORT      cbFrame  : 2;           // frame type
} FPO_DATA, *PFPO_DATA;
#define SIZEOF_RFPO_DATA 16


#define IMAGE_DEBUG_MISC_EXENAME    1

typedef struct _IMAGE_DEBUG_MISC {
    ULONG       DataType;               // type of misc data, see defines
    ULONG       Length;                 // total length of record, rounded to four
                                        // byte multiple.
    BOOLEAN     Unicode;                // TRUE if data is unicode string
    UCHAR       Reserved[ 3 ];
    UCHAR       Data[ 1 ];              // Actual data
} IMAGE_DEBUG_MISC, *PIMAGE_DEBUG_MISC;


//
// Debugging information can be stripped from an image file and placed
// in a separate .DBG file, whose file name part is the same as the
// image file name part (e.g. symbols for CMD.EXE could be stripped
// and placed in CMD.DBG).  This is indicated by the IMAGE_FILE_DEBUG_STRIPPED
// flag in the Characteristics field of the file header.  The beginning of
// the .DBG file contains the following structure which captures certain
// information from the image file.  This allows a debug to proceed even if
// the original image file is not accessable.  This header is followed by
// zero of more IMAGE_SECTION_HEADER structures, followed by zero or more
// IMAGE_DEBUG_DIRECTORY structures.  The latter structures and those in
// the image file contain file offsets relative to the beginning of the
// .DBG file.
//
// If symbols have been stripped from an image, the IMAGE_DEBUG_MISC structure
// is left in the image file, but not mapped.  This allows a debugger to
// compute the name of the .DBG file, from the name of the image in the
// IMAGE_DEBUG_MISC structure.
//

typedef struct _IMAGE_SEPARATE_DEBUG_HEADER {
    USHORT      Signature;
    USHORT      Flags;
    USHORT      Machine;
    USHORT      Characteristics;
    ULONG       TimeDateStamp;
    ULONG       CheckSum;
    ULONG       ImageBase;
    ULONG       SizeOfImage;
    ULONG       NumberOfSections;
    ULONG       ExportedNamesSize;
    ULONG       DebugDirectorySize;
    ULONG       Reserved[ 3 ];
} IMAGE_SEPARATE_DEBUG_HEADER, *PIMAGE_SEPARATE_DEBUG_HEADER;

#define IMAGE_SEPARATE_DEBUG_SIGNATURE 0x4944

#ifndef RC_INVOKED
#pragma pack ()
#endif  // !RC_INVOKED

//
// End Image Format
//

// end_winnt

#endif // _NTIMAGE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\mbstring.h ===
/***
* mbstring.h - MBCS string manipulation macros and functions
*
*	Copyright (c) 1990-1995, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains macros and function declarations for the MBCS
*	string manipulation functions.
*
*       [Public]
*
****/

#ifndef _INC_MBSTRING
#define _INC_MBSTRING

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef	_MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif	/* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


#ifndef _NLSCMP_DEFINED
#define _NLSCMPERROR    2147483647	/* currently == INT_MAX */
#define _NLSCMP_DEFINED
#endif


#ifndef _VA_LIST_DEFINED
#ifdef	_M_ALPHA
typedef struct {
	char *a0;	/* pointer to first homed integer argument */
	int offset;	/* byte offset of next parameter */
} va_list;
#else
typedef char *	va_list;
#endif
#define _VA_LIST_DEFINED
#endif

#ifndef _FILE_DEFINED
struct _iobuf {
	char *_ptr;
	int   _cnt;
	char *_base;
	int   _flag;
	int   _file;
	int   _charbuf;
	int   _bufsiz;
	char *_tmpfname;
	};
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif

/*
 * MBCS - Multi-Byte Character Set
 */

#ifndef _MBSTRING_DEFINED

/* function prototypes */

_CRTIMP unsigned int __cdecl _mbbtombc(unsigned int);
_CRTIMP int __cdecl _mbbtype(unsigned char, int);
_CRTIMP unsigned int __cdecl _mbctombb(unsigned int);
_CRTIMP int __cdecl _mbsbtype(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbscat(unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbschr(const unsigned char *, unsigned int);
_CRTIMP int __cdecl _mbscmp(const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _mbscoll(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbscpy(unsigned char *, const unsigned char *);
_CRTIMP size_t __cdecl _mbscspn(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsdec(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsdup(const unsigned char *);
_CRTIMP int __cdecl _mbsicmp(const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _mbsicoll(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsinc(const unsigned char *);
_CRTIMP size_t __cdecl _mbslen(const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbslwr(unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsnbcat(unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbcmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbcoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP size_t __cdecl _mbsnbcnt(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnbcpy(unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbicmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbicoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnbset(unsigned char *, unsigned int, size_t);
_CRTIMP unsigned char * __cdecl _mbsncat(unsigned char *, const unsigned char *, size_t);
_CRTIMP size_t __cdecl _mbsnccnt(const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsncmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsncoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsncpy(unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned int __cdecl _mbsnextc (const unsigned char *);
_CRTIMP int __cdecl _mbsnicmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnicoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsninc(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnset(unsigned char *, unsigned int, size_t);
_CRTIMP unsigned char * __cdecl _mbspbrk(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsrchr(const unsigned char *, unsigned int);
_CRTIMP unsigned char * __cdecl _mbsrev(unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsset(unsigned char *, unsigned int);
_CRTIMP size_t __cdecl _mbsspn(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsspnp(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsstr(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbstok(unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsupr(unsigned char *);

_CRTIMP size_t __cdecl _mbclen(const unsigned char *);
_CRTIMP void __cdecl _mbccpy(unsigned char *, const unsigned char *);
#define _mbccmp(_cpc1, _cpc2) _mbsncmp((_cpc1),(_cpc2),1)

/* character routines */

_CRTIMP int __cdecl _ismbcalnum(unsigned int);
_CRTIMP int __cdecl _ismbcalpha(unsigned int);
_CRTIMP int __cdecl _ismbcdigit(unsigned int);
_CRTIMP int __cdecl _ismbcgraph(unsigned int);
_CRTIMP int __cdecl _ismbclegal(unsigned int);
_CRTIMP int __cdecl _ismbclower(unsigned int);
_CRTIMP int __cdecl _ismbcprint(unsigned int);
_CRTIMP int __cdecl _ismbcpunct(unsigned int);
_CRTIMP int __cdecl _ismbcspace(unsigned int);
_CRTIMP int __cdecl _ismbcupper(unsigned int);

_CRTIMP unsigned int __cdecl _mbctolower(unsigned int);
_CRTIMP unsigned int __cdecl _mbctoupper(unsigned int);

#define _MBSTRING_DEFINED
#endif

#ifndef _MBLEADTRAIL_DEFINED
_CRTIMP int __cdecl _ismbblead( unsigned int );
_CRTIMP int __cdecl _ismbbtrail( unsigned int );
_CRTIMP int __cdecl _ismbslead( const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _ismbstrail( const unsigned char *, const unsigned char *);
#define _MBLEADTRAIL_DEFINED
#endif

/*  Kanji specific prototypes.	*/

_CRTIMP int __cdecl _ismbchira(unsigned int);
_CRTIMP int __cdecl _ismbckata(unsigned int);
_CRTIMP int __cdecl _ismbcsymbol(unsigned int);
_CRTIMP int __cdecl _ismbcl0(unsigned int);
_CRTIMP int __cdecl _ismbcl1(unsigned int);
_CRTIMP int __cdecl _ismbcl2(unsigned int);
_CRTIMP unsigned int __cdecl _mbcjistojms(unsigned int);
_CRTIMP unsigned int __cdecl _mbcjmstojis(unsigned int);
_CRTIMP unsigned int __cdecl _mbctohira(unsigned int);
_CRTIMP unsigned int __cdecl _mbctokata(unsigned int);

#ifdef __cplusplus
}
#endif

#ifdef	_MSC_VER
#pragma pack(pop)
#endif	/* _MSC_VER */

#endif	/* _INC_MBSTRING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\nddesec.h ===
//
//  NDDESEC.H
//  Copyright (c) 1994-1995, Microsoft Corp. All rights reserved.
//

#ifndef          _INC_NDDESEC
#define          _INC_NDDESEC

#define NDDE_SHAREDB_ADD	   (0x00000001)
#define NDDE_SHAREDB_DELETE	   (0x00000002)
#define NDDE_SHAREDB_LIST	   (0x00000004)

#define NDDE_SHAREDB_ADMIN	(NDDE_SHAREDB_ADD |			\
			         NDDE_SHAREDB_DELETE |			\
				 NDDE_SHAREDB_LIST |			\
				 READ_CONTROL |				\
				 WRITE_DAC |				\
				 WRITE_OWNER)

#define NDDE_SHAREDB_OPER	(NDDE_SHAREDB_ADD |			\
			         NDDE_SHAREDB_DELETE |			\
				 NDDE_SHAREDB_LIST)

#define NDDE_SHAREDB_POWER	(NDDE_SHAREDB_ADD |			\
			         NDDE_SHAREDB_DELETE |			\
				 NDDE_SHAREDB_LIST)

#define NDDE_SHAREDB_USER	(NDDE_SHAREDB_ADD |			\
			         NDDE_SHAREDB_DELETE |			\
				 NDDE_SHAREDB_LIST)

#define NDDE_SHAREDB_EVERYONE	(NDDE_SHAREDB_LIST)

#define NDDE_SHARE_READ		   (0x00000001)
#define NDDE_SHARE_WRITE	   (0x00000002)
#define NDDE_SHARE_INITIATE_STATIC (0x00000004)
#define NDDE_SHARE_INITIATE_LINK   (0x00000008)
#define NDDE_SHARE_REQUEST	   (0x00000010)
#define NDDE_SHARE_ADVISE	   (0x00000020)
#define NDDE_SHARE_POKE		   (0x00000040)
#define NDDE_SHARE_EXECUTE	   (0x00000080)
#define NDDE_SHARE_ADD_ITEMS	   (0x00000100)
#define NDDE_SHARE_LIST_ITEMS	   (0x00000200)

#define NDDE_SHARE_GENERIC_READ	(NDDE_SHARE_READ |			\
			         NDDE_SHARE_INITIATE_STATIC |		\
				 NDDE_SHARE_REQUEST |			\
				 NDDE_SHARE_ADVISE |			\
				 NDDE_SHARE_LIST_ITEMS)

#define NDDE_SHARE_GENERIC_WRITE (NDDE_SHARE_INITIATE_STATIC |		\
			          NDDE_SHARE_INITIATE_LINK |		\
				  NDDE_SHARE_POKE |			\
				  DELETE)

#define NDDE_SHARE_GENERIC_EXECUTE (NDDE_SHARE_INITIATE_STATIC |	\
			            NDDE_SHARE_INITIATE_LINK |		\
				    NDDE_SHARE_EXECUTE)

#define NDDE_SHARE_GENERIC_ALL (NDDE_SHARE_READ |			\
				NDDE_SHARE_WRITE |			\
			        NDDE_SHARE_INITIATE_STATIC |		\
			        NDDE_SHARE_INITIATE_LINK |		\
				NDDE_SHARE_REQUEST |			\
				NDDE_SHARE_ADVISE |			\
				NDDE_SHARE_POKE |			\
				NDDE_SHARE_EXECUTE |			\
				NDDE_SHARE_ADD_ITEMS |			\
				NDDE_SHARE_LIST_ITEMS |			\
				DELETE |				\
				READ_CONTROL |				\
				WRITE_DAC |				\
				WRITE_OWNER)


#define NDDE_ITEM_REQUEST	   (0x00000001)
#define NDDE_ITEM_ADVISE	   (0x00000002)
#define NDDE_ITEM_POKE		   (0x00000004)

#define NDDE_ITEM_GENERIC_READ	  (NDDE_ITEM_REQUEST | NDDE_ITEM_ADVISE)
#define NDDE_ITEM_GENERIC_WRITE   (NDDE_ITEM_POKE)
#define NDDE_ITEM_GENERIC_EXECUTE (0)
#define NDDE_ITEM_GENERIC_ALL     (NDDE_ITEM_REQUEST |			\
				   NDDE_ITEM_ADVISE |			\
				   NDDE_ITEM_POKE |			\
				   DELETE |				\
				   READ_CONTROL |			\
				   WRITE_DAC |				\
				   WRITE_OWNER)

#define NDDE_GUI_NONE	  	(0)

#define NDDE_GUI_READ		(NDDE_SHARE_GENERIC_READ)

#define NDDE_GUI_READ_LINK	(NDDE_SHARE_GENERIC_READ |		\
				 NDDE_SHARE_INITIATE_LINK)

#define NDDE_GUI_CHANGE		(NDDE_SHARE_GENERIC_READ |		\
				 NDDE_SHARE_GENERIC_WRITE |		\
				 NDDE_SHARE_GENERIC_EXECUTE)

#define NDDE_GUI_FULL_CONTROL	(NDDE_SHARE_GENERIC_ALL)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\new.h ===
/***
*new.h - declarations and definitions for C++ memory allocation functions
*
*       Copyright (c) 1990-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the declarations for C++ memory allocation functions.
*
*       [Public]
*
****/

#ifndef _INC_NEW
#define _INC_NEW

#ifdef __cplusplus

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif



#include <stdexcpt.h> /* for class exception */

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if     _MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if     _MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else   /* ndef _NTSDK */
/* current definition */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _NTSDK */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* types and structures */

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* default new placement operator */
inline void * operator new( size_t, void * ptr ) { return ptr; }

/* 
 * new mode flag -- when set, makes malloc() behave like new()
 */

_CRTIMP int __cdecl _query_new_mode( void );
_CRTIMP int __cdecl _set_new_mode( int );

#ifndef _PNH_DEFINED
typedef int (__cdecl * _PNH)( size_t );
#define _PNH_DEFINED
#endif

_CRTIMP _PNH __cdecl _query_new_handler( void );
_CRTIMP _PNH __cdecl _set_new_handler( _PNH );


/*
 * ANSI C++ new_handler and set_new_handler:
 *
 * WARNING: set_new_handler is a stub function that is provided to
 * allow compilation of the Standard Template Library (STL).
 *
 * Do NOT use it to register a new handler. Use _set_new_handler instead.
 *
 * However, it can be called to remove the current handler:
 *
 *      set_new_handler(NULL); // calls _set_new_handler(NULL)
 */

#ifndef _ANSI_NH_DEFINED
typedef void (__cdecl * new_handler) ();
#define _ANSI_NH_DEFINED
#endif

_CRTIMP new_handler __cdecl set_new_handler(new_handler);


#endif /* __cplusplus */

#endif /* _INC_NEW */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\ntsdexts.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    ntsdexts.h

Abstract:

    This file contains procedure prototypes and structures
    needed to write NTSD and KD debugger extensions.

Environment:

    runs in the Win32 NTSD debug environment.

Revision History:

--*/

#ifndef _NTSDEXTNS_
#define _NTSDEXTNS_

#ifdef __cplusplus
extern "C" {
#endif

typedef
VOID
(*PNTSD_OUTPUT_ROUTINE)(
    char *,
    ...
    );

typedef
DWORD
(*PNTSD_GET_EXPRESSION)(
    char *
    );

typedef
VOID
(*PNTSD_GET_SYMBOL)(
    LPVOID offset,
    PUCHAR pchBuffer,
    LPDWORD pDisplacement
    );

typedef
DWORD
(*PNTSD_DISASM)(
    LPDWORD lpOffset,
    LPSTR lpBuffer,
    BOOL fShowEfeectiveAddress
    );

typedef
BOOL
(*PNTSD_CHECK_CONTROL_C)(
    VOID
    );

typedef struct _NTSD_EXTENSION_APIS {
    DWORD nSize;
    PNTSD_OUTPUT_ROUTINE lpOutputRoutine;
    PNTSD_GET_EXPRESSION lpGetExpressionRoutine;
    PNTSD_GET_SYMBOL lpGetSymbolRoutine;
    PNTSD_DISASM lpDisasmRoutine;
    PNTSD_CHECK_CONTROL_C lpCheckControlCRoutine;
} NTSD_EXTENSION_APIS, *PNTSD_EXTENSION_APIS;

typedef
VOID
(*PNTSD_EXTENSION_ROUTINE)(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    );

#ifdef __cplusplus
}
#endif


#endif // _NTSDEXTNS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\rpc.h ===
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    rpc.h

Abstract:

    Master include file for RPC applications.

--*/

#ifndef RPC_NO_WINDOWS_H
#include <windows.h>
#endif // RPC_NO_WINDOWS_H

#ifndef __RPC_H__
#define __RPC_H__

#ifdef __cplusplus
extern "C" {
#endif

#define __RPC_WIN32__

#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

typedef void * I_RPC_HANDLE;
typedef long RPC_STATUS;

#define RPC_UNICODE_SUPPORTED
#if   (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define __RPC_FAR
#define __RPC_API  __stdcall
#define __RPC_USER __stdcall
#define __RPC_STUB __stdcall
#define RPC_ENTRY  __stdcall
#else
#define __RPC_FAR
#define __RPC_API
#define __RPC_USER
#define __RPC_STUB
#define RPC_ENTRY
#endif

#ifdef IN
#undef IN
#undef OUT
#undef OPTIONAL
#endif /* IN */

#include <rpcdce.h>
#include <rpcnsi.h>
#include <rpcnterr.h>


#include <excpt.h>
#include <winerror.h>

#define RpcTryExcept \
    __try \
        {

// trystmts

#define RpcExcept(expr) \
        } \
    __except (expr) \
        {

// exceptstmts

#define RpcEndExcept \
        }

#define RpcTryFinally \
    __try \
        {

// trystmts

#define RpcFinally \
        } \
    __finally \
        {

// finallystmts

#define RpcEndFinally \
        }

#define RpcExceptionCode() GetExceptionCode()
#define RpcAbnormalTermination() AbnormalTermination()

RPC_STATUS RPC_ENTRY
RpcImpersonateClient (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcRevertToSelf (
    );

long RPC_ENTRY
I_RpcMapWin32Status (
    IN RPC_STATUS Status
    );

#ifdef __cplusplus
}
#endif

#endif // __RPC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\rpcbase.h ===
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    rpcbase.h

Abstract:

    Basic definitions for OLE

--*/

#ifndef __RPCBASE_H__
#define __RPCBASE_H__

#if   (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define __RPC_FAR
#define __RPC_API  __stdcall
#define __RPC_USER __stdcall
#define __RPC_STUB __stdcall
#define RPC_ENTRY  __stdcall
#else
#define __RPC_FAR
#define __RPC_API
#define __RPC_USER
#define __RPC_STUB
#define RPC_ENTRY
#endif

typedef unsigned char byte;

#endif // __RPCBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\raserror.h ===
/* Copyright (c) 1992-1995, Microsoft Corporation, all rights reserved
**
** raserror.h
** Remote Access external API
** RAS specific error codes
*/

#ifndef _RASERROR_H_
#define _RASERROR_H_


#define RASBASE 600
#define SUCCESS 0


#define PENDING                              (RASBASE+0)
#define ERROR_INVALID_PORT_HANDLE            (RASBASE+1)
#define ERROR_PORT_ALREADY_OPEN              (RASBASE+2)
#define ERROR_BUFFER_TOO_SMALL               (RASBASE+3)
#define ERROR_WRONG_INFO_SPECIFIED           (RASBASE+4)
#define ERROR_CANNOT_SET_PORT_INFO           (RASBASE+5)
#define ERROR_PORT_NOT_CONNECTED             (RASBASE+6)
#define ERROR_EVENT_INVALID                  (RASBASE+7)
#define ERROR_DEVICE_DOES_NOT_EXIST          (RASBASE+8)
#define ERROR_DEVICETYPE_DOES_NOT_EXIST      (RASBASE+9)
#define ERROR_BUFFER_INVALID                 (RASBASE+10)
#define ERROR_ROUTE_NOT_AVAILABLE            (RASBASE+11)
#define ERROR_ROUTE_NOT_ALLOCATED            (RASBASE+12)
#define ERROR_INVALID_COMPRESSION_SPECIFIED  (RASBASE+13)
#define ERROR_OUT_OF_BUFFERS                 (RASBASE+14)
#define ERROR_PORT_NOT_FOUND                 (RASBASE+15)
#define ERROR_ASYNC_REQUEST_PENDING          (RASBASE+16)
#define ERROR_ALREADY_DISCONNECTING          (RASBASE+17)
#define ERROR_PORT_NOT_OPEN                  (RASBASE+18)
#define ERROR_PORT_DISCONNECTED              (RASBASE+19)
#define ERROR_NO_ENDPOINTS                   (RASBASE+20)
#define ERROR_CANNOT_OPEN_PHONEBOOK          (RASBASE+21)
#define ERROR_CANNOT_LOAD_PHONEBOOK          (RASBASE+22)
#define ERROR_CANNOT_FIND_PHONEBOOK_ENTRY    (RASBASE+23)
#define ERROR_CANNOT_WRITE_PHONEBOOK         (RASBASE+24)
#define ERROR_CORRUPT_PHONEBOOK              (RASBASE+25)
#define ERROR_CANNOT_LOAD_STRING             (RASBASE+26)
#define ERROR_KEY_NOT_FOUND                  (RASBASE+27)
#define ERROR_DISCONNECTION                  (RASBASE+28)
#define ERROR_REMOTE_DISCONNECTION           (RASBASE+29)
#define ERROR_HARDWARE_FAILURE               (RASBASE+30)
#define ERROR_USER_DISCONNECTION             (RASBASE+31)
#define ERROR_INVALID_SIZE                   (RASBASE+32)
#define ERROR_PORT_NOT_AVAILABLE             (RASBASE+33)
#define ERROR_CANNOT_PROJECT_CLIENT          (RASBASE+34)
#define ERROR_UNKNOWN                        (RASBASE+35)
#define ERROR_WRONG_DEVICE_ATTACHED          (RASBASE+36)
#define ERROR_BAD_STRING                     (RASBASE+37)
#define ERROR_REQUEST_TIMEOUT                (RASBASE+38)
#define ERROR_CANNOT_GET_LANA                (RASBASE+39)
#define ERROR_NETBIOS_ERROR                  (RASBASE+40)
#define ERROR_SERVER_OUT_OF_RESOURCES        (RASBASE+41)
#define ERROR_NAME_EXISTS_ON_NET             (RASBASE+42)
#define ERROR_SERVER_GENERAL_NET_FAILURE     (RASBASE+43)
#define WARNING_MSG_ALIAS_NOT_ADDED          (RASBASE+44)
#define ERROR_AUTH_INTERNAL                  (RASBASE+45)
#define ERROR_RESTRICTED_LOGON_HOURS         (RASBASE+46)
#define ERROR_ACCT_DISABLED                  (RASBASE+47)
#define ERROR_PASSWD_EXPIRED                 (RASBASE+48)
#define ERROR_NO_DIALIN_PERMISSION           (RASBASE+49)
#define ERROR_SERVER_NOT_RESPONDING          (RASBASE+50)
#define ERROR_FROM_DEVICE                    (RASBASE+51)
#define ERROR_UNRECOGNIZED_RESPONSE          (RASBASE+52)
#define ERROR_MACRO_NOT_FOUND                (RASBASE+53)
#define ERROR_MACRO_NOT_DEFINED              (RASBASE+54)
#define ERROR_MESSAGE_MACRO_NOT_FOUND        (RASBASE+55)
#define ERROR_DEFAULTOFF_MACRO_NOT_FOUND     (RASBASE+56)
#define ERROR_FILE_COULD_NOT_BE_OPENED       (RASBASE+57)
#define ERROR_DEVICENAME_TOO_LONG            (RASBASE+58)
#define ERROR_DEVICENAME_NOT_FOUND           (RASBASE+59)
#define ERROR_NO_RESPONSES                   (RASBASE+60)
#define ERROR_NO_COMMAND_FOUND               (RASBASE+61)
#define ERROR_WRONG_KEY_SPECIFIED            (RASBASE+62)
#define ERROR_UNKNOWN_DEVICE_TYPE            (RASBASE+63)
#define ERROR_ALLOCATING_MEMORY              (RASBASE+64)
#define ERROR_PORT_NOT_CONFIGURED            (RASBASE+65)
#define ERROR_DEVICE_NOT_READY               (RASBASE+66)
#define ERROR_READING_INI_FILE               (RASBASE+67)
#define ERROR_NO_CONNECTION                  (RASBASE+68)
#define ERROR_BAD_USAGE_IN_INI_FILE          (RASBASE+69)
#define ERROR_READING_SECTIONNAME            (RASBASE+70)
#define ERROR_READING_DEVICETYPE             (RASBASE+71)
#define ERROR_READING_DEVICENAME             (RASBASE+72)
#define ERROR_READING_USAGE                  (RASBASE+73)
#define ERROR_READING_MAXCONNECTBPS          (RASBASE+74)
#define ERROR_READING_MAXCARRIERBPS          (RASBASE+75)
#define ERROR_LINE_BUSY                      (RASBASE+76)
#define ERROR_VOICE_ANSWER                   (RASBASE+77)
#define ERROR_NO_ANSWER                      (RASBASE+78)
#define ERROR_NO_CARRIER                     (RASBASE+79)
#define ERROR_NO_DIALTONE                    (RASBASE+80)
#define ERROR_IN_COMMAND                     (RASBASE+81)
#define ERROR_WRITING_SECTIONNAME            (RASBASE+82)
#define ERROR_WRITING_DEVICETYPE             (RASBASE+83)
#define ERROR_WRITING_DEVICENAME             (RASBASE+84)
#define ERROR_WRITING_MAXCONNECTBPS          (RASBASE+85)
#define ERROR_WRITING_MAXCARRIERBPS          (RASBASE+86)
#define ERROR_WRITING_USAGE                  (RASBASE+87)
#define ERROR_WRITING_DEFAULTOFF             (RASBASE+88)
#define ERROR_READING_DEFAULTOFF             (RASBASE+89)
#define ERROR_EMPTY_INI_FILE                 (RASBASE+90)
#define ERROR_AUTHENTICATION_FAILURE         (RASBASE+91)
#define ERROR_PORT_OR_DEVICE                 (RASBASE+92)
#define ERROR_NOT_BINARY_MACRO               (RASBASE+93)
#define ERROR_DCB_NOT_FOUND                  (RASBASE+94)
#define ERROR_STATE_MACHINES_NOT_STARTED     (RASBASE+95)
#define ERROR_STATE_MACHINES_ALREADY_STARTED (RASBASE+96)
#define ERROR_PARTIAL_RESPONSE_LOOPING       (RASBASE+97)
#define ERROR_UNKNOWN_RESPONSE_KEY           (RASBASE+98)
#define ERROR_RECV_BUF_FULL                  (RASBASE+99)
#define ERROR_CMD_TOO_LONG                   (RASBASE+100)
#define ERROR_UNSUPPORTED_BPS                (RASBASE+101)
#define ERROR_UNEXPECTED_RESPONSE            (RASBASE+102)
#define ERROR_INTERACTIVE_MODE               (RASBASE+103)
#define ERROR_BAD_CALLBACK_NUMBER            (RASBASE+104)
#define ERROR_INVALID_AUTH_STATE             (RASBASE+105)
#define ERROR_WRITING_INITBPS                (RASBASE+106)
#define ERROR_X25_DIAGNOSTIC                 (RASBASE+107)
#define ERROR_ACCT_EXPIRED                   (RASBASE+108)
#define ERROR_CHANGING_PASSWORD              (RASBASE+109)
#define ERROR_OVERRUN                        (RASBASE+110)
#define ERROR_RASMAN_CANNOT_INITIALIZE	     (RASBASE+111)
#define ERROR_BIPLEX_PORT_NOT_AVAILABLE      (RASBASE+112)
#define ERROR_NO_ACTIVE_ISDN_LINES           (RASBASE+113)
#define ERROR_NO_ISDN_CHANNELS_AVAILABLE     (RASBASE+114)
#define ERROR_TOO_MANY_LINE_ERRORS           (RASBASE+115)
#define ERROR_IP_CONFIGURATION               (RASBASE+116)
#define ERROR_NO_IP_ADDRESSES                (RASBASE+117)
#define ERROR_PPP_TIMEOUT                    (RASBASE+118)
#define ERROR_PPP_REMOTE_TERMINATED          (RASBASE+119)
#define ERROR_PPP_NO_PROTOCOLS_CONFIGURED    (RASBASE+120)
#define ERROR_PPP_NO_RESPONSE                (RASBASE+121)
#define ERROR_PPP_INVALID_PACKET             (RASBASE+122)
#define ERROR_PHONE_NUMBER_TOO_LONG          (RASBASE+123)
#define ERROR_IPXCP_NO_DIALOUT_CONFIGURED    (RASBASE+124)
#define ERROR_IPXCP_NO_DIALIN_CONFIGURED     (RASBASE+125)
#define ERROR_IPXCP_DIALOUT_ALREADY_ACTIVE   (RASBASE+126)
#define ERROR_ACCESSING_TCPCFGDLL            (RASBASE+127)
#define ERROR_NO_IP_RAS_ADAPTER              (RASBASE+128)
#define ERROR_SLIP_REQUIRES_IP               (RASBASE+129)
#define ERROR_PROJECTION_NOT_COMPLETE        (RASBASE+130)
#define ERROR_PROTOCOL_NOT_CONFIGURED        (RASBASE+131)
#define ERROR_PPP_NOT_CONVERGING             (RASBASE+132)
#define ERROR_PPP_CP_REJECTED                (RASBASE+133)
#define ERROR_PPP_LCP_TERMINATED             (RASBASE+134)
#define ERROR_PPP_REQUIRED_ADDRESS_REJECTED  (RASBASE+135)
#define ERROR_PPP_NCP_TERMINATED             (RASBASE+136)
#define ERROR_PPP_LOOPBACK_DETECTED          (RASBASE+137)
#define ERROR_PPP_NO_ADDRESS_ASSIGNED        (RASBASE+138)
#define ERROR_CANNOT_USE_LOGON_CREDENTIALS   (RASBASE+139)
#define ERROR_TAPI_CONFIGURATION             (RASBASE+140)
#define ERROR_NO_LOCAL_ENCRYPTION            (RASBASE+141)
#define ERROR_NO_REMOTE_ENCRYPTION           (RASBASE+142)
#define ERROR_REMOTE_REQUIRES_ENCRYPTION     (RASBASE+143)
#define ERROR_IPXCP_NET_NUMBER_CONFLICT      (RASBASE+144)
#define ERROR_INVALID_SMM                    (RASBASE+145)
#define ERROR_SMM_UNINITIALIZED              (RASBASE+146)
#define ERROR_NO_MAC_FOR_PORT                (RASBASE+147)
#define ERROR_SMM_TIMEOUT                    (RASBASE+148)
#define ERROR_BAD_PHONE_NUMBER               (RASBASE+149)
#define ERROR_WRONG_MODULE                   (RASBASE+150)

#define RASBASEEND                           (RASBASE+150)


#endif // _RASERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\ole.h ===
/*****************************************************************************\
*                                                                             *
* ole.h -       Object Linking and Embedding functions, types, and definitions*
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1990-1995, Microsoft Corp.  All rights reserved.*
*                                                                             *
\*****************************************************************************/

#ifndef _INC_OLE
#define _INC_OLE

#ifdef WIN16
#include <pshpack1.h>   /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef WINAPI          /* If not included with 3.1 headers... */
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define LPCSTR      LPSTR
#define LRESULT     LONG
#define HGLOBAL     HANDLE
#endif  /* _INC_WINDOWS */


#ifdef STRICT
#define OLE_LPCSTR  LPCSTR
#define OLE_CONST   const
#else   /* STRICT */
#define OLE_LPCSTR  LPSTR
#define OLE_CONST
#endif /* !STRICT */

#define LRESULT     LONG
#define HGLOBAL     HANDLE


/* Object types */
#define OT_LINK             1L
#define OT_EMBEDDED         2L
#define OT_STATIC           3L

/* activate verbs */
#define OLEVERB_PRIMARY     0

/* target device info structure */
typedef struct _OLETARGETDEVICE
{
    USHORT otdDeviceNameOffset;
    USHORT otdDriverNameOffset;
    USHORT otdPortNameOffset;
    USHORT otdExtDevmodeOffset;
    USHORT otdExtDevmodeSize;
    USHORT otdEnvironmentOffset;
    USHORT otdEnvironmentSize;
    BYTE otdData[1];
} OLETARGETDEVICE;
typedef OLETARGETDEVICE FAR* LPOLETARGETDEVICE;

/* flags used in some methods */
#define OF_SET              0x0001
#define OF_GET              0x0002
#define OF_HANDLER          0x0004

/* return codes for OLE functions */
typedef enum
{
    OLE_OK,                     /* 0   Function operated correctly             */

    OLE_WAIT_FOR_RELEASE,       /* 1   Command has been initiated, client      */
                                /*     must wait for release. keep dispatching */
                                /*     messages till OLE_RELESE in callback    */

    OLE_BUSY,                   /* 2   Tried to execute a method while another */
                                /*     method is in progress.                  */

    OLE_ERROR_PROTECT_ONLY,     /* 3   Ole APIs are called in real mode        */
    OLE_ERROR_MEMORY,           /* 4   Could not alloc or lock memory          */
    OLE_ERROR_STREAM,           /* 5  (OLESTREAM) stream error                 */
    OLE_ERROR_STATIC,           /* 6   Non static object expected              */
    OLE_ERROR_BLANK,            /* 7   Critical data missing                   */
    OLE_ERROR_DRAW,             /* 8   Error while drawing                     */
    OLE_ERROR_METAFILE,         /* 9   Invalid metafile                        */
    OLE_ERROR_ABORT,            /* 10  Client chose to abort metafile drawing  */
    OLE_ERROR_CLIPBOARD,        /* 11  Failed to get/set clipboard data        */
    OLE_ERROR_FORMAT,           /* 12  Requested format is not available       */
    OLE_ERROR_OBJECT,           /* 13  Not a valid object                      */
    OLE_ERROR_OPTION,           /* 14  Invalid option(link update / render)    */
    OLE_ERROR_PROTOCOL,         /* 15  Invalid protocol                        */
    OLE_ERROR_ADDRESS,          /* 16  One of the pointers is invalid          */
    OLE_ERROR_NOT_EQUAL,        /* 17  Objects are not equal                   */
    OLE_ERROR_HANDLE,           /* 18  Invalid handle encountered              */
    OLE_ERROR_GENERIC,          /* 19  Some general error                      */
    OLE_ERROR_CLASS,            /* 20  Invalid class                           */
    OLE_ERROR_SYNTAX,           /* 21  Command syntax is invalid               */
    OLE_ERROR_DATATYPE,         /* 22  Data format is not supported            */
    OLE_ERROR_PALETTE,          /* 23  Invalid color palette                   */
    OLE_ERROR_NOT_LINK,         /* 24  Not a linked object                     */
    OLE_ERROR_NOT_EMPTY,        /* 25  Client doc contains objects.            */
    OLE_ERROR_SIZE,             /* 26  Incorrect buffer size passed to the api */
                                /*     that places some string in caller's     */
                                /*     buffer                                  */

    OLE_ERROR_DRIVE,            /* 27  Drive letter in doc name is invalid     */
    OLE_ERROR_NETWORK,          /* 28  Failed to establish connection to a     */
                                /*     network share on which the document     */
                                /*     is located                              */

    OLE_ERROR_NAME,             /* 29  Invalid name(doc name, object name),    */
                                /*     etc.. passed to the APIs                */

    OLE_ERROR_TEMPLATE,         /* 30  Server failed to load template          */
    OLE_ERROR_NEW,              /* 31  Server failed to create new doc         */
    OLE_ERROR_EDIT,             /* 32  Server failed to create embedded        */
                                /*     instance                                */
    OLE_ERROR_OPEN,             /* 33  Server failed to open document,         */
                                /*     possible invalid link                   */

    OLE_ERROR_NOT_OPEN,         /* 34  Object is not open for editing          */
    OLE_ERROR_LAUNCH,           /* 35  Failed to launch server                 */
    OLE_ERROR_COMM,             /* 36  Failed to communicate with server       */
    OLE_ERROR_TERMINATE,        /* 37  Error in termination                    */
    OLE_ERROR_COMMAND,          /* 38  Error in execute                        */
    OLE_ERROR_SHOW,             /* 39  Error in show                           */
    OLE_ERROR_DOVERB,           /* 40  Error in sending do verb, or invalid    */
                                /*     verb                                    */
    OLE_ERROR_ADVISE_NATIVE,    /* 41  Item could be missing                   */
    OLE_ERROR_ADVISE_PICT,      /* 42  Item could be missing or server doesn't */
                                /*     this format.                            */

    OLE_ERROR_ADVISE_RENAME,    /* 43  Server doesn't support rename           */
    OLE_ERROR_POKE_NATIVE,      /* 44  Failure of poking native data to server */
    OLE_ERROR_REQUEST_NATIVE,   /* 45  Server failed to render native data     */
    OLE_ERROR_REQUEST_PICT,     /* 46  Server failed to render presentation    */
                                /*     data                                    */
    OLE_ERROR_SERVER_BLOCKED,   /* 47  Trying to block a blocked server or     */
                                /*     trying to revoke a blocked server       */
                                /*     or document                             */

    OLE_ERROR_REGISTRATION,     /* 48  Server is not registered in regestation */
                                /*     data base                               */
    OLE_ERROR_ALREADY_REGISTERED,/*49  Trying to register same doc multiple    */
                                 /*    times                                   */
    OLE_ERROR_TASK,             /* 50  Server or client task is invalid        */
    OLE_ERROR_OUTOFDATE,        /* 51  Object is out of date                   */
    OLE_ERROR_CANT_UPDATE_CLIENT,/* 52 Embed doc's client doesn't accept       */
                                /*     updates                                 */
    OLE_ERROR_UPDATE,           /* 53  erorr while trying to update            */
    OLE_ERROR_SETDATA_FORMAT,   /* 54  Server app doesn't understand the       */
                                /*     format given to its SetData method      */
    OLE_ERROR_STATIC_FROM_OTHER_OS,/* 55 trying to load a static object created */
                                   /*    on another Operating System           */
    OLE_ERROR_FILE_VER,

    /*  Following are warnings */
    OLE_WARN_DELETE_DATA = 1000 /*     Caller must delete the data when he is  */
                                /*     done with it.                           */
} OLESTATUS;



/* Codes for CallBack events */
typedef enum
{
    OLE_CHANGED,            /* 0                                             */
    OLE_SAVED,              /* 1                                             */
    OLE_CLOSED,             /* 2                                             */
    OLE_RENAMED,            /* 3                                             */
    OLE_QUERY_PAINT,        /* 4  Interruptible paint support                */
    OLE_RELEASE,            /* 5  Object is released(asynchronous operation  */
                            /*    is completed)                              */
    OLE_QUERY_RETRY        /* 6  Query for retry when server sends busy ACK */
} OLE_NOTIFICATION;

typedef enum
{
    OLE_NONE,               /* 0  no method active                           */
    OLE_DELETE,             /* 1  object delete                              */
    OLE_LNKPASTE,           /* 2  PasteLink(auto reconnect)                  */
    OLE_EMBPASTE,           /* 3  paste(and update)                          */
    OLE_SHOW,               /* 4  Show                                       */
    OLE_RUN,                /* 5  Run                                        */
    OLE_ACTIVATE,           /* 6  Activate                                   */
    OLE_UPDATE,             /* 7  Update                                     */
    OLE_CLOSE,              /* 8  Close                                      */
    OLE_RECONNECT,          /* 9  Reconnect                                  */
    OLE_SETUPDATEOPTIONS,   /* 10 setting update options                     */
    OLE_SERVERUNLAUNCH,     /* 11 server is being unlaunched                 */
    OLE_LOADFROMSTREAM,     /* 12 LoadFromStream(auto reconnect)             */
    OLE_SETDATA,            /* 13 OleSetData                                 */
    OLE_REQUESTDATA,        /* 14 OleRequestData                             */
    OLE_OTHER,              /* 15 other misc async operations                */
    OLE_CREATE,             /* 16 create                                     */
    OLE_CREATEFROMTEMPLATE, /* 17 CreatefromTemplate                         */
    OLE_CREATELINKFROMFILE, /* 18 CreateLinkFromFile                         */
    OLE_COPYFROMLNK,        /* 19 CopyFromLink(auto reconnect)               */
    OLE_CREATEFROMFILE,     /* 20 CreateFromFile                             */
    OLE_CREATEINVISIBLE     /* 21 CreateInvisible                            */
} OLE_RELEASE_METHOD;

/* rendering options */
typedef enum
{
    olerender_none,
    olerender_draw,
    olerender_format
} OLEOPT_RENDER;

/* standard clipboard format type */
typedef WORD OLECLIPFORMAT;

/* Link update options */
typedef enum
{
    oleupdate_always,
    oleupdate_onsave,
#ifdef OLE_INTERNAL
    oleupdate_oncall,
    oleupdate_onclose
#else
    oleupdate_oncall
#endif  /* OLE_INTERNAL */
} OLEOPT_UPDATE;

typedef HANDLE  HOBJECT;
typedef LONG    LHSERVER;
typedef LONG    LHCLIENTDOC;
typedef LONG    LHSERVERDOC;

typedef struct _OLEOBJECT FAR*  LPOLEOBJECT;
typedef struct _OLESTREAM FAR*  LPOLESTREAM;
typedef struct _OLECLIENT FAR*  LPOLECLIENT;


/* object method table definitions. */
typedef struct _OLEOBJECTVTBL
{
    void FAR*      (CALLBACK* QueryProtocol)        (LPOLEOBJECT, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* Release)              (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Show)                 (LPOLEOBJECT, BOOL);
    OLESTATUS      (CALLBACK* DoVerb)               (LPOLEOBJECT, UINT, BOOL, BOOL);
    OLESTATUS      (CALLBACK* GetData)              (LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
    OLESTATUS      (CALLBACK* SetData)              (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
    OLESTATUS      (CALLBACK* SetTargetDevice)      (LPOLEOBJECT, HGLOBAL);
    OLESTATUS      (CALLBACK* SetBounds)            (LPOLEOBJECT, OLE_CONST RECT FAR*);
    OLECLIPFORMAT  (CALLBACK* EnumFormats)          (LPOLEOBJECT, OLECLIPFORMAT);
    OLESTATUS      (CALLBACK* SetColorScheme)       (LPOLEOBJECT, OLE_CONST LOGPALETTE FAR*);
    /* Server has to implement only the above methods. */

#ifndef SERVERONLY
    /* Extra methods required for client. */
    OLESTATUS      (CALLBACK* Delete)               (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* SetHostNames)         (LPOLEOBJECT, OLE_LPCSTR, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* SaveToStream)         (LPOLEOBJECT, LPOLESTREAM);
    OLESTATUS      (CALLBACK* Clone)                (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* CopyFromLink)         (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* Equal)                (LPOLEOBJECT, LPOLEOBJECT);
    OLESTATUS      (CALLBACK* CopyToClipboard)      (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Draw)                 (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
    OLESTATUS      (CALLBACK* Activate)             (LPOLEOBJECT, UINT, BOOL, BOOL, HWND, OLE_CONST RECT FAR*);
    OLESTATUS      (CALLBACK* Execute)              (LPOLEOBJECT, HGLOBAL, UINT);
    OLESTATUS      (CALLBACK* Close)                (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Update)               (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Reconnect)            (LPOLEOBJECT);

    OLESTATUS      (CALLBACK* ObjectConvert)        (LPOLEOBJECT, OLE_LPCSTR, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* GetLinkUpdateOptions) (LPOLEOBJECT, OLEOPT_UPDATE FAR*);
    OLESTATUS      (CALLBACK* SetLinkUpdateOptions) (LPOLEOBJECT, OLEOPT_UPDATE);

    OLESTATUS      (CALLBACK* Rename)               (LPOLEOBJECT, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* QueryName)            (LPOLEOBJECT, LPSTR, UINT FAR*);

    OLESTATUS      (CALLBACK* QueryType)            (LPOLEOBJECT, LONG FAR*);
    OLESTATUS      (CALLBACK* QueryBounds)          (LPOLEOBJECT, RECT FAR*);
    OLESTATUS      (CALLBACK* QuerySize)            (LPOLEOBJECT, DWORD FAR*);
    OLESTATUS      (CALLBACK* QueryOpen)            (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* QueryOutOfDate)       (LPOLEOBJECT);

    OLESTATUS      (CALLBACK* QueryReleaseStatus)   (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* QueryReleaseError)    (LPOLEOBJECT);
    OLE_RELEASE_METHOD (CALLBACK* QueryReleaseMethod)(LPOLEOBJECT);

    OLESTATUS      (CALLBACK* RequestData)          (LPOLEOBJECT, OLECLIPFORMAT);
    OLESTATUS      (CALLBACK* ObjectLong)           (LPOLEOBJECT, UINT, LONG FAR*);

/* This method is internal only */
    OLESTATUS      (CALLBACK* ChangeData)           (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);
#endif  /* !SERVERONLY */
} OLEOBJECTVTBL;
typedef  OLEOBJECTVTBL FAR* LPOLEOBJECTVTBL;

#ifndef OLE_INTERNAL
typedef struct _OLEOBJECT
{
    LPOLEOBJECTVTBL    lpvtbl;
} OLEOBJECT;
#endif

/* ole client definitions */
typedef struct _OLECLIENTVTBL
{
    int (CALLBACK* CallBack)(LPOLECLIENT, OLE_NOTIFICATION, LPOLEOBJECT);
} OLECLIENTVTBL;

typedef  OLECLIENTVTBL FAR*  LPOLECLIENTVTBL;

typedef struct _OLECLIENT
{
    LPOLECLIENTVTBL   lpvtbl;
} OLECLIENT;

/* Stream definitions */
typedef struct _OLESTREAMVTBL
{
    DWORD (CALLBACK* Get)(LPOLESTREAM, void FAR*, DWORD);
    DWORD (CALLBACK* Put)(LPOLESTREAM, OLE_CONST void FAR*, DWORD);
} OLESTREAMVTBL;
typedef  OLESTREAMVTBL FAR*  LPOLESTREAMVTBL;

typedef struct _OLESTREAM
{
    LPOLESTREAMVTBL      lpstbl;
} OLESTREAM;

/* Public Function Prototypes */
OLESTATUS   WINAPI  OleDelete(LPOLEOBJECT);
OLESTATUS   WINAPI  OleRelease(LPOLEOBJECT);
OLESTATUS   WINAPI  OleSaveToStream(LPOLEOBJECT, LPOLESTREAM);
OLESTATUS   WINAPI  OleEqual(LPOLEOBJECT, LPOLEOBJECT );
OLESTATUS   WINAPI  OleCopyToClipboard(LPOLEOBJECT);
OLESTATUS   WINAPI  OleSetHostNames(LPOLEOBJECT, LPCSTR, LPCSTR);
OLESTATUS   WINAPI  OleSetTargetDevice(LPOLEOBJECT, HGLOBAL);
OLESTATUS   WINAPI  OleSetBounds(LPOLEOBJECT, const RECT FAR*);
OLESTATUS   WINAPI  OleSetColorScheme(LPOLEOBJECT, const LOGPALETTE FAR*);
OLESTATUS   WINAPI  OleQueryBounds(LPOLEOBJECT, RECT FAR*);
OLESTATUS   WINAPI  OleQuerySize(LPOLEOBJECT, DWORD FAR*);
OLESTATUS   WINAPI  OleDraw(LPOLEOBJECT, HDC, const RECT FAR*, const RECT FAR*, HDC);
OLESTATUS   WINAPI  OleQueryOpen(LPOLEOBJECT);
OLESTATUS   WINAPI  OleActivate(LPOLEOBJECT, UINT, BOOL, BOOL, HWND, const RECT FAR*);
OLESTATUS   WINAPI  OleExecute(LPOLEOBJECT, HGLOBAL, UINT);
OLESTATUS   WINAPI  OleClose(LPOLEOBJECT);
OLESTATUS   WINAPI  OleUpdate(LPOLEOBJECT);
OLESTATUS   WINAPI  OleReconnect(LPOLEOBJECT);
OLESTATUS   WINAPI  OleGetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE FAR*);
OLESTATUS   WINAPI  OleSetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE);
void FAR*   WINAPI  OleQueryProtocol(LPOLEOBJECT, LPCSTR);

/* Routines related to asynchronous operations. */
OLESTATUS   WINAPI  OleQueryReleaseStatus(LPOLEOBJECT);
OLESTATUS   WINAPI  OleQueryReleaseError(LPOLEOBJECT);
OLE_RELEASE_METHOD WINAPI OleQueryReleaseMethod(LPOLEOBJECT);

OLESTATUS   WINAPI  OleQueryType(LPOLEOBJECT, LONG FAR*);

/* LOWORD is major version, HIWORD is minor version */
DWORD       WINAPI  OleQueryClientVersion(void);
DWORD       WINAPI  OleQueryServerVersion(void);

/* Converting to format (as in clipboard): */
OLECLIPFORMAT  WINAPI  OleEnumFormats(LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleGetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
OLESTATUS   WINAPI  OleSetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS   WINAPI  OleQueryOutOfDate(LPOLEOBJECT);
OLESTATUS   WINAPI  OleRequestData(LPOLEOBJECT, OLECLIPFORMAT);

/* Query apis for creation from clipboard */
OLESTATUS   WINAPI  OleQueryLinkFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleQueryCreateFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);

/* Object creation functions */
OLESTATUS   WINAPI  OleCreateFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR,  LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateLinkFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateLinkFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleLoadFromStream(LPOLESTREAM, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleCreate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateInvisible(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);
OLESTATUS   WINAPI  OleCreateFromTemplate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleClone(LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleCopyFromLink(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleObjectConvert(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleRename(LPOLEOBJECT, LPCSTR);
OLESTATUS   WINAPI  OleQueryName(LPOLEOBJECT, LPSTR, UINT FAR*);
OLESTATUS   WINAPI  OleRevokeObject(LPOLECLIENT);
BOOL        WINAPI  OleIsDcMeta(HDC);

/* client document API */
OLESTATUS   WINAPI  OleRegisterClientDoc(LPCSTR, LPCSTR, LONG, LHCLIENTDOC FAR*);
OLESTATUS   WINAPI  OleRevokeClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleRenameClientDoc(LHCLIENTDOC, LPCSTR);
OLESTATUS   WINAPI  OleRevertClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleSavedClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleEnumObjects(LHCLIENTDOC, LPOLEOBJECT FAR*);

/* server usage definitions */
typedef enum {
    OLE_SERVER_MULTI,           /* multiple instances */
    OLE_SERVER_SINGLE           /* single instance(multiple document) */
} OLE_SERVER_USE;

/* Server API */
typedef struct _OLESERVER FAR*  LPOLESERVER;

OLESTATUS   WINAPI  OleRegisterServer(LPCSTR, LPOLESERVER, LHSERVER FAR*, HINSTANCE, OLE_SERVER_USE);
OLESTATUS   WINAPI  OleRevokeServer(LHSERVER);
OLESTATUS   WINAPI  OleBlockServer(LHSERVER);
OLESTATUS   WINAPI  OleUnblockServer(LHSERVER, BOOL FAR*);

/* APIs to keep server open */
OLESTATUS   WINAPI  OleLockServer(LPOLEOBJECT, LHSERVER FAR*);
OLESTATUS   WINAPI  OleUnlockServer(LHSERVER);

/* Server document API */

typedef struct _OLESERVERDOC FAR*  LPOLESERVERDOC;

OLESTATUS   WINAPI  OleRegisterServerDoc(LHSERVER, LPCSTR, LPOLESERVERDOC, LHSERVERDOC FAR*);
OLESTATUS   WINAPI  OleRevokeServerDoc(LHSERVERDOC);
OLESTATUS   WINAPI  OleRenameServerDoc(LHSERVERDOC, LPCSTR);
OLESTATUS   WINAPI  OleRevertServerDoc(LHSERVERDOC);
OLESTATUS   WINAPI  OleSavedServerDoc(LHSERVERDOC);

typedef struct _OLESERVERVTBL
{
    OLESTATUS (CALLBACK* Open)  (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* document name                        */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Create)(LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* CreateFromTemplate)(LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* lp template name                     */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Edit)  (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Exit)  (LPOLESERVER);
                                    /* lp OLESERVER                         */

    OLESTATUS (CALLBACK* Release)  (LPOLESERVER);
                                    /* lp OLESERVER                         */

    OLESTATUS (CALLBACK* Execute)(LPOLESERVER, HGLOBAL);
                                    /* lp OLESERVER                         */
                                    /* handle to command strings            */
} OLESERVERVTBL;
typedef  OLESERVERVTBL FAR*  LPOLESERVERVTBL;

typedef struct _OLESERVER
{
    LPOLESERVERVTBL    lpvtbl;
} OLESERVER;

typedef struct _OLESERVERDOCVTBL
{
    OLESTATUS (CALLBACK* Save)      (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* Close)     (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* SetHostNames)(LPOLESERVERDOC, OLE_LPCSTR, OLE_LPCSTR);
    OLESTATUS (CALLBACK* SetDocDimensions)(LPOLESERVERDOC, OLE_CONST RECT FAR*);
    OLESTATUS (CALLBACK* GetObject) (LPOLESERVERDOC, OLE_LPCSTR, LPOLEOBJECT FAR*, LPOLECLIENT);
    OLESTATUS (CALLBACK* Release)   (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* SetColorScheme)(LPOLESERVERDOC, OLE_CONST LOGPALETTE FAR*);
    OLESTATUS (CALLBACK* Execute)  (LPOLESERVERDOC, HGLOBAL);
} OLESERVERDOCVTBL;
typedef  OLESERVERDOCVTBL FAR*  LPOLESERVERDOCVTBL;

typedef struct _OLESERVERDOC
{
    LPOLESERVERDOCVTBL lpvtbl;
} OLESERVERDOC;

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifdef WIN16
#include <poppack.h>
#endif

#endif  /* !_INC_OLE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\ras.h ===
/* Copyright (c) 1992-1996, Microsoft Corporation, all rights reserved
**
** ras.h
** Remote Access external API
** Public header for external API clients
**
** WINVER values in this file:
**      WINVER < 0x400 = Windows NT 3.5, Windows NT 3.51
**      WINVER = 0x400 = Windows 95, Windows NT SUR (default)
**      WINVER > 0x400 = Windows NT SUR enhancements
*/

#ifndef _RAS_H_
#define _RAS_H_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef UNLEN
#include <lmcons.h>
#endif

#include <pshpack4.h>

#define RAS_MaxDeviceType     16
#define RAS_MaxPhoneNumber    128
#define RAS_MaxIpAddress      15
#define RAS_MaxIpxAddress     21

#if (WINVER >= 0x400)
#define RAS_MaxEntryName      256
#define RAS_MaxDeviceName     128
#define RAS_MaxCallbackNumber RAS_MaxPhoneNumber
#else
#define RAS_MaxEntryName      20
#define RAS_MaxDeviceName     32
#define RAS_MaxCallbackNumber 48
#endif

#define RAS_MaxAreaCode       10
#define RAS_MaxPadType        32
#define RAS_MaxX25Address     200
#define RAS_MaxFacilities     200
#define RAS_MaxUserData       200

DECLARE_HANDLE( HRASCONN );
#define LPHRASCONN HRASCONN*


/* Identifies an active RAS connection.  (See RasEnumConnections)
*/
#define RASCONNW struct tagRASCONNW
RASCONNW
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    WCHAR    szEntryName[ RAS_MaxEntryName + 1 ];

#if (WINVER >= 0x400)
    WCHAR    szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR    szDeviceName[ RAS_MaxDeviceName + 1 ];
#endif
#if (WINVER >= 0x401)
    WCHAR    szPhonebook [ MAX_PATH ];
    DWORD    dwSubEntry;
#endif
};

#define RASCONNA struct tagRASCONNA
RASCONNA
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    CHAR     szEntryName[ RAS_MaxEntryName + 1 ];

#if (WINVER >= 0x400)
    CHAR     szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR     szDeviceName[ RAS_MaxDeviceName + 1 ];
#endif
#if (WINVER >= 0x401)
    CHAR     szPhonebook [ MAX_PATH ];
    DWORD    dwSubEntry;
#endif
};

#ifdef UNICODE
#define RASCONN RASCONNW
#else
#define RASCONN RASCONNA
#endif

#define LPRASCONNW RASCONNW*
#define LPRASCONNA RASCONNA*
#define LPRASCONN  RASCONN*


/* Enumerates intermediate states to a connection.  (See RasDial)
*/
#define RASCS_PAUSED 0x1000
#define RASCS_DONE   0x2000

#define RASCONNSTATE enum tagRASCONNSTATE
RASCONNSTATE
{
    RASCS_OpenPort = 0,
    RASCS_PortOpened,
    RASCS_ConnectDevice,
    RASCS_DeviceConnected,
    RASCS_AllDevicesConnected,
    RASCS_Authenticate,
    RASCS_AuthNotify,
    RASCS_AuthRetry,
    RASCS_AuthCallback,
    RASCS_AuthChangePassword,
    RASCS_AuthProject,
    RASCS_AuthLinkSpeed,
    RASCS_AuthAck,
    RASCS_ReAuthenticate,
    RASCS_Authenticated,
    RASCS_PrepareForCallback,
    RASCS_WaitForModemReset,
    RASCS_WaitForCallback,
    RASCS_Projected,

#if (WINVER >= 0x400)
    RASCS_StartAuthentication,
    RASCS_CallbackComplete,
    RASCS_LogonNetwork,
#endif
    RASCS_SubEntryConnected,
    RASCS_SubEntryDisconnected,

    RASCS_Interactive = RASCS_PAUSED,
    RASCS_RetryAuthentication,
    RASCS_CallbackSetByCaller,
    RASCS_PasswordExpired,

    RASCS_Connected = RASCS_DONE,
    RASCS_Disconnected
};

#define LPRASCONNSTATE RASCONNSTATE*


/* Describes the status of a RAS connection.  (See RasConnectionStatus)
*/
#define RASCONNSTATUSW struct tagRASCONNSTATUSW
RASCONNSTATUSW
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    WCHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
#if (WINVER >= 0x401)
    WCHAR        szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
#endif
};

#define RASCONNSTATUSA struct tagRASCONNSTATUSA
RASCONNSTATUSA
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    CHAR         szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR         szDeviceName[ RAS_MaxDeviceName + 1 ];
#if (WINVER >= 0x401)
    CHAR         szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
#endif
};

#ifdef UNICODE
#define RASCONNSTATUS RASCONNSTATUSW
#else
#define RASCONNSTATUS RASCONNSTATUSA
#endif

#define LPRASCONNSTATUSW RASCONNSTATUSW*
#define LPRASCONNSTATUSA RASCONNSTATUSA*
#define LPRASCONNSTATUS  RASCONNSTATUS*


/* Describes connection establishment parameters.  (See RasDial)
*/
#define RASDIALPARAMSW struct tagRASDIALPARAMSW
RASDIALPARAMSW
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
    WCHAR szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    WCHAR szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
#if (WINVER >= 0x401)
    DWORD dwSubEntry;
    DWORD dwCallbackId;
#endif
};

#define RASDIALPARAMSA struct tagRASDIALPARAMSA
RASDIALPARAMSA
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];
    CHAR  szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    CHAR  szUserName[ UNLEN + 1 ];
    CHAR  szPassword[ PWLEN + 1 ];
    CHAR  szDomain[ DNLEN + 1 ];
#if (WINVER >= 0x401)
    DWORD dwSubEntry;
    DWORD dwCallbackId;
#endif
};

#ifdef UNICODE
#define RASDIALPARAMS RASDIALPARAMSW
#else
#define RASDIALPARAMS RASDIALPARAMSA
#endif

#define LPRASDIALPARAMSW RASDIALPARAMSW*
#define LPRASDIALPARAMSA RASDIALPARAMSA*
#define LPRASDIALPARAMS  RASDIALPARAMS*


/* Describes extended connection establishment options.  (See RasDial)
*/
#define RASDIALEXTENSIONS struct tagRASDIALEXTENSIONS
RASDIALEXTENSIONS
{
    DWORD dwSize;
    DWORD dwfOptions;
    HWND  hwndParent;
    DWORD reserved;
};

#define LPRASDIALEXTENSIONS RASDIALEXTENSIONS*

/* 'dwfOptions' bit flags.
*/
#define RDEOPT_UsePrefixSuffix           0x00000001
#define RDEOPT_PausedStates              0x00000002
#define RDEOPT_IgnoreModemSpeaker        0x00000004
#define RDEOPT_SetModemSpeaker           0x00000008
#define RDEOPT_IgnoreSoftwareCompression 0x00000010
#define RDEOPT_SetSoftwareCompression    0x00000020
#define RDEOPT_DisableConnectedUI        0x00000040
#define RDEOPT_DisableReconnectUI        0x00000080
#define RDEOPT_DisableReconnect          0x00000100
#define RDEOPT_NoUser                    0x00000200
#define RDEOPT_PauseOnScript             0x00000400


/* Describes an enumerated RAS phone book entry name.  (See RasEntryEnum)
*/
#define RASENTRYNAMEW struct tagRASENTRYNAMEW
RASENTRYNAMEW
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
};

#define RASENTRYNAMEA struct tagRASENTRYNAMEA
RASENTRYNAMEA
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];
};

#ifdef UNICODE
#define RASENTRYNAME RASENTRYNAMEW
#else
#define RASENTRYNAME RASENTRYNAMEA
#endif

#define LPRASENTRYNAMEW RASENTRYNAMEW*
#define LPRASENTRYNAMEA RASENTRYNAMEA*
#define LPRASENTRYNAME  RASENTRYNAME*


/* Protocol code to projection data structure mapping.
*/
#define RASPROJECTION enum tagRASPROJECTION
RASPROJECTION
{
    RASP_Amb = 0x10000,
    RASP_PppNbf = 0x803F,
    RASP_PppIpx = 0x802B,
    RASP_PppIp = 0x8021,
#if (WINVER >= 0x40A)
    RASP_PppCcp = 0x80FD,
#endif
    RASP_PppLcp = 0xC021,
    RASP_Slip = 0x20000
};

#define LPRASPROJECTION RASPROJECTION*


/* Describes the result of a RAS AMB (Authentication Message Block)
** projection.  This protocol is used with NT 3.1 and OS/2 1.3 downlevel
** RAS servers.
*/
#define RASAMBW struct tagRASAMBW
RASAMBW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#define RASAMBA struct tagRASAMBA
RASAMBA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#ifdef UNICODE
#define RASAMB RASAMBW
#else
#define RASAMB RASAMBA
#endif

#define LPRASAMBW RASAMBW*
#define LPRASAMBA RASAMBA*
#define LPRASAMB  RASAMB*


/* Describes the result of a PPP NBF (NetBEUI) projection.
*/
#define RASPPPNBFW struct tagRASPPPNBFW
RASPPPNBFW
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwNetBiosError;
    WCHAR szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    WCHAR szWorkstationName[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#define RASPPPNBFA struct tagRASPPPNBFA
RASPPPNBFA
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwNetBiosError;
    CHAR  szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    CHAR  szWorkstationName[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#ifdef UNICODE
#define RASPPPNBF RASPPPNBFW
#else
#define RASPPPNBF RASPPPNBFA
#endif

#define LPRASPPPNBFW RASPPPNBFW*
#define LPRASPPPNBFA RASPPPNBFA*
#define LPRASPPPNBF  RASPPPNBF*


/* Describes the results of a PPP IPX (Internetwork Packet Exchange)
** projection.
*/
#define RASPPPIPXW struct tagRASIPXW
RASPPPIPXW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpxAddress[ RAS_MaxIpxAddress + 1 ];
};


#define RASPPPIPXA struct tagRASPPPIPXA
RASPPPIPXA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpxAddress[ RAS_MaxIpxAddress + 1 ];
};

#ifdef UNICODE
#define RASPPPIPX RASPPPIPXW
#else
#define RASPPPIPX RASPPPIPXA
#endif

#define LPRASPPPIPXW RASPPPIPXW*
#define LPRASPPPIPXA RASPPPIPXA*
#define LPRASPPPIPX  RASPPPIPX*


/* Describes the results of a PPP IP (Internet) projection.
*/
#define RASPPPIPW struct tagRASPPPIPW
RASPPPIPW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpAddress[ RAS_MaxIpAddress + 1 ];

#ifndef WINNT35COMPATIBLE

    /* This field was added between Windows NT 3.51 beta and Windows NT 3.51
    ** final, and between Windows 95 M8 beta and Windows 95 final.  If you do
    ** not require the server address and wish to retrieve PPP IP information
    ** from Windows NT 3.5 or early Windows NT 3.51 betas, or on early Windows
    ** 95 betas, define WINNT35COMPATIBLE.
    **
    ** The server IP address is not provided by all PPP implementations,
    ** though Windows NT server's do provide it.
    */
    WCHAR szServerIpAddress[ RAS_MaxIpAddress + 1 ];

#endif
};

#define RASPPPIPA struct tagRASPPPIPA
RASPPPIPA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpAddress[ RAS_MaxIpAddress + 1 ];

#ifndef WINNT35COMPATIBLE

    /* See RASPPPIPW comment.
    */
    CHAR  szServerIpAddress[ RAS_MaxIpAddress + 1 ];

#endif
};

#ifdef UNICODE
#define RASPPPIP RASPPPIPW
#else
#define RASPPPIP RASPPPIPA
#endif

#define LPRASPPPIPW RASPPPIPW*
#define LPRASPPPIPA RASPPPIPA*
#define LPRASPPPIP  RASPPPIP*


#if (WINVER >= 0x40A)

/* Describes the results of a PPP CCP (Compression Control Protocol) projection.
*/

/* RASPPPCCP 'dwCompressionAlgorithm' values.
*/
#define RASCCPCA_MPPC         0x00000012
#define RASCCPCA_STAC         0x00000011

/* RASPPPCCP 'dwOptions' values.
*/
#define RASCCPO_Compression   0x00000001
#define RASCCPO_Encryption1   0x00000010
#define RASCCPO_Encryption2   0x00000020
#define RASCCPO_Encryption3   0x00000040

#define RASPPPCCPW struct tagRASCCPW
RASPPPCCPW
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwCompressionAlgorithm;
    DWORD dwOptions;
    DWORD dwServerCompressionAlgorithm;
    DWORD dwServerOptions;
};


#define RASPPPCCPA struct tagRASPPPCCPA
RASPPPCCPA
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwCompressionAlgorithm;
    DWORD dwOptions;
    DWORD dwServerCompressionAlgorithm;
    DWORD dwServerOptions;
};

#ifdef UNICODE
#define RASPPPCCP RASPPPCCPW
#else
#define RASPPPCCP RASPPPCCPA
#endif

#define LPRASPPPCCPW RASPPPCCPW*
#define LPRASPPPCCPA RASPPPCCPA*
#define LPRASPPPCCP  RASPPPCCP*


/* Describes the results of a PPP LCP (Link Control Protocol) projection.
*/

/* RASPPPLCP 'dwAuthenticatonProtocol' values.
*/
#define RASLCPAP_PAP          0xC023
#define RASLCPAP_SPAP         0xC027
#define RASLCPAP_SPAP_OLD     0xC123
#define RASLCPAP_CHAP         0xC223
#define RASLCPAP_EAP          0xC227

/* RASPPPLCP 'dwAuthenticatonData' values.
*/
#define RASLCPAD_CHAP_MD5     0x05
#define RASLCPAD_CHAP_MS      0x80

#define RASPPPLCPW struct tagRASLCPW
RASPPPLCPW
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwAuthenticationProtocol;
    DWORD dwAuthenticationData;
    DWORD dwServerAuthenticationProtocol;
    DWORD dwServerAuthenticationData;
    BOOL  fMultilink;
};


#define RASPPPLCPA struct tagRASPPPLCPA
RASPPPLCPA
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwAuthenticationProtocol;
    DWORD dwAuthenticationData;
    DWORD dwServerAuthenticationProtocol;
    DWORD dwServerAuthenticationData;
    BOOL fMultilink;
};

#ifdef UNICODE
#define RASPPPLCP RASPPPLCPW
#else
#define RASPPPLCP RASPPPLCPA
#endif

#define LPRASPPPLCPW RASPPPLCPW*
#define LPRASPPPLCPA RASPPPLCPA*
#define LPRASPPPLCP  RASPPPLCP*

#else
/* Describes the results of a PPP LCP/multi-link negotiation.
*/

#define RASPPPLCP struct tagRASPPPLCP
RASPPPLCP
{
    DWORD dwSize;
    BOOL  fBundled;
};

#define LPRASPPPLCP RASPPPLCP*


#endif








/* Describes the results of a SLIP (Serial Line IP) projection.
*/
#define RASSLIPW struct tagRASSLIPW
RASSLIPW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpAddress[ RAS_MaxIpAddress + 1 ];
};


#define RASSLIPA struct tagRASSLIPA
RASSLIPA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpAddress[ RAS_MaxIpAddress + 1 ];
};

#ifdef UNICODE
#define RASSLIP RASSLIPW
#else
#define RASSLIP RASSLIPA
#endif

#define LPRASSLIPW RASSLIPW*
#define LPRASSLIPA RASSLIPA*
#define LPRASSLIP  RASSLIP*


/* If using RasDial message notifications, get the notification message code
** by passing this string to the RegisterWindowMessageA() API.
** WM_RASDIALEVENT is used only if a unique message cannot be registered.
*/
#define RASDIALEVENT    "RasDialEvent"
#define WM_RASDIALEVENT 0xCCCD

/* Prototypes for caller's RasDial callback handler.  Arguments are the
** message ID (currently always WM_RASDIALEVENT), the current RASCONNSTATE and
** the error that has occurred (or 0 if none).  Extended arguments are the
** handle of the RAS connection and an extended error code.
**
** For RASDIALFUNC2, subsequent callback notifications for all
** subentries can be cancelled by returning FALSE.
*/
typedef VOID (WINAPI *RASDIALFUNC)( UINT, RASCONNSTATE, DWORD );
typedef VOID (WINAPI *RASDIALFUNC1)( HRASCONN, UINT, RASCONNSTATE, DWORD, DWORD );
typedef DWORD (WINAPI *RASDIALFUNC2)( DWORD, DWORD, HRASCONN, UINT, RASCONNSTATE, DWORD, DWORD );


/* Information describing a RAS-capable device.
*/
#define RASDEVINFOW struct tagRASDEVINFOW
RASDEVINFOW
{
    DWORD    dwSize;
    WCHAR    szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR    szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#define RASDEVINFOA struct tagRASDEVINFOA
RASDEVINFOA
{
    DWORD    dwSize;
    CHAR     szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR     szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#ifdef UNICODE
#define RASDEVINFO RASDEVINFOW
#else
#define RASDEVINFO RASDEVINFOA
#endif

#define LPRASDEVINFOW RASDEVINFOW*
#define LPRASDEVINFOA RASDEVINFOA*
#define LPRASDEVINFO  RASDEVINFO*

/* RAS country information (currently retrieved from TAPI).
*/
#define RASCTRYINFO struct RASCTRYINFO
RASCTRYINFO
{
    DWORD   dwSize;
    DWORD   dwCountryID;
    DWORD   dwNextCountryID;
    DWORD   dwCountryCode;
    DWORD   dwCountryNameOffset;
};

/* There is currently no difference between
** RASCTRYINFOA and RASCTRYINFOW.  This may
** change in the future.
*/
#define RASCTRYINFOW   RASCTRYINFO
#define RASCTRYINFOA   RASCTRYINFO

#define LPRASCTRYINFOW RASCTRYINFOW*
#define LPRASCTRYINFOA RASCTRYINFOW*
#define LPRASCTRYINFO  RASCTRYINFO*

/* A RAS IP address.
*/
#define RASIPADDR struct RASIPADDR
RASIPADDR
{
    BYTE a;
    BYTE b;
    BYTE c;
    BYTE d;
};

#define LPRASIPADDR RASIPADDR*

/* A RAS phone book entry.
*/
#define RASENTRYA struct tagRASENTRYA
RASENTRYA
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number.
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    CHAR        szAreaCode[ RAS_MaxAreaCode + 1 ];
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    CHAR        szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    CHAR        szAutodialDll[ MAX_PATH ];
    CHAR        szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    CHAR        szX25PadType[ RAS_MaxPadType + 1 ];
    CHAR        szX25Address[ RAS_MaxX25Address + 1 ];
    CHAR        szX25Facilities[ RAS_MaxFacilities + 1 ];
    CHAR        szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
#if (WINVER >= 0x401)
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
#endif
};

#define RASENTRYW struct tagRASENTRYW
RASENTRYW
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    WCHAR       szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    WCHAR       szAutodialDll[ MAX_PATH ];
    WCHAR       szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
    WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
#if (WINVER >= 0x401)
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
#endif
};

#ifdef UNICODE
#define RASENTRY RASENTRYW
#else
#define RASENTRY RASENTRYA
#endif

#define LPRASENTRYW RASENTRYW*
#define LPRASENTRYA RASENTRYA*
#define LPRASENTRY  RASENTRY*

/* RASENTRY 'dwfOptions' bit flags.
*/
#define RASEO_UseCountryAndAreaCodes    0x00000001
#define RASEO_SpecificIpAddr            0x00000002
#define RASEO_SpecificNameServers       0x00000004
#define RASEO_IpHeaderCompression       0x00000008
#define RASEO_RemoteDefaultGateway      0x00000010
#define RASEO_DisableLcpExtensions      0x00000020
#define RASEO_TerminalBeforeDial        0x00000040
#define RASEO_TerminalAfterDial         0x00000080
#define RASEO_ModemLights               0x00000100
#define RASEO_SwCompression             0x00000200
#define RASEO_RequireEncryptedPw        0x00000400
#define RASEO_RequireMsEncryptedPw      0x00000800
#define RASEO_RequireDataEncryption     0x00001000
#define RASEO_NetworkLogon              0x00002000
#define RASEO_UseLogonCredentials       0x00004000
#define RASEO_PromoteAlternates         0x00008000
#if (WINVER >= 0x401)
#define RASEO_SecureLocalFiles          0x00010000
#endif

/* RASENTRY 'dwProtocols' bit flags.
*/
#define RASNP_NetBEUI                   0x00000001
#define RASNP_Ipx                       0x00000002
#define RASNP_Ip                        0x00000004

/* RASENTRY 'dwFramingProtocols' bit flags.
*/
#define RASFP_Ppp                       0x00000001
#define RASFP_Slip                      0x00000002
#define RASFP_Ras                       0x00000004

/* RASENTRY 'szDeviceType' default strings.
*/
#define RASDT_Modem                     TEXT("modem")
#define RASDT_Isdn                      TEXT("isdn")
#define RASDT_X25                       TEXT("x25")

/* Old AutoDial DLL function prototype.
**
** This prototype is documented for backward-compatibility
** purposes only.  It is superceded by the RASADFUNCA
** and RASADFUNCW definitions below.  DO NOT USE THIS
** PROTOTYPE IN NEW CODE.  SUPPORT FOR IT MAY BE REMOVED
** IN FUTURE VERSIONS OF RAS.
*/
typedef BOOL (WINAPI *ORASADFUNC)( HWND, LPSTR, DWORD, LPDWORD );

#if (WINVER >= 0x401)
/* Flags for RasConnectionNotification().
*/
#define RASCN_Connection        0x00000001
#define RASCN_Disconnection     0x00000002
#define RASCN_BandwidthAdded    0x00000004
#define RASCN_BandwidthRemoved  0x00000008

/* RASENTRY 'dwDialMode' values.
*/
#define RASEDM_DialAll                  1
#define RASEDM_DialAsNeeded             2

/* RASENTRY 'dwIdleDisconnectSeconds' constants.
*/
#define RASIDS_Disabled                 0xffffffff
#define RASIDS_UseGlobalValue           0

/* AutoDial DLL function parameter block.
*/
#define RASADPARAMS struct tagRASADPARAMS
RASADPARAMS
{
    DWORD       dwSize;
    HWND        hwndOwner;
    DWORD       dwFlags;
    LONG        xDlg;
    LONG        yDlg;
};

#define LPRASADPARAMS RASADPARAMS*

/* AutoDial DLL function parameter block 'dwFlags.'
*/
#define RASADFLG_PositionDlg            0x00000001

/* Prototype AutoDial DLL function.
*/
typedef BOOL (WINAPI *RASADFUNCA)( LPSTR, LPSTR, LPRASADPARAMS, LPDWORD );
typedef BOOL (WINAPI *RASADFUNCW)( LPWSTR, LPWSTR, LPRASADPARAMS, LPDWORD );

#ifdef UNICODE
#define RASADFUNC RASADFUNCW
#else
#define RASADFUNC RASADFUNCA
#endif

/* A RAS phone book multilinked sub-entry.
*/
#define RASSUBENTRYA struct tagRASSUBENTRYA
RASSUBENTRYA
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#define RASSUBENTRYW struct tagRASSUBENTRYW
RASSUBENTRYW
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#ifdef UNICODE
#define RASSUBENTRY RASSUBENTRYW
#else
#define RASSUBENTRY RASSUBENTRYA
#endif

#define LPRASSUBENTRYW RASSUBENTRYW*
#define LPRASSUBENTRYA RASSUBENTRYA*
#define LPRASSUBENTRY  RASSUBENTRY*

/* Ras{Get,Set}Credentials structure.  These calls
** supercede Ras{Get,Set}EntryDialParams.
*/
#define RASCREDENTIALSA struct tagRASCREDENTIALSA
RASCREDENTIALSA
{
    DWORD dwSize;
    DWORD dwMask;
    CHAR szUserName[ UNLEN + 1 ];
    CHAR szPassword[ PWLEN + 1 ];
    CHAR szDomain[ DNLEN + 1 ];
};

#define RASCREDENTIALSW struct tagRASCREDENTIALSW
RASCREDENTIALSW
{
    DWORD dwSize;
    DWORD dwMask;
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
};

#ifdef UNICODE
#define RASCREDENTIALS RASCREDENTIALSW
#else
#define RASCREDENTIALS RASCREDENTIALSA
#endif

#define LPRASCREDENTIALSW RASCREDENTIALSW*
#define LPRASCREDENTIALSA RASCREDENTIALSA*
#define LPRASCREDENTIALS  RASCREDENTIALS*

/* RASCREDENTIALS 'dwMask' values.
*/
#define RASCM_UserName       0x00000001
#define RASCM_Password       0x00000002
#define RASCM_Domain         0x00000004

/* AutoDial address properties.
*/
#define RASAUTODIALENTRYA struct tagRASAUTODIALENTRYA
RASAUTODIALENTRYA
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    CHAR szEntry[ RAS_MaxEntryName + 1];
};

#define RASAUTODIALENTRYW struct tagRASAUTODIALENTRYW
RASAUTODIALENTRYW
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    WCHAR szEntry[ RAS_MaxEntryName + 1];
};

#ifdef UNICODE
#define RASAUTODIALENTRY RASAUTODIALENTRYW
#else
#define RASAUTODIALENTRY RASAUTODIALENTRYA
#endif

#define LPRASAUTODIALENTRYW RASAUTODIALENTRYW*
#define LPRASAUTODIALENTRYA RASAUTODIALENTRYA*
#define LPRASAUTODIALENTRY  RASAUTODIALENTRY*

/* AutoDial control parameter values for
** Ras{Get,Set}AutodialParam.
*/
#define RASADP_DisableConnectionQuery           0
#define RASADP_LoginSessionDisable              1
#define RASADP_SavedAddressesLimit              2
#define RASADP_FailedConnectionTimeout          3
#define RASADP_ConnectionQueryTimeout           4

#endif // (WINVER >= 0x401)


/* External RAS API function prototypes.
*/
DWORD APIENTRY RasDialA( LPRASDIALEXTENSIONS, LPSTR, LPRASDIALPARAMSA, DWORD,
                   LPVOID, LPHRASCONN );

DWORD APIENTRY RasDialW( LPRASDIALEXTENSIONS, LPWSTR, LPRASDIALPARAMSW, DWORD,
                   LPVOID, LPHRASCONN );

DWORD APIENTRY RasEnumConnectionsA( LPRASCONNA, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumConnectionsW( LPRASCONNW, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumEntriesA( LPSTR, LPSTR, LPRASENTRYNAMEA, LPDWORD,
                   LPDWORD );

DWORD APIENTRY RasEnumEntriesW( LPWSTR, LPWSTR, LPRASENTRYNAMEW, LPDWORD,
                   LPDWORD );

DWORD APIENTRY RasGetConnectStatusA( HRASCONN, LPRASCONNSTATUSA );

DWORD APIENTRY RasGetConnectStatusW( HRASCONN, LPRASCONNSTATUSW );

DWORD APIENTRY RasGetErrorStringA( UINT, LPSTR, DWORD );

DWORD APIENTRY RasGetErrorStringW( UINT, LPWSTR, DWORD );

DWORD APIENTRY RasHangUpA( HRASCONN );

DWORD APIENTRY RasHangUpW( HRASCONN );

DWORD APIENTRY RasGetProjectionInfoA( HRASCONN, RASPROJECTION, LPVOID,
                   LPDWORD );

DWORD APIENTRY RasGetProjectionInfoW( HRASCONN, RASPROJECTION, LPVOID,
                   LPDWORD );

DWORD APIENTRY RasCreatePhonebookEntryA( HWND, LPSTR );

DWORD APIENTRY RasCreatePhonebookEntryW( HWND, LPWSTR );

DWORD APIENTRY RasEditPhonebookEntryA( HWND, LPSTR, LPSTR );

DWORD APIENTRY RasEditPhonebookEntryW( HWND, LPWSTR, LPWSTR );

DWORD APIENTRY RasSetEntryDialParamsA( LPSTR, LPRASDIALPARAMSA, BOOL );

DWORD APIENTRY RasSetEntryDialParamsW( LPWSTR, LPRASDIALPARAMSW, BOOL );

DWORD APIENTRY RasGetEntryDialParamsA( LPSTR, LPRASDIALPARAMSA, LPBOOL );

DWORD APIENTRY RasGetEntryDialParamsW( LPWSTR, LPRASDIALPARAMSW, LPBOOL );

DWORD APIENTRY RasEnumDevicesA( LPRASDEVINFOA, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumDevicesW( LPRASDEVINFOW, LPDWORD, LPDWORD );

DWORD APIENTRY RasGetCountryInfoA( LPRASCTRYINFOA, LPDWORD );

DWORD APIENTRY RasGetCountryInfoW( LPRASCTRYINFOW, LPDWORD );

DWORD APIENTRY RasGetEntryPropertiesA( LPSTR, LPSTR, LPRASENTRYA, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasGetEntryPropertiesW( LPWSTR, LPWSTR, LPRASENTRYW, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasSetEntryPropertiesA( LPSTR, LPSTR, LPRASENTRYA, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasSetEntryPropertiesW( LPWSTR, LPWSTR, LPRASENTRYW, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasRenameEntryA( LPSTR, LPSTR, LPSTR );

DWORD APIENTRY RasRenameEntryW( LPWSTR, LPWSTR, LPWSTR );

DWORD APIENTRY RasDeleteEntryA( LPSTR, LPSTR );

DWORD APIENTRY RasDeleteEntryW( LPWSTR, LPWSTR );

DWORD APIENTRY RasValidateEntryNameA( LPSTR, LPSTR );

DWORD APIENTRY RasValidateEntryNameW( LPWSTR, LPWSTR );

#if (WINVER >= 0x401)
DWORD APIENTRY RasGetSubEntryHandleA( HRASCONN, DWORD, LPHRASCONN );

DWORD APIENTRY RasGetSubEntryHandleW( HRASCONN, DWORD, LPHRASCONN );

DWORD APIENTRY RasGetCredentialsA( LPSTR, LPSTR, LPRASCREDENTIALSA);

DWORD APIENTRY RasGetCredentialsW( LPWSTR, LPWSTR, LPRASCREDENTIALSW );

DWORD APIENTRY RasSetCredentialsA( LPSTR, LPSTR, LPRASCREDENTIALSA, BOOL );

DWORD APIENTRY RasSetCredentialsW( LPWSTR, LPWSTR, LPRASCREDENTIALSW, BOOL );

DWORD APIENTRY RasConnectionNotificationA( HRASCONN, HANDLE, DWORD );

DWORD APIENTRY RasConnectionNotificationW( HRASCONN, HANDLE, DWORD );

DWORD APIENTRY RasGetSubEntryPropertiesA( LPSTR, LPSTR, DWORD,
                    LPRASSUBENTRYA, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasGetSubEntryPropertiesW( LPWSTR, LPWSTR, DWORD,
                    LPRASSUBENTRYW, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasSetSubEntryPropertiesA( LPSTR, LPSTR, DWORD,
                    LPRASSUBENTRYA, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasSetSubEntryPropertiesW( LPWSTR, LPWSTR, DWORD,
                    LPRASSUBENTRYW, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasDeleteSubEntryA( LPSTR, LPSTR, DWORD );

DWORD APIENTRY RasDeleteSubEntryW( LPWSTR, LPWSTR, DWORD );

DWORD APIENTRY RasGetAutodialAddressA( LPSTR, LPDWORD, LPRASAUTODIALENTRYA,
                    LPDWORD, LPDWORD );

DWORD APIENTRY RasGetAutodialAddressW( LPWSTR, LPDWORD, LPRASAUTODIALENTRYW,
                    LPDWORD, LPDWORD);

DWORD APIENTRY RasSetAutodialAddressA( LPSTR, DWORD, LPRASAUTODIALENTRYA,
                    DWORD, DWORD );

DWORD APIENTRY RasSetAutodialAddressW( LPWSTR, DWORD, LPRASAUTODIALENTRYW,
                    DWORD, DWORD );

DWORD APIENTRY RasEnumAutodialAddressesA( LPSTR *, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumAutodialAddressesW( LPWSTR *, LPDWORD, LPDWORD );

DWORD APIENTRY RasGetAutodialEnableA( DWORD, LPBOOL );

DWORD APIENTRY RasGetAutodialEnableW( DWORD, LPBOOL );

DWORD APIENTRY RasSetAutodialEnableA( DWORD, BOOL );

DWORD APIENTRY RasSetAutodialEnableW( DWORD, BOOL );

DWORD APIENTRY RasGetAutodialParamA( DWORD, LPVOID, LPDWORD );

DWORD APIENTRY RasGetAutodialParamW( DWORD, LPVOID, LPDWORD );

DWORD APIENTRY RasSetAutodialParamA( DWORD, LPVOID, DWORD );

DWORD APIENTRY RasSetAutodialParamW( DWORD, LPVOID, DWORD );
#endif


#ifdef UNICODE
#define RasDial                 RasDialW
#define RasEnumConnections      RasEnumConnectionsW
#define RasEnumEntries          RasEnumEntriesW
#define RasGetConnectStatus     RasGetConnectStatusW
#define RasGetErrorString       RasGetErrorStringW
#define RasHangUp               RasHangUpW
#define RasGetProjectionInfo    RasGetProjectionInfoW
#define RasCreatePhonebookEntry RasCreatePhonebookEntryW
#define RasEditPhonebookEntry   RasEditPhonebookEntryW
#define RasSetEntryDialParams   RasSetEntryDialParamsW
#define RasGetEntryDialParams   RasGetEntryDialParamsW
#define RasEnumDevices          RasEnumDevicesW
#define RasGetCountryInfo       RasGetCountryInfoW
#define RasGetEntryProperties   RasGetEntryPropertiesW
#define RasSetEntryProperties   RasSetEntryPropertiesW
#define RasRenameEntry          RasRenameEntryW
#define RasDeleteEntry          RasDeleteEntryW
#define RasValidateEntryName    RasValidateEntryNameW
#if (WINVER >= 0x401)
#define RasGetSubEntryHandle        RasGetSubEntryHandleW
#define RasConnectionNotification   RasConnectionNotificationW
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesW
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesW
#define RasDeleteSubEntry           RasDeleteSubEntryW
#define RasGetCredentials           RasGetCredentialsW
#define RasSetCredentials           RasSetCredentialsW
#define RasGetAutodialAddress       RasGetAutodialAddressW
#define RasSetAutodialAddress       RasSetAutodialAddressW
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesW
#define RasGetAutodialEnable        RasGetAutodialEnableW
#define RasSetAutodialEnable        RasSetAutodialEnableW
#define RasGetAutodialParam         RasGetAutodialParamW
#define RasSetAutodialParam         RasSetAutodialParamW
#endif
#else
#define RasDial                 RasDialA
#define RasEnumConnections      RasEnumConnectionsA
#define RasEnumEntries          RasEnumEntriesA
#define RasGetConnectStatus     RasGetConnectStatusA
#define RasGetErrorString       RasGetErrorStringA
#define RasHangUp               RasHangUpA
#define RasGetProjectionInfo    RasGetProjectionInfoA
#define RasCreatePhonebookEntry RasCreatePhonebookEntryA
#define RasEditPhonebookEntry   RasEditPhonebookEntryA
#define RasSetEntryDialParams   RasSetEntryDialParamsA
#define RasGetEntryDialParams   RasGetEntryDialParamsA
#define RasEnumDevices          RasEnumDevicesA
#define RasGetCountryInfo       RasGetCountryInfoA
#define RasGetEntryProperties   RasGetEntryPropertiesA
#define RasSetEntryProperties   RasSetEntryPropertiesA
#define RasRenameEntry          RasRenameEntryA
#define RasDeleteEntry          RasDeleteEntryA
#define RasValidateEntryName    RasValidateEntryNameA
#if (WINVER >= 0x401)
#define RasGetSubEntryHandle        RasGetSubEntryHandleA
#define RasConnectionNotification   RasConnectionNotificationA
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesA
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesA
#define RasDeleteSubEntry           RasDeleteSubEntryA
#define RasGetCredentials           RasGetCredentialsA
#define RasSetCredentials           RasSetCredentialsA
#define RasGetAutodialAddress       RasGetAutodialAddressA
#define RasSetAutodialAddress       RasSetAutodialAddressA
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesA
#define RasGetAutodialEnable        RasGetAutodialEnableA
#define RasSetAutodialEnable        RasSetAutodialEnableA
#define RasGetAutodialParam         RasGetAutodialParamA
#define RasSetAutodialParam         RasSetAutodialParamA
#endif
#endif

#ifdef __cplusplus
}
#endif

#include <poppack.h>

#endif // _RAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\ostream.h ===
/***
*ostream.h - definitions/declarations for the ostream class
*
*	Copyright (c) 1991-1995, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the classes, values, macros, and functions
*	used by the ostream class.
*	[AT&T C++]
*
*       [Public]
*
****/

#ifdef __cplusplus

#ifndef _INC_OSTREAM
#define _INC_OSTREAM

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef	_MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)
#endif	// _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


#include <ios.h>

#ifdef	_MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)	// use this to reenable, if desired
#endif	// _MSC_VER

typedef long streamoff, streampos;

class _CRTIMP ostream : virtual public ios {

public:
	ostream(streambuf*);
	virtual ~ostream();

	ostream& flush();
	int  opfx();
	void osfx();

inline	ostream& operator<<(ostream& (__cdecl * _f)(ostream&));
inline	ostream& operator<<(ios& (__cdecl * _f)(ios&));
	ostream& operator<<(const char *);
inline	ostream& operator<<(const unsigned char *);
inline	ostream& operator<<(const signed char *);
inline	ostream& operator<<(char);
	ostream& operator<<(unsigned char);
inline	ostream& operator<<(signed char);
	ostream& operator<<(short);
	ostream& operator<<(unsigned short);
	ostream& operator<<(int);
	ostream& operator<<(unsigned int);
	ostream& operator<<(long);
	ostream& operator<<(unsigned long);
inline	ostream& operator<<(float);
	ostream& operator<<(double);
	ostream& operator<<(long double);
	ostream& operator<<(const void *);
	ostream& operator<<(streambuf*);
inline	ostream& put(char);
	ostream& put(unsigned char);
inline	ostream& put(signed char);
	ostream& write(const char *,int);
inline	ostream& write(const unsigned char *,int);
inline	ostream& write(const signed char *,int);
	ostream& seekp(streampos);
	ostream& seekp(streamoff,ios::seek_dir);
	streampos tellp();

protected:
	ostream();
	ostream(const ostream&);	// treat as private
	ostream& operator=(streambuf*);	// treat as private
	ostream& operator=(const ostream& _os) {return operator=(_os.rdbuf()); }
	int do_opfx(int);		// not used
	void do_osfx();			// not used

private:
	ostream(ios&);
	ostream& writepad(const char *, const char *);
	int x_floatused;
};

inline ostream& ostream::operator<<(ostream& (__cdecl * _f)(ostream&)) { (*_f)(*this); return *this; }
inline ostream& ostream::operator<<(ios& (__cdecl * _f)(ios& )) { (*_f)(*this); return *this; }

inline	ostream& ostream::operator<<(char _c) { return operator<<((unsigned char) _c); }
inline	ostream& ostream::operator<<(signed char _c) { return operator<<((unsigned char) _c); }

inline	ostream& ostream::operator<<(const unsigned char * _s) { return operator<<((const char *) _s); }
inline	ostream& ostream::operator<<(const signed char * _s) { return operator<<((const char *) _s); }

inline	ostream& ostream::operator<<(float _f) { x_floatused = 1; return operator<<((double) _f); }

inline	ostream& ostream::put(char _c) { return put((unsigned char) _c); }
inline	ostream& ostream::put(signed char _c) { return put((unsigned char) _c); }

inline	ostream& ostream::write(const unsigned char * _s, int _n) { return write((char *) _s, _n); }
inline	ostream& ostream::write(const signed char * _s, int _n) { return write((char *) _s, _n); }


class _CRTIMP ostream_withassign : public ostream {
	public:
		ostream_withassign();
		ostream_withassign(streambuf* _is);
		~ostream_withassign();
    ostream& operator=(const ostream& _os) { return ostream::operator=(_os.rdbuf()); }
    ostream& operator=(streambuf* _sb) { return ostream::operator=(_sb); }
};

extern ostream_withassign _CRTIMP cout;
extern ostream_withassign _CRTIMP cerr;
extern ostream_withassign _CRTIMP clog;

inline _CRTIMP ostream& __cdecl flush(ostream& _outs) { return _outs.flush(); }
inline _CRTIMP ostream& __cdecl endl(ostream& _outs) { return _outs << '\n' << flush; }
inline _CRTIMP ostream& __cdecl ends(ostream& _outs) { return _outs << char('\0'); }

_CRTIMP ios&		__cdecl dec(ios&);
_CRTIMP ios&		__cdecl hex(ios&);
_CRTIMP ios&		__cdecl oct(ios&);

#ifdef	_MSC_VER
// Restore default packing
#pragma pack(pop)
#endif	// _MSC_VER

#endif	// _INC_OSTREAM

#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\process.h ===
/***
*process.h - definition and declarations for process control functions
*
*	Copyright (c) 1985-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines the modeflag values for spawnxx calls.
*	Also contains the function argument declarations for all
*	process control related routines.
*
*       [Public]
*
****/

#ifndef _INC_PROCESS
#define _INC_PROCESS

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifndef _POSIX_

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _MAC
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif
#endif /* ndef _MAC */


/* modeflag values for _spawnxx routines */

#ifndef _MAC

#define _P_WAIT 	0
#define _P_NOWAIT	1
#define _OLD_P_OVERLAY	2
#define _P_NOWAITO	3
#define _P_DETACH	4

#ifdef _MT
#define _P_OVERLAY	2
#else
extern int _p_overlay;
#define _P_OVERLAY	_p_overlay
#endif	/* _MT */

/* Action codes for _cwait(). The action code argument to _cwait is ignored
   on Win32 though it is accepted for compatibilty with old OS/2 CRT libs */
#define _WAIT_CHILD	 0
#define _WAIT_GRANDCHILD 1

#else /* ndef _MAC */

#define _P_NOWAIT	1
#define _P_OVERLAY	2

#endif /* ndef _MAC */


/* function prototypes */

#ifdef	_MT
_CRTIMP unsigned long  __cdecl _beginthread (void (__cdecl *) (void *),
	unsigned, void *);
_CRTIMP void __cdecl _endthread(void);
_CRTIMP unsigned long __cdecl _beginthreadex(void *, unsigned,
	unsigned (__stdcall *) (void *), void *, unsigned, unsigned *);
_CRTIMP void __cdecl _endthreadex(unsigned);
#endif

_CRTIMP void __cdecl abort(void);
_CRTIMP void __cdecl _cexit(void);
_CRTIMP void __cdecl _c_exit(void);
_CRTIMP void __cdecl exit(int);
_CRTIMP void __cdecl _exit(int);
_CRTIMP int __cdecl _getpid(void);

#ifndef _MAC

_CRTIMP int __cdecl _cwait(int *, int, int);
_CRTIMP int __cdecl _execl(const char *, const char *, ...);
_CRTIMP int __cdecl _execle(const char *, const char *, ...);
_CRTIMP int __cdecl _execlp(const char *, const char *, ...);
_CRTIMP int __cdecl _execlpe(const char *, const char *, ...);
_CRTIMP int __cdecl _execv(const char *, const char * const *);
_CRTIMP int __cdecl _execve(const char *, const char * const *, const char * const *);
_CRTIMP int __cdecl _execvp(const char *, const char * const *);
_CRTIMP int __cdecl _execvpe(const char *, const char * const *, const char * const *);
_CRTIMP int __cdecl _spawnl(int, const char *, const char *, ...);
_CRTIMP int __cdecl _spawnle(int, const char *, const char *, ...);
_CRTIMP int __cdecl _spawnlp(int, const char *, const char *, ...);
_CRTIMP int __cdecl _spawnlpe(int, const char *, const char *, ...);
_CRTIMP int __cdecl _spawnv(int, const char *, const char * const *);
_CRTIMP int __cdecl _spawnve(int, const char *, const char * const *,
	const char * const *);
_CRTIMP int __cdecl _spawnvp(int, const char *, const char * const *);
_CRTIMP int __cdecl _spawnvpe(int, const char *, const char * const *,
	const char * const *);
_CRTIMP int __cdecl system(const char *);

#else /* ndef _MAC */

_CRTIMP int __cdecl _spawn(int, const char *);

#endif /* ndef _MAC */

#ifndef _MAC
#ifndef _WPROCESS_DEFINED
/* wide function prototypes, also declared in wchar.h  */
_CRTIMP int __cdecl _wexecl(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wexecle(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wexeclp(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wexeclpe(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wexecv(const wchar_t *, const wchar_t * const *);
_CRTIMP int __cdecl _wexecve(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP int __cdecl _wexecvp(const wchar_t *, const wchar_t * const *);
_CRTIMP int __cdecl _wexecvpe(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP int __cdecl _wspawnl(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wspawnle(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wspawnlp(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wspawnlpe(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wspawnv(int, const wchar_t *, const wchar_t * const *);
_CRTIMP int __cdecl _wspawnve(int, const wchar_t *, const wchar_t * const *,
	const wchar_t * const *);
_CRTIMP int __cdecl _wspawnvp(int, const wchar_t *, const wchar_t * const *);
_CRTIMP int __cdecl _wspawnvpe(int, const wchar_t *, const wchar_t * const *,
	const wchar_t * const *);
_CRTIMP int __cdecl _wsystem(const wchar_t *);

#define _WPROCESS_DEFINED
#endif

/* --------- The following functions are OBSOLETE --------- */
/*
 * The Win32 API LoadLibrary, FreeLibrary and GetProcAddress should be used
 * instead.
 */
int __cdecl _loaddll(char *);
int __cdecl _unloaddll(int);
int (__cdecl * __cdecl _getdllprocaddr(int, char *, int))();
/* --------- The preceding functions are OBSOLETE --------- */


#ifdef	_DECL_DLLMAIN
/*
 * Declare DLL notification (initialization/termination) routines
 *	The preferred method is for the user to provide DllMain() which will
 *	be called automatically by the DLL entry point defined by the C run-
 *	time library code.  If the user wants to define the DLL entry point
 *	routine, the user's entry point must call _CRT_INIT on all types of
 *	notifications, as the very first thing on attach notifications and
 *	as the very last thing on detach notifications.
 */
#ifdef	_WINDOWS_	/* Use types from WINDOWS.H */
BOOL WINAPI DllMain(HANDLE, DWORD, LPVOID);
BOOL WINAPI _CRT_INIT(HANDLE, DWORD, LPVOID);
BOOL WINAPI _wCRT_INIT(HANDLE, DWORD, LPVOID);
extern BOOL (WINAPI *_pRawDllMain)(HANDLE, DWORD, LPVOID);
#else
int __stdcall DllMain(void *, unsigned, void *);
int __stdcall _CRT_INIT(void *, unsigned, void *);
int __stdcall _wCRT_INIT(void *, unsigned, void *);
extern int (__stdcall *_pRawDllMain)(void *, unsigned, void *);
#endif	/* _WINDOWS_ */
#endif
#endif /* ndef _MAC */

#if	!__STDC__

/* Non-ANSI names for compatibility */


#ifndef _MAC

#define P_WAIT		_P_WAIT
#define P_NOWAIT	_P_NOWAIT
#define P_OVERLAY	_P_OVERLAY
#define OLD_P_OVERLAY	_OLD_P_OVERLAY
#define P_NOWAITO	_P_NOWAITO
#define P_DETACH	_P_DETACH
#define WAIT_CHILD	_WAIT_CHILD
#define WAIT_GRANDCHILD _WAIT_GRANDCHILD

#else /* ndef _MAC */

#define P_NOWAIT	_P_NOWAIT
#define P_OVERLAY	_P_OVERLAY

#endif /* ndef _MAC */

#ifdef	_NTSDK

/* definitions compatible with NT SDK */
#define cwait	 _cwait
#define execl	 _execl
#define execle	 _execle
#define execlp	 _execlp
#define execlpe  _execlpe
#define execv	 _execv
#define execve	 _execve
#define execvp	 _execvp
#define execvpe  _execvpe
#define getpid	 _getpid
#define spawnl	 _spawnl
#define spawnle  _spawnle
#define spawnlp  _spawnlp
#define spawnlpe _spawnlpe
#define spawnv	 _spawnv
#define spawnve  _spawnve
#define spawnvp  _spawnvp
#define spawnvpe _spawnvpe

#else	/* ndef _NTSDK */

#ifndef _MAC

/* current declarations */
_CRTIMP int __cdecl cwait(int *, int, int);
_CRTIMP int __cdecl execl(const char *, const char *, ...);
_CRTIMP int __cdecl execle(const char *, const char *, ...);
_CRTIMP int __cdecl execlp(const char *, const char *, ...);
_CRTIMP int __cdecl execlpe(const char *, const char *, ...);
_CRTIMP int __cdecl execv(const char *, const char * const *);
_CRTIMP int __cdecl execve(const char *, const char * const *, const char * const *);
_CRTIMP int __cdecl execvp(const char *, const char * const *);
_CRTIMP int __cdecl execvpe(const char *, const char * const *, const char * const *);
_CRTIMP int __cdecl spawnl(int, const char *, const char *, ...);
_CRTIMP int __cdecl spawnle(int, const char *, const char *, ...);
_CRTIMP int __cdecl spawnlp(int, const char *, const char *, ...);
_CRTIMP int __cdecl spawnlpe(int, const char *, const char *, ...);
_CRTIMP int __cdecl spawnv(int, const char *, const char * const *);
_CRTIMP int __cdecl spawnve(int, const char *, const char * const *,
	const char * const *);
_CRTIMP int __cdecl spawnvp(int, const char *, const char * const *);
_CRTIMP int __cdecl spawnvpe(int, const char *, const char * const *,
	const char * const *);

#endif /* ndef _MAC */

_CRTIMP int __cdecl getpid(void);

#endif	/* _NTSDK */

#endif	/* __STDC__ */

#ifdef __cplusplus
}
#endif

#endif	/* _POSIX_ */

#endif	/* _INC_PROCESS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\rpcnsi.h ===
/*++

Copyright (c) 1992-1995 Microsoft Corporation

Module Name:

    rpcnsi.h

Abstract:

    This file contains the types and function definitions to use the
    Name Service Independent APIs.

--*/

#ifndef __RPCNSI_H__
#define __RPCNSI_H__

typedef void __RPC_FAR * RPC_NS_HANDLE;

#define RPC_C_NS_SYNTAX_DEFAULT 0
#define RPC_C_NS_SYNTAX_DCE 3

#define RPC_C_PROFILE_DEFAULT_ELT 0
#define RPC_C_PROFILE_ALL_ELT 1
#define RPC_C_PROFILE_MATCH_BY_IF 2
#define RPC_C_PROFILE_MATCH_BY_MBR 3
#define RPC_C_PROFILE_MATCH_BY_BOTH 4

#define RPC_C_NS_DEFAULT_EXP_AGE -1

/* Server APIs */

RPC_STATUS RPC_ENTRY
RpcNsBindingExportA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN RPC_BINDING_VECTOR __RPC_FAR * BindingVec OPTIONAL,
    IN UUID_VECTOR __RPC_FAR * ObjectUuidVec OPTIONAL
    );


RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID_VECTOR __RPC_FAR * ObjectUuidVec OPTIONAL
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNsBindingExportW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN RPC_BINDING_VECTOR __RPC_FAR * BindingVec OPTIONAL,
    IN UUID_VECTOR __RPC_FAR * ObjectUuidVec OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID_VECTOR __RPC_FAR * ObjectUuidVec OPTIONAL
    );

#endif

/* Client APIs */

#ifndef UNICODE_ONLY
RPC_STATUS RPC_ENTRY
RpcNsBindingLookupBeginA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName OPTIONAL,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned long BindingMaxCount OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * LookupContext
    );
#endif //!UNICODE_ONLY

#ifdef RPC_UNICODE_SUPPORTED

#ifndef ANSI_ONLY
RPC_STATUS RPC_ENTRY
RpcNsBindingLookupBeginW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName OPTIONAL,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned long BindingMaxCount OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * LookupContext
    );
#endif //!ANSI_ONLY
#endif

RPC_STATUS RPC_ENTRY
RpcNsBindingLookupNext(
    IN  RPC_NS_HANDLE LookupContext,
    OUT RPC_BINDING_VECTOR __RPC_FAR * __RPC_FAR * BindingVec
    );

RPC_STATUS RPC_ENTRY
RpcNsBindingLookupDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * LookupContext
    );

/* Group APIs */

RPC_STATUS RPC_ENTRY
RpcNsGroupDeleteA(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * GroupName
    );

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrAddA(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * MemberName
    );

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrRemoveA(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * MemberName
    );

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqBeginA(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqNextA(
    IN  RPC_NS_HANDLE InquiryContext,
    OUT unsigned char __RPC_FAR * __RPC_FAR * MemberName
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNsGroupDeleteW(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * GroupName
    );

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrAddW(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * MemberName
    );

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrRemoveW(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * MemberName
    );

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqBeginW(
    IN unsigned long GroupNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * GroupName,
    IN unsigned long MemberNameSyntax OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqNextW(
    IN  RPC_NS_HANDLE InquiryContext,
    OUT unsigned short __RPC_FAR * __RPC_FAR * MemberName
    );

#endif

RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

/* Profile APIs */

RPC_STATUS RPC_ENTRY
RpcNsProfileDeleteA(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * ProfileName
    );

RPC_STATUS RPC_ENTRY
RpcNsProfileEltAddA(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * ProfileName,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * MemberName,
    IN unsigned long Priority,
    IN unsigned char __RPC_FAR * Annotation OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcNsProfileEltRemoveA(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * ProfileName,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * MemberName
    );

RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqBeginA(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * ProfileName,
    IN unsigned long InquiryType,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long VersOption,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * MemberName OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqNextA(
    IN RPC_NS_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT unsigned char __RPC_FAR * __RPC_FAR * MemberName,
    OUT unsigned long __RPC_FAR * Priority,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Annotation
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNsProfileDeleteW(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * ProfileName
    );

RPC_STATUS RPC_ENTRY
RpcNsProfileEltAddW(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * ProfileName,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * MemberName,
    IN unsigned long Priority,
    IN unsigned short __RPC_FAR * Annotation OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcNsProfileEltRemoveW(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * ProfileName,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * MemberName
    );

RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqBeginW(
    IN unsigned long ProfileNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * ProfileName,
    IN unsigned long InquiryType,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long VersOption,
    IN unsigned long MemberNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * MemberName OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqNextW(
    IN RPC_NS_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT unsigned short __RPC_FAR * __RPC_FAR * MemberName,
    OUT unsigned long __RPC_FAR * Priority,
    OUT unsigned short __RPC_FAR * __RPC_FAR * Annotation
    );

#endif

RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

/* Entry object APIs */

#ifndef UNICODE_ONLY
RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqBeginA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName,
    OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );
#endif //!UNICODE_ONLY

#ifdef RPC_UNICODE_SUPPORTED

#ifndef ANSI_ONLY
RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqBeginW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName,
    OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );
#endif //!ANSI_ONLY

#endif

RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqNext(
    IN  RPC_NS_HANDLE InquiryContext,
    OUT UUID __RPC_FAR * ObjUuid
    );

RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

/* Management and MISC APIs */

RPC_STATUS RPC_ENTRY
RpcNsEntryExpandNameA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ExpandedName
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtBindingUnexportA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long VersOption,
    IN UUID_VECTOR __RPC_FAR * ObjectUuidVec OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryCreateA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryDeleteA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryInqIfIdsA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName,
    OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVec
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtHandleSetExpAge(
    IN RPC_NS_HANDLE NsHandle,
    IN unsigned long ExpirationAge
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtInqExpAge(
    OUT unsigned long __RPC_FAR * ExpirationAge
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtSetExpAge(
    IN unsigned long ExpirationAge
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNsEntryExpandNameW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ExpandedName
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtBindingUnexportW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long VersOption,
    IN UUID_VECTOR __RPC_FAR * ObjectUuidVec OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryCreateW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryDeleteW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName
    );

RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryInqIfIdsW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName,
    OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVec
    );

#endif

/* Client API's implemented in wrappers. */

#ifndef UNICODE_ONLY
RPC_STATUS RPC_ENTRY
RpcNsBindingImportBeginA(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned char __RPC_FAR * EntryName OPTIONAL,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID __RPC_FAR * ObjUuid OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * ImportContext
    );
#endif //!UNICODE_ONLY

#ifdef RPC_UNICODE_SUPPORTED

#ifndef ANSI_ONLY
RPC_STATUS RPC_ENTRY
RpcNsBindingImportBeginW(
    IN unsigned long EntryNameSyntax OPTIONAL,
    IN unsigned short __RPC_FAR * EntryName OPTIONAL,
    IN RPC_IF_HANDLE IfSpec OPTIONAL,
    IN UUID __RPC_FAR * ObjUuid OPTIONAL,
    OUT RPC_NS_HANDLE __RPC_FAR * ImportContext
    );
#endif //!ANSI_ONLY

#endif

RPC_STATUS RPC_ENTRY
RpcNsBindingImportNext(
    IN RPC_NS_HANDLE ImportContext,
    OUT RPC_BINDING_HANDLE  __RPC_FAR * Binding
    );

RPC_STATUS RPC_ENTRY
RpcNsBindingImportDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * ImportContext
    );

RPC_STATUS RPC_ENTRY
RpcNsBindingSelect(
    IN OUT RPC_BINDING_VECTOR __RPC_FAR * BindingVec,
    OUT RPC_BINDING_HANDLE  __RPC_FAR * Binding
    );

#ifdef UNICODE

#define RpcNsBindingLookupBegin RpcNsBindingLookupBeginW
#define RpcNsBindingImportBegin RpcNsBindingImportBeginW
#define RpcNsBindingExport RpcNsBindingExportW
#define RpcNsBindingUnexport RpcNsBindingUnexportW
#define RpcNsGroupDelete RpcNsGroupDeleteW
#define RpcNsGroupMbrAdd RpcNsGroupMbrAddW
#define RpcNsGroupMbrRemove RpcNsGroupMbrRemoveW
#define RpcNsGroupMbrInqBegin RpcNsGroupMbrInqBeginW
#define RpcNsGroupMbrInqNext RpcNsGroupMbrInqNextW
#define RpcNsEntryExpandName RpcNsEntryExpandNameW
#define RpcNsEntryObjectInqBegin RpcNsEntryObjectInqBeginW
#define RpcNsMgmtBindingUnexport RpcNsMgmtBindingUnexportW
#define RpcNsMgmtEntryCreate RpcNsMgmtEntryCreateW
#define RpcNsMgmtEntryDelete RpcNsMgmtEntryDeleteW
#define RpcNsMgmtEntryInqIfIds RpcNsMgmtEntryInqIfIdsW
#define RpcNsProfileDelete RpcNsProfileDeleteW
#define RpcNsProfileEltAdd RpcNsProfileEltAddW
#define RpcNsProfileEltRemove RpcNsProfileEltRemoveW
#define RpcNsProfileEltInqBegin RpcNsProfileEltInqBeginW
#define RpcNsProfileEltInqNext RpcNsProfileEltInqNextW

#else

#define RpcNsBindingLookupBegin RpcNsBindingLookupBeginA
#define RpcNsBindingImportBegin RpcNsBindingImportBeginA
#define RpcNsBindingExport RpcNsBindingExportA
#define RpcNsBindingUnexport RpcNsBindingUnexportA
#define RpcNsGroupDelete RpcNsGroupDeleteA
#define RpcNsGroupMbrAdd RpcNsGroupMbrAddA
#define RpcNsGroupMbrRemove RpcNsGroupMbrRemoveA
#define RpcNsGroupMbrInqBegin RpcNsGroupMbrInqBeginA
#define RpcNsGroupMbrInqNext RpcNsGroupMbrInqNextA
#define RpcNsEntryExpandName RpcNsEntryExpandNameA
#define RpcNsEntryObjectInqBegin RpcNsEntryObjectInqBeginA
#define RpcNsMgmtBindingUnexport RpcNsMgmtBindingUnexportA
#define RpcNsMgmtEntryCreate RpcNsMgmtEntryCreateA
#define RpcNsMgmtEntryDelete RpcNsMgmtEntryDeleteA
#define RpcNsMgmtEntryInqIfIds RpcNsMgmtEntryInqIfIdsA
#define RpcNsProfileDelete RpcNsProfileDeleteA
#define RpcNsProfileEltAdd RpcNsProfileEltAddA
#define RpcNsProfileEltRemove RpcNsProfileEltRemoveA
#define RpcNsProfileEltInqBegin RpcNsProfileEltInqBeginA
#define RpcNsProfileEltInqNext RpcNsProfileEltInqNextA

#endif /* UNICODE */

#endif /* __RPCNSI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\rpcdce.h ===
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    rpcdce.h

Abstract:

    This module contains the DCE RPC runtime APIs.

--*/

#ifndef __RPCDCE_H__
#define __RPCDCE_H__

#ifdef __cplusplus
extern "C" {
#endif

#define IN
#define OUT
#define OPTIONAL

/*typedef char small;*/
/*typedef unsigned char byte;*/
/*typedef unsigned char boolean;*/

typedef I_RPC_HANDLE RPC_BINDING_HANDLE;
typedef RPC_BINDING_HANDLE handle_t;
#define rpc_binding_handle_t RPC_BINDING_HANDLE

#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct _GUID
{
    unsigned long Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char Data4[8];
} GUID;
#endif /* GUID_DEFINED */

#ifndef UUID_DEFINED
#define UUID_DEFINED
typedef GUID UUID;
#ifndef uuid_t
#define uuid_t UUID
#endif
#endif

typedef struct _RPC_BINDING_VECTOR
{
    unsigned long Count;
    RPC_BINDING_HANDLE BindingH[1];
} RPC_BINDING_VECTOR;
#ifndef rpc_binding_vector_t
#define rpc_binding_vector_t RPC_BINDING_VECTOR
#endif

typedef struct _UUID_VECTOR
{
  unsigned long Count;
  UUID *Uuid[1];
} UUID_VECTOR;
#ifndef uuid_vector_t
#define uuid_vector_t UUID_VECTOR
#endif

typedef void __RPC_FAR * RPC_IF_HANDLE;

#ifndef IFID_DEFINED
#define IFID_DEFINED
typedef struct _RPC_IF_ID
{
    UUID Uuid;
    unsigned short VersMajor;
    unsigned short VersMinor;
} RPC_IF_ID;
#endif

#define RPC_C_BINDING_INFINITE_TIMEOUT 10
#define RPC_C_BINDING_MIN_TIMEOUT 0
#define RPC_C_BINDING_DEFAULT_TIMEOUT 5
#define RPC_C_BINDING_MAX_TIMEOUT 9

#define RPC_C_CANCEL_INFINITE_TIMEOUT -1

#define RPC_C_LISTEN_MAX_CALLS_DEFAULT 1234
#define RPC_C_PROTSEQ_MAX_REQS_DEFAULT 10

#ifdef RPC_UNICODE_SUPPORTED

typedef struct _RPC_PROTSEQ_VECTORA
{
    unsigned int Count;
    unsigned char __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTORA;

typedef struct _RPC_PROTSEQ_VECTORW
{
    unsigned int Count;
    unsigned short __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTORW;

#ifdef UNICODE
#define RPC_PROTSEQ_VECTOR RPC_PROTSEQ_VECTORW
#else /* UNICODE */
#define RPC_PROTSEQ_VECTOR RPC_PROTSEQ_VECTORA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

typedef struct _RPC_PROTSEQ_VECTOR
{
    unsigned int Count;
    unsigned char __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTOR;

#endif /* RPC_UNICODE_SUPPORTED */

typedef void __RPC_USER
RPC_OBJECT_INQ_FN (
    IN UUID __RPC_FAR * ObjectUuid,
    OUT UUID __RPC_FAR * TypeUuid,
    OUT RPC_STATUS __RPC_FAR * Status
    );

typedef RPC_STATUS
RPC_IF_CALLBACK_FN (
    IN RPC_IF_HANDLE  InterfaceUuid,
    IN void *Context
    ) ;

#define RPC_MGR_EPV void

typedef struct
{
    unsigned int Count;
    unsigned long Stats[1];
} RPC_STATS_VECTOR;

#define RPC_C_STATS_CALLS_IN 0
#define RPC_C_STATS_CALLS_OUT 1
#define RPC_C_STATS_PKTS_IN 2
#define RPC_C_STATS_PKTS_OUT 3

typedef struct
{
  unsigned long Count;
  RPC_IF_ID __RPC_FAR * IfId[1];
} RPC_IF_ID_VECTOR;

/* client */
RPC_STATUS RPC_ENTRY
RpcBindingCopy (
    IN RPC_BINDING_HANDLE SourceBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * DestinationBinding
    );

/* client */
RPC_STATUS RPC_ENTRY
RpcBindingFree (
    IN OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

/* client */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcBindingFromStringBindingA (
    IN unsigned char __RPC_FAR * StringBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

RPC_STATUS RPC_ENTRY
RpcBindingFromStringBindingW (
    IN unsigned short __RPC_FAR * StringBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

#ifdef UNICODE
#define RpcBindingFromStringBinding RpcBindingFromStringBindingW
#else /* UNICODE */
#define RpcBindingFromStringBinding RpcBindingFromStringBindingA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcBindingFromStringBinding (
    IN unsigned char __RPC_FAR * StringBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* RpcBindingInqAuthClient */
/* RpcBindingInqAuthInfo */

/* client/server */
RPC_STATUS RPC_ENTRY
RpcBindingInqObject (
    IN RPC_BINDING_HANDLE Binding,
    OUT UUID __RPC_FAR * ObjectUuid
    );

/* client */
RPC_STATUS RPC_ENTRY
RpcBindingReset (
    IN RPC_BINDING_HANDLE Binding
    );

/* RpcBindingServerFromClient : UNSUPPORTED */
/* RpcBindingSetAuthInfo */

/* client */
RPC_STATUS RPC_ENTRY
RpcBindingSetObject (
    IN RPC_BINDING_HANDLE Binding,
    IN UUID __RPC_FAR * ObjectUuid
    );

/* client/server */
RPC_STATUS RPC_ENTRY
RpcMgmtInqDefaultProtectLevel(
    IN  unsigned long AuthnSvc,
    OUT unsigned long __RPC_FAR *AuthnLevel
    );

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcBindingToStringBindingA (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringBinding
    );

RPC_STATUS RPC_ENTRY
RpcBindingToStringBindingW (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short __RPC_FAR * __RPC_FAR * StringBinding
    );

#ifdef UNICODE
#define RpcBindingToStringBinding RpcBindingToStringBindingW
#else /* UNICODE */
#define RpcBindingToStringBinding RpcBindingToStringBindingA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcBindingToStringBinding (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringBinding
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */
RPC_STATUS RPC_ENTRY
RpcBindingVectorFree (
    IN OUT RPC_BINDING_VECTOR __RPC_FAR * __RPC_FAR * BindingVector
    );

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcStringBindingComposeA (
    IN unsigned char __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned char __RPC_FAR * Protseq OPTIONAL,
    IN unsigned char __RPC_FAR * NetworkAddr OPTIONAL,
    IN unsigned char __RPC_FAR * Endpoint OPTIONAL,
    IN unsigned char __RPC_FAR * Options OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringBinding OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcStringBindingComposeW (
    IN unsigned short __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned short __RPC_FAR * Protseq OPTIONAL,
    IN unsigned short __RPC_FAR * NetworkAddr OPTIONAL,
    IN unsigned short __RPC_FAR * Endpoint OPTIONAL,
    IN unsigned short __RPC_FAR * Options OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * StringBinding OPTIONAL
    );

#ifdef UNICODE
#define RpcStringBindingCompose RpcStringBindingComposeW
#else /* UNICODE */
#define RpcStringBindingCompose RpcStringBindingComposeA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcStringBindingCompose (
    IN unsigned char __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned char __RPC_FAR * Protseq OPTIONAL,
    IN unsigned char __RPC_FAR * NetworkAddr OPTIONAL,
    IN unsigned char __RPC_FAR * Endpoint OPTIONAL,
    IN unsigned char __RPC_FAR * Options OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringBinding OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcStringBindingParseA (
    IN unsigned char __RPC_FAR * StringBinding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ObjUuid OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Protseq OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * NetworkAddr OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Endpoint OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * NetworkOptions OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcStringBindingParseW (
    IN unsigned short __RPC_FAR * StringBinding,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ObjUuid OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * Protseq OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * NetworkAddr OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * Endpoint OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * NetworkOptions OPTIONAL
    );

#ifdef UNICODE
#define RpcStringBindingParse RpcStringBindingParseW
#else /* UNICODE */
#define RpcStringBindingParse RpcStringBindingParseA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcStringBindingParse (
    IN unsigned char __RPC_FAR * StringBinding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ObjUuid OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Protseq OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * NetworkAddr OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Endpoint OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * NetworkOptions OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcStringFreeA (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR * String
    );

RPC_STATUS RPC_ENTRY
RpcStringFreeW (
    IN OUT unsigned short __RPC_FAR * __RPC_FAR * String
    );

#ifdef UNICODE
#define RpcStringFree RpcStringFreeW
#else /* UNICODE */
#define RpcStringFree RpcStringFreeA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcStringFree (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR * String
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */
RPC_STATUS RPC_ENTRY
RpcIfInqId (
    IN RPC_IF_HANDLE RpcIfHandle,
    OUT RPC_IF_ID __RPC_FAR * RpcIfId
    );

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNetworkIsProtseqValidA (
    IN unsigned char __RPC_FAR * Protseq
    );

RPC_STATUS RPC_ENTRY
RpcNetworkIsProtseqValidW (
    IN unsigned short __RPC_FAR * Protseq
    );

#ifdef UNICODE
#define RpcNetworkIsProtseqValid RpcNetworkIsProtseqValidW
#else /* UNICODE */
#define RpcNetworkIsProtseqValid RpcNetworkIsProtseqValidA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcNetworkIsProtseqValid (
    IN unsigned char __RPC_FAR * Protseq
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client */
RPC_STATUS RPC_ENTRY
RpcMgmtInqComTimeout (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned int __RPC_FAR * Timeout
    );

/* client */
RPC_STATUS RPC_ENTRY
RpcMgmtSetComTimeout (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned int Timeout
    );

/* client */
RPC_STATUS RPC_ENTRY
RpcMgmtSetCancelTimeout(
    long Timeout
    );


/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNetworkInqProtseqsA (
    OUT RPC_PROTSEQ_VECTORA __RPC_FAR * __RPC_FAR * ProtseqVector
    );

RPC_STATUS RPC_ENTRY
RpcNetworkInqProtseqsW (
    OUT RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#ifdef UNICODE
#define RpcNetworkInqProtseqs RpcNetworkInqProtseqsW
#else /* UNICODE */
#define RpcNetworkInqProtseqs RpcNetworkInqProtseqsA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcNetworkInqProtseqs (
    OUT RPC_PROTSEQ_VECTOR __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */
RPC_STATUS RPC_ENTRY
RpcObjectInqType (
    IN UUID __RPC_FAR * ObjUuid,
    OUT UUID __RPC_FAR * TypeUuid OPTIONAL
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcObjectSetInqFn (
    IN RPC_OBJECT_INQ_FN __RPC_FAR * InquiryFn
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcObjectSetType (
    IN UUID __RPC_FAR * ObjUuid,
    IN UUID __RPC_FAR * TypeUuid OPTIONAL
    );

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcProtseqVectorFreeA (
    IN OUT RPC_PROTSEQ_VECTORA __RPC_FAR * __RPC_FAR * ProtseqVector
    );

RPC_STATUS RPC_ENTRY
RpcProtseqVectorFreeW (
    IN OUT RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#ifdef UNICODE
#define RpcProtseqVectorFree RpcProtseqVectorFreeW
#else /* UNICODE */
#define RpcProtseqVectorFree RpcProtseqVectorFreeA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcProtseqVectorFree (
    IN OUT RPC_PROTSEQ_VECTOR __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */
RPC_STATUS RPC_ENTRY
RpcServerInqBindings (
    OUT RPC_BINDING_VECTOR __RPC_FAR * __RPC_FAR * BindingVector
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcServerInqIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID __RPC_FAR * MgrTypeUuid, OPTIONAL
    OUT RPC_MGR_EPV __RPC_FAR * __RPC_FAR * MgrEpv
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcServerListen (
    IN unsigned int MinimumCallThreads,
    IN unsigned int MaxCalls,
    IN unsigned int DontWait
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcServerRegisterIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID __RPC_FAR * MgrTypeUuid OPTIONAL,
    IN RPC_MGR_EPV __RPC_FAR * MgrEpv OPTIONAL
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcServerRegisterIfEx (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID __RPC_FAR * MgrTypeUuid,
    IN RPC_MGR_EPV __RPC_FAR * MgrEpv,
    IN unsigned int Flags,
    IN unsigned int MaxCalls,
    IN RPC_IF_CALLBACK_FN __RPC_FAR *IfCallback
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcServerUnregisterIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID __RPC_FAR * MgrTypeUuid, OPTIONAL
    IN unsigned int WaitForCallsToComplete
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcServerUseAllProtseqs (
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcServerUseAllProtseqsIf (
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcServerUseProtseqA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcServerUseProtseqW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

#ifdef UNICODE
#define RpcServerUseProtseq RpcServerUseProtseqW
#else /* UNICODE */
#define RpcServerUseProtseq RpcServerUseProtseqA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcServerUseProtseq (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcServerUseProtseqEpA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned char __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcServerUseProtseqEpW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned short __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

#ifdef UNICODE
#define RpcServerUseProtseqEp RpcServerUseProtseqEpW
#else /* UNICODE */
#define RpcServerUseProtseqEp RpcServerUseProtseqEpA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcServerUseProtseqEp (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned char __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcServerUseProtseqIfA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcServerUseProtseqIfW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

#ifdef UNICODE
#define RpcServerUseProtseqIf RpcServerUseProtseqIfW
#else /* UNICODE */
#define RpcServerUseProtseqIf RpcServerUseProtseqIfA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcServerUseProtseqIf (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */
RPC_STATUS RPC_ENTRY
RpcMgmtStatsVectorFree (
    IN RPC_STATS_VECTOR ** StatsVector
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcMgmtInqStats (
    IN RPC_BINDING_HANDLE Binding,
    OUT RPC_STATS_VECTOR ** Statistics
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcMgmtIsServerListening (
    IN RPC_BINDING_HANDLE Binding
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcMgmtStopServerListening (
    IN RPC_BINDING_HANDLE Binding
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcMgmtWaitServerListen (
    void
    );

/* server */
RPC_STATUS RPC_ENTRY
RpcMgmtSetServerStackSize (
    IN unsigned long ThreadStackSize
    );

/* server */
void RPC_ENTRY
RpcSsDontSerializeContext (
    void
    );

/* client */
RPC_STATUS RPC_ENTRY
RpcMgmtEnableIdleCleanup (
    void
    );

RPC_STATUS RPC_ENTRY
RpcMgmtInqIfIds (
    IN RPC_BINDING_HANDLE Binding,
    OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVector
    );

RPC_STATUS RPC_ENTRY
RpcIfIdVectorFree (
    IN OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVector
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcMgmtInqServerPrincNameA (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long AuthnSvc,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName
    );

RPC_STATUS RPC_ENTRY
RpcMgmtInqServerPrincNameW (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long AuthnSvc,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName
    );

#ifdef UNICODE
#define RpcMgmtInqServerPrincName RpcMgmtInqServerPrincNameW
#else /* UNICODE */
#define RpcMgmtInqServerPrincName RpcMgmtInqServerPrincNameA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcMgmtInqServerPrincName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long AuthnSvc,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName
    );

#endif /* RPC_UNICODE_SUPPORTED */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcServerInqDefaultPrincNameA (
    IN unsigned long AuthnSvc,
    OUT unsigned char __RPC_FAR * __RPC_FAR * PrincName
    );

RPC_STATUS RPC_ENTRY
RpcServerInqDefaultPrincNameW (
    IN unsigned long AuthnSvc,
    OUT unsigned short __RPC_FAR * __RPC_FAR * PrincName
    );

#ifdef UNICODE
#define RpcServerInqDefaultPrincName RpcServerInqDefaultPrincNameW
#else /* UNICODE */
#define RpcServerInqDefaultPrincName RpcServerInqDefaultPrincNameA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcServerInqDefaultPrincName (
    IN unsigned long AuthnSvc,
    OUT unsigned char __RPC_FAR * __RPC_FAR * PrincName
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client */
RPC_STATUS RPC_ENTRY
RpcEpResolveBinding (
    IN RPC_BINDING_HANDLE Binding,
    IN RPC_IF_HANDLE IfSpec
    );

/* client */

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNsBindingInqEntryNameA (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    OUT unsigned char __RPC_FAR * __RPC_FAR * EntryName
    );

RPC_STATUS RPC_ENTRY
RpcNsBindingInqEntryNameW (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    OUT unsigned short __RPC_FAR * __RPC_FAR * EntryName
    );

#ifdef UNICODE
#define RpcNsBindingInqEntryName RpcNsBindingInqEntryNameW
#else /* UNICODE */
#define RpcNsBindingInqEntryName RpcNsBindingInqEntryNameA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcNsBindingInqEntryName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    OUT unsigned char __RPC_FAR * __RPC_FAR * EntryName
    );

#endif /* RPC_UNICODE_SUPPORTED */

typedef void __RPC_FAR * RPC_AUTH_IDENTITY_HANDLE;
typedef void __RPC_FAR * RPC_AUTHZ_HANDLE;

#define RPC_C_AUTHN_LEVEL_DEFAULT 0
#define RPC_C_AUTHN_LEVEL_NONE 1
#define RPC_C_AUTHN_LEVEL_CONNECT 2
#define RPC_C_AUTHN_LEVEL_CALL 3
#define RPC_C_AUTHN_LEVEL_PKT 4
#define RPC_C_AUTHN_LEVEL_PKT_INTEGRITY 5
#define RPC_C_AUTHN_LEVEL_PKT_PRIVACY 6

#define RPC_C_IMP_LEVEL_ANONYMOUS    1
#define RPC_C_IMP_LEVEL_IDENTIFY     2
#define RPC_C_IMP_LEVEL_IMPERSONATE  3
#define RPC_C_IMP_LEVEL_DELEGATE     4

#define RPC_C_PROTECT_LEVEL_DEFAULT       (RPC_C_AUTHN_LEVEL_DEFAULT)
#define RPC_C_PROTECT_LEVEL_NONE          (RPC_C_AUTHN_LEVEL_NONE)
#define RPC_C_PROTECT_LEVEL_CONNECT       (RPC_C_AUTHN_LEVEL_CONNECT)
#define RPC_C_PROTECT_LEVEL_CALL          (RPC_C_AUTHN_LEVEL_CALL)
#define RPC_C_PROTECT_LEVEL_PKT           (RPC_C_AUTHN_LEVEL_PKT)
#define RPC_C_PROTECT_LEVEL_PKT_INTEGRITY (RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
#define RPC_C_PROTECT_LEVEL_PKT_PRIVACY   (RPC_C_AUTHN_LEVEL_PKT_PRIVACY)

#define RPC_C_AUTHN_NONE 0
#define RPC_C_AUTHN_DCE_PRIVATE 1
#define RPC_C_AUTHN_DCE_PUBLIC 2
#define RPC_C_AUTHN_DEC_PUBLIC 4
#define RPC_C_AUTHN_WINNT       10
#define RPC_C_AUTHN_DEFAULT 0xFFFFFFFFL

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__)
typedef struct _SEC_WINNT_AUTH_IDENTITY
{
  char __RPC_FAR *User;
  char __RPC_FAR *Domain;
  char __RPC_FAR *Password;
} SEC_WINNT_AUTH_IDENTITY;
#else


#define SEC_WINNT_AUTH_IDENTITY_ANSI 0x1
#define SEC_WINNT_AUTH_IDENTITY_UNICODE 0x2

typedef struct _SEC_WINNT_AUTH_IDENTITY_W {
  unsigned short __RPC_FAR *User;
  unsigned long UserLength;
  unsigned short __RPC_FAR *Domain;
  unsigned long DomainLength;
  unsigned short __RPC_FAR *Password;
  unsigned long PasswordLength;
  unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_W, *PSEC_WINNT_AUTH_IDENTITY_W;

typedef struct _SEC_WINNT_AUTH_IDENTITY_A {
  unsigned char __RPC_FAR *User;
  unsigned long UserLength;
  unsigned char __RPC_FAR *Domain;
  unsigned long DomainLength;
  unsigned char __RPC_FAR *Password;
  unsigned long PasswordLength;
  unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_A, *PSEC_WINNT_AUTH_IDENTITY_A;

#ifdef UNICODE
#define SEC_WINNT_AUTH_IDENTITY SEC_WINNT_AUTH_IDENTITY_W
#define PSEC_WINNT_AUTH_IDENTITY PSEC_WINNT_AUTH_IDENTITY_W
#define _SEC_WINNT_AUTH_IDENTITY _SEC_WINNT_AUTH_IDENTITY_W
#else // UNICODE
#define SEC_WINNT_AUTH_IDENTITY SEC_WINNT_AUTH_IDENTITY_A
#define PSEC_WINNT_AUTH_IDENTITY PSEC_WINNT_AUTH_IDENTITY_A
#define _SEC_WINNT_AUTH_IDENTITY _SEC_WINNT_AUTH_IDENTITY_A
#endif // UNICODE
#endif // defined(__RPC_DOS__) || defined(__RPC_WIN16__)

#define RPC_C_AUTHZ_NONE 0
#define RPC_C_AUTHZ_NAME 1
#define RPC_C_AUTHZ_DCE 2

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcBindingInqAuthClientA (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcBindingInqAuthClientW (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcBindingInqAuthInfoA (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcBindingInqAuthInfoW (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcBindingSetAuthInfoA (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc
    );

RPC_STATUS RPC_ENTRY
RpcBindingSetAuthInfoW (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned short __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc
    );

typedef void
(__RPC_USER * RPC_AUTH_KEY_RETRIEVAL_FN) (
    IN void __RPC_FAR * Arg,
    IN unsigned short __RPC_FAR * ServerPrincName,
    IN unsigned long KeyVer,
    OUT void __RPC_FAR * __RPC_FAR * Key,
    OUT RPC_STATUS __RPC_FAR * Status
    );

RPC_STATUS RPC_ENTRY
RpcServerRegisterAuthInfoA (
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn OPTIONAL,
    IN void __RPC_FAR * Arg OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcServerRegisterAuthInfoW (
    IN unsigned short __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn OPTIONAL,
    IN void __RPC_FAR * Arg OPTIONAL
    );

#ifdef UNICODE
#define RpcBindingInqAuthClient RpcBindingInqAuthClientW
#define RpcBindingInqAuthInfo RpcBindingInqAuthInfoW
#define RpcBindingSetAuthInfo RpcBindingSetAuthInfoW
#define RpcServerRegisterAuthInfo RpcServerRegisterAuthInfoW
#else /* UNICODE */
#define RpcBindingInqAuthClient RpcBindingInqAuthClientA
#define RpcBindingInqAuthInfo RpcBindingInqAuthInfoA
#define RpcBindingSetAuthInfo RpcBindingSetAuthInfoA
#define RpcServerRegisterAuthInfo RpcServerRegisterAuthInfoA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcBindingInqAuthClient (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcBindingInqAuthInfo (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcBindingSetAuthInfo (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc
    );

typedef void
(__RPC_USER * RPC_AUTH_KEY_RETRIEVAL_FN) (
    IN void __RPC_FAR * Arg,
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long KeyVer,
    OUT void __RPC_FAR * __RPC_FAR * Key,
    OUT RPC_STATUS __RPC_FAR * Status
    );

RPC_STATUS RPC_ENTRY
RpcServerRegisterAuthInfo (
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn OPTIONAL,
    IN void __RPC_FAR * Arg OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

typedef struct {
    unsigned char __RPC_FAR * UserName;
    unsigned char __RPC_FAR * ComputerName;
    unsigned short Privilege;
    unsigned long AuthFlags;
} RPC_CLIENT_INFORMATION1, __RPC_FAR * PRPC_CLIENT_INFORMATION1;

RPC_STATUS RPC_ENTRY
RpcBindingServerFromClient (
    IN RPC_BINDING_HANDLE ClientBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * ServerBinding
    );

void RPC_ENTRY
RpcRaiseException (
    IN RPC_STATUS exception
    );

RPC_STATUS RPC_ENTRY
RpcTestCancel(
    );

RPC_STATUS RPC_ENTRY
RpcCancelThread(
    IN void * Thread
    );

/* client/server */
RPC_STATUS RPC_ENTRY
UuidCreate (
    OUT UUID __RPC_FAR * Uuid
    );

#ifdef RPC_UNICODE_SUPPORTED

/* client/server */
RPC_STATUS RPC_ENTRY
UuidToStringA (
    IN UUID __RPC_FAR * Uuid,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringUuid
    );

/* client/server */
RPC_STATUS RPC_ENTRY
UuidFromStringA (
    IN unsigned char __RPC_FAR * StringUuid,
    OUT UUID __RPC_FAR * Uuid
    );

/* client/server */
RPC_STATUS RPC_ENTRY
UuidToStringW (
    IN UUID __RPC_FAR * Uuid,
    OUT unsigned short __RPC_FAR * __RPC_FAR * StringUuid
    );

/* client/server */
RPC_STATUS RPC_ENTRY
UuidFromStringW (
    IN unsigned short __RPC_FAR * StringUuid,
    OUT UUID __RPC_FAR * Uuid
    );

#ifdef UNICODE
#define UuidFromString UuidFromStringW
#define UuidToString UuidToStringW
#else /* UNICODE */
#define UuidFromString UuidFromStringA
#define UuidToString UuidToStringA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

/* client/server */
RPC_STATUS RPC_ENTRY
UuidToString (
    IN UUID __RPC_FAR * Uuid,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringUuid
    );

/* client/server */
RPC_STATUS RPC_ENTRY
UuidFromString (
    IN unsigned char __RPC_FAR * StringUuid,
    OUT UUID __RPC_FAR * Uuid
    );

#endif /* RPC_UNICODE_SUPPORTED */

signed int RPC_ENTRY
UuidCompare (
    IN UUID __RPC_FAR * Uuid1,
    IN UUID __RPC_FAR * Uuid2,
    OUT RPC_STATUS __RPC_FAR * Status
    );

RPC_STATUS RPC_ENTRY
UuidCreateNil (
    OUT UUID __RPC_FAR * NilUuid
    );

int RPC_ENTRY
UuidEqual (
    IN UUID __RPC_FAR * Uuid1,
    IN UUID __RPC_FAR * Uuid2,
    OUT RPC_STATUS __RPC_FAR * Status
    );

unsigned short RPC_ENTRY
UuidHash (
    IN UUID __RPC_FAR * Uuid,
    OUT RPC_STATUS __RPC_FAR * Status
    );

int RPC_ENTRY
UuidIsNil (
    IN UUID __RPC_FAR * Uuid,
    OUT RPC_STATUS __RPC_FAR * Status
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcEpRegisterNoReplaceA (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned char * Annotation
    );

RPC_STATUS RPC_ENTRY
RpcEpRegisterNoReplaceW (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned short  * Annotation
    );

RPC_STATUS RPC_ENTRY
RpcEpRegisterA (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned char * Annotation
    );

RPC_STATUS RPC_ENTRY
RpcEpRegisterW (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned short * Annotation
    );

#ifdef UNICODE
#define RpcEpRegisterNoReplace RpcEpRegisterNoReplaceW
#define RpcEpRegister RpcEpRegisterW
#else /* UNICODE */
#define RpcEpRegisterNoReplace RpcEpRegisterNoReplaceA
#define RpcEpRegister RpcEpRegisterA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcEpRegisterNoReplace (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned  char * Annotation
    );

RPC_STATUS RPC_ENTRY
RpcEpRegister (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned char * Annotation
    );

#endif /* RPC_UNICODE_SUPPORTED */


RPC_STATUS RPC_ENTRY
RpcEpUnregister(
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
DceErrorInqTextA (
    IN RPC_STATUS RpcStatus,
    OUT unsigned char __RPC_FAR * ErrorText
    );

RPC_STATUS RPC_ENTRY
DceErrorInqTextW (
    IN RPC_STATUS RpcStatus,
    OUT unsigned short __RPC_FAR * ErrorText
    );

#ifdef UNICODE
#define DceErrorInqText DceErrorInqTextW
#else /* UNICODE */
#define DceErrorInqText DceErrorInqTextA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
DceErrorInqText (
    IN RPC_STATUS RpcStatus,
    OUT unsigned char __RPC_FAR * ErrorText
    );

#endif /* RPC_UNICODE_SUPPORTED */

#define DCE_C_ERROR_STRING_LEN 256

typedef I_RPC_HANDLE * RPC_EP_INQ_HANDLE;

#define  RPC_C_EP_ALL_ELTS        0
#define  RPC_C_EP_MATCH_BY_IF     1
#define  RPC_C_EP_MATCH_BY_OBJ    2
#define  RPC_C_EP_MATCH_BY_BOTH   3

#define  RPC_C_VERS_ALL           1
#define  RPC_C_VERS_COMPATIBLE    2
#define  RPC_C_VERS_EXACT         3
#define  RPC_C_VERS_MAJOR_ONLY    4
#define  RPC_C_VERS_UPTO          5

RPC_STATUS RPC_ENTRY
RpcMgmtEpEltInqBegin (
    IN RPC_BINDING_HANDLE EpBinding OPTIONAL,
    IN unsigned long InquiryType,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long VersOption OPTIONAL,
    IN UUID __RPC_FAR * ObjectUuid OPTIONAL,
    OUT RPC_EP_INQ_HANDLE __RPC_FAR * InquiryContext
    );

RPC_STATUS RPC_ENTRY
RpcMgmtEpEltInqDone (
    IN OUT RPC_EP_INQ_HANDLE __RPC_FAR * InquiryContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcMgmtEpEltInqNextA (
    IN RPC_EP_INQ_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding OPTIONAL,
    OUT UUID __RPC_FAR * ObjectUuid OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Annotation OPTIONAL
    );

RPC_STATUS RPC_ENTRY
RpcMgmtEpEltInqNextW (
    IN RPC_EP_INQ_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding OPTIONAL,
    OUT UUID __RPC_FAR * ObjectUuid OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * Annotation OPTIONAL
    );

#ifdef UNICODE
#define RpcMgmtEpEltInqNext RpcMgmtEpEltInqNextW
#else /* UNICODE */
#define RpcMgmtEpEltInqNext RpcMgmtEpEltInqNextA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcMgmtEpEltInqNext (
    IN RPC_EP_INQ_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Annotation OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

RPC_STATUS RPC_ENTRY
RpcMgmtEpUnregister (
    IN RPC_BINDING_HANDLE EpBinding OPTIONAL,
    IN RPC_IF_ID __RPC_FAR * IfId,
    IN RPC_BINDING_HANDLE Binding,
    IN UUID __RPC_FAR * ObjectUuid OPTIONAL
    );

typedef int
(__RPC_API * RPC_MGMT_AUTHORIZATION_FN) (
    IN RPC_BINDING_HANDLE ClientBinding,
    IN unsigned long RequestedMgmtOperation,
    OUT RPC_STATUS __RPC_FAR * Status
    );

#define RPC_C_MGMT_INQ_IF_IDS         0
#define RPC_C_MGMT_INQ_PRINC_NAME     1
#define RPC_C_MGMT_INQ_STATS          2
#define RPC_C_MGMT_IS_SERVER_LISTEN   3
#define RPC_C_MGMT_STOP_SERVER_LISTEN 4

RPC_STATUS RPC_ENTRY
RpcMgmtSetAuthorizationFn (
    IN RPC_MGMT_AUTHORIZATION_FN AuthorizationFn
    );


#define RPC_C_PARM_MAX_PACKET_LENGTH    1
#define RPC_C_PARM_BUFFER_LENGTH        2

RPC_STATUS RPC_ENTRY
RpcMgmtInqParameter (
    IN unsigned Parameter,
    IN unsigned long __RPC_FAR * Value
    );

RPC_STATUS RPC_ENTRY
RpcMgmtSetParameter (
    IN unsigned Parameter,
    IN unsigned long Value
    );

RPC_STATUS RPC_ENTRY
RpcMgmtBindingInqParameter (
    IN RPC_BINDING_HANDLE Handle,
    IN unsigned Parameter,
    IN unsigned long __RPC_FAR * Value
    );

RPC_STATUS RPC_ENTRY
RpcMgmtBindingSetParameter (
    IN RPC_BINDING_HANDLE Handle,
    IN unsigned Parameter,
    IN unsigned long Value
    );

#define RPC_IF_AUTOLISTEN 0x0001
#define RPC_IF_OLE              0x0002

#include <rpcdcep.h>

#ifdef __cplusplus
}
#endif

#endif /* __RPCDCE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\rpcndr.h ===
/*++

Copyright (c) 1992-1995 Microsoft Corporation

Module Name:

    rpcndr.h

Abstract:

    Definitions for stub data structures and prototypes of helper functions.

Author:

    DonnaLi (01-01-91)

Environment:

    DOS, Win 3.X, and Win/NT.

Revision History:

   DONNALI  08-29-91     Start recording history
   donnali  09-11-91     change conversion macros
   donnali  09-18-91     check in files for moving
   STEVEZ   10-15-91     Merge with NT tree
   donnali  10-28-91     add prototype
   donnali  11-19-91     bugfix for strings
   MIKEMON  12-17-91     DCE runtime API conversion
   donnali  03-24-92     change rpc public header f
   STEVEZ   04-04-92     add nsi include
   mikemon  04-18-92     security support and misc
   DovhH    04-24-24     Changed signature of <int>_from_ndr
                         (to unsigned <int>)
                         Added <base_type>_array_from_ndr routines
   RyszardK 06-17-93     Added support for hyper
   VibhasC  09-11-93     Created rpcndrn.h
   DKays    10-14-93     Fixed up rpcndrn.h MIDL 2.0
   RyszardK 01-15-94     Merged in the midl 2.0 changes from rpcndrn.h

--*/

#ifndef __RPCNDR_H__
#define __RPCNDR_H__

//
// Set the packing level for RPC structures for Dos, Windows and Mac.
//

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__) || defined(__RPC_MAC__)
#pragma pack(2)
#endif

#if defined(__RPC_MAC__)
#define _MAC_
#endif

#include <rpcnsip.h>

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************

     Network Computing Architecture (NCA) definition:

     Network Data Representation: (NDR) Label format:
     An unsigned long (32 bits) with the following layout:

     3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
     1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
    +---------------+---------------+---------------+-------+-------+
    |   Reserved    |   Reserved    |Floating point | Int   | Char  |
    |               |               |Representation | Rep.  | Rep.  |
    +---------------+---------------+---------------+-------+-------+

     Where

         Reserved:

             Must be zero (0) for NCA 1.5 and NCA 2.0.

         Floating point Representation is:

             0 - IEEE
             1 - VAX
             2 - Cray
             3 - IBM

         Int Rep. is Integer Representation:

             0 - Big Endian
             1 - Little Endian

         Char Rep. is Character Representation:

             0 - ASCII
             1 - EBCDIC

     The Microsoft Local Data Representation (for all platforms which are
     of interest currently is edefined below:

 ****************************************************************************/

#define NDR_CHAR_REP_MASK               (unsigned long)0X0000000FL
#define NDR_INT_REP_MASK                (unsigned long)0X000000F0L
#define NDR_FLOAT_REP_MASK              (unsigned long)0X0000FF00L

#define NDR_LITTLE_ENDIAN               (unsigned long)0X00000010L
#define NDR_BIG_ENDIAN                  (unsigned long)0X00000000L

#define NDR_IEEE_FLOAT                  (unsigned long)0X00000000L
#define NDR_VAX_FLOAT                   (unsigned long)0X00000100L

#define NDR_ASCII_CHAR                  (unsigned long)0X00000000L
#define NDR_EBCDIC_CHAR                 (unsigned long)0X00000001L

#if defined(__RPC_MAC__)
#define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000000L
#define NDR_LOCAL_ENDIAN                NDR_BIG_ENDIAN
#else
#define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000010L
#define NDR_LOCAL_ENDIAN                NDR_LITTLE_ENDIAN
#endif

/****************************************************************************
 *  Other MIDL base types / predefined types:
 ****************************************************************************/

#define small char
typedef unsigned char byte;
typedef unsigned char boolean;

#ifndef _HYPER_DEFINED
#define _HYPER_DEFINED

#if !defined(__RPC_DOS__) && !defined(__RPC_WIN16__) && !defined(__RPC_MAC__) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64))
#define  hyper           __int64
#define MIDL_uhyper  unsigned __int64
#else
typedef double  hyper;
typedef double MIDL_uhyper;
#endif

#endif // _HYPER_DEFINED

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifdef __RPC_DOS__
#define __RPC_CALLEE       __far __pascal
#endif

#ifdef __RPC_WIN16__
#define __RPC_CALLEE       __far __pascal __export
#endif

#ifdef __RPC_WIN32__
#if   (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define __RPC_CALLEE       __stdcall
#else
#define __RPC_CALLEE
#endif
#endif

#ifdef __RPC_MAC__
#define __RPC_CALLEE __far
#endif

#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void             __RPC_USER MIDL_user_free( void __RPC_FAR * );

#ifdef __RPC_WIN16__
#define RPC_VAR_ENTRY __export __cdecl
#else
#define RPC_VAR_ENTRY __cdecl
#endif


/* winnt only */
#if defined(_M_MRX000) || defined(_M_IX86) || defined(_M_ALPHA)
#define __MIDL_DECLSPEC_DLLIMPORT   __declspec(dllimport)
#define __MIDL_DECLSPEC_DLLEXPORT   __declspec(dllexport)
#else
#define __MIDL_DECLSPEC_DLLIMPORT
#define __MIDL_DECLSPEC_DLLEXPORT
#endif

/****************************************************************************
 * Context handle management related definitions:
 *
 * Client and Server Contexts.
 *
 ****************************************************************************/

typedef void __RPC_FAR * NDR_CCONTEXT;

typedef struct
    {
    void __RPC_FAR * pad[2];
    void __RPC_FAR * userContext;
    } __RPC_FAR * NDR_SCONTEXT;

#define NDRSContextValue(hContext) (&(hContext)->userContext)

#define cbNDRContext 20         /* size of context on WIRE */

typedef void (__RPC_USER __RPC_FAR * NDR_RUNDOWN)(void __RPC_FAR * context);

typedef struct _SCONTEXT_QUEUE {
    unsigned long   NumberOfObjects;
    NDR_SCONTEXT  * ArrayOfObjects;
    } SCONTEXT_QUEUE, __RPC_FAR * PSCONTEXT_QUEUE;

RPC_BINDING_HANDLE RPC_ENTRY
NDRCContextBinding (
    IN NDR_CCONTEXT CContext
    );

void RPC_ENTRY
NDRCContextMarshall (
        IN  NDR_CCONTEXT CContext,
        OUT void __RPC_FAR *pBuff
        );

void RPC_ENTRY
NDRCContextUnmarshall (
        OUT NDR_CCONTEXT __RPC_FAR *pCContext,
        IN  RPC_BINDING_HANDLE hBinding,
        IN  void __RPC_FAR *pBuff,
        IN  unsigned long DataRepresentation
        );

void RPC_ENTRY
NDRSContextMarshall (
        IN  NDR_SCONTEXT CContext,
        OUT void __RPC_FAR *pBuff,
        IN  NDR_RUNDOWN userRunDownIn
        );

NDR_SCONTEXT RPC_ENTRY
NDRSContextUnmarshall (
    IN  void __RPC_FAR *pBuff,
    IN  unsigned long DataRepresentation
    );

void RPC_ENTRY
RpcSsDestroyClientContext (
    IN void __RPC_FAR * __RPC_FAR * ContextHandle
    );


/****************************************************************************
    NDR conversion related definitions.
 ****************************************************************************/

#define byte_from_ndr(source, target) \
    { \
    *(target) = *(*(char __RPC_FAR * __RPC_FAR *)&(source)->Buffer)++; \
    }

#define byte_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char __RPC_FAR *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long __RPC_FAR *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

#define boolean_from_ndr(source, target) \
    { \
    *(target) = *(*(char __RPC_FAR * __RPC_FAR *)&(source)->Buffer)++; \
    }

#define boolean_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char __RPC_FAR *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long __RPC_FAR *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

#define small_from_ndr(source, target) \
    { \
    *(target) = *(*(char __RPC_FAR * __RPC_FAR *)&(source)->Buffer)++; \
    }

#define small_from_ndr_temp(source, target, format) \
    { \
    *(target) = *(*(char __RPC_FAR * __RPC_FAR *)(source))++; \
    }

#define small_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char __RPC_FAR *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long __RPC_FAR *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

/****************************************************************************
    Platform specific mapping of c-runtime functions.
 ****************************************************************************/

#ifdef __RPC_DOS__
#define MIDL_ascii_strlen(string) \
    _fstrlen(string)
#define MIDL_ascii_strcpy(target,source) \
    _fstrcpy(target,source)
#define MIDL_memset(s,c,n) \
    _fmemset(s,c,n)
#endif

#ifdef __RPC_WIN16__
#define MIDL_ascii_strlen(string) \
    _fstrlen(string)
#define MIDL_ascii_strcpy(target,source) \
    _fstrcpy(target,source)
#define MIDL_memset(s,c,n) \
    _fmemset(s,c,n)
#endif

#if defined(__RPC_WIN32__) || defined(__RPC_MAC__)
#define MIDL_ascii_strlen(string) \
    strlen(string)
#define MIDL_ascii_strcpy(target,source) \
    strcpy(target,source)
#define MIDL_memset(s,c,n) \
    memset(s,c,n)
#endif

/****************************************************************************
    Ndr Library helper function prototypes for MIDL 1.0 ndr functions.
 ****************************************************************************/

void RPC_ENTRY
NDRcopy (
    IN void __RPC_FAR *pTarget,
    IN void __RPC_FAR *pSource,
    IN unsigned int size
    );

size_t RPC_ENTRY
MIDL_wchar_strlen (
    IN wchar_t __RPC_FAR *   s
    );

void RPC_ENTRY
MIDL_wchar_strcpy (
    OUT void __RPC_FAR *     t,
    IN wchar_t __RPC_FAR *   s
    );

void RPC_ENTRY
char_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT unsigned char __RPC_FAR *                 Target
    );

void RPC_ENTRY
char_array_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT unsigned char __RPC_FAR *                 Target
    );

void RPC_ENTRY
short_from_ndr (
    IN OUT PRPC_MESSAGE                           source,
    OUT unsigned short __RPC_FAR *                target
    );

void RPC_ENTRY
short_array_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT unsigned short __RPC_FAR *                Target
    );

void RPC_ENTRY
short_from_ndr_temp (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR *  source,
    OUT unsigned short __RPC_FAR *                target,
    IN unsigned long                              format
    );

void RPC_ENTRY
long_from_ndr (
    IN OUT PRPC_MESSAGE                           source,
    OUT unsigned long __RPC_FAR *                 target
    );

void RPC_ENTRY
long_array_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT unsigned long __RPC_FAR *                 Target
    );

void RPC_ENTRY
long_from_ndr_temp (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR *  source,
    OUT unsigned long __RPC_FAR *                 target,
    IN unsigned long                              format
    );

void RPC_ENTRY
enum_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT unsigned int __RPC_FAR *                  Target
    );

void RPC_ENTRY
float_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT void __RPC_FAR *                          Target
    );

void RPC_ENTRY
float_array_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT void __RPC_FAR *                          Target
    );

void RPC_ENTRY
double_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT void __RPC_FAR *                          Target
    );

void RPC_ENTRY
double_array_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT void __RPC_FAR *                          Target
    );

void RPC_ENTRY
hyper_from_ndr (
    IN OUT PRPC_MESSAGE                           source,
    OUT    hyper __RPC_FAR *                      target
    );

void RPC_ENTRY
hyper_array_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT          hyper __RPC_FAR *                Target
    );

void RPC_ENTRY
hyper_from_ndr_temp (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR *  source,
    OUT             hyper __RPC_FAR *             target,
    IN   unsigned   long                          format
    );

void RPC_ENTRY
data_from_ndr (
    PRPC_MESSAGE                                  source,
    void __RPC_FAR *                              target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

void RPC_ENTRY
data_into_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

void RPC_ENTRY
tree_into_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

void RPC_ENTRY
data_size_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

void RPC_ENTRY
tree_size_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

void RPC_ENTRY
tree_peek_ndr (
    PRPC_MESSAGE                                  source,
    unsigned char __RPC_FAR * __RPC_FAR *         buffer,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

void __RPC_FAR * RPC_ENTRY
midl_allocate (
    size_t      size
    );

/****************************************************************************
    MIDL 2.0 ndr definitions.
 ****************************************************************************/

typedef unsigned long error_status_t;

#define _midl_ma1( p, cast )    *(*( cast **)&p)++
#define _midl_ma2( p, cast )    *(*( cast **)&p)++
#define _midl_ma4( p, cast )    *(*( cast **)&p)++
#define _midl_ma8( p, cast )    *(*( cast **)&p)++

#define _midl_unma1( p, cast )  *(( cast *)p)++
#define _midl_unma2( p, cast )  *(( cast *)p)++
#define _midl_unma3( p, cast )  *(( cast *)p)++
#define _midl_unma4( p, cast )  *(( cast *)p)++

// Some alignment specific macros.


#define _midl_fa2( p )          (p = (RPC_BUFPTR )((unsigned long)(p+1) & 0xfffffffe))
#define _midl_fa4( p )          (p = (RPC_BUFPTR )((unsigned long)(p+3) & 0xfffffffc))
#define _midl_fa8( p )          (p = (RPC_BUFPTR )((unsigned long)(p+7) & 0xfffffff8))

#define _midl_addp( p, n )      (p += n)

// Marshalling macros

#define _midl_marsh_lhs( p, cast )  *(*( cast **)&p)++
#define _midl_marsh_up( mp, p )     *(*(unsigned long **)&mp)++ = (unsigned long)p
#define _midl_advmp( mp )           *(*(unsigned long **)&mp)++
#define _midl_unmarsh_up( p )       (*(*(unsigned long **)&p)++)


////////////////////////////////////////////////////////////////////////////
// Ndr macros.
////////////////////////////////////////////////////////////////////////////

#define NdrMarshConfStringHdr( p, s, l )    (_midl_ma4( p, unsigned long) = s, \
                                            _midl_ma4( p, unsigned long) = 0, \
                                            _midl_ma4( p, unsigned long) = l)

#define NdrUnMarshConfStringHdr(p, s, l)    ((s=_midl_unma4(p,unsigned long),\
                                            (_midl_addp(p,4)),               \
                                            (l=_midl_unma4(p,unsigned long))

#define NdrMarshCCtxtHdl(pc,p)  (NDRCContextMarshall( (NDR_CCONTEXT)pc, p ),p+20)

#define NdrUnMarshCCtxtHdl(pc,p,h,drep) \
        (NDRCContextUnmarshall((NDR_CONTEXT)pc,h,p,drep), p+20)

#define NdrUnMarshSCtxtHdl(pc, p,drep)  (pc = NdrSContextUnMarshall(p,drep ))


#define NdrMarshSCtxtHdl(pc,p,rd)   (NdrSContextMarshall((NDR_SCONTEXT)pc,p, (NDR_RUNDOWN)rd)

#define NdrFieldOffset(s,f)     (long)(& (((s __RPC_FAR *)0)->f))
#define NdrFieldPad(s,f,p,t)    (NdrFieldOffset(s,f) - NdrFieldOffset(s,p) - sizeof(t))

#if defined(__RPC_MAC__)
#define NdrFcShort(s)   (unsigned char)(s >> 8), (unsigned char)(s & 0xff)
#define NdrFcLong(s)    (unsigned char)(s >> 24), (unsigned char)((s & 0x00ff0000) >> 16), \
                        (unsigned char)((s & 0x0000ff00) >> 8), (unsigned char)(s & 0xff)
#else
#define NdrFcShort(s)   (unsigned char)(s & 0xff), (unsigned char)(s >> 8)
#define NdrFcLong(s)    (unsigned char)(s & 0xff), (unsigned char)((s & 0x0000ff00) >> 8), \
                        (unsigned char)((s & 0x00ff0000) >> 16), (unsigned char)(s >> 24)
#endif //  Mac

/////////////////////////////////////////////////////////////////////////////
// Some stub helper functions.
/////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// Stub helper structures.
////////////////////////////////////////////////////////////////////////////

struct _MIDL_STUB_MESSAGE;
struct _MIDL_STUB_DESC;
struct _FULL_PTR_XLAT_TABLES;

typedef unsigned char __RPC_FAR * RPC_BUFPTR;
typedef unsigned long             RPC_LENGTH;

// Expression evaluation callback routine prototype.
typedef void (__RPC_USER __RPC_FAR * EXPR_EVAL)( struct _MIDL_STUB_MESSAGE __RPC_FAR * );

typedef const unsigned char __RPC_FAR * PFORMAT_STRING;

/*
 * Multidimensional conformant/varying array struct.
 */
typedef struct
    {
    long                            Dimension;

    /* These fields MUST be (unsigned long *) */
    unsigned long __RPC_FAR *       BufferConformanceMark;
    unsigned long __RPC_FAR *       BufferVarianceMark;

    /* Count arrays, used for top level arrays in -Os stubs */
    unsigned long __RPC_FAR *       MaxCountArray;
    unsigned long __RPC_FAR *       OffsetArray;
    unsigned long __RPC_FAR *       ActualCountArray;
    } ARRAY_INFO, __RPC_FAR *PARRAY_INFO;

/*
 *  Pipe related definitions.
 */

typedef void
(__RPC_FAR __RPC_API * NDR_PIPE_PULL_RTN)(
        char          __RPC_FAR *  state,
        void          __RPC_FAR *  buf,
        unsigned long              esize,
        unsigned long __RPC_FAR *  ecount );

typedef void
(__RPC_FAR __RPC_API * NDR_PIPE_PUSH_RTN)(
        char          __RPC_FAR *  state,
        void          __RPC_FAR *  buf,
        unsigned long              ecount );

typedef void
(__RPC_FAR __RPC_API * NDR_PIPE_ALLOC_RTN)(
        char             __RPC_FAR *  state,
        unsigned long                 bsize,
        void __RPC_FAR * __RPC_FAR *  buf,
        unsigned long    __RPC_FAR *  bcount );


typedef struct  _GENERIC_PIPE_TYPE
    {
    NDR_PIPE_PULL_RTN       pfnPull;
    NDR_PIPE_PUSH_RTN       pfnPush;
    NDR_PIPE_ALLOC_RTN      pfnAlloc;
    char  __RPC_FAR *       pState;
    } GENERIC_PIPE_TYPE;


/*
 * MIDL Stub Message
 */
#if !defined(__RPC_DOS__) && !defined(__RPC_WIN16__) && !defined(__RPC_MAC__)
#include <pshpack4.h>
#endif

typedef struct _MIDL_STUB_MESSAGE
    {
    /* RPC message structure. */
    PRPC_MESSAGE                RpcMsg;

    /* Pointer into RPC message buffer. */
    unsigned char __RPC_FAR *   Buffer;

    /*
     * These are used internally by the Ndr routines to mark the beginning
     * and end of an incoming RPC buffer.
     */
    unsigned char __RPC_FAR *   BufferStart;
    unsigned char __RPC_FAR *   BufferEnd;

    /*
     * Used internally by the Ndr routines as a place holder in the buffer.
     * On the marshalling side it's used to mark the location where conformance
     * size should be marshalled.
     * On the unmarshalling side it's used to mark the location in the buffer
     * used during pointer unmarshalling to base pointer offsets off of.
     */
    unsigned char __RPC_FAR *   BufferMark;

    /* Set by the buffer sizing routines. */
    unsigned long               BufferLength;

    /* Set by the memory sizing routines. */
    unsigned long               MemorySize;

    /* Pointer to user memory. */
    unsigned char __RPC_FAR *   Memory;

    /* Is the Ndr routine begin called from a client side stub. */
    int                         IsClient;

    /* Can the buffer be re-used for memory on unmarshalling. */
    int                         ReuseBuffer;

    /* Holds the current pointer to an allocate all nodes memory block. */
    unsigned char __RPC_FAR *   AllocAllNodesMemory;

    /* Used for debugging asserts only, remove later. */
    unsigned char __RPC_FAR *   AllocAllNodesMemoryEnd;

    /*
     * Stuff needed while handling complex structures
     */

    /* Ignore imbeded pointers while computing buffer or memory sizes. */
    int                         IgnoreEmbeddedPointers;

    /*
     * This marks the location in the buffer where pointees of a complex
     * struct reside.
     */
    unsigned char __RPC_FAR *   PointerBufferMark;

    /*
     * Used to catch errors in SendReceive.
     */
    unsigned char               fBufferValid;

    /*
     * Obsolete unused field (formerly MaxContextHandleNumber).
     */
    unsigned char               Unused;

    /*
     * Used internally by the Ndr routines.  Holds the max counts for
     * a conformant array.
     */
    unsigned long               MaxCount;

    /*
     * Used internally by the Ndr routines.  Holds the offsets for a varying
     * array.
     */
    unsigned long               Offset;

    /*
     * Used internally by the Ndr routines.  Holds the actual counts for
     * a varying array.
     */
    unsigned long               ActualCount;

    /* Allocation and Free routine to be used by the Ndr routines. */
    void __RPC_FAR *    (__RPC_FAR __RPC_API * pfnAllocate)(size_t);
    void                (__RPC_FAR __RPC_API * pfnFree)(void __RPC_FAR *);

    /*
     * Top of parameter stack.  Used for "single call" stubs during marshalling
     * to hold the beginning of the parameter list on the stack.  Needed to
     * extract parameters which hold attribute values for top level arrays and
     * pointers.
     */
    unsigned char __RPC_FAR *       StackTop;

    /*
     *  Fields used for the transmit_as and represent_as objects.
     *  For represent_as the mapping is: presented=local, transmit=named.
     */
    unsigned char __RPC_FAR *       pPresentedType;
    unsigned char __RPC_FAR *       pTransmitType;

    /*
     * When we first construct a binding on the client side, stick it
     * in the rpcmessage and later call RpcGetBuffer, the handle field
     * in the rpcmessage is changed. That's fine except that we need to
     * have that original handle for use in unmarshalling context handles
     * (the second argument in NDRCContextUnmarshall to be exact). So
     * stash the contructed handle here and extract it when needed.
     */
    handle_t                        SavedHandle;

    /*
     * Pointer back to the stub descriptor.  Use this to get all handle info.
     */
    const struct _MIDL_STUB_DESC __RPC_FAR *    StubDesc;

    /*
     * Full pointer stuff.
     */
    struct _FULL_PTR_XLAT_TABLES __RPC_FAR *    FullPtrXlatTables;

    unsigned long                   FullPtrRefId;

    /*
     * flags
     */

    int                             fCheckBounds;

    int                             fInDontFree       :1;
    int                             fDontCallFreeInst :1;
    int                             fInOnlyParam      :1;
    int                             fHasReturn        :1;

    unsigned long                   dwDestContext;
    void __RPC_FAR *                pvDestContext;

    NDR_SCONTEXT *                  SavedContextHandles;

    long                            ParamNumber;

    struct IRpcChannelBuffer __RPC_FAR *    pRpcChannelBuffer;

    PARRAY_INFO                     pArrayInfo;

    /*
     * This is where the Beta2 stub message ends.
     */

    unsigned long __RPC_FAR *       SizePtrCountArray;
    unsigned long __RPC_FAR *       SizePtrOffsetArray;
    unsigned long __RPC_FAR *       SizePtrLengthArray;

    /*
     * Interpreter argument queue.  Used on server side only.
     */
    void __RPC_FAR *                pArgQueue;

    unsigned long                   dwStubPhase;

    /*
     * Pipe descriptor, defined for the 4.0 release.
     */

    void        __RPC_FAR *         pPipeDesc;

    unsigned long                   Reserved[4];

    /*
     *  Fields up to this point present since the 3.50 release.
     */ 

    } MIDL_STUB_MESSAGE, __RPC_FAR *PMIDL_STUB_MESSAGE;

#if !defined(__RPC_DOS__) && !defined(__RPC_WIN16__) && !defined(__RPC_MAC__)
#include <poppack.h>
#endif

/*
 * Generic handle bind/unbind routine pair.
 */
typedef void __RPC_FAR *
        (__RPC_FAR __RPC_API * GENERIC_BINDING_ROUTINE)
        (void __RPC_FAR *);
typedef void
        (__RPC_FAR __RPC_API * GENERIC_UNBIND_ROUTINE)
        (void __RPC_FAR *, unsigned char __RPC_FAR *);

typedef struct _GENERIC_BINDING_ROUTINE_PAIR
    {
    GENERIC_BINDING_ROUTINE     pfnBind;
    GENERIC_UNBIND_ROUTINE      pfnUnbind;
    } GENERIC_BINDING_ROUTINE_PAIR, __RPC_FAR *PGENERIC_BINDING_ROUTINE_PAIR;

typedef struct __GENERIC_BINDING_INFO
    {
    void __RPC_FAR *            pObj;
    unsigned int                Size;
    GENERIC_BINDING_ROUTINE     pfnBind;
    GENERIC_UNBIND_ROUTINE      pfnUnbind;
    } GENERIC_BINDING_INFO, __RPC_FAR *PGENERIC_BINDING_INFO;

// typedef EXPR_EVAL - see above
// typedefs for xmit_as

#if (defined(_MSC_VER)) && !defined(MIDL_PASS)
// a Microsoft C++ compiler
#define NDR_SHAREABLE __inline
#else
#define NDR_SHAREABLE static
#endif


typedef void (__RPC_FAR __RPC_USER * XMIT_HELPER_ROUTINE)
    ( PMIDL_STUB_MESSAGE );

typedef struct _XMIT_ROUTINE_QUINTUPLE
    {
    XMIT_HELPER_ROUTINE     pfnTranslateToXmit;
    XMIT_HELPER_ROUTINE     pfnTranslateFromXmit;
    XMIT_HELPER_ROUTINE     pfnFreeXmit;
    XMIT_HELPER_ROUTINE     pfnFreeInst;
    } XMIT_ROUTINE_QUINTUPLE, __RPC_FAR *PXMIT_ROUTINE_QUINTUPLE;

typedef unsigned long
(__RPC_FAR __RPC_USER * USER_MARSHAL_SIZING_ROUTINE)
    (unsigned long __RPC_FAR *,
     unsigned long,
     void __RPC_FAR * );

typedef unsigned char __RPC_FAR *
(__RPC_FAR __RPC_USER * USER_MARSHAL_MARSHALLING_ROUTINE)
    (unsigned long __RPC_FAR *,
     unsigned char  __RPC_FAR * ,
     void __RPC_FAR * );

typedef unsigned char __RPC_FAR *
(__RPC_FAR __RPC_USER * USER_MARSHAL_UNMARSHALLING_ROUTINE)
    (unsigned long __RPC_FAR *,
     unsigned char  __RPC_FAR * ,
     void __RPC_FAR * );

typedef void (__RPC_FAR __RPC_USER * USER_MARSHAL_FREEING_ROUTINE)
    (unsigned long __RPC_FAR *,
     void __RPC_FAR * );

typedef struct _USER_MARSHAL_ROUTINE_QUADRUPLE
    {
    USER_MARSHAL_SIZING_ROUTINE          pfnBufferSize;
    USER_MARSHAL_MARSHALLING_ROUTINE     pfnMarshall;
    USER_MARSHAL_UNMARSHALLING_ROUTINE   pfnUnmarshall;
    USER_MARSHAL_FREEING_ROUTINE         pfnFree;
    } USER_MARSHAL_ROUTINE_QUADRUPLE;

typedef struct _USER_MARSHAL_CB
{
    unsigned long       Flags;
    PMIDL_STUB_MESSAGE  pStubMsg;
    PFORMAT_STRING      pReserve;
} USER_MARSHAL_CB;

#define USER_CALL_CTXT_MASK(f)  ((f) & 0x3)
#define GET_USER_DATA_REP(f)    ((f) >> 16)

typedef struct _MALLOC_FREE_STRUCT
    {
    void __RPC_FAR *	(__RPC_FAR __RPC_USER * pfnAllocate)(size_t);
    void                (__RPC_FAR __RPC_USER * pfnFree)(void __RPC_FAR *);
    } MALLOC_FREE_STRUCT;

typedef struct _COMM_FAULT_OFFSETS
    {
    short       CommOffset;
    short       FaultOffset;
    } COMM_FAULT_OFFSETS;

/*
 * MIDL Stub Descriptor
 */

typedef struct _MIDL_STUB_DESC
    {

    void __RPC_FAR *    RpcInterfaceInformation;

    void __RPC_FAR *    (__RPC_FAR __RPC_API * pfnAllocate)(size_t);
    void                (__RPC_FAR __RPC_API * pfnFree)(void __RPC_FAR *);

    union
        {
        handle_t __RPC_FAR *            pAutoHandle;
        handle_t __RPC_FAR *            pPrimitiveHandle;
        PGENERIC_BINDING_INFO           pGenericBindingInfo;
        } IMPLICIT_HANDLE_INFO;

    const NDR_RUNDOWN __RPC_FAR *                   apfnNdrRundownRoutines;
    const GENERIC_BINDING_ROUTINE_PAIR __RPC_FAR *  aGenericBindingRoutinePairs;

    const EXPR_EVAL __RPC_FAR *                     apfnExprEval;

    const XMIT_ROUTINE_QUINTUPLE __RPC_FAR *        aXmitQuintuple;

    const unsigned char __RPC_FAR *                 pFormatTypes;

    int                                             fCheckBounds;

    /* Ndr library version. */
    unsigned long                                   Version;

    /*
     * Reserved for future use. (no reserves )
     */

    MALLOC_FREE_STRUCT __RPC_FAR *                  pMallocFreeStruct;

    long                                MIDLVersion;

    const COMM_FAULT_OFFSETS __RPC_FAR *    CommFaultOffsets;

    // New fields for version 3.0+ 

    const USER_MARSHAL_ROUTINE_QUADRUPLE __RPC_FAR * aUserMarshalQuadruple;

    long                                    Reserved1;
    long                                    Reserved2;
    long                                    Reserved3;
    long                                    Reserved4;
    long                                    Reserved5;

    } MIDL_STUB_DESC;

typedef const MIDL_STUB_DESC __RPC_FAR * PMIDL_STUB_DESC;

typedef void __RPC_FAR * PMIDL_XMIT_TYPE;

/*
 * MIDL Stub Format String.  This is a const in the stub.
 */
#if !defined( RC_INVOKED )
#pragma warning( disable:4200 )
#endif
typedef struct _MIDL_FORMAT_STRING
    {
    short               Pad;
    unsigned char       Format[];
    } MIDL_FORMAT_STRING;
#if !defined( RC_INVOKED )
#pragma warning( default:4200 )
#endif

/*
 * Stub thunk used for some interpreted server stubs.
 */
typedef void (__RPC_FAR __RPC_API * STUB_THUNK)( PMIDL_STUB_MESSAGE );

typedef long (__RPC_FAR __RPC_API * SERVER_ROUTINE)();

/*
 * Server Interpreter's information strucuture.
 */
typedef struct  _MIDL_SERVER_INFO_
    {
    PMIDL_STUB_DESC             pStubDesc;
    const SERVER_ROUTINE *      DispatchTable;
    PFORMAT_STRING              ProcString;
    const unsigned short *      FmtStringOffset;
    const STUB_THUNK *          ThunkTable;
    } MIDL_SERVER_INFO, *PMIDL_SERVER_INFO;

/*
 * Stubless object proxy information structure.
 */
typedef struct _MIDL_STUBLESS_PROXY_INFO
    {
    PMIDL_STUB_DESC                     pStubDesc;
    PFORMAT_STRING                      ProcFormatString;
    const unsigned short __RPC_FAR *    FormatStringOffset;
    } MIDL_STUBLESS_PROXY_INFO;

typedef MIDL_STUBLESS_PROXY_INFO __RPC_FAR * PMIDL_STUBLESS_PROXY_INFO;

/*
 * This is the return value from NdrClientCall.
 */
typedef union _CLIENT_CALL_RETURN
    {
    void __RPC_FAR *        Pointer;
    long                    Simple;
    } CLIENT_CALL_RETURN;

/*
 * Full pointer data structures.
 */

typedef enum
        {
        XLAT_SERVER = 1,
        XLAT_CLIENT
        } XLAT_SIDE;

/*
 * Stores the translation for the conversion from a full pointer into it's
 * corresponding ref id.
 */
typedef struct _FULL_PTR_TO_REFID_ELEMENT
    {
    struct _FULL_PTR_TO_REFID_ELEMENT __RPC_FAR *  Next;

    void __RPC_FAR *            Pointer;
    unsigned long       RefId;
    unsigned char       State;
    } FULL_PTR_TO_REFID_ELEMENT, __RPC_FAR *PFULL_PTR_TO_REFID_ELEMENT;

/*
 * Full pointer translation tables.
 */
typedef struct _FULL_PTR_XLAT_TABLES
    {
    /*
     * Ref id to pointer translation information.
     */
    struct
        {
        void __RPC_FAR *__RPC_FAR *             XlatTable;
        unsigned char __RPC_FAR *     StateTable;
        unsigned long       NumberOfEntries;
        } RefIdToPointer;

    /*
     * Pointer to ref id translation information.
     */
    struct
        {
        PFULL_PTR_TO_REFID_ELEMENT __RPC_FAR *  XlatTable;
        unsigned long                   NumberOfBuckets;
        unsigned long                   HashMask;
        } PointerToRefId;

    /*
     * Next ref id to use.
     */
    unsigned long           NextRefId;

    /*
     * Keep track of the translation size we're handling : server or client.
     * This tells us when we have to do reverse translations when we insert
     * new translations.  On the server we must insert a pointer-to-refid
     * translation whenever we insert a refid-to-pointer translation, and
     * vica versa for the client.
     */
    XLAT_SIDE               XlatSide;
    } FULL_PTR_XLAT_TABLES, __RPC_FAR *PFULL_PTR_XLAT_TABLES;

/***************************************************************************
 ** New MIDL 2.0 Ndr routine templates
 ***************************************************************************/

/*
 * Marshall routines
 */

void RPC_ENTRY
NdrSimpleTypeMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *                       pMemory,
    unsigned char                       FormatChar
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrPointerMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Structures */

unsigned char __RPC_FAR * RPC_ENTRY
NdrSimpleStructMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantStructMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantVaryingStructMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrHardStructMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrComplexStructMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Arrays */

unsigned char __RPC_FAR * RPC_ENTRY
NdrFixedArrayMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantArrayMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrComplexArrayMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Strings */

unsigned char __RPC_FAR * RPC_ENTRY
NdrNonConformantStringMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantStringMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Unions */

unsigned char __RPC_FAR * RPC_ENTRY
NdrEncapsulatedUnionMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrNonEncapsulatedUnionMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Byte count pointer */

unsigned char __RPC_FAR * RPC_ENTRY
NdrByteCountPointerMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Transmit as and represent as*/

unsigned char __RPC_FAR * RPC_ENTRY
NdrXmitOrRepAsMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* User_marshal */

unsigned char __RPC_FAR * RPC_ENTRY
NdrUserMarshalMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Cairo interface pointer */

unsigned char __RPC_FAR * RPC_ENTRY
NdrInterfacePointerMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Context handles */

void RPC_ENTRY
NdrClientContextMarshall(
    PMIDL_STUB_MESSAGE    pStubMsg,
    NDR_CCONTEXT          ContextHandle,
    int                   fCheck
    );

void RPC_ENTRY
NdrServerContextMarshall(
    PMIDL_STUB_MESSAGE    pStubMsg,
    NDR_SCONTEXT          ContextHandle,
    NDR_RUNDOWN           RundownRoutine
    );

/*
 * Unmarshall routines
 */

void RPC_ENTRY
NdrSimpleTypeUnmarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    unsigned char                       FormatChar
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrPointerUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Structures */

unsigned char __RPC_FAR * RPC_ENTRY
NdrSimpleStructUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantStructUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantVaryingStructUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrHardStructUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrComplexStructUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Arrays */

unsigned char __RPC_FAR * RPC_ENTRY
NdrFixedArrayUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantArrayUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrComplexArrayUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Strings */

unsigned char __RPC_FAR * RPC_ENTRY
NdrNonConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Unions */

unsigned char __RPC_FAR * RPC_ENTRY
NdrEncapsulatedUnionUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrNonEncapsulatedUnionUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Byte count pointer */

unsigned char __RPC_FAR * RPC_ENTRY
NdrByteCountPointerUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Transmit as and represent as*/

unsigned char __RPC_FAR * RPC_ENTRY
NdrXmitOrRepAsUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* User_marshal */

unsigned char __RPC_FAR * RPC_ENTRY
NdrUserMarshalUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Cairo interface pointer */

unsigned char __RPC_FAR * RPC_ENTRY
NdrInterfacePointerUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Context handles */

void RPC_ENTRY
NdrClientContextUnmarshall(
    PMIDL_STUB_MESSAGE          pStubMsg,
    NDR_CCONTEXT __RPC_FAR *    pContextHandle,
    RPC_BINDING_HANDLE          BindHandle
    );

NDR_SCONTEXT RPC_ENTRY
NdrServerContextUnmarshall(
    PMIDL_STUB_MESSAGE          pStubMsg
    );

/*
 * Buffer sizing routines
 */

void RPC_ENTRY
NdrPointerBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Structures */

void RPC_ENTRY
NdrSimpleStructBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

void RPC_ENTRY
NdrConformantStructBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

void RPC_ENTRY
NdrConformantVaryingStructBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

void RPC_ENTRY
NdrHardStructBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

void RPC_ENTRY
NdrComplexStructBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Arrays */

void RPC_ENTRY
NdrFixedArrayBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

void RPC_ENTRY
NdrConformantArrayBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

void RPC_ENTRY
NdrConformantVaryingArrayBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

void RPC_ENTRY
NdrVaryingArrayBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

void RPC_ENTRY
NdrComplexArrayBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Strings */

void RPC_ENTRY
NdrConformantStringBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

void RPC_ENTRY
NdrNonConformantStringBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Unions */

void RPC_ENTRY
NdrEncapsulatedUnionBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

void RPC_ENTRY
NdrNonEncapsulatedUnionBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Byte count pointer */

void RPC_ENTRY
NdrByteCountPointerBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Transmit as and represent as*/

void RPC_ENTRY
NdrXmitOrRepAsBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* User_marshal */

void RPC_ENTRY
NdrUserMarshalBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Cairo Interface pointer */

void RPC_ENTRY
NdrInterfacePointerBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

// Context Handle size
//
void RPC_ENTRY
NdrContextHandleSize(
    PMIDL_STUB_MESSAGE          pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/*
 * Memory sizing routines
 */

unsigned long RPC_ENTRY
NdrPointerMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Structures */

unsigned long RPC_ENTRY
NdrSimpleStructMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY
NdrConformantStructMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY
NdrConformantVaryingStructMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY
NdrHardStructMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY
NdrComplexStructMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Arrays */

unsigned long RPC_ENTRY
NdrFixedArrayMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY
NdrConformantArrayMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY
NdrConformantVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY
NdrVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY
NdrComplexArrayMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Strings */

unsigned long RPC_ENTRY
NdrConformantStringMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY
NdrNonConformantStringMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Unions */

unsigned long RPC_ENTRY
NdrEncapsulatedUnionMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

unsigned long RPC_ENTRY
NdrNonEncapsulatedUnionMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Transmit as and represent as*/

unsigned long RPC_ENTRY
NdrXmitOrRepAsMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* User_marshal */

unsigned long RPC_ENTRY
NdrUserMarshalMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Cairo Interface pointer */

unsigned long RPC_ENTRY
NdrInterfacePointerMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/*
 * Freeing routines
 */

void RPC_ENTRY
NdrPointerFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Structures */

void RPC_ENTRY
NdrSimpleStructFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

void RPC_ENTRY
NdrConformantStructFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

void RPC_ENTRY
NdrConformantVaryingStructFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

void RPC_ENTRY
NdrHardStructFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

void RPC_ENTRY
NdrComplexStructFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Arrays */

void RPC_ENTRY
NdrFixedArrayFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

void RPC_ENTRY
NdrConformantArrayFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

void RPC_ENTRY
NdrConformantVaryingArrayFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

void RPC_ENTRY
NdrVaryingArrayFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

void RPC_ENTRY
NdrComplexArrayFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Unions */

void RPC_ENTRY
NdrEncapsulatedUnionFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

void RPC_ENTRY
NdrNonEncapsulatedUnionFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Byte count */

void RPC_ENTRY
NdrByteCountPointerFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Transmit as and represent as*/

void RPC_ENTRY
NdrXmitOrRepAsFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* User_marshal */

void RPC_ENTRY
NdrUserMarshalFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Cairo Interface pointer */

void RPC_ENTRY
NdrInterfacePointerFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/*
 * Endian conversion routine.
 */

void RPC_ENTRY
NdrConvert2(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    long                                NumberParams
    );

void RPC_ENTRY
NdrConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

#define USER_MARSHAL_FC_BYTE         1
#define USER_MARSHAL_FC_CHAR         2
#define USER_MARSHAL_FC_SMALL        3
#define USER_MARSHAL_FC_USMALL       4
#define USER_MARSHAL_FC_WCHAR        5
#define USER_MARSHAL_FC_SHORT        6
#define USER_MARSHAL_FC_USHORT       7
#define USER_MARSHAL_FC_LONG         8
#define USER_MARSHAL_FC_ULONG        9
#define USER_MARSHAL_FC_FLOAT       10
#define USER_MARSHAL_FC_HYPER       11
#define USER_MARSHAL_FC_DOUBLE      12

unsigned char __RPC_FAR * RPC_ENTRY
NdrUserMarshalSimpleTypeConvert( 
    unsigned long * pFlags,
    unsigned char * pBuffer,
    unsigned char   FormatChar
    );

/* 
 * Auxilary routines
 */

void RPC_ENTRY
NdrClientInitializeNew(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    unsigned int                        ProcNum
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrServerInitializeNew(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor
    );

void RPC_ENTRY
NdrClientInitialize(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    unsigned int                        ProcNum
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrServerInitialize(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrServerInitializeUnmarshall (
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    PRPC_MESSAGE                        pRpcMsg
    );

void RPC_ENTRY
NdrServerInitializeMarshall (
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrGetBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long                       BufferLength,
    RPC_BINDING_HANDLE                  Handle
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrNsGetBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long                       BufferLength,
    RPC_BINDING_HANDLE                  Handle
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrSendReceive(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR*                        pBufferEnd
    );

unsigned char __RPC_FAR * RPC_ENTRY
NdrNsSendReceive(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *                       pBufferEnd,
    RPC_BINDING_HANDLE __RPC_FAR *              pAutoHandle
    );

void RPC_ENTRY
NdrFreeBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg
    );

/*
 * Interpeter calls.
 */

/* client */

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall2(
    PMIDL_STUB_DESC                     pStubDescriptor,
    PFORMAT_STRING                      pFormat,
    ...
    );

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall(
    PMIDL_STUB_DESC                     pStubDescriptor,
    PFORMAT_STRING                      pFormat,
    ...
    );

/* server */
typedef enum {
    STUB_UNMARSHAL,
    STUB_CALL_SERVER,
    STUB_MARSHAL,
    STUB_CALL_SERVER_NO_HRESULT
}STUB_PHASE;

typedef enum {
    PROXY_CALCSIZE,
    PROXY_GETBUFFER,
    PROXY_MARSHAL,
    PROXY_SENDRECEIVE,
    PROXY_UNMARSHAL
}PROXY_PHASE;

long RPC_ENTRY
NdrStubCall2(
    struct IRpcStubBuffer __RPC_FAR *    pThis,
    struct IRpcChannelBuffer __RPC_FAR * pChannel,
    PRPC_MESSAGE                         pRpcMsg,
    unsigned long __RPC_FAR *            pdwStubPhase
    );

void RPC_ENTRY
NdrServerCall2(
    PRPC_MESSAGE                         pRpcMsg
    );

long RPC_ENTRY
NdrStubCall (
    struct IRpcStubBuffer __RPC_FAR *    pThis,
    struct IRpcChannelBuffer __RPC_FAR * pChannel,
    PRPC_MESSAGE                         pRpcMsg,
    unsigned long __RPC_FAR *            pdwStubPhase
    );

void RPC_ENTRY
NdrServerCall(
    PRPC_MESSAGE                        pRpcMsg
    );

int RPC_ENTRY
NdrServerUnmarshall(
    struct IRpcChannelBuffer __RPC_FAR * pChannel,
    PRPC_MESSAGE                         pRpcMsg,
    PMIDL_STUB_MESSAGE                   pStubMsg,
    PMIDL_STUB_DESC                      pStubDescriptor,
    PFORMAT_STRING                       pFormat,
    void __RPC_FAR *                     pParamList
    );

void RPC_ENTRY
NdrServerMarshall(
    struct IRpcStubBuffer __RPC_FAR *    pThis,
    struct IRpcChannelBuffer __RPC_FAR * pChannel,
    PMIDL_STUB_MESSAGE                   pStubMsg,
    PFORMAT_STRING                       pFormat
    );

/* Comm and Fault status */

RPC_STATUS RPC_ENTRY
NdrMapCommAndFaultStatus(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long __RPC_FAR *                       pCommStatus,
    unsigned long __RPC_FAR *                       pFaultStatus,
    RPC_STATUS                          Status
    );

/* Helper routines */

int RPC_ENTRY
NdrSH_UPDecision(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    RPC_BUFPTR                          pBuffer
    );

int RPC_ENTRY
NdrSH_TLUPDecision(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem
    );

int RPC_ENTRY
NdrSH_TLUPDecisionBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem
    );

int RPC_ENTRY
NdrSH_IfAlloc(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

int RPC_ENTRY
NdrSH_IfAllocRef(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

int RPC_ENTRY
NdrSH_IfAllocSet(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

RPC_BUFPTR RPC_ENTRY
NdrSH_IfCopy(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

RPC_BUFPTR RPC_ENTRY
NdrSH_IfAllocCopy(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

unsigned long RPC_ENTRY
NdrSH_Copy(
    unsigned char           __RPC_FAR *         pStubMsg,
    unsigned char           __RPC_FAR *         pPtrInMem,
    unsigned long                       Count
    );

void RPC_ENTRY
NdrSH_IfFree(
    PMIDL_STUB_MESSAGE                  pMessage,
    unsigned char           __RPC_FAR *         pPtr );


RPC_BUFPTR  RPC_ENTRY
NdrSH_StringMarshall(
    PMIDL_STUB_MESSAGE                  pMessage,
    unsigned char           __RPC_FAR *         pMemory,
    unsigned long                       Count,
    int                                 Size );

RPC_BUFPTR  RPC_ENTRY
NdrSH_StringUnMarshall(
    PMIDL_STUB_MESSAGE                  pMessage,
    unsigned char           __RPC_FAR *__RPC_FAR *          pMemory,
    int                                 Size );

/****************************************************************************
    MIDL 2.0 memory package: rpc_ss_* rpc_sm_*
 ****************************************************************************/

typedef void __RPC_FAR * RPC_SS_THREAD_HANDLE;

typedef void __RPC_FAR * __RPC_API
RPC_CLIENT_ALLOC (
    IN size_t Size
    );

typedef void __RPC_API
RPC_CLIENT_FREE (
    IN void __RPC_FAR * Ptr
    );

/*++
     RpcSs* package
--*/

void __RPC_FAR * RPC_ENTRY
RpcSsAllocate (
    IN size_t Size
    );

void RPC_ENTRY
RpcSsDisableAllocate (
    void
    );

void RPC_ENTRY
RpcSsEnableAllocate (
    void
    );

void RPC_ENTRY
RpcSsFree (
    IN void __RPC_FAR * NodeToFree
    );

RPC_SS_THREAD_HANDLE RPC_ENTRY
RpcSsGetThreadHandle (
    void
    );

void RPC_ENTRY
RpcSsSetClientAllocFree (
    IN RPC_CLIENT_ALLOC __RPC_FAR * ClientAlloc,
    IN RPC_CLIENT_FREE __RPC_FAR * ClientFree
    );

void RPC_ENTRY
RpcSsSetThreadHandle (
    IN RPC_SS_THREAD_HANDLE Id
    );

void RPC_ENTRY
RpcSsSwapClientAllocFree (
    IN RPC_CLIENT_ALLOC __RPC_FAR * ClientAlloc,
    IN RPC_CLIENT_FREE __RPC_FAR * ClientFree,
    OUT RPC_CLIENT_ALLOC __RPC_FAR * __RPC_FAR * OldClientAlloc,
    OUT RPC_CLIENT_FREE __RPC_FAR * __RPC_FAR * OldClientFree
    );

/*++
     RpcSm* package
--*/

void __RPC_FAR * RPC_ENTRY
RpcSmAllocate (
    IN  size_t          Size,
    OUT RPC_STATUS __RPC_FAR *    pStatus
    );

RPC_STATUS RPC_ENTRY
RpcSmClientFree (
    IN  void __RPC_FAR * pNodeToFree
    );

RPC_STATUS  RPC_ENTRY
RpcSmDestroyClientContext (
    IN void __RPC_FAR * __RPC_FAR * ContextHandle
    );

RPC_STATUS  RPC_ENTRY
RpcSmDisableAllocate (
    void
    );

RPC_STATUS  RPC_ENTRY
RpcSmEnableAllocate (
    void
    );

RPC_STATUS  RPC_ENTRY
RpcSmFree (
    IN void __RPC_FAR * NodeToFree
    );

RPC_SS_THREAD_HANDLE RPC_ENTRY
RpcSmGetThreadHandle (
    OUT RPC_STATUS __RPC_FAR *    pStatus
    );

RPC_STATUS  RPC_ENTRY
RpcSmSetClientAllocFree (
    IN RPC_CLIENT_ALLOC __RPC_FAR * ClientAlloc,
    IN RPC_CLIENT_FREE __RPC_FAR * ClientFree
    );

RPC_STATUS  RPC_ENTRY
RpcSmSetThreadHandle (
    IN RPC_SS_THREAD_HANDLE Id
    );

RPC_STATUS  RPC_ENTRY
RpcSmSwapClientAllocFree (
    IN RPC_CLIENT_ALLOC __RPC_FAR * ClientAlloc,
    IN RPC_CLIENT_FREE __RPC_FAR * ClientFree,
    OUT RPC_CLIENT_ALLOC __RPC_FAR * __RPC_FAR * OldClientAlloc,
    OUT RPC_CLIENT_FREE __RPC_FAR * __RPC_FAR * OldClientFree
    );

/*++
     Ndr stub entry points
--*/

void RPC_ENTRY
NdrRpcSsEnableAllocate(
    PMIDL_STUB_MESSAGE      pMessage );

void RPC_ENTRY
NdrRpcSsDisableAllocate(
    PMIDL_STUB_MESSAGE      pMessage );

void RPC_ENTRY
NdrRpcSmSetClientToOsf(
    PMIDL_STUB_MESSAGE      pMessage );

void __RPC_FAR *  RPC_ENTRY
NdrRpcSmClientAllocate (
    IN size_t Size
    );

void  RPC_ENTRY
NdrRpcSmClientFree (
    IN void __RPC_FAR * NodeToFree
    );

void __RPC_FAR *  RPC_ENTRY
NdrRpcSsDefaultAllocate (
    IN size_t Size
    );

void  RPC_ENTRY
NdrRpcSsDefaultFree (
    IN void __RPC_FAR * NodeToFree
    );

/****************************************************************************
    end of memory package: rpc_ss_* rpc_sm_*
 ****************************************************************************/

/****************************************************************************
 * Full Pointer APIs
 ****************************************************************************/

PFULL_PTR_XLAT_TABLES RPC_ENTRY
NdrFullPointerXlatInit(
    unsigned long           NumberOfPointers,
    XLAT_SIDE               XlatSide
    );

void RPC_ENTRY
NdrFullPointerXlatFree(
    PFULL_PTR_XLAT_TABLES   pXlatTables
    );

int RPC_ENTRY
NdrFullPointerQueryPointer(
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    void __RPC_FAR *                    pPointer,
    unsigned char           QueryType,
    unsigned long __RPC_FAR *           pRefId
    );

int RPC_ENTRY
NdrFullPointerQueryRefId(
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    unsigned long           RefId,
    unsigned char           QueryType,
    void __RPC_FAR *__RPC_FAR *                 ppPointer
    );

void RPC_ENTRY
NdrFullPointerInsertRefId(
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    unsigned long           RefId,
    void __RPC_FAR *                    pPointer
    );

int RPC_ENTRY
NdrFullPointerFree(
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    void __RPC_FAR *                    Pointer
    );

void __RPC_FAR *  RPC_ENTRY
NdrAllocate(
    PMIDL_STUB_MESSAGE      pStubMsg,
    size_t                  Len
    );

void RPC_ENTRY
NdrClearOutParameters(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat,
    void __RPC_FAR *        ArgAddr
    );


/****************************************************************************
 * Proxy APIs
 ****************************************************************************/

void __RPC_FAR * RPC_ENTRY
NdrOleAllocate (
    IN size_t Size
    );

void RPC_ENTRY
NdrOleFree (
    IN void __RPC_FAR * NodeToFree
    );

#ifdef CONST_VTABLE
#define CONST_VTBL const
#else
#define CONST_VTBL
#endif




#ifdef __cplusplus
}
#endif

// Reset the packing level for DOS, Windows and Mac.

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__) || defined(__RPC_MAC__)
#pragma pack()
#endif

#endif /* __RPCNDR_H__ */






=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\rpcnsip.h ===
/*++

Copyright (c) 1992-1995 Microsoft Corporation

Module Name:

    rpcnsip.h

Abstract:

    This file contains the types and function definitions to use the
    to implement the autohandle features of the runtime.

--*/

#ifndef __RPCNSIP_H__
#define __RPCNSIP_H__

#ifdef __cplusplus
extern "C" {
#endif

typedef struct
{
   RPC_NS_HANDLE        LookupContext;
   RPC_BINDING_HANDLE   ProposedHandle;
   RPC_BINDING_VECTOR * Bindings;

} RPC_IMPORT_CONTEXT_P, * PRPC_IMPORT_CONTEXT_P;


/* Stub Auto Binding routines. */

RPC_STATUS RPC_ENTRY
I_RpcNsGetBuffer(
    IN PRPC_MESSAGE Message
    );

RPC_STATUS RPC_ENTRY
I_RpcNsSendReceive(
    IN PRPC_MESSAGE Message,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Handle
    );

void RPC_ENTRY
I_RpcNsRaiseException(
    IN PRPC_MESSAGE Message,
    IN RPC_STATUS Status
    );

RPC_STATUS RPC_ENTRY
I_RpcReBindBuffer(
    IN PRPC_MESSAGE Message
    );

RPC_STATUS RPC_ENTRY
I_NsServerBindSearch(
    );

RPC_STATUS RPC_ENTRY
I_NsClientBindSearch(
    );

void RPC_ENTRY
I_NsClientBindDone(
    );

#ifdef __cplusplus
}
#endif

#endif /* __RPCNSIP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\rpcnterr.h ===
/*********************************************************/
/**               Microsoft LAN Manager                 **/
/**       Copyright(c) Microsoft Corp., 1987-1995       **/
/**                                                     **/
/**     Rpc Error Codes from the compiler and runtime   **/
/**                                                     **/
/*********************************************************/

/*
If you change this file, you must also change rpcerr.h.
*/

#ifndef __RPCNTERR_H__
#define __RPCNTERR_H__

#define RPC_S_OK                          ERROR_SUCCESS
#define RPC_S_INVALID_ARG                 ERROR_INVALID_PARAMETER
#define RPC_S_OUT_OF_MEMORY               ERROR_OUTOFMEMORY
#define RPC_S_OUT_OF_THREADS              ERROR_MAX_THRDS_REACHED
#define RPC_S_INVALID_LEVEL               ERROR_INVALID_PARAMETER
#define RPC_S_BUFFER_TOO_SMALL            ERROR_INSUFFICIENT_BUFFER
#define RPC_S_INVALID_SECURITY_DESC       ERROR_INVALID_SECURITY_DESCR
#define RPC_S_ACCESS_DENIED               ERROR_ACCESS_DENIED
#define RPC_S_SERVER_OUT_OF_MEMORY        ERROR_NOT_ENOUGH_SERVER_MEMORY

#define RPC_X_NO_MEMORY                   RPC_S_OUT_OF_MEMORY
#define RPC_X_INVALID_BOUND               RPC_S_INVALID_BOUND
#define RPC_X_INVALID_TAG                 RPC_S_INVALID_TAG
#define RPC_X_ENUM_VALUE_TOO_LARGE        RPC_X_ENUM_VALUE_OUT_OF_RANGE
#define RPC_X_SS_CONTEXT_MISMATCH         ERROR_INVALID_HANDLE
#define RPC_X_INVALID_BUFFER              ERROR_INVALID_USER_BUFFER

#endif /* __RPCNTERR_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\rpcferr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:      rpc.mc
//
//  Contents:  Errors for RPC facility.  Some historical from 16 bit,
//             some new ones.
//
//  History:   dd-mmm-yy Author    Comment
//             20-Sep-93 AlexMit   Created
//
//  Notes:
//  .mc file is compiled by the MC tool to generate a .h file and
//  .rc (resource compiler script) file.
//
// Comments in .mc files start with a ";".
// Comment lines are generated directly in the .h file, without
// the leading ";"
//
// See mc.hlp for more help on .mc files and the MC tool.
//
//
// Instructions for the transition to moleerror.mc:
//
//
// Use this sample file as template for constructing .mc files for
// your project.
//
// The project .mc files will be merged into a single .mc file for
// Cairo: oleerror.mc
//
// Reserve a range of error codes within a FACILITY defined in
// oleerror.mc.  Reserve this range within oleerror.mc, by locating the
// appropraite facility in oleerror.mc and placing a comment block
// within oleerror.mc of the form:
//
//
//--------------------------------------------------------------------------
#ifndef _RPCFERR_H_
#define _RPCFERR_H_
// **** START OF COPIED DATA ****
// The following information is copied from oleerror.mc.
// It should not be merged into oleerror.mc
// Define the status type.
// Define the severities
// Define the severities
// Define the facilities
//
// FACILITY_RPC is for compatibilty with OLE2 and is not used
// in later versions of OLE

// **** END OF COPIED DATA ****
//
// Error definitions follow
//
// ******************
// FACILITY_RPC
// ******************
//
// Codes 0x0-0x11 are propogated from 16 bit OLE.
//
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-+---------------------+-------------------------------+
//  |S|R|C|N|r|    Facility         |               Code            |
//  +-+-+-+-+-+---------------------+-------------------------------+
//
//  where
//
//      S - Severity - indicates success/fail
//
//          0 - Success
//          1 - Fail (COERROR)
//
//      R - reserved portion of the facility code, corresponds to NT's
//              second severity bit.
//
//      C - reserved portion of the facility code, corresponds to NT's
//              C field.
//
//      N - reserved portion of the facility code. Used to indicate a
//              mapped NT status value.
//
//      r - reserved portion of the facility code. Reserved for internal
//              use. Used to indicate HRESULT values that are not status
//              values, but are instead message ids for display strings.
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_WINDOWS                 0x8
#define FACILITY_WIN32                   0x7
#define FACILITY_STORAGE                 0x3
#define FACILITY_RPC                     0x1
#define FACILITY_NULL                    0x0
#define FACILITY_ITF                     0x4
#define FACILITY_DISPATCH                0x2


//
// Define the severity codes
//
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_COERROR          0x2


//
// MessageId: RPC_E_CALL_REJECTED
//
// MessageText:
//
//  Call was rejected by callee.
//
#define RPC_E_CALL_REJECTED              ((HRESULT)0x80010001L)

//
// MessageId: RPC_E_CALL_CANCELED
//
// MessageText:
//
//  Call was canceld by call - returned by MessagePending.
//  This code only occurs if MessagePending return cancel.
//
#define RPC_E_CALL_CANCELED              ((HRESULT)0x80010002L)

//
// MessageId: RPC_E_CANTPOST_INSENDCALL
//
// MessageText:
//
//  The caller is dispatching an intertask SendMessage call and
//  can NOT call out via PostMessage.
//
#define RPC_E_CANTPOST_INSENDCALL        ((HRESULT)0x80010003L)

//
// MessageId: RPC_E_CANTCALLOUT_INASYNCCALL
//
// MessageText:
//
//  The caller is dispatching an asynchronus call can NOT
//  make an outgoing call on behalf of this call.
//
#define RPC_E_CANTCALLOUT_INASYNCCALL    ((HRESULT)0x80010004L)

//
// MessageId: RPC_E_CANTCALLOUT_INEXTERNALCALL
//
// MessageText:
//
//  The caller is not in a state where an outgoing call can be made.
//  This is the case if the caller has an outstanding call and
//  another incoming call was excepted by HIC; now the caller is
//  not allowed to call out again.
//
#define RPC_E_CANTCALLOUT_INEXTERNALCALL ((HRESULT)0x80010005L)

//
// MessageId: RPC_E_CONNECTION_TERMINATED
//
// MessageText:
//
//  The connection terminated or is in a bogus state
//  and can not be used any more. Other connections
//  are still valid.
//
#define RPC_E_CONNECTION_TERMINATED      ((HRESULT)0x80010006L)

//
// MessageId: RPC_E_SERVER_DIED
//
// MessageText:
//
//  The callee (server [not server application]) is not available
//  and disappeared; all connections are invalid.  The call may
//  have executed.
//
#define RPC_E_SERVER_DIED                ((HRESULT)0x80010007L)

//
// MessageId: RPC_E_CLIENT_DIED
//
// MessageText:
//
//  The caller (client ) disappeared while the callee (server) was
//  processing a call.
//
#define RPC_E_CLIENT_DIED                ((HRESULT)0x80010008L)

//
// MessageId: RPC_E_INVALID_DATAPACKET
//
// MessageText:
//
//  The date packet with the marshalled parameter data is incorrect.
//
#define RPC_E_INVALID_DATAPACKET         ((HRESULT)0x80010009L)

//
// MessageId: RPC_E_CANTTRANSMIT_CALL
//
// MessageText:
//
//  The call was not transmitted properly; the message queue
//  was full and was not emptied after yielding.
//
#define RPC_E_CANTTRANSMIT_CALL          ((HRESULT)0x8001000AL)

//
// MessageId: RPC_E_CLIENT_CANTMARSHAL_DATA
//
// MessageText:
//
//  The client (caller) can not marshall the parameter data - low memory etc.
//
#define RPC_E_CLIENT_CANTMARSHAL_DATA    ((HRESULT)0x8001000BL)

//
// MessageId: RPC_E_CLIENT_CANTUNMARSHAL_DATA
//
// MessageText:
//
//  The client (caller) can not unmarshall the return data - low memory etc.
//
#define RPC_E_CLIENT_CANTUNMARSHAL_DATA  ((HRESULT)0x8001000CL)

//
// MessageId: RPC_E_SERVER_CANTMARSHAL_DATA
//
// MessageText:
//
//  The server (callee) can not marshall the return data - low memory etc.
//
#define RPC_E_SERVER_CANTMARSHAL_DATA    ((HRESULT)0x8001000DL)

//
// MessageId: RPC_E_SERVER_CANTUNMARSHAL_DATA
//
// MessageText:
//
//  The server (callee) can not unmarshall the parameter data - low memory etc.
//
#define RPC_E_SERVER_CANTUNMARSHAL_DATA  ((HRESULT)0x8001000EL)

//
// MessageId: RPC_E_INVALID_DATA
//
// MessageText:
//
//  Received data are invalid; can be server or client data.
//
#define RPC_E_INVALID_DATA               ((HRESULT)0x8001000FL)

//
// MessageId: RPC_E_INVALID_PARAMETER
//
// MessageText:
//
//  A particular parameter is invalid and can not be un/marshalled.
//
#define RPC_E_INVALID_PARAMETER          ((HRESULT)0x80010010L)

//
// MessageId: RPC_E_CANTCALLOUT_AGAIN
//
// MessageText:
//
//  There is no second outgoing call on same channel in DDE conversation.
//
#define RPC_E_CANTCALLOUT_AGAIN          ((HRESULT)0x80010011L)

//
// MessageId: RPC_E_SERVER_DIED_DNE
//
// MessageText:
//
//  The callee (server [not server application]) is not available
//  and disappeared; all connections are invalid.  The call did not execute.
//
#define RPC_E_SERVER_DIED_DNE            ((HRESULT)0x80010012L)

//
// MessageId: RPC_E_SYS_CALL_FAILED
//
// MessageText:
//
//  System call failed.
//
#define RPC_E_SYS_CALL_FAILED            ((HRESULT)0x80010100L)

//
// MessageId: RPC_E_OUT_OF_RESOURCES
//
// MessageText:
//
//  Could not allocate some required resource (memory, events, ...)
//
#define RPC_E_OUT_OF_RESOURCES           ((HRESULT)0x80010101L)

//
// MessageId: RPC_E_ATTEMPTED_MULTITHREAD
//
// MessageText:
//
//  Attempted to make calls on more then one thread in single threaded mode.
//
#define RPC_E_ATTEMPTED_MULTITHREAD      ((HRESULT)0x80010102L)

//
// MessageId: RPC_E_NOT_REGISTERED
//
// MessageText:
//
//  The requested interface is not registered on the server object.
//
#define RPC_E_NOT_REGISTERED             ((HRESULT)0x80010103L)

//
// MessageId: RPC_E_FAULT
//
// MessageText:
//
//  RPC could not call the server or could not return the results of calling the server.
//
#define RPC_E_FAULT                      ((HRESULT)0x80010104L)

//
// MessageId: RPC_E_SERVERFAULT
//
// MessageText:
//
//  The server threw an exception.
//
#define RPC_E_SERVERFAULT                ((HRESULT)0x80010105L)

//
// MessageId: RPC_E_CHANGED_MODE
//
// MessageText:
//
//  Cannot change thread mode after it is set.
//
#define RPC_E_CHANGED_MODE               ((HRESULT)0x80010106L)

//
// MessageId: RPC_E_INVALIDMETHOD
//
// MessageText:
//
//  The method called does not exist on the server.
//
#define RPC_E_INVALIDMETHOD              ((HRESULT)0x80010107L)

//
// MessageId: RPC_E_DISCONNECTED
//
// MessageText:
//
//  The object invoked has disconnected from its clients.
//
#define RPC_E_DISCONNECTED               ((HRESULT)0x80010108L)

//
// MessageId: RPC_E_RETRY
//
// MessageText:
//
//  The object invoked choose not to process the call now.  Try again later.
//
#define RPC_E_RETRY                      ((HRESULT)0x80010109L)

//
// MessageId: RPC_E_SERVERCALL_RETRYLATER
//
// MessageText:
//
//  The messagefilter indicated that the app is bussy.
//
#define RPC_E_SERVERCALL_RETRYLATER      ((HRESULT)0x8001010AL)

//
// MessageId: RPC_E_SERVERCALL_REJECTED
//
// MessageText:
//
//  The messagefilter rejected the call.
//
#define RPC_E_SERVERCALL_REJECTED        ((HRESULT)0x8001010BL)

//
// MessageId: RPC_E_INVALID_CALLDATA
//
// MessageText:
//
//  The call control interfaces was called with invalid data.
//
#define RPC_E_INVALID_CALLDATA           ((HRESULT)0x8001010CL)

//
// MessageId: RPC_E_CANTCALLOUT_ININPUTSYNCCALL
//
// MessageText:
//
//  An outgoing call can not be made since the app is dispatching an input-sync call.
//
#define RPC_E_CANTCALLOUT_ININPUTSYNCCALL ((HRESULT)0x8001010DL)

//
// MessageId: RPC_E_WRONG_THREAD
//
// MessageText:
//
//  The app called an interface that was marshalled for a different thread.
//
#define RPC_E_WRONG_THREAD               ((HRESULT)0x8001010EL)

//
// MessageId: RPC_E_THREAD_NOT_INIT
//
// MessageText:
//
//  The CoInitialize has not been called on the current thread.
//
#define RPC_E_THREAD_NOT_INIT            ((HRESULT)0x8001010FL)

//
// MessageId: RPC_E_UNEXPECTED
//
// MessageText:
//
//  An internal error occured.
//
#define RPC_E_UNEXPECTED                 ((HRESULT)0x8001FFFFL)

#endif // _RPCFERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\rpcdcep.h ===
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    rpcdcep.h

Abstract:

    This module contains the private RPC runtime APIs for use by the
    stubs and by support libraries.  Applications must not call these
    routines.

--*/

#ifndef __RPCDCEP_H__
#define __RPCDCEP_H__

// Set the packing level for RPC structures for Dos and Windows.

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__)
#pragma pack(2)
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _RPC_VERSION {
    unsigned short MajorVersion;
    unsigned short MinorVersion;
} RPC_VERSION;

typedef struct _RPC_SYNTAX_IDENTIFIER {
    GUID SyntaxGUID;
    RPC_VERSION SyntaxVersion;
} RPC_SYNTAX_IDENTIFIER, __RPC_FAR * PRPC_SYNTAX_IDENTIFIER;

typedef struct _RPC_MESSAGE
{
    RPC_BINDING_HANDLE Handle;
    unsigned long DataRepresentation;
    void __RPC_FAR * Buffer;
    unsigned int BufferLength;
    unsigned int ProcNum;
    PRPC_SYNTAX_IDENTIFIER TransferSyntax;
    void __RPC_FAR * RpcInterfaceInformation;
    void __RPC_FAR * ReservedForRuntime;
    RPC_MGR_EPV __RPC_FAR * ManagerEpv;
    void __RPC_FAR * ImportContext;
    unsigned long RpcFlags;
} RPC_MESSAGE, __RPC_FAR * PRPC_MESSAGE;


typedef RPC_STATUS RPC_ENTRY RPC_FORWARD_FUNCTION(
                       IN UUID             __RPC_FAR * InterfaceId,
                       IN RPC_VERSION      __RPC_FAR * InterfaceVersion,
                       IN UUID             __RPC_FAR * ObjectId,
                       IN unsigned char         __RPC_FAR * Rpcpro,
                       IN void __RPC_FAR * __RPC_FAR * ppDestEndpoint);

/*
 * Types of function calls for datagram rpc
 */

#define RPC_NCA_FLAGS_DEFAULT       0x00000000  /* 0b000...000 */
#define RPC_NCA_FLAGS_IDEMPOTENT    0x00000001  /* 0b000...001 */
#define RPC_NCA_FLAGS_BROADCAST     0x00000002  /* 0b000...010 */
#define RPC_NCA_FLAGS_MAYBE         0x00000004  /* 0b000...100 */

#define RPC_BUFFER_COMPLETE         0x00001000 /* used by pipes */
#define RPC_BUFFER_PARTIAL          0x00002000 /* used by pipes */
#define RPC_BUFFER_EXTRA            0x00004000 /* used by pipes */

#define RPCFLG_ASYNCHRONOUS         0x40000000UL
#define RPCFLG_INPUT_SYNCHRONOUS    0x20000000UL

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__)
#define RPC_FLAGS_VALID_BIT 0x8000
#endif

#if defined(__RPC_WIN32__) || defined(__RPC_MAC__)
#define RPC_FLAGS_VALID_BIT 0x00008000
#endif

typedef
void
(__RPC_STUB __RPC_FAR * RPC_DISPATCH_FUNCTION) (
    IN OUT PRPC_MESSAGE Message
    );

typedef struct {
    unsigned int DispatchTableCount;
    RPC_DISPATCH_FUNCTION __RPC_FAR * DispatchTable;
    int Reserved;
} RPC_DISPATCH_TABLE, __RPC_FAR * PRPC_DISPATCH_TABLE;

typedef struct _RPC_PROTSEQ_ENDPOINT
{
    unsigned char __RPC_FAR * RpcProtocolSequence;
    unsigned char __RPC_FAR * Endpoint;
} RPC_PROTSEQ_ENDPOINT, __RPC_FAR * PRPC_PROTSEQ_ENDPOINT;

/*
Both of these types MUST start with the InterfaceId and TransferSyntax.
Look at RpcIfInqId and I_RpcIfInqTransferSyntaxes to see why.
*/
#define NT351_INTERFACE_SIZE 0x40
#define RPC_INTERFACE_HAS_PIPES           0x0001

typedef struct _RPC_SERVER_INTERFACE
{
    unsigned int Length;
    RPC_SYNTAX_IDENTIFIER InterfaceId;
    RPC_SYNTAX_IDENTIFIER TransferSyntax;
    PRPC_DISPATCH_TABLE DispatchTable;
    unsigned int RpcProtseqEndpointCount;
    PRPC_PROTSEQ_ENDPOINT RpcProtseqEndpoint;
    RPC_MGR_EPV __RPC_FAR *DefaultManagerEpv;
    void const __RPC_FAR *InterpreterInfo;
    unsigned int Flags ;
} RPC_SERVER_INTERFACE, __RPC_FAR * PRPC_SERVER_INTERFACE;

typedef struct _RPC_CLIENT_INTERFACE
{
    unsigned int Length;
    RPC_SYNTAX_IDENTIFIER InterfaceId;
    RPC_SYNTAX_IDENTIFIER TransferSyntax;
    PRPC_DISPATCH_TABLE DispatchTable;
    unsigned int RpcProtseqEndpointCount;
    PRPC_PROTSEQ_ENDPOINT RpcProtseqEndpoint;
    unsigned long Reserved;
    void const __RPC_FAR * InterpreterInfo;
    unsigned int Flags ;
} RPC_CLIENT_INTERFACE, __RPC_FAR * PRPC_CLIENT_INTERFACE;


RPC_STATUS RPC_ENTRY
I_RpcGetBuffer (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPC_STATUS RPC_ENTRY
I_RpcSendReceive (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPC_STATUS RPC_ENTRY
I_RpcFreeBuffer (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPC_STATUS RPC_ENTRY
I_RpcSend (
    IN OUT PRPC_MESSAGE Message
    ) ;

RPC_STATUS RPC_ENTRY
I_RpcReceive (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int Size
    ) ;

RPC_STATUS RPC_ENTRY
I_RpcFreePipeBuffer (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    ) ;

RPC_STATUS RPC_ENTRY
I_RpcReallocPipeBuffer (
    IN PRPC_MESSAGE Message,
    IN unsigned int NewSize
    ) ;

typedef void * I_RPC_MUTEX;

void RPC_ENTRY
I_RpcRequestMutex (
    IN OUT I_RPC_MUTEX * Mutex
    );

void RPC_ENTRY
I_RpcClearMutex (
    IN I_RPC_MUTEX Mutex
    );

void RPC_ENTRY
I_RpcDeleteMutex (
    IN I_RPC_MUTEX Mutex
    );

void __RPC_FAR * RPC_ENTRY
I_RpcAllocate (
    IN unsigned int Size
    );

void RPC_ENTRY
I_RpcFree (
    IN void __RPC_FAR * Object
    );

void RPC_ENTRY
I_RpcPauseExecution (
    IN unsigned long Milliseconds
    );

typedef
void
(__RPC_USER __RPC_FAR * PRPC_RUNDOWN) (
    void __RPC_FAR * AssociationContext
    );

RPC_STATUS RPC_ENTRY
I_RpcMonitorAssociation (
    IN RPC_BINDING_HANDLE Handle,
    IN PRPC_RUNDOWN RundownRoutine,
    IN void * Context
    );

RPC_STATUS RPC_ENTRY
I_RpcStopMonitorAssociation (
    IN RPC_BINDING_HANDLE Handle
    );

RPC_BINDING_HANDLE RPC_ENTRY
I_RpcGetCurrentCallHandle(
    void
    );

RPC_STATUS RPC_ENTRY
I_RpcGetAssociationContext (
    OUT void __RPC_FAR * __RPC_FAR * AssociationContext
    );

RPC_STATUS RPC_ENTRY
I_RpcSetAssociationContext (
    IN void __RPC_FAR * AssociationContext
    );

#ifdef __RPC_NT__

RPC_STATUS RPC_ENTRY
I_RpcNsBindingSetEntryName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    IN unsigned short __RPC_FAR * EntryName
    );

#else

RPC_STATUS RPC_ENTRY
I_RpcNsBindingSetEntryName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    IN unsigned char __RPC_FAR * EntryName
    );

#endif

#ifdef __RPC_NT__

RPC_STATUS RPC_ENTRY
I_RpcBindingInqDynamicEndpoint (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short __RPC_FAR * __RPC_FAR * DynamicEndpoint
    );

#else

RPC_STATUS RPC_ENTRY
I_RpcBindingInqDynamicEndpoint (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * DynamicEndpoint
    );

#endif

#define TRANSPORT_TYPE_CN        0x1
#define TRANSPORT_TYPE_DG        0x2
#define TRANSPORT_TYPE_LPC       0x4
#define TRANSPORT_TYPE_WMSG   0x8

RPC_STATUS RPC_ENTRY
I_RpcBindingInqTransportType (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned int __RPC_FAR * Type
    );

typedef struct _RPC_TRANSFER_SYNTAX
{
    UUID Uuid;
    unsigned short VersMajor;
    unsigned short VersMinor;
} RPC_TRANSFER_SYNTAX;

RPC_STATUS RPC_ENTRY
I_RpcIfInqTransferSyntaxes (
    IN RPC_IF_HANDLE RpcIfHandle,
    OUT RPC_TRANSFER_SYNTAX __RPC_FAR * TransferSyntaxes,
    IN unsigned int TransferSyntaxSize,
    OUT unsigned int __RPC_FAR * TransferSyntaxCount
    );

RPC_STATUS RPC_ENTRY
I_UuidCreate (
    OUT UUID __RPC_FAR * Uuid
    );

RPC_STATUS RPC_ENTRY
I_RpcBindingCopy (
    IN RPC_BINDING_HANDLE SourceBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * DestinationBinding
    );

RPC_STATUS RPC_ENTRY
I_RpcBindingIsClientLocal (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL,
    OUT unsigned int __RPC_FAR * ClientLocalFlag
    );

void RPC_ENTRY
I_RpcSsDontSerializeContext (
    void
    );

RPC_STATUS RPC_ENTRY
I_RpcLaunchDatagramReceiveThread(
    void __RPC_FAR * pAddress
    );

RPC_STATUS RPC_ENTRY
I_RpcServerRegisterForwardFunction (
    IN RPC_FORWARD_FUNCTION __RPC_FAR * pForwardFunction
    );


RPC_STATUS RPC_ENTRY
I_RpcConnectionInqSockBuffSize(
  OUT unsigned long __RPC_FAR * RecvBuffSize,
  OUT unsigned long __RPC_FAR * SendBuffSize
  );

RPC_STATUS RPC_ENTRY
I_RpcConnectionSetSockBuffSize(
   IN unsigned long RecvBuffSize,
   IN unsigned long SendBuffSize
   );


#ifdef MSWMSG
RPC_STATUS RPC_ENTRY
I_RpcServerStartListening(
    HWND hWnd
    ) ;

RPC_STATUS RPC_ENTRY
I_RpcServerStopListening(
    ) ;

RPC_STATUS RPC_ENTRY
I_RpcGetThreadWindowHandle(
    OUT HWND *WindowHandle
    ) ;

typedef RPC_STATUS (*RPC_BLOCKING_FN) (
    IN void *wnd,
    IN void *Context,
    IN HANDLE hSyncEvent
    ) ;

RPC_STATUS RPC_ENTRY
I_RpcAsyncSendReceive(
    IN OUT PRPC_MESSAGE pRpcMessage,
    IN OPTIONAL void *Context,
    HWND hWnd
    ) ;

RPC_STATUS RPC_ENTRY
I_RpcBindingSetAsync(
    IN RPC_BINDING_HANDLE Binding,
    IN RPC_BLOCKING_FN BlockingFn
    ) ;

LONG RPC_ENTRY
I_RpcWindowProc(
    IN HWND hWnd,
    IN UINT Message,
    IN WPARAM wParam,
    IN LPARAM lParam
    ) ;

#endif

RPC_STATUS RPC_ENTRY
I_RpcServerInqTransportType(
    OUT unsigned int __RPC_FAR * Type
    ) ;

#ifdef __cplusplus

#ifdef __RPC_WIN32__

typedef
RPC_STATUS
(__RPC_USER __RPC_FAR * RPC_BLOCKING_FUNCTION) (
    IN void __RPC_FAR *RpcWindowHandle,
    IN void __RPC_FAR *Context
    );

RPC_STATUS RPC_ENTRY
I_RpcBindingSetAsync(
    IN RPC_BINDING_HANDLE Binding,
    IN RPC_BLOCKING_FUNCTION BlockingHook
    );

RPC_STATUS RPC_ENTRY
I_RpcAsyncSendReceive(
    IN OUT RPC_MESSAGE __RPC_FAR * Message,
    IN void __RPC_FAR * Context
    );

RPC_STATUS RPC_ENTRY
I_RpcGetThreadWindowHandle(
    OUT void __RPC_FAR * __RPC_FAR * WindowHandle
    );

RPC_STATUS RPC_ENTRY
I_RpcServerThreadPauseListening(
    );

RPC_STATUS RPC_ENTRY
I_RpcServerThreadContinueListening(
    );

RPC_STATUS RPC_ENTRY
I_RpcServerUnregisterEndpointA (
    IN unsigned char * Protseq,
    IN unsigned char * Endpoint
    );

RPC_STATUS RPC_ENTRY
I_RpcServerUnregisterEndpointW (
    IN unsigned short * Protseq,
    IN unsigned short * Endpoint
    );

#ifdef UNICODE
#define I_RpcServerUnregisterEndpoint I_RpcServerUnregisterEndpointW
#else
#define I_RpcServerUnregisterEndpoint I_RpcServerUnregisterEndpointA
#endif

#endif // __RPC_WIN32__


}
#endif

// Reset the packing level for Dos and Windows.

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__)
#pragma pack()
#endif

#endif /* __RPCDCEP_H__ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\share.h ===
/***
*share.h - defines file sharing modes for sopen
*
*	Copyright (c) 1985-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines the file sharing modes for sopen().
*
*       [Public]
*
****/

#ifndef _INC_SHARE
#define _INC_SHARE

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#define _SH_DENYRW	0x10	/* deny read/write mode */
#define _SH_DENYWR	0x20	/* deny write mode */
#define _SH_DENYRD	0x30	/* deny read mode */
#define _SH_DENYNO	0x40	/* deny none mode */

#if !__STDC__
/* Non-ANSI names for compatibility */
#define SH_DENYRW _SH_DENYRW
#define SH_DENYWR _SH_DENYWR
#define SH_DENYRD _SH_DENYRD
#define SH_DENYNO _SH_DENYNO
#endif

#endif	/* _INC_SHARE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\signal.h ===
/***
*signal.h - defines signal values and routines
*
*	Copyright (c) 1985-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines the signal values and declares the signal functions.
*	[ANSI/System V]
*
*       [Public]
*
****/

#ifndef _INC_SIGNAL
#define _INC_SIGNAL

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIG_ATOMIC_T_DEFINED
typedef int sig_atomic_t;
#define _SIG_ATOMIC_T_DEFINED
#endif


#define NSIG 23     /* maximum signal number + 1 */


/* Signal types */

#define SIGINT		2	/* interrupt */
#define SIGILL		4	/* illegal instruction - invalid function image */
#define SIGFPE		8	/* floating point exception */
#define SIGSEGV 	11	/* segment violation */
#define SIGTERM 	15	/* Software termination signal from kill */
#define SIGBREAK	21	/* Ctrl-Break sequence */
#define SIGABRT 	22	/* abnormal termination triggered by abort call */


/* signal action codes */

#define SIG_DFL (void (__cdecl *)(int))0	   /* default signal action */
#define SIG_IGN (void (__cdecl *)(int))1	   /* ignore signal */
#define SIG_SGE (void (__cdecl *)(int))3	   /* signal gets error */
#define SIG_ACK (void (__cdecl *)(int))4	   /* acknowledge */


/* signal error value (returned by signal call on error) */

#define SIG_ERR (void (__cdecl *)(int))-1	   /* signal error value */


/* pointer to exception information pointers structure */

#if defined(_MT) || defined(_DLL)
extern void * * __cdecl __pxcptinfoptrs(void);
#define _pxcptinfoptrs	(*__pxcptinfoptrs())
#else	/* ndef _MT && ndef _DLL */
extern void * _pxcptinfoptrs;
#endif	/* _MT || _DLL */


/* Function prototypes */

_CRTIMP void (__cdecl * __cdecl signal(int, void (__cdecl *)(int)))(int);
_CRTIMP int __cdecl raise(int);


#ifdef __cplusplus
}
#endif

#endif	/* _INC_SIGNAL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\search.h ===
/***
*search.h - declarations for searcing/sorting routines
*
*	Copyright (c) 1985-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file contains the declarations for the sorting and
*	searching routines.
*	[System V]
*
*       [Public]
*
****/

#ifndef _INC_SEARCH
#define _INC_SEARCH

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


/* Function prototypes */

_CRTIMP void * __cdecl bsearch(const void *, const void *, size_t, size_t,
	int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl _lfind(const void *, const void *, unsigned int *, unsigned int,
	int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl _lsearch(const void *, void  *, unsigned int *, unsigned int,
	int (__cdecl *)(const void *, const void *));
_CRTIMP void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)(const void *,
	const void *));


#if	!__STDC__
/* Non-ANSI names for compatibility */
#ifdef	_NTSDK
/* definitions compatible with NT SDK */
#define lfind	_lfind
#define lsearch _lsearch
#else	/* ndef _NTSDK */
/* current declarations */
_CRTIMP void * __cdecl lfind(const void *, const void *, unsigned int *, unsigned int,
	int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl lsearch(const void *, void  *, unsigned int *, unsigned int,
	int (__cdecl *)(const void *, const void *));
#endif	/* _NTSDK */
#endif	/* __STDC__ */


#ifdef __cplusplus
}
#endif

#endif	/* _INC_SEARCH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\stdarg.h ===
/***
*stdarg.h - defines ANSI-style macros for variable argument functions
*
*	Copyright (c) 1985-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines ANSI-style macros for accessing arguments
*	of functions which take a variable number of arguments.
*	[ANSI]
*
*       [Public]
*
****/

#ifndef _INC_STDARG
#define _INC_STDARG

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef	_MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif	/* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif



#ifndef _VA_LIST_DEFINED
#ifdef	_M_ALPHA
typedef struct {
	char *a0;	/* pointer to first homed integer argument */
	int offset;	/* byte offset of next parameter */
} va_list;
#else
typedef char *	va_list;
#endif
#define _VA_LIST_DEFINED
#endif

#ifdef	_M_IX86


#define _INTSIZEOF(n)	( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v)	( ap = (va_list)&v + _INTSIZEOF(v) )
#define va_arg(ap,t)	( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap)	( ap = (va_list)0 )

#elif	defined(_M_MRX000)


/* Use these types and definitions if generating code for MIPS */

#define va_start(ap,v) ap  = (va_list)&v + sizeof(v)
#define va_end(list)
#define va_arg(list, mode) ((mode *)(list =\
 (char *) ((((int)list + (__builtin_alignof(mode)<=4?3:7)) &\
 (__builtin_alignof(mode)<=4?-4:-8))+sizeof(mode))))[-1]

/*  +++++++++++++++++++++++++++++++++++++++++++
    Because of parameter passing conventions in C:
    use mode=int for char, and short types
    use mode=double for float types
    use a pointer for array types
    +++++++++++++++++++++++++++++++++++++++++++ */


#elif	defined(_M_ALPHA)


/* Use these types and definitions if generating code for ALPHA */

/*
 * The Alpha compiler supports two builtin functions that are used to
 * implement stdarg/varargs.  The __builtin_va_start function is used
 * by va_start to initialize the data structure that locates the next
 * argument.  The __builtin_isfloat function is used by va_arg to pick
 * which part of the home area a given register argument is stored in.
 * The home area is where up to six integer and/or six floating point
 * register arguments are stored down (so they can also be referenced
 * by a pointer like any arguments passed on the stack).
 */

extern void * __builtin_va_start(va_list, ...);

#ifdef	_CFRONT
#define __builtin_isfloat(a) __builtin_alignof(a)
#endif

#define va_start(list, v) __builtin_va_start(list, v, 1)
#define va_end(list)
#define va_arg(list, mode) \
    ( *(        ((list).offset += ((int)sizeof(mode) + 7) & -8) , \
        (mode *)((list).a0 + (list).offset - \
                    ((__builtin_isfloat(mode) && (list).offset <= (6 * 8)) ? \
                        (6 * 8) + 8 : ((int)sizeof(mode) + 7) & -8) \
                ) \
       ) \
    )

#elif defined(_M_PPC)

/* Microsoft C8 front end (used in Motorola Merged compiler) */
/* bytes that a type occupies in the argument list */
#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )
/* return 'ap' adjusted for type 't' in arglist */
#define	_ALIGNIT(ap,t) \
	((((int)(ap))+(sizeof(t)<8?3:7)) & (sizeof(t)<8?~3:~7))

#define va_start(ap,v)  ( ap = (va_list)&v + _INTSIZEOF(v) )
#define va_arg(ap,t)    ( *(t *)((ap = (char *) (_ALIGNIT(ap, t) + _INTSIZEOF(t))) - _INTSIZEOF(t)) )
#define va_end(ap)      ( ap = (va_list)0 )

#elif defined(_M_M68K)
#define _INTSIZEOF(n)	( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v)	( ap = (va_list)&v + (sizeof(v) < sizeof(int) ? sizeof(v) : _INTSIZEOF(v)) )
#define va_arg(ap,t)	( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap)	( ap = (va_list)0 )

#elif defined(_M_MPPC)
#define _INTSIZEOF(n)	( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v)	( ap = (va_list)&v + _INTSIZEOF(v) )
#define va_arg(ap,t)	( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap)	( ap = (va_list)0 )

#else

/* A guess at the proper definitions for other platforms */

#define _INTSIZEOF(n)	( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v)	( ap = (va_list)&v + _INTSIZEOF(v) )
#define va_arg(ap,t)	( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap)	( ap = (va_list)0 )


#endif


#ifdef __cplusplus
}
#endif

#ifdef	_MSC_VER
#pragma pack(pop)
#endif	/* _MSC_VER */

#endif	/* _INC_STDARG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\stddef.h ===
/***
*stddef.h - definitions/declarations for common constants, types, variables
*
*	Copyright (c) 1985-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file contains definitions and declarations for some commonly
*	used constants, types, and variables.
*	[ANSI]
*
*       [Public]
*
****/

#ifndef _INC_STDDEF
#define _INC_STDDEF

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Define NULL pointer value and the offset() macro */

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif


#define offsetof(s,m)	(size_t)&(((s *)0)->m)


/* Declare reference to errno */

#if (defined(_MT) || defined(_DLL)) && (!defined(_M_MPPC) && !defined(_M_M68K))
_CRTIMP extern int * __cdecl _errno(void);
#define errno	(*_errno())
#else	/* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;
#endif	/* _MT || _DLL */


/* define the implementation dependent size types */

#ifndef _PTRDIFF_T_DEFINED
typedef int ptrdiff_t;
#define _PTRDIFF_T_DEFINED
#endif


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


#ifdef	_MT
_CRTIMP extern unsigned long  __cdecl __threadid(void);
#define _threadid	(__threadid())
_CRTIMP extern unsigned long  __cdecl __threadhandle(void);
#endif


#ifdef __cplusplus
}
#endif

#endif	/* _INC_STDDEF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\setjmp.h ===
/***
*setjmp.h - definitions/declarations for setjmp/longjmp routines
*
*       Copyright (c) 1985-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the machine-dependent buffer used by
*       setjmp/longjmp to save and restore the program state, and
*       declarations for those routines.
*       [ANSI/System V]
*
*       [Public]
*
****/

#ifndef _INC_SETJMP
#define _INC_SETJMP

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if     _MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if     _MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else   /* ndef _NTSDK */
/* current definition */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _NTSDK */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/*
 * Definitions specific to particular setjmp implementations.
 */

#if     defined(_M_IX86)

/*
 * MS compiler for x86
 */

#ifndef _INC_SETJMPEX
#define setjmp  _setjmp
#endif

#define _JBLEN  16
#define _JBTYPE int

/*
 * Define jump buffer layout for x86 setjmp/longjmp.
 */
typedef struct __JUMP_BUFFER {
    unsigned long Ebp;
    unsigned long Ebx;
    unsigned long Edi;
    unsigned long Esi;
    unsigned long Esp;
    unsigned long Eip;
    unsigned long Registration;
    unsigned long TryLevel;
    unsigned long Cookie;
    unsigned long UnwindFunc;
    unsigned long UnwindData[6];
} _JUMP_BUFFER;



#elif   defined(_M_MRX000)

#ifndef _INC_SETJMPEX
#define setjmp  _setjmp
#endif

/*
 * All MIPS implementations need _JBLEN of 16
 */
#define _JBLEN  16
#define _JBTYPE double

/*
 * Define jump buffer layout for MIPS setjmp/longjmp.
 */
typedef struct __JUMP_BUFFER {
    unsigned long FltF20;
    unsigned long FltF21;
    unsigned long FltF22;
    unsigned long FltF23;
    unsigned long FltF24;
    unsigned long FltF25;
    unsigned long FltF26;
    unsigned long FltF27;
    unsigned long FltF28;
    unsigned long FltF29;
    unsigned long FltF30;
    unsigned long FltF31;
    unsigned long IntS0;
    unsigned long IntS1;
    unsigned long IntS2;
    unsigned long IntS3;
    unsigned long IntS4;
    unsigned long IntS5;
    unsigned long IntS6;
    unsigned long IntS7;
    unsigned long IntS8;
    unsigned long IntSp;
    unsigned long Type;
    unsigned long Fir;
} _JUMP_BUFFER;


#elif   defined(_M_ALPHA)

/*
 * The Alpha C8/GEM C compiler uses an intrinsic _setjmp.
 * The Alpha acc compiler implements setjmp as a function.
 */
#ifdef  _MSC_VER
#ifndef _INC_SETJMPEX
#define setjmp  _setjmp
#endif
#endif

/*
 * Alpha implementations use a _JBLEN of 24 quadwords.
 * A double is used only to obtain quadword size and alignment.
 */
#define _JBLEN  24
#define _JBTYPE double

/*
 * Define jump buffer layout for Alpha setjmp/longjmp.
 * A double is used only to obtain quadword size and alignment.
 */
typedef struct __JUMP_BUFFER {
    unsigned long Fp;
    unsigned long Pc;
    unsigned long Seb;
    unsigned long Type;
    double FltF2;
    double FltF3;
    double FltF4;
    double FltF5;
    double FltF6;
    double FltF7;
    double FltF8;
    double FltF9;
    double IntS0;
    double IntS1;
    double IntS2;
    double IntS3;
    double IntS4;
    double IntS5;
    double IntS6;
    double IntSp;
    double Fir;
    double Fill[5];
} _JUMP_BUFFER;

#elif defined(_M_PPC)
/*
 * The Microsoft VC++ V4.0 compiler uses an intrinsic _setjmp.
 * The Motorola C8.5 compiler implements setjmp as a function.
 */

#if _MSC_VER > 850
#ifndef _INC_SETJMPEX
#undef _setjmp
#define setjmp  _setjmp
#endif
#endif

/*
 * Min length is 240 bytes; round to 256 bytes.
 * Since this is allocated as an array of "double", the
 * number of entries required is 32.
 *
 * All PPC implementations need _JBLEN of 32
 */

#define _JBLEN  32
#define _JBTYPE double

/*
 * Define jump buffer layout for PowerPC setjmp/longjmp.
 */

typedef struct __JUMP_BUFFER {
    double Fpr14;
    double Fpr15;
    double Fpr16;
    double Fpr17;
    double Fpr18;
    double Fpr19;
    double Fpr20;
    double Fpr21;
    double Fpr22;
    double Fpr23;
    double Fpr24;
    double Fpr25;
    double Fpr26;
    double Fpr27;
    double Fpr28;
    double Fpr29;
    double Fpr30;
    double Fpr31;
    unsigned long Gpr1;
    unsigned long Gpr2;
    unsigned long Gpr13;
    unsigned long Gpr14;
    unsigned long Gpr15;
    unsigned long Gpr16;
    unsigned long Gpr17;
    unsigned long Gpr18;
    unsigned long Gpr19;
    unsigned long Gpr20;
    unsigned long Gpr21;
    unsigned long Gpr22;
    unsigned long Gpr23;
    unsigned long Gpr24;
    unsigned long Gpr25;
    unsigned long Gpr26;
    unsigned long Gpr27;
    unsigned long Gpr28;
    unsigned long Gpr29;
    unsigned long Gpr30;
    unsigned long Gpr31;
    unsigned long Cr;
    unsigned long Iar;
    unsigned long Type;
} _JUMP_BUFFER;

#elif   defined(_M_M68K)

#ifndef _INC_SETJMPEX
#define setjmp  _setjmp
#endif

/* internal only for version checking for compatibility */
#define _SETJMP_VER 1.0

/* internal only, jump buffer layout definition */
typedef struct __JUMP_BUFFER {   
        unsigned long d1;       /* 0x00, saved */
        unsigned long d2;       /* 0x04, saved */
        unsigned long d3;       /* 0x08, saved */
        unsigned long d4;       /* 0x0c, saved */
        unsigned long d5;       /* 0x10, saved */
        unsigned long d6;       /* 0x14, saved */
        unsigned long d7;       /* 0x18, saved */
        unsigned long a1;       /* 0x1c, non-swappable version: return address, 
                                         swappable version: swapper lib routine pointer for building return address */
        unsigned long a2;       /* 0x20, saved */
        unsigned long a3;       /* 0x24, saved */
        unsigned long a4;       /* 0x28, saved */
        unsigned long a6;       /* 0x2c, saved */
        unsigned long a7;       /* 0x30, saved */
        unsigned long SwapChain; /* 0x34, without swapper: unused. with swapper: link swappable frames */
        unsigned short reserved; /* 0x38, unused */
        unsigned short SN;      /* 0x3a, swappable version: segment number */
        unsigned long BPC;      /* 0x3c, swappable version: offset within segment */
} _JUMP_BUFFER; 

#define _JBTYPE int
#define _JBLEN  (sizeof(_JUMP_BUFFER)/sizeof(_JBTYPE))

#elif   defined(_M_MPPC)

#ifndef _INC_SETJMPEX
#define setjmp  _setjmp
#endif

#define _JBTYPE int

/* define the buffer type for building the state information */

#define _JBLEN 64   /* return address, R1, R2, R13-R31, FPR14-FPR31, CR 2-5 */
#endif


/* Define the buffer type for holding the state information */

#ifndef _JMP_BUF_DEFINED
typedef _JBTYPE jmp_buf[_JBLEN];
#define _JMP_BUF_DEFINED
#endif


/* Function prototypes */

int __cdecl setjmp(jmp_buf);
_CRTIMP void __cdecl longjmp(jmp_buf, int);

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_SETJMP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\rpcproxy.h ===
/*++

Copyright (c) 1992-1995 Microsoft Corporation

Module Name:

    rpcproxy.h

Abstract:

    Definitions for rpc proxy  stubs. 

Compiler switches:

    -DREGISTER_PROXY_DLL 
        Generates DllMain, DllRegisterServer, and DllUnregisterServer functions
        for automatically registering a proxy DLL.

    -DPROXY_CLSID=clsid
        Specifies a class ID to be used by the proxy DLL.

    -DPROXY_CLSID_IS={0x6f11fe5c,0x2fc5,0x101b,{0x9e,0x45,0x00,0x00,0x0b,0x65,0xc7,0xef}}
        Specifies the value of the class ID to be used by the proxy DLL.

    -DNT35_STRICT 
        Specifies that the target platform is Windows NT 3.5. This switch disables
        the new functions added after the Windows NT 3.5 release.

--*/

#ifndef __RPCPROXY_H__
#define __RPCPROXY_H__
#define __midl_proxy

#ifndef INC_OLE2
#define INC_OLE2
#endif

#if defined(WIN32) || defined(_MPPC_)

//We need to define REFIID, REFCLSID and REFGUID here so that the
//proxy code won't get the const GUID *const definition.
#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct _GUID
{
    unsigned long Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char Data4[8];
} GUID;
#endif /* GUID_DEFINED */

#if !defined( __IID_DEFINED__ )
    #define __IID_DEFINED__

    typedef GUID IID;
    typedef IID *LPIID;
    #define IID_NULL            GUID_NULL
    #define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)
    typedef GUID CLSID;
    typedef CLSID *LPCLSID;
    #define CLSID_NULL          GUID_NULL
    #define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)

    #ifndef _REFGUID_DEFINED
        #define _REFGUID_DEFINED
        typedef const GUID *REFGUID;
    #endif // !_REFGUID_DEFINED

    #ifndef _REFIID_DEFINED
        #define _REFIID_DEFINED
        typedef const IID *REFIID;
    #endif // !_REFIID_DEFINED

    #ifndef _REFCLSID_DEFINED
        #define _REFCLSID_DEFINED
        typedef const CLSID *REFCLSID;
    #endif // !_REFCLSID_DEFINED

#endif // !__IID_DEFINED__

// forward declarations
struct tagCInterfaceStubVtbl;
struct tagCInterfaceProxyVtbl;

typedef struct tagCInterfaceStubVtbl *  PCInterfaceStubVtblList;
typedef struct tagCInterfaceProxyVtbl *  PCInterfaceProxyVtblList;
typedef const char *                    PCInterfaceName;
typedef int __stdcall IIDLookupRtn( const IID * pIID, int * pIndex );
typedef IIDLookupRtn * PIIDLookup;

// pointers to arrays of CInterfaceProxyVtbl's and CInterfaceStubVtbls
typedef struct tagProxyFileInfo
{
    const PCInterfaceProxyVtblList *pProxyVtblList;
    const PCInterfaceStubVtblList *pStubVtblList;
    const PCInterfaceName *     pNamesArray;
    const IID **                pDelegatedIIDs;
    const PIIDLookup            pIIDLookupRtn;
    unsigned short              TableSize;
    unsigned short              TableVersion;
    unsigned long               Filler1;
    unsigned long               Filler2;
    unsigned long               Filler3;
    unsigned long               Filler4;
}ProxyFileInfo;

// extended info with list of interface names
typedef ProxyFileInfo ExtendedProxyFileInfo;

#include <rpc.h>
#include <rpcndr.h>
#include <string.h>
#include <memory.h>

typedef struct tagCInterfaceProxyHeader
{
    //
    // New fields should be added here, at the beginning of the structure.
    //
#ifdef USE_STUBLESS_PROXY
    const void *    pStublessProxyInfo;
#endif
    const IID *     piid;
} CInterfaceProxyHeader;

// Macro used for ANSI compatible stubs.

#if defined(_MPPC_)
#define CINTERFACE_PROXY_VTABLE( n )  \
struct \
{                                     \
    CInterfaceProxyHeader header;     \
    void * pDummyEntryForPowerMac;    \
    void *Vtbl[ n ];                  \
}
#else
#define CINTERFACE_PROXY_VTABLE( n )  \
struct \
{                                     \
    CInterfaceProxyHeader header;     \
    void *Vtbl[ n ];                  \
}                                     
#endif

#pragma warning( disable:4200 )
typedef struct tagCInterfaceProxyVtbl
{
    CInterfaceProxyHeader header;
#if defined(_MPPC_)
    void * pDummyEntryForPowerMac;
#endif
#if defined( _MSC_VER )
    void *Vtbl[];
#else
    void *Vtbl[1];
#endif
} CInterfaceProxyVtbl;
#pragma warning( default:4200 )

typedef
void
(__RPC_STUB __RPC_FAR * PRPC_STUB_FUNCTION) (
    IRpcStubBuffer *This,
    IRpcChannelBuffer * _pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD __RPC_FAR *pdwStubPhase);

typedef struct tagCInterfaceStubHeader
{
    //New fields should be added here, at the beginning of the structure.
    const IID *piid;
    const MIDL_SERVER_INFO *pServerInfo;
    unsigned long DispatchTableCount;
    const PRPC_STUB_FUNCTION *pDispatchTable;
} CInterfaceStubHeader;

typedef struct tagCInterfaceStubVtbl
{
    CInterfaceStubHeader header;
    IRpcStubBufferVtbl Vtbl;
} CInterfaceStubVtbl;

typedef struct tagCStdStubBuffer
{
    const struct IRpcStubBufferVtbl *   lpVtbl; //Points to Vtbl field in CInterfaceStubVtbl.
    long                                RefCount;
    struct IUnknown *                   pvServerObject;
} CStdStubBuffer;

typedef struct tagCStdPSFactoryBuffer
{
    const IPSFactoryBufferVtbl *lpVtbl;
    long                    RefCount;
    const ProxyFileInfo **  pProxyFileList;
    long                    Filler1;  //Reserved for future use.
} CStdPSFactoryBuffer;

void RPC_ENTRY
NdrProxyInitialize(
    void *              This,
    PRPC_MESSAGE        pRpcMsg, 
    PMIDL_STUB_MESSAGE  pStubMsg,
    PMIDL_STUB_DESC     pStubDescriptor,
    unsigned int        ProcNum );

void RPC_ENTRY
NdrProxyGetBuffer(
    void *              This,
    PMIDL_STUB_MESSAGE pStubMsg);

void RPC_ENTRY
NdrProxySendReceive(
    void                *This,
    MIDL_STUB_MESSAGE   *pStubMsg);

void RPC_ENTRY
NdrProxyFreeBuffer(
    void                *This,
    MIDL_STUB_MESSAGE   *pStubMsg);

HRESULT RPC_ENTRY
NdrProxyErrorHandler(
    DWORD dwExceptionCode);

void RPC_ENTRY
NdrStubInitialize(
    PRPC_MESSAGE        pRpcMsg, 
    PMIDL_STUB_MESSAGE  pStubMsg, 
    PMIDL_STUB_DESC     pStubDescriptor,
    IRpcChannelBuffer * pRpcChannelBuffer);

void __RPC_STUB NdrStubForwardingFunction(
    IN  IRpcStubBuffer *    This,
    IN  IRpcChannelBuffer * pChannel,
    IN  PRPC_MESSAGE        pmsg,
    OUT DWORD __RPC_FAR *   pdwStubPhase);

void RPC_ENTRY
NdrStubGetBuffer(
    IRpcStubBuffer *    This,
    IRpcChannelBuffer * pRpcChannelBuffer, 
    PMIDL_STUB_MESSAGE  pStubMsg);

HRESULT RPC_ENTRY
NdrStubErrorHandler(
    DWORD dwExceptionCode);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_QueryInterface(
    IRpcStubBuffer *This, 
    REFIID riid, 
    void **ppvObject);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_AddRef(
    IRpcStubBuffer *This);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_Release(
    IRpcStubBuffer *This);

ULONG STDMETHODCALLTYPE
NdrCStdStubBuffer_Release(
    IRpcStubBuffer *This,
    IPSFactoryBuffer * pPSF);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_Connect(
    IRpcStubBuffer *This, 
    IUnknown *pUnkServer);

void STDMETHODCALLTYPE
CStdStubBuffer_Disconnect(
    IRpcStubBuffer *This);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_Invoke(
    IRpcStubBuffer *This,
    RPCOLEMESSAGE *pRpcMsg,
    IRpcChannelBuffer *pRpcChannelBuffer);

IRpcStubBuffer * STDMETHODCALLTYPE
CStdStubBuffer_IsIIDSupported(
    IRpcStubBuffer *This,
    REFIID riid);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_CountRefs(
    IRpcStubBuffer *This);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_DebugServerQueryInterface(
    IRpcStubBuffer *This, 
    void **ppv);

void STDMETHODCALLTYPE
CStdStubBuffer_DebugServerRelease(
    IRpcStubBuffer *This,
    void *pv);

#if defined(_MPPC_)
#define CStdStubBuffer_METHODS \
    0,  /* a PowerMac dummy */  \
    CStdStubBuffer_QueryInterface,\
    CStdStubBuffer_AddRef, \
    CStdStubBuffer_Release, \
    CStdStubBuffer_Connect, \
    CStdStubBuffer_Disconnect, \
    CStdStubBuffer_Invoke, \
    CStdStubBuffer_IsIIDSupported, \
    CStdStubBuffer_CountRefs, \
    CStdStubBuffer_DebugServerQueryInterface, \
    CStdStubBuffer_DebugServerRelease
#else
#define CStdStubBuffer_METHODS \
    CStdStubBuffer_QueryInterface,\
    CStdStubBuffer_AddRef, \
    CStdStubBuffer_Release, \
    CStdStubBuffer_Connect, \
    CStdStubBuffer_Disconnect, \
    CStdStubBuffer_Invoke, \
    CStdStubBuffer_IsIIDSupported, \
    CStdStubBuffer_CountRefs, \
    CStdStubBuffer_DebugServerQueryInterface, \
    CStdStubBuffer_DebugServerRelease
#endif

//+-------------------------------------------------------------------------
//
//  Macro definitions for the proxy file
//
//--------------------------------------------------------------------------

#define IID_GENERIC_CHECK_IID(name,pIID,index) memcmp( pIID, name##_ProxyVtblList[ index ]->header.piid, 16 )

#define IID_BS_LOOKUP_SETUP     int result, low=-1;

#define IID_BS_LOOKUP_INITIAL_TEST(name, sz, split)   \
    if ( ( result = name##_CHECK_IID( split ) ) > 0 ) \
        { low = sz - split; }                      \
    else if ( !result )                               \
        { low = split; goto found_label; }

#define IID_BS_LOOKUP_NEXT_TEST(name, split )         \
    if ( ( result = name##_CHECK_IID( low + split )) >= 0 )  \
        { low = low + split; if ( !result ) goto found_label; }

#define IID_BS_LOOKUP_RETURN_RESULT(name, sz, index )                  \
    low = low + 1;                                          \
    if ( ( low >= sz ) || (result = name##_CHECK_IID( low ) )) goto not_found_label; \
    found_label: (index) = low; return 1;                         \
    not_found_label: return 0;

//+-------------------------------------------------------------------------
//
//  Macro and routine definitions for the dlldata file
//
//--------------------------------------------------------------------------

/****************************************************************************
 * Proxy Dll APIs
 ****************************************************************************/

HRESULT RPC_ENTRY 
NdrDllGetClassObject (
    IN  REFCLSID                rclsid,
    IN  REFIID                  riid,
    OUT void **                 ppv,
    IN const ProxyFileInfo **   pProxyFileList, 
    IN const CLSID *            pclsid,
    IN CStdPSFactoryBuffer *    pPSFactoryBuffer);

HRESULT RPC_ENTRY 
NdrDllCanUnloadNow(
    IN CStdPSFactoryBuffer * pPSFactoryBuffer);

/*************************************************************************
The following new functions were added after the Windows NT 3.5 release.
Programs intended to run on Windows NT 3.5 should define NT35_STRICT to 
ensure that no new functions are used.
*************************************************************************/
#ifndef NT35_STRICT

HRESULT RPC_ENTRY NdrDllRegisterProxy(
    IN HMODULE                  hDll,
    IN const ProxyFileInfo **   pProxyFileList, 
    IN const CLSID *            pclsid);

HRESULT RPC_ENTRY NdrDllUnregisterProxy(
    IN HMODULE                  hDll,
    IN const ProxyFileInfo **   pProxyFileList, 
    IN const CLSID *            pclsid);


#define REGISTER_PROXY_DLL_ROUTINES(pProxyFileList, pClsID) \
    \
    HINSTANCE hProxyDll = 0; \
    \
    /*DllMain saves the DLL module handle for later use by DllRegisterServer */ \
    BOOL WINAPI DllMain( \
        HINSTANCE  hinstDLL, \
        DWORD  fdwReason, \
        LPVOID  lpvReserved) \
    { \
        if(fdwReason == DLL_PROCESS_ATTACH) \
            hProxyDll = hinstDLL; \
        return TRUE; \
    } \
    \
    /* DllRegisterServer registers the interfaces contained in the proxy DLL. */ \
    HRESULT STDAPICALLTYPE DllRegisterServer() \
    { \
        return NdrDllRegisterProxy(hProxyDll, pProxyFileList, pClsID); \
    }  \
    \
    /* DllUnregisterServer unregisters the interfaces contained in the proxy DLL. */ \
    HRESULT STDAPICALLTYPE DllUnregisterServer() \
    { \
        return NdrDllUnregisterProxy(hProxyDll, pProxyFileList, pClsID); \
    }  

//Delegation support.
#define STUB_FORWARDING_FUNCTION        NdrStubForwardingFunction

ULONG STDMETHODCALLTYPE
CStdStubBuffer2_Release(IRpcStubBuffer *This);

ULONG STDMETHODCALLTYPE
NdrCStdStubBuffer2_Release(IRpcStubBuffer *This,IPSFactoryBuffer * pPSF);

#define CStdStubBuffer_DELEGATING_METHODS 0, 0, CStdStubBuffer2_Release, 0, 0, 0, 0, 0, 0, 0

#endif //NT35_STRICT
/*************************************************************************
End of new functions.
*************************************************************************/

// PROXY_CLSID has precedence over PROXY_CLSID_IS

#ifdef PROXY_CLSID

#define CLSID_PSFACTORYBUFFER extern CLSID PROXY_CLSID;

#else // PROXY_CLSID

#ifdef PROXY_CLSID_IS
#define CLSID_PSFACTORYBUFFER const CLSID CLSID_PSFactoryBuffer = PROXY_CLSID_IS;
#define PROXY_CLSID     CLSID_PSFactoryBuffer
#else // PROXY_CLSID_IS
#define CLSID_PSFACTORYBUFFER
#endif //PROXY_CLSID_IS

#endif //PROXY_CLSID

// if the user specified an override for the class id, it is
// PROXY_CLSID at this point

#ifndef PROXY_CLSID
#define GET_DLL_CLSID   \
    ( aProxyFileList[0]->pStubVtblList[0] != 0 ? \
    aProxyFileList[0]->pStubVtblList[0]->header.piid : 0)
#else  //PROXY_CLSID
#define GET_DLL_CLSID   &PROXY_CLSID
#endif //PROXY_CLSID




#define EXTERN_PROXY_FILE(name) \
    EXTERN_C const ProxyFileInfo name##_ProxyFileInfo;

#define PROXYFILE_LIST_START    \
    const ProxyFileInfo  *  aProxyFileList[]    = {

#define REFERENCE_PROXY_FILE(name)  \
    & name##_ProxyFileInfo 

#define PROXYFILE_LIST_END      \
    0 };

// return pointers to the class information

#define DLLDATA_GETPROXYDLLINFO(pPFList,pClsid) \
    void RPC_ENTRY GetProxyDllInfo( const ProxyFileInfo*** pInfo, const CLSID ** pId )  \
        {   \
        *pInfo  = pPFList;  \
        *pId    = pClsid;   \
        };

// ole entry points:
#define DLLGETCLASSOBJECTROUTINE(pPFlist, pClsid,pFactory)    \
 HRESULT STDAPICALLTYPE DllGetClassObject ( \
     REFCLSID rclsid, \
     REFIID riid, \
     void ** ppv ) \
        { \
        return  \
            NdrDllGetClassObject(rclsid,riid,ppv,pPFlist,pClsid,pFactory ); \
        }

#define DLLCANUNLOADNOW(pFactory)   \
 HRESULT STDAPICALLTYPE DllCanUnloadNow()    \
    {   \
    return NdrDllCanUnloadNow( pFactory );    \
    }

   
#define DLLDUMMYPURECALL    \
    void __cdecl _purecall(void)    \
        {   \
        }

#define CSTDSTUBBUFFERRELEASE(pFactory)   \
ULONG STDMETHODCALLTYPE CStdStubBuffer_Release(IRpcStubBuffer *This) \
    {   \
    return NdrCStdStubBuffer_Release(This,(IPSFactoryBuffer *)pFactory);   \
    }   \

#ifdef PROXY_DELEGATION
#define CSTDSTUBBUFFER2RELEASE(pFactory)   \
ULONG STDMETHODCALLTYPE CStdStubBuffer2_Release(IRpcStubBuffer *This) \
    {   \
    return NdrCStdStubBuffer2_Release(This,(IPSFactoryBuffer *)pFactory);   \
    }
#else
#define CSTDSTUBBUFFER2RELEASE(pFactory)   
#endif //PROXY_DELEGATION


#ifdef REGISTER_PROXY_DLL
#define DLLREGISTRY_ROUTINES(pProxyFileList,pClsID ) REGISTER_PROXY_DLL_ROUTINES(pProxyFileList,pClsID )
#else
#define DLLREGISTRY_ROUTINES(pProxyFileList,pClsID )    
#endif //REGISTER_PROXY_DLL


// the dll entry points that must be defined
#define DLLDATA_ROUTINES(pProxyFileList,pClsID )    \
    \
    CLSID_PSFACTORYBUFFER \
    \
    CStdPSFactoryBuffer       gPFactory = {0,0,0,0};  \
    \
    DLLDATA_GETPROXYDLLINFO(pProxyFileList,pClsID) \
    \
    DLLGETCLASSOBJECTROUTINE(pProxyFileList,pClsID,&gPFactory)    \
    \
    DLLCANUNLOADNOW(&gPFactory)   \
    \
    CSTDSTUBBUFFERRELEASE(&gPFactory)   \
    \
    CSTDSTUBBUFFER2RELEASE(&gPFactory) \
    \
    DLLDUMMYPURECALL    \
    \
    DLLREGISTRY_ROUTINES(pProxyFileList, pClsID) \
    \

    // more code goes here...


#define DLLDATA_STANDARD_ROUTINES   \
    DLLDATA_ROUTINES( (const ProxyFileInfo**) pProxyFileList, &CLSID_PSFactoryBuffer )  \

#else  // !defined(__RPC_DOS__) && !defined(__RPC_WIN16__)

//+-------------------------------------------------------------------------
//
//  16-bit definitions (all empty)
//
//--------------------------------------------------------------------------

#endif // WIN32 or _MPPC_

#endif // __RPCPROXY_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\scrnsave.h ===
/*****************************************************************************\
*                                                                             *
* scrnsave.h    Windows NT 3.1 screensaver defines and definitions.           *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*  Windows NT NOTE:   (Differences from Win 3.1 Screensavers)                 *
*                                                                             *
*               All Screensavers are required to have a Description string    *
*               of no more than 25 chars for display by the Control Panel's   *
*               Desktop applet.  This is string 1 in the resource string      *
*               table of the Windows 32-bit screen saver .SCR (.EXE) file.    *
*                                                                             *
*               Passwords for Windows NT Screen Savers are handled by the     *
*               Winlogon process.  If the registry value:                     *
*                                                                             *
*               HKEY_CURRENT_USER\Control Panel\Desktop\ScreenSaverIsSecure   *
*                                                                             *
*               is nonzero, Winlogon will ask for the User's login password   *
*               before allowing the Screen Saver to exit.  All password data  *
*               and dialogs have been removed from individual Screensavers.   *
*                                                                             *
*                                                                             *
*          Copyright (c) 1992-1995, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_SCRNSAVE
#define _INC_SCRNSAVE

#include <pshpack1.h>   /* Assume byte packing throughout */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */


/* MANDATORY string required in .RC file 
 * This string should contain a less than 25 char name/description of the
 * screen saver.  This string is what will be seen by the user in the Control
 * Panel's Desktop applet screen saver listbox.
 */

#define IDS_DESCRIPTION      1

/* Icon resource ID.
 *
 * This should be the first icon used and must have this resource number.
 * This is needed as the first icon in the file will be grabbed
 */
#define ID_APP      100
#define DLG_SCRNSAVECONFIGURE   2003

#define idsIsPassword           1000
#define idsIniFile              1001
#define idsScreenSaver          1002
#define idsPassword             1003
#define idsDifferentPW          1004
#define idsChangePW             1005
#define idsBadOldPW             1006
#define idsAppName              1007
#define idsNoHelpMemory         1008
#define idsHelpFile             1009
#define idsDefKeyword           1010

/* This function is the Window Procedure for the screen saver.  It is
 * up to the programmer to handle any of the messages that wish to be
 * interpretted.  Any unused messages are then passed back to
 * DefScreenSaverProc if desired which will take default action on any
 * unprocessed message...
 */
LRESULT WINAPI ScreenSaverProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

/* This function performs default message processing.  Currently handles
 * the following messages:
 *
 * WM_SYSCOMMAND:   return FALSE if wParam is SC_SCREENSAVE or SC_CLOSE
 *
 * WM_DESTROY:      PostQuitMessage(0)
 *
 * WM_SETCURSOR:    By default, this will set the cursor to a null cursor,
 *                  thereby removing it from the screen.
 *
 * WM_LBUTTONDOWN:
 * WM_MBUTTONDOWN:
 * WM_RBUTTONDOWN:
 * WM_KEYDOWN:
 * WM_KEYUP:
 * WM_MOUSEMOVE:    By default, these will cause the program to terminate.
 *                  Unless the password option is enabled.  In that case
 *                  the DlgGetPassword() dialog box is brought up.
 *
 * WM_NCACTIVATE:
 * WM_ACTIVATEAPP:
 * WM_ACTIVATE:     By default, if the wParam parameter is FALSE (signifying
 *                  that transfer is being taken away from the application),
 *                  then the program will terminate.  Termination is
 *                  accomplished by generating a WM_CLOSE message.  This way,
 *                  if the user sets something up in the WM_CREATE, a
 *                  WM_DESTROY will be generated and it can be destroyed
 *                  properly.
 *                  This message is ignored, however is the password option
 *                  is enabled.
 */
LRESULT WINAPI DefScreenSaverProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

/* A function is also needed for configuring the screen saver.  The function
 * should be exactly like it is below and must be exported such that the
 * program can use MAKEPROCINSTANCE on it and call up a dialog box. Further-
 * more, the template used for the dialog must be called
 * ScreenSaverConfigure to allow the main function to access it...
 */
BOOL WINAPI ScreenSaverConfigureDialog (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

/* To allow the programmer the ability to register child control windows, this
 * function is called prior to the creation of the dialog box.  Any
 * registering that is required should be done here, or return TRUE if none
 * is needed...
 */
BOOL WINAPI RegisterDialogClasses (HANDLE hInst);

/* The following functions are called by DefScreenSaverProc and must
 * be exported by all screensavers using this model.
 */

/*
 * There are only three other points that should be of notice:
 * 1) The screen saver must have a string declared as 'szAppName' contaning the
 *     name of the screen saver, and it must be declared as a global.
 * 2) The screen saver EXE file should be renamed to a file with a SCR
 *     extension so that the screen saver dialog from the control panel can
 *     find it when is searches for screen savers.
 */
#define WS_GT   (WS_GROUP | WS_TABSTOP)

#define MAXFILELEN         13
#define TITLEBARNAMELEN    40
#define APPNAMEBUFFERLEN   40
#define BUFFLEN           255

/* The following globals are defined in scrnsave.lib */
extern HANDLE hMainInstance;
extern HWND   hMainWindow;
extern BOOL   fChildPreview;
extern TCHAR  szName[TITLEBARNAMELEN];
extern TCHAR  szAppName[APPNAMEBUFFERLEN];
extern TCHAR  szIniFile[MAXFILELEN];
extern TCHAR  szScreenSaver[22];
extern TCHAR  szHelpFile[MAXFILELEN];
extern TCHAR  szNoHelpMemory[BUFFLEN];
extern UINT   MyHelpMessage;

/* OPTIONAL - Win95 Only */

#define SCRM_VERIFYPW   WM_APP
/*
 * This message is sent to the main screen saver window when password
 * protection is enabled and the user is trying to close the screen saver.  You
 * can process this message and provide your own validation technology.  If you
 * process this message, you should also support the ScreenSaverChangePassword
 * function, described below.  Return zero from this message if the password
 * check failed.  Return nonzero for success.  If you run out of memory or
 * encounter a similar class of error, return non-zero so the user isn't left
 * out in the cold.  The default action is to call the Windows Master
 * Password Router to validate the user's password. 
 */

void WINAPI ScreenSaverChangePassword( HWND hParent );
/*
 * You supply this if you provide your own authentication.  Windows will call
 * it when the user wants to change the password.  An implementation of this
 * function should present password change UI to the user.
 * You should only supply this function if you also hook the SCRM_VERIFYPW
 * message to validate passwords.
 * The default action is to call the Windows Master Password Router.
 */


#ifdef __cplusplus
}
#endif	/* __cplusplus */

#include <poppack.h>

#endif  /* !_INC_SCRNSAVE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\stdiostr.h ===
/***
*stdiostr.h - definitions/declarations for stdiobuf, stdiostream
*
*	Copyright (c) 1991-1995, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the classes, values, macros, and functions
*	used by the stdiostream and stdiobuf classes.
*	[AT&T C++]
*
*       [Public]
*
****/

#ifdef __cplusplus

#ifndef _INC_STDIOSTREAM
#define _INC_STDIOSTREAM

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef	_MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)
#endif	// _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */

#include <iostream.h>
#include <stdio.h>

#ifdef	_MSC_VER
#pragma warning(disable:4514)		// disable unwanted /W4 warning
// #pragma warning(default:4514)	// use this to reenable, if necessary
#endif	// _MSC_VER

class _CRTIMP stdiobuf : public streambuf  {
public:
	stdiobuf(FILE* f);
FILE *	stdiofile() { return _str; }

virtual int pbackfail(int c);
virtual int overflow(int c = EOF);
virtual int underflow();
virtual streampos seekoff( streamoff, ios::seek_dir, int =ios::in|ios::out);
virtual int sync();
	~stdiobuf();
	int setrwbuf(int _rsize, int _wsize);
// protected:
// virtual int doallocate();
private:
	FILE * _str;
};

// obsolescent
class _CRTIMP stdiostream : public iostream {	// note: spec.'d as : public IOS...
public:
	stdiostream(FILE *);
	~stdiostream();
	stdiobuf* rdbuf() const { return (stdiobuf*) ostream::rdbuf(); }
	
private:
};

#ifdef	_MSC_VER
// Restore default packing
#pragma pack(pop)
#endif	// _MSC_VER

#endif	// _INC_STDIOSTREAM

#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\stdio.h ===
/***
*stdio.h - definitions/declarations for standard I/O routines
*
*       Copyright (c) 1985-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structures, values, macros, and functions
*       used by the level 2 I/O ("standard I/O") routines.
*       [ANSI/System V]
*
*       [Public]
*
****/

#ifndef _INC_STDIO
#define _INC_STDIO

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if     _MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if     _MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else   /* ndef _NTSDK */
/* current definition */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _NTSDK */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


#ifndef _MAC
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


#ifndef _WCTYPE_T_DEFINED
typedef wchar_t wint_t;
typedef wchar_t wctype_t;
#define _WCTYPE_T_DEFINED
#endif
#endif /* ndef _MAC */


#ifndef _VA_LIST_DEFINED
#ifdef  _M_ALPHA
typedef struct {
        char *a0;       /* pointer to first homed integer argument */
        int offset;     /* byte offset of next parameter */
} va_list;
#else
typedef char *  va_list;
#endif
#define _VA_LIST_DEFINED
#endif


/* Buffered I/O macros */

#if     defined(_M_MPPC)
#define BUFSIZ  4096
#else  /* defined (_M_MPPC) */
#define BUFSIZ  512
#endif /* defined (_M_MPPC) */


/*
 * Default number of supported streams. _NFILE is confusing and obsolete, but
 * supported anyway for backwards compatibility.
 */
#define _NFILE      _NSTREAM_

#ifdef  _WIN32

#define _NSTREAM_   512

/*
 * Number of entries in _iob[] (declared below). Note that _NSTREAM_ must be
 * greater than or equal to _IOB_ENTRIES.
 */
#define _IOB_ENTRIES 20

#else   /* ndef _WIN32 */

#ifdef  _DLL
#define _NSTREAM_   128
#else
#ifdef  _MT
#define _NSTREAM_   40
#else
#define _NSTREAM_   20
#endif
#endif  /* _DLL */

#endif  /* ndef _MAC */

#define EOF     (-1)


#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif

#if     !defined(_M_MPPC) && !defined(_M_M68K)

/* Directory where temporary files may be created. */

#ifdef  _POSIX_
#define _P_tmpdir   "/"
#define _wP_tmpdir  L"/"
#else
#define _P_tmpdir   "\\"
#define _wP_tmpdir  L"\\"
#endif


/* L_tmpnam = size of P_tmpdir
 *            + 1 (in case P_tmpdir does not end in "/")
 *            + 12 (for the filename string)
 *            + 1 (for the null terminator)
 */
#define L_tmpnam sizeof(_P_tmpdir)+12
#else   /* defined(_M_M68K) || defined(_M_MPPC) */
#define L_tmpnam 255
#endif  /* !defined(_M_M68K) && defined(_M_MPPC) */


#ifdef  _POSIX_
#define L_ctermid   9
#define L_cuserid   32
#endif


/* Seek method constants */

#define SEEK_CUR    1
#define SEEK_END    2
#define SEEK_SET    0


#define FILENAME_MAX    260
#define FOPEN_MAX       20
#define _SYS_OPEN       20
#define TMP_MAX         32767


/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Declare _iob[] array */

#ifndef _STDIO_DEFINED

#ifdef  _NTSDK

#ifdef  _DLL
extern FILE * _iob;
#else
extern FILE _iob[];
#endif

#else   /* ndef _NTSDK */

#if     defined(_DLL) && defined(_M_IX86)

#define _iob    (__p__iob())
_CRTIMP extern FILE * __cdecl __p__iob(void);

#else   /* !(defined(_DLL) && defined(_M_IX86)) */

_CRTIMP extern FILE _iob[];

#endif  /* defined(_DLL) && defined(_M_IX86) */

#endif  /* _NTSDK */

#endif  /* _STDIO_DEFINED */


/* Define file position type */

#ifndef _FPOS_T_DEFINED

#if     defined(_M_MPPC) || defined(_M_M68K) || defined(_POSIX_)

typedef long fpos_t;

#else   /* !defined(_M_MPPC) && !defined(_M_M68K) */

#if     !__STDC__ && _INTEGRAL_MAX_BITS >= 64
typedef __int64 fpos_t;
#else
typedef struct fpos_t {
        unsigned int lopart;
        int          hipart;
        } fpos_t;
#endif

#endif  /* defined(_M_MPPC) || defined(_M_68K) */

#define _FPOS_T_DEFINED
#endif


#define stdin  (&_iob[0])
#define stdout (&_iob[1])
#define stderr (&_iob[2])


#define _IOREAD         0x0001
#define _IOWRT          0x0002

#define _IOFBF          0x0000
#define _IOLBF          0x0040
#define _IONBF          0x0004

#define _IOMYBUF        0x0008
#define _IOEOF          0x0010
#define _IOERR          0x0020
#define _IOSTRG         0x0040
#define _IORW           0x0080
#ifdef _POSIX_
#define _IOAPPEND       0x0200
#endif


/* Function prototypes */

#ifndef _STDIO_DEFINED

_CRTIMP int __cdecl _filbuf(FILE *);
_CRTIMP int __cdecl _flsbuf(int, FILE *);

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl _fsopen(const char *, const char *);
#else
_CRTIMP FILE * __cdecl _fsopen(const char *, const char *, int);
#endif

_CRTIMP void __cdecl clearerr(FILE *);
_CRTIMP int __cdecl fclose(FILE *);
_CRTIMP int __cdecl _fcloseall(void);

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl fdopen(int, const char *);
#else
_CRTIMP FILE * __cdecl _fdopen(int, const char *);
#endif

_CRTIMP int __cdecl feof(FILE *);
_CRTIMP int __cdecl ferror(FILE *);
_CRTIMP int __cdecl fflush(FILE *);
_CRTIMP int __cdecl fgetc(FILE *);
_CRTIMP int __cdecl _fgetchar(void);
_CRTIMP int __cdecl fgetpos(FILE *, fpos_t *);
_CRTIMP char * __cdecl fgets(char *, int, FILE *);

#ifdef  _POSIX_
_CRTIMP int __cdecl fileno(FILE *);
#else
_CRTIMP int __cdecl _fileno(FILE *);
#endif

_CRTIMP int __cdecl _flushall(void);
_CRTIMP FILE * __cdecl fopen(const char *, const char *);
_CRTIMP int __cdecl fprintf(FILE *, const char *, ...);
_CRTIMP int __cdecl fputc(int, FILE *);
_CRTIMP int __cdecl _fputchar(int);
_CRTIMP int __cdecl fputs(const char *, FILE *);
_CRTIMP size_t __cdecl fread(void *, size_t, size_t, FILE *);
_CRTIMP FILE * __cdecl freopen(const char *, const char *, FILE *);
_CRTIMP int __cdecl fscanf(FILE *, const char *, ...);
_CRTIMP int __cdecl fsetpos(FILE *, const fpos_t *);
_CRTIMP int __cdecl fseek(FILE *, long, int);
_CRTIMP long __cdecl ftell(FILE *);
_CRTIMP size_t __cdecl fwrite(const void *, size_t, size_t, FILE *);
_CRTIMP int __cdecl getc(FILE *);
_CRTIMP int __cdecl getchar(void);
_CRTIMP char * __cdecl gets(char *);
_CRTIMP int __cdecl _getw(FILE *);
_CRTIMP void __cdecl perror(const char *);
_CRTIMP int __cdecl _pclose(FILE *);
_CRTIMP FILE * __cdecl _popen(const char *, const char *);
_CRTIMP int __cdecl printf(const char *, ...);
_CRTIMP int __cdecl putc(int, FILE *);
_CRTIMP int __cdecl putchar(int);
_CRTIMP int __cdecl puts(const char *);
_CRTIMP int __cdecl _putw(int, FILE *);
_CRTIMP int __cdecl remove(const char *);
_CRTIMP int __cdecl rename(const char *, const char *);
_CRTIMP void __cdecl rewind(FILE *);
_CRTIMP int __cdecl _rmtmp(void);
_CRTIMP int __cdecl scanf(const char *, ...);
_CRTIMP void __cdecl setbuf(FILE *, char *);
_CRTIMP int __cdecl _setmaxstdio(int);
_CRTIMP int __cdecl setvbuf(FILE *, char *, int, size_t);
_CRTIMP int __cdecl _snprintf(char *, size_t, const char *, ...);
_CRTIMP int __cdecl sprintf(char *, const char *, ...);
_CRTIMP int __cdecl sscanf(const char *, const char *, ...);
_CRTIMP char * __cdecl _tempnam(const char *, const char *);
_CRTIMP FILE * __cdecl tmpfile(void);
_CRTIMP char * __cdecl tmpnam(char *);
_CRTIMP int __cdecl ungetc(int, FILE *);
_CRTIMP int __cdecl _unlink(const char *);
_CRTIMP int __cdecl vfprintf(FILE *, const char *, va_list);
_CRTIMP int __cdecl vprintf(const char *, va_list);
_CRTIMP int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
_CRTIMP int __cdecl vsprintf(char *, const char *, va_list);

#ifndef _MAC
#ifndef _WSTDIO_DEFINED

/* wide function prototypes, also declared in wchar.h  */

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *);
#else
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *, int);
#endif

_CRTIMP wint_t __cdecl fgetwc(FILE *);
_CRTIMP wint_t __cdecl _fgetwchar(void);
_CRTIMP wint_t __cdecl fputwc(wint_t, FILE *);
_CRTIMP wint_t __cdecl _fputwchar(wint_t);
_CRTIMP wint_t __cdecl getwc(FILE *);
_CRTIMP wint_t __cdecl getwchar(void);
_CRTIMP wint_t __cdecl putwc(wint_t, FILE *);
_CRTIMP wint_t __cdecl putwchar(wint_t);
_CRTIMP wint_t __cdecl ungetwc(wint_t, FILE *);

_CRTIMP wchar_t * __cdecl fgetws(wchar_t *, int, FILE *);
_CRTIMP int __cdecl fputws(const wchar_t *, FILE *);
_CRTIMP wchar_t * __cdecl _getws(wchar_t *);
_CRTIMP int __cdecl _putws(const wchar_t *);

_CRTIMP int __cdecl fwprintf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl wprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _snwprintf(wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl swprintf(wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl vfwprintf(FILE *, const wchar_t *, va_list);
_CRTIMP int __cdecl vwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl _vsnwprintf(wchar_t *, size_t, const wchar_t *, va_list);
_CRTIMP int __cdecl vswprintf(wchar_t *, const wchar_t *, va_list);
_CRTIMP int __cdecl fwscanf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl swscanf(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl wscanf(const wchar_t *, ...);

#define getwchar()              fgetwc(stdin)
#define putwchar(_c)            fputwc((_c),stdout)
#define getwc(_stm)             fgetwc(_stm)
#define putwc(_c,_stm)          fputwc(_c,_stm)

_CRTIMP FILE * __cdecl _wfdopen(int, const wchar_t *);
_CRTIMP FILE * __cdecl _wfopen(const wchar_t *, const wchar_t *);
_CRTIMP FILE * __cdecl _wfreopen(const wchar_t *, const wchar_t *, FILE *);
_CRTIMP void __cdecl _wperror(const wchar_t *);
_CRTIMP FILE * __cdecl _wpopen(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wremove(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtempnam(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtmpnam(wchar_t *);


#define _WSTDIO_DEFINED
#endif  /* _WSTDIO_DEFINED */
#endif /* ndef _MAC */

#define _STDIO_DEFINED
#endif  /* _STDIO_DEFINED */


/* Macro definitions */

#define feof(_stream)     ((_stream)->_flag & _IOEOF)
#define ferror(_stream)   ((_stream)->_flag & _IOERR)
#define _fileno(_stream)  ((_stream)->_file)
#define getc(_stream)     (--(_stream)->_cnt >= 0 \
                ? 0xff & *(_stream)->_ptr++ : _filbuf(_stream))
#define putc(_c,_stream)  (--(_stream)->_cnt >= 0 \
                ? 0xff & (*(_stream)->_ptr++ = (char)(_c)) :  _flsbuf((_c),(_stream)))
#define getchar()         getc(stdin)
#define putchar(_c)       putc((_c),stdout)



#ifdef  _MT
#undef  getc
#undef  putc
#undef  getchar
#undef  putchar
#endif



#if     !__STDC__ && !defined(_POSIX_)

/* Non-ANSI names for compatibility */

#define P_tmpdir  _P_tmpdir
#define SYS_OPEN  _SYS_OPEN

#ifdef  _NTSDK

#define fcloseall _fcloseall
#define fdopen    _fdopen
#define fgetchar  _fgetchar
#define fileno    _fileno
#define flushall  _flushall
#define fputchar  _fputchar
#define getw      _getw
#define putw      _putw
#define rmtmp     _rmtmp
#define tempnam   _tempnam
#define unlink    _unlink

#else   /* ndef _NTSDK */

_CRTIMP int __cdecl fcloseall(void);
_CRTIMP FILE * __cdecl fdopen(int, const char *);
_CRTIMP int __cdecl fgetchar(void);
_CRTIMP int __cdecl fileno(FILE *);
_CRTIMP int __cdecl flushall(void);
_CRTIMP int __cdecl fputchar(int);
_CRTIMP int __cdecl getw(FILE *);
_CRTIMP int __cdecl putw(int, FILE *);
_CRTIMP int __cdecl rmtmp(void);
_CRTIMP char * __cdecl tempnam(const char *, const char *);
_CRTIMP int __cdecl unlink(const char *);

#endif  /* _NTSDK */

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif


#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STDIO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\stdlib.h ===
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*       Copyright (c) 1985-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for
*       commonly used library functions which either don't fit somewhere
*       else, or, like toupper/tolower, can't be declared in the normal
*       place for other reasons.
*       [ANSI]
*
*       [Public]
*
****/

#ifndef _INC_STDLIB
#define _INC_STDLIB

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if     _MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if     _MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else   /* ndef _NTSDK */
/* current definition */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _NTSDK */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Definition of the argument values for the exit() function */

#define EXIT_SUCCESS    0
#define EXIT_FAILURE    1


#ifndef _ONEXIT_T_DEFINED
typedef int (__cdecl * _onexit_t)(void);
#if !__STDC__
/* Non-ANSI name for compatibility */
#define onexit_t _onexit_t
#endif
#define _ONEXIT_T_DEFINED
#endif


/* Data structure definitions for div and ldiv runtimes. */

#ifndef _DIV_T_DEFINED

typedef struct _div_t {
        int quot;
        int rem;
} div_t;

typedef struct _ldiv_t {
        long quot;
        long rem;
} ldiv_t;

#define _DIV_T_DEFINED
#endif

/* Maximum value that can be returned by the rand function. */

#define RAND_MAX 0x7fff

/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in ctype.h).
 */
#ifndef MB_CUR_MAX

#ifdef  _NTSDK

/* definition compatible with NT SDK */
#ifdef  _DLL
#define __mb_cur_max    (*__mb_cur_max_dll)
#define MB_CUR_MAX      (*__mb_cur_max_dll)
extern  int *__mb_cur_max_dll;
#else   /* ndef _DLL */
#define MB_CUR_MAX      __mb_cur_max
extern  int __mb_cur_max;
#endif  /* _DLL */

#else   /* ndef _NTSDK */

/* current definition */
#if     defined(_DLL) && defined(_M_IX86)
#define MB_CUR_MAX  (*__p___mb_cur_max())
_CRTIMP int * __cdecl __p___mb_cur_max(void);
#else   /* !(defined(_DLL) && defined(_M_IX86)) */
#define MB_CUR_MAX __mb_cur_max
_CRTIMP extern int __mb_cur_max;
#endif  /* defined(_DLL) && defined(_M_IX86) */

#endif  /* _NTSDK */

#endif  /* MB_CUR_MAX */


/* Minimum and maximum macros */

#define __max(a,b)  (((a) > (b)) ? (a) : (b))
#define __min(a,b)  (((a) < (b)) ? (a) : (b))

/*
 * Sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */
#if !defined(_M_MPPC) && !defined(_M_M68K)
#define _MAX_PATH   260 /* max. length of full pathname */
#define _MAX_DRIVE  3   /* max. length of drive component */
#define _MAX_DIR    256 /* max. length of path component */
#define _MAX_FNAME  256 /* max. length of file name component */
#define _MAX_EXT    256 /* max. length of extension component */
#else   /* ndef defined(_M_M68K) || defined(_M_MPPC) */
#define _MAX_PATH   256 /* max. length of full pathname */
#define _MAX_DIR    32  /* max. length of path component */
#define _MAX_FNAME  64  /* max. length of file name component */
#endif  /* defined(_M_M68K) || defined(_M_MPPC) */

/*
 * Argument values for _set_error_mode().
 */
#define _OUT_TO_DEFAULT 0
#define _OUT_TO_STDERR  1
#define _OUT_TO_MSGBOX  2
#define _REPORT_ERRMODE 3

/* External variable declarations */

#if (defined(_MT) || defined(_DLL)) && (!defined(_M_MPPC) && !defined(_M_M68K))
_CRTIMP int * __cdecl _errno(void);
_CRTIMP unsigned long * __cdecl __doserrno(void);
#define errno       (*_errno())
#define _doserrno   (*__doserrno())
#else   /* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;           /* XENIX style error number */
_CRTIMP extern unsigned long _doserrno;     /* OS system error value */
#endif  /* _MT || _DLL */

#if defined(_M_MPPC) || defined(_M_M68K)
_CRTIMP extern int  _macerrno;      /* OS system error value */
#endif

#ifdef  _NTSDK

/* Definitions and declarations compatible with the NT SDK */

#ifdef  _DLL

extern char ** _sys_errlist;    /* perror error message table */

#define _sys_nerr   (*_sys_nerr_dll)
#define __argc      (*__argc_dll)
#define __argv      (*__argv_dll)
#ifndef _MAC
#define __wargv     (*__wargv_dll)
#endif /* ndef _MAC */
#define _environ    (*_environ_dll)
#ifndef _MAC
#define _wenviron   (*_wenviron_dll)
#endif /* ndef _MAC */
#define _fmode      (*_fmode_dll)
#define _fileinfo   (*_fileinfo_dll)

extern int * _sys_nerr_dll; /* # of entries in sys_errlist table */
extern int * __argc_dll;    /* count of cmd line args */
extern char *** __argv_dll; /* pointer to table of cmd line args */
#ifndef _MAC
extern wchar_t *** __wargv_dll; /* pointer to table of wide cmd line args */
#endif /* ndef _MAC */
extern char *** _environ_dll;   /* pointer to environment table */
#ifndef _MAC
extern wchar_t *** _wenviron_dll;   /* pointer to wide environment table */
#endif /* ndef _MAC */
extern int * _fmode_dll;    /* default file translation mode */
extern int * _fileinfo_dll; /* open file info mode (for spawn) */

#define _pgmptr     (*_pgmptr_dll)
#ifndef _MAC
#define _wpgmptr    (*_wpgmptr_dll)
#endif /* ndef _MAC */

#define _osver      (*_osver_dll)
#define _winver     (*_winver_dll)
#define _winmajor   (*_winmajor_dll)
#define _winminor   (*_winminor_dll)

extern char ** _pgmptr_dll;
#ifndef _MAC
extern wchar_t ** _wpgmptr_dll;
#endif /* ndef _MAC */

extern unsigned int * _osver_dll;
extern unsigned int * _winver_dll;
extern unsigned int * _winmajor_dll;
extern unsigned int * _winminor_dll;

#else   /* ndef _DLL */


extern char * _sys_errlist[];   /* perror error message table */
extern int _sys_nerr;       /* # of entries in sys_errlist table */

extern int __argc;      /* count of cmd line args */
extern char ** __argv;      /* pointer to table of cmd line args */
#ifndef _MAC
extern wchar_t ** __wargv;  /* pointer to table of wide cmd line args */
#endif /* ndef _MAC */

#ifdef _POSIX_
extern char ** environ;     /* pointer to environment table */
#else
extern char **    _environ;     /* pointer to environment table */
#ifndef _MAC
extern wchar_t ** _wenviron;    /* pointer to wide environment table */
#endif /* ndef _MAC */
#endif

extern int _fmode;      /* default file translation mode */
extern int _fileinfo;       /* open file info mode (for spawn) */

extern char * _pgmptr;      /* points to the module (EXE) name */
#ifndef _MAC
extern wchar_t * _wpgmptr;  /* points to the module (EXE) wide name */
#endif /* ndef _MAC */

/* Windows major/minor and O.S. version numbers */

extern unsigned int _osver;
extern unsigned int _winver;
extern unsigned int _winmajor;
extern unsigned int _winminor;

#endif  /* _DLL */

#else   /* ndef _NTSDK */

/* Current definitions and declarations */

_CRTIMP extern char * _sys_errlist[];   /* perror error message table */
_CRTIMP extern int _sys_nerr;       /* # of entries in sys_errlist table */

#if defined(_DLL) && defined(_M_IX86)

#define __argc      (*__p___argc()) /* count of cmd line args */
#define __argv      (*__p___argv()) /* pointer to table of cmd line args */
#define __wargv     (*__p___wargv())    /* pointer to table of wide cmd line args */
#define _environ    (*__p__environ())   /* pointer to environment table */
#ifndef _MAC
#define _wenviron   (*__p__wenviron())  /* pointer to wide environment table */
#endif /* ndef _MAC */
#define _fmode      (*__p__fmode())
#define _osver      (*__p__osver())
#define _pgmptr     (*__p__pgmptr())    /* points to the module (EXE) name */
#ifndef _MAC
#define _wpgmptr    (*__p__wpgmptr())   /* points to the module (EXE) wide name */
#endif /* ndef _MAC */
#define _winver     (*__p__winver())
#define _winmajor   (*__p__winmajor())
#define _winminor   (*__p__winminor())

_CRTIMP int *          __cdecl __p___argc(void);
_CRTIMP char ***       __cdecl __p___argv(void);
#ifndef _MAC
_CRTIMP wchar_t ***    __cdecl __p___wargv(void);
#endif /* ndef _MAC */
_CRTIMP char ***       __cdecl __p__environ(void);
#ifndef _MAC
_CRTIMP wchar_t ***    __cdecl __p__wenviron(void);
#endif /* ndef _MAC */
_CRTIMP int *          __cdecl __p__fmode(void);
_CRTIMP unsigned int * __cdecl __p__osver(void);
_CRTIMP char **        __cdecl __p__pgmptr(void);
#ifndef _MAC
_CRTIMP wchar_t **     __cdecl __p__wpgmptr(void);
#endif /* ndef _MAC */
_CRTIMP unsigned int * __cdecl __p__winver(void);
_CRTIMP unsigned int * __cdecl __p__winmajor(void);
_CRTIMP unsigned int * __cdecl __p__winminor(void);

#else   /* !(defined(_DLL) && defined(_M_IX86)) */
_CRTIMP extern int __argc;          /* count of cmd line args */
_CRTIMP extern char ** __argv;      /* pointer to table of cmd line args */
#ifndef _MAC
_CRTIMP extern wchar_t ** __wargv;  /* pointer to table of wide cmd line args */
#endif /* ndef _MAC */

_CRTIMP extern char **    _environ;     /* pointer to environment table */
#ifndef _MAC
_CRTIMP extern wchar_t ** _wenviron;    /* pointer to wide environment table */
#endif /* ndef _MAC */

_CRTIMP extern int _fmode;          /* default file translation mode */
_CRTIMP extern int _fileinfo;       /* open file info mode (for spawn) */

_CRTIMP extern char * _pgmptr;      /* points to the module (EXE) name */
#ifndef _MAC
_CRTIMP extern wchar_t * _wpgmptr;  /* points to the module (EXE) wide name */
#endif /* ndef _MAC */

/* Windows major/minor and O.S. version numbers */

_CRTIMP extern unsigned int _osver;
_CRTIMP extern unsigned int _winver;
_CRTIMP extern unsigned int _winmajor;
_CRTIMP extern unsigned int _winminor;
#endif  /* defined(_DLL) && defined(_M_IX86) */

#endif  /* _NTSDK */

/* function prototypes */

_CRTIMP void   __cdecl abort(void);
#if defined(_M_MRX000)
_CRTIMP int    __cdecl abs(int);

#else
        int    __cdecl abs(int);
#endif
        int    __cdecl atexit(void (__cdecl *)(void));
_CRTIMP double __cdecl atof(const char *);
_CRTIMP int    __cdecl atoi(const char *);
_CRTIMP long   __cdecl atol(const char *);
#ifdef _M_M68K
_CRTIMP long double __cdecl _atold(const char *);
#endif
_CRTIMP void * __cdecl bsearch(const void *, const void *, size_t, size_t,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl calloc(size_t, size_t);
_CRTIMP div_t  __cdecl div(int, int);
_CRTIMP void   __cdecl exit(int);
_CRTIMP void   __cdecl free(void *);
_CRTIMP char * __cdecl getenv(const char *);
_CRTIMP char * __cdecl _itoa(int, char *, int);
#if defined(_M_MRX000)
_CRTIMP long __cdecl labs(long);
#else
        long __cdecl labs(long);
#endif
_CRTIMP ldiv_t __cdecl ldiv(long, long);
_CRTIMP char * __cdecl _ltoa(long, char *, int);
_CRTIMP void * __cdecl malloc(size_t);
_CRTIMP int    __cdecl mblen(const char *, size_t);
_CRTIMP size_t __cdecl _mbstrlen(const char *s);
_CRTIMP int    __cdecl mbtowc(wchar_t *, const char *, size_t);
_CRTIMP size_t __cdecl mbstowcs(wchar_t *, const char *, size_t);
_CRTIMP void   __cdecl qsort(void *, size_t, size_t, int (__cdecl *)
        (const void *, const void *));
_CRTIMP int    __cdecl rand(void);
_CRTIMP void * __cdecl realloc(void *, size_t);
_CRTIMP int    __cdecl _set_error_mode(int);
_CRTIMP void   __cdecl srand(unsigned int);
_CRTIMP double __cdecl strtod(const char *, char **);
_CRTIMP long   __cdecl strtol(const char *, char **, int);
#ifdef _M_M68K
_CRTIMP long double __cdecl _strtold(const char *, char **);
#endif
_CRTIMP unsigned long __cdecl strtoul(const char *, char **, int);
#if !defined(_M_MPPC) && !defined(_M_M68K)
_CRTIMP int    __cdecl system(const char *);
#endif
_CRTIMP char * __cdecl _ultoa(unsigned long, char *, int);
_CRTIMP int    __cdecl wctomb(char *, wchar_t);
_CRTIMP size_t __cdecl wcstombs(char *, const wchar_t *, size_t);

#ifndef _MAC
#ifndef _WSTDLIB_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _itow (int, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ltow (long, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ultow (unsigned long, wchar_t *, int);
_CRTIMP double __cdecl wcstod(const wchar_t *, wchar_t **);
_CRTIMP long   __cdecl wcstol(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned long __cdecl wcstoul(const wchar_t *, wchar_t **, int);
_CRTIMP wchar_t * __cdecl _wgetenv(const wchar_t *);
_CRTIMP int    __cdecl _wsystem(const wchar_t *);
_CRTIMP int __cdecl _wtoi(const wchar_t *);
_CRTIMP long __cdecl _wtol(const wchar_t *);

#define _WSTDLIB_DEFINED
#endif
#endif /* ndef _MAC */

#ifndef _POSIX_

_CRTIMP char * __cdecl _ecvt(double, int, int *, int *);
_CRTIMP void   __cdecl _exit(int);
_CRTIMP char * __cdecl _fcvt(double, int, int *, int *);
_CRTIMP char * __cdecl _fullpath(char *, const char *, size_t);
_CRTIMP char * __cdecl _gcvt(double, int, char *);
        unsigned long __cdecl _lrotl(unsigned long, int);
        unsigned long __cdecl _lrotr(unsigned long, int);
#if !defined(_M_MPPC) && !defined(_M_M68K)
_CRTIMP void   __cdecl _makepath(char *, const char *, const char *, const char *,
        const char *);
#endif
        _onexit_t __cdecl _onexit(_onexit_t);
_CRTIMP void   __cdecl perror(const char *);
_CRTIMP int    __cdecl _putenv(const char *);
        unsigned int __cdecl _rotl(unsigned int, int);
        unsigned int __cdecl _rotr(unsigned int, int);
_CRTIMP void   __cdecl _searchenv(const char *, const char *, char *);
#if !defined(_M_MPPC) && !defined(_M_M68K)
_CRTIMP void   __cdecl _splitpath(const char *, char *, char *, char *, char *);
#endif
_CRTIMP void   __cdecl _swab(char *, char *, int);

#ifndef _MAC
#ifndef _WSTDLIBP_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wfullpath(wchar_t *, const wchar_t *, size_t);
_CRTIMP void   __cdecl _wmakepath(wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *,
        const wchar_t *);
_CRTIMP void   __cdecl _wperror(const wchar_t *);
_CRTIMP int    __cdecl _wputenv(const wchar_t *);
_CRTIMP void   __cdecl _wsearchenv(const wchar_t *, const wchar_t *, wchar_t *);
_CRTIMP void   __cdecl _wsplitpath(const wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *);

#define _WSTDLIBP_DEFINED
#endif
#endif /* ndef _MAC */

/* --------- The following functions are OBSOLETE --------- */
/* The Win32 API SetErrorMode, Beep and Sleep should be used instead. */
#if !defined(_M_MPPC) && !defined(_M_M68K)
_CRTIMP void _seterrormode(int);
_CRTIMP void _beep(unsigned, unsigned);
_CRTIMP void _sleep(unsigned long);
#endif  /* ndef defined(_M_M68K) || defined(_M_MPPC) */
/*  --------- The preceding functions are OBSOLETE --------- */

#endif  /* _POSIX_ */

#ifndef tolower     /* tolower has been undefined - use function */
_CRTIMP int __cdecl tolower(int);
#endif  /* tolower */

#ifndef toupper     /* toupper has been undefined - use function */
_CRTIMP int __cdecl toupper(int);
#endif  /* toupper */


#if     !__STDC__

/* Non-ANSI names for compatibility */

#ifdef  _NTSDK

#ifndef _POSIX_

#ifndef __cplusplus
#define max(a,b)    (((a) > (b)) ? (a) : (b))
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif

#define sys_errlist _sys_errlist
#define sys_nerr    _sys_nerr
#define environ     _environ

#define DOS_MODE    _DOS_MODE
#define OS2_MODE    _OS2_MODE

#define ecvt        _ecvt
#define fcvt        _fcvt
#define gcvt        _gcvt
#define itoa        _itoa
#define ltoa        _ltoa
#define onexit      _onexit
#define putenv      _putenv
#define swab        _swab
#define ultoa       _ultoa

#endif  /* _POSIX_ */

#else   /* ndef _NTSDK */

#ifndef __cplusplus
#define max(a,b)    (((a) > (b)) ? (a) : (b))
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif

#define sys_errlist _sys_errlist
#define sys_nerr    _sys_nerr
#define environ     _environ

_CRTIMP char * __cdecl ecvt(double, int, int *, int *);
_CRTIMP char * __cdecl fcvt(double, int, int *, int *);
_CRTIMP char * __cdecl gcvt(double, int, char *);
_CRTIMP char * __cdecl itoa(int, char *, int);
_CRTIMP char * __cdecl ltoa(long, char *, int);
        onexit_t __cdecl onexit(onexit_t);
_CRTIMP int    __cdecl putenv(const char *);
_CRTIMP void   __cdecl swab(char *, char *, int);
_CRTIMP char * __cdecl ultoa(unsigned long, char *, int);

#endif  /* _NTSDK */

#endif  /* __STDC__ */

#ifdef __cplusplus
}
#endif


#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STDLIB */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\strstrea.h ===
/***
*strstream.h - definitions/declarations for strstreambuf, strstream
*
*	Copyright (c) 1991-1995, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the classes, values, macros, and functions
*	used by the strstream and strstreambuf classes.
*	[AT&T C++]
*
*       [Public]
*
****/

#ifdef __cplusplus

#ifndef _INC_STRSTREAM
#define _INC_STRSTREAM

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef	_MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)
#endif	// _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


#include <iostream.h>

#ifdef	_MSC_VER
#pragma warning(disable:4514)		// disable unwanted /W4 warning
// #pragma warning(default:4514)	// use this to reenable, if necessary
#endif	// _MSC_VER

class _CRTIMP strstreambuf : public streambuf  {
public:
		strstreambuf();
		strstreambuf(int);
		strstreambuf(char *, int, char * = 0);
		strstreambuf(unsigned char *, int, unsigned char * = 0);
		strstreambuf(signed char *, int, signed char * = 0);
		strstreambuf(void * (*a)(long), void (*f) (void *));
		~strstreambuf();

	void	freeze(int =1);
	char * str();

virtual	int	overflow(int);
virtual	int	underflow();
virtual streambuf* setbuf(char *, int);
virtual	streampos seekoff(streamoff, ios::seek_dir, int);
virtual int	sync();		// not in spec.

protected:
virtual	int	doallocate();
private:
	int	x_dynamic;
	int 	x_bufmin;
	int 	_fAlloc;
	int	x_static;
	void * (* x_alloc)(long);
	void 	(* x_free)(void *);
};

class _CRTIMP istrstream : public istream {
public:
		istrstream(char *);
		istrstream(char *, int);
		~istrstream();

inline	strstreambuf* rdbuf() const { return (strstreambuf*) ios::rdbuf(); }
inline	char * str() { return rdbuf()->str(); }
};

class _CRTIMP ostrstream : public ostream {
public:
		ostrstream();
		ostrstream(char *, int, int = ios::out);
		~ostrstream();

inline	int	pcount() const { return rdbuf()->out_waiting(); }
inline	strstreambuf* rdbuf() const { return (strstreambuf*) ios::rdbuf(); }
inline	char *	str() { return rdbuf()->str(); }
};

class _CRTIMP strstream : public iostream {	// strstreambase ???
public:
		strstream();
		strstream(char *, int, int);
		~strstream();

inline	int	pcount() const { return rdbuf()->out_waiting(); } // not in spec.
inline	strstreambuf* rdbuf() const { return (strstreambuf*) ostream::rdbuf(); }
inline	char * str() { return rdbuf()->str(); }
};

#ifdef	_MSC_VER
// Restore previous packing
#pragma pack(pop)
#endif	// _MSC_VER

#endif	// _INC_STRSTREAM

#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\time.h ===
/***
*time.h - definitions/declarations for time routines
*
*       Copyright (c) 1985-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has declarations of time routines and defines
*       the structure returned by the localtime and gmtime routines and
*       used by asctime.
*       [ANSI/System V]
*
*       [Public]
*
****/

#ifndef _INC_TIME
#define _INC_TIME

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if     _MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if     _MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else   /* ndef _NTSDK */
/* current definition */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _NTSDK */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _MAC
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif
#endif /* ndef _MAC */

/* Define the implementation defined time type */

#ifndef _TIME_T_DEFINED
typedef long time_t;        /* time value */
#define _TIME_T_DEFINED     /* avoid multiple def's of time_t */
#endif

#ifndef _CLOCK_T_DEFINED
typedef long clock_t;
#define _CLOCK_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


#ifndef _TM_DEFINED
struct tm {
        int tm_sec;     /* seconds after the minute - [0,59] */
        int tm_min;     /* minutes after the hour - [0,59] */
        int tm_hour;    /* hours since midnight - [0,23] */
        int tm_mday;    /* day of the month - [1,31] */
        int tm_mon;     /* months since January - [0,11] */
        int tm_year;    /* years since 1900 */
        int tm_wday;    /* days since Sunday - [0,6] */
        int tm_yday;    /* days since January 1 - [0,365] */
        int tm_isdst;   /* daylight savings time flag */
        };
#define _TM_DEFINED
#endif


/* Clock ticks macro - ANSI version */

#define CLOCKS_PER_SEC  1000


/* Extern declarations for the global variables used by the ctime family of
 * routines.
 */

#ifdef  _NTSDK

#ifdef  _DLL

/* Declarations and definitions compatible with the NT SDK */

#define _daylight   (*_daylight_dll)
#define _timezone   (*_timezone_dll)

/* non-zero if daylight savings time is used */
extern int * _daylight_dll;

/* difference in seconds between GMT and local time */
extern long * _timezone_dll;

/* standard/daylight savings time zone names */
extern char ** _tzname;

#else   /* ndef _DLL */


#ifdef  _POSIX_
extern char * _rule;
#endif  /* _POSIX_ */

/* non-zero if daylight savings time is used */
extern int _daylight;

/* difference in seconds between GMT and local time */
extern long _timezone;

/* standard/daylight savings time zone names */
#ifdef  _POSIX_
extern char * tzname[2];
#else   /* ndef _POSIX_ */
extern char * _tzname[2];
#endif  /* _POSIX_ */

#endif  /* _DLL */

#else   /* ndef _NTSDK */

/* Current declarations and definitions */

#if     defined(_DLL) && defined(_M_IX86)

#define _daylight   (*__p__daylight())
_CRTIMP int * __cdecl __p__daylight(void);

#define _timezone   (*__p__timezone())
_CRTIMP long * __cdecl __p__timezone(void);

#define _tzname     (__p__tzname())
_CRTIMP char ** __cdecl __p__tzname(void);

#else   /* !(defined(_DLL) && defined(_M_IX86)) */

/* non-zero if daylight savings time is used */
_CRTIMP extern int _daylight;

/* difference in seconds between GMT and local time */
_CRTIMP extern long _timezone;

/* standard/daylight savings time zone names */
_CRTIMP extern char * _tzname[2];

#endif  /* defined(_DLL) && defined(_M_IX86) */

#endif  /* _NTSDK */


/* Function prototypes */

_CRTIMP char * __cdecl asctime(const struct tm *);
_CRTIMP char * __cdecl ctime(const time_t *);
_CRTIMP clock_t __cdecl clock(void);
_CRTIMP double __cdecl difftime(time_t, time_t);
_CRTIMP struct tm * __cdecl gmtime(const time_t *);
_CRTIMP struct tm * __cdecl localtime(const time_t *);
_CRTIMP time_t __cdecl mktime(struct tm *);
_CRTIMP size_t __cdecl strftime(char *, size_t, const char *,
        const struct tm *);
_CRTIMP char * __cdecl _strdate(char *);
_CRTIMP char * __cdecl _strtime(char *);
_CRTIMP time_t __cdecl time(time_t *);

#ifdef  _POSIX_
_CRTIMP void __cdecl tzset(void);
#else
_CRTIMP void __cdecl _tzset(void);
#endif

/* --------- The following functions are OBSOLETE --------- */
/* The Win32 API GetLocalTime and SetLocalTime should be used instead. */
unsigned __cdecl _getsystime(struct tm *);
unsigned __cdecl _setsystime(struct tm *, unsigned);
/* --------- The preceding functions are OBSOLETE --------- */


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _MAC
#ifndef _WTIME_DEFINED

/* wide function prototypes, also declared in wchar.h */
 
_CRTIMP wchar_t * __cdecl _wasctime(const struct tm *);
_CRTIMP wchar_t * __cdecl _wctime(const time_t *);
_CRTIMP size_t __cdecl wcsftime(wchar_t *, size_t, const wchar_t *,
        const struct tm *);
_CRTIMP wchar_t * __cdecl _wstrdate(wchar_t *);
_CRTIMP wchar_t * __cdecl _wstrtime(wchar_t *);

#define _WTIME_DEFINED
#endif
#endif /* ndef _MAC */


#if     !__STDC__ || defined(_POSIX_)

/* Non-ANSI names for compatibility */

#define CLK_TCK  CLOCKS_PER_SEC

#ifdef  _NTSDK

/* Declarations and definitions compatible with the NT SDK */

#define daylight _daylight
/* timezone cannot be #defined because of <sys/timeb.h> */

#ifndef _POSIX_
#define tzname  _tzname
#define tzset   _tzset
#endif /* _POSIX_ */

#else   /* ndef _NTSDK */

#if     defined(_DLL) && defined(_M_IX86)

#define daylight   (*__p__daylight())
/* timezone cannot be #defined because of <sys/timeb.h>
   so CRT DLL for win32s will not have timezone */
_CRTIMP extern long timezone;
#define tzname     (__p__tzname())

#else   /* !(defined(_DLL) && defined(_M_IX86)) */

_CRTIMP extern int daylight;
_CRTIMP extern long timezone;
_CRTIMP extern char * tzname[2];

#endif  /* !(defined(_DLL) && defined(_M_IX86)) */

_CRTIMP void __cdecl tzset(void);

#endif  /* _NTSDK */

#endif  /* __STDC__ */


#ifdef __cplusplus
}
#endif


#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_TIME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*       Copyright (c) 1985-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the string
*       manipulation functions.
*       [ANSI/System V]
*
*       [Public]
*
****/

#ifndef _INC_STRING
#define _INC_STRING

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if     _MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if     _MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else   /* ndef _NTSDK */
/* current definition */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _NTSDK */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


#ifndef _MAC
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif
#endif /* ndef _MAC */

#ifndef _NLSCMP_DEFINED
#define _NLSCMPERROR    2147483647  /* currently == INT_MAX */
#define _NLSCMP_DEFINED
#endif

/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Function prototypes */

#ifdef _M_MRX000
_CRTIMP void *  __cdecl memcpy(void *, const void *, size_t);
_CRTIMP int     __cdecl memcmp(const void *, const void *, size_t);
_CRTIMP void *  __cdecl memset(void *, int, size_t);
_CRTIMP char *  __cdecl _strset(char *, int);
_CRTIMP char *  __cdecl strcpy(char *, const char *);
_CRTIMP char *  __cdecl strcat(char *, const char *);
_CRTIMP int     __cdecl strcmp(const char *, const char *);
_CRTIMP size_t  __cdecl strlen(const char *);
#else
        void *  __cdecl memcpy(void *, const void *, size_t);
        int     __cdecl memcmp(const void *, const void *, size_t);
        void *  __cdecl memset(void *, int, size_t);
        char *  __cdecl _strset(char *, int);
        char *  __cdecl strcpy(char *, const char *);
        char *  __cdecl strcat(char *, const char *);
        int     __cdecl strcmp(const char *, const char *);
        size_t  __cdecl strlen(const char *);
#endif
_CRTIMP void *  __cdecl _memccpy(void *, const void *, int, unsigned int);
_CRTIMP void *  __cdecl memchr(const void *, int, size_t);
_CRTIMP int     __cdecl _memicmp(const void *, const void *, unsigned int);

#ifdef  _M_ALPHA
        /* memmove is available as an intrinsic in the Alpha compiler */
        void *  __cdecl memmove(void *, const void *, size_t);
#else
_CRTIMP void *  __cdecl memmove(void *, const void *, size_t);
#endif


_CRTIMP char *  __cdecl strchr(const char *, int);
_CRTIMP int     __cdecl _strcmpi(const char *, const char *);
_CRTIMP int     __cdecl _stricmp(const char *, const char *);
_CRTIMP int     __cdecl strcoll(const char *, const char *);
_CRTIMP int     __cdecl _stricoll(const char *, const char *);
_CRTIMP int     __cdecl _strncoll(const char *, const char *, size_t);
_CRTIMP int     __cdecl _strnicoll(const char *, const char *, size_t);
_CRTIMP size_t  __cdecl strcspn(const char *, const char *);
_CRTIMP char *  __cdecl _strdup(const char *);
_CRTIMP char *  __cdecl _strerror(const char *);
_CRTIMP char *  __cdecl strerror(int);
_CRTIMP char *  __cdecl _strlwr(char *);
_CRTIMP char *  __cdecl strncat(char *, const char *, size_t);
_CRTIMP int     __cdecl strncmp(const char *, const char *, size_t);
_CRTIMP int     __cdecl _strnicmp(const char *, const char *, size_t);
_CRTIMP char *  __cdecl strncpy(char *, const char *, size_t);
_CRTIMP char *  __cdecl _strnset(char *, int, size_t);
_CRTIMP char *  __cdecl strpbrk(const char *, const char *);
_CRTIMP char *  __cdecl strrchr(const char *, int);
_CRTIMP char *  __cdecl _strrev(char *);
_CRTIMP size_t  __cdecl strspn(const char *, const char *);
_CRTIMP char *  __cdecl strstr(const char *, const char *);
_CRTIMP char *  __cdecl strtok(char *, const char *);
_CRTIMP char *  __cdecl _strupr(char *);
_CRTIMP size_t  __cdecl strxfrm (char *, const char *, size_t);

#if defined(_M_MPPC) || defined(_M_M68K)
unsigned char * __cdecl _c2pstr(char *);
char * __cdecl _p2cstr(unsigned char *);

#if     !__STDC__
__inline unsigned char * __cdecl c2pstr(char *sz) { return _c2pstr(sz);};
__inline char * __cdecl p2cstr(unsigned char *sz) { return _p2cstr(sz);};
#endif
#endif

#if     !__STDC__

#ifdef  _NTSDK

/* Non-ANSI names for compatibility */
#define memccpy  _memccpy
#define memicmp  _memicmp
#define strcmpi  _strcmpi
#define stricmp  _stricmp
#define strdup   _strdup
#define strlwr   _strlwr
#define strnicmp _strnicmp
#define strnset  _strnset
#define strrev   _strrev
#define strset   _strset
#define strupr   _strupr
#define stricoll _stricoll
#else   /* ndef _NTSDK */

/* prototypes for oldnames.lib functions */
_CRTIMP void * __cdecl memccpy(void *, const void *, int, unsigned int);
_CRTIMP int __cdecl memicmp(const void *, const void *, unsigned int);
_CRTIMP int __cdecl strcmpi(const char *, const char *);
_CRTIMP int __cdecl stricmp(const char *, const char *);
_CRTIMP char * __cdecl strdup(const char *);
_CRTIMP char * __cdecl strlwr(char *);
_CRTIMP int __cdecl strnicmp(const char *, const char *, size_t);
_CRTIMP char * __cdecl strnset(char *, int, size_t);
_CRTIMP char * __cdecl strrev(char *);
        char * __cdecl strset(char *, int);
_CRTIMP char * __cdecl strupr(char *);

#endif  /* ndef _NTSDK */

#endif  /* !__STDC__ */


#ifndef _MAC
#ifndef _WSTRING_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl wcscat(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcschr(const wchar_t *, wchar_t);
_CRTIMP int __cdecl wcscmp(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcscpy(wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcscspn(const wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcslen(const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsncat(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcsncmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsncpy(wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcspbrk(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsrchr(const wchar_t *, wchar_t);
_CRTIMP size_t __cdecl wcsspn(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsstr(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcstok(wchar_t *, const wchar_t *);

_CRTIMP wchar_t * __cdecl _wcsdup(const wchar_t *);
_CRTIMP int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl _wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl _wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsset(wchar_t *, wchar_t);

_CRTIMP wchar_t * __cdecl _wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsupr(wchar_t *);
_CRTIMP size_t __cdecl wcsxfrm(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcscoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsicoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsncoll(const wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl _wcsnicoll(const wchar_t *, const wchar_t *, size_t);

#if     !__STDC__

/* old names */
#define wcswcs wcsstr

#ifdef  _NTSDK

/* Non-ANSI names for compatibility */
#define wcsdup  _wcsdup
#define wcsicmp _wcsicmp
#define wcsnicmp _wcsnicmp
#define wcsnset _wcsnset
#define wcsrev  _wcsrev
#define wcsset  _wcsset
#define wcslwr  _wcslwr
#define wcsupr  _wcsupr
#define wcsicoll _wcsicoll

#else   /* ndef _NTSDK */

/* prototypes for oldnames.lib functions */
_CRTIMP wchar_t * __cdecl wcsdup(const wchar_t *);
_CRTIMP int __cdecl wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsset(wchar_t *, wchar_t);
_CRTIMP wchar_t * __cdecl wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsupr(wchar_t *);
_CRTIMP int __cdecl wcsicoll(const wchar_t *, const wchar_t *);

#endif  /* ndef _NTSDK */

#endif  /* !__STDC__ */

#define _WSTRING_DEFINED
#endif

#endif /* ndef _MAC */

#ifdef __cplusplus
}
#endif

#endif  /* _INC_STRING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\tchar.h ===
/***
*tchar.h - definitions for generic international text functions
*
*       Copyright (c) 1991-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Definitions for generic international functions, mostly defines
*       which map string/formatted-io/ctype functions to char, wchar_t, or
*       MBCS versions.  To be used for compatibility between single-byte,
*       multi-byte and Unicode text models.
*
*       [Public]
*
****/

#ifndef _INC_TCHAR
#define _INC_TCHAR

#ifdef  _MSC_VER
#pragma warning(disable:4514)       /* disable unwanted C++ /W4 warning */
/* #pragma warning(default:4514) */ /* use this to reenable, if necessary */
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else   /* ndef _NTSDK */
/* current definition */
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _NTSDK */
#endif  /* _CRTIMP */


#define __far

#define _ftcscat    _tcscat
#define _ftcschr    _tcschr
#define _ftcscpy    _tcscpy
#define _ftcscspn   _tcscspn
#define _ftcslen    _tcslen
#define _ftcsncat   _tcsncat
#define _ftcsncpy   _tcsncpy
#define _ftcspbrk   _tcspbrk
#define _ftcsrchr   _tcsrchr
#define _ftcsspn    _tcsspn
#define _ftcsstr    _tcsstr
#define _ftcstok    _tcstok

#define _ftcsdup    _tcsdup
#define _ftcsnset   _tcsnset
#define _ftcsrev    _tcsrev
#define _ftcsset    _tcsset

#define _ftcscmp      _tcscmp
#define _ftcsicmp     _tcsicmp
#define _ftcsnccmp    _tcsnccmp
#define _ftcsncmp     _tcsncmp
#define _ftcsncicmp   _tcsncicmp
#define _ftcsnicmp    _tcsnicmp

#define _ftcscoll     _tcscoll
#define _ftcsicoll    _tcsicoll
#define _ftcsnccoll   _tcsnccoll
#define _ftcsncoll    _tcsncoll
#define _ftcsncicoll  _tcsncicoll
#define _ftcsnicoll   _tcsnicoll

/* Redundant "logical-character" mappings */

#define _ftcsclen   _tcsclen
#define _ftcsnccat  _tcsnccat
#define _ftcsnccpy  _tcsnccpy
#define _ftcsncset  _tcsncset

#define _ftcsdec    _tcsdec
#define _ftcsinc    _tcsinc
#define _ftcsnbcnt  _tcsnbcnt
#define _ftcsnccnt  _tcsnccnt
#define _ftcsnextc  _tcsnextc
#define _ftcsninc   _tcsninc
#define _ftcsspnp   _tcsspnp

#define _ftcslwr    _tcslwr
#define _ftcsupr    _tcsupr

#define _ftclen     _tclen
#define _ftccpy     _tccpy
#define _ftccmp     _tccmp


#ifdef  _UNICODE

/* ++++++++++++++++++++ UNICODE ++++++++++++++++++++ */

#include <wchar.h>


#ifndef _WCTYPE_T_DEFINED
typedef wchar_t wint_t;
typedef wchar_t wctype_t;
#define _WCTYPE_T_DEFINED
#endif

#ifndef __TCHAR_DEFINED
typedef wchar_t     _TCHAR;
typedef wchar_t     _TSCHAR;
typedef wchar_t     _TUCHAR;
typedef wchar_t     _TXCHAR;
typedef wint_t      _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if     !__STDC__
typedef wchar_t     TCHAR;
#endif
#define _TCHAR_DEFINED
#endif

#define _TEOF       WEOF

#define __T(x)      L ## x


/* Program */

#define _tmain      wmain
#define _tWinMain   wWinMain
#define _tenviron   _wenviron
#define __targv     __wargv

/* Formatted i/o */

#define _tprintf    wprintf
#define _ftprintf   fwprintf
#define _stprintf   swprintf
#define _sntprintf  _snwprintf
#define _vtprintf   vwprintf
#define _vftprintf  vfwprintf
#define _vstprintf  vswprintf
#define _vsntprintf _vsnwprintf
#define _tscanf     wscanf
#define _ftscanf    fwscanf
#define _stscanf    swscanf


/* Unformatted i/o */

#define _fgettc     fgetwc
#define _fgettchar  _fgetwchar
#define _fgetts     fgetws
#define _fputtc     fputwc
#define _fputtchar  _fputwchar
#define _fputts     fputws
#define _gettc      getwc
#define _gettchar   getwchar
#define _getts      _getws
#define _puttc      putwc
#define _puttchar   putwchar
#define _putts      _putws
#define _ungettc    ungetwc


/* String conversion functions */

#define _tcstod     wcstod
#define _tcstol     wcstol
#define _tcstoul    wcstoul

#define _itot       _itow
#define _ltot       _ltow
#define _ultot      _ultow
#define _ttoi       _wtoi
#define _ttol       _wtol


/* String functions */

#define _tcscat     wcscat
#define _tcschr     wcschr
#define _tcscpy     wcscpy
#define _tcscspn    wcscspn
#define _tcslen     wcslen
#define _tcsncat    wcsncat
#define _tcsncpy    wcsncpy
#define _tcspbrk    wcspbrk
#define _tcsrchr    wcsrchr
#define _tcsspn     wcsspn
#define _tcsstr     wcsstr
#define _tcstok     wcstok

#define _tcsdup     _wcsdup
#define _tcsnset    _wcsnset
#define _tcsrev     _wcsrev
#define _tcsset     _wcsset

#define _tcscmp     wcscmp
#define _tcsicmp    _wcsicmp
#define _tcsnccmp   wcsncmp
#define _tcsncmp    wcsncmp
#define _tcsncicmp  _wcsnicmp
#define _tcsnicmp   _wcsnicmp

#define _tcscoll    wcscoll
#define _tcsicoll   _wcsicoll
#define _tcsnccoll  _wcsncoll
#define _tcsncoll   _wcsncoll
#define _tcsncicoll _wcsnicoll
#define _tcsnicoll  _wcsnicoll


/* Execute functions */

#define _texecl     _wexecl
#define _texecle    _wexecle
#define _texeclp    _wexeclp
#define _texeclpe   _wexeclpe
#define _texecv     _wexecv
#define _texecve    _wexecve
#define _texecvp    _wexecvp
#define _texecvpe   _wexecvpe

#define _tspawnl    _wspawnl
#define _tspawnle   _wspawnle
#define _tspawnlp   _wspawnlp
#define _tspawnlpe  _wspawnlpe
#define _tspawnv    _wspawnv
#define _tspawnve   _wspawnve
#define _tspawnvp   _wspawnvp
#define _tspawnvp   _wspawnvp
#define _tspawnvpe  _wspawnvpe

#define _tsystem    _wsystem


/* Time functions */

#define _tasctime   _wasctime
#define _tctime     _wctime
#define _tstrdate   _wstrdate
#define _tstrtime   _wstrtime
#define _tutime     _wutime
#define _tcsftime   wcsftime


/* Directory functions */

#define _tchdir     _wchdir
#define _tgetcwd    _wgetcwd
#define _tgetdcwd   _wgetdcwd
#define _tmkdir     _wmkdir
#define _trmdir     _wrmdir


/* Environment/Path functions */

#define _tfullpath  _wfullpath
#define _tgetenv    _wgetenv
#define _tmakepath  _wmakepath
#define _tputenv    _wputenv
#define _tsearchenv _wsearchenv
#define _tsplitpath _wsplitpath


/* Stdio functions */

#define _tfdopen    _wfdopen
#define _tfsopen    _wfsopen
#define _tfopen     _wfopen
#define _tfreopen   _wfreopen
#define _tperror    _wperror
#define _tpopen     _wpopen
#define _ttempnam   _wtempnam
#define _ttmpnam    _wtmpnam


/* Io functions */

#define _taccess    _waccess
#define _tchmod     _wchmod
#define _tcreat     _wcreat
#define _tfindfirst _wfindfirst
#define _tfindfirsti64  _wfindfirsti64
#define _tfindnext  _wfindnext
#define _tfindnexti64   _wfindnexti64
#define _tmktemp    _wmktemp
#define _topen      _wopen
#define _tremove    _wremove
#define _trename    _wrename
#define _tsopen     _wsopen
#define _tunlink    _wunlink

#define _tfinddata_t    _wfinddata_t
#define _tfinddatai64_t _wfinddatai64_t


/* Stat functions */

#define _tstat      _wstat
#define _tstati64   _wstati64


/* Setlocale functions */

#define _tsetlocale _wsetlocale


/* Redundant "logical-character" mappings */

#define _tcsclen    wcslen
#define _tcsnccat   wcsncat
#define _tcsnccpy   wcsncpy
#define _tcsncset   _wcsnset

#define _tcsdec     _wcsdec
#define _tcsinc     _wcsinc
#define _tcsnbcnt   _wcsncnt
#define _tcsnccnt   _wcsncnt
#define _tcsnextc   _wcsnextc
#define _tcsninc    _wcsninc
#define _tcsspnp    _wcsspnp

#define _tcslwr     _wcslwr
#define _tcsupr     _wcsupr
#define _tcsxfrm    wcsxfrm


#if     (__STDC__ || defined(_NO_INLINING)) && !defined(_M_M68K)
#define _tclen(_pc) (1)
#define _tccpy(_pc1,_cpc2) ((*(_pc1) = *(_cpc2)))
#define _tccmp(_cpc1,_cpc2) ((*(_cpc1))-(*(_cpc2)))
#else   /* __STDC__ */
__inline size_t __cdecl _tclen(const wchar_t *_cpc) { return (_cpc,1); }
__inline void __cdecl _tccpy(wchar_t *_pc1, const wchar_t *_cpc2) { *_pc1 = (wchar_t)*_cpc2; }
__inline int __cdecl _tccmp(const wchar_t *_cpc1, const wchar_t *_cpc2) { return (int) ((*_cpc1)-(*_cpc2)); }
#endif  /* __STDC__ */


/* ctype functions */

#define _istalnum   iswalnum
#define _istalpha   iswalpha
#define _istascii   iswascii
#define _istcntrl   iswcntrl
#define _istdigit   iswdigit
#define _istgraph   iswgraph
#define _istlower   iswlower
#define _istprint   iswprint
#define _istpunct   iswpunct
#define _istspace   iswspace
#define _istupper   iswupper
#define _istxdigit  iswxdigit

#define _totupper   towupper
#define _totlower   towlower

#define _istlegal(_c)   (1)
#define _istlead(_c)    (0)
#define _istleadbyte(_c)    (0)


#if     (__STDC__ || defined(_NO_INLINING)) && !defined(_M_M68K)
#define _wcsdec(_cpc1, _cpc2) ((_cpc2)-1)
#define _wcsinc(_pc)    ((_pc)+1)
#define _wcsnextc(_cpc) ((unsigned int) *(_cpc))
#define _wcsninc(_pc, _sz) (((_pc)+(_sz)))
#define _wcsncnt(_cpc, _sz) ((wcslen(_cpc)>_sz) ? _sz : wcslen(_cpc))
#define _wcsspnp(_cpc1, _cpc2) ((*((_cpc1)+wcsspn(_cpc1,_cpc2))) ? ((_cpc1)+wcsspn(_cpc1,_cpc2)) : NULL)
#else   /* __STDC__ */
__inline wchar_t * __cdecl _wcsdec(const wchar_t * _cpc1, const wchar_t * _cpc2) { return (wchar_t *)(_cpc1,(_cpc2-1)); }
__inline wchar_t * __cdecl _wcsinc(const wchar_t * _pc) { return (wchar_t *)(_pc+1); }
__inline unsigned int __cdecl _wcsnextc(const wchar_t * _cpc) { return (unsigned int)*_cpc; }
__inline wchar_t * __cdecl _wcsninc(const wchar_t * _pc, size_t _sz) { return (wchar_t *)(_pc+_sz); }
__inline size_t __cdecl _wcsncnt( const wchar_t * _cpc, size_t _sz) { size_t len; len = wcslen(_cpc); return (len>_sz) ? _sz : len; }
__inline wchar_t * __cdecl _wcsspnp( const wchar_t * _cpc1, const wchar_t * _cpc2) { return (*(_cpc1 += wcsspn(_cpc1,_cpc2))!='\0') ? (wchar_t*)_cpc1 : NULL; }
#endif  /* __STDC__ */


#else   /* ndef _UNICODE */

/* ++++++++++++++++++++ SBCS and MBCS ++++++++++++++++++++ */

#include <string.h>


#define _TEOF       EOF

#define __T(x)      x


/* Program */

#define _tmain      main
#define _tWinMain   WinMain
#ifdef  _POSIX_
#define _tenviron   environ
#else
#define _tenviron  _environ
#endif
#define __targv     __argv


/* Formatted i/o */

#define _tprintf    printf
#define _ftprintf   fprintf
#define _stprintf   sprintf
#define _sntprintf  _snprintf
#define _vtprintf   vprintf
#define _vftprintf  vfprintf
#define _vstprintf  vsprintf
#define _vsntprintf _vsnprintf
#define _tscanf     scanf
#define _ftscanf    fscanf
#define _stscanf    sscanf


/* Unformatted i/o */

#define _fgettc     fgetc
#define _fgettchar  _fgetchar
#define _fgetts     fgets
#define _fputtc     fputc
#define _fputtchar  _fputchar
#define _fputts     fputs
#define _gettc      getc
#define _gettchar   getchar
#define _getts      gets
#define _puttc      putc
#define _puttchar   putchar
#define _putts      puts
#define _ungettc    ungetc


/* String conversion functions */

#define _tcstod     strtod
#define _tcstol     strtol
#define _tcstoul    strtoul

#define _itot       _itoa
#define _ltot       _ltoa
#define _ultot      _ultoa
#define _ttoi       atoi
#define _ttol       atol


/* String functions */

#define _tcscat     strcat
#define _tcscpy     strcpy
#define _tcslen     strlen
#define _tcsxfrm    strxfrm
#define _tcsdup     _strdup


/* Execute functions */

#define _texecl     _execl
#define _texecle    _execle
#define _texeclp    _execlp
#define _texeclpe   _execlpe
#define _texecv     _execv
#define _texecve    _execve
#define _texecvp    _execvp
#define _texecvpe   _execvpe

#define _tspawnl    _spawnl
#define _tspawnle   _spawnle
#define _tspawnlp   _spawnlp
#define _tspawnlpe  _spawnlpe
#define _tspawnv    _spawnv
#define _tspawnve   _spawnve
#define _tspawnvp   _spawnvp
#define _tspawnvpe  _spawnvpe

#define _tsystem    system


/* Time functions */

#define _tasctime   asctime
#define _tctime     ctime
#define _tstrdate   _strdate
#define _tstrtime   _strtime
#define _tutime     _utime
#define _tcsftime   strftime


/* Directory functions */

#define _tchdir     _chdir
#define _tgetcwd    _getcwd
#define _tgetdcwd   _getdcwd
#define _tmkdir     _mkdir
#define _trmdir     _rmdir


/* Environment/Path functions */

#define _tfullpath  _fullpath
#define _tgetenv    getenv
#define _tmakepath  _makepath
#define _tputenv    _putenv
#define _tsearchenv _searchenv
#define _tsplitpath _splitpath


/* Stdio functions */

#ifdef  _POSIX_
#define _tfdopen    fdopen
#else
#define _tfdopen    _fdopen
#endif
#define _tfsopen    _fsopen
#define _tfopen     fopen
#define _tfreopen   freopen
#define _tperror    perror
#define _tpopen     _popen
#define _ttempnam   _tempnam
#define _ttmpnam    tmpnam


/* Io functions */

#define _tchmod     _chmod
#define _tcreat     _creat
#define _tfindfirst _findfirst
#define _tfindfirsti64  _findfirsti64
#define _tfindnext  _findnext
#define _tfindnexti64   _findnexti64
#define _tmktemp    _mktemp

#ifdef _POSIX_
#define _topen      open
#define _taccess    access
#else
#define _topen      _open
#define _taccess    _access
#endif

#define _tremove    remove
#define _trename    rename
#define _tsopen     _sopen
#define _tunlink    _unlink

#define _tfinddata_t    _finddata_t
#define _tfinddatai64_t _finddatai64_t


/* ctype functions */

#define _istascii   isascii
#define _istcntrl   iscntrl
#define _istxdigit  isxdigit


/* Stat functions */

#define _tstat      _stat
#define _tstati64   _stati64


/* Setlocale functions */

#define _tsetlocale setlocale


#ifdef _MBCS

/* ++++++++++++++++++++ MBCS ++++++++++++++++++++ */


#include <mbstring.h>


#ifndef __TCHAR_DEFINED
typedef char            _TCHAR;
typedef signed char     _TSCHAR;
typedef unsigned char   _TUCHAR;
typedef unsigned char   _TXCHAR;
typedef unsigned int    _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if     !__STDC__
typedef char            TCHAR;
#endif
#define _TCHAR_DEFINED
#endif


#ifdef _MB_MAP_DIRECT

/* use mb functions directly - types must match */

/* String functions */

#define _tcschr     _mbschr
#define _tcscspn    _mbscspn
#define _tcsncat    _mbsnbcat
#define _tcsncpy    _mbsnbcpy
#define _tcspbrk    _mbspbrk
#define _tcsrchr    _mbsrchr
#define _tcsspn     _mbsspn
#define _tcsstr     _mbsstr
#define _tcstok     _mbstok

#define _tcsnset    _mbsnbset
#define _tcsrev     _mbsrev
#define _tcsset     _mbsset

#define _tcscmp     _mbscmp
#define _tcsicmp    _mbsicmp
#define _tcsnccmp   _mbsncmp
#define _tcsncmp    _mbsnbcmp
#define _tcsncicmp  _mbsnicmp
#define _tcsnicmp   _mbsnbicmp

#define _tcscoll    _mbscoll
#define _tcsicoll   _mbsicoll
#define _tcsnccoll  _mbsncoll
#define _tcsncoll   _mbsnbcoll
#define _tcsncicoll _mbsnicoll
#define _tcsnicoll  _mbsnbicoll


/* "logical-character" mappings */

#define _tcsclen    _mbslen
#define _tcsnccat   _mbsncat
#define _tcsnccpy   _mbsncpy
#define _tcsncset   _mbsnset


/* MBCS-specific mappings */

#define _tcsdec     _mbsdec
#define _tcsinc     _mbsinc
#define _tcsnbcnt   _mbsnbcnt
#define _tcsnccnt   _mbsnccnt
#define _tcsnextc   _mbsnextc
#define _tcsninc    _mbsninc
#define _tcsspnp    _mbsspnp

#define _tcslwr     _mbslwr
#define _tcsupr     _mbsupr

#define _tclen      _mbclen
#define _tccpy      _mbccpy

#define _tccmp(_cpuc1,_cpuc2)   _tcsnccmp(_cpuc1,_cpuc2,1)


#else /* _MB_MAP_DIRECT */

#if     (__STDC__ || defined(_NO_INLINING)) && !defined(_M_M68K)

/* use type-safe linked-in function thunks */

/* String functions */

_CRTIMP char * __cdecl _tcschr(const char *, unsigned int);
_CRTIMP size_t __cdecl _tcscspn(const char *, const char *);
_CRTIMP char * __cdecl _tcsncat(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcsncpy(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcspbrk(const char *, const char *);
_CRTIMP char * __cdecl _tcsrchr(const char *, int);
_CRTIMP size_t __cdecl _tcsspn(const char *, const char *);
_CRTIMP char * __cdecl _tcsstr(const char *, const char *);
_CRTIMP char * __cdecl _tcstok(char *, const char *);

_CRTIMP char * __cdecl _tcsnset(char *, unsigned int, size_t);
_CRTIMP char * __cdecl _tcsrev(char *);
_CRTIMP char * __cdecl _tcsset(char *, unsigned int);

_CRTIMP int __cdecl _tcscmp(const char *, const char *);
_CRTIMP int __cdecl _tcsicmp(const char *, const char *);
_CRTIMP int __cdecl _tcsnccmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncicmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsnicmp(const char *, const char *, size_t);

_CRTIMP int __cdecl _tcscoll(const char *, const char *);
_CRTIMP int __cdecl _tcsicoll(const char *, const char *);
_CRTIMP int __cdecl _tcsnccoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncicoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsnicoll(const char *, const char *, size_t);


/* "logical-character" mappings */

_CRTIMP size_t __cdecl _tcsclen(const char *);
_CRTIMP char * __cdecl _tcsnccat(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcsnccpy(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcsncset(char *, unsigned int, size_t);


/* MBCS-specific mappings */

_CRTIMP char * __cdecl _tcsdec(const char *, const char *);
_CRTIMP char * __cdecl _tcsinc(const char *);
_CRTIMP size_t __cdecl _tcsnbcnt(const char *, size_t);
_CRTIMP size_t __cdecl _tcsnccnt(const char *, size_t);
_CRTIMP unsigned int __cdecl _tcsnextc (const char *);
_CRTIMP char * __cdecl _tcsninc(const char *, size_t);
_CRTIMP char * __cdecl _tcsspnp(const char *, const char *);

_CRTIMP char * __cdecl _tcslwr(char *);
_CRTIMP char * __cdecl _tcsupr(char *);

_CRTIMP size_t __cdecl _tclen(const char *);
_CRTIMP void __cdecl _tccpy(char *, const char *);


#else   /* __STDC__ */

/* the default: use type-safe inline function thunks */

#define _PUC    unsigned char *
#define _CPUC   const unsigned char *
#define _PC     char *
#define _CPC    const char *
#define _UI     unsigned int


/* String functions */

__inline _PC _tcschr(_CPC _s1,_UI _c) {return (_PC)_mbschr((_CPUC)_s1,_c);}
__inline size_t _tcscspn(_CPC _s1,_CPC _s2) {return _mbscspn((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsncat(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsnbcat((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcsncpy(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsnbcpy((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcspbrk(_CPC _s1,_CPC _s2) {return (_PC)_mbspbrk((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsrchr(_CPC _s1,_UI _c) {return (_PC)_mbsrchr((_CPUC)_s1,_c);}
__inline size_t _tcsspn(_CPC _s1,_CPC _s2) {return _mbsspn((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsstr(_CPC _s1,_CPC _s2) {return (_PC)_mbsstr((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcstok(_PC _s1,_CPC _s2) {return (_PC)_mbstok((_PUC)_s1,(_CPUC)_s2);}

__inline _PC _tcsnset(_PC _s1,_UI _c,size_t _n) {return (_PC)_mbsnbset((_PUC)_s1,_c,_n);}
__inline _PC _tcsrev(_PC _s1) {return (_PC)_mbsrev((_PUC)_s1);}
__inline _PC _tcsset(_PC _s1,_UI _c) {return (_PC)_mbsset((_PUC)_s1,_c);}

__inline int _tcscmp(_CPC _s1,_CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsicmp(_CPC _s1,_CPC _s2) {return _mbsicmp((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsnccmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsncmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbcmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncicmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnicmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsnicmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbicmp((_CPUC)_s1,(_CPUC)_s2,_n);}

__inline int _tcscoll(_CPC _s1,_CPC _s2) {return _mbscoll((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsicoll(_CPC _s1,_CPC _s2) {return _mbsicoll((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsnccoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsncoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbcoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncicoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnicoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsnicoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbicoll((_CPUC)_s1,(_CPUC)_s2,_n);}


/* "logical-character" mappings */

__inline size_t _tcsclen(_CPC _s1) {return _mbslen((_CPUC)_s1);}
__inline _PC _tcsnccat(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsncat((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcsnccpy(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsncpy((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcsncset(_PC _s1,_UI _c,size_t _n) {return (_PC)_mbsnset((_PUC)_s1,_c,_n);}


/* MBCS-specific mappings */

__inline _PC _tcsdec(_CPC _s1,_CPC _s2) {return (_PC)_mbsdec((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsinc(_CPC _s1) {return (_PC)_mbsinc((_CPUC)_s1);}
__inline size_t _tcsnbcnt(_CPC _s1,size_t _n) {return _mbsnbcnt((_CPUC)_s1,_n);}
__inline size_t _tcsnccnt(_CPC _s1,size_t _n) {return _mbsnccnt((_CPUC)_s1,_n);}
__inline _PC _tcsninc(_CPC _s1,size_t _n) {return (_PC)_mbsninc((_CPUC)_s1,_n);}
__inline _PC _tcsspnp(_CPC _s1,_CPC _s2) {return (_PC)_mbsspnp((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcslwr(_PC _s1) {return (_PC)_mbslwr((_PUC)_s1);}
__inline _PC _tcsupr(_PC _s1) {return (_PC)_mbsupr((_PUC)_s1);}

__inline size_t _tclen(_CPC _s1) {return _mbclen((_CPUC)_s1);}
__inline void _tccpy(_PC _s1,_CPC _s2) {_mbccpy((_PUC)_s1,(_CPUC)_s2); return;}


/* inline helper */
__inline _UI _tcsnextc(_CPC _s1) {_UI _n=0; if (_ismbblead((_UI)*(_PUC)_s1)) _n=((_UI)*_s1++)<<8; _n+=(_UI)*_s1; return(_n);}


#endif /* __STDC__ */

#endif /* _MB_MAP_DIRECT */


/* MBCS-specific mappings */

#define _tccmp(_cp1,_cp2)   _tcsnccmp(_cp1,_cp2,1)


/* ctype functions */

#define _istalnum   _ismbcalnum
#define _istalpha   _ismbcalpha
#define _istdigit   _ismbcdigit
#define _istgraph   _ismbcgraph
#define _istlegal   _ismbclegal
#define _istlower   _ismbclower
#define _istprint   _ismbcprint
#define _istpunct   _ismbcpunct
#define _istspace   _ismbcspace
#define _istupper   _ismbcupper

#define _totupper   _mbctoupper
#define _totlower   _mbctolower

#define _istlead    _ismbblead
#define _istleadbyte    isleadbyte

#else   /* !_MBCS */

/* ++++++++++++++++++++ SBCS ++++++++++++++++++++ */


#ifndef __TCHAR_DEFINED
typedef char            _TCHAR;
typedef signed char     _TSCHAR;
typedef unsigned char   _TUCHAR;
typedef char            _TXCHAR;
typedef int             _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if     !__STDC__
typedef char            TCHAR;
#endif
#define _TCHAR_DEFINED
#endif


/* String functions */

#define _tcschr     strchr
#define _tcscspn    strcspn
#define _tcsncat    strncat
#define _tcsncpy    strncpy
#define _tcspbrk    strpbrk
#define _tcsrchr    strrchr
#define _tcsspn     strspn
#define _tcsstr     strstr
#define _tcstok     strtok

#define _tcsnset    _strnset
#define _tcsrev     _strrev
#define _tcsset     _strset

#define _tcscmp     strcmp
#define _tcsicmp    _stricmp
#define _tcsnccmp   strncmp
#define _tcsncmp    strncmp
#define _tcsncicmp  _strnicmp
#define _tcsnicmp   _strnicmp

#define _tcscoll    strcoll
#define _tcsicoll   _stricoll
#define _tcsnccoll  _strncoll
#define _tcsncoll   _strncoll
#define _tcsncicoll _strnicoll
#define _tcsnicoll  _strnicoll


/* "logical-character" mappings */

#define _tcsclen    strlen
#define _tcsnccat   strncat
#define _tcsnccpy   strncpy
#define _tcsncset   _strnset


/* MBCS-specific functions */

#define _tcsdec     _strdec
#define _tcsinc     _strinc
#define _tcsnbcnt   _strncnt
#define _tcsnccnt   _strncnt
#define _tcsnextc   _strnextc
#define _tcsninc    _strninc
#define _tcsspnp    _strspnp

#define _tcslwr     _strlwr
#define _tcsupr     _strupr
#define _tcsxfrm    strxfrm

#define _istlead(_c)    (0)
#define _istleadbyte(_c)    (0)

#if     (__STDC__ || defined(_NO_INLINING)) && !defined(_M_M68K)
#define _tclen(_pc) (1)
#define _tccpy(_pc1,_cpc2) (*(_pc1) = *(_cpc2))
#define _tccmp(_cpc1,_cpc2) (((unsigned char)*(_cpc1))-((unsigned char)*(_cpc2)))
#else   /* __STDC__ */
__inline size_t __cdecl _tclen(const char *_cpc) { return (_cpc,1); }
__inline void __cdecl _tccpy(char *_pc1, const char *_cpc2) { *_pc1 = *_cpc2; }
__inline int __cdecl _tccmp(const char *_cpc1, const char *_cpc2) { return (int) (((unsigned char)*_cpc1)-((unsigned char)*_cpc2)); }
#endif  /* __STDC__ */


/* ctype-functions */

#define _istalnum   isalnum
#define _istalpha   isalpha
#define _istdigit   isdigit
#define _istgraph   isgraph
#define _istlower   islower
#define _istprint   isprint
#define _istpunct   ispunct
#define _istspace   isspace
#define _istupper   isupper

#define _totupper   toupper
#define _totlower   tolower

#define _istlegal(_c)   (1)


/* the following is optional if functional versions are available */

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


#if     (__STDC__ || defined(_NO_INLINING)) && !defined(_M_M68K)
#define _strdec(_cpc1, _cpc2) ((_cpc2)-1)
#define _strinc(_pc)    ((_pc)+1)
#define _strnextc(_cpc) ((unsigned int) *(_cpc))
#define _strninc(_pc, _sz) (((_pc)+(_sz)))
#define _strncnt(_cpc, _sz) ((strlen(_cpc)>_sz) ? _sz : strlen(_cpc))
#define _strspnp(_cpc1, _cpc2) ((*((_cpc1)+strspn(_cpc1,_cpc2))) ? ((_cpc1)+strspn(_cpc1,_cpc2)) : NULL)
#else   /* __STDC__ */
__inline char * __cdecl _strdec(const char * _cpc1, const char * _cpc2) { return (char *)(_cpc1,(_cpc2-1)); }
__inline char * __cdecl _strinc(const char * _pc) { return (char *)(_pc+1); }
__inline unsigned int __cdecl _strnextc(const char * _cpc) { return (unsigned int)*_cpc; }
__inline char * __cdecl _strninc(const char * _pc, size_t _sz) { return (char *)(_pc+_sz); }
__inline size_t __cdecl _strncnt( const char * _cpc, size_t _sz) { size_t len; len = strlen(_cpc); return (len>_sz) ? _sz : len; }
__inline char * __cdecl _strspnp( const char * _cpc1, const char * _cpc2) { return (*(_cpc1 += strspn(_cpc1,_cpc2))!='\0') ? (char*)_cpc1 : NULL; }
#endif  /* __STDC__ */


#endif  /* _MBCS */

#endif  /* _UNICODE */


/* Generic text macros to be used with string literals and character constants.
   Will also allow symbolic constants that resolve to same. */

#define _T(x)       __T(x)
#define _TEXT(x)    __T(x)


#ifdef __cplusplus
}
#endif

#endif  /* _INC_TCHAR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\streamb.h ===
/***
*streamb.h - definitions/declarations for the streambuf class
*
*	Copyright (c) 1990-1995, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the classes, values, macros, and functions
*	used by the streambuf class.
*	[AT&T C++]
*
*       [Public]
*
****/

#ifdef __cplusplus

#ifndef _INC_STREAMB
#define _INC_STREAMB

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef	_MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)
#endif	// _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


#include <ios.h>	// need ios::seek_dir definition

#ifndef NULL
#define NULL	0
#endif

#ifndef EOF
#define EOF	(-1)
#endif

#ifdef	_MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)	// use this to reenable, if desired
#endif	// _MSC_VER

typedef long streampos, streamoff;

class _CRTIMP ios;

class _CRTIMP streambuf {
public:

    virtual ~streambuf();

    inline int in_avail() const;
    inline int out_waiting() const;
    int sgetc();
    int snextc();
    int sbumpc();
    void stossc();

    inline int sputbackc(char);

    inline int sputc(int);
    inline int sputn(const char *,int);
    inline int sgetn(char *,int);

    virtual int sync();

    virtual streambuf* setbuf(char *, int);
    virtual streampos seekoff(streamoff,ios::seek_dir,int =ios::in|ios::out);
    virtual streampos seekpos(streampos,int =ios::in|ios::out);

    virtual int xsputn(const char *,int);
    virtual int xsgetn(char *,int);

    virtual int overflow(int =EOF) = 0;	// pure virtual function
    virtual int underflow() = 0;	// pure virtual function

    virtual int pbackfail(int);

    void dbp();

#ifdef	_MT
    void setlock() { LockFlg--; }	// <0 indicates lock required;
    void clrlock() { if (LockFlg <= 0) LockFlg++; }
    void lock() { if (LockFlg<0) _mtlock(lockptr()); };
    void unlock() { if (LockFlg<0) _mtunlock(lockptr()); }
#else
    void lock() { }
    void unlock() { }
#endif

protected:
    streambuf();
    streambuf(char *,int);

    inline char * base() const;
    inline char * ebuf() const;
    inline char * pbase() const;
    inline char * pptr() const;
    inline char * epptr() const;
    inline char * eback() const;
    inline char * gptr() const;
    inline char * egptr() const;
    inline int blen() const;
    inline void setp(char *,char *);
    inline void setg(char *,char *,char *);
    inline void pbump(int);
    inline void gbump(int);

    void setb(char *,char *,int =0);
    inline int unbuffered() const;
    inline void unbuffered(int);
    int allocate();
    virtual int doallocate();
#ifdef	_MT
    _PCRT_CRITICAL_SECTION lockptr() { return & x_lock; }
#endif

private:
    int _fAlloc;
    int _fUnbuf;
    int x_lastc;
    char * _base;
    char * _ebuf;
    char * _pbase;
    char * _pptr;
    char * _epptr;
    char * _eback;
    char * _gptr;
    char * _egptr;
#ifdef	_MT
    int LockFlg;		// <0 indicates locking required
   _CRT_CRITICAL_SECTION x_lock;	// lock needed only for multi-thread operation
#endif
};

inline int streambuf::in_avail() const { return (gptr()<_egptr) ? (_egptr-gptr()) : 0; }
inline int streambuf::out_waiting() const { return (_pptr>=_pbase) ? (_pptr-_pbase) : 0; }

inline int streambuf::sputbackc(char _c){ return (_eback<gptr()) ? *(--_gptr)=_c : pbackfail(_c); }

inline int streambuf::sputc(int _i){ return (_pptr<_epptr) ? (unsigned char)(*(_pptr++)=(char)_i) : overflow(_i); }

inline int streambuf::sputn(const char * _str,int _n) { return xsputn(_str, _n); }
inline int streambuf::sgetn(char * _str,int _n) { return xsgetn(_str, _n); }

inline char * streambuf::base() const { return _base; }
inline char * streambuf::ebuf() const { return _ebuf; }
inline int streambuf::blen() const  {return ((_ebuf > _base) ? (_ebuf-_base) : 0); }
inline char * streambuf::pbase() const { return _pbase; }
inline char * streambuf::pptr() const { return _pptr; }
inline char * streambuf::epptr() const { return _epptr; }
inline char * streambuf::eback() const { return _eback; }
inline char * streambuf::gptr() const { return _gptr; }
inline char * streambuf::egptr() const { return _egptr; }
inline void streambuf::gbump(int _n) { if (_egptr) _gptr += _n; }
inline void streambuf::pbump(int _n) { if (_epptr) _pptr += _n; }
inline void streambuf::setg(char * _eb, char * _g, char * _eg) {_eback=_eb; _gptr=_g; _egptr=_eg; x_lastc=EOF; }
inline void streambuf::setp(char * _p, char * _ep) {_pptr=_pbase=_p; _epptr=_ep; }
inline int streambuf::unbuffered() const { return _fUnbuf; }
inline void streambuf::unbuffered(int _f) { _fUnbuf = _f; }

#ifdef	_MSC_VER
// Restore previous packing
#pragma pack(pop)
#endif	// _MSC_VER

#endif	// _INC_STREAMB

#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\wcstr.h ===
/***
* wcstr.h - declarations for wide character string manipulation functions
*
*       Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the string
*       manipulation functions.
*       [OBSOLETE][UNICODE/ISO]
*
*	WARNING: OBSOLETE FILE: use wchar.h/stdlib.h instead!!!
*	This file provided only for short-term compatibility.  It will
*	disappear in the near future after a brief transitional period.
*
****/

#ifndef _INC_WCSTR

#include <wchar.h>
#define wcswcs wcsstr

#define _wcscmpi _wcsicmp
#if !__STDC__
#define wcscmpi	_wcsicmp
#endif

/* from stdlib.h */
int    _CRTAPI1 wctomb(char *, wchar_t);
size_t _CRTAPI1 wcstombs(char*, const wchar_t *, size_t);

#define _INC_WCSTR
#endif  /* _INC_WCSTR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\vdmdbg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1985-1995, Microsoft Corporation

Module Name:

    vdmdbg.h

Abstract:

    Prodecure declarations, constant definitions, type definition and macros
    for the VDMDBG.DLL VDM Debugger interface.

--*/

#ifndef _VDMDBG_
#define _VDMDBG_

#ifdef __cplusplus
extern "C" {
#endif

#include <pshpack4.h>

#define STATUS_VDM_EVENT    STATUS_SEGMENT_NOTIFICATION

#ifndef DBG_SEGLOAD
#define DBG_SEGLOAD     0
#define DBG_SEGMOVE     1
#define DBG_SEGFREE     2
#define DBG_MODLOAD     3
#define DBG_MODFREE     4
#define DBG_SINGLESTEP  5
#define DBG_BREAK       6
#define DBG_GPFAULT     7
#define DBG_DIVOVERFLOW 8
#define DBG_INSTRFAULT  9
#define DBG_TASKSTART   10
#define DBG_TASKSTOP    11
#define DBG_DLLSTART    12
#define DBG_DLLSTOP     13
#define DBG_ATTACH      14
#endif

//
// The following flags control the contents of the CONTEXT structure.
//

#define VDMCONTEXT_i386    0x00010000    // this assumes that i386 and
#define VDMCONTEXT_i486    0x00010000    // i486 have identical context records

#define VDMCONTEXT_CONTROL         (VDMCONTEXT_i386 | 0x00000001L) // SS:SP, CS:IP, FLAGS, BP
#define VDMCONTEXT_INTEGER         (VDMCONTEXT_i386 | 0x00000002L) // AX, BX, CX, DX, SI, DI
#define VDMCONTEXT_SEGMENTS        (VDMCONTEXT_i386 | 0x00000004L) // DS, ES, FS, GS
#define VDMCONTEXT_FLOATING_POINT  (VDMCONTEXT_i386 | 0x00000008L) // 387 state
#define VDMCONTEXT_DEBUG_REGISTERS (VDMCONTEXT_i386 | 0x00000010L) // DB 0-3,6,7

#define VDMCONTEXT_FULL (VDMCONTEXT_CONTROL | VDMCONTEXT_INTEGER |\
                      VDMCONTEXT_SEGMENTS)


#ifdef _X86_

// On x86 machines, just copy the definition of the CONTEXT and LDT_ENTRY
// structures.
typedef struct _CONTEXT VDMCONTEXT;
typedef struct _LDT_ENTRY VDMLDT_ENTRY;

#else // _X86_

//
//  Define the size of the 80387 save area, which is in the context frame.
//

#define SIZE_OF_80387_REGISTERS      80

typedef struct _FLOATING_SAVE_AREA {
    ULONG   ControlWord;
    ULONG   StatusWord;
    ULONG   TagWord;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;
    ULONG   DataSelector;
    UCHAR   RegisterArea[SIZE_OF_80387_REGISTERS];
    ULONG   Cr0NpxState;
} FLOATING_SAVE_AREA;

//
// Simulated context structure for the 16-bit environment
//

typedef struct _VDMCONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //
    // CONTEXT_FULL on some systems (MIPS namely) does not contain the
    // CONTEXT_SEGMENTS definition.  VDMDBG assumes that CONTEXT_INTEGER also
    // includes CONTEXT_SEGMENTS to account for this.
    //

    ULONG ContextFlags;

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //

    ULONG   Dr0;
    ULONG   Dr1;
    ULONG   Dr2;
    ULONG   Dr3;
    ULONG   Dr6;
    ULONG   Dr7;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //

    FLOATING_SAVE_AREA FloatSave;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_SEGMENTS.
    //

    ULONG   SegGs;
    ULONG   SegFs;
    ULONG   SegEs;
    ULONG   SegDs;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //

    ULONG   Edi;
    ULONG   Esi;
    ULONG   Ebx;
    ULONG   Edx;
    ULONG   Ecx;
    ULONG   Eax;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //

    ULONG   Ebp;
    ULONG   Eip;
    ULONG   SegCs;              // MUST BE SANITIZED
    ULONG   EFlags;             // MUST BE SANITIZED
    ULONG   Esp;
    ULONG   SegSs;

} VDMCONTEXT;

//
//  LDT descriptor entry
//

typedef struct _VDMLDT_ENTRY {
    USHORT  LimitLow;
    USHORT  BaseLow;
    union {
        struct {
            UCHAR   BaseMid;
            UCHAR   Flags1;     // Declare as bytes to avoid alignment
            UCHAR   Flags2;     // Problems.
            UCHAR   BaseHi;
        } Bytes;
        struct {
            ULONG   BaseMid : 8;
            ULONG   Type : 5;
            ULONG   Dpl : 2;
            ULONG   Pres : 1;
            ULONG   LimitHi : 4;
            ULONG   Sys : 1;
            ULONG   Reserved_0 : 1;
            ULONG   Default_Big : 1;
            ULONG   Granularity : 1;
            ULONG   BaseHi : 8;
        } Bits;
    } HighWord;
} VDMLDT_ENTRY;


#endif // _X86_

typedef VDMCONTEXT *LPVDMCONTEXT;
typedef VDMLDT_ENTRY *LPVDMLDT_ENTRY;

#define VDMCONTEXT_TO_PROGRAM_COUNTER(Context) (PVOID)((Context)->Eip)

#define VDMCONTEXT_LENGTH  (sizeof(VDMCONTEXT))
#define VDMCONTEXT_ALIGN   (sizeof(ULONG))
#define VDMCONTEXT_ROUND   (VDMCONTEXT_ALIGN - 1)

#define V86FLAGS_CARRY      0x00001
#define V86FLAGS_PARITY     0x00004
#define V86FLAGS_AUXCARRY   0x00010
#define V86FLAGS_ZERO       0x00040
#define V86FLAGS_SIGN       0x00080
#define V86FLAGS_TRACE      0x00100
#define V86FLAGS_INTERRUPT  0x00200
#define V86FLAGS_DIRECTION  0x00400
#define V86FLAGS_OVERFLOW   0x00800
#define V86FLAGS_IOPL       0x03000
#define V86FLAGS_IOPL_BITS  0x12
#define V86FLAGS_RESUME     0x10000
#define V86FLAGS_V86        0x20000     // Used to detect RealMode v. ProtMode
#define V86FLAGS_ALIGNMENT  0x40000

#define MAX_MODULE_NAME  8 + 1
#define MAX_PATH16      255

typedef struct _SEGMENT_NOTE {
    WORD    Selector1;                      // Selector of operation
    WORD    Selector2;                      // Dest. Sel. for moving segments
    WORD    Segment;                        // Segment within Module
    CHAR    Module[MAX_MODULE_NAME+1];      // Module name
    CHAR    FileName[MAX_PATH16+1];         // PathName to executable image
    WORD    Type;                           // Code / Data, etc.
    DWORD   Length;                         // Length of image
} SEGMENT_NOTE;

typedef struct _IMAGE_NOTE {
    CHAR    Module[MAX_MODULE_NAME+1];      // Module
    CHAR    FileName[MAX_PATH16+1];         // Path to executable image
    WORD    hModule;                        // 16-bit hModule
    WORD    hTask;                          // 16-bit hTask
} IMAGE_NOTE;

typedef struct {
    DWORD   dwSize;
    char    szModule[MAX_MODULE_NAME+1];
    HANDLE  hModule;
    WORD    wcUsage;
    char    szExePath[MAX_PATH16+1];
    WORD    wNext;
} MODULEENTRY, *LPMODULEENTRY;

/* GlobalFirst()/GlobalNext() flags */
#define GLOBAL_ALL      0
#define GLOBAL_LRU      1
#define GLOBAL_FREE     2

/* GLOBALENTRY.wType entries */
#define GT_UNKNOWN      0
#define GT_DGROUP       1
#define GT_DATA         2
#define GT_CODE         3
#define GT_TASK         4
#define GT_RESOURCE     5
#define GT_MODULE       6
#define GT_FREE         7
#define GT_INTERNAL     8
#define GT_SENTINEL     9
#define GT_BURGERMASTER 10

/* If GLOBALENTRY.wType==GT_RESOURCE, the following is GLOBALENTRY.wData: */
#define GD_USERDEFINED      0
#define GD_CURSORCOMPONENT  1
#define GD_BITMAP           2
#define GD_ICONCOMPONENT    3
#define GD_MENU             4
#define GD_DIALOG           5
#define GD_STRING           6
#define GD_FONTDIR          7
#define GD_FONT             8
#define GD_ACCELERATORS     9
#define GD_RCDATA           10
#define GD_ERRTABLE         11
#define GD_CURSOR           12
#define GD_ICON             14
#define GD_NAMETABLE        15
#define GD_MAX_RESOURCE     15

typedef struct {
    DWORD   dwSize;
    DWORD   dwAddress;
    DWORD   dwBlockSize;
    HANDLE  hBlock;
    WORD    wcLock;
    WORD    wcPageLock;
    WORD    wFlags;
    BOOL    wHeapPresent;
    HANDLE  hOwner;
    WORD    wType;
    WORD    wData;
    DWORD   dwNext;
    DWORD   dwNextAlt;
} GLOBALENTRY, *LPGLOBALENTRY;

typedef DWORD (CALLBACK* DEBUGEVENTPROC)( LPDEBUG_EVENT, LPVOID );

// Macros to access VDM_EVENT parameters
#define W1(x) ((USHORT)(x.ExceptionInformation[0]))
#define W2(x) ((USHORT)(x.ExceptionInformation[0] >> 16))
#define W3(x) ((USHORT)(x.ExceptionInformation[1]))
#define W4(x) ((USHORT)(x.ExceptionInformation[1] >> 16))
#define DW3(x) (x.ExceptionInformation[2])
#define DW4(x) (x.ExceptionInformation[3])

#include <poppack.h>

BOOL
WINAPI
VDMProcessException(
    LPDEBUG_EVENT   lpDebugEvent
    );

BOOL
WINAPI
VDMGetThreadSelectorEntry(
    HANDLE          hProcess,
    HANDLE          hThread,
    WORD            wSelector,
    LPVDMLDT_ENTRY  lpSelectorEntry
    );

ULONG
WINAPI
VDMGetPointer(
    HANDLE          hProcess,
    HANDLE          hThread,
    WORD            wSelector,
    DWORD           dwOffset,
    BOOL            fProtMode
    );

BOOL
WINAPI
VDMGetThreadContext(
    LPDEBUG_EVENT   lpDebugEvent,
    LPVDMCONTEXT    lpVDMContext
);

BOOL
WINAPI
VDMSetThreadContext(
    LPDEBUG_EVENT   lpDebugEvent,
    LPVDMCONTEXT    lpVDMContext
);

BOOL
WINAPI
VDMGetSelectorModule(
    HANDLE          hProcess,
    HANDLE          hThread,
    WORD            wSelector,
    PUINT           lpSegmentNumber,
    LPSTR           lpModuleName,
    UINT            nNameSize,
    LPSTR           lpModulePath,
    UINT            nPathSize
);

BOOL
WINAPI
VDMGetModuleSelector(
    HANDLE          hProcess,
    HANDLE          hThread,
    UINT            wSegmentNumber,
    LPSTR           lpModuleName,
    LPWORD          lpSelector
);

BOOL
WINAPI
VDMModuleFirst(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPMODULEENTRY   lpModuleEntry,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
);

BOOL
WINAPI
VDMModuleNext(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPMODULEENTRY   lpModuleEntry,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
);

BOOL
WINAPI
VDMGlobalFirst(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPGLOBALENTRY   lpGlobalEntry,
    WORD            wFlags,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
);

BOOL
WINAPI
VDMGlobalNext(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPGLOBALENTRY   lpGlobalEntry,
    WORD            wFlags,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
);

typedef BOOL (WINAPI *PROCESSENUMPROC)( DWORD dwProcessId, DWORD dwAttributes, LPARAM lpUserDefined );
typedef BOOL (WINAPI *TASKENUMPROC)( DWORD dwThreadId, WORD hMod16, WORD hTask16, LPARAM lpUserDefined );

#define WOW_SYSTEM  (DWORD)0x0001

INT
WINAPI
VDMEnumProcessWOW(
    PROCESSENUMPROC fp,
    LPARAM          lparam
);

INT
WINAPI
VDMEnumTaskWOW(
    DWORD           dwProcessId,
    TASKENUMPROC    fp,
    LPARAM          lparam
);

BOOL
WINAPI
VDMKillWOW(
    VOID
);

BOOL
WINAPI
VDMDetectWOW(
    VOID
);

BOOL
WINAPI
VDMBreakThread(
    HANDLE          hProcess,
    HANDLE          hThread
);

#ifdef __cplusplus
}
#endif

#endif // _VDMDBG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\wfext.h ===
/*****************************************************************************\
*                                                                             *
* wfext.h -     Windows File Manager Extensions definitions (Win32 variant)   *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1991-1995, Microsoft Corp. All rights reserved. *
*                                                                             *
*******************************************************************************/

#ifndef _INC_WFEXT
#define _INC_WFEXT            /* #defined if wfext.h has been included */

#ifdef __cplusplus            /* Assume C declaration for C++ */
extern "C" {
#endif  /* __cplusplus */

#define MENU_TEXT_LEN           40

#define FMMENU_FIRST            1
#define FMMENU_LAST             99

#define FMEVENT_LOAD            100
#define FMEVENT_UNLOAD          101
#define FMEVENT_INITMENU        102
#define FMEVENT_USER_REFRESH    103
#define FMEVENT_SELCHANGE       104
#define FMEVENT_TOOLBARLOAD     105
#define FMEVENT_HELPSTRING      106
#define FMEVENT_HELPMENUITEM    107

#define FMFOCUS_DIR             1
#define FMFOCUS_TREE            2
#define FMFOCUS_DRIVES          3
#define FMFOCUS_SEARCH          4

#define FM_GETFOCUS           (WM_USER + 0x0200)
#define FM_GETSELCOUNT        (WM_USER + 0x0202)
#define FM_GETSELCOUNTLFN     (WM_USER + 0x0203)  /* LFN versions are odd */
#define FM_REFRESH_WINDOWS    (WM_USER + 0x0206)
#define FM_RELOAD_EXTENSIONS  (WM_USER + 0x0207)

#define FM_GETDRIVEINFOA      (WM_USER + 0x0201)
#define FM_GETFILESELA        (WM_USER + 0x0204)
#define FM_GETFILESELLFNA     (WM_USER + 0x0205)  /* LFN versions are odd */

#define FM_GETDRIVEINFOW      (WM_USER + 0x0211)
#define FM_GETFILESELW        (WM_USER + 0x0214)
#define FM_GETFILESELLFNW     (WM_USER + 0x0215)  /* LFN versions are odd */

#ifdef UNICODE
#define FM_GETDRIVEINFO    FM_GETDRIVEINFOW
#define FM_GETFILESEL      FM_GETFILESELW
#define FM_GETFILESELLFN   FM_GETFILESELLFNW
#else
#define FM_GETDRIVEINFO    FM_GETDRIVEINFOA
#define FM_GETFILESEL      FM_GETFILESELA
#define FM_GETFILESELLFN   FM_GETFILESELLFNA
#endif


#ifndef UNICODE_ONLY
typedef struct _FMS_GETFILESELA {
   FILETIME ftTime;
   DWORD dwSize;
   BYTE bAttr;
   CHAR szName[260];          // always fully qualified
} FMS_GETFILESELA, FAR *LPFMS_GETFILESELA;
#endif //!UNICODE_ONLY

#ifndef ANSI_ONLY
typedef struct _FMS_GETFILESELW {
   FILETIME ftTime ;
   DWORD dwSize;
   BYTE bAttr;
   WCHAR szName[260];          // always fully qualified
} FMS_GETFILESELW, FAR *LPFMS_GETFILESELW;
#endif //!ANSI_ONLY

#ifdef UNICODE
#define FMS_GETFILESEL   FMS_GETFILESELW
#define LPFMS_GETFILESEL LPFMS_GETFILESELW
#else
#define FMS_GETFILESEL   FMS_GETFILESELA
#define LPFMS_GETFILESEL LPFMS_GETFILESELA
#endif


#ifndef UNICODE_ONLY
typedef struct _FMS_GETDRIVEINFOA {      // for drive
   DWORD dwTotalSpace;
   DWORD dwFreeSpace;
   CHAR  szPath[260];                    // current directory
   CHAR  szVolume[14];                   // volume label
   CHAR  szShare[128];                   // if this is a net drive
} FMS_GETDRIVEINFOA, FAR *LPFMS_GETDRIVEINFOA;
#endif //!UNICODE_ONLY

#ifndef ANSI_ONLY
typedef struct _FMS_GETDRIVEINFOW {      // for drive
   DWORD dwTotalSpace;
   DWORD dwFreeSpace;
   WCHAR szPath[260];                    // current directory
   WCHAR szVolume[14];                   // volume label
   WCHAR szShare[128];                   // if this is a net drive
} FMS_GETDRIVEINFOW, FAR *LPFMS_GETDRIVEINFOW;
#endif //!ANSI_ONLY

#ifdef UNICODE
#define FMS_GETDRIVEINFO   FMS_GETDRIVEINFOW
#define LPFMS_GETDRIVEINFO LPFMS_GETDRIVEINFOW
#else
#define FMS_GETDRIVEINFO   FMS_GETDRIVEINFOA
#define LPFMS_GETDRIVEINFO LPFMS_GETDRIVEINFOA
#endif


#ifndef UNICODE_ONLY
typedef struct _FMS_LOADA {
   DWORD dwSize;                        // for version checks
   CHAR  szMenuName[MENU_TEXT_LEN];     // output
   HMENU hMenu;                         // output
   UINT  wMenuDelta;                    // input
} FMS_LOADA, FAR *LPFMS_LOADA;
#endif //!UNICODE_ONLY

#ifndef ANSI_ONLY
typedef struct _FMS_LOADW {
   DWORD dwSize;                        // for version checks
   WCHAR szMenuName[MENU_TEXT_LEN];     // output
   HMENU hMenu;                         // output
   UINT  wMenuDelta;                    // input
} FMS_LOADW, FAR *LPFMS_LOADW;
#endif //!ANSI_ONLY

#ifdef UNICODE
#define FMS_LOAD   FMS_LOADW
#define LPFMS_LOAD LPFMS_LOADW
#else
#define FMS_LOAD   FMS_LOADA
#define LPFMS_LOAD LPFMS_LOADA
#endif


// Toolbar definitions

typedef struct tagEXT_BUTTON {
   WORD idCommand;                 /* menu command to trigger */
   WORD idsHelp;                   /* help string ID */
   WORD fsStyle;                   /* button style */
} EXT_BUTTON, FAR *LPEXT_BUTTON;

typedef struct tagFMS_TOOLBARLOAD {
   DWORD dwSize;                   /* for version checks */
   LPEXT_BUTTON lpButtons;         /* output */
   WORD cButtons;                  /* output, 0==>no buttons */
   WORD cBitmaps;                  /* number of non-sep buttons */
   WORD idBitmap;                  /* output */
   HBITMAP hBitmap;                /* output if idBitmap==0 */
} FMS_TOOLBARLOAD, FAR *LPFMS_TOOLBARLOAD;

#ifndef UNICODE_ONLY
typedef struct tagFMS_HELPSTRINGA {
   INT   idCommand;       /* input, -1==>the menu was selected */
   HMENU hMenu;           /* input, the extensions menu */
   CHAR  szHelp[128];     /* output, the help string */
} FMS_HELPSTRINGA, FAR *LPFMS_HELPSTRINGA;
#endif //!UNICODE_ONLY

#ifndef ANSI_ONLY
typedef struct tagFMS_HELPSTRINGW {
   INT   idCommand;       /* input, -1==>the menu was selected */
   HMENU hMenu;           /* input, the extensions menu */
   WCHAR szHelp[128];     /* output, the help string */
} FMS_HELPSTRINGW, FAR *LPFMS_HELPSTRINGW;
#endif //!ANSI_ONLY

#ifdef UNICODE
#define FMS_HELPSTRING   FMS_HELPSTRINGW
#define LPFMS_HELPSTRING LPFMS_HELPSTRINGW
#else
#define FMS_HELPSTRING   FMS_HELPSTRINGA
#define LPFMS_HELPSTRING LPFMS_HELPSTRINGA
#endif


typedef DWORD (APIENTRY *FM_EXT_PROC)(HWND, WORD, LONG);
typedef DWORD (APIENTRY *FM_UNDELETE_PROC)(HWND, LPTSTR);

#ifdef UNICODE
LONG WINAPI FMExtensionProcW(HWND hwnd, WORD wEvent, LONG lParam);
#else
LONG WINAPI FMExtensionProc(HWND hwnd, WORD wEvent, LONG lParam);
#endif

#ifdef __cplusplus
}                  /* End of extern "C" { */
#endif             /* __cplusplus */

#endif             /* _INC_WFEXT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\wdbgexts.h ===
/*++

Copyright (c) 1992-1995  Microsoft Corporation

Module Name:

    wdbgexts.h

Abstract:

    This file contains the necessary prototypes and data types for a user
    to write a debugger extension DLL.  This header file is also included
    by the NT debuggers (WINDBG & KD).

    This header file must be included after "windows.h" and "imagehlp.h".

    Please see the NT DDK documentation for specific information about
    how to write your own debugger extension DLL.

Environment:

    Win32 only.

Revision History:

--*/

#ifndef _WDBGEXTS_
#define _WDBGEXTS_

#ifdef __cplusplus
extern "C" {
#endif

#if !defined(WDBGAPI)
#define WDBGAPI __stdcall
#endif

#ifndef _WINDEF_
typedef CONST void far *LPCVOID;
#endif


typedef
VOID
(WDBGAPI*PWINDBG_OUTPUT_ROUTINE)(
    PCSTR lpFormat,
    ...
    );

typedef
ULONG
(WDBGAPI*PWINDBG_GET_EXPRESSION)(
    PCSTR lpExpression
    );

typedef
VOID
(WDBGAPI*PWINDBG_GET_SYMBOL)(
    PVOID   offset,
    PUCHAR  pchBuffer,
    PULONG  pDisplacement
    );

typedef
ULONG
(WDBGAPI*PWINDBG_DISASM)(
    PULONG lpOffset,
    PCSTR  lpBuffer,
    ULONG  fShowEffectiveAddress
    );

typedef
ULONG
(WDBGAPI*PWINDBG_CHECK_CONTROL_C)(
    VOID
    );

typedef
ULONG
(WDBGAPI*PWINDBG_READ_PROCESS_MEMORY_ROUTINE)(
    ULONG  offset,
    PVOID  lpBuffer,
    ULONG  cb,
    PULONG lpcbBytesRead
    );

typedef
ULONG
(WDBGAPI*PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE)(
    ULONG   offset,
    LPCVOID lpBuffer,
    ULONG   cb,
    PULONG  lpcbBytesWritten
    );

typedef
ULONG
(WDBGAPI*PWINDBG_GET_THREAD_CONTEXT_ROUTINE)(
    ULONG       Processor,
    PCONTEXT    lpContext,
    ULONG       cbSizeOfContext
    );

typedef
ULONG
(WDBGAPI*PWINDBG_SET_THREAD_CONTEXT_ROUTINE)(
    ULONG       Processor,
    PCONTEXT    lpContext,
    ULONG       cbSizeOfContext
    );

typedef
ULONG
(WDBGAPI*PWINDBG_IOCTL_ROUTINE)(
    USHORT   IoctlType,
    PVOID    lpvData,
    ULONG    cbSize
    );

typedef
ULONG
(WDBGAPI*PWINDBG_OLDKD_READ_PHYSICAL_MEMORY)(
    LARGE_INTEGER    address,
    PVOID            buffer,
    ULONG            count,
    PULONG           bytesread
    );

typedef
ULONG
(WDBGAPI*PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY)(
    LARGE_INTEGER    address,
    PVOID            buffer,
    ULONG            length,
    PULONG           byteswritten
    );


typedef struct _tagEXTSTACKTRACE {
    ULONG       FramePointer;
    ULONG       ProgramCounter;
    ULONG       ReturnAddress;
    ULONG       Args[4];
} EXTSTACKTRACE, *PEXTSTACKTRACE;


typedef
ULONG
(*PWINDBG_STACKTRACE_ROUTINE)(
    ULONG             FramePointer,
    ULONG             StackPointer,
    ULONG             ProgramCounter,
    PEXTSTACKTRACE    StackFrames,
    ULONG             Frames
    );

typedef struct _WINDBG_EXTENSION_APIS {
    ULONG                                  nSize;
    PWINDBG_OUTPUT_ROUTINE                 lpOutputRoutine;
    PWINDBG_GET_EXPRESSION                 lpGetExpressionRoutine;
    PWINDBG_GET_SYMBOL                     lpGetSymbolRoutine;
    PWINDBG_DISASM                         lpDisasmRoutine;
    PWINDBG_CHECK_CONTROL_C                lpCheckControlCRoutine;
    PWINDBG_READ_PROCESS_MEMORY_ROUTINE    lpReadProcessMemoryRoutine;
    PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE   lpWriteProcessMemoryRoutine;
    PWINDBG_GET_THREAD_CONTEXT_ROUTINE     lpGetThreadContextRoutine;
    PWINDBG_SET_THREAD_CONTEXT_ROUTINE     lpSetThreadContextRoutine;
    PWINDBG_IOCTL_ROUTINE                  lpIoctlRoutine;
    PWINDBG_STACKTRACE_ROUTINE             lpStackTraceRoutine;
} WINDBG_EXTENSION_APIS, *PWINDBG_EXTENSION_APIS;

typedef struct _WINDBG_OLD_EXTENSION_APIS {
    ULONG                                  nSize;
    PWINDBG_OUTPUT_ROUTINE                 lpOutputRoutine;
    PWINDBG_GET_EXPRESSION                 lpGetExpressionRoutine;
    PWINDBG_GET_SYMBOL                     lpGetSymbolRoutine;
    PWINDBG_DISASM                         lpDisasmRoutine;
    PWINDBG_CHECK_CONTROL_C                lpCheckControlCRoutine;
} WINDBG_OLD_EXTENSION_APIS, *PWINDBG_OLD_EXTENSION_APIS;

typedef struct _WINDBG_OLDKD_EXTENSION_APIS {
    ULONG                                  nSize;
    PWINDBG_OUTPUT_ROUTINE                 lpOutputRoutine;
    PWINDBG_GET_EXPRESSION                 lpGetExpressionRoutine;
    PWINDBG_GET_SYMBOL                     lpGetSymbolRoutine;
    PWINDBG_DISASM                         lpDisasmRoutine;
    PWINDBG_CHECK_CONTROL_C                lpCheckControlCRoutine;
    PWINDBG_READ_PROCESS_MEMORY_ROUTINE    lpReadVirtualMemRoutine;
    PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE   lpWriteVirtualMemRoutine;
    PWINDBG_OLDKD_READ_PHYSICAL_MEMORY     lpReadPhysicalMemRoutine;
    PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY    lpWritePhysicalMemRoutine;
} WINDBG_OLDKD_EXTENSION_APIS, *PWINDBG_OLDKD_EXTENSION_APIS;

typedef
VOID
(WDBGAPI*PWINDBG_OLD_EXTENSION_ROUTINE)(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    ULONG                   dwCurrentPc,
    PWINDBG_EXTENSION_APIS  lpExtensionApis,
    PCSTR                   lpArgumentString
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_ROUTINE)(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    ULONG                   dwCurrentPc,
    ULONG                   dwProcessor,
    PCSTR                   lpArgumentString
    );

typedef
VOID
(WDBGAPI*PWINDBG_OLDKD_EXTENSION_ROUTINE)(
    ULONG                        dwCurrentPc,
    PWINDBG_OLDKD_EXTENSION_APIS lpExtensionApis,
    PCSTR                        lpArgumentString
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_DLL_INIT)(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT                 MajorVersion,
    USHORT                 MinorVersion
    );

typedef
ULONG
(WDBGAPI*PWINDBG_CHECK_VERSION)(
    VOID
    );

#define EXT_API_VERSION_NUMBER 3

typedef struct EXT_API_VERSION {
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  Revision;
    USHORT  Reserved;
} EXT_API_VERSION, *LPEXT_API_VERSION;

typedef
LPEXT_API_VERSION
(WDBGAPI*PWINDBG_EXTENSION_API_VERSION)(
    VOID
    );

#define IG_KD_CONTEXT               1
#define IG_READ_CONTROL_SPACE       2
#define IG_WRITE_CONTROL_SPACE      3
#define IG_READ_IO_SPACE            4
#define IG_WRITE_IO_SPACE           5
#define IG_READ_PHYSICAL            6
#define IG_WRITE_PHYSICAL           7
#define IG_READ_IO_SPACE_EX         8
#define IG_WRITE_IO_SPACE_EX        9

typedef struct _tagPROCESSORINFO {
    USHORT      Processor;                // current processor
    USHORT      NumberProcessors;         // total number of processors
} PROCESSORINFO, *PPROCESSORINFO;

typedef struct _tagREADCONTROLSPACE {
    USHORT      Processor;
    ULONG       Address;
    ULONG       BufLen;
    UCHAR       Buf[1];
} READCONTROLSPACE, *PREADCONTROLSPACE;

typedef struct _tagIOSPACE {
    ULONG       Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
} IOSPACE, *PIOSPACE;

typedef struct _tagIOSPACE_EX {
    ULONG       Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
    ULONG       InterfaceType;
    ULONG       BusNumber;
    ULONG       AddressSpace;
} IOSPACE_EX, *PIOSPACE_EX;

typedef struct _tagPHYSICAL {
    LARGE_INTEGER          Address;
    ULONG                  BufLen;
    UCHAR                  Buf[1];
} PHYSICAL, *PPHYSICAL;


#ifdef __cplusplus
#define CPPMOD extern "C"
#else
#define CPPMOD
#endif


#define DECLARE_API(s)                             \
    CPPMOD VOID                                    \
    s(                                             \
        HANDLE                 hCurrentProcess,    \
        HANDLE                 hCurrentThread,     \
        ULONG                  dwCurrentPc,        \
        ULONG                  dwProcessor,        \
        PCSTR                  args                \
     )

#ifndef NOEXTAPI

#define dprintf          (ExtensionApis.lpOutputRoutine)
#define GetExpression    (ExtensionApis.lpGetExpressionRoutine)
#define GetSymbol        (ExtensionApis.lpGetSymbolRoutine)
#define Disassm          (ExtensionApis.lpDisasmRoutine)
#define CheckControlC    (ExtensionApis.lpCheckControlCRoutine)
#define ReadMemory       (ExtensionApis.lpReadProcessMemoryRoutine)
#define WriteMemory      (ExtensionApis.lpWriteProcessMemoryRoutine)
#define GetContext       (ExtensionApis.lpGetThreadContextRoutine)
#define SetContext       (ExtensionApis.lpSetThreadContextRoutine)
#define Ioctl            (ExtensionApis.lpIoctlRoutine)
#define StackTrace       (ExtensionApis.lpStackTraceRoutine)

#define GetKdContext(ppi) \
    Ioctl( IG_KD_CONTEXT, (PVOID)ppi, sizeof(*ppi) )

extern WINDBG_EXTENSION_APIS ExtensionApis;

__inline VOID
ReadControlSpace(
    USHORT  processor,
    ULONG   address,
    PVOID   buf,
    ULONG   size
    )
{
    PREADCONTROLSPACE prc;
    prc = (PREADCONTROLSPACE)LocalAlloc(LPTR, sizeof(*prc) + size );
    ZeroMemory( prc->Buf, size );
    prc->Processor = processor;
    prc->Address = (ULONG)address;
    prc->BufLen = size;
    Ioctl( IG_READ_CONTROL_SPACE, (PVOID)prc, sizeof(*prc) + size );
    CopyMemory( buf, prc->Buf, size );
    LocalFree( prc );
}

__inline VOID
ReadIoSpace(
    ULONG   address,
    PULONG  data,
    PULONG  size
    )
{
    IOSPACE is;
    is.Address = (ULONG)address;
    is.Length = *size;
    is.Data = 0;
    Ioctl( IG_READ_IO_SPACE, (PVOID)&is, sizeof(is) );
    *data = is.Data;
    *size = is.Length;
}

__inline VOID
WriteIoSpace(
    ULONG   address,
    ULONG   data,
    PULONG  size
    )
{
    IOSPACE is;
    is.Address = (ULONG)address;
    is.Length = *size;
    is.Data = data;
    Ioctl( IG_WRITE_IO_SPACE, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
ReadIoSpaceEx(
    ULONG   address,
    PULONG  data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX is;
    is.Address = (ULONG)address;
    is.Length = *size;
    is.Data = 0;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_READ_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *data = is.Data;
    *size = is.Length;
}

__inline VOID
WriteIoSpaceEx(
    ULONG   address,
    ULONG   data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX is;
    is.Address = (ULONG)address;
    is.Length = *size;
    is.Data = data;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_WRITE_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
ReadPhysical(
    LARGE_INTEGER       address,
    PVOID               buf,
    ULONG               size,
    PULONG              sizer
    )
{
    PPHYSICAL phy;
    phy = (PPHYSICAL)LocalAlloc(LPTR,  sizeof(*phy) + size );
    ZeroMemory( phy->Buf, size );
    phy->Address = address;
    phy->BufLen = size;
    Ioctl( IG_READ_PHYSICAL, (PVOID)phy, sizeof(*phy) + size );
    *sizer = phy->BufLen;
    CopyMemory( buf, phy->Buf, *sizer );
    LocalFree( phy );
}

__inline VOID
WritePhysical(
    LARGE_INTEGER       address,
    PVOID               buf,
    ULONG               size,
    PULONG              sizew
    )
{
    PPHYSICAL phy;
    phy = (PPHYSICAL)LocalAlloc(LPTR, sizeof(*phy) + size );
    ZeroMemory( phy->Buf, size );
    phy->Address = address;
    phy->BufLen = size;
    CopyMemory( phy->Buf, buf, size );
    Ioctl( IG_WRITE_PHYSICAL, (PVOID)phy, sizeof(*phy) + size );
    *sizew = phy->BufLen;
    LocalFree( phy );
}
#endif


#ifdef __cplusplus
}
#endif

#endif // _WDBGEXTS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\wchar.h ===
/***
*wchar.h - declarations for wide character functions
*
*	Copyright (c) 1992-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file contains the types, macros and function declarations for
*	all wide character-related functions.  They may also be declared in
*	individual header files on a functional basis.
*	[ISO]
*
*	Note: keep in sync with ctype.h, stdio.h, stdlib.h, string.h, time.h.
*
*       [Public]
*
****/

#if	!defined(_M_MPPC) && !defined(_M_M68K)

#ifndef _INC_WCHAR
#define _INC_WCHAR

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef	_MSC_VER
#pragma pack(push,8)
#endif	/* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif


/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if	( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


#ifndef _WCTYPE_T_DEFINED
typedef wchar_t wint_t;
typedef wchar_t wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef _VA_LIST_DEFINED
#ifdef	_M_ALPHA
typedef struct {
	char *a0;	/* pointer to first homed integer argument */
	int offset;	/* byte offset of next parameter */
} va_list;
#else
typedef char *	va_list;
#endif
#define _VA_LIST_DEFINED
#endif

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifndef _FILE_DEFINED
struct _iobuf {
	char *_ptr;
	int   _cnt;
	char *_base;
	int   _flag;
	int   _file;
	int   _charbuf;
	int   _bufsiz;
	char *_tmpfname;
	};
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif

#ifndef _FSIZE_T_DEFINED
typedef unsigned long _fsize_t; /* Could be 64 bits for Win32 */
#define _FSIZE_T_DEFINED
#endif

#ifndef _WFINDDATA_T_DEFINED

struct _wfinddata_t {
	unsigned attrib;
	time_t	 time_create;	/* -1 for FAT file systems */
	time_t	 time_access;	/* -1 for FAT file systems */
	time_t	 time_write;
	_fsize_t size;
	wchar_t	 name[260];
};

#if	!defined(_M_MPPC) && !defined(_M_M68K)
#if	_INTEGRAL_MAX_BITS >= 64
struct _wfinddatai64_t {
	unsigned attrib;
	time_t	 time_create;	/* -1 for FAT file systems */
	time_t	 time_access;	/* -1 for FAT file systems */
	time_t	 time_write;
	__int64	 size;
	wchar_t	 name[260];
};
#endif
#endif

#define _WFINDDATA_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif

/*
 * This declaration allows the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */

#ifdef	_NTSDK

/* definitions and declarations compatible with NT SDK */

#ifdef	_DLL
extern unsigned short * _ctype;
#define _pctype     (*_pctype_dll)
extern unsigned short **_pctype_dll;
#define _pwctype    (*_pwctype_dll)
extern unsigned short **_pwctype_dll;
#else	/* ndef _DLL */
extern unsigned short _ctype[];
extern unsigned short *_pctype;
extern wctype_t *_pwctype;
#endif	/* _DLL */

#else	/* ndef _NTSDK */

/* current declarations */

_CRTIMP extern unsigned short _ctype[];

#if	defined(_DLL) && defined(_M_IX86)

#define _pctype     (*__p__pctype())
_CRTIMP unsigned short ** __cdecl __p__pctype(void);

#define _pwctype    (*__p__pwctype())
_CRTIMP wctype_t ** __cdecl ___p__pwctype(void);

#else	/* !(defined(_DLL) && defined(_M_IX86)) */

_CRTIMP extern unsigned short *_pctype;
_CRTIMP extern wctype_t *_pwctype;

#endif	/* defined(_DLL) && defined(_M_IX86) */

#endif	/* _NTSDK */


/* set bit masks for the possible character types */

#define _UPPER		0x1	/* upper case letter */
#define _LOWER		0x2	/* lower case letter */
#define _DIGIT		0x4	/* digit[0-9] */
#define _SPACE		0x8	/* tab, carriage return, newline, */
				/* vertical tab or form feed */
#define _PUNCT		0x10	/* punctuation character */
#define _CONTROL	0x20	/* control character */
#define _BLANK		0x40	/* space char */
#define _HEX		0x80	/* hexadecimal digit */

#define _LEADBYTE	0x8000			/* multibyte leadbyte */
#define _ALPHA		(0x0100|_UPPER|_LOWER)	/* alphabetic character */


/* Function prototypes */

#ifndef _WCTYPE_DEFINED

/* Character classification function prototypes */
/* also declared in ctype.h */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

#ifndef _WDIRECT_DEFINED

/* also declared in direct.h */

_CRTIMP int __cdecl _wchdir(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wgetcwd(wchar_t *, int);
_CRTIMP wchar_t * __cdecl _wgetdcwd(int, wchar_t *, int);
_CRTIMP int __cdecl _wmkdir(const wchar_t *);
_CRTIMP int __cdecl _wrmdir(const wchar_t *);

#define _WDIRECT_DEFINED
#endif

#ifndef _WIO_DEFINED

/* also declared in io.h */

_CRTIMP int __cdecl _waccess(const wchar_t *, int);
_CRTIMP int __cdecl _wchmod(const wchar_t *, int);
_CRTIMP int __cdecl _wcreat(const wchar_t *, int);
_CRTIMP long __cdecl _wfindfirst(wchar_t *, struct _wfinddata_t *);
_CRTIMP int __cdecl _wfindnext(long, struct _wfinddata_t *);
_CRTIMP int __cdecl _wunlink(const wchar_t *);
_CRTIMP int __cdecl _wrename(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wopen(const wchar_t *, int, ...);
_CRTIMP int __cdecl _wsopen(const wchar_t *, int, int, ...);
_CRTIMP wchar_t * __cdecl _wmktemp(wchar_t *);

#if	_INTEGRAL_MAX_BITS >= 64
_CRTIMP long __cdecl _wfindfirsti64(wchar_t *, struct _wfinddatai64_t *);
_CRTIMP int __cdecl _wfindnexti64(long, struct _wfinddatai64_t *);
#endif

#define _WIO_DEFINED
#endif

#ifndef _WLOCALE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wsetlocale(int, const wchar_t *);

#define _WLOCALE_DEFINED
#endif

#ifndef _WPROCESS_DEFINED

/* also declared in process.h */

_CRTIMP int __cdecl _wexecl(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wexecle(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wexeclp(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wexeclpe(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wexecv(const wchar_t *, const wchar_t * const *);
_CRTIMP int __cdecl _wexecve(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP int __cdecl _wexecvp(const wchar_t *, const wchar_t * const *);
_CRTIMP int __cdecl _wexecvpe(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP int __cdecl _wspawnl(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wspawnle(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wspawnlp(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wspawnlpe(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wspawnv(int, const wchar_t *, const wchar_t * const *);
_CRTIMP int __cdecl _wspawnve(int, const wchar_t *, const wchar_t * const *,
	const wchar_t * const *);
_CRTIMP int __cdecl _wspawnvp(int, const wchar_t *, const wchar_t * const *);
_CRTIMP int __cdecl _wspawnvpe(int, const wchar_t *, const wchar_t * const *,
	const wchar_t * const *);
_CRTIMP int __cdecl _wsystem(const wchar_t *);

#define _WPROCESS_DEFINED
#endif

#define iswalpha(_c)	( iswctype(_c,_ALPHA) )
#define iswupper(_c)	( iswctype(_c,_UPPER) )
#define iswlower(_c)	( iswctype(_c,_LOWER) )
#define iswdigit(_c)	( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)	( iswctype(_c,_HEX) )
#define iswspace(_c)	( iswctype(_c,_SPACE) )
#define iswpunct(_c)	( iswctype(_c,_PUNCT) )
#define iswalnum(_c)	( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)	( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)	( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)	( iswctype(_c,_CONTROL) )
#define iswascii(_c)	( (unsigned)(_c) < 0x80 )

#define isleadbyte(_c)	(_pctype[(unsigned char)(_c)] & _LEADBYTE)

/* define structure for returning status information */

#ifndef _INO_T_DEFINED

typedef unsigned short _ino_t;		/* i-node number (not used on DOS) */

#if	!__STDC__
/* Non-ANSI name for compatibility */
#ifdef	_NTSDK
#define ino_t _ino_t
#else	/* ndef _NTSDK */
typedef unsigned short ino_t;
#endif	/* _NTSDK */
#endif

#define _INO_T_DEFINED
#endif


#ifndef _DEV_T_DEFINED

#ifdef	_NTSDK
typedef short _dev_t;			/* device code */
#else	/* ndef _NTSDK */
typedef unsigned int _dev_t;		/* device code */
#endif	/* _NTSDK */

#if	!__STDC__
/* Non-ANSI name for compatibility */
#ifdef	_NTSDK
#define dev_t _dev_t
#else	/* ndef _NTSDK */
typedef unsigned int dev_t;
#endif	/* _NTSDK */
#endif

#define _DEV_T_DEFINED
#endif

#ifndef _OFF_T_DEFINED

typedef long _off_t;			/* file offset value */

#if	!__STDC__
/* Non-ANSI name for compatibility */
#ifdef	_NTSDK
#define off_t _off_t
#else	/* ndef _NTSDK */
typedef long off_t;
#endif	/* _NTSDK */
#endif

#define _OFF_T_DEFINED
#endif

#ifndef _STAT_DEFINED

struct _stat {
	_dev_t st_dev;
	_ino_t st_ino;
	unsigned short st_mode;
	short st_nlink;
	short st_uid;
	short st_gid;
	_dev_t st_rdev;
	_off_t st_size;
	time_t st_atime;
	time_t st_mtime;
	time_t st_ctime;
	};

#if	!__STDC__ && !defined(_NTSDK)

/* Non-ANSI names for compatibility */

struct stat {
	_dev_t st_dev;
	_ino_t st_ino;
	unsigned short st_mode;
	short st_nlink;
	short st_uid;
	short st_gid;
	_dev_t st_rdev;
	_off_t st_size;
	time_t st_atime;
	time_t st_mtime;
	time_t st_ctime;
	};

#endif	/* __STDC__ */

#if	_INTEGRAL_MAX_BITS >= 64
struct _stati64 {
	_dev_t st_dev;
	_ino_t st_ino;
	unsigned short st_mode;
	short st_nlink;
	short st_uid;
	short st_gid;
	_dev_t st_rdev;
	__int64 st_size;
	time_t st_atime;
	time_t st_mtime;
	time_t st_ctime;
	};
#endif

#define _STAT_DEFINED
#endif


#ifndef _WSTAT_DEFINED

/* also declared in stat.h */

_CRTIMP int __cdecl _wstat(const wchar_t *, struct _stat *);

#if	_INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _wstati64(const wchar_t *, struct _stati64 *);
#endif

#define _WSTAT_DEFINED
#endif


#ifndef _WSTDIO_DEFINED

/* also declared in stdio.h */

#ifdef	_POSIX_
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *);
#else
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *, int);
#endif

_CRTIMP wint_t __cdecl fgetwc(FILE *);
_CRTIMP wint_t __cdecl _fgetwchar(void);
_CRTIMP wint_t __cdecl fputwc(wint_t, FILE *);
_CRTIMP wint_t __cdecl _fputwchar(wint_t);
_CRTIMP wint_t __cdecl getwc(FILE *);
_CRTIMP wint_t __cdecl getwchar(void);
_CRTIMP wint_t __cdecl putwc(wint_t, FILE *);
_CRTIMP wint_t __cdecl putwchar(wint_t);
_CRTIMP wint_t __cdecl ungetwc(wint_t, FILE *);

_CRTIMP wchar_t * __cdecl fgetws(wchar_t *, int, FILE *);
_CRTIMP int __cdecl fputws(const wchar_t *, FILE *);
_CRTIMP wchar_t * __cdecl _getws(wchar_t *);
_CRTIMP int __cdecl _putws(const wchar_t *);

_CRTIMP int __cdecl fwprintf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl wprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _snwprintf(wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl swprintf(wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl vfwprintf(FILE *, const wchar_t *, va_list);
_CRTIMP int __cdecl vwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl _vsnwprintf(wchar_t *, size_t, const wchar_t *, va_list);
_CRTIMP int __cdecl vswprintf(wchar_t *, const wchar_t *, va_list);
_CRTIMP int __cdecl fwscanf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl swscanf(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl wscanf(const wchar_t *, ...);

#define getwchar()		fgetwc(stdin)
#define putwchar(_c)		fputwc((_c),stdout)
#define getwc(_stm)		fgetwc(_stm)
#define putwc(_c,_stm)		fputwc(_c,_stm)

_CRTIMP FILE * __cdecl _wfdopen(int, const wchar_t *);
_CRTIMP FILE * __cdecl _wfopen(const wchar_t *, const wchar_t *);
_CRTIMP FILE * __cdecl _wfreopen(const wchar_t *, const wchar_t *, FILE *);
_CRTIMP void __cdecl _wperror(const wchar_t *);
_CRTIMP FILE * __cdecl _wpopen(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wremove(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtempnam(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtmpnam(wchar_t *);

#define _WSTDIO_DEFINED
#endif


#ifndef _WSTDLIB_DEFINED

/* also declared in stdlib.h */

_CRTIMP wchar_t * __cdecl _itow (int, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ltow (long, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ultow (unsigned long, wchar_t *, int);
_CRTIMP double __cdecl wcstod(const wchar_t *, wchar_t **);
_CRTIMP long   __cdecl wcstol(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned long __cdecl wcstoul(const wchar_t *, wchar_t **, int);
_CRTIMP wchar_t * __cdecl _wgetenv(const wchar_t *);
_CRTIMP int    __cdecl _wsystem(const wchar_t *);
_CRTIMP int __cdecl _wtoi(const wchar_t *);
_CRTIMP long __cdecl _wtol(const wchar_t *);

#define _WSTDLIB_DEFINED
#endif

#ifndef _POSIX_

#ifndef _WSTDLIBP_DEFINED

/* also declared in stdlib.h  */

_CRTIMP wchar_t * __cdecl _wfullpath(wchar_t *, const wchar_t *, size_t);
_CRTIMP void   __cdecl _wmakepath(wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *,
	const wchar_t *);
_CRTIMP void   __cdecl _wperror(const wchar_t *);
_CRTIMP int    __cdecl _wputenv(const wchar_t *);
_CRTIMP void   __cdecl _wsearchenv(const wchar_t *, const wchar_t *, wchar_t *);
_CRTIMP void   __cdecl _wsplitpath(const wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *);

#define _WSTDLIBP_DEFINED
#endif

#endif /* _POSIX_ */


#ifndef _WSTRING_DEFINED

/* also declared in string.h */

_CRTIMP wchar_t * __cdecl wcscat(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcschr(const wchar_t *, wchar_t);
_CRTIMP int __cdecl wcscmp(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcscpy(wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcscspn(const wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcslen(const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsncat(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcsncmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsncpy(wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcspbrk(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsrchr(const wchar_t *, wchar_t);
_CRTIMP size_t __cdecl wcsspn(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsstr(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcstok(wchar_t *, const wchar_t *);

_CRTIMP wchar_t * __cdecl _wcsdup(const wchar_t *);
_CRTIMP int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl _wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl _wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsset(wchar_t *, wchar_t);

_CRTIMP wchar_t * __cdecl _wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsupr(wchar_t *);
_CRTIMP size_t __cdecl wcsxfrm(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcscoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsicoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsncoll(const wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl _wcsnicoll(const wchar_t *, const wchar_t *, size_t);

/* Old names */
#define wcswcs wcsstr

#if	!__STDC__

#ifdef _NTSDK

/* Non-ANSI names for compatibility */
#define wcsdup	_wcsdup
#define wcsicmp	_wcsicmp
#define wcsnicmp _wcsnicmp
#define wcsnset	_wcsnset
#define wcsrev	_wcsrev
#define wcsset	_wcsset
#define wcslwr	_wcslwr
#define wcsupr	_wcsupr
#define wcsicoll _wcsicoll

#else /* ndef _NTSDK */

/* prototypes for oldnames.lib functions */
_CRTIMP wchar_t * __cdecl wcsdup(const wchar_t *);
_CRTIMP int __cdecl wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsset(wchar_t *, wchar_t);
_CRTIMP wchar_t * __cdecl wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsupr(wchar_t *);
_CRTIMP int __cdecl wcsicoll(const wchar_t *, const wchar_t *);

#endif /* ndef _NTSDK */

#endif /* !__STDC__ */

#define _WSTRING_DEFINED
#endif

#ifndef _TM_DEFINED
struct tm {
	int tm_sec;	/* seconds after the minute - [0,59] */
	int tm_min;	/* minutes after the hour - [0,59] */
	int tm_hour;	/* hours since midnight - [0,23] */
	int tm_mday;	/* day of the month - [1,31] */
	int tm_mon;	/* months since January - [0,11] */
	int tm_year;	/* years since 1900 */
	int tm_wday;	/* days since Sunday - [0,6] */
	int tm_yday;	/* days since January 1 - [0,365] */
	int tm_isdst;	/* daylight savings time flag */
	};
#define _TM_DEFINED
#endif

#ifndef _WTIME_DEFINED

/* also declared in time.h */
 
_CRTIMP wchar_t * __cdecl _wasctime(const struct tm *);
_CRTIMP wchar_t * __cdecl _wctime(const time_t *);
_CRTIMP size_t __cdecl wcsftime(wchar_t *, size_t, const wchar_t *,
	const struct tm *);
_CRTIMP wchar_t * __cdecl _wstrdate(wchar_t *);
_CRTIMP wchar_t * __cdecl _wstrtime(wchar_t *);

#define _WTIME_DEFINED
#endif


#ifdef __cplusplus
}
#endif

#ifdef	_MSC_VER
#pragma pack(pop)
#endif	/* _MSC_VER */

#endif	/* _INC_WCHAR */

#endif /* !defined(_M_MPPC) && !defined(_M_M68K) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\varargs.h ===
/***
*varargs.h - XENIX style macros for variable argument functions
*
*	Copyright (c) 1985-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines XENIX style macros for accessing arguments of a
*	function which takes a variable number of arguments.
*	[System V]
*
*       [Public]
*
****/

#ifndef _INC_VARARGS
#define _INC_VARARGS

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef	_MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif	/* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif

#if	__STDC__
#error varargs.h incompatible with ANSI (use stdarg.h)
#endif


#ifndef _VA_LIST_DEFINED

#ifdef _M_ALPHA
typedef struct {
    char *a0;           /* pointer to first homed integer argument */
    int offset;         /* byte offset of next parameter */
} va_list;
#else
typedef char *va_list;
#endif

#define _VA_LIST_DEFINED
#endif


#if	defined(_M_IX86)

/*
 * define a macro to compute the size of a type, variable or expression,
 * rounded up to the nearest multiple of sizeof(int). This number is its
 * size as function argument (Intel architecture). Note that the macro
 * depends on sizeof(int) being a power of 2!
 */
#define _INTSIZEOF(n)	 ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0


#elif	defined(_M_MRX000)	/* _MIPS_ */


#define va_dcl int va_alist;
#define va_start(list) list = (char *) &va_alist
#define va_end(list)
#define va_arg(list, mode) ((mode *)(list =\
 (char *) ((((int)list + (__builtin_alignof(mode)<=4?3:7)) &\
 (__builtin_alignof(mode)<=4?-4:-8))+sizeof(mode))))[-1]
/*  +++++++++++++++++++++++++++++++++++++++++++
    Because of parameter passing conventions in C:
    use mode=int for char, and short types
    use mode=double for float types
    use a pointer for array types
    +++++++++++++++++++++++++++++++++++++++++++ */


#elif	defined(_M_ALPHA)

/*
 * The Alpha compiler supports two builtin functions that are used to
 * implement stdarg/varargs.  The __builtin_va_start function is used
 * by va_start to initialize the data structure that locates the next
 * argument.  The __builtin_isfloat function is used by va_arg to pick
 * which part of the home area a given register argument is stored in.
 * The home area is where up to six integer and/or six floating point
 * register arguments are stored down (so they can also be referenced
 * by a pointer like any arguments passed on the stack).
 */
extern void * __builtin_va_start(va_list, ...);

#define va_dcl long va_alist;
#define va_start(list) __builtin_va_start(list, va_alist, 0)
#define va_end(list)
#define va_arg(list, mode) \
    ( *(        ((list).offset += ((int)sizeof(mode) + 7) & -8) , \
        (mode *)((list).a0 + (list).offset - \
                    ((__builtin_isfloat(mode) && (list).offset <= (6 * 8)) ? \
                        (6 * 8) + 8 : ((int)sizeof(mode) + 7) & -8) \
                ) \
       ) \
    )


#elif defined(_M_PPC)

/*
 * define a macro to compute the size of a type, variable or expression,
 * rounded up to the nearest multiple of sizeof(int). This number is its
 * size as function argument (PPC architecture). Note that the macro
 * depends on sizeof(int) being a power of 2!
 */
/* this is for LITTLE-ENDIAN PowerPC */

/* bytes that a type occupies in the argument list */
#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )
/* return 'ap' adjusted for type 't' in arglist */
#define	_ALIGNIT(ap,t) \
	((((int)(ap))+(sizeof(t)<8?3:7)) & (sizeof(t)<8?~3:~7))

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t)    ( *(t *)((ap = (char *) (_ALIGNIT(ap, t) + _INTSIZEOF(t))) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0

#else

/* A guess at the proper definitions for other platforms */

#define _INTSIZEOF(n)	 ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0


#endif


#ifdef __cplusplus
}
#endif

#ifdef	_MSC_VER
#pragma pack(pop)
#endif	/* _MSC_VER */

#endif	/* _INC_VARARGS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\winmm.h ===
/*++ BUILD Version: 0002    Increment this if a change has global effects

Copyright (c) 1990-1993, Microsoft Corporation

Module Name:

    winmm.h

Abstract:

    This include file defines all the support for Multimedia applications.

    24-Apr-91 MMTIME structure added. NigelT.
    3-Dec-91  Wholesale changes.  LaurieGr.
    30-Jan-92 Avoid things only in portwin32 LPARAM,HFILE,WPARAM  LaurieGr
    19-Feb-92 Brave attempt to avoid collisions with rest of NT LaurieGr
    26-Feb-92 Moved to mmsystem.h - RobinSp.

--*/


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\winioctl.h ===
/*++ BUILD Version: 0012    // Increment this if a change has global effects

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    winioctl.h

Abstract:

    This module defines the 32-Bit Windows Device I/O control codes.

Revision History:

--*/

#ifndef _WINIOCTL_
#define _WINIOCTL_


#ifndef _DEVIOCTL_
#define _DEVIOCTL_

// begin_ntddk begin_nthal begin_ntifs
//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define DEVICE_TYPE DWORD

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a

//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//


#define FILE_ANY_ACCESS                 0
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

// end_ntddk end_nthal end_ntifs

#endif // _DEVIOCTL_


//
// IoControlCode values for disk devices.
//

#define IOCTL_DISK_BASE                 FILE_DEVICE_DISK
#define IOCTL_DISK_GET_DRIVE_GEOMETRY   CTL_CODE(IOCTL_DISK_BASE, 0x0000, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_GET_PARTITION_INFO   CTL_CODE(IOCTL_DISK_BASE, 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_SET_PARTITION_INFO   CTL_CODE(IOCTL_DISK_BASE, 0x0002, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_GET_DRIVE_LAYOUT     CTL_CODE(IOCTL_DISK_BASE, 0x0003, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_SET_DRIVE_LAYOUT     CTL_CODE(IOCTL_DISK_BASE, 0x0004, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_VERIFY               CTL_CODE(IOCTL_DISK_BASE, 0x0005, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_FORMAT_TRACKS        CTL_CODE(IOCTL_DISK_BASE, 0x0006, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_REASSIGN_BLOCKS      CTL_CODE(IOCTL_DISK_BASE, 0x0007, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_PERFORMANCE          CTL_CODE(IOCTL_DISK_BASE, 0x0008, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_IS_WRITABLE          CTL_CODE(IOCTL_DISK_BASE, 0x0009, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_LOGGING              CTL_CODE(IOCTL_DISK_BASE, 0x000a, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_FORMAT_TRACKS_EX     CTL_CODE(IOCTL_DISK_BASE, 0x000b, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_HISTOGRAM_STRUCTURE	CTL_CODE(IOCTL_DISK_BASE, 0x000c, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_HISTOGRAM_DATA	CTL_CODE(IOCTL_DISK_BASE, 0x000d, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_HISTOGRAM_RESET	CTL_CODE(IOCTL_DISK_BASE, 0x000e, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_REQUEST_STRUCTURE	CTL_CODE(IOCTL_DISK_BASE, 0x000f, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_REQUEST_DATA		CTL_CODE(IOCTL_DISK_BASE, 0x0010, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// The following device control codes are common for all class drivers.  The
// functions codes defined here must match all of the other class drivers.
//

#define IOCTL_DISK_CHECK_VERIFY     CTL_CODE(IOCTL_DISK_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_MEDIA_REMOVAL    CTL_CODE(IOCTL_DISK_BASE, 0x0201, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_EJECT_MEDIA      CTL_CODE(IOCTL_DISK_BASE, 0x0202, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_LOAD_MEDIA       CTL_CODE(IOCTL_DISK_BASE, 0x0203, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_RESERVE          CTL_CODE(IOCTL_DISK_BASE, 0x0204, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_RELEASE          CTL_CODE(IOCTL_DISK_BASE, 0x0205, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_FIND_NEW_DEVICES CTL_CODE(IOCTL_DISK_BASE, 0x0206, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_REMOVE_DEVICE    CTL_CODE(IOCTL_DISK_BASE, 0x0207, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_DISK_GET_MEDIA_TYPES CTL_CODE(IOCTL_DISK_BASE, 0x0300, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Define the partition types returnable by known disk drivers.
//

#define PARTITION_ENTRY_UNUSED          0x00      // Entry unused
#define PARTITION_FAT_12                0x01      // 12-bit FAT entries
#define PARTITION_XENIX_1               0x02      // Xenix
#define PARTITION_XENIX_2               0x03      // Xenix
#define PARTITION_FAT_16                0x04      // 16-bit FAT entries
#define PARTITION_EXTENDED              0x05      // Extended partition entry
#define PARTITION_HUGE                  0x06      // Huge partition MS-DOS V4
#define PARTITION_IFS                   0x07      // IFS Partition
#define PARTITION_PREP                  0x41      // PowerPC Reference Platform (PReP) Boot Partition
#define PARTITION_UNIX                  0x63      // Unix

#define VALID_NTFT                      0xC0      // NTFT uses high order bits

//
// The high bit of the partition type code indicates that a partition
// is part of an NTFT mirror or striped array.
//

#define PARTITION_NTFT                  0x80     // NTFT partition

//
// The following macro is used to determine which partitions should be
// assigned drive letters.
//

//++
//
// BOOLEAN
// IsRecognizedPartition(
//     IN DWORD PartitionType
//     )
//
// Routine Description:
//
//     This macro is used to determine to which partitions drive letters
//     should be assigned.
//
// Arguments:
//
//     PartitionType - Supplies the type of the partition being examined.
//
// Return Value:
//
//     The return value is TRUE if the partition type is recognized,
//     otherwise FALSE is returned.
//
//--

#define IsRecognizedPartition( PartitionType ) (       \
     ((PartitionType & PARTITION_NTFT) && ((PartitionType & ~0xC0) == PARTITION_FAT_12)) ||  \
     ((PartitionType & PARTITION_NTFT) && ((PartitionType & ~0xC0) == PARTITION_FAT_16)) ||  \
     ((PartitionType & PARTITION_NTFT) && ((PartitionType & ~0xC0) == PARTITION_IFS)) ||  \
     ((PartitionType & PARTITION_NTFT) && ((PartitionType & ~0xC0) == PARTITION_HUGE)) ||  \
     ((PartitionType & ~PARTITION_NTFT) == PARTITION_FAT_12) ||  \
     ((PartitionType & ~PARTITION_NTFT) == PARTITION_FAT_16) ||  \
     ((PartitionType & ~PARTITION_NTFT) == PARTITION_IFS)    ||  \
     ((PartitionType & ~PARTITION_NTFT) == PARTITION_HUGE) )

//
// Define the media types supported by the driver.
//

typedef enum _MEDIA_TYPE {
    Unknown,                // Format is unknown
    F5_1Pt2_512,            // 5.25", 1.2MB,  512 bytes/sector
    F3_1Pt44_512,           // 3.5",  1.44MB, 512 bytes/sector
    F3_2Pt88_512,           // 3.5",  2.88MB, 512 bytes/sector
    F3_20Pt8_512,           // 3.5",  20.8MB, 512 bytes/sector
    F3_720_512,             // 3.5",  720KB,  512 bytes/sector
    F5_360_512,             // 5.25", 360KB,  512 bytes/sector
    F5_320_512,             // 5.25", 320KB,  512 bytes/sector
    F5_320_1024,            // 5.25", 320KB,  1024 bytes/sector
    F5_180_512,             // 5.25", 180KB,  512 bytes/sector
    F5_160_512,             // 5.25", 160KB,  512 bytes/sector
    RemovableMedia,         // Removable media other than floppy
    FixedMedia              // Fixed hard disk media
} MEDIA_TYPE, *PMEDIA_TYPE;

//
// Define the input buffer structure for the driver, when
// it is called with IOCTL_DISK_FORMAT_TRACKS.
//

typedef struct _FORMAT_PARAMETERS {
   MEDIA_TYPE MediaType;
   DWORD StartCylinderNumber;
   DWORD EndCylinderNumber;
   DWORD StartHeadNumber;
   DWORD EndHeadNumber;
} FORMAT_PARAMETERS, *PFORMAT_PARAMETERS;

//
// Define the BAD_TRACK_NUMBER type. An array of elements of this type is
// returned by the driver on IOCTL_DISK_FORMAT_TRACKS requests, to indicate
// what tracks were bad during formatting. The length of that array is
// reported in the `Information' field of the I/O Status Block.
//

typedef WORD   BAD_TRACK_NUMBER;
typedef WORD   *PBAD_TRACK_NUMBER;

//
// Define the input buffer structure for the driver, when
// it is called with IOCTL_DISK_FORMAT_TRACKS_EX.
//

typedef struct _FORMAT_EX_PARAMETERS {
   MEDIA_TYPE MediaType;
   DWORD StartCylinderNumber;
   DWORD EndCylinderNumber;
   DWORD StartHeadNumber;
   DWORD EndHeadNumber;
   WORD   FormatGapLength;
   WORD   SectorsPerTrack;
   WORD   SectorNumber[1];
} FORMAT_EX_PARAMETERS, *PFORMAT_EX_PARAMETERS;

//
// The following structure is returned on an IOCTL_DISK_GET_DRIVE_GEOMETRY
// request and an array of them is returned on an IOCTL_DISK_GET_MEDIA_TYPES
// request.
//

typedef struct _DISK_GEOMETRY {
    LARGE_INTEGER Cylinders;
    MEDIA_TYPE MediaType;
    DWORD TracksPerCylinder;
    DWORD SectorsPerTrack;
    DWORD BytesPerSector;
} DISK_GEOMETRY, *PDISK_GEOMETRY;

//
// The following structure is returned on an IOCTL_DISK_GET_PARTITION_INFO
// and an IOCTL_DISK_GET_DRIVE_LAYOUT request.  It is also used in a request
// to change the drive layout, IOCTL_DISK_SET_DRIVE_LAYOUT.
//

typedef struct _PARTITION_INFORMATION {
    LARGE_INTEGER StartingOffset;
    LARGE_INTEGER PartitionLength;
    DWORD HiddenSectors;
    DWORD PartitionNumber;
    BYTE  PartitionType;
    BOOLEAN BootIndicator;
    BOOLEAN RecognizedPartition;
    BOOLEAN RewritePartition;
} PARTITION_INFORMATION, *PPARTITION_INFORMATION;

//
// The following structure is used to change the partition type of a
// specified disk partition using an IOCTL_DISK_SET_PARTITION_INFO
// request.
//

typedef struct _SET_PARTITION_INFORMATION {
    BYTE  PartitionType;
} SET_PARTITION_INFORMATION, *PSET_PARTITION_INFORMATION;

//
// The following structures is returned on an IOCTL_DISK_GET_DRIVE_LAYOUT
// request and given as input to an IOCTL_DISK_SET_DRIVE_LAYOUT request.
//

typedef struct _DRIVE_LAYOUT_INFORMATION {
    DWORD PartitionCount;
    DWORD Signature;
    PARTITION_INFORMATION PartitionEntry[1];
} DRIVE_LAYOUT_INFORMATION, *PDRIVE_LAYOUT_INFORMATION;

//
// The following structure is passed in on an IOCTL_DISK_VERIFY request.
// The offset and length parameters are both given in bytes.
//

typedef struct _VERIFY_INFORMATION {
    LARGE_INTEGER StartingOffset;
    DWORD Length;
} VERIFY_INFORMATION, *PVERIFY_INFORMATION;

//
// The following structure is passed in on an IOCTL_DISK_REASSIGN_BLOCKS
// request.
//

typedef struct _REASSIGN_BLOCKS {
    WORD   Reserved;
    WORD   Count;
    DWORD BlockNumber[1];
} REASSIGN_BLOCKS, *PREASSIGN_BLOCKS;

//
// IOCTL_DISK_MEDIA_REMOVAL disables the mechanism
// on a SCSI device that ejects media. This function
// may or may not be supported on SCSI devices that
// support removable media.
//
// TRUE means prevent media from being removed.
// FALSE means allow media removal.
//

typedef struct _PREVENT_MEDIA_REMOVAL {
    BOOLEAN PreventMediaRemoval;
} PREVENT_MEDIA_REMOVAL, *PPREVENT_MEDIA_REMOVAL;

///////////////////////////////////////////////////////
//                                                   //
// The following structures define disk performance  //
// statistics: specifically the locations of all the //
// reads and writes which have occured on the disk.  //
//                                                   //
// To use these structures, you must issue an IOCTL_ //
// DISK_HIST_STRUCTURE (with a DISK_HISTOGRAM) to    //
// obtain the basic histogram information. The       //
// number of buckets which must allocated is part of //
// this structure. Allocate the required number of   //
// buckets and call an IOCTL_DISK_HIST_DATA to fill  //
// in the data                                       //
//                                                   //
///////////////////////////////////////////////////////

#define HIST_NO_OF_BUCKETS	24

typedef struct _HISTOGRAM_BUCKET {
    DWORD 		Reads;
    DWORD		Writes;
} HISTOGRAM_BUCKET, *PHISTOGRAM_BUCKET;

#define HISTOGRAM_BUCKET_SIZE	sizeof(HISTOGRAM_BUCKET)

typedef struct _DISK_HISTOGRAM {
    LARGE_INTEGER	DiskSize;
    LARGE_INTEGER	Start;
    LARGE_INTEGER	End;
    LARGE_INTEGER	Average;
    LARGE_INTEGER	AverageRead;
    LARGE_INTEGER	AverageWrite;
    DWORD		Granularity;
    DWORD		Size;
    DWORD		ReadCount;
    DWORD		WriteCount;
    PHISTOGRAM_BUCKET	Histogram;
} DISK_HISTOGRAM, *PDISK_HISTOGRAM;

#define DISK_HISTOGRAM_SIZE	sizeof(DISK_HISTOGRAM)

///////////////////////////////////////////////////////
//                                                   //
// The following structures define disk debugging    //
// capabilities. The IOCTLs are directed to one of   //
// the two disk filter drivers.                      //
//                                                   //
// DISKPERF is a utilty for collecting disk request  //
// statistics.                                       //
//                                                   //
// SIMBAD is a utility for injecting faults in       //
// IO requests to disks.                             //
//                                                   //
///////////////////////////////////////////////////////

//
// The following structure is exchanged on an IOCTL_DISK_GET_PERFORMANCE
// request. This ioctl collects summary disk request statistics used
// in measuring performance.
//

typedef struct _DISK_PERFORMANCE {
        LARGE_INTEGER BytesRead;
        LARGE_INTEGER BytesWritten;
        LARGE_INTEGER ReadTime;
        LARGE_INTEGER WriteTime;
        DWORD ReadCount;
        DWORD WriteCount;
        DWORD QueueDepth;
} DISK_PERFORMANCE, *PDISK_PERFORMANCE;

//
// This structure defines the disk logging record. When disk logging
// is enabled, one of these is written to an internal buffer for each
// disk request.
//

typedef struct _DISK_RECORD {
   LARGE_INTEGER ByteOffset;
   LARGE_INTEGER StartTime;
   LARGE_INTEGER EndTime;
   PVOID VirtualAddress;
   DWORD NumberOfBytes;
   BYTE  DeviceNumber;
   BOOLEAN ReadRequest;
} DISK_RECORD, *PDISK_RECORD;

//
// The following structure is exchanged on an IOCTL_DISK_LOG request.
// Not all fields are valid with each function type.
//

typedef struct _DISK_LOGGING {
    BYTE  Function;
    PVOID BufferAddress;
    DWORD BufferSize;
} DISK_LOGGING, *PDISK_LOGGING;

//
// Disk logging functions
//
// Start disk logging. Only the Function and BufferSize fields are valid.
//

#define DISK_LOGGING_START    0

//
// Stop disk logging. Only the Function field is valid.
//

#define DISK_LOGGING_STOP     1

//
// Return disk log. All fields are valid. Data will be copied from internal
// buffer to buffer specified for the number of bytes requested.
//

#define DISK_LOGGING_DUMP     2

//
// DISK BINNING
//
// DISKPERF will keep counters for IO that falls in each of these ranges.
// The application determines the number and size of the ranges.
// Joe Lin wanted me to keep it flexible as possible, for instance, IO
// sizes are interesting in ranges like 0-4096, 4097-16384, 16385-65536, 65537+.
//

#define DISK_BINNING          3

//
// Bin types
//

typedef enum _BIN_TYPES {
    RequestSize,
    RequestLocation
} BIN_TYPES;

//
// Bin ranges
//

typedef struct _BIN_RANGE {
    LARGE_INTEGER StartValue;
    LARGE_INTEGER Length;
} BIN_RANGE, *PBIN_RANGE;

//
// Bin definition
//

typedef struct _PERF_BIN {
    DWORD NumberOfBins;
    DWORD TypeOfBin;
    BIN_RANGE BinsRanges[1];
} PERF_BIN, *PPERF_BIN ;

//
// Bin count
//

typedef struct _BIN_COUNT {
    BIN_RANGE BinRange;
    DWORD BinCount;
} BIN_COUNT, *PBIN_COUNT;

//
// Bin results
//

typedef struct _BIN_RESULTS {
    DWORD NumberOfBins;
    BIN_COUNT BinCounts[1];
} BIN_RESULTS, *PBIN_RESULTS;


#define IOCTL_SERIAL_LSRMST_INSERT      CTL_CODE(FILE_DEVICE_SERIAL_PORT,31,METHOD_BUFFERED,FILE_ANY_ACCESS)


//
// The following values follow the escape designator in the
// data stream if the LSRMST_INSERT mode has been turned on.
//
#define SERIAL_LSRMST_ESCAPE     ((BYTE )0x00)

//
// Following this value is the contents of the line status
// register, and then the character in the RX hardware when
// the line status register was encountered.
//
#define SERIAL_LSRMST_LSR_DATA   ((BYTE )0x01)

//
// Following this value is the contents of the line status
// register.  No error character follows
//
#define SERIAL_LSRMST_LSR_NODATA ((BYTE )0x02)

//
// Following this value is the contents of the modem status
// register.
//
#define SERIAL_LSRMST_MST        ((BYTE )0x03)

#define FSCTL_LOCK_VOLUME               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_UNLOCK_VOLUME             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DISMOUNT_VOLUME           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_MOUNT_DBLS_VOLUME         CTL_CODE(FILE_DEVICE_FILE_SYSTEM,13, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_GET_COMPRESSION           CTL_CODE(FILE_DEVICE_FILE_SYSTEM,15, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SET_COMPRESSION           CTL_CODE(FILE_DEVICE_FILE_SYSTEM,16, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA)
#define FSCTL_READ_COMPRESSION          CTL_CODE(FILE_DEVICE_FILE_SYSTEM,17, METHOD_NEITHER,  FILE_READ_DATA)
#define FSCTL_WRITE_COMPRESSION         CTL_CODE(FILE_DEVICE_FILE_SYSTEM,18, METHOD_NEITHER,  FILE_WRITE_DATA)

#endif // _WINIOCTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\winsock.h ===
/* WINSOCK.H--definitions to be used with the WINSOCK.DLL
 * Copyright (c) 1993-1995, Microsoft Corp. All rights reserved.
 *
 * This header file corresponds to version 1.1 of the Windows Sockets specification.
 *
 * This file includes parts which are Copyright (c) 1982-1986 Regents
 * of the University of California.  All rights reserved.  The
 * Berkeley Software License Agreement specifies the terms and
 * conditions for redistribution.
 *
 */

#ifndef _WINSOCKAPI_
#define _WINSOCKAPI_

/*
 * Pull in WINDOWS.H if necessary
 */
#ifndef _INC_WINDOWS
#include <windows.h>
#endif /* _INC_WINDOWS */

/*
 * Basic system type definitions, taken from the BSD file sys/types.h.
 */
typedef unsigned char   u_char;
typedef unsigned short  u_short;
typedef unsigned int    u_int;
typedef unsigned long   u_long;

/*
 * The new type to be used in all
 * instances which refer to sockets.
 */
typedef u_int           SOCKET;

/*
 * Select uses arrays of SOCKETs.  These macros manipulate such
 * arrays.  FD_SETSIZE may be defined by the user before including
 * this file, but the default here should be >= 64.
 *
 * CAVEAT IMPLEMENTOR and USER: THESE MACROS AND TYPES MUST BE
 * INCLUDED IN WINSOCK.H EXACTLY AS SHOWN HERE.
 */
#ifndef FD_SETSIZE
#define FD_SETSIZE      64
#endif /* FD_SETSIZE */

typedef struct fd_set {
        u_int   fd_count;               /* how many are SET? */
        SOCKET  fd_array[FD_SETSIZE];   /* an array of SOCKETs */
} fd_set;

#ifdef __cplusplus
extern "C" {
#endif

extern int PASCAL FAR __WSAFDIsSet(SOCKET, fd_set FAR *);

#ifdef __cplusplus
}
#endif


#define FD_CLR(fd, set) do { \
    u_int __i; \
    for (__i = 0; __i < ((fd_set FAR *)(set))->fd_count ; __i++) { \
        if (((fd_set FAR *)(set))->fd_array[__i] == fd) { \
            while (__i < ((fd_set FAR *)(set))->fd_count-1) { \
                ((fd_set FAR *)(set))->fd_array[__i] = \
                    ((fd_set FAR *)(set))->fd_array[__i+1]; \
                __i++; \
            } \
            ((fd_set FAR *)(set))->fd_count--; \
            break; \
        } \
    } \
} while(0)

#define FD_SET(fd, set) do { \
    if (((fd_set FAR *)(set))->fd_count < FD_SETSIZE) \
        ((fd_set FAR *)(set))->fd_array[((fd_set FAR *)(set))->fd_count++]=(fd);\
} while(0)

#define FD_ZERO(set) (((fd_set FAR *)(set))->fd_count=0)

#define FD_ISSET(fd, set) __WSAFDIsSet((SOCKET)(fd), (fd_set FAR *)(set))

/*
 * Structure used in select() call, taken from the BSD file sys/time.h.
 */
struct timeval {
        long    tv_sec;         /* seconds */
        long    tv_usec;        /* and microseconds */
};

/*
 * Operations on timevals.
 *
 * NB: timercmp does not work for >= or <=.
 */
#define timerisset(tvp)         ((tvp)->tv_sec || (tvp)->tv_usec)
#define timercmp(tvp, uvp, cmp) \
        ((tvp)->tv_sec cmp (uvp)->tv_sec || \
         (tvp)->tv_sec == (uvp)->tv_sec && (tvp)->tv_usec cmp (uvp)->tv_usec)
#define timerclear(tvp)         (tvp)->tv_sec = (tvp)->tv_usec = 0

/*
 * Commands for ioctlsocket(),  taken from the BSD file fcntl.h.
 *
 *
 * Ioctl's have the command encoded in the lower word,
 * and the size of any in or out parameters in the upper
 * word.  The high 2 bits of the upper word are used
 * to encode the in/out status of the parameter; for now
 * we restrict parameters to at most 128 bytes.
 */
#define IOCPARM_MASK    0x7f            /* parameters must be < 128 bytes */
#define IOC_VOID        0x20000000      /* no parameters */
#define IOC_OUT         0x40000000      /* copy out parameters */
#define IOC_IN          0x80000000      /* copy in parameters */
#define IOC_INOUT       (IOC_IN|IOC_OUT)
                                        /* 0x20000000 distinguishes new &
                                           old ioctl's */
#define _IO(x,y)        (IOC_VOID|((x)<<8)|(y))

#define _IOR(x,y,t)     (IOC_OUT|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

#define _IOW(x,y,t)     (IOC_IN|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

#define FIONREAD    _IOR('f', 127, u_long) /* get # bytes to read */
#define FIONBIO     _IOW('f', 126, u_long) /* set/clear non-blocking i/o */
#define FIOASYNC    _IOW('f', 125, u_long) /* set/clear async i/o */

/* Socket I/O Controls */
#define SIOCSHIWAT  _IOW('s',  0, u_long)  /* set high watermark */
#define SIOCGHIWAT  _IOR('s',  1, u_long)  /* get high watermark */
#define SIOCSLOWAT  _IOW('s',  2, u_long)  /* set low watermark */
#define SIOCGLOWAT  _IOR('s',  3, u_long)  /* get low watermark */
#define SIOCATMARK  _IOR('s',  7, u_long)  /* at oob mark? */

/*
 * Structures returned by network data base library, taken from the
 * BSD file netdb.h.  All addresses are supplied in host order, and
 * returned in network order (suitable for use in system calls).
 */

struct  hostent {
        char    FAR * h_name;           /* official name of host */
        char    FAR * FAR * h_aliases;  /* alias list */
        short   h_addrtype;             /* host address type */
        short   h_length;               /* length of address */
        char    FAR * FAR * h_addr_list; /* list of addresses */
#define h_addr  h_addr_list[0]          /* address, for backward compat */
};

/*
 * It is assumed here that a network number
 * fits in 32 bits.
 */
struct  netent {
        char    FAR * n_name;           /* official name of net */
        char    FAR * FAR * n_aliases;  /* alias list */
        short   n_addrtype;             /* net address type */
        u_long  n_net;                  /* network # */
};

struct  servent {
        char    FAR * s_name;           /* official service name */
        char    FAR * FAR * s_aliases;  /* alias list */
        short   s_port;                 /* port # */
        char    FAR * s_proto;          /* protocol to use */
};

struct  protoent {
        char    FAR * p_name;           /* official protocol name */
        char    FAR * FAR * p_aliases;  /* alias list */
        short   p_proto;                /* protocol # */
};

/*
 * Constants and structures defined by the internet system,
 * Per RFC 790, September 1981, taken from the BSD file netinet/in.h.
 */

/*
 * Protocols
 */
#define IPPROTO_IP              0               /* dummy for IP */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_GGP             2               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */
#define IPPROTO_IDP             22              /* xns idp */
#define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256

/*
 * Port/socket numbers: network standard functions
 */
#define IPPORT_ECHO             7
#define IPPORT_DISCARD          9
#define IPPORT_SYSTAT           11
#define IPPORT_DAYTIME          13
#define IPPORT_NETSTAT          15
#define IPPORT_FTP              21
#define IPPORT_TELNET           23
#define IPPORT_SMTP             25
#define IPPORT_TIMESERVER       37
#define IPPORT_NAMESERVER       42
#define IPPORT_WHOIS            43
#define IPPORT_MTP              57

/*
 * Port/socket numbers: host specific functions
 */
#define IPPORT_TFTP             69
#define IPPORT_RJE              77
#define IPPORT_FINGER           79
#define IPPORT_TTYLINK          87
#define IPPORT_SUPDUP           95

/*
 * UNIX TCP sockets
 */
#define IPPORT_EXECSERVER       512
#define IPPORT_LOGINSERVER      513
#define IPPORT_CMDSERVER        514
#define IPPORT_EFSSERVER        520

/*
 * UNIX UDP sockets
 */
#define IPPORT_BIFFUDP          512
#define IPPORT_WHOSERVER        513
#define IPPORT_ROUTESERVER      520
                                        /* 520+1 also used */

/*
 * Ports < IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).
 */
#define IPPORT_RESERVED         1024

/*
 * Link numbers
 */
#define IMPLINK_IP              155
#define IMPLINK_LOWEXPER        156
#define IMPLINK_HIGHEXPER       158

/*
 * Internet address (old style... should be updated)
 */
struct in_addr {
        union {
                struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { u_short s_w1,s_w2; } S_un_w;
                u_long S_addr;
        } S_un;
#define s_addr  S_un.S_addr
                                /* can be used for most tcp & ip code */
#define s_host  S_un.S_un_b.s_b2
                                /* host on imp */
#define s_net   S_un.S_un_b.s_b1
                                /* network */
#define s_imp   S_un.S_un_w.s_w2
                                /* imp */
#define s_impno S_un.S_un_b.s_b4
                                /* imp # */
#define s_lh    S_un.S_un_b.s_b3
                                /* logical host */
};

/*
 * Definitions of bits in internet address integers.
 * On subnets, the decomposition of addresses to host and net parts
 * is done according to subnet mask, not the masks here.
 */
#define IN_CLASSA(i)            (((long)(i) & 0x80000000) == 0)
#define IN_CLASSA_NET           0xff000000
#define IN_CLASSA_NSHIFT        24
#define IN_CLASSA_HOST          0x00ffffff
#define IN_CLASSA_MAX           128

#define IN_CLASSB(i)            (((long)(i) & 0xc0000000) == 0x80000000)
#define IN_CLASSB_NET           0xffff0000
#define IN_CLASSB_NSHIFT        16
#define IN_CLASSB_HOST          0x0000ffff
#define IN_CLASSB_MAX           65536

#define IN_CLASSC(i)            (((long)(i) & 0xe0000000) == 0xc0000000)
#define IN_CLASSC_NET           0xffffff00
#define IN_CLASSC_NSHIFT        8
#define IN_CLASSC_HOST          0x000000ff

#define INADDR_ANY              (u_long)0x00000000
#define INADDR_LOOPBACK         0x7f000001
#define INADDR_BROADCAST        (u_long)0xffffffff
#define INADDR_NONE             0xffffffff

/*
 * Socket address, internet style.
 */
struct sockaddr_in {
        short   sin_family;
        u_short sin_port;
        struct  in_addr sin_addr;
        char    sin_zero[8];
};

#define WSADESCRIPTION_LEN      256
#define WSASYS_STATUS_LEN       128

typedef struct WSAData {
        WORD                    wVersion;
        WORD                    wHighVersion;
        char                    szDescription[WSADESCRIPTION_LEN+1];
        char                    szSystemStatus[WSASYS_STATUS_LEN+1];
        unsigned short          iMaxSockets;
        unsigned short          iMaxUdpDg;
        char FAR *              lpVendorInfo;
} WSADATA;

typedef WSADATA FAR *LPWSADATA;

/*
 * Options for use with [gs]etsockopt at the IP level.
 */
#define IP_OPTIONS          1           /* set/get IP per-packet options    */
#define IP_MULTICAST_IF     2           /* set/get IP multicast interface   */
#define IP_MULTICAST_TTL    3           /* set/get IP multicast timetolive  */
#define IP_MULTICAST_LOOP   4           /* set/get IP multicast loopback    */
#define IP_ADD_MEMBERSHIP   5           /* add  an IP group membership      */
#define IP_DROP_MEMBERSHIP  6           /* drop an IP group membership      */

#define IP_DEFAULT_MULTICAST_TTL   1    /* normally limit m'casts to 1 hop  */
#define IP_DEFAULT_MULTICAST_LOOP  1    /* normally hear sends if a member  */
#define IP_MAX_MEMBERSHIPS         20   /* per socket; must fit in one mbuf */

/*
 * Argument structure for IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP.
 */
struct ip_mreq {
        struct in_addr  imr_multiaddr;  /* IP multicast address of group */
        struct in_addr  imr_interface;  /* local IP address of interface */
};

/*
 * Definitions related to sockets: types, address families, options,
 * taken from the BSD file sys/socket.h.
 */

/*
 * This is used instead of -1, since the
 * SOCKET type is unsigned.
 */
#define INVALID_SOCKET  (SOCKET)(~0)
#define SOCKET_ERROR            (-1)

/*
 * Types
 */
#define SOCK_STREAM     1               /* stream socket */
#define SOCK_DGRAM      2               /* datagram socket */
#define SOCK_RAW        3               /* raw-protocol interface */
#define SOCK_RDM        4               /* reliably-delivered message */
#define SOCK_SEQPACKET  5               /* sequenced packet stream */

/*
 * Option flags per-socket.
 */
#define SO_DEBUG        0x0001          /* turn on debugging info recording */
#define SO_ACCEPTCONN   0x0002          /* socket has had listen() */
#define SO_REUSEADDR    0x0004          /* allow local address reuse */
#define SO_KEEPALIVE    0x0008          /* keep connections alive */
#define SO_DONTROUTE    0x0010          /* just use interface addresses */
#define SO_BROADCAST    0x0020          /* permit sending of broadcast msgs */
#define SO_USELOOPBACK  0x0040          /* bypass hardware when possible */
#define SO_LINGER       0x0080          /* linger on close if data present */
#define SO_OOBINLINE    0x0100          /* leave received OOB data in line */

#define SO_DONTLINGER   (u_int)(~SO_LINGER)

/*
 * Additional options.
 */
#define SO_SNDBUF       0x1001          /* send buffer size */
#define SO_RCVBUF       0x1002          /* receive buffer size */
#define SO_SNDLOWAT     0x1003          /* send low-water mark */
#define SO_RCVLOWAT     0x1004          /* receive low-water mark */
#define SO_SNDTIMEO     0x1005          /* send timeout */
#define SO_RCVTIMEO     0x1006          /* receive timeout */
#define SO_ERROR        0x1007          /* get error status and clear */
#define SO_TYPE         0x1008          /* get socket type */

/*
 * Options for connect and disconnect data and options.  Used only by
 * non-TCP/IP transports such as DECNet, OSI TP4, etc.
 */
#define SO_CONNDATA     0x7000
#define SO_CONNOPT      0x7001
#define SO_DISCDATA     0x7002
#define SO_DISCOPT      0x7003
#define SO_CONNDATALEN  0x7004
#define SO_CONNOPTLEN   0x7005
#define SO_DISCDATALEN  0x7006
#define SO_DISCOPTLEN   0x7007

/*
 * Option for opening sockets for synchronous access.
 */
#define SO_OPENTYPE     0x7008

#define SO_SYNCHRONOUS_ALERT    0x10
#define SO_SYNCHRONOUS_NONALERT 0x20

/*
 * Other NT-specific options.
 */
#define SO_MAXDG        0x7009
#define SO_MAXPATHDG    0x700A

/*
 * TCP options.
 */
#define TCP_NODELAY     0x0001
#define TCP_BSDURGENT   0x7000

/*
 * Address families.
 */
#define AF_UNSPEC       0               /* unspecified */
#define AF_UNIX         1               /* local to host (pipes, portals) */
#define AF_INET         2               /* internetwork: UDP, TCP, etc. */
#define AF_IMPLINK      3               /* arpanet imp addresses */
#define AF_PUP          4               /* pup protocols: e.g. BSP */
#define AF_CHAOS        5               /* mit CHAOS protocols */
#define AF_IPX          6               /* IPX and SPX */
#define AF_NS           6               /* XEROX NS protocols */
#define AF_ISO          7               /* ISO protocols */
#define AF_OSI          AF_ISO          /* OSI is ISO */
#define AF_ECMA         8               /* european computer manufacturers */
#define AF_DATAKIT      9               /* datakit protocols */
#define AF_CCITT        10              /* CCITT protocols, X.25 etc */
#define AF_SNA          11              /* IBM SNA */
#define AF_DECnet       12              /* DECnet */
#define AF_DLI          13              /* Direct data link interface */
#define AF_LAT          14              /* LAT */
#define AF_HYLINK       15              /* NSC Hyperchannel */
#define AF_APPLETALK    16              /* AppleTalk */
#define AF_NETBIOS      17              /* NetBios-style addresses */
#define AF_VOICEVIEW    18              /* VoiceView */

#define AF_MAX          19

/*
 * Structure used by kernel to store most
 * addresses.
 */
struct sockaddr {
        u_short sa_family;              /* address family */
        char    sa_data[14];            /* up to 14 bytes of direct address */
};

/*
 * Structure used by kernel to pass protocol
 * information in raw sockets.
 */
struct sockproto {
        u_short sp_family;              /* address family */
        u_short sp_protocol;            /* protocol */
};

/*
 * Protocol families, same as address families for now.
 */
#define PF_UNSPEC       AF_UNSPEC
#define PF_UNIX         AF_UNIX
#define PF_INET         AF_INET
#define PF_IMPLINK      AF_IMPLINK
#define PF_PUP          AF_PUP
#define PF_CHAOS        AF_CHAOS
#define PF_NS           AF_NS
#define PF_IPX          AF_IPX
#define PF_ISO          AF_ISO
#define PF_OSI          AF_OSI
#define PF_ECMA         AF_ECMA
#define PF_DATAKIT      AF_DATAKIT
#define PF_CCITT        AF_CCITT
#define PF_SNA          AF_SNA
#define PF_DECnet       AF_DECnet
#define PF_DLI          AF_DLI
#define PF_LAT          AF_LAT
#define PF_HYLINK       AF_HYLINK
#define PF_APPLETALK    AF_APPLETALK
#define PF_VOICEVIEW    AF_VOICEVIEW

#define PF_MAX          AF_MAX

/*
 * Structure used for manipulating linger option.
 */
struct  linger {
        u_short l_onoff;                /* option on/off */
        u_short l_linger;               /* linger time */
};

/*
 * Level number for (get/set)sockopt() to apply to socket itself.
 */
#define SOL_SOCKET      0xffff          /* options for socket level */

/*
 * Maximum queue length specifiable by listen.
 */
#define SOMAXCONN       5

#define MSG_OOB         0x1             /* process out-of-band data */
#define MSG_PEEK        0x2             /* peek at incoming message */
#define MSG_DONTROUTE   0x4             /* send without using routing tables */

#define MSG_MAXIOVLEN   16

#define MSG_PARTIAL     0x8000          /* partial send or recv for message xport */

/*
 * Define constant based on rfc883, used by gethostbyxxxx() calls.
 */
#define MAXGETHOSTSTRUCT        1024

/*
 * Define flags to be used with the WSAAsyncSelect() call.
 */
#define FD_READ         0x01
#define FD_WRITE        0x02
#define FD_OOB          0x04
#define FD_ACCEPT       0x08
#define FD_CONNECT      0x10
#define FD_CLOSE        0x20

/*
 * All Windows Sockets error constants are biased by WSABASEERR from
 * the "normal"
 */
#define WSABASEERR              10000
/*
 * Windows Sockets definitions of regular Microsoft C error constants
 */
#define WSAEINTR                (WSABASEERR+4)
#define WSAEBADF                (WSABASEERR+9)
#define WSAEACCES               (WSABASEERR+13)
#define WSAEFAULT               (WSABASEERR+14)
#define WSAEINVAL               (WSABASEERR+22)
#define WSAEMFILE               (WSABASEERR+24)

/*
 * Windows Sockets definitions of regular Berkeley error constants
 */
#define WSAEWOULDBLOCK          (WSABASEERR+35)
#define WSAEINPROGRESS          (WSABASEERR+36)
#define WSAEALREADY             (WSABASEERR+37)
#define WSAENOTSOCK             (WSABASEERR+38)
#define WSAEDESTADDRREQ         (WSABASEERR+39)
#define WSAEMSGSIZE             (WSABASEERR+40)
#define WSAEPROTOTYPE           (WSABASEERR+41)
#define WSAENOPROTOOPT          (WSABASEERR+42)
#define WSAEPROTONOSUPPORT      (WSABASEERR+43)
#define WSAESOCKTNOSUPPORT      (WSABASEERR+44)
#define WSAEOPNOTSUPP           (WSABASEERR+45)
#define WSAEPFNOSUPPORT         (WSABASEERR+46)
#define WSAEAFNOSUPPORT         (WSABASEERR+47)
#define WSAEADDRINUSE           (WSABASEERR+48)
#define WSAEADDRNOTAVAIL        (WSABASEERR+49)
#define WSAENETDOWN             (WSABASEERR+50)
#define WSAENETUNREACH          (WSABASEERR+51)
#define WSAENETRESET            (WSABASEERR+52)
#define WSAECONNABORTED         (WSABASEERR+53)
#define WSAECONNRESET           (WSABASEERR+54)
#define WSAENOBUFS              (WSABASEERR+55)
#define WSAEISCONN              (WSABASEERR+56)
#define WSAENOTCONN             (WSABASEERR+57)
#define WSAESHUTDOWN            (WSABASEERR+58)
#define WSAETOOMANYREFS         (WSABASEERR+59)
#define WSAETIMEDOUT            (WSABASEERR+60)
#define WSAECONNREFUSED         (WSABASEERR+61)
#define WSAELOOP                (WSABASEERR+62)
#define WSAENAMETOOLONG         (WSABASEERR+63)
#define WSAEHOSTDOWN            (WSABASEERR+64)
#define WSAEHOSTUNREACH         (WSABASEERR+65)
#define WSAENOTEMPTY            (WSABASEERR+66)
#define WSAEPROCLIM             (WSABASEERR+67)
#define WSAEUSERS               (WSABASEERR+68)
#define WSAEDQUOT               (WSABASEERR+69)
#define WSAESTALE               (WSABASEERR+70)
#define WSAEREMOTE              (WSABASEERR+71)

#define WSAEDISCON              (WSABASEERR+101)

/*
 * Extended Windows Sockets error constant definitions
 */
#define WSASYSNOTREADY          (WSABASEERR+91)
#define WSAVERNOTSUPPORTED      (WSABASEERR+92)
#define WSANOTINITIALISED       (WSABASEERR+93)

/*
 * Error return codes from gethostbyname() and gethostbyaddr()
 * (when using the resolver). Note that these errors are
 * retrieved via WSAGetLastError() and must therefore follow
 * the rules for avoiding clashes with error numbers from
 * specific implementations or language run-time systems.
 * For this reason the codes are based at WSABASEERR+1001.
 * Note also that [WSA]NO_ADDRESS is defined only for
 * compatibility purposes.
 */

#define h_errno         WSAGetLastError()

/* Authoritative Answer: Host not found */
#define WSAHOST_NOT_FOUND       (WSABASEERR+1001)
#define HOST_NOT_FOUND          WSAHOST_NOT_FOUND

/* Non-Authoritative: Host not found, or SERVERFAIL */
#define WSATRY_AGAIN            (WSABASEERR+1002)
#define TRY_AGAIN               WSATRY_AGAIN

/* Non recoverable errors, FORMERR, REFUSED, NOTIMP */
#define WSANO_RECOVERY          (WSABASEERR+1003)
#define NO_RECOVERY             WSANO_RECOVERY

/* Valid name, no data record of requested type */
#define WSANO_DATA              (WSABASEERR+1004)
#define NO_DATA                 WSANO_DATA

/* no address, look for MX record */
#define WSANO_ADDRESS           WSANO_DATA
#define NO_ADDRESS              WSANO_ADDRESS

/*
 * Windows Sockets errors redefined as regular Berkeley error constants.
 * These are commented out in Windows NT to avoid conflicts with errno.h.
 * Use the WSA constants instead.
 */
#if 0
#define EWOULDBLOCK             WSAEWOULDBLOCK
#define EINPROGRESS             WSAEINPROGRESS
#define EALREADY                WSAEALREADY
#define ENOTSOCK                WSAENOTSOCK
#define EDESTADDRREQ            WSAEDESTADDRREQ
#define EMSGSIZE                WSAEMSGSIZE
#define EPROTOTYPE              WSAEPROTOTYPE
#define ENOPROTOOPT             WSAENOPROTOOPT
#define EPROTONOSUPPORT         WSAEPROTONOSUPPORT
#define ESOCKTNOSUPPORT         WSAESOCKTNOSUPPORT
#define EOPNOTSUPP              WSAEOPNOTSUPP
#define EPFNOSUPPORT            WSAEPFNOSUPPORT
#define EAFNOSUPPORT            WSAEAFNOSUPPORT
#define EADDRINUSE              WSAEADDRINUSE
#define EADDRNOTAVAIL           WSAEADDRNOTAVAIL
#define ENETDOWN                WSAENETDOWN
#define ENETUNREACH             WSAENETUNREACH
#define ENETRESET               WSAENETRESET
#define ECONNABORTED            WSAECONNABORTED
#define ECONNRESET              WSAECONNRESET
#define ENOBUFS                 WSAENOBUFS
#define EISCONN                 WSAEISCONN
#define ENOTCONN                WSAENOTCONN
#define ESHUTDOWN               WSAESHUTDOWN
#define ETOOMANYREFS            WSAETOOMANYREFS
#define ETIMEDOUT               WSAETIMEDOUT
#define ECONNREFUSED            WSAECONNREFUSED
#define ELOOP                   WSAELOOP
#define ENAMETOOLONG            WSAENAMETOOLONG
#define EHOSTDOWN               WSAEHOSTDOWN
#define EHOSTUNREACH            WSAEHOSTUNREACH
#define ENOTEMPTY               WSAENOTEMPTY
#define EPROCLIM                WSAEPROCLIM
#define EUSERS                  WSAEUSERS
#define EDQUOT                  WSAEDQUOT
#define ESTALE                  WSAESTALE
#define EREMOTE                 WSAEREMOTE
#endif

/* Socket function prototypes */

#ifdef __cplusplus
extern "C" {
#endif

SOCKET PASCAL FAR accept (SOCKET s, struct sockaddr FAR *addr,
                          int FAR *addrlen);

int PASCAL FAR bind (SOCKET s, const struct sockaddr FAR *addr, int namelen);

int PASCAL FAR closesocket (SOCKET s);

int PASCAL FAR connect (SOCKET s, const struct sockaddr FAR *name, int namelen);

int PASCAL FAR ioctlsocket (SOCKET s, long cmd, u_long FAR *argp);

int PASCAL FAR getpeername (SOCKET s, struct sockaddr FAR *name,
                            int FAR * namelen);

int PASCAL FAR getsockname (SOCKET s, struct sockaddr FAR *name,
                            int FAR * namelen);

int PASCAL FAR getsockopt (SOCKET s, int level, int optname,
                           char FAR * optval, int FAR *optlen);

u_long PASCAL FAR htonl (u_long hostlong);

u_short PASCAL FAR htons (u_short hostshort);

unsigned long PASCAL FAR inet_addr (const char FAR * cp);

char FAR * PASCAL FAR inet_ntoa (struct in_addr in);

int PASCAL FAR listen (SOCKET s, int backlog);

u_long PASCAL FAR ntohl (u_long netlong);

u_short PASCAL FAR ntohs (u_short netshort);

int PASCAL FAR recv (SOCKET s, char FAR * buf, int len, int flags);

int PASCAL FAR recvfrom (SOCKET s, char FAR * buf, int len, int flags,
                         struct sockaddr FAR *from, int FAR * fromlen);

int PASCAL FAR select (int nfds, fd_set FAR *readfds, fd_set FAR *writefds,
                       fd_set FAR *exceptfds, const struct timeval FAR *timeout);

int PASCAL FAR send (SOCKET s, const char FAR * buf, int len, int flags);

int PASCAL FAR sendto (SOCKET s, const char FAR * buf, int len, int flags,
                       const struct sockaddr FAR *to, int tolen);

int PASCAL FAR setsockopt (SOCKET s, int level, int optname,
                           const char FAR * optval, int optlen);

int PASCAL FAR shutdown (SOCKET s, int how);

SOCKET PASCAL FAR socket (int af, int type, int protocol);

/* Database function prototypes */

struct hostent FAR * PASCAL FAR gethostbyaddr(const char FAR * addr,
                                              int len, int type);

struct hostent FAR * PASCAL FAR gethostbyname(const char FAR * name);

int PASCAL FAR gethostname (char FAR * name, int namelen);

struct servent FAR * PASCAL FAR getservbyport(int port, const char FAR * proto);

struct servent FAR * PASCAL FAR getservbyname(const char FAR * name,
                                              const char FAR * proto);

struct protoent FAR * PASCAL FAR getprotobynumber(int proto);

struct protoent FAR * PASCAL FAR getprotobyname(const char FAR * name);

/* Microsoft Windows Extension function prototypes */

int PASCAL FAR WSAStartup(WORD wVersionRequired, LPWSADATA lpWSAData);

int PASCAL FAR WSACleanup(void);

void PASCAL FAR WSASetLastError(int iError);

int PASCAL FAR WSAGetLastError(void);

BOOL PASCAL FAR WSAIsBlocking(void);

int PASCAL FAR WSAUnhookBlockingHook(void);

FARPROC PASCAL FAR WSASetBlockingHook(FARPROC lpBlockFunc);

int PASCAL FAR WSACancelBlockingCall(void);

HANDLE PASCAL FAR WSAAsyncGetServByName(HWND hWnd, u_int wMsg,
                                        const char FAR * name,
                                        const char FAR * proto,
                                        char FAR * buf, int buflen);

HANDLE PASCAL FAR WSAAsyncGetServByPort(HWND hWnd, u_int wMsg, int port,
                                        const char FAR * proto, char FAR * buf,
                                        int buflen);

HANDLE PASCAL FAR WSAAsyncGetProtoByName(HWND hWnd, u_int wMsg,
                                         const char FAR * name, char FAR * buf,
                                         int buflen);

HANDLE PASCAL FAR WSAAsyncGetProtoByNumber(HWND hWnd, u_int wMsg,
                                           int number, char FAR * buf,
                                           int buflen);

HANDLE PASCAL FAR WSAAsyncGetHostByName(HWND hWnd, u_int wMsg,
                                        const char FAR * name, char FAR * buf,
                                        int buflen);

HANDLE PASCAL FAR WSAAsyncGetHostByAddr(HWND hWnd, u_int wMsg,
                                        const char FAR * addr, int len, int type,
                                        char FAR * buf, int buflen);

int PASCAL FAR WSACancelAsyncRequest(HANDLE hAsyncTaskHandle);

int PASCAL FAR WSAAsyncSelect(SOCKET s, HWND hWnd, u_int wMsg,
                               long lEvent);

int PASCAL FAR WSARecvEx (SOCKET s, char FAR * buf, int len, int FAR *flags);

typedef struct _TRANSMIT_FILE_BUFFERS {
    PVOID Head;
    DWORD HeadLength;
    PVOID Tail;
    DWORD TailLength;
} TRANSMIT_FILE_BUFFERS, *PTRANSMIT_FILE_BUFFERS, *LPTRANSMIT_FILE_BUFFERS;

BOOL
PASCAL FAR
TransmitFile (
    IN SOCKET hSocket,
    IN HANDLE hFile,
    IN DWORD nNumberOfBytesToWrite,
    IN DWORD nNumberOfBytesPerSend,
    IN LPOVERLAPPED lpOverlapped,
    IN LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,
    IN DWORD dwReserved
    );

#ifdef __cplusplus
}
#endif

/* Microsoft Windows Extended data types */
typedef struct sockaddr SOCKADDR;
typedef struct sockaddr *PSOCKADDR;
typedef struct sockaddr FAR *LPSOCKADDR;

typedef struct sockaddr_in SOCKADDR_IN;
typedef struct sockaddr_in *PSOCKADDR_IN;
typedef struct sockaddr_in FAR *LPSOCKADDR_IN;

typedef struct linger LINGER;
typedef struct linger *PLINGER;
typedef struct linger FAR *LPLINGER;

typedef struct in_addr IN_ADDR;
typedef struct in_addr *PIN_ADDR;
typedef struct in_addr FAR *LPIN_ADDR;

typedef struct fd_set FD_SET;
typedef struct fd_set *PFD_SET;
typedef struct fd_set FAR *LPFD_SET;

typedef struct hostent HOSTENT;
typedef struct hostent *PHOSTENT;
typedef struct hostent FAR *LPHOSTENT;

typedef struct servent SERVENT;
typedef struct servent *PSERVENT;
typedef struct servent FAR *LPSERVENT;

typedef struct protoent PROTOENT;
typedef struct protoent *PPROTOENT;
typedef struct protoent FAR *LPPROTOENT;

typedef struct timeval TIMEVAL;
typedef struct timeval *PTIMEVAL;
typedef struct timeval FAR *LPTIMEVAL;

/*
 * Windows message parameter composition and decomposition
 * macros.
 *
 * WSAMAKEASYNCREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to a WSAAsyncGetXByY() routine.
 */
#define WSAMAKEASYNCREPLY(buflen,error)     MAKELONG(buflen,error)
/*
 * WSAMAKESELECTREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to WSAAsyncSelect().
 */
#define WSAMAKESELECTREPLY(event,error)     MAKELONG(event,error)
/*
 * WSAGETASYNCBUFLEN is intended for use by the Windows Sockets application
 * to extract the buffer length from the lParam in the response
 * to a WSAGetXByY().
 */
#define WSAGETASYNCBUFLEN(lParam)           LOWORD(lParam)
/*
 * WSAGETASYNCERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAGetXByY().
 */
#define WSAGETASYNCERROR(lParam)            HIWORD(lParam)
/*
 * WSAGETSELECTEVENT is intended for use by the Windows Sockets application
 * to extract the event code from the lParam in the response
 * to a WSAAsyncSelect().
 */
#define WSAGETSELECTEVENT(lParam)           LOWORD(lParam)
/*
 * WSAGETSELECTERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAAsyncSelect().
 */
#define WSAGETSELECTERROR(lParam)           HIWORD(lParam)

#endif  /* _WINSOCKAPI_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\winperf.h ===
/*++

Copyright (C) 1993 - 1995 Microsoft Corporation

Module Name:

    winperf.h

Abstract:

    Header file for the Performance Monitor data.

    This file contains the definitions of the data structures returned
    by the Configuration Registry in response to a request for
    performance data.  This file is used by both the Configuration
    Registry and the Performance Monitor to define their interface.
    The complete interface is described here, except for the name
    of the node to query in the registry.  It is

                   HKEY_PERFORMANCE_DATA.

    By querying that node with a subkey of "Global" the caller will
    retrieve the structures described here.

    There is no need to RegOpenKey() the reserved handle HKEY_PERFORMANCE_DATA,
    but the caller should RegCloseKey() the handle so that network transports
    and drivers can be removed or installed (which cannot happen while
    they are open for monitoring.)  Remote requests must first
    RegConnectRegistry().

--*/

#ifndef _WINPERF_
#define _WINPERF_

//  Data structure definitions.

//  In order for data to be returned through the Configuration Registry
//  in a system-independent fashion, it must be self-describing.

//  In the following, all offsets are in bytes.

//
//  Data is returned through the Configuration Registry in a
//  a data block which begins with a _PERF_DATA_BLOCK structure.
//

#define PERF_DATA_VERSION   1
#define PERF_DATA_REVISION  1


typedef struct _PERF_DATA_BLOCK {
    WCHAR           Signature[4];       // Signature: Unicode "PERF"
    DWORD           LittleEndian;       // 0 = Big Endian, 1 = Little Endian
    DWORD           Version;            // Version of these data structures
                                        // starting at 1
    DWORD           Revision;           // Revision of these data structures
                                        // starting at 0 for each Version
    DWORD           TotalByteLength;    // Total length of data block
    DWORD           HeaderLength;       // Length of this structure
    DWORD           NumObjectTypes;     // Number of types of objects
                                        // being reported
    LONG            DefaultObject;      // Object Title Index of default
                                        // object to display when data from
                                        // this system is retrieved (-1 =
                                        // none, but this is not expected to
                                        // be used)
    SYSTEMTIME      SystemTime;         // Time at the system under
                                        // measurement
    LARGE_INTEGER   PerfTime;           // Performance counter value
                                        // at the system under measurement
    LARGE_INTEGER   PerfFreq;           // Performance counter frequency
                                        // at the system under measurement
    LARGE_INTEGER   PerfTime100nSec;    // Performance counter time in 100 nsec
                                        // units at the system under measurement
    DWORD           SystemNameLength;   // Length of the system name
    DWORD           SystemNameOffset;   // Offset, from beginning of this
                                        // structure, to name of system
                                        // being measured
} PERF_DATA_BLOCK, *PPERF_DATA_BLOCK;


//
//  The _PERF_DATA_BLOCK structure is followed by NumObjectTypes of
//  data sections, one for each type of object measured.  Each object
//  type section begins with a _PERF_OBJECT_TYPE structure.
//


typedef struct _PERF_OBJECT_TYPE {
    DWORD           TotalByteLength;    // Length of this object definition
                                        // including this structure, the
                                        // counter definitions, and the
                                        // instance definitions and the
                                        // counter blocks for each instance:
                                        // This is the offset from this
                                        // structure to the next object, if
                                        // any
    DWORD           DefinitionLength;   // Length of object definition,
                                        // which includes this structure
                                        // and the counter definition
                                        // structures for this object: this
                                        // is the offset of the first
                                        // instance or of the counters
                                        // for this object if there is
                                        // no instance
    DWORD           HeaderLength;       // Length of this structure: this
                                        // is the offset to the first
                                        // counter definition for this
                                        // object
    DWORD           ObjectNameTitleIndex;
                                        // Index to name in Title Database
    LPWSTR          ObjectNameTitle;    // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
    DWORD           ObjectHelpTitleIndex;
                                        // Index to Help in Title Database
    LPWSTR          ObjectHelpTitle;    // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
    DWORD           DetailLevel;        // Object level of detail (for
                                        // controlling display complexity);
                                        // will be min of detail levels
                                        // for all this object's counters
    DWORD           NumCounters;        // Number of counters in each
                                        // counter block (one counter
                                        // block per instance)
    LONG            DefaultCounter;     // Default counter to display when
                                        // this object is selected, index
                                        // starting at 0 (-1 = none, but
                                        // this is not expected to be used)
    LONG            NumInstances;       // Number of object instances
                                        // for which counters are being
                                        // returned from the system under
                                        // measurement. If the object defined
                                        // will never have any instance data
                                        // structures (PERF_INSTANCE_DEFINITION)
                                        // then this value should be -1, if the
                                        // object can have 0 or more instances,
                                        // but has none present, then this
                                        // should be 0, otherwise this field
                                        // contains the number of instances of
                                        // this counter.
    DWORD           CodePage;           // 0 if instance strings are in
                                        // UNICODE, else the Code Page of
                                        // the instance names
    LARGE_INTEGER   PerfTime;           // Sample Time in "Object" units
                                        //
    LARGE_INTEGER   PerfFreq;           // Frequency of "Object" units in
                                        // counts per second.
} PERF_OBJECT_TYPE, *PPERF_OBJECT_TYPE;

#define PERF_NO_INSTANCES           -1  // no instances (see NumInstances above)
//
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//
//  PERF_COUNTER_DEFINITION.CounterType field values
//
//
//        Counter ID Field Definition:
//
//   3      2        2    2    2        1        1    1
//   1      8        4    2    0        6        2    0    8                0
//  +--------+--------+----+----+--------+--------+----+----+----------------+
//  |Display |Calculation  |Time|Counter |        |Ctr |Size|                |
//  |Flags   |Modifiers    |Base|SubType |Reserved|Type|Fld |   Reserved     |
//  +--------+--------+----+----+--------+--------+----+----+----------------+
//
//
//  The counter type is the "or" of the following values as described below
//
//  select one of the following to indicate the counter's data size
//
#define PERF_SIZE_DWORD         0x00000000
#define PERF_SIZE_LARGE         0x00000100
#define PERF_SIZE_ZERO          0x00000200  // for Zero Length fields
#define PERF_SIZE_VARIABLE_LEN  0x00000300  // length is in CounterLength field
                                            //  of Counter Definition struct
//
//  select one of the following values to indicate the counter field usage
//
#define PERF_TYPE_NUMBER        0x00000000  // a number (not a counter)
#define PERF_TYPE_COUNTER       0x00000400  // an increasing numeric value
#define PERF_TYPE_TEXT          0x00000800  // a text field
#define PERF_TYPE_ZERO          0x00000C00  // displays a zero
//
//  If the PERF_TYPE_NUMBER field was selected, then select one of the
//  following to describe the Number
//
#define PERF_NUMBER_HEX         0x00000000  // display as HEX value
#define PERF_NUMBER_DECIMAL     0x00010000  // display as a decimal integer
#define PERF_NUMBER_DEC_1000    0x00020000  // display as a decimal/1000
//
//  If the PERF_TYPE_COUNTER value was selected then select one of the
//  following to indicate the type of counter
//
#define PERF_COUNTER_VALUE      0x00000000  // display counter value
#define PERF_COUNTER_RATE       0x00010000  // divide ctr / delta time
#define PERF_COUNTER_FRACTION   0x00020000  // divide ctr / base
#define PERF_COUNTER_BASE       0x00030000  // base value used in fractions
#define PERF_COUNTER_ELAPSED    0x00040000  // subtract counter from current time
#define PERF_COUNTER_QUEUELEN   0x00050000  // Use Queuelen processing func.
#define PERF_COUNTER_HISTOGRAM  0x00060000  // Counter begins or ends a histogram
//
//  If the PERF_TYPE_TEXT value was selected, then select one of the
//  following to indicate the type of TEXT data.
//
#define PERF_TEXT_UNICODE       0x00000000  // type of text in text field
#define PERF_TEXT_ASCII         0x00010000  // ASCII using the CodePage field
//
//  Timer SubTypes
//
#define PERF_TIMER_TICK         0x00000000  // use system perf. freq for base
#define PERF_TIMER_100NS        0x00100000  // use 100 NS timer time base units
#define PERF_OBJECT_TIMER       0x00200000  // use the object timer freq
//
//  Any types that have calculations performed can use one or more of
//  the following calculation modification flags listed here
//
#define PERF_DELTA_COUNTER      0x00400000  // compute difference first
#define PERF_DELTA_BASE         0x00800000  // compute base diff as well
#define PERF_INVERSE_COUNTER    0x01000000  // show as 1.00-value (assumes:
#define PERF_MULTI_COUNTER      0x02000000  // sum of multiple instances
//
//  Select one of the following values to indicate the display suffix (if any)
//
#define PERF_DISPLAY_NO_SUFFIX  0x00000000  // no suffix
#define PERF_DISPLAY_PER_SEC    0x10000000  // "/sec"
#define PERF_DISPLAY_PERCENT    0x20000000  // "%"
#define PERF_DISPLAY_SECONDS    0x30000000  // "secs"
#define PERF_DISPLAY_NOSHOW     0x40000000  // value is not displayed
//
//  Predefined counter types
//

// 32-bit Counter.  Divide delta by delta time.  Display suffix: "/sec"
#define PERF_COUNTER_COUNTER        \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_PER_SEC)


// 64-bit Timer.  Divide delta by delta time.  Display suffix: "%"
#define PERF_COUNTER_TIMER          \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_PERCENT)

// Queue Length Space-Time Product. Divide delta by delta time. No Display Suffix.
#define PERF_COUNTER_QUEUELEN_TYPE  \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_QUEUELEN |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)

// 64-bit Counter.  Divide delta by delta time. Display Suffix: "/sec"
#define PERF_COUNTER_BULK_COUNT     \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_PER_SEC)

// Indicates the counter is not a  counter but rather Unicode text Display as text.
#define PERF_COUNTER_TEXT           \
            (PERF_SIZE_VARIABLE_LEN | PERF_TYPE_TEXT | PERF_TEXT_UNICODE |\
            PERF_DISPLAY_NO_SUFFIX)

// Indicates the data is a counter  which should not be
// time averaged on display (such as an error counter on a serial line)
// Display as is.  No Display Suffix.
#define PERF_COUNTER_RAWCOUNT       \
            (PERF_SIZE_DWORD | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL |\
            PERF_DISPLAY_NO_SUFFIX)

// Same as PERF_COUNTER_RAWCOUNT except its size is a large integer
#define PERF_COUNTER_LARGE_RAWCOUNT       \
            (PERF_SIZE_LARGE | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL |\
            PERF_DISPLAY_NO_SUFFIX)

// Special case for RAWCOUNT that want to be displayed in hex
// Indicates the data is a counter  which should not be
// time averaged on display (such as an error counter on a serial line)
// Display as is.  No Display Suffix.
#define PERF_COUNTER_RAWCOUNT_HEX       \
            (PERF_SIZE_DWORD | PERF_TYPE_NUMBER | PERF_NUMBER_HEX |\
            PERF_DISPLAY_NO_SUFFIX)

// Same as PERF_COUNTER_RAWCOUNT_HEX except its size is a large integer
#define PERF_COUNTER_LARGE_RAWCOUNT_HEX       \
            (PERF_SIZE_LARGE | PERF_TYPE_NUMBER | PERF_NUMBER_HEX |\
            PERF_DISPLAY_NO_SUFFIX)


// A count which is either 1 or 0 on each sampling interrupt (% busy)
// Divide delta by delta base. Display Suffix: "%"
#define PERF_SAMPLE_FRACTION        \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION |\
            PERF_DELTA_COUNTER | PERF_DELTA_BASE | PERF_DISPLAY_PERCENT)

// A count which is sampled on each sampling interrupt (queue length)
// Divide delta by delta time. No Display Suffix.
#define PERF_SAMPLE_COUNTER         \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)

// A label: no data is associated with this counter (it has 0 length)
// Do not display.
#define PERF_COUNTER_NODATA         \
            (PERF_SIZE_ZERO | PERF_DISPLAY_NOSHOW)

// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 - delta divided by delta time.  Display suffix: "%"
#define PERF_COUNTER_TIMER_INV      \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_INVERSE_COUNTER | \
            PERF_DISPLAY_PERCENT)

// The divisor for a sample, used with the previous counter to form a
// sampled %.  You must check for >0 before dividing by this!  This
// counter will directly follow the  numerator counter.  It should not
// be displayed to the user.
#define PERF_SAMPLE_BASE            \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_DISPLAY_NOSHOW |\
            0x00000001)  // for compatibility with pre-beta versions

// A timer which, when divided by an average base, produces a time
// in seconds which is the average time of some operation.  This
// timer times total operations, and  the base is the number of opera-
// tions.  Display Suffix: "sec"
#define PERF_AVERAGE_TIMER          \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION |\
            PERF_DISPLAY_SECONDS)

// Used as the denominator in the computation of time or count
// averages.  Must directly follow the numerator counter.  Not dis-
// played to the user.
#define PERF_AVERAGE_BASE           \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_DISPLAY_NOSHOW |\
            0x00000002)  // for compatibility with pre-beta versions


// A bulk count which, when divided (typically) by the number of
// operations, gives (typically) the number of bytes per operation.
// No Display Suffix.
#define PERF_AVERAGE_BULK           \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION  |\
            PERF_DISPLAY_NOSHOW)

// 64-bit Timer in 100 nsec units. Display delta divided by
// delta time.  Display suffix: "%"
#define PERF_100NSEC_TIMER          \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_100NS | PERF_DELTA_COUNTER | PERF_DISPLAY_PERCENT)

// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 - delta divided by delta time.  Display suffix: "%"
#define PERF_100NSEC_TIMER_INV      \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_100NS | PERF_DELTA_COUNTER | PERF_INVERSE_COUNTER  |\
            PERF_DISPLAY_PERCENT)

// 64-bit Timer.  Divide delta by delta time.  Display suffix: "%"
// Timer for multiple instances, so result can exceed 100%.
#define PERF_COUNTER_MULTI_TIMER    \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_DELTA_COUNTER | PERF_TIMER_TICK | PERF_MULTI_COUNTER |\
            PERF_DISPLAY_PERCENT)

// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 * _MULTI_BASE - delta divided by delta time.
// Display suffix: "%" Timer for multiple instances, so result
// can exceed 100%.  Followed by a counter of type _MULTI_BASE.
#define PERF_COUNTER_MULTI_TIMER_INV \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_DELTA_COUNTER | PERF_MULTI_COUNTER | PERF_TIMER_TICK |\
            PERF_INVERSE_COUNTER | PERF_DISPLAY_PERCENT)

// Number of instances to which the preceding _MULTI_..._INV counter
// applies.  Used as a factor to get the percentage.
#define PERF_COUNTER_MULTI_BASE     \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_MULTI_COUNTER | PERF_DISPLAY_NOSHOW)

// 64-bit Timer in 100 nsec units. Display delta divided by delta time.
// Display suffix: "%" Timer for multiple instances, so result can exceed 100%.
#define PERF_100NSEC_MULTI_TIMER   \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_DELTA_COUNTER  |\
            PERF_COUNTER_RATE | PERF_TIMER_100NS | PERF_MULTI_COUNTER |\
            PERF_DISPLAY_PERCENT)

// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 * _MULTI_BASE - delta divided by delta time.
// Display suffix: "%" Timer for multiple instances, so result
// can exceed 100%.  Followed by a counter of type _MULTI_BASE.
#define PERF_100NSEC_MULTI_TIMER_INV \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_DELTA_COUNTER  |\
            PERF_COUNTER_RATE | PERF_TIMER_100NS | PERF_MULTI_COUNTER |\
            PERF_INVERSE_COUNTER | PERF_DISPLAY_PERCENT)

// Indicates the data is a fraction of the following counter  which
// should not be time averaged on display (such as free space over
// total space.) Display as is.  Display the quotient as "%".
#define PERF_RAW_FRACTION           \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION |\
            PERF_DISPLAY_PERCENT)

// Indicates the data is a base for the preceding counter which should
// not be time averaged on display (such as free space over total space.)
#define PERF_RAW_BASE               \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_DISPLAY_NOSHOW |\
            0x00000003)  // for compatibility with pre-beta versions

// The data collected in this counter is actually the start time of the
// item being measured. For display, this data is subtracted from the
// sample time to yield the elapsed time as the difference between the two.
// In the definition below, the PerfTime field of the Object contains
// the sample time as indicated by the PERF_OBJECT_TIMER bit and the
// difference is scaled by the PerfFreq of the Object to convert the time
// units into seconds.
#define PERF_ELAPSED_TIME           \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_ELAPSED |\
            PERF_OBJECT_TIMER | PERF_DISPLAY_SECONDS)
//
//  The following counter type can be used with the preceding types to
//  define a range of values to be displayed in a histogram.
//

#define PERF_COUNTER_HISTOGRAM_TYPE   0x80000000
                                        // Counter begins or ends a histogram

//
//  The following are used to determine the level of detail associated
//  with the counter.  The user will be setting the level of detail
//  that should be displayed at any given time.
//

#define PERF_DETAIL_NOVICE          100 // The uninformed can understand it
#define PERF_DETAIL_ADVANCED        200 // For the advanced user
#define PERF_DETAIL_EXPERT          300 // For the expert user
#define PERF_DETAIL_WIZARD          400 // For the system designer


//
//  There is one of the following for each of the
//  PERF_OBJECT_TYPE.NumCounters.  The Unicode names in this structure MUST
//  come from a message file.
//

typedef struct _PERF_COUNTER_DEFINITION {
    DWORD           ByteLength;         // Length in bytes of this structure
    DWORD           CounterNameTitleIndex;
                                        // Index of Counter name into
                                        // Title Database
    LPWSTR          CounterNameTitle;   // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
    DWORD           CounterHelpTitleIndex;
                                        // Index of Counter Help into
                                        // Title Database
    LPWSTR          CounterHelpTitle;   // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
    LONG            DefaultScale;       // Power of 10 by which to scale
                                        // chart line if vertical axis is 100
                                        // 0 ==> 1, 1 ==> 10, -1 ==>1/10, etc.
    DWORD           DetailLevel;        // Counter level of detail (for
                                        // controlling display complexity)
    DWORD           CounterType;        // Type of counter
    DWORD           CounterSize;        // Size of counter in bytes
    DWORD           CounterOffset;      // Offset from the start of the
                                        // PERF_COUNTER_BLOCK to the first
                                        // byte of this counter
} PERF_COUNTER_DEFINITION, *PPERF_COUNTER_DEFINITION;

//
//  If (PERF_DATA_BLOCK.NumInstances >= 0) then there will be
//  PERF_DATA_BLOCK.NumInstances of a (PERF_INSTANCE_DEFINITION
//  followed by a PERF_COUNTER_BLOCK followed by the counter data fields)
//  for each instance.
//
//  If (PERF_DATA_BLOCK.NumInstances < 0) then the counter definition
//  strucutre above will be followed by only a PERF_COUNTER_BLOCK and the
//  counter data for that COUNTER.
//

#define PERF_NO_UNIQUE_ID -1

typedef struct _PERF_INSTANCE_DEFINITION {
    DWORD           ByteLength;         // Length in bytes of this structure,
                                        // including the subsequent name
    DWORD           ParentObjectTitleIndex;
                                        // Title Index to name of "parent"
                                        // object (e.g., if thread, then
                                        // process is parent object type);
                                        // if logical drive, the physical
                                        // drive is parent object type
    DWORD           ParentObjectInstance;
                                        // Index to instance of parent object
                                        // type which is the parent of this
                                        // instance.
    LONG            UniqueID;           // A unique ID used instead of
                                        // matching the name to identify
                                        // this instance, -1 = none
    DWORD           NameOffset;         // Offset from beginning of
                                        // this struct to the Unicode name
                                        // of this instance
    DWORD           NameLength;         // Length in bytes of name; 0 = none

} PERF_INSTANCE_DEFINITION, *PPERF_INSTANCE_DEFINITION;
//
//  If .ParentObjectName is 0, there
//  is no parent-child hierarchy for this object type.  Otherwise,
//   the .ParentObjectInstance is an index, starting at 0, into the
//  instances reported for the parent object type.  It is only
//  meaningful if .ParentObjectName is not 0.  The purpose of all this
//  is to permit reporting/summation of object instances like threads
//  within processes, and logical drives within physical drives.
//
//
//  The PERF_INSTANCE_DEFINITION will be followed by a PERF_COUNTER_BLOCK.
//

typedef struct _PERF_COUNTER_BLOCK {
    DWORD           ByteLength;         // Length in bytes of this structure,
                                        // including the following counters
} PERF_COUNTER_BLOCK, *PPERF_COUNTER_BLOCK;

//
//  The PERF_COUNTER_BLOCK is followed by PERF_OBJECT_TYPE.NumCounters
//  number of counters.
//

//
//  function typedefs for extensible counter function prototypes
//
typedef DWORD (APIENTRY PM_OPEN_PROC) (LPWSTR);
typedef DWORD (APIENTRY PM_COLLECT_PROC) (LPWSTR, LPVOID *, LPDWORD, LPDWORD);
typedef DWORD (APIENTRY PM_CLOSE_PROC) (void);

#endif // _WINPERF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\winver.h ===
/*****************************************************************************\
*                                                                             *
* winver.h -    Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL.  This library is                    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*               Copyright (c) 1993-1995, Microsoft Corp.  All rights reserved *
*                                                                             *
\*****************************************************************************/

#ifndef VER_H
#define VER_H

#ifdef __cplusplus
extern "C" {
#endif

/* ----- Symbols ----- */
#define VS_FILE_INFO            RT_VERSION
#define VS_VERSION_INFO         1
#define VS_USER_DEFINED         100

/* ----- VS_VERSION.dwFileFlags ----- */
#define VS_FFI_SIGNATURE        0xFEEF04BDL
#define VS_FFI_STRUCVERSION     0x00010000L
#define VS_FFI_FILEFLAGSMASK    0x0000003FL

/* ----- VS_VERSION.dwFileFlags ----- */
#define VS_FF_DEBUG             0x00000001L
#define VS_FF_PRERELEASE        0x00000002L
#define VS_FF_PATCHED           0x00000004L
#define VS_FF_PRIVATEBUILD      0x00000008L
#define VS_FF_INFOINFERRED      0x00000010L
#define VS_FF_SPECIALBUILD      0x00000020L

/* ----- VS_VERSION.dwFileOS ----- */
#define VOS_UNKNOWN             0x00000000L
#define VOS_DOS                 0x00010000L
#define VOS_OS216               0x00020000L
#define VOS_OS232               0x00030000L
#define VOS_NT                  0x00040000L

#define VOS__BASE               0x00000000L
#define VOS__WINDOWS16          0x00000001L
#define VOS__PM16               0x00000002L
#define VOS__PM32               0x00000003L
#define VOS__WINDOWS32          0x00000004L

#define VOS_DOS_WINDOWS16       0x00010001L
#define VOS_DOS_WINDOWS32       0x00010004L
#define VOS_OS216_PM16          0x00020002L
#define VOS_OS232_PM32          0x00030003L
#define VOS_NT_WINDOWS32        0x00040004L

/* ----- VS_VERSION.dwFileType ----- */
#define VFT_UNKNOWN             0x00000000L
#define VFT_APP                 0x00000001L
#define VFT_DLL                 0x00000002L
#define VFT_DRV                 0x00000003L
#define VFT_FONT                0x00000004L
#define VFT_VXD                 0x00000005L
#define VFT_STATIC_LIB          0x00000007L

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
#define VFT2_UNKNOWN            0x00000000L
#define VFT2_DRV_PRINTER        0x00000001L
#define VFT2_DRV_KEYBOARD       0x00000002L
#define VFT2_DRV_LANGUAGE       0x00000003L
#define VFT2_DRV_DISPLAY        0x00000004L
#define VFT2_DRV_MOUSE          0x00000005L
#define VFT2_DRV_NETWORK        0x00000006L
#define VFT2_DRV_SYSTEM         0x00000007L
#define VFT2_DRV_INSTALLABLE    0x00000008L
#define VFT2_DRV_SOUND          0x00000009L
#define VFT2_DRV_COMM           0x0000000AL
#define VFT2_DRV_INPUTMETHOD    0x0000000BL

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
#define VFT2_FONT_RASTER        0x00000001L
#define VFT2_FONT_VECTOR        0x00000002L
#define VFT2_FONT_TRUETYPE      0x00000003L

/* ----- VerFindFile() flags ----- */
#define VFFF_ISSHAREDFILE       0x0001

#define VFF_CURNEDEST           0x0001
#define VFF_FILEINUSE           0x0002
#define VFF_BUFFTOOSMALL        0x0004

/* ----- VerInstallFile() flags ----- */
#define VIFF_FORCEINSTALL       0x0001
#define VIFF_DONTDELETEOLD      0x0002

#define VIF_TEMPFILE            0x00000001L
#define VIF_MISMATCH            0x00000002L
#define VIF_SRCOLD              0x00000004L

#define VIF_DIFFLANG            0x00000008L
#define VIF_DIFFCODEPG          0x00000010L
#define VIF_DIFFTYPE            0x00000020L

#define VIF_WRITEPROT           0x00000040L
#define VIF_FILEINUSE           0x00000080L
#define VIF_OUTOFSPACE          0x00000100L
#define VIF_ACCESSVIOLATION     0x00000200L
#define VIF_SHARINGVIOLATION    0x00000400L
#define VIF_CANNOTCREATE        0x00000800L
#define VIF_CANNOTDELETE        0x00001000L
#define VIF_CANNOTRENAME        0x00002000L
#define VIF_CANNOTDELETECUR     0x00004000L
#define VIF_OUTOFMEMORY         0x00008000L

#define VIF_CANNOTREADSRC       0x00010000L
#define VIF_CANNOTREADDST       0x00020000L

#define VIF_BUFFTOOSMALL        0x00040000L

#ifndef RC_INVOKED              /* RC doesn't need to see the rest of this */

/* ----- Types and structures ----- */

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;

/* ----- Function prototypes ----- */

#ifndef UNICODE_ONLY
DWORD
APIENTRY
VerFindFileA(
        DWORD uFlags,
        LPSTR szFileName,
        LPSTR szWinDir,
        LPSTR szAppDir,
        LPSTR szCurDir,
        PUINT lpuCurDirLen,
        LPSTR szDestDir,
        PUINT lpuDestDirLen
        );
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
DWORD
APIENTRY
VerFindFileW(
        DWORD uFlags,
        LPWSTR szFileName,
        LPWSTR szWinDir,
        LPWSTR szAppDir,
        LPWSTR szCurDir,
        PUINT lpuCurDirLen,
        LPWSTR szDestDir,
        PUINT lpuDestDirLen
        );
#endif //!ANSI_ONLY
#ifdef UNICODE
#define VerFindFile  VerFindFileW
#else
#define VerFindFile  VerFindFileA
#endif // !UNICODE

#ifndef UNICODE_ONLY
DWORD
APIENTRY
VerInstallFileA(
        DWORD uFlags,
        LPSTR szSrcFileName,
        LPSTR szDestFileName,
        LPSTR szSrcDir,
        LPSTR szDestDir,
        LPSTR szCurDir,
        LPSTR szTmpFile,
        PUINT lpuTmpFileLen
        );
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
DWORD
APIENTRY
VerInstallFileW(
        DWORD uFlags,
        LPWSTR szSrcFileName,
        LPWSTR szDestFileName,
        LPWSTR szSrcDir,
        LPWSTR szDestDir,
        LPWSTR szCurDir,
        LPWSTR szTmpFile,
        PUINT lpuTmpFileLen
        );
#endif //!ANSI_ONLY
#ifdef UNICODE
#define VerInstallFile  VerInstallFileW
#else
#define VerInstallFile  VerInstallFileA
#endif // !UNICODE

/* Returns size of version info in bytes */
DWORD
APIENTRY
GetFileVersionInfoSizeA(
        LPSTR lptstrFilename, /* Filename of version stamped file */
        LPDWORD lpdwHandle
        );                      /* Information for use by GetFileVersionInfo */
/* Returns size of version info in bytes */
DWORD
APIENTRY
GetFileVersionInfoSizeW(
        LPWSTR lptstrFilename, /* Filename of version stamped file */
        LPDWORD lpdwHandle
        );                      /* Information for use by GetFileVersionInfo */
#ifdef UNICODE
#define GetFileVersionInfoSize  GetFileVersionInfoSizeW
#else
#define GetFileVersionInfoSize  GetFileVersionInfoSizeA
#endif // !UNICODE

/* Read version info into buffer */
BOOL
APIENTRY
GetFileVersionInfoA(
        LPSTR lptstrFilename, /* Filename of version stamped file */
        DWORD dwHandle,         /* Information from GetFileVersionSize */
        DWORD dwLen,            /* Length of buffer for info */
        LPVOID lpData
        );                      /* Buffer to place the data structure */
/* Read version info into buffer */
BOOL
APIENTRY
GetFileVersionInfoW(
        LPWSTR lptstrFilename, /* Filename of version stamped file */
        DWORD dwHandle,         /* Information from GetFileVersionSize */
        DWORD dwLen,            /* Length of buffer for info */
        LPVOID lpData
        );                      /* Buffer to place the data structure */
#ifdef UNICODE
#define GetFileVersionInfo  GetFileVersionInfoW
#else
#define GetFileVersionInfo  GetFileVersionInfoA
#endif // !UNICODE

DWORD
APIENTRY
VerLanguageNameA(
        DWORD wLang,
        LPSTR szLang,
        DWORD nSize
        );
DWORD
APIENTRY
VerLanguageNameW(
        DWORD wLang,
        LPWSTR szLang,
        DWORD nSize
        );
#ifdef UNICODE
#define VerLanguageName  VerLanguageNameW
#else
#define VerLanguageName  VerLanguageNameA
#endif // !UNICODE

#ifndef UNICODE_ONLY
BOOL
APIENTRY
VerQueryValueA(
        const LPVOID pBlock,
        LPSTR lpSubBlock,
        LPVOID * lplpBuffer,
        PUINT puLen
        );
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
APIENTRY
VerQueryValueW(
        const LPVOID pBlock,
        LPWSTR lpSubBlock,
        LPVOID * lplpBuffer,
        PUINT puLen
        );
#endif //!ANSI_ONLY
#ifdef UNICODE
#define VerQueryValue  VerQueryValueW
#else
#define VerQueryValue  VerQueryValueA
#endif // !UNICODE

#endif  /* !RC_INVOKED */

#ifdef __cplusplus
}
#endif

#endif  /* !VER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c1032\inc\winsvc.h ===
/*++ BUILD Version: 0010    // Increment this if a change has global effects

Copyright (c) 1995  Microsoft Corporation

Module Name:

    winsvc.h

Abstract:

    Header file for the Service Control Manager

Environment:

    User Mode - Win32

--*/
#ifndef _WINSVC_
#define _WINSVC_

//
// Define API decoration for direct importing of DLL references.
//

#if !defined(WINADVAPI)
#if !defined(_ADVAPI32_)
#define WINADVAPI DECLSPEC_IMPORT
#else
#define WINADVAPI
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Constants
//

//
// Service database names
//

#define SERVICES_ACTIVE_DATABASEW      L"ServicesActive"
#define SERVICES_FAILED_DATABASEW      L"ServicesFailed"

#define SERVICES_ACTIVE_DATABASEA      "ServicesActive"
#define SERVICES_FAILED_DATABASEA      "ServicesFailed"

//
// Character to designate that a name is a group
//

#define SC_GROUP_IDENTIFIERW           L'+'
#define SC_GROUP_IDENTIFIERA           '+'

#ifdef UNICODE

#define SERVICES_ACTIVE_DATABASE       SERVICES_ACTIVE_DATABASEW
#define SERVICES_FAILED_DATABASE       SERVICES_FAILED_DATABASEW


#define SC_GROUP_IDENTIFIER            SC_GROUP_IDENTIFIERW

#else // ndef UNICODE

#define SERVICES_ACTIVE_DATABASE       SERVICES_ACTIVE_DATABASEA
#define SERVICES_FAILED_DATABASE       SERVICES_FAILED_DATABASEA

#define SC_GROUP_IDENTIFIER            SC_GROUP_IDENTIFIERA
#endif // ndef UNICODE


//
// Value to indicate no change to an optional parameter
//
#define SERVICE_NO_CHANGE              0xffffffff

//
// Service State -- for Enum Requests (Bit Mask)
//
#define SERVICE_ACTIVE                 0x00000001
#define SERVICE_INACTIVE               0x00000002
#define SERVICE_STATE_ALL              (SERVICE_ACTIVE   | \
                                        SERVICE_INACTIVE)

//
// Controls
//
#define SERVICE_CONTROL_STOP           0x00000001
#define SERVICE_CONTROL_PAUSE          0x00000002
#define SERVICE_CONTROL_CONTINUE       0x00000003
#define SERVICE_CONTROL_INTERROGATE    0x00000004
#define SERVICE_CONTROL_SHUTDOWN       0x00000005

//
// Service State -- for CurrentState
//
#define SERVICE_STOPPED                0x00000001
#define SERVICE_START_PENDING          0x00000002
#define SERVICE_STOP_PENDING           0x00000003
#define SERVICE_RUNNING                0x00000004
#define SERVICE_CONTINUE_PENDING       0x00000005
#define SERVICE_PAUSE_PENDING          0x00000006
#define SERVICE_PAUSED                 0x00000007

//
// Controls Accepted  (Bit Mask)
//
#define SERVICE_ACCEPT_STOP            0x00000001
#define SERVICE_ACCEPT_PAUSE_CONTINUE  0x00000002
#define SERVICE_ACCEPT_SHUTDOWN        0x00000004

//
// Service Control Manager object specific access types
//
#define SC_MANAGER_CONNECT             0x0001
#define SC_MANAGER_CREATE_SERVICE      0x0002
#define SC_MANAGER_ENUMERATE_SERVICE   0x0004
#define SC_MANAGER_LOCK                0x0008
#define SC_MANAGER_QUERY_LOCK_STATUS   0x0010
#define SC_MANAGER_MODIFY_BOOT_CONFIG  0x0020

#define SC_MANAGER_ALL_ACCESS          (STANDARD_RIGHTS_REQUIRED      | \
                                        SC_MANAGER_CONNECT            | \
                                        SC_MANAGER_CREATE_SERVICE     | \
                                        SC_MANAGER_ENUMERATE_SERVICE  | \
                                        SC_MANAGER_LOCK               | \
                                        SC_MANAGER_QUERY_LOCK_STATUS  | \
                                        SC_MANAGER_MODIFY_BOOT_CONFIG)



//
// Service object specific access type
//
#define SERVICE_QUERY_CONFIG           0x0001
#define SERVICE_CHANGE_CONFIG          0x0002
#define SERVICE_QUERY_STATUS           0x0004
#define SERVICE_ENUMERATE_DEPENDENTS   0x0008
#define SERVICE_START                  0x0010
#define SERVICE_STOP                   0x0020
#define SERVICE_PAUSE_CONTINUE         0x0040
#define SERVICE_INTERROGATE            0x0080
#define SERVICE_USER_DEFINED_CONTROL   0x0100

#define SERVICE_ALL_ACCESS             (STANDARD_RIGHTS_REQUIRED     | \
                                        SERVICE_QUERY_CONFIG         | \
                                        SERVICE_CHANGE_CONFIG        | \
                                        SERVICE_QUERY_STATUS         | \
                                        SERVICE_ENUMERATE_DEPENDENTS | \
                                        SERVICE_START                | \
                                        SERVICE_STOP                 | \
                                        SERVICE_PAUSE_CONTINUE       | \
                                        SERVICE_INTERROGATE          | \
                                        SERVICE_USER_DEFINED_CONTROL)


//
// Handle Types
//

typedef HANDLE      SC_HANDLE;
typedef SC_HANDLE   *LPSC_HANDLE;

typedef DWORD       SERVICE_STATUS_HANDLE;

//
// Service Status Structure
//

typedef struct _SERVICE_STATUS {
    DWORD   dwServiceType;
    DWORD   dwCurrentState;
    DWORD   dwControlsAccepted;
    DWORD   dwWin32ExitCode;
    DWORD   dwServiceSpecificExitCode;
    DWORD   dwCheckPoint;
    DWORD   dwWaitHint;
} SERVICE_STATUS, *LPSERVICE_STATUS;



//
// Service Status Enumeration Structure
//

#ifndef UNICODE_ONLY
typedef struct _ENUM_SERVICE_STATUSA {
    LPSTR          lpServiceName;
    LPSTR          lpDisplayName;
    SERVICE_STATUS ServiceStatus;
} ENUM_SERVICE_STATUSA, *LPENUM_SERVICE_STATUSA;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _ENUM_SERVICE_STATUSW {
    LPWSTR         lpServiceName;
    LPWSTR         lpDisplayName;
    SERVICE_STATUS ServiceStatus;
} ENUM_SERVICE_STATUSW, *LPENUM_SERVICE_STATUSW;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef ENUM_SERVICE_STATUSW ENUM_SERVICE_STATUS;
typedef LPENUM_SERVICE_STATUSW LPENUM_SERVICE_STATUS;
#else
typedef ENUM_SERVICE_STATUSA ENUM_SERVICE_STATUS;
typedef LPENUM_SERVICE_STATUSA LPENUM_SERVICE_STATUS;
#endif // UNICODE


//
// Structures for the Lock API functions
//

typedef LPVOID  SC_LOCK;

#ifndef UNICODE_ONLY
typedef struct _QUERY_SERVICE_LOCK_STATUSA {
    DWORD   fIsLocked;
    LPSTR   lpLockOwner;
    DWORD   dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSA, *LPQUERY_SERVICE_LOCK_STATUSA;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _QUERY_SERVICE_LOCK_STATUSW {
    DWORD   fIsLocked;
    LPWSTR  lpLockOwner;
    DWORD   dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSW, *LPQUERY_SERVICE_LOCK_STATUSW;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef QUERY_SERVICE_LOCK_STATUSW QUERY_SERVICE_LOCK_STATUS;
typedef LPQUERY_SERVICE_LOCK_STATUSW LPQUERY_SERVICE_LOCK_STATUS;
#else
typedef QUERY_SERVICE_LOCK_STATUSA QUERY_SERVICE_LOCK_STATUS;
typedef LPQUERY_SERVICE_LOCK_STATUSA LPQUERY_SERVICE_LOCK_STATUS;
#endif // UNICODE



//
// Query Service Configuration Structure
//

#ifndef UNICODE_ONLY
typedef struct _QUERY_SERVICE_CONFIGA {
    DWORD   dwServiceType;
    DWORD   dwStartType;
    DWORD   dwErrorControl;
    LPSTR   lpBinaryPathName;
    LPSTR   lpLoadOrderGroup;
    DWORD   dwTagId;
    LPSTR   lpDependencies;
    LPSTR   lpServiceStartName;
    LPSTR   lpDisplayName;
} QUERY_SERVICE_CONFIGA, *LPQUERY_SERVICE_CONFIGA;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _QUERY_SERVICE_CONFIGW {
    DWORD   dwServiceType;
    DWORD   dwStartType;
    DWORD   dwErrorControl;
    LPWSTR  lpBinaryPathName;
    LPWSTR  lpLoadOrderGroup;
    DWORD   dwTagId;
    LPWSTR  lpDependencies;
    LPWSTR  lpServiceStartName;
    LPWSTR  lpDisplayName;
} QUERY_SERVICE_CONFIGW, *LPQUERY_SERVICE_CONFIGW;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef QUERY_SERVICE_CONFIGW QUERY_SERVICE_CONFIG;
typedef LPQUERY_SERVICE_CONFIGW LPQUERY_SERVICE_CONFIG;
#else
typedef QUERY_SERVICE_CONFIGA QUERY_SERVICE_CONFIG;
typedef LPQUERY_SERVICE_CONFIGA LPQUERY_SERVICE_CONFIG;
#endif // UNICODE



//
// Function Prototype for the Service Main Function
//

#ifndef ANSI_ONLY
typedef VOID (WINAPI *LPSERVICE_MAIN_FUNCTIONW)(
    DWORD   dwNumServicesArgs,
    LPWSTR  *lpServiceArgVectors
    );
#endif //!ANSI_ONLY

#ifndef UNICODE_ONLY
typedef VOID (WINAPI *LPSERVICE_MAIN_FUNCTIONA)(
    DWORD   dwNumServicesArgs,
    LPSTR   *lpServiceArgVectors
    );
#endif //!UNICODE_ONLY

#ifdef UNICODE
#define LPSERVICE_MAIN_FUNCTION LPSERVICE_MAIN_FUNCTIONW
#else
#define LPSERVICE_MAIN_FUNCTION LPSERVICE_MAIN_FUNCTIONA
#endif //UNICODE


//
// Service Start Table
//

#ifndef UNICODE_ONLY
typedef struct _SERVICE_TABLE_ENTRYA {
    LPSTR                       lpServiceName;
    LPSERVICE_MAIN_FUNCTIONA    lpServiceProc;
}SERVICE_TABLE_ENTRYA, *LPSERVICE_TABLE_ENTRYA;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _SERVICE_TABLE_ENTRYW {
    LPWSTR                      lpServiceName;
    LPSERVICE_MAIN_FUNCTIONW    lpServiceProc;
}SERVICE_TABLE_ENTRYW, *LPSERVICE_TABLE_ENTRYW;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef SERVICE_TABLE_ENTRYW SERVICE_TABLE_ENTRY;
typedef LPSERVICE_TABLE_ENTRYW LPSERVICE_TABLE_ENTRY;
#else
typedef SERVICE_TABLE_ENTRYA SERVICE_TABLE_ENTRY;
typedef LPSERVICE_TABLE_ENTRYA LPSERVICE_TABLE_ENTRY;
#endif // UNICODE

//
// Prototype for the Service Control Handler Function
//

typedef VOID (WINAPI *LPHANDLER_FUNCTION)(
    DWORD    dwControl
    );



///////////////////////////////////////////////////////////////////////////
// API Function Prototypes
///////////////////////////////////////////////////////////////////////////

#ifndef UNICODE_ONLY
WINADVAPI
BOOL
WINAPI
ChangeServiceConfigA(
    SC_HANDLE    hService,
    DWORD        dwServiceType,
    DWORD        dwStartType,
    DWORD        dwErrorControl,
    LPCSTR     lpBinaryPathName,
    LPCSTR     lpLoadOrderGroup,
    LPDWORD      lpdwTagId,
    LPCSTR     lpDependencies,
    LPCSTR     lpServiceStartName,
    LPCSTR     lpPassword,
    LPCSTR     lpDisplayName
    );
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
WINADVAPI
BOOL
WINAPI
ChangeServiceConfigW(
    SC_HANDLE    hService,
    DWORD        dwServiceType,
    DWORD        dwStartType,
    DWORD        dwErrorControl,
    LPCWSTR     lpBinaryPathName,
    LPCWSTR     lpLoadOrderGroup,
    LPDWORD      lpdwTagId,
    LPCWSTR     lpDependencies,
    LPCWSTR     lpServiceStartName,
    LPCWSTR     lpPassword,
    LPCWSTR     lpDisplayName
    );
#endif //!ANSI_ONLY
#ifdef UNICODE
#define ChangeServiceConfig  ChangeServiceConfigW
#else
#define ChangeServiceConfig  ChangeServiceConfigA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
CloseServiceHandle(
    SC_HANDLE   hSCObject
    );

WINADVAPI
BOOL
WINAPI
ControlService(
    SC_HANDLE           hService,
    DWORD               dwControl,
    LPSERVICE_STATUS    lpServiceStatus
    );

#ifndef UNICODE_ONLY
WINADVAPI
SC_HANDLE
WINAPI
CreateServiceA(
    SC_HANDLE    hSCManager,
    LPCSTR     lpServiceName,
    LPCSTR     lpDisplayName,
    DWORD        dwDesiredAccess,
    DWORD        dwServiceType,
    DWORD        dwStartType,
    DWORD        dwErrorControl,
    LPCSTR     lpBinaryPathName,
    LPCSTR     lpLoadOrderGroup,
    LPDWORD      lpdwTagId,
    LPCSTR     lpDependencies,
    LPCSTR     lpServiceStartName,
    LPCSTR     lpPassword
    );
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
WINADVAPI
SC_HANDLE
WINAPI
CreateServiceW(
    SC_HANDLE    hSCManager,
    LPCWSTR     lpServiceName,
    LPCWSTR     lpDisplayName,
    DWORD        dwDesiredAccess,
    DWORD        dwServiceType,
    DWORD        dwStartType,
    DWORD        dwErrorControl,
    LPCWSTR     lpBinaryPathName,
    LPCWSTR     lpLoadOrderGroup,
    LPDWORD      lpdwTagId,
    LPCWSTR     lpDependencies,
    LPCWSTR     lpServiceStartName,
    LPCWSTR     lpPassword
    );
#endif //!ANSI_ONLY
#ifdef UNICODE
#define CreateService  CreateServiceW
#else
#define CreateService  CreateServiceA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
DeleteService(
    SC_HANDLE   hService
    );

#ifndef UNICODE_ONLY
WINADVAPI
BOOL
WINAPI
EnumDependentServicesA(
    SC_HANDLE               hService,
    DWORD                   dwServiceState,
    LPENUM_SERVICE_STATUSA  lpServices,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded,
    LPDWORD                 lpServicesReturned
    );
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
WINADVAPI
BOOL
WINAPI
EnumDependentServicesW(
    SC_HANDLE               hService,
    DWORD                   dwServiceState,
    LPENUM_SERVICE_STATUSW  lpServices,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded,
    LPDWORD                 lpServicesReturned
    );
#endif //!ANSI_ONLY
#ifdef UNICODE
#define EnumDependentServices  EnumDependentServicesW
#else
#define EnumDependentServices  EnumDependentServicesA
#endif // !UNICODE

#ifndef UNICODE_ONLY
WINADVAPI
BOOL
WINAPI
EnumServicesStatusA(
    SC_HANDLE               hSCManager,
    DWORD                   dwServiceType,
    DWORD                   dwServiceState,
    LPENUM_SERVICE_STATUSA  lpServices,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded,
    LPDWORD                 lpServicesReturned,
    LPDWORD                 lpResumeHandle
    );
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
WINADVAPI
BOOL
WINAPI
EnumServicesStatusW(
    SC_HANDLE               hSCManager,
    DWORD                   dwServiceType,
    DWORD                   dwServiceState,
    LPENUM_SERVICE_STATUSW  lpServices,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded,
    LPDWORD                 lpServicesReturned,
    LPDWORD                 lpResumeHandle
    );
#endif //!ANSI_ONLY
#ifdef UNICODE
#define EnumServicesStatus  EnumServicesStatusW
#else
#define EnumServicesStatus  EnumServicesStatusA
#endif // !UNICODE

#ifndef UNICODE_ONLY
WINADVAPI
BOOL
WINAPI
GetServiceKeyNameA(
    SC_HANDLE               hSCManager,
    LPCSTR                lpDisplayName,
    LPSTR                 lpServiceName,
    LPDWORD                 lpcchBuffer
    );
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
WINADVAPI
BOOL
WINAPI
GetServiceKeyNameW(
    SC_HANDLE               hSCManager,
    LPCWSTR                lpDisplayName,
    LPWSTR                 lpServiceName,
    LPDWORD                 lpcchBuffer
    );
#endif //!ANSI_ONLY
#ifdef UNICODE
#define GetServiceKeyName  GetServiceKeyNameW
#else
#define GetServiceKeyName  GetServiceKeyNameA
#endif // !UNICODE

#ifndef UNICODE_ONLY
WINADVAPI
BOOL
WINAPI
GetServiceDisplayNameA(
    SC_HANDLE               hSCManager,
    LPCSTR                lpServiceName,
    LPSTR                 lpDisplayName,
    LPDWORD                 lpcchBuffer
    );
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
WINADVAPI
BOOL
WINAPI
GetServiceDisplayNameW(
    SC_HANDLE               hSCManager,
    LPCWSTR                lpServiceName,
    LPWSTR                 lpDisplayName,
    LPDWORD                 lpcchBuffer
    );
#endif //!ANSI_ONLY
#ifdef UNICODE
#define GetServiceDisplayName  GetServiceDisplayNameW
#else
#define GetServiceDisplayName  GetServiceDisplayNameA
#endif // !UNICODE

WINADVAPI
SC_LOCK
WINAPI
LockServiceDatabase(
    SC_HANDLE   hSCManager
    );

WINADVAPI
BOOL
WINAPI
NotifyBootConfigStatus(
    BOOL     BootAcceptable
    );

#ifndef UNICODE_ONLY
WINADVAPI
SC_HANDLE
WINAPI
OpenSCManagerA(
    LPCSTR lpMachineName,
    LPCSTR lpDatabaseName,
    DWORD   dwDesiredAccess
    );
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
WINADVAPI
SC_HANDLE
WINAPI
OpenSCManagerW(
    LPCWSTR lpMachineName,
    LPCWSTR lpDatabaseName,
    DWORD   dwDesiredAccess
    );
#endif //!ANSI_ONLY
#ifdef UNICODE
#define OpenSCManager  OpenSCManagerW
#else
#define OpenSCManager  OpenSCManagerA
#endif // !UNICODE

#ifndef UNICODE_ONLY
WINADVAPI
SC_HANDLE
WINAPI
OpenServiceA(
    SC_HANDLE   hSCManager,
    LPCSTR    lpServiceName,
    DWORD       dwDesiredAccess
    );
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
WINADVAPI
SC_HANDLE
WINAPI
OpenServiceW(
    SC_HANDLE   hSCManager,
    LPCWSTR    lpServiceName,
    DWORD       dwDesiredAccess
    );
#endif //!ANSI_ONLY
#ifdef UNICODE
#define OpenService  OpenServiceW
#else
#define OpenService  OpenServiceA
#endif // !UNICODE

#ifndef UNICODE_ONLY
WINADVAPI
BOOL
WINAPI
QueryServiceConfigA(
    SC_HANDLE               hService,
    LPQUERY_SERVICE_CONFIGA lpServiceConfig,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded
    );
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
WINADVAPI
BOOL
WINAPI
QueryServiceConfigW(
    SC_HANDLE               hService,
    LPQUERY_SERVICE_CONFIGW lpServiceConfig,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded
    );
#endif //!ANSI_ONLY
#ifdef UNICODE
#define QueryServiceConfig  QueryServiceConfigW
#else
#define QueryServiceConfig  QueryServiceConfigA
#endif // !UNICODE

#ifndef UNICODE_ONLY
WINADVAPI
BOOL
WINAPI
QueryServiceLockStatusA(
    SC_HANDLE                       hSCManager,
    LPQUERY_SERVICE_LOCK_STATUSA    lpLockStatus,
    DWORD                           cbBufSize,
    LPDWORD                         pcbBytesNeeded
    );
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
WINADVAPI
BOOL
WINAPI
QueryServiceLockStatusW(
    SC_HANDLE                       hSCManager,
    LPQUERY_SERVICE_LOCK_STATUSW    lpLockStatus,
    DWORD                           cbBufSize,
    LPDWORD                         pcbBytesNeeded
    );
#endif //!ANSI_ONLY
#ifdef UNICODE
#define QueryServiceLockStatus  QueryServiceLockStatusW
#else
#define QueryServiceLockStatus  QueryServiceLockStatusA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
QueryServiceObjectSecurity(
    SC_HANDLE               hService,
    SECURITY_INFORMATION    dwSecurityInformation,
    PSECURITY_DESCRIPTOR    lpSecurityDescriptor,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded
    );

WINADVAPI
BOOL
WINAPI
QueryServiceStatus(
    SC_HANDLE           hService,
    LPSERVICE_STATUS    lpServiceStatus
    );

#ifndef UNICODE_ONLY
WINADVAPI
SERVICE_STATUS_HANDLE
WINAPI
RegisterServiceCtrlHandlerA(
    LPCSTR             lpServiceName,
    LPHANDLER_FUNCTION   lpHandlerProc
    );
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
WINADVAPI
SERVICE_STATUS_HANDLE
WINAPI
RegisterServiceCtrlHandlerW(
    LPCWSTR             lpServiceName,
    LPHANDLER_FUNCTION   lpHandlerProc
    );
#endif //!ANSI_ONLY
#ifdef UNICODE
#define RegisterServiceCtrlHandler  RegisterServiceCtrlHandlerW
#else
#define RegisterServiceCtrlHandler  RegisterServiceCtrlHandlerA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
SetServiceObjectSecurity(
    SC_HANDLE               hService,
    SECURITY_INFORMATION    dwSecurityInformation,
    PSECURITY_DESCRIPTOR    lpSecurityDescriptor
    );

WINADVAPI
BOOL
WINAPI
SetServiceStatus(
    SERVICE_STATUS_HANDLE   hServiceStatus,
    LPSERVICE_STATUS        lpServiceStatus
    );

#ifndef UNICODE_ONLY
WINADVAPI
BOOL
WINAPI
StartServiceCtrlDispatcherA(
    LPSERVICE_TABLE_ENTRYA    lpServiceStartTable
    );
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
WINADVAPI
BOOL
WINAPI
StartServiceCtrlDispatcherW(
    LPSERVICE_TABLE_ENTRYW    lpServiceStartTable
    );
#endif //!ANSI_ONLY
#ifdef UNICODE
#define StartServiceCtrlDispatcher  StartServiceCtrlDispatcherW
#else
#define StartServiceCtrlDispatcher  StartServiceCtrlDispatcherA
#endif // !UNICODE


#ifndef UNICODE_ONLY
WINADVAPI
BOOL
WINAPI
StartServiceA(
    SC_HANDLE            hService,
    DWORD                dwNumServiceArgs,
    LPCSTR             *lpServiceArgVectors
    );
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
WINADVAPI
BOOL
WINAPI
StartServiceW(
    SC_HANDLE            hService,
    DWORD                dwNumServiceArgs,
    LPCWSTR             *lpServiceArgVectors
    );
#endif //!ANSI_ONLY
#ifdef UNICODE
#define StartService  StartServiceW
#else
#define StartService  StartServiceA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
UnlockServiceDatabase(
    SC_LOCK     ScLock
    );


#ifdef __cplusplus
}
#endif

#endif // _WINSVC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\assert.h ===
/***
*assert.h - define the assert macro
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Defines the assert(exp) macro.
*   [ANSI/System V]
*
****/

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#undef  assert

#ifdef NDEBUG

#define assert(exp) ((void)0)

#else 
#ifdef __cplusplus
extern "C" {
#endif 
void __cdecl _assert(void *, void *, unsigned);
#ifdef __cplusplus
}
#endif 

#define assert(exp) \
    ( (exp) ? (void) 0 : _assert(#exp, __FILE__, __LINE__) )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\cderr.h ===
/*****************************************************************************\
*                                                                             *
* cderr.h -     Common dialog error return codes                              *
*                                                                             *
* Version 1.0								      *
*                                                                             *
* Copyright (c) 1992-1994, Microsoft Corp.	All rights reserved.	      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_CDERR
#define _INC_CDERR

#define CDERR_DIALOGFAILURE   0xFFFF

#define CDERR_GENERALCODES     0x0000
#define CDERR_STRUCTSIZE       0x0001
#define CDERR_INITIALIZATION   0x0002
#define CDERR_NOTEMPLATE       0x0003
#define CDERR_NOHINSTANCE      0x0004
#define CDERR_LOADSTRFAILURE   0x0005
#define CDERR_FINDRESFAILURE   0x0006
#define CDERR_LOADRESFAILURE   0x0007
#define CDERR_LOCKRESFAILURE   0x0008
#define CDERR_MEMALLOCFAILURE  0x0009
#define CDERR_MEMLOCKFAILURE   0x000A
#define CDERR_NOHOOK           0x000B
#define CDERR_REGISTERMSGFAIL  0x000C

#define PDERR_PRINTERCODES     0x1000
#define PDERR_SETUPFAILURE     0x1001
#define PDERR_PARSEFAILURE     0x1002
#define PDERR_RETDEFFAILURE    0x1003
#define PDERR_LOADDRVFAILURE   0x1004
#define PDERR_GETDEVMODEFAIL   0x1005
#define PDERR_INITFAILURE      0x1006
#define PDERR_NODEVICES        0x1007
#define PDERR_NODEFAULTPRN     0x1008
#define PDERR_DNDMMISMATCH     0x1009
#define PDERR_CREATEICFAILURE  0x100A
#define PDERR_PRINTERNOTFOUND  0x100B
#define PDERR_DEFAULTDIFFERENT 0x100C

#define CFERR_CHOOSEFONTCODES  0x2000
#define CFERR_NOFONTS          0x2001
#define CFERR_MAXLESSTHANMIN   0x2002

#define FNERR_FILENAMECODES    0x3000
#define FNERR_SUBCLASSFAILURE  0x3001
#define FNERR_INVALIDFILENAME  0x3002
#define FNERR_BUFFERTOOSMALL   0x3003

#define FRERR_FINDREPLACECODES 0x4000
#define FRERR_BUFFERLENGTHZERO 0x4001

#define CCERR_CHOOSECOLORCODES 0x5000

#endif  /* !_INC_CDERR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\conio.h ===
/***
*conio.h - console and port I/O declarations
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for
*   the MS C V2.03 compatible console and port I/O routines.
*
****/

#ifndef _INC_CONIO

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

/* function prototypes */

#ifndef _WINDOWS
char * __cdecl _cgets(char *);
int __cdecl _cprintf(const char *, ...);
int __cdecl _cputs(const char *);
int __cdecl _cscanf(const char *, ...);
int __cdecl _getch(void);
int __cdecl _getche(void);
#endif 
int __cdecl _inp(unsigned);
unsigned __cdecl _inpw(unsigned);
#ifndef _WINDOWS
int __cdecl _kbhit(void);
#endif 
int __cdecl _outp(unsigned, int);
unsigned __cdecl _outpw(unsigned, unsigned);
#ifndef _WINDOWS
int __cdecl _putch(int);
int __cdecl _ungetch(int);
#endif 

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#ifndef _WINDOWS
char * __cdecl cgets(char *);
int __cdecl cprintf(const char *, ...);
int __cdecl cputs(const char *);
int __cdecl cscanf(const char *, ...);
int __cdecl getch(void);
int __cdecl getche(void);
#endif 
int __cdecl inp(unsigned);
unsigned __cdecl inpw(unsigned);
#ifndef _WINDOWS
int __cdecl kbhit(void);
#endif 
int __cdecl outp(unsigned, int);
unsigned __cdecl outpw(unsigned, unsigned);
#ifndef _WINDOWS
int __cdecl putch(int);
int __cdecl ungetch(int);
#endif 
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_CONIO
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\direct.h ===
/***
*direct.h - function declarations for directory handling/creation
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for the library
*   functions related to directory handling and creation.
*
****/

#ifndef _INC_DIRECT

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

/* function prototypes */

int __cdecl _chdir(const char *);
int __cdecl _chdrive(int);
char * __cdecl _getcwd(char *, int);
char * __cdecl _getdcwd(int, char *, int);
int __cdecl _getdrive(void);
int __cdecl _mkdir(const char *);
int __cdecl _rmdir(const char *);

#ifndef __STDC__
/* Non-ANSI names for compatibility */
int __cdecl chdir(const char *);
char * __cdecl getcwd(char *, int);
int __cdecl mkdir(const char *);
int __cdecl rmdir(const char *);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_DIRECT
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\bios.h ===
/***
*bios.h - declarations for bios interface functions and supporting definitions
*
*   Copyright (c) 1987-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file declares the constants, structures, and functions
*   used for accessing and using various BIOS interfaces.
*
****/

#ifndef _INC_BIOS

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _MT

/* manifest constants for BIOS serial communications (RS-232) support */

/* serial port services */

#define _COM_INIT   0   /* init serial port */
#define _COM_SEND   1   /* send character */
#define _COM_RECEIVE    2   /* receive character */
#define _COM_STATUS 3   /* get serial port status */

/* serial port initializers.  One and only one constant from each of the
 * following four groups - character size, stop bit, parity, and baud rate -
 * must be specified in the initialization byte.
 */

/* character size initializers */

#define _COM_CHR7   2   /* 7 bits characters */
#define _COM_CHR8   3   /* 8 bits characters */

/* stop bit values - on or off */

#define _COM_STOP1  0   /* 1 stop bit */
#define _COM_STOP2  4   /* 2 stop bits */

/*  parity initializers */

#define _COM_NOPARITY   0   /* no parity */
#define _COM_ODDPARITY  8   /* odd parity */
#define _COM_EVENPARITY 24  /* even parity */

/*  baud rate initializers */

#define _COM_110    0   /* 110 baud */
#define _COM_150    32  /* 150 baud */
#define _COM_300    64  /* 300 baud */
#define _COM_600    96  /* 600 baud */
#define _COM_1200   128 /* 1200 baud */
#define _COM_2400   160 /* 2400 baud */
#define _COM_4800   192 /* 4800 baud */
#define _COM_9600   224 /* 9600 baud */


/* manifest constants for BIOS disk support */

/* disk services */

#define _DISK_RESET 0   /* reset disk controller */
#define _DISK_STATUS    1   /* get disk status */
#define _DISK_READ  2   /* read disk sectors */
#define _DISK_WRITE 3   /* write disk sectors */
#define _DISK_VERIFY    4   /* verify disk sectors */
#define _DISK_FORMAT    5   /* format disk track */

/* struct used to send/receive information to/from the BIOS disk services */

#ifndef _DISKINFO_T_DEFINED
#pragma pack(2)

struct _diskinfo_t {
    unsigned drive;
    unsigned head;
    unsigned track;
    unsigned sector;
    unsigned nsectors;
    void __far *buffer;
    };

#ifndef __STDC__
/* Non-ANSI name for compatibility */
#define diskinfo_t _diskinfo_t
#endif 

#pragma pack()
#define _DISKINFO_T_DEFINED
#endif 


/* manifest constants for BIOS keyboard support */

/* keyboard services */

#define _KEYBRD_READ        0   /* read next character from keyboard */
#define _KEYBRD_READY       1   /* check for keystroke */
#define _KEYBRD_SHIFTSTATUS 2   /* get current shift key status */

/* services for enhanced keyboards */

#define _NKEYBRD_READ       0x10    /* read next character from keyboard */
#define _NKEYBRD_READY      0x11    /* check for keystroke */
#define _NKEYBRD_SHIFTSTATUS    0x12    /* get current shift key status */


/* manifest constants for BIOS printer support */

/* printer services */

#define _PRINTER_WRITE  0   /* write character to printer */
#define _PRINTER_INIT   1   /* intialize printer */
#define _PRINTER_STATUS 2   /* get printer status */


/* manifest constants for BIOS time of day support */

/* time of day services */

#define _TIME_GETCLOCK  0   /* get current clock count */
#define _TIME_SETCLOCK  1   /* set current clock count */


#ifndef _REGS_DEFINED

/* word registers */

struct _WORDREGS {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
    unsigned int si;
    unsigned int di;
    unsigned int cflag;
    };

/* byte registers */

struct _BYTEREGS {
    unsigned char al, ah;
    unsigned char bl, bh;
    unsigned char cl, ch;
    unsigned char dl, dh;
    };

/* general purpose registers union -
 *  overlays the corresponding word and byte registers.
 */

union _REGS {
    struct _WORDREGS x;
    struct _BYTEREGS h;
    };

/* segment registers */

struct _SREGS {
    unsigned int es;
    unsigned int cs;
    unsigned int ss;
    unsigned int ds;
    };

#ifndef __STDC__
/* Non-ANSI names for compatibility */

struct WORDREGS {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
    unsigned int si;
    unsigned int di;
    unsigned int cflag;
    };

struct BYTEREGS {
    unsigned char al, ah;
    unsigned char bl, bh;
    unsigned char cl, ch;
    unsigned char dl, dh;
    };

union REGS {
    struct WORDREGS x;
    struct BYTEREGS h;
    };

struct SREGS {
    unsigned int es;
    unsigned int cs;
    unsigned int ss;
    unsigned int ds;
    };

#endif 

#define _REGS_DEFINED
#endif 


/* function prototypes */

#ifndef _WINDOWS
unsigned __cdecl _bios_disk(unsigned, struct _diskinfo_t *);
#endif 
unsigned __cdecl _bios_equiplist(void);
#ifndef _WINDOWS
unsigned __cdecl _bios_keybrd(unsigned);
#endif 
unsigned __cdecl _bios_memsize(void);
#ifndef _WINDOWS
unsigned __cdecl _bios_printer(unsigned, unsigned, unsigned);
unsigned __cdecl _bios_serialcom(unsigned, unsigned, unsigned);
#endif 
unsigned __cdecl _bios_timeofday(unsigned, long *);
int __cdecl _int86(int, union _REGS *, union _REGS *);
int __cdecl _int86x(int, union _REGS *, union _REGS *, struct _SREGS *);

#ifndef __STDC__
/* Non-ANSI names for compatibility */
int __cdecl int86(int, union REGS *, union REGS *);
int __cdecl int86x(int, union REGS *, union REGS *, struct SREGS *);
#endif 

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_BIOS
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\tools\c816\inc\ctype.h ===
/***
*ctype.h - character conversion macros and ctype macros
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Defines macros for character classification/conversion.
*   [ANSI/System V]
*
****/

#ifndef _INC_CTYPE

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif 

/*
 * This declaration allows the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */

extern unsigned char __near __cdecl _ctype[];

/* set bit masks for the possible character types */

#define _UPPER      0x1 /* upper case letter */
#define _LOWER      0x2 /* lower case letter */
#define _DIGIT      0x4 /* digit[0-9] */
#define _SPACE      0x8 /* tab, carriage return, newline, */
                /* vertical tab or form feed */
#define _PUNCT      0x10    /* punctuation character */
#define _CONTROL    0x20    /* control character */
#define _BLANK      0x40    /* space char */
#define _HEX        0x80    /* hexadecimal digit */

/* character classification function prototypes */

#ifndef _CTYPE_DEFINED
int __cdecl isalpha(int);
int __cdecl isupper(int);
int __cdecl islower(int);
int __cdecl isdigit(int);
int __cdecl isxdigit(int);
int __cdecl isspace(int);
int __cdecl ispunct(int);
int __cdecl isalnum(int);
int __cdecl isprint(int);
int __cdecl isgraph(int);
int __cdecl iscntrl(int);
int __cdecl toupper(int);
int __cdecl tolower(int);
int __cdecl _tolower(int);
int __cdecl _toupper(int);
int __cdecl __isascii(int);
int __cdecl __toascii(int);
int __cdecl __iscsymf(int);
int __cdecl __iscsym(int);
#define _CTYPE_DEFINED
#endif 

#ifdef _INTL
int __cdecl __isleadbyte(int);
#endif 

/* the character classification macro definitions */

#define isalpha(_c) ( (_ctype+1)[_c] & (_UPPER|_LOWER) )
#define isupper(_c) ( (_ctype+1)[_c] & _UPPER )
#define islower(_c) ( (_ctype+1)[_c] & _LOWER )
#define isdigit(_c) ( (_ctype+1)[_c] & _DIGIT )
#define isxdigit(_c)    ( (_ctype+1)[_c] & _HEX )
#define isspace(_c) ( (_ctype+1)[_c] & _SPACE )
#define ispunct(_c) ( (_ctype+1)[_c] & _PUNCT )
#de