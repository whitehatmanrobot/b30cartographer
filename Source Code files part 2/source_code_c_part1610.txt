    }
    else
    {
        pRasConnection1->PppInfo.nbf.wszWksta[0] = (WCHAR)NULL;
    }

    pRasConnection1->PppInfo.ip.dwError =
                            pConnObj->PppProjectionResult.ip.dwError;

    if ( pRasConnection1->PppInfo.ip.dwError == NO_ERROR )
    {
        ConvertIpAddressToString(
                            pConnObj->PppProjectionResult.ip.dwLocalAddress,
                            pRasConnection1->PppInfo.ip.wszAddress );

        ConvertIpAddressToString(
                            pConnObj->PppProjectionResult.ip.dwRemoteAddress,
                            pRasConnection1->PppInfo.ip.wszRemoteAddress );
    }
    else
    {
        pRasConnection1->PppInfo.ip.wszAddress[0]       = (WCHAR)NULL;
        pRasConnection1->PppInfo.ip.wszRemoteAddress[0] = (WCHAR)NULL;
    }

    pRasConnection1->PppInfo.ipx.dwError =
                            pConnObj->PppProjectionResult.ipx.dwError;

    if ( pRasConnection1->PppInfo.ipx.dwError == NO_ERROR )
    {
        ConvertIpxAddressToString(
                            ( pConnObj->InterfaceType == ROUTER_IF_TYPE_CLIENT )
                            ? pConnObj->PppProjectionResult.ipx.bRemoteAddress
                            : pConnObj->PppProjectionResult.ipx.bLocalAddress,
                            pRasConnection1->PppInfo.ipx.wszAddress );
    }
    else
    {
        pRasConnection1->PppInfo.ipx.wszAddress[0]      = (WCHAR)NULL;
    }

    pRasConnection1->PppInfo.at.dwError =
                            pConnObj->PppProjectionResult.at.dwError;

    if ( pRasConnection1->PppInfo.at.dwError == NO_ERROR )
    {
        ConvertAtAddressToString(
                            ( pConnObj->InterfaceType == ROUTER_IF_TYPE_CLIENT )
                            ? pConnObj->PppProjectionResult.at.dwRemoteAddress
                            : pConnObj->PppProjectionResult.at.dwLocalAddress,
                              pRasConnection1->PppInfo.at.wszAddress );
    }
    else
    {
        pRasConnection1->PppInfo.at.wszAddress[0]      = (WCHAR)NULL;
    }

    pRasConnection1->dwBytesXmited  = pStats->S_Statistics[BYTES_XMITED];
    pRasConnection1->dwBytesRcved   = pStats->S_Statistics[BYTES_RCVED];
    pRasConnection1->dwFramesXmited = pStats->S_Statistics[FRAMES_XMITED];
    pRasConnection1->dwFramesRcved  = pStats->S_Statistics[FRAMES_RCVED];
    pRasConnection1->dwCrcErr       = pStats->S_Statistics[CRC_ERR];
    pRasConnection1->dwTimeoutErr   = pStats->S_Statistics[TIMEOUT_ERR];
    pRasConnection1->dwAlignmentErr = pStats->S_Statistics[ALIGNMENT_ERR];
    pRasConnection1->dwFramingErr   = pStats->S_Statistics[FRAMING_ERR];
    pRasConnection1->dwHardwareOverrunErr
                            = pStats->S_Statistics[HARDWARE_OVERRUN_ERR];
    pRasConnection1->dwBufferOverrunErr
                            = pStats->S_Statistics[BUFFER_OVERRUN_ERR];

    pRasConnection1->dwCompressionRatioIn
                            = pStats->S_Statistics[COMPRESSION_RATIO_IN];
    pRasConnection1->dwCompressionRatioOut
                            = pStats->S_Statistics[COMPRESSION_RATIO_OUT];

    return( NO_ERROR );
}

//**
//
// Call:        GetRasConnection2Data
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Given a pointer to a CONNECTION_OBJECT structure will extract
//              all relevent information and insert it into a RAS_CONNECTION_2
//              structure.
//
DWORD
GetRasiConnection2Data(
    IN  PCONNECTION_OBJECT      pConnObj,
    OUT PRASI_CONNECTION_2      pRasConnection2
)
{
    pRasConnection2->dwConnection        = PtrToUlong(pConnObj->hConnection);
    pRasConnection2->guid               = pConnObj->guid;
    pRasConnection2->dwInterfaceType    = pConnObj->InterfaceType;
    wcscpy( pRasConnection2->wszUserName, pConnObj->wchUserName );

    pRasConnection2->PppInfo2.nbf.dwError =
                            pConnObj->PppProjectionResult.nbf.dwError;

    if ( pRasConnection2->PppInfo2.nbf.dwError == NO_ERROR )
    {
        wcscpy( pRasConnection2->PppInfo2.nbf.wszWksta,
                            pConnObj->PppProjectionResult.nbf.wszWksta );
    }
    else
    {
        pRasConnection2->PppInfo2.nbf.wszWksta[0] = (WCHAR)NULL;
    }

    pRasConnection2->PppInfo2.ip.dwError =
                            pConnObj->PppProjectionResult.ip.dwError;

    if ( pRasConnection2->PppInfo2.ip.dwError == NO_ERROR )
    {
        ConvertIpAddressToString(
                            pConnObj->PppProjectionResult.ip.dwLocalAddress,
                            pRasConnection2->PppInfo2.ip.wszAddress );

        ConvertIpAddressToString(
                            pConnObj->PppProjectionResult.ip.dwRemoteAddress,
                            pRasConnection2->PppInfo2.ip.wszRemoteAddress );

        pRasConnection2->PppInfo2.ip.dwOptions       = 0;
        pRasConnection2->PppInfo2.ip.dwRemoteOptions = 0;

        if ( pConnObj->PppProjectionResult.ip.fSendVJHCompression )
        {
            pRasConnection2->PppInfo2.ip.dwOptions |= PPP_IPCP_VJ;
        }

        if ( pConnObj->PppProjectionResult.ip.fReceiveVJHCompression )
        {
            pRasConnection2->PppInfo2.ip.dwRemoteOptions |= PPP_IPCP_VJ;
        }
    }
    else
    {
        pRasConnection2->PppInfo2.ip.wszAddress[0]       = (WCHAR)NULL;
        pRasConnection2->PppInfo2.ip.wszRemoteAddress[0] = (WCHAR)NULL;
    }

    pRasConnection2->PppInfo2.ipx.dwError =
                            pConnObj->PppProjectionResult.ipx.dwError;

    if ( pRasConnection2->PppInfo2.ipx.dwError == NO_ERROR )
    {
        ConvertIpxAddressToString(
                            ( pConnObj->InterfaceType == ROUTER_IF_TYPE_CLIENT )
                            ? pConnObj->PppProjectionResult.ipx.bRemoteAddress
                            : pConnObj->PppProjectionResult.ipx.bLocalAddress,
                            pRasConnection2->PppInfo2.ipx.wszAddress );
    }
    else
    {
        pRasConnection2->PppInfo2.ipx.wszAddress[0]      = (WCHAR)NULL;
    }

    pRasConnection2->PppInfo2.at.dwError =
                            pConnObj->PppProjectionResult.at.dwError;

    if ( pRasConnection2->PppInfo2.at.dwError == NO_ERROR )
    {
        ConvertAtAddressToString(
                            ( pConnObj->InterfaceType == ROUTER_IF_TYPE_CLIENT )
                            ? pConnObj->PppProjectionResult.at.dwRemoteAddress
                            : pConnObj->PppProjectionResult.at.dwLocalAddress,
                              pRasConnection2->PppInfo2.at.wszAddress );
    }
    else
    {
        pRasConnection2->PppInfo2.at.wszAddress[0]      = (WCHAR)NULL;
    }

    pRasConnection2->PppInfo2.ccp.dwError =
                            pConnObj->PppProjectionResult.ccp.dwError;

    if ( pRasConnection2->PppInfo2.ccp.dwError == NO_ERROR )
    {
        pRasConnection2->PppInfo2.ccp.dwCompressionAlgorithm = 0;

        if ( pConnObj->PppProjectionResult.ccp.dwSendProtocol == 0x12 )
        {
            pRasConnection2->PppInfo2.ccp.dwCompressionAlgorithm = RASCCPCA_MPPC;
        }

        pRasConnection2->PppInfo2.ccp.dwOptions = 
                        pConnObj->PppProjectionResult.ccp.dwSendProtocolData;

        pRasConnection2->PppInfo2.ccp.dwRemoteCompressionAlgorithm = 0;

        if ( pConnObj->PppProjectionResult.ccp.dwReceiveProtocol == 0x12 )
        {
            pRasConnection2->PppInfo2.ccp.dwRemoteCompressionAlgorithm = RASCCPCA_MPPC;
        }

        pRasConnection2->PppInfo2.ccp.dwRemoteOptions =     
                        pConnObj->PppProjectionResult.ccp.dwReceiveProtocolData;
    }

    pRasConnection2->PppInfo2.lcp.dwError = NO_ERROR;

    pRasConnection2->PppInfo2.lcp.dwAuthenticationProtocol =
                    pConnObj->PppProjectionResult.lcp.dwLocalAuthProtocol;

    pRasConnection2->PppInfo2.lcp.dwAuthenticationData =
                    pConnObj->PppProjectionResult.lcp.dwLocalAuthProtocolData;

    pRasConnection2->PppInfo2.lcp.dwEapTypeId =
                    pConnObj->PppProjectionResult.lcp.dwLocalEapTypeId;

    pRasConnection2->PppInfo2.lcp.dwTerminateReason = NO_ERROR;

    pRasConnection2->PppInfo2.lcp.dwOptions = 0;

    if ( pConnObj->PppProjectionResult.lcp.dwLocalFramingType & PPP_MULTILINK_FRAMING )
    {
        pRasConnection2->PppInfo2.lcp.dwOptions |= PPP_LCP_MULTILINK_FRAMING;
    }

    if ( pConnObj->PppProjectionResult.lcp.dwLocalOptions & PPPLCPO_PFC )
    {
        pRasConnection2->PppInfo2.lcp.dwOptions |= PPP_LCP_PFC;
    }

    if ( pConnObj->PppProjectionResult.lcp.dwLocalOptions & PPPLCPO_ACFC )
    {
        pRasConnection2->PppInfo2.lcp.dwOptions |= PPP_LCP_ACFC;
    } 

    if ( pConnObj->PppProjectionResult.lcp.dwLocalOptions & PPPLCPO_SSHF )
    {
        pRasConnection2->PppInfo2.lcp.dwOptions |= PPP_LCP_SSHF;
    }

    if ( pConnObj->PppProjectionResult.lcp.dwLocalOptions & PPPLCPO_DES_56 )
    {
        pRasConnection2->PppInfo2.lcp.dwOptions |= PPP_LCP_DES_56;
    }

    if ( pConnObj->PppProjectionResult.lcp.dwLocalOptions & PPPLCPO_3_DES )
    {
        pRasConnection2->PppInfo2.lcp.dwOptions |= PPP_LCP_3_DES;
    }

    pRasConnection2->PppInfo2.lcp.dwRemoteAuthenticationProtocol =
                    pConnObj->PppProjectionResult.lcp.dwRemoteAuthProtocol;

    pRasConnection2->PppInfo2.lcp.dwRemoteAuthenticationData =
                    pConnObj->PppProjectionResult.lcp.dwRemoteAuthProtocolData;

    pRasConnection2->PppInfo2.lcp.dwRemoteEapTypeId =
                    pConnObj->PppProjectionResult.lcp.dwRemoteEapTypeId;

    pRasConnection2->PppInfo2.lcp.dwRemoteTerminateReason = NO_ERROR;

    pRasConnection2->PppInfo2.lcp.dwRemoteOptions = 0;

    if ( pConnObj->PppProjectionResult.lcp.dwRemoteFramingType & PPP_MULTILINK_FRAMING )
    {
        pRasConnection2->PppInfo2.lcp.dwRemoteOptions |= PPP_LCP_MULTILINK_FRAMING;
    }

    if ( pConnObj->PppProjectionResult.lcp.dwRemoteOptions & PPPLCPO_PFC )
    {
        pRasConnection2->PppInfo2.lcp.dwRemoteOptions |= PPP_LCP_PFC;
    }

    if ( pConnObj->PppProjectionResult.lcp.dwRemoteOptions & PPPLCPO_ACFC )
    {
        pRasConnection2->PppInfo2.lcp.dwRemoteOptions |= PPP_LCP_ACFC;
    }

    if ( pConnObj->PppProjectionResult.lcp.dwRemoteOptions & PPPLCPO_SSHF )
    {
        pRasConnection2->PppInfo2.lcp.dwRemoteOptions |= PPP_LCP_SSHF;
    }

    if ( pConnObj->PppProjectionResult.lcp.dwRemoteOptions & PPPLCPO_DES_56 )
    {
        pRasConnection2->PppInfo2.lcp.dwRemoteOptions |= PPP_LCP_DES_56;
    }

    if ( pConnObj->PppProjectionResult.lcp.dwRemoteOptions & PPPLCPO_3_DES )
    {
        pRasConnection2->PppInfo2.lcp.dwRemoteOptions |= PPP_LCP_3_DES;
    }

    return( NO_ERROR );
}

DWORD
GetRasConnection0Data(
    IN  PCONNECTION_OBJECT  pConnObj,
    OUT PRAS_CONNECTION_0   pRasConn0
)
{
#ifdef _WIN64

    DWORD dwErr;
    RASI_CONNECTION_0     RasiConn0;

    dwErr = GetRasiConnection0Data(pConnObj, &RasiConn0);
    if (dwErr == NO_ERROR)
    {
        pRasConn0->hConnection         = UlongToPtr(RasiConn0.dwConnection);
        pRasConn0->hInterface          = UlongToPtr(RasiConn0.dwInterface);
        pRasConn0->dwConnectDuration   = RasiConn0.dwConnectDuration;
        pRasConn0->dwInterfaceType     = RasiConn0.dwInterfaceType;
        pRasConn0->dwConnectionFlags   = RasiConn0.dwConnectionFlags;
        
        wcscpy(pRasConn0->wszInterfaceName, RasiConn0.wszInterfaceName);
        wcscpy(pRasConn0->wszUserName,      RasiConn0.wszUserName);
        wcscpy(pRasConn0->wszLogonDomain,   RasiConn0.wszLogonDomain);
        wcscpy(pRasConn0->wszRemoteComputer,RasiConn0.wszRemoteComputer);        
    }

    return dwErr;                
    
#else

    return GetRasiConnection0Data(pConnObj, (PRASI_CONNECTION_0)pRasConn0);

#endif
}

DWORD
GetRasConnection1Data(
    IN  PCONNECTION_OBJECT  pConnObj,
    OUT PRAS_CONNECTION_1   pRasConn1
)
{
#ifdef _WIN64

    DWORD dwErr;
    RASI_CONNECTION_1     RasiConn1;

    dwErr = GetRasiConnection1Data(pConnObj, &RasiConn1);
    if (dwErr == NO_ERROR)
    {
        pRasConn1->hConnection          = UlongToPtr(RasiConn1.dwConnection);
        pRasConn1->hInterface           = UlongToPtr(RasiConn1.dwInterface);
        pRasConn1->PppInfo              = RasiConn1.PppInfo;
        pRasConn1->dwBytesXmited        = RasiConn1.dwBytesXmited;
        pRasConn1->dwBytesRcved         = RasiConn1.dwBytesRcved;
        pRasConn1->dwFramesXmited       = RasiConn1.dwFramesXmited;
        pRasConn1->dwFramesRcved        = RasiConn1.dwFramesRcved;
        pRasConn1->dwCrcErr             = RasiConn1.dwCrcErr;
        pRasConn1->dwTimeoutErr         = RasiConn1.dwTimeoutErr;
        pRasConn1->dwAlignmentErr       = RasiConn1.dwAlignmentErr;
        pRasConn1->dwHardwareOverrunErr = RasiConn1.dwHardwareOverrunErr;
        pRasConn1->dwFramingErr         = RasiConn1.dwFramingErr;
        pRasConn1->dwBufferOverrunErr   = RasiConn1.dwBufferOverrunErr;
        pRasConn1->dwCompressionRatioIn = RasiConn1.dwCompressionRatioIn;
        pRasConn1->dwCompressionRatioOut= RasiConn1.dwCompressionRatioOut;
    }

    return dwErr;                
    
#else

    return GetRasiConnection1Data(pConnObj, (PRASI_CONNECTION_1)pRasConn1);
    
#endif    
}

DWORD
GetRasConnection2Data(
    IN  PCONNECTION_OBJECT  pConnObj,
    OUT PRAS_CONNECTION_2   pRasConn2
)
{
#ifdef _WIN64

    DWORD dwErr;
    RASI_CONNECTION_2     RasiConn2;

    dwErr = GetRasiConnection2Data(pConnObj, &RasiConn2);
    if (dwErr == NO_ERROR)
    {
        pRasConn2->hConnection     = UlongToPtr(RasiConn2.dwConnection);
        pRasConn2->dwInterfaceType = RasiConn2.dwInterfaceType;
        pRasConn2->guid            = RasiConn2.guid;
        pRasConn2->PppInfo2        = RasiConn2.PppInfo2;

        wcscpy(pRasConn2->wszUserName,  RasiConn2.wszUserName);
    }

    return dwErr;                
    
#else

    return GetRasiConnection2Data(pConnObj, (PRASI_CONNECTION_2)pRasConn2);
    
#endif    
}
//**
//
// Call:        GetRasiPort0Data
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Given a pointer to a DEVICE_OBJECT structure will extract all
//              relevent information and insert it into a RAS_PORT_0 structure.
//
DWORD
GetRasiPort0Data(
    IN  PDEVICE_OBJECT      pDevObj,
    OUT PRASI_PORT_0        pRasPort0
)
{

    pRasPort0->dwPort               = PtrToUlong(pDevObj->hPort);
    pRasPort0->dwConnection         = PtrToUlong(pDevObj->hConnection);
    pRasPort0->dwTotalNumberOfCalls = pDevObj->dwTotalNumberOfCalls;
    pRasPort0->dwConnectDuration    = 0;
    wcscpy( pRasPort0->wszPortName,     pDevObj->wchPortName );
    wcscpy( pRasPort0->wszMediaName,    pDevObj->wchMediaName );
    wcscpy( pRasPort0->wszDeviceName,   pDevObj->wchDeviceName );
    wcscpy( pRasPort0->wszDeviceType,   pDevObj->wchDeviceType );


    if ( pDevObj->fFlags & DEV_OBJ_OPENED_FOR_DIALOUT )
    {
        RASCONNSTATUS ConnectionStatus;

        ConnectionStatus.dwSize = sizeof( RASCONNSTATUS );

        if ( RasGetConnectStatus( pDevObj->hRasConn, &ConnectionStatus ) )
        {
            //
            // On any error we assume the port is disconnected and closed.
            //

            pRasPort0->dwPortCondition = RAS_PORT_LISTENING;

            return( NO_ERROR );
        }

        switch( ConnectionStatus.rasconnstate )
        {
        case RASCS_OpenPort:
        case RASCS_PortOpened:
        case RASCS_ConnectDevice:
        case RASCS_DeviceConnected:
        case RASCS_AllDevicesConnected:
        case RASCS_Authenticate:
        case RASCS_AuthNotify:
        case RASCS_AuthRetry:
        case RASCS_AuthChangePassword:
        case RASCS_AuthLinkSpeed:
        case RASCS_AuthAck:
        case RASCS_ReAuthenticate:
        case RASCS_AuthProject:
        case RASCS_StartAuthentication:
        case RASCS_LogonNetwork:
        case RASCS_RetryAuthentication:
        case RASCS_CallbackComplete:
        case RASCS_PasswordExpired:
            pRasPort0->dwPortCondition = RAS_PORT_AUTHENTICATING;
            break;

        case RASCS_CallbackSetByCaller:
        case RASCS_AuthCallback:
        case RASCS_PrepareForCallback:
        case RASCS_WaitForModemReset:
        case RASCS_WaitForCallback:
            pRasPort0->dwPortCondition = RAS_PORT_LISTENING;
            break;

        case RASCS_Projected:
        case RASCS_Authenticated:
            pRasPort0->dwPortCondition = RAS_PORT_AUTHENTICATED;
            break;

        case RASCS_SubEntryConnected:
        case RASCS_Connected:
            pRasPort0->dwPortCondition = RAS_PORT_AUTHENTICATED;
            pRasPort0->dwConnectDuration =
                        GetActiveTimeInSeconds( &(pDevObj->qwActiveTime) );
            break;

        case RASCS_Disconnected:
        case RASCS_SubEntryDisconnected:
            pRasPort0->dwPortCondition = RAS_PORT_DISCONNECTED;
            break;

        case RASCS_Interactive:
        default:
            pRasPort0->dwPortCondition = RAS_PORT_DISCONNECTED;
            break;
        }

        return( NO_ERROR );
    }

    switch( pDevObj->DeviceState )
    {
    case DEV_OBJ_LISTENING:
        pRasPort0->dwPortCondition   = RAS_PORT_LISTENING;
        break;

    case DEV_OBJ_HW_FAILURE:
        pRasPort0->dwPortCondition   = RAS_PORT_NON_OPERATIONAL;
        break;

    case DEV_OBJ_RECEIVING_FRAME:
    case DEV_OBJ_LISTEN_COMPLETE:
    case DEV_OBJ_AUTH_IS_ACTIVE:
        pRasPort0->dwPortCondition   = RAS_PORT_AUTHENTICATING;
        break;

    case DEV_OBJ_ACTIVE:
        pRasPort0->dwPortCondition   = RAS_PORT_AUTHENTICATED;
        pRasPort0->dwConnectDuration =
                        GetActiveTimeInSeconds( &(pDevObj->qwActiveTime) );
        break;

    case DEV_OBJ_CALLBACK_DISCONNECTING:
    case DEV_OBJ_CALLBACK_DISCONNECTED:
    case DEV_OBJ_CALLBACK_CONNECTING:
        pRasPort0->dwPortCondition   = RAS_PORT_CALLING_BACK;
        break;

    case DEV_OBJ_CLOSED:
    case DEV_OBJ_CLOSING:
        pRasPort0->dwPortCondition   = RAS_PORT_DISCONNECTED;
        break;

    default:
        ASSERT( FALSE );
    }

    return( NO_ERROR );
}

//**
//
// Call:        GetRasiPort1Data
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Given a pointer to a DEVICE_OBJECT structure will extract all
//              relevent information and insert it into a RAS_PORT_0 structure.
//
DWORD
GetRasiPort1Data(
    IN  PDEVICE_OBJECT      pDevObj,
    OUT PRASI_PORT_1        pRasPort1
)
{
    BYTE buffer[sizeof(RAS_STATISTICS) + (MAX_STATISTICS * sizeof (ULONG))];
    RAS_STATISTICS  *pStats = (RAS_STATISTICS *)buffer;
    DWORD           dwSize = sizeof (buffer);
    DWORD           dwRetCode;
    RASMAN_INFO     RasManInfo;

    pRasPort1->dwPort               = PtrToUlong(pDevObj->hPort);
    pRasPort1->dwConnection         = PtrToUlong(pDevObj->hConnection);
    pRasPort1->dwHardwareCondition =
                    ( pDevObj->DeviceState == DEV_OBJ_HW_FAILURE )
                    ? RAS_HARDWARE_FAILURE
                    : RAS_HARDWARE_OPERATIONAL;

    dwRetCode = RasGetInfo( NULL, (HPORT)pDevObj->hPort, &RasManInfo );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    pRasPort1->dwLineSpeed = RasManInfo.RI_LinkSpeed;

    dwRetCode = RasPortGetStatisticsEx(NULL, (HPORT)pDevObj->hPort,
                                      (PBYTE)pStats, &dwSize );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    pRasPort1->dwLineSpeed      = RasManInfo.RI_LinkSpeed;
    pRasPort1->dwBytesXmited    = pStats->S_Statistics[BYTES_XMITED];
    pRasPort1->dwBytesRcved     = pStats->S_Statistics[BYTES_RCVED];
    pRasPort1->dwFramesXmited   = pStats->S_Statistics[FRAMES_XMITED];
    pRasPort1->dwFramesRcved    = pStats->S_Statistics[FRAMES_RCVED];
    pRasPort1->dwCrcErr         = pStats->S_Statistics[CRC_ERR];
    pRasPort1->dwTimeoutErr     = pStats->S_Statistics[TIMEOUT_ERR];
    pRasPort1->dwAlignmentErr   = pStats->S_Statistics[ALIGNMENT_ERR];
    pRasPort1->dwFramingErr     = pStats->S_Statistics[FRAMING_ERR];
    pRasPort1->dwHardwareOverrunErr
                            = pStats->S_Statistics[HARDWARE_OVERRUN_ERR];
    pRasPort1->dwBufferOverrunErr
                            = pStats->S_Statistics[BUFFER_OVERRUN_ERR];
    pRasPort1->dwCompressionRatioIn
                            = pStats->S_Statistics[ COMPRESSION_RATIO_IN ];
    pRasPort1->dwCompressionRatioOut
                            = pStats->S_Statistics[ COMPRESSION_RATIO_OUT ];

    return( NO_ERROR );
}

DWORD
GetRasPort0Data(
    IN  PDEVICE_OBJECT      pDevObj,
    OUT PRAS_PORT_0        pRasPort0
)
{
#ifdef _WIN64

    DWORD dwErr;
    RASI_PORT_0     RasiPort0;

    dwErr = GetRasiPort0Data(pDevObj, &RasiPort0);
    if (dwErr == NO_ERROR)
    {
        pRasPort0->hPort                = UlongToPtr(RasiPort0.dwPort);
        pRasPort0->hConnection          = UlongToPtr(RasiPort0.dwConnection);
        pRasPort0->dwPortCondition      = RasiPort0.dwPortCondition;
        pRasPort0->dwTotalNumberOfCalls = RasiPort0.dwTotalNumberOfCalls;
        pRasPort0->dwConnectDuration    = RasiPort0.dwConnectDuration;
        wcscpy(pRasPort0->wszPortName,   RasiPort0.wszPortName);
        wcscpy(pRasPort0->wszMediaName,  RasiPort0.wszMediaName);
        wcscpy(pRasPort0->wszDeviceName, RasiPort0.wszDeviceName);
        wcscpy(pRasPort0->wszDeviceType, RasiPort0.wszDeviceType);
    }

    return dwErr;                
    
#else

    return GetRasiPort0Data(pDevObj, (PRASI_PORT_0)pRasPort0);

#endif
}

DWORD
GetRasPort1Data(
    IN  PDEVICE_OBJECT      pDevObj,
    OUT PRAS_PORT_1        pRasPort1
)
{
#ifdef _WIN64

    DWORD dwErr;
    RASI_PORT_1     RasiPort1;

    dwErr = GetRasiPort1Data(pDevObj, &RasiPort1);
    if (dwErr == NO_ERROR)
    {
        pRasPort1->hPort                = UlongToPtr(RasiPort1.dwPort);
        pRasPort1->hConnection          = UlongToPtr(RasiPort1.dwConnection);
        pRasPort1->dwHardwareCondition  = RasiPort1.dwHardwareCondition;
        pRasPort1->dwLineSpeed          = RasiPort1.dwLineSpeed;
        pRasPort1->dwBytesXmited        = RasiPort1.dwBytesXmited;
        pRasPort1->dwBytesRcved         = RasiPort1.dwBytesRcved;
        pRasPort1->dwFramesXmited       = RasiPort1.dwFramesXmited;
        pRasPort1->dwFramesRcved        = RasiPort1.dwFramesRcved;
        pRasPort1->dwCrcErr             = RasiPort1.dwCrcErr;
        pRasPort1->dwTimeoutErr         = RasiPort1.dwTimeoutErr;
        pRasPort1->dwAlignmentErr       = RasiPort1.dwAlignmentErr;
        pRasPort1->dwHardwareOverrunErr = RasiPort1.dwHardwareOverrunErr;
        pRasPort1->dwFramingErr         = RasiPort1.dwFramingErr;
        pRasPort1->dwBufferOverrunErr   = RasiPort1.dwBufferOverrunErr;
        pRasPort1->dwCompressionRatioIn = RasiPort1.dwCompressionRatioIn;
        pRasPort1->dwCompressionRatioOut= RasiPort1.dwCompressionRatioOut;
    }

    return dwErr;                
    
#else

    return GetRasiPort1Data(pDevObj, (PRASI_PORT_1)pRasPort1);
    
#endif    
}

//***
//
// Function:	SignalHwError
//
// Descr:
//
//***
VOID
SignalHwError(
    IN PDEVICE_OBJECT pDeviceObj
)
{
    LPWSTR	portnamep;

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM, "SignalHwErr: Entered");

    portnamep = pDeviceObj->wchPortName;

    DDMLogError( ROUTERLOG_DEV_HW_ERROR, 1, &portnamep, 0 );
}

DWORD
MapAuthCodeToLogId(
    IN WORD Code
)
{
    switch (Code)
    {
        case AUTH_ALL_PROJECTIONS_FAILED:
            return (ROUTERLOG_AUTH_NO_PROJECTIONS);
        case AUTH_PASSWORD_EXPIRED:
            return(ROUTERLOG_PASSWORD_EXPIRED);
        case AUTH_ACCT_EXPIRED:
            return(ROUTERLOG_ACCT_EXPIRED);
        case AUTH_NO_DIALIN_PRIVILEGE:
            return(ROUTERLOG_NO_DIALIN_PRIVILEGE);
        case AUTH_UNSUPPORTED_VERSION:
            return(ROUTERLOG_UNSUPPORTED_VERSION);
        case AUTH_ENCRYPTION_REQUIRED:
            return(ROUTERLOG_ENCRYPTION_REQUIRED);
    }

    return(0);
}

BOOL
IsPortOwned(
    IN PDEVICE_OBJECT pDeviceObj
)
{
    RASMAN_INFO	rasinfo;

    //
    // get the current port state
    //

    if ( RasGetInfo( NULL, pDeviceObj->hPort, &rasinfo ) != NO_ERROR )
    {
        return( FALSE );
    }

    return( rasinfo.RI_OwnershipFlag );
}

VOID
GetLoggingInfo(
    IN PDEVICE_OBJECT pDeviceObj,
    OUT PDWORD BaudRate,
    OUT PDWORD BytesSent,
    OUT PDWORD BytesRecv,
    OUT RASMAN_DISCONNECT_REASON *Reason,
    OUT SYSTEMTIME *Time
)
{
    RASMAN_INFO RasmanInfo;
    BYTE buffer[sizeof(RAS_STATISTICS) + (MAX_STATISTICS * sizeof (ULONG))];
    RAS_STATISTICS  *PortStats = (RAS_STATISTICS *)buffer;
    DWORD PortStatsSize = sizeof (buffer);

    *Reason = 3L;

    //
    // Time is a piece of cake
    //

    GetLocalTime(Time);


    //
    // Now the statistics
    //

    *BytesSent = 0L;
    *BytesRecv = 0L;

    if (RasPortGetStatisticsEx( NULL, 
                                pDeviceObj->hPort, 
                                (PBYTE)PortStats,
                                &PortStatsSize))
    {
        return;
    }

    *BytesRecv = PortStats->S_Statistics[BYTES_RCVED];
    *BytesSent = PortStats->S_Statistics[BYTES_XMITED];

    //
    // And finally the disconnect reason (local or remote) and baud rate
    //

    if (RasGetInfo(NULL, pDeviceObj->hPort, &RasmanInfo))
    {
        return;
    }

    *Reason = RasmanInfo.RI_DisconnectReason;
    *BaudRate = GetLineSpeed(pDeviceObj->hPort);

    return;
}

DWORD
GetLineSpeed(
    IN HPORT hPort
)
{
   RASMAN_INFO RasManInfo;

   if (RasGetInfo(NULL, hPort, &RasManInfo))
   {
      return 0;
   }

   return (RasManInfo.RI_LinkSpeed);
}


VOID
LogConnectionEvent(
    IN PCONNECTION_OBJECT pConnObj,
    IN PDEVICE_OBJECT     pDeviceObj
)
{
    DWORD BaudRate = 0;
    DWORD BytesSent;
    DWORD BytesRecv;
    RASMAN_DISCONNECT_REASON Reason;
    SYSTEMTIME DiscTime;
    LPWSTR auditstrp[12];
    WCHAR *ReasonStr;
    WCHAR BytesRecvStr[20];
    WCHAR BytesSentStr[20];
    WCHAR BaudRateStr[20];
    WCHAR DateConnected[64];
    WCHAR DateDisconnected[64];
    WCHAR TimeConnected[64];
    WCHAR TimeDisconnected[64];
    DWORD active_time;
    WCHAR minutes[20];
    WCHAR seconds[4];
    WCHAR wchFullUserName[UNLEN+DNLEN+2];

    WCHAR *DiscReasons[] =
    {
        gblpszAdminRequest,
        gblpszUserRequest,
        gblpszHardwareFailure,
        gblpszUnknownReason
    };

    GetLoggingInfo( pDeviceObj, &BaudRate, &BytesSent,
                    &BytesRecv, &Reason, &DiscTime);

    wcscpy(TimeConnected, L"");
    wcscpy(DateConnected, L"");
    wcscpy(TimeDisconnected, L"");
    wcscpy(DateDisconnected, L"");

    GetTimeFormat(
        LOCALE_SYSTEM_DEFAULT,
        TIME_NOSECONDS,
        &pDeviceObj->ConnectionTime,
        NULL,
        TimeConnected,
        sizeof(TimeConnected)/sizeof(WCHAR));
        
    GetDateFormat(
        LOCALE_SYSTEM_DEFAULT,
        DATE_SHORTDATE,
        &pDeviceObj->ConnectionTime,
        NULL,
        DateConnected,
        sizeof(DateConnected)/sizeof(WCHAR));
        
    GetTimeFormat(
        LOCALE_SYSTEM_DEFAULT,
        TIME_NOSECONDS,
        &DiscTime,
        NULL,
        TimeDisconnected,
        sizeof(TimeDisconnected)/sizeof(WCHAR));
        
    GetDateFormat(
        LOCALE_SYSTEM_DEFAULT,
        DATE_SHORTDATE,
        &DiscTime,
        NULL,
        DateDisconnected,
        sizeof(DateDisconnected)/sizeof(WCHAR));
        
    active_time = GetActiveTimeInSeconds( &(pDeviceObj->qwActiveTime) );

    DDM_PRINT(  gblDDMConfigInfo.dwTraceId,  TRACE_FSM,
                    "CLIENT ACTIVE FOR %li SECONDS", active_time);

    _itow(active_time / 60, minutes, 10);
    _itow(active_time % 60, seconds, 10);

    wsprintf(BytesSentStr, TEXT("%u"), BytesSent);
    wsprintf(BytesRecvStr, TEXT("%u"), BytesRecv);
    wsprintf(BaudRateStr, TEXT("%i"), BaudRate);
    ReasonStr = DiscReasons[Reason];

    if ( pConnObj->wchDomainName[0] != TEXT('\0') )
    {
        wcscpy( wchFullUserName, pConnObj->wchDomainName );
        wcscat( wchFullUserName, TEXT("\\") );
        wcscat( wchFullUserName, pConnObj->wchUserName );
    }
    else
    {
        wcscpy( wchFullUserName, pConnObj->wchUserName );
    }

    auditstrp[0]    = wchFullUserName;
    auditstrp[1]    = pDeviceObj->wchPortName;
    auditstrp[2]    = DateConnected;
    auditstrp[3]    = TimeConnected;
    auditstrp[4]    = DateDisconnected;
    auditstrp[5]    = TimeDisconnected;
    auditstrp[6]    = minutes;
    auditstrp[7]    = seconds;
    auditstrp[8]    = BytesSentStr;
    auditstrp[9]    = BytesRecvStr;

    if(RAS_DEVICE_CLASS(pDeviceObj->dwDeviceType) == RDT_Tunnel)
    {
        auditstrp[10]   = DiscReasons[Reason];
        auditstrp[11]   = NULL;
        DDMLogInformation( ROUTERLOG_USER_ACTIVE_TIME_VPN, 11, auditstrp );
    }
    else
    {
        auditstrp[10]   = BaudRateStr;
        auditstrp[11]   = DiscReasons[Reason];
        DDMLogInformation( ROUTERLOG_USER_ACTIVE_TIME, 12, auditstrp );
    }

    if(pConnObj->PppProjectionResult.ip.dwError == NO_ERROR)
    {
        WCHAR *pszAddress = GetIpAddress(
                pConnObj->PppProjectionResult.ip.dwRemoteAddress);
                
        auditstrp[0] = pszAddress;

        DDMLogInformation( ROUTERLOG_IP_USER_DISCONNECTED, 1, auditstrp);
        LocalFree(pszAddress);
    }
}

//**
//
// Call:        GetTransportIndex
//
// Returns:     Index of the tansport entry in the interface object
//
// Description: Given the id of a protocol return an index.
//
DWORD
GetTransportIndex(
    IN DWORD dwProtocolId
)
{
    DWORD dwTransportIndex;

    for ( dwTransportIndex = 0;
          dwTransportIndex < gblDDMConfigInfo.dwNumRouterManagers;
          dwTransportIndex++ )
    {
        if ( gblRouterManagers[dwTransportIndex].DdmRouterIf.dwProtocolId
                                                            == dwProtocolId )
        {
            return( dwTransportIndex );
        }
    }

    return( (DWORD)-1 );
}

//**
//
// Call:        DDMCleanUp
//
// Returns:     None
//
// Description: Will clean up all DDM allocations
//
VOID
DDMCleanUp(
    VOID
)
{
    DWORD   dwIndex;

    if(gblDDMConfigInfo.dwServerFlags & PPPCFG_AudioAccelerator)
    {
        //
        // Cleanup rasaudio stuff.
        // 
        (void) RasEnableRasAudio(NULL, FALSE);
    }

    if ( gblDDMConfigInfo.hIpHlpApi != NULL )
    {
        FreeLibrary( gblDDMConfigInfo.hIpHlpApi );
        gblDDMConfigInfo.hIpHlpApi = NULL;
        gblDDMConfigInfo.lpfnAllocateAndGetIfTableFromStack = NULL;
        gblDDMConfigInfo.lpfnAllocateAndGetIpAddrTableFromStack = NULL;
    }

    if ( gblDDMConfigInfo.fRasSrvrInitialized )
    {
        RasSrvrUninitialize();
        gblDDMConfigInfo.fRasSrvrInitialized = FALSE;
    }

    PppDdmDeInit();

    if ( gblDDMConfigInfo.hinstAcctModule != NULL )
    {
        DWORD dwRetCode;
        HKEY  hKeyAccounting;

        if ( gblDDMConfigInfo.lpfnRasAcctProviderTerminate != NULL )
        {
            gblDDMConfigInfo.lpfnRasAcctProviderTerminate();
        }

        //
        // Write back the AccntSessionId value
        //

        dwRetCode = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        RAS_KEYPATH_ACCOUNTING,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hKeyAccounting );

        if ( dwRetCode == NO_ERROR )
        {
            RegSetValueEx(
                        hKeyAccounting,
                        RAS_VALNAME_ACCTSESSIONID,
                        0,
                        REG_DWORD,
                        (BYTE *)(&gblDDMConfigInfo.dwAccountingSessionId),
                        4 );

            RegCloseKey( hKeyAccounting );
        }

        FreeLibrary( gblDDMConfigInfo.hinstAcctModule );

        gblDDMConfigInfo.hinstAcctModule = NULL;
    }

    DeleteCriticalSection( &(gblDDMConfigInfo.CSAccountingSessionId) );

    if ( gblDDMConfigInfo.hinstAuthModule != NULL )
    {
        if ( gblDDMConfigInfo.lpfnRasAuthProviderTerminate != NULL )
        {
            gblDDMConfigInfo.lpfnRasAuthProviderTerminate();
        }

        FreeLibrary( gblDDMConfigInfo.hinstAuthModule );

        gblDDMConfigInfo.hinstAuthModule = NULL;
    }

    if ( gblDDMConfigInfo.hkeyParameters != NULL )
    {
        RegCloseKey( gblDDMConfigInfo.hkeyParameters );

        gblDDMConfigInfo.hkeyParameters = NULL;
    }

    if ( gblDDMConfigInfo.hkeyAccounting != NULL )
    {
        RegCloseKey( gblDDMConfigInfo.hkeyParameters );

        gblDDMConfigInfo.hkeyParameters = NULL;
    }

    if ( gblDDMConfigInfo.hkeyAuthentication != NULL )
    {
        RegCloseKey( gblDDMConfigInfo.hkeyParameters );

        gblDDMConfigInfo.hkeyParameters = NULL;
    }

    if ( gblDDMConfigInfo.hInstAdminModule != NULL )
    {
        if ( gblDDMConfigInfo.lpfnRasAdminTerminateDll != NULL )
        {
            DWORD (*TerminateAdminDll)() =
                (DWORD(*)(VOID))gblDDMConfigInfo.lpfnRasAdminTerminateDll;

            TerminateAdminDll();
        }

        FreeLibrary( gblDDMConfigInfo.hInstAdminModule );
    }

    if ( gblDDMConfigInfo.hInstSecurityModule != NULL )
    {
        FreeLibrary( gblDDMConfigInfo.hInstSecurityModule );
    }

    if ( gblpRouterPhoneBook != NULL )
    {
        LOCAL_FREE( gblpRouterPhoneBook );
    }

    if ( gblpszAdminRequest != NULL )
    {
        LOCAL_FREE( gblpszAdminRequest );
    }

    if ( gblpszUserRequest != NULL )
    {
        LOCAL_FREE( gblpszUserRequest );
    }

    if ( gblpszHardwareFailure != NULL )
    {
        LOCAL_FREE( gblpszHardwareFailure );
    }

    if ( gblpszUnknownReason != NULL )
    {
        LOCAL_FREE( gblpszUnknownReason );
    }

    if ( gblpszPm != NULL )
    {
        LOCAL_FREE( gblpszPm );
    }

    if ( gblpszAm  != NULL )
    {
        LOCAL_FREE( gblpszAm  );
    }

    if( gblDDMConfigInfo.apAnalogIPAddresses != NULL )
    {
        LocalFree( gblDDMConfigInfo.apAnalogIPAddresses[0] );
        LocalFree( gblDDMConfigInfo.apAnalogIPAddresses );

        gblDDMConfigInfo.apAnalogIPAddresses = NULL;
        gblDDMConfigInfo.cAnalogIPAddresses  = 0;
    }

    if( gblDDMConfigInfo.apDigitalIPAddresses != NULL )
    {
        LocalFree( gblDDMConfigInfo.apDigitalIPAddresses[0] );
        LocalFree( gblDDMConfigInfo.apDigitalIPAddresses );

        gblDDMConfigInfo.apDigitalIPAddresses = NULL;
        gblDDMConfigInfo.cDigitalIPAddresses  = 0;
    }

    gblDDMConfigInfo.dwIndex = 0;

    if ( gblDeviceTable.DeviceBucket != NULL )
    {
        //
        // close all opened devices
        //

        DeviceObjIterator( DeviceObjClose, FALSE, NULL );
    }

    if(gblDDMConfigInfo.fRasmanReferenced)
    {
        //
        // Decerement rasman's refrence count. This does not happen
        // automatically since we are in the same process as rasman.
        //

        RasReferenceRasman( FALSE );
    }

    if ( gblSupervisorEvents != (HANDLE *)NULL )
    {
        DeleteMessageQs();

        for ( dwIndex = 0;
              dwIndex < NUM_DDM_EVENTS +
                        gblDeviceTable.NumDeviceBuckets +
                        gblDeviceTable.NumConnectionBuckets;
              dwIndex ++ )
        {
            if ( gblSupervisorEvents[dwIndex] != NULL )
            {
                switch( dwIndex )
                {
                case DDM_EVENT_SVC_TERMINATED:
                case DDM_EVENT_SVC:
                    break;

                default:
                    CloseHandle( gblSupervisorEvents[dwIndex] );
                    break;
                }

                gblSupervisorEvents[dwIndex] = NULL;
            }
        }
    }

    //
    // Wait for this to be released
    //

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    DeleteCriticalSection( &(gblDeviceTable.CriticalSection) );

    TimerQDelete();

    //
    // Release all notification events
    //

    if ( gblDDMConfigInfo.NotificationEventListHead.Flink != NULL )
    {
        while( !IsListEmpty( &(gblDDMConfigInfo.NotificationEventListHead ) ) )
        {
            NOTIFICATION_EVENT * pNotificationEvent = (NOTIFICATION_EVENT *)
               RemoveHeadList( &(gblDDMConfigInfo.NotificationEventListHead) );

            CloseHandle( pNotificationEvent->hEventClient );

            CloseHandle( pNotificationEvent->hEventRouter );

            LOCAL_FREE( pNotificationEvent );
        }
    }

    MediaObjFreeTable();

    //
    // Destroy private heap
    //

    if ( gblDDMConfigInfo.hHeap != NULL )
    {
        HeapDestroy( gblDDMConfigInfo.hHeap );
    }

    //
    // Zero out globals
    //

    ZeroMemory( &gblDeviceTable,        sizeof( gblDeviceTable ) );
    ZeroMemory( &gblMediaTable,         sizeof( gblMediaTable ) );
    ZeroMemory( gblEventHandlerTable,   sizeof( gblEventHandlerTable ) );
    //ZeroMemory( &gblDDMConfigInfo,      sizeof( gblDDMConfigInfo ) );
    gblRouterManagers           = NULL;
    gblpInterfaceTable          = NULL;
    gblSupervisorEvents         = NULL;
    gblphEventDDMServiceState   = NULL;
    gblpRouterPhoneBook         = NULL;
    gblpszAdminRequest          = NULL;
    gblpszUserRequest           = NULL;
    gblpszHardwareFailure       = NULL;
    gblpszUnknownReason         = NULL;
    gblpszPm                    = NULL;
    gblpszAm                    = NULL;

}

//**
//
// Call:        GetRouterPhoneBook
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will set the gblpRouterPhoneBook global to point to the
//              full path of the router phonebook.
//
DWORD
GetRouterPhoneBook(
    VOID
)
{
    DWORD dwSize;
    DWORD cchDir = GetWindowsDirectory( NULL, 0 );

    if ( cchDir == 0 )
    {
        return( GetLastError() );
    }

    dwSize=(cchDir+wcslen(TEXT("\\SYSTEM32\\RAS\\ROUTER.PBK"))+1)*sizeof(WCHAR);

    if ( ( gblpRouterPhoneBook = LOCAL_ALLOC( LPTR, dwSize ) ) == NULL )
    {
        return( GetLastError() );
    }

    if ( GetWindowsDirectory( gblpRouterPhoneBook, cchDir ) == 0 )
    {
        return( GetLastError() );
    }

    if ( gblpRouterPhoneBook[cchDir-1] != TEXT('\\') )
    {
        wcscat( gblpRouterPhoneBook, TEXT("\\") );
    }

    wcscat( gblpRouterPhoneBook, TEXT("SYSTEM32\\RAS\\ROUTER.PBK") );

    return( NO_ERROR );

}

//**
//
// Call:        LoadStrings
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Loads all localizable strings from the resource table
//
DWORD
LoadStrings(
    VOID
)
{
    #define MAX_XLATE_STRING 40
    LPWSTR  lpwsModuleName = TEXT("MPRDDM.DLL");

    //
    // Load strings from resource file
    //

    gblpszAdminRequest     = LOCAL_ALLOC( LPTR, MAX_XLATE_STRING*sizeof(WCHAR));
    gblpszUserRequest      = LOCAL_ALLOC( LPTR, MAX_XLATE_STRING*sizeof(WCHAR));
    gblpszHardwareFailure  = LOCAL_ALLOC( LPTR, MAX_XLATE_STRING*sizeof(WCHAR));
    gblpszUnknownReason    = LOCAL_ALLOC( LPTR, MAX_XLATE_STRING*sizeof(WCHAR));
    gblpszPm               = LOCAL_ALLOC( LPTR, MAX_XLATE_STRING*sizeof(WCHAR));
    gblpszAm               = LOCAL_ALLOC( LPTR, MAX_XLATE_STRING*sizeof(WCHAR));
    gblpszUnknown          = LOCAL_ALLOC( LPTR, MAX_XLATE_STRING*sizeof(WCHAR));


    if ( ( gblpszAdminRequest       == NULL ) ||
         ( gblpszUserRequest        == NULL ) ||
         ( gblpszHardwareFailure    == NULL ) ||
         ( gblpszUnknownReason      == NULL ) ||
         ( gblpszUnknown            == NULL ) ||
         ( gblpszPm                 == NULL ) ||
         ( gblpszAm                 == NULL ) )
    {
        return( GetLastError() );
    }

    if (( !LoadString( GetModuleHandle( lpwsModuleName ), 1,
                       gblpszAdminRequest, MAX_XLATE_STRING ))
        ||
        ( !LoadString( GetModuleHandle( lpwsModuleName ), 2,
                       gblpszUserRequest, MAX_XLATE_STRING ))
        ||
        ( !LoadString( GetModuleHandle( lpwsModuleName ), 3,
                       gblpszHardwareFailure, MAX_XLATE_STRING ))
        ||
        ( !LoadString( GetModuleHandle( lpwsModuleName ), 4,
                       gblpszUnknownReason, MAX_XLATE_STRING ))
        ||
        ( !LoadString( GetModuleHandle( lpwsModuleName) , 5,
                       gblpszAm, MAX_XLATE_STRING ))
        ||
        ( !LoadString( GetModuleHandle( lpwsModuleName ), 6,
                       gblpszPm, MAX_XLATE_STRING ))
        ||
        ( !LoadString( GetModuleHandle( lpwsModuleName) , 7,
                       gblpszUnknown, MAX_XLATE_STRING )))
    {
        return( GetLastError() );
    }

    return( NO_ERROR );

}

//**
//
// Call:        AcceptNewLink
//
// Returns:     TRUE  - Continue with link processing
//              FALSE - Abort link processing
//
// Description:
//
BOOL
AcceptNewLink(
    IN DEVICE_OBJECT *      pDeviceObj,
    IN CONNECTION_OBJECT *  pConnObj
)
{
    //
    // If admin module is loaded, notify it of a new link
    //

    if ( gblDDMConfigInfo.lpfnRasAdminAcceptNewLink != NULL )
    {
        RAS_PORT_0 RasPort0;
        RAS_PORT_1 RasPort1;
        BOOL (*MprAdminAcceptNewLink)( RAS_PORT_0 *, RAS_PORT_1 * );

        if ((GetRasPort0Data(pDeviceObj,&RasPort0) != NO_ERROR)
             ||
            (GetRasPort1Data(pDeviceObj,&RasPort1) != NO_ERROR))
        {
            DevStartClosing( pDeviceObj );

            return( FALSE );
        }

        pDeviceObj->fFlags &= (~DEV_OBJ_NOTIFY_OF_DISCONNECTION);

        MprAdminAcceptNewLink =
                (BOOL (*)( RAS_PORT_0 *, RAS_PORT_1 * ))
                            gblDDMConfigInfo.lpfnRasAdminAcceptNewLink;

        if ( !MprAdminAcceptNewLink( &RasPort0, &RasPort1 ) )
        {
            DevStartClosing( pDeviceObj );

            return( FALSE );
        }

        pDeviceObj->fFlags |= DEV_OBJ_NOTIFY_OF_DISCONNECTION;
    }

    return( TRUE );
}

//**
//
// Call:        AcceptNewConnection
//
// Returns:     TRUE  - Continue with connection processing
//              FALSE - Abort connection processing
//
// Description:
//
BOOL
AcceptNewConnection(
    IN DEVICE_OBJECT *      pDeviceObj,
    IN CONNECTION_OBJECT *  pConnObj
)
{
    //
    // If admin module is loaded, notify it of a new connection
    //

    if ( ( gblDDMConfigInfo.lpfnRasAdminAcceptNewConnection != NULL ) ||
         ( gblDDMConfigInfo.lpfnRasAdminAcceptNewConnection2 != NULL ) )
    {
        RAS_CONNECTION_0 RasConnection0;
        RAS_CONNECTION_1 RasConnection1;
        RAS_CONNECTION_2 RasConnection2;

        if ((GetRasConnection0Data(pConnObj,&RasConnection0) != NO_ERROR)
             ||
            (GetRasConnection1Data(pConnObj,&RasConnection1) != NO_ERROR)
             ||
            (GetRasConnection2Data(pConnObj,&RasConnection2) != NO_ERROR))
        {
            ConnObjDisconnect( pConnObj );

            return( FALSE );
        }

        //
        // Let callout DLL know that we do not have a username for this user
        //

        if ( _wcsicmp( RasConnection0.wszUserName, gblpszUnknown ) == 0 )
        {
            RasConnection0.wszUserName[0] = (WCHAR)NULL;
        }

        pConnObj->fFlags &= (~CONN_OBJ_NOTIFY_OF_DISCONNECTION);

        if ( gblDDMConfigInfo.lpfnRasAdminAcceptNewConnection2 != NULL )
        {
            BOOL (*MprAdminAcceptNewConnection2)(
                                RAS_CONNECTION_0 *,
                                RAS_CONNECTION_1 *,
                                RAS_CONNECTION_2 * );

            MprAdminAcceptNewConnection2 =
                (BOOL (*)(
                        RAS_CONNECTION_0 *,
                        RAS_CONNECTION_1 * ,
                        RAS_CONNECTION_2 * ))
                            gblDDMConfigInfo.lpfnRasAdminAcceptNewConnection2;

            if ( !MprAdminAcceptNewConnection2( &RasConnection0,
                                               &RasConnection1,
                                               &RasConnection2 ) )
            {
                ConnObjDisconnect( pConnObj );

                return( FALSE );
            }
        }
        else
        {

            BOOL (*MprAdminAcceptNewConnection)(
                                RAS_CONNECTION_0 *,
                                RAS_CONNECTION_1 * );

            MprAdminAcceptNewConnection =
                (BOOL (*)(
                        RAS_CONNECTION_0 *,
                        RAS_CONNECTION_1 * ))
                            gblDDMConfigInfo.lpfnRasAdminAcceptNewConnection;

            if ( !MprAdminAcceptNewConnection( &RasConnection0,
                                           &RasConnection1 ) )
            {
                ConnObjDisconnect( pConnObj );

                return( FALSE );
            }
        }

        pConnObj->fFlags |= CONN_OBJ_NOTIFY_OF_DISCONNECTION;
    }

    return( TRUE );
}

//**
//
// Call:        ConnectionHangupNotification
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
VOID
ConnectionHangupNotification(
    IN CONNECTION_OBJECT *  pConnObj
)
{
    RAS_CONNECTION_0 RasConnection0;
    RAS_CONNECTION_1 RasConnection1;
    RAS_CONNECTION_2 RasConnection2;


    if ((GetRasConnection0Data(pConnObj,&RasConnection0) == NO_ERROR) &&
        (GetRasConnection1Data(pConnObj,&RasConnection1) == NO_ERROR) &&
        (GetRasConnection2Data(pConnObj,&RasConnection2) == NO_ERROR))
    {
        if ( gblDDMConfigInfo.lpfnRasAdminConnectionHangupNotification2 != NULL)
        {
            VOID (*MprAdminConnectionHangupNotification2)( RAS_CONNECTION_0 *,
                                                           RAS_CONNECTION_1 *,
                                                           RAS_CONNECTION_2 * );
            MprAdminConnectionHangupNotification2 =
                (VOID (*)( RAS_CONNECTION_0 *,
                           RAS_CONNECTION_1 *,
                           RAS_CONNECTION_2 * ))
                     gblDDMConfigInfo.lpfnRasAdminConnectionHangupNotification2;

            MprAdminConnectionHangupNotification2( &RasConnection0,
                                                   &RasConnection1,
                                                   &RasConnection2 );
        }
        else
        {
            VOID (*MprAdminConnectionHangupNotification)( RAS_CONNECTION_0 *,
                                                          RAS_CONNECTION_1 * );
            MprAdminConnectionHangupNotification =
                (VOID (*)( RAS_CONNECTION_0 *,
                           RAS_CONNECTION_1 * ))
                      gblDDMConfigInfo.lpfnRasAdminConnectionHangupNotification;

            MprAdminConnectionHangupNotification( &RasConnection0,
                                                  &RasConnection1 );
        }
    }
}

//**
//
// Call:        GetActiveTimeInSeconds
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will return the difference, in seconds, between then time the
//              current time and the time represented by the argument passed in.
//
DWORD
GetActiveTimeInSeconds(
    IN ULARGE_INTEGER * pqwActiveTime
)
{
    ULARGE_INTEGER  qwCurrentTime;
    ULARGE_INTEGER  qwUpTime;
    DWORD           dwRemainder;

    if ( pqwActiveTime->QuadPart == 0 )
    {
        return( 0 );
    }

    GetSystemTimeAsFileTime( (FILETIME*)&qwCurrentTime );

    if ( pqwActiveTime->QuadPart > qwCurrentTime.QuadPart )
    {
        return( 0 );
    }

    qwUpTime.QuadPart = qwCurrentTime.QuadPart - pqwActiveTime->QuadPart;

    return( RtlEnlargedUnsignedDivide(qwUpTime,(DWORD)10000000,&dwRemainder));

}

//**
//
// Call:        DDMRecognizeFrame
//
// Returns:     TRUE  - Recognized
//              FALSE - Unrecognized
//
// Description: Returns whether a received packet has a recognized format
//              by the RAS server (i.e. is in the format of a data-link layer
//              protocol that is supported by RAS).
//          
//              Up though Windows 2000, this api would return true for AMB
//              or PPP packets.  
//
//              Now, only PPP packets are supported.
//
BOOL
DDMRecognizeFrame(
    IN PVOID    pvFrameBuf,         // pointer to the frame
    IN WORD     wFrameLen,          // Length in bytes of the frame
    OUT DWORD   *pProtocol          // xport id - valid only if recognized
)
{
    PBYTE   pb;
    WORD    FrameType;

    if ( wFrameLen < 16 )
    {
        DDMTRACE( "Initial frame length is less than 16, frame not recognized");
        //ASSERT( FALSE );
        return( FALSE );
    }

    //
    // Check PPP 
    //

    pb = ((PBYTE) pvFrameBuf) + 12;

    GET_USHORT(&FrameType, pb);

    switch( FrameType )
    {
    case PPP_LCP_PROTOCOL:
    case PPP_PAP_PROTOCOL:
    case PPP_CBCP_PROTOCOL:
    case PPP_BACP_PROTOCOL:
    case PPP_BAP_PROTOCOL:
    case PPP_CHAP_PROTOCOL:
    case PPP_IPCP_PROTOCOL:
    case PPP_ATCP_PROTOCOL:
    case PPP_IPXCP_PROTOCOL:
    case PPP_CCP_PROTOCOL:
    case PPP_SPAP_NEW_PROTOCOL:
    case PPP_EAP_PROTOCOL:

        *pProtocol = PPP_LCP_PROTOCOL;
        return( TRUE );

    default:

        DDMTRACE1("Initial frame has unknown header %x, frame unrecognized",
                   FrameType );
        //ASSERT( FALSE );
        break;
    }

    return( FALSE );
}

//**
//
// Call:        DDMGetIdentityAttributes
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will gather all identity attributes and return them to
//              DIM to be plumbed into the DS
//
DWORD
DDMGetIdentityAttributes(
    IN OUT ROUTER_IDENTITY_ATTRIBUTE * pRouterIdAttributes
)
{
    DWORD dwIndex;

    //
    // Get all media types used
    //

    DeviceObjIterator( DeviceObjGetType, FALSE, pRouterIdAttributes );

    for( dwIndex = 0;
         pRouterIdAttributes[dwIndex].dwVendorId != (DWORD)-1;
         dwIndex++ );

    //
    // Find out the authentication/accounting providers
    //

    if ( gblDDMConfigInfo.fFlags & DDM_USING_NT_AUTHENTICATION )
    {
        pRouterIdAttributes[dwIndex].dwVendorId = 311;
        pRouterIdAttributes[dwIndex].dwType     = 6;
        pRouterIdAttributes[dwIndex].dwValue    = 801;

        dwIndex++;
    }
    else if ( gblDDMConfigInfo.fFlags & DDM_USING_RADIUS_AUTHENTICATION )
    {
        pRouterIdAttributes[dwIndex].dwVendorId = 311;
        pRouterIdAttributes[dwIndex].dwType     = 6;
        pRouterIdAttributes[dwIndex].dwValue    = 802;

        dwIndex++;
    }

    if ( gblDDMConfigInfo.fFlags & DDM_USING_RADIUS_ACCOUNTING )
    {
        pRouterIdAttributes[dwIndex].dwVendorId = 311;
        pRouterIdAttributes[dwIndex].dwType     = 6;
        pRouterIdAttributes[dwIndex].dwValue    = 803;

        dwIndex++;
    }

    if ( gblDDMConfigInfo.fArapAllowed )
    {
        // AppleTalkRAS(ATCP): Vendor= MS, TypeMajor= 6, TypeMinor= 504
        //
        pRouterIdAttributes[dwIndex].dwVendorId = 311;
        pRouterIdAttributes[dwIndex].dwType     = 6;
        pRouterIdAttributes[dwIndex].dwValue    = 504;

        dwIndex++;
    }

    //
    // Terminate the array
    //

    pRouterIdAttributes[dwIndex].dwVendorId = (DWORD)-1;
    pRouterIdAttributes[dwIndex].dwType     = (DWORD)-1;
    pRouterIdAttributes[dwIndex].dwValue    = (DWORD)-1;

    return( NO_ERROR );
}

//**
//
// Call:        GetNextAccountingSessionId
//
// Returns:     Next Accounting session Id to use
//
// Description: Called by PPP to get the next accounting session ID
//              to use the next accouting request sent to the accounting
//              provider.
//
DWORD
GetNextAccountingSessionId(
    VOID
)
{
    DWORD  dwAccountingSessionId;

    EnterCriticalSection( &(gblDDMConfigInfo.CSAccountingSessionId) );

    dwAccountingSessionId = (gblDDMConfigInfo.dwAccountingSessionId++);

    LeaveCriticalSection( &(gblDDMConfigInfo.CSAccountingSessionId) );

    return( dwAccountingSessionId );
}

//**
//
// Call:        LoadIpHlpApiDll
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Loads iphlpapi.dll and gets the proc addresses of
//              AllocateAndGetIfTableFromStack and
//              AllocateAndGetIpAddrTableFromStack. These values are stored in
//              gblDDMConfigInfo. If anything fails, the variables in
//              gblDDMConfigInfo remain NULL, and no cleanup is necessary.
//
DWORD
LoadIpHlpApiDll(
    VOID
)
{
    DWORD   dwResult    = NO_ERROR;

    if ( gblDDMConfigInfo.hIpHlpApi != NULL )
    {
        RTASSERT( gblDDMConfigInfo.lpfnAllocateAndGetIfTableFromStack != NULL );
        RTASSERT( gblDDMConfigInfo.lpfnAllocateAndGetIpAddrTableFromStack !=
                  NULL );

        return ( NO_ERROR );
    }

    do
    {
        gblDDMConfigInfo.hIpHlpApi = LoadLibrary(TEXT("iphlpapi.dll"));

        if ( gblDDMConfigInfo.hIpHlpApi == NULL )
        {
            dwResult = GetLastError();

            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                       "LoadLibrary(iphlpapi.dll) failed: %d", dwResult);

            break;
        }

        gblDDMConfigInfo.lpfnAllocateAndGetIfTableFromStack =
            (ALLOCATEANDGETIFTABLEFROMSTACK)
            GetProcAddress( gblDDMConfigInfo.hIpHlpApi,
                            "AllocateAndGetIfTableFromStack" );

        if ( gblDDMConfigInfo.lpfnAllocateAndGetIfTableFromStack == NULL )
        {
            dwResult = GetLastError();

            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                       "GetProcAddress( AllocateAndGetIfTableFromStack ) "
                       "failed: %d", dwResult);

            break;
        }

        gblDDMConfigInfo.lpfnAllocateAndGetIpAddrTableFromStack =
            (ALLOCATEANDGETIPADDRTABLEFROMSTACK)
            GetProcAddress( gblDDMConfigInfo.hIpHlpApi,
                            "AllocateAndGetIpAddrTableFromStack" );

        if ( gblDDMConfigInfo.lpfnAllocateAndGetIpAddrTableFromStack == NULL )
        {
            dwResult = GetLastError();

            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                       "GetProcAddress( AllocateAndGetIpAddrTableFromStack ) "
                       "failed: %d", dwResult);

            break;
        }

    }
    while ( FALSE );

    if ( dwResult != NO_ERROR )
    {
        gblDDMConfigInfo.lpfnAllocateAndGetIfTableFromStack = NULL;
        gblDDMConfigInfo.lpfnAllocateAndGetIpAddrTableFromStack = NULL;

        if ( gblDDMConfigInfo.hIpHlpApi != NULL )
        {
            FreeLibrary( gblDDMConfigInfo.hIpHlpApi );
            gblDDMConfigInfo.hIpHlpApi = NULL;
        }
    }

    return( dwResult );
}

//**
//
// Call:        LogUnreachabilityEvent
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
VOID
LogUnreachabilityEvent(
    IN DWORD    dwReason,
    IN LPWSTR   lpwsInterfaceName
)
{
    DWORD dwEventLogId = 0;

    switch( dwReason )
    {
    case INTERFACE_OUT_OF_RESOURCES:
        dwEventLogId = ROUTERLOG_IF_UNREACHABLE_REASON1;
        break;
    case INTERFACE_CONNECTION_FAILURE:
        dwEventLogId = ROUTERLOG_IF_UNREACHABLE_REASON2;
        break;
    case INTERFACE_DISABLED:
        dwEventLogId = ROUTERLOG_IF_UNREACHABLE_REASON3;
        break;
    case INTERFACE_SERVICE_IS_PAUSED:
        dwEventLogId = ROUTERLOG_IF_UNREACHABLE_REASON4;
        break;
    case INTERFACE_DIALOUT_HOURS_RESTRICTION:
        dwEventLogId = ROUTERLOG_IF_UNREACHABLE_REASON5;
        break;
    case INTERFACE_NO_MEDIA_SENSE:
        dwEventLogId = ROUTERLOG_IF_UNREACHABLE_REASON6;
        break;
    case INTERFACE_NO_DEVICE:
        dwEventLogId = ROUTERLOG_IF_UNREACHABLE_REASON7;
        break;
    default:
        dwEventLogId = 0;
        break;
    }

    if ( dwEventLogId != 0 )
    {
        DDMLogInformation( dwEventLogId, 1, &lpwsInterfaceName );
    }
}

//**
//
// Call:        GetLocalNASIpAddress
//
// Returns:     IP address of Local Machine - Success
//              0                           - Failure
//
// Description: Will get the IP address of this NAS to be sent to the back-end
//              authentication module, if IP is installed on the local machine,
//              otherwise it will
//
DWORD
GetLocalNASIpAddress(
    VOID
)
{
    DWORD               dwResult, i, j, dwSize;
    DWORD               dwIpAddress;
    PMIB_IFTABLE        pIfTable;
    PMIB_IPADDRTABLE    pIpAddrTable;

    dwResult = LoadIpHlpApiDll();

    if ( dwResult != NO_ERROR )
    {
        return( 0 );
    }

    dwSize = 0;

    dwResult = gblDDMConfigInfo.lpfnAllocateAndGetIfTableFromStack(
                    &pIfTable,
                    FALSE,
                    GetProcessHeap(),
                    HEAP_ZERO_MEMORY,
                    TRUE);

    if ( dwResult != NO_ERROR )
    {
        return( 0 );
    }

    if( pIfTable->dwNumEntries == 0 )
    {
        LocalFree( pIfTable );

        return( 0 );
    }

    //
    // Ok so now we have the IF Table, get the corresponding IP Address table
    //

    dwResult = gblDDMConfigInfo.lpfnAllocateAndGetIpAddrTableFromStack(
                    &pIpAddrTable,
                    FALSE,
                    GetProcessHeap(),
                    HEAP_ZERO_MEMORY);

    if ( dwResult != NO_ERROR )
    {
        LocalFree( pIfTable );

        return( 0 );
    }

    if ( pIpAddrTable->dwNumEntries == 0 )
    {
        LocalFree( pIfTable );

        LocalFree( pIpAddrTable );

        return( 0 );
    }

    for ( i = 0; i < pIfTable->dwNumEntries; i++ )
    {
        //
        // Go through the interface trying to find a good one
        //

        if((pIfTable->table[i].dwType == MIB_IF_TYPE_PPP)  ||
           (pIfTable->table[i].dwType == MIB_IF_TYPE_SLIP) ||
           (pIfTable->table[i].dwType == MIB_IF_TYPE_LOOPBACK))
        {
            //
            // Dont want any of these
            //

            continue;
        }

        for ( j = 0; j < pIpAddrTable->dwNumEntries; j++ )
        {
            if( pIpAddrTable->table[j].dwIndex == pIfTable->table[i].dwIndex )
            {
                if( pIpAddrTable->table[j].dwAddr == 0x00000000 )
                {
                    //
                    // An invalid address
                    //

                    continue;
                }

                LocalFree( pIfTable );

                dwIpAddress = WireToHostFormat32(
                                       (CHAR*)&(pIpAddrTable->table[j].dwAddr));

                LocalFree( pIpAddrTable );

                return( dwIpAddress );
            }
        }
    }

    LocalFree( pIfTable );

    LocalFree( pIpAddrTable );

    return( 0 );
}

DWORD
ModifyDefPolicyToForceEncryption(
    IN BOOL bStrong)
{
    HANDLE hServer = NULL;
    DWORD dwErr = NO_ERROR, dwType, dwSize, dwFlags = 0;
    HKEY hkFlags = NULL;

    do
    {
        dwErr = MprAdminUserServerConnect(NULL, TRUE, &hServer);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        dwErr = MprAdminUserWriteProfFlags(
                    hServer,
                    (bStrong) ? MPR_USER_PROF_FLAG_FORCE_STRONG_ENCRYPTION
                              : MPR_USER_PROF_FLAG_FORCE_ENCRYPTION);

        // DISP_E_MEMBERNOTFOUND returned from MprAdminUserWriteProfFlags means that
        // there is no default policy either because there are no policies or because
        // there are more than one.
        //
        // If there is no default policy, then we should continue on this function
        // to clear the bits.
        //
        if ((dwErr != DISP_E_MEMBERNOTFOUND) && (dwErr != NO_ERROR))
        {
            break;
        }

        dwErr = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters",
                    0,
                    KEY_READ | KEY_WRITE,
                    &hkFlags);
        if (dwErr != ERROR_SUCCESS)
        {
            break;
        }

        dwType = REG_DWORD;
        dwSize = sizeof(DWORD);
        dwErr = RegQueryValueExW(
                    hkFlags,
                    L"ServerFlags",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwFlags,
                    &dwSize);
        if (dwErr != ERROR_SUCCESS)
        {
            break;
        }

        dwFlags &= ~PPPCFG_RequireEncryption;
        dwFlags &= ~PPPCFG_RequireStrongEncryption;

        dwErr = RegSetValueExW(
                    hkFlags,
                    L"ServerFlags",
                    0,
                    dwType,
                    (CONST BYTE*)&dwFlags,
                    dwSize);
        if (dwErr != ERROR_SUCCESS)
        {
            break;
        }


    } while (FALSE);

    // Cleanup
    {
        if (hServer)
        {
            MprAdminUserServerDisconnect(hServer);
        }
        if (hkFlags)
        {
            RegCloseKey(hkFlags);
        }
    }

    return dwErr;
}

DWORD
MungePhoneNumber(
    char  *cbphno,
    DWORD dwIndex,
    DWORD *pdwSizeofMungedPhNo,
    char  **ppszMungedPhNo
    )
{
    DWORD dwErr         = ERROR_SUCCESS;
    BOOL  fDigital      = FALSE;
    WCHAR *pwszAddress;
    char  *pszMungedPhNo;
    DWORD dwSizeofMungedPhNo;

    *ppszMungedPhNo = cbphno;
    *pdwSizeofMungedPhNo = strlen(cbphno);

    do
    {
        if(     (NULL == cbphno)
            ||  ('\0' == cbphno[0])
            ||  ('\0' == cbphno[1]))
        {
            break;
        }

        //
        // find out if the cbphno is digital or analog
        //
        if(     (   ('D' == cbphno[0])
                ||  ('d' == cbphno[0]))
            &&  (':' == cbphno[1]))
        {
            fDigital = TRUE;
        }

        if(fDigital)
        {
            if(0 == gblDDMConfigInfo.cDigitalIPAddresses)
            {
                break;
            }

            dwIndex = (dwIndex % gblDDMConfigInfo.cDigitalIPAddresses);
            pwszAddress = gblDDMConfigInfo.apDigitalIPAddresses[dwIndex];
        }
        else
        {
            if(0 == gblDDMConfigInfo.cAnalogIPAddresses)
            {
                break;
            }

            dwIndex = (dwIndex % gblDDMConfigInfo.cAnalogIPAddresses);
            pwszAddress = gblDDMConfigInfo.apAnalogIPAddresses[dwIndex];
        }

        dwSizeofMungedPhNo = strlen(cbphno)
                             + wcslen(pwszAddress)
                             + 2;  // +2 is for a space and terminating NULL;

        pszMungedPhNo = LocalAlloc(
                                LPTR,
                                dwSizeofMungedPhNo);

        if(NULL == pszMungedPhNo)
        {
            dwErr = GetLastError();
            break;
        }

        sprintf(pszMungedPhNo, "%ws %s", pwszAddress, cbphno);

        *ppszMungedPhNo = pszMungedPhNo;
        *pdwSizeofMungedPhNo = dwSizeofMungedPhNo;

    } while (FALSE);

    return dwErr;
}

WCHAR *
GetIpAddress(DWORD dwIpAddress)
{
    struct in_addr ipaddr;
    CHAR    *pszaddr;
    WCHAR   *pwszaddr = NULL;

    ipaddr.s_addr = dwIpAddress;
    
    pszaddr = inet_ntoa(ipaddr);

    if(NULL != pszaddr)
    {
        DWORD cb;
        
        cb = MultiByteToWideChar(
                    CP_ACP, 0, pszaddr, -1, NULL, 0);
                    
        pwszaddr = LocalAlloc(LPTR, cb * sizeof(WCHAR));
        
        if (pwszaddr == NULL) 
        {
            return NULL;
        }

        cb = MultiByteToWideChar(
                    CP_ACP, 0, pszaddr, -1, pwszaddr, cb);
                    
        if (!cb) 
        {
            LocalFree(pwszaddr);
            return NULL;
        }
    }

    return pwszaddr;
}




#ifdef MEM_LEAK_CHECK
//**
//
// Call:        DebugAlloc
//
// Returns:     return from HeapAlloc
//
// Description: Will use the memory table to store the pointer returned by
//              LocalAlloc
//
LPVOID
DebugAlloc(
    IN DWORD Flags,
    IN DWORD dwSize
)
{
    DWORD Index;
    LPBYTE pMem = (LPBYTE)HeapAlloc( gblDDMConfigInfo.hHeap,
                                     HEAP_ZERO_MEMORY,dwSize+8);

    if ( pMem == NULL )
        return( pMem );

    for( Index=0; Index < DDM_MEM_TABLE_SIZE; Index++ )
    {
        if ( DdmMemTable[Index] == NULL )
        {
            DdmMemTable[Index] = pMem;
            break;
        }
    }


    *((LPDWORD)pMem) = dwSize;

    pMem += 4;

    //
    // Our signature
    //

    *(pMem+dwSize)   = 0x0F;
    *(pMem+dwSize+1) = 0x0E;
    *(pMem+dwSize+2) = 0x0A;
    *(pMem+dwSize+3) = 0x0B;

    RTASSERT( Index != DDM_MEM_TABLE_SIZE );

    return( (LPVOID)pMem );
}

//**
//
// Call:        DebugFree
//
// Returns:     return from HeapFree
//
// Description: Will remove the pointer from the memory table before freeing
//              the memory block
//
BOOL
DebugFree(
    IN LPVOID pMem
)
{
    DWORD Index;

    pMem = ((LPBYTE)pMem) - 4;

    for( Index=0; Index < DDM_MEM_TABLE_SIZE; Index++ )
    {
        if ( DdmMemTable[Index] == pMem )
        {
            DdmMemTable[Index] = NULL;
            break;
        }
    }

    RTASSERT( Index != DDM_MEM_TABLE_SIZE );

    return( HeapFree( gblDDMConfigInfo.hHeap, 0, pMem ) );
}

//**
//
// Call:        DebugReAlloc
//
// Returns:     return from HeapReAlloc
//
// Description: Will change the value of the realloced pointer.
//
LPVOID
DebugReAlloc( PVOID pMem, DWORD dwSize )
{
    DWORD Index;

    if ( pMem == NULL )
    {
        RTASSERT(FALSE);
    }

    for( Index=0; Index < DDM_MEM_TABLE_SIZE; Index++ )
    {
        if ( DdmMemTable[Index] == pMem )
        {
            DdmMemTable[Index] = HeapReAlloc( gblDDMConfigInfo.hHeap,
                                              HEAP_ZERO_MEMORY,
                                              pMem, dwSize+8 );

            pMem = DdmMemTable[Index];

            *((LPDWORD)pMem) = dwSize;

            ((LPBYTE)pMem) += 4;

            //
            // Our signature
            //

            *(((LPBYTE)pMem)+dwSize)   = 0x0F;
            *(((LPBYTE)pMem)+dwSize+1) = 0x0E;
            *(((LPBYTE)pMem)+dwSize+2) = 0x0A;
            *(((LPBYTE)pMem)+dwSize+3) = 0x0B;

            break;
        }
    }

    RTASSERT( Index != DDM_MEM_TABLE_SIZE );

    return( (LPVOID)pMem );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\routerif.h ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    routerif.h
//
// Description: Prototypes of procedures in routerif.c
//
// History:     May 11,1995	    NarenG		Created original version.
//

DWORD
DDMConnectInterface(
    IN  HANDLE  hDDMInterface,
    IN  DWORD   dwProtocolId  
);

DWORD
DDMDisconnectInterface(
    IN  HANDLE  hDDMInterface,
    IN  DWORD   dwProtocolId 
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\timer.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	timer.c
//
// Description: All timer queue related funtions live here.
//
// History:
//	Nov 11,1993.	NarenG		Created original version.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>     // needed for winbase.h
#include <windows.h>    // Win32 base API's
#include "ddm.h"
#include "timer.h"
#include <rasppp.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>

//
//
// Timer queue item
//

typedef struct _TIMER_EVENT_OBJECT
{
    struct _TIMER_EVENT_OBJECT * pNext;

    struct _TIMER_EVENT_OBJECT * pPrev;
        
    TIMEOUT_HANDLER              pfuncTimeoutHandler;

    HANDLE                       hObject;

    DWORD                        dwDelta; // # of secs. to wait after prev. item

} TIMER_EVENT_OBJECT, *PTIMER_EVENT_OBJECT;

//
// Head of timer queue.
//

typedef struct _TIMER_Q 
{
    TIMER_EVENT_OBJECT * pQHead;

    CRITICAL_SECTION     CriticalSection; // Mutual exclusion around timer Q

} TIMER_Q, *PTIMER_Q;


static TIMER_Q gblTimerQ;          // Timer Queue

//**
//
// Call:        TimerQInitialize
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Initializes the gblTimerQ structure
//
DWORD
TimerQInitialize(
    VOID 
)
{
    //
    // Initialize the global timer queue
    //

    InitializeCriticalSection( &(gblTimerQ.CriticalSection) );

    return( NO_ERROR );
}

//**
//
// Call:        TimerQDelete
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Deinitializes the TimerQ
//
VOID
TimerQDelete(
    VOID
)
{
    DeleteCriticalSection( &(gblTimerQ.CriticalSection) );

    ZeroMemory( &gblTimerQ, sizeof( gblTimerQ ) );
}

//**
//
// Call:	TimerQTick
//
// Returns:	None.
//
// Description: Called each second if there are elements in the timeout queue.
//
VOID
TimerQTick(
    VOID
)
{
    TIMER_EVENT_OBJECT * pTimerEvent;
    TIMER_EVENT_OBJECT * pTimerEventTmp;

    //
    // **** Exclusion Begin ****
    //

    EnterCriticalSection( &(gblTimerQ.CriticalSection) );


    if ( ( pTimerEvent = gblTimerQ.pQHead ) == (TIMER_EVENT_OBJECT*)NULL ) 
    {
	    //
	    // *** Exclusion End ***
	    //

        LeaveCriticalSection( &(gblTimerQ.CriticalSection) );

	    return;
    }

    //
    // Decrement time on the first element 
    //

    if ( pTimerEvent->dwDelta > 0 )
    {
        (pTimerEvent->dwDelta)--; 

	    //
	    // *** Exclusion End ***
	    //

        LeaveCriticalSection( &(gblTimerQ.CriticalSection) );

	    return;
    }

    //
    // Now run through and remove all completed (delta 0) elements.
    //

    while ( ( pTimerEvent != (TIMER_EVENT_OBJECT*)NULL ) && 
            ( pTimerEvent->dwDelta == 0 ) ) 
    {
	    pTimerEvent = pTimerEvent->pNext;
    }

    if ( pTimerEvent == (TIMER_EVENT_OBJECT*)NULL )
    {
	    pTimerEvent = gblTimerQ.pQHead;

        gblTimerQ.pQHead = (TIMER_EVENT_OBJECT*)NULL;

    }
    else
    {
	    pTimerEvent->pPrev->pNext = (TIMER_EVENT_OBJECT*)NULL;

	    pTimerEvent->pPrev = (TIMER_EVENT_OBJECT*)NULL;

        pTimerEventTmp     = gblTimerQ.pQHead;

        gblTimerQ.pQHead   = pTimerEvent;

        pTimerEvent        = pTimerEventTmp;
    }

    //
    // *** Exclusion End ***
    //

    LeaveCriticalSection( &(gblTimerQ.CriticalSection) );

    //
    // Process all the timeout event objects items with delta == 0
    //

    while( pTimerEvent != (TIMER_EVENT_OBJECT*)NULL )
    {
        pTimerEvent->pfuncTimeoutHandler( pTimerEvent->hObject );

        if ( pTimerEvent->pNext == (TIMER_EVENT_OBJECT *)NULL )
        {
            LOCAL_FREE( pTimerEvent );

            pTimerEvent = (TIMER_EVENT_OBJECT*)NULL;
        }
        else
        {
            pTimerEvent = pTimerEvent->pNext;

            LOCAL_FREE( pTimerEvent->pPrev );
        }
    }
}

//**
//
// Call:	    TimerQInsert
//
// Returns:	    NO_ERROR			        - Success
//		        return from GetLastError() 	- Failure
//
// Description: Adds a timeout element into the delta queue. If the Timer is not
//	            started it is started. Since there is a LocalAlloc() call here -
//	            this may fail in which case it will simply not insert it in the
//	            queue and the request will never timeout.
//
DWORD
TimerQInsert(
    IN HANDLE           hObject,
    IN DWORD            dwTimeout,
    IN TIMEOUT_HANDLER  pfuncTimeoutHandler
)
{
    TIMER_EVENT_OBJECT * pLastEvent;
    TIMER_EVENT_OBJECT * pTimerEventWalker;
    TIMER_EVENT_OBJECT * pTimerEvent;
				
    pTimerEvent = (TIMER_EVENT_OBJECT *)LOCAL_ALLOC( LPTR,  
                                               sizeof(TIMER_EVENT_OBJECT));

    if ( pTimerEvent == (TIMER_EVENT_OBJECT *)NULL )
    {
	    return( GetLastError() );
    }

    pTimerEvent->hObject             = hObject;
    pTimerEvent->pfuncTimeoutHandler = pfuncTimeoutHandler;
	
    //
    // **** Exclusion Begin ****
    //

    EnterCriticalSection( &(gblTimerQ.CriticalSection) );

    for ( pTimerEventWalker = gblTimerQ.pQHead,
	      pLastEvent        = pTimerEventWalker;

	      ( pTimerEventWalker != NULL ) && 
	      ( pTimerEventWalker->dwDelta < dwTimeout );

   	      pLastEvent        = pTimerEventWalker,
	      pTimerEventWalker = pTimerEventWalker->pNext 
	)
    {
	    dwTimeout -= pTimerEventWalker->dwDelta;
    }

    //
    // Insert before pTimerEventWalker. If pTimerEventWalker is NULL then 
    // we insert at the end of the list.
    //
    
    if ( pTimerEventWalker == (TIMER_EVENT_OBJECT*)NULL )
    {
	    //
	    // If the list was empty
	    //

	    if ( gblTimerQ.pQHead == (TIMER_EVENT_OBJECT*)NULL )
	    {
	        gblTimerQ.pQHead   = pTimerEvent;
	        pTimerEvent->pNext = (TIMER_EVENT_OBJECT *)NULL;
	        pTimerEvent->pPrev = (TIMER_EVENT_OBJECT *)NULL;

	    }
	    else
	    {
	        pLastEvent->pNext  = pTimerEvent;
	        pTimerEvent->pPrev = pLastEvent;
	        pTimerEvent->pNext = (TIMER_EVENT_OBJECT*)NULL;
	    }
    }
    else if ( pTimerEventWalker == gblTimerQ.pQHead )
    {
	    //
	    // Insert before the first element
	    //

	    pTimerEvent->pNext          = gblTimerQ.pQHead;
	    gblTimerQ.pQHead->pPrev     = pTimerEvent;
	    gblTimerQ.pQHead->dwDelta   -= dwTimeout;
	    pTimerEvent->pPrev          = (TIMER_EVENT_OBJECT*)NULL;
	    gblTimerQ.pQHead  	        = pTimerEvent;
    }
    else
    {

	    //
	    // Insert middle element
	    //

	    pTimerEvent->pNext 	        = pLastEvent->pNext;
	    pLastEvent->pNext  	        = pTimerEvent;
	    pTimerEvent->pPrev 	        = pLastEvent;
	    pTimerEventWalker->pPrev    = pTimerEvent;
	    pTimerEventWalker->dwDelta  -= dwTimeout;
    }

    pTimerEvent->dwDelta = dwTimeout;

    //
    // *** Exclusion End ***
    //

    LeaveCriticalSection( &(gblTimerQ.CriticalSection) );

    return( NO_ERROR );
}

//**
//
// Call:	TimerQRemove
//
// Returns:	None.
//
// Description: Will remove a timeout event for a certain Id,hPort combination
//		        from the delta Q.
//
VOID
TimerQRemove(
    IN HANDLE           hObject,
    IN TIMEOUT_HANDLER  pfuncTimeoutHandler
)
{
    TIMER_EVENT_OBJECT * pTimerEvent;

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_TIMER,
               "TimerQRemove called");

    //
    // **** Exclusion Begin ****
    //

    EnterCriticalSection( &(gblTimerQ.CriticalSection) );

    for ( pTimerEvent = gblTimerQ.pQHead;

	    ( pTimerEvent != (TIMER_EVENT_OBJECT *)NULL ) &&
          ( ( pTimerEvent->pfuncTimeoutHandler != pfuncTimeoutHandler ) ||
	        ( pTimerEvent->hObject != hObject ) );
	
	    pTimerEvent = pTimerEvent->pNext
	);

    //
    // If event was not found simply return.
    //

    if ( pTimerEvent == (TIMER_EVENT_OBJECT *)NULL )
    {
    	//
    	// *** Exclusion End ***
    	//

        LeaveCriticalSection( &(gblTimerQ.CriticalSection) );

	    return;
    }

    //
    // If this is the first element to be removed
    //

    if ( pTimerEvent == gblTimerQ.pQHead )
    {
	    gblTimerQ.pQHead = pTimerEvent->pNext;

	    if ( gblTimerQ.pQHead != (TIMER_EVENT_OBJECT *)NULL )
	    {   
	        gblTimerQ.pQHead->pPrev     = (TIMER_EVENT_OBJECT*)NULL;
	        gblTimerQ.pQHead->dwDelta   += pTimerEvent->dwDelta;
	    }
    }
    else if ( pTimerEvent->pNext == (TIMER_EVENT_OBJECT*)NULL )
    {
	    //
	    // If this was the last element to be removed
	    //

	    pTimerEvent->pPrev->pNext = (TIMER_EVENT_OBJECT*)NULL;
    }
    else
    {
        pTimerEvent->pNext->dwDelta += pTimerEvent->dwDelta;
        pTimerEvent->pPrev->pNext   = pTimerEvent->pNext;
        pTimerEvent->pNext->pPrev   = pTimerEvent->pPrev;
    }

    //
    // *** Exclusion End ***
    //

    LeaveCriticalSection( &(gblTimerQ.CriticalSection) );

    LOCAL_FREE( pTimerEvent );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\svchand.c ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:	svchand.c
//
// Description: This module contains procedures to handle DDM service state
//              changes and startup initialization.
//
// History:     May 11,1995	    NarenG		Created original version.
//

#define _ALLOCATE_DDM_GLOBALS_
#include "ddm.h"
#include "objects.h"
#include "handlers.h"
#include "rasmanif.h"
#include "util.h"
#include <ddmif.h>
#include <ddmparms.h>
#include "timer.h"
#include "rassrvr.h"

DWORD
EventDispatcher(
    IN LPVOID arg
);

//***
//
// Function:	DDMServiceStopComplete
//
// Descr:	called by each device which has closed. Checks if all devices
//		are closed and if true signals the event dispatcher to
//		exit the "forever" loop and return.
//
//***

VOID
DDMServiceStopComplete(
    VOID
)
{
    //
    // check if all devices have been stopped
    //

    if ( DeviceObjIterator( DeviceObjIsClosed, TRUE, NULL ) != NO_ERROR )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	               "ServiceStopComplete:there are device pending close");

        //
	    // there are still unclosed devices
        //

        return;
    }

    //
    //*** All Devices Are Closed at the Supervisor Level ***
    //

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
               "ServiceStopComplete: ALL devices closed");

    //
    // Notify connections that the service has stopped.
    //
    {
        RASEVENT RasEvent;

        ZeroMemory((PBYTE) &RasEvent, sizeof(RASEVENT));

        RasEvent.Type = SERVICE_EVENT;
        RasEvent.Event   = RAS_SERVICE_STOPPED;
        RasEvent.Service = REMOTEACCESS;

        (void) RasSendNotification(&RasEvent);
    }

    //
    // notify the DIM that DDM has terminated. This will also cause the
    // event dispatcher and timer threads to die.
    //

    SetEvent( gblSupervisorEvents[DDM_EVENT_SVC_TERMINATED] );
}

//***
//
//  Function:	DDMServiceTerminate
//
//  Descr:	deallocates all resources and closes all dialin devices
//
//***

VOID
DDMServiceTerminate(
    VOID
)
{
    //
    // Disconnect all connected DDM interfaces
    //

    IfObjectDisconnectInterfaces();

    //
    // Wait for all disconenct notificaions to be processed
    //

    Sleep( 2000L );

    DeviceObjIterator( DeviceObjStartClosing, FALSE, NULL );

    //
    // UnRegister the notifier form rasman
    //
    (void) RasRegisterPnPHandler( (PAPCFUNC) DdmDevicePnpHandler,
                                   NULL,
                                   FALSE);

    //
    // check if all devices are closed and terminate if true
    //

    DDMServiceStopComplete();
}

//***
//
// Function:	DDMServicePause
//
// Descr:	disables listening on any active listenning ports. Sets
//		service global state to RAS_SERVICE_PAUSED. No new listen
//		will be posted when a client terminates.
//
//***

VOID
DDMServicePause(
    VOID
)
{
    WORD i;
    PDEVICE_OBJECT pDeviceObj;

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,"SvServicePause: Entered");

    //
    // Close all active listenning ports
    //

    DeviceObjIterator( DeviceObjCloseListening, FALSE, NULL );

    //
    // Notify all interfaces that they are not reachable
    //

    IfObjectNotifyAllOfReachabilityChange( FALSE, INTERFACE_SERVICE_IS_PAUSED );
}

//***
//
// Function:	DDMServiceResume
//
// Descr:	resumes listening on all ports.
//
//***
VOID
DDMServiceResume(
    VOID
)
{
    WORD i;
    PDEVICE_OBJECT pDeviceObj;

    DDM_PRINT(gblDDMConfigInfo.dwTraceId,TRACE_FSM,"SvServiceResume: Entered");

    //
    // resume listening on all closed devices
    //

    DeviceObjIterator( DeviceObjResumeListening, FALSE, NULL );

    //
    // Notify all interfaces that they are reachable now.
    //

    IfObjectNotifyAllOfReachabilityChange( TRUE, INTERFACE_SERVICE_IS_PAUSED );
}

//***
//
//  Function:	    DDMServiceInitialize
//
//  Descrption:	    It does init work as follows:
//		                Loads the configuration parameters
//                      Loads the security module if there is one.
//		                Creates the event flags
//		                Initializes the message DLL
//		                Opens all dialin devices
//		                Initializes the DCBs
//		                Initializes the authentication DLL
//		                Posts listen on all opened dialin devices
//
//                  NOTE: Also changing the working set size for this process
//                        will change it for all the services in this process.
//                        Is this OK?
//                        What do we do about the security check call?
//
//  Returns:	    NO_ERROR - Sucess
//                  non-zero - Failure
//
//***
DWORD
DDMServiceInitialize(
    IN DIM_INFO * DimInfo
)
{
    DWORD           dwIndex;
    DWORD           ThreadId;
    QUOTA_LIMITS    ql;
    NTSTATUS        ntStatus                                = STATUS_SUCCESS;
    DWORD           dwRetCode                               = NO_ERROR;
    HANDLE          hEventDispatcher                        = NULL;
    DEVICE_OBJECT * pDeviceObj                              = NULL;
    HPORT *         phPorts                                 = NULL;
    BOOL            fIpAllowed                              = FALSE;
    LPVOID          lpfnRasAuthProviderFreeAttributes       = NULL;
    LPVOID          lpfnRasAuthProviderAuthenticateUser     = NULL;
    LPVOID          lpfnRasAuthConfigChangeNotification     = NULL;
    LPVOID          lpfnRasAcctProviderStartAccounting      = NULL;
    LPVOID          lpfnRasAcctProviderInterimAccounting    = NULL;
    LPVOID          lpfnRasAcctProviderStopAccounting       = NULL;
    LPVOID          lpfnRasAcctProviderFreeAttributes       = NULL;
    LPVOID          lpfnRasAcctConfigChangeNotification     = NULL;
    DWORD           dwLocalIpAddress                        = 0;


    ZeroMemory( &gblDDMConfigInfo,      sizeof( gblDDMConfigInfo ) );
    gblDDMConfigInfo.fRasSrvrInitialized                    = FALSE;
    gblDDMConfigInfo.hIpHlpApi                              = NULL;
    gblDDMConfigInfo.lpfnAllocateAndGetIfTableFromStack     = NULL;
    gblDDMConfigInfo.lpfnAllocateAndGetIpAddrTableFromStack = NULL;
    gblDDMConfigInfo.dwNumRouterManagers    = DimInfo->dwNumRouterManagers;
    gblRouterManagers                       = DimInfo->pRouterManagers;
    gblpInterfaceTable                      = DimInfo->pInterfaceTable;
    gblDDMConfigInfo.pServiceStatus         = DimInfo->pServiceStatus;
    gblDDMConfigInfo.dwTraceId              = DimInfo->dwTraceId;
    gblDDMConfigInfo.hLogEvents             = DimInfo->hLogEvents;
    gblphEventDDMServiceState               = DimInfo->phEventDDMServiceState;
    gblphEventDDMTerminated                 = DimInfo->phEventDDMTerminated;
    gblDDMConfigInfo.lpdwNumThreadsRunning  = DimInfo->lpdwNumThreadsRunning;
    gblDDMConfigInfo.lpfnIfObjectRemove     = DimInfo->lpfnIfObjectRemove;
    gblDDMConfigInfo.lpfnIfObjectGetPointer = DimInfo->lpfnIfObjectGetPointer;
    gblDDMConfigInfo.lpfnIfObjectInsertInTable =
                                        DimInfo->lpfnIfObjectInsertInTable;
    gblDDMConfigInfo.lpfnIfObjectAllocateAndInit =
                                        DimInfo->lpfnIfObjectAllocateAndInit;
    gblDDMConfigInfo.lpfnIfObjectGetPointerByName =
                                        DimInfo->lpfnIfObjectGetPointerByName;
    gblDDMConfigInfo.lpfnIfObjectWANDeviceInstalled =
                                        DimInfo->lpfnIfObjectWANDeviceInstalled;
    gblDDMConfigInfo.lpfnRouterIdentityObjectUpdate =
                                        DimInfo->lpfnRouterIdentityObjectUpdate;

    gblDDMConfigInfo.fRasmanReferenced = FALSE;

    DimInfo->fWANDeviceInstalled = FALSE;

    //
    // Create DDM private heap
    //

    gblDDMConfigInfo.hHeap = HeapCreate( 0, DDM_HEAP_INITIAL_SIZE,
                                            DDM_HEAP_MAX_SIZE );

    if ( gblDDMConfigInfo.hHeap == NULL )
    {
        return( GetLastError() );
    }

    InitializeCriticalSection( &(gblDeviceTable.CriticalSection) );

    do
    {
        //
        // initialize the rasman module
        //

        if ( ( dwRetCode = RasInitialize() ) != NO_ERROR )
        {
            //
            // can't start rasman
            //

            DDMLogErrorString( ROUTERLOG_RASMAN_NOT_AVAILABLE,
                               0, NULL, dwRetCode, 0 );

            break;
        }

        //
        // Increase rasman's reference count since we are in the same process
        // this does not happen automatically
        //

        if ( dwRetCode = RasReferenceRasman( TRUE ) )
        {
            //
            // can't start rasman
            //

            DDMLogErrorString( ROUTERLOG_RASMAN_NOT_AVAILABLE,
                               0, NULL, dwRetCode, 0 );

            break;
        }

        gblDDMConfigInfo.fRasmanReferenced = TRUE;

        //
        // Check if there is any security agent on the network.  If there is,
        // we check with it if we can start up or not.
        //

/*
        if ( SecurityCheck() )
        {
            dwRetCode = ERROR_SERVICE_DISABLED;
            break;
        }
*/

        if ( ( dwRetCode = GetRouterPhoneBook() ) != NO_ERROR )
        {
            break;
        }

        if ( ( dwRetCode = LoadStrings() ) != NO_ERROR )
        {
            break;
        }

        //
        // get handle to the supervisor parameters key
        //

        if ( dwRetCode = RegOpenKey( HKEY_LOCAL_MACHINE,
                                     DDM_PARAMETERS_KEY_PATH,
                                     &(gblDDMConfigInfo.hkeyParameters) ))
        {
            WCHAR * pwChar = DDM_PARAMETERS_KEY_PATH;

            DDMLogError( ROUTERLOG_CANT_OPEN_REGKEY, 1, &pwChar, dwRetCode);

            break;
        }

        if ( dwRetCode = RegOpenKey( HKEY_LOCAL_MACHINE,
                                     DDM_ACCOUNTING_KEY_PATH,
                                     &(gblDDMConfigInfo.hkeyAccounting) ))
        {
            WCHAR * pwChar = DDM_ACCOUNTING_KEY_PATH;

            DDMLogError( ROUTERLOG_CANT_OPEN_REGKEY, 1, &pwChar, dwRetCode);

            break;
        }

        if ( dwRetCode = RegOpenKey( HKEY_LOCAL_MACHINE,
                                     DDM_AUTHENTICATION_KEY_PATH,
                                     &(gblDDMConfigInfo.hkeyAuthentication) ))
        {
            WCHAR * pwChar = DDM_AUTHENTICATION_KEY_PATH;

            DDMLogError( ROUTERLOG_CANT_OPEN_REGKEY, 1, &pwChar, dwRetCode);

            break;
        }

        if ( ( dwRetCode = LoadDDMParameters( gblDDMConfigInfo.hkeyParameters,
                                              &fIpAllowed) )
                                      != NO_ERROR )
        {
            //
	        // error loading parameters
            //

            break;
        }

        //
        // Load the secuirity module if there is one.
        //

        if ( ( dwRetCode = LoadSecurityModule() ) != NO_ERROR )
        {
            //
	        // error loading security dll
            //

            break;
        }

        //
        // Load the third party admin module if there is one
        //

        if ( ( dwRetCode = LoadAdminModule() ) != NO_ERROR )
        {
            //
	        // error loading admin module dll
            //

            break;
        }

        //
        // Initialize and allocate the media object table
        //

        if ( ( dwRetCode = MediaObjInitializeTable() ) != NO_ERROR )
        {
	        DDMLogError(ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode );

            break;
        }

        //
        // This call allocates memory for all enumed devices with dialin
        // capability, opens each device and updates the port handle and
        // the port name in the DCB.
        //

        if ((dwRetCode = RmInit(&(DimInfo->fWANDeviceInstalled))) != NO_ERROR)
        {
            break;
        }

        //
        // Allocate the supervisor events array, 2 per device bucket since there
        // are 2 rasman events per device, state change and frame received.
        //

        gblSupervisorEvents = (HANDLE *)LOCAL_ALLOC( LPTR,
                        (NUM_DDM_EVENTS + (gblDeviceTable.NumDeviceBuckets * 3))
                        * sizeof( HANDLE )  );

        if ( gblSupervisorEvents == (HANDLE *)NULL )
        {
            dwRetCode = GetLastError();

	        DDMLogError(ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode );

            break;
        }

        //
        // Create the DDM Events
        //

        for ( dwIndex = 0;
              dwIndex < (NUM_DDM_EVENTS+(gblDeviceTable.NumDeviceBuckets * 3));
              dwIndex ++ )
        {
            switch( dwIndex )
            {
            case DDM_EVENT_SVC:

                gblSupervisorEvents[dwIndex]=*gblphEventDDMServiceState;
                gblEventHandlerTable[dwIndex].EventHandler = SvcEventHandler;
                break;

            case DDM_EVENT_SVC_TERMINATED:

                gblSupervisorEvents[dwIndex]=*gblphEventDDMTerminated;
                break;

            case DDM_EVENT_TIMER:

                gblSupervisorEvents[dwIndex]=CreateWaitableTimer( NULL,
                                                                  FALSE,
                                                                  NULL );
                gblEventHandlerTable[dwIndex].EventHandler = TimerHandler;
                break;

            case DDM_EVENT_SECURITY_DLL:

                gblSupervisorEvents[dwIndex]=CreateEvent(NULL,FALSE,FALSE,NULL);
                gblEventHandlerTable[dwIndex].EventHandler =
                                                    SecurityDllEventHandler;
                break;

            case DDM_EVENT_PPP:

                gblSupervisorEvents[dwIndex]=CreateEvent(NULL,FALSE,FALSE,NULL);
                gblEventHandlerTable[dwIndex].EventHandler = PppEventHandler;
                break;

            case DDM_EVENT_CHANGE_NOTIFICATION:
            case DDM_EVENT_CHANGE_NOTIFICATION1:
            case DDM_EVENT_CHANGE_NOTIFICATION2:

                gblSupervisorEvents[dwIndex]=CreateEvent(NULL,FALSE,FALSE,NULL);
                gblEventHandlerTable[dwIndex].EventHandler =
                                                ChangeNotificationEventHandler;
                break;

            default:

                //
                // RasMan events
                //

                gblSupervisorEvents[dwIndex]=CreateEvent(NULL,FALSE,FALSE,NULL);
                break;
            }

	        if ( gblSupervisorEvents[dwIndex] == NULL )
            {
                dwRetCode = GetLastError();

                break;
	        }
        }

        //
        // Initialize the Message Mechanism
        //

        InitializeMessageQs(    gblSupervisorEvents[DDM_EVENT_SECURITY_DLL],
                                gblSupervisorEvents[DDM_EVENT_PPP] );

        //
        // Register the device hEvents with RasMan
        //

        dwRetCode = DeviceObjIterator(DeviceObjRequestNotification,TRUE,NULL);

        if ( dwRetCode != NO_ERROR )
        {
            break;
        }

        if ( fIpAllowed )
        {
            //
            // GetLocalNASIpAddress tries to load iphlpapi.dll. iphlpapi.dll
            // tries to load dhcpcsvc.dll. The latter fails unless TCP/IP is
            // installed and a popup appears.
            //

            dwLocalIpAddress = GetLocalNASIpAddress();
        }

        //
        // Load the configured authentication provider
        //

        dwRetCode = LoadAndInitAuthOrAcctProvider(
                                TRUE,
                                dwLocalIpAddress,
                                NULL,
                                &lpfnRasAuthProviderAuthenticateUser,
                                &lpfnRasAuthProviderFreeAttributes,
                                &lpfnRasAuthConfigChangeNotification,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL );


        if ( dwRetCode != NO_ERROR )
        {
            DDMLogErrorString(  ROUTERLOG_AUTHPROVIDER_FAILED_INIT,
                                0, NULL, dwRetCode, 0);
            break;
        }

        gblDDMConfigInfo.lpfnRasAuthConfigChangeNotification = (DWORD(*)(DWORD))
            lpfnRasAuthConfigChangeNotification;

        //
        // Load the configured accounting provider
        //

        dwRetCode = LoadAndInitAuthOrAcctProvider(
                                FALSE,
                                dwLocalIpAddress,
                                &(gblDDMConfigInfo.dwAccountingSessionId),
                                NULL,
                                NULL,
                                NULL,
                                &lpfnRasAcctProviderStartAccounting,
                                &lpfnRasAcctProviderInterimAccounting,
                                &lpfnRasAcctProviderStopAccounting,
                                &lpfnRasAcctProviderFreeAttributes,
                                &lpfnRasAcctConfigChangeNotification );

        if ( dwRetCode != NO_ERROR )
        {
            DDMLogErrorString(  ROUTERLOG_ACCTPROVIDER_FAILED_INIT,
                                0, NULL, dwRetCode, 0);
            break;
        }

        gblDDMConfigInfo.lpfnRasAcctConfigChangeNotification =  (DWORD(*)(DWORD))
            lpfnRasAcctConfigChangeNotification;

        InitializeCriticalSection( &(gblDDMConfigInfo.CSAccountingSessionId) );

        //
        // Initialize PPP RASIPHLP DLL
        //

        if ( fIpAllowed )
        {
            dwRetCode = RasSrvrInitialize(
                            gblDDMConfigInfo.lpfnMprAdminGetIpAddressForUser,
                            gblDDMConfigInfo.lpfnMprAdminReleaseIpAddress );

            if ( dwRetCode != NO_ERROR )
            {
                DDMLogErrorString( ROUTERLOG_CANT_INITIALIZE_IP_SERVER,
                                   0, NULL, dwRetCode, 0 );

                break;
            }

            gblDDMConfigInfo.fRasSrvrInitialized = TRUE;
        }

        //
        // Init Timer Q
        //

        if ( ( dwRetCode = TimerQInitialize() ) != NO_ERROR )
        {
            break;
        }

        //
        // Start the timer
        //

        {
            LARGE_INTEGER DueTime;

            DueTime.QuadPart = Int32x32To64((LONG)1000, -10000);

            if ( !SetWaitableTimer( gblSupervisorEvents[DDM_EVENT_TIMER],
                                    &DueTime, 1000, NULL, NULL, FALSE) )
            {
                dwRetCode = GetLastError();
                break;
            }
        }


        //
        // Initialize PPP engine DLL
        //

        dwRetCode = PppDdmInit(
                        SendPppMessageToDDM,
                        gblDDMConfigInfo.dwServerFlags,
                        gblDDMConfigInfo.dwLoggingLevel,
                        dwLocalIpAddress,
                        gblDDMConfigInfo.fFlags&DDM_USING_RADIUS_AUTHENTICATION,
                        lpfnRasAuthProviderAuthenticateUser,
                        lpfnRasAuthProviderFreeAttributes,
                        lpfnRasAcctProviderStartAccounting,
                        lpfnRasAcctProviderInterimAccounting,
                        lpfnRasAcctProviderStopAccounting,
                        lpfnRasAcctProviderFreeAttributes,
                        (LPVOID)GetNextAccountingSessionId );

        if ( dwRetCode != NO_ERROR )
        {
            DDMLogErrorString(ROUTERLOG_PPP_INIT_FAILED, 0, NULL, dwRetCode, 0);

            break;
        }

        //
        // Create the Event dispatcher thread
        //

        if ( ( hEventDispatcher = CreateThread( NULL, 0, EventDispatcher,
                                                NULL, 0, &ThreadId)) == 0 )
        {
            //
            // cannot create event dispatcher thread
            //

            dwRetCode = GetLastError();

            break;
        }

        //
        // Register for plug and play notifications with RASMAN
        //

        dwRetCode = RasRegisterPnPHandler( (PAPCFUNC) DdmDevicePnpHandler,
                                                       hEventDispatcher,
                                                       TRUE);

        if ( dwRetCode != NO_ERROR )
        {
            break;
        }

        //
        // Initialize notification event list
        //

        InitializeListHead( &(gblDDMConfigInfo.NotificationEventListHead) );

        //
        // Initialize the array of Analog/Digital Ip Addresses.
        //
        dwRetCode = AddressPoolInit();

        if( dwRetCode != NO_ERROR )
        {
            break;
        }

        if(gblDDMConfigInfo.dwServerFlags & PPPCFG_AudioAccelerator)
        {
            //
            // Call rasman to initialize rasaudio. Ignore the error
            // - rasman will event log and clean up if required.
            //
            (void) RasEnableRasAudio(NULL,TRUE);
        }

        gblDDMConfigInfo.dwIndex = 0;

/*
        TimerQInsert( NULL,
                      gblDDMConfigInfo.dwAnnouncePresenceTimer,
                      AnnouncePresenceHandler );
*/

        //
        // Send notification to the connections folder that ddm
        // has started.
        //
        {
            RASEVENT RasEvent;

            ZeroMemory((PBYTE) &RasEvent, sizeof(RASEVENT));

            RasEvent.Type = SERVICE_EVENT;
            RasEvent.Event   = RAS_SERVICE_STARTED;
            RasEvent.Service = REMOTEACCESS;

            (void) RasSendNotification(&RasEvent);
        }

        return( NO_ERROR );

    } while ( FALSE );


    //
    // We call DDMCleanUp before setting the gblphEventDDMTerminated because
    // otherwise the DIM dll will be unloaded while DDMCleanUp is being
    // executed
    //

    DDMCleanUp();

    //
    // Will terminate the event dispatcher thread if it started
    // and will notify DIM that the service is terminated.
    //
    if(NULL != gblphEventDDMTerminated)
    {
        SetEvent( *gblphEventDDMTerminated );
    }

    gblphEventDDMTerminated = NULL;

    return( dwRetCode );
}

//***
//
//  Function:	SvcEventHandler
//
//  Descrption:	Invoked following the event signaled by the handler registered
//		        with the service controller. Replaces old service state with
//		        the new state and calls the appropriate handler.
//
//***
VOID
SvcEventHandler(
    VOID
)
{
    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    switch ( gblDDMConfigInfo.pServiceStatus->dwCurrentState )
    {
    case SERVICE_RUNNING:
        DDMServiceResume();
        break;

    case SERVICE_PAUSED:
        DDMServicePause();
        break;

    case SERVICE_STOP_PENDING:
        DDMServiceTerminate();
        break;

    default:
        RTASSERT(FALSE);
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\timehand.c ===
/*******************************************************************/
/*	      Copyright(c)  1992 Microsoft Corporation		   */
/*******************************************************************/


//***
//
// Filename:	timehand.c
//
// Description: This module contains the procedures for the supervisor's
//              procedure-driven state machine that handles timer events.
//
// Author:	    Stefan Solomon (stefans)    May 26, 1992.
//
//
//***
#include "ddm.h"
#include "handlers.h"
#include "timer.h"
#include "objects.h"
#include "util.h"
#include "routerif.h"
#include "rasapiif.h"
#include <raserror.h>
#include <serial.h>
#include "rasmanif.h"
#include <string.h>
#include <stdlib.h>
#include <memory.h>

//
// Defines a list of blocks of time.
//
// The time block is expressed as a pair as follows:
//      <offset from midnight sunday, length>
//
// For example, the block of time from 7:00a to 8:30a on Monday
// would be
//      <24*60+7*60, 90> or <1860, 90>
//
//
typedef struct _MPR_TIME_BLOCK
{
    DWORD dwTime;       // Time of day expressed as # of mins since 12:00a
    DWORD dwLen;        // # of minutes in this time block
} MPR_TIME_BLOCK;

//
// Amount by which resizable array grows in TbCreateList
//
#define TB_GROW 30
#define TBDIGIT(_x) ((_x) - L'0')

//
// Local prototypes
//
PVOID
TbAlloc(
    IN DWORD dwSize,
    IN BOOL bZero);

VOID
TbFree(
    IN PVOID pvData);

DWORD
TbCreateList(
    IN  PWCHAR pszBlocks,
    OUT MPR_TIME_BLOCK** ppBlocks,
    OUT LPDWORD lpdwCount);

DWORD
TbCleanupList(
    IN MPR_TIME_BLOCK* pList);

DWORD
TbBlockFromString(
    IN  PWCHAR pszBlock,
    IN  DWORD dwDay,
    OUT MPR_TIME_BLOCK* pBlock);

DWORD
TbPrintBlock(
    IN MPR_TIME_BLOCK* pBlock);

//
// Common allocation for Tb* functions.  Will zero
// memory if bZero is set.
//
PVOID
TbAlloc(
    IN DWORD dwSize,
    IN BOOL bZero)
{
    return LOCAL_ALLOC(0, dwSize);
}

//
// Common free for Tb* functions
//
VOID
TbFree(
    IN PVOID pvData)
{
    LOCAL_FREE(pvData);
}

//
// Translates a multi-sz string containing time blocks into
// a MPR_TIME_BLOCK_LIST
//
DWORD
TbCreateList(
    IN  PWCHAR pszBlocks,
    OUT MPR_TIME_BLOCK** ppBlocks,
    OUT LPDWORD lpdwCount)
{
    DWORD dwErr = NO_ERROR, dwDay = 0, i = 0, dwTot = 0;
    MPR_TIME_BLOCK* pBlocks = NULL, *pTemp = NULL;
    PWCHAR pszCurBlock = NULL, pszStart, pszEnd;

    // Initailze
    //
    *ppBlocks = NULL;
    *lpdwCount = 0;
    pszCurBlock = pszBlocks;

    while (pszCurBlock && *pszCurBlock)
    {
        // Calculate the day indicated in the current block
        //
        // pszCurBlock = "d hh:mm-hh:mm hh:mm-hh:mm ..."
        //
        if (! iswdigit(*pszCurBlock))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
        dwDay = *pszCurBlock - L'0';

        // Advance past the day portion of the line to the
        // timeblock portion
        //
        if (pszStart = wcsstr(pszCurBlock, L" "))
        {
            pszStart++;

            // Loop through the blocks in this line (separated by spaces).
            //
            // pszStart = "hh:mm-hh:mm hh:mm-hh:mm ..."
            //
            while (TRUE)
            {
                // Parse out the current time block
                // hh:mm-hh:mm
                //
                pszEnd = wcsstr(pszStart, L" ");
                if (pszEnd)
                {
                    *pszEnd = L'\0';
                }

                // Resize the array if needed
                //
                if (i >= dwTot)
                {
                    dwTot += TB_GROW;
                    pTemp = (MPR_TIME_BLOCK*)
                        TbAlloc(dwTot * sizeof(MPR_TIME_BLOCK), TRUE);
                    if (pTemp == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }
                    if (dwTot - TB_GROW != 0)
                    {
                        CopyMemory(
                            pTemp,
                            pBlocks,
                            sizeof(MPR_TIME_BLOCK) * (dwTot - TB_GROW));
                    }

                    TbFree(pBlocks);
                    pBlocks = pTemp;
                }

                // Generate the current time block
                //
                dwErr = TbBlockFromString(pszStart, dwDay, &pBlocks[i++]);
                if (dwErr != NO_ERROR)
                {
                    break;
                }

                // Undo any changes made to the string and
                // advance to the next time block
                //
                if (pszEnd)
                {
                    *pszEnd = L' ';
                    pszStart = pszEnd + 1;
                }
                else
                {
                    // Exit the loop successfully
                    break;
                }
            }
            if (dwErr != NO_ERROR)
            {
                break;
            }
        }
        else
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        // Increment the block of time in the multi-sz
        //
        pszCurBlock += wcslen(pszCurBlock) + 1;
    }

    // Cleanup
    {
        if (dwErr != NO_ERROR)
        {
            TbCleanupList(*ppBlocks);
            *ppBlocks = NULL;
        }
        else
        {
            *ppBlocks = pBlocks;
            *lpdwCount = i;
        }
    }

    return dwErr;
}

//
// Cleans up the given series of time blocks.
//
DWORD
TbCleanupList(
    IN MPR_TIME_BLOCK* pList)
{
    TbFree(pList);

    return NO_ERROR;
}

//
// Creates a time block based on a string which must
// be in the form "hh:mm-hh:mm".
//
DWORD
TbBlockFromString(
    IN  PWCHAR pszBlock,
    IN  DWORD dwDay,
    OUT MPR_TIME_BLOCK* pBlock)
{
    DWORD dwErr = NO_ERROR, dwEndTime = 0;

    // Block must be in format:
    //   "hh:mm-hh:mm"
    //
    if ((wcslen(pszBlock) != 11)  ||
        (! iswdigit(pszBlock[0])) ||
        (! iswdigit(pszBlock[1])) ||
        (pszBlock[2]  != L':')    ||
        (! iswdigit(pszBlock[3])) ||
        (! iswdigit(pszBlock[4])) ||
        (pszBlock[5]  != L'-')    ||
        (! iswdigit(pszBlock[6])) ||
        (! iswdigit(pszBlock[7])) ||
        (pszBlock[8]  != L':')    ||
        (! iswdigit(pszBlock[9])) ||
        (! iswdigit(pszBlock[10]))
       )
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Assign the time values to the block
    //
    pBlock->dwTime =
        (((TBDIGIT(pszBlock[0]) * 10) + TBDIGIT(pszBlock[1])) * 60) +  // hrs
        ((TBDIGIT(pszBlock[3]) * 10) + TBDIGIT(pszBlock[4]))        +  // mns
        (dwDay * 24 * 60);                                             // dys

    dwEndTime =
        (((TBDIGIT(pszBlock[6]) * 10) + TBDIGIT(pszBlock[7])) * 60) +  // hrs
        ((TBDIGIT(pszBlock[9]) * 10) + TBDIGIT(pszBlock[10]))       +  // mns
        (dwDay * 24 * 60);                                             // dys

    pBlock ->dwLen = dwEndTime - pBlock->dwTime;

    return dwErr;
}

//
// Finds a time block that matches the given time.
//
// Parameters:
//      pList   = list of time blocks to search
//      dwTime  = time to search for (mins since midnight sunday)
//      ppBlock = the block that matched
//      pbFound = returned TRUE if dwTime lies within ppBlock.
//                returned FALSE if ppBlock is the next time block in pList
//                that occurs after dwTime.
//
DWORD
TbSearchList(
    IN  MPR_TIME_BLOCK* pList,
    IN  DWORD dwCount,
    IN  DWORD dwTime,
    OUT MPR_TIME_BLOCK** ppBlock,
    OUT PBOOL pbFound)
{
    DWORD dwErr = NO_ERROR;
    DWORD i = 0;

    // Initialize
    //
    *pbFound = FALSE;
    *ppBlock = NULL;

    // Loop through the list looking for a block with
    // a time less than ours.
    //
    for (i = 0; (i < dwCount) && (dwTime >= pList[i].dwTime); i++);
    i--;

    // If we fall within the current block then we're
    // done.
    //
    if ((dwTime >= pList[i].dwTime) &&
        (dwTime - pList[i].dwTime <= pList[i].dwLen))
    {
        *pbFound = TRUE;
        *ppBlock = &pList[i];
    }

    // Otherwise, we don't fall within any block.  Show the next block
    // that we qualify for (wrapping around as needed)
    //
    else
    {
        *pbFound = FALSE;
        *ppBlock = &pList[(i == dwCount-1) ? 0 : i+1];
    }

    return dwErr;
}

//
// Traces a block for debugging purposes
//
DWORD
TbTraceBlock(
    IN MPR_TIME_BLOCK* pBlock)
{
    DWORD dwTime, dwDay;

    dwDay = pBlock->dwTime / (24*60);
    dwTime = pBlock->dwTime - (dwDay * (24*60));
    DDMTRACE5(
        "Time Block:  %d, %02d:%02d-%02d:%02d\n",
        dwDay,
        dwTime / 60,
        dwTime % 60,
        (dwTime + pBlock->dwLen) / 60,
        (dwTime + pBlock->dwLen) % 60);

    return NO_ERROR;
}



//***
//
//  Function:   TimerHandler
//
//  Descr:
//
//***
VOID
TimerHandler(
    VOID
)
{
    //
    // call our timer
    //

    TimerQTick();

    //
    // increment the system timer
    //

    gblDDMConfigInfo.dwSystemTime++;
}

//**
//
// Call:        AnnouncePresenceHandler
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
/*
VOID
AnnouncePresenceHandler(
    IN HANDLE hObject
)
{
    AnnouncePresence();

    TimerQInsert( NULL,
                  gblDDMConfigInfo.dwAnnouncePresenceTimer,
                  AnnouncePresenceHandler );
}
*/

//***
//
// Function: SvHwErrDelayCompleted
//
// Descr:    Tries to repost a listen on the specified port.
//
//***
VOID
SvHwErrDelayCompleted(
    IN HANDLE hObject
)
{
    PDEVICE_OBJECT pDeviceObj;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    pDeviceObj = DeviceObjGetPointer( (HPORT)hObject );

    if ( pDeviceObj == NULL )
    {
        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
        return;
    }

    if (pDeviceObj->DeviceState == DEV_OBJ_HW_FAILURE)
    {
        DDMTRACE1( "SvHwErrDelayCompleted: reposting listen for hPort%d\n",
		           pDeviceObj->hPort);

	    pDeviceObj->DeviceState = DEV_OBJ_LISTENING;

	    RmListen(pDeviceObj);
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
}

//***
//
// Function: SvCbDelayCompleted
//
// Descr:    Tries to connect on the specified port.
//
//***
VOID
SvCbDelayCompleted(
    IN HANDLE hObject
)
{
	CHAR chCallbackNumber[MAX_PHONE_NUMBER_LEN+1];
    PDEVICE_OBJECT pDeviceObj;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    pDeviceObj = DeviceObjGetPointer( (HPORT)hObject );

    if ( pDeviceObj == NULL )
    {
        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
        return;
    }

    WideCharToMultiByte( CP_ACP,
                         0,
                         pDeviceObj->wchCallbackNumber,
                         -1,
                         chCallbackNumber,
                         sizeof( chCallbackNumber ),
                         NULL,
                         NULL );

    DDMTRACE1( "SvCbDelayCmpleted:Entered, hPort=%d\n",pDeviceObj->hPort );

    if (pDeviceObj->DeviceState == DEV_OBJ_CALLBACK_DISCONNECTED)
    {
	    pDeviceObj->DeviceState = DEV_OBJ_CALLBACK_CONNECTING;
	    RmConnect(pDeviceObj, chCallbackNumber);
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
}

//***
//
// Function: SvAuthTimeout
//
// Descr:    Disconnects the remote client and stops the authentication
//
//
VOID
SvAuthTimeout(
    IN HANDLE hObject
)
{
    LPWSTR          portnamep;
    PDEVICE_OBJECT  pDeviceObj;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    pDeviceObj = DeviceObjGetPointer( (HPORT)hObject );

    if ( pDeviceObj == NULL )
    {
        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
        return;
    }

    DDMTRACE1( "SvAuthTimeout: Entered, hPort=%d", pDeviceObj->hPort);

    portnamep = pDeviceObj->wchPortName;

    DDMLogWarning( ROUTERLOG_AUTH_TIMEOUT, 1, &portnamep );

    //
    // stop everything and go closing
    //

    DevStartClosing( pDeviceObj );

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
}

//***
//
// Function:	SvDiscTimeout
//
// Descr:	disconnects remote client if it has not done it itself
//
//
VOID
SvDiscTimeout(
    IN HANDLE hObject
)
{
    PDEVICE_OBJECT pDeviceObj;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    pDeviceObj = DeviceObjGetPointer( (HPORT)hObject );

    if ( pDeviceObj == NULL )
    {
        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
        return;
    }

    DDMTRACE1( "SvDiscTimeout: Entered, hPort=%d", pDeviceObj->hPort );

    switch (pDeviceObj->DeviceState)
    {
	case DEV_OBJ_CALLBACK_DISCONNECTING:

	    RmDisconnect(pDeviceObj);
	    break;

	case DEV_OBJ_AUTH_IS_ACTIVE:

	    DevStartClosing(pDeviceObj);
	    break;

	default:

	    break;
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
}

//***
//
// Function:	SvSecurityTimeout
//
// Descr:	disconnects the connection because the 3rd party security DLL
//              did not complete in time.
//
//***
VOID
SvSecurityTimeout(
    IN HANDLE hObject
)
{
    LPWSTR          portnamep;
    PDEVICE_OBJECT pDeviceObj;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    pDeviceObj = DeviceObjGetPointer( (HPORT)hObject );

    if ( pDeviceObj == NULL )
    {
        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
        return;
    }

    DDMTRACE1( "SvSecurityTimeout: Entered,hPort=%d",pDeviceObj->hPort);

    portnamep = pDeviceObj->wchPortName;

    DDMLogWarning( ROUTERLOG_AUTH_TIMEOUT, 1, &portnamep );

    //
    // stop everything and go closing
    //

    DevStartClosing(pDeviceObj);

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
}

//***
//
// Function:	ReConnectInterface
//
// Description:	Will try to reconnect an interface.
//
//***
VOID
ReConnectInterface(
    IN HANDLE hObject
)
{
    ROUTER_INTERFACE_OBJECT *   pIfObject;
    DWORD                       dwRetCode = NO_ERROR;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );
    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    do
    {
        pIfObject = IfObjectGetPointer( hObject );

        if ( pIfObject == (ROUTER_INTERFACE_OBJECT *)NULL )
        {
            break;
        }

        if ( pIfObject->State != RISTATE_CONNECTING )
        {
            break;
        }

        dwRetCode = RasConnectionInitiate( pIfObject, TRUE );

        DDMTRACE2( "ReConnectInterface: To interface %ws returned %d",
                    pIfObject->lpwsInterfaceName, dwRetCode );

        if ( dwRetCode != NO_ERROR )
        {
            IfObjectDisconnected( pIfObject );
        }

    }while( FALSE );

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );
    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    if ( dwRetCode != NO_ERROR )
    {
        LPWSTR  lpwsAudit[1];

        lpwsAudit[0] = pIfObject->lpwsInterfaceName;

        DDMLogErrorString(ROUTERLOG_CONNECTION_FAILURE,1,lpwsAudit,dwRetCode,1);
    }

}

//***
//
// Function:    MarkInterfaceAsReachable
//
// Description: Will mark an interface as reachable.
//
//***
VOID
MarkInterfaceAsReachable(
    IN HANDLE hObject
)
{
    ROUTER_INTERFACE_OBJECT *   pIfObject;

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    do
    {
        pIfObject = IfObjectGetPointer( hObject );

        if ( pIfObject == (ROUTER_INTERFACE_OBJECT *)NULL )
        {
            break;
        }

        pIfObject->fFlags &= ~IFFLAG_CONNECTION_FAILURE;

        IfObjectNotifyOfReachabilityChange( pIfObject,
                                            TRUE,
                                            INTERFACE_CONNECTION_FAILURE );

        pIfObject->dwLastError = NO_ERROR;

    }while( FALSE );

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );
}

//**
//
// Call:        ReConnectPersistentInterface
//
// Returns:     None
//
// Description: Will insert an event in the timer Q that will reconnect this
//              interface.
//
VOID
ReConnectPersistentInterface(
    IN HANDLE hObject
)
{
    ROUTER_INTERFACE_OBJECT *   pIfObject;
    DWORD                       dwRetCode;

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    do
    {
        pIfObject = IfObjectGetPointer( hObject );

        if ( pIfObject == (ROUTER_INTERFACE_OBJECT *)NULL )
        {
            break;
        }

        if ( pIfObject->State != RISTATE_DISCONNECTED )
        {
            break;
        }

        dwRetCode = RasConnectionInitiate( pIfObject, FALSE );

        DDMTRACE2( "ReConnect to persistent interface %ws returned %d",
                    pIfObject->lpwsInterfaceName, dwRetCode );

    }while( FALSE );

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );
}

//**
//
// Call:        SetDialoutHoursRestriction
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
VOID
SetDialoutHoursRestriction(
    IN HANDLE hObject
)
{
    ROUTER_INTERFACE_OBJECT *   pIfObject;
    SYSTEMTIME                  CurrentTime;
    MPR_TIME_BLOCK*             pBlocks = NULL, *pTimeBlock = NULL;
    DWORD                       dwRetCode = NO_ERROR, dwCount, dwTime;
    DWORD                       dwTimer, dwBlDay;
    BOOL                        bFound = FALSE;

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    do
    {
        pIfObject = IfObjectGetPointer( hObject );

        if ( pIfObject == (ROUTER_INTERFACE_OBJECT *)NULL )
        {
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        //
        // Null dialout hours restriction is interpreted as
        // 'always allow'.
        //

        if (pIfObject->lpwsDialoutHoursRestriction == NULL)
        {
            pIfObject->fFlags &= ~IFFLAG_DIALOUT_HOURS_RESTRICTION;
            DDMTRACE("Dialout hours restriction off forever.");
            dwRetCode = NO_ERROR;
            break;
        }

        //
        // Generate the list of time blocks based on the current
        // multisz
        //

        dwRetCode = TbCreateList(
                        pIfObject->lpwsDialoutHoursRestriction,
                        &pBlocks,
                        &dwCount);
        if (dwRetCode != NO_ERROR)
        {
            break;
        }

        //
        // If an empty list was created, then all hours were
        // specified as deny.  Mark the interface unreachable
        // and set ourselves to wake up and check things later.
        //

        if ((dwCount == 0) || (pBlocks == NULL))
        {
            pIfObject->fFlags |= IFFLAG_DIALOUT_HOURS_RESTRICTION;
            DDMTRACE("Dialout hours restriction on forever.");
            dwRetCode = NO_ERROR;
            break;
        }

        //
        // Get the current time
        //

        GetLocalTime( &CurrentTime );

        //
        // Convert the current time into an offset in
        // minutes from midnight, sunday.
        //

        dwTime = (DWORD)
            ( ( CurrentTime.wDayOfWeek * 24 * 60 ) +
              ( CurrentTime.wHour * 60 )           +
              CurrentTime.wMinute );

        //
        // Search for the current time in the list of available times.
        //

        dwRetCode = TbSearchList(
                        pBlocks,
                        dwCount,
                        dwTime,
                        &pTimeBlock,
                        &bFound);
        if (dwRetCode != NO_ERROR)
        {
            break;
        }

        //
        // If we fell within one of the blocks, set the timer
        // to go off after this block completes.
        //

        if (bFound)
        {
            dwTimer = ((pTimeBlock->dwTime + pTimeBlock->dwLen) - dwTime) + 1;

            pIfObject->fFlags &= ~IFFLAG_DIALOUT_HOURS_RESTRICTION;

            DDMTRACE1("Dialout hours restriction off for %d mins", dwTimer);
            TbTraceBlock(pTimeBlock);
        }

        //
        // If we didn't fall within one of the blocks, set the timer
        // to go off when the next block begins
        //

        else
        {
            //
            // Check for week wrap around (i.e. today is saturday, next
            // block is sunday).
            //

            dwBlDay = (pTimeBlock->dwTime / (24*60));

            //
            // If there's no week wrap around, calculation of timer
            // is trivial.
            //

            if ((DWORD)CurrentTime.wDayOfWeek <= dwBlDay)
            {
                dwTimer = pTimeBlock->dwTime - dwTime;
            }

            //
            // Otherwise, calculate the timer by adding one week to the
            // start of the next time block.
            //

            else
            {
                dwTimer = (pTimeBlock->dwTime + (7*24*60)) - dwTime;
            }

            pIfObject->fFlags |= IFFLAG_DIALOUT_HOURS_RESTRICTION;

            DDMTRACE1("Dialout hours restriction on for %d mins", dwTimer);
            TbTraceBlock(pTimeBlock);
        }

        //
        // Set the timer
        //

        TimerQInsert(
            pIfObject->hDIMInterface,
            dwTimer * 60,
            SetDialoutHoursRestriction );

    } while (FALSE);

    if (pIfObject)
    {
        if ( dwRetCode != NO_ERROR )
        {
            //
            // Do not set any restriction if the string is invalid
            //

            pIfObject->fFlags &= ~IFFLAG_DIALOUT_HOURS_RESTRICTION;
        }

        IfObjectNotifyOfReachabilityChange(
                        pIfObject,
                        !( pIfObject->fFlags & IFFLAG_DIALOUT_HOURS_RESTRICTION ),
                        INTERFACE_DIALOUT_HOURS_RESTRICTION );
    }

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    // Cleanup
    if (pBlocks)
    {
        TbCleanupList(pBlocks);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\inc\arapif.h ===
/********************************************************************/
/**               Copyright(c) 1996 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    arapif.h
//
// Description: Contains structures and definitions for components that
//              interface directly or indirectly with the Arap module
//              These componenets are Arap and DDM
//
// History:     Sep 9, 1996    Shirish Koti		Created original version.
//
//***

#ifndef _ARAPIF_
#define _ARAPIF_

//#include <ras.h>
//#include <mprapi.h>


typedef struct _ARAPCONFIGINFO
{
    DWORD   dwNumPorts;         // total number of ports configured
    PVOID   FnMsgDispatch;      // function that Arap should use to send msgs to DDM
    DWORD   NASIpAddress;       // ipaddress of the system
    PVOID   FnAuthProvider;     // function that Arap should use to call AuthProvider
    PVOID   FnAuthFreeAttrib;
    PVOID   FnAcctStartAccounting;
    PVOID   FnAcctInterimAccounting;
    PVOID   FnAcctStopAccounting;
    PVOID   FnAcctFreeAttrib;
    DWORD   dwAuthRetries;      // retries for Authentication

} ARAPCONFIGINFO;

//
// Authentication info sent to DDM by Arap
//
typedef struct _ARAPDDM_AUTH_RESULT
{
    WCHAR    wchUserName[ UNLEN + 1 ];
    WCHAR    wchLogonDomain[ DNLEN + 1 ];
} ARAPDDM_AUTH_RESULT;

//
// Callback info sent to DDM by Arap
//
typedef struct _ARAPDDM_CALLBACK_REQUEST
{
    BOOL  fUseCallbackDelay;
    DWORD dwCallbackDelay;
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
} ARAPDDM_CALLBACK_REQUEST;


//
// ARAP error notification
//
typedef struct _ARAPDDM_DISCONNECT
{
    DWORD dwError;
    WCHAR  wchUserName[ UNLEN + 1 ];
    WCHAR  wchLogonDomain[ DNLEN + 1 ];
} ARAPDDM_DISCONNECT;


typedef struct _ARAPDDM_DONE
{
    DWORD   NetAddress;
    DWORD   SessTimeOut;
} ARAPDDM_DONE;

//
// Message used for Arap/DDM notification
//
typedef struct _ARAP_MESSAGE
{
    struct _ARAP_MESSAGE * pNext;
    DWORD   dwError;
    DWORD   dwMsgId;
    HPORT   hPort;

    union
    {
        ARAPDDM_AUTH_RESULT         AuthResult;        // dwMsgId = ARAPDDMMSG_Authenticated

        ARAPDDM_CALLBACK_REQUEST    CallbackRequest;   // dwMsgId = ARAPDDMMSG_CallbackRequest

        ARAPDDM_DONE                Done;              // dwMsgId = ARAPDDMMSG_Done

        ARAPDDM_DISCONNECT          FailureInfo;       // dwMsgId = ARAPDDMMSG_Failure

    } ExtraInfo;

} ARAP_MESSAGE;


//
// ARAP_MESSAGE dwMsgId codes.
//
typedef enum _ARAP_MSG_ID
{
    ARAPDDMMSG_Started,             // ARAP engine has started (response to ArapStartup)
    ARAPDDMMSG_Authenticated,       // Client has been authenticated.
    ARAPDDMMSG_CallbackRequest,     // Callback client now.
    ARAPDDMMSG_Done,                // ARAP negotiated successfully and connection is up
    ARAPDDMMSG_Failure,             // Client has been authenticated.
    ARAPDDMMSG_Disconnected,        // Client has been authenticated.
    ARAPDDMMSG_Inactive,            // Client is inactive
    ARAPDDMMSG_Stopped,             // ARAP engine has stopped (response to ArapShutdown)

} ARAP_MSG_ID;

typedef DWORD (* ARAPPROC1)(ARAP_MESSAGE  *pArapMsg);

//
// prototypes for Arap functions
//

DWORD
ArapDDMLoadModule(
    IN VOID
);

VOID
ArapEventHandler(
    IN VOID
);

VOID
ArapSetModemParms(
    IN PVOID        pDevObjPtr,
    IN BOOLEAN      TurnItOff
);


//
// exports from rasarap.lib
//

DWORD
ArapStartup(
    IN  ARAPCONFIGINFO  *pArapConfig
);


DWORD
ArapAcceptConnection(
    IN  HPORT   hPort,
    IN  HANDLE  hConnection,
    IN  PCHAR   Frame,
    IN  DWORD   FrameLen
);


DWORD
ArapDisconnect(
    IN  HPORT   hPort
);


DWORD
ArapCallBackDone(
    IN  HPORT   hPort
);


DWORD
ArapSendUserMsg(
    IN  HPORT   hPort,
    IN  PCHAR   MsgBuf,
    IN  DWORD   MsgBufLen
);


DWORD
ArapForcePwdChange(
    IN  HPORT   hPort,
    IN  DWORD   Reason
);


DWORD
ArapShutdown(
    IN  VOID
);


#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ddm\util.h ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    util.h
//
// Description: Prototypes of various DDM utility functions.
//
// History:     May 11,1995	    NarenG		Created original version.
//

#define GET_USHORT(DstPtr, SrcPtr)               \
    *(unsigned short *)(DstPtr) =               \
        ((*((unsigned char *)(SrcPtr)+1)) +     \
         (*((unsigned char *)(SrcPtr)+0) << 8))

DWORD
GetRasiConnection0Data(
    IN  PCONNECTION_OBJECT      pConnObj,
    OUT PRASI_CONNECTION_0      pRasConnection0
);

DWORD
GetRasiConnection1Data(
    IN  PCONNECTION_OBJECT      pConnObj,
    OUT PRASI_CONNECTION_1      pRasConnection1
);

DWORD
GetRasiConnection2Data(
    IN  PCONNECTION_OBJECT      pConnObj,
    OUT PRASI_CONNECTION_2      pRasConnection2
);

DWORD
GetRasConnection0Data(
    IN  PCONNECTION_OBJECT      pConnObj,
    OUT PRAS_CONNECTION_0       pRasConnection0
);

DWORD
GetRasConnection1Data(
    IN  PCONNECTION_OBJECT      pConnObj,
    OUT PRAS_CONNECTION_1       pRasConnection1
);

DWORD
GetRasConnection2Data(
    IN  PCONNECTION_OBJECT      pConnObj,
    OUT PRAS_CONNECTION_2       pRasConnection2
);

DWORD
GetRasiPort0Data(
    IN  PDEVICE_OBJECT          pDevObj,
    OUT PRASI_PORT_0            pRasPort0
);

DWORD
GetRasiPort1Data(
    IN  PDEVICE_OBJECT          pDevObj,
    OUT PRASI_PORT_1            pRasPort1
);

DWORD
GetRasPort0Data(
    IN  PDEVICE_OBJECT          pDevObj,
    OUT PRAS_PORT_0             pRasPort0
);

DWORD
GetRasPort1Data(
    IN  PDEVICE_OBJECT          pDevObj,
    OUT PRAS_PORT_1             pRasPort1
);

DWORD
LoadStrings(
    VOID
);

DWORD
GetRouterPhoneBook(
    VOID
); 

DWORD
MapAuthCodeToLogId(
    IN WORD Code
);

BOOL
IsPortOwned(
    IN PDEVICE_OBJECT pDeviceObj
);

VOID
GetLoggingInfo(
    IN PDEVICE_OBJECT pDeviceObj,
    OUT PDWORD BaudRate,
    OUT PDWORD BytesSent,
    OUT PDWORD BytesRecv,
    OUT RASMAN_DISCONNECT_REASON *Reason,
    OUT SYSTEMTIME *Time
);

DWORD
GetLineSpeed(
    IN HPORT hPort
);

VOID
LogConnectionEvent(
    IN PCONNECTION_OBJECT   pConnObj,
    IN PDEVICE_OBJECT       pDeviceObj
);

DWORD
GetTransportIndex(
    IN DWORD dwProtocolId
);

VOID
DDMCleanUp(
    VOID
);

BOOL
AcceptNewConnection( 
    IN DEVICE_OBJECT *      pDeviceObj,
    IN CONNECTION_OBJECT *  pConnObj
);

VOID
ConnectionHangupNotification(
    IN CONNECTION_OBJECT *  pConnObj
);

BOOL
AcceptNewLink( 
    IN DEVICE_OBJECT *      pDeviceObj, 
    IN CONNECTION_OBJECT *  pConnObj
);

VOID
ConvertStringToIpAddress(
    IN  WCHAR * pwchIpAddress,
    OUT DWORD * lpdwIpAddress
);

VOID
ConvertStringToIpxAddress(
    IN  WCHAR * pwchIpAddress,
    OUT BYTE *  bIpxAddress
);

DWORD
GetActiveTimeInSeconds( 
    IN ULARGE_INTEGER * pqwActiveTime
);

BOOL
DDMRecognizeFrame(
    IN  PVOID    pvFrameBuf,
    IN  WORD     wFrameLen, 
    OUT DWORD   *pProtocol  
);

DWORD
GetNextAccountingSessionId(
    VOID
);

DWORD
GetLocalNASIpAddress(
    VOID
);

DWORD
MungePhoneNumber(
    char  *cbphno,
    DWORD dwIndex,
    DWORD *pdwSizeofMungedPhNo,
    char  **ppszMungedPhNo
);

WCHAR *
GetIpAddress(DWORD dwIpAddress);

VOID
LogUnreachabilityEvent(
    IN DWORD    dwReason,
    IN LPWSTR   lpwsInterfaceName
);

DWORD
ModifyDefPolicyToForceEncryption(
    IN BOOL bStrong
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\inc\ddmparms.h ===
/*******************************************************************/
/*	      Copyright(c)  1992 Microsoft Corporation		   */
/*******************************************************************/


//***
//
// Filename:	ddmparms.h
//
// Description: This module contains the definitions for loading
//		        DDM parameters from the registry. This lives in the inc dir.
//              because it is also used by RASNBFCP
//
// Author:	    Stefan Solomon (stefans)    May 18, 1992.
//
// Revision     History:
//
//***

#ifndef _DDMPARMS_
#define _DDMPARMS_

//
//  Names of DDM registry keys
//

#define DDM_PARAMETERS_KEY_PATH TEXT("System\\CurrentControlSet\\Services\\RemoteAccess\\Parameters")

#define DDM_ACCOUNTING_KEY_PATH TEXT("System\\CurrentControlSet\\Services\\RemoteAccess\\Accounting")

#define DDM_AUTHENTICATION_KEY_PATH TEXT("System\\CurrentControlSet\\Services\\RemoteAccess\\Authentication")

#define DDM_SEC_KEY_PATH        TEXT("Software\\Microsoft\\RAS\\SecurityHost")

#define DDM_PARAMETERS_NBF_KEY_PATH TEXT("System\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\Nbf")

#define DDM_PROTOCOLS_KEY_PATH  TEXT("Software\\Microsoft\\RAS\\Protocols")

#define DDM_ADMIN_KEY_PATH      TEXT("Software\\Microsoft\\RAS\\AdminDll")

#define RAS_KEYPATH_ACCOUNTING      \
    TEXT("SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Accounting")

//
//  Names of DDM registry parameters
//

#define DDM_VALNAME_AUTHENTICATERETRIES     TEXT("AuthenticateRetries")
#define DDM_VALNAME_AUTHENTICATETIME        TEXT("AuthenticateTime")
#define DDM_VALNAME_CALLBACKTIME            TEXT("CallbackTime")
#define DDM_VALNAME_ALLOWNETWORKACCESS      TEXT("AllowNetworkAccess")
#define DDM_VALNAME_AUTODISCONNECTTIME      TEXT("Autodisconnect")
#define DDM_VALNAME_CLIENTSPERPROC          TEXT("ClientsPerProcess")
#define DDM_VALNAME_SECURITYTIME            TEXT("SecurityHostTime")
#define DDM_VALNAME_NETBEUIALLOWED          TEXT("fNetBeuiAllowed")
#define DDM_VALNAME_IPALLOWED               TEXT("fTcpIpAllowed")
#define DDM_VALNAME_IPXALLOWED              TEXT("fIpxAllowed")
#define DDM_VALNAME_DLLPATH                 TEXT("DllPath")
#define DDM_VALNAME_LOGGING_LEVEL           TEXT("LoggingFlags")
#define DDM_VALNAME_NUM_CALLBACK_RETRIES    TEXT("CallbackRetries")
#define DDM_VALNAME_SERVERFLAGS             TEXT("ServerFlags")
#define RAS_VALNAME_ACTIVEPROVIDER          TEXT("ActiveProvider")
#define RAS_VALNAME_ACCTSESSIONID           TEXT("AccountSessionIdStart")

#define DEF_SERVERFLAGS                 PPPCFG_UseSwCompression      |   \
                                        PPPCFG_NegotiateSPAP         |   \
                                        PPPCFG_NegotiateMSCHAP       |   \
                                        PPPCFG_UseLcpExtensions      |   \
                                        PPPCFG_NegotiateMultilink    |   \
                                        PPPCFG_NegotiateBacp         |   \
                                        PPPCFG_NegotiateEAP          |   \
                                        PPPCFG_NegotiatePAP          |   \
                                        PPPCFG_NegotiateMD5CHAP

// Number of callback retries to be made

#define DEF_NUMCALLBACKRETRIES      0
#define MIN_NUMCALLBACKRETRIES      0
#define MAX_NUMCALLBACKRETRIES      0xFFFFFFFF


//  Authentication retries

#define DEF_AUTHENTICATERETRIES 	2
#define MIN_AUTHENTICATERETRIES 	0
#define MAX_AUTHENTICATERETRIES 	10

//  Authentication time

#define DEF_AUTHENTICATETIME		120
#define MIN_AUTHENTICATETIME		20
#define MAX_AUTHENTICATETIME		600

// Audit

#define DEF_ENABLEAUDIT 		1
#define MIN_ENABLEAUDIT 		0
#define MAX_ENABLEAUDIT			1

//  Callback time

#define DEF_CALLBACKTIME		2
#define MIN_CALLBACKTIME		2
#define MAX_CALLBACKTIME		12


//  Autodisconnect time

#define DEF_AUTODISCONNECTTIME          0
#define MIN_AUTODISCONNECTTIME          0
#define MAX_AUTODISCONNECTTIME          0xFFFFFFFF

//  Third party security time

#define DEF_SECURITYTIME                120
#define MIN_SECURITYTIME                20
#define MAX_SECURITYTIME                600


// Clients per process

#define DEF_CLIENTSPERPROC              32
#define MIN_CLIENTSPERPROC              1
#define MAX_CLIENTSPERPROC              64

// Logging level

#define DEF_LOGGINGLEVEL                3
#define MIN_LOGGINGLEVEL                0
#define MAX_LOGGINGLEVEL                3

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\inc\ddmif.h ===
/*******************************************************************/
/*	      Copyright(c)  1992 Microsoft Corporation		   */
/*******************************************************************/


//***
//
// Filename:	ddmif.h
//
// Description: This file contains the definitions for
//		        the data structures used in the message communication with DDM.
//
// Author:	    Stefan Solomon (stefans)    June 24, 1992.
//
// Revision History:
//
//***

#ifndef _DDMIF_
#define _DDMIF_

#include <ras.h>
#include <dim.h>
#include <rasman.h>
#include <srvauth.h>
#include <sechost.h>
#include <nbfcpif.h>
#include <nbgtwyif.h>
#include <rasppp.h>
#include <dimif.h>

typedef struct _DIM_INFO
{
    IN  ROUTER_INTERFACE_TABLE *    pInterfaceTable;
    IN  ROUTER_MANAGER_OBJECT *     pRouterManagers;
    IN  DWORD                       dwNumRouterManagers;
    IN  SERVICE_STATUS*             pServiceStatus;
    IN  HANDLE *                    phEventDDMServiceState;
    IN  HANDLE *                    phEventDDMTerminated;
    IN  LPDWORD                     lpdwNumThreadsRunning;
    IN  DWORD                       dwTraceId;
    IN  HANDLE                      hLogEvents;
    IN  LPVOID                      lpfnIfObjectAllocateAndInit;
    IN  LPVOID                      lpfnIfObjectGetPointerByName;
    IN  LPVOID                      lpfnIfObjectGetPointer;
    IN  LPVOID                      lpfnIfObjectRemove;
    IN  LPVOID                      lpfnIfObjectInsertInTable;
    IN  LPVOID                      lpfnIfObjectWANDeviceInstalled;
    IN  LPVOID                      lpfnRouterIdentityObjectUpdate;
    OUT BOOL                        fWANDeviceInstalled;

} DIM_INFO, *PDIM_INFO;

//
// Called be DIM to initialize DDM
//

DWORD
DDMServiceInitialize(
    IN DIM_INFO * pDimInfo
);

//
// Message Queues IDs
//

typedef enum _MESSAGEQ_ID
{
    MESSAGEQ_ID_SECURITY,       //queue of messages sent by 3rd party sec.dll
    MESSAGEQ_ID_PPP,            //queue of messages sent by PPP engine.

} MESSAGEQ_ID, *PMESSAGEQ_ID;

#define MAX_MSG_QUEUES          3


//
//*** Common Message Type ***
//

typedef union _MESSAGE
{
    AUTH_MESSAGE        authmsg;
    NBG_MESSAGE         nbgmsg;
    NBFCP_MESSAGE       nbfcpmsg;
    SECURITY_MESSAGE    securitymsg;
    PPP_MESSAGE         PppMsg;

} MESSAGE, *PMESSAGE;

//
// Message Functions
//

VOID
SendPppMessageToDDM(
    IN PPP_MESSAGE *  pPppMsg
);

DWORD
ServerSendMessage(
    IN MESSAGEQ_ID  MsgQId,
    IN BYTE*        pMessage
);

BOOL
ServerReceiveMessage(
    IN MESSAGEQ_ID  MsgQId,
    IN BYTE*        pMessage
);

typedef DWORD (* PMSGFUNCTION)(DWORD, BYTE *);


#endif   // _DDMIF_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\inc\clauth.h ===
/*****************************************************************************/
/**                      Microsoft LAN Manager                              **/
/**                Copyright (C) 1992-1993 Microsoft Corp.                  **/
/*****************************************************************************/

//***
//    File Name:
//       CLAUTH.H
//
//    Function:
//        Contains header information for Win32 Client and Client
//        Authentication Transport module
//
//    History:
//        05/18/92 - Michael Salamone (MikeSa) - Original Version 1.0
//***

#ifndef _CLAUTH_
#define _CLAUTH_


/* This flag enables the NT31/WFW311 RAS compression support re-added for the
** NT-PPC release.
*/
#define RASCOMPRESSION 1


#include <lmcons.h>


#ifndef MAX_PHONE_NUMBER_LEN
#define MAX_PHONE_NUMBER_LEN    48
#endif

#ifndef MAX_INIT_NAMES
#define MAX_INIT_NAMES          16
#endif


//
// Used for establishing session with RAS netbios server
//
#define AUTH_NETBIOS_NAME    "DIALIN_GATEWAY  "


//
// Used for passing NetBIOS projection info to Supervisor
//
typedef struct _NAME_STRUCT 
{
    BYTE NBName[NETBIOS_NAME_LEN]; // NetBIOS name
    WORD wType;                    // GROUP, UNIQUE, COMPUTER
} NAME_STRUCT, *PNAME_STRUCT;


//
// Configuration info supplied by UI to auth transport
//
#define INVALID_NET_HANDLE    0xFFFFFFFFL

typedef struct _AUTH_CONFIGURATION_INFO
{
    RAS_PROTOCOLTYPE Protocol;
    DWORD NetHandle;
    WORD CallbackDelay;
    BOOL fUseCallbackDelay;
    BOOL fUseSoftwareCompression;
    BOOL fForceDataEncryption;
    BOOL fProjectIp;
    BOOL fProjectIpx;
    BOOL fProjectNbf;
} AUTH_CONFIGURATION_INFO, *PAUTH_CONFIGURATION_INFO;


typedef struct _AUTH_SUCCESS_INFO
{
    BOOL fPppCapable;
} AUTH_SUCCESS_INFO, *PAUTH_SUCCESS_INFO;


//
// Error codes for AUTH_FAILURE_INFO are found in raserror.h
//

typedef struct _AUTH_FAILURE_INFO
{
    DWORD Result;
    DWORD ExtraInfo;    // Only valid if non-zero
} AUTH_FAILURE_INFO, *PAUTH_FAILURE_INFO;


//
// Projection result info must be copied into this structure.
//

typedef struct _NETBIOS_PROJECTION_RESULT
{
    DWORD Result;
    char achName[NETBIOS_NAME_LEN + 1];   // this will be NULL-terminated
} NETBIOS_PROJECTION_RESULT, *PNETBIOS_PROJECTION_RESULT;


typedef struct _AUTH_PROJECTION_RESULT
{
    BOOL IpProjected;
    BOOL IpxProjected;
    BOOL NbProjected;
    NETBIOS_PROJECTION_RESULT NbInfo;
} AUTH_PROJECTION_RESULT, *PAUTH_PROJECTION_RESULT;


//
// These are possible values for wInfoType field in AUTH_RESULT struct below.
//
#define AUTH_DONE                       1
#define AUTH_RETRY_NOTIFY               2
#define AUTH_FAILURE                    3
#define AUTH_PROJ_RESULT                4
#define AUTH_REQUEST_CALLBACK_DATA      5
#define AUTH_CALLBACK_NOTIFY            6
#define AUTH_CHANGE_PASSWORD_NOTIFY     7
#define AUTH_PROJECTING_NOTIFY          8
#define AUTH_LINK_SPEED_NOTIFY          9
#define AUTH_STOP_COMPLETED            10


//
// This is structure returned by AuthGetInfo API
//
typedef struct _AUTH_CLIENT_INFO
{
    WORD wInfoType;
    union
    {
        AUTH_SUCCESS_INFO DoneInfo;
        AUTH_PROJECTION_RESULT ProjResult;
        AUTH_FAILURE_INFO FailureInfo;
    };
} AUTH_CLIENT_INFO, *PAUTH_CLIENT_INFO;


//
// Interface exported to Client UI follows
//

//
// Used by Client UI to supply Auth Xport w/callback number
//
DWORD AuthCallback(
    IN HPORT,
    IN PCHAR      // pszCallbackNumber
    );


DWORD AuthChangePassword(
    IN HPORT,
    IN PCHAR,     // pszUserName
    IN PCHAR,     // pszPassword
    IN PCHAR      // pszNewPassword
    );


//
// Called by UI to tell authentication it has completed processing the
// last authentication event.  Called after AUTH_PROJECTION_RESULT and
// AUTH_CALLBACK_NOTIFY authentication events.
//
DWORD AuthContinue(
    IN HPORT
    );


//
// Used by Client UI to get completion info from Auth Xport module
//
DWORD AuthGetInfo(
    IN HPORT,
    OUT PAUTH_CLIENT_INFO
    );


//
// To allow UI to provide a new username and/or password for authenticating
// on.  Called in response to AUTH_RETRY_NOTIFY event (indicating previous
// username/password combination failed authentication).
//
DWORD AuthRetry(
    IN HPORT,
    IN PCHAR,    // Username
    IN PCHAR,    // Password
    IN PCHAR     // Domain
    );


//
// To kick off an Authentication thread for the given port.  Used to
// 1) initiate authentication; 2) retry authentication when invalid
// account info supplied; 3) resume authentication after callback..
//
DWORD AuthStart(
    IN HPORT,
    IN PCHAR OPTIONAL,    // Username
    IN PCHAR OPTIONAL,    // Password
    IN PCHAR,             // Domain
    IN PAUTH_CONFIGURATION_INFO,
    IN HANDLE             // Event Handle
    );


//
// Used by Client UI to tell Auth Xport module to halt authentication
// processing on the given port.
//
DWORD AuthStop(
    IN HPORT hPort
    );


//
// Returned by AuthStop
//
#define AUTH_STOP_PENDING          1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\inc\device.h ===
//***************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//      Copyright (C) 1992-93 Microsft Corporation. All rights reserved.
//
//  Filename: device.h
//
//  Revision History:
//
//  Aug 11, 1992   J. Perry Hannah   Created
//
//
//  Description: This file contains function prototypes and typedefs
//               used by the interface between RAS Manager and the
//               device DLLs, such as RASMXS.DLL.  This header file
//               will be used by RASMAN.
//
//****************************************************************************


#ifndef _RASDEVICEDLL_
#define _RASDEVICEDLL_


//*  RASMXS API Prototypes  **************************************************
//
//   Apps should define RASMXS_STATIC_LINK to get the appropriate function
//   prototypes for linking statically with the RASMXS DLL.
//
//   Apps should define RASMXS_DYNAMIC_LINK to get the appropriate function
//   typedefs for linking dynamically with the RASMXS DLL.
//

#ifdef RASMXS_STATIC_LINK

DWORD APIENTRY DeviceEnum(char  *pszDeviceType,
                          DWORD  *pcEntries,
                          BYTE  *pBuffer,
                          DWORD  *pdwSize);


DWORD APIENTRY DeviceGetInfo(HANDLE  hIOPort,
                             char    *pszDeviceType,
                             char    *pszDeviceName,
                             BYTE    *pInfo,
                             DWORD   *pdwSize);


DWORD APIENTRY DeviceSetInfo(HANDLE      hIOPort,
                             char        *pszDeviceType,
                             char        *pszDeviceName,
                             DEVICEINFO  *pInfo);


DWORD APIENTRY DeviceConnect(HANDLE  hIOPort,
                             char    *pszDeviceType,
                             char    *pszDeviceName,
                             HANDLE  hNotifier);


DWORD APIENTRY DeviceListen(HANDLE  hIOPort,
                            char    *pszDeviceType,
                            char    *pszDeviceName,
                            HANDLE  hNotifier);


 VOID APIENTRY DeviceDone(HANDLE  hIOPort);


DWORD APIENTRY DeviceWork(HANDLE  hIOPort,
                          HANDLE  hNotifier);

#endif // RASMXS_STATIC_LINK




#ifdef RASMXS_DYNAMIC_LINK

typedef DWORD (APIENTRY * DeviceEnum_t)(char*, DWORD*, BYTE*, DWORD*);

typedef DWORD (APIENTRY * DeviceGetInfo_t)(HANDLE, char*, char*, BYTE*, DWORD*);

typedef DWORD (APIENTRY * DeviceSetInfo_t)(HANDLE, char*, char*,
                                           RASMAN_DEVICEINFO*);

typedef DWORD (APIENTRY * DeviceConnect_t)(HANDLE, char*, char*);

typedef DWORD (APIENTRY * DeviceListen_t)(HANDLE, char*, char*);

typedef DWORD (APIENTRY * DeviceDone_t)(HANDLE);

typedef DWORD (APIENTRY * DeviceWork_t)(HANDLE);

// OPTIONAL

typedef DWORD (APIENTRY * DeviceSetDevConfig_t)(HANDLE, PBYTE, DWORD);

typedef DWORD (APIENTRY * DeviceGetDevConfig_t)(char *, PBYTE, DWORD*);

#endif // RASMXS_DYNAMIC_LINK




#endif // _RASDEVICEDLL_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\inc\eaptypeid.h ===
/*

Copyright (c) 1999, Microsoft Corporation, all rights reserved

File:
    eaptypeid.h

Description:
    This header defines the type IDs of various EAPs implemented in rasppp.dll

History:
    6 Jan 1999: Vijay Baliga created original version.

*/

#ifndef _EAPTYPEID_H_
#define _EAPTYPEID_H_

//
// Various EAP type IDs
//

#define PPP_EAP_CHAP            4       // MD5-Challenge
#define PPP_EAP_TLS             13      // Smartcard or other certificate (TLS)
#define PPP_EAP_PEAP            25      // PEAP
#define PPP_EAP_MSCHAPv2        26      // EAP Mschapv2

#endif // #ifndef _EAPTYPEID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\inc\interror.h ===
//***************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//                     Copyright 1992-93
//
//
//  Revision History:
//
//  Jul  9, 1992   J. Perry Hannah   Created.
//
//
//  Description: Contains internal error codes which are common
//               to the entire RAS project.
//
//****************************************************************************


#ifndef _INTERROR_
#define _INTERROR_



//*  Internal Error Codes  ***************************************************
//
//  The follow is recommended form for component internal header files.
//
//  #define BASE  RAS_INTERNAL_ERROR_BASE + REIB_YOURCOMPONENT
//
//  #define ERROR_NO_CLUE           BASE + 1
//  #define ERROR_NEXT_BAD_THING    BASE + 2
//
//

#define  RAS_INTERNAL_ERROR_BASE  13000           // 0x32C8

#define  RIEB_RASMAN                100
#define  RIEB_MXSDLL                200
#define  RIEB_ASYNCMEDIADLL         300
#define  RIEB_INFFILEAPI            400
#define  RIEB_RASFILE               500
#define  RIEB_RASHUB                600
#define  RIEB_ASYMAC                700
#define  RIEB_SUPERVISOR            800






#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\inc\isdn.h ===
//****************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//                     Copyright 1992-93
//
//  Filename: isdn.h
//
//  Revision History:
//
//  Feb 28, 1993	Gurdeep Pall Created
//
//
//  Description: This file contains all the device and media DLL interface
//		 information specific to ISDN.
//
//****************************************************************************


#ifndef _ISDNINCLUDE_
#define _ISDNINCLUDE_

#define ISDN_TXT "isdn"

// ISDN Media Parameter
//
#define ISDN_LINETYPE_KEY	"LineType"	// Param type NUMBER
#define ISDN_LINETYPE_VALUE_64DATA	0
#define ISDN_LINETYPE_VALUE_56DATA	1
#define ISDN_LINETYPE_VALUE_56VOICE	2
#define ISDN_LINETYPE_STRING_64DATA	"0"
#define ISDN_LINETYPE_STRING_56DATA	"1"
#define ISDN_LINETYPE_STRING_56VOICE	"2"


#define ISDN_FALLBACK_KEY	"Fallback"	// Param type NUMBER
#define ISDN_FALLBACK_VALUE_ON		1
#define ISDN_FALLBACK_VALUE_OFF 	0
#define ISDN_FALLBACK_STRING_ON		"1"
#define ISDN_FALLBACK_STRING_OFF	"0"



#define ISDN_COMPRESSION_KEY	"EnableCompression" // Param type NUMBER
#define ISDN_COMPRESSION_VALUE_ON	1
#define ISDN_COMPRESSION_VALUE_OFF	0
#define ISDN_COMPRESSION_STRING_ON	"1"
#define ISDN_COMPRESSION_STRING_OFF	"0"


#define ISDN_CHANNEL_AGG_KEY	"ChannelAggregation"// Param type NUMBER


// ISDN Device Parameter
//
#define ISDN_PHONENUMBER_KEY	"PhoneNumber"	// Param type STRING
#define MAX_PHONENUMBER_LEN	255

#define CONNECTBPS_KEY		"ConnectBPS"	// Param type STRING


//  Statistics information and indices.
//
#define NUM_ISDN_STATS		10

#define BYTES_XMITED		0	// Generic Stats
#define BYTES_RCVED             1
#define FRAMES_XMITED           2
#define FRAMES_RCVED            3

#define CRC_ERR 		4	// Isdn Stats
#define TIMEOUT_ERR             5
#define ALIGNMENT_ERR           6
#define SERIAL_OVERRUN_ERR      7
#define FRAMING_ERR             8
#define BUFFER_OVERRUN_ERR      9

#endif // _ISDNINCLUDE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\inc\imports.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Imports.h

Abstract:

    This file allows us to include standard system header files in the
    regrpc.idl file.  The regrpc.idl file imports a file called
    imports.idl.  This allows the regrpc.idl file to use the types defined
    in these header files.  It also causes the following line to be added
    in the MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    David J. Gilman (davegi) 28-Jan-1992

--*/

#include <windef.h>
#include <ras.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\inc\media.h ===
//***************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//      Copyright (C) 1992-93 Microsft Corporation. All rights reserved.
//
//
//  Revision History:
//
//  Jul 22, 1992   J. Perry Hannah   Created
//  Aug 11, 1992   Gurdeep Pall      Added Media data structures
//
//  Description: This file contains function prototypes and structures
//               used by the interface between RAS Manager and the
//               Media DLLs.
//
//****************************************************************************


#ifndef _MEDIADLLHEADER_
#define _MEDIADLLHEADER_



//  General Defines  *********************************************************
//

#define SS_HARDWAREFAILURE  0x00000001
#define SS_LINKDROPPED      0x00000002



//*  Data Structures  ********************************************************
//

#define MAC_NAME_SIZE	32

struct PortMediaInfo {
    CHAR            PMI_Name [MAX_PORT_NAME] ;
    CHAR            PMI_MacBindingName[MAC_NAME_SIZE] ;
    RASMAN_USAGE    PMI_Usage ;
    CHAR            PMI_DeviceType [MAX_DEVICETYPE_NAME] ;
    CHAR	        PMI_DeviceName [MAX_DEVICE_NAME] ;
    DWORD	        PMI_LineDeviceId ;	// Valid for TAPI devices only
    DWORD	        PMI_AddressId ;	    // Valid for TAPI devices only
    DeviceInfo     *PMI_pDeviceInfo;    // valid for non unimodem devices only.
} ;


typedef struct PortMediaInfo PortMediaInfo ;




//*  API References  *********************************************************
//

typedef  DWORD (APIENTRY * PortEnum_t)(BYTE *, DWORD *, DWORD *);

typedef  DWORD (APIENTRY * PortOpen_t)(char *, HANDLE *, HANDLE, ULONG);

typedef  DWORD (APIENTRY * PortClose_t)(HANDLE);

typedef  DWORD (APIENTRY * PortGetInfo_t)(HANDLE, TCHAR *, BYTE *, DWORD *);

typedef  DWORD (APIENTRY * PortSetInfo_t)(HANDLE, RASMAN_PORTINFO *);

typedef  DWORD (APIENTRY * PortTestSignalState_t)(HANDLE, DWORD *);

typedef  DWORD (APIENTRY * PortConnect_t)(HANDLE, BOOL, HANDLE *) ;

typedef  DWORD (APIENTRY * PortDisconnect_t)(HANDLE);

typedef  DWORD (APIENTRY * PortInit_t)(HANDLE);

typedef  DWORD (APIENTRY * PortCompressionSetInfo_t)(HANDLE) ;

typedef  DWORD (APIENTRY * PortSend_t)(HANDLE, BYTE *, DWORD);

typedef  DWORD (APIENTRY * PortReceive_t)(HANDLE, BYTE *, DWORD, DWORD);

typedef  DWORD (APIENTRY * PortGetStatistics_t)(HANDLE, RAS_STATISTICS *);

typedef  DWORD (APIENTRY * PortClearStatistics_t)(HANDLE);

typedef  DWORD (APIENTRY * PortGetPortState_t)(BYTE *, DWORD *);

typedef  DWORD (APIENTRY * PortChangeCallback_t)(HANDLE);

typedef  DWORD (APIENTRY * PortReceiveComplete_t)(HANDLE, DWORD *);

typedef  DWORD (APIENTRY * PortSetFraming_t)(HANDLE, DWORD, DWORD, DWORD, DWORD);

typedef  DWORD (APIENTRY * PortGetIOHandle_t)(HANDLE, HANDLE*);

typedef  DWORD (APIENTRY * PortSetIoCompletionPort_t)(HANDLE);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\inc\nbfcpif.h ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    nbfcpif.h
//
// Description: Contains structures and id definitions for componenets that
//              directly or indireclty interface with NBFCP. The 2 components
//              that do this are DDM and the NetBios gateqway
//
// History:     May 11,1995	    NarenG		Created original version.
//

#ifndef _NBFCPIF_
#define _NBFCPIF_

#include <nb30.h>
#include <nbgparms.h>


//
// Configuration Options
//
#define NBFCP_MAX_NAMES_IN_OPTION    14
#define NBFCP_UNIQUE_NAME            1
#define NBFCP_GROUP_NAME             2

typedef struct _NBFCP_NETBIOS_NAME_INFO
{
    BYTE Name[NCBNAMSZ];
    BYTE Code;
} NBFCP_NETBIOS_NAME_INFO, *PNBFCP_NETBIOS_NAME_INFO;

typedef struct _NBFCP_MULTICAST_FILTER
{
    BYTE Period[2];
    BYTE Priority;
} NBFCP_MULTICAST_FILTER, *PNBFCP_MULTICAST_FILTER;


//
// Peer classes
//
#define MSFT_PPP_NB_GTWY_SERVER           1
#define GENERIC_PPP_NB_GTWY_SERVER        2
#define MSFT_PPP_LOCAL_ACCESS_SERVER      3
#define GENERIC_PPP_LOCAL_ACCESS_SERVER   4
#define RESERVED                          5
#define GENERIC_PPP_NBF_BRIDGE            6
#define MSFT_PPP_CLIENT                   7
#define GENERIC_PPP_CLIENT                8


//
// Our version numbers
//
#define NBFCP_MAJOR_VERSION_NUMBER        1
#define NBFCP_MINOR_VERSION_NUMBER        0

typedef struct _NBFCP_PEER_INFORMATION
{
    BYTE Class[2];
    BYTE MajorVersion[2];
    BYTE MinorVersion[2];
    BYTE Name[MAX_COMPUTERNAME_LENGTH + 1];
} NBFCP_PEER_INFORMATION, *PNBFCP_PEER_INFORMATION;

//
// Server Info
//

typedef struct _NBFCP_SERVER_CONFIGURATION
{
    NBFCP_PEER_INFORMATION PeerInformation;
    NBFCP_MULTICAST_FILTER MulticastFilter;
    WORD NumNetbiosNames;
    DWORD NetbiosResult;
    NBFCP_NETBIOS_NAME_INFO NetbiosNameInfo[MAX_NB_NAMES];
} NBFCP_SERVER_CONFIGURATION, *PNBFCP_SERVER_CONFIGURATION;

//
// NBFCP<->DDM Message Ids and definitions.
//

#define NBFCP_CONFIGURATION_REQUEST    1
#define NBFCP_TIME_SINCE_LAST_ACTIVITY 2

typedef struct _NBFCP_MESSAGE
{
    WORD    MsgId;
    HCONN   hConnection;

    union
    {
        DWORD TimeSinceLastActivity;
        NBFCP_SERVER_CONFIGURATION ServerConfig;
    };

} NBFCP_MESSAGE, *PNBFCP_MESSAGE;

DWORD
SendMessageToNbfCp(
    IN NBFCP_MESSAGE * pMsg
);

typedef VOID (*FUNCNBFCPDDMMSG)( IN NBFCP_MESSAGE * pNbfCpMsg );

VOID
InitNbfCp(
    FUNCNBFCPDDMMSG pFuncSendNbfCpMessageToDDM
);

#endif _NBFCPIF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\inc\nbgparms.h ===
/*******************************************************************/
/*	      Copyright(c)  1992 Microsoft Corporation		   */
/*******************************************************************/


//***
//
// Filename:	nbgparms.h
//
// Description: This module contains the definitions for loading
//		        the netbios gateway parameters from the registry. This lives
//              in the inc directory because it is also used by NBFCP
//
// Author:	Stefan Solomon (stefans)    July 15, 1992.
//
// Revision History:
//
//***

#ifndef _NBGPARMS_
#define _NBGPARMS_

#define MAX_NB_NAMES    28

#define NCBQUICKADDNAME     0x75    

//
//  Names of Netbios Gateway registry keys
//

#define RAS_NBG_PARAMETERS_KEY_PATH "System\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\Nbf"

//
//  Names of Netbios Gateway registry parameters
//

#define RAS_NBG_VALNAME_AVAILABLELANNETS	    "AvailableLanNets"
#define RAS_NBG_VALNAME_ENABLEBROADCAST 	    "EnableBroadcast"
#define RAS_NBG_VALNAME_MAXDYNMEM		    "MaxDynMem"
#define RAS_NBG_VALNAME_MAXNAMES		    "MaxNames"
#define RAS_NBG_VALNAME_MAXSESSIONS		    "MaxSessions"
#define RAS_NBG_VALNAME_MULTICASTFORWARDRATE	    "MulticastForwardRate"
#define RAS_NBG_VALNAME_SIZWORKBUF		    "SizWorkbuf"
#define RAS_NBG_VALNAME_REMOTELISTEN		    "RemoteListen"
#define RAS_NBG_VALNAME_NAMEUPDATETIME		    "NameUpdateTime"
#define RAS_NBG_VALNAME_MAXDGBUFFEREDPERGROUPNAME   "MaxDgBufferedPerGroupName"
#define RAS_NBG_VALNAME_RCVDGSUBMITTEDPERGROUPNAME  "RcvDgSubmittedPerGroupName"
#define RAS_NBG_VALNAME_DISMCASTWHENSESSTRAFFIC     "DisableMcastFwdWhenSessionTraffic"
#define RAS_NBG_VALNAME_MAXBCASTDGBUFFERED	    "MaxBcastDgBuffered"
#define RAS_NBG_VALNAME_NUMRECVQUERYINDICATIONS     "NumRecvQueryIndications"
#define RAS_NBG_VALNAME_ENABLENBSESSIONSAUDITING    "EnableNetbiosSessionsAuditing"

typedef struct _NB_REG_PARMS
{
    DWORD MaxNames;
    DWORD MaxSessions;
    DWORD SmallBuffSize;
    DWORD MaxDynMem;
    DWORD MulticastForwardRate;
    DWORD RemoteListen;
    DWORD BcastEnabled;
    DWORD NameUpdateTime;
    DWORD MaxDgBufferedPerGn;
    DWORD RcvDgSubmittedPerGn;
    DWORD DisMcastWhenSessTraffic;
    DWORD MaxBcastDgBuffered;
    DWORD NumRecvQryIndications;
    DWORD EnableSessAuditing;
    DWORD MaxLanNets;            // nr of available lan nets
} NB_REG_PARMS, *PNB_REG_PARMS;

//
// Parameter descriptor
//
typedef struct _NB_PARAM_DESCRIPTOR
{
    LPSTR p_namep;
    LPDWORD p_valuep;
    DWORD p_default;
    DWORD p_min;
    DWORD p_max;
} NB_PARAM_DESCRIPTOR, *PNB_PARAM_DESCRIPTOR;


#define DEF_ENABLEBROADCAST		0
#define MIN_ENABLEBROADCAST		0
#define MAX_ENABLEBROADCAST		1

#define DEF_MAXDYNMEM			655350
#define MIN_MAXDYNMEM			131072
#define MAX_MAXDYNMEM			0xFFFFFFFF

#define DEF_MAXNAMES			0xFF
#define MIN_MAXNAMES			1
#define MAX_MAXNAMES			0xFF

#define DEF_MAXSESSIONS			0xFF
#define MIN_MAXSESSIONS 		1
#define MAX_MAXSESSIONS 		0xFF

#define DEF_MULTICASTFORWARDRATE	5
#define MIN_MULTICASTFORWARDRATE	0
#define MAX_MULTICASTFORWARDRATE	0xFFFFFFFF

#define DEF_SIZWORKBUF			4500
#define MIN_SIZWORKBUF			1024
#define MAX_SIZWORKBUF			65536

#define LISTEN_NONE			0
#define LISTEN_MESSAGES 		1
#define LISTEN_ALL			2

#define DEF_REMOTELISTEN		LISTEN_MESSAGES
#define MIN_REMOTELISTEN		LISTEN_NONE
#define MAX_REMOTELISTEN		LISTEN_ALL

#define DEF_NAMEUPDATETIME		120
#define MIN_NAMEUPDATETIME		10
#define MAX_NAMEUPDATETIME		3600

#define DEF_MAXDGBUFFEREDPERGROUPNAME	10
#define MIN_MAXDGBUFFEREDPERGROUPNAME	1
#define MAX_MAXDGBUFFEREDPERGROUPNAME	0xFF

#define DEF_RCVDGSUBMITTEDPERGROUPNAME	3
#define MIN_RCVDGSUBMITTEDPERGROUPNAME	1
#define MAX_RCVDGSUBMITTEDPERGROUPNAME	32

#define DEF_DISMCASTWHENSESSTRAFFIC	1
#define MIN_DISMCASTWHENSESSTRAFFIC	0
#define MAX_DISMCASTWHENSESSTRAFFIC	1

#define DEF_MAXBCASTDGBUFFERED		32
#define MIN_MAXBCASTDGBUFFERED		16
#define MAX_MAXBCASTDGBUFFERED		0xFF

#define DEF_NUMRECVQUERYINDICATIONS     3
#define MIN_NUMRECVQUERYINDICATIONS     1
#define MAX_NUMRECVQUERYINDICATIONS     32

#define DEF_ENABLENBSESSIONSAUDITING	0
#define MIN_ENABLENBSESSIONSAUDITING	0
#define MAX_ENABLENBSESSIONSAUDITING	1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\inc\mxsint.h ===
//***************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//      Copyright (C) 1992-93 Microsft Corporation. All rights reserved.
//
//  Filename: mxsint.h
//
//  Revision History:
//
//  Jun  8, 1992   J. Perry Hannah   Created
//
//
//  Description: This file contains defines and enums that are used
//               by RAS components that share things in common with
//               RASMXS DLL.
//
//               Header File  Used by
//               -----------  -------
//               rasmxs.h     UIs and other external applicaions
//               device.h     RASMAN.DLL (shared by all device DLLs)
//               mxsint.h     other internal RAS components
//               raspriv.h    RASMXS.DLL only
//
//****************************************************************************


#ifndef _MXSINT_
#define _MXSINT_


//  General Defines  *********************************************************
//

#define  MAX_CMD_BUF_LEN            256
#define  MAX_RCV_BUF_LEN            256
#define  MAX_CMDTYPE_SUFFIX_LEN     8

#define  RESPONSES_SECTION_NAME     "Responses"




//  Data Structures shared with wrapmxs.c  ***********************************
//

typedef struct MXT_ENTRY MXT_ENTRY;

struct MXT_ENTRY
{
  TCHAR         E_MacroName[MAX_PARAM_KEY_SIZE + 1];
  RAS_PARAMS    *E_Param;
};



typedef struct MACROXLATIONTABLE MACROXLATIONTABLE;

struct MACROXLATIONTABLE
{
  WORD      MXT_NumOfEntries;
  MXT_ENTRY MXT_Entry[1];
};




//*  Function Prototypes shared with wrapmxs.c  ******************************
//

DWORD UpdateParamString(RAS_PARAMS *pParam, TCHAR *psStr, DWORD dwStrLen);




//*  Enumeration Types  ******************************************************
//

enum RCVSTATE                           // ReceiveStateMachine() State
{
  GETECHO              = 0,
  GETNUMBYTESECHOD     = 1,
  CHECKECHO            = 2,
  GETFIRSTCHAR         = 3,
  GETNUMBYTESFIRSTCHAR = 4,
  GETRECEIVESTR        = 5,
  GETNUMBYTESRCVD      = 6,
  CHECKRESPONSE        = 7
};

typedef enum RCVSTATE RCVSTATE;


enum NEXTACTION                         // DeviceStateMachine() State
{
  SEND    = 0,
  RECEIVE = 1,
  DONE    = 2
};

typedef enum NEXTACTION NEXTACTION;


enum CMDTYPE                            // Used by DeviceStateMachine()
{
  CT_UNKNOWN   = 0,
  CT_GENERIC   = 1,
  CT_INIT      = 2,
  CT_DIAL      = 3,
  CT_LISTEN    = 4
};

typedef enum CMDTYPE CMDTYPE;


enum DEVICETYPE                         // Used by DeviceConnect()
{
  DT_UNKNOWN  = 0,
  DT_NULL     = 1,
  DT_MODEM    = 2,
  DT_PAD      = 3,
  DT_SWITCH   = 4
};

typedef enum DEVICETYPE DEVICETYPE;


enum INFOTYPE                           // Used by BinarySuffix()
{
  UNKNOWN_INFOTYPE  = 0,
  VARIABLE          = 1,
  UNARYMACRO        = 2,
  BINARYMACRO       = 3
};

typedef enum INFOTYPE INFOTYPE;



//*  Wrapper Errors  *********************************************************
//
//  These are error codes returned from mxswrap.c to rasmxs dll, and which
//  are used only by rasmxs dll and are not passed up to rasman dll.
//

#define  WRAP_BASE  13200

#define  ERROR_END_OF_SECTION                   WRAP_BASE + 7

// RasDevGetCommand() found the end of a section instead of a command.


#define  ERROR_PARTIAL_RESPONSE                 WRAP_BASE + 8

// RasDevCheckResponse() matched just the first part of a response
// containing an <append> macro.

#endif // _MXSINT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\inc\pppcp.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	pppcp.h
//
// Description: This header defines function prototypes, structures and 
//		related constants used in the interface between the PPP 
//		engine and the various CPs
//
// History:
//	Nov 5,1993.	NarenG		Created original version.
//

#ifndef _PPPCP_
#define _PPPCP_

#include <mprapi.h>
#include <rasppp.h>
#include <rasauth.h>

//
// Maximum number of CPs that can live in a single DLL
//

#define PPPCP_MAXCPSPERDLL 	20

//
// Various control protocol IDs
//

#define PPP_LCP_PROTOCOL        0xC021  // Link Control Protocol 
#define PPP_PAP_PROTOCOL        0xC023  // Password Authentication Protocol 
#define PPP_CBCP_PROTOCOL	    0xC029  // Callback Control Protocol
#define PPP_BACP_PROTOCOL       0xC02B  // Bandwidth Allocation Control Protocol
#define PPP_BAP_PROTOCOL        0xc02D  // Bandwidth Allocation Protocol
#define PPP_CHAP_PROTOCOL	    0xC223  // Challenge Handshake Auth. Protocol
#define PPP_IPCP_PROTOCOL       0x8021  // Internet Protocol Control Protocol 
#define PPP_ATCP_PROTOCOL	    0x8029  // Appletalk Control Protocol 
#define PPP_IPXCP_PROTOCOL	    0x802B  // Novel IPX Control Procotol 
#define PPP_NBFCP_PROTOCOL	    0x803F  // NetBIOS Framing Control Protocol 
#define PPP_CCP_PROTOCOL	    0x80FD  // Compression Control Protocol
#define PPP_SPAP_NEW_PROTOCOL	0xC027  // Shiva PAP new protocol
#define PPP_EAP_PROTOCOL	    0xC227  // Extensible Authentication Protocol

//
// CHAP Digest codes
//
#define PPP_CHAP_DIGEST_MD5        0x05 // PPP standard MD5
#define PPP_CHAP_DIGEST_MSEXT      0x80 // Microsoft extended CHAP (nonstandard)
#define PPP_CHAP_DIGEST_MSEXT_NEW  0x81 // Microsoft extended CHAP (nonstandard)

//
// Config Codes
//

#define CONFIG_REQ              1
#define CONFIG_ACK              2
#define CONFIG_NAK              3
#define CONFIG_REJ              4
#define TERM_REQ                5
#define TERM_ACK                6
#define CODE_REJ                7
#define PROT_REJ                8
#define ECHO_REQ                9
#define ECHO_REPLY              10
#define DISCARD_REQ             11
#define IDENTIFICATION          12
#define TIME_REMAINING          13

typedef struct _PPP_CONFIG 
{
    BYTE	Code;		// Config code 
  
    BYTE	Id;		    // ID of this config packet.  CPs and APs need
                        // not muck with this.  The engine handles it.

    BYTE	Length[2];	// Length of this packet 

    BYTE	Data[1];	// Data 

}PPP_CONFIG, *PPPP_CONFIG;

#define PPP_CONFIG_HDR_LEN 	( sizeof( PPP_CONFIG ) - 1 )

typedef struct _BAP_RESPONSE
{
    BYTE    Type;       // BAP packet type
  
    BYTE    Id;         // ID of this packet

    BYTE    Length[2];  // Length of this packet

    BYTE    ResponseCode; // BAP_RESPONSE_ACK, etc

    BYTE    Data[1];    // Data 

} BAP_RESPONSE, *PBAP_RESPONSE;

#define BAP_RESPONSE_HDR_LEN    ( sizeof( BAP_RESPONSE ) - 1 )

//
// Option header structure
//

typedef struct _PPP_OPTION 
{
    BYTE	Type;		// Option Code 

    BYTE	Length;		// Length of this option packet 

    BYTE	Data[1];	// Data 

}PPP_OPTION, *PPPP_OPTION;

#define PPP_OPTION_HDR_LEN 	( sizeof( PPP_OPTION ) - 1 )


//
// Vendor-Type ids for MS VSAs - taken from rfc 2548
//
#define MS_VSA_CHAP_RESPONSE                1
#define MS_VSA_CHAP_Error                   2
#define MS_VSA_CHAP_CPW1                    3
#define MS_VSA_CHAP_CPW2                    4
#define MS_VSA_CHAP_LM_Enc_PW               5
#define MS_VSA_CHAP_NT_Enc_PW               6
#define MS_VSA_MPPE_Encryption_Policy       7
#define MS_VSA_MPPE_Encryption_Type         8
#define MS_VSA_RAS_Vendor                   9
#define MS_VSA_CHAP_Domain                  10
#define MS_VSA_CHAP_Challenge               11
#define MS_VSA_CHAP_MPPE_Keys               12
#define MS_VSA_BAP_Usage                    13
#define MS_VSA_Link_Utilization_Threshold   14
#define MS_VSA_Link_Drop_Time_Limit         15
#define MS_VSA_MPPE_Send_Key                16
#define MS_VSA_MPPE_Recv_Key                17
#define MS_VSA_RAS_Version                  18
#define MS_VSA_Old_ARAP_Password            19
#define MS_VSA_New_ARAP_Password            20
#define MS_VSA_ARAP_PW_Change_Reason        21
#define MS_VSA_Filter                       22
#define MS_VSA_Acct_Auth_Type               23
#define MS_VSA_Acct_EAP_Type                24
#define MS_VSA_CHAP2_Response               25
#define MS_VSA_CHAP2_Success                26
#define MS_VSA_CHAP2_CPW                    27
#define MS_VSA_Primary_DNS_Server           28
#define MS_VSA_Secondary_DNS_Server         29
#define MS_VSA_Primary_NBNS_Server          30
#define MS_VSA_Secondary_NBNS_Server        31
#define MS_VSA_ARAP_Challenge               33
#define MS_VSA_RAS_Client_Name              34
#define MS_VSA_RAS_Client_Version           35
#define MS_VSA_Quarantine_IP_Filter         36
#define MS_VSA_Quarantine_Session_Timeout   37
#define MS_VSA_Local_Magic_Number           38
#define MS_VSA_Remote_Magic_Number          39




//
// Interface structure between the engine and APs. This is passed to the
// AP's via the RasCpBegin call. 
//

typedef struct _PPPAP_INPUT
{
    HPORT 	    hPort;	        // Handle to Ras Port for this connection.

    BOOL 	    fServer;	    // Is this server side authentication?

    BOOL        fRouter;

    DWORD       fConfigInfo;

    CHAR *      pszUserName;    // Client's account ID.

    CHAR *      pszPassword;    // Client's account password.

    CHAR *      pszDomain;      // Client's account domain.

    CHAR *      pszOldPassword; // Client's old account password.  This is set
                                // only for change password processing.

    LUID	    Luid;           // Used by LSA.  Must get it in user's context
                                // which is why it must be passed down.

    DWORD       dwRetries;      // Retries allowed by the server.

    DWORD       APDataSize;     // Size in bytes of the data pointed to by
                                // pAPData

    PBYTE       pAPData;        // Pointer to the data that was received along
                                // with the authentication option during LCP
                                // negotiation. Data is in wire format.

    DWORD       dwInitialPacketId;

    //
    // Passed in by the server when a call comes in. Identifies the port used,
    // etc.
    //

    RAS_AUTH_ATTRIBUTE * pUserAttributes;

    //
    // Indicates that the authenticator has completed the request, if an
    // authenticator was used. Ignore this field otherwise.
    //

    BOOL        fAuthenticationComplete;

    //
    // Indicates an error condition during the process of authentication if
    // value is non-zero. Valid only when the field above is TRUE.
    //

    DWORD       dwAuthError;

    //
    // Result of the authentication process. NO_ERROR indicates success, 
    // otherwise is a value from winerror.h, raserror.h or mprerror.h 
    // indicating failure reason. Valid only when the field above is NO_ERROR.
    //

    DWORD       dwAuthResultCode;

    //
    // When the fAuthenticationComplete flag is TRUE this will point to 
    // attributes returned by the authenticator, if the authentication was
    // successful. ie. dwAuthResultCode and dwAuthError are both NO_ERROR.
    //

    OPTIONAL RAS_AUTH_ATTRIBUTE * pAttributesFromAuthenticator;

    //
    // Used for EAP only
    //

    HANDLE                  hTokenImpersonateUser;

    PRAS_CUSTOM_AUTH_DATA   pCustomAuthConnData;

    PRAS_CUSTOM_AUTH_DATA   pCustomAuthUserData;

    BOOL                fLogon; // pCustomAuthUserData comes from WinLogon

    BOOL                fThisIsACallback;

    BOOL                fPortWillBeBundled;

    BOOL                fNonInteractive;

    BOOL                fSuccessPacketReceived;

    BOOL                fEapUIDataReceived;

    PPP_EAP_UI_DATA     EapUIData;

    DWORD               dwEapTypeToBeUsed;

}PPPAP_INPUT, *PPPPAP_INPUT;

typedef enum _PPPAP_ACTION
{
    //
    // These actions are provided by the AP as output from the
    // RasApMakeMessage API.  They tell the PPP engine what action (if any) to
    // take on the APs behalf, and eventually inform the engine that the AP
    // has finished authentication.
    //

    APA_NoAction,        // Be passive, i.e. listen without timeout (default)
    APA_Done,            // End authentication session, dwError gives result
    APA_SendAndDone,     // As above but send message without timeout first
    APA_Send,            // Send message, don't timeout waiting for reply
    APA_SendWithTimeout, // Send message, timeout if reply not received
    APA_SendWithTimeout2,// As above, but don't increment retry count
    APA_Authenticate     // Authenticate using specified credentials.

} PPPAP_ACTION;

typedef struct _PPPAP_RESULT
{
    PPPAP_ACTION    Action;

    //
    // The packet ID which will cause the timeout for this send to be removed
    // from the timer queue.  Otherwise, the timer queue is not touched.  The
    // packet received is returned to the AP regardless of whether the timer
    // queue is changed.
    //

    BYTE            bIdExpected;

    //
    // dwError is valid only with an Action code of Done or SendAndDone.  0
    // indicates succesful authentication.  Non-0 indicates unsuccessful
    // authentication with the value indicating the error that occurred.
    //

    DWORD	        dwError;

    //
    // Valid only when dwError is non-0.  Indicates whether client is allowed
    // to retry without restarting authentication.  (Will be true in MS
    // extended CHAP only)
    //

    BOOL            fRetry;

    CHAR            szUserName[ UNLEN + 1 ];

    //
    // Set to attributes to be used for this user. If this is NULL, attributes 
    // from the authenticator will be used for this user. It is upto the
    // allocater of this memory to free it. Must be freed during the RasCpEnd 
    // call. 
    //

    OPTIONAL RAS_AUTH_ATTRIBUTE * pUserAttributes;

    //
    // Used by MS-CHAP to pass the challenge used during the authentication
    // protocol. These 8 bytes are used as the variant for the 128 bit
    // encryption keys.
    //

    BYTE                            abChallenge[MAX_CHALLENGE_SIZE];

    BYTE                            abResponse[MAX_RESPONSE_SIZE];

    //
    // Used only by EAP
    //

    BOOL                            fInvokeEapUI;

    PPP_INVOKE_EAP_UI               InvokeEapUIData;

    DWORD                           dwEapTypeId;

    BOOL                            fSaveUserData;
    
    BYTE *                          pUserData;

    DWORD                           dwSizeOfUserData;

    BOOL                            fSaveConnectionData;

    PPP_SET_CUSTOM_AUTH_DATA        SetCustomAuthData;

    CHAR *                          szReplyMessage;
  
}PPPAP_RESULT;

//
// Interface structure between the engine and the callback control protocol. 
// This is passed to the CBCP via the RasCpBegin call. 
//

typedef struct _PPPCB_INPUT
{
    BOOL            fServer;

    BYTE            bfCallbackPrivilege;    

    DWORD           CallbackDelay;          

    CHAR *          pszCallbackNumber;     

} PPPCB_INPUT, *PPPPCB_INPUT;

typedef struct _PPPCB_RESULT
{
    PPPAP_ACTION    Action;

    BYTE            bIdExpected;

    CHAR            szCallbackNumber[ MAX_CALLBACKNUMBER_SIZE + 1 ];

    BYTE            bfCallbackPrivilege;    

    DWORD           CallbackDelay;

    BOOL            fGetCallbackNumberFromUser;

} PPPCB_RESULT, *PPPPCB_RESULT;


typedef struct _PPPCP_INIT
{
    BOOL                    fServer;

    HPORT                   hPort;

    DWORD                   dwDeviceType;

    VOID (*CompletionRoutine)(
                            HCONN         hPortOrBundle,
                            DWORD         Protocol,
                            PPP_CONFIG *  pSendConfig, 
                            DWORD         dwError );

    CHAR*                   pszzParameters;

    BOOL                    fThisIsACallback;

    BOOL                    fDisableNetbt;

    PPP_CONFIG_INFO         PppConfigInfo;

    CHAR *                  pszUserName;

    CHAR *                  pszPortName;

    HCONN                   hConnection;

    HANDLE                  hInterface;

    ROUTER_INTERFACE_TYPE   IfType;

    RAS_AUTH_ATTRIBUTE *    pAttributes;

} PPPCP_INIT, *PPPPCP_INIT;

//
// This structure is passed by the engine to the CP via RasCpGetInfo call.
// The Cp will fill up this structure.
//

typedef struct _PPPCP_INFO
{
    DWORD	Protocol;	// Protocol number for this CP

    CHAR    SzProtocolName[10]; // The name of this protocol

    // All Config codes upto (not including) this value are valid.  

    DWORD	Recognize;

    // Called to initialize/uninitialize this CP. In the former case,
    // fInitialize will be TRUE; in the latter case, it will be FALSE.
    // Even if RasCpInit(TRUE) returns FALSE, RasCpInit(FALSE) will be called.

    DWORD   (*RasCpInit)(   IN  BOOL        fInitialize );

    // Called to get the workbuffer for this CP and pass info if requred.
    // This will be called before any negotiation takes place.

    DWORD	(*RasCpBegin)(  OUT VOID ** ppWorkBuffer, 
			                IN  VOID *  pInfo );

    // Called to free the workbuffer for this CP. Called after negotiation
    // is completed successfully or not.

    DWORD	(*RasCpEnd)(    IN VOID * pWorkBuffer );

    // Called to notify the CP dll to (re)initiaize its option values.
    // This will be called at least once, right after RasCpBegin

    DWORD	(*RasCpReset)(  IN VOID * pWorkBuffer );

    // When leaving Initial or Stopped states. May be NULL.

    DWORD 	(*RasCpThisLayerStarted)( 
                            IN VOID * pWorkBuffer );    

    // When entering Closed or Stopped states. May be NULL

    DWORD 	(*RasCpThisLayerFinished)( 
                            IN VOID * pWorkBuffer );    

    // When entering the Opened state. May be NULL. 

    DWORD 	(*RasCpThisLayerUp)( 
                            IN VOID * pWorkBuffer );    

    // When leaving the Opened state. May be NULL. 

    DWORD 	(*RasCpThisLayerDown)( 
                            IN VOID * pWorkBuffer );
 
    // Just before the line goes down. May be NULL. 

    DWORD 	(*RasCpPreDisconnectCleanup)( 
                            IN VOID * pWorkBuffer );

    // Called to make a configure request.

    DWORD	(*RasCpMakeConfigRequest)( 
                            IN  VOID * 	    pWorkBuffer,
					        OUT PPP_CONFIG* pRequestBufffer,
					        IN  DWORD	    cbRequestBuffer );

    // Called when configure request is received and a result packet 
    // Ack/Nak/Reject needs to be sent

    DWORD	(*RasCpMakeConfigResult)( 
                            IN  VOID * 	        pWorkBuffer,
					        IN  PPP_CONFIG *    pReceiveBufffer,
					        OUT PPP_CONFIG *    pResultBufffer,
					        IN  DWORD	        cbResultBuffer,
					        IN  BOOL 	        fRejectNaks );

    // Called to process an Ack that was received.

    DWORD	(*RasCpConfigAckReceived)( 
                            IN VOID *       pWorkBuffer, 
					        IN PPP_CONFIG * pReceiveBuffer );

    // Called to process a Nak that was received.

    DWORD	(*RasCpConfigNakReceived)( 
                            IN VOID *       pWorkBuffer,
					        IN PPP_CONFIG * pReceiveBuffer );

    // Called to process a Rej that was received.

    DWORD	(*RasCpConfigRejReceived)( 
                            IN VOID *       pWorkBuffer,
					        IN PPP_CONFIG * pReceiveBuffer );

    // Called to get the network address from configured protocols.

    DWORD	(*RasCpGetNegotiatedInfo)( 
                            IN      VOID *  pWorkBuffer,
                            OUT     VOID *  pInfo );

    // Called after all CPs have completed their negotiation, successfully or
    // not, to notify each CP of the projection result. May be NULL.
    // To access information, cast pProjectionInfo to PPP_PROJECTION_RESULT*

    DWORD	(*RasCpProjectionNotification)( 
				            IN  VOID * pWorkBuffer,
				            IN  PVOID  pProjectionResult );

    DWORD   (*RasCpChangeNotification)( VOID );

    //
    // This entry point only applies to Authentication protocols.
    // MUST BE NULL FOR CONTROL PROTOCOLS.

    DWORD  	(*RasApMakeMessage)( 
                            IN  VOID*         pWorkBuf,
				            IN  PPP_CONFIG*   pReceiveBuf,
    				        OUT PPP_CONFIG*   pSendBuf,
    				        IN  DWORD         cbSendBuf,
    				        OUT PPPAP_RESULT* pResult,
                            IN  PPPAP_INPUT*  pInput );

} PPPCP_INFO, *PPPPCP_INFO;

#define PPPCP_FLAG_INIT_CALLED  0x00000001  // RasCpInit has been called
#define PPPCP_FLAG_AVAILABLE    0x00000002  // The protocol can be used

//
// The information that PPP needs to keep about each CP.
//

typedef struct _PPPCP_ENTRY
{
    PPPCP_INFO  CpInfo;

    DWORD       fFlags;

} PPPCP_ENTRY;

// 
// Used to get result from NBFCP via the RasCpGetResult call
//

typedef struct _PPPCP_NBFCP_RESULT
{

    DWORD dwNetBiosError;
    CHAR  szName[ NETBIOS_NAME_LEN + 1 ];

} PPPCP_NBFCP_RESULT;

//
// Function prototypes.
//

DWORD APIENTRY
RasCpGetInfo(
    IN  DWORD 	    dwProtocolId,
    OUT PPPCP_INFO* pCpInfo
);

DWORD APIENTRY
RasCpEnumProtocolIds(
    OUT    DWORD * pdwProtocolIds,
    IN OUT DWORD * pcProtocolIds
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\inc\nbgutils.h ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    nbgutils.h
//
// Description: Contains utility routines for the NetBios gateway related
//              components
//
// History:     May 11,1995	    NarenG		Created original version.
//

#ifndef _NBGUTILS_
#define _NBGUTILS_

DWORD
LoadNbGateway(
    VOID
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\inc\pipemsg.h ===
#ifndef _PIPEMSG_
#define _PIPEMSG_

#include <lm.h>
#include <nbgparms.h>
#include <srvauth.h>


#define RASIPCNAME    "\\\\.\\pipe\\RAS_SERVICE_IPC_READ"

typedef enum _PIPE_MESSAGE_ID
{
    START_GATEWAY,
    PROJECT_CLIENT,
    START_CLIENT,
    STOP_CLIENT,
    SWITCH_PORTS,
    TERMINATE
} PIPE_MESSAGE_ID, *PPIPE_MESSAGE_ID;


typedef struct _PIPE_MSG_START_GATEWAY
{
    DWORD MaxClients;
    NB_REG_PARMS RegParms;
    UCHAR LanNet[MAX_LAN_NETS];  // array of lana nums for the lan nets
    HANDLE hLogFile;
} PIPE_MSG_START_GATEWAY, *PPIPE_MSG_START_GATEWAY;


typedef struct _PIPE_MSG_PROJECT_CLIENT
{
    HPORT hPort;
    CHAR PortName[MAX_PORT_NAME];
    NBFCP_SERVER_CONFIGURATION ServerConfig;
} PIPE_MSG_PROJECT_CLIENT, *PPIPE_MSG_PROJECT_CLIENT;


typedef struct _PIPE_MSG_START_CLIENT
{
    HPORT hPort;
    UCHAR lana;
    CHAR UserName[UNLEN + 1];
} PIPE_MSG_START_CLIENT, *PPIPE_MSG_START_CLIENT;


typedef struct _PIPE_MSG_STOP_CLIENT
{
    HPORT hPort;
} PIPE_MSG_STOP_CLIENT, *PPIPE_MSG_STOP_CLIENT;

//
// No info needed for REMOTE_LISTEN and TERMINATE messages
//


typedef struct _PIPE_MESSAGE
{
    PIPE_MESSAGE_ID MsgId;

    union Msg
    {
        PIPE_MSG_START_GATEWAY StartGateway;
        PIPE_MSG_PROJECT_CLIENT ProjectClient;
        PIPE_MSG_START_CLIENT StartClient;
        PIPE_MSG_STOP_CLIENT StopClient;
//      PIPE_MSG_REMOTE_LISTEN RemoteListen;
//      PIPE_MSG_TERMINATE Terminate;
    };
} PIPE_MESSAGE, *PPIPE_MESSAGE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\inc\nbgtwyif.h ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    nbgtwyif.h
//
// Description: Contains structures and definitions for components that 
//              interface directly or indirectly with the NetBios gateway. 
//              These componenets are NBFCP and DDM
//
// History:     May 11,1995	    NarenG		Created original version.
//
#ifndef _NBGTWYIF_
#define _NBGTWYIF_

#include <nbfcpif.h>


//
// Netbios Gateway -> DDM Message Ids and definitions
//

enum
{
    NBG_PROJECTION_RESULT,  // proj result. If fatal error, gtwy function
			                //  is terminated on this client
    NBG_CLIENT_STOPPED,     // gtwy function on this client has terminated
			                //  following a stop command
    NBG_DISCONNECT_REQUEST, // gtwy function on this client has terminated
			                //  due to an internal exception
    NBG_LAST_ACTIVITY       // to report time of last session activity
};

typedef struct _NBG_MESSAGE
{
    WORD  MsgId;
    HPORT hPort;                // This is really an hConnection. Change this.

    union
    {
        DWORD LastActivity;        // in minutes
        NBFCP_SERVER_CONFIGURATION config_result;
    };

} NBG_MESSAGE;

typedef WORD (* NBGATEWAYPROC)();

extern NBGATEWAYPROC FpNbGatewayStart;
extern NBGATEWAYPROC FpNbGatewayProjectClient;
extern NBGATEWAYPROC FpNbGatewayStartClient;
extern NBGATEWAYPROC FpNbGatewayStopClient;
extern NBGATEWAYPROC FpNbGatewayRemoteListen;
extern NBGATEWAYPROC FpNbGatewayTimer;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\inc\rasndis.h ===
#include <ntddndis.h>

//
// definition of the basic spin lock structure
//

typedef struct _NDIS_SPIN_LOCK {
    KSPIN_LOCK SpinLock;
    KIRQL OldIrql;
} NDIS_SPIN_LOCK, * PNDIS_SPIN_LOCK;

typedef PVOID NDIS_HANDLE, *PNDIS_HANDLE;

typedef int NDIS_STATUS, *PNDIS_STATUS; // note default size

//
// Physical address.
//

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS; // windbgkd

typedef PHYSICAL_ADDRESS NDIS_PHYSICAL_ADDRESS, *PNDIS_PHYSICAL_ADDRESS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\inc\rasmxs.h ===
//****************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//      Copyright (C) 1992-93 Microsft Corporation. All rights reserved.
//
//  Filename: rasmxs.h
//
//  Revision History:
//
//  Jun 24, 1992   J. Perry Hannah   Created
//
//
//  Description: This file contains name strings for standard macros and
//               variables found in modem.inf, pad.inf, and switch.inf.
//               This header file will be needed by all users.
//
//****************************************************************************


#ifndef _RASMXS_
#define _RASMXS_


//  General Defines  *********************************************************
//

#include <rasfile.h>


#define  MAX_PHONE_NUMBER_LENGTH    RAS_MAXLINEBUFLEN

#define  MXS_PAD_TXT                "pad"
#define  MXS_MODEM_TXT              "modem"
#define  MXS_SWITCH_TXT             "switch"
#define  MXS_NULL_TXT               "null"

#define  ATTRIB_VARIABLE            0x08
#define  ATTRIB_BINARYMACRO         0x04
#define  ATTRIB_USERSETTABLE        0x02
#define  ATTRIB_ENABLED             0x01


//  Unary Macros  ************************************************************
//
                                                                    //Used in:

#define  MXS_PHONENUMBER_KEY        "PhoneNumber"                   //modem.inf
#define  MXS_CARRIERBPS_KEY         "CarrierBps"                    //modem.inf
#define  MXS_CONNECTBPS_KEY         "ConnectBps"                    //modem.inf

#define  MXS_X25PAD_KEY             "X25Pad"                        //pad.inf
#define  MXS_X25ADDRESS_KEY         "X25Address"                    //pad.inf
#define  MXS_DIAGNOSTICS_KEY        "Diagnostics"                   //pad.inf
#define  MXS_USERDATA_KEY           "UserData"                      //pad.inf
#define  MXS_FACILITIES_KEY         "Facilities"                    //pad.inf

#define  MXS_MESSAGE_KEY	    "Message"			    //all

#define  MXS_USERNAME_KEY	    "UserName"			    //all
#define  MXS_PASSWORD_KEY	    "Password"			    // all


//  Binary Macros  ***********************************************************
//

#define  MXS_SPEAKER_KEY            "Speaker"                       //modem.inf
#define  MXS_HDWFLOWCONTROL_KEY     "HwFlowControl"                 //modem.inf
#define  MXS_PROTOCOL_KEY           "Protocol"                      //modem.inf
#define  MXS_COMPRESSION_KEY        "Compression"                   //modem.inf
#define  MXS_AUTODIAL_KEY           "AutoDial"                      //modem.inf


//  Binary Macro Suffixes  ***************************************************
//

#define  MXS_ON_SUFX                "_on"                           //all
#define  MXS_OFF_SUFX               "_off"                          //all


//  INF File Variables  ******************************************************
//

#define  MXS_DEFAULTOFF_KEY         "DEFAULTOFF"                    //modem.inf
#define  MXS_CALLBACKTIME_KEY       "CALLBACKTIME"                  //modem.inf
#define  MXS_MAXCARRIERBPS_KEY      "MAXCARRIERBPS"                 //modem.inf
#define  MXS_MAXCONNECTBPS_KEY      "MAXCONNECTBPS"                 //modem.inf


//  Keywork Prefixes  ********************************************************
//

#define  MXS_COMMAND_PRFX           "COMMAND"                       //all
#define  MXS_CONNECT_PRFX           "CONNECT"                       //all
#define  MXS_ERROR_PRFX             "ERROR"                         //all
#define  MXS_OK_PRFX                "OK"                            //all


//  Modem Command Keywords  **************************************************
//

#define  MXS_GENERIC_COMMAND        "COMMAND"
#define  MXS_INIT_COMMAND           "COMMAND_INIT"
#define  MXS_DIAL_COMMAND           "COMMAND_DIAL"
#define  MXS_LISTEN_COMMAND         "COMMAND_LISTEN"


//  Modem Response Keywords  *************************************************
//

#define  MXS_OK_KEY                 "OK"

#define  MXS_CONNECT_KEY            "CONNECT"
#define  MXS_CONNECT_EC_KEY         "CONNECT_EC"

#define  MXS_ERROR_KEY              "ERROR"
#define  MXS_ERROR_BUSY_KEY         "ERROR_BUSY"
#define  MXS_ERROR_NO_ANSWER_KEY    "ERROR_NO_ANSWER"
#define  MXS_ERROR_VOICE_KEY        "ERROR_VOICE"
#define  MXS_ERROR_NO_CARRIER_KEY   "ERROR_NO_CARRIER"
#define  MXS_ERROR_NO_DIALTONE_KEY  "ERROR_NO_DIALTONE"
#define  MXS_ERROR_DIAGNOSTICS_KEY  "ERROR_DIAGNOSTICS"

#define  MXS_NORESPONSE             "NoResponse"
#define  MXS_NOECHO                 "NoEcho"



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\inc\sechost.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:    sechost.h
//
// Description: This header defines the interface between third party security
//              DLLs and the supervisor. 
//
// History:
//	Nov 11,1994.	NarenG		Created original version.
//

#ifndef _SECHOST_
#define _SECHOST_

#include <lmcons.h>                 // Defines for DNLEN and UNLEN

#define DEVICE_NAME_LEN             32

// typedef DWORD  HPORT;

typedef struct _SECURITY_MESSAGE
{
    DWORD dwMsgId;

    HPORT hPort;
    
    DWORD dwError;                  // Should be non-zero only if error
                                    // occurred during the security dialog.
                                    // Should contain errors from winerror.h
                                    // or raserror.h
    CHAR  UserName[UNLEN+1];        // Should always contain username if 
                                    // dwMsgId is SUCCESS/FAILURE

    CHAR  Domain[DNLEN+1];          // Should always contain domain if 
                                    // dwMsgId is SUCCESS/FAILURE

} SECURITY_MESSAGE, *PSECURITY_MESSAGE;


// Values for dwMsgId in SECURITY_MESSAGE structure

#define SECURITYMSG_SUCCESS     1
#define SECURITYMSG_FAILURE     2
#define SECURITYMSG_ERROR       3

// Used by RasSecurityGetInfo call

typedef struct _RAS_SECURITY_INFO
{

    DWORD LastError;                    // SUCCESS = receive completed
                                        // PENDING = receive pending
                                        // else completed with error

    DWORD BytesReceived;                // only valid if LastError == SUCCESS

    CHAR  DeviceName[DEVICE_NAME_LEN+1];        
   

}RAS_SECURITY_INFO,*PRAS_SECURITY_INFO;

typedef DWORD (WINAPI *RASSECURITYPROC)();

//
// Called by third party DLL to notify the supervisor of termination of 
// the security dialog
//

VOID WINAPI
RasSecurityDialogComplete(
    IN SECURITY_MESSAGE * pSecMsg       // Pointer to the above info. structure
);

//
// Called by supervisor into the security DLL to notify it to begin the 
// security dialog for a client.
//
// Should return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogBegin(
    IN HPORT  hPort,        // RAS handle to port
    IN PBYTE  pSendBuf,     // Pointer to the buffer used in 
                            // RasSecurityDialogSend
    IN DWORD  SendBufSize,  // Size of above bufer in bytes
    IN PBYTE  pRecvBuf,     // Pointer to the buffer used in 
                            // RasSecurityDialogReceive
    IN DWORD  RecvBufSize,  // Size of above buffer
    IN VOID  (WINAPI *RasSecurityDialogComplete)( SECURITY_MESSAGE* )
                            // Pointer to function RasSecurityDialogComplete.   
                            // Guaranteed to be the same on every call.
);

//
// Called by supervisor into the security DLL to notify it to stop the 
// security dialog for a client. If this call returns an error, then it is not
// neccesary for the dll to call RasSecurityDialogComplete. Otherwise the DLL
// must call RasSecurityDialogComplete.
//
// Should return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogEnd(
    IN HPORT    hPort           // RAS handle to port.
);

//
// Called to send data to remote host
// Will return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogSend(
    IN HPORT    hPort,          // RAS handle to port.
    IN PBYTE    pBuffer,        // Pointer to buffer containing data to send
    IN WORD     BufferLength    // Length of above buffer.
);

//
// Called to receive data from remote host
// Will return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogReceive(
    IN HPORT    hPort,          // RAS handle to port.
    IN PBYTE    pBuffer,        // Pointer to buffer to receive data
    IN PWORD    pBufferLength,  // length of data received in bytes.
    IN DWORD    Timeout,        // in seconds
    IN HANDLE   hEvent          // Event to set when receive completes or 
                                // timeouts
);

//
// Called to get Information about port.
// Will return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogGetInfo(
    IN HPORT                hPort,      // RAS handle to port.
    IN RAS_SECURITY_INFO*   pBuffer     // Pointer to get info structure.
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\inc\rasauth.h ===
/********************************************************************/
/**               Copyright(c) 1997-1998 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    RASAUTH.H
//
// Description: Contains definitions to allow for third parties to plug in
//              back-end authenticaion modules into Remote Access Service.
//
#ifndef _RASAUTH_
#define _RASAUTH_

#include <raseapif.h>

#ifdef __cplusplus
extern "C" {
#endif

#if(WINVER >= 0x0500)

//
// Registry definitions used for installation or Accounting and Authenticaion
// providers

#define RAS_AUTHPROVIDER_REGISTRY_LOCATION      \
    TEXT("SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Authentication\\Providers")

#define RAS_ACCTPROVIDER_REGISTRY_LOCATION      \
    TEXT("SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Accounting\\Providers")

#define RAS_PROVIDER_VALUENAME_PATH             TEXT("Path")
#define RAS_PROVIDER_VALUENAME_CONFIGCLSID      TEXT("ConfigCLSID")
#define RAS_PROVIDER_VALUENAME_DISPLAYNAME      TEXT("DisplayName")

DWORD APIENTRY
RasAuthProviderInitialize(
    IN  RAS_AUTH_ATTRIBUTE * pServerAttributes,
    IN  HANDLE               hEventLog,
    IN  DWORD                dwLoggingLevel
);

DWORD APIENTRY
RasAuthProviderTerminate(
    VOID
);

DWORD APIENTRY
RasAuthProviderFreeAttributes(
    IN  RAS_AUTH_ATTRIBUTE * pAttributes
);

DWORD APIENTRY
RasAuthProviderAuthenticateUser(
    IN  RAS_AUTH_ATTRIBUTE *    prgInAttributes,
    OUT RAS_AUTH_ATTRIBUTE **   pprgOutAttributes,
    OUT DWORD *                 lpdwResultCode
);

DWORD APIENTRY
RasAuthConfigChangeNotification(
    IN  DWORD                dwLoggingLevel
);

DWORD APIENTRY
RasAcctProviderInitialize(
    IN  RAS_AUTH_ATTRIBUTE * pServerAttributes,
    IN  HANDLE               hEventLog,
    IN  DWORD                dwLoggingLevel
);

DWORD APIENTRY
RasAcctProviderTerminate(
    VOID
);


DWORD APIENTRY
RasAcctProviderFreeAttributes(
    IN  RAS_AUTH_ATTRIBUTE * pAttributes
);

DWORD APIENTRY
RasAcctProviderStartAccounting(
    IN  RAS_AUTH_ATTRIBUTE *prgInAttributes,
    OUT RAS_AUTH_ATTRIBUTE **pprgOutAttributes
);

DWORD APIENTRY
RasAcctProviderStopAccounting(
    IN  RAS_AUTH_ATTRIBUTE *prgInAttributes,
    OUT RAS_AUTH_ATTRIBUTE **pprgOutAttributes
);

DWORD APIENTRY
RasAcctProviderInterimAccounting(
    IN  RAS_AUTH_ATTRIBUTE *prgInAttributes,
    OUT RAS_AUTH_ATTRIBUTE **pprgOutAttributes
);

DWORD APIENTRY
RasAcctConfigChangeNotification(
    IN  DWORD                dwLoggingLevel
);

#endif /* WINVER >= 0x0500 */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\inc\serial.h ===
//****************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//      Copyright (C) 1992-93 Microsft Corporation. All rights reserved.
//
//  Filename: serial.h
//
//  Revision History:
//
//  July 27, 1992   Gurdeep Pall Created
//
//
//  Description: This file contains name strings for standard parameter
//               names used for serial Media.
//
//****************************************************************************


#ifndef _SERIALDLLINCLUDE_
#define _SERIALDLLINCLUDE_


//  General Defines  *********************************************************
//

#define MAX_BPS_STR_LEN     11  //Longest string from a DWORD + zero byte

#define SERIAL_TXT          "serial"


//  Serial.ini File Defines  *************************************************
//

#define SER_MAXCONNECTBPS_KEY   "MAXCONNECTBPS"
#define SER_MAXCARRIERBPS_KEY   "MAXCARRIERBPS"
#define SER_INITBPS_KEY         "INITIALBPS"

#define SER_DEVICETYPE_KEY      "DEVICETYPE"
#define SER_DEVICENAME_KEY      "DEVICENAME"

#define SER_USAGE_KEY           "USAGE"
#define SER_USAGE_VALUE_CLIENT  "Client"
#define SER_USAGE_VALUE_SERVER  "Server"
//#define SER_USAGE_VALUE_BOTH    "ClientAndServer"
#define SER_USAGE_VALUE_ROUTER  "Router"
#define SER_USAGE_VALUE_NONE    "None"

#define SER_DEFAULTOFF_KEY      "DEFAULTOFF"
#define SER_C_DEFAULTOFF_KEY    "CLIENT_DEFAULTOFF"


//  PortGetInfo and PortSetInfo Defines  *************************************
//

#define SER_PORTNAME_KEY        "PortName"
#define SER_CONNECTBPS_KEY      "ConnectBPS"
#define SER_DATABITS_KEY        "WordSize"

#define SER_PARITY_KEY          "Parity"
#define SER_STOPBITS_KEY        "StopBits"
#define SER_HDWFLOWCTRLON_KEY   "HdwFlowControlEnabled"

#define SER_CARRIERBPS_KEY      "CarrierBPS"
#define SER_ERRORCONTROLON_KEY  "ErrorControlEnabled"
#define SER_DEFAULTOFFSTR_KEY   "DEFAULTOFF"
#define SER_C_DEFAULTOFFSTR_KEY "CLIENT_DEFAULTOFF"

#define SER_PORTOPEN_KEY        "PortOpenFlag"


//  Statistics Indicies  *****************************************************
//

#define NUM_RAS_SERIAL_STATS    14

#define BYTES_XMITED            0       //Generic Stats
#define BYTES_RCVED             1
#define FRAMES_XMITED           2
#define FRAMES_RCVED            3

#define CRC_ERR                 4       //Serial Stats
#define TIMEOUT_ERR             5
#define ALIGNMENT_ERR           6
#define SERIAL_OVERRUN_ERR      7
#define FRAMING_ERR             8
#define BUFFER_OVERRUN_ERR      9

#define BYTES_XMITED_UNCOMP     10      //Compression Stats
#define BYTES_RCVED_UNCOMP      11
#define BYTES_XMITED_COMP       12
#define BYTES_RCVED_COMP        13



#endif // _SERIALDLLINCLUDE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\inc\uiip.h ===
/* Copyright (c) 1994, Microsoft Corporation, all rights reserved
**
** uiip.h
** Remote Access PPP
** UI->IPCP interface definitions
*/

#ifndef _UIIP_H_
#define _UIIP_H_


/* Parameter buffer option keys.
*/
#define PBUFKEY_IpAddress           "IpAddr"
#define PBUFKEY_IpAddressSource     "IpAddrSrc"
#define PBUFKEY_IpPrioritizeRemote  "IpRemote"
#define PBUFKEY_IpVjCompression     "IpVj"
#define PBUFKEY_IpDnsAddress        "IpDns"
#define PBUFKEY_IpDns2Address       "IpDns2"
#define PBUFKEY_IpWinsAddress       "IpWins"
#define PBUFKEY_IpWins2Address      "IpWins2"
#define PBUFKEY_IpNameAddressSource "IpNameSrc"
#define PBUFKEY_IpDnsFlags          "IpDnsFlags"
#define PBUFKEY_IpDnsSuffix         "IpDnsSuffix"

/* IpAddressSource values.  For the UI's convenience, these codes are defined
** to match the codes stored in the phonebook.
*/
#define PBUFVAL_ServerAssigned   1
#define PBUFVAL_RequireSpecific  2


#endif // _UIIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\inc\rasfile.h ===
/*****************************************************************************
**              Microsoft Rasfile Library
**              Copyright (C) Microsoft Corp., 1992
**
** File Name : rasfile.h
**
** Revision History :
**      July 10, 1992   David Kays      Created
**      Dec  12, 1992   Ram Cherala     Added RFM_KEEPDISKFILEOPEN
**
** Description :
**      Rasfile file export include file.
******************************************************************************/

#ifndef _RASFILE_
#define _RASFILE_

//
// RASFILE load modes
//
#define RFM_SYSFORMAT           0x01    // DOS config.sys style file
#define RFM_CREATE              0x02    // create file if it does't exist
#define RFM_READONLY            0x04    // open file for read only
#define RFM_LOADCOMMENTS        0x08    // load comment lines into memory
#define RFM_ENUMSECTIONS        0x10    // only section headers loaded
#define RFM_KEEPDISKFILEOPEN    0x20    // if not set close the disk file

//
// RASFILE line type bit-masks.
// The ANY types are shorthand for multiple line types.
//
#define RFL_SECTION             0x01
#define RFL_GROUP               0x02
#define RFL_ANYHEADER           (RFL_SECTION | RFL_GROUP)
#define RFL_BLANK               0x04
#define RFL_COMMENT             0x08
#define RFL_ANYINACTIVE         (RFL_BLANK | RFL_COMMENT)
#define RFL_KEYVALUE            0x10
#define RFL_COMMAND             0x20
#define RFL_ANYACTIVE           (RFL_KEYVALUE | RFL_COMMAND)
#define RFL_ANY                 0x3F

//
// RASFILE search scope.
//
typedef enum
{
    RFS_FILE,
    RFS_SECTION,
    RFS_GROUP
} RFSCOPE;

typedef int     HRASFILE;
typedef BOOL    (*PFBISGROUP)();

#define INVALID_HRASFILE     -1
#define RAS_MAXLINEBUFLEN    600
#define RAS_MAXSECTIONNAME   RAS_MAXLINEBUFLEN

//
// RasfileLoad parameters as returned by RasfileLoadInfo.
//
typedef struct _RASFILELOADINFO
{
    CHAR        szPath[ MAX_PATH ];
    DWORD       dwMode;
    CHAR        szSection[ RAS_MAXSECTIONNAME + 1 ];
    PFBISGROUP  pfbIsGroup;
} RASFILELOADINFO;


//
// RASFILE APIs
//

// file management routines
HRASFILE APIENTRY  RasfileLoad( LPCSTR, DWORD, LPCSTR, PFBISGROUP);
BOOL APIENTRY    RasfileWrite( HRASFILE, LPCSTR );
BOOL APIENTRY    RasfileClose( HRASFILE );
VOID APIENTRY    RasfileLoadInfo( HRASFILE, RASFILELOADINFO* );

// file navigation routines
BOOL APIENTRY    RasfileFindFirstLine( HRASFILE, BYTE, RFSCOPE );
BOOL APIENTRY    RasfileFindLastLine( HRASFILE, BYTE, RFSCOPE );
BOOL APIENTRY    RasfileFindPrevLine( HRASFILE, BYTE, RFSCOPE );
BOOL APIENTRY    RasfileFindNextLine( HRASFILE, BYTE, RFSCOPE );
BOOL APIENTRY    RasfileFindNextKeyLine( HRASFILE, LPCSTR, RFSCOPE );
BOOL APIENTRY    RasfileFindMarkedLine( HRASFILE, BYTE );
BOOL APIENTRY    RasfileFindSectionLine( HRASFILE, LPCSTR, BOOL );

// file editing routines
const LPCSTR APIENTRY    RasfileGetLine( HRASFILE );
BOOL APIENTRY    RasfileGetLineText( HRASFILE, LPSTR );
BOOL APIENTRY    RasfilePutLineText( HRASFILE, LPCSTR );
BYTE APIENTRY    RasfileGetLineMark( HRASFILE );
BOOL APIENTRY    RasfilePutLineMark( HRASFILE, BYTE );
BYTE APIENTRY    RasfileGetLineType( HRASFILE );
BOOL APIENTRY    RasfileInsertLine( HRASFILE, LPCSTR, BOOL );
BOOL APIENTRY    RasfileDeleteLine( HRASFILE );
BOOL APIENTRY    RasfileGetSectionName( HRASFILE, LPSTR );
BOOL APIENTRY    RasfilePutSectionName( HRASFILE, LPCSTR );
BOOL APIENTRY    RasfileGetKeyValueFields( HRASFILE, LPSTR, LPSTR );
BOOL APIENTRY    RasfilePutKeyValueFields( HRASFILE, LPCSTR, LPCSTR );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\inc\srvauth.h ===
/*****************************************************************************/
/**                      Microsoft LAN Manager                              **/
/**                Copyright (C) Microsoft Corp., 1992-1993                 **/
/*****************************************************************************/

//***
//    File Name:
//       SRVAUTH.H
//
//    Function:
//        Contains header information for Supervisor and Server
//        Authentication Transport module
//
//    History:
//        05/18/92 - Michael Salamone (MikeSa) - Original Version 1.0
//***

#ifndef _SRVAUTH_
#define _SRVAUTH_


/* This flag enables the NT31/WFW311 RAS compression support re-added for the
** NT-PPC release.
*/
#define RASCOMPRESSION 1


#include <lmcons.h>
#include <rasman.h>

#ifndef MAX_PHONE_NUMBER_LEN
#define MAX_PHONE_NUMBER_LEN    48
#endif

#ifndef MAX_INIT_NAMES
#define MAX_INIT_NAMES          16
#endif


//
// Used for establishing session with remote netbios clients
//
#define AUTH_NETBIOS_NAME    "DIALIN_GATEWAY  "



//
// Used for passing NetBIOS projection info to Supervisor
//
typedef struct _NAME_STRUCT
{
    BYTE NBName[NETBIOS_NAME_LEN]; // NetBIOS name
    WORD wType;                    // GROUP, UNIQUE, COMPUTER
} NAME_STRUCT, *PNAME_STRUCT;


//
// Manifests used to find location and type of name in the buffer returned
// by the NCB.STATUS call
//
#define NCB_GROUP_NAME  0x0080
#define UNIQUE_INAME    0x0001
#define GROUP_INAME     0x0002
#define COMPUTER_INAME  0x0004  // A computer name is also unique


//
// Projection result codes.  If not success, then the reason code
// (below) should be examined.  These values are used in wResult
// field in structs define below.
//
#define AUTH_PROJECTION_SUCCESS        0
#define AUTH_PROJECTION_FAILURE        1


//
// Projection reason codes.
//
#define FATAL_ERROR                    0x80000000
#define AUTH_DUPLICATE_NAME            (FATAL_ERROR | 0x00000001)
#define AUTH_OUT_OF_RESOURCES          (FATAL_ERROR | 0x00000002)
#define AUTH_STACK_NAME_TABLE_FULL     (FATAL_ERROR | 0x00000003)
#define AUTH_MESSENGER_NAME_NOT_ADDED                0x00000004
#define AUTH_CANT_ALLOC_ROUTE          (FATAL_ERROR | 0x00000005)
#define AUTH_LAN_ADAPTER_FAILURE       (FATAL_ERROR | 0x00000006)

//
// Projection result info must be copied into this structure.
//

typedef struct _IP_PROJECTION_RESULT
{
    DWORD Result;
    DWORD Reason;
} IP_PROJECTION_RESULT, *PIP_PROJECTION_RESULT;

typedef struct _IPX_PROJECTION_RESULT
{
    DWORD Result;
    DWORD Reason;
} IPX_PROJECTION_RESULT, *PIPX_PROJECTION_RESULT;


typedef struct _NETBIOS_PROJECTION_RESULT
{
    DWORD Result;
    DWORD Reason;
    char achName[NETBIOS_NAME_LEN];
} NETBIOS_PROJECTION_RESULT, *PNETBIOS_PROJECTION_RESULT;


typedef struct _AUTH_PROJECTION_RESULT
{
    IP_PROJECTION_RESULT IpResult;
    IPX_PROJECTION_RESULT IpxResult;
    NETBIOS_PROJECTION_RESULT NetbiosResult;
} AUTH_PROJECTION_RESULT, *PAUTH_PROJECTION_RESULT;


//
// The Supervisor will supply this structure to the Auth Xport (in
// the AuthStart API) so it knows what transport, as well as any
// necessary info for that transport, to use for authenticating on
// the given port.
//
typedef struct _AUTH_XPORT_INFO
{
    RAS_PROTOCOLTYPE Protocol;
    BYTE bLana;   // Only valid if Protocol == ASYBEUI
} AUTH_XPORT_INFO, *PAUTH_XPORT_INFO;


#ifndef _CLAUTH_


typedef WORD (*MSG_ROUTINE)(WORD, PVOID);

//
// Used to initialize the Auth Xport module
//
DWORD 
AuthInitialize(
    IN HPORT        *phPorts,  // pointer to array of port handles
    IN WORD         cPorts,    // number of port handles in array
    IN WORD         cRetries,  // number of retries clients will get if initial
                               // authentication attemps fails
    IN MSG_ROUTINE  MsgSend,
    IN DWORD        dwLocalIpAddress,
    IN LPVOID       lpfnRasAuthProviderAuthenticateUser,
    IN LPVOID       lpfnRasAuthProviderFreeAttributes,
    IN LPVOID       lpfnRasAcctProviderStartAccounting,
    IN LPVOID       lpfnRasAcctProviderInterimAccounting,
    IN LPVOID       lpfnRasAcctProviderStopAccounting,
    IN LPVOID       lpfnRasAcctProviderFreeAttributes,
    IN LPVOID       GetNextAccountingSessionId
);

//
// Returned by AuthInitialize
//
#define AUTH_INIT_SUCCESS          0
#define AUTH_INIT_FAILURE          1


//
// Used by Supervisor to tell Auth Xport module that it has completed its
// callback request.
//
VOID AuthCallbackDone(
    IN HPORT hPort
    );


//
// Used by Supervisor to tell Auth Xport module that it has completed its
// projection request.
//
VOID AuthProjectionDone(
    IN HPORT hPort,
    IN PAUTH_PROJECTION_RESULT
    );


//
// Returned by AuthRecognizeFrame
//
#define AUTH_FRAME_RECOGNIZED      0
#define AUTH_FRAME_NOT_RECOGNIZED  1


//
// To kick off an Authentication thread for the given port.
//
WORD AuthStart(
    IN HPORT,
    IN PAUTH_XPORT_INFO
    );

//
// Returned by AuthStart:
//
#define AUTH_START_SUCCESS         0
#define AUTH_START_FAILURE         1


//
// Used by Supervisor to tell Auth Xport module to halt authentication
// processing on the given port.
//
WORD AuthStop(
    IN HPORT hPort
    );

//
// Returned by AuthStop
//
#define AUTH_STOP_SUCCESS          0
#define AUTH_STOP_PENDING          1
#define AUTH_STOP_FAILURE          2


//
// The following messages are sent from Authentication to Supervisor via
// MESSAGE.DLL and are to be used in wMsgId in message struct below:
//
#define AUTH_DONE                    100
#define AUTH_FAILURE                 101
#define AUTH_STOP_COMPLETED          102
#define AUTH_PROJECTION_REQUEST      103
#define AUTH_CALLBACK_REQUEST        104
#define AUTH_ACCT_OK                 105


//
// These are the structures that accompany each message defined above:
//

// No structure for AUTH_DONE

// Structure for AUTH_FAILURE
typedef struct _AUTH_FAILURE_INFO
{
    WORD wReason;
    BYTE szLogonDomain[DNLEN + 1];
    BYTE szUserName[UNLEN + 1];
} AUTH_FAILURE_INFO, *PAUTH_FAILURE_INFO;

//
// These are the reasons that Authentication might fail:
//
#define AUTH_XPORT_ERROR             200
#define AUTH_NOT_AUTHENTICATED       201
#define AUTH_ALL_PROJECTIONS_FAILED  202
#define AUTH_INTERNAL_ERROR          203
#define AUTH_ACCT_EXPIRED            204
#define AUTH_NO_DIALIN_PRIVILEGE     205
#define AUTH_UNSUPPORTED_VERSION     206
#define AUTH_ENCRYPTION_REQUIRED     207
#define AUTH_PASSWORD_EXPIRED        208
#define AUTH_LICENSE_LIMIT_EXCEEDED  209


// No structure for AUTH_STOP_COMPLETED


typedef BOOL IP_PROJECTION_INFO, *PIP_PROJECTION_INFO;

typedef BOOL IPX_PROJECTION_INFO, *PIPX_PROJECTION_INFO;

typedef struct _NETBIOS_PROJECTION_INFO
{
    BOOL fProject;
    WORD cNames;
    NAME_STRUCT Names[MAX_INIT_NAMES];
} NETBIOS_PROJECTION_INFO, *PNETBIOS_PROJECTION_INFO;


typedef struct _AUTH_PROJECTION_REQUEST_INFO
{
    IP_PROJECTION_INFO IpInfo;
    IPX_PROJECTION_INFO IpxInfo;
    NETBIOS_PROJECTION_INFO NetbiosInfo;
} AUTH_PROJECTION_REQUEST_INFO, *PAUTH_PROJECTION_REQUEST_INFO;


typedef struct _AUTH_CALLBACK_REQUEST_INFO
{
    BOOL fUseCallbackDelay;
    WORD CallbackDelay;       // Valid only if fUseCallbackDelay == TRUE
    CHAR szCallbackNumber[MAX_PHONE_NUMBER_LEN + 1];
} AUTH_CALLBACK_REQUEST_INFO, *PAUTH_CALLBACK_REQUEST_INFO;


typedef struct _AUTH_ACCT_OK_INFO
{
    BYTE szUserName[UNLEN + 1];
    BYTE szLogonDomain[DNLEN + 1];
    BOOL fAdvancedServer;
    HANDLE hLicense;
} AUTH_ACCT_OK_INFO, *PAUTH_ACCT_OK_INFO;


//
// This is the structure used in sending messages to the Supervisor
//
typedef struct _AUTH_MESSAGE
{
    WORD wMsgId;
    HPORT hPort;
    union
    {
        AUTH_FAILURE_INFO FailureInfo;
        AUTH_PROJECTION_REQUEST_INFO ProjectionRequest;
        AUTH_CALLBACK_REQUEST_INFO CallbackRequest;
        AUTH_ACCT_OK_INFO AcctOkInfo;
    };
} AUTH_MESSAGE, *PAUTH_MESSAGE;


#endif // _CLAUTH_


#endif // _SRVAUTH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\auth\nt\resource.h ===
#define IDS_UNAUTHENTICATED_USER    1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\auth\radius\hmacmd5.c ===
/*++

Copyright (C) 1997 Cisco Systems, Inc.  All Rights Reserved.

Module Name:

    hmac_md5.c

Abstract:

    This module contains routines to perform HMAC using MD5
	as defined in RFC-2104.

Author:

	Derrell Piper (v-dpiper)

Facility:

    ISAKMP/Oakley

Revision History:

--*/

//#include <iascore.h>
#include <windows.h>
#include <hmacmd5.h>

#ifdef WIN32
#define bcopy(b1, b2, len) memcpy((b2), (b1), (len))
#define bzero(b,len) memset((b), 0, (len))
#define bcmp(b1, b2, len) memcmp((b1), (b2), (len))
#endif /* WIN32 */

#define MD5_LEN     16

 /*
 * hmac_md5 = MD5(key ^ opad, MD5(key ^ ipad, text))
 *    where ipad is 64 0x36's, and
 *	    opad is 64 0x5c's
 *
 *  Also contains native MD5 wrappers which allow for consistent calling
 */

VOID
HmacMD5Init  (
    PHmacContext   pContext, 
    PBYTE          pkey, 
    ULONG          keylen
    )
{
    BYTE        ipad[64];
    MD5Digest   keydigest;
    int i;

    if((pkey == NULL) && (keylen != 0))
	return;

    if(keylen > 64)
    {
	    MD5Context tempctx;

	    MD5Init(&tempctx);
	    MD5Update(&tempctx, pkey, keylen);
    	MD5Final(&keydigest, &tempctx);
	    pkey = keydigest.digest;
	    keylen = MD5_LEN;
    }

    bzero(ipad, 64);
    bzero(pContext->opad, 64);
    bcopy(pkey, ipad, keylen);
    bcopy(pkey, pContext->opad, keylen);

    for(i=0; i<64; i++)
    {
	    ipad[i] ^= 0x36;
	    pContext->opad[i] ^= 0x5c;
    }

    MD5Init(&pContext->md5);
    MD5Update(&pContext->md5, ipad, 64);
    return;

}   //  end of HmacMD5Init method

VOID
HmacMD5Update (
    PHmacContext    pContext, 
    PBYTE           ptext, 
    ULONG           textlen
    )
{
    if((ptext == NULL) || (textlen == 0))
	    return;
    MD5Update(&pContext->md5, ptext, textlen);

}   //  end of HMacMD5Update method

VOID
HmacMD5Final (
    PMD5Digest      pDigest, 
    PHmacContext    pContext
    )
{
    MD5Digest    tempDigest;

    if ((NULL == pDigest) || (NULL == pContext))
        return;

    MD5Final(&tempDigest, &pContext->md5);
    MD5Init(&pContext->md5);
    MD5Update(&pContext->md5, pContext->opad, 64);
    MD5Update(&pContext->md5, tempDigest.digest, MD5_LEN);
    MD5Final(pDigest, &pContext->md5);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\auth\nt\ntauth.h ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    ntauth.h
//
// Description: 
//
// History:     Feb 11,1997	    NarenG		Created original version.
//

#ifdef __cplusplus
extern "C" {
#endif

#ifdef ALLOCATE_GLOBALS
#define EXTERN
#else
#define EXTERN extern
#endif

#include <iaspolcy.h>
#include <iasext.h>

typedef enum
{
    RAS_IAS_START_ACCOUNTING,
    RAS_IAS_STOP_ACCOUNTING,
    RAS_IAS_INTERIM_ACCOUNTING,
    RAS_IAS_ACCOUNTING_ON,
    RAS_IAS_ACCOUNTING_OFF,
    RAS_IAS_ACCESS_REQUEST

} RAS_IAS_REQUEST_TYPE;

EXTERN 
DWORD g_dwTraceIdNt
#ifdef GLOBALS
    = INVALID_TRACEID;
#endif
;

EXTERN 
BOOL g_fInitialized
#ifdef GLOBALS
    = FALSE;
#endif
;

EXTERN
RAS_AUTH_ATTRIBUTE *
g_pServerAttributes 
#ifdef GLOBALS
    = NULL
#endif
;

EXTERN
DWORD *
g_hEventLog
#ifdef GLOBALS
    = NULL
#endif
;

EXTERN
HANDLE
g_hInstance
#ifdef GLOBALS
    = NULL
#endif
;

EXTERN
DWORD
g_LoggingLevel
#ifdef GLOBALS
    = 0
#endif
;

#define MaxCharsUnauthUser_c 100
EXTERN CHAR g_aszUnauthenticatedUser[MaxCharsUnauthUser_c+1];

#define TRACE_NTAUTH        (0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC)

#define TRACE(a)            TracePrintfExA(g_dwTraceIdNt,TRACE_NTAUTH,a )
#define TRACE1(a,b)         TracePrintfExA(g_dwTraceIdNt,TRACE_NTAUTH,a,b )
#define TRACE2(a,b,c)       TracePrintfExA(g_dwTraceIdNt,TRACE_NTAUTH,a,b,c )
#define TRACE3(a,b,c,d)     TracePrintfExA(g_dwTraceIdNt,TRACE_NTAUTH,a,b,c,d )
#define TRACE4(a,b,c,d,e)   TracePrintfExA(g_dwTraceIdNt,TRACE_NTAUTH,a,b,c,d,e)

#define NtAuthLogWarning( LogId, NumStrings, lpwsSubStringArray )        \
    if ( g_LoggingLevel > 1 ) {                                          \
        RouterLogWarningW( g_hEventLog, LogId,                           \
                          NumStrings, lpwsSubStringArray, 0 ); }

DWORD
IASSendReceiveAttributes(
    IN  RAS_IAS_REQUEST_TYPE    RequestType,
    IN  RAS_AUTH_ATTRIBUTE *    pInAttributes,
    OUT PRAS_AUTH_ATTRIBUTE *   ppOutAttributes,
    OUT DWORD *                 lpdwResultCode
);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\auth\radius\lsa.c ===
/********************************************************************/
/**          Copyright(c) 1985-1998 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    lsa.c
//
// Description: 
//
// History:     Feb 11,1998	    NarenG		Created original version.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>

#include <windows.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <raserror.h>
#include <time.h>
#include <string.h>
#include <rasauth.h>
#include <stdlib.h>
#include <stdio.h>
#include <rtutils.h>
#include <mprlog.h>
#include <mprerror.h>
#define INCL_RASAUTHATTRIBUTES
#include <ppputil.h>
#include "md5.h"
#include "radclnt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\auth\radius\hmacmd5.h ===
/*++

Copyright (C) 1997 Cisco Systems, Inc.  All Rights Reserved.

Module Name:

    hmac_md5.h

Abstract:

    This module contains definitions for HMAC MD5.

Author:

	Derrell Piper (v-dpiper)

Facility:

    ISAKMP/Oakley

Revision History:

--*/
#ifndef _HMAC_MD5_
#define _HMAC_MD5_

#include "md5.h"

typedef struct _hmaccontext_ {
    MD5Context md5;
    unsigned char opad[64];

} HmacContext, *PHmacContext;

VOID WINAPI
HmacMD5Init(
	PHmacContext    pContext, 
	PBYTE           pkey, 
	ULONG           keylen
    );

VOID WINAPI
HmacMD5Update(
	PHmacContext    pContext, 
	PBYTE           ptext, 
	ULONG           textlen
);

VOID WINAPI
HmacMD5Final (
	PMD5Digest      pdigest, 
	PHmacContext    pcontext
);

#endif //end of _HMAC_MD5_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\auth\nt\ntauth.c ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    ntauth.c
//
// Description: Contains entrypoints to do NT back-end authentication for
//              ppp.
//
// History:     Feb 11,1997	    NarenG		Created original version.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <ntsamp.h>
#include <crypt.h>

#include <crypt.h>
#define INC_OLE2
#include <windows.h>
#include <lmcons.h>
#include <netlib.h>     // For NetpGetDomainNameEx
#include <lmapibuf.h>
#include <lmaccess.h>
#include <raserror.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <locale.h>
#include <shlobj.h>
#include <dsclient.h>
#include <dsgetdc.h>
#include <ntdsapi.h>
#include <rasman.h>
#include <rasppp.h>
#include <mprerror.h>
#include <rasauth.h>
#include <mprlog.h>
#include <pppcp.h>
#include <rtutils.h>
#define INCL_RASAUTHATTRIBUTES
#define INCL_HOSTWIRE
#define INCL_MISC
#include <ppputil.h>
#define ALLOCATE_GLOBALS
#include "ntauth.h"
#include "resource.h"

//**
//
// Call:        RasAuthDllEntry
//
// Returns:     TRUE        - Success
//              FALSE       - Failure
//
// Description:
//
BOOL
RasAuthDllEntry(
    HANDLE hinstDll,
    DWORD  fdwReason,
    LPVOID lpReserved
)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            DisableThreadLibraryCalls( hinstDll );

            g_hInstance = hinstDll;

            break;
        }

        case DLL_PROCESS_DETACH:
        {
            g_hInstance = NULL;

            break;
        }

        default:

            break;
    }

    return( TRUE );
}

//**
//
// Call:        RasAuthProviderInitialize
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD APIENTRY
RasAuthProviderInitialize(
    IN  RAS_AUTH_ATTRIBUTE *    pServerAttributes,
    IN  HANDLE                  hEventLog,
    IN  DWORD                   dwLoggingLevel
)
{
    DWORD           dwRetCode = NO_ERROR;
    HRESULT         hResult;
    NT_PRODUCT_TYPE NtProductType       = NtProductLanManNt;
    LPWSTR          lpwstrDomainNamePtr = NULL;
    BOOLEAN         fIsWorkgroupName    = FALSE;

    //
    // If already initalized, we return
    //

    if ( g_fInitialized )
    {
        return( NO_ERROR );
    }

    g_dwTraceIdNt = INVALID_TRACEID;

    setlocale( LC_ALL,"" );

    g_dwTraceIdNt = TraceRegisterA( "RASAUTH" );

    hResult = CoInitializeEx( NULL, COINIT_MULTITHREADED );

    if ( FAILED( hResult ) )
    {
        return( HRESULT_CODE( hResult ) );
    }

    hResult = InitializeIas( TRUE );

    if ( FAILED( hResult ) )
    {
        dwRetCode = HRESULT_CODE( hResult );

        TRACE1("Initialize Ias failed with %d", dwRetCode );

        CoUninitialize();

        return( dwRetCode );
    }

    g_hEventLog = hEventLog;

    g_LoggingLevel = dwLoggingLevel;

    if (!LoadString(g_hInstance, IDS_UNAUTHENTICATED_USER,
            g_aszUnauthenticatedUser, MaxCharsUnauthUser_c))
    {
        g_aszUnauthenticatedUser[0] = 0;
    }

    g_fInitialized = TRUE;

    TRACE("RasAuthProviderInitialize succeeded");

    return( NO_ERROR );
}

//**
//
// Call:        RasAuthProviderTerminate
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD APIENTRY
RasAuthProviderTerminate(
    VOID
)
{
    //
    // If already terminated, we return
    //

    if ( !g_fInitialized )
    {
        return( NO_ERROR );
    }

    g_fInitialized = FALSE;

    if ( g_dwTraceIdNt != INVALID_TRACEID )
    {
        TraceDeregisterA( g_dwTraceIdNt );
    }

    ShutdownIas();

    CoUninitialize();

    TRACE("RasAuthTerminate succeeded");

    return( NO_ERROR );
}

//**
//
// Call:        RasAcctProviderInitialize
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD APIENTRY
RasAcctProviderInitialize(
    IN  RAS_AUTH_ATTRIBUTE *    pServerAttributes,
    IN  HANDLE                  hEventLog,
    IN  DWORD                   dwLoggingLevel
)
{
    RAS_AUTH_ATTRIBUTE *    pOutAttributes = NULL;
    DWORD                   dwResultCode;

    DWORD dwRetCode =  RasAuthProviderInitialize( pServerAttributes, 
                                                  hEventLog, 
                                                  dwLoggingLevel );

    if ( dwRetCode == NO_ERROR )
    {
        dwRetCode = IASSendReceiveAttributes( RAS_IAS_ACCOUNTING_ON,
                                              pServerAttributes,
                                              &pOutAttributes,
                                              &dwResultCode );

        if ( pOutAttributes != NULL )
        {
            RasAuthAttributeDestroy( pOutAttributes );
        }

        if ( dwRetCode == NO_ERROR )
        {
            //
            // Make a copy of the Server attributes
            //

            g_pServerAttributes = RasAuthAttributeCopy( pServerAttributes );

            if ( g_pServerAttributes == NULL )
            {
                dwRetCode = GetLastError();
            }
        }
    }

    g_hEventLog = hEventLog;

    g_LoggingLevel = dwLoggingLevel;

    return( dwRetCode );
}

//**
//
// Call:        RasAcctProviderTerminate
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD APIENTRY
RasAcctProviderTerminate(
    VOID
)
{
    RAS_AUTH_ATTRIBUTE *    pOutAttributes = NULL;
    DWORD                   dwResultCode;

    IASSendReceiveAttributes( RAS_IAS_ACCOUNTING_OFF,
                              g_pServerAttributes,
                              &pOutAttributes,
                              &dwResultCode );

    if ( pOutAttributes != NULL )
    {
        RasAuthAttributeDestroy( pOutAttributes );
    }

    if ( g_pServerAttributes != NULL )
    {
        RasAuthAttributeDestroy( g_pServerAttributes );

        g_pServerAttributes = NULL;
    }

    RasAuthProviderTerminate();

    return( NO_ERROR );
}

//**
//
// Call:        RasAcctProviderStartAccounting
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD APIENTRY
RasAcctProviderStartAccounting(
    IN  RAS_AUTH_ATTRIBUTE *    pInAttributes,
    OUT PRAS_AUTH_ATTRIBUTE *   ppOutAttributes
)
{
    DWORD dwResultCode = NO_ERROR;

    TRACE("RasStartAccounting called");

    return( IASSendReceiveAttributes( RAS_IAS_START_ACCOUNTING,
                                      pInAttributes,
                                      ppOutAttributes,
                                      &dwResultCode ) );
}

//**
//
// Call:        RasAcctProviderStopAccounting
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD APIENTRY
RasAcctProviderStopAccounting(
    IN  RAS_AUTH_ATTRIBUTE *    pInAttributes,
    OUT PRAS_AUTH_ATTRIBUTE *   ppOutAttributes
)
{
    DWORD dwResultCode = NO_ERROR;

    TRACE("RasStopAccounting called");

    return( IASSendReceiveAttributes( RAS_IAS_STOP_ACCOUNTING,
                                      pInAttributes,
                                      ppOutAttributes,
                                      &dwResultCode ) );
}

//**
//
// Call:        RasAcctConfigChangeNotification
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Reloads config information dynamically
//
DWORD APIENTRY
RasAcctConfigChangeNotification(
    IN  DWORD                   dwLoggingLevel
)
{
    TRACE("RasAcctConfigChangeNotification called");

    g_LoggingLevel = dwLoggingLevel;

    return( NO_ERROR );
}

//**
//
// Call:        RasAcctProviderInterimAccounting
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD APIENTRY
RasAcctProviderInterimAccounting(
    IN  RAS_AUTH_ATTRIBUTE *    pInAttributes,
    OUT PRAS_AUTH_ATTRIBUTE *   ppOutAttributes
)
{
    DWORD dwResultCode = NO_ERROR;

    TRACE("RasInterimAccounting called");

    return( IASSendReceiveAttributes( RAS_IAS_INTERIM_ACCOUNTING,
                                      pInAttributes,
                                      ppOutAttributes,
                                      &dwResultCode ) );
}

//**
//
// Call:        RasAuthConfigChangeNotification
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Reloads config information dynamically
//
DWORD APIENTRY
RasAuthConfigChangeNotification(
    IN  DWORD                   dwLoggingLevel
)
{
    TRACE("RasAuthConfigChangeNotification called");

    g_LoggingLevel = dwLoggingLevel;

    return( NO_ERROR );
}

//**
//
// Call:        MapIasRetCodeToRasError
//
// Description: Maps IAS_RETCODE to an error in raserror.h or mprerror.h
//
DWORD
MapIasRetCodeToRasError(
    IN  LONG    lFailureReason
)
{
    DWORD   dwError;

    switch ( lFailureReason )
    {
    case IAS_CHANGE_PASSWORD_FAILURE:
        dwError = ERROR_CHANGING_PASSWORD;
        break;
    
    case IAS_ACCOUNT_DISABLED:
        dwError = ERROR_ACCT_DISABLED;
        break;

    case IAS_ACCOUNT_EXPIRED:
        dwError = ERROR_ACCT_EXPIRED;
        break;

    case IAS_INVALID_LOGON_HOURS:
    case IAS_INVALID_DIALIN_HOURS:
        dwError = ERROR_DIALIN_HOURS_RESTRICTION;
        break;

    case IAS_DIALIN_DISABLED:
        dwError = ERROR_NO_DIALIN_PERMISSION;
        break;

    case IAS_SESSION_TIMEOUT:
        dwError = ERROR_AUTH_SERVER_TIMEOUT;
        break;

    case IAS_INVALID_PORT_TYPE:
        dwError = ERROR_ALLOWED_PORT_TYPE_RESTRICTION;
        break;

    case IAS_INVALID_AUTH_TYPE:
        dwError = ERROR_AUTH_PROTOCOL_RESTRICTION;
        break;

    default:
        dwError = ERROR_AUTHENTICATION_FAILURE;
        break;
    }

    return( dwError );
}

//**
//
// Call:        IASSendReceiveAttributes
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will send attributes to and receive attributes from IAS
//
DWORD
IASSendReceiveAttributes(
    IN  RAS_IAS_REQUEST_TYPE    RequestType,
    IN  RAS_AUTH_ATTRIBUTE *    pInAttributes,
    OUT PRAS_AUTH_ATTRIBUTE *   ppOutAttributes,
    OUT DWORD *                 lpdwResultCode
)
{
    DWORD                   dwIndex;
    HRESULT                 hResult;
    LONG                    IasResponse;
    LONG                    IasRequest;
    DWORD                   dwInAttributeCount      = 0;
    DWORD                   dwTotalInAttributeCount = 0;
    PIASATTRIBUTE *         ppInIasAttributes       = NULL;
    DWORD                   dwOutAttributeCount     = 0;
    PIASATTRIBUTE *         ppOutIasAttributes      = NULL;
    IAS_INET_ADDR           InetAddr                = 0;
    RAS_AUTH_ATTRIBUTE *    pNASIdentifier          = NULL;
    RAS_AUTH_ATTRIBUTE *    pCallingStationId       = NULL;
    DWORD                   dwLength;
    PVOID                   pValue;
    BOOL                    fConvertToAnsi;
    DWORD                   dwRetCode               = NO_ERROR;
    LPSTR                   lpsUserName             = g_aszUnauthenticatedUser;
    LONG                    lFailureReason;

    RasAuthAttributesPrint( g_dwTraceIdNt, TRACE_NTAUTH, pInAttributes );

    switch( RequestType )
    {
    case RAS_IAS_START_ACCOUNTING:
    case RAS_IAS_STOP_ACCOUNTING:
    case RAS_IAS_INTERIM_ACCOUNTING:
    case RAS_IAS_ACCOUNTING_ON:
    case RAS_IAS_ACCOUNTING_OFF:

        IasRequest = IAS_REQUEST_ACCOUNTING;
        break;

    case RAS_IAS_ACCESS_REQUEST:
        IasRequest = IAS_REQUEST_ACCESS_REQUEST;
        break;

    default:
        ASSERT( FALSE );
        return( ERROR_INVALID_PARAMETER );
    }

    *ppOutAttributes = NULL;
    *lpdwResultCode  = ERROR_AUTHENTICATION_FAILURE;

    hResult = CoInitializeEx( NULL, COINIT_MULTITHREADED );

    if ( FAILED( hResult ) )
    {
        return( HRESULT_CODE( hResult ) );
    }

    do
    {
        //
        // First findout how many attributes there are
        //

        for ( dwInAttributeCount = 0;
              pInAttributes[dwInAttributeCount].raaType != raatMinimum;
              dwInAttributeCount++);

        dwTotalInAttributeCount = dwInAttributeCount;

        if ( IasRequest == IAS_REQUEST_ACCOUNTING )
        {
            //
            // Add one more of the Acct-Status-Type attribute
            //

            dwTotalInAttributeCount++;
        }

        //
        // Add two more for Client-IP-Address and Client-Friendly-Name
        //

        dwTotalInAttributeCount += 2;

        //
        // Now allocate an array of pointer to attributes
        //

        ppInIasAttributes =
            (PIASATTRIBUTE *)
                MemAllocIas(sizeof(PIASATTRIBUTE) * dwTotalInAttributeCount);

        if ( ppInIasAttributes == NULL )
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;

            break;
        }

        ZeroMemory( ppInIasAttributes,
                    sizeof(PIASATTRIBUTE) * dwTotalInAttributeCount );

        //
        // Now allocate the attributes
        //

        hResult = AllocateAttributes( dwTotalInAttributeCount,
                                        ppInIasAttributes );

        if ( FAILED( hResult ) )
        {
            dwRetCode = HRESULT_CODE( hResult );

            break;
        }

        //
        // Convert to IAS attributes
        //

        for ( dwIndex = 0; dwIndex < dwInAttributeCount; dwIndex++ )
        {
            switch( pInAttributes[dwIndex].raaType )
            {
            case raatNASPort:
            case raatServiceType:
            case raatFramedProtocol:

                //
                // arap connection?  it's an access-request
                //

                if ((pInAttributes[dwIndex].raaType == raatFramedProtocol) &&
                    (pInAttributes[dwIndex].Value == (LPVOID)3))
                {
                    IasRequest = IAS_REQUEST_ACCESS_REQUEST;
                }

                //
                // fall through
                //

            case raatFramedRouting:
            case raatFramedMTU:
            case raatFramedCompression:
            case raatLoginIPHost:
            case raatLoginService:
            case raatLoginTCPPort:
            case raatFramedIPXNetwork:
            case raatSessionTimeout:
            case raatIdleTimeout:
            case raatTerminationAction:
            case raatFramedAppleTalkLink:
            case raatFramedAppleTalkNetwork:
            case raatNASPortType:
            case raatPortLimit:
            case raatTunnelType:
            case raatTunnelMediumType:
            case raatAcctStatusType:
            case raatAcctDelayTime:
            case raatAcctInputOctets:
            case raatAcctOutputOctets:
            case raatAcctAuthentic:
            case raatAcctSessionTime:
            case raatAcctInputPackets:
            case raatAcctOutputPackets:
            case raatAcctTerminateCause:
            case raatAcctLinkCount:
            case raatFramedIPNetmask:
            case raatPrompt:
            case raatPasswordRetry:
            case raatARAPZoneAccess:
            case raatARAPSecurity:
            case raatAcctEventTimeStamp:

                (ppInIasAttributes[dwIndex])->Value.itType = IASTYPE_INTEGER;
                (ppInIasAttributes[dwIndex])->Value.Integer =
                                    PtrToUlong(pInAttributes[dwIndex].Value);
                break;

            case raatNASIPAddress:

                InetAddr = PtrToUlong(pInAttributes[dwIndex].Value);

                //
                // Fall through
                //

            case raatFramedIPAddress:

                (ppInIasAttributes[dwIndex])->Value.itType = IASTYPE_INET_ADDR;
                (ppInIasAttributes[dwIndex])->Value.InetAddr =
                                    PtrToUlong(pInAttributes[dwIndex].Value);

                break;

            case raatUserPassword:
            case raatMD5CHAPPassword:
            case raatARAPPassword:
            case raatEAPMessage:


                //
                // If any passwords are present then we want authentication
                // as well.
                //

                IasRequest = IAS_REQUEST_ACCESS_REQUEST;

                //
                // Fall thru
                //

            case raatVendorSpecific:

                //
                // Is this the MS-CHAP password ?
                //

                if ( ( pInAttributes[dwIndex].raaType == raatVendorSpecific ) &&
                     ( pInAttributes[dwIndex].dwLength >= 8 ) )
                {
                    //
                    // Does the Vendor Id match Microsoft's ?
                    //

                    if ( WireToHostFormat32(
                            (PBYTE)(pInAttributes[dwIndex].Value)) == 311 )
                    {
                        //
                        // Does the vendor type match MS-CHAP password's,
                        // change pasword V1 or V2 ?
                        //

                        switch( *(((PBYTE)(pInAttributes[dwIndex].Value))+4) )
                        {
                            //
                            // is this is an MS-CHAP password?
                            //
                        case 1:
                        case 3:
                        case 4:


                            //
                            // is this is an ARAP password?
                            //
                        case raatARAPOldPassword:
                        case raatARAPNewPassword:

                            IasRequest = IAS_REQUEST_ACCESS_REQUEST;

                            break;

                        default:
                            break;
                        }
                    }
                }

                //
                // Fall thru
                //

            default:

                if ( pInAttributes[dwIndex].raaType == raatUserName )
                {
                    //
                    // Save pointer for logging purposes
                    //
    
                    lpsUserName = (PBYTE)(pInAttributes[dwIndex].Value);
                }

                {
                    DWORD dwLength = pInAttributes[dwIndex].dwLength;
                    PBYTE pValue   = (PBYTE)MemAllocIas( dwLength );

                    if ( pValue == NULL )
                    {
                        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }

                    if ( raatNASIdentifier == pInAttributes[dwIndex].raaType )
                    {
                        pNASIdentifier = pInAttributes + dwIndex;
                    }

                    if ( raatCallingStationId == pInAttributes[dwIndex].raaType )
                    {
                        pCallingStationId = pInAttributes + dwIndex;
                    }

                    (ppInIasAttributes[dwIndex])->Value.itType =
                                                           IASTYPE_OCTET_STRING;

                    (ppInIasAttributes[dwIndex])->Value.OctetString.dwLength =
                                                            dwLength;

                    (ppInIasAttributes[dwIndex])->Value.OctetString.lpValue =
                                                            pValue;

                    CopyMemory( pValue,
                                (PBYTE)(pInAttributes[dwIndex].Value),
                                dwLength );

                    break;
                }
            }

            if ( dwRetCode != NO_ERROR )
            {
                break;
            }

            //
            // Set the attribute Id
            //

            (ppInIasAttributes[dwIndex])->dwId = pInAttributes[dwIndex].raaType;

            TRACE1( "Inserting attribute type %d",
                     pInAttributes[dwIndex].raaType );
        }

        if ( dwRetCode != NO_ERROR )
        {
            break;
        }

        //
        // If accounting type of request then we need to add the
        // Acct-Status-Type attribute
        //

        if ( IasRequest == IAS_REQUEST_ACCOUNTING )
        {
            (ppInIasAttributes[dwIndex])->dwId         = raatAcctStatusType;
            (ppInIasAttributes[dwIndex])->Value.itType = IASTYPE_INTEGER;

            switch ( RequestType )
            {
            case RAS_IAS_START_ACCOUNTING:

                (ppInIasAttributes[dwIndex])->Value.Integer = (DWORD)1;
                break;

            case RAS_IAS_STOP_ACCOUNTING:

                (ppInIasAttributes[dwIndex])->Value.Integer = (DWORD)2;
                break;

            case RAS_IAS_INTERIM_ACCOUNTING:

                (ppInIasAttributes[dwIndex])->Value.Integer = (DWORD)3;
                break;

            case RAS_IAS_ACCOUNTING_ON:

                (ppInIasAttributes[dwIndex])->Value.Integer = (DWORD)7;
                break;

            case RAS_IAS_ACCOUNTING_OFF:

                (ppInIasAttributes[dwIndex])->Value.Integer = (DWORD)8;
                break;
            }

            dwIndex++;
        }

        //
        // Insert Client-IP-Address and Client-Friendly-Name
        //

        if ( 0 != InetAddr )
        {
            (ppInIasAttributes[dwIndex])->dwId = 4108; // Client-IP-Address
            (ppInIasAttributes[dwIndex])->Value.itType = IASTYPE_INET_ADDR;
            (ppInIasAttributes[dwIndex])->Value.InetAddr = InetAddr;
            dwIndex++;

            TRACE( "Inserting attribute type 4108" );
        }

        if ( NULL != pNASIdentifier )
        {
            DWORD dwLength = pNASIdentifier->dwLength;
            PBYTE pValue   = (PBYTE)MemAllocIas( dwLength );

            if ( pValue == NULL )
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            (ppInIasAttributes[dwIndex])->dwId = 4128; // Client-Friendly-Name

            (ppInIasAttributes[dwIndex])->Value.itType =
                                                    IASTYPE_OCTET_STRING;

            (ppInIasAttributes[dwIndex])->Value.OctetString.dwLength =
                                                    dwLength;

            (ppInIasAttributes[dwIndex])->Value.OctetString.lpValue =
                                                    pValue;

            CopyMemory( pValue,
                        (PBYTE)(pNASIdentifier->Value),
                        dwLength );

            dwIndex++;

            TRACE( "Inserting attribute type 4128" );
        }

        //
        //  process the filled attributes
        //

        hResult = DoRequest(
                            dwTotalInAttributeCount,
                            ppInIasAttributes,
                            &dwOutAttributeCount,
                            &ppOutIasAttributes,
                            IasRequest,
                            &IasResponse,
                            IAS_PROTOCOL_RAS,
                            &lFailureReason,
                            TRUE );

        if ( FAILED( hResult ) )
        {
            dwRetCode = HRESULT_CODE( hResult );

            TRACE1( "IAS->DoRequest failed with %d", dwRetCode );

            break;
        }

        switch( IasResponse )
        {
        case IAS_RESPONSE_ACCESS_ACCEPT:

            TRACE( "IASResponse = ACCESS_ACCEPT");

            *lpdwResultCode = NO_ERROR;

            break;

        case IAS_RESPONSE_ACCESS_CHALLENGE:

            TRACE( "IASResponse = ACCESS_CHALLENGE");

            *lpdwResultCode = NO_ERROR;

            break;

        case IAS_RESPONSE_DISCARD_PACKET:

            TRACE( "IASResponse = DISCARD_PACKET");

            *lpdwResultCode = ERROR_AUTH_SERVER_TIMEOUT;

            dwRetCode = ERROR_AUTH_SERVER_TIMEOUT;

            break;

        case IAS_RESPONSE_ACCESS_REJECT:

            {
                WCHAR  *lpwsSubStringArray[3];
                WCHAR  wchInsertionString[13];
                WCHAR  wchUserName[UNLEN+1];
                WCHAR  wchCallerId[100];

                MultiByteToWideChar( CP_ACP,
                                     0,
                                     lpsUserName,
                                     -1,
                                     wchUserName,
                                     UNLEN+1 );

                wsprintfW( wchInsertionString, L"%%%%%lu", lFailureReason + 0x1000 );


                if ( pCallingStationId != NULL )
                {
                    lpwsSubStringArray[0] = wchUserName;
                    lpwsSubStringArray[1] = wchCallerId;
                    lpwsSubStringArray[2] = wchInsertionString;

                    MultiByteToWideChar( CP_ACP,
                                         0,
                                         (PBYTE)(pCallingStationId->Value),
                                         -1,
                                         wchCallerId,
                                         100 );

                    NtAuthLogWarning( ROUTERLOG_NTAUTH_FAILURE_EX, 3, lpwsSubStringArray);
                }
                else
                {
                    lpwsSubStringArray[0] = wchUserName;
                    lpwsSubStringArray[1] = wchInsertionString;

                    NtAuthLogWarning( ROUTERLOG_NTAUTH_FAILURE, 2, lpwsSubStringArray );
                }

                *lpdwResultCode = MapIasRetCodeToRasError( lFailureReason );
            }

        default:

            TRACE2( "IASResponse = %d, FailureReason = 0x%x",
                     IasResponse, lFailureReason );

            break;
        }

        if ( dwRetCode != NO_ERROR )
        {
            break;
        }

        if ( dwOutAttributeCount > 0 )
        {
            //
            // Convert from IAS attributes
            //

            *ppOutAttributes = RasAuthAttributeCreate( dwOutAttributeCount );

            if ( *ppOutAttributes == NULL )
            {
                dwRetCode = GetLastError();

                break;
            }

            for ( dwIndex = 0; dwIndex < dwOutAttributeCount; dwIndex++ )
            {
                IASVALUE IasValue = (ppOutIasAttributes[dwIndex])->Value;

                fConvertToAnsi = FALSE;

                switch ( IasValue.itType )
                {
                case IASTYPE_INTEGER:

                    dwLength = sizeof( DWORD );
                    pValue = (LPVOID) ULongToPtr(IasValue.Integer);
                    break;

                case IASTYPE_BOOLEAN:

                    dwLength = sizeof( DWORD );
                    pValue = (LPVOID)ULongToPtr(IasValue.Boolean);
                    break;

                case IASTYPE_ENUM:

                    dwLength = sizeof( DWORD );
                    pValue = (LPVOID)ULongToPtr(IasValue.Enumerator);
                    break;

                case IASTYPE_INET_ADDR:

                    dwLength = sizeof( DWORD );
                    pValue = (LPVOID)ULongToPtr(IasValue.InetAddr);
                    break;

                case IASTYPE_STRING:

                    if ( NULL != IasValue.String.pszAnsi )
                    {
                        dwLength = strlen( IasValue.String.pszAnsi );
                        pValue = (LPVOID)( IasValue.String.pszAnsi );
                    }
                    else if ( NULL != IasValue.String.pszWide )
                    {
                        dwLength = wcslen( IasValue.String.pszWide );
                        pValue = (LPVOID)( IasValue.String.pszWide );
                        fConvertToAnsi = TRUE;
                    }
                    else
                    {
                        continue;
                    }

                    break;

                case IASTYPE_OCTET_STRING:

                    dwLength = IasValue.OctetString.dwLength;
                    pValue = IasValue.OctetString.lpValue;
                    break;

                default:

                    continue;
                }

                dwRetCode =
                    RasAuthAttributeInsert(
                        dwIndex,
                        *ppOutAttributes,
                        (ppOutIasAttributes[dwIndex])->dwId,
                        fConvertToAnsi,
                        dwLength,
                        pValue );

                if ( dwRetCode != NO_ERROR )
                {
                    break;
                }

                TRACE1( "Received attribute %d",
                         (ppOutIasAttributes[dwIndex])->dwId );
            }

            RasAuthAttributesPrint( g_dwTraceIdNt, TRACE_NTAUTH,
                *ppOutAttributes );
        }

    } while( FALSE );

    //
    //  Free all the IAS attributes allocated earlier
    //

    if ( ppInIasAttributes != NULL )
    {
        FreeAttributes( dwTotalInAttributeCount, ppInIasAttributes );

        MemFreeIas( ppInIasAttributes );
    }

    if ( ppOutIasAttributes != NULL )
    {
        FreeAttributes( dwOutAttributeCount, ppOutIasAttributes );

        MemFreeIas( ppOutIasAttributes );
    }

    if ( dwRetCode != NO_ERROR )
    {
        if ( *ppOutAttributes != NULL )
        {
            RasAuthAttributeDestroy( *ppOutAttributes );

            *ppOutAttributes = NULL;
        }
    }

    CoUninitialize();

    return( dwRetCode );
}

//**
//
// Call:        RasAuthProviderAuthenticateUser
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
//
DWORD APIENTRY
RasAuthProviderAuthenticateUser(
    IN  RAS_AUTH_ATTRIBUTE *    pInAttributes,
    OUT PRAS_AUTH_ATTRIBUTE *   ppOutAttributes,
    OUT DWORD *                 lpdwResultCode
)
{
    *ppOutAttributes = NULL;
    *lpdwResultCode  = NO_ERROR;

    TRACE("RasAuthProviderAuthenticateUser called");

    return( IASSendReceiveAttributes( RAS_IAS_ACCESS_REQUEST,
                                      pInAttributes,
                                      ppOutAttributes,
                                      lpdwResultCode ) );
}

//**
//
// Call:        RasAuthProviderFreeAttributes
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD APIENTRY
RasAuthProviderFreeAttributes(
    IN  RAS_AUTH_ATTRIBUTE * pAttributes
)
{
    RasAuthAttributeDestroy( pAttributes );

    return( NO_ERROR );
}

//**
//
// Call:        RasAcctProviderFreeAttributes
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD APIENTRY
RasAcctProviderFreeAttributes(
    IN  RAS_AUTH_ATTRIBUTE * pAttributes
)
{
    RasAuthAttributeDestroy( pAttributes );

    return( NO_ERROR );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\auth\radius\lsa.h ===
#ifndef LSA_H
#define LSA_H

DWORD StorePrivateData(TCHAR *pszServerName, TCHAR *pszSecret);
DWORD RetrievePrivateData(TCHAR *pszServerName, TCHAR *pszSecret);

#endif // LSA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\auth\radius\md5.h ===
/****************************************************************************************
 * NAME:        MD5.H
 * MODULE:      RADSRV
 * AUTHOR:      Don Dumitru
 *
 * HISTORY
 *      02/15/95  DONDU      Created
 *
 * OVERVIEW
 *
 * Header file for MD5 hashing routines.
 *
 *
 * Copyright 1995, Microsoft Corporation
 *
 ****************************************************************************************/


#ifndef _MD5_INC
#define _MD5_INC


typedef struct MD5Context
	{
	unsigned long hash[4];
	unsigned long Bytes[2];
	unsigned long input[16];
	} MD5Context, *PMD5Context;

typedef struct MD5Digest
	{
	unsigned char digest[16];
	} MD5Digest,  *PMD5Digest;


void 
MD5Init(
    struct MD5Context UNALIGNED *context
);

void 
MD5Update(
    struct MD5Context UNALIGNED *context, 
    unsigned char const UNALIGNED *buf, 
    unsigned len
);

void 
MD5Final( struct MD5Digest UNALIGNED *digest, 
          struct MD5Context UNALIGNED *context
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\auth\radius\perfmon.h ===
#ifndef PERFMON_H
#define PERFMON_H

#define	RADIUS_CLIENT_COUNTER_OBJECT				0
// ADD
#define AUTHREQSENT									2
#define AUTHREQFAILED								4
#define AUTHREQSUCCEDED								6
#define AUTHREQTIMEOUT								8
#define ACCTREQSENT									10
#define ACCTBADPACK									12
#define ACCTREQSUCCEDED								14
#define ACCTREQTIMEOUT								16
#define AUTHBADPACK									18

extern LONG							g_cAuthReqSent;			// Auth Requests Sent
extern LONG							g_cAuthReqFailed;		// Auth Requests Failed
extern LONG							g_cAuthReqSucceded;		// Auth Requests Succeded
extern LONG							g_cAuthReqTimeout;		// Auth Requests timeouts
extern LONG							g_cAcctReqSent;			// Acct Requests Sent
extern LONG							g_cAcctBadPack;			// Acct Bad Packets
extern LONG							g_cAcctReqSucceded;		// Acct Requests Succeded
extern LONG							g_cAcctReqTimeout;		// Acct Requests timeouts
extern LONG							g_cAuthBadPack;			// Auth bad Packets

#endif // PERFMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\auth\radius\packconv.c ===
/********************************************************************/
/**          Copyright(c) 1985-1998 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    packconv.c
//
// Description: 
//
// History:     Feb 11,1998	    NarenG		Created original version.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <raserror.h>
#include <time.h>
#include <string.h>
#include <rasauth.h>
#include <stdlib.h>
#include <stdio.h>
#include <rtutils.h>
#include <mprlog.h>
#include <mprerror.h>
#define INCL_RASAUTHATTRIBUTES
#define INCL_HOSTWIRE
#include <ppputil.h>
#include "radclnt.h"
#include "hmacmd5.h"
#include "md5.h"
#include "radclnt.h"

//**
//
// Call:        Router2Radius
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Converts attribute array from RAS_AUTH_ATTRIBUTE to 
//              RADIUS_ATTRIBUTE
//              INPUT: 
//		            prgRouter	    - array of attributes passed in from 
//                                    the application
//		            pRadiusServer   - RADIUS server 
//                                    descriptor(ip address, secret)
//		            pHeader			- RADIUS packet header
//		            bSubCode		- accounting sub codes.
//              OUTPUT:
//		            prgRadius		- array of attribtes that will be sent 
//                                    to the RADIUS server.
//                  pAttrLength     - Length of the Radius packet.
//      
DWORD 
Router2Radius(
    IN  RAS_AUTH_ATTRIBUTE              * prgRouter, 
    OUT RADIUS_ATTRIBUTE UNALIGNED      * prgRadius, 
    IN  RADIUSSERVER UNALIGNED          * pRadiusServer, 
    IN  RADIUS_PACKETHEADER UNALIGNED   * pHeader, 
    IN  BYTE                              bSubCode,
    IN  DWORD                             dwRetryCount,
    OUT PBYTE *                           ppSignature,
    OUT DWORD *                           pAttrLength
)
{
    DWORD dwError     = NO_ERROR;
    BOOL  fEAPMessage = FALSE;

	*pAttrLength = 0;
    *ppSignature = NULL;

    do
    {
        //
	    // add the attribute for accounting records
        //

		switch( bSubCode )
	    {
	    case atStart:
		case atStop:
		case atAccountingOn:
		case atAccountingOff:
        case atInterimUpdate:

            //
            // Add the accounting status type attribute
            //

            prgRadius->bType   = ptAcctStatusType;
		    prgRadius->bLength = sizeof(RADIUS_ATTRIBUTE) + sizeof(DWORD);
			(*pAttrLength)    += prgRadius->bLength;
				
		    prgRadius++;

			*((DWORD UNALIGNED *) prgRadius) = htonl(bSubCode);
		    prgRadius = (RADIUS_ATTRIBUTE *)(((PBYTE) prgRadius)+sizeof(DWORD));

            //
            // Add the accounting delay time attribute
            //

            prgRadius->bType   = raatAcctDelayTime;
            prgRadius->bLength = sizeof(RADIUS_ATTRIBUTE) + sizeof(DWORD);
            (*pAttrLength)    += prgRadius->bLength;

            prgRadius++;

            HostToWireFormat32( dwRetryCount *  pRadiusServer->Timeout.tv_sec,
                                (LPBYTE)(prgRadius) );
                                               
            prgRadius = (RADIUS_ATTRIBUTE *)(((PBYTE) prgRadius)+sizeof(DWORD));

	        break;

	    default:

		    break;
	    }

		while( prgRouter->raaType != raatMinimum )
	    {
            //
			// Copy attribute type & length
            //

			prgRadius->bType   = (BYTE)(prgRouter->raaType);
			prgRadius->bLength = (BYTE)(prgRouter->dwLength);
			
			switch( prgRouter->raaType )
		    {
			case raatUserPassword:

		        (*pAttrLength) += EncryptPassword( prgRouter, 
                                                   prgRadius,   
                                                   pRadiusServer,   
                                                   pHeader,     
                                                   bSubCode);
			    break;

	        case raatUserName:
            case raatMD5CHAPPassword:
            case raatFilterId:
            case raatReplyMessage:
            case raatCallbackNumber:
            case raatCallbackId:
            case raatFramedRoute:
            case raatState:
            case raatClass:
            case raatVendorSpecific:
            case raatCalledStationId:
            case raatCallingStationId:
            case raatNASIdentifier:
            case raatProxyState:
            case raatLoginLATService:
            case raatLoginLATNode:
            case raatLoginLATGroup:
            case raatFramedAppleTalkZone:
            case raatAcctSessionId:
            case raatAcctMultiSessionId:
            case raatMD5CHAPChallenge:
            case raatLoginLATPort:
            case raatTunnelClientEndpoint:
            case raatTunnelServerEndpoint:
            case raatARAPPassword:
            case raatARAPFeatures:
            case raatARAPSecurityData:
            case raatConnectInfo:
            case raatConfigurationToken:
            case raatSignature:
			case raatCertificateOID:

                CopyMemory( prgRadius+1,
                            (PBYTE)prgRouter->Value,
                            prgRadius->bLength);

                prgRadius->bLength += sizeof(RADIUS_ATTRIBUTE);

                (*pAttrLength) += prgRadius->bLength;

                break;

            case raatEAPMessage:

                {
                    DWORD dwLength          = prgRouter->dwLength;
                    PBYTE pRouterEapMessage = (PBYTE)(prgRouter->Value);

                    while( dwLength > 0 )
                    {
                        if ( dwLength > 253 )
                        {
                            CopyMemory( (PBYTE)(prgRadius+1),
                                        pRouterEapMessage, 
                                        253 );

		                    prgRadius->bLength = 253;
                            pRouterEapMessage += 253;

                            dwLength   -= 253;
                        }
                        else
                        {
                            CopyMemory( prgRadius+1, 
                                        (PBYTE)pRouterEapMessage,
                                        dwLength );

		                    prgRadius->bLength  = (BYTE)dwLength;
                            dwLength            = 0;
                        }

			            prgRadius->bType   = (BYTE)raatEAPMessage;
		                prgRadius->bLength += sizeof(RADIUS_ATTRIBUTE);

                        (*pAttrLength) += prgRadius->bLength;

                        if ( dwLength > 0 ) 
                        {
                            prgRadius = (PRADIUS_ATTRIBUTE) 
                                      ((PBYTE) prgRadius + prgRadius->bLength);
                        }
                    }
                }

                fEAPMessage = TRUE;
                
			    break;

            case raatNASPort:
            case raatServiceType:
            case raatFramedProtocol:
            case raatFramedRouting:
            case raatFramedMTU:
            case raatFramedCompression:
            case raatLoginIPHost:
            case raatLoginService:
            case raatLoginTCPPort:
            case raatFramedIPXNetwork:
            case raatSessionTimeout:
            case raatIdleTimeout:
            case raatTerminationAction:
            case raatFramedAppleTalkLink:
            case raatFramedAppleTalkNetwork:
            case raatNASPortType:
            case raatPortLimit:
            case raatTunnelType:
            case raatTunnelMediumType:
            case raatAcctStatusType:
            case raatAcctDelayTime:
            case raatAcctInputOctets:
            case raatAcctOutputOctets:
            case raatAcctAuthentic:
            case raatAcctSessionTime:
            case raatAcctInputPackets:
            case raatAcctOutputPackets:
            case raatAcctTerminateCause:
            case raatAcctLinkCount:
            case raatFramedIPAddress:
            case raatFramedIPNetmask:
            case raatPrompt:
            case raatPasswordRetry:
            case raatARAPZoneAccess:
            case raatARAPSecurity:
            case raatAcctInterimInterval:
            case raatAcctEventTimeStamp:

                switch( prgRouter->dwLength )
                {
                case 1:
			        *((LPBYTE)(prgRadius+1)) = (BYTE)prgRouter->Value;
                    break;

                case 2:
                    HostToWireFormat16U( (WORD)prgRouter->Value, 
                                          (LPBYTE)(prgRadius+1) );
                    break;

                case 4:
                    HostToWireFormat32( PtrToUlong(prgRouter->Value), 
                                        (LPBYTE)(prgRadius+1) );
                    break;

                default:
                    break;
                }

		        prgRadius->bLength += sizeof(RADIUS_ATTRIBUTE);

			    (*pAttrLength) += prgRadius->bLength;

                break;

            case raatNASIPAddress:

                RTASSERT( 4 == prgRouter->dwLength );

                if ( pRadiusServer->nboNASIPAddress != INADDR_NONE )
                {
                    CopyMemory( (LPBYTE)(prgRadius+1),
                                (LPBYTE)&(pRadiusServer->nboNASIPAddress),
                                4 );
                }
                else
                {
                    HostToWireFormat32( PtrToUlong(prgRouter->Value), 
                                        (LPBYTE)(prgRadius+1) );
                }

		        prgRadius->bLength += sizeof(RADIUS_ATTRIBUTE);

			    (*pAttrLength) += prgRadius->bLength;

                break;
            }

			prgRadius = (PRADIUS_ATTRIBUTE) 
                                ((PBYTE) prgRadius + prgRadius->bLength);
			prgRouter++;
	    }

    }while( FALSE );

    if ( dwError != NO_ERROR )
    {
        (*pAttrLength) = 0;
    }
    else
    {
        if ( ( ( bSubCode == atInvalid ) 
                    ? pRadiusServer->fSendSignature 
                    : FALSE ) || ( fEAPMessage ) )
        {
            //
            // Add a signature attribute as well. Zero this out for now.
            //

            *ppSignature = (BYTE *)prgRadius;

            prgRadius->bType   = (BYTE)raatSignature;
            prgRadius->bLength = (BYTE)18;

            ZeroMemory( prgRadius+1, 16 );

            (*pAttrLength) += prgRadius->bLength;
        }
    }
		
	return( dwError );
} 

//**
//
// Call:        Radius2Router
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Converts RADIUS attribute array to RAS_AUTH_ATTRIBUTE array
//
DWORD 
Radius2Router(
	IN	RADIUS_PACKETHEADER	UNALIGNED * pRecvHeader,
    IN  RADIUSSERVER UNALIGNED *        pRadiusServer, 
    IN  PBYTE                           pRequestAuthenticator,
    IN  DWORD                           dwNumAttributes,
    OUT DWORD *                         pdwExtError,
    OUT PRAS_AUTH_ATTRIBUTE *           pprgRouter,
    OUT BOOL *                          fEapMessageReceived
)
{
    LONG                            cbLength;
    DWORD                           dwRetCode       = NO_ERROR;
    BOOL                            fEAPMessage     = FALSE;
    BOOL                            fSignature      = FALSE;
	PBYTE							pEAPMessage	    = NULL;
	DWORD							cbEAPMessage    = 0;	
    RADIUS_ATTRIBUTE UNALIGNED *    prgRadius 
                                        = (PRADIUS_ATTRIBUTE)(pRecvHeader + 1);
    *pdwExtError         = 0;
    *pprgRouter          = NULL;
    *fEapMessageReceived = FALSE;

	*pprgRouter = RasAuthAttributeCreate( dwNumAttributes );
    
    if ( *pprgRouter == NULL )
    {
        return( GetLastError() );
    }

	dwNumAttributes = 0;

    cbLength = ntohs( pRecvHeader->wLength ) - sizeof(RADIUS_PACKETHEADER);
   
    while( cbLength > 0 )
	{
        switch( (RAS_AUTH_ATTRIBUTE_TYPE)prgRadius->bType )
        {
        case raatNASPort:
        case raatServiceType:
        case raatFramedProtocol:
        case raatFramedRouting:
        case raatFramedMTU:
        case raatFramedCompression:
        case raatLoginIPHost:
        case raatLoginService:
        case raatLoginTCPPort:
        case raatFramedIPXNetwork:
        case raatSessionTimeout:
        case raatIdleTimeout:
        case raatTerminationAction:
        case raatFramedAppleTalkLink:
        case raatFramedAppleTalkNetwork:
        case raatNASPortType:
        case raatPortLimit:
        case raatTunnelType:
        case raatTunnelMediumType:
        case raatAcctStatusType:
        case raatAcctDelayTime:
        case raatAcctInputOctets:
        case raatAcctOutputOctets:
        case raatAcctAuthentic:
        case raatAcctSessionTime:
        case raatAcctInputPackets:
        case raatAcctOutputPackets:
        case raatAcctTerminateCause:
        case raatAcctLinkCount:
        case raatFramedIPAddress:
        case raatFramedIPNetmask:
        case raatNASIPAddress:
        case raatPrompt:
        case raatPasswordRetry:
        case raatARAPZoneAccess:
        case raatARAPSecurity:
        case raatAcctInterimInterval: 
        case raatAcctEventTimeStamp:

            {
                DWORD dwIntegralValue;
                DWORD dwLength = prgRadius->bLength - sizeof(RADIUS_ATTRIBUTE);

                if ( dwLength == 1 )
                {
                    dwIntegralValue = (DWORD)(*(LPBYTE)(prgRadius+1));
                }
                else if ( dwLength == 2 )
                {
                    dwIntegralValue=(DWORD)WireToHostFormat16U( 
                                                    (PBYTE)(prgRadius+1));
                }
                else if ( dwLength == 4 )
                {
                    dwIntegralValue=(DWORD)WireToHostFormat32(
                                                    (PBYTE)(prgRadius+1));
                }
                else
                {
                    //
                    // Drop bad attribute
                    //

                    break;
                }

                dwRetCode = RasAuthAttributeInsert( 
                                dwNumAttributes++,
                                *pprgRouter,
                                (RAS_AUTH_ATTRIBUTE_TYPE)prgRadius->bType,
                                FALSE,
                                prgRadius->bLength-sizeof(RADIUS_ATTRIBUTE),
                                (LPVOID)ULongToPtr(dwIntegralValue) );

            }

            break;

        case raatSignature:

            //
            // Check the signature
            //

            {
	            MD5Digest      	    MD5d;
                HmacContext         HmacMD5c;
                BYTE                Signature[16];

                HmacMD5Init( &HmacMD5c,
                             (PBYTE)(pRadiusServer->szSecret),
                             pRadiusServer->cbSecret);

                //
                // Zero out the signature attribute before calculating it
                // 

                if ( prgRadius->bLength != 18 ) 
                {
                    RADIUS_TRACE("Received invalid signature length in packet");

                    *pdwExtError = ERROR_INVALID_SIGNATURE_LENGTH;

                    dwRetCode = ERROR_INVALID_RADIUS_RESPONSE;

                    break;
                }

                CopyMemory( Signature, (prgRadius+1), 16 );

                ZeroMemory( (PBYTE)(prgRadius+1), 16 );

                CopyMemory( (PBYTE)(pRecvHeader->rgAuthenticator),
                            pRequestAuthenticator,
                            16 );

                HmacMD5Update( &HmacMD5c,
                               (PBYTE)pRecvHeader,
                               ntohs(pRecvHeader->wLength) );

                HmacMD5Final( &MD5d, &HmacMD5c );

			    if ( memcmp( Signature, MD5d.digest, 16 ) != 0 )
                {
                    RADIUS_TRACE("Received invalid signature in packet");

                    *pdwExtError = ERROR_INVALID_SIGNATURE;

                    dwRetCode = ERROR_INVALID_RADIUS_RESPONSE;

                    break;
                }

                fSignature = TRUE;
            }

            //
            // Fall thru
            //

        case raatUserName:
        case raatUserPassword:
        case raatMD5CHAPPassword:
        case raatFilterId:
        case raatReplyMessage:
        case raatCallbackNumber:
        case raatCallbackId:
        case raatFramedRoute:
        case raatState:
        case raatClass:
        case raatCalledStationId:
        case raatCallingStationId:
        case raatNASIdentifier:
        case raatProxyState:
        case raatLoginLATService:
        case raatLoginLATNode:
        case raatLoginLATGroup:
        case raatFramedAppleTalkZone:
        case raatAcctSessionId:
        case raatAcctMultiSessionId:
        case raatMD5CHAPChallenge:
        case raatLoginLATPort:
        case raatTunnelClientEndpoint:
        case raatTunnelServerEndpoint:
        case raatARAPPassword:
        case raatARAPFeatures:
        case raatARAPSecurityData:
        case raatConnectInfo:
        case raatConfigurationToken:
        case raatARAPChallengeResponse:
		case raatCertificateOID:

			dwRetCode = RasAuthAttributeInsert( 
                                dwNumAttributes++,
                                *pprgRouter,
                                (RAS_AUTH_ATTRIBUTE_TYPE)prgRadius->bType,
                                FALSE,
                                prgRadius->bLength-sizeof(RADIUS_ATTRIBUTE),
                                (LPVOID)(prgRadius+1) );
			break;
        
        case raatVendorSpecific:

            if ( WireToHostFormat32( (PBYTE)(prgRadius+1) ) == 311 )
            {
                BYTE  abTemp[34];
                PBYTE pVSAWalker  = (PBYTE)(prgRadius+1)+4;
                DWORD cbVSALength = prgRadius->bLength - 
                                        sizeof( RADIUS_ATTRIBUTE ) - 4;
                
                while( cbVSALength > 1 )
                {
                    if ( *pVSAWalker == 12 )
                    {
                        if ( *(pVSAWalker+1) != 34 )
                        {
                            RADIUS_TRACE("Recvd invalid MPPE key packet");
                        }
                        else
                        {
                            //
                            // We don't want to modify whatever data we got 
                            // from RADIUS (to keep the signature valid).
                            //

                            CopyMemory( abTemp, pVSAWalker, 34 );

                            //
                            // Decrypt the MPPE session keys.
                            //
        
                            dwRetCode = DecryptMPPEKeys( pRadiusServer, 
                                                         pRequestAuthenticator,
                                                         abTemp+2 );

                            if ( dwRetCode != NO_ERROR )
                            {
                                break;
                            }

        			        dwRetCode = RasAuthAttributeInsertVSA( 
                                                        dwNumAttributes++,
                                                        *pprgRouter,
                                                        311,
                                                        *(pVSAWalker+1),
                                                        abTemp );
                        }
                    }
                    else if (   ( *pVSAWalker == 16 )
                             || ( *pVSAWalker == 17 ) )
                    {
                        DWORD dwLength;
                        BYTE* pbTemp;

                        dwLength = *(pVSAWalker+1);

                        if (   ( dwLength <= 4 )
                            || ( ( dwLength - 4 ) % 16 != 0 ) )
                        {
                            RADIUS_TRACE("Recvd invalid MPPE key packet");
                        }
                        else
                        {
                            pbTemp = LocalAlloc( LPTR, dwLength );

                            if ( NULL == pbTemp )
                            {
                                dwRetCode = GetLastError();
                                RADIUS_TRACE("Out of memory");
                                break;
                            }

                            //
                            // We don't want to modify whatever data we got 
                            // from RADIUS (to keep the signature valid).
                            //

                            CopyMemory( pbTemp, pVSAWalker, dwLength );

                            //
                            // Decrypt the MPPE Send/Recv keys.
                            //
        
                            dwRetCode = DecryptMPPESendRecvKeys(
                                                        pRadiusServer, 
                                                        pRequestAuthenticator,
                                                        dwLength,
                                                        pbTemp+2 );

                            if ( dwRetCode != NO_ERROR )
                            {
                                LocalFree( pbTemp );
                                break;
                            }

                            dwRetCode = RasAuthAttributeInsertVSA( 
                                                        dwNumAttributes++,
                                                        *pprgRouter,
                                                        311,
                                                        *(pVSAWalker+1),
                                                        pbTemp );

                            LocalFree( pbTemp );
                        }
                    }
                    else
                    {
    			        dwRetCode = RasAuthAttributeInsertVSA( 
                                                    dwNumAttributes++,
                                                    *pprgRouter,
                                                    311,
                                                    *(pVSAWalker+1),
                                                    pVSAWalker );
                    }

                    if ( dwRetCode != NO_ERROR )
                    {
                        break;  
                    }

                    cbVSALength -= *(pVSAWalker+1);
                    pVSAWalker += *(pVSAWalker+1);
                }
            }

            break;

		case raatEAPMessage:

			fEAPMessage = TRUE;

			{
                if ( pEAPMessage == NULL )
                {
                    //
                    // Nothing has been allocated for EAP yet.
                    //

                    pEAPMessage = (PBYTE)LocalAlloc( 
                                            LPTR, 
                                            prgRadius->bLength
                                            - sizeof( RADIUS_ATTRIBUTE ) );
    
                }
                else
                {
                    //  
                    // Need to increase the size of the buffer to hold this
                    // message
                    //

	                PBYTE pReallocEAPMessage = 
                                    (PBYTE)LocalReAlloc( 
                                            pEAPMessage,
				                            cbEAPMessage 
                                            + prgRadius->bLength 
                                            - sizeof( RADIUS_ATTRIBUTE ),
                                            LMEM_MOVEABLE );

                    if ( pReallocEAPMessage == NULL )
                    {
                        LocalFree( pEAPMessage );

                        pEAPMessage = NULL;
                    }
                    else
                    {
                        pEAPMessage = pReallocEAPMessage;
                    }
                }

                if ( pEAPMessage == NULL )
                {
                    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                
                    break;
                }

                //
				// Copy existing buffer to new buffer
                //

		        CopyMemory( pEAPMessage+cbEAPMessage, 
                            (PBYTE)(prgRadius+1),
                            prgRadius->bLength - sizeof(RADIUS_ATTRIBUTE) );

                //
				// Increment the cbEAPMessage so that the size is updated 
                // properly
                //

				cbEAPMessage += (prgRadius->bLength - sizeof(RADIUS_ATTRIBUTE));
			}

            break;
    
        default:
        
            //
            // Drop attributes we do not know about.
            //
	
            break;
        }

        if ( dwRetCode != NO_ERROR )
        {
	        RasAuthAttributeDestroy( *pprgRouter );

	        *pprgRouter = NULL;

			if ( pEAPMessage != NULL )
            {
				LocalFree( pEAPMessage );
            }
            
			return( dwRetCode );
        }
    
        RADIUS_TRACE1( "Returning attribute type %d", prgRadius->bType );

        cbLength -= prgRadius->bLength;

        prgRadius = (PRADIUS_ATTRIBUTE)((PBYTE)prgRadius+prgRadius->bLength);
    }

    if ( dwRetCode == NO_ERROR )
    {
        if ( fEAPMessage )
        {
            //
            // If we have received an EAP message, make sure we received a valid
            // signature as well
            //

            if ( !fSignature )
            {
                RADIUS_TRACE("Did not receive signature along auth EAPMessage");

                *pdwExtError = ERROR_NO_SIGNATURE;

                dwRetCode = ERROR_INVALID_RADIUS_RESPONSE;
            }
            else
            {

                dwRetCode = RasAuthAttributeInsert( 
					                dwNumAttributes++,
						            *pprgRouter,
									(RAS_AUTH_ATTRIBUTE_TYPE)raatEAPMessage,
									FALSE,
									cbEAPMessage,
									(LPVOID)pEAPMessage );

                *fEapMessageReceived = TRUE;
            }

		    LocalFree( pEAPMessage );
        }
    }
			
    return( dwRetCode );
} 

DWORD 
EncryptPassword(
    IN RAS_AUTH_ATTRIBUTE *             prgRouter, 
    IN RADIUS_ATTRIBUTE UNALIGNED *     prgRadius, 
    IN RADIUSSERVER UNALIGNED *         pRadiusServer, 
    IN RADIUS_PACKETHEADER UNALIGNED *  pHeader, 
    IN BYTE                             bSubCode
)
{
	struct MD5Context	MD5c;
	struct MD5Digest	MD5d;
	DWORD				iIndex, iBlock, cBlocks;
	DWORD				bLength, AttrLength;
	BYTE UNALIGNED		*pbValue;

    //
	// make the password into a 16 octet multiple
    //

	bLength = ((prgRadius->bLength + 15) / 16) * 16;

    if ( bLength == 0 )
    {
        bLength = 16;
    }

	prgRadius->bLength = (BYTE)(sizeof(RADIUS_ATTRIBUTE) + bLength);

	pbValue = (PBYTE) (prgRadius + 1);
	
	AttrLength = sizeof(RADIUS_ATTRIBUTE);

    //
	// Zero pad the password
    //

	ZeroMemory( pbValue, bLength );

    //
	// Copy the original password
    //

    CopyMemory( pbValue, (PBYTE)prgRouter->Value, (BYTE)prgRouter->dwLength);

	cBlocks = bLength / 16;

	for ( iBlock = 0; iBlock < cBlocks; iBlock++ )
    {
		MD5Init( &MD5c );

		MD5Update(&MD5c,(PBYTE)pRadiusServer->szSecret,pRadiusServer->cbSecret);

		if (iBlock == 0)
        {
			MD5Update( &MD5c,   
                       pHeader->rgAuthenticator, 
                       sizeof(pHeader->rgAuthenticator));
        }
		else
        {
			MD5Update(&MD5c, (pbValue - 16), 16);
        }
			
		MD5Final( &MD5d, &MD5c );

		for ( iIndex = 0; iIndex < 16; iIndex++ )
		{
			*pbValue ^= MD5d.digest[iIndex];

			pbValue++;
		}
    }
		
	return( AttrLength + bLength );
} 

DWORD
DecryptMPPEKeys(
    IN      RADIUSSERVER UNALIGNED * pRadiusServer,
    IN      PBYTE                    pRequestAuthenticator,
    IN OUT  PBYTE                    pEncryptionKeys
)
{
    BYTE *              pbValue = (BYTE *)pEncryptionKeys;
    struct MD5Context   MD5c;
    struct MD5Digest    MD5d;
    DWORD               dwIndex;
    DWORD               dwBlock;
    BYTE                abCipherText[16];

    //
    // Save the cipherText from the first block.
    //

    CopyMemory(abCipherText, pbValue, sizeof(abCipherText));

    //
    // Walk thru the 2 blocks
    //

    for ( dwBlock = 0; dwBlock < 2; dwBlock++ )
    {
        MD5Init( &MD5c );

        MD5Update( &MD5c,
                   (PBYTE)(pRadiusServer->szSecret),
                   pRadiusServer->cbSecret);

        if ( dwBlock == 0 )
        {
            //
            // Use the Request Authenticator for the first block
            //

            MD5Update( &MD5c, pRequestAuthenticator, 16 );
        }
        else
        {
            //
            // Use the first block of cipherText for the second block
            //

            MD5Update( &MD5c, abCipherText, 16 );
        }

        MD5Final( &MD5d, &MD5c );

        for ( dwIndex = 0; dwIndex < 16; dwIndex ++ )
        {
            *pbValue ^= MD5d.digest[dwIndex];

            pbValue++;
        }
    }

    return( NO_ERROR );
}

DWORD
DecryptMPPESendRecvKeys(
    IN      RADIUSSERVER UNALIGNED * pRadiusServer, 
    IN      PBYTE                    pRequestAuthenticator,
    IN      DWORD                    dwLength,
    IN OUT  PBYTE                    pEncryptionKeys
)
{
    BYTE *              pbValue = (BYTE *)pEncryptionKeys + 2;
    BYTE                abCipherText[16];
    struct MD5Context   MD5c;
    struct MD5Digest    MD5d;
    DWORD               dwIndex;
    DWORD               dwBlock;
    DWORD               dwNumBlocks;

    dwNumBlocks = ( dwLength - 2 ) / 16;

    //
    // Walk thru the blocks
    //

    for ( dwBlock = 0; dwBlock < dwNumBlocks; dwBlock++ )
    {
        MD5Init( &MD5c );

        MD5Update( &MD5c,
                   (PBYTE)(pRadiusServer->szSecret),
                   pRadiusServer->cbSecret);

        if ( dwBlock == 0 )
        {
            //
            // Use the Request Authenticator and salt for the first block
            //

            MD5Update( &MD5c, pRequestAuthenticator, 16 );
            MD5Update( &MD5c, pEncryptionKeys, 2 );
        }
        else
        {
            //
            // Use the previous block of cipherText
            //

            MD5Update( &MD5c, abCipherText, 16 );
        }
            
        MD5Final( &MD5d, &MD5c );

        //
        // Save the cipherText from this block.
        //

        CopyMemory(abCipherText, pbValue, sizeof(abCipherText));

        for ( dwIndex = 0; dwIndex < 16; dwIndex++ )
        {
            *pbValue ^= MD5d.digest[dwIndex];

            pbValue++;
        }
    }
        
    return( NO_ERROR );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\auth\radius\perfmon.c ===
/********************************************************************/
/**          Copyright(c) 1985-1998 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    perfmon.c
//
// Description: 
//
// History:     Feb 11,1998	    NarenG		Created original version.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <raserror.h>
#include <time.h>
#include <string.h>
#include <rasauth.h>
#include <stdlib.h>
#include <stdio.h>
#include <rtutils.h>
#include <mprlog.h>
#include <mprerror.h>
#define INCL_RASAUTHATTRIBUTES
#include <ppputil.h>
#include "radclnt.h"
#include "md5.h"
#include "perfmon.h"




// ADD

#define PERFORMANCEKEY		TEXT("SYSTEM\\CurrentControlSet\\Services\\Rasrad\\Performance")
#define FIRSTCOUNTER        TEXT("First Counter")
#define FIRSTHELP           TEXT("First Help")

#define QUERY_GLOBAL		1
#define QUERY_FOREIGN		2
#define QUERY_COSTLY		3
#define QUERY_ITEMS			4

#define DELIMITER			1
#define DIGIT				2
#define INVALID				3

#pragma pack(4)

// ADD
#define NUMBER_COUNTERS				9
#define AUTHREQSENT_OFFSET			sizeof(DWORD)
#define AUTHREQFAILED_OFFSET		(AUTHREQSENT_OFFSET + sizeof(DWORD))
#define AUTHREQSUCCEDED_OFFSET		(AUTHREQFAILED_OFFSET + sizeof(DWORD))
#define AUTHREQTIMEOUT_OFFSET		(AUTHREQSUCCEDED_OFFSET + sizeof(DWORD))
#define ACCTREQSENT_OFFSET			(AUTHREQTIMEOUT_OFFSET + sizeof(DWORD))
#define ACCTBADPACK_OFFSET			(ACCTREQSENT_OFFSET + sizeof(DWORD))
#define ACCTREQSUCCEDED_OFFSET		(ACCTBADPACK_OFFSET + sizeof(DWORD))
#define ACCTREQTIMEOUT_OFFSET		(ACCTREQSUCCEDED_OFFSET + sizeof(DWORD))
#define AUTHBADPACK_OFFSET			(ACCTREQTIMEOUT_OFFSET + sizeof(DWORD))

#define CB_PERF_DATA		(sizeof(PERF_COUNTER_BLOCK) + (NUMBER_COUNTERS * sizeof(DWORD)))

typedef struct
	{
	PERF_OBJECT_TYPE		PerfObjectType;
	
	// ADD
	PERF_COUNTER_DEFINITION	cAuthReqSent;
	PERF_COUNTER_DEFINITION	cAuthReqFailed;
	PERF_COUNTER_DEFINITION	cAuthReqSucceded;
	PERF_COUNTER_DEFINITION	cAuthReqTimeout;
	PERF_COUNTER_DEFINITION	cAcctReqSent;
	PERF_COUNTER_DEFINITION	cAcctBadPack;
	PERF_COUNTER_DEFINITION	cAcctReqSucceded;
	PERF_COUNTER_DEFINITION	cAcctReqTimeout;
	PERF_COUNTER_DEFINITION	cAuthBadPack;
	} PERF_DATA;
	
#pragma pack()

DWORD GetQueryType(LPWSTR pwszQuery);
BOOL IsNumberInUnicodeList(DWORD dwNumber, WCHAR UNALIGNED *pwszUnicodeList);

DWORD					g_cRef			= 0;
CONST WCHAR				g_wszGlobal[]	= L"Global";
CONST WCHAR				g_wszForeign[]	= L"Foreign";
CONST WCHAR				g_wszCostly[]	= L"Costly";
PERF_DATA				g_PerfData		=
	{
		{
		sizeof(PERF_DATA) + CB_PERF_DATA, sizeof(PERF_DATA), sizeof(PERF_OBJECT_TYPE),
		RADIUS_CLIENT_COUNTER_OBJECT, 0, RADIUS_CLIENT_COUNTER_OBJECT, 0, PERF_DETAIL_NOVICE, (sizeof(PERF_DATA) - sizeof(PERF_OBJECT_TYPE)) / sizeof(PERF_COUNTER_DEFINITION),
		0, 0, 0
		},
		
		// ADD
		{
		sizeof(PERF_COUNTER_DEFINITION), AUTHREQSENT, 0, AUTHREQSENT, 0, 0, PERF_DETAIL_NOVICE, PERF_COUNTER_RAWCOUNT,
		sizeof(DWORD), AUTHREQSENT_OFFSET
		},
		{
		sizeof(PERF_COUNTER_DEFINITION), AUTHREQFAILED, 0, AUTHREQFAILED, 0, 0, PERF_DETAIL_NOVICE, PERF_COUNTER_RAWCOUNT,
		sizeof(DWORD), AUTHREQFAILED_OFFSET
		},
		{
		sizeof(PERF_COUNTER_DEFINITION), AUTHREQSUCCEDED, 0, AUTHREQSUCCEDED, 0, 0, PERF_DETAIL_NOVICE, PERF_COUNTER_RAWCOUNT,
		sizeof(DWORD), AUTHREQSUCCEDED_OFFSET
		},
		{
		sizeof(PERF_COUNTER_DEFINITION), AUTHREQTIMEOUT, 0, AUTHREQTIMEOUT, 0, 0, PERF_DETAIL_NOVICE, PERF_COUNTER_RAWCOUNT,
		sizeof(DWORD), AUTHREQTIMEOUT_OFFSET
		},
		{
		sizeof(PERF_COUNTER_DEFINITION), ACCTREQSENT, 0, ACCTREQSENT, 0, 0, PERF_DETAIL_NOVICE, PERF_COUNTER_RAWCOUNT,
		sizeof(DWORD), ACCTREQSENT_OFFSET
		},
		{
		sizeof(PERF_COUNTER_DEFINITION), ACCTBADPACK, 0, ACCTBADPACK, 0, 0, PERF_DETAIL_NOVICE, PERF_COUNTER_RAWCOUNT,
		sizeof(DWORD), ACCTBADPACK_OFFSET
		},
		{
		sizeof(PERF_COUNTER_DEFINITION), ACCTREQSUCCEDED, 0, ACCTREQSUCCEDED, 0, 0, PERF_DETAIL_NOVICE, PERF_COUNTER_RAWCOUNT,
		sizeof(DWORD), ACCTREQSUCCEDED_OFFSET
		},
		{
		sizeof(PERF_COUNTER_DEFINITION), ACCTREQTIMEOUT, 0, ACCTREQTIMEOUT, 0, 0, PERF_DETAIL_NOVICE, PERF_COUNTER_RAWCOUNT,
		sizeof(DWORD), ACCTREQTIMEOUT_OFFSET
		},
		{
		sizeof(PERF_COUNTER_DEFINITION), AUTHBADPACK, 0, AUTHBADPACK, 0, 0, PERF_DETAIL_NOVICE, PERF_COUNTER_RAWCOUNT,
		sizeof(DWORD), AUTHBADPACK_OFFSET
		},
	};

// ============================= EvalChar ==========================================

DWORD EvalChar(WCHAR wch, WCHAR wchDelimiter)
{
	if (wch == wchDelimiter || wch == 0)
		return (DELIMITER);

	if (wch >= (WCHAR) '0' && wch <= (WCHAR) '9')
		return (DIGIT);

	return (INVALID);		
} // EvalChar()

// ================================== CompareQuery ===================================

BOOL CompareQuery(WCHAR UNALIGNED *pwszFirst, WCHAR UNALIGNED *pwszSecond)
{
	BOOL				fFound = TRUE;
	
	while ((*pwszFirst != 0) && (*pwszSecond != 0))
		{
		if (*pwszFirst++ != *pwszSecond++)
			{
			fFound = FALSE;
			break;
			}
		}

	return (fFound);	
} // CompareQuery()

// ================================ Open ===========================================

DWORD APIENTRY Open(LPWSTR *pwszDeviceName)
{
	DWORD				Status = ERROR_SUCCESS;
	
	if (g_cRef == 0)
		{
		HKEY			hKey = NULL;
		DWORD			Size, Type, dwFirstCounter, dwFirstHelp;

		__try
			{
			Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, PERFORMANCEKEY, 0, KEY_ALL_ACCESS, &hKey);
			if (Status != ERROR_SUCCESS)
				__leave;

			Size = sizeof(DWORD);
			Status = RegQueryValueEx(hKey, FIRSTCOUNTER, 0, &Type, (PBYTE) &dwFirstCounter, &Size);	
			if (Status != ERROR_SUCCESS)
				__leave;
				
			Size = sizeof(DWORD);
			Status = RegQueryValueEx(hKey, FIRSTHELP, 0, &Type, (PBYTE) &dwFirstHelp, &Size);	
			if (Status != ERROR_SUCCESS)
				__leave;

			g_PerfData.PerfObjectType.ObjectNameTitleIndex += dwFirstCounter;
			g_PerfData.PerfObjectType.ObjectHelpTitleIndex += dwFirstHelp;
			
			// ADD
			g_PerfData.cAuthReqSent.CounterNameTitleIndex += dwFirstCounter;
			g_PerfData.cAuthReqSent.CounterHelpTitleIndex += dwFirstHelp;
			g_PerfData.cAuthReqFailed.CounterNameTitleIndex += dwFirstCounter;
			g_PerfData.cAuthReqFailed.CounterHelpTitleIndex += dwFirstHelp;
			g_PerfData.cAuthReqSucceded.CounterNameTitleIndex += dwFirstCounter;
			g_PerfData.cAuthReqSucceded.CounterHelpTitleIndex += dwFirstHelp;
			g_PerfData.cAuthReqTimeout.CounterNameTitleIndex += dwFirstCounter;
			g_PerfData.cAuthReqTimeout.CounterHelpTitleIndex += dwFirstHelp;
			
			g_PerfData.cAcctReqSent.CounterNameTitleIndex += dwFirstCounter;
			g_PerfData.cAcctReqSent.CounterHelpTitleIndex += dwFirstHelp;
			g_PerfData.cAcctBadPack.CounterNameTitleIndex += dwFirstCounter;
			g_PerfData.cAcctBadPack.CounterHelpTitleIndex += dwFirstHelp;
			g_PerfData.cAcctReqSucceded.CounterNameTitleIndex += dwFirstCounter;
			g_PerfData.cAcctReqSucceded.CounterHelpTitleIndex += dwFirstHelp;
			g_PerfData.cAcctReqTimeout.CounterNameTitleIndex += dwFirstCounter;
			g_PerfData.cAcctReqTimeout.CounterHelpTitleIndex += dwFirstHelp;

			g_PerfData.cAuthBadPack.CounterNameTitleIndex += dwFirstCounter;
			g_PerfData.cAuthBadPack.CounterHelpTitleIndex += dwFirstHelp;
			
			} // __try

		__finally
			{
			RegCloseKey(hKey);
			} // __finally
		} // g_cRef == 0
		
	g_cRef ++;
	
	return (Status);
} // Open()

// ================================ Collect ========================================

DWORD APIENTRY Collect(LPWSTR pwszValue, LPVOID *ppvData, LPDWORD pcbData, LPDWORD pcObjectTypes)
{
	DWORD				dwQueryType, *pdwCounter, dwSpaceNeeded;
	PERF_DATA UNALIGNED	*pPerfData;
	PERF_COUNTER_BLOCK UNALIGNED	*pPerfCounter;
	
	dwQueryType = GetQueryType(pwszValue);

	if (dwQueryType == QUERY_FOREIGN)
		{
		*pcbData = 0;
		*pcObjectTypes = 0;
		
		return (ERROR_SUCCESS);
		}

	if (dwQueryType == QUERY_ITEMS)
		{
		if (IsNumberInUnicodeList(g_PerfData.PerfObjectType.ObjectNameTitleIndex, pwszValue) == FALSE)
			{
			*pcbData = 0;
			*pcObjectTypes = 0;
			
			return (ERROR_SUCCESS);
			}
		} // QUERY_ITEMS

	pPerfData = (PERF_DATA *) *ppvData;
	dwSpaceNeeded = sizeof(PERF_DATA) + CB_PERF_DATA;

	if (*pcbData < dwSpaceNeeded)
		{
		*pcbData = 0;
		*pcObjectTypes = 0;
		
		return (ERROR_MORE_DATA);
		}

	CopyMemory(pPerfData, &g_PerfData, sizeof(PERF_DATA));
	pPerfCounter = (PERF_COUNTER_BLOCK *) &pPerfData[1];
	pPerfCounter->ByteLength = CB_PERF_DATA;
	pdwCounter = (DWORD *) &pPerfCounter[1];
	
	// ADD
	*pdwCounter = g_cAuthReqSent;
	pdwCounter += 1;
	*pdwCounter = g_cAuthReqFailed;
	pdwCounter += 1;
	*pdwCounter = g_cAuthReqSucceded;
	pdwCounter += 1;
	*pdwCounter = g_cAuthReqTimeout;
	pdwCounter += 1;
	*pdwCounter = g_cAcctReqSent;
	pdwCounter += 1;
	*pdwCounter = g_cAcctBadPack;
	pdwCounter += 1;
	*pdwCounter = g_cAcctReqSucceded;
	pdwCounter += 1;
	*pdwCounter = g_cAcctReqTimeout;
	pdwCounter += 1;

	*pdwCounter = g_cAuthBadPack;
	pdwCounter += 1;
		
	*ppvData = (PVOID) pdwCounter;
	*pcObjectTypes = 1;
	*pcbData = (DWORD) ((PBYTE) pdwCounter - (PBYTE) pPerfData);
	
	return (ERROR_SUCCESS);
} // Collect()

// ================================= Close ==========================================

DWORD APIENTRY Close(VOID)
{
	g_cRef --;
	if (g_cRef == 0)
		{
		}
		
	return (ERROR_SUCCESS);
} // Close()


// ================================== GetQueryType ==================================

DWORD GetQueryType(LPWSTR pwszQuery)
{
	if (pwszQuery == NULL || *pwszQuery == 0)
		{
		return (QUERY_GLOBAL);
		}

	if (CompareQuery(pwszQuery, (WCHAR *) g_wszGlobal))
		return (QUERY_GLOBAL);
		
	if (CompareQuery(pwszQuery, (WCHAR *) g_wszForeign))
		return (QUERY_FOREIGN);
		
	if (CompareQuery(pwszQuery, (WCHAR *) g_wszCostly))
		return (QUERY_COSTLY);
		
	return (QUERY_ITEMS);
} // GetQueryType()

// ============================== IsNumberInUnicodeList ===============================

BOOL IsNumberInUnicodeList(DWORD dwNumber, WCHAR UNALIGNED *pwszUnicodeList)
{
	BOOL				fInList = FALSE;

	__try
		{
		WCHAR UNALIGNED	*pwszCh = pwszUnicodeList;
		BOOL			fNewItem = TRUE;
		BOOL			fValidNumber = FALSE;
		DWORD			dwThisNumber = 0;
		
		if (pwszUnicodeList == NULL)
			__leave;

		while (TRUE)
			{
			switch (EvalChar(*pwszCh, (WCHAR) ' '))
				{
				case DIGIT:
					if (fNewItem == TRUE)
						{
						fNewItem = FALSE;
						fValidNumber = TRUE;
						}
						
					if (fValidNumber == TRUE)
						{
						dwThisNumber *= 10;
						dwThisNumber += (*pwszCh - (WCHAR) '0');
						}	
					break;
				case DELIMITER:
					if (fValidNumber)
						{
						if (dwThisNumber == dwNumber)
							return (TRUE);
							
						fValidNumber = FALSE;
						}

					if (*pwszCh	== 0)
						{
						return (FALSE);
						}
					else
						{
						fNewItem = TRUE;
						dwThisNumber = 0;
						}	
					break;
				case INVALID:
					fValidNumber = FALSE;
					break;
				default:
					break;
				} // EvalChar

			pwszCh++;
			} // TRUE
			
		} // __try

	__finally
		{
		} // __finally
		
	return (fInList);
} // IsNumberInUnicodeList()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\auth\radius\md5.c ===
/****************************************************************************************
 * NAME:        MD5.CPP
 * MODULE:      RADSRV
 * AUTHOR:      Don Dumitru
 *
 * HISTORY
 *      02/15/95  DONDU      Created
 *
 * OVERVIEW
 *
 * MD5 hashing routines.
 *
 *
 * Copyright 1995, Microsoft Corporation
 *
 ****************************************************************************************/


/* md5.c
 * An implementation of Ron Rivest's MD5 message-digest algorithm.
 * Written by Colin Plumb in 1993, no copyright is claimed.
 * This code is in the public domain; do with it what you wish.
 *
 * Equivalent code is available from RSA Data Security, Inc.  This code
 * has been tested against that, but was developed separately and does
 * not oblige you to include legal boilerplate in the documentation.
 *
 * To compute the message digest of a sequence of bytes, declare an
 * MD5Context structure, pass it to MD5Init, call MD5Update as needed
 * on buffers full of bytes, and then call MD5Final, which will fill
 * a supplied 16-unsigned char array with the digest.
 */
#include <windows.h>
#include "md5.h"


/*
 * byte-swap an array of words to little-endian.
 * (The code is unsigned char-order independent.)
 */
void ByteSwap (unsigned long UNALIGNED *buf, unsigned words)
{
	unsigned char UNALIGNED *p = (unsigned char *) buf;
	do
		{
		*buf++ = (unsigned long) ((unsigned) p[3] << 8 | p[2]) << 16 |
			((unsigned) p[1] << 8 | p[0]);
		p += 4;
		}
	while (--words);
}


/*
 * Start MD5 accumulation.  Set the hash buffer to the mysterious
 * initialization constants and clear the unsigned char count.
 */
void MD5Init (struct MD5Context UNALIGNED *ctx)
{
	ctx->hash[0] = 0x67452301;
	ctx->hash[1] = 0xefcdab89;
	ctx->hash[2] = 0x98badcfe;
	ctx->hash[3] = 0x10325476;

	ctx->Bytes[1] = ctx->Bytes[0] = 0;
}


/* The four core functions - F1 is optimized somewhat */
/* #define F1(x, y, z) (x & y | ~x & z) */
#define F1(x, y, z) (z ^ (x & (y ^ z)))
#define F2(x, y, z) F1(z, x, y)
#define F3(x, y, z) (x ^ y ^ z)
#define F4(x, y, z) (y ^ (x | ~z))

/* This is the central step in the MD5 algorithm. */
#define MD5STEP(f,w,x,y,z,in,s) (w += f(x,y,z)+in, w = ((w<<s) | (w>>(32-s))) + x)

/*
 * The heart of the MD5 algorithm, this alters an existing MD5 hash to
 * reflect the addition of 16 words of new data.  MD5Update blocks the
 * data and converts bytes into 32-bit words for this routine.
 */
void MD5Transform (unsigned long UNALIGNED hash[4], unsigned long const UNALIGNED input[16])
{
	register unsigned long a = hash[0], b = hash[1], c = hash[2], d = hash[3];

	MD5STEP (F1, a, b, c, d, input[0] + 0xd76aa478, 7);
	MD5STEP (F1, d, a, b, c, input[1] + 0xe8c7b756, 12);
	MD5STEP (F1, c, d, a, b, input[2] + 0x242070db, 17);
	MD5STEP (F1, b, c, d, a, input[3] + 0xc1bdceee, 22);
	MD5STEP (F1, a, b, c, d, input[4] + 0xf57c0faf, 7);
	MD5STEP (F1, d, a, b, c, input[5] + 0x4787c62a, 12);
	MD5STEP (F1, c, d, a, b, input[6] + 0xa8304613, 17);
	MD5STEP (F1, b, c, d, a, input[7] + 0xfd469501, 22);
	MD5STEP (F1, a, b, c, d, input[8] + 0x698098d8, 7);
	MD5STEP (F1, d, a, b, c, input[9] + 0x8b44f7af, 12);
	MD5STEP (F1, c, d, a, b, input[10] + 0xffff5bb1, 17);
	MD5STEP (F1, b, c, d, a, input[11] + 0x895cd7be, 22);
	MD5STEP (F1, a, b, c, d, input[12] + 0x6b901122, 7);
	MD5STEP (F1, d, a, b, c, input[13] + 0xfd987193, 12);
	MD5STEP (F1, c, d, a, b, input[14] + 0xa679438e, 17);
	MD5STEP (F1, b, c, d, a, input[15] + 0x49b40821, 22);

	MD5STEP (F2, a, b, c, d, input[1] + 0xf61e2562, 5);
	MD5STEP (F2, d, a, b, c, input[6] + 0xc040b340, 9);
	MD5STEP (F2, c, d, a, b, input[11] + 0x265e5a51, 14);
	MD5STEP (F2, b, c, d, a, input[0] + 0xe9b6c7aa, 20);
	MD5STEP (F2, a, b, c, d, input[5] + 0xd62f105d, 5);
	MD5STEP (F2, d, a, b, c, input[10] + 0x02441453, 9);
	MD5STEP (F2, c, d, a, b, input[15] + 0xd8a1e681, 14);
	MD5STEP (F2, b, c, d, a, input[4] + 0xe7d3fbc8, 20);
	MD5STEP (F2, a, b, c, d, input[9] + 0x21e1cde6, 5);
	MD5STEP (F2, d, a, b, c, input[14] + 0xc33707d6, 9);
	MD5STEP (F2, c, d, a, b, input[3] + 0xf4d50d87, 14);
	MD5STEP (F2, b, c, d, a, input[8] + 0x455a14ed, 20);
	MD5STEP (F2, a, b, c, d, input[13] + 0xa9e3e905, 5);
	MD5STEP (F2, d, a, b, c, input[2] + 0xfcefa3f8, 9);
	MD5STEP (F2, c, d, a, b, input[7] + 0x676f02d9, 14);
	MD5STEP (F2, b, c, d, a, input[12] + 0x8d2a4c8a, 20);

	MD5STEP (F3, a, b, c, d, input[5] + 0xfffa3942, 4);
	MD5STEP (F3, d, a, b, c, input[8] + 0x8771f681, 11);
	MD5STEP (F3, c, d, a, b, input[11] + 0x6d9d6122, 16);
	MD5STEP (F3, b, c, d, a, input[14] + 0xfde5380c, 23);
	MD5STEP (F3, a, b, c, d, input[1] + 0xa4beea44, 4);
	MD5STEP (F3, d, a, b, c, input[4] + 0x4bdecfa9, 11);
	MD5STEP (F3, c, d, a, b, input[7] + 0xf6bb4b60, 16);
	MD5STEP (F3, b, c, d, a, input[10] + 0xbebfbc70, 23);
	MD5STEP (F3, a, b, c, d, input[13] + 0x289b7ec6, 4);
	MD5STEP (F3, d, a, b, c, input[0] + 0xeaa127fa, 11);
	MD5STEP (F3, c, d, a, b, input[3] + 0xd4ef3085, 16);
	MD5STEP (F3, b, c, d, a, input[6] + 0x04881d05, 23);
	MD5STEP (F3, a, b, c, d, input[9] + 0xd9d4d039, 4);
	MD5STEP (F3, d, a, b, c, input[12] + 0xe6db99e5, 11);
	MD5STEP (F3, c, d, a, b, input[15] + 0x1fa27cf8, 16);
	MD5STEP (F3, b, c, d, a, input[2] + 0xc4ac5665, 23);

	MD5STEP (F4, a, b, c, d, input[0] + 0xf4292244, 6);
	MD5STEP (F4, d, a, b, c, input[7] + 0x432aff97, 10);
	MD5STEP (F4, c, d, a, b, input[14] + 0xab9423a7, 15);
	MD5STEP (F4, b, c, d, a, input[5] + 0xfc93a039, 21);
	MD5STEP (F4, a, b, c, d, input[12] + 0x655b59c3, 6);
	MD5STEP (F4, d, a, b, c, input[3] + 0x8f0ccc92, 10);
	MD5STEP (F4, c, d, a, b, input[10] + 0xffeff47d, 15);
	MD5STEP (F4, b, c, d, a, input[1] + 0x85845dd1, 21);
	MD5STEP (F4, a, b, c, d, input[8] + 0x6fa87e4f, 6);
	MD5STEP (F4, d, a, b, c, input[15] + 0xfe2ce6e0, 10);
	MD5STEP (F4, c, d, a, b, input[6] + 0xa3014314, 15);
	MD5STEP (F4, b, c, d, a, input[13] + 0x4e0811a1, 21);
	MD5STEP (F4, a, b, c, d, input[4] + 0xf7537e82, 6);
	MD5STEP (F4, d, a, b, c, input[11] + 0xbd3af235, 10);
	MD5STEP (F4, c, d, a, b, input[2] + 0x2ad7d2bb, 15);
	MD5STEP (F4, b, c, d, a, input[9] + 0xeb86d391, 21);

	hash[0] += a;
	hash[1] += b;
	hash[2] += c;
	hash[3] += d;
}


/* Update ctx to reflect the addition of another buffer full of bytes. */
void MD5Update (struct MD5Context UNALIGNED *ctx, unsigned char const UNALIGNED *buf, unsigned len)
{
	unsigned long t = ctx->Bytes[0];

	/* Update 64-bit unsigned char count */
	if ((ctx->Bytes[0] = t + len) < t)
		ctx->Bytes[1]++;		/* Carry from low to high */

	t = 64 - (t & 0x3f);		/* bytes available in ctx->input (>= 1) */
	if (t > len)
		{
		memcpy ((unsigned char *) ctx->input + 64 - t, buf, len);
		return;
		}

	/* First chunk is an odd size */
	memcpy ((unsigned char *) ctx->input + 64 - t, buf, t);
	ByteSwap (ctx->input, 16);
	MD5Transform (ctx->hash, ctx->input);
	buf += t;
	len -= t;

	/* Process data in 64-unsigned char chunks */
	while (len >= 64)
		{
		memcpy (ctx->input, buf, 64);
		ByteSwap (ctx->input, 16);
		MD5Transform (ctx->hash, ctx->input);
		buf += 64;
		len -= 64;
		}

	/* Buffer any remaining bytes of data */
	memcpy (ctx->input, buf, len);
}


/*
 * Final wrapup - pad to 64-unsigned char boundary with the bit pattern
 * 1 0* (64-bit count of bits processed, LSB-first)
 */
void MD5Final (struct MD5Digest UNALIGNED *digest, struct MD5Context UNALIGNED *ctx)
{
	int count = ctx->Bytes[0] & 0x3F;	/* bytes mod 64 */
	unsigned char UNALIGNED *p = (unsigned char *) ctx->input + count;

	/* Set the first unsigned char of padding to 0x80.  There is always room. */
	*p++ = 0x80;

	/* bytes of zero padding needed to make 56 bytes (-8..55) */
	count = 56 - 1 - count;

	if (count < 0)
		{						/* Padding forces an extra block */
		memset (p, 0, count + 8);
		ByteSwap (ctx->input, 16);
		MD5Transform (ctx->hash, ctx->input);
		p = (unsigned char *) ctx->input;
		count = 56;
		}
	memset (p, 0, count);
	ByteSwap (ctx->input, 14);

	/* Append 8 bytes of length in *bits* and transform */
	ctx->input[14] = ctx->Bytes[0] << 3;
	ctx->input[15] = ctx->Bytes[1] << 3 | ctx->Bytes[0] >> 29;
	MD5Transform (ctx->hash, ctx->input);

	ByteSwap (ctx->hash, 4);
	memcpy (digest, ctx->hash, 16);
	memset (ctx, 0, sizeof (*ctx));		/* In case it's sensitive */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\auth\radius\radclnt.c ===
/********************************************************************/
/**          Copyright(c) 1985-1998 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    radclnt.c
//
// Description: Main module of the RADIUS client
//
// History:     Feb 11,1998     NarenG      Created original version.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <raserror.h>
#include <time.h>
#include <string.h>
#include <rasauth.h>
#include <stdlib.h>
#include <stdio.h>
#include <rtutils.h>
#include <mprlog.h>
#include <mprerror.h>
#define INCL_RASAUTHATTRIBUTES
#define INCL_HOSTWIRE
#include <ppputil.h>
#include "hmacmd5.h"
#include "md5.h"
#define ALLOCATE_GLOBALS
#include "radclnt.h"


//
// Perfmon Counters
//

#pragma data_seg(".shdat")
LONG    g_cAuthReqSent      = 0;	    // Auth Requests Sent
LONG	g_cAuthReqFailed    = 0;        // Auth Requests Failed
LONG	g_cAuthReqSucceded  = 0;        // Auth Requests Succeded
LONG	g_cAuthReqTimeout   = 0;        // Auth Requests timeouts
LONG	g_cAcctReqSent      = 0;	    // Acct Requests Sent
LONG    g_cAcctBadPack      = 0;	    // Acct Bad packets
LONG    g_cAcctReqSucceded  = 0;        // Acct Requests Succeded
LONG	g_cAcctReqTimeout   = 0;        // Acct Requests timeouts
LONG    g_cAuthBadPack      = 0;	    // Auth Bad packets

#pragma data_seg()

//**
//
// Call:        RasAuthProviderInitialize
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Initialize all global parameters here.
//              Called up each process only once.
//              Each RAS_AuthInitialize should be matched with RAS_AuthTerminate
//
DWORD APIENTRY 
RasAuthProviderInitialize(
    IN  RAS_AUTH_ATTRIBUTE * pServerAttributes,
    IN  HANDLE               hLogEvents,    
    IN  DWORD                dwLoggingLevel
)
{
	WSADATA WSAData;
	DWORD	dwErrorCode = NO_ERROR;

    do
    {
	    if ( g_dwTraceID == INVALID_TRACEID )
        {
	        g_dwTraceID = TraceRegister( TEXT("RADIUS") );
        }

        if ( g_hLogEvents == INVALID_HANDLE_VALUE )
        {
            g_hLogEvents = RouterLogRegister( TEXT("RemoteAccess") );
        }

        //
		// Init Winsock
        //

        if ( !fWinsockInitialized )
        {
		    dwErrorCode = WSAStartup(MAKEWORD(1, 1), &WSAData);

		    if ( dwErrorCode != ERROR_SUCCESS )
            {
                break;
            }

            fWinsockInitialized = TRUE;
        }

        if ( g_AuthServerListHead.Flink == NULL )
        {
            //
		    // Load global list of RADIUS servers
            //

            InitializeRadiusServerList( TRUE );
        }

        dwErrorCode = LoadRadiusServers( TRUE );

        if ( dwErrorCode != ERROR_SUCCESS )
        {
            break;
        }

    }while( FALSE ); 

    if ( dwErrorCode != NO_ERROR )
    {
	    RasAuthProviderTerminate();
    }

	return( dwErrorCode );
} 

//**
//
// Call:        RasAuthProviderTerminate
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Cleanup for entire process 
//              Called once per process
// 
DWORD APIENTRY 
RasAuthProviderTerminate(
    VOID
)
{
    if ( g_AuthServerListHead.Flink != NULL )
    {
        FreeRadiusServerList( TRUE );
    }

    if ( fWinsockInitialized )
    {
		WSACleanup();

        fWinsockInitialized = FALSE;
    }

	if ( g_dwTraceID != INVALID_TRACEID )
    {
	    TraceDeregister( g_dwTraceID );

	    g_dwTraceID = INVALID_TRACEID;
    }

    if ( g_hLogEvents != INVALID_HANDLE_VALUE )
    {
        RouterLogDeregister( g_hLogEvents );

        g_hLogEvents = INVALID_HANDLE_VALUE;
    }

	return( NO_ERROR );
} 

//**
//
// Call:        RasAuthProviderFreeAttributes
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD APIENTRY
RasAuthProviderFreeAttributes(
    IN  RAS_AUTH_ATTRIBUTE * pAttributes
)
{
    RasAuthAttributeDestroy( pAttributes );

    return( NO_ERROR );
}

//**
//
// Call:        RasAuthProviderAuthenticateUser
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Takes a list of radius attributes and tries to authenticate 
//              with a radius server. 
//              INPUT: Array of RADIUS attributes RAS_AUTH_ATTRIBUTE[]
//              OUTPUT: Header packet followed by array of RADIUS attributes
//			    RAS_AUTH_ATTRIBUTE[]
//
DWORD APIENTRY 
RasAuthProviderAuthenticateUser(
    IN  RAS_AUTH_ATTRIBUTE *    prgInAttributes, 
    OUT RAS_AUTH_ATTRIBUTE **   pprgOutAttributes, 
    OUT DWORD *                 lpdwResultCode
)
{
	DWORD   dwError = NO_ERROR;
	BYTE	bCode;
    BOOL    fEapMessageReceived;

	RADIUS_TRACE("RasAuthenticateUser called");

    do
    {
		if (lpdwResultCode == NULL)
	    {
		    dwError = ERROR_INVALID_PARAMETER;
            break;
	    }

		bCode = ptAccessRequest;

		if ((dwError = SendData2ServerWRetry( prgInAttributes, 
                                              pprgOutAttributes, 
                                              &bCode, 
                                              atInvalid,
                                              &fEapMessageReceived )
                                                                ) == NO_ERROR )
	    {
			switch (bCode)
			{
			case ptAccessAccept:

			    InterlockedIncrement( &g_cAuthReqSucceded );

                *lpdwResultCode = ERROR_SUCCESS;

                break;

	        case ptAccessChallenge:

                if ( fEapMessageReceived )
                {
				    *lpdwResultCode = ERROR_SUCCESS;
                }
                else
                {
			        *lpdwResultCode = ERROR_AUTHENTICATION_FAILURE;
                }

				break;

		    case ptAccessReject:

			    InterlockedIncrement(&g_cAuthReqFailed);

			    *lpdwResultCode = ERROR_AUTHENTICATION_FAILURE;

			    break;
					
	        default:

		        InterlockedIncrement(&g_cAuthBadPack);

			    *lpdwResultCode = ERROR_AUTHENTICATION_FAILURE;

			    break;
            }
	    }
		else
	    {
            if ( dwError == ERROR_INVALID_RADIUS_RESPONSE )
            {
				InterlockedIncrement(&g_cAuthBadPack);
			}
        }

    }while( FALSE );

	return( dwError );
} 

//**
//
// Call:        RasAuthConfigChangeNotification
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Reloads config information dynamically
//
DWORD APIENTRY
RasAuthConfigChangeNotification(
    IN  DWORD                dwLoggingLevel
)
{
    DWORD dwError = NO_ERROR;

    RADIUS_TRACE("RasAuthConfigChangeNotification called");

    return( ReloadConfig( TRUE ) );
}

//**
//
// Call:        RasAcctProviderInitialize
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Do nothing since all the work is done by 
//              RasAuthProviderInitialize
//
DWORD APIENTRY
RasAcctProviderInitialize(
    IN  RAS_AUTH_ATTRIBUTE * pServerAttributes,
    IN  HANDLE               hLogEvents,    
    IN  DWORD                dwLoggingLevel
)
{
    WSADATA WSAData;
    DWORD   dwErrorCode = NO_ERROR;

    do
    {
        if ( g_dwTraceID == INVALID_TRACEID )
        {
            g_dwTraceID = TraceRegister( TEXT("RADIUS") );
        }

        if ( g_hLogEvents == INVALID_HANDLE_VALUE )
        {
            g_hLogEvents = RouterLogRegister( TEXT("RemoteAccess") );
        }

        //
        // Init Winsock
        //

        if ( !fWinsockInitialized )
        {
            dwErrorCode = WSAStartup(MAKEWORD(1, 1), &WSAData);

            if ( dwErrorCode != ERROR_SUCCESS )
            {
                break;
            }

            fWinsockInitialized = TRUE;
        }

        //
        // Load global list of RADIUS servers
        //

        if ( g_AcctServerListHead.Flink == NULL )
        {
            InitializeRadiusServerList( FALSE );
        }

        //
        // Make a copy of the Server attributes
        //

        g_pServerAttributes = RasAuthAttributeCopy( pServerAttributes );

        if ( g_pServerAttributes == NULL )
        {
            dwErrorCode = GetLastError();

            break;
        }

        dwErrorCode = LoadRadiusServers( FALSE );

        if ( dwErrorCode != ERROR_SUCCESS )
        {
            break;
        }

    }while( FALSE );

    if ( dwErrorCode != ERROR_SUCCESS )
    {
        RasAuthProviderTerminate();
    }

    return( dwErrorCode );
}

//**
//
// Call:        RasAcctProviderTerminate
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Do nothing since all the work is done by 
//              RasAuthProviderTerminate
//
DWORD APIENTRY
RasAcctProviderTerminate(
    VOID
)
{
    if ( g_AcctServerListHead.Flink != NULL )
    {
        FreeRadiusServerList( FALSE );
    }

    if ( fWinsockInitialized )
    {
        WSACleanup();

        fWinsockInitialized = FALSE;
    }

    if ( g_pServerAttributes != NULL )
    {
        RasAuthAttributeDestroy( g_pServerAttributes );

        g_pServerAttributes = NULL;
    }

    if ( g_dwTraceID != INVALID_TRACEID )
    {
        TraceDeregister( g_dwTraceID );

        g_dwTraceID = INVALID_TRACEID;
    }

    if ( g_hLogEvents != INVALID_HANDLE_VALUE )
    {
        RouterLogDeregister( g_hLogEvents );

        g_hLogEvents = INVALID_HANDLE_VALUE;
    }

    return( NO_ERROR );
}

//**
//
// Call:        RasAcctProviderFreeAttributes
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD APIENTRY
RasAcctProviderFreeAttributes(
    IN  RAS_AUTH_ATTRIBUTE * pAttributes
)
{
    RasAuthAttributeDestroy( pAttributes );

    return( NO_ERROR );
}

//**
//
// Call:        RasAcctProviderStartAccounting
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD APIENTRY 
RasAcctProviderStartAccounting(
    IN  RAS_AUTH_ATTRIBUTE *prgInAttributes, 
    OUT RAS_AUTH_ATTRIBUTE **pprgOutAttributes
)
{
	DWORD   dwError = NO_ERROR;
	BYTE    bCode;
    BOOL    fEapMessageReceived;

	RADIUS_TRACE("RasStartAccounting called");

    do
    {
		bCode = ptAccountingRequest;

		if ((dwError = SendData2ServerWRetry( prgInAttributes, 
                                              pprgOutAttributes, 
                                              &bCode, 
                                              atStart,
                                              &fEapMessageReceived )
                                                                ) == NO_ERROR )
        {
			if (bCode == ptAccountingResponse)
			{
				InterlockedIncrement(&g_cAcctReqSucceded);
		    }
			else
		    {
				InterlockedIncrement(&g_cAcctBadPack);
		    }
	    }
		else
	    {
            if ( dwError == ERROR_INVALID_RADIUS_RESPONSE )
            {
				InterlockedIncrement(&g_cAcctBadPack);
            }
	    }
				
    }while( FALSE );

	return( dwError );
}

//**
//
// Call:        RasAcctProviderStopAccounting
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD APIENTRY 
RasAcctProviderStopAccounting(
    IN  RAS_AUTH_ATTRIBUTE *prgInAttributes, 
    OUT RAS_AUTH_ATTRIBUTE **pprgOutAttributes
)
{
	DWORD   dwError = NO_ERROR;
	BYTE    bCode;
    BOOL    fEapMessageReceived;

	RADIUS_TRACE("RasStopAccounting called");

    do
    {
		bCode = ptAccountingRequest;

		if ((dwError = SendData2ServerWRetry( prgInAttributes, 
                                              pprgOutAttributes, 
                                              &bCode, 
                                              atStop,
                                              &fEapMessageReceived)
                                                            ) == NO_ERROR )
	    {
			if (bCode == ptAccountingResponse)
			{
				InterlockedIncrement(&g_cAcctReqSucceded);
		    }
			else
		    {
				InterlockedIncrement(&g_cAcctBadPack);
		    }
	    }
		else
	    {
            if ( dwError == ERROR_INVALID_RADIUS_RESPONSE )
            {
				InterlockedIncrement(&g_cAcctBadPack);
            }
	    }

    }while( FALSE );

	return( dwError );
} 

//**
//
// Call:        RasAcctProviderInterimAccounting
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD APIENTRY
RasAcctProviderInterimAccounting(
    IN  RAS_AUTH_ATTRIBUTE *prgInAttributes,
    OUT RAS_AUTH_ATTRIBUTE **pprgOutAttributes
)
{
    DWORD   dwError = NO_ERROR;
    BYTE    bCode;
    BOOL    fEapMessageReceived;

    RADIUS_TRACE("RasInterimAccounting called");

    do
    {
        bCode = ptAccountingRequest;

        if ((dwError = SendData2ServerWRetry( prgInAttributes,
                                              pprgOutAttributes,
                                              &bCode,
                                              atInterimUpdate,
                                              &fEapMessageReceived )) 
                                                                == NO_ERROR )
        {
            if ( bCode == ptAccountingResponse )
            {
                InterlockedIncrement( &g_cAcctReqSucceded );
            }
            else
            {
                InterlockedIncrement( &g_cAcctBadPack );
            }
        }
        else
        {
            if ( dwError == ERROR_INVALID_RADIUS_RESPONSE )
            {
                InterlockedIncrement( &g_cAcctBadPack );
            }
        }

    }while( FALSE );

    return( dwError );
}

//**
//
// Call:        RasAcctConfigChangeNotification
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Reloads config information dynamically
//
DWORD APIENTRY
RasAcctConfigChangeNotification(
    IN  DWORD                dwLoggingLevel
)
{
    DWORD   dwError = NO_ERROR;

    RADIUS_TRACE("RasAcctConfigChangeNotification called");

    return( ReloadConfig( FALSE ) );
}

//**
//
// Call:        SendData2Server
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will do the real work of sending the Access/Accounting Request
//              packets to the server and receive the reponse back
//
DWORD 
SendData2Server(
    IN  PRAS_AUTH_ATTRIBUTE     prgInAttributes, 
    OUT PRAS_AUTH_ATTRIBUTE *   pprgOutAttributes, 
    IN  BYTE *                  pbCode, 
    IN  BYTE                    bSubCode, 
    IN  LONG                    lPacketID,
    IN  DWORD                   dwRetryCount,
    OUT BOOL *                  pfEapMessageReceived 
)
{
	SOCKET  SockServer      = INVALID_SOCKET;
	DWORD   dwError         = NO_ERROR;
	DWORD   dwExtError      = 0;
    DWORD   dwNumAttributes = 0;

    do
    {
		BYTE					        szSendBuffer[MAXBUFFERSIZE];
		BYTE					        szRecvBuffer[MAXBUFFERSIZE];
		RADIUS_PACKETHEADER	UNALIGNED * pSendHeader = NULL;
		RADIUS_PACKETHEADER	UNALIGNED * pRecvHeader = NULL;
        BYTE UNALIGNED *                pSignature  = NULL;
		BYTE UNALIGNED *                prgBuffer   = NULL;
		INT 					        AttrLength  = 0;
		PRAS_AUTH_ATTRIBUTE			    pAttribute  = NULL;
		RADIUS_ATTRIBUTE UNALIGNED *    pRadiusAttribute;
		fd_set					        fdsSocketRead;
		RADIUSSERVER			        RadiusServer;
        struct MD5Context	            MD5c;
	    struct MD5Digest	            MD5d;
        DWORD                           dwLength = 0;

		if (prgInAttributes == NULL || pprgOutAttributes == NULL)
        {
			dwError = ERROR_INVALID_PARAMETER;
            break;
	    }

		*pprgOutAttributes = NULL;
		
        //
		// Pick a RADIUS server
        //

        if ( ChooseRadiusServer( &RadiusServer, 
                                 (*pbCode == ptAccessRequest )
                                    ? FALSE
                                    : TRUE,
                                 lPacketID ) == NULL )
        {
		    dwError = ERROR_NO_RADIUS_SERVERS;
            break;
        }
			
        //
		// Set packet type to Access-Request
        //

		pSendHeader                 = (PRADIUS_PACKETHEADER)szSendBuffer;
		pSendHeader->bCode			= *pbCode;
		pSendHeader->bIdentifier	= RadiusServer.bIdentifier;
		pSendHeader->wLength		= sizeof(RADIUS_PACKETHEADER);

        //
        // Set the request authenticator to a random value
        //

        srand( (unsigned)time( NULL ) );

        *((WORD*)(pSendHeader->rgAuthenticator))    = (WORD)rand();
        *((WORD*)(pSendHeader->rgAuthenticator+2))  = (WORD)rand();
        *((WORD*)(pSendHeader->rgAuthenticator+4))  = (WORD)rand();
        *((WORD*)(pSendHeader->rgAuthenticator+6))  = (WORD)rand();
        *((WORD*)(pSendHeader->rgAuthenticator+8))  = (WORD)rand();
        *((WORD*)(pSendHeader->rgAuthenticator+10)) = (WORD)rand();
        *((WORD*)(pSendHeader->rgAuthenticator+12)) = (WORD)rand();
        *((WORD*)(pSendHeader->rgAuthenticator+14)) = (WORD)rand();

        //
		// Find length of all attribute values
        //

		pAttribute = prgInAttributes;

		prgBuffer = (PBYTE) (pSendHeader + 1);

        //
		// Convert Attributes to RADIUS format
        //

		dwError = Router2Radius( prgInAttributes, 
                                 (RADIUS_ATTRIBUTE *) prgBuffer,
                                 &RadiusServer,  
                                 pSendHeader,    
                                 bSubCode,
                                 dwRetryCount,
                                 &pSignature,
                                 &dwLength );

		if ( dwError != NO_ERROR )
        {
            break;
        }

        pSendHeader->wLength += (WORD)dwLength;

        //
        // Convert length to network order
        //

		pSendHeader->wLength = htons( pSendHeader->wLength );

        //
		// set encryption block for accounting packets
        //

		if ( pSendHeader->bCode == ptAccountingRequest )
	    {
			RadiusServer.IPAddress.sin_port =   
                                        htons((SHORT)RadiusServer.AcctPort);
			
			ZeroMemory( pSendHeader->rgAuthenticator, 
                        sizeof(pSendHeader->rgAuthenticator));

			MD5Init( &MD5c );

			MD5Update( &MD5c, szSendBuffer, ntohs(pSendHeader->wLength ));

			MD5Update( &MD5c,   
                       (PBYTE) RadiusServer.szSecret, 
                       RadiusServer.cbSecret);

			MD5Final(&MD5d, &MD5c);
			
			CopyMemory( pSendHeader->rgAuthenticator, 
                        MD5d.digest, 
                        sizeof(pSendHeader->rgAuthenticator));
	    }
		else
		{
			RadiusServer.IPAddress.sin_port = 
                                        htons((SHORT) RadiusServer.AuthPort);
        }

        //
        // If a Signature field is present we need to sign it
        //

        if ( pSignature != NULL )
        {
            HmacContext HmacMD5c;
            MD5Digest   MD5d;

			HmacMD5Init( &HmacMD5c, 
                        (PBYTE) RadiusServer.szSecret, 
                        RadiusServer.cbSecret);

			HmacMD5Update( &HmacMD5c, 
                           szSendBuffer, 
                           ntohs(pSendHeader->wLength) );

			HmacMD5Final( &MD5d, &HmacMD5c );

			CopyMemory( (pSignature+2), MD5d.digest, 16 ); 
        }

        //
		// Create a Datagram socket
        //

		SockServer = socket( AF_INET, SOCK_DGRAM, 0 );

		if ( SockServer == INVALID_SOCKET )
        {
            dwError = WSAGetLastError();
            RADIUS_TRACE1("Socket failed with error %d", dwError );
            break;
        }

        if ( RadiusServer.nboNASIPAddress != INADDR_NONE )
        {
    		if ( bind( SockServer, 
                          (PSOCKADDR)&RadiusServer.NASIPAddress, 
                          sizeof(RadiusServer.NASIPAddress) ) == SOCKET_ERROR )
            {
                dwError = WSAGetLastError();
                RADIUS_TRACE1("Bind failed with error %d", dwError );
                break;
            }
        }

		if ( connect( SockServer, 
                      (PSOCKADDR)&RadiusServer.IPAddress, 
                      sizeof(RadiusServer.IPAddress) ) == SOCKET_ERROR )
        {
            dwError = WSAGetLastError();
            RADIUS_TRACE1("Connect failed with error %d", dwError );
            break;
        }

        RADIUS_TRACE("Sending packet to radius server");

		TraceSendPacket( szSendBuffer, ntohs( pSendHeader->wLength ) );

        //
		// Send packet if server doesn't respond within a give amount of time.
        //

        if ( send( SockServer,  
                   (PCSTR)szSendBuffer,     
                   ntohs(pSendHeader->wLength), 0) == SOCKET_ERROR )
        {
            dwError = GetLastError();

            break;
        }

		FD_ZERO(&fdsSocketRead);
		FD_SET(SockServer, &fdsSocketRead);

		if ( select( 0, &fdsSocketRead, NULL, NULL, 
                     RadiusServer.Timeout.tv_sec == 0 
                        ? NULL 
                        : &RadiusServer.Timeout ) < 1 )
	    {
            //
            // Server didn't respond to any of the requests. 
            // time to quit asking
            //

			ValidateRadiusServer( 
                               &RadiusServer, 
                               FALSE,
		                       !( pSendHeader->bCode == ptAccountingRequest ) );

            RADIUS_TRACE("Timeout: Radius server did not respond");

			dwError = ERROR_AUTH_SERVER_TIMEOUT;

            break;
        }

        AttrLength = recv( SockServer, (PSTR)szRecvBuffer, MAXBUFFERSIZE, 0 );

	    if ( AttrLength == SOCKET_ERROR )
        {
            //
            // A response from the machine that the server is not 
            // running at the designated port.
            //
                        
            ValidateRadiusServer( &RadiusServer, 
                                  FALSE,
		                          !(pSendHeader->bCode == ptAccountingRequest));

            RADIUS_TRACE( "Radius server not running at specifed IPaddr/port");

	        dwError = ERROR_AUTH_SERVER_TIMEOUT;

            break;
        }

        //
        // Response received from server. First update the score for
        // this server
        //

		ValidateRadiusServer( &RadiusServer, 
                              TRUE,
		                      !( pSendHeader->bCode == ptAccountingRequest ));

        pRecvHeader = (PRADIUS_PACKETHEADER) szRecvBuffer;

        RADIUS_TRACE("Received packet from radius server");
		TraceRecvPacket(szRecvBuffer, ntohs(pRecvHeader->wLength));

        dwError = VerifyPacketIntegrity( AttrLength,
                                         pRecvHeader,
		                                 pSendHeader,
                                         &RadiusServer,
                                         pRecvHeader->bCode,
                                         &dwExtError,
                                         &dwNumAttributes );

        if ( dwError == NO_ERROR )
        {
            //
            // Convert to Router attribute format
            //

            dwError = Radius2Router(
                                    pRecvHeader,
                                    &RadiusServer,
                                    (PBYTE)(pSendHeader->rgAuthenticator),
                                    dwNumAttributes,
                                    &dwExtError,
                                    pprgOutAttributes,
                                    pfEapMessageReceived );
        }

        if ( dwError == ERROR_INVALID_RADIUS_RESPONSE )
        {
            LPWSTR auditstrp[2];
            auditstrp[0] = RadiusServer.wszName;

            RadiusLogWarningString( ROUTERLOG_INVALID_RADIUS_RESPONSE,
                              1, auditstrp, dwExtError, 1 );

            dwError = ERROR_AUTH_SERVER_TIMEOUT;
        }
        else 
        {
            *pbCode = pRecvHeader->bCode;
        }

    } while( FALSE );

    if ( SockServer != INVALID_SOCKET )
    {
        closesocket( SockServer );
    }

	return( dwError );
} 

//**
//
// Call:        VerifyPacketIntegrity
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
VerifyPacketIntegrity(
    IN  DWORD                           cbPacketLength,
    IN  RADIUS_PACKETHEADER	UNALIGNED * pRecvHeader,
    IN  RADIUS_PACKETHEADER	UNALIGNED * pSendHeader,
    IN  RADIUSSERVER *			        pRadiusServer,
    IN  BYTE                            bCode,
    OUT DWORD *                         pdwExtError,
    OUT DWORD *                         lpdwNumAttributes
)
{
    struct MD5Context	            MD5c;
	struct MD5Digest	            MD5d;
    RADIUS_ATTRIBUTE UNALIGNED *    prgRadiusWalker;
    LONG                            cbLengthOfRadiusAttributes;
    LONG                            cbLength;

    *pdwExtError = 0;
    *lpdwNumAttributes = 0;

    if ( ( cbPacketLength < 20 )                                      ||
         ( ntohs( pRecvHeader->wLength ) != cbPacketLength )          || 
         ( pRecvHeader->bIdentifier != pSendHeader->bIdentifier ) )
    {
        RADIUS_TRACE("Recvd packet with invalid length/Id from server");

        *pdwExtError = ERROR_INVALID_PACKET_LENGTH_OR_ID;

        return( ERROR_INVALID_RADIUS_RESPONSE );
    }

    //
    // Convert length from network order
    //

    cbLength = ntohs( pRecvHeader->wLength ) - sizeof( RADIUS_PACKETHEADER );

    cbLengthOfRadiusAttributes = cbLength;

    prgRadiusWalker = (PRADIUS_ATTRIBUTE)(pRecvHeader + 1);

    //
    // Count the number of attributes to determine the size of the out
    // parameters table. The length of each attribute has to be at least 2.
    //

    while ( cbLengthOfRadiusAttributes > 1 )
    {
        (*lpdwNumAttributes)++;

        if ( prgRadiusWalker->bLength < 2 )
        {
            RADIUS_TRACE("Recvd packet with attribute of length less than 2");

            *pdwExtError = ERROR_INVALID_ATTRIBUTE_LENGTH;

            return( ERROR_INVALID_RADIUS_RESPONSE );
        }

        if ( prgRadiusWalker->bLength > cbLengthOfRadiusAttributes )
        {
            RADIUS_TRACE("Recvd packet with attribute with illegal length ");

            *pdwExtError = ERROR_INVALID_ATTRIBUTE_LENGTH;

            return( ERROR_INVALID_RADIUS_RESPONSE );
        }

        //
        // If this is Microsoft VSA then validate it and findout how many
        // subattributes there are
        //

        if ( ( prgRadiusWalker->bType == raatVendorSpecific )   &&
             ( prgRadiusWalker->bLength > 6 )                   && 
             ( WireToHostFormat32( (PBYTE)(prgRadiusWalker+1) ) == 311 ) )
        {
            PBYTE pVSAWalker  = (PBYTE)(prgRadiusWalker+1)+4;
            DWORD cbVSALength = prgRadiusWalker->bLength -
                                        sizeof( RADIUS_ATTRIBUTE ) - 4;

            (*lpdwNumAttributes)--;

            while( cbVSALength > 1 )
            {
                (*lpdwNumAttributes)++;

                if ( *(pVSAWalker+1) < 2 )
                {
                    RADIUS_TRACE("VSA attribute has incorrect length");

                    *pdwExtError = ERROR_INVALID_ATTRIBUTE_LENGTH;

                    return( ERROR_INVALID_RADIUS_RESPONSE );
                }

                if ( *(pVSAWalker+1) > cbVSALength )
                {
                    RADIUS_TRACE("VSA attribute has incorrect length");

                    *pdwExtError = ERROR_INVALID_ATTRIBUTE_LENGTH;

                    return( ERROR_INVALID_RADIUS_RESPONSE );
                }

                cbVSALength -= *(pVSAWalker+1);
                pVSAWalker += *(pVSAWalker+1);
            }

            if ( cbVSALength != 0 )
            {
                RADIUS_TRACE("VSA attribute has incorrect length");

                *pdwExtError = ERROR_INVALID_ATTRIBUTE_LENGTH;

                return( ERROR_INVALID_RADIUS_RESPONSE );
            }
        }

        cbLengthOfRadiusAttributes -= prgRadiusWalker->bLength;

        prgRadiusWalker = (PRADIUS_ATTRIBUTE)
                            (((PBYTE)prgRadiusWalker)+prgRadiusWalker->bLength);
    }

    if ( cbLengthOfRadiusAttributes != 0 )
    {
        RADIUS_TRACE("Received invalid packet from radius server");

        *pdwExtError = ERROR_INVALID_PACKET;

        return( ERROR_INVALID_RADIUS_RESPONSE );
    }

    RADIUS_TRACE1("Total number of Radius attributes returned = %d",
                  *lpdwNumAttributes );

    switch( bCode )
    {
        case ptAccessReject:
        case ptAccessAccept:
	    case ptAccessChallenge:
        case ptAccountingResponse:
    
            //
            // Validate response authenticator with request authenticator
            //

            MD5Init( &MD5c );

            //
            // Code+Id+Length of Response
            //

            MD5Update( &MD5c, (PBYTE)pRecvHeader, 4 );

            //
            // Request authenticator
            //

            MD5Update( &MD5c, (PBYTE)(pSendHeader->rgAuthenticator), 16 );

            //
            // Response attributes
            //

            MD5Update( &MD5c, 
                       (PBYTE)(pRecvHeader+1), 
		               ntohs(pRecvHeader->wLength)-sizeof(RADIUS_PACKETHEADER));

            //
            // Shared secret
            //

            MD5Update( &MD5c,
                       (PBYTE)(pRadiusServer->szSecret),
                       pRadiusServer->cbSecret );

            MD5Final(&MD5d, &MD5c);

            //
            // This must match the Response Authenticator   
            //
    
            if ( memcmp( &MD5d.digest, pRecvHeader->rgAuthenticator, 16 ) != 0 )
            {
                RADIUS_TRACE("Authenticator does not match.");

                *pdwExtError = ERROR_AUTHENTICATOR_MISMATCH;

                return( ERROR_INVALID_RADIUS_RESPONSE );
            }

            break;

        case ptStatusServer:
        case ptStatusClient:
        case ptAcctStatusType:
        default:

            RADIUS_TRACE("Received invalid packet from radius server");

            *pdwExtError = ERROR_INVALID_PACKET;

            return( ERROR_INVALID_RADIUS_RESPONSE );

            break;
    }

    return( NO_ERROR );
}

//**
//
// Call:        SendData2ServerWRetry
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD 
SendData2ServerWRetry(
    IN  PRAS_AUTH_ATTRIBUTE prgInAttributes, 
    OUT PRAS_AUTH_ATTRIBUTE *pprgOutAttributes, 
    OUT BYTE *              pbCode, 
    IN  BYTE                bSubCode,
    OUT BOOL *              pfEapMessageReceived 
)
{
    DWORD   dwError      = NO_ERROR;
    DWORD   dwRetryCount = 0;
	DWORD   cRetries     = ( bSubCode == atInvalid) 
                                ? g_cAuthRetries 
                                : g_cAcctRetries;
	LONG    lPacketID;

	InterlockedIncrement( &g_lPacketID );

	lPacketID = InterlockedExchange( &g_lPacketID, g_lPacketID );
	
	while( cRetries-- > 0 )
    {
		switch( *pbCode )
		{
		case ptAccountingRequest:
		    InterlockedIncrement( &g_cAcctReqSent );
			break;
				
	    case ptAccessRequest:
			InterlockedIncrement( &g_cAuthReqSent );
		    break;
    
        default:
            break;
        }
			
		dwError = SendData2Server( prgInAttributes, 
                                   pprgOutAttributes, 
                                   pbCode, 
                                   bSubCode, 
                                   lPacketID,
                                   dwRetryCount++,
                                   pfEapMessageReceived );

		if ( dwError != ERROR_AUTH_SERVER_TIMEOUT )
        {
			break;
        }

		switch( *pbCode )
	    {
	    case ptAccountingRequest:
		    InterlockedIncrement( &g_cAcctReqTimeout );
			break;
				
	    case ptAccessRequest:
			InterlockedIncrement( &g_cAuthReqTimeout );
			break;

        default:
            break;
	    }
    }

	return( dwError );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\auth\radius\radclnt.h ===
/********************************************************************/
/**          Copyright(c) 1985-1998 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    radclnt.h
//
// Description: 
//
// History:     Feb 11,1998	    NarenG		Created original version.
//

#ifndef RADCLNT_H
#define RADCLNT_H

#include <winsock.h>
#include <rasauth.h>
#include <raserror.h>
#include <mprerror.h>
#include <rtutils.h>

#define PSZAUTHRADIUSSERVERS        \
    TEXT("SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Authentication\\Providers\\{1AA7F83F-C7F5-11D0-A376-00C04FC9DA04}\\Servers")

#define PSZACCTRADIUSSERVERS        \
    TEXT("SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Accounting\\Providers\\{1AA7F840-C7F5-11D0-A376-00C04FC9DA04}\\Servers")

#define PSZTIMEOUT              TEXT("Timeout")
#define PSZAUTHPORT             TEXT("AuthPort")
#define PSZACCTPORT             TEXT("AcctPort")
#define PSZENABLEACCTONOFF      TEXT("EnableAccountingOnOff")
#define PSZSCORE                TEXT("Score")
#define PSZRETRIES              TEXT("Retries")
#define PSZSENDSIGNATURE        TEXT("SendSignature")
#define PSZNASIPADDRESS         "NASIPAddress"

//
// Matches max RADIUS packet size
//

#define MAXBUFFERSIZE           4096

//
// defines for perfmon
//

#define RADIUS_CLIENT_COUNTER_OBJECT                0

// ADD

#define AUTHREQSENT                                 2
#define AUTHREQFAILED                               4
#define AUTHREQSUCCEDED                             6
#define AUTHREQTIMEOUT                              8
#define ACCTREQSENT                                 10
#define ACCTBADPACK                                 12
#define ACCTREQSUCCEDED                             14
#define ACCTREQTIMEOUT                              16
#define AUTHBADPACK                                 18

//
// Trace flags
//

#define TRACE_PACKETS           (0x00020000|TRACE_USE_MASK|TRACE_USE_MSEC)
#define TRACE_RADIUS            (0x00080000|TRACE_USE_MASK|TRACE_USE_MSEC)

extern DWORD    g_dwTraceID;
extern HANDLE   g_hLogEvents;

#define RADIUS_TRACE(a)         TracePrintfExA(g_dwTraceID,TRACE_RADIUS,a)
#define RADIUS_TRACE1(a,b)      TracePrintfExA(g_dwTraceID,TRACE_RADIUS,a,b)
#define RADIUS_TRACE2(a,b,c)    TracePrintfExA(g_dwTraceID,TRACE_RADIUS,a,b,c)
#define RADIUS_TRACE3(a,b,c,d)  TracePrintfExA(g_dwTraceID,TRACE_RADIUS,a,b,c,d)

#define TraceSendPacket(pbBuffer, cbLength) \
    TraceDumpExA(g_dwTraceID, TRACE_PACKETS, pbBuffer, cbLength, 1, FALSE, "<")

#define TraceRecvPacket(pbBuffer, cbLength) \
    TraceDumpExA(g_dwTraceID, TRACE_PACKETS, pbBuffer, cbLength, 1, FALSE, ">")

//
// Event Logging macros
//

#define RadiusLogWarning( LogId, NumStrings, lpwsSubStringArray )   \
    RouterLogWarning( g_hLogEvents, LogId,                          \
                      NumStrings, lpwsSubStringArray, 0 )

#define RadiusLogWarningString(LogId,NumStrings,lpwsSubStringArray,dwRetCode,\
                          dwPos )                                            \
    RouterLogWarningString( g_hLogEvents, LogId, NumStrings,                 \
                          lpwsSubStringArray, dwRetCode, dwPos )

#define RadiusLogError( LogId, NumStrings, lpwsSubStringArray, dwRetCode )  \
    RouterLogError( g_hLogEvents, LogId,                                    \
                    NumStrings, lpwsSubStringArray, dwRetCode )

#define RadiusLogErrorString(LogId,NumStrings,lpwsSubStringArray,dwRetCode, \
                          dwPos )                                           \
    RouterLogErrorString( g_hLogEvents, LogId, NumStrings,                  \
                          lpwsSubStringArray, dwRetCode, dwPos )

#define RadiusLogInformation( LogId, NumStrings, lpwsSubStringArray )       \
    RouterLogInformation( g_hLogEvents,                                     \
                          LogId, NumStrings, lpwsSubStringArray, 0 )

//
// Enumeration of RADIUS codes 
//

typedef enum
{
	ptMinimum				= 0,

	ptAccessRequest			= 1,
	ptAccessAccept			= 2,
	ptAccessReject			= 3,
	ptAccountingRequest		= 4,
	ptAccountingResponse	= 5,
	ptAccessChallenge		= 11,
	ptStatusServer			= 12,
	ptStatusClient			= 13,

	ptAcctStatusType		= 40,
		
	ptMaximum				= 255,

} RADIUS_PACKETTYPE;
	

//
// Enumeration of (some of the) attribute types.
//

typedef enum
{
	atStart				= 1,
	atStop				= 2,
	atInterimUpdate	    = 3,
	
	atAccountingOn		= 7,
	atAccountingOff		= 8,

	atInvalid			= 255

} RADIUS_ACCOUNTINGTYPE;

		
//
// Use BYTE alignment
//

#pragma pack(push, 1)

#define MAX_AUTHENTICATOR						16

typedef struct
{
	BYTE bCode;	        // Indicates type of packet. Request, Accept, Reject...
	BYTE bIdentifier;	// Unique identifier for the packet.
	WORD wLength;	    // length of packet including header in network byte 
                        // order
	BYTE rgAuthenticator[MAX_AUTHENTICATOR];

} RADIUS_PACKETHEADER, *PRADIUS_PACKETHEADER;
	
typedef struct
{
	BYTE bType;    // Indicates type of attribute. UserName, UserPassword, ...
	BYTE bLength;  // length of attribute
	               // Variable length Value
} RADIUS_ATTRIBUTE, *PRADIUS_ATTRIBUTE;
	
#pragma pack(pop)


//
// 5 seconds for default timeout to server requests
//

#define DEFTIMEOUT				5
#define DEFAUTHPORT				1812
#define DEFACCTPORT				1813

#define MAXSCORE				30
#define INCSCORE				3
#define DECSCORE				2
#define MINSCORE				0

typedef struct RadiusServer
{
    LIST_ENTRY  ListEntry;
	DWORD		cbSecret;			    // length of multibyte secret password
	struct timeval  Timeout;		    // recv timeout in seconds
	INT		    cScore;				    // Score indicating functioning power 
                                        // of server.
    BOOL        fSendSignature;         // Send signature attribute or not
	DWORD	    AuthPort;			    // Authentication port number
	DWORD	    AcctPort;			    // Accounting port number
	BOOL	    fAccountingOnOff;	    // Enable accounting On/Off messages
	BYTE	    bIdentifier;		    // Unique ID for packet
	LONG	    lPacketID;			    // Global Packet ID across all servers
    BOOL        fDelete;                // Flag indicates this should be removed
    DWORD       nboNASIPAddress;        // IP Address to bind to
	SOCKADDR_IN NASIPAddress;           // IP Address to bind to
	SOCKADDR_IN IPAddress;			    // IP Address of radius server
	WCHAR		wszName[MAX_PATH+1];	// Name of radius server
	WCHAR	    wszSecret[MAX_PATH+1];  // secret password to encrypt packets
	CHAR		szSecret[MAX_PATH+1];	// multibyte secret password

} RADIUSSERVER, *PRADIUSSERVER;
	

VOID
InitializeRadiusServerList(
    IN BOOL fAuthentication
);

VOID
FreeRadiusServerList(
    IN BOOL fAuthentication
);

DWORD
AddRadiusServerToList(
    IN RADIUSSERVER *   pRadiusServer,
    IN BOOL             fAuthentication
);

RADIUSSERVER *
ChooseRadiusServer(
    IN RADIUSSERVER *   pRadiusServer,
    IN BOOL             fAccounting,
    IN LONG             lPacketID
);

VOID
ValidateRadiusServer(
    IN RADIUSSERVER *   pServer,
    IN BOOL             fResponding,
    IN BOOL             fAuthentication
);

DWORD
ReloadConfig(
    IN BOOL             fAuthentication
);

DWORD 
LoadRadiusServers(
    IN BOOL fAuthenticationServers
);

BOOL 
NotifyServer(
    IN BOOL             fStart,
    IN RADIUSSERVER *   pServer
);

DWORD
Router2Radius(
    RAS_AUTH_ATTRIBUTE *            prgRouter,
    RADIUS_ATTRIBUTE UNALIGNED *    prgRadius,
    RADIUSSERVER UNALIGNED *        pRadiusServer,
    RADIUS_PACKETHEADER UNALIGNED * pHeader,
    BYTE                            bSubCode,
    DWORD                           dwRetryCount,
    PBYTE *                         ppSignature,
    DWORD *                         pAttrLength
);

DWORD
Radius2Router(
	IN	RADIUS_PACKETHEADER	UNALIGNED * pRecvHeader,
    IN  RADIUSSERVER UNALIGNED *        pRadiusServer, 
    IN  PBYTE                           pRequestAuthenticator,
    IN  DWORD                           dwNumAttributes,
    OUT DWORD *                         pdwExtError,
    OUT PRAS_AUTH_ATTRIBUTE *           pprgRouter,
    OUT BOOL *                          fEapMessageReceived
);

DWORD 
SendData2ServerWRetry(
    IN  PRAS_AUTH_ATTRIBUTE prgInAttributes, 
    IN  PRAS_AUTH_ATTRIBUTE *pprgOutAttributes, 
    OUT BYTE *              pbCode, 
    IN  BYTE                bSubCode,
    OUT BOOL *              pfEapMessageReceived
);

DWORD 
RetrievePrivateData(
    WCHAR *pszServerName, 
    WCHAR *pszSecret
);

DWORD
VerifyPacketIntegrity(
    IN  DWORD                           cbPacketLength,
    IN  RADIUS_PACKETHEADER	UNALIGNED * pRecvHeader,
    IN  RADIUS_PACKETHEADER	UNALIGNED * pSendHeader,
    IN  RADIUSSERVER *			        pRadiusServer,
    IN  BYTE                            bCode,
    OUT DWORD *                         pdwExtError,
    OUT DWORD *                         lpdwNumAttributes
);

DWORD
EncryptPassword(
    IN RAS_AUTH_ATTRIBUTE *             prgRouter,
    IN RADIUS_ATTRIBUTE UNALIGNED *     prgRadius,
    IN RADIUSSERVER UNALIGNED *         pRadiusServer,
    IN RADIUS_PACKETHEADER UNALIGNED *  pHeader,
    IN BYTE                             bSubCode
);

DWORD
DecryptMPPEKeys(
    IN      RADIUSSERVER UNALIGNED * pRadiusServer,
    IN      PBYTE                    pRequestAuthenticator,
    IN OUT  PBYTE                    pEncryptionKeys
);

DWORD
DecryptMPPESendRecvKeys(
    IN      RADIUSSERVER UNALIGNED * pRadiusServer,
    IN      PBYTE                    pRequestAuthenticator,
    IN      DWORD                    dwLength,
    IN OUT  PBYTE                    pEncryptionKeys
);

//
// globals
//

#ifdef ALLOCATE_GLOBALS
#define GLOBALS
#define EXTERN
#else
#define EXTERN extern
#endif

EXTERN 
LONG g_lPacketID
#ifdef GLOBALS
    = 0
#endif
;

EXTERN 
DWORD g_dwTraceID
#ifdef GLOBALS
    = INVALID_TRACEID
#endif
;

EXTERN 
HANDLE g_hLogEvents                   
#ifdef GLOBALS
    = INVALID_HANDLE_VALUE
#endif
;

EXTERN 
BOOL fWinsockInitialized            
#ifdef GLOBALS
    = FALSE
#endif
;

EXTERN 
RAS_AUTH_ATTRIBUTE * g_pServerAttributes            
#ifdef GLOBALS
    = NULL
#endif
;

EXTERN 
LIST_ENTRY g_AuthServerListHead;        // Linked list of valid radius servers

EXTERN 
CRITICAL_SECTION g_csAuth;               // used to prevent multiple access to 

EXTERN
LIST_ENTRY g_AcctServerListHead;        // Linked list of valid radius servers

WCHAR * g_pszCurrentServer;        // current radius server being used

EXTERN
DWORD g_cAuthRetries                    // #of times to resend packets
#ifdef GLOBALS
    = 2
#endif
;

EXTERN
DWORD g_cAcctRetries                    // #of times to resend packets
#ifdef GLOBALS
    = 2
#endif
;

EXTERN
CRITICAL_SECTION g_csAcct;              // used to prevent multiple access to

extern LONG         g_cAuthReqSent;         // Auth Requests Sent
extern LONG         g_cAuthReqFailed;       // Auth Requests Failed
extern LONG         g_cAuthReqSucceded;     // Auth Requests Succeded
extern LONG         g_cAuthReqTimeout;      // Auth Requests timeouts
extern LONG         g_cAcctReqSent;         // Acct Requests Sent
extern LONG         g_cAcctBadPack;         // Acct Bad Packets
extern LONG         g_cAcctReqSucceded;     // Acct Requests Succeded
extern LONG         g_cAcctReqTimeout;      // Acct Requests timeouts
extern LONG         g_cAuthBadPack;         // Auth bad Packets

#endif // RADCLNT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\common\encrypt.c ===
/* Copyright (c) 1994, Microsoft Corporation, all rights reserved
**
** encrypt.c
** Remote Access
** Encryption check routine
**
** 06/16/94 Steve Cobb
**
** Note: This is in a separate file because it requires version.lib which is
**       not otherwise needed by many utility library users.
*/

#include <windows.h>
#include <stdlib.h>
#include <string.h>
#define INCL_ENCRYPT
#include <ppputil.h>


BOOL
IsEncryptionPermitted()

    /* Returns true if encryption is permitted in this version of the product,
    ** false if not.  Currently encryption is allowed unless the NT shell
    ** language(s) include French for France.  If any errors occur attempting
    ** to retrieve the information, encryption is not allowed.
    */
{
    BOOL  fStatus = FALSE;
    CHAR  szUser32DllPath[ MAX_PATH + 1 ];
    DWORD dwUnused;
    CHAR* pVersionInfo = NULL;
    DWORD cbVersionInfo;
    WORD* pTranslationInfo;
    DWORD cbTranslationInfo;
    DWORD cTranslations;
    DWORD i;

    do
    {
        /* Find the path to USER32.DLL.
        */
        if (GetSystemDirectory( szUser32DllPath, MAX_PATH + 1 ) == 0)
            break;

        strcat( szUser32DllPath, "\\USER32.DLL" );

        /* Retrieve the version information for USER32.DLL.
        */
        cbVersionInfo = GetFileVersionInfoSize( szUser32DllPath, &dwUnused );

        if (!(pVersionInfo = malloc( cbVersionInfo )))
            break;

        if (!GetFileVersionInfo(
                szUser32DllPath, 0, cbVersionInfo, pVersionInfo ))
        {
            break;
        }

        /* Find the table of language/char-set identifier pairs indicating the
        ** language(s) available in the file.
        */
        if (!VerQueryValue(
                pVersionInfo, "\\VarFileInfo\\Translation",
                (LPVOID )&pTranslationInfo, &cbTranslationInfo ))
        {
            break;
        }

        /* Scan the table for French for France.
        */
        cTranslations = cbTranslationInfo / sizeof(DWORD);

        for (i = 0; i < cTranslations; ++i)
        {
            if (pTranslationInfo[ i * 2 ] == 0x040C)
                break;
        }

        if (i < cTranslations)
            break;

        /* No French for France so encryption is permitted.
        */
        fStatus = TRUE;
    }
    while (FALSE);

    if (pVersionInfo)
        free( pVersionInfo );

    return fStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\auth\radius\test\radtest.cpp ===
#include <windows.h>
#include <assert.h>
#include <stdio.h>

#include "radclnt.h"

DWORD TestAuthenticateProc(DWORD dwValid);
DWORD TestAccountingProc(DWORD dwValid);
/*
int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hInstPrev, LPSTR lpszCmd, int CmdShow)
{
	RAS_AuthInitialize();

	RAS_AuthSetup();

	return (0);
}
*/
// ================================== main =============================

int main(int argc, char *argv[])
{
	DWORD				dwTID, cClients = 1, iClient;
	HANDLE				hrgThread[1000];

	if (argc > 1)
		cClients = atoi(argv[1]);
		
	RAS_AuthInitialize();

	for (iClient = 0; iClient < cClients; iClient ++)
		{
		if (rand() % 2)
			hrgThread[iClient] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) TestAccountingProc, (LPVOID) (iClient % 2), 0, &dwTID);
		else
			hrgThread[iClient] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) TestAuthenticateProc, (LPVOID) (iClient % 2), 0, &dwTID);
		}

	for (iClient = 0; iClient < cClients; iClient ++)
		{
		WaitForSingleObject(hrgThread[iClient], 30000);
		CloseHandle(hrgThread[iClient]);
		}
	
	RAS_AuthTerminate();

	return (0);
} // main()

// ============================= TestAuthenticateProc ============================

DWORD TestAuthenticateProc(DWORD dwValid)
{
	BYTE					szTemp[1024];
	PAUTH_ATTRIBUTE			prgAttr;
	BOOL					fAuthenticated;
	
	prgAttr = (PAUTH_ATTRIBUTE) szTemp;
	
	prgAttr->dwType		= atUserName;
	lstrcpy((PSTR) (prgAttr + 1), "vijayb@hardcoresoftware.com");
	prgAttr->dwLength	= lstrlen((PSTR) (prgAttr + 1));
///	lstrcpy((PSTR) (prgAttr + 1), "dondu");
///	prgAttr->bLength	= lstrlen((PSTR) (prgAttr + 1));
	prgAttr = (PAUTH_ATTRIBUTE) ((PBYTE) prgAttr + prgAttr->dwLength);
	prgAttr ++;
	
	prgAttr->dwType		= atUserPassword;
	if (dwValid)
		lstrcpy((PSTR) (prgAttr + 1), "Password");
	else
		lstrcpy((PSTR) (prgAttr + 1), "Passwork");
	
	prgAttr->dwLength	= lstrlen((PSTR) (prgAttr + 1));
	prgAttr = (PAUTH_ATTRIBUTE) ((PBYTE) prgAttr + prgAttr->dwLength);
	prgAttr ++;
	
	prgAttr->dwType		= atMinimum;
	if (RAS_Autenticate((PAUTH_ATTRIBUTE) szTemp, &prgAttr, &fAuthenticated) == ERROR_SUCCESS)
		{
		LocalFree(prgAttr);
		if (dwValid)
			assert(fAuthenticated == TRUE);
		else
			assert(fAuthenticated == FALSE);
			
		switch (fAuthenticated)
			{
			case TRUE:
				printf("Access Accept\n");
				break;
			case FALSE:
				printf("Access Reject\n");
				break;
			default:
				printf("Unknown Packet Type\n");
				break;
			}
		}
	else
		{
		TCHAR			szBuffer[MAX_PATH];

		szBuffer[0] = 0;
		FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, GetLastError(), 0, szBuffer, MAX_PATH, NULL);
		printf("Packet Lost = %s", szBuffer);
		}
		
	return (0);	
} // TestAuthenticateProc()


// ============================= TestAccountingProc ============================

DWORD TestAccountingProc(DWORD dwValid)
{
	BYTE					szTemp[1024];
	PAUTH_ATTRIBUTE			prgAttr;
	BOOL					fSent;
	
	prgAttr = (PAUTH_ATTRIBUTE) szTemp;
	
	prgAttr->dwType		= atUserName;
	lstrcpy((PSTR) (prgAttr + 1), "vijayb@hardcoresoftware.com");
	prgAttr->dwLength	= lstrlen((PSTR) (prgAttr + 1));
	prgAttr = (PAUTH_ATTRIBUTE) ((PBYTE) prgAttr + prgAttr->dwLength);
	prgAttr ++;

	prgAttr->dwType		= atNASIPAddress;
	*((PDWORD) (prgAttr + 1)) = inet_addr("206.63.141.134");
	prgAttr->dwLength	= 4;
	prgAttr = (PAUTH_ATTRIBUTE) ((PBYTE) prgAttr + prgAttr->dwLength);
	prgAttr ++;
	
	prgAttr->dwType		= atMinimum;
	if (RAS_StartAccounting((PAUTH_ATTRIBUTE) szTemp, &prgAttr, &fSent) == ERROR_SUCCESS)
		{
		LocalFree(prgAttr);
			
		switch (fSent)
			{
			case TRUE:
				printf("Accounting Response\n");
				break;
			case FALSE:
				printf("NO RESPONSE\n");
				break;
			default:
				printf("Unknown Packet Type\n");
				break;
			}
		}
	else
		{
		TCHAR			szBuffer[MAX_PATH];

		szBuffer[0] = 0;
		FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, GetLastError(), 0, szBuffer, MAX_PATH, NULL);
		printf("Packet Lost = %s", szBuffer);
		}
		
	return (0);	
} // TestAccountingProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\common\attrib.c ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    attrib.c
//
// Description: Contains code to manipulate RAS_AUTH_ATTRIBUTE structures
//
// History:     Feb 11,1997	    NarenG		Created original version.
//

#define UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <rtutils.h>
#include <lmcons.h>
#include <rasauth.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#define INCL_RASAUTHATTRIBUTES
#define INCL_HOSTWIRE
#include "ppputil.h"

//**
//
// Call:        RasAuthAttributeCreate
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will create an array of attributes plus one for the terminator
//
RAS_AUTH_ATTRIBUTE *
RasAuthAttributeCreate(
    IN DWORD    dwNumAttributes
)
{
    RAS_AUTH_ATTRIBUTE * pAttributes;
    DWORD                dwIndex;

    pAttributes = (RAS_AUTH_ATTRIBUTE * )
                    LocalAlloc(LPTR,
                             sizeof( RAS_AUTH_ATTRIBUTE )*(1+dwNumAttributes));


    if ( pAttributes == NULL )
    {
        return( NULL );
    }

    //
    // Initialize
    //

    for( dwIndex = 0; dwIndex < dwNumAttributes; dwIndex++ )
    {
        pAttributes[dwIndex].raaType  = raatReserved;
        pAttributes[dwIndex].dwLength = 0;
        pAttributes[dwIndex].Value    = NULL;
    }

    //
    // Terminate
    //

    pAttributes[dwNumAttributes].raaType  = raatMinimum;
    pAttributes[dwNumAttributes].dwLength = 0;
    pAttributes[dwNumAttributes].Value    = NULL;

    return( pAttributes );
}

//**
//
// Call:        RasAuthAttributeDestroy
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will free up all allocated memory occupied by the attributes
//              structure
//
VOID
RasAuthAttributeDestroy(
    IN RAS_AUTH_ATTRIBUTE * pAttributes
)
{
    DWORD dwIndex;

    if ( NULL == pAttributes )
    {
        return;
    }

    for( dwIndex = 0; pAttributes[dwIndex].raaType != raatMinimum; dwIndex++ )
    {
        switch( pAttributes[dwIndex].raaType )
        {
        case raatUserName:
        case raatUserPassword:
        case raatMD5CHAPPassword:
        case raatFilterId:
        case raatReplyMessage:
        case raatCallbackNumber:
        case raatCallbackId:
        case raatFramedRoute:
        case raatState:
        case raatClass:
        case raatVendorSpecific:
        case raatCalledStationId:
        case raatCallingStationId:
        case raatNASIdentifier:
        case raatProxyState:
        case raatLoginLATService:
        case raatLoginLATNode:
        case raatLoginLATGroup:
        case raatFramedAppleTalkZone:
        case raatAcctSessionId:
        case raatAcctMultiSessionId:
        case raatMD5CHAPChallenge:
        case raatLoginLATPort:
        case raatTunnelClientEndpoint:
        case raatTunnelServerEndpoint:
        case raatARAPPassword:
        case raatARAPFeatures:
        case raatARAPSecurityData:
        case raatConnectInfo:
        case raatConfigurationToken:
        case raatEAPMessage:
        case raatSignature:
        case raatARAPChallengeResponse:
		case raatCertificateOID:
            //
            // Allocated memory here so free it
            //

            if ( pAttributes[dwIndex].Value != NULL )
            {
                ZeroMemory( pAttributes[dwIndex].Value,
                            pAttributes[dwIndex].dwLength);

                LocalFree( pAttributes[dwIndex].Value );
            }

            break;

        case raatReserved:

            //
            // Do nothing to uninitialized values
            //

        default:

            //
            // DWORDs, USHORTs or BYTEs so do nothing
            //

            break;
        }
    }

    LocalFree( pAttributes );
}

//**
//
// Call:        RasAuthAttributeGet
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
RAS_AUTH_ATTRIBUTE *
RasAuthAttributeGet(
    IN RAS_AUTH_ATTRIBUTE_TYPE  raaType,
    IN RAS_AUTH_ATTRIBUTE *     pAttributes
)
{
    DWORD dwIndex;

    if ( pAttributes == NULL )
    {
        return( NULL );
    }

    for( dwIndex = 0; pAttributes[dwIndex].raaType != raatMinimum; dwIndex++ )
    {
        if ( pAttributes[dwIndex].raaType == raaType )
        {
            return( &(pAttributes[dwIndex]) );
        }
    }

    return( NULL );
}

//**
//
// Call:        RasAuthAttributeGetFirst
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
RAS_AUTH_ATTRIBUTE *
RasAuthAttributeGetFirst(
    IN  RAS_AUTH_ATTRIBUTE_TYPE  raaType,
    IN  RAS_AUTH_ATTRIBUTE *     pAttributes,
    OUT HANDLE *                 phAttribute
)
{
    DWORD                   dwIndex;
    RAS_AUTH_ATTRIBUTE *    pRequiredAttribute;

    pRequiredAttribute = RasAuthAttributeGet( raaType, pAttributes );

    if ( pRequiredAttribute == NULL )
    {
        *phAttribute = NULL;

        return( NULL );
    }

    *phAttribute = pRequiredAttribute;

    return( pRequiredAttribute );
}

//**
//
// Call:        RasAuthAttributeGetNext
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
RAS_AUTH_ATTRIBUTE *
RasAuthAttributeGetNext(
    IN  OUT HANDLE *             phAttribute,
    IN  RAS_AUTH_ATTRIBUTE_TYPE  raaType
)
{
    DWORD                   dwIndex;
    RAS_AUTH_ATTRIBUTE *    pAttributes = (RAS_AUTH_ATTRIBUTE *)*phAttribute;

    if ( pAttributes == NULL )
    {
        return( NULL );
    }

    pAttributes++;

    while( pAttributes->raaType != raatMinimum )
    {
        if ( pAttributes->raaType == raaType )
        {
            *phAttribute = pAttributes;
            return( pAttributes );
        }

        pAttributes++;
    }

    *phAttribute = NULL;
    return( NULL );
}

//**
//
// Call:        RasAuthAttributesPrint
//
// Returns:     VOID
//
// Description: Will print all the attributes in pAttributes
//
VOID
RasAuthAttributesPrint(
    IN  DWORD                   dwTraceID,
    IN  DWORD                   dwFlags,
    IN  RAS_AUTH_ATTRIBUTE *    pAttributes
)
{
    DWORD   dwIndex;

    if ( NULL == pAttributes )
    {
        return;
    }

    for ( dwIndex = 0;
          pAttributes[dwIndex].raaType != raatMinimum;
          dwIndex++)
    {
        switch( pAttributes[dwIndex].raaType )
        {
        case raatUserName:
        case raatUserPassword:
        case raatMD5CHAPPassword:
        case raatFilterId:
        case raatReplyMessage:
        case raatCallbackNumber:
        case raatCallbackId:
        case raatFramedRoute:
        case raatState:
        case raatClass:
        case raatVendorSpecific:
        case raatCalledStationId:
        case raatCallingStationId:
        case raatNASIdentifier:
        case raatProxyState:
        case raatLoginLATService:
        case raatLoginLATNode:
        case raatLoginLATGroup:
        case raatFramedAppleTalkZone:
        case raatAcctSessionId:
        case raatAcctMultiSessionId:
        case raatMD5CHAPChallenge:
        case raatLoginLATPort:
        case raatTunnelClientEndpoint:
        case raatTunnelServerEndpoint:
        case raatARAPPassword:
        case raatARAPFeatures:
        case raatARAPSecurityData:
        case raatConnectInfo:
        case raatConfigurationToken:
        case raatEAPMessage:
        case raatSignature:
        case raatARAPChallengeResponse:
		case raatCertificateOID:
            TracePrintfExA(
                dwTraceID, dwFlags,
                "Type=%d, Length=%d, Value=",
                pAttributes[dwIndex].raaType, 
                pAttributes[dwIndex].dwLength );

            if (   ( pAttributes[dwIndex].raaType == raatVendorSpecific )
                && ( pAttributes[dwIndex].dwLength >= 5 ) 
                && ( WireToHostFormat32( pAttributes[dwIndex].Value ) == 311 ) )
            {
                DWORD   dwVendorType;

                dwVendorType = ((BYTE*)(pAttributes[dwIndex].Value))[4];

                //
                // Do not print MS-CHAP-MPPE-Keys, MS-MPPE-Send-Key and
                // MS-MPPE-Recv-Key
                //

                if (   ( dwVendorType == 12 )
                    || ( dwVendorType == 16 )
                    || ( dwVendorType == 17 ) )
                {
                    TracePrintfExA(
                        dwTraceID, dwFlags,
                        "MS vendor specific %d", dwVendorType );

                    break;
                }

            }

            //
            // Do not print the password
            //
            if(pAttributes[dwIndex].raaType == raatUserPassword)
            {
                TracePrintfExA(
                    dwTraceID, dwFlags,
                    "raatUserPassword");

                break;                    
            }
            

            TraceDumpExA(
                dwTraceID, dwFlags,
                pAttributes[dwIndex].Value,
                pAttributes[dwIndex].dwLength,
                1, FALSE, "" );

            break;

        default:

            TracePrintfExA(
                dwTraceID, dwFlags,
                "Type=%d, Length=%d, Value=0x%x",
                pAttributes[dwIndex].raaType, 
                pAttributes[dwIndex].dwLength,
                pAttributes[dwIndex].Value );

            break;
        }
    }
}

//**
//
// Call:        RasAuthAttributeInsert
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
RasAuthAttributeInsert(
    IN DWORD                    dwIndex,
    IN RAS_AUTH_ATTRIBUTE *     pAttributes,
    IN RAS_AUTH_ATTRIBUTE_TYPE  raaType,
    IN BOOL                     fConvertToMultiByte,
    IN DWORD                    dwLength,
    IN PVOID                    pValue
)
{
    DWORD   dwErr;

    if ( raatMinimum == pAttributes[dwIndex].raaType )
    {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    switch( raaType )
    {
    case raatUserName:
    case raatUserPassword:
    case raatMD5CHAPPassword:
    case raatFilterId:
    case raatReplyMessage:
    case raatCallbackNumber:
    case raatCallbackId:
    case raatFramedRoute:
    case raatState:
    case raatClass:
    case raatVendorSpecific:
    case raatCalledStationId:
    case raatCallingStationId:
    case raatNASIdentifier:
    case raatProxyState:
    case raatLoginLATService:
    case raatLoginLATNode:
    case raatLoginLATGroup:
    case raatFramedAppleTalkZone:
    case raatAcctSessionId:
    case raatAcctMultiSessionId:
    case raatMD5CHAPChallenge:
    case raatLoginLATPort:
    case raatTunnelClientEndpoint:
    case raatTunnelServerEndpoint:
    case raatARAPPassword:
    case raatARAPFeatures:
    case raatARAPSecurityData:
    case raatConnectInfo:
    case raatConfigurationToken:
    case raatEAPMessage:
    case raatSignature:
    case raatARAPChallengeResponse:
	case raatCertificateOID:
    // If you add a new attribute here, update RasAuthAttributesPrint also.

        if ( pValue != NULL )
        {
            pAttributes[dwIndex].Value = LocalAlloc( LPTR, dwLength+1 );

            if ( pAttributes[dwIndex].Value == NULL )
            {
                return( GetLastError() );
            }

            if ( fConvertToMultiByte )
            {
                if (0 == WideCharToMultiByte(
                            CP_ACP,
                            0,
                            (WCHAR*)pValue,
                            dwLength + 1,
                            pAttributes[dwIndex].Value,
                            dwLength + 1,
                            NULL,
                            NULL ) )
                {
                    dwErr = GetLastError();
                    LocalFree( pAttributes[dwIndex].Value );
                    return( dwErr );
                }
            }
            else
            {
                CopyMemory( pAttributes[dwIndex].Value, pValue, dwLength );
            }
        }
        else
        {
            pAttributes[dwIndex].Value = NULL;
        }

        break;

    default:

        pAttributes[dwIndex].Value = pValue;

        break;

    }

    pAttributes[dwIndex].dwLength = dwLength;
    pAttributes[dwIndex].raaType  = raaType;

    return( NO_ERROR );
}

//**
//
// Call:        RasAuthAttributeInsertVSA
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
RasAuthAttributeInsertVSA(
    IN DWORD                    dwIndex,
    IN RAS_AUTH_ATTRIBUTE *     pAttributes,
    IN DWORD                    dwVendorId,
    IN DWORD                    dwLength,
    IN PVOID                    pValue
)
{
    if ( pValue != NULL )
    {
        pAttributes[dwIndex].Value = LocalAlloc( LPTR, dwLength+1+4 );

        if ( pAttributes[dwIndex].Value == NULL )
        {
            return( GetLastError() );
        }

        HostToWireFormat32( dwVendorId, (PBYTE)(pAttributes[dwIndex].Value) );

        CopyMemory( ((PBYTE)pAttributes[dwIndex].Value)+4,
                    (PBYTE)pValue,
                    dwLength );

        pAttributes[dwIndex].dwLength = dwLength+4;
    }
    else
    {
        pAttributes[dwIndex].Value    = NULL;
        pAttributes[dwIndex].dwLength = 0;
    }

    pAttributes[dwIndex].raaType = raatVendorSpecific;

    return( NO_ERROR );
}

//**
//
// Call:        RasAuthAttributeCopy
//
// Returns:     Pointer to copy of attributes - Success
//              NULL - Failure
//
// Description:
//
RAS_AUTH_ATTRIBUTE *
RasAuthAttributeCopy(
    IN  RAS_AUTH_ATTRIBUTE *     pAttributes
)
{
    RAS_AUTH_ATTRIBUTE * pAttributesCopy;
    DWORD                dwAttributesCount = 0;
    DWORD                dwIndex;
    DWORD                dwRetCode;

    //
    // Find out how many attributes there are
    //

    if ( pAttributes == NULL )
    {
        return( NULL );
    }

    for( dwIndex = 0; pAttributes[dwIndex].raaType != raatMinimum; dwIndex++ );

    if ( ( pAttributesCopy = RasAuthAttributeCreate( dwIndex ) ) == NULL )
    {
        return( NULL );
    }

    for( dwIndex = 0; pAttributes[dwIndex].raaType != raatMinimum; dwIndex++ )
    {
        dwRetCode = RasAuthAttributeInsert( dwIndex,
                                            pAttributesCopy,
                                            pAttributes[dwIndex].raaType,
                                            FALSE,
                                            pAttributes[dwIndex].dwLength,
                                            pAttributes[dwIndex].Value );

        if ( dwRetCode != NO_ERROR )
        {
            RasAuthAttributeDestroy( pAttributesCopy );

            SetLastError( dwRetCode );

            return( NULL );
        }
    }

    return( pAttributesCopy );
}

//**
//
// Call:        RasAuthAttributeCopyWithAlloc
//
// Returns:     Pointer to copy of attributes - Success
//              NULL - Failure
//
// Description: Copies the attribute list and allocs dwNumExtraAttributes
//              extra blank attributes in the beginning. pAttributes can
//              be NULL.
//
RAS_AUTH_ATTRIBUTE *
RasAuthAttributeCopyWithAlloc(
    IN  RAS_AUTH_ATTRIBUTE *    pAttributes,
    IN  DWORD                   dwNumExtraAttributes
)
{
    RAS_AUTH_ATTRIBUTE * pAttributesCopy;
    DWORD                dwAttributesCount = 0;
    DWORD                dwIndex;
    DWORD                dwRetCode;

    if ( pAttributes == NULL )
    {
        pAttributesCopy = RasAuthAttributeCreate( dwNumExtraAttributes );

        if ( pAttributesCopy == NULL )
        {
            return( NULL );
        }
    }
    else
    {
        //
        // Find out how many attributes there are
        //

        for( dwIndex = 0;
             pAttributes[dwIndex].raaType != raatMinimum;
             dwIndex++ );

        dwIndex += dwNumExtraAttributes;

        if ( ( pAttributesCopy = RasAuthAttributeCreate( dwIndex ) ) == NULL )
        {
            return( NULL );
        }

        for( dwIndex = 0;
             pAttributes[dwIndex].raaType != raatMinimum;
             dwIndex++ )
        {
            dwRetCode = RasAuthAttributeInsert( dwIndex + dwNumExtraAttributes,
                                                pAttributesCopy,
                                                pAttributes[dwIndex].raaType,
                                                FALSE,
                                                pAttributes[dwIndex].dwLength,
                                                pAttributes[dwIndex].Value );

            if ( dwRetCode != NO_ERROR )
            {
                RasAuthAttributeDestroy( pAttributesCopy );

                SetLastError( dwRetCode );

                return( NULL );
            }
        }
    }

    return( pAttributesCopy );
}

//**
//
// Call:        RasAuthAttributeGetVendorSpecific
//
// Returns:     Pointer to attribute
//              NULL if it couldn't find it
//
// Description:
//
RAS_AUTH_ATTRIBUTE *
RasAuthAttributeGetVendorSpecific(
    IN  DWORD                   dwVendorId,
    IN  DWORD                   dwVendorType,
    IN  RAS_AUTH_ATTRIBUTE *    pAttributes
)
{
    HANDLE               hAttribute;
    RAS_AUTH_ATTRIBUTE * pAttribute;

    //
    // First search for the vendor specific attribute
    //

    pAttribute = RasAuthAttributeGetFirst( raatVendorSpecific,
                                           pAttributes,
                                           &hAttribute );

    while ( pAttribute != NULL )
    {
        //
        // If this attribute is of at least size to hold vendor Id/Type
        //

        if ( pAttribute->dwLength >= 8 )
        {
            //
            // Does this have the correct VendorId
            //

            if (WireToHostFormat32( (PBYTE)(pAttribute->Value) ) == dwVendorId)
            {
                //
                // Does this have the correct Vendor Type
                //

                if ( *(((PBYTE)(pAttribute->Value))+4) == dwVendorType )
                {
                    return( pAttribute );
                }
            }
        }

        pAttribute = RasAuthAttributeGetNext( &hAttribute,
                                              raatVendorSpecific );
    }

    return( NULL );
}

//**
//
// Call:        RasAuthAttributeReAlloc
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will create an array of attributes plus one for the terminator
//
RAS_AUTH_ATTRIBUTE *
RasAuthAttributeReAlloc(
    IN  RAS_AUTH_ATTRIBUTE *   pAttributes,
    IN  DWORD                  dwNumAttributes
)
{
    DWORD                   dwIndex;
    RAS_AUTH_ATTRIBUTE *    pOutAttributes;

    pOutAttributes = (RAS_AUTH_ATTRIBUTE *)
                        LocalReAlloc(
                             pAttributes,
                             sizeof( RAS_AUTH_ATTRIBUTE )*(1+dwNumAttributes),
                             LMEM_ZEROINIT );


    if ( pOutAttributes == NULL )
    {
        return( NULL );
    }

    //
    // Initialize the rest of the array.
    //

    for( dwIndex = 0; dwIndex < dwNumAttributes; dwIndex++ )
    {
        if ( pOutAttributes[dwIndex].raaType == raatMinimum )
        {
            while( dwIndex < dwNumAttributes )
            {
                pOutAttributes[dwIndex].raaType  = raatReserved;
                pOutAttributes[dwIndex].dwLength = 0;
                pOutAttributes[dwIndex].Value    = NULL;

                dwIndex++;
            }

            break;
        }
    }

    //
    // Terminate the new array.
    //

    pOutAttributes[dwNumAttributes].raaType  = raatMinimum;
    pOutAttributes[dwNumAttributes].dwLength = 0;
    pOutAttributes[dwNumAttributes].Value    = NULL;

    return( pOutAttributes );
}

//**
//
// Call:        RasAuthAttributeGetConcatString
//
// Returns:     pointer to a LocalAlloc'ed string
//
// Description: Looks for attributes of type raaType in pAttributes. Combines
//              them all into one string and returns the string. The string
//              must be LocalFree'd. *pdwStringLength will contain the number
//              of characters in the string.
//
CHAR *
RasAuthAttributeGetConcatString(
    IN      RAS_AUTH_ATTRIBUTE_TYPE raaType,
    IN      RAS_AUTH_ATTRIBUTE *    pAttributes,
    IN OUT  DWORD *                 pdwStringLength
)
{
#define                     MAX_STR_LENGTH      1500
    HANDLE                  hAttribute;
    CHAR *                  pszReplyMessage     = NULL;
    RAS_AUTH_ATTRIBUTE *    pAttribute;
    DWORD                   dwBytesRemaining;
    DWORD                   dwBytesToCopy;

    do
    {
        *pdwStringLength = 0;

        pAttribute = RasAuthAttributeGetFirst( raaType, pAttributes,
                                               &hAttribute );

        if ( NULL == pAttribute )
        {
            break;
        }

        pszReplyMessage = LocalAlloc( LPTR, MAX_STR_LENGTH + 1 );

        if ( NULL == pszReplyMessage )
        {
            break;
        }

        //
        // Bytes remaining, excluding terminating NULL
        //

        dwBytesRemaining = MAX_STR_LENGTH;

        while (   ( dwBytesRemaining > 0 )
               && ( NULL != pAttribute ) )
        {
            //
            // This does not include the terminating NULL
            //

            dwBytesToCopy = pAttribute->dwLength;

            if ( dwBytesToCopy > dwBytesRemaining )
            {
                dwBytesToCopy = dwBytesRemaining;
            }

            CopyMemory( pszReplyMessage + MAX_STR_LENGTH - dwBytesRemaining,
                        pAttribute->Value,
                        dwBytesToCopy );

            dwBytesRemaining -= dwBytesToCopy;

            pAttribute = RasAuthAttributeGetNext( &hAttribute,
                                                  raaType );

        }

        *pdwStringLength = MAX_STR_LENGTH - dwBytesRemaining;
    }
    while ( FALSE );

    return( pszReplyMessage );
}

//**
//
// Call:        RasAuthAttributeGetConcatVendorSpecific
//
// Returns:     Pointer to a chunk of bytes
//              NULL if it couldn't find it
//
// Description: Looks for attributes of type dwVendorType in pAttributes.
//              Combines them all into the return value. The Value must be
//              LocalFree'd.
//
BYTE *
RasAuthAttributeGetConcatVendorSpecific(
    IN  DWORD                   dwVendorId,
    IN  DWORD                   dwVendorType,
    IN  RAS_AUTH_ATTRIBUTE *    pAttributes
)
{
    DWORD                dwMAX_ATTR_LENGTH  = 1024;
    HANDLE               hAttribute;
    RAS_AUTH_ATTRIBUTE * pAttribute;
    BYTE*                pbValue            = NULL;
    DWORD                dwIndex            = 0;
    DWORD                dwLength;
    BOOL                 fFound             = FALSE;

    pbValue = LocalAlloc( LPTR, dwMAX_ATTR_LENGTH );

    if ( NULL == pbValue )
    {
        return( NULL );
    }

    //
    // First search for the vendor specific attribute
    //

    pAttribute = RasAuthAttributeGetFirst( raatVendorSpecific,
                                           pAttributes,
                                           &hAttribute );

    while ( pAttribute != NULL )
    {
        //
        // If this attribute is of at least size to hold vendor Id/Type
        //

        if ( pAttribute->dwLength >= 8 )
        {
            //
            // Does this have the correct VendorId
            //

            if (WireToHostFormat32( (PBYTE)(pAttribute->Value) ) == dwVendorId)
            {
                //
                // Does this have the correct Vendor Type
                //

                if ( *(((PBYTE)(pAttribute->Value))+4) == dwVendorType )
                {
                    //
                    // Exclude Vendor-Type and Vendor-Length from the length
                    //

                    dwLength = *(((PBYTE)(pAttribute->Value))+5) - 2;

                    // If we overrun the buffer, we should increase it
                    if ( dwMAX_ATTR_LENGTH - dwIndex < dwLength )
                    {
                        BYTE    *pbNewValue;
                        dwMAX_ATTR_LENGTH += 1024;

                        pbNewValue = LocalReAlloc(pbValue, dwMAX_ATTR_LENGTH, LMEM_ZEROINIT|LMEM_MOVEABLE);

                        // Bail if we can't get more memory
                        if( pbNewValue == NULL )
                        {
                            LocalFree( pbValue );
                            return( NULL );
                        }

                        pbValue = pbNewValue;
                    }

                    CopyMemory(
                        pbValue + dwIndex,
                        ((PBYTE)(pAttribute->Value))+6,
                        dwLength );

                    dwIndex += dwLength;

                    fFound = TRUE;
                }
            }
        }

        pAttribute = RasAuthAttributeGetNext( &hAttribute,
                                              raatVendorSpecific );
    }

    if ( fFound )
    {
        return( pbValue );
    }
    else
    {
        LocalFree( pbValue );
        return( NULL );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\common\clsa.c ===
/* Copyright (c) 1993, Microsoft Corporation, all rights reserved
**
** clsa.c
** Client-side LSA Authentication Utilities
**
** 11/12/93 MikeSa  Pulled from NT 3.1 RAS authentication.
*/

#define UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <crypt.h>

#include <windows.h>
#include <lmcons.h>

#include <string.h>
#include <stdlib.h>

#include <rasman.h>
#include <raserror.h>

#include <rtutils.h>
//
//Revisit the tracing for common components 
//in BC timeframe.
//This really sucks...

BOOL GetDESChallengeResponse(
	IN DWORD dwTraceId,
    IN PCHAR pszPassword,
    IN PBYTE pchChallenge,
    OUT PBYTE pchChallengeResponse
    );

BOOL GetMD5ChallengeResponse(
	IN DWORD dwTraceId,
    IN PCHAR pszPassword,
    IN PBYTE pchChallenge,
    OUT PBYTE pchChallengeResponse
    );

BOOL Uppercase(IN DWORD dwTraceId, PBYTE pString);

#define GCR_MACHINE_CREDENTIAL         0x400

DWORD
RegisterLSA (DWORD          dwTraceId,
             OUT HANDLE *   phLsa,
             OUT DWORD *    pdwAuthPkgId)
{
    NTSTATUS    ntstatus;
    STRING  LsaName;
    LSA_OPERATIONAL_MODE LSASecurityMode ;

    TracePrintfExA (dwTraceId, 0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC, "RegisterLSA" );
    //
    // To be able to do authentications, we have to
    // register with the Lsa as a logon process.
    //
    RtlInitString(&LsaName, "CCHAP");

    *phLsa = NULL;

    ntstatus = LsaRegisterLogonProcess(&LsaName,
                                       phLsa,
                                       &LSASecurityMode);

    if (ntstatus != STATUS_SUCCESS)
    {
        TracePrintfExA (dwTraceId, 0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC, "LsaregisterLogonProcess Failed" );
        return (1);
    }

    //
    // We use the MSV1_0 authentication package for LM2.x
    // logons.  We get to MSV1_0 via the Lsa.  So we call
    // Lsa to get MSV1_0's package id, which we'll use in
    // later calls to Lsa.
    //
    RtlInitString(&LsaName, MSV1_0_PACKAGE_NAME);

    ntstatus = LsaLookupAuthenticationPackage(*phLsa,
                                              &LsaName,
                                              pdwAuthPkgId);

    if (ntstatus != STATUS_SUCCESS)
    {
        TracePrintfExA (dwTraceId, 0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC, "LsaLookupAuthenticationPackage Failed" );
        return (1);
    }

    return NO_ERROR;
}


DWORD
GetMachineCredentials 
(	
    IN DWORD dwTraceId,
    IN PBYTE pszMachineName,
    IN PLUID pLuid,
    IN PBYTE pbChallenge,
    OUT PBYTE CaseInsensitiveChallengeResponse,
    OUT PBYTE CaseSensitiveChallengeResponse,
    OUT PBYTE pLmSessionKey,
    OUT PBYTE pUserSessionKey
)
{
    DWORD                           dwRetCode = NO_ERROR;
    DWORD                           dwChallengeResponseRequestLength;
    DWORD                           dwChallengeResponseLength;
    MSV1_0_GETCHALLENRESP_REQUEST   ChallengeResponseRequest;
    PMSV1_0_GETCHALLENRESP_RESPONSE pChallengeResponse;
    NTSTATUS                        status;
    NTSTATUS                        substatus;
    HANDLE                          hLsa = NULL;
    DWORD                           dwAuthPkgId = 0;


    dwRetCode = RegisterLSA (   dwTraceId,
                                &hLsa,
                                &dwAuthPkgId
                            );
    if ( NO_ERROR != dwRetCode )
        goto LDone;

    ZeroMemory( &ChallengeResponseRequest, sizeof(ChallengeResponseRequest) );

    dwChallengeResponseRequestLength =
                            sizeof(MSV1_0_GETCHALLENRESP_REQUEST);

    ChallengeResponseRequest.MessageType =
                            MsV1_0Lm20GetChallengeResponse;

    ChallengeResponseRequest.ParameterControl = 
        RETURN_PRIMARY_LOGON_DOMAINNAME | 
        RETURN_PRIMARY_USERNAME | 
        USE_PRIMARY_PASSWORD|
        GCR_MACHINE_CREDENTIAL;

    ChallengeResponseRequest.LogonId = *pLuid;

    ChallengeResponseRequest.Password.Length = 0;

    ChallengeResponseRequest.Password.MaximumLength = 0;

    ChallengeResponseRequest.Password.Buffer = NULL;

    RtlMoveMemory( ChallengeResponseRequest.ChallengeToClient,
                   pbChallenge, 
                   (DWORD) MSV1_0_CHALLENGE_LENGTH);

    status = LsaCallAuthenticationPackage(hLsa,
                                        dwAuthPkgId,
                                        &ChallengeResponseRequest,
                                        dwChallengeResponseRequestLength,
                                        (PVOID *) &pChallengeResponse,
                                        &dwChallengeResponseLength,
                                        &substatus);

    if (    (status != STATUS_SUCCESS)
        ||  (substatus != STATUS_SUCCESS))
    {
         TracePrintfExA (   dwTraceId, 
                            0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC, 
                            "LsaCallAuthenticationPackage failed status:0x%x substatus:0x%x", status, substatus );
         dwRetCode = 1 ;

    }
    else
    {
        if(NULL !=
           pChallengeResponse->CaseInsensitiveChallengeResponse.Buffer)
        {

            RtlMoveMemory(CaseInsensitiveChallengeResponse,
                 pChallengeResponse->CaseInsensitiveChallengeResponse.Buffer,
                 SESSION_PWLEN);
        }
        else
        {
            ZeroMemory(CaseInsensitiveChallengeResponse,
                       SESSION_PWLEN);

        }

        if(NULL !=
           pChallengeResponse->CaseSensitiveChallengeResponse.Buffer)
        {

            RtlMoveMemory(CaseSensitiveChallengeResponse,
                 pChallengeResponse->CaseSensitiveChallengeResponse.Buffer,
                 SESSION_PWLEN);
        }
        else
        {
            ZeroMemory(CaseSensitiveChallengeResponse,
                       SESSION_PWLEN);
        }

        RtlMoveMemory(pLmSessionKey,
             pChallengeResponse->LanmanSessionKey,
             MAX_SESSIONKEY_SIZE);

        RtlMoveMemory(pUserSessionKey,
             pChallengeResponse->UserSessionKey,
             MAX_USERSESSIONKEY_SIZE);

        LsaFreeReturnBuffer(pChallengeResponse);        
    }

LDone:
    if ( hLsa )
    {
        LsaDeregisterLogonProcess (hLsa);
    }
    return dwRetCode;
}


DWORD
GetChallengeResponse(
	IN DWORD dwTraceId,
    IN PBYTE pszUsername,
    IN PBYTE pszPassword,
    IN PLUID pLuid,
    IN PBYTE pbChallenge,
    IN BOOL  fMachineAuth,
    OUT PBYTE CaseInsensitiveChallengeResponse,
    OUT PBYTE CaseSensitiveChallengeResponse,
    OUT PBYTE pfUseNtResponse,
    OUT PBYTE pLmSessionKey,
    OUT PBYTE pUserSessionKey

    )
{
	DWORD dwRetCode = ERROR_SUCCESS;
    *pfUseNtResponse = TRUE;
	TracePrintfExA (dwTraceId, 0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC, "GetChallengeResponse" );
    //
    // Check if we're supposed to get credentials from the system
    //
    if ( fMachineAuth )
    {
        if ( ( dwRetCode = GetMachineCredentials (
                dwTraceId,
                pszUsername,
                pLuid,
                pbChallenge,
                CaseInsensitiveChallengeResponse,
                CaseSensitiveChallengeResponse,
                pLmSessionKey,
                pUserSessionKey
                ) ) )
        {
			TracePrintfExA (dwTraceId, 
                            0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC, 
                            "GetMachineCredentials Failed ErrorCode: 0x%x", 
                            dwRetCode );
            return (ERROR_AUTH_INTERNAL);
        }
    }
    else if (lstrlenA(pszUsername))
    {
        
        if (lstrlenA(pszPassword) <= LM20_PWLEN)
        {
            if (!GetDESChallengeResponse(dwTraceId, pszPassword, pbChallenge,
                    CaseInsensitiveChallengeResponse))
            {
				//We dont want to send back the error that 
				//this function must have failed with
				//but just log it in our logs...
				TracePrintfExA (dwTraceId, 0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC, "GetDESChallangeResponse Failed" );
                return (ERROR_AUTH_INTERNAL);
            }
        }

        //
        // And we'll always get the case sensitive response.
        //
        if (!GetMD5ChallengeResponse(dwTraceId, pszPassword, pbChallenge,
                CaseSensitiveChallengeResponse))
        {
			TracePrintfExA (dwTraceId, 0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC, "GetMD5ChallangeResponse Failed" );
            return (ERROR_AUTH_INTERNAL);
        }
    }
    else
    {
        WCHAR Username[UNLEN + DNLEN + 1];

        //
        // need to make sure that Rasman is started
        //
        dwRetCode = RasInitialize();
        if ( NO_ERROR != dwRetCode )
        {
            TracePrintfExA (dwTraceId, 0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC, "RasInitialize Failed ErrorCode: 0x%x", dwRetCode );
            return dwRetCode;            
        }
        
        
        dwRetCode = RasReferenceRasman(TRUE);
        if ( NO_ERROR != dwRetCode )
        {
            TracePrintfExA (dwTraceId, 0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC, "RasReferenceRasman Failed ErrorCode: 0x%x", dwRetCode );
            return dwRetCode;
        }
        

        //
        // We can get credentials from the system
        //
        if ( ( dwRetCode = RasGetUserCredentials(
                pbChallenge,
                pLuid,
                Username,
                CaseSensitiveChallengeResponse,
                CaseInsensitiveChallengeResponse,
                pLmSessionKey,
                pUserSessionKey
                ) ) )
        {
			TracePrintfExA (dwTraceId, 0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC, "RasGetUserCredentials Failed ErrorCode: 0x%x", dwRetCode );
            RasReferenceRasman(FALSE);
            return (ERROR_AUTH_INTERNAL);
        }


        WideCharToMultiByte(
            CP_ACP,
            0,
            Username,
            -1,
            pszUsername,
            UNLEN + 1,
            NULL,
            NULL);

        //
        // What if the conversion fails?
        //
        
        pszUsername[UNLEN] = 0;
        RasReferenceRasman(FALSE);
    }
	TracePrintfExA (dwTraceId, 0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC, "GetChallengeResponse Success");
    return (0L);
}


BOOL GetDESChallengeResponse(
	IN DWORD dwTraceId,
    IN PCHAR pszPassword,
    IN PBYTE pchChallenge,
    OUT PBYTE pchChallengeResponse
    )
{
    CHAR			LocalPassword[LM20_PWLEN + 1];
	DWORD			dwRetCode = ERROR_SUCCESS;
    LM_OWF_PASSWORD LmOwfPassword;

	TracePrintfExA (dwTraceId, 0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC, "GetDESChallengeResponse" );

    if (lstrlenA(pszPassword) > LM20_PWLEN)
    {
		TracePrintfExA (dwTraceId, 0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC, "too big" );
        return (FALSE);
    }

    lstrcpyA(LocalPassword, pszPassword);

    if (!Uppercase(dwTraceId, LocalPassword))
    {
		TracePrintfExA (dwTraceId, 0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC, "UpperCase Fail" );
        ZeroMemory( LocalPassword, LM20_PWLEN );
        return (FALSE);
    }


    //
    // Encrypt standard text with the password as a key
    //
    if (( dwRetCode = RtlCalculateLmOwfPassword((PLM_PASSWORD) LocalPassword, &LmOwfPassword) ))
    {
		TracePrintfExA (dwTraceId, 0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC, "GetDesChallengeResponse Fail 1.  ErrorCode: 0x%x", dwRetCode );
        ZeroMemory( LocalPassword, LM20_PWLEN );
        return (FALSE);
    }

    //
    // Use the challenge sent by the gateway to encrypt the
    // password digest from above.
    //
    if ( ( dwRetCode = RtlCalculateLmResponse((PLM_CHALLENGE) pchChallenge,
            &LmOwfPassword, (PLM_RESPONSE) pchChallengeResponse) ) )
    {
		TracePrintfExA (dwTraceId, 0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC, "GetDesChallengeResponse Fail 2.  ErrorCode: 0x%x", dwRetCode );
        ZeroMemory( LocalPassword, LM20_PWLEN );
        return (FALSE);
    }

#ifdef CHAPSAMPLES
    TRACE( "LM challenge..." );
    DUMPB( pchChallenge, sizeof(LM_CHALLENGE) );
    TRACE( "LM password..." );
    DUMPB( LocalPassword, LM20_PWLEN );
    TRACE( "LM OWF password..." );
    DUMPB( &LmOwfPassword, sizeof(LM_OWF_PASSWORD) );
    TRACE( "LM Response..." );
    DUMPB( pchChallengeResponse, sizeof(LM_RESPONSE) );
#endif

    ZeroMemory( LocalPassword, LM20_PWLEN );
	TracePrintfExA (dwTraceId, 0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC, "GetDESChallengeResponse Success" );
    return (TRUE);
}


BOOL GetMD5ChallengeResponse(
	IN DWORD dwTraceId,
    IN PCHAR pszPassword,
    IN PBYTE pchChallenge,
    OUT PBYTE pchChallengeResponse
    )
{
    NT_PASSWORD			NtPassword;
    NT_OWF_PASSWORD		NtOwfPassword;
	DWORD				dwRetCode = ERROR_SUCCESS;

	TracePrintfExA (dwTraceId, 0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC, "GetMD5ChallengeResponse Success" );
    RtlCreateUnicodeStringFromAsciiz(&NtPassword, pszPassword);

    //
    // Encrypt standard text with the password as a key
    //
    if (( dwRetCode = RtlCalculateNtOwfPassword(&NtPassword, &NtOwfPassword) ) )
    {
		TracePrintfExA (dwTraceId, 0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC, "GetMD5ChallengeResponse Fail 1.  ErrorCode:0x%x", dwRetCode );
        return (FALSE);
    }


    //
    // Use the challenge sent by the gateway to encrypt the
    // password digest from above.
    //
    if (( dwRetCode = RtlCalculateNtResponse((PNT_CHALLENGE) pchChallenge,
            &NtOwfPassword, (PNT_RESPONSE) pchChallengeResponse) ) )
    {
		TracePrintfExA (dwTraceId, 0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC, "GetMD5ChallengeResponse Fail 2.  ErrorCode:0x%x", dwRetCode );
        return (FALSE);
    }

#ifdef CHAPSAMPLES
        TRACE( "NT Challenge..." );
        DUMPB( pchChallenge, sizeof(NT_CHALLENGE) );
        TRACE( "NT password..." );
        DUMPB( NtPassword.Buffer, NtPassword.MaximumLength );
        TRACE( "NT OWF password..." );
        DUMPB( &NtOwfPassword, sizeof(NT_OWF_PASSWORD) );
        TRACE( "NT Response..." );
        DUMPB( pchChallengeResponse, sizeof(NT_RESPONSE) );
#endif

    RtlFreeUnicodeString(&NtPassword);
	TracePrintfExA (dwTraceId, 0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC, "GetMD5ChallengeResponse Success" );
    return (TRUE);
}


DWORD GetEncryptedOwfPasswordsForChangePassword(
    IN PCHAR pClearTextOldPassword,
    IN PCHAR pClearTextNewPassword,
    IN PLM_SESSION_KEY pLmSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD pEncryptedLmOwfOldPassword,
    OUT PENCRYPTED_LM_OWF_PASSWORD pEncryptedLmOwfNewPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD pEncryptedNtOwfOldPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD pEncryptedNtOwfNewPassword
    )
{
    NT_PASSWORD NtPassword;
    NT_OWF_PASSWORD NtOwfPassword;
    DWORD rc;


    if ((lstrlenA(pClearTextOldPassword) <= LM20_PWLEN) &&
            (lstrlenA(pClearTextOldPassword) <= LM20_PWLEN))
    {
        CHAR LmPassword[LM20_PWLEN + 1];
        LM_OWF_PASSWORD LmOwfPassword;

        //
        // Make an uppercased-version of old password
        //
        lstrcpyA(LmPassword, pClearTextOldPassword);

        if (!Uppercase(0, LmPassword))
        {
            memset(LmPassword, 0, lstrlenA(LmPassword));
            return (1L);
        }


        //
        // We need to calculate the OWF's for the old and new passwords
        //
        rc = RtlCalculateLmOwfPassword((PLM_PASSWORD) LmPassword,
                &LmOwfPassword);
        if (!NT_SUCCESS(rc))
        {
            memset(LmPassword, 0, lstrlenA(LmPassword));
            return (rc);
        }

        rc = RtlEncryptLmOwfPwdWithLmSesKey(&LmOwfPassword, pLmSessionKey,
                pEncryptedLmOwfOldPassword);
        if (!NT_SUCCESS(rc))
        {
            memset(LmPassword, 0, lstrlenA(LmPassword));
            return (rc);
        }


        //
        // Make an uppercased-version of new password
        //
        lstrcpyA(LmPassword, pClearTextNewPassword);

        if (!Uppercase(0, LmPassword))
        {
            memset(LmPassword, 0, lstrlenA(LmPassword));
            return (1L);
        }

        rc = RtlCalculateLmOwfPassword((PLM_PASSWORD) LmPassword,
                &LmOwfPassword);
        if (!NT_SUCCESS(rc))
        {
            memset(LmPassword, 0, lstrlenA(LmPassword));
            return (rc);
        }

        rc = RtlEncryptLmOwfPwdWithLmSesKey(&LmOwfPassword, pLmSessionKey,
            pEncryptedLmOwfNewPassword);
        if (!NT_SUCCESS(rc))
        {
            memset(LmPassword, 0, lstrlenA(LmPassword));
            return (rc);
        }
    }


    RtlCreateUnicodeStringFromAsciiz(&NtPassword, pClearTextOldPassword);

    rc = RtlCalculateNtOwfPassword(&NtPassword, &NtOwfPassword);

    if (!NT_SUCCESS(rc))
    {
        memset(NtPassword.Buffer, 0, NtPassword.Length);
        return (rc);
    }

    rc = RtlEncryptNtOwfPwdWithNtSesKey(&NtOwfPassword, pLmSessionKey,
            pEncryptedNtOwfOldPassword);
    if (!NT_SUCCESS(rc))
    {
        memset(NtPassword.Buffer, 0, NtPassword.Length);
        return (rc);
    }


    RtlCreateUnicodeStringFromAsciiz(&NtPassword, pClearTextNewPassword);

    rc = RtlCalculateNtOwfPassword(&NtPassword, &NtOwfPassword);

    if (!NT_SUCCESS(rc))
    {
        memset(NtPassword.Buffer, 0, NtPassword.Length);
        return (rc);
    }

    rc = RtlEncryptNtOwfPwdWithNtSesKey(&NtOwfPassword, pLmSessionKey,
            pEncryptedNtOwfNewPassword);
    if (!NT_SUCCESS(rc))
    {
        memset(NtPassword.Buffer, 0, NtPassword.Length);
        return (rc);
    }


    return (0L);
}


BOOL Uppercase(DWORD dwTraceId, PBYTE pString)
{
    OEM_STRING OemString;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    NTSTATUS rc;


    RtlInitAnsiString(&AnsiString, pString);

    rc = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);
    if (!NT_SUCCESS(rc))
    {
		if ( dwTraceId )
			TracePrintfExA (dwTraceId, 0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC, "UpperCase Fail 1.  ErrorCode:%x", rc );

        return (FALSE);
    }

    rc = RtlUpcaseUnicodeStringToOemString(&OemString, &UnicodeString, TRUE);
    if (!NT_SUCCESS(rc))
    {
		if ( dwTraceId )
			TracePrintfExA (dwTraceId, 0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC, "UpperCase Fail 2.  ErrorCode:%x", rc );

        RtlFreeUnicodeString(&UnicodeString);

        return (FALSE);
    }

    OemString.Buffer[OemString.Length] = '\0';

    lstrcpyA(pString, OemString.Buffer);

    RtlFreeOemString(&OemString);
    RtlFreeUnicodeString(&UnicodeString);

    return (TRUE);
}

VOID
CGetSessionKeys(
    IN  CHAR*             pszPw,
    OUT LM_SESSION_KEY*   pLmKey,
    OUT USER_SESSION_KEY* pUserKey )

    /* Loads caller's 'pLmKey' buffer with the LAN Manager session key and
    ** caller's 'pUserKey' buffer with the user session key associated with
    ** password 'pszPw'.  If a session key cannot be calculated, that key is
    ** returned as all zeros.
    */
{
    /* The Lanman session key is the first 8 bytes of the Lanman
    ** one-way-function password.
    */
    {
        CHAR            szPw[ LM20_PWLEN + 1 ];
        LM_OWF_PASSWORD lmowf;

            memset( pLmKey, '\0', sizeof(*pLmKey) );

        if (strlen( pszPw ) <= LM20_PWLEN )
        {
            memset( szPw, '\0', LM20_PWLEN + 1 );
            strcpy( szPw, pszPw );

            if (Uppercase( 0, szPw ))
            {
                if (RtlCalculateLmOwfPassword(
                        (PLM_PASSWORD )szPw, &lmowf ) == 0)
                {
                    memcpy( pLmKey, &lmowf, sizeof(*pLmKey) );
                }
            }

            memset( szPw, '\0', sizeof(szPw) );
        }
    }

    /* The user session key is the NT one-way-function of the NT
    ** one-way-function password.
    */
    {
        WCHAR           szPw[ PWLEN + 1 ];
        NT_PASSWORD     ntpw;
        NT_OWF_PASSWORD ntowf;
        ANSI_STRING     ansi;

        memset( pUserKey, '\0', sizeof(pUserKey) );

        /* NT_PASSWORD is really a UNICODE_STRING, so we need to convert our
        ** ANSI password.
        */
        ntpw.Length = 0;
        ntpw.MaximumLength = sizeof(szPw);
        ntpw.Buffer = szPw;
        RtlInitAnsiString( &ansi, pszPw );
        RtlAnsiStringToUnicodeString( &ntpw, &ansi, FALSE );

        RtlCalculateNtOwfPassword( &ntpw, &ntowf );

        /* The first argument to RtlCalculateUserSessionKeyNt is the NT
        ** response, but it is not used internally.
        */
        RtlCalculateUserSessionKeyNt( NULL, &ntowf, pUserKey );

        memset( szPw, '\0', sizeof(szPw) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\auth\radius\radsrvrs.c ===
/********************************************************************/
/**          Copyright(c) 1985-1998 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    radsrvrs.c
//
// Description: Routines to manipulate the radius server list
//
// History:     Feb 11,1998	    NarenG		Created original version.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>

#include <windows.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <raserror.h>
#include <string.h>
#include <rasauth.h>
#include <stdlib.h>
#include <stdio.h>
#include <rtutils.h>
#include <mprlog.h>
#include <mprerror.h>
#define INCL_RASAUTHATTRIBUTES
#define INCL_HOSTWIRE
#include <ppputil.h>
#include "md5.h"
#include "radclnt.h"

//**
//
// Call:        InitializeRadiusServerList
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
VOID
InitializeRadiusServerList(
    IN  BOOL    fAuthentication
)
{
    if ( fAuthentication )
    {
        if ( g_AuthServerListHead.Flink == NULL )
        {
            InitializeListHead( &g_AuthServerListHead );

	        InitializeCriticalSection( &g_csAuth );
        }
    }
    else
    {
        if ( g_AcctServerListHead.Flink == NULL )
        {
            InitializeListHead( &g_AcctServerListHead );

            InitializeCriticalSection( &g_csAcct );
        }
    }

    g_pszCurrentServer = NULL;
}

//**
//
// Call:        FreeRadiusServerList
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
VOID
FreeRadiusServerList(
    IN  BOOL    fAuthentication
)
{
	RADIUSSERVER *      pServer;
    CRITICAL_SECTION *  pcs;
    LIST_ENTRY *        pListHead;

    if ( fAuthentication )
    {
        pcs       = &g_csAuth;
        pListHead = &g_AuthServerListHead;
    }
    else
    {
        pcs       = &g_csAcct;
        pListHead = &g_AcctServerListHead;
    }

    EnterCriticalSection( pcs );

    if ( pListHead->Flink != NULL )
    {
        //
        // free all items in linked list
        //

        while( !IsListEmpty( pListHead ) )
        {
            pServer = (RADIUSSERVER *)RemoveHeadList( pListHead );

            if ( !fAuthentication )
            {
                //
                // Notify Accounting server of NAS going down
                //

                NotifyServer( FALSE, pServer );
            }

            LocalFree( pServer );
        }
    }

	LeaveCriticalSection( pcs );
	
	DeleteCriticalSection( pcs );

    if ( fAuthentication )
    {
        g_AuthServerListHead.Flink = NULL; 
        g_AuthServerListHead.Blink = NULL; 
    }
    else
    {
        g_AcctServerListHead.Flink = NULL;
        g_AcctServerListHead.Blink = NULL;
    }

    if(NULL != g_pszCurrentServer)
    {
        LocalFree(g_pszCurrentServer);
    }

    g_pszCurrentServer = NULL;
} 

//**
//
// Call:        RetrievePrivateData
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
RetrievePrivateData(
    IN  WCHAR *pwszServerName,
    OUT WCHAR *pwszSecret
)
{
    LSA_HANDLE              hLSA = NULL;
    NTSTATUS                ntStatus;
    LSA_OBJECT_ATTRIBUTES   objectAttributes;
    LSA_UNICODE_STRING      *pLSAPrivData;
    LSA_UNICODE_STRING      LSAPrivDataDesc;
    WCHAR                   wszPrivData[MAX_PATH+1];
    WCHAR                   wszPrivDataDesc[MAX_PATH+1];

    InitializeObjectAttributes(&objectAttributes, NULL, 0, NULL, NULL);

    ntStatus = LsaOpenPolicy(NULL, &objectAttributes, POLICY_ALL_ACCESS, &hLSA);

    if ( !NT_SUCCESS( ntStatus) )
    {
        return( RtlNtStatusToDosError( ntStatus ) );
    }

    wcscpy(wszPrivDataDesc, TEXT("RADIUSServer."));
    wcscat(wszPrivDataDesc, pwszServerName);

    LSAPrivDataDesc.Length = (wcslen(wszPrivDataDesc) + 1) * sizeof(WCHAR);
    LSAPrivDataDesc.MaximumLength = sizeof(wszPrivDataDesc);
    LSAPrivDataDesc.Buffer        = wszPrivDataDesc;

    ntStatus = LsaRetrievePrivateData(hLSA, &LSAPrivDataDesc, &pLSAPrivData);

    if ( !NT_SUCCESS( ntStatus ) )
    {
        LsaClose(hLSA);
        return( RtlNtStatusToDosError( ntStatus ) );
    }
    else
    {
        ZeroMemory(pwszSecret, (pLSAPrivData->Length + 1) * sizeof(WCHAR));
        CopyMemory(pwszSecret, pLSAPrivData->Buffer, pLSAPrivData->Length);

        LsaFreeMemory(pLSAPrivData);
    }

    return( NO_ERROR );
}

//**
//
// Call:        LoadRadiusServers
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD 
LoadRadiusServers(
    IN BOOL fAuthenticationServers
)
{
	HKEY				hKeyServers = NULL;
    HKEY                hKeyServer  = NULL;
	DWORD				dwErrorCode;
	BOOL				fValidServerFound = FALSE;
	
    do
    {
		DWORD			dwKeyIndex, cbKeyServer, cbValue, dwType;
		CHAR            szNASIPAddress[20];
		SHORT           sPort;
		WCHAR			wszKeyServer[MAX_PATH+1];
		CHAR			szName[MAX_PATH+1];
		RADIUSSERVER	RadiusServer;

		dwErrorCode = RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
                                    ( fAuthenticationServers )
                                        ? PSZAUTHRADIUSSERVERS 
                                        : PSZACCTRADIUSSERVERS, 
                                    0, 
                                    KEY_READ,   
                                    &hKeyServers );

        if ( dwErrorCode != NO_ERROR )
        {
            break;
        }

        //
        // Get the retry value
        //

        cbValue = sizeof( DWORD );

        dwErrorCode = RegQueryValueEx( hKeyServers,
                                       PSZRETRIES,
                                       NULL,
                                       NULL,
                                       ( fAuthenticationServers ) 
                                        ? (PBYTE)&g_cAuthRetries
                                        : (PBYTE)&g_cAcctRetries,
                                       &cbValue );

        if ( dwErrorCode != NO_ERROR )
        {
            dwErrorCode = NO_ERROR;

            if ( fAuthenticationServers ) 
            {
                g_cAuthRetries = 2;
            }
            else
            {
                g_cAcctRetries = 2;
            }
        }

		dwKeyIndex  = 0;
		cbKeyServer = sizeof(wszKeyServer)/sizeof(TCHAR);

		while( RegEnumKeyEx( hKeyServers, 
                             dwKeyIndex, 
                             wszKeyServer, 
                             &cbKeyServer, 
                             NULL, 
                             NULL, 
                             NULL, 
                             NULL ) == NO_ERROR )
        {
			dwErrorCode = RegOpenKeyEx( hKeyServers, 
                                        wszKeyServer, 
                                        0, 
                                        KEY_READ,   
                                        &hKeyServer );

            if ( dwErrorCode != NO_ERROR )
            {
                break;
            }

			ZeroMemory( &RadiusServer, sizeof( RadiusServer ) );
			
			wcscpy( RadiusServer.wszName, wszKeyServer );

			RadiusServer.Timeout.tv_usec = 0;

			cbValue = sizeof( RadiusServer.Timeout.tv_sec );

			dwErrorCode = RegQueryValueEx( hKeyServer, 
                                           PSZTIMEOUT, 
                                           NULL, 
                                           NULL, 
                                           (PBYTE)&RadiusServer.Timeout.tv_sec,
                                           &cbValue );

            if ( dwErrorCode != NO_ERROR )
            {
				RadiusServer.Timeout.tv_sec = DEFTIMEOUT;
            }

            //
			// Secret Value is required
            //

			dwErrorCode = RetrievePrivateData( RadiusServer.wszName, 
                                               RadiusServer.wszSecret );

            if ( dwErrorCode != NO_ERROR )
            {
                break;
            }

			RadiusServer.szSecret[0] = 0;

			WideCharToMultiByte( CP_ACP, 
                                 0, 
                                 RadiusServer.wszSecret, 
                                 -1, 
                                 RadiusServer.szSecret, 
                                 MAX_PATH, 
                                 NULL, 
                                 NULL );

			RadiusServer.cbSecret = lstrlenA(RadiusServer.szSecret);

            if ( fAuthenticationServers )
            {
                //
                // Get the SendSignature value
                //

                cbValue = sizeof( BOOL );

                dwErrorCode = RegQueryValueEx(
                                            hKeyServer,
                                            PSZSENDSIGNATURE,
                                            NULL,
                                            NULL,
                                            (PBYTE)&RadiusServer.fSendSignature,
                                            &cbValue );

                if ( dwErrorCode != NO_ERROR )
                {
                        RadiusServer.fSendSignature = FALSE;
                }

                //
			    // read in port numbers
                //

			    cbValue = sizeof( RadiusServer.AuthPort );

			    dwErrorCode = RegQueryValueEx( 
                                            hKeyServer, 
                                            PSZAUTHPORT, 
                                            NULL, 
                                            NULL, 
                                            (PBYTE)&RadiusServer.AuthPort, 
                                            &cbValue );
    
                if ( dwErrorCode != NO_ERROR )
			    {    
				    RadiusServer.AuthPort = DEFAUTHPORT;
			    }

			    sPort = (SHORT)RadiusServer.AuthPort;
            }
            else
            {
			    cbValue = sizeof(RadiusServer.AcctPort);

			    dwErrorCode =  RegQueryValueEx( 
                                            hKeyServer, 
                                            PSZACCTPORT, 
                                            NULL, 
                                            NULL, 
                                            (PBYTE)&RadiusServer.AcctPort, 
                                            &cbValue );

                if ( dwErrorCode != NO_ERROR )
                {
				    RadiusServer.AcctPort = DEFACCTPORT;
	            }

			    sPort = (SHORT)RadiusServer.AcctPort;

			    cbValue = sizeof( RadiusServer.fAccountingOnOff );

			    dwErrorCode = RegQueryValueEx(
                                        hKeyServer, 
                                        PSZENABLEACCTONOFF, 
                                        NULL, 
                                        NULL, 
                                        (PBYTE)&RadiusServer.fAccountingOnOff,
                                        &cbValue );

                if ( dwErrorCode != NO_ERROR )
			    {    
				    RadiusServer.fAccountingOnOff = TRUE;
		        }
            }

			cbValue = sizeof( RadiusServer.cScore );

			dwErrorCode = RegQueryValueEx( hKeyServer, 
                                           PSZSCORE, 
                                           NULL, 
                                           NULL, 
                                           (PBYTE)&RadiusServer.cScore, 
                                           &cbValue );

            if ( dwErrorCode != NO_ERROR )
		    {
				RadiusServer.cScore = MAXSCORE;
		    }

            //
            // See if we need to bind to a particular IP address. This is 
            // useful if there are multiple NICs on the RAS server.
            //

			cbValue = sizeof( szNASIPAddress );

			dwErrorCode = RegQueryValueExA( hKeyServer, 
                                            PSZNASIPADDRESS, 
                                            NULL, 
                                            &dwType, 
                                            (PBYTE)szNASIPAddress,
                                            &cbValue );

            if (   ( dwErrorCode != NO_ERROR )
                || ( dwType != REG_SZ ) )
            {
				RadiusServer.nboNASIPAddress = INADDR_NONE;

                dwErrorCode = NO_ERROR;
            }
            else
            {
                RadiusServer.nboNASIPAddress = inet_addr(szNASIPAddress);
				RadiusServer.NASIPAddress.sin_family = AF_INET;
				RadiusServer.NASIPAddress.sin_port = 0;
				RadiusServer.NASIPAddress.sin_addr.S_un.S_addr	=
				    RadiusServer.nboNASIPAddress;
            }

            //
			// Convert name to ip address.
            //

			szName[0] = 0;

			WideCharToMultiByte( CP_ACP, 
                                 0, 
                                 RadiusServer.wszName, 
                                 -1, 
                                 szName, 
                                 MAX_PATH, 
                                 NULL, 
                                 NULL );
			
			if ( inet_addr( szName ) == INADDR_NONE )
		    { 
                //
                // resolve name
                //

				struct hostent * phe = gethostbyname( szName );

				if ( phe != NULL )
                { 
                    //
                    // host could have multiple addresses
                    //

					DWORD iAddress = 0;
					
					while( phe->h_addr_list[iAddress] != NULL )
				    {
						RadiusServer.IPAddress.sin_family = AF_INET;
						RadiusServer.IPAddress.sin_port	= htons(sPort);
						RadiusServer.IPAddress.sin_addr.S_un.S_addr	= 
                                      *((PDWORD) phe->h_addr_list[iAddress]);

                        if ( AddRadiusServerToList( &RadiusServer ,
                                                    fAuthenticationServers )
                                                                   == NO_ERROR )
                        {
                            fValidServerFound = TRUE;
                        }
							
						iAddress++;
				    }
                }
                else
                {
                    LPWSTR lpwsRadiusServerName = RadiusServer.wszName;

                    RadiusLogWarning( ROUTERLOG_RADIUS_SERVER_NAME,
                                      1, &lpwsRadiusServerName );
                }
	        }
			else
	        { 
                //
                // use specified ip address
                //

				RadiusServer.IPAddress.sin_family = AF_INET;
				RadiusServer.IPAddress.sin_port = htons(sPort);
				RadiusServer.IPAddress.sin_addr.S_un.S_addr	= inet_addr(szName);

                if ( AddRadiusServerToList(&RadiusServer,
                                           fAuthenticationServers) == NO_ERROR)
                {
                    fValidServerFound = TRUE;
                }
	        }

			RegCloseKey( hKeyServer );
			hKeyServer = NULL;
			dwKeyIndex ++;
			cbKeyServer = sizeof(wszKeyServer);
        }

    } while( FALSE );

    RegCloseKey( hKeyServers );
	RegCloseKey( hKeyServer );

    //
    // if no servers entries are found in registry return error code.
    //

    if ( ( !fValidServerFound ) && ( dwErrorCode == NO_ERROR ) )
    {
	    dwErrorCode = ERROR_NO_RADIUS_SERVERS;
    }

	return( dwErrorCode );
} 

//**
//
// Call:        AddRadiusServerToList
//
// Returns:     NO_ERROR         - Success, Server Node added successfully
//              Non-zero returns - Failure,unsuccessfully in adding server node.
//
// Description: Adds a RADIUS server node into the linked list of avialable 
//              servers.
//
//              INPUT:
//		            pRadiusServer - struct defining attributes for RADIUS server
//
DWORD 
AddRadiusServerToList(
    IN RADIUSSERVER *   pRadiusServer,
    IN BOOL             fAuthentication
)
{
    RADIUSSERVER *      pNewServer;
    DWORD               dwRetCode    = NO_ERROR;
    CRITICAL_SECTION *  pcs;
    LIST_ENTRY *        pListHead;
    BOOL                fServerFound = FALSE;
		
    if ( fAuthentication )
    {
        pcs = &g_csAuth;
    }
    else
    {
        pcs = &g_csAcct;
    }

    EnterCriticalSection( pcs );

    if ( fAuthentication )
    {
        pListHead = &g_AuthServerListHead;
    }
    else
    {
        pListHead = &g_AcctServerListHead;
    }

    //
    // First check to see if this server already exists in the list
    //

    if ( !IsListEmpty( pListHead ) )
    {
        RADIUSSERVER * pServer;

        for ( pServer =  (RADIUSSERVER *)pListHead->Flink;
              pServer != (RADIUSSERVER *)pListHead;
              pServer =  (RADIUSSERVER *)(pServer->ListEntry.Flink) )
        {
            if ( _wcsicmp( pServer->wszName, pRadiusServer->wszName ) == 0 )
            {
                pServer->fDelete = FALSE;

                fServerFound = TRUE;

                break;
            }
        }
    }

    //
    // If the server doesn't exist in the list, add it.
    //

    if ( !fServerFound )
    {
        //
        // Allocate space for node
        //

        pNewServer = (RADIUSSERVER *)LocalAlloc( LPTR, sizeof( RADIUSSERVER ) );

        if ( pNewServer == NULL )
        {
            dwRetCode = GetLastError();
        }
        else
        {
            //
            // Copy server data
            //

            *pNewServer = *pRadiusServer;

            //
	        // Add node to linked list
            //

            InsertHeadList( pListHead, (LIST_ENTRY*)pNewServer );

            pNewServer->fDelete = FALSE;
        }
    }
    else
    {
        pNewServer = pRadiusServer;
    }

    // 
    // Notify it if this is an accounting server and accounting is turned on.
    //

    if ( dwRetCode == NO_ERROR )
    {
        if ( !fAuthentication )
        {
            if ( !NotifyServer( TRUE, pNewServer ) )
            {
                dwRetCode = ERROR_NO_RADIUS_SERVERS;
            }
        }
    }

    LeaveCriticalSection( pcs );

    return( dwRetCode );
} 

//**
//
// Call:        ChooseRadiusServer 
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Selects a RADIUS server to send requests to based on the 
//              servers with the highest score. If multiple server have the 
//              same score they are selected in a roundrobin fashion.
//
//              OUTPUT:
//		            RADIUSSERVER *pServer - pointer to a struct defining 
//                  the server.
//
RADIUSSERVER *
ChooseRadiusServer(
    IN RADIUSSERVER *   pRadiusServer, 
    IN BOOL             fAccounting, 
    IN LONG             lPacketID
)
{
	RADIUSSERVER *      pServer = NULL;
    CRITICAL_SECTION *  pcs;
    LIST_ENTRY *        pListHead;
	RADIUSSERVER *      pCurrentServer;
    
    if ( !fAccounting )
    {
        pcs = &g_csAuth;
    }
    else
    {
        pcs = &g_csAcct;
    }

    EnterCriticalSection( pcs );

    if ( !fAccounting )
    {
        pListHead = &g_AuthServerListHead;
    }
    else
    {
        pListHead = &g_AcctServerListHead;
    }

    if ( IsListEmpty( pListHead ) )
    {
        LeaveCriticalSection( pcs );

        return( NULL );
    }

    pCurrentServer = (RADIUSSERVER *)(pListHead->Flink);

    //
	// Find server with highest score
    //

	for ( pServer =  (RADIUSSERVER *)pListHead->Flink;
          pServer != (RADIUSSERVER *)pListHead;
          pServer =  (RADIUSSERVER *)(pServer->ListEntry.Flink) )
    {
	    if ( pCurrentServer->cScore < pServer->cScore )
		{
	        pCurrentServer = pServer;
        }
	}

    pServer = pCurrentServer;

    //
    // Make a copy of the values & pass them back to the caller.
	// Increment unique packet id counter only if its an Accounting packet
	// or not a retry packet. If its an Accounting packet and a retry packet, 
	// then we update AcctDelayTime; so Identifier must change.
    //

	if (   fAccounting
	    || ( pServer->lPacketID != lPacketID ) )
    {
	    pServer->bIdentifier++;
    }
					
    pServer->lPacketID = lPacketID;
				
	*pRadiusServer = *pServer;

    pServer = pRadiusServer;

    if(     !fAccounting
        &&  (   (NULL == g_pszCurrentServer)
            ||  (0 != _wcsicmp(g_pszCurrentServer,pServer->wszName))))
    {

        LPWSTR auditstrp[1];
        
        if(NULL == g_pszCurrentServer)
        {
            g_pszCurrentServer = LocalAlloc(
                                    LPTR, 
                                    (MAX_PATH+1) * sizeof(WCHAR));
        }

        if(NULL != g_pszCurrentServer)
        {
            //
            // This means radius server changed or we are choosing the server
            // for the first time. In both these cases log an event.
            //
            auditstrp[0] = pServer->wszName;

            RadiusLogInformation(
                            ROUTERLOG_RADIUS_SERVER_CHANGED,
                            1, 
                            auditstrp);

            wcscpy(g_pszCurrentServer,pServer->wszName);
        }
    }

    LeaveCriticalSection( pcs );

	RADIUS_TRACE1("Choosing RADIUS server %ws", pServer->wszName );

	return( pServer );
} 

//**
//
// Call:        GetPointerToServer
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
RADIUSSERVER *
GetPointerToServer(
    IN BOOL     fAuthentication,
    IN LPWSTR   lpwsName
)
{
    RADIUSSERVER *      pServer = NULL;
    CRITICAL_SECTION *  pcs;
    LIST_ENTRY *        pListHead;
    BOOL                fServerFound = FALSE;

    if ( fAuthentication )
    {
        pcs = &g_csAuth;
    }
    else
    {
        pcs = &g_csAcct;
    }

    EnterCriticalSection( pcs );

    if ( fAuthentication )
    {
        pListHead = &g_AuthServerListHead;
    }
    else
    {
        pListHead = &g_AcctServerListHead;
    }

    if ( IsListEmpty( pListHead ) )
    {
        LeaveCriticalSection( pcs );

        return( NULL );
    }

    for ( pServer =  (RADIUSSERVER *)pListHead->Flink;
          pServer != (RADIUSSERVER *)pListHead;
          pServer =  (RADIUSSERVER *)(pServer->ListEntry.Flink) )
    {
        if ( _wcsicmp( pServer->wszName, lpwsName ) == 0 )
        {
            fServerFound = TRUE;
            break;
        }
    }

    LeaveCriticalSection( pcs );

    if ( fServerFound )
    {
        return( pServer );
    }
    else
    {
        return( NULL );
    }
}

//**
//
// Call:        ValidateRadiusServer 
//
// Returns:     None
//
// Description: Used to update the status of the RADIUS servers.
//              All servers start with a score of MAXSCORE
//              Every time a server responding the score is increased by 
//              INCSCORE to a max of MAXSCORE. Every time a server fails to 
//              respond the score is decreased by DECSCORE to a min of MINSCORE
//              Servers with the highest score are selected in a roundrobin 
//              method for servers with equal score
//
//              INPUT:
//		            fResponding - Indicates if the server is responding or not
//
VOID 
ValidateRadiusServer(
    IN RADIUSSERVER *   pServer, 
    IN BOOL             fResponding,
    IN BOOL             fAuthentication
)
{
    RADIUSSERVER *      pRadiusServer;
    CRITICAL_SECTION *  pcs;

    if ( fAuthentication )
    {
        pcs = &g_csAuth;
    }
    else
    {
        pcs = &g_csAcct;
    }

	EnterCriticalSection( pcs );

    pRadiusServer = GetPointerToServer( fAuthentication, pServer->wszName );

    if ( pRadiusServer != NULL )
    {
        if ( fResponding )
        {
	        pRadiusServer->cScore=min(MAXSCORE,pRadiusServer->cScore+INCSCORE);

	        RADIUS_TRACE1("Incrementing score for RADIUS server %ws", 
                           pRadiusServer->wszName );
        }
        else
	    {
            pRadiusServer->cScore=max(MINSCORE,pRadiusServer->cScore-DECSCORE);

	        RADIUS_TRACE1("Decrementing score for RADIUS server %ws", 
                           pRadiusServer->wszName );
        }
    }

	LeaveCriticalSection( pcs );
}

//**
//
// Call:        ReloadConfig 
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Used to dynamically reload configuration information of the 
//              server lists.
DWORD 
ReloadConfig(
    IN BOOL             fAuthentication
)
{
	DWORD		        dwError = NO_ERROR;
	RADIUSSERVER *      pServer = NULL;
    LIST_ENTRY *        pListHead;
    CRITICAL_SECTION *  pcs;

    if ( fAuthentication )
    {
        pcs             = &g_csAuth;
        pListHead       = &g_AuthServerListHead;
    }
    else
    {
        pcs             = &g_csAcct;
        pListHead       = &g_AcctServerListHead;
    }

	EnterCriticalSection( pcs );

    //
    // First mark all servers as to be deleted
    //

    for ( pServer =  (RADIUSSERVER *)pListHead->Flink;
          pServer != (RADIUSSERVER *)pListHead;
          pServer =  (RADIUSSERVER *)(pServer->ListEntry.Flink) )
    {
        pServer->fDelete = TRUE;
    }

    //
    // Now reload server list, don't return on error since we have to 
    // cleanup the list of deleted servers first.
    //

    dwError = LoadRadiusServers( fAuthentication );

    //
    // Now delete the ones that are to be removed
    //

    pServer = (RADIUSSERVER *)pListHead->Flink;

    while( pServer != (RADIUSSERVER *)pListHead )
    {
        if ( pServer->fDelete )
        {
            RADIUSSERVER * pServerToBeDeleted = pServer;

            pServer = (RADIUSSERVER *)(pServer->ListEntry.Flink);

            RemoveEntryList( (LIST_ENTRY *)pServerToBeDeleted ); 

            if ( !fAuthentication )
            {
                NotifyServer( FALSE, pServerToBeDeleted );
            }

            LocalFree( pServerToBeDeleted );
        }
        else
        {
            pServer = (RADIUSSERVER *)(pServer->ListEntry.Flink);
        }
    }

	LeaveCriticalSection( pcs );

	return( dwError );
} 

//**
//
// Call:        NotifyServer
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Notifies the specified RADIUS server of this device is starting 
//              up or shuting down by sending Accounting Start/Stop records.
//              INPUT:
//		            fStart	 - TRUE	    - Accounting Start
//					         - FALSE	- Accounting Stop
//
BOOL 
NotifyServer(
    IN BOOL             fStart,
    IN RADIUSSERVER *   pServer
)
{
	SOCKET		    SockServer              = INVALID_SOCKET;
    DWORD           dwError                 = NO_ERROR;
    BOOL            fRadiusServerResponded  = FALSE;

    do
	{
	    RADIUS_PACKETHEADER	UNALIGNED *pSendHeader;
		RADIUS_PACKETHEADER	UNALIGNED *pRecvHeader;
		BYTE		                  szSendBuffer[MAXBUFFERSIZE];
		BYTE		                  szRecvBuffer[MAXBUFFERSIZE];
		BYTE UNALIGNED			      *prgBuffer;
		RADIUS_ATTRIBUTE UNALIGNED	  *pAttribute;
		fd_set					      fdsSocketRead;
		DWORD					      cRetries;
		INT 					      AttrLength;
        RAS_AUTH_ATTRIBUTE *          pServerAttribute;           
			
        //
	    // send start/stop records only to servers that have 
        // accounting On/Off set.
        //

		if ( !pServer->fAccountingOnOff ) 
        {
            fRadiusServerResponded  = TRUE;
            break;
        }

		pSendHeader                 = (PRADIUS_PACKETHEADER) szSendBuffer;
		pSendHeader->bCode			= ptAccountingRequest;
		pSendHeader->bIdentifier	= pServer->bIdentifier;
		pSendHeader->wLength		= sizeof(RADIUS_PACKETHEADER);
		ZeroMemory( pSendHeader->rgAuthenticator, 
                    sizeof(pSendHeader->rgAuthenticator));

        //
		// set attribute for accounting On/Off
        //

	    pAttribute              = (RADIUS_ATTRIBUTE *) (pSendHeader + 1);
	    pAttribute->bType	    = ptAcctStatusType;
	    pAttribute->bLength	    = sizeof(RADIUS_ATTRIBUTE) + sizeof(DWORD);
	    *((DWORD UNALIGNED *) (pAttribute + 1))	= 
                    htonl(fStart == TRUE ? atAccountingOn : atAccountingOff);

	    pSendHeader->wLength += pAttribute->bLength;

        //
        // Set NAS IP address or Identifier attribute   
        //

	    pAttribute = (RADIUS_ATTRIBUTE *)( (PBYTE)pAttribute +
                                            pAttribute->bLength );

        pServerAttribute = RasAuthAttributeGet( raatNASIPAddress,
                                                g_pServerAttributes );
        if ( pServerAttribute != NULL )
        {
		    pAttribute->bType = (BYTE)(pServerAttribute->raaType);

            if ( pServer->nboNASIPAddress == INADDR_NONE )
            {
                HostToWireFormat32( PtrToUlong(pServerAttribute->Value),
                                    (BYTE *)(pAttribute + 1) );
            }
            else
            {
                CopyMemory( (BYTE*)(pAttribute + 1),
                            (BYTE*)&(pServer->nboNASIPAddress),
                            sizeof( DWORD ) );
            }

		    pAttribute->bLength	= (BYTE) (sizeof( RADIUS_ATTRIBUTE ) + 
                                                pServerAttribute->dwLength);

	        pSendHeader->wLength += pAttribute->bLength;

	        pAttribute = (RADIUS_ATTRIBUTE *)( (PBYTE)pAttribute +
                                               pAttribute->bLength );
        }
        else
        {
            pServerAttribute = RasAuthAttributeGet( raatNASIdentifier,
                                                    g_pServerAttributes );
    
            if ( pServerAttribute != NULL )
            {
		        pAttribute->bType = (BYTE)(pServerAttribute->raaType);

                CopyMemory( (BYTE *)(pAttribute + 1), 
                            (BYTE *)(pServerAttribute->Value),
                            pServerAttribute->dwLength );

		        pAttribute->bLength	= (BYTE) (sizeof( RADIUS_ATTRIBUTE ) + 
                                                pServerAttribute->dwLength);

	            pSendHeader->wLength += pAttribute->bLength;

	            pAttribute = (RADIUS_ATTRIBUTE *)( (PBYTE)pAttribute +
                                                    pAttribute->bLength );
            }
        }

        //
        // Set Account session Id
        //

        pServerAttribute = RasAuthAttributeGet( raatAcctSessionId,
                                                g_pServerAttributes );
    
        if ( pServerAttribute != NULL )
        {
            pAttribute->bType = (BYTE)(pServerAttribute->raaType);

            CopyMemory( (BYTE *)(pAttribute + 1),
                        (BYTE *)(pServerAttribute->Value),
                        pServerAttribute->dwLength );

            pAttribute->bLength = (BYTE)(sizeof( RADIUS_ATTRIBUTE ) +
                                                  pServerAttribute->dwLength);

            pSendHeader->wLength += pAttribute->bLength;
        }

        //
		// convert to network order
        //

        pSendHeader->wLength = htons(pSendHeader->wLength);

        //
	    // Set encryption block
        //

	    {
		    struct MD5Context	MD5c;
			struct MD5Digest	MD5d;

			pServer->IPAddress.sin_port = htons((SHORT)(pServer->AcctPort));
			
			ZeroMemory( pSendHeader->rgAuthenticator, 
                        sizeof(pSendHeader->rgAuthenticator));

			MD5Init(&MD5c);
			MD5Update(&MD5c, szSendBuffer, ntohs(pSendHeader->wLength));
			MD5Update(&MD5c, (PBYTE)pServer->szSecret, pServer->cbSecret);
			MD5Final(&MD5d, &MD5c);
			
			CopyMemory( pSendHeader->rgAuthenticator, 
                        MD5d.digest, 
                        sizeof(pSendHeader->rgAuthenticator));
        }
			
        //
	    // Create a Datagram socket
        //

	    SockServer = socket(AF_INET, SOCK_DGRAM, 0);

	    if (SockServer == INVALID_SOCKET)
        {
            break;
        }

        if ( pServer->nboNASIPAddress != INADDR_NONE )
        {
    		if ( bind( SockServer, 
                          (PSOCKADDR)&pServer->NASIPAddress, 
                          sizeof(pServer->NASIPAddress) ) == SOCKET_ERROR )
            {
                break;
            }
        }

		if ( connect( SockServer, 
                      (PSOCKADDR) &(pServer->IPAddress), 
                      sizeof(pServer->IPAddress)) == SOCKET_ERROR)
        {
            break;
        }

        //
		// Send packet if server doesn't respond within a give amount of 
        // time.
        //

        cRetries = g_cAcctRetries+1;

	    while( cRetries-- > 0 )
		{
		    if ( send( SockServer, 
                       (PCSTR) szSendBuffer, 
                       ntohs(pSendHeader->wLength), 0) == SOCKET_ERROR)
            {
                break;
            }

            RADIUS_TRACE1("Sending Accounting request packet to server %ws",
                           pServer->wszName );
		    TraceSendPacket(szSendBuffer, ntohs(pSendHeader->wLength));

		    FD_ZERO(&fdsSocketRead);
			FD_SET(SockServer, &fdsSocketRead);

		    if ( select( 0, 
                         &fdsSocketRead, 
                         NULL, 
                         NULL, 
                         ( pServer->Timeout.tv_sec == 0 )
                            ? NULL 
                            : &(pServer->Timeout) ) < 1 )
		    {
			    if ( cRetries == 0 )
				{ 
                    LPWSTR lpwsRadiusServerName = pServer->wszName;

                    //
                    // Server didn't respond to any of the requests. 
                    // time to quit asking
                    //

                    RADIUS_TRACE1( "Timeout:Radius server %ws did not respond",
                                   lpwsRadiusServerName );

                    if ( fStart )
                    {
                        RadiusLogWarning( ROUTERLOG_RADIUS_SERVER_NO_RESPONSE,
                                          1, &lpwsRadiusServerName );
                    }

                    dwError = ERROR_AUTH_SERVER_TIMEOUT;

                    break;
			    }
            }
            else
            {
                //
                // Response received
                //

                break;
            }
	    }

        if ( dwError != NO_ERROR )
        {
            break;
        }
				
        AttrLength = recv( SockServer, (PSTR) szRecvBuffer,  MAXBUFFERSIZE, 0 );

        if ( AttrLength == SOCKET_ERROR )
        {
            LPWSTR lpwsRadiusServerName = pServer->wszName;

            //
            // Server didn't respond to any of the requests.
            // time to quit asking
            //

            RADIUS_TRACE1( "Timeout:Radius server %ws did not respond",
                            lpwsRadiusServerName );

            if ( fStart )
            {
                RadiusLogWarning( ROUTERLOG_RADIUS_SERVER_NO_RESPONSE,
                                  1, &lpwsRadiusServerName );
            }

            dwError = ERROR_AUTH_SERVER_TIMEOUT;

            break;
        }

        //
        // Got a response from a RADIUS server.
        //

        fRadiusServerResponded = TRUE;
				
	    pRecvHeader = (PRADIUS_PACKETHEADER) szRecvBuffer;

        //
		// Convert length from network order
        //

        pRecvHeader->wLength = ntohs(pRecvHeader->wLength);

        //
	    // Ignore return packet
        //

        RADIUS_TRACE1("Response received from server %ws", pServer->wszName);
		TraceRecvPacket(szRecvBuffer, pRecvHeader->wLength );

    } while( FALSE );

	if ( SockServer != INVALID_SOCKET )
    {
        closesocket( SockServer );

		SockServer = INVALID_SOCKET;
	} 

    return( fRadiusServerResponded );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\common\hostwire.c ===
/* Copyright (c) 1993, Microsoft Corporation, all rights reserved
**
** hostwire.c
** Gidwanian Host<-->Wire format conversions.
*/

#include <windows.h>
#define INCL_HOSTWIRE
#include "ppputil.h"

//**
//
// Call:	HostToWireFormat16
//
// Returns:	None
//
// Description: Will convert a 16 bit integer from host format to wire format
//
VOID
HostToWireFormat16(
    IN 	   WORD  wHostFormat,
    IN OUT PBYTE pWireFormat
)
{
    *((PBYTE)(pWireFormat)+0) = (BYTE) ((DWORD)(wHostFormat) >>  8);
    *((PBYTE)(pWireFormat)+1) = (BYTE) (wHostFormat);
}


//**
//
// Call:	HostToWireFormat16U
//
// Returns:	None
//
// Description: Will convert a 16 bit integer from host format to wire format
//              (accepts unaligned wire data).
//
VOID
HostToWireFormat16U(
    IN 	   WORD            wHostFormat,
    IN OUT PBYTE           pWireFormat
)
{
    *((PBYTE )(pWireFormat)+0) = (BYTE) ((DWORD)(wHostFormat) >>  8);
    *((PBYTE )(pWireFormat)+1) = (BYTE) (wHostFormat);
}


//**
//
// Call:	WireToHostFormat16
//
// Returns:	WORD	- Representing the integer in host format.
//
// Description: Will convert a 16 bit integer from wire format to host format
//
WORD
WireToHostFormat16(
    IN PBYTE pWireFormat
)
{
    WORD wHostFormat = ((*((PBYTE)(pWireFormat)+0) << 8) +
                        (*((PBYTE)(pWireFormat)+1)));

    return( wHostFormat );
}


//**
//
// Call:	WireToHostFormat16
//
// Returns:	WORD	- Representing the integer in host format.
//
// Description: Will convert a 16 bit integer from wire format to host format
//              (accepts unaligned wire data)
//
WORD
WireToHostFormat16U(
    IN PBYTE pWireFormat
)
{
    WORD wHostFormat = ((*((PBYTE )(pWireFormat)+0) << 8) +
                        (*((PBYTE )(pWireFormat)+1)));

    return( wHostFormat );
}


//**
//
// Call:	HostToWireFormat32
//
// Returns:	nonr
//
// Description: Will convert a 32 bit integer from host format to wire format
//
VOID
HostToWireFormat32(
    IN 	   DWORD dwHostFormat,
    IN OUT PBYTE pWireFormat
)
{
    *((PBYTE)(pWireFormat)+0) = (BYTE) ((DWORD)(dwHostFormat) >> 24);
    *((PBYTE)(pWireFormat)+1) = (BYTE) ((DWORD)(dwHostFormat) >> 16);
    *((PBYTE)(pWireFormat)+2) = (BYTE) ((DWORD)(dwHostFormat) >>  8);
    *((PBYTE)(pWireFormat)+3) = (BYTE) (dwHostFormat);
}


//**
//
// Call:	WireToHostFormat32
//
// Returns:	DWORD	- Representing the integer in host format.
//
// Description: Will convert a 32 bit integer from wire format to host format
//
DWORD
WireToHostFormat32(
    IN PBYTE pWireFormat
)
{
    DWORD dwHostFormat = ((*((PBYTE)(pWireFormat)+0) << 24) +
    			  (*((PBYTE)(pWireFormat)+1) << 16) +
        		  (*((PBYTE)(pWireFormat)+2) << 8)  +
                    	  (*((PBYTE)(pWireFormat)+3) ));

    return( dwHostFormat );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\common\md5.h ===
/*
 ***********************************************************************
 ** md5.h -- Header file for implementation of MD5                    **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version               **
 ** Revised (for MD5): RLR 4/27/91                                    **
 **   -- G modified to have y&~z instead of y&z                       **
 **   -- FF, GG, HH modified to add in last register done             **
 **   -- Access pattern: round 2 works mod 5, round 3 works mod 3     **
 **   -- distinct additive constant for each step                     **
 **   -- round 4 added, working mod 7                                 **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

#ifndef _MD5_
#define _MD5_

/* Data structure for MD5 (Message-Digest) computation */
typedef struct {
  ULONG i[2];                          /* number of _bits_ handled mod 2^64 */
  ULONG buf[4];                                           /* scratch buffer */
  unsigned char in[64];                                     /* input buffer */
  unsigned char digest[16];            /* actual digest after MD5Final call */
} MD5_CTX;

#define MD5_LEN 16

#define PROTO_LIST(list)    list


void MD5Init PROTO_LIST ((MD5_CTX *));
void MD5Update PROTO_LIST ((MD5_CTX *, unsigned char *, unsigned int));
void MD5Final PROTO_LIST ((MD5_CTX *));

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\common\pwutil.c ===
/* Copyright (c) 1994, Microsoft Corporation, all rights reserved
**
** pwutil.c
** Remote Access
** Password handling routines
**
** 03/01/94 Steve Cobb
*/

#include <windows.h>
#include <stdlib.h>
#include <string.h>
#define INCL_PWUTIL
#include <ppputil.h>

#define PASSWORDMAGIC 0xA5

VOID ReverseString( CHAR* psz );


CHAR*
DecodePw(
    IN CHAR chSeed, 
    IN OUT CHAR* pszPassword )

    /* Un-obfuscate 'pszPassword' in place.
    **
    ** Returns the address of 'pszPassword'.
    */
{
    return EncodePw( chSeed, pszPassword );
}


CHAR*
EncodePw(
    IN CHAR chSeed,
    IN OUT CHAR* pszPassword )

    /* Obfuscate 'pszPassword' in place to foil memory scans for passwords.
    **
    ** Returns the address of 'pszPassword'.
    */
{
    if (pszPassword)
    {
        CHAR* psz;

        ReverseString( pszPassword );

        for (psz = pszPassword; *psz != '\0'; ++psz)
        {
            if (*psz != chSeed)
                *psz ^= chSeed;
            /*
            if (*psz != (CHAR)PASSWORDMAGIC)
                *psz ^= PASSWORDMAGIC;
            */
        }
    }

    return pszPassword;
}


VOID
ReverseString(
    CHAR* psz )

    /* Reverses order of characters in 'psz'.
    */
{
    CHAR* pszBegin;
    CHAR* pszEnd;

    for (pszBegin = psz, pszEnd = psz + strlen( psz ) - 1;
         pszBegin < pszEnd;
         ++pszBegin, --pszEnd)
    {
        CHAR ch = *pszBegin;
        *pszBegin = *pszEnd;
        *pszEnd = ch;
    }
}


CHAR*
WipePw(
    IN OUT CHAR* pszPassword )

    /* Zero out the memory occupied by a password.
    **
    ** Returns the address of 'pszPassword'.
    */
{
    if (pszPassword)
    {
        CHAR* psz = pszPassword;

        while (*psz != '\0')
            *psz++ = '\0';
    }

    return pszPassword;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\common\ppputil.h ===
/* Copyright (c) 1993, Microsoft Corporation, all rights reserved
**
** ppputil.h
** Public header for miscellaneuos PPP common library functions.
*/

#ifndef _PPPUTIL_H_
#define _PPPUTIL_H_

#ifdef __cplusplus
extern "C" {
#endif

#ifdef INCL_PARAMBUF

VOID
AddFlagToParamBuf(
    IN CHAR* pszzBuf,
    IN CHAR* pszKey,
    IN BOOL  fValue );

VOID
AddLongToParamBuf(
    IN CHAR* pszzBuf,
    IN CHAR* pszKey,
    IN LONG  lValue );

VOID
AddStringToParamBuf(
    IN CHAR* pszzBuf,
    IN CHAR* pszKey,
    IN CHAR* pszValue );

VOID
ClearParamBuf(
    IN OUT CHAR* pszzBuf );

BOOL
FindFlagInParamBuf(
    IN CHAR* pszzBuf,
    IN CHAR* pszKey,
    IN BOOL* pfValue );

BOOL
FindLongInParamBuf(
    IN CHAR* pszzBuf,
    IN CHAR* pszKey,
    IN LONG* plValue );

BOOL
FindStringInParamBuf(
    IN CHAR* pszzBuf,
    IN CHAR* pszKey,
    IN CHAR* pchValueBuf,
    IN DWORD cbValueBuf );

#endif // INCL_PARAMBUF


#ifdef INCL_PWUTIL

CHAR*
DecodePw(
    IN CHAR chSeed,
    CHAR* pszPassword );

CHAR*
EncodePw(
    IN CHAR chSeed, 
    CHAR* pszPassword );

CHAR*
WipePw(
    CHAR* pszPassword );

#endif // INCL_PWUTIL


#ifdef INCL_ENCRYPT

BOOL
IsEncryptionPermitted();

#endif // INCL_ENCRYPT


#ifdef INCL_HOSTWIRE

VOID
HostToWireFormat16(
    IN  WORD wHostFormat,
    OUT PBYTE pWireFormat );

VOID
HostToWireFormat16U(
    IN  WORD wHostFormat,
    OUT PBYTE pWireFormat );

WORD
WireToHostFormat16(
    IN PBYTE pWireFormat );

WORD
WireToHostFormat16U(
    IN PBYTE pWireFormat );

VOID
HostToWireFormat32(
    IN  DWORD dwHostFormat,
    OUT PBYTE pWireFormat );

DWORD
WireToHostFormat32(
   IN PBYTE pWireFormat );

#endif // INCL_HOSTWIRE


#ifdef INCL_SLSA

NTSTATUS
InitLSA();

VOID
EndLSA();

WORD
GetChallenge(
    OUT PBYTE pChallenge );

DWORD
GetDefaultDomain(
    OUT PWCHAR           pwchDomainName,
    OUT PNT_PRODUCT_TYPE ProductType );

NTSTATUS
GetLsaHandle(
    IN PUNICODE_STRING pSystem OPTIONAL,
    IN OUT PLSA_HANDLE phLsa );

#endif // INCL_SLSA


#ifdef INCL_CLSA

DWORD
GetChallengeResponse(
	IN DWORD dwTraceId,
    IN PBYTE pszUsername,
    IN PBYTE pszPassword,
    IN PLUID pLuid,
    IN PBYTE pbChallenge,
    IN BOOL  fMachineAuth,
    OUT PBYTE CaseInsensitiveChallengeResponse,
    OUT PBYTE CaseSensitiveChallengeResponse,
    OUT PBYTE fUseNtResponse,
    OUT PBYTE pLmSessionKey,
    OUT PBYTE pUserSessionKey
    );

DWORD GetEncryptedOwfPasswordsForChangePassword(
    IN PCHAR pClearTextOldPassword,
    IN PCHAR pClearTextNewPassword,
    IN PLM_SESSION_KEY pLmSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD pEncryptedLmOwfOldPassword,
    OUT PENCRYPTED_LM_OWF_PASSWORD pEncryptedLmOwfNewPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD pEncryptedNtOwfOldPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD pEncryptedNtOwfNewPassword
    );

BOOL Uppercase(
    IN OUT PBYTE pString
    );

VOID
CGetSessionKeys(
    IN  CHAR*             pszPw,
    OUT LM_SESSION_KEY*   pLmKey,
    OUT USER_SESSION_KEY* pUserKey );

#endif // INCL_CLSA


#ifdef INCL_RASUSER

BOOL
DialinPrivilege(
    IN PWCHAR Username,
    IN PWCHAR ServerName );

WORD
GetCallbackPrivilege(
    IN  PWCHAR Username,
    IN  PWCHAR ServerName,
    OUT PCHAR CallbackNumber );

#endif // INCL_RASUSER

#ifdef INCL_RASAUTHATTRIBUTES

RAS_AUTH_ATTRIBUTE *
RasAuthAttributeCreate(
    IN DWORD    dwNumAttributes
);

VOID
RasAuthAttributeDestroy(
    IN RAS_AUTH_ATTRIBUTE * pAttributes
);

RAS_AUTH_ATTRIBUTE *
RasAuthAttributeGet(
    IN RAS_AUTH_ATTRIBUTE_TYPE  raaType,
    IN RAS_AUTH_ATTRIBUTE *     pAttributes
);

VOID
RasAuthAttributesPrint(
    IN  DWORD                   dwTraceID,
    IN  DWORD                   dwFlags,
    IN  RAS_AUTH_ATTRIBUTE *    pInAttributes
);

DWORD
RasAuthAttributeInsert(
    IN DWORD                    dwIndex,
    IN RAS_AUTH_ATTRIBUTE *     pAttributes,
    IN RAS_AUTH_ATTRIBUTE_TYPE  raaType,
    IN BOOL                     fConvertToMultiByte,
    IN DWORD                    dwLength,
    IN PVOID                    Value
);

DWORD
RasAuthAttributeInsertVSA(
    IN DWORD                    dwIndex,
    IN RAS_AUTH_ATTRIBUTE *     pAttributes,
    IN DWORD                    dwVendorId,
    IN DWORD                    dwLength,
    IN PVOID                    pValue
);

RAS_AUTH_ATTRIBUTE * 
RasAuthAttributeCopy(
    IN  RAS_AUTH_ATTRIBUTE *     pAttributes
);

RAS_AUTH_ATTRIBUTE * 
RasAuthAttributeCopyWithAlloc(
    IN  RAS_AUTH_ATTRIBUTE *    pAttributes,
    IN  DWORD                   dwNumExtraAttributes
);

RAS_AUTH_ATTRIBUTE *
RasAuthAttributeGetFirst(
    IN  RAS_AUTH_ATTRIBUTE_TYPE  raaType,
    IN  RAS_AUTH_ATTRIBUTE *     pAttributes,
    OUT HANDLE *                 phAttribute
);

RAS_AUTH_ATTRIBUTE *
RasAuthAttributeGetNext(
    IN  OUT HANDLE                   *phAttribute,
    IN      RAS_AUTH_ATTRIBUTE_TYPE  raaType
);

RAS_AUTH_ATTRIBUTE *
RasAuthAttributeGetVendorSpecific(
    IN  DWORD                   dwVendorId,
    IN  DWORD                   dwVendorType,
    IN  RAS_AUTH_ATTRIBUTE *    pAttributes
);

RAS_AUTH_ATTRIBUTE *
RasAuthAttributeReAlloc(
    IN OUT  RAS_AUTH_ATTRIBUTE *    pAttributes,
    IN      DWORD                   dwNumAttributes
);

CHAR *
RasAuthAttributeGetConcatString(
    IN      RAS_AUTH_ATTRIBUTE_TYPE raaType,
    IN      RAS_AUTH_ATTRIBUTE *    pAttributes,
    IN OUT  DWORD *                 pdwStringLength
);

BYTE *
RasAuthAttributeGetConcatVendorSpecific(
    IN  DWORD                   dwVendorId,
    IN  DWORD                   dwVendorType,
    IN  RAS_AUTH_ATTRIBUTE *    pAttributes
);

#endif

#ifdef INCL_MISC

DWORD
ExtractUsernameAndDomain(
    IN  LPSTR szIdentity,
    OUT LPSTR szUserName,
    OUT LPSTR szDomainName      OPTIONAL
);

#endif

#ifdef __cplusplus
}
#endif

#endif // _PPPUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\common\md5c.c ===
/*
 ***********************************************************************
 ** md5.c                                                             **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 1/91 SRD,AJ,BSK,JT Reference C Version                   **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

//  Portions copyright (c) 1992 Microsoft Corp.
//  All rights reserved



#include <nt.h>
#define UINT4   ULONG

#include <md5.h>


/* Constants for Transform routine.
 */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21

static void TransformMD5 PROTO_LIST ((UINT4 *, UINT4 *));

static unsigned char PADDING[64] = {
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* F, G and H are basic MD5 functions */
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))

/* ROTATE_LEFT rotates x left n bits.
 */
#if CT_COMPILER == CT_MPW

/* MPW doesn't compile the macro correctly, so use a procedure. */
static UINT4 RotateLeft (UINT4, unsigned int);
#define ROTATE_LEFT RotateLeft

#else
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
#endif

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s, ac) \
  {(a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) \
  {(a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) \
  {(a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) \
  {(a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }

void MD5Init (mdContext)
MD5_CTX *mdContext;
{
  mdContext->i[0] = mdContext->i[1] = (UINT4)0;

  /* Load magic initialization constants.
   */
  mdContext->buf[0] = (UINT4)0x67452301;
  mdContext->buf[1] = (UINT4)0xefcdab89;
  mdContext->buf[2] = (UINT4)0x98badcfe;
  mdContext->buf[3] = (UINT4)0x10325476;
}

void MD5Update (mdContext, inBuf, inLen)
MD5_CTX *mdContext;
unsigned char *inBuf;
unsigned int inLen;
{
  UINT4 in[16];
  int mdi;
  unsigned int i, ii;

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3f);

  /* update number of bits */
  if ((mdContext->i[0] + ((UINT4)inLen << 3)) < mdContext->i[0])
    mdContext->i[1]++;
  mdContext->i[0] += ((UINT4)inLen << 3);
  mdContext->i[1] += ((UINT4)inLen >> 29);

  while (inLen--) {
    /* add new character to buffer, increment mdi */
    mdContext->in[mdi++] = *inBuf++;

    /* transform if necessary */
    if (mdi == 0x40) {
      for (i = 0, ii = 0; i < 16; i++, ii += 4)
        in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
                (((UINT4)mdContext->in[ii+2]) << 16) |
                (((UINT4)mdContext->in[ii+1]) << 8) |
                ((UINT4)mdContext->in[ii]);
      TransformMD5 (mdContext->buf, in);
      mdi = 0;
    }
  }
}

void MD5Final (mdContext)
MD5_CTX *mdContext;
{
  UINT4 in[16];
  int mdi;
  unsigned int i, ii;
  unsigned int padLen;

  /* save number of bits */
  in[14] = mdContext->i[0];
  in[15] = mdContext->i[1];

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3f);

  /* pad out to 56 mod 64 */
  padLen = (mdi < 56) ? (56 - mdi) : (120 - mdi);
  MD5Update (mdContext, PADDING, padLen);

  /* append length in bits and transform */
  for (i = 0, ii = 0; i < 14; i++, ii += 4)
    in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
            (((UINT4)mdContext->in[ii+2]) << 16) |
            (((UINT4)mdContext->in[ii+1]) << 8) |
            ((UINT4)mdContext->in[ii]);
  TransformMD5 (mdContext->buf, in);

  /* store buffer in digest */
  for (i = 0, ii = 0; i < 4; i++, ii += 4) {
    mdContext->digest[ii] = (unsigned char)(mdContext->buf[i] & 0xff);
    mdContext->digest[ii+1] =
      (unsigned char)((mdContext->buf[i] >> 8) & 0xff);
    mdContext->digest[ii+2] =
      (unsigned char)((mdContext->buf[i] >> 16) & 0xff);
    mdContext->digest[ii+3] =
      (unsigned char)((mdContext->buf[i] >> 24) & 0xff);
  }
}

/* Basic MD5 step. Transforms buf based on in.
 */
static void TransformMD5 (buf, in)
UINT4 *buf;
UINT4 *in;
{
  UINT4 a = buf[0], b = buf[1], c = buf[2], d = buf[3];

  /* Round 1 */
  FF ( a, b, c, d, in[ 0], S11, 0xd76aa478); /* 1 */
  FF ( d, a, b, c, in[ 1], S12, 0xe8c7b756); /* 2 */
  FF ( c, d, a, b, in[ 2], S13, 0x242070db); /* 3 */
  FF ( b, c, d, a, in[ 3], S14, 0xc1bdceee); /* 4 */
  FF ( a, b, c, d, in[ 4], S11, 0xf57c0faf); /* 5 */
  FF ( d, a, b, c, in[ 5], S12, 0x4787c62a); /* 6 */
  FF ( c, d, a, b, in[ 6], S13, 0xa8304613); /* 7 */
  FF ( b, c, d, a, in[ 7], S14, 0xfd469501); /* 8 */
  FF ( a, b, c, d, in[ 8], S11, 0x698098d8); /* 9 */
  FF ( d, a, b, c, in[ 9], S12, 0x8b44f7af); /* 10 */
  FF ( c, d, a, b, in[10], S13, 0xffff5bb1); /* 11 */
  FF ( b, c, d, a, in[11], S14, 0x895cd7be); /* 12 */
  FF ( a, b, c, d, in[12], S11, 0x6b901122); /* 13 */
  FF ( d, a, b, c, in[13], S12, 0xfd987193); /* 14 */
  FF ( c, d, a, b, in[14], S13, 0xa679438e); /* 15 */
  FF ( b, c, d, a, in[15], S14, 0x49b40821); /* 16 */

  /* Round 2 */
  GG ( a, b, c, d, in[ 1], S21, 0xf61e2562); /* 17 */
  GG ( d, a, b, c, in[ 6], S22, 0xc040b340); /* 18 */
  GG ( c, d, a, b, in[11], S23, 0x265e5a51); /* 19 */
  GG ( b, c, d, a, in[ 0], S24, 0xe9b6c7aa); /* 20 */
  GG ( a, b, c, d, in[ 5], S21, 0xd62f105d); /* 21 */
  GG ( d, a, b, c, in[10], S22,  0x2441453); /* 22 */
  GG ( c, d, a, b, in[15], S23, 0xd8a1e681); /* 23 */
  GG ( b, c, d, a, in[ 4], S24, 0xe7d3fbc8); /* 24 */
  GG ( a, b, c, d, in[ 9], S21, 0x21e1cde6); /* 25 */
  GG ( d, a, b, c, in[14], S22, 0xc33707d6); /* 26 */
  GG ( c, d, a, b, in[ 3], S23, 0xf4d50d87); /* 27 */
  GG ( b, c, d, a, in[ 8], S24, 0x455a14ed); /* 28 */
  GG ( a, b, c, d, in[13], S21, 0xa9e3e905); /* 29 */
  GG ( d, a, b, c, in[ 2], S22, 0xfcefa3f8); /* 30 */
  GG ( c, d, a, b, in[ 7], S23, 0x676f02d9); /* 31 */
  GG ( b, c, d, a, in[12], S24, 0x8d2a4c8a); /* 32 */

  /* Round 3 */
  HH ( a, b, c, d, in[ 5], S31, 0xfffa3942); /* 33 */
  HH ( d, a, b, c, in[ 8], S32, 0x8771f681); /* 34 */
  HH ( c, d, a, b, in[11], S33, 0x6d9d6122); /* 35 */
  HH ( b, c, d, a, in[14], S34, 0xfde5380c); /* 36 */
  HH ( a, b, c, d, in[ 1], S31, 0xa4beea44); /* 37 */
  HH ( d, a, b, c, in[ 4], S32, 0x4bdecfa9); /* 38 */
  HH ( c, d, a, b, in[ 7], S33, 0xf6bb4b60); /* 39 */
  HH ( b, c, d, a, in[10], S34, 0xbebfbc70); /* 40 */
  HH ( a, b, c, d, in[13], S31, 0x289b7ec6); /* 41 */
  HH ( d, a, b, c, in[ 0], S32, 0xeaa127fa); /* 42 */
  HH ( c, d, a, b, in[ 3], S33, 0xd4ef3085); /* 43 */
  HH ( b, c, d, a, in[ 6], S34,  0x4881d05); /* 44 */
  HH ( a, b, c, d, in[ 9], S31, 0xd9d4d039); /* 45 */
  HH ( d, a, b, c, in[12], S32, 0xe6db99e5); /* 46 */
  HH ( c, d, a, b, in[15], S33, 0x1fa27cf8); /* 47 */
  HH ( b, c, d, a, in[ 2], S34, 0xc4ac5665); /* 48 */

  /* Round 4 */
  II ( a, b, c, d, in[ 0], S41, 0xf4292244); /* 49 */
  II ( d, a, b, c, in[ 7], S42, 0x432aff97); /* 50 */
  II ( c, d, a, b, in[14], S43, 0xab9423a7); /* 51 */
  II ( b, c, d, a, in[ 5], S44, 0xfc93a039); /* 52 */
  II ( a, b, c, d, in[12], S41, 0x655b59c3); /* 53 */
  II ( d, a, b, c, in[ 3], S42, 0x8f0ccc92); /* 54 */
  II ( c, d, a, b, in[10], S43, 0xffeff47d); /* 55 */
  II ( b, c, d, a, in[ 1], S44, 0x85845dd1); /* 56 */
  II ( a, b, c, d, in[ 8], S41, 0x6fa87e4f); /* 57 */
  II ( d, a, b, c, in[15], S42, 0xfe2ce6e0); /* 58 */
  II ( c, d, a, b, in[ 6], S43, 0xa3014314); /* 59 */
  II ( b, c, d, a, in[13], S44, 0x4e0811a1); /* 60 */
  II ( a, b, c, d, in[ 4], S41, 0xf7537e82); /* 61 */
  II ( d, a, b, c, in[11], S42, 0xbd3af235); /* 62 */
  II ( c, d, a, b, in[ 2], S43, 0x2ad7d2bb); /* 63 */
  II ( b, c, d, a, in[ 9], S44, 0xeb86d391); /* 64 */

  buf[0] += a;
  buf[1] += b;
  buf[2] += c;
  buf[3] += d;
}

#if CT_COMPILER == CT_MPW
static UINT4 RotateLeft (x, n)
UINT4 x;
unsigned int n;
{
  return (((x) << (n)) | ((x) >> (32-(n))));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\common\misc.c ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    misc.c
//
// Description: Contains miscillaneous functions and routines
//
// History:     Feb 11,1998     NarenG      Created original version.
//

#define UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <rtutils.h>
#include <lmcons.h>
#include <rasauth.h>

#define INCL_MISC
#include "ppputil.h"

#include <stdio.h>
#include <stdlib.h>

//**
//
// Call:        ExtractUsernameAndDomain
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
ExtractUsernameAndDomain(
    IN  LPSTR szIdentity,
    OUT LPSTR szUserName,
    OUT LPSTR szDomainName  OPTIONAL
)
{
    WCHAR * pwchIdentity   = NULL;
    WCHAR * pwchColon      = NULL;
    WCHAR * pwchBackSlash  = NULL;
    WCHAR * wszIdentity    = NULL;
    DWORD dwLen, dwSize;
    DWORD   dwErr          = NO_ERROR;

    *szUserName = (CHAR)NULL;

    if ( szDomainName != NULL )
    {
        *szDomainName = (CHAR)NULL;
    }

    //
    // First, allocate a buffer to hold the unicode version of the
    // identity string
    //
    dwLen = strlen(szIdentity);
    if ( dwLen == 0 )
    {
        dwErr = ERROR_BAD_USERNAME;
        goto LDone;
    }
    dwSize = (dwLen + 1) * sizeof(WCHAR);
    
    //
    // Convert identity to UNICODE string for user name so that
    // a search for '\\' doesn't accidentally succeed. (bug 152088)
    //
    wszIdentity = LocalAlloc ( LPTR, dwSize );
    if ( wszIdentity == NULL )
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto LDone;
    }

    if ( 0 == MultiByteToWideChar(
                    CP_ACP,
                    0,
                    szIdentity,
                    -1,
                    wszIdentity,
                    dwLen + 1 ) )
    {
        dwErr = GetLastError();
        goto LDone;
    }

    pwchIdentity = wszIdentity;
    
    //
    // Parse out username and domain from the Name (domain\username or
    // username format).
    //

    if ( ( pwchBackSlash = wcschr( wszIdentity, L'\\' ) ) != NULL )
    {
        //
        // Extract the domain.
        //

        DWORD cbDomain;

        //
        // Get the domain the user wants to logon to, if one was specified,
        // and convert to UNICODE.
        //

        cbDomain = (DWORD)(pwchBackSlash - pwchIdentity);

        if ( cbDomain > DNLEN )
        {
            dwErr = ERROR_BAD_USERNAME;
            goto LDone;
        }

        if ( szDomainName != NULL )
        {
            dwLen = WideCharToMultiByte(
                        CP_ACP,
                        0,
                        pwchIdentity,
                        cbDomain,
                        szDomainName,
                        cbDomain,
                        NULL,
                        NULL );

            if ( dwLen > 0 )
            {
                szDomainName[ dwLen ] = 0;
            }
            else
            {
                szDomainName[ 0 ] = 0;
            }
        }

        pwchIdentity = pwchBackSlash + 1;
    }
    else
    {
        //
        // No domain name
        //

        if ( szDomainName != NULL )
        {
            szDomainName[ 0 ] = '\0';
        }
    }

    dwLen = wcslen( pwchIdentity );
    if ( dwLen > UNLEN )
    {
        dwErr = ERROR_BAD_USERNAME;
        goto LDone;
    }

    if ( 0 == WideCharToMultiByte(
                        CP_ACP,
                        0,
                        pwchIdentity,
                        -1,
                        szUserName,
                        UNLEN + 1,
                        NULL,
                        NULL ) )
    {
        dwErr = GetLastError();
        goto LDone;
    }

LDone:

    LocalFree( wszIdentity );

    return( dwErr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\eaptls\ceapcfg.cpp ===
/*

Copyright (c) 1997, Microsoft Corporation, all rights reserved

Description:

History:

*/
#include <nt.h>         // Required by windows.h
#include <ntrtl.h>      // Required by windows.h
#include <nturtl.h>     // Required by windows.h
#include <windows.h>    // Win32 base API's

#include <schannel.h>
#define SECURITY_WIN32
#include <sspi.h>       // For CredHandle
#include <wincrypt.h>   // Required by sclogon.h
#include <eaptypeid.h>
#include <rasauth.h>    // Required by raseapif.h
#include <eaptypeid.h>
#include <raseapif.h>
#include <rasman.h>     // For EAPLOGONINFO
#include "eaptls.h"

#include "ceapcfg.h"


extern "C"
DWORD
InvokeServerConfigUI(
    IN  HWND    hWnd,
    IN  WCHAR*  pwszMachineName
);


extern "C"
DWORD
WINAPI PeapInvokeServerConfigUI ( IN HWND hWnd,
                           IN WCHAR * pwszMachineName
                           );


extern "C"
DWORD 
EapTlsInvokeIdentityUI(
    IN  BOOL            fServer,
    IN  BOOL            fRouterConfig,
    IN  DWORD           dwFlags,
    IN  WCHAR*          pszStoreName,
    IN  const WCHAR*    pwszPhonebook,
    IN  const WCHAR*    pwszEntry,
    IN  HWND            hwndParent,
    IN  BYTE*           pConnectionDataIn,
    IN  DWORD           dwSizeOfConnectionDataIn,
    IN  BYTE*           pUserDataIn,
    IN  DWORD           dwSizeOfUserDataIn,
    OUT BYTE**          ppUserDataOut,
    OUT DWORD*          pdwSizeOfUserDataOut,
    OUT WCHAR**         ppwszIdentity
);

extern "C"
DWORD
RasEapInvokeConfigUI(
    IN  DWORD       dwEapTypeId,
    IN  HWND        hwndParent,
    IN  DWORD       dwFlags,
    IN  BYTE*       pConnectionDataIn,
    IN  DWORD       dwSizeOfConnectionDataIn,
    OUT BYTE**      ppConnectionDataOut,
    OUT DWORD*      pdwSizeOfConnectionDataOut
);

extern "C"
DWORD 
RasEapFreeMemory(
    IN  BYTE*   pMemory
);
/*

Returns:

Notes:
    Implementation of IEAPProviderConfig::Initialize
    
*/

STDMETHODIMP
CEapCfg::Initialize(
    LPCOLESTR   pwszMachineName,
    DWORD       dwEapTypeId,
    ULONG_PTR*  puConnectionParam
)
{
    size_t      size;
    WCHAR*      pwsz    = NULL;
    DWORD       dwErr   = NO_ERROR;

    *puConnectionParam = NULL;

    if (dwEapTypeId != PPP_EAP_TLS && dwEapTypeId != PPP_EAP_PEAP)
    {
        dwErr = ERROR_NOT_SUPPORTED;
        goto LDone;
    }

    size = wcslen(pwszMachineName);

    pwsz = (WCHAR*) LocalAlloc(LPTR, (size + 1)*sizeof(WCHAR));

    if (NULL == pwsz)
    {
        dwErr = GetLastError();
        goto LDone;
    }

    CopyMemory(pwsz, pwszMachineName, (size + 1)*sizeof(WCHAR));
    *puConnectionParam = (ULONG_PTR)pwsz;
    pwsz = NULL;

LDone:

    LocalFree(pwsz);

    return(HRESULT_FROM_WIN32(dwErr));
}

/*

Returns:

Notes:
    Implementation of IEAPProviderConfig::Uninitialize

*/

STDMETHODIMP
CEapCfg::Uninitialize(
    DWORD       dwEapTypeId,
    ULONG_PTR   uConnectionParam
)
{
    LocalFree((VOID*)uConnectionParam);
    return(HRESULT_FROM_WIN32(NO_ERROR));
}

/*

Returns:

Notes:
    Implementation of IEAPProviderConfig::ServerInvokeConfigUI
        hWnd - handle to the parent window
        dwRes1 - reserved parameter (ignore)
        dwRes2 - reserved parameter (ignore)

*/

STDMETHODIMP
CEapCfg::ServerInvokeConfigUI(
    DWORD       dwEapTypeId,
    ULONG_PTR   uConnectionParam,
    HWND        hWnd,
    DWORD_PTR   dwRes1,
    DWORD_PTR   dwRes2
)
{
    WCHAR*      pwszMachineName;
    HRESULT     hr;
    DWORD       dwErr;

    if (dwEapTypeId != PPP_EAP_TLS 
#ifdef IMPL_PEAP
        && dwEapTypeId != PPP_EAP_PEAP
#endif
       )
    {
        dwErr = ERROR_NOT_SUPPORTED;
        goto LDone;
    }

    pwszMachineName = (WCHAR*)uConnectionParam;

    if (NULL == pwszMachineName)
    {
        dwErr = E_FAIL;
    }
    else
    {
        if ( dwEapTypeId == PPP_EAP_TLS )
        {
            dwErr = InvokeServerConfigUI(hWnd, pwszMachineName);
        }
#ifdef IMPL_PEAP
        else
        {

            dwErr = PeapInvokeServerConfigUI(hWnd, pwszMachineName);
        }
#endif
    }

LDone:

    hr = HRESULT_FROM_WIN32(dwErr);

    return(hr);
}

/*

Returns:

Notes:
    Implementation of IEAPProviderConfig::RouterInvokeConfigUI

*/

STDMETHODIMP
CEapCfg::RouterInvokeConfigUI(
    DWORD       dwEapTypeId,
    ULONG_PTR   uConnectionParam,
    HWND        hwndParent,
    DWORD       dwFlags,
    BYTE*       pConnectionDataIn,
    DWORD       dwSizeOfConnectionDataIn,
    BYTE**      ppConnectionDataOut,
    DWORD*      pdwSizeOfConnectionDataOut
)
{
    DWORD       dwErr                       = NO_ERROR;
    BYTE*       pConnectionDataOut          = NULL;
    DWORD       dwSizeOfConnectionDataOut   = 0;

    *ppConnectionDataOut = NULL;
    *pdwSizeOfConnectionDataOut = 0;

    if (dwEapTypeId != PPP_EAP_TLS )
    {
        dwErr = ERROR_NOT_SUPPORTED;
        goto LDone;
    }

    dwErr = RasEapInvokeConfigUI(
                dwEapTypeId,
                hwndParent,
                dwFlags,
                pConnectionDataIn,
                dwSizeOfConnectionDataIn,
                &pConnectionDataOut,
                &dwSizeOfConnectionDataOut);

    if (   (NO_ERROR == dwErr)
        && (0 != dwSizeOfConnectionDataOut))
    {
        *ppConnectionDataOut = (BYTE*)CoTaskMemAlloc(dwSizeOfConnectionDataOut);

        if (NULL == *ppConnectionDataOut)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto LDone;
        }

        CopyMemory(*ppConnectionDataOut, pConnectionDataOut,
            dwSizeOfConnectionDataOut);
        *pdwSizeOfConnectionDataOut = dwSizeOfConnectionDataOut;
    }

LDone:

    RasEapFreeMemory(pConnectionDataOut);

    return(HRESULT_FROM_WIN32(dwErr));
}

/*

Returns:

Notes:
    Implementation of IEAPProviderConfig::RouterInvokeCredentialsUI

*/

STDMETHODIMP
CEapCfg::RouterInvokeCredentialsUI(
    DWORD       dwEapTypeId,
    ULONG_PTR   uConnectionParam,
    HWND        hwndParent,
    DWORD       dwFlags,
    BYTE*       pConnectionDataIn,
    DWORD       dwSizeOfConnectionDataIn,
    BYTE*       pUserDataIn,
    DWORD       dwSizeOfUserDataIn,
    BYTE**      ppUserDataOut,
    DWORD*      pdwSizeOfUserDataOut
)
{
#define MAX_STORE_NAME_LENGTH   MAX_COMPUTERNAME_LENGTH + 20

    WCHAR       awszStoreName[MAX_STORE_NAME_LENGTH + 1];
    DWORD       dwErr;
    DWORD       dwSizeOfUserDataOut;
    BYTE*       pUserDataOut            = NULL;
    WCHAR*      pwszIdentityOut         = NULL;
    WCHAR*      pwszMachineName;
    BOOL        fLocal                  = FALSE;

    *ppUserDataOut = NULL;
    *pdwSizeOfUserDataOut = 0;

    if (dwEapTypeId != PPP_EAP_TLS )
    {
        dwErr = ERROR_NOT_SUPPORTED;
        goto LDone;
    }

    pwszMachineName = (WCHAR*)uConnectionParam;

    if (0 == *pwszMachineName)
    {
        fLocal = TRUE;
    }

    wcscpy(awszStoreName, L"\\\\");
    wcsncat(awszStoreName, pwszMachineName, MAX_COMPUTERNAME_LENGTH);
    wcsncat(awszStoreName, L"\\MY", wcslen(L"\\MY"));
    if ( dwEapTypeId == PPP_EAP_TLS )
    {
        dwErr = EapTlsInvokeIdentityUI(
                    FALSE /* fServer */,
                    TRUE /* fRouterConfig */,
                    dwFlags,
                    fLocal ? L"MY" : awszStoreName,
                    L"",
                    L"",
                    hwndParent,
                    pConnectionDataIn,
                    dwSizeOfConnectionDataIn,
                    pUserDataIn,
                    dwSizeOfUserDataIn,
                    &pUserDataOut,
                    &dwSizeOfUserDataOut,
                    &pwszIdentityOut);

        if (   (NO_ERROR == dwErr)
            && (0 != dwSizeOfUserDataOut))
        {
            *ppUserDataOut = (BYTE*)CoTaskMemAlloc(dwSizeOfUserDataOut);

            if (NULL == *ppUserDataOut)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto LDone;
            }

            CopyMemory(*ppUserDataOut, pUserDataOut, dwSizeOfUserDataOut);
            *pdwSizeOfUserDataOut = dwSizeOfUserDataOut;
        }
    }
    else
    {
        //Show PEAP dialog to get identity for router...
    }

LDone:

    RasEapFreeMemory(pUserDataOut);
    RasEapFreeMemory((BYTE*)pwszIdentityOut);

    return(HRESULT_FROM_WIN32(dwErr));
}


extern "C"
{
//utility function kept here so that we dont have to get the COM junk in other files

DWORD PeapEapInfoInvokeServerConfigUI ( HWND            hWndParent,
                                        LPWSTR          lpwszMachineName,
                                        PPEAP_EAP_INFO  pEapInfo
                                      )
{
    DWORD                       dwRetCode = NO_ERROR;
    GUID                        guid;
    HRESULT                     hr = S_OK;
    ULONG_PTR                   uConnection = 0;
    CComPtr<IEAPProviderConfig> spEAPConfig;


    hr = CLSIDFromString(pEapInfo->lpwszConfigClsId, &guid);

    if (FAILED(hr)) goto L_ERR;

    // Create the EAP provider object
   // ----------------------------------------------------------------
    hr = CoCreateInstance(  guid,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            __uuidof(IEAPProviderConfig),
                            (LPVOID *) &spEAPConfig);
    if (FAILED(hr )) goto L_ERR;

    // Configure this EAP provider
   // ----------------------------------------------------------------
   // EAP configure displays its own error message, so no hr is kept
   
    if ( !FAILED(spEAPConfig->Initialize(lpwszMachineName, pEapInfo->dwTypeId, &uConnection)) )
    {
        spEAPConfig->ServerInvokeConfigUI(pEapInfo->dwTypeId, uConnection, hWndParent, 0, 0);
        spEAPConfig->Uninitialize(pEapInfo->dwTypeId, uConnection);
    }

    if ( hr == E_NOTIMPL )
        hr = S_OK;

L_ERR:
    if ( FAILED(hr) )
    {
        dwRetCode = hr;      
    }


    return dwRetCode;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\common\parambuf.c ===
/* Copyright (c) 1994, Microsoft Corporation, all rights reserved
**
** parambuf.c
** Double-NUL terminated buffer of "key=value" parameter routines.
**
** 03/14/94 Steve Cobb
*/

#include <windows.h>
#include <string.h>
#include <stdlib.h>
#define INCL_PARAMBUF
#include "ppputil.h"


VOID
AddFlagToParamBuf(
    IN CHAR* pszzBuf,
    IN CHAR* pszKey,
    IN BOOL  fValue )

    /* Add a "key=value" entry with key 'pszKey' and value 'fValue' to
    ** double-NUL terminated buffer of "key=value"s 'pszzBuf'.
    */
{
    AddStringToParamBuf( pszzBuf, pszKey, (fValue) ? "1" : "0" );
}


VOID
AddLongToParamBuf(
    IN CHAR* pszzBuf,
    IN CHAR* pszKey,
    IN LONG  lValue )

    /* Add a "key=value" entry with key 'pszKey' and value 'lValue' to
    ** double-NUL terminated buffer of "key=value"s 'pszzBuf'.
    */
{
    CHAR szNum[ 33 + 1 ];

    _ltoa( lValue, szNum, 10 );
    AddStringToParamBuf( pszzBuf, pszKey, szNum );
}


VOID
AddStringToParamBuf(
    IN CHAR* pszzBuf,
    IN CHAR* pszKey,
    IN CHAR* pszValue )

    /* Add a "key=value" entry with key 'pszKey' and value 'pszValue' to
    ** double-NUL terminated buffer of "key=value"s 'pszzBuf'.
    */
{
    CHAR* psz;
    INT   cb;

    for (psz = pszzBuf; (cb = strlen( psz )) > 0; psz += cb + 1)
        ;

    if (!pszValue)
        pszValue = "";

    strcpy( psz, pszKey );
    strcat( psz, "=" );
    strcat( psz, pszValue );
    psz[ strlen( psz ) + 1 ] = '\0';
}


VOID
ClearParamBuf(
    IN OUT CHAR* pszzBuf )

    /* Clears double-NUL terminated buffer of "key=value"s 'pszzBuf'.
    */
{
    pszzBuf[ 0 ] = pszzBuf[ 1 ] = '\0';
}


BOOL
FindFlagInParamBuf(
    IN CHAR* pszzBuf,
    IN CHAR* pszKey,
    IN BOOL* pfValue )

    /* Loads caller's 'pfValue' with the flag value associated with the key
    ** 'pszKey' in double-NUL terminated buffer of "key=value"s 'pszzBuf'.
    **
    ** Returns true if the parameter was found, false otherwise.
    */
{
    CHAR szBuf[ 2 ];

    if (FindStringInParamBuf( pszzBuf, pszKey, szBuf, 2 ))
    {
        *pfValue = (szBuf[ 0 ] == '1');
        return TRUE;
    }

    return FALSE;
}


BOOL
FindLongInParamBuf(
    IN CHAR* pszzBuf,
    IN CHAR* pszKey,
    IN LONG* plValue )

    /* Loads caller's 'plValue' with the long value associated with the key
    ** 'pszKey' in double-NUL terminated buffer of "key=value"s 'pszzBuf'.
    **
    ** Returns true if the parameter was found, false otherwise.
    */
{
    CHAR szBuf[ 33 + 1 ];

    if (FindStringInParamBuf( pszzBuf, pszKey, szBuf, 33 ))
    {
        *plValue = atol( szBuf );
        return TRUE;
    }

    return FALSE;
}


BOOL
FindStringInParamBuf(
    IN CHAR* pszzBuf,
    IN CHAR* pszKey,
    IN CHAR* pchValueBuf,
    IN DWORD cbValueBuf )

    /* Loads caller's 'pchValueBuf' with the value associated with the key
    ** 'pszKey' in double-NUL terminated buffer of "key=value"s 'pszzBuf'.
    ** The string is truncated at 'cbValueBuf' if necessary.
    **
    ** Returns true if the parameter was found, false otherwise.
    */
{
    INT   cbSearchKey = strlen( pszKey );
    CHAR* psz;
    INT   cb;

    for (psz = pszzBuf; (cb = strlen( psz )) > 0; psz += cb + 1)
    {
        CHAR* pszKeyEnd = strchr( psz, '=' );
        INT   cbKey = (pszKeyEnd) ? (LONG)(pszKeyEnd - psz) : 0;

        if (cbKey == cbSearchKey && _strnicmp( psz, pszKey, cbKey ) == 0)
        {
            strncpy( pchValueBuf, pszKeyEnd + 1, cbValueBuf );
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\eaptls\ceapcfg.h ===
/*

Copyright (c) 1997, Microsoft Corporation, all rights reserved

Description:

History:

*/

#ifndef _CEAPCFG_H_
#define _CEAPCFG_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <rrascfg.h>    // IEAPProviderConfig declarations

#include "resource.h"

// Define this here so that our macros will expand correctly
#define IMPL

// External references
extern const CLSID  CLSID_EapCfg;

class ATL_NO_VTABLE CEapCfg :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CEapCfg, &CLSID_EapCfg>,
    public IEAPProviderConfig
{
public:
    CEapCfg()  {}

DECLARE_REGISTRY_RESOURCEID(IDR_EAPCFG)
DECLARE_NOT_AGGREGATABLE(CEapCfg)

BEGIN_COM_MAP(CEapCfg)
    COM_INTERFACE_ENTRY(IEAPProviderConfig)
END_COM_MAP()

public:
    // This is the declaration of the UI interface members.
    // See rrascfg.idl for the prototypes
    DeclareIEAPProviderConfigMembers(IMPL);
};

#endif // _CEAPCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\eaptls\eaptls.h ===
/*

Copyright (c) 1997, Microsoft Corporation, all rights reserved

File:
    eaptls.h

Description:
    PPP EAP TLS Authentication Protocol. Based on RFC xxxx.

History:
    Oct 9, 1997: Vijay Baliga created original version.

*/

#ifndef _EAPTLS_H_
#define _EAPTLS_H_

#define EAPTLS_KEY_13 L"System\\CurrentControlSet\\Services\\Rasman\\PPP\\EAP\\13"
#define EAPTLS_VAL_SERVER_CONFIG_DATA           L"ServerConfigData"
#define EAPTLS_VAL_MAX_TLS_MESSAGE_LENGTH       L"MaxTLSMessageLength"
#define EAPTLS_VAL_IGNORE_NO_REVOCATION_CHECK   L"IgnoreNoRevocationCheck"
#define EAPTLS_VAL_IGNORE_REVOCATION_OFFLINE    L"IgnoreRevocationOffline"
#define EAPTLS_VAL_NO_ROOT_REVOCATION_CHECK     L"NoRootRevocationCheck"
#define EAPTLS_VAL_NO_REVOCATION_CHECK          L"NoRevocationCheck"

#define EAPTLS_8021x_PIN_DATA_DESCR             L"starcehvionrsf"


#define MAX_HASH_SIZE       20      // Certificate hash size

// EAPTLS_PACKET flags

#define     EAPTLS_PACKET_FLAG_LENGTH_INCL              0x80
#define     EAPTLS_PACKET_FLAG_MORE_FRAGMENTS           0x40
#define     EAPTLS_PACKET_FLAG_TLS_START                0x20

//
// Versioning for PEAP.  This will include the highest and lowest
// supported versions
//
#define     EAPTLS_PACKET_HIGHEST_SUPPORTED_VERSION     0x00
#define     EAPTLS_PACKET_LOWEST_SUPPORTED_VERSION      0x00
#define     EAPTLS_PACKET_CURRENT_VERSION               0x00

typedef struct _EAPTLS_PACKET
{
    BYTE    bCode;          // See EAPCODE_*
    BYTE    bId;            // Id of this packet
    BYTE    pbLength[2];    // Length of this packet
    BYTE    bType;          // Should be PPP_EAP_TLS 
                            // (only for Request, Response)
    BYTE    bFlags;         // See EAPTLS_PACKET_FLAG_*
                            // (only for Request, Response)
    BYTE    pbData[1];      // Data
                            // (only for Request, Response)
} EAPTLS_PACKET;

#define EAPTLS_PACKET_HDR_LEN       (sizeof(EAPTLS_PACKET) - 1)

// The largest EAP TLS header has 4 more octects for TLS blob size

#define EAPTLS_PACKET_HDR_LEN_MAX   (EAPTLS_PACKET_HDR_LEN + 4)

// EAP TLS states

typedef enum EAPTLS_STATE
{
    EAPTLS_STATE_INITIAL,
    EAPTLS_STATE_SENT_START,        // Server only
    EAPTLS_STATE_SENT_HELLO,
    EAPTLS_STATE_SENT_FINISHED,
    EAPTLS_STATE_RECD_FINISHED,     // Client only
    EAPTLS_STATE_SENT_RESULT,       // Server only
    EAPTLS_STATE_RECD_RESULT,       // Client only
    EAPTLS_STATE_WAIT_FOR_USER_OK   // Client only


} EAPTLS_STATE;

// Highest number we can handle

#define EAPTLS_STATE_LIMIT EAPTLS_STATE_RECD_RESULT

typedef struct _EAPTLS_HASH
{
    DWORD   cbHash;                 // Number of bytes in the hash
    BYTE    pbHash[MAX_HASH_SIZE];  // The hash of a certificate

} EAPTLS_HASH;

// Values of the EAPTLS_CONN_PROPERTIES->fFlags field

// Use a certificate on this machine
#define     EAPTLS_CONN_FLAG_REGISTRY           0x00000001
// Do not validate server cert
#define     EAPTLS_CONN_FLAG_NO_VALIDATE_CERT   0x00000002
// Do not Validate server name
#define     EAPTLS_CONN_FLAG_NO_VALIDATE_NAME   0x00000004
// Send a different EAP Identity
#define     EAPTLS_CONN_FLAG_DIFF_USER          0x00000008
// User simple cert selection logic
#define     EAPTLS_CONN_FLAG_SIMPLE_CERT_SEL    0x00000010

#define     EAPTLS_CONN_PROP_WATERMARK          0xBEEFFEEB
//
// EAPTLS_CONN_PROPERTIES + EAPTLS_CONN_PROPERTIES_V1_EXTRA
// are send back to the calling application.  However, internally
// EAPTLS_CONN_PROPERTIES_V1 is used.
//

typedef struct _EAPTLS_CONN_PROPERTIES
{
    DWORD       dwVersion;              //Version will be 1 for this release
    DWORD       dwSize;                 // Number of bytes in this structure
    DWORD       fFlags;                 // See EAPTLS_CONN_FLAG_*
    EAPTLS_HASH Hash;                   // Hash of the first certificate
    WCHAR       awszServerName[1];       // server name of the first server
} EAPTLS_CONN_PROPERTIES;


//
// This is a very messy way of doing things
// but cannot help it because the verion
// checking on the data structure was not
// done to begin with.  Hopefully some day
// we will be able to get away from this
// deal.  Other part of the story is CM is
// unable to create targetted connectoids. 
// So we have to carry this structure going
// ahead unless CM is smart about targetted
// connectoids.

//
// Additional stuff required in 
// version 1 of data structure
//
typedef struct _EAPTLS_CONN_PROPERTIES_V1_EXTRA     
{
    DWORD       dwNumHashes;            // Number of Hashes in the 
                                        // structure including the one
                                        // in v0 struct above    
    BYTE        bData[1];               // Data - contains an array of
                                        // EAPTLS_HASH structures followed by
                                        // a string specifying server names
                                        // minus the first server
}EAPTLS_CONN_PROPERTIES_V1_EXTRA;



//The new v1.0 structure used internally
typedef struct _EAPTLS_CONN_PROPERTIES_V1
{
    DWORD       dwVersion;              // Version will be 1 for this release
    DWORD       dwSize;                 // Number of bytes in this structure
    DWORD       fFlags;                 // See EAPTLS_CONN_FLAG_*
    DWORD       dwNumHashes;            // Number of hash structures in the list
    BYTE        bData[1];               // Data - contains an array of
                                        // EAPTLS_HASH structures followed by
                                        // a string specifying server name
}EAPTLS_CONN_PROPERTIES_V1;

// The old 'PIN must be saved' flag
#define     EAPTLS_USER_FLAG_OLD_SAVE_PIN       0x00000001

// The PIN must be saved
#define     EAPTLS_USER_FLAG_SAVE_PIN           0x00000002

typedef struct _EAPTLS_USER_PROPERTIES
{
    DWORD       reserved;               // Must be 0 (compare with EAPLOGONINFO)
    DWORD       dwVersion;
    DWORD       dwSize;                 // Number of bytes in this structure
    DWORD       fFlags;                 // See EAPTLS_USER_FLAG_*
    EAPTLS_HASH Hash;                   // Hash for the user certificate
    WCHAR*      pwszDiffUser;           // The EAP Identity to send
    DWORD       dwPinOffset;            // Offset in abData
    WCHAR*      pwszPin;                // The smartcard PIN
    USHORT      usLength;               // Part of UnicodeString
    USHORT      usMaximumLength;        // Part of UnicodeString
    UCHAR       ucSeed;                 // To unlock the UnicodeString
    WCHAR       awszString[1];          // Storage for pwszDiffUser and pwszPin

} EAPTLS_USER_PROPERTIES;

typedef struct _EAPTLS_PIN
{
    WCHAR *pwszPin;
    USHORT usLength;
    USHORT usMaximumLength;
    UCHAR ucSeed;
} EAPTLS_PIN;

// Values of the EAPTLSCB->fFlags field

// We are the server

#define     EAPTLSCB_FLAG_SERVER                0x00000001

// We are a router

#define     EAPTLSCB_FLAG_ROUTER                0x00000002

// The call is happening during logon

#define     EAPTLSCB_FLAG_LOGON                 0x00000004

// Negotiation is complete, and so far appears successful. A server may get a 
// TLS Alert message from the client at this point, in which case it will 
// realize that the negotiation was unsuccessful. However, a client never 
// changes its mind.

#define     EAPTLSCB_FLAG_SUCCESS               0x00000008

// The peer has a large blob to send. So it has divided it into fragments

#define     EAPTLSCB_FLAG_RECEIVING_FRAGMENTS   0x00000010

// Keeps track of whether we need to call FreeCredentialsHandle(hCredential)

#define     EAPTLSCB_FLAG_HCRED_INVALID         0x00000020

// Keeps track of whether we need to call DeleteSecurityContext(hContext)

#define     EAPTLSCB_FLAG_HCTXT_INVALID         0x00000040

// We are not allowed to display any UI

#define     EAPTLSCB_FLAG_NON_INTERACTIVE       0x00000080

// This is the first link in a multilink bundle. This is not a callback.

#define     EAPTLSCB_FLAG_FIRST_LINK            0x00000100

// The user data was obtained from Winlogon

#define     EAPTLSCB_FLAG_WINLOGON_DATA         0x00000200

// We are doing Machine Authentication
#define     EAPTLSCB_FLAG_MACHINE_AUTH          0x00000400

// We are providing guest access
#define     EAPTLSCB_FLAG_GUEST_ACCESS          0x00000800

//We want to do something specific to 8021x auth
#define     EAPTLSCB_FLAG_8021X_AUTH            0x00001000

//We are using cached credentials
#define     EAPTLSCB_FLAG_USING_CACHED_CREDS    0x00002000

//We are running in PEAP context
#define     EAPTLSCB_FLAG_EXECUTING_PEAP        0x00004000


// The EAP TLS work buffer

typedef struct _EAPTLS_CONTROL_BLOCK
{
    EAPTLS_STATE    EapTlsState;
    DWORD           fFlags;                 // See EAPTLSCB_FLAG_*
    HANDLE          hTokenImpersonateUser;  // Client only
    WCHAR           awszIdentity[UNLEN + 1];// Server only

    RAS_AUTH_ATTRIBUTE*     pAttributes;    // Username or MPPE key
    EAPTLS_CONN_PROPERTIES_V1* pConnProp;      // Client only
    EAPTLS_CONN_PROPERTIES_V1 * pNewConnProp;// Client only
    EAPTLS_USER_PROPERTIES* pUserProp;

    // Client only, EAPTLSCB_FLAG_LOGON only
    BYTE*           pUserData;
    DWORD           dwSizeOfUserData;

    PCCERT_CONTEXT  pCertContext;
    CredHandle      hCredential;            // The credentials handle
    CtxtHandle      hContext;               // The context handle
    ULONG           fContextReq;            // Required context attributes

    BYTE*           pbBlobIn;               // TLS blob received from the peer
    DWORD           cbBlobIn;               // Number of bytes in the TLS blob
                                            // received from the peer
    DWORD           cbBlobInBuffer;         // Number of bytes allocated for the
                                            // pbBlobIn buffer

    DWORD           dwBlobInRemining;       // We are receiving fragments from 
                                            // the peer and the peer has 
                                            // promised to send dwBlobInRemining
                                            // more bytes

    BYTE*           pbBlobOut;              // TLS blob created for the peer
    DWORD           cbBlobOut;              // Number of bytes in the TLS blob
                                            // created for the peer
    DWORD           cbBlobOutBuffer;        // Number of bytes allocated for the
                                            // pbBlobOut buffer

    DWORD           dwBlobOutOffset;        // Pointer to the first byte in
                                            // pbBlobOut that has to be sent
    DWORD           dwBlobOutOffsetNew;     // Update dwBlobOutOffset to this 
                                            // value when the peer confirms 
                                            // receipt of the previous packet

    BYTE            bCode;                  // bCode of the last packet sent
    BYTE            bId;                    // bId of the last packet sent

    DWORD           dwAuthResultCode;       // The error code that we get when
                                            // the negotiation is complete
    EAPTLS_PIN      *pSavedPin;             //
    HANDLE          hEventLog;
    BYTE*           pUIContextData;
    BYTE            bNextId;                // Saved when we raise UI
    EAPTLS_PACKET   ReceivePacket;          // Saved when we go off to get PIN

} EAPTLSCB;

typedef struct _EAPTLS_CERT_NODE EAPTLS_CERT_NODE;

struct _EAPTLS_CERT_NODE
{
    EAPTLS_CERT_NODE*   pNext;
    EAPTLS_HASH         Hash;
    WCHAR*              pwszDisplayName;
    WCHAR*              pwszFriendlyName;
    WCHAR*              pwszIssuer;
    WCHAR*              pwszExpiration;    
    //
    // New fields added vivekk
    //
    FILETIME            IssueDate;
#if 0
    WCHAR*              pwszIssuedTo;
    WCHAR*              pwszIssuedBy;
#endif
};

// Values of the EAPTLS_CONN_DIALOG->fFlags field

// We are a router

#define     EAPTLS_CONN_DIALOG_FLAG_ROUTER      0x00000001
#define     EAPTLS_CONN_DIALOG_FLAG_READONLY    0x00000002

typedef struct _EAPTLS_CONN_DIALOG
{
    DWORD                   fFlags;                 // See
                                                    // EAPTLS_CONN_DIALOG_FLAG_*

    EAPTLS_CERT_NODE*       pCertList;              //List of all the root certificates
                                                    //from internet trusted root store
    EAPTLS_CERT_NODE**      ppSelCertList;          //List of pointers to selected certs.
                                                    //will be as many as num hashes
                                                    //in conn prop.
    EAPTLS_CONN_PROPERTIES* pConnProp;              // ConfigData in phonebook
    EAPTLS_CONN_PROPERTIES_V1 * pConnPropv1;       // Version 1.0 config data

    HWND                    hWndRadioUseCard;
    HWND                    hWndRadioUseRegistry;
    HWND                    hWndCheckValidateCert;
    HWND                    hWndCheckValidateName;
    HWND                    hWndEditServerName;
    HWND                    hWndStaticRootCaName;
    //HWND                    hWndComboRootCaName;      //This will go away
    HWND                    hWndListRootCaName;         //This is the new list
    HWND                    hWndCheckDiffUser;
    HWND                    hWndCheckUseSimpleSel;
    HWND                    hWndViewCertDetails;

} EAPTLS_CONN_DIALOG;



// Values of the EAPTLS_USER_DIALOG->fFlags field

// We need to send a different EAP Identity

#define     EAPTLS_USER_DIALOG_FLAG_DIFF_USER           0x00000001

// We need to change the title

#define     EAPTLS_USER_DIALOG_FLAG_DIFF_TITLE          0x00000002

//USe simple cert selection
#define     EAPTLS_USER_DIALOG_FLAG_USE_SIMPLE_CERTSEL  0x00000004
//
// Nodes are grouped by displayname
// 


typedef struct _EAPTLS_GROUPED_CERT_NODES EAPTLS_GROUPED_CERT_NODES;
typedef struct _EAPTLS_GROUPED_CERT_NODES* PEAPTLS_GROUPED_CERT_NODES;

struct _EAPTLS_GROUPED_CERT_NODES
{
    PEAPTLS_GROUPED_CERT_NODES      pNext;
    WCHAR*                          pwszDisplayName;

    //Most current one in the colation...
    EAPTLS_CERT_NODE*               pMostRecentCert; 
};



typedef struct _EAPTLS_USER_DIALOG
{
    DWORD                       fFlags;                 // See 
                                                    // EAPTLS_USER_DIALOG_FLAG_*
    EAPTLS_CERT_NODE*           pCertList;
    EAPTLS_CERT_NODE*           pCert;
    PEAPTLS_GROUPED_CERT_NODES  pGroupedList;
    EAPTLS_USER_PROPERTIES*     pUserProp;              // UserData in registry
    const WCHAR*                pwszEntry;
    const WCHAR*                pwszStoreName;
    BOOL                        fIdentity;              //Identity UI is being shown here
    HWND                        hWndComboUserName;
    HWND                        hWndBtnViewCert;
    // These are required for the server's certificate selection
    HWND                        hWndEditFriendlyName;
    HWND                        hWndEditIssuer;
    HWND                        hWndEditExpiration;
    HWND                        hWndStaticDiffUser;
    HWND                        hWndEditDiffUser;

} EAPTLS_USER_DIALOG;

// Values of the EAPTLS_PIN_DIALOG->fFlags field

// We need to send a different EAP Identity

#define     EAPTLS_PIN_DIALOG_FLAG_DIFF_USER    0x00000001

// The UI is coming up before Logon

#define     EAPTLS_PIN_DIALOG_FLAG_LOGON        0x00000002

#define     EAPTLS_PIN_DIALOG_FLAG_ROUTER       0x00000004

typedef struct _EAPTLS_PIN_DIALOG
{
    DWORD                   fFlags;                 // See 
                                                    // EAPTLS_PIN_DIALOG_FLAG_*
    EAPTLS_USER_PROPERTIES* pUserProp;              // UserData in registry
    const WCHAR*            pwszEntry;
    PCCERT_CONTEXT          pCertContext;           //Certificate Context for selected certificate.
	DWORD					dwRetCode;				//Return Code of Validate PIN operation.
    HWND                    hWndStaticDiffUser;
    HWND                    hWndEditDiffUser;
    HWND                    hWndStaticPin;
    HWND                    hWndEditPin;

} EAPTLS_PIN_DIALOG;

#define NUM_CHARS_TITLE     100

typedef struct _EAPTLS_VALIDATE_SERVER
{
    DWORD                   dwSize;
    DWORD                   fShowCertDetails;
    EAPTLS_HASH             Hash;           //Hash of the root certificate to show details
    WCHAR                   awszTitle[NUM_CHARS_TITLE];
    WCHAR                   awszWarning[1];

} EAPTLS_VALIDATE_SERVER;

#ifdef ALLOC_EAPTLS_GLOBALS

DWORD           g_dwEapTlsTraceId           = INVALID_TRACEID;

int g_nEapTlsClientNextState[] =
{
    EAPTLS_STATE_SENT_HELLO,
    EAPTLS_STATE_INITIAL,           // Impossible
    EAPTLS_STATE_SENT_FINISHED,
    EAPTLS_STATE_RECD_FINISHED,
    EAPTLS_STATE_RECD_RESULT,
    EAPTLS_STATE_INITIAL,           // Impossible
    EAPTLS_STATE_RECD_RESULT,
    EAPTLS_STATE_RECD_FINISHED
};

int g_nEapTlsServerNextState[] =
{
    EAPTLS_STATE_SENT_START,
    EAPTLS_STATE_SENT_HELLO,
    EAPTLS_STATE_SENT_FINISHED,
    EAPTLS_STATE_SENT_RESULT,
    EAPTLS_STATE_INITIAL,           // Impossible
    EAPTLS_STATE_SENT_RESULT,
    EAPTLS_STATE_INITIAL,           // Impossible
    EAPTLS_STATE_INITIAL,           // Impossible
};

CHAR *g_szEapTlsState[] =
{
    "Initial",
    "SentStart",
    "SentHello",
    "SentFinished",
    "RecdFinished",
    "SentResult",
    "RecdResult",
    "WaitForUserOK",
};

#else // !ALLOC_EAPTLS_GLOBALS

extern DWORD    g_dwEapTlsTraceId;

#endif // ALLOC_EAPTLS_GLOBALS

// Prototypes for functions in util.c

VOID   
EapTlsTrace(
    IN  CHAR*   Format, 
    ... 
);

DWORD
EapTlsInitialize2(
    IN  BOOL    fInitialize,
    IN  BOOL    fUI
);

DWORD
EapTlsInitialize(
    IN  BOOL    fInitialize
);

VOID
EncodePin(
    IN  EAPTLS_USER_PROPERTIES* pUserProp
);

VOID
DecodePin(
    IN  EAPTLS_USER_PROPERTIES* pUserProp
);

BOOL 
FFormatMachineIdentity1 ( 
    LPWSTR lpszMachineNameRaw, 
    LPWSTR * lppszMachineNameFormatted );

BOOL 
FFormatMachineIdentity ( 
    IN LPWSTR lpszMachineNameRaw, 
    OUT LPWSTR * lppszMachineNameFormatted );

BOOL
FCertToStr(
    IN  PCCERT_CONTEXT  pCertContext,
    IN  DWORD           fFlags,
    IN  BOOL            fMachineCert,
    OUT WCHAR**         ppwszName
);

BOOL
FMachineAuthCertToStr (
	IN 	PCCERT_CONTEXT 	pCertContext, 
	OUT WCHAR		**	ppwszName
);


BOOL
FGetFriendlyName(
    IN  PCCERT_CONTEXT  pCertContext,
    OUT WCHAR**         ppwszName
);

BOOL
FSmartCardReaderInstalled(
    VOID
);

DWORD DwGetEKUUsage ( 
	IN PCCERT_CONTEXT			pCertContext,
	OUT PCERT_ENHKEY_USAGE	*	ppUsage
	);

BOOL
FCheckUsage(
    IN  PCCERT_CONTEXT  pCertContext,
	IN  PCERT_ENHKEY_USAGE	pUsage,
    IN  BOOL            fMachine
);

BOOL
FCheckSCardCertAndCanOpenSilentContext ( 
IN PCCERT_CONTEXT pCertContext 
);


BOOL
FCheckCSP(
    IN  PCCERT_CONTEXT  pCertContext
);

BOOL
FCheckTimeValidity(
    IN  PCCERT_CONTEXT  pCertContext
);

DWORD DwCheckCertPolicy ( 
    IN PCCERT_CONTEXT   pCertContextUser,
    OUT PCCERT_CHAIN_CONTEXT  * ppCertChainContext
);

DWORD
GetRootCertHashAndNameVerifyChain(
    IN  PCERT_CONTEXT   pCertContextServer,
    OUT EAPTLS_HASH*    pHash,    
    OUT WCHAR**         ppwszName,
    IN  BOOL            fVerifyGP,
    OUT BOOL       *    pfRootCheckRequired
);

DWORD
ServerConfigDataIO(
    IN      BOOL    fRead,
    IN      WCHAR*  pwszMachineName,
    IN OUT  BYTE**  ppData,
    IN      DWORD   dwNumBytes
);

VOID
FreeCertList(
    IN  EAPTLS_CERT_NODE* pNode
);

VOID
CreateCertList(
    IN  BOOL                fServer,
    IN  BOOL                fRouter,
    IN  BOOL                fRoot,
    OUT EAPTLS_CERT_NODE**  ppCertList,
    OUT EAPTLS_CERT_NODE**  ppCert,
    IN  DWORD               dwNumHashStructs,
    IN  EAPTLS_HASH*        pHash,
    IN  WCHAR*              pwszStoreName
);

DWORD
GetDefaultClientMachineCert(
    IN  HCERTSTORE      hCertStore,
    OUT PCCERT_CONTEXT* ppCertContext
);


DWORD
GetDefaultMachineCert(
    IN  HCERTSTORE      hCertStore,
    OUT PCCERT_CONTEXT* ppCertContext
);

DWORD
GetCertFromLogonInfo(
    IN  BYTE*           pUserDataIn,
    IN  DWORD           dwSizeOfUserDataIn,
    OUT PCCERT_CONTEXT* ppCertContext
);

DWORD
GetIdentityFromLogonInfo(
    IN  BYTE*   pUserDataIn,
    IN  DWORD   dwSizeOfUserDataIn,
    OUT WCHAR** ppwszIdentity
);

DWORD
ReadConnectionData(
    IN  BOOL                        fWireless,
    IN  BYTE*                       pConnectionDataIn,
    IN  DWORD                       dwSizeOfConnectionDataIn,
    OUT EAPTLS_CONN_PROPERTIES**    ppConnProp
);

DWORD
ReadUserData(
    IN  BYTE*                       pUserDataIn,
    IN  DWORD                       dwSizeOfUserDataIn,
    OUT EAPTLS_USER_PROPERTIES**    ppUserProp
);

DWORD
AllocUserDataWithNewIdentity(
    IN  EAPTLS_USER_PROPERTIES*     pUserProp,
    IN  WCHAR*                      pwszIdentity,
    OUT EAPTLS_USER_PROPERTIES**    ppUserProp
);

DWORD
AllocUserDataWithNewPin(
    IN  EAPTLS_USER_PROPERTIES*     pUserProp,
    IN  PBYTE                       pbzPin,
    IN  DWORD                       cbPin,
    OUT EAPTLS_USER_PROPERTIES**    ppUserProp
);

WCHAR*
WszFromId(
    IN  HINSTANCE   hInstance,
    IN  DWORD       dwStringId
);

// Prototypes for functions in eaptls.c

DWORD
EapTlsBegin(
    OUT VOID**          ppWorkBuffer,
    IN  PPP_EAP_INPUT*  pPppEapInput
);

DWORD
EapTlsEnd(
    IN  EAPTLSCB*   pEapTlsCb
);

DWORD
EapTlsMakeMessage(
    IN  EAPTLSCB*       pEapTlsCb,
    IN  PPP_EAP_PACKET* pInput,
    OUT PPP_EAP_PACKET* pOutput,
    IN  DWORD           cbSendPacket,
    OUT PPP_EAP_OUTPUT* pEapOutput,
    IN  PPP_EAP_INPUT*  pEapInput
);

DWORD
GetCredentials(
    IN  EAPTLSCB*   pEapTlsCb
);

DWORD
EapTlsCMakeMessage(
    IN  EAPTLSCB*       pEapTlsCb,
    IN  EAPTLS_PACKET*  pReceivePacket,
    OUT EAPTLS_PACKET*  pSendPacket,
    IN  DWORD           cbSendPacket,
    OUT PPP_EAP_OUTPUT* pEapOutput,
    IN  PPP_EAP_INPUT*  pEapInput
);

DWORD
EapTlsSMakeMessage(
    IN  EAPTLSCB*       pEapTlsCb,
    IN  EAPTLS_PACKET*  pReceivePacket,
    OUT EAPTLS_PACKET*  pSendPacket,
    IN  DWORD           cbSendPacket,
    OUT PPP_EAP_OUTPUT* pEapOutput,
    IN  PPP_EAP_INPUT*  pEapInput
);

// Prototypes for functions in scard.c

DWORD
GetCertFromCard(
    OUT PCCERT_CONTEXT* ppCertContext
);

VOID
FreeScardDlgDll(
    VOID
);

// Prototypes for functions in eapui.cpp

HINSTANCE
GetHInstance(
    VOID
);

// Prototypes for functions in dialog.c

VOID
GetString(
    IN      HWND    hwndParent,
    IN      UINT    ID,
    IN OUT  WCHAR** ppwszString
);

//
//Prototypes in eaptls.c
//

DWORD
AssociatePinWithCertificate(
    IN  PCCERT_CONTEXT          pCertContext,
    IN  EAPTLS_USER_PROPERTIES* pUserProp,
	IN  BOOL					fErarePIN,
	IN  BOOL					fCheckNullPin
);

DWORD EncryptData
( 
    IN PBYTE  pbPlainData, 
    IN DWORD  cbPlainData,
    OUT PBYTE * ppEncData,
    OUT DWORD * pcbEncData
);




//
// Prototypes of functions in util.c
//

DWORD GetMBytePIN ( WCHAR * pwszPIN, CHAR ** ppszPIN );

DWORD VerifyCallerTrust ( void * callersaddress );


#if 0
//
//This function get's the hash blob 
//deposited by Group Policy in the registry
//
DWORD
ReadGPCARootHashes(
        DWORD   *pdwSizeOfRootHashBlob,
        PBYTE   *ppbRootHashBlob
);

#endif

//
// These functions are around the cludgy 
// CONN PROP structure.
//
EAPTLS_CONN_PROPERTIES_V1_EXTRA UNALIGNED * ConnPropGetExtraPointer (EAPTLS_CONN_PROPERTIES * pConnProp);

DWORD ConnPropGetNumHashes(EAPTLS_CONN_PROPERTIES * pConnProp );

void ConnPropSetNumHashes(EAPTLS_CONN_PROPERTIES * pConnProp, DWORD dwNumHashes );

DWORD ConnPropGetV1Struct ( EAPTLS_CONN_PROPERTIES * pConnProp, EAPTLS_CONN_PROPERTIES_V1 ** ppConnPropv1 );

DWORD ConnPropGetV0Struct ( EAPTLS_CONN_PROPERTIES_V1 * pConnPropv1, EAPTLS_CONN_PROPERTIES ** ppConnProp );

void ShowCertDetails ( HWND hWnd, HCERTSTORE hStore, PCCERT_CONTEXT pCertContext);

//////////////////////////All Peap Related Declarations /////////////////////

//
// PEAP Message Types
//
//

//TBD: Check with IANA ( ashwinp ) what the type will be.

#define PEAP_TYPE_AVP                       0x21
//
// TLV Format is: 
// Flags - 2bits
// Type - 14 bits
// Length - 2 octets
// Value - Variable

//
// TLV Flags
//
#define PEAP_AVP_FLAG_MANDATORY              0x80

//
// TLV types are of following types

//
// Status TLV.  Tell's if the outcome of the EAP is success
// or failure.
//
#define MS_PEAP_AVP_LANGUAGE_NEGOTIATE      0x01
#define MS_PEAP_AVP_CIPHERSUITE_NEGOTIATE   0x02
#define MS_PEAP_AVP_TYPE_STATUS             0x03


//
// Values possible in Status AVP
//
#define MS_PEAP_AVP_VALUE_SUCCESS           0x1
#define MS_PEAP_AVP_VALUE_FAILURE           0x2



// PEAP Reg Keys
#define PEAP_KEY_25                         L"System\\CurrentControlSet\\Services\\Rasman\\PPP\\EAP\\25"
#define PEAP_VAL_SERVER_CONFIG_DATA         L"ServerConfigData"

//
// This key is required for include only MSCHAPv2.  IF this is missing all protocols will be included in PEAP
// except PEAP itself
//
#define PEAP_KEY_PEAP                   L"System\\CurrentControlSet\\Services\\Rasman\\PPP\\EAP\\25"
#define PEAP_CRIPPLE_VALUE              L"EAPMschapv2Only"
#define PEAP_KEY_EAP                    L"System\\CurrentControlSet\\Services\\Rasman\\PPP\\EAP"

#define PEAP_REGVAL_PATH                L"Path"
#define PEAP_REGVAL_FRIENDLYNAME        L"FriendlyName"
#define PEAP_REGVAL_CONFIGDLL           L"ConfigUIPath"
#define PEAP_REGVAL_IDENTITYDLL         L"IdentityPath"
#define PEAP_REGVAL_INTERACTIVEUIDLL    L"InteractiveUIPath"
#define PEAP_REGVAL_CONFIGCLSID         L"ConfigCLSID"
#define PEAP_REGVAL_ROLESSUPPORTED      L"RolesSupported"

#define PEAP_EAPTYPE_IDENTITY           1
#define PEAP_EAPTYPE_NAK                3


typedef DWORD (APIENTRY * RASEAPFREE)( PBYTE );
typedef DWORD (APIENTRY * RASEAPINVOKECONFIGUI)( DWORD, HWND, DWORD, PBYTE, DWORD, PBYTE*, DWORD*);
typedef DWORD (APIENTRY * RASEAPGETIDENTITY)( DWORD, HWND, DWORD, const WCHAR*, const WCHAR*, PBYTE, DWORD, PBYTE, DWORD, PBYTE*, DWORD*, WCHAR** );
typedef DWORD (APIENTRY * RASEAPINVOKEINTERACTIVEUI)(
                                           DWORD,
                                           HWND,
                                           PBYTE,
                                           DWORD,
                                           PBYTE *,
                                           DWORD *);

//List of all EAP types allowed in PEAP
typedef struct _PEAP_EAP_INFO PEAP_EAP_INFO;
typedef struct _PEAP_EAP_INFO* PPEAP_EAP_INFO;


struct _PEAP_EAP_INFO
{
    //Next one in the list
    PPEAP_EAP_INFO       pNext;
    //Type 
    DWORD           dwTypeId;
    // Path of the protocol DLL
    LPWSTR          lpwszPath;
    //Friendly Name
    LPWSTR          lpwszFriendlyName;
    //Configuration UI path for client
    LPWSTR          lpwszConfigUIPath;
    //Identity UI path
    LPWSTR          lpwszIdentityUIPath;
    //Interactive UI path
    LPWSTR          lpwszInteractiveUIPath;
    //Configuration GUID
    LPWSTR          lpwszConfigClsId;
    //Library HAndle
    HMODULE         hEAPModule;
    //Eap Info for each EAP Type
    PPP_EAP_INFO    PppEapInfo;
    //Work buffer for each eap type
    PBYTE           pWorkBuf;      
    // Original Client Config from PEAP blob    
    PBYTE           pbClientConfigOrig;
    // Client Config Length
    DWORD           dwClientConfigOrigSize;
    // New client config
    PBYTE           pbNewClientConfig;
    // New client config length
    DWORD           dwNewClientConfigSize;
    // Original User Config information
    PBYTE           pbUserConfigOrig;
    // Original size of user configuration
    DWORD           dwUserConfigOrigSize;
    // New user config
    PBYTE           pbUserConfigNew;
    // New user config size
    DWORD           dwNewUserConfigSize;
    //
    DWORD   (APIENTRY *RasEapGetCredentials)(
                            IN  DWORD   dwTypeId,
                            IN  VOID *  pWorkBuf,
                            OUT VOID ** pInfo);


    //There will be more items in this node...
};


typedef enum _PEAP_STATE
{
    PEAP_STATE_INITIAL,
    PEAP_STATE_TLS_INPROGRESS,              // PEAP-Part 1 (TLS) is being executed
    PEAP_WAITING_FOR_IDENTITY,              // Client should expect and identity request    
                                            // server should send identity request
    PEAP_STATE_IDENTITY_REQUEST_SENT,       // identity request send by server
    PEAP_STATE_IDENTITY_RESPONSE_SENT,      // identity response send to server
    PEAP_STATE_EAP_TYPE_INPROGRESS,         // PEAP-Part 2 (Embedded EAP) is being 
                                            // executed
    PEAP_STATE_EAP_TYPE_FINISHED,           // sever should send identity request    
    PEAP_STATE_PEAP_SUCCESS_SEND,           // server send PEAP success request
    PEAP_STATE_PEAP_FAIL_SEND,              // server send PEAP fail request
    PEAP_STATE_FAST_ROAMING_IDENTITY_REQUEST// client is not setup to do fast roaming
                                            // and the server send a roaming success
                                            // we replied with fail and are now expecting
                                            // an identity request from server.

} PEAP_STATE;


//
// connection properties for 
// each of the peap entries
//
typedef struct _PEAP_ENTRY_CONN_PROPERTIES
{
    DWORD       dwVersion;          //Version will be 1 for this release
    DWORD       dwSize;             //Number of bytes in this structure
    DWORD       dwEapTypeId;        //TypeId for this Entry Properties
    BYTE        bData[1];           //Actual conn properties for the given 
                                    //Type Id
}PEAP_ENTRY_CONN_PROPERTIES, *PPEAP_ENTRY_CONN_PROPERTIES;

//
// This structure holds EapTlsConn Prop along with 
// each configured eap type.
//

// Allow fast roaming
#define PEAP_CONN_FLAG_FAST_ROAMING      0x00000001

typedef struct _PEAP_CONN_PROPERTIES
{
    //Version will be 1 for this release
    DWORD                       dwVersion;

    //
    //Number of bytes in this structure
    //

    DWORD                       dwSize;

    //Number of types configured in this PEAP 
    //For now there is only one.
    DWORD                       dwNumPeapTypes;

    //Flags
    DWORD                       dwFlags;
    //Tls Connection Properties to start with - This is a variable length structure
    EAPTLS_CONN_PROPERTIES_V1   EapTlsConnProp;

    //Array of PPEAP_ENTRY_CONN_PROPERTIES follows here

}PEAP_CONN_PROP, *PPEAP_CONN_PROP;

//
// Default credentials for eaptypes that dont expose
// identity UI
//

typedef struct _PEAP_DEFAULT_CREDENTIALS
{
    WCHAR                   wszUserName[UNLEN+1];
    WCHAR                   wszPassword[PWLEN+1];
    WCHAR                   wszDomain[DNLEN+1];
}PEAP_DEFAULT_CREDENTIALS, *PPEAP_DEFAULT_CREDENTIALS;
//
// user properties for 
// each of the peap entries
//

typedef struct _PEAP_ENTRY_USER_PROPERTIES
{
    DWORD       dwVersion;          //Version will be 1 for this release
    DWORD       dwSize;             //Number of bytes in this structure
    DWORD       dwEapTypeId;        //TypeId for this Entry Properties
    BOOL        fUsingPeapDefault;  //Default Identity provided by PEAP is being used.
    BYTE        bData[1];           //Actual User properties for the given 
                                    //Type Id 
}PEAP_ENTRY_USER_PROPERTIES, *PPEAP_ENTRY_USER_PROPERTIES;


// Allow fast roaming

#define PEAP_USER_FLAG_FAST_ROAMING      0x00000001

typedef struct _PEAP_USER_PROPERTIES
{
    //Version will be 1 for this release
    DWORD                       dwVersion;

    //Number of bytes in this structure
    DWORD                       dwSize;
    
    //Flags 
    DWORD                       dwFlags;

    //Hash for user certificate
    EAPTLS_HASH                 CertHash;

    // User properties for an entry

    PEAP_ENTRY_USER_PROPERTIES  UserProperties;
    //
    // Array of PEAP_ENTRY_USER_PROPERTIES for each eap type.
    // should be as many as dwNumPeapTypes in PEAP_CONN_PROP
    // structure
    // For now there is only one element...
}PEAP_USER_PROP, *PPEAP_USER_PROP;



// We are a router

#define     PEAP_CONN_DIALOG_FLAG_ROUTER    0x00000001
#define     PEAP_CONN_DIALOG_FLAG_8021x     0x00000002

typedef struct _PEAP_CONN_DIALOG
{
    DWORD                   fFlags;                 // See
                                                    // PEAP_CONN_DIALOG_FLAG_*

    EAPTLS_CERT_NODE*       pCertList;              //List of all the root certificates
                                                    //from internet trusted root store
    EAPTLS_CERT_NODE**      ppSelCertList;          //List of pointers to selected certs.
                                                    //will be as many as num hashes
                                                    //in conn prop.

    PPEAP_CONN_PROP         pConnProp;

    PPEAP_EAP_INFO          pEapInfo;               //List of all the PEAP Eap Types
    
    PPEAP_EAP_INFO          pSelEapInfo;            //Selected Peap Type

    HWND                    hWndCheckValidateCert;
    HWND                    hWndCheckValidateName;
    HWND                    hWndEditServerName;
    HWND                    hWndStaticRootCaName;
    HWND                    hWndListRootCaName;
    HWND                    hWndComboPeapType;
    HWND                    hWndButtonConfigure;
    HWND                    hWndCheckEnableFastReconnect;

} PEAP_CONN_DIALOG, *PPEAP_CONN_DIALOG;


typedef struct _PEAP_SERVER_CONFIG_DIALOG
{
    EAPTLS_CERT_NODE*       pCertList;              //List of all certificates in MY machine
                                                    //store
    EAPTLS_CERT_NODE*       pSelCertList;          //List of selected cert.

    PPEAP_USER_PROP         pUserProp;              //User properties

    PPEAP_USER_PROP         pNewUserProp;           //New USer Properties

    PPEAP_EAP_INFO          pEapInfo;               //List of all the PEAP Eap Types
    
    PPEAP_EAP_INFO          pSelEapInfo;            //Selected Peap Type

    LPWSTR                  pwszMachineName;

    HWND                    hWndComboServerName;
    HWND                    hWndEditFriendlyName;
    HWND                    hWndEditIssuer;
    HWND                    hWndEditExpiration;
    HWND                    hWndComboPeapType;
    HWND                    hWndBtnConfigure;
    HWND                    hEndEnableFastReconnect;
}PEAP_SERVER_CONFIG_DIALOG, *PPEAP_SERVER_CONFIG_DIALOG;


typedef struct _PEAP_DEFAULT_CRED_DIALOG
{
    PEAP_DEFAULT_CREDENTIALS    PeapDefaultCredentials;

    HWND                    hWndUserName;
    HWND                    hWndPassword;
    HWND                    hWndDomain;
}PEAP_DEFAULT_CRED_DIALOG, *PPEAP_DEFAULT_CRED_DIALOG;

typedef struct _PEAP_INTERACTIVE_UI
{
    DWORD           dwEapTypeId;    // Embedded Eap Type Id requesting 
                                    // interactive UI
    DWORD           dwSizeofUIContextData;
    BYTE            bUIContextData[1];
}PEAP_INTERACTIVE_UI, *PPEAP_INTERACTIVE_UI;

typedef struct _PEAP_COOKIE_ATTRIBUTE
{
    RAS_AUTH_ATTRIBUTE_TYPE raaType;
    DWORD                   dwLength;
    BYTE                    Data[1];
}PEAP_COOKIE_ATTRIBUTE, *PPEAP_COOKIE_ATTRIBUTE;


typedef struct _PEAP_COOKIE
{
    WCHAR          awszIdentity[DNLEN+UNLEN+1]; // Outer Identity that was used for 
                                                // authentication.
    DWORD          dwNumAuthAttribs;            // Number of Ras Auth Attributes
                                                // other than MPPE keys
                                                // returned when auth succeeded
                                                // with full handshake
    BYTE           Data[1];                     // Data Conn Props + RAS Auth Attribs
}PEAP_COOKIE, *PPEAP_COOKIE;

//PEAP Flags 
#define PEAPCB_FLAG_SERVER                  0x00000001  // This is a server

#define PEAPCB_FLAG_ROUTER                  0x00000002  // This is a router

#define PEAPCB_FLAG_NON_INTERACTIVE         0x00000004  // No UI should be displayed

#define PEAPCB_FLAG_LOGON                   0x00000008  // The user data was
                                                        // obtained from Winlogon

#define PEAPCB_FLAG_PREVIEW                 0x00000010  // User has checked
                                                        // "Prompt for information
                                                        // before dialing"

#define PEAPCB_FLAG_FIRST_LINK              0x00000020  // This is the first link

#define PEAPCB_FLAG_MACHINE_AUTH            0x00000040  // Use the default machine cert
                                                        // or user cert based on the
                                                        // application logon context

#define PEAPCB_FLAG_GUEST_ACCESS            0x00000080  // Request to provide guest
                                                        // access.

#define PEAPCB_FLAG_8021X_AUTH              0x00000100  // Anything specific to 8021x
                                                        // to be done in TLS

#define PEAPCB_VERSION_OK                   0x00000200  // version negotiation took place
                                                        // and all's ok.

#define PEAPCB_FAST_ROAMING                 0x00000400  // Allow fast roaming

typedef struct _PEAP_CONTROL_BLOCK
{
    PEAP_STATE                  PeapState;          //Current Peap State
    DWORD                       dwFlags;            //Peap Flags
    HANDLE                      hTokenImpersonateUser;  //Impersonation token.
    BYTE                        bId;                //Peap Packet Id
    WCHAR                       awszIdentity[DNLEN+ UNLEN + 1];
    WCHAR                       awszTypeIdentity[DNLEN+ UNLEN + 1];
    WCHAR                       awszPassword[PWLEN+1];      //Type's password if
                                                        //send in.
    BOOL                        fTlsConnPropDirty;  //Need to save the TLS Conn prop
    EAPTLS_CONN_PROPERTIES_V1 * pNewTlsConnProp;    
    BOOL                        fEntryConnPropDirty;
    PPEAP_CONN_PROP             pConnProp;          //Peap Connection Prop
    BOOL                        fTlsUserPropDirty;  //Need to saveTLS user prop
    BOOL                        fEntryUserPropDirty;
    DWORD                       dwAuthResultCode;   //Result of authentication
    BOOL                        fReceivedTLVSuccessFail;    //Received a TLV instead of
                                                            //a real success or failure
    BOOL                        fSendTLVSuccessforFastRoaming;
    PPP_EAP_PACKET *            pPrevReceivePacket;     //Previously received packet
    WORD                        cbPrevReceivePacket;    //Number of bytes in previously
                                                        //received packet
    PBYTE                       pPrevDecData;           //Previously Decrypted packet data
    WORD                        cbPrevDecData;          //Data size
    //
    // Encryption related entries in the control block
    //
    HCRYPTPROV              hProv;              //CryptoProvider
    //
    // following info is used if we use TLS to do encryption
    // This is the desired way of doing things since the cipher suite 
    // is negotiated within TLS
    SecPkgContext_StreamSizes       PkgStreamSizes;
    SecPkgContext_ConnectionInfo    PkgConnInfo;
    PBYTE                           pbIoBuffer;
    DWORD                           dwIoBufferLen;      //Enc or Dec Data Length
    PPEAP_USER_PROP         pUserProp;          //Peap User Prop
    RAS_AUTH_ATTRIBUTE *    pTlsUserAttributes; //User Attributes send 
                                                //back by EAPTLS
    PPEAP_INTERACTIVE_UI    pUIContextData;     //UI context Data for an eap type
    BOOL                    fInvokedInteractiveUI; //PEAP has invoked interactive UI
    BOOL                    fExecutingInteractiveUI;
    EAPTLSCB       *        pEapTlsCB;          //Tls Control Block
    PPEAP_EAP_INFO          pEapInfo;           //Eap info - contains all data reqd for 
                                                //eap type to function well.    
}PEAPCB, * PPEAPCB;


DWORD
EapPeapInitialize(
    IN  BOOL    fInitialize
);

DWORD
EapPeapBegin(
    OUT VOID**          ppWorkBuffer,
    IN  PPP_EAP_INPUT*  pPppEapInput
);


DWORD
EapPeapEnd(
    IN  PPEAPCB   pPeapCb
);


DWORD
EapPeapMakeMessage(
    IN  PPEAPCB         pPeapCb,
    IN  PPP_EAP_PACKET* pInput,
    OUT PPP_EAP_PACKET* pOutput,
    IN  DWORD           cbSendPacket,
    OUT PPP_EAP_OUTPUT* pEapOutput,
    IN  PPP_EAP_INPUT*  pEapInput
);


DWORD
EapPeapCMakeMessage(
    IN  PPEAPCB         pPeapCb,
    IN  PPP_EAP_PACKET* pReceivePacket,
    OUT PPP_EAP_PACKET* pSendPacket,
    IN  DWORD           cbSendPacket,
    OUT PPP_EAP_OUTPUT* pEapOutput,
    IN  PPP_EAP_INPUT*  pEapInput
);

DWORD
EapPeapSMakeMessage(
    IN  PPEAPCB         pPeapCb,
    IN  PPP_EAP_PACKET* pReceivePacket,
    OUT PPP_EAP_PACKET* pSendPacket,
    IN  DWORD           cbSendPacket,
    OUT PPP_EAP_OUTPUT* pEapOutput,
    IN  PPP_EAP_INPUT*  pEapInput
);

//Peap functions from util.c

DWORD
PeapReadConnectionData(
    IN BOOL                         fWireless,
    IN  BYTE*                       pConnectionDataIn,
    IN  DWORD                       dwSizeOfConnectionDataIn,
    OUT PPEAP_CONN_PROP*            ppConnProp
);

DWORD
PeapReadUserData(
    IN  BYTE*                       pUserDataIn,
    IN  DWORD                       dwSizeOfUserDataIn,
    OUT PPEAP_USER_PROP*            ppUserProp
);


DWORD
PeapReDoUserData (
    IN  DWORD                dwNewTypeId,
    OUT PPEAP_USER_PROP*     ppNewUserProp
);

DWORD 
PeapEapInfoAddListNode (PPEAP_EAP_INFO * ppEapInfo);


VOID
PeapEapInfoFreeList ( PPEAP_EAP_INFO  pEapInfo );

DWORD
PeapEapInfoExpandSZ (HKEY hkeyPeapType, 
                     LPWSTR pwszValue, 
                     LPWSTR * ppValueData );

DWORD
PeapEapInfoGetList ( LPWSTR lpwszMachineName, PPEAP_EAP_INFO * ppEapInfo);

DWORD
PeapEapInfoSetConnData ( PPEAP_EAP_INFO pEapInfo, PPEAP_CONN_PROP pPeapConnProp );

DWORD PeapEapInfoInvokeClientConfigUI ( HWND hWndParent, 
                                        PPEAP_EAP_INFO pEapInfo,
                                        DWORD fFlags);

DWORD
PeapGetFirstEntryConnProp ( PPEAP_CONN_PROP pConnProp,
                            PEAP_ENTRY_CONN_PROPERTIES UNALIGNED ** ppEntryProp
                          );

DWORD
PeapGetFirstEntryUserProp ( PPEAP_USER_PROP pUserProp, 
                            PEAP_ENTRY_USER_PROPERTIES UNALIGNED ** ppEntryProp
                          );

DWORD 
PeapEapInfoCopyListNode (   DWORD dwTypeId, 
    PPEAP_EAP_INFO pEapInfoList, 
    PPEAP_EAP_INFO * ppEapInfo );



DWORD
PeapEapInfoFindListNode (   DWORD dwTypeId, 
    PPEAP_EAP_INFO pEapInfoList, 
    PPEAP_EAP_INFO * ppEapInfo );

DWORD PeapEapInfoInvokeIdentityUI ( HWND hWndParent, 
                                    PPEAP_EAP_INFO pEapInfo,
                                    const WCHAR * pwszPhoneBook,
                                    const WCHAR * pwszEntry,
                                    PBYTE pbUserDataIn,
                                    DWORD cbUserDataIn,
                                    WCHAR** ppwszIdentityOut,
                                    DWORD fFlags);

#ifdef __cplusplus
extern "C"
#endif
DWORD PeapEapInfoInvokeServerConfigUI ( HWND hWndParent,
                                        LPWSTR lpwszMachineName,
                                        PPEAP_EAP_INFO pEapInfo
                                      );

DWORD
OpenPeapRegistryKey(
    IN  WCHAR*  pwszMachineName,
    IN  REGSAM  samDesired,
    OUT HKEY*   phKeyPeap
);

DWORD
PeapServerConfigDataIO(
    IN      BOOL    fRead,
    IN      WCHAR*  pwszMachineName,
    IN OUT  BYTE**  ppData,
    IN      DWORD   dwNumBytes
);

INT_PTR CALLBACK
PeapConnDialogProc(
    IN  HWND    hWnd,
    IN  UINT    unMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

INT_PTR CALLBACK
PeapServerDialogProc(
    IN  HWND    hWnd,
    IN  UINT    unMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);


INT_PTR CALLBACK
DefaultCredDialogProc(
    IN  HWND    hWnd,
    IN  UINT    unMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

DWORD
GetIdentityFromUserName ( 
LPWSTR lpszUserName,
LPWSTR lpszDomain,
LPWSTR * ppwszIdentity
);

BOOL FFormatUserIdentity ( 
LPWSTR lpszUserNameRaw, 
LPWSTR * lppszUserNameFormatted 
);

DWORD
GetLocalMachineName ( 
    OUT WCHAR ** ppLocalMachineName
);
BOOL
IsPeapCrippled(HKEY hKeyLM);


/////////////////////////////////////////////////////////
//  XPSP1 related stuff
/////////////////////////////////////////////////////////
HINSTANCE
GetResouceDLLHInstance(
    VOID
);

#endif // #ifndef _EAPTLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\eaptls\dialog.c ===
/* 

Copyright (c) 1997, Microsoft Corporation, all rights reserved

Description:

History:
    Nov 1997: Vijay Baliga created original version.

*/

#include <nt.h>         // Required by windows.h
#include <ntrtl.h>      // Required by windows.h
#include <nturtl.h>     // Required by windows.h
#include <windows.h>    // Win32 base API's
#include <windowsx.h>

#include <stdio.h>      // For swprintf
#include <rasauth.h>    // Required by raseapif.h
#include <rtutils.h>    // For RTASSERT
#include <rasman.h>     // For EAPLOGONINFO
#include <raserror.h>   // For ERROR_NO_SMART_CARD_READER
#include <eaptypeid.h>
#include <commctrl.h>
#if WINVER > 0x0500
    #include "wzcsapi.h"
#endif
#include <schannel.h>
#define SECURITY_WIN32
#include <security.h>   // For GetUserNameExA, CredHandle

#include <sspi.h>       // For CredHandle

#include <wincrypt.h>

#include <eaptls.h>
#include <resource.h>   


const DWORD g_adwHelp[] =
{
    IDC_RADIO_USE_CARD,         IDH_RADIO_USE_CARD,
    IDC_RADIO_USE_REGISTRY,     IDH_RADIO_USE_REGISTRY,
    IDC_CHECK_VALIDATE_CERT,    IDH_CHECK_VALIDATE_CERT,
    IDC_CHECK_VALIDATE_NAME,    IDH_CHECK_VALIDATE_NAME,
    IDC_EDIT_SERVER_NAME,       IDH_EDIT_SERVER_NAME,
    IDC_STATIC_ROOT_CA_NAME,     IDH_COMBO_ROOT_CA_NAME,
    IDC_CHECK_DIFF_USER,        IDH_CHECK_DIFF_USER,

	IDC_STATIC_DIFF_USER,		IDH_EDIT_DIFF_USER,
    IDC_EDIT_DIFF_USER,         IDH_EDIT_DIFF_USER,

	IDC_STATIC_PIN,				IDH_EDIT_PIN,
    IDC_EDIT_PIN,               IDH_EDIT_PIN,
    IDC_CHECK_SAVE_PIN,         IDH_CHECK_SAVE_PIN,

	IDC_STATIC_SERVER_NAME,		IDH_COMBO_SERVER_NAME,
    IDC_COMBO_SERVER_NAME,      IDH_COMBO_SERVER_NAME,

    IDC_STATIC_USER_NAME,       IDH_COMBO_USER_NAME,
	IDC_COMBO_USER_NAME,       IDH_COMBO_USER_NAME,
    IDC_STATIC_FRIENDLY_NAME,   IDH_EDIT_FRIENDLY_NAME,
	IDC_EDIT_FRIENDLY_NAME,		IDH_EDIT_FRIENDLY_NAME,
    IDC_STATIC_ISSUER,          IDH_EDIT_ISSUER,
	IDC_EDIT_ISSUER,			IDH_EDIT_ISSUER,
    IDC_STATIC_EXPIRATION,      IDH_EDIT_EXPIRATION,
	IDC_EDIT_EXPIRATION,		IDH_EDIT_EXPIRATION,

    0, 0
};

/*

Returns:
    VOID

Notes:
    Calls WinHelp to popup context sensitive help. padwMap is an array of 
    control-ID help-ID pairs terminated with a 0,0 pair. unMsg is WM_HELP or 
    WM_CONTEXTMENU indicating the message received requesting help. wParam and 
    lParam are the parameters of the message received requesting help.

*/

VOID
ContextHelp(
    IN  const   DWORD*  padwMap,
    IN          HWND    hWndDlg,
    IN          UINT    unMsg,
    IN          WPARAM  wParam,
    IN          LPARAM  lParam
)
{
    HWND        hWnd;
    UINT        unType;
    WCHAR*      pwszHelpFile    = NULL;
    HELPINFO*   pHelpInfo;

    if (unMsg == WM_HELP)
    {
         pHelpInfo = (HELPINFO*) lParam;

        if (pHelpInfo->iContextType != HELPINFO_WINDOW)
        {
            goto LDone;
        }

        hWnd = pHelpInfo->hItemHandle;
        unType = HELP_WM_HELP;
    }
    else
    {
        // Standard Win95 method that produces a one-item "What's This?" menu
        // that user must click to get help.

        hWnd = (HWND) wParam;
        unType = HELP_CONTEXTMENU;
    };

    pwszHelpFile = WszFromId(GetHInstance(), IDS_HELPFILE);

    if (NULL == pwszHelpFile)
    {
        goto LDone;
    }

    WinHelp(hWnd, pwszHelpFile, unType, (ULONG_PTR)padwMap);

LDone:

    LocalFree(pwszHelpFile);
}

VOID 
DisplayResourceError (
    IN  HWND    hwndParent,
    IN  DWORD   dwResourceId
)
{
    WCHAR*  pwszTitle           = NULL;
    WCHAR*  pwszMessage         = NULL;

    pwszTitle = WszFromId(GetHInstance(), IDS_CANT_CONFIGURE_SERVER_TITLE);

    //
    // Check to see which file the resource is to be loaded
    //
    switch ( dwResourceId )
    {
    case IDS_VALIDATE_SERVER_TITLE:
    case IDS_CANT_CONFIGURE_SERVER_TEXT:
    case IDS_CONNECT:
    case IDS_HELPFILE:
    case IDS_PEAP_NO_SERVER_CERT:
        pwszMessage = WszFromId(GetHInstance(), dwResourceId);
    default:
        pwszMessage = WszFromId(GetResouceDLLHInstance(), dwResourceId);

    }
    

    MessageBox(hwndParent,
        (pwszMessage != NULL)? pwszMessage : L"",
        (pwszTitle != NULL) ? pwszTitle : L"",
        MB_OK | MB_ICONERROR);

    LocalFree(pwszTitle);
    LocalFree(pwszMessage);
}
/*

Returns:
    VOID

Notes:
    Display the error message corresponding to dwErrNum. Used only on the server 
    side.

*/

VOID
DisplayError(
    IN  HWND    hwndParent,
    IN  DWORD   dwErrNum
)
{
    WCHAR*  pwszTitle           = NULL;
    WCHAR*  pwszMessageFormat   = NULL;
    WCHAR*  pwszMessage         = NULL;
    DWORD   dwErr;

    pwszTitle = WszFromId(GetHInstance(), IDS_CANT_CONFIGURE_SERVER_TITLE);

    dwErr = MprAdminGetErrorString(dwErrNum, &pwszMessage);

    if (NO_ERROR != dwErr)
    {
        pwszMessageFormat = WszFromId(GetHInstance(), 
                                IDS_CANT_CONFIGURE_SERVER_TEXT);

        if (NULL != pwszMessageFormat)
        {
            pwszMessage = LocalAlloc(LPTR, wcslen(pwszMessageFormat) + 20);

            if (NULL != pwszMessage)
            {
                swprintf(pwszMessage, pwszMessageFormat, dwErrNum);
            }
        }
    }

    MessageBox(hwndParent,
        (pwszMessage != NULL)? pwszMessage : L"",
        (pwszTitle != NULL) ? pwszTitle : L"",
        MB_OK | MB_ICONERROR);

    LocalFree(pwszTitle);
    LocalFree(pwszMessageFormat);
    LocalFree(pwszMessage);
}

/* List view of check boxes state indices.
*/
#define SI_Unchecked 1
#define SI_Checked   2
#define SI_DisabledUnchecked 3
#define SI_DisabledChecked 4
#define LVXN_SETCHECK (LVN_LAST + 1)
//
//Work arounds for bugs in list ctrl...
//
BOOL
ListView_GetCheck(
    IN HWND hwndLv,
    IN INT  iItem )

    /* Returns true if the check box of item 'iItem' of listview of checkboxes
    ** 'hwndLv' is checked, false otherwise.  This function works on disabled
    ** check boxes as well as enabled ones.
    */
{
    UINT unState;

    unState = ListView_GetItemState( hwndLv, iItem, LVIS_STATEIMAGEMASK );
    return !!((unState == INDEXTOSTATEIMAGEMASK( SI_Checked )) ||
              (unState == INDEXTOSTATEIMAGEMASK( SI_DisabledChecked )));
}



BOOL
ListView_IsCheckDisabled (
        IN HWND hwndLv,
        IN INT  iItem)

    /* Returns true if the check box of item 'iItem' of listview of checkboxes
    ** 'hwndLv' is disabled, false otherwise.
    */
{
    UINT unState;
    unState = ListView_GetItemState( hwndLv, iItem, LVIS_STATEIMAGEMASK );

    if ((unState == INDEXTOSTATEIMAGEMASK( SI_DisabledChecked )) ||
        (unState == INDEXTOSTATEIMAGEMASK( SI_DisabledUnchecked )))
        return TRUE;

    return FALSE;
}

VOID
ListView_SetCheck(
    IN HWND hwndLv,
    IN INT  iItem,
    IN BOOL fCheck )

    /* Sets the check mark on item 'iItem' of listview of checkboxes 'hwndLv'
    ** to checked if 'fCheck' is true or unchecked if false.
    */
{
    NM_LISTVIEW nmlv;

    if (ListView_IsCheckDisabled(hwndLv, iItem))
        return;

    ListView_SetItemState( hwndLv, iItem,
        INDEXTOSTATEIMAGEMASK( (fCheck) ? SI_Checked : SI_Unchecked ),
        LVIS_STATEIMAGEMASK );

    nmlv.hdr.code = LVXN_SETCHECK;
    nmlv.hdr.hwndFrom = hwndLv;
    nmlv.iItem = iItem;

    FORWARD_WM_NOTIFY(
        GetParent(hwndLv), GetDlgCtrlID(hwndLv), &nmlv, SendMessage
        );
}


/*

Returns:
    FALSE (prevent Windows from setting the default keyboard focus).

Notes:
    Response to the WM_INITDIALOG message.

*/

BOOL
PinInitDialog(
    IN  HWND    hWnd,
    IN  LPARAM  lParam
)
{
    EAPTLS_PIN_DIALOG*      pEapTlsPinDialog;
    EAPTLS_USER_PROPERTIES* pUserProp;
    WCHAR*                  pwszTitleFormat     = NULL;
    WCHAR*                  pwszTitle           = NULL;
    WCHAR*                  pwszIdentity        = NULL;
    
    SetWindowLongPtr(hWnd, DWLP_USER, lParam);

    pEapTlsPinDialog = (EAPTLS_PIN_DIALOG*)lParam;
    pUserProp = pEapTlsPinDialog->pUserProp;

    pEapTlsPinDialog->hWndStaticDiffUser =
        GetDlgItem(hWnd, IDC_STATIC_DIFF_USER);
    pEapTlsPinDialog->hWndEditDiffUser =
        GetDlgItem(hWnd, IDC_EDIT_DIFF_USER);
    pEapTlsPinDialog->hWndStaticPin =
        GetDlgItem(hWnd, IDC_STATIC_PIN);
    pEapTlsPinDialog->hWndEditPin =
        GetDlgItem(hWnd, IDC_EDIT_PIN);

    if (pUserProp->pwszDiffUser[0])
    {
        SetWindowText(pEapTlsPinDialog->hWndEditDiffUser,
            pUserProp->pwszDiffUser);
    }

    if (pUserProp->pwszPin[0])
    {
        SetWindowText(pEapTlsPinDialog->hWndEditPin, pUserProp->pwszPin);

        ZeroMemory(pUserProp->pwszPin,
            wcslen(pUserProp->pwszPin) * sizeof(WCHAR));
    }

    if (!(pEapTlsPinDialog->fFlags & EAPTLS_PIN_DIALOG_FLAG_DIFF_USER))
    {
        EnableWindow(pEapTlsPinDialog->hWndStaticDiffUser, FALSE);
        EnableWindow(pEapTlsPinDialog->hWndEditDiffUser, FALSE);
    }

    if (pUserProp->fFlags & EAPTLS_USER_FLAG_SAVE_PIN)
    {
        CheckDlgButton(hWnd, IDC_CHECK_SAVE_PIN, BST_CHECKED);
    }

    // Bug 428871 implies that SavePin must not be allowed.
    ShowWindow(GetDlgItem(hWnd, IDC_CHECK_SAVE_PIN), SW_HIDE);

    SetFocus(pEapTlsPinDialog->hWndEditPin);

    {
        // Set the title

        pwszTitleFormat = WszFromId(GetHInstance(), IDS_CONNECT);

        if (NULL != pwszTitleFormat)
        {
            pwszTitle = LocalAlloc(LPTR,
                            (wcslen(pwszTitleFormat) + 
                            wcslen(pEapTlsPinDialog->pwszEntry)) * 
                            sizeof(WCHAR));

            if (NULL != pwszTitle)
            {
                swprintf(pwszTitle, pwszTitleFormat,
                    pEapTlsPinDialog->pwszEntry);

                SetWindowText(hWnd, pwszTitle);
            }
        }
    }

    LocalFree(pwszTitleFormat);
    LocalFree(pwszTitle);  
    return(FALSE);
}


void ValidatePIN ( IN EAPTLS_PIN_DIALOG*  pEapTlsPinDialog )
{
	
	pEapTlsPinDialog->dwRetCode = 
		AssociatePinWithCertificate( pEapTlsPinDialog->pCertContext,
									 pEapTlsPinDialog->pUserProp,
									 FALSE,
									 TRUE
								    );
	
	return;
}
/*

Returns:
    TRUE: We prrocessed this message.
    FALSE: We did not prrocess this message.

Notes:
    Response to the WM_COMMAND message.

*/

BOOL
PinCommand(
    IN  EAPTLS_PIN_DIALOG*  pEapTlsPinDialog,
    IN  WORD                wNotifyCode,
    IN  WORD                wId,
    IN  HWND                hWndDlg,
    IN  HWND                hWndCtrl
)
{
    DWORD                   dwNumChars;
    DWORD                   dwNameLength;
    DWORD                   dwPinLength;
    DWORD                   dwSize;
    EAPTLS_USER_PROPERTIES* pUserProp;

    switch(wId)
    {
    case IDOK:


        dwNameLength = GetWindowTextLength(
                        pEapTlsPinDialog->hWndEditDiffUser);
        dwPinLength = GetWindowTextLength(
                        pEapTlsPinDialog->hWndEditPin);

        // There is already one character in awszString.
        // Add the number of characters in DiffUser...
        dwNumChars = dwNameLength;
        // Add the number of characters in PIN...
        dwNumChars += dwPinLength;
        // Add one more for a terminating NULL. Use the extra character in
        // awszString for the other terminating NULL.
        dwNumChars += 1;

        dwSize = sizeof(EAPTLS_USER_PROPERTIES) + dwNumChars*sizeof(WCHAR);

        pUserProp = LocalAlloc(LPTR, dwSize);

        if (NULL == pUserProp)
        {
            EapTlsTrace("LocalAlloc in Command failed and returned %d",
                GetLastError());
        }
        else
        {
            CopyMemory(pUserProp, pEapTlsPinDialog->pUserProp,
                sizeof(EAPTLS_USER_PROPERTIES));
            pUserProp->dwSize = dwSize;

            pUserProp->pwszDiffUser = pUserProp->awszString;
            GetWindowText(pEapTlsPinDialog->hWndEditDiffUser,
                pUserProp->pwszDiffUser,
                dwNameLength + 1);

            pUserProp->dwPinOffset = dwNameLength + 1;
            pUserProp->pwszPin = pUserProp->awszString +
                pUserProp->dwPinOffset;
            GetWindowText(pEapTlsPinDialog->hWndEditPin,
                pUserProp->pwszPin,
                dwPinLength + 1);

            LocalFree(pEapTlsPinDialog->pUserProp);
            pEapTlsPinDialog->pUserProp = pUserProp;
        }

        if (BST_CHECKED == IsDlgButtonChecked(hWndDlg, IDC_CHECK_SAVE_PIN))
        {
            pEapTlsPinDialog->pUserProp->fFlags |= EAPTLS_USER_FLAG_SAVE_PIN;
        }
        else
        {
            pEapTlsPinDialog->pUserProp->fFlags &= ~EAPTLS_USER_FLAG_SAVE_PIN;
        }

		//
        //Check if valid PIN has been entered and set the error code in pEapTlsPinDialog
		//
		ValidatePIN ( pEapTlsPinDialog);


        // Fall through

    case IDCANCEL:

        EndDialog(hWndDlg, wId);
        return(TRUE);

    default:

        return(FALSE);
    }
}




/*

Returns:

Notes:
    Callback function used with the DialogBoxParam function. It processes 
    messages sent to the dialog box. See the DialogProc documentation in MSDN.

*/

INT_PTR CALLBACK
PinDialogProc(
    IN  HWND    hWnd,
    IN  UINT    unMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    EAPTLS_PIN_DIALOG* pEapTlsPinDialog;

    switch (unMsg)
    {
    case WM_INITDIALOG:
        
        return(PinInitDialog(hWnd, lParam));

    case WM_HELP:
    case WM_CONTEXTMENU:
    {
        ContextHelp(g_adwHelp, hWnd, unMsg, wParam, lParam);
        break;
    }

    case WM_COMMAND:

        pEapTlsPinDialog = (EAPTLS_PIN_DIALOG*)GetWindowLongPtr(hWnd, DWLP_USER);

        return(PinCommand(pEapTlsPinDialog, HIWORD(wParam), LOWORD(wParam),
                       hWnd, (HWND)lParam));
    }

    return(FALSE);
}



/*
** Smart card and cert store accessing status dialog
*/
INT_PTR CALLBACK
StatusDialogProc(
    IN  HWND    hWnd,
    IN  UINT    unMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            ShowWindow(GetDlgItem(hWnd, IDC_BITMAP_SCARD),
                        SW_SHOW
                      );
            ShowWindow(GetDlgItem(hWnd, IDC_STATUS_SCARD),
                        SW_SHOW
                      );
            return TRUE;
        }
    }

    
    return FALSE;
}
/*

Returns:
    VOID

Notes:
    Enables or disables the controls in the "Validate server name" group.

*/

VOID
EnableValidateNameControls(
    IN  EAPTLS_CONN_DIALOG*  pEapTlsConnDialog
)
{
    BOOL            fEnable;

    RTASSERT(NULL != pEapTlsConnDialog);

    fEnable = !(pEapTlsConnDialog->pConnPropv1->fFlags &
                    EAPTLS_CONN_FLAG_NO_VALIDATE_CERT);

    EnableWindow(pEapTlsConnDialog->hWndCheckValidateName, fEnable);
    EnableWindow(pEapTlsConnDialog->hWndStaticRootCaName, fEnable);
    EnableWindow(pEapTlsConnDialog->hWndListRootCaName, fEnable);

    fEnable = (   fEnable
               && !(pEapTlsConnDialog->pConnPropv1->fFlags &
                        EAPTLS_CONN_FLAG_NO_VALIDATE_NAME));

    EnableWindow(pEapTlsConnDialog->hWndEditServerName, fEnable);

    fEnable = pEapTlsConnDialog->pConnPropv1->fFlags 
                & EAPTLS_CONN_FLAG_REGISTRY;

    EnableWindow( pEapTlsConnDialog->hWndCheckUseSimpleSel, fEnable );
        
}

/*

Returns:
    VOID

Notes:
    Displays the cert information

*/

VOID
DisplayCertInfo(
    IN  EAPTLS_USER_DIALOG*  pEapTlsUserDialog
)
{
    RTASSERT(NULL != pEapTlsUserDialog);

    // Erase old values first
    SetWindowText(pEapTlsUserDialog->hWndEditFriendlyName, L"");
    SetWindowText(pEapTlsUserDialog->hWndEditIssuer, L"");
    SetWindowText(pEapTlsUserDialog->hWndEditExpiration, L"");
    SetWindowText(pEapTlsUserDialog->hWndEditDiffUser, L"");

    if (NULL != pEapTlsUserDialog->pCert)
    {
        if (NULL != pEapTlsUserDialog->pCert->pwszFriendlyName)
        {
            SetWindowText(pEapTlsUserDialog->hWndEditFriendlyName,
                pEapTlsUserDialog->pCert->pwszFriendlyName);
        }

        if (NULL != pEapTlsUserDialog->pCert->pwszIssuer)
        {
            SetWindowText(pEapTlsUserDialog->hWndEditIssuer,
                pEapTlsUserDialog->pCert->pwszIssuer);
        }

        if (NULL != pEapTlsUserDialog->pCert->pwszExpiration)
        {
            SetWindowText(pEapTlsUserDialog->hWndEditExpiration,
                pEapTlsUserDialog->pCert->pwszExpiration);
        }

        if (   (NULL != pEapTlsUserDialog->pCert->pwszDisplayName)
            && (NULL != pEapTlsUserDialog->hWndEditDiffUser)
            && (EAPTLS_USER_DIALOG_FLAG_DIFF_USER & pEapTlsUserDialog->fFlags))
        {
            SetWindowText(pEapTlsUserDialog->hWndEditDiffUser,
                pEapTlsUserDialog->pCert->pwszDisplayName);
        }
    }
}


VOID InitComboBoxFromGroup ( 
    IN HWND hWnd,
    IN PEAPTLS_GROUPED_CERT_NODES  pGroupList,
    IN  EAPTLS_CERT_NODE*   pCert       //Selected certificate
)
{
    DWORD   dwIndex;
    DWORD   dwItemIndex;
    WCHAR*  pwszDisplayName;
    PEAPTLS_GROUPED_CERT_NODES  pGListTemp = pGroupList;

    SendMessage(hWnd, CB_RESETCONTENT, 0, 0);

    dwIndex     = 0;
    dwItemIndex = 0;

    while (NULL != pGListTemp)
    {
        pwszDisplayName = pGListTemp->pwszDisplayName;

        if (NULL == pwszDisplayName)
        {
            pwszDisplayName = L" ";
        }

        SendMessage(hWnd, CB_ADDSTRING, 0, (LPARAM)pwszDisplayName);

        if (pGListTemp->pMostRecentCert == pCert)
        {
            dwItemIndex = dwIndex;
        }

        pGListTemp = pGListTemp->pNext;
        dwIndex++;
    }

    SendMessage(hWnd, CB_SETCURSEL, dwItemIndex, 0);
}

/*

Returns:
    VOID

Notes:
    Initializes a combo box

*/

VOID
InitComboBox(
    IN  HWND                hWnd,
    IN  EAPTLS_CERT_NODE*   pCertList,
    IN  EAPTLS_CERT_NODE*   pCert
)
{
    DWORD   dwIndex;
    DWORD   dwItemIndex;
    WCHAR*  pwszDisplayName;

    SendMessage(hWnd, CB_RESETCONTENT, 0, 0);

    dwIndex     = 0;
    dwItemIndex = 0;

    while (NULL != pCertList)
    {
        pwszDisplayName = pCertList->pwszDisplayName;

        if (NULL == pwszDisplayName)
        {
            pwszDisplayName = L" ";
        }

        SendMessage(hWnd, CB_ADDSTRING, 0, (LPARAM)pwszDisplayName);
        SendMessage(hWnd, CB_SETITEMDATA, (WORD)dwIndex, (LPARAM)pCertList);

        if (pCertList == pCert)
        {
            dwItemIndex = dwIndex;
        }

        pCertList = pCertList->pNext;
        dwIndex++;
    }

    SendMessage(hWnd, CB_SETCURSEL, dwItemIndex, 0);
}

/*

Returns:
    VOID

Notes:
    Initializes a List box with selected certs

*/


VOID  InitListBox ( IN HWND hWnd,
                    IN EAPTLS_CERT_NODE *   pCertList,
                    IN DWORD                dwNumSelCerts,
                    IN EAPTLS_CERT_NODE **  ppSelectedCertList
                )
{
    int     nIndex = 0;
    int     nNewIndex = 0;
    DWORD   dw = 0;
    WCHAR*  pwszDisplayName;
    LVITEM  lvItem;

    ListView_DeleteAllItems(hWnd);

    while (NULL != pCertList)
    {
        pwszDisplayName = pCertList->pwszDisplayName;

        if (NULL == pwszDisplayName)
        {
            pCertList = pCertList->pNext;
            continue;
        }

        ZeroMemory(&lvItem, sizeof(lvItem));
        lvItem.mask = LVIF_TEXT|LVIF_PARAM;
        lvItem.pszText = pwszDisplayName;
        lvItem.iItem = nIndex;
        lvItem.lParam = (LPARAM)pCertList;

        nNewIndex = ListView_InsertItem ( hWnd, &lvItem );

        for ( dw = 0; dw < dwNumSelCerts; dw ++ )
        {
            if ( pCertList == *(ppSelectedCertList+dw) )
            {
                ListView_SetCheckState(hWnd, nNewIndex,TRUE);
            }
        }
        nIndex++;
        pCertList = pCertList->pNext;
    }
    
    ListView_SetItemState(  hWnd, 
                            0,
                            LVIS_FOCUSED|LVIS_SELECTED,
                            LVIS_FOCUSED|LVIS_SELECTED
                         );

}


VOID CertListSelectedCount ( HWND hWndCtrl,
                             DWORD * pdwSelCertCount )
{
    DWORD       dwItemIndex = 0;
    DWORD       dwItemCount = 0;

    dwItemCount = ListView_GetItemCount(hWndCtrl);

    *pdwSelCertCount = 0;

    for ( dwItemIndex = 0; dwItemIndex < dwItemCount; dwItemIndex ++ )
    {
        if ( ListView_GetCheckState(hWndCtrl, dwItemIndex) )
        {
            (*pdwSelCertCount) ++;
        }
    }
}


VOID
CertListSelected(
    IN      HWND                hWndCtrl,               //Handle to the list box
    IN      EAPTLS_CERT_NODE*   pCertList,              //List of certs in the listbox
    IN OUT  EAPTLS_CERT_NODE**  ppSelCertList,          //List of selected
    IN OUT  EAPTLS_HASH*        pHash,                  //List of Hash
    IN      DWORD               dwNumHash               //Number of Items in the list
)
{
 

    DWORD       dwItemIndex = 0;
    DWORD       dwItemCount = ListView_GetItemCount(hWndCtrl);
    DWORD       dwCertIndex = 0;
    LVITEM      lvitem;
    
    if (NULL == pCertList)
    {
        return;
    }
    //Skip the one with null display name...
    pCertList = pCertList->pNext;
    //
    //Need to do two iterations on the list box.
    //I am sure there is a better way of doing this but
    //I just dont know...
    //
    for ( dwItemIndex = 0; dwItemIndex < dwItemCount; dwItemIndex ++ )
    {
        if ( ListView_GetCheckState(hWndCtrl, dwItemIndex) )
        {
            ZeroMemory( &lvitem, sizeof(lvitem) );
            lvitem.mask = LVIF_PARAM;
            lvitem.iItem = dwItemIndex;           
            ListView_GetItem(hWndCtrl, &lvitem);

            *(ppSelCertList + dwCertIndex ) = (EAPTLS_CERT_NODE *)lvitem.lParam;

            CopyMemory (    pHash + dwCertIndex,
                            &(((EAPTLS_CERT_NODE *)lvitem.lParam)->Hash),
                            sizeof(EAPTLS_HASH)
                        );
            dwCertIndex ++;
        }
    }
}

/*

Returns:
    VOID

Notes:
    hWndCtrl is the HWND of a combo box. pCertList is the associated list of
    certs. *ppCert will ultimately point to the cert that was selected. Its
    hash will be stored in *pHash.

*/

VOID
CertSelected(
    IN  HWND                hWndCtrl,
    IN  EAPTLS_CERT_NODE*   pCertList,
    IN  EAPTLS_CERT_NODE**  ppCert,
    IN  EAPTLS_HASH*        pHash
)
{
    LONG_PTR    lIndex;
    LRESULT     lrItemIndex;

    if (NULL == pCertList)
    {
        return;
    }

    if ( NULL == hWndCtrl )
    {
       lrItemIndex = 0; 
    }
    else
    {
        lrItemIndex = SendMessage(hWndCtrl, CB_GETCURSEL, 0, 0);
    }

    for (lIndex = 0; lIndex != lrItemIndex; lIndex++)
    {
        pCertList = pCertList->pNext;
    }

    *ppCert = pCertList;

    CopyMemory(pHash, &(pCertList->Hash), sizeof(EAPTLS_HASH));
}

VOID
GroupCertSelected(
    IN  HWND                hWndCtrl,
    IN  PEAPTLS_GROUPED_CERT_NODES   pGroupList,
    IN  EAPTLS_CERT_NODE**  ppCert,
    IN  EAPTLS_HASH*        pHash
)
{
    LONG_PTR                    lIndex;
    LRESULT                     lrItemIndex;
    PEAPTLS_GROUPED_CERT_NODES  pGList = pGroupList;

    if (NULL == pGList)
    {
        return;
    }

    if ( NULL == hWndCtrl )
    {
       lrItemIndex = 0; 
    }
    else
    {
        lrItemIndex = SendMessage(hWndCtrl, CB_GETCURSEL, 0, 0);
    }

    //
    // This is really a very bogus way of doing things...
    // We can setup a itemdata for this in the control itself...
    //
    for (lIndex = 0; lIndex != lrItemIndex; lIndex++)
    {
        pGList  = pGList ->pNext;
    }

    *ppCert = pGList->pMostRecentCert;

    CopyMemory(pHash, &(pGList ->pMostRecentCert->Hash), sizeof(EAPTLS_HASH));
}


/*

Returns:
    FALSE (prevent Windows from setting the default keyboard focus).

Notes:
    Response to the WM_INITDIALOG message.

*/

BOOL
UserInitDialog(
    IN  HWND    hWnd,
    IN  LPARAM  lParam
)
{
    EAPTLS_USER_DIALOG* pEapTlsUserDialog;
    WCHAR*              pwszTitleFormat     = NULL;
    WCHAR*              pwszTitle           = NULL;

    SetWindowLongPtr(hWnd, DWLP_USER, lParam);

    pEapTlsUserDialog = (EAPTLS_USER_DIALOG*)lParam;

    BringWindowToTop(hWnd);

    pEapTlsUserDialog->hWndComboUserName =
        GetDlgItem(hWnd, IDC_COMBO_USER_NAME);
    if (NULL == pEapTlsUserDialog->hWndComboUserName)
    {
        // We must be showing the server's cert selection dialog
        pEapTlsUserDialog->hWndComboUserName =
            GetDlgItem(hWnd, IDC_COMBO_SERVER_NAME);
    }

    pEapTlsUserDialog->hWndBtnViewCert =
        GetDlgItem(hWnd, IDC_BUTTON_VIEW_CERTIFICATE );

    
    pEapTlsUserDialog->hWndEditFriendlyName =
        GetDlgItem(hWnd, IDC_EDIT_FRIENDLY_NAME);

    pEapTlsUserDialog->hWndEditIssuer =
        GetDlgItem(hWnd, IDC_EDIT_ISSUER);

    pEapTlsUserDialog->hWndEditExpiration =
        GetDlgItem(hWnd, IDC_EDIT_EXPIRATION);

    pEapTlsUserDialog->hWndStaticDiffUser =
        GetDlgItem(hWnd, IDC_STATIC_DIFF_USER);

    pEapTlsUserDialog->hWndEditDiffUser =
        GetDlgItem(hWnd, IDC_EDIT_DIFF_USER);

    if ( pEapTlsUserDialog->fFlags & EAPTLS_USER_DIALOG_FLAG_USE_SIMPLE_CERTSEL
       )
    {
        InitComboBoxFromGroup(pEapTlsUserDialog->hWndComboUserName,
            pEapTlsUserDialog->pGroupedList,
            pEapTlsUserDialog->pCert);
    }
    else
    {
        InitComboBox(pEapTlsUserDialog->hWndComboUserName,
            pEapTlsUserDialog->pCertList,
            pEapTlsUserDialog->pCert);

    }

    if (   (NULL != pEapTlsUserDialog->hWndEditDiffUser)
        && (!(pEapTlsUserDialog->fFlags & EAPTLS_USER_DIALOG_FLAG_DIFF_USER)))
    {
        ShowWindow(pEapTlsUserDialog->hWndStaticDiffUser, SW_HIDE);
        ShowWindow(pEapTlsUserDialog->hWndEditDiffUser, SW_HIDE);
    }

    DisplayCertInfo(pEapTlsUserDialog);

    if (pEapTlsUserDialog->pUserProp->pwszDiffUser[0])
    {
        SetWindowText(pEapTlsUserDialog->hWndEditDiffUser,
            pEapTlsUserDialog->pUserProp->pwszDiffUser);
    }

    SetFocus(pEapTlsUserDialog->hWndComboUserName);

    if (pEapTlsUserDialog->fFlags & EAPTLS_USER_DIALOG_FLAG_DIFF_TITLE)
    {
        // Set the title

        pwszTitleFormat = WszFromId(GetHInstance(), IDS_CONNECT);

        if (NULL != pwszTitleFormat)
        {
            pwszTitle = LocalAlloc(LPTR,
                            (wcslen(pwszTitleFormat) + 
                            wcslen(pEapTlsUserDialog->pwszEntry)) * 
                            sizeof(WCHAR));

            if (NULL != pwszTitle)
            {
                HWND    hWndDuplicate = NULL;
                DWORD   dwThreadProcessId = 0;
                DWORD   dwRetCode = NO_ERROR;

                swprintf(pwszTitle, pwszTitleFormat,
                    pEapTlsUserDialog->pwszEntry);

                if ((hWndDuplicate = FindWindow (NULL, pwszTitle)) != NULL)
                {
                    GetWindowThreadProcessId (hWndDuplicate, &dwThreadProcessId);
                    if ((GetCurrentProcessId ()) == dwThreadProcessId)
                    {
                        // Kill current dialog since old one may be in use
                        if (!PostMessage (hWnd, WM_DESTROY, 0, 0))
                        {
                            dwRetCode = GetLastError ();
                            EapTlsTrace("PostMessage failed with error %ld", dwRetCode);
                        }
                        goto LDone;
                    }
                    else
                    {
                        EapTlsTrace("Matching Window does not have same process id");
                    }
                }
                else
                {
                    EapTlsTrace ("FindWindow could not find matching window");
                }

                SetWindowText(hWnd, pwszTitle);
            }
        }
    }

LDone:
    LocalFree(pwszTitleFormat);
    LocalFree(pwszTitle);

    return(FALSE);
}

/*

Returns:
    TRUE: We prrocessed this message.
    FALSE: We did not prrocess this message.

Notes:
    Response to the WM_COMMAND message.

*/

BOOL
UserCommand(
    IN  EAPTLS_USER_DIALOG* pEapTlsUserDialog,
    IN  WORD                wNotifyCode,
    IN  WORD                wId,
    IN  HWND                hWndDlg,
    IN  HWND                hWndCtrl
)
{
    DWORD                   dwNumChars;
    DWORD                   dwTextLength;
    DWORD                   dwSize;
    EAPTLS_USER_PROPERTIES* pUserProp;
    HCERTSTORE              hCertStore;
    PCCERT_CONTEXT          pCertContext = NULL;
    switch(wId)
    {
    case IDC_BUTTON_VIEW_CERTIFICATE:
        {
            WCHAR               szError[256];
            WCHAR               szTitle[512] = {0};
            CRYPT_HASH_BLOB     chb;

            GetWindowText(hWndDlg, szTitle, 511 );
            //
            // Show the certificate details here
            //
            if ( pEapTlsUserDialog->pCert )
            {
                //There is a selected cert - show details.
                hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                                            0,
                                            0,
                                            CERT_STORE_READONLY_FLAG |
                                            ((pEapTlsUserDialog->fIdentity) ?
                                                CERT_SYSTEM_STORE_CURRENT_USER:
                                                CERT_SYSTEM_STORE_LOCAL_MACHINE
                                                ),
                                            pEapTlsUserDialog->pwszStoreName
                                           );

                LoadString( GetResouceDLLHInstance(), IDS_NO_CERT_DETAILS,
                                szError, 255);

                if ( !hCertStore )
                {
                    MessageBox ( hWndDlg,
                                 szError,
                                 szTitle,
                                 MB_OK|MB_ICONSTOP
                               );
                    return(TRUE);
                }
        
                chb.cbData = pEapTlsUserDialog->pCert->Hash.cbHash;
                chb.pbData = pEapTlsUserDialog->pCert->Hash.pbHash;

                pCertContext = CertFindCertificateInStore(
                          hCertStore,
                          0,
                          0,
                          CERT_FIND_HASH,
                          &chb,
                          0);
                if ( NULL == pCertContext )
                {
                    MessageBox ( hWndDlg,
                                 szError,
                                 szTitle,
                                 MB_OK|MB_ICONSTOP
                               );
                    if ( hCertStore )
                        CertCloseStore( hCertStore, CERT_CLOSE_STORE_FORCE_FLAG );

                    return(TRUE);
                }

                //
                // Show Cert detail 
                //
                ShowCertDetails ( hWndDlg, hCertStore, pCertContext );

                if ( pCertContext )
                    CertFreeCertificateContext(pCertContext);

                if ( hCertStore )
                    CertCloseStore( hCertStore, CERT_CLOSE_STORE_FORCE_FLAG );

                
            }
            return(TRUE);
        }
        
    case IDC_COMBO_USER_NAME:
    case IDC_COMBO_SERVER_NAME:

        if (CBN_SELCHANGE != wNotifyCode)
        {
            return(FALSE); // We will not process this message
        }

        if ( pEapTlsUserDialog->fFlags & EAPTLS_USER_DIALOG_FLAG_USE_SIMPLE_CERTSEL
            )
        {
            GroupCertSelected(hWndCtrl, pEapTlsUserDialog->pGroupedList,
                &(pEapTlsUserDialog->pCert), &(pEapTlsUserDialog->pUserProp->Hash));
        }
        else
        {
            CertSelected(hWndCtrl, pEapTlsUserDialog->pCertList,
                &(pEapTlsUserDialog->pCert), &(pEapTlsUserDialog->pUserProp->Hash));

        }
        DisplayCertInfo(pEapTlsUserDialog);

        return(TRUE);

    case IDOK:

        if ( pEapTlsUserDialog->fFlags & EAPTLS_USER_DIALOG_FLAG_USE_SIMPLE_CERTSEL
           )
        {
            GroupCertSelected(pEapTlsUserDialog->hWndComboUserName, pEapTlsUserDialog->pGroupedList,
                &(pEapTlsUserDialog->pCert), &(pEapTlsUserDialog->pUserProp->Hash));
        }
        else
        {
            CertSelected(pEapTlsUserDialog->hWndComboUserName, pEapTlsUserDialog->pCertList,
                &(pEapTlsUserDialog->pCert), &(pEapTlsUserDialog->pUserProp->Hash));
        }

        if (NULL != pEapTlsUserDialog->hWndEditDiffUser)
        {
            dwTextLength = GetWindowTextLength(
                            pEapTlsUserDialog->hWndEditDiffUser);

            // There is already one character in awszString.
            // Add the number of characters in DiffUser...
            dwNumChars = dwTextLength;
            // Add the number of characters in PIN...
            dwNumChars += wcslen(pEapTlsUserDialog->pUserProp->pwszPin);
            // Add one more for a terminating NULL. Use the extra character in
            // awszString for the other terminating NULL.
            dwNumChars += 1;

            dwSize = sizeof(EAPTLS_USER_PROPERTIES) + dwNumChars*sizeof(WCHAR);

            pUserProp = LocalAlloc(LPTR, dwSize);

            if (NULL == pUserProp)
            {
                EapTlsTrace("LocalAlloc in Command failed and returned %d",
                    GetLastError());
            }
            else
            {
                CopyMemory(pUserProp, pEapTlsUserDialog->pUserProp,
                    sizeof(EAPTLS_USER_PROPERTIES));
                pUserProp->dwSize = dwSize;

                pUserProp->pwszDiffUser = pUserProp->awszString;
                GetWindowText(pEapTlsUserDialog->hWndEditDiffUser,
                    pUserProp->pwszDiffUser,
                    dwTextLength + 1);

                pUserProp->dwPinOffset = dwTextLength + 1;
                pUserProp->pwszPin = pUserProp->awszString +
                    pUserProp->dwPinOffset;
                wcscpy(pUserProp->pwszPin,
                    pEapTlsUserDialog->pUserProp->pwszPin);

                ZeroMemory(pEapTlsUserDialog->pUserProp,
                    pEapTlsUserDialog->pUserProp->dwSize);
                LocalFree(pEapTlsUserDialog->pUserProp);
                pEapTlsUserDialog->pUserProp = pUserProp;
            }
        }

        // Fall through

    case IDCANCEL:

        EndDialog(hWndDlg, wId);
        return(TRUE);

    default:

        return(FALSE);
    }
}

/*

Returns:

Notes:
    Callback function used with the DialogBoxParam function. It processes 
    messages sent to the dialog box. See the DialogProc documentation in MSDN.

*/

INT_PTR CALLBACK
UserDialogProc(
    IN  HWND    hWnd,
    IN  UINT    unMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    EAPTLS_USER_DIALOG* pEapTlsUserDialog;

    switch (unMsg)
    {
    case WM_INITDIALOG:
        
        return(UserInitDialog(hWnd, lParam));

    case WM_HELP:
    case WM_CONTEXTMENU:
    {
        ContextHelp(g_adwHelp, hWnd, unMsg, wParam, lParam);
        break;
    }

    case WM_COMMAND:

        pEapTlsUserDialog = (EAPTLS_USER_DIALOG*)GetWindowLongPtr(hWnd, DWLP_USER);

        return(UserCommand(pEapTlsUserDialog, HIWORD(wParam), LOWORD(wParam),
                       hWnd, (HWND)lParam));
    case WM_DESTROY:
        EndDialog(hWnd, IDCANCEL);
        break;
    }

    return(FALSE);
}



VOID CenterWindow(HWND hWnd, HWND hWndParent, BOOL bRightTop)
{
    RECT	rcWndParent,
			rcWnd;

	// Get the window rect for the parent window.
	//
	if (hWndParent == NULL) 
	    GetWindowRect(GetDesktopWindow(), &rcWndParent);
	else
		GetWindowRect(hWndParent, &rcWndParent);

	// Get the window rect for the window to be centered.
	//
    GetWindowRect(hWnd, &rcWnd);

	// Now center the window.
	//
    if (bRightTop)
	{
		SetWindowPos(hWnd, HWND_TOPMOST, 
			rcWndParent.right - (rcWnd.right - rcWnd.left) - 5, 
			GetSystemMetrics(SM_CYCAPTION) * 2, 
			0, 0, SWP_NOSIZE | SWP_SHOWWINDOW);
	}
	else
	{
		SetWindowPos(hWnd, NULL, 
			rcWndParent.left + (rcWndParent.right - rcWndParent.left - (rcWnd.right - rcWnd.left)) / 2,
			rcWndParent.top + (rcWndParent.bottom - rcWndParent.top - (rcWnd.bottom - rcWnd.top)) / 2,
			0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_SHOWWINDOW);
	}
}

void DeleteGroupedList(PEAPTLS_GROUPED_CERT_NODES pList)
{
    PEAPTLS_GROUPED_CERT_NODES  pTemp = NULL;

    while ( pList )
    {
        pTemp = pList->pNext;        
        LocalFree(pList);
        pList = pTemp;
    }
}


DWORD 
GroupCertificates ( EAPTLS_USER_DIALOG * pEapTlsUserDialog )
{
    DWORD                           dwRetCode = NO_ERROR;
    PEAPTLS_GROUPED_CERT_NODES      pGroupList = NULL;
    PEAPTLS_GROUPED_CERT_NODES      pGroupListTemp = NULL;
    EAPTLS_CERT_NODE*               pCertList = pEapTlsUserDialog->pCertList;
    EAPTLS_CERT_NODE*               pSelCert = NULL;
    BOOL                            fItemProcessed;
   
    EapTlsTrace("GroupCertificates");

    //
    // This second pass to do grouping is not really required but 
    // is good in case we add
    // something more to the groups later
    //

    while ( pCertList )
    {
        pGroupListTemp = pGroupList;
        fItemProcessed = FALSE;
        while ( pGroupListTemp )
        {            
            if ( pCertList->pwszDisplayName &&
                 pGroupListTemp->pwszDisplayName &&
                 ! wcscmp( pCertList->pwszDisplayName, 
                           pGroupListTemp->pwszDisplayName
                         )
               )
            {
                //
                // Found the group.  Now check to see
                // if the new cert is more current than
                // the one we have in the group.  If so,
                // 
                   
                if ( ! pGroupListTemp->pMostRecentCert )
                {
                    pGroupListTemp->pMostRecentCert = pCertList;
                    fItemProcessed = TRUE;
                    break;
                }
                else
                {
                    if ( CompareFileTime ( &(pGroupListTemp->pMostRecentCert->IssueDate),
                                      &(pCertList->IssueDate)
                                    ) < 0
                       )
                    {
                        pGroupListTemp->pMostRecentCert = pCertList;
                    }
                    //Or else drop the item.
                    fItemProcessed = TRUE;
                    break;
                }
            }
            pGroupListTemp = pGroupListTemp->pNext;
        }
        if ( !fItemProcessed && pCertList->pwszDisplayName)
        {
            //
            // need to create a new group
            //
            pGroupListTemp = (PEAPTLS_GROUPED_CERT_NODES)LocalAlloc(LPTR, sizeof(EAPTLS_GROUPED_CERT_NODES));

            if ( NULL == pGroupListTemp )
            {
                dwRetCode = ERROR_OUTOFMEMORY;
                goto LDone;
            }
            pGroupListTemp->pNext = pGroupList;

            pGroupListTemp->pwszDisplayName = pCertList->pwszDisplayName;

            pGroupListTemp->pMostRecentCert = pCertList;

            pGroupList = pGroupListTemp;

        }
        pCertList = pCertList->pNext;
    }

    //
    // now that we have grouped all the certs, check to see if 
    // the cert previously used is in the list.  If so, 
    // 
    pGroupListTemp = pGroupList;
    while ( pGroupListTemp )
    {
        if ( pEapTlsUserDialog->pCert == pGroupListTemp->pMostRecentCert )
        {
            pSelCert = pEapTlsUserDialog->pCert;
            break;
        }
        pGroupListTemp = pGroupListTemp->pNext;
    }

    pEapTlsUserDialog->pGroupedList = pGroupList ;
    pGroupList = NULL;
    if ( NULL == pSelCert )
    {
        //
        // Selected cert is not in the group.
        //
        pEapTlsUserDialog->pCert = pEapTlsUserDialog->pGroupedList->pMostRecentCert;
    }
LDone:

    DeleteGroupedList( pGroupList );
    
    return dwRetCode;
}


/*

Returns:

Notes:
    ppwszIdentity can be NULL.
    Break up this ugly function.

*/

DWORD
GetCertInfo(
    IN      BOOL                        fServer,
    IN      BOOL                        fRouterConfig,
    IN      DWORD                       dwFlags,
    IN      const WCHAR*                pwszPhonebook,
    IN      const WCHAR*                pwszEntry,
    IN      HWND                        hwndParent,
    IN      WCHAR*                      pwszStoreName,
    IN      EAPTLS_CONN_PROPERTIES_V1*  pConnProp,
    IN OUT  EAPTLS_USER_PROPERTIES**    ppUserProp,
    OUT     WCHAR**                     ppwszIdentity
)
{
    INT_PTR                     nRet;
    HCERTSTORE                  hCertStore          = NULL;
    CRYPT_HASH_BLOB             HashBlob;
    PCCERT_CONTEXT              pCertContext        = NULL;
    DWORD                       dwCertFlags;
    BOOL                        fRouter;
    BOOL                        fDiffUser           = FALSE;
    BOOL                        fGotIdentity        = FALSE;
    WCHAR*                      pwszIdentity        = NULL;
    WCHAR*                      pwszTemp;
    DWORD                       dwNumChars;
    BOOL                        fLogon;
    EAPTLS_USER_DIALOG          EapTlsUserDialog;
    EAPTLS_PIN_DIALOG           EapTlsPinDialog;
    EAPTLS_USER_PROPERTIES*     pUserProp           = NULL;
    EAPTLS_USER_PROPERTIES*     pUserPropTemp;
    RASCREDENTIALS              RasCredentials;
    DWORD                       dwErr               = NO_ERROR;
	DWORD						dwNumCerts			= 0;
    HWND                       hWndStatus          = NULL;

    RTASSERT(NULL != pwszStoreName);
    RTASSERT(NULL != pConnProp);
    RTASSERT(NULL != ppUserProp);
    RTASSERT(NULL != *ppUserProp);
    // ppwszIdentity can be NULL.

    fRouter = dwFlags & RAS_EAP_FLAG_ROUTER;
    fLogon = dwFlags & RAS_EAP_FLAG_LOGON;
    EapTlsTrace("GetCertInfo");

    pUserProp = *ppUserProp;

    ZeroMemory(&EapTlsUserDialog, sizeof(EapTlsUserDialog));
    ZeroMemory(&EapTlsPinDialog, sizeof(EapTlsPinDialog));

    if (EAPTLS_CONN_FLAG_DIFF_USER & pConnProp->fFlags)
    {
        fDiffUser = TRUE;
        EapTlsUserDialog.fFlags |= EAPTLS_USER_DIALOG_FLAG_DIFF_USER;
        EapTlsPinDialog.fFlags |= EAPTLS_PIN_DIALOG_FLAG_DIFF_USER;
    }

    EapTlsUserDialog.pwszEntry = pwszEntry;
    EapTlsPinDialog.pwszEntry = pwszEntry;

    if (   fServer
        || fRouter 
        || dwFlags & RAS_EAP_FLAG_MACHINE_AUTH      //if this is a machine cert authentication
       )

    {
        dwCertFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
    }
    else
    {
        dwCertFlags = CERT_SYSTEM_STORE_CURRENT_USER;
        EapTlsUserDialog.fFlags |= EAPTLS_USER_DIALOG_FLAG_DIFF_TITLE;
    }

    //Use simple cert selection logic

    if ( pConnProp->fFlags & EAPTLS_CONN_FLAG_SIMPLE_CERT_SEL )
    {
        EapTlsUserDialog.fFlags |= EAPTLS_USER_DIALOG_FLAG_USE_SIMPLE_CERTSEL;
    }

    if (fLogon)
    {
        if (pConnProp->fFlags & EAPTLS_CONN_FLAG_REGISTRY)
        {
            dwErr = ERROR_NO_REG_CERT_AT_LOGON;
            goto LDone;
        }
        else
        {
            EapTlsPinDialog.fFlags |= EAPTLS_PIN_DIALOG_FLAG_LOGON;
        }
    }

    if ( fRouter )
    {
        EapTlsPinDialog.fFlags |= EAPTLS_PIN_DIALOG_FLAG_ROUTER;
    }

    if (   !fServer
        && !(pConnProp->fFlags & EAPTLS_CONN_FLAG_REGISTRY))
    {
        //this is smart card stuff
        BOOL    fCredentialsFound   = FALSE;
        BOOL    fGotAllInfo         = FALSE;
        if ( dwFlags  & RAS_EAP_FLAG_MACHINE_AUTH )
        {
            //
            // Machine auth requested along with
            // smart card auth so return an interactive
            // mode error.
            //
            dwErr = ERROR_INTERACTIVE_MODE;
            goto LDone;
        }
        hWndStatus = CreateDialogParam (GetResouceDLLHInstance(),
                        MAKEINTRESOURCE(IDD_SCARD_STATUS),
                        hwndParent,
                        StatusDialogProc,
                        1       
                        );
        if ( NULL != hWndStatus )
        {
            CenterWindow(hWndStatus, NULL, FALSE);
            ShowWindow(hWndStatus, SW_SHOW);
            UpdateWindow(hWndStatus);
        }


          
        if (!FSmartCardReaderInstalled())
        {
            dwErr = ERROR_NO_SMART_CARD_READER;
            goto LDone;
        }

        if (pUserProp->fFlags & EAPTLS_USER_FLAG_SAVE_PIN)
        {
            ZeroMemory(&RasCredentials, sizeof(RasCredentials));
            RasCredentials.dwSize = sizeof(RasCredentials);
            RasCredentials.dwMask = RASCM_Password;

            dwErr = RasGetCredentials(pwszPhonebook, pwszEntry,
                        &RasCredentials);

            if (   (dwErr == NO_ERROR)
                && (RasCredentials.dwMask & RASCM_Password))
            {
                fCredentialsFound = TRUE;
            }
            else
            {
                pUserProp->fFlags &= ~EAPTLS_USER_FLAG_SAVE_PIN;
            }

            dwErr = NO_ERROR;
        }

        if (   fCredentialsFound
            && (   !fDiffUser
                || (0 != pUserProp->pwszDiffUser[0])))
        {
            fGotAllInfo = TRUE;
        }

        if (   !fGotAllInfo
            && (dwFlags & RAS_EAP_FLAG_NON_INTERACTIVE))
        {
            dwErr = ERROR_INTERACTIVE_MODE;
            goto LDone;
        }


        dwErr = GetCertFromCard(&pCertContext);

        if (NO_ERROR != dwErr)
        {
            goto LDone;
        }
		//Check the time validity of the certificate 
		//got from the card
		if ( !FCheckTimeValidity( pCertContext) )
		{
			dwErr = CERT_E_EXPIRED;
			goto LDone;
		}

        pUserProp->Hash.cbHash = MAX_HASH_SIZE;

        if (!CertGetCertificateContextProperty(pCertContext,
                CERT_HASH_PROP_ID, pUserProp->Hash.pbHash,
                &(pUserProp->Hash.cbHash)))
        {
            dwErr = GetLastError();
            EapTlsTrace("CertGetCertificateContextProperty failed and "
                "returned 0x%x", dwErr);
            goto LDone;
        }

        EapTlsPinDialog.pUserProp = pUserProp;

        if (   !fDiffUser
            || (0 == pUserProp->pwszDiffUser[0]))
        {
            if (!FCertToStr(pCertContext, 0, fRouter, &pwszIdentity))
            {
                dwErr = E_FAIL;
                goto LDone;
            }

            dwErr = AllocUserDataWithNewIdentity(pUserProp, pwszIdentity, 
                        &pUserPropTemp);

            LocalFree(pwszIdentity);
            pwszIdentity = NULL;

            if (NO_ERROR != dwErr)
            {
                goto LDone;
            }

            LocalFree(pUserProp);
            EapTlsPinDialog.pUserProp = pUserProp = *ppUserProp = pUserPropTemp;
        }
        
        if (fCredentialsFound)
        {
            dwErr = AllocUserDataWithNewPin(
                        pUserProp,
                        (PBYTE)RasCredentials.szPassword,
                        lstrlen(RasCredentials.szPassword),
                        &pUserPropTemp);

            if (NO_ERROR != dwErr)
            {
                goto LDone;
            }

            LocalFree(pUserProp);
            EapTlsPinDialog.pUserProp = pUserProp = *ppUserProp = pUserPropTemp;
        }
        
        EapTlsPinDialog.pCertContext =  pCertContext;

        

        if (   !fGotAllInfo
            || (dwFlags & RAS_EAP_FLAG_PREVIEW))
        {

            if ( NULL != hWndStatus )
            {
                DestroyWindow(hWndStatus);
                hWndStatus = NULL;
            }

            nRet = DialogBoxParam(
                        GetHInstance(),
                        MAKEINTRESOURCE(IDD_USERNAME_PIN_UI),
                        hwndParent,
                        PinDialogProc,
                        (LPARAM)&EapTlsPinDialog);

            // EapTlsPinDialog.pUserProp may have been realloced

            pUserProp = *ppUserProp = EapTlsPinDialog.pUserProp;

            if (-1 == nRet)
            {
                dwErr = GetLastError();
                goto LDone;
            }
            else if (IDOK != nRet)
            {
                dwErr = ERROR_CANCELLED;
                goto LDone;
            }

            ZeroMemory(&RasCredentials, sizeof(RasCredentials));
            RasCredentials.dwSize = sizeof(RasCredentials);
            RasCredentials.dwMask = RASCM_Password;

            if (EapTlsPinDialog.pUserProp->fFlags & EAPTLS_USER_FLAG_SAVE_PIN)
            {
                wcscpy(RasCredentials.szPassword, 
                    EapTlsPinDialog.pUserProp->pwszPin);

                RasSetCredentials(pwszPhonebook, pwszEntry, &RasCredentials, 
                    FALSE /* fClearCredentials */);
            }
            else
            {
                RasSetCredentials(pwszPhonebook, pwszEntry, &RasCredentials, 
                    TRUE /* fClearCredentials */);
            }
        }

        EncodePin(EapTlsPinDialog.pUserProp);

        pwszIdentity = LocalAlloc(LPTR,
                        (wcslen(pUserProp->pwszDiffUser) + 1) * sizeof(WCHAR));

        if (NULL == pwszIdentity)
        {
            dwErr = GetLastError();
            EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
            goto LDone;
        }

        wcscpy(pwszIdentity, pUserProp->pwszDiffUser);

        if (NULL != ppwszIdentity)
        {
            *ppwszIdentity = pwszIdentity;
            pwszIdentity = NULL;
        }

        if (!fDiffUser)
        {
            pUserProp->pwszDiffUser[0] = 0;
        }
		if ( EapTlsPinDialog.dwRetCode != NO_ERROR )
			dwErr = EapTlsPinDialog.dwRetCode ;
        goto LDone;
    }

    dwCertFlags |= CERT_STORE_READONLY_FLAG;

    hCertStore = CertOpenStore(
                    CERT_STORE_PROV_SYSTEM_W,
                    X509_ASN_ENCODING,
                    0,
                    dwCertFlags,
                    pwszStoreName);

    if (NULL == hCertStore)
    {
        dwErr = GetLastError();
        EapTlsTrace("CertOpenStore failed and returned 0x%x", dwErr);
        goto LDone;
    }
    if ( ( dwFlags & RAS_EAP_FLAG_MACHINE_AUTH) )       
    {
        //if this is not machine authentication
        //This is propably not the best way to do things.
        //We should provide a way in which 
        //Get the default machine certificate and 
        //populate the out data structures...
        
        dwErr = GetDefaultClientMachineCert(hCertStore, &pCertContext );
        if ( NO_ERROR == dwErr )
        {
            EapTlsTrace("Got the default Machine Cert");
            pUserProp->Hash.cbHash = MAX_HASH_SIZE;

            if (!CertGetCertificateContextProperty(pCertContext,
                    CERT_HASH_PROP_ID, pUserProp->Hash.pbHash,
                    &(pUserProp->Hash.cbHash)))
            {
                dwErr = GetLastError();
                EapTlsTrace("CertGetCertificateContextProperty failed and "
                    "returned 0x%x", dwErr);
            }
            pUserProp->pwszDiffUser[0] = 0;

			if ( FMachineAuthCertToStr(pCertContext, &pwszIdentity))
            {
                //format the identity in the domain\machinename format.
                FFormatMachineIdentity1 (pwszIdentity, ppwszIdentity );
                pwszIdentity = NULL;                
            }
			else
			{
			
				//if not possible get it from the subject field
				if ( FCertToStr(pCertContext, 0, TRUE, &pwszIdentity))
				{
	                //format the identity in the domain\machinename format.
		            FFormatMachineIdentity1 (pwszIdentity, ppwszIdentity );
			        pwszIdentity = NULL;
				}
			
			}
			
            *ppUserProp = pUserProp;
            
        }
        goto LDone;
    }

    HashBlob.cbData = pUserProp->Hash.cbHash;
    HashBlob.pbData = pUserProp->Hash.pbHash;

    pCertContext = CertFindCertificateInStore(hCertStore, X509_ASN_ENCODING,
                        0, CERT_FIND_HASH, &HashBlob, NULL);

    if (   (NULL == pCertContext)
        || (   fDiffUser
            && (0 == pUserProp->pwszDiffUser[0])))
    {
        // We don't have complete information. Note that for registry certs, 
        // pwszDiffUser is not a different dialog.

        if (fServer)
        {
            dwErr = GetDefaultMachineCert(hCertStore, &pCertContext);

            if (NO_ERROR == dwErr)
            {
                pUserProp->Hash.cbHash = MAX_HASH_SIZE;

                if (!CertGetCertificateContextProperty(pCertContext,
                        CERT_HASH_PROP_ID, pUserProp->Hash.pbHash,
                        &(pUserProp->Hash.cbHash)))
                {
                    dwErr = GetLastError();
                    EapTlsTrace("CertGetCertificateContextProperty failed and "
                        "returned 0x%x", dwErr);
                }
            }

            dwErr = NO_ERROR;
        }
    }
    else
    {
        if (   !fServer
            && !fRouterConfig
            && !(dwFlags & RAS_EAP_FLAG_PREVIEW)
            && !(FCheckSCardCertAndCanOpenSilentContext ( pCertContext ))
           )
        {
            fGotIdentity = FALSE;

            if (!fDiffUser)
            {
                pUserProp->pwszDiffUser[0] = 0;
            }

            if (   fDiffUser
                && (pUserProp->pwszDiffUser[0]))
            {
                pwszIdentity = LocalAlloc(LPTR,
                    (wcslen(pUserProp->pwszDiffUser)+1) * sizeof(WCHAR));;
                if (NULL == pwszIdentity)
                {
                    dwErr = GetLastError();
                    EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
                    goto LDone;
                }

                wcscpy(pwszIdentity, pUserProp->pwszDiffUser);
                EapTlsTrace("(saved) Sending EAP identity %ws", pwszIdentity);
                fGotIdentity = TRUE;
            }
            else if (FCertToStr(pCertContext, 0, fRouter, &pwszIdentity))
            {
                EapTlsTrace("(saved) The name in the certificate is: %ws",
                    pwszIdentity);
                fGotIdentity = TRUE;
            }

            if (fGotIdentity)
            {
                RTASSERT(NULL != ppwszIdentity);
                *ppwszIdentity = pwszIdentity;
                pwszIdentity = NULL;
                goto LDone;
            }
        }
    }

    EapTlsUserDialog.pUserProp = pUserProp;

    CreateCertList( fServer,
                    fRouter,
                    FALSE /* fRoot */,
                    &(EapTlsUserDialog.pCertList),
                    &(EapTlsUserDialog.pCert),
                    1,
                    &(EapTlsUserDialog.pUserProp->Hash),
                    pwszStoreName);

    if (NULL == EapTlsUserDialog.pCertList)
    {
        dwErr = ERROR_NO_EAPTLS_CERTIFICATE;

        if (fServer || fRouter)
        {
            if (dwFlags & RAS_EAP_FLAG_NON_INTERACTIVE)
            {
                dwErr = ERROR_INTERACTIVE_MODE;
                goto LDone;
            }
            DisplayError(hwndParent, dwErr);
        }

        goto LDone;
    }
    else
    {
        if ( NULL == EapTlsUserDialog.pCert )
        {
            EapTlsUserDialog.pCert = EapTlsUserDialog.pCertList;
        }

        EapTlsUserDialog.pwszStoreName = pwszStoreName;

        if ( !fServer && !fRouter )
        {
			// if this is a client - not a server and not a router 
			// There are more than one certificates or the user has 
			// chosen to provide different identity
            //
			if ( EapTlsUserDialog.pCertList->pNext  || EapTlsUserDialog.fFlags & EAPTLS_USER_DIALOG_FLAG_DIFF_USER )	
			{
                if (dwFlags & RAS_EAP_FLAG_NON_INTERACTIVE)
                {
                    dwErr = ERROR_INTERACTIVE_MODE;
                    goto LDone;
                }
                //
                // Group Certs for the client UI
                //
                if ( !fServer )
                {
                    if ( EapTlsUserDialog.fFlags & EAPTLS_USER_DIALOG_FLAG_USE_SIMPLE_CERTSEL )
                    {
                        //
                        // Grouping is done only if it is specified in 
                        // the connection properties
                        //
                        dwErr = GroupCertificates (&EapTlsUserDialog);
                        if ( NO_ERROR != dwErr )
                        {
                            EapTlsTrace("Error grouping certificates.  0x%x", dwErr );
                            goto LDone;
                        }
                    }
                    
                    //
                    // Now check to see if we have only one group
                    //
                    if ( EapTlsUserDialog.fFlags & EAPTLS_USER_DIALOG_FLAG_USE_SIMPLE_CERTSEL &&
                         !(EapTlsUserDialog.fFlags & EAPTLS_USER_DIALOG_FLAG_DIFF_USER ) &&
                        !(EapTlsUserDialog.pGroupedList->pNext) 
                        )
                    {
                        //
                        // only one group.  So select the cert and use it
                        //
                        CertSelected(NULL, 
                            EapTlsUserDialog.pCertList,
		                    &(EapTlsUserDialog.pGroupedList->pMostRecentCert), 
                            &(EapTlsUserDialog.pUserProp->Hash)
                            );
                    }
                    else
                    {
                        EapTlsUserDialog.fIdentity = TRUE;
				        nRet = DialogBoxParam(
						        GetResouceDLLHInstance(),
						        MAKEINTRESOURCE(IDD_IDENTITY_UI),
						        hwndParent,
						        UserDialogProc,
						        (LPARAM)&EapTlsUserDialog);
				        if (-1 == nRet)
				        {
					        dwErr = GetLastError();
					        goto LDone;
				        }
				        else if (IDOK != nRet)
				        {
					        dwErr = ERROR_CANCELLED;
					        goto LDone;
				        }

                    }

                }
                else
                {
                    //
                    // No server side code on XPSP1 to save on resources
                    //
#if 0
				    nRet = DialogBoxParam(
						    GetHInstance(),
						    MAKEINTRESOURCE(IDD_SERVER_UI),
						    hwndParent,
						    UserDialogProc,
						    (LPARAM)&EapTlsUserDialog);
				    if (-1 == nRet)
				    {
					    dwErr = GetLastError();
					    goto LDone;
				    }
				    else if (IDOK != nRet)
				    {
					    dwErr = ERROR_CANCELLED;
					    goto LDone;
				    }
#endif
                }


				// EapTlsUserDialog.pUserProp may have been realloced

				pUserProp = *ppUserProp = EapTlsUserDialog.pUserProp;

			}
			else
			{
                //
                // There is only one relevant certificate so auto select it.
                //
                CertSelected(NULL, EapTlsUserDialog.pCertList,
		                &(EapTlsUserDialog.pCert), &(EapTlsUserDialog.pUserProp->Hash));
			}
		}
		else
		{
            if (dwFlags & RAS_EAP_FLAG_NON_INTERACTIVE)
            {
                dwErr = ERROR_INTERACTIVE_MODE;
                goto LDone;
            }
            if ( EapTlsUserDialog.fFlags & EAPTLS_USER_DIALOG_FLAG_USE_SIMPLE_CERTSEL )
            {
                //
                // Grouping is done only if it is specified in 
                // the connection properties
                //
                dwErr = GroupCertificates (&EapTlsUserDialog);
                if ( NO_ERROR != dwErr )
                {
                    EapTlsTrace("Error grouping certificates.  0x%x", dwErr );
                    goto LDone;
                }
            }
            //
            // No server side UI on the client for XPSP1 to save on resources
            //
			nRet = DialogBoxParam(
					GetResouceDLLHInstance(),
					MAKEINTRESOURCE(IDD_IDENTITY_UI),
					hwndParent,
					UserDialogProc,
					(LPARAM)&EapTlsUserDialog);

#if 0
			nRet = DialogBoxParam(
					GetHInstance(),
					MAKEINTRESOURCE(fServer ? IDD_SERVER_UI : IDD_IDENTITY_UI),
					hwndParent,
					UserDialogProc,
					(LPARAM)&EapTlsUserDialog);
#endif 
			// EapTlsUserDialog.pUserProp may have been realloced

			pUserProp = *ppUserProp = EapTlsUserDialog.pUserProp;

			if (-1 == nRet)
			{
				dwErr = GetLastError();
				goto LDone;
			}
			else if (IDOK != nRet)
			{
				dwErr = ERROR_CANCELLED;
				goto LDone;
			}
		}
    }

    if (NULL != EapTlsUserDialog.pCert)
    {
        if (   fDiffUser
            && (0 != EapTlsUserDialog.pUserProp->pwszDiffUser[0]))
        {
            pwszTemp = EapTlsUserDialog.pUserProp->pwszDiffUser;
        }
        else
        {
            pwszTemp = EapTlsUserDialog.pCert->pwszDisplayName;
        }

        pwszIdentity = LocalAlloc(LPTR, (wcslen(pwszTemp) + 1)*sizeof(WCHAR));

        if (NULL == pwszIdentity)
        {
            dwErr = GetLastError();
            EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
            goto LDone;
        }

        wcscpy(pwszIdentity, pwszTemp);

        if (NULL != ppwszIdentity)
        {
            *ppwszIdentity = pwszIdentity;
            pwszIdentity = NULL;
        }
    }

LDone:
    if ( NULL != hWndStatus )
    {
        DestroyWindow(hWndStatus);
        hWndStatus = NULL;
    }

    if (NULL != pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
        // Always returns TRUE;
    }

    if (NULL != hCertStore)
    {
        if (!CertCloseStore(hCertStore, 0))
        {
            EapTlsTrace("CertCloseStore failed and returned 0x%x",
                GetLastError());
        }
    }
    if ( pwszIdentity )
        LocalFree(pwszIdentity);
    FreeCertList(EapTlsUserDialog.pCertList);

    ZeroMemory(&RasCredentials, sizeof(RasCredentials));

    return(dwErr);
}

/*

Returns:
    FALSE (prevent Windows from setting the default keyboard focus).

Notes:
    Response to the WM_INITDIALOG message (Config UI).

*/

BOOL
ConnInitDialog(
    IN  HWND    hWnd,
    IN  LPARAM  lParam
)
{
    EAPTLS_CONN_DIALOG*      pEapTlsConnDialog;
    LVCOLUMN                 lvColumn;

    SetWindowLongPtr(hWnd, DWLP_USER, lParam);

    pEapTlsConnDialog = (EAPTLS_CONN_DIALOG*)lParam;

    pEapTlsConnDialog->hWndRadioUseCard =
        GetDlgItem(hWnd, IDC_RADIO_USE_CARD);
    pEapTlsConnDialog->hWndRadioUseRegistry =
        GetDlgItem(hWnd, IDC_RADIO_USE_REGISTRY);
    pEapTlsConnDialog->hWndCheckValidateCert =
        GetDlgItem(hWnd, IDC_CHECK_VALIDATE_CERT);
    pEapTlsConnDialog->hWndCheckValidateName =
        GetDlgItem(hWnd, IDC_CHECK_VALIDATE_NAME);
    pEapTlsConnDialog->hWndEditServerName =
        GetDlgItem(hWnd, IDC_EDIT_SERVER_NAME);
    pEapTlsConnDialog->hWndStaticRootCaName =
        GetDlgItem(hWnd, IDC_STATIC_ROOT_CA_NAME);
    //pEapTlsConnDialog->hWndComboRootCaName =
    //    GetDlgItem(hWnd, IDC_COMBO_ROOT_CA_NAME);
    pEapTlsConnDialog->hWndListRootCaName =
        GetDlgItem(hWnd, IDC_LIST_ROOT_CA_NAME);

    pEapTlsConnDialog->hWndCheckDiffUser =
        GetDlgItem(hWnd, IDC_CHECK_DIFF_USER);

    pEapTlsConnDialog->hWndCheckUseSimpleSel =
        GetDlgItem(hWnd, IDC_CHECK_USE_SIMPLE_CERT_SEL);

    pEapTlsConnDialog->hWndViewCertDetails = 
        GetDlgItem(hWnd, IDC_BUTTON_VIEW_CERTIFICATE);

    //Set the style to set list boxes.
    ListView_SetExtendedListViewStyle
        (   pEapTlsConnDialog->hWndListRootCaName,
            ListView_GetExtendedListViewStyle(pEapTlsConnDialog->hWndListRootCaName) | LVS_EX_CHECKBOXES
        );

    ZeroMemory ( &lvColumn, sizeof(lvColumn));
    lvColumn.fmt = LVCFMT_LEFT;



    ListView_InsertColumn(  pEapTlsConnDialog->hWndListRootCaName,
                            0,
                            &lvColumn
                         );

    ListView_SetColumnWidth(pEapTlsConnDialog->hWndListRootCaName,
                            0,
                            LVSCW_AUTOSIZE_USEHEADER
                           );

    //
    //Now we need to init the
    //list box with all the certs and selected cert
    InitListBox (   pEapTlsConnDialog->hWndListRootCaName,
                    pEapTlsConnDialog->pCertList,
                    pEapTlsConnDialog->pConnPropv1->dwNumHashes,
                    pEapTlsConnDialog->ppSelCertList
                );

    SetWindowText(pEapTlsConnDialog->hWndEditServerName,
                  (LPWSTR )(pEapTlsConnDialog->pConnPropv1->bData + sizeof( EAPTLS_HASH ) * pEapTlsConnDialog->pConnPropv1->dwNumHashes)
                  );

    if (pEapTlsConnDialog->fFlags & EAPTLS_CONN_DIALOG_FLAG_ROUTER)
    {
        pEapTlsConnDialog->pConnPropv1->fFlags |= EAPTLS_CONN_FLAG_REGISTRY;

        EnableWindow(pEapTlsConnDialog->hWndRadioUseCard, FALSE);
    }

    CheckRadioButton(hWnd, IDC_RADIO_USE_CARD, IDC_RADIO_USE_REGISTRY,
        (pEapTlsConnDialog->pConnPropv1->fFlags & EAPTLS_CONN_FLAG_REGISTRY) ?
            IDC_RADIO_USE_REGISTRY : IDC_RADIO_USE_CARD);

    CheckDlgButton(hWnd, IDC_CHECK_VALIDATE_CERT,
        (pEapTlsConnDialog->pConnPropv1->fFlags &
            EAPTLS_CONN_FLAG_NO_VALIDATE_CERT) ?
            BST_UNCHECKED : BST_CHECKED);

    CheckDlgButton(hWnd, IDC_CHECK_VALIDATE_NAME,
        (pEapTlsConnDialog->pConnPropv1->fFlags &
            EAPTLS_CONN_FLAG_NO_VALIDATE_NAME) ?
            BST_UNCHECKED : BST_CHECKED);

    CheckDlgButton(hWnd, IDC_CHECK_DIFF_USER,
        (pEapTlsConnDialog->pConnPropv1->fFlags &
            EAPTLS_CONN_FLAG_DIFF_USER) ?
            BST_CHECKED : BST_UNCHECKED);

    CheckDlgButton(hWnd, IDC_CHECK_USE_SIMPLE_CERT_SEL,
        (pEapTlsConnDialog->pConnPropv1->fFlags &
            EAPTLS_CONN_FLAG_SIMPLE_CERT_SEL) ?
            BST_CHECKED : BST_UNCHECKED);

    
    EnableValidateNameControls(pEapTlsConnDialog);
    
    
    //
    // Check to see if we are in readonly mode
    // If so, disable the OK button and
    // make the dialog go into readonly mode
    //
    return(FALSE);
}


DWORD GetSelCertContext(EAPTLS_CERT_NODE*  pCertList,
                        int                nIndex,
                        HCERTSTORE *       phCertStore,
                        LPWSTR             pwszStoreName,
                        PCCERT_CONTEXT *   ppCertContext
                       )
{
    PCCERT_CONTEXT      pCertContext = NULL;
    EAPTLS_CERT_NODE *  pTemp = pCertList;    
    DWORD               dwErr= NO_ERROR;
    HCERTSTORE          hStore = NULL;
    CRYPT_HASH_BLOB     chb;

    if ( nIndex >= 0 )
    {
        pTemp = pTemp->pNext;
        while ( nIndex && pTemp )
        {
            pTemp = pTemp->pNext;
            nIndex --;
        }
    }

    if ( pTemp )
    {
        *phCertStore = CertOpenStore (CERT_STORE_PROV_SYSTEM,
                                        0,
                                        0,
                                        CERT_STORE_READONLY_FLAG |CERT_SYSTEM_STORE_CURRENT_USER,
                                        pwszStoreName
                                     );
        if ( !*phCertStore )
        {
            dwErr =  GetLastError();
            goto LDone;
        }
        
        chb.cbData = pTemp->Hash.cbHash;
        chb.pbData = pTemp->Hash.pbHash;

        pCertContext = CertFindCertificateInStore(
                  *phCertStore,
                  0,
                  0,
                  CERT_FIND_HASH,
                  &chb,
                  0);
        if ( NULL == pCertContext )
        {
            dwErr =  GetLastError();
        }
    }
    else
    {
        dwErr = ERROR_NOT_FOUND;
        goto LDone;
    }

    *ppCertContext = pCertContext;

LDone:
    if ( NO_ERROR != dwErr )
    {
        if ( pCertContext )
            CertFreeCertificateContext(pCertContext);

        if ( *phCertStore )
            CertCloseStore( *phCertStore, CERT_CLOSE_STORE_FORCE_FLAG );

    }
    return dwErr;
}


/*

Returns:
    TRUE: We prrocessed this message.
    FALSE: We did not prrocess this message.

Notes:
    Response to the WM_COMMAND message (Config UI).

*/

BOOL
ConnCommand(
    IN  EAPTLS_CONN_DIALOG*     pEapTlsConnDialog,
    IN  WORD                    wNotifyCode,
    IN  WORD                    wId,
    IN  HWND                    hWndDlg,
    IN  HWND                    hWndCtrl
)
{
    DWORD                           dwNumChars;
    EAPTLS_CONN_PROPERTIES_V1   *   pConnProp;

    switch(wId)
    {
    case IDC_RADIO_USE_CARD:

        pEapTlsConnDialog->pConnPropv1->fFlags &= ~EAPTLS_CONN_FLAG_REGISTRY;
        pEapTlsConnDialog->pConnPropv1->fFlags &= ~EAPTLS_CONN_FLAG_SIMPLE_CERT_SEL;
        EnableValidateNameControls(pEapTlsConnDialog);
        return(TRUE);

    case IDC_RADIO_USE_REGISTRY:

        pEapTlsConnDialog->pConnPropv1->fFlags |= EAPTLS_CONN_FLAG_REGISTRY;
        pEapTlsConnDialog->pConnPropv1->fFlags |= EAPTLS_CONN_FLAG_SIMPLE_CERT_SEL;
        CheckDlgButton(hWndDlg, IDC_CHECK_USE_SIMPLE_CERT_SEL, BST_CHECKED);
        EnableValidateNameControls(pEapTlsConnDialog);
        return(TRUE);
    case IDC_CHECK_USE_SIMPLE_CERT_SEL:

        if (BST_CHECKED == IsDlgButtonChecked(hWndDlg, IDC_CHECK_USE_SIMPLE_CERT_SEL))
        {
            pEapTlsConnDialog->pConnPropv1->fFlags |= EAPTLS_CONN_FLAG_SIMPLE_CERT_SEL;
        }
        else
        {
            pEapTlsConnDialog->pConnPropv1->fFlags &= ~EAPTLS_CONN_FLAG_SIMPLE_CERT_SEL;
        }
        return TRUE;
    case IDC_CHECK_VALIDATE_CERT:

        if (BST_CHECKED == IsDlgButtonChecked(hWndDlg, IDC_CHECK_VALIDATE_CERT))
        {
            pEapTlsConnDialog->pConnPropv1->fFlags &=
                ~EAPTLS_CONN_FLAG_NO_VALIDATE_CERT;

            pEapTlsConnDialog->pConnPropv1->fFlags &=
                ~EAPTLS_CONN_FLAG_NO_VALIDATE_NAME;

            CheckDlgButton(hWndDlg, IDC_CHECK_VALIDATE_NAME, BST_CHECKED);
        }
        else
        {
            pEapTlsConnDialog->pConnPropv1->fFlags |=
                EAPTLS_CONN_FLAG_NO_VALIDATE_CERT;

            pEapTlsConnDialog->pConnPropv1->fFlags |=
                EAPTLS_CONN_FLAG_NO_VALIDATE_NAME;

            CheckDlgButton(hWndDlg, IDC_CHECK_VALIDATE_NAME, BST_UNCHECKED);
        }

        EnableValidateNameControls(pEapTlsConnDialog);

        return(TRUE);

    case IDC_CHECK_VALIDATE_NAME:

        if (BST_CHECKED == IsDlgButtonChecked(hWndDlg, IDC_CHECK_VALIDATE_NAME))
        {
            pEapTlsConnDialog->pConnPropv1->fFlags &=
                ~EAPTLS_CONN_FLAG_NO_VALIDATE_NAME;
        }
        else
        {
            pEapTlsConnDialog->pConnPropv1->fFlags |=
                EAPTLS_CONN_FLAG_NO_VALIDATE_NAME;
        }

        EnableValidateNameControls(pEapTlsConnDialog);

        return(TRUE);

    case IDC_CHECK_DIFF_USER:

        if (BST_CHECKED == IsDlgButtonChecked(hWndDlg, IDC_CHECK_DIFF_USER))
        {
            pEapTlsConnDialog->pConnPropv1->fFlags |=
                EAPTLS_CONN_FLAG_DIFF_USER;
        }
        else
        {
            pEapTlsConnDialog->pConnPropv1->fFlags &=
                ~EAPTLS_CONN_FLAG_DIFF_USER;
        }

        return(TRUE);

    case IDC_BUTTON_VIEW_CERTIFICATE:
        {
            //Show cert details here
            INT                 nIndex = -1;
            HCERTSTORE          hCertStore = NULL;
            PCCERT_CONTEXT      pCertContext = NULL;
            LVITEM              lvItem;

            nIndex = ListView_GetNextItem(pEapTlsConnDialog->hWndListRootCaName,
                                            -1,
                                            LVNI_SELECTED
                                         );
            if ( nIndex >= 0 )
            {
                ZeroMemory( &lvItem, sizeof(lvItem) );
                lvItem.iItem = nIndex;
                lvItem.mask = LVIF_PARAM;

                ListView_GetItem ( pEapTlsConnDialog->hWndListRootCaName,
                                    &lvItem
                                 );

                if ( NO_ERROR == GetSelCertContext( (EAPTLS_CERT_NODE*)(lvItem.lParam),
                                                    -1,
                                                    &hCertStore,
                                                    L"ROOT",
                                                    &pCertContext
                                                  )
                   )
                {
                    ShowCertDetails( hWndDlg, hCertStore, pCertContext );
                    CertFreeCertificateContext(pCertContext);
                    CertCloseStore( hCertStore, CERT_CLOSE_STORE_FORCE_FLAG );
                }
            }
        }
        return TRUE;

    case IDOK:

       {

           EAPTLS_HASH     *   pHash = NULL;
           DWORD               dwNumHash = 0;
           DWORD               dwSelCount = 0;
           EAPTLS_CERT_NODE ** ppSelCertList = NULL;
           WCHAR               wszTitle[200] = {0};
           WCHAR               wszMessage[200] = {0};


           CertListSelectedCount ( pEapTlsConnDialog->hWndListRootCaName, &dwSelCount );

           if ( pEapTlsConnDialog->fFlags & EAPTLS_CONN_DIALOG_FLAG_ROUTER)
           {
               //
               // If we are a router,
               // check to see if Validate Server certificate is selected
               // and no cert is selected.  
               // Also, check to see if server name is checked and no server's
               // are entered.  
               //
               if ( !( pEapTlsConnDialog->pConnPropv1->fFlags & EAPTLS_CONN_FLAG_NO_VALIDATE_CERT) && 
                    0 == dwSelCount )
               {
                   
                   LoadString ( GetHInstance(), 
                                IDS_CANT_CONFIGURE_SERVER_TITLE,
                                wszTitle, sizeof(wszTitle)/sizeof(WCHAR)
                              );

                   LoadString ( GetResouceDLLHInstance(), 
                                IDS_NO_ROOT_CERT,
                                wszMessage, sizeof(wszMessage)/sizeof(WCHAR)
                              );

                   MessageBox ( GetFocus(),  wszMessage, wszTitle, MB_OK|MB_ICONWARNING );
                   return TRUE;
               }
               if ( !( pEapTlsConnDialog->pConnPropv1->fFlags & EAPTLS_CONN_FLAG_NO_VALIDATE_NAME) &&
                   !GetWindowTextLength(pEapTlsConnDialog->hWndEditServerName) )
               {
                   //
                   // Nothing entered in server name field
                   //
                   LoadString ( GetHInstance(), 
                                IDS_CANT_CONFIGURE_SERVER_TITLE,
                                wszTitle, sizeof(wszTitle)/sizeof(WCHAR)
                              );

                   LoadString ( GetResouceDLLHInstance(), 
                                IDS_NO_SERVER_NAME,
                                wszMessage, sizeof(wszMessage)/sizeof(WCHAR)
                              );

                   MessageBox ( GetFocus(),  wszMessage, wszTitle, MB_OK|MB_ICONWARNING );
                   return TRUE;

               }


           }
           if ( dwSelCount > 0 )
           {
               ppSelCertList = (EAPTLS_CERT_NODE **)LocalAlloc(LPTR, sizeof(EAPTLS_CERT_NODE *) * dwSelCount );
               if ( NULL == ppSelCertList )
               {
                   EapTlsTrace("LocalAlloc in Command failed and returned %d",
                       GetLastError());
                   return TRUE;
               }
               pHash = (EAPTLS_HASH *)LocalAlloc(LPTR, sizeof(EAPTLS_HASH ) * dwSelCount );
               if ( NULL == pHash )
               {
                   EapTlsTrace("LocalAlloc in Command failed and returned %d",
                       GetLastError());
                   return TRUE;
               }
               CertListSelected(   pEapTlsConnDialog->hWndListRootCaName,
                                   pEapTlsConnDialog->pCertList,
                                   ppSelCertList,
                                   pHash,
                                   dwSelCount
                                   );

           }

           dwNumChars = GetWindowTextLength(pEapTlsConnDialog->hWndEditServerName);

            pConnProp = LocalAlloc( LPTR,
                                    sizeof(EAPTLS_CONN_PROPERTIES_V1) +
                                    sizeof(EAPTLS_HASH) * dwSelCount +
                                    dwNumChars * sizeof(WCHAR) + sizeof(WCHAR)  //one for null.
                                  );

            if (NULL == pConnProp)
            {
                EapTlsTrace("LocalAlloc in Command failed and returned %d",
                    GetLastError());
            }
            else
            {

                CopyMemory( pConnProp,
                            pEapTlsConnDialog->pConnPropv1,
                            sizeof(EAPTLS_CONN_PROPERTIES_V1)
                          );

                pConnProp->dwSize = sizeof(EAPTLS_CONN_PROPERTIES_V1) +
                                    sizeof(EAPTLS_HASH) * dwSelCount +
                                    dwNumChars * sizeof(WCHAR);

                CopyMemory ( pConnProp->bData,
                             pHash,
                             sizeof(EAPTLS_HASH) * dwSelCount
                           );

                pConnProp->dwNumHashes = dwSelCount;

                GetWindowText(pEapTlsConnDialog->hWndEditServerName,
                    (LPWSTR)(pConnProp->bData + sizeof(EAPTLS_HASH) * dwSelCount) ,
                    dwNumChars + 1);

                LocalFree(pEapTlsConnDialog->pConnPropv1);

                if ( pEapTlsConnDialog->ppSelCertList )
                    LocalFree(pEapTlsConnDialog->ppSelCertList);

                pEapTlsConnDialog->ppSelCertList = ppSelCertList;

                pEapTlsConnDialog->pConnPropv1 = pConnProp;
            }

        }
        // Fall through

    case IDCANCEL:

        EndDialog(hWndDlg, wId);
        return(TRUE);

    default:

        return(FALSE);
    }
}




BOOL ConnNotify(  EAPTLS_CONN_DIALOG *pEaptlsConnDialog, 
                  WPARAM wParam,
                  LPARAM lParam,
                  HWND hWnd
                )
{
    HCERTSTORE          hCertStore = NULL;
    PCCERT_CONTEXT      pCertContext = NULL;    
    LPNMITEMACTIVATE    lpnmItem;
    LVITEM              lvItem;    
    if ( wParam == IDC_LIST_ROOT_CA_NAME )
    {
        lpnmItem = (LPNMITEMACTIVATE) lParam;
        if ( lpnmItem->hdr.code == NM_DBLCLK )
        {
            
            ZeroMemory(&lvItem, sizeof(lvItem) );
            lvItem.mask = LVIF_PARAM;
            lvItem.iItem = lpnmItem->iItem;
            ListView_GetItem(lpnmItem->hdr.hwndFrom, &lvItem);
            
            if ( NO_ERROR == GetSelCertContext( //pEaptlsConnDialog->pCertList,
                                                (EAPTLS_CERT_NODE*)(lvItem.lParam) ,
                                                -1,
                                                &hCertStore,
                                                L"ROOT",
                                                &pCertContext
                                              )
               )
            {
                ShowCertDetails( hWnd, hCertStore, pCertContext );
                CertFreeCertificateContext(pCertContext);
                CertCloseStore( hCertStore, CERT_CLOSE_STORE_FORCE_FLAG );
                return TRUE;
            }

            return TRUE;
        }
    }

    return FALSE;
}

/*

Returns:

Notes:
    Callback function used with the Config UI DialogBoxParam function. It 
    processes messages sent to the dialog box. See the DialogProc documentation 
    in MSDN.

*/

INT_PTR CALLBACK
ConnDialogProc(
    IN  HWND    hWnd,
    IN  UINT    unMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    EAPTLS_CONN_DIALOG*  pEapTlsConnDialog;

    switch (unMsg)
    {
    case WM_INITDIALOG:
        
        return(ConnInitDialog(hWnd, lParam));

    case WM_HELP:
    case WM_CONTEXTMENU:
    {
        ContextHelp(g_adwHelp, hWnd, unMsg, wParam, lParam);
        break;
    }

    case WM_NOTIFY:
    {
        pEapTlsConnDialog = (EAPTLS_CONN_DIALOG*)GetWindowLongPtr(hWnd, DWLP_USER);
        return ConnNotify(  pEapTlsConnDialog, 
                            wParam,
                            lParam,
                            hWnd
                         );
    }
    case WM_COMMAND:

        pEapTlsConnDialog = (EAPTLS_CONN_DIALOG*)GetWindowLongPtr(hWnd, DWLP_USER);

        return(ConnCommand(pEapTlsConnDialog, HIWORD(wParam), LOWORD(wParam),
                       hWnd, (HWND)lParam));
    }

    return(FALSE);
}


DWORD 
RasEapTlsInvokeConfigUI(
    IN  DWORD       dwEapTypeId,
    IN  HWND        hwndParent,
    IN  DWORD       dwFlags,
    IN  BYTE*       pConnectionDataIn,
    IN  DWORD       dwSizeOfConnectionDataIn,
    OUT BYTE**      ppConnectionDataOut,
    OUT DWORD*      pdwSizeOfConnectionDataOut
)
{
    DWORD               dwErr = NO_ERROR;
    BOOL                fRouter             = FALSE;
    INT_PTR             nRet;
    EAPTLS_CONN_DIALOG  EapTlsConnDialog;

    RTASSERT(NULL != ppConnectionDataOut);
    RTASSERT(NULL != pdwSizeOfConnectionDataOut);

    EapTlsInitialize2(TRUE, TRUE /* fUI */);

    *ppConnectionDataOut = NULL;
    *pdwSizeOfConnectionDataOut = 0;

    ZeroMemory(&EapTlsConnDialog, sizeof(EAPTLS_CONN_DIALOG));

    if (dwFlags & RAS_EAP_FLAG_ROUTER)
    {
        fRouter = TRUE;
        EapTlsConnDialog.fFlags = EAPTLS_CONN_DIALOG_FLAG_ROUTER;
    }
#if 0
    if ( dwFlags & RAS_EAP_FLAG_READ_ONLY_UI )
    {
        EapTlsConnDialog.fFlags |= EAPTLS_CONN_DIALOG_FLAG_READONLY;
    }
#endif
    dwErr = ReadConnectionData( ( dwFlags & RAS_EAP_FLAG_8021X_AUTH ),
                                pConnectionDataIn, 
                                dwSizeOfConnectionDataIn,
                                &(EapTlsConnDialog.pConnProp)
                              );

    if (NO_ERROR != dwErr)
    {
        goto LDone;
    }


    dwErr = ConnPropGetV1Struct ( EapTlsConnDialog.pConnProp, &(EapTlsConnDialog.pConnPropv1) );
    if ( NO_ERROR != dwErr )
    {
        goto LDone;
    }

    //
    //if there are certificates that need to be selected, allocate
    //memory upfront for them
    //
    if ( EapTlsConnDialog.pConnPropv1->dwNumHashes )
    {
        EapTlsConnDialog.ppSelCertList = (EAPTLS_CERT_NODE **)LocalAlloc(LPTR, sizeof(EAPTLS_CERT_NODE *) * EapTlsConnDialog.pConnPropv1->dwNumHashes );
        if ( NULL == EapTlsConnDialog.ppSelCertList )
        {
            dwErr = GetLastError();
            EapTlsTrace("LocalAlloc failed and returned %d",
                dwErr);
            goto LDone;
        }
    }

    

    CreateCertList( FALSE /* fServer */,
                    fRouter,
                    TRUE /* fRoot */,
                    &(EapTlsConnDialog.pCertList),  //lined list of all certs in the store.
                    EapTlsConnDialog.ppSelCertList, //list of selected certificates - null if nothing's in the list
                    EapTlsConnDialog.pConnPropv1->dwNumHashes,
                    (EAPTLS_HASH*)(EapTlsConnDialog.pConnPropv1->bData),
                    L"ROOT"
                   );
    nRet = DialogBoxParam(
                GetResouceDLLHInstance(),
                MAKEINTRESOURCE(IDD_CONFIG_UI),
                hwndParent, 
                ConnDialogProc,
                (LPARAM)&EapTlsConnDialog);

    if (-1 == nRet)
    {
        dwErr = GetLastError();
        goto LDone;
    }
    else if (IDOK != nRet)
    {
        dwErr = ERROR_CANCELLED;
        goto LDone;
    }

    //
    //Convert the connpropv1 back to connpropv0 + extra cludge
    //here
    //

    RTASSERT(NULL != EapTlsConnDialog.pConnPropv1);

    dwErr = ConnPropGetV0Struct ( EapTlsConnDialog.pConnPropv1, (EAPTLS_CONN_PROPERTIES ** )ppConnectionDataOut );
    if ( NO_ERROR != dwErr )
    {
        goto LDone;
    }
    *pdwSizeOfConnectionDataOut = ((EAPTLS_CONN_PROPERTIES * )*ppConnectionDataOut)->dwSize;

LDone:

    EapTlsInitialize2(FALSE, TRUE /* fUI */);

    FreeCertList(EapTlsConnDialog.pCertList);
    if ( EapTlsConnDialog.ppSelCertList )
    {
        LocalFree( EapTlsConnDialog.ppSelCertList );
        EapTlsConnDialog.ppSelCertList = NULL;
    }
    LocalFree( EapTlsConnDialog.pConnProp );
    LocalFree( EapTlsConnDialog.pConnPropv1 );
    return dwErr;
}



DWORD 
RasEapPeapInvokeConfigUI(
    IN  DWORD       dwEapTypeId,
    IN  HWND        hwndParent,
    IN  DWORD       dwFlags,
    IN  BYTE*       pConnectionDataIn,
    IN  DWORD       dwSizeOfConnectionDataIn,
    OUT BYTE**      ppConnectionDataOut,
    OUT DWORD*      pdwSizeOfConnectionDataOut
)
{
    DWORD                   dwRetCode = NO_ERROR;
    PEAP_CONN_DIALOG        PeapConnDialog;
    BOOL                    fRouter = FALSE;
    INT_PTR                 nRet;
    //
    // Do the following here:
    //
    // Get a list of Root Certs:
    // Get the list of all the eaptypes registered for PEAP:
    // and set in in the GUI
    //
    EapTlsInitialize2(TRUE, TRUE /* fUI */);

    *ppConnectionDataOut = NULL;
    *pdwSizeOfConnectionDataOut = 0;

    ZeroMemory(&PeapConnDialog, sizeof(PEAP_CONN_DIALOG));

    if (dwFlags & RAS_EAP_FLAG_ROUTER)
    {
        fRouter = TRUE;
        PeapConnDialog.fFlags = PEAP_CONN_DIALOG_FLAG_ROUTER;
    }

    if ( dwFlags & RAS_EAP_FLAG_8021X_AUTH )
    {
        PeapConnDialog.fFlags |= PEAP_CONN_DIALOG_FLAG_8021x;
    }
    dwRetCode = PeapReadConnectionData(( dwFlags & RAS_EAP_FLAG_8021X_AUTH ),
                        pConnectionDataIn, dwSizeOfConnectionDataIn,
                &(PeapConnDialog.pConnProp));

    if (NO_ERROR != dwRetCode)
    {
        goto LDone;
    }

    //
    //if there are certificates that need to be selected, allocate
    //memory upfront for them
    //
    if ( PeapConnDialog.pConnProp->EapTlsConnProp.dwNumHashes )
    {
        PeapConnDialog.ppSelCertList = (EAPTLS_CERT_NODE **)LocalAlloc(LPTR, 
            sizeof(EAPTLS_CERT_NODE *) * PeapConnDialog.pConnProp->EapTlsConnProp.dwNumHashes );
        if ( NULL == PeapConnDialog.ppSelCertList )
        {
            dwRetCode = GetLastError();
            EapTlsTrace("LocalAlloc failed and returned %d",
                dwRetCode);
            goto LDone;
        }
    }

    

    CreateCertList( FALSE /* fServer */,
                    fRouter,
                    TRUE /* fRoot */,
                    &(PeapConnDialog.pCertList),  //lined list of all certs in the store.
                    PeapConnDialog.ppSelCertList, //list of selected certificates - null if nothing's in the list
                    PeapConnDialog.pConnProp->EapTlsConnProp.dwNumHashes,
                    (EAPTLS_HASH*)(PeapConnDialog.pConnProp->EapTlsConnProp.bData),
                    L"ROOT"
                   );

    //
    // Create a list of all Eap Types here
    //
    dwRetCode = PeapEapInfoGetList ( NULL, &(PeapConnDialog.pEapInfo) );
    if ( NO_ERROR != dwRetCode )
    {
        EapTlsTrace("Error Creating list of PEAP EapTypes");
        goto LDone;
    }

    // Setup the conn props for each of the eaptypes from our PeapConnprop 
    // in 

    dwRetCode = PeapEapInfoSetConnData ( PeapConnDialog.pEapInfo, 
                                         PeapConnDialog.pConnProp );


    nRet = DialogBoxParam(
                GetResouceDLLHInstance(),
                MAKEINTRESOURCE(IDD_PEAP_CONFIG_UI),
                hwndParent, 
                PeapConnDialogProc,
                (LPARAM)&PeapConnDialog);

    if (-1 == nRet)
    {
        dwRetCode = GetLastError();
        goto LDone;
    }
    else if (IDOK != nRet)
    {
        dwRetCode = ERROR_CANCELLED;
        goto LDone;
    }

    //
    //Convert the connpropv1 back to connpropv0 + extra cludge
    //here
    //

    RTASSERT(NULL != PeapConnDialog.pConnProp);

    *ppConnectionDataOut = (PBYTE)PeapConnDialog.pConnProp;
    *pdwSizeOfConnectionDataOut = PeapConnDialog.pConnProp->dwSize;
    PeapConnDialog.pConnProp = NULL;

LDone:

    EapTlsInitialize2(FALSE, TRUE /* fUI */);

    FreeCertList(PeapConnDialog.pCertList);
    if ( PeapConnDialog.ppSelCertList )
    {
        LocalFree( PeapConnDialog.ppSelCertList );
        PeapConnDialog.ppSelCertList = NULL;
    }

    PeapEapInfoFreeList ( PeapConnDialog.pEapInfo );

    LocalFree( PeapConnDialog.pConnProp );

    return dwRetCode;
}




/*

Returns:

Notes:
    Called to get the EAP-TLS properties for a connection.

*/

DWORD 
RasEapInvokeConfigUI(
    IN  DWORD       dwEapTypeId,
    IN  HWND        hwndParent,
    IN  DWORD       dwFlags,
    IN  BYTE*       pConnectionDataIn,
    IN  DWORD       dwSizeOfConnectionDataIn,
    OUT BYTE**      ppConnectionDataOut,
    OUT DWORD*      pdwSizeOfConnectionDataOut
)
{
    DWORD               dwErr               = ERROR_INVALID_PARAMETER;
    //
    // This is invoked in case of client configuration
    //
    if ( PPP_EAP_TLS == dwEapTypeId )
    {
        dwErr = RasEapTlsInvokeConfigUI(
            dwEapTypeId,
            hwndParent,
            dwFlags,
            pConnectionDataIn,
            dwSizeOfConnectionDataIn,
            ppConnectionDataOut,
            pdwSizeOfConnectionDataOut
        );

    }
#ifdef IMPL_PEAP
    else
    {
        //Invoke the client config UI
        dwErr = RasEapPeapInvokeConfigUI(
            dwEapTypeId,
            hwndParent,
            dwFlags,
            pConnectionDataIn,
            dwSizeOfConnectionDataIn,
            ppConnectionDataOut,
            pdwSizeOfConnectionDataOut
        );
    }
#endif
    return(dwErr);

}

/*

Returns:

Notes:
    pConnectionDataIn, pUserDataIn, and ppwszIdentity may be NULL.

*/

DWORD 
EapTlsInvokeIdentityUI(
    IN  BOOL            fServer,
    IN  BOOL            fRouterConfig,
    IN  DWORD           dwFlags,
    IN  WCHAR*          pwszStoreName,
    IN  const WCHAR*    pwszPhonebook,
    IN  const WCHAR*    pwszEntry,
    IN  HWND            hwndParent,
    IN  BYTE*           pConnectionDataIn,
    IN  DWORD           dwSizeOfConnectionDataIn,
    IN  BYTE*           pUserDataIn,
    IN  DWORD           dwSizeOfUserDataIn,
    OUT BYTE**          ppUserDataOut,
    OUT DWORD*          pdwSizeOfUserDataOut,
    OUT WCHAR**         ppwszIdentity
)
{
    DWORD                   dwErr           = NO_ERROR;
    EAPTLS_USER_PROPERTIES* pUserProp       = NULL;
    EAPTLS_CONN_PROPERTIES* pConnProp       = NULL;
    EAPTLS_CONN_PROPERTIES_V1 * pConnPropv1 = NULL;
    WCHAR*                  pwszIdentity    = NULL;
    PBYTE                   pbEncPIN        = NULL;
    DWORD                   cbEncPIN        = 0;


    RTASSERT(NULL != pwszStoreName);
    RTASSERT(NULL != ppUserDataOut);
    RTASSERT(NULL != pdwSizeOfUserDataOut);
    // pConnectionDataIn, pUserDataIn, and ppwszIdentity may be NULL.

    EapTlsInitialize2(TRUE, TRUE /* fUI */);


    EapTlsTrace("EapTlsInvokeIdentityUI");
    *ppUserDataOut          = NULL;
    *pdwSizeOfUserDataOut   = 0;

    if (NULL != ppwszIdentity)
    {
        *ppwszIdentity        = NULL;
    }

    dwErr = ReadConnectionData( ( dwFlags & RAS_EAP_FLAG_8021X_AUTH ),
                                pConnectionDataIn, 
                                dwSizeOfConnectionDataIn,
                                &pConnProp);

    if (NO_ERROR != dwErr)
    {
        goto LDone;
    }

    dwErr = ConnPropGetV1Struct ( pConnProp, &pConnPropv1 );
    if ( NO_ERROR != dwErr )
    {
        goto LDone;
    }

    dwErr = ReadUserData(pUserDataIn, dwSizeOfUserDataIn, &pUserProp);

    if (NO_ERROR != dwErr)
    {
        goto LDone;
    }

    if (   !(dwFlags & RAS_EAP_FLAG_LOGON)
        || (NULL == pUserDataIn))
    {
        dwErr = GetCertInfo(fServer, fRouterConfig, dwFlags, pwszPhonebook,
                    pwszEntry, hwndParent, pwszStoreName, pConnPropv1, &pUserProp,
                    ppwszIdentity);

        if (NO_ERROR != dwErr)
        {
#if WINVER > 0x0500
            if ( dwErr == SCARD_E_CANCELLED || dwErr == SCARD_W_CANCELLED_BY_USER )
            {
                dwErr = ERROR_READING_SCARD;
            }
#endif
            goto LDone;
        }

        if ( (!fServer) &&
             ( dwFlags & RAS_EAP_FLAG_8021X_AUTH ) &&
             !(pConnProp->fFlags & EAPTLS_CONN_FLAG_REGISTRY)
           )
        {
            //
            // Encrypt PIN and send it back
            //

            dwErr = EncryptData ( (PBYTE)pUserProp->pwszPin, 
                                    lstrlen(pUserProp->pwszPin) * sizeof(WCHAR),
                                    &pbEncPIN,
                                    &cbEncPIN
                                );

            if ( NO_ERROR != dwErr )
            {
                goto LDone;
            }
            dwErr = AllocUserDataWithNewPin(pUserProp, pbEncPIN, cbEncPIN, &pUserProp);
        }
        

        *ppUserDataOut = (BYTE*)(pUserProp);
        *pdwSizeOfUserDataOut = pUserProp->dwSize;
        pUserProp = NULL;
        goto LDone;
    }
    else
    {
        if (EAPTLS_CONN_FLAG_REGISTRY & pConnProp->fFlags)
        {
            dwErr = ERROR_NO_REG_CERT_AT_LOGON;
            goto LDone;
        }

        if (EAPTLS_CONN_FLAG_DIFF_USER & pConnProp->fFlags)
        {
            dwErr = ERROR_NO_DIFF_USER_AT_LOGON;
            goto LDone;
        }

        dwErr = GetIdentityFromLogonInfo(pUserDataIn, dwSizeOfUserDataIn,
                    &pwszIdentity);

        if (NO_ERROR != dwErr)
        {
            goto LDone;
        }

        if (NULL != ppwszIdentity)
        {
            *ppwszIdentity = pwszIdentity;
            pwszIdentity = NULL;
        }
    }

LDone:

    EapTlsInitialize2(FALSE, TRUE /* fUI */);

    LocalFree(pwszIdentity);
    LocalFree(pUserProp);
    LocalFree(pConnProp);
    LocalFree(pConnPropv1);
    LocalFree(pbEncPIN);
    return(dwErr);
}



DWORD
PeapInvokeServerConfigUI ( IN HWND hWnd,
                             IN WCHAR * pwszMachineName
                           )
{

    //
    // Since this is the client side code only for xpsp1, we remove
    // serve side resources.
    //
    return ERROR_CALL_NOT_IMPLEMENTED;
#if 0
    WCHAR                       awszStoreName[MAX_COMPUTERNAME_LENGTH + 10 + 1];
    DWORD                       dwStrLen;    
    BYTE*                       pUserDataOut                = NULL;
    DWORD                       dwSizeOfUserDataOut;
    BOOL                        fLocal                      = FALSE;
    PEAP_SERVER_CONFIG_DIALOG   ServerConfigDialog;
    PPEAP_ENTRY_USER_PROPERTIES pEntryProp = NULL;
    INT_PTR                     nRet = -1;    
    DWORD                       dwErr                       = NO_ERROR;


    EapTlsInitialize2(TRUE, TRUE /* fUI */);

    ZeroMemory ( &ServerConfigDialog, sizeof(ServerConfigDialog));

    if (0 == *pwszMachineName)
    {
        fLocal = TRUE;
    }

    ServerConfigDialog.pwszMachineName = pwszMachineName;
    wcscpy(awszStoreName, L"\\\\");
    wcsncat(awszStoreName, pwszMachineName, MAX_COMPUTERNAME_LENGTH);
    
    dwErr = PeapServerConfigDataIO(TRUE /* fRead */, fLocal ? NULL : awszStoreName,
                (BYTE**)&( ServerConfigDialog.pUserProp), 0);

    if (NO_ERROR != dwErr)
    {
        goto LDone;
    }

    //
    // Create cert list to display and then show the server config UI.
    //
    dwStrLen = wcslen(awszStoreName);
    wcsncat(awszStoreName, L"\\MY", wcslen(L"\\MY") );

    CreateCertList( TRUE,
                FALSE, /*fRouter */
                TRUE /* fRoot */,
                &(ServerConfigDialog.pCertList),
                &(ServerConfigDialog.pSelCertList),
                1,
                &(ServerConfigDialog.pUserProp->CertHash),
                fLocal ? L"MY": awszStoreName);

    
    wcsncat(awszStoreName, L"\\MY", wcslen(L"\\MY"));
    awszStoreName[dwStrLen] = 0; // Get rid of the \MY

    //
    // Create list of All EAP Types allowed 
    //

    dwErr = PeapEapInfoGetList ( pwszMachineName, &(ServerConfigDialog.pEapInfo) );
    if ( NO_ERROR != dwErr )
    {
        goto LDone;
    }

    //
    // From the user info get the selected PEAP Type if any
    //
    
    dwErr = PeapGetFirstEntryUserProp ( ServerConfigDialog.pUserProp, 
                                        &pEntryProp
                                      );
    if ( NO_ERROR == dwErr )
    {
        // Set the selected EAP type
        //
        PeapEapInfoFindListNode (   pEntryProp->dwEapTypeId, 
                                    ServerConfigDialog.pEapInfo, 
                                    &(ServerConfigDialog.pSelEapInfo) 
                                );
    }

    //
    // Invoke the config UI.
    //
    nRet = DialogBoxParam(
                GetResouceDLLHInstance(),
                MAKEINTRESOURCE(IDD_PEAP_SERVER_UI),
                hWnd,
                PeapServerDialogProc,
                (LPARAM)&ServerConfigDialog);

    if (-1 == nRet)
    {
        dwErr = GetLastError();
        goto LDone;
    }
    else if (IDOK != nRet)
    {
        dwErr = ERROR_CANCELLED;
        goto LDone;
    }

    if ( ServerConfigDialog.pNewUserProp )
    {
        dwErr = PeapServerConfigDataIO(FALSE /* fRead */, fLocal ? NULL : awszStoreName,
                    (PBYTE *) &(ServerConfigDialog.pNewUserProp), sizeof(PEAP_USER_PROP));
    }

LDone:

    // Ignore errors
    RasEapFreeMemory(pUserDataOut);
    LocalFree(ServerConfigDialog.pNewUserProp );
    LocalFree(ServerConfigDialog.pUserProp );
    PeapEapInfoFreeList ( ServerConfigDialog.pEapInfo );
    EapTlsInitialize2(FALSE, TRUE /* fUI */);
    return dwErr;
#endif
}


/*

Returns:
    NO_ERROR: iff Success

Notes:
    Congigure EAP-TLS for the RAS server.

*/

DWORD
InvokeServerConfigUI(
    IN  HWND    hWnd,
    IN  WCHAR*  pwszMachineName
)
{
#define MAX_STORE_NAME_LENGTH   MAX_COMPUTERNAME_LENGTH + 10

    WCHAR                   awszStoreName[MAX_STORE_NAME_LENGTH + 1];
    DWORD                   dwStrLen;

    EAPTLS_USER_PROPERTIES* pUserProp                   = NULL;
    BYTE*                   pUserDataOut                = NULL;
    DWORD                   dwSizeOfUserDataOut;
    BOOL                    fLocal                      = FALSE;

    DWORD                   dwErr                       = NO_ERROR;

    if (0 == *pwszMachineName)
    {
        fLocal = TRUE;
    }

    wcscpy(awszStoreName, L"\\\\");
    wcsncat(awszStoreName, pwszMachineName, MAX_COMPUTERNAME_LENGTH);

    dwErr = ServerConfigDataIO(TRUE /* fRead */, fLocal ? NULL : awszStoreName,
                (BYTE**)&pUserProp, 0);

    if (NO_ERROR != dwErr)
    {
        goto LDone;
    }

    dwStrLen = wcslen(awszStoreName);
    wcsncat(awszStoreName, L"\\MY", wcslen(L"\\MY"));

    dwErr = EapTlsInvokeIdentityUI(
                TRUE /* fServer */,
                FALSE /* fRouterConfig */,
                0 /* dwFlags */, 
                fLocal ? L"MY" : awszStoreName,
                L"" /* pwszPhonebook */,
                L"" /* pwszEntry */,
                hWnd,
                NULL /* pConnectionDataIn */,
                0 /* dwSizeOfConnectionDataIn */,
                (BYTE*)pUserProp,
                pUserProp->dwSize,
                &pUserDataOut,
                &dwSizeOfUserDataOut,
                NULL /* pszIdentity */);

    if (NO_ERROR != dwErr)
    {
        goto LDone;
    }

    awszStoreName[dwStrLen] = 0; // Get rid of the \MY

    dwErr = ServerConfigDataIO(FALSE /* fRead */, fLocal ? NULL : awszStoreName,
                &pUserDataOut, dwSizeOfUserDataOut);

LDone:

    // Ignore errors
    RasEapFreeMemory(pUserDataOut);
    LocalFree(pUserProp);

    return(dwErr);
}

DWORD
PeapGetIdentity(
    IN  DWORD           dwEapTypeId,
    IN  HWND            hwndParent,
    IN  DWORD           dwFlags,
    IN  const WCHAR*    pwszPhonebook,
    IN  const WCHAR*    pwszEntry,
    IN  BYTE*           pConnectionDataIn,
    IN  DWORD           dwSizeOfConnectionDataIn,
    IN  BYTE*           pUserDataIn,
    IN  DWORD           dwSizeOfUserDataIn,
    OUT BYTE**          ppUserDataOut,
    OUT DWORD*          pdwSizeOfUserDataOut,
    OUT WCHAR**         ppwszIdentityOut
)
{
    DWORD                           dwRetCode = NO_ERROR;
    PPEAP_CONN_PROP                 pConnProp = NULL;
    PPEAP_USER_PROP                 pUserProp = NULL;
    PPEAP_USER_PROP                 pUserPropNew = NULL;
    PPEAP_EAP_INFO                  pEapInfo = NULL;
    PPEAP_EAP_INFO                  pFirstEapInfo = NULL;
    PEAP_ENTRY_CONN_PROPERTIES UNALIGNED *   pFirstEntryConnProp = NULL;
    PEAP_ENTRY_USER_PROPERTIES UNALIGNED *   pFirstEntryUserProp = NULL;
    PEAP_DEFAULT_CRED_DIALOG        DefaultCredDialog;
    INT_PTR                         nRet;
    LPWSTR                          lpwszLocalMachineName = NULL;    
    //
    // Since PEAP itself does not have any client identity of its own,
    // check the first configured eap type and call it's get identity
    // entry point.  If we dont have any eaptype configured, it is an
    // error condition.
    //
    dwRetCode = PeapReadConnectionData( ( dwFlags & RAS_EAP_FLAG_8021X_AUTH ),
                                        pConnectionDataIn,
                                        dwSizeOfConnectionDataIn,
                                        &pConnProp
                                      );
    if ( NO_ERROR != dwRetCode )
    {
        goto LDone;
    }

    dwRetCode = PeapReadUserData (  pUserDataIn,
                                    dwSizeOfUserDataIn,
                                    &pUserProp
                                 );
    if ( NO_ERROR != dwRetCode )
    {
        goto LDone;
    }

    //
    // This is probably not a very good thing.  Modify PeapReadConnectionData to
    // put in the default of first eap type that it finds...
    // For now we have the only one - mschap v2 so may not be an issue...
    //
    if ( !pConnProp->dwNumPeapTypes )
    {
        dwRetCode = ERROR_PROTOCOL_NOT_CONFIGURED;
        goto LDone;
    }

    //
    // Check to see if the conn prop and user prop are mismatched.  If so, we need to get the 
    // User props all over again
    
    //
    // Now invoke the first EAP method configured ( in this release, the only EAP )
    // method and get the config info from it...
    //

    dwRetCode = PeapEapInfoGetList ( NULL, &pEapInfo);
    if ( NO_ERROR != dwRetCode )
    {
        goto LDone;
    }

    //
    //  If we have come this far, we have at least one configured eaptype in 
    //  PEAP.  So, get the entry properties for it.
    //
    dwRetCode = PeapGetFirstEntryConnProp ( pConnProp, 
                                            &pFirstEntryConnProp
                                          );

    if ( NO_ERROR != dwRetCode )
    {
        goto LDone;
    }

    dwRetCode = PeapGetFirstEntryUserProp ( pUserProp, 
                                            &pFirstEntryUserProp
                                          );

    if ( NO_ERROR != dwRetCode )
    {
        goto LDone;
    }

    dwRetCode = PeapEapInfoFindListNode ( pFirstEntryConnProp->dwEapTypeId,
                                          pEapInfo,
                                          &pFirstEapInfo
                                        );
    if ( NO_ERROR != dwRetCode )
    {
        goto LDone;
    }

    if ( pFirstEntryConnProp->dwEapTypeId != pFirstEntryUserProp->dwEapTypeId )
    {
        //
        // We have mismatched user prop and conn prop.  So Reset the USer Prop Structure
        //
        LocalFree ( pUserProp );

        dwRetCode = PeapReDoUserData (pFirstEntryConnProp->dwEapTypeId,
                                        &pUserProp
                                     );

        if ( NO_ERROR != dwRetCode )
        {
            goto LDone;
        }
        dwRetCode = PeapGetFirstEntryUserProp ( pUserProp, 
                                                &pFirstEntryUserProp
                                            );

        if ( NO_ERROR != dwRetCode )
        {
            goto LDone;
        }
        
    }

    if ( pFirstEntryConnProp->dwSize > sizeof(PEAP_ENTRY_CONN_PROPERTIES))
    {
        pFirstEapInfo->pbClientConfigOrig = pFirstEntryConnProp->bData;
        pFirstEapInfo->dwClientConfigOrigSize = pFirstEntryConnProp->dwSize - sizeof(PEAP_ENTRY_CONN_PROPERTIES) + 1;
    }
    else
    {
        pFirstEapInfo->pbClientConfigOrig = NULL;
        pFirstEapInfo->dwClientConfigOrigSize = 0;
    }
    //if typeid is 0, no user props are setup yet.
    if ( pFirstEntryUserProp->dwSize > sizeof(PEAP_ENTRY_USER_PROPERTIES))
    {
        pFirstEapInfo->pbUserConfigOrig = pFirstEntryUserProp->bData;
        pFirstEapInfo->dwUserConfigOrigSize = pFirstEntryUserProp->dwSize - sizeof(PEAP_ENTRY_USER_PROPERTIES) + 1;
    }
    else
    {
        pFirstEapInfo->pbUserConfigOrig = NULL;
        pFirstEapInfo->dwUserConfigOrigSize = 0;
    }


    //
    // Invoke Identity UI for the first entry
    // and - NOTE we will have to chain this later.
    // and save it in the conn prop of each 
    if ( pFirstEapInfo->lpwszIdentityUIPath )
    {
        dwRetCode = PeapEapInfoInvokeIdentityUI (   hwndParent, 
                                                    pFirstEapInfo,
                                                    pwszPhonebook,
                                                    pwszEntry,
                                                    pUserDataIn,
                                                    dwSizeOfUserDataIn,
                                                    ppwszIdentityOut,
                                                    dwFlags
                                                );
        if ( NO_ERROR == dwRetCode )
        {
            //
            // Check to see if we have new user data
            //

            if ( pFirstEapInfo->pbUserConfigNew && pFirstEapInfo->dwNewUserConfigSize )
            {
                //
                // redo the user prop blob 
                //
            
                pUserPropNew = (PPEAP_USER_PROP) 
                    LocalAlloc ( LPTR, sizeof(PEAP_USER_PROP) + pFirstEapInfo->dwNewUserConfigSize  );
                if ( NULL == pUserPropNew )
                {
                    dwRetCode = ERROR_OUTOFMEMORY;
                    goto LDone;
                }
            
                CopyMemory ( pUserPropNew, pUserProp, sizeof(PEAP_USER_PROP) );
                pUserPropNew->UserProperties.dwVersion = 1;
                pUserPropNew->UserProperties.dwSize = sizeof(PEAP_ENTRY_USER_PROPERTIES) +
                    pFirstEapInfo->dwNewUserConfigSize -1;
                pUserPropNew->dwSize = pUserPropNew->UserProperties.dwSize + 
                    sizeof(PEAP_USER_PROP) - sizeof(PEAP_ENTRY_USER_PROPERTIES);
                pUserPropNew->UserProperties.dwEapTypeId = pFirstEapInfo->dwTypeId;
                pUserPropNew->UserProperties.fUsingPeapDefault = 0;
                CopyMemory (pUserPropNew->UserProperties.bData,  
                            pFirstEapInfo->pbUserConfigNew, 
                            pFirstEapInfo->dwNewUserConfigSize
                           );
                *ppUserDataOut = (PBYTE)pUserPropNew;
                *pdwSizeOfUserDataOut = pUserPropNew->dwSize;
                pUserPropNew = NULL;
            
            }
            else
            {
                *ppUserDataOut = (PBYTE)pUserProp;
                *pdwSizeOfUserDataOut = pUserProp->dwSize;
                pUserProp = NULL;
            }
        }
    }
    else
    {

        //MAchine Auth
        if ( dwFlags & RAS_EAP_FLAG_MACHINE_AUTH)
        {

            //Send the identity back as domain\machine$
            dwRetCode = GetLocalMachineName(&lpwszLocalMachineName );
            if ( NO_ERROR != dwRetCode )
            {
                EapTlsTrace("Failed to get computer name");
                goto LDone;
            }
            if ( ! FFormatMachineIdentity1 ( lpwszLocalMachineName, 
                                            ppwszIdentityOut )
               )
            {
                EapTlsTrace("Failed to format machine identity");
            }
            goto LDone;
        }
        if ( dwFlags & RAS_EAP_FLAG_NON_INTERACTIVE )
        {
            EapTlsTrace("Passed non interactive mode when interactive mode expected.");
            dwRetCode = ERROR_INTERACTIVE_MODE;
            goto LDone;
        }


        //
        // provide our default identity - You cannot save this identity or anything like that.
        // This is for the lame EAP methods that dont supply their own identity
        //
        ZeroMemory ( &DefaultCredDialog, sizeof(DefaultCredDialog) );

        nRet = DialogBoxParam(
                    GetResouceDLLHInstance(),
                    MAKEINTRESOURCE(IDD_DIALOG_DEFAULT_CREDENTIALS),
                    hwndParent,
                    DefaultCredDialogProc,
                    (LPARAM)&DefaultCredDialog);

        // EapTlsPinDialog.pUserProp may have been realloced

        if (-1 == nRet)
        {
            dwRetCode = GetLastError();
            goto LDone;
        }
        else if (IDOK != nRet)
        {
            dwRetCode = ERROR_CANCELLED;
            goto LDone;
        }

        //CReate the new user prop blob        
        pUserPropNew = (PPEAP_USER_PROP) 
            LocalAlloc ( LPTR, 
                sizeof(PEAP_USER_PROP) + sizeof( PEAP_DEFAULT_CREDENTIALS )  );
        if ( NULL == pUserPropNew )
        {
            dwRetCode = ERROR_OUTOFMEMORY;
            goto LDone;
        }
    
        CopyMemory ( pUserPropNew, pUserProp, sizeof(PEAP_USER_PROP) );

        pUserPropNew->UserProperties.dwVersion = 1;

        pUserPropNew->UserProperties.dwSize = sizeof(PEAP_ENTRY_USER_PROPERTIES) +
            sizeof(PEAP_DEFAULT_CREDENTIALS) - 1;

        pUserPropNew->UserProperties.fUsingPeapDefault = 1;

        pUserPropNew->dwSize = pUserPropNew->UserProperties.dwSize + 
            sizeof(PEAP_USER_PROP) - sizeof(PEAP_ENTRY_USER_PROPERTIES);

        pUserPropNew->UserProperties.dwEapTypeId = pFirstEapInfo->dwTypeId;
    
        CopyMemory (pUserPropNew->UserProperties.bData,  
                    &(DefaultCredDialog.PeapDefaultCredentials),
                    sizeof(DefaultCredDialog.PeapDefaultCredentials)
                   );
        *ppUserDataOut = (PBYTE)pUserPropNew;
        *pdwSizeOfUserDataOut = pUserPropNew->dwSize;

        //
        // Now create the identity with uid and domain if any
        //
        dwRetCode = GetIdentityFromUserName ( 
            DefaultCredDialog.PeapDefaultCredentials.wszUserName,
            DefaultCredDialog.PeapDefaultCredentials.wszDomain,
            ppwszIdentityOut
        );
        if ( NO_ERROR != dwRetCode )
        {
            goto LDone;
        }

        pUserPropNew = NULL;
    }

LDone:
    LocalFree( lpwszLocalMachineName );
    LocalFree(pConnProp);
    LocalFree(pUserProp);
    LocalFree(pUserPropNew);
    PeapEapInfoFreeList( pEapInfo );
    return dwRetCode;
}



/*

Returns:
    NO_ERROR: iff Success

Notes:

*/

DWORD
RasEapGetIdentity(
    IN  DWORD           dwEapTypeId,
    IN  HWND            hwndParent,
    IN  DWORD           dwFlags,
    IN  const WCHAR*    pwszPhonebook,
    IN  const WCHAR*    pwszEntry,
    IN  BYTE*           pConnectionDataIn,
    IN  DWORD           dwSizeOfConnectionDataIn,
    IN  BYTE*           pUserDataIn,
    IN  DWORD           dwSizeOfUserDataIn,
    OUT BYTE**          ppUserDataOut,
    OUT DWORD*          pdwSizeOfUserDataOut,
    OUT WCHAR**         ppwszIdentityOut
)
{
    DWORD   dwErr = ERROR_INVALID_PARAMETER;
    if ( PPP_EAP_TLS == dwEapTypeId )
    {
        dwErr = EapTlsInvokeIdentityUI(
                    FALSE /* fServer */,
                    FALSE /* fRouterConfig */,
                    dwFlags,
                    L"MY",
                    pwszPhonebook,
                    pwszEntry,
                    hwndParent,
                    pConnectionDataIn,
                    dwSizeOfConnectionDataIn,
                    pUserDataIn,
                    dwSizeOfUserDataIn,
                    ppUserDataOut,
                    pdwSizeOfUserDataOut,
                    ppwszIdentityOut);
    }
#ifdef IMPL_PEAP
    else if ( PPP_EAP_PEAP == dwEapTypeId )
    {
        dwErr = PeapGetIdentity(dwEapTypeId,
                                hwndParent,
                                dwFlags,
                                pwszPhonebook,
                                pwszEntry,
                                pConnectionDataIn,
                                dwSizeOfConnectionDataIn,
                                pUserDataIn,
                                dwSizeOfUserDataIn,
                                ppUserDataOut,
                                pdwSizeOfUserDataOut,
                                ppwszIdentityOut
                               );

    }
#endif
    return(dwErr);
}

/*

Returns:

Notes:
    Called to free memory.

*/

DWORD 
RasEapFreeMemory(
    IN  BYTE*   pMemory
)
{
    LocalFree(pMemory);
    return(NO_ERROR);
}


#if 0
#if WINVER > 0x0500

/*
Returns:

Notes:
    API to create a connection Properties V1 Blob
*/
/*
Returns:

Notes:
    API to create a connection Properties V1 Blob
*/

DWORD
RasEapCreateConnProp
(
    IN      PEAPTLS_CONNPROP_ATTRIBUTE  pAttr,
    IN      PVOID *                     ppConnPropIn,
    IN      DWORD *                     pdwConnPropSizeIn,
    OUT     PVOID *                     ppConnPropOut,
    OUT     DWORD *                     pdwConnPropSizeOut
)
{
    DWORD                       dwRetCode = NO_ERROR;
    DWORD                       dwAllocBytes = 0;
    DWORD                       dwNumHashesOrig = 0;
    DWORD                       dwServerNamesLengthOrig = 0;
    PEAPTLS_CONNPROP_ATTRIBUTE  pAttrInternal = pAttr;
    EAPTLS_CONN_PROPERTIES_V1 * pConnPropv1 = NULL;
    EAPTLS_CONN_PROPERTIES_V1 * pConnPropv1Orig = NULL;
    PEAPTLS_CONNPROP_ATTRIBUTE  pAttrServerNames = NULL;
    PEAPTLS_CONNPROP_ATTRIBUTE  pAttrHashes = NULL;
    EAPTLS_HASH                 sHash;
    DWORD                       i;

    if ( !pAttr || !ppConnPropOut )
    {
        dwRetCode = ERROR_INVALID_PARAMETER;
        goto done;
    }
    *ppConnPropOut = NULL;
    
    //
    // Get the sizeof this allocation.
    //
    dwAllocBytes = sizeof(EAPTLS_CONN_PROPERTIES_V1);

    while ( pAttrInternal->ecaType != ecatMinimum )
    {
        switch ( pAttrInternal->ecaType )
        {
            case ecatMinimum:
            case ecatFlagRegistryCert:
            case ecatFlagScard:
            case ecatFlagValidateServer:
            case ecatFlagValidateName:
            case ecatFlagDiffUser:
                break;
            case ecatServerNames:
                dwAllocBytes += pAttrInternal->dwLength;
                break;
            case ecatRootHashes:
                dwAllocBytes += ( ( (pAttrInternal->dwLength)/MAX_HASH_SIZE)  * sizeof(EAPTLS_HASH) );
                break;
            default:
                dwRetCode = ERROR_INVALID_PARAMETER;
                goto done;
        }
        pAttrInternal ++;
    }

    pAttrInternal = pAttr;

    if (*ppConnPropIn == NULL)
    {
        pConnPropv1 = (EAPTLS_CONN_PROPERTIES_V1 *) LocalAlloc(LPTR, dwAllocBytes );
        if ( NULL == pConnPropv1 )
        {
            dwRetCode = GetLastError();
            goto done;
        }
    }
    else
    {
        // Input struct with always be Version 0, convert internally to 
        // Version 1
        dwRetCode = ConnPropGetV1Struct ( ((EAPTLS_CONN_PROPERTIES *)(*ppConnPropIn)), &pConnPropv1Orig );
        if ( NO_ERROR != dwRetCode )
        {
            goto done;
        }
        if (pConnPropv1Orig->dwNumHashes)
        {
            dwAllocBytes += pConnPropv1Orig->dwNumHashes*sizeof(EAPTLS_HASH);
        }
        dwAllocBytes += wcslen ( (WCHAR *)( pConnPropv1Orig->bData + (pConnPropv1Orig->dwNumHashes * sizeof(EAPTLS_HASH)) )) * sizeof(WCHAR) + sizeof(WCHAR);
        pConnPropv1 = (EAPTLS_CONN_PROPERTIES_V1 *) LocalAlloc(LPTR, dwAllocBytes );
        if ( NULL == pConnPropv1 )
        {
            dwRetCode = GetLastError();
            goto done;
        }
    }

    pConnPropv1->dwVersion = 1;
    pConnPropv1->dwSize = dwAllocBytes;
    //
    //Set the flags first
    //
    while ( pAttrInternal->ecaType != ecatMinimum )
    {
        switch ( pAttrInternal->ecaType )
        {
            case ecatFlagRegistryCert:
                pConnPropv1->fFlags |= EAPTLS_CONN_FLAG_REGISTRY;
                break;

            case ecatFlagScard:
                pConnPropv1->fFlags &= ~EAPTLS_CONN_FLAG_REGISTRY;
                break;

            case ecatFlagValidateServer:
                if ( *((BOOL *)(pAttrInternal->Value)) )
                    pConnPropv1->fFlags &= ~EAPTLS_CONN_FLAG_NO_VALIDATE_CERT;
                else
                    pConnPropv1->fFlags |= EAPTLS_CONN_FLAG_NO_VALIDATE_CERT;
                break;
            case ecatFlagValidateName:
                if ( *((BOOL *)(pAttrInternal->Value)) )
                    pConnPropv1->fFlags &= ~EAPTLS_CONN_FLAG_NO_VALIDATE_NAME;
                else
                    pConnPropv1->fFlags |= EAPTLS_CONN_FLAG_NO_VALIDATE_NAME;
                break;
            case ecatFlagDiffUser:
                if ( *((BOOL *)(pAttrInternal->Value)) )
                    pConnPropv1->fFlags &= ~EAPTLS_CONN_FLAG_DIFF_USER;
                else
                    pConnPropv1->fFlags |= EAPTLS_CONN_FLAG_DIFF_USER;
                break;

            case ecatServerNames:
                pAttrServerNames = pAttrInternal;
                break;
            case ecatRootHashes:
                pAttrHashes = pAttrInternal;
                break;
        }
        pAttrInternal++;
    }
        
    dwNumHashesOrig = pConnPropv1Orig?pConnPropv1Orig->dwNumHashes:0;
    if ( dwNumHashesOrig )
    {
        CopyMemory( pConnPropv1->bData, pConnPropv1Orig->bData, sizeof(EAPTLS_HASH)*dwNumHashesOrig );
        pConnPropv1->dwNumHashes = dwNumHashesOrig;
    }
    if ( pAttrHashes )
    {
        DWORD   dwNumHashes = 0;
        dwNumHashes = (pAttrHashes->dwLength)/MAX_HASH_SIZE;
        for ( i = 0; i < dwNumHashes; i ++ )
        {
            ZeroMemory( &sHash, sizeof(sHash) );
            sHash.cbHash = MAX_HASH_SIZE;
            CopyMemory( sHash.pbHash, ((PBYTE)pAttrHashes->Value) + MAX_HASH_SIZE * i, MAX_HASH_SIZE );
            CopyMemory( pConnPropv1->bData + sizeof(EAPTLS_HASH) * (pConnPropv1->dwNumHashes + i) , &sHash, sizeof(sHash) );
        }
        pConnPropv1->dwNumHashes += dwNumHashes;
    }

    dwServerNamesLengthOrig = pConnPropv1Orig?(wcslen((WCHAR*)(pConnPropv1Orig->bData+sizeof(EAPTLS_HASH) * (pConnPropv1Orig->dwNumHashes)))*sizeof(WCHAR) + sizeof (WCHAR) ):0;
    if ( dwServerNamesLengthOrig )
    {
        CopyMemory ( pConnPropv1->bData + sizeof(EAPTLS_HASH) * pConnPropv1->dwNumHashes,
                     pConnPropv1Orig->bData+sizeof(EAPTLS_HASH) * pConnPropv1Orig->dwNumHashes,
                     dwServerNamesLengthOrig
                   );
    }
    if ( pAttrServerNames )
    {
        //Setup the server name
        CopyMemory ( pConnPropv1->bData + sizeof(EAPTLS_HASH) * pConnPropv1->dwNumHashes + dwServerNamesLengthOrig,
                     pAttrServerNames->Value,
                     pAttrServerNames->dwLength
                   );
    }

    dwRetCode = ConnPropGetV0Struct ( pConnPropv1, (EAPTLS_CONN_PROPERTIES ** )ppConnPropOut );
    if ( NO_ERROR != dwRetCode )
    {
        goto done;
    }

    *pdwConnPropSizeOut = ((EAPTLS_CONN_PROPERTIES * )*ppConnPropOut)->dwSize;
    
done:

    LocalFree ( pConnPropv1 );
    return dwRetCode;
}

#endif

#endif

////////////////////////// all PEAP related stuff ///////////////////////////////////////
TCHAR*
ComboBox_GetPsz(
    IN HWND hwnd,
    IN INT  nIndex )

    /* Returns heap block containing the text contents of the 'nIndex'th item
    ** of combo box 'hwnd' or NULL.  It is caller's responsibility to Free the
    ** returned string.
    */
{
    INT    cch;
    TCHAR* psz;

    cch = ComboBox_GetLBTextLen( hwnd, nIndex );
    if (cch < 0)
        return NULL;

    psz = LocalAlloc (LPTR, (cch + 1) * sizeof(TCHAR) );

    if (psz)
    {
        *psz = TEXT('\0');
        ComboBox_GetLBText( hwnd, nIndex, psz );
    }

    return psz;
}

VOID
ComboBox_AutoSizeDroppedWidth(
    IN HWND hwndLb )

    /* Set the width of the drop-down list 'hwndLb' to the width of the
    ** longest item (or the width of the list box if that's wider).
    */
{
    HDC    hdc;
    HFONT  hfont;
    TCHAR* psz;
    SIZE   size;
    DWORD  cch;
    DWORD  dxNew;
    DWORD  i;

    hfont = (HFONT )SendMessage( hwndLb, WM_GETFONT, 0, 0 );
    if (!hfont)
        return;

    hdc = GetDC( hwndLb );
    if (!hdc)
        return;

    SelectObject( hdc, hfont );

    dxNew = 0;
    for (i = 0; psz = ComboBox_GetPsz( hwndLb, i ); ++i)
    {
        cch = lstrlen( psz );
        if (GetTextExtentPoint32( hdc, psz, cch, &size ))
        {
            if (dxNew < (DWORD )size.cx)
                dxNew = (DWORD )size.cx;
        }

        LocalFree( psz );
    }

    ReleaseDC( hwndLb, hdc );

    /* Allow for the spacing on left and right added by the control.
    */
    dxNew += 6;

    /* Figure out if the vertical scrollbar will be displayed and, if so,
    ** allow for it's width.
    */
    {
        RECT  rectD;
        RECT  rectU;
        DWORD dyItem;
        DWORD cItemsInDrop;
        DWORD cItemsInList;

        GetWindowRect( hwndLb, &rectU );
        SendMessage( hwndLb, CB_GETDROPPEDCONTROLRECT, 0, (LPARAM )&rectD );
        dyItem = (DWORD)SendMessage( hwndLb, CB_GETITEMHEIGHT, 0, 0 );
        cItemsInDrop = (rectD.bottom - rectU.bottom) / dyItem;
        cItemsInList = ComboBox_GetCount( hwndLb );
        if (cItemsInDrop < cItemsInList)
            dxNew += GetSystemMetrics( SM_CXVSCROLL );
    }

    SendMessage( hwndLb, CB_SETDROPPEDWIDTH, dxNew, 0 );
}


VOID
PeapEnableValidateNameControls(
    IN  PPEAP_CONN_DIALOG  pPeapConnDialog
)
{
    BOOL            fEnable;

    RTASSERT(NULL != pPeapConnDialog);

    fEnable = !(pPeapConnDialog->pConnProp->EapTlsConnProp.fFlags &
                    EAPTLS_CONN_FLAG_NO_VALIDATE_CERT);

    EnableWindow(pPeapConnDialog->hWndCheckValidateName, fEnable);
    EnableWindow(pPeapConnDialog->hWndStaticRootCaName, fEnable);
    EnableWindow(pPeapConnDialog->hWndListRootCaName, fEnable);

    fEnable = (   fEnable
               && !(pPeapConnDialog->pConnProp->EapTlsConnProp.fFlags &
                        EAPTLS_CONN_FLAG_NO_VALIDATE_NAME));

    EnableWindow(pPeapConnDialog->hWndEditServerName, fEnable);
}



BOOL
PeapConnInitDialog(
    IN  HWND    hWnd,
    IN  LPARAM  lParam
)
{
    PPEAP_CONN_DIALOG           pPeapConnDialog;
    LVCOLUMN                    lvColumn;
    LPWSTR                      lpwszServerName = NULL;
    DWORD                       dwCount = 0;
    PPEAP_EAP_INFO              pEapInfo;
    DWORD                       dwSelItem = 0;
    PEAP_ENTRY_CONN_PROPERTIES UNALIGNED * pEntryProp;
    INT_PTR                     nIndex = 0;
    BOOL                        fCripplePeap = FALSE;


    SetWindowLongPtr(hWnd, DWLP_USER, lParam);

    pPeapConnDialog = (PPEAP_CONN_DIALOG)lParam;

    pPeapConnDialog->hWndCheckValidateCert =
        GetDlgItem(hWnd, IDC_CHECK_VALIDATE_CERT);

    pPeapConnDialog->hWndCheckValidateName =
        GetDlgItem(hWnd, IDC_CHECK_VALIDATE_NAME);

    pPeapConnDialog->hWndEditServerName =
        GetDlgItem(hWnd, IDC_EDIT_SERVER_NAME);

    pPeapConnDialog->hWndStaticRootCaName =
        GetDlgItem(hWnd, IDC_STATIC_ROOT_CA_NAME);

    pPeapConnDialog->hWndListRootCaName =
        GetDlgItem(hWnd, IDC_LIST_ROOT_CA_NAME);

    pPeapConnDialog->hWndComboPeapType = 
        GetDlgItem(hWnd, IDC_COMBO_PEAP_TYPE);

    pPeapConnDialog->hWndButtonConfigure = 
        GetDlgItem(hWnd, IDC_BUTTON_CONFIGURE);

    pPeapConnDialog->hWndCheckEnableFastReconnect =
        GetDlgItem(hWnd, IDC_CHECK_ENABLE_FAST_RECONNECT);
    
    //Set the style to set list boxes.
    ListView_SetExtendedListViewStyle
        (   pPeapConnDialog->hWndListRootCaName,
            ListView_GetExtendedListViewStyle(pPeapConnDialog->hWndListRootCaName) | LVS_EX_CHECKBOXES
        );

    ZeroMemory ( &lvColumn, sizeof(lvColumn));
    lvColumn.fmt = LVCFMT_LEFT;



    ListView_InsertColumn(  pPeapConnDialog->hWndListRootCaName,
                            0,
                            &lvColumn
                         );

    ListView_SetColumnWidth(pPeapConnDialog->hWndListRootCaName,
                            0,
                            LVSCW_AUTOSIZE_USEHEADER
                           );

    //
    //Now we need to init the
    //list box with all the certs and selected cert
    InitListBox (   pPeapConnDialog->hWndListRootCaName,
                    pPeapConnDialog->pCertList,
                    pPeapConnDialog->pConnProp->EapTlsConnProp.dwNumHashes,
                    pPeapConnDialog->ppSelCertList
                );


    lpwszServerName = 
        (LPWSTR )(pPeapConnDialog->pConnProp->EapTlsConnProp.bData + 
        sizeof( EAPTLS_HASH ) * pPeapConnDialog->pConnProp->EapTlsConnProp.dwNumHashes);

    SetWindowText(pPeapConnDialog->hWndEditServerName,
                  lpwszServerName
                  );

    if (pPeapConnDialog->fFlags & EAPTLS_CONN_DIALOG_FLAG_ROUTER)
    {
        pPeapConnDialog->pConnProp->EapTlsConnProp.fFlags |= EAPTLS_CONN_FLAG_REGISTRY;
    }

    CheckDlgButton(hWnd, IDC_CHECK_VALIDATE_CERT,
        (pPeapConnDialog->pConnProp->EapTlsConnProp.fFlags &
            EAPTLS_CONN_FLAG_NO_VALIDATE_CERT) ?
            BST_UNCHECKED : BST_CHECKED);

    CheckDlgButton(hWnd, IDC_CHECK_VALIDATE_NAME,
        (pPeapConnDialog->pConnProp->EapTlsConnProp.fFlags &
            EAPTLS_CONN_FLAG_NO_VALIDATE_NAME) ?
            BST_UNCHECKED : BST_CHECKED);

    PeapEnableValidateNameControls(pPeapConnDialog);        

    //NOTE:
    // For this version of PEAP the control is a combo box.  But
    // it will change to list box and we need to change the 
    // control to list and change the following code to 
    // add only the ones that are applicable

    //
    // Check to see if PEAP is crippled.
    //

    {
        HKEY            hKeyLM =0;

        RegConnectRegistry ( NULL, 
                             HKEY_LOCAL_MACHINE,
                             &hKeyLM
                           );
        
        fCripplePeap = IsPeapCrippled ( hKeyLM );
        RegCloseKey(hKeyLM);

    }

    //
    //Add all the PEAP eap type friendly names
    //
    pEapInfo = pPeapConnDialog->pEapInfo;
    dwCount = 0;
    while ( pEapInfo  )
    {
        if ( pEapInfo->dwTypeId == PPP_EAP_CHAP )
        {
            pEapInfo = pEapInfo->pNext;
            continue;
        }

        nIndex = SendMessage(pPeapConnDialog->hWndComboPeapType, 
                             CB_ADDSTRING, 
                             0, 
                             (LPARAM)pEapInfo->lpwszFriendlyName);
        SendMessage (   pPeapConnDialog->hWndComboPeapType, 
                        CB_SETITEMDATA, 
                        (WPARAM)nIndex,
                        (LPARAM)pEapInfo 
                    );
        ComboBox_AutoSizeDroppedWidth( pPeapConnDialog->hWndComboPeapType );
        dwCount++;
        if ( pPeapConnDialog->pConnProp->dwNumPeapTypes )
        {
            /*
            if ( pPeapConnDialog->pConnProp->EapTlsConnProp.dwSize == sizeof(EAPTLS_CONN_PROPERTIES_V1) )
            {
                //This is a newly initialized structure.
                pEntryProp = (PEAP_ENTRY_CONN_PROPERTIES UNALIGNED *)
                    (((BYTE UNALIGNED *)(pPeapConnDialog->pConnProp)) + sizeof(PEAP_CONN_PROP));
            }
            else
            */
            {
            
                pEntryProp = ( PEAP_ENTRY_CONN_PROPERTIES UNALIGNED *) 
                    ( (BYTE UNALIGNED *)pPeapConnDialog->pConnProp->EapTlsConnProp.bData 
                    + pPeapConnDialog->pConnProp->EapTlsConnProp.dwNumHashes * sizeof(EAPTLS_HASH) + 
                    wcslen(lpwszServerName) * sizeof(WCHAR) + sizeof(WCHAR));
            }
            if ( pEntryProp->dwEapTypeId == pEapInfo->dwTypeId )
            {
                pPeapConnDialog->pSelEapInfo = pEapInfo;
                pPeapConnDialog->pSelEapInfo->pbClientConfigOrig = 
                    pEntryProp->bData;
                pPeapConnDialog->pSelEapInfo->dwClientConfigOrigSize =
                    pEntryProp->dwSize - sizeof(PEAP_ENTRY_CONN_PROPERTIES) + 1;
            }
        }
            
        pEapInfo = pEapInfo->pNext;
    }

    dwSelItem = 0;

    for ( nIndex = 0; nIndex < (INT_PTR)dwCount; nIndex ++ )
    {
        pEapInfo = (PPEAP_EAP_INFO)SendMessage( pPeapConnDialog->hWndComboPeapType,
                                                CB_GETITEMDATA,
                                                (WPARAM)nIndex,
                                                (LPARAM)0L
                                              );
        if ( pEapInfo == pPeapConnDialog->pSelEapInfo )
        {
            dwSelItem = (DWORD)nIndex;
            break;
        }            
    }

    SendMessage(pPeapConnDialog->hWndComboPeapType, CB_SETCURSEL, dwSelItem, 0);
    //
    // Hide/Show Fast reconnect based on if this is a 
    // Wireless client or VPN client.    
    //

    if ( pPeapConnDialog->fFlags & PEAP_CONN_DIALOG_FLAG_8021x )
    {
        ShowWindow ( pPeapConnDialog->hWndCheckEnableFastReconnect,
                     SW_SHOW 
                     );
        //Check the box based on what the 
        CheckDlgButton(hWnd, IDC_CHECK_ENABLE_FAST_RECONNECT,
                ( pPeapConnDialog->pConnProp->dwFlags & 
                    PEAP_CONN_FLAG_FAST_ROAMING) ?
                        BST_CHECKED : BST_UNCHECKED
                );
    }
    else
    {
        ShowWindow ( pPeapConnDialog->hWndCheckEnableFastReconnect,
                     SW_HIDE 
                     );
    }


    if ( pPeapConnDialog->pSelEapInfo->lpwszConfigUIPath )
    {
        EnableWindow(pPeapConnDialog->hWndButtonConfigure, TRUE );
    }
    else
    {
        //
        // There is no configuration option here.
        //
        EnableWindow(pPeapConnDialog->hWndButtonConfigure, FALSE );                    
    }

    //
    // if this is to function in readonly mode, 
    // disable the controls - set them in read only mode.
    
    return(FALSE);
}

/*

Returns:
    TRUE: We prrocessed this message.
    FALSE: We did not prrocess this message.

Notes:
    Response to the WM_COMMAND message (Config UI).

*/

BOOL
PeapConnCommand(
    IN  PPEAP_CONN_DIALOG       pPeapConnDialog,
    IN  WORD                    wNotifyCode,
    IN  WORD                    wId,
    IN  HWND                    hWndDlg,
    IN  HWND                    hWndCtrl
)
{
    DWORD                           dwNumChars;
    PPEAP_CONN_PROP                 pPeapConnProp;
    

    switch(wId)
    {

    case IDC_CHECK_VALIDATE_CERT:

        if (BST_CHECKED == IsDlgButtonChecked(hWndDlg, IDC_CHECK_VALIDATE_CERT))
        {
            pPeapConnDialog->pConnProp->EapTlsConnProp.fFlags &=
                ~EAPTLS_CONN_FLAG_NO_VALIDATE_CERT;

            pPeapConnDialog->pConnProp->EapTlsConnProp.fFlags &=
                ~EAPTLS_CONN_FLAG_NO_VALIDATE_NAME;

            CheckDlgButton(hWndDlg, IDC_CHECK_VALIDATE_NAME, BST_CHECKED);
        }
        else
        {
            pPeapConnDialog->pConnProp->EapTlsConnProp.fFlags |=
                EAPTLS_CONN_FLAG_NO_VALIDATE_CERT;

            pPeapConnDialog->pConnProp->EapTlsConnProp.fFlags |=
                EAPTLS_CONN_FLAG_NO_VALIDATE_NAME;

            CheckDlgButton(hWndDlg, IDC_CHECK_VALIDATE_NAME, BST_UNCHECKED);
        }

        PeapEnableValidateNameControls(pPeapConnDialog);

        return(TRUE);

    case IDC_CHECK_VALIDATE_NAME:

        if (BST_CHECKED == IsDlgButtonChecked(hWndDlg, IDC_CHECK_VALIDATE_NAME))
        {
            pPeapConnDialog->pConnProp->EapTlsConnProp.fFlags &=
                ~EAPTLS_CONN_FLAG_NO_VALIDATE_NAME;
        }
        else
        {
            pPeapConnDialog->pConnProp->EapTlsConnProp.fFlags |=
                EAPTLS_CONN_FLAG_NO_VALIDATE_NAME;
        }

        PeapEnableValidateNameControls(pPeapConnDialog);

        return(TRUE);

    case IDC_COMBO_PEAP_TYPE:
        if (CBN_SELCHANGE != wNotifyCode)
        {
            return(FALSE); // We will not process this message
        }
        //Fall Thru'

    case IDC_BUTTON_CONFIGURE:
        {
            INT nIndex = -1;

            
            nIndex = (INT)SendMessage (  pPeapConnDialog->hWndComboPeapType,
                                    CB_GETCURSEL,
                                    0,0
                                 );
            if ( nIndex != -1 )
            {
                //
                // Change the currently selected EAP Type.
                //
                pPeapConnDialog->pSelEapInfo = (PPEAP_EAP_INFO)
                    SendMessage (   pPeapConnDialog->hWndComboPeapType,
                                    CB_GETITEMDATA,
                                    (WPARAM)nIndex,
                                    (LPARAM)0
                                );

                if ( pPeapConnDialog->pSelEapInfo->lpwszConfigUIPath )
                {
                    EnableWindow(pPeapConnDialog->hWndButtonConfigure, TRUE );
                    if ( wId == IDC_BUTTON_CONFIGURE )
                    {
                        //
                        // Invoke the configure method for selected eap type and if no error is
                        // returned, then set the new configuration
                        //
                        DWORD dwFlags = 0;
                        if ( pPeapConnDialog->fFlags & EAPTLS_CONN_DIALOG_FLAG_ROUTER )
                        {
                            dwFlags |= RAS_EAP_FLAG_ROUTER;
                        }
                        if ( pPeapConnDialog->fFlags & PEAP_CONN_DIALOG_FLAG_8021x )
                        {
                            dwFlags |= RAS_EAP_FLAG_8021X_AUTH;
                        }

                            
                        PeapEapInfoInvokeClientConfigUI ( hWndDlg, 
                                                          pPeapConnDialog->pSelEapInfo,
                                                          dwFlags
                                                          );
                    }
                }
                else
                {
                    //
                    // There is no configuration option here.
                    //
                    EnableWindow(pPeapConnDialog->hWndButtonConfigure, FALSE );                    
                }

            }
            else
            {
                EnableWindow(pPeapConnDialog->hWndButtonConfigure, FALSE );
                pPeapConnDialog->pSelEapInfo = NULL;
            }

            return TRUE;
        }
        
    case IDOK:

       {
           // Setup new PPEAP_CONN_PROP here.
           //
            
           EAPTLS_HASH     *            pHash = NULL;
           DWORD                        dwNumHash = 0;
           DWORD                        dwSelCount = 0;
           DWORD                        dwPeapConnBlobSize = 0;
           PEAP_ENTRY_CONN_PROPERTIES UNALIGNED * pEntryProp;
           EAPTLS_CERT_NODE **          ppSelCertList = NULL;
           WCHAR                        wszTitle[200] = {0};
           WCHAR                        wszMessage[200] = {0};

           if ( NULL == pPeapConnDialog->pSelEapInfo )
           {
               // No item selected so cannot complete configuration
               // $TODO:show message 
               LoadString ( GetHInstance(), 
                            IDS_CANT_CONFIGURE_SERVER_TITLE,
                            wszTitle, sizeof(wszTitle)/sizeof(WCHAR)
                          );

               LoadString ( GetResouceDLLHInstance(), 
                            IDS_PEAP_NO_EAP_TYPE,
                            wszMessage, sizeof(wszMessage)/sizeof(WCHAR)
                          );

               MessageBox ( GetFocus(),  wszMessage, wszTitle, MB_OK|MB_ICONWARNING );

               return TRUE;

           }
           CertListSelectedCount ( pPeapConnDialog->hWndListRootCaName, &dwSelCount );

           if ( dwSelCount > 0 )
           {
               ppSelCertList = (EAPTLS_CERT_NODE **)LocalAlloc(LPTR, sizeof(EAPTLS_CERT_NODE *) * dwSelCount );
               if ( NULL == ppSelCertList )
               {
                   EapTlsTrace("LocalAlloc in Command failed and returned %d",
                       GetLastError());
                   return TRUE;
               }
               pHash = (EAPTLS_HASH *)LocalAlloc(LPTR, sizeof(EAPTLS_HASH ) * dwSelCount );
               if ( NULL == pHash )
               {
                   EapTlsTrace("LocalAlloc in Command failed and returned %d",
                       GetLastError());
                   return TRUE;
               }
               CertListSelected(   pPeapConnDialog->hWndListRootCaName,
                                   pPeapConnDialog->pCertList,
                                   ppSelCertList,
                                   pHash,
                                   dwSelCount
                                   );

           }

            dwNumChars = GetWindowTextLength(pPeapConnDialog->hWndEditServerName);
            //Allocate memory for pPeapConnProp
            
            //Size of Peap conn prop includes
            // sizeof peap conn prop + 
            // sizeof eaptls hashes of selected certs + 
            // sizeof server name + 
            // sizeof PEAP_ENTRY_CONN_PROPERTIES + 
            // sizeof conn prop returned by the selected type.
            //
            dwPeapConnBlobSize = sizeof(PEAP_CONN_PROP) + sizeof(EAPTLS_HASH) * dwSelCount +
                                dwNumChars * sizeof(WCHAR) + sizeof(WCHAR) + 
                                sizeof(PEAP_ENTRY_CONN_PROPERTIES );

            if ( pPeapConnDialog->pSelEapInfo->pbNewClientConfig )
            {
                dwPeapConnBlobSize += pPeapConnDialog->pSelEapInfo->dwNewClientConfigSize;
            }
            else
            {
                dwPeapConnBlobSize += pPeapConnDialog->pSelEapInfo->dwClientConfigOrigSize;
            }
            pPeapConnProp = (PPEAP_CONN_PROP)LocalAlloc( LPTR,   dwPeapConnBlobSize );
            if (NULL == pPeapConnProp)
            {
                EapTlsTrace("LocalAlloc in Command failed and returned %d",
                    GetLastError());
            }
            else
            {
                pPeapConnProp->dwVersion = 1;
                pPeapConnProp->dwSize = dwPeapConnBlobSize;
                pPeapConnProp->dwNumPeapTypes = 1;

                //
                // See if fast roaming is enabled or not.
                //
                
                if ( pPeapConnDialog->fFlags & PEAP_CONN_DIALOG_FLAG_8021x )
                {


                    if ( IsDlgButtonChecked ( hWndDlg,
                                            IDC_CHECK_ENABLE_FAST_RECONNECT
                                            ) == BST_CHECKED 
                    )
                    {
                        pPeapConnProp->dwFlags |= PEAP_CONN_FLAG_FAST_ROAMING;                        
                    }
                    else
                    {
                        pPeapConnProp->dwFlags &= ~PEAP_CONN_FLAG_FAST_ROAMING;
                    }

                }


                CopyMemory( &pPeapConnProp->EapTlsConnProp,
                            &(pPeapConnDialog->pConnProp->EapTlsConnProp),
                            sizeof(EAPTLS_CONN_PROPERTIES_V1)
                          );

                
                
                //
                //Size of EapTlsConnProp is sizeof (EAPTLS_CONN_PROP_V1) -1 ( for bdata)
                //+ sizeof(EAPTLS_HASH) * dwSelCount + sizeof( string) + one for null.
                //
                pPeapConnProp->EapTlsConnProp.dwSize = (sizeof(EAPTLS_CONN_PROPERTIES_V1) - 1) +
                                    sizeof(EAPTLS_HASH) * dwSelCount +
                                    dwNumChars * sizeof(WCHAR) + sizeof(WCHAR);

                CopyMemory ( pPeapConnProp->EapTlsConnProp.bData,
                             pHash,
                             sizeof(EAPTLS_HASH) * dwSelCount
                           );

                pPeapConnProp->EapTlsConnProp.dwVersion = 1;
                pPeapConnProp->EapTlsConnProp.dwNumHashes = dwSelCount;

                GetWindowText(pPeapConnDialog->hWndEditServerName,
                    (LPWSTR)(pPeapConnProp->EapTlsConnProp.bData + sizeof(EAPTLS_HASH) * dwSelCount) ,
                    dwNumChars + 1);

                //
                // Now copy over the PEAP_ENTRY_CONN_PROPERTIES structure
                //
                pEntryProp = (PEAP_ENTRY_CONN_PROPERTIES UNALIGNED *)
                    ((BYTE UNALIGNED *)pPeapConnProp->EapTlsConnProp.bData + sizeof(EAPTLS_HASH) * dwSelCount 
                            + dwNumChars * sizeof(WCHAR)+ sizeof(WCHAR));
                pEntryProp->dwVersion = 1;
                pEntryProp->dwEapTypeId = pPeapConnDialog->pSelEapInfo->dwTypeId;

                pEntryProp->dwSize =  sizeof(PEAP_ENTRY_CONN_PROPERTIES)-1;

                if ( pPeapConnDialog->pSelEapInfo->pbNewClientConfig )
                {
                    pEntryProp->dwSize += pPeapConnDialog->pSelEapInfo->dwNewClientConfigSize ;
                    if ( pPeapConnDialog->pSelEapInfo->dwNewClientConfigSize )
                    {
                        CopyMemory( pEntryProp->bData,
                                    pPeapConnDialog->pSelEapInfo->pbNewClientConfig,
                                    pPeapConnDialog->pSelEapInfo->dwNewClientConfigSize
                                  );
                                    
                    }
                }
                else
                {
                    pEntryProp->dwSize += pPeapConnDialog->pSelEapInfo->dwClientConfigOrigSize;
                    if ( pPeapConnDialog->pSelEapInfo->dwClientConfigOrigSize )
                    {
                        CopyMemory( pEntryProp->bData,
                                    pPeapConnDialog->pSelEapInfo->pbClientConfigOrig,
                                    pPeapConnDialog->pSelEapInfo->dwClientConfigOrigSize
                                  );                                    
                    }
                }                

                LocalFree(pPeapConnDialog->pConnProp);

                if ( pPeapConnDialog->ppSelCertList )
                    LocalFree(pPeapConnDialog->ppSelCertList);

                pPeapConnDialog->ppSelCertList = ppSelCertList;
                
                pPeapConnDialog->pConnProp= pPeapConnProp;
            }

        }
        // Fall through

    case IDCANCEL:

        EndDialog(hWndDlg, wId);
        return(TRUE);

    default:

        return(FALSE);
    }
}



BOOL PeapConnNotify(  PEAP_CONN_DIALOG *pPeapConnDialog, 
                  WPARAM wParam,
                  LPARAM lParam,
                  HWND hWnd
                )
{
    HCERTSTORE          hCertStore = NULL;
    PCCERT_CONTEXT      pCertContext = NULL;    
    LPNMITEMACTIVATE    lpnmItem;
    LVITEM              lvItem;

    if ( wParam == IDC_LIST_ROOT_CA_NAME )
    {
        lpnmItem = (LPNMITEMACTIVATE) lParam;
        if ( lpnmItem->hdr.code == NM_DBLCLK )
        {
            
            ZeroMemory(&lvItem, sizeof(lvItem) );
            lvItem.mask = LVIF_PARAM;
            lvItem.iItem = lpnmItem->iItem;
            ListView_GetItem(lpnmItem->hdr.hwndFrom, &lvItem);
            
            if ( NO_ERROR == GetSelCertContext( //pEaptlsConnDialog->pCertList,
                                                (EAPTLS_CERT_NODE*)(lvItem.lParam) ,
                                                -1,
                                                &hCertStore,
                                                L"ROOT",
                                                &pCertContext
                                              )
               )
            {
                ShowCertDetails( hWnd, hCertStore, pCertContext );
                CertFreeCertificateContext(pCertContext);
                CertCloseStore( hCertStore, CERT_CLOSE_STORE_FORCE_FLAG );
                return TRUE;
            }

            return TRUE;
        }
    }

    return FALSE;
}

/*

Returns:

Notes:
    Callback function used with the Config UI DialogBoxParam function. It 
    processes messages sent to the dialog box. See the DialogProc documentation 
    in MSDN.

*/

INT_PTR CALLBACK
PeapConnDialogProc(
    IN  HWND    hWnd,
    IN  UINT    unMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    PPEAP_CONN_DIALOG  pPeapConnDialog;

    switch (unMsg)
    {
    case WM_INITDIALOG:
        
        return(PeapConnInitDialog(hWnd, lParam));

    case WM_HELP:
    case WM_CONTEXTMENU:
    {
        ContextHelp(g_adwHelp, hWnd, unMsg, wParam, lParam);
        break;
    }

    case WM_NOTIFY:
    {
        pPeapConnDialog = (PPEAP_CONN_DIALOG)GetWindowLongPtr(hWnd, DWLP_USER);
        return PeapConnNotify(  pPeapConnDialog, 
                                wParam,
                                lParam,
                                hWnd
                             );
    }
    case WM_COMMAND:

        pPeapConnDialog = (PPEAP_CONN_DIALOG)GetWindowLongPtr(hWnd, DWLP_USER);

        return(PeapConnCommand(pPeapConnDialog, HIWORD(wParam), LOWORD(wParam),
                       hWnd, (HWND)lParam));
    }

    return(FALSE);
}


VOID
PeapDisplayCertInfo (
    IN  PPEAP_SERVER_CONFIG_DIALOG pServerConfigDialog
)
{
    RTASSERT(NULL != pServerConfigDialog);

    // Erase old values first
    SetWindowText(pServerConfigDialog->hWndEditFriendlyName, L"");
    SetWindowText(pServerConfigDialog->hWndEditIssuer, L"");
    SetWindowText(pServerConfigDialog->hWndEditExpiration, L"");
    

    if (NULL != pServerConfigDialog->pSelCertList)
    {
        if (NULL != pServerConfigDialog->pSelCertList->pwszFriendlyName)
        {
            SetWindowText(pServerConfigDialog->hWndEditFriendlyName,
                pServerConfigDialog->pSelCertList->pwszFriendlyName);
        }

        if (NULL != pServerConfigDialog->pSelCertList->pwszIssuer)
        {
            SetWindowText(pServerConfigDialog->hWndEditIssuer,
                pServerConfigDialog->pSelCertList->pwszIssuer);
        }

        if (NULL != pServerConfigDialog->pSelCertList->pwszExpiration)
        {
            SetWindowText(pServerConfigDialog->hWndEditExpiration,
                pServerConfigDialog->pSelCertList->pwszExpiration);
        }

    }
}

#if 0
BOOL
PeapServerInitDialog(
    IN  HWND    hWnd,
    IN  LPARAM  lParam
)
{
    PPEAP_SERVER_CONFIG_DIALOG          pPeapServerDialog;
    PPEAP_EAP_INFO                      pEapInfo;
    DWORD                               dwSelItem = 0;

    SetWindowLongPtr( hWnd, DWLP_USER, lParam);

    pPeapServerDialog = (PPEAP_SERVER_CONFIG_DIALOG)lParam;

    pPeapServerDialog ->hWndComboServerName =
        GetDlgItem(hWnd, IDC_COMBO_SERVER_NAME);

    pPeapServerDialog ->hWndEditFriendlyName=
        GetDlgItem(hWnd, IDC_EDIT_FRIENDLY_NAME);

    pPeapServerDialog ->hWndEditIssuer=
        GetDlgItem(hWnd, IDC_EDIT_ISSUER);

    pPeapServerDialog ->hWndEditExpiration=
        GetDlgItem(hWnd, IDC_EDIT_EXPIRATION);

    pPeapServerDialog ->hWndComboPeapType=
        GetDlgItem(hWnd, IDC_COMBO_PEAP_TYPE);

    pPeapServerDialog ->hWndBtnConfigure= 
        GetDlgItem(hWnd, IDC_BUTTON_CONFIGURE);

    pPeapServerDialog->hEndEnableFastReconnect = 
        GetDlgItem(hWnd, IDC_CHECK_ENABLE_FAST_RECONNECT );

    InitComboBox(pPeapServerDialog ->hWndComboServerName,
                 pPeapServerDialog ->pCertList,
                 pPeapServerDialog ->pSelCertList
                );

    CheckDlgButton(hWnd, IDC_CHECK_ENABLE_FAST_RECONNECT,
            ( pPeapServerDialog->pUserProp->dwFlags &
                PEAP_USER_FLAG_FAST_ROAMING) ?
                BST_CHECKED : BST_UNCHECKED);

    PeapDisplayCertInfo(pPeapServerDialog);
    //NOTE:
    // For this version of PEAP the control is a combo box.  But
    // it will change to list box and we need to change the 
    // control to list and change the following code to 
    // add only the ones that are applicable

    //
    //Add all the PEAP eap type friendly names
    //
    pEapInfo = pPeapServerDialog->pEapInfo;
    while ( pEapInfo  )
    {
        INT_PTR nIndex = 0;
        nIndex = SendMessage( pPeapServerDialog->hWndComboPeapType, 
                             CB_ADDSTRING, 
                             0, 
                             (LPARAM)pEapInfo->lpwszFriendlyName);
        SendMessage (   pPeapServerDialog->hWndComboPeapType, 
                        CB_SETITEMDATA, 
                        (WPARAM)nIndex,
                        (LPARAM)pEapInfo 
                    );
        
        if ( pPeapServerDialog->pSelEapInfo )
        {
            if ( pPeapServerDialog->pSelEapInfo->dwTypeId == pEapInfo->dwTypeId )
            {
                dwSelItem = (DWORD)nIndex;
            }
        }
        
        pEapInfo = pEapInfo->pNext;
    }

    SendMessage(pPeapServerDialog->hWndComboPeapType, CB_SETCURSEL, dwSelItem, 0);
    //
    // Set the state of configure button
    //
    if ( NULL == pPeapServerDialog->pSelEapInfo )
    {
        pPeapServerDialog->pSelEapInfo = (PPEAP_EAP_INFO)
        SendMessage (   pPeapServerDialog->hWndComboPeapType,
                        CB_GETITEMDATA,
                        (WPARAM)dwSelItem,
                        (LPARAM)0
                    );
    }

    if ( !pPeapServerDialog->pSelEapInfo->lpwszConfigClsId )
    {
        EnableWindow ( pPeapServerDialog->hWndBtnConfigure, FALSE );
    }
    else
    {
        EnableWindow (pPeapServerDialog->hWndBtnConfigure, TRUE );
    }

    return(FALSE);
}

/*

Returns:
    TRUE: We prrocessed this message.
    FALSE: We did not prrocess this message.

Notes:
    Response to the WM_COMMAND message (Config UI).

*/

BOOL
PeapServerCommand(
    IN  PPEAP_SERVER_CONFIG_DIALOG       pPeapServerDialog,
    IN  WORD                            wNotifyCode,
    IN  WORD                            wId,
    IN  HWND                            hWndDlg,
    IN  HWND                            hWndCtrl
)
{

    switch(wId)
    {

    case IDC_COMBO_SERVER_NAME:

        if (CBN_SELCHANGE != wNotifyCode)
        {
            return(FALSE); // We will not process this message
        }

        pPeapServerDialog->pSelCertList = (EAPTLS_CERT_NODE *)
        SendMessage (   hWndCtrl, 
                        CB_GETITEMDATA,
                        SendMessage(hWndCtrl,
                                    CB_GETCURSEL,
                                    0,0L
                                    ),
                        0L
                    );


        PeapDisplayCertInfo(pPeapServerDialog);

        return(TRUE);
    case IDC_COMBO_PEAP_TYPE:
        if (CBN_SELCHANGE != wNotifyCode)
        {
            return(FALSE); // We will not process this message
        }
        //Fall Through...
    case IDC_BUTTON_CONFIGURE:
        {
            INT nIndex = -1;

            
            nIndex = (INT)SendMessage (  pPeapServerDialog->hWndComboPeapType,
                                    CB_GETCURSEL,
                                    0,0
                                 );


            if ( nIndex != -1 )
            {
                //
                // Change the currently selected EAP Type.
                //
                pPeapServerDialog->pSelEapInfo = (PPEAP_EAP_INFO)
                SendMessage (   pPeapServerDialog->hWndComboPeapType,
                                CB_GETITEMDATA,
                                (WPARAM)nIndex,
                                (LPARAM)0
                            );

                if ( pPeapServerDialog->pSelEapInfo->lpwszConfigClsId )
                {
                    EnableWindow(pPeapServerDialog->hWndBtnConfigure, TRUE );
                    if ( wId == IDC_BUTTON_CONFIGURE )
                    {
                        //
                        // Invoke the configure method for selected eap type and if no error is
                        // returned, then set the new configuration
                        //
                        PeapEapInfoInvokeServerConfigUI ( hWndDlg, 
                                                        pPeapServerDialog->pwszMachineName,
                                                        pPeapServerDialog->pSelEapInfo
                                                        );
                    }
                }
                else
                {
                    //
                    // There is no configuration option here.
                    //
                    EnableWindow(pPeapServerDialog->hWndBtnConfigure, FALSE );
                }

            }
            else
            {
                EnableWindow(pPeapServerDialog->hWndBtnConfigure, FALSE );
                pPeapServerDialog->pSelEapInfo = NULL;

            }

            return TRUE;
        }

    case IDOK:

       {
            // Setup new PPEAP_USER_PROP here.
            //

            EAPTLS_HASH     *            pHash = NULL;
            DWORD                        dwNumHash = 0;
            DWORD                        dwSelCount = 0;
            DWORD                        dwPeapConnBlobSize = 0;
            PPEAP_USER_PROP              pUserProp = NULL;
                        

            if ( NULL == pPeapServerDialog->pSelCertList )
            {
                DisplayResourceError ( hWndDlg, IDS_PEAP_NO_SERVER_CERT );
                return TRUE;
            }
            if ( !pPeapServerDialog->pSelCertList->pwszDisplayName )
            {
                DisplayResourceError ( hWndDlg, IDS_PEAP_NO_SERVER_CERT );
                return TRUE;
            }
            if ( !wcslen(pPeapServerDialog->pSelCertList->pwszDisplayName) )
            {
                DisplayResourceError ( hWndDlg, IDS_PEAP_NO_SERVER_CERT );
                return TRUE;
            }

            if ( NULL == pPeapServerDialog->pSelEapInfo )
            {
                DisplayResourceError ( hWndDlg, IDS_PEAP_NO_EAP_TYPE );
                return TRUE;
            }


            pUserProp = (PPEAP_USER_PROP)LocalAlloc(LPTR, sizeof(PEAP_USER_PROP));
            if ( NULL == pUserProp )
            {
                EapTlsTrace("LocalAlloc in Command failed and returned %d",
                    GetLastError());
            }
            else
            {
                pUserProp->dwVersion = 1;

                pUserProp->dwSize = sizeof(PEAP_USER_PROP);

                CopyMemory( &pUserProp->CertHash, 
                            &(pPeapServerDialog->pSelCertList->Hash),
                            sizeof(pUserProp->CertHash) 
                          );
                //
                // If Fast Roaming is enabled, then set it in our user prop struct.
                //
                if (BST_CHECKED == IsDlgButtonChecked(hWndDlg, IDC_CHECK_ENABLE_FAST_RECONNECT))
                {
                    pUserProp->dwFlags |= PEAP_USER_FLAG_FAST_ROAMING;
                    
                }
                else
                {
                    pUserProp->dwFlags &= ~PEAP_USER_FLAG_FAST_ROAMING;                    
                }

                pUserProp->UserProperties.dwVersion = 1;
                pUserProp->UserProperties.dwSize = sizeof(PEAP_ENTRY_USER_PROPERTIES );
                pUserProp->UserProperties.dwEapTypeId = pPeapServerDialog->pSelEapInfo->dwTypeId;
                pPeapServerDialog->pNewUserProp = pUserProp;
            }
        }
        // Fall through

    case IDCANCEL:

        EndDialog(hWndDlg, wId);
        return(TRUE);

    default:

        return(FALSE);
    }
}



INT_PTR CALLBACK
PeapServerDialogProc(
    IN  HWND    hWnd,
    IN  UINT    unMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    PPEAP_SERVER_CONFIG_DIALOG  pPeapServerDialog;

    switch (unMsg)
    {
    case WM_INITDIALOG:
        
        return(PeapServerInitDialog(hWnd, lParam));

    case WM_HELP:
    case WM_CONTEXTMENU:
    {
        ContextHelp(g_adwHelp, hWnd, unMsg, wParam, lParam);
        break;
    }

    case WM_COMMAND:

        pPeapServerDialog = (PPEAP_SERVER_CONFIG_DIALOG)GetWindowLongPtr(hWnd, DWLP_USER);

        return(PeapServerCommand(pPeapServerDialog, HIWORD(wParam), LOWORD(wParam),
                       hWnd, (HWND)lParam));
    }

    return(FALSE);
}
#endif

/////
//// Default credentials UI
////

BOOL
DefaultCredInitDialog(
    IN  HWND    hWnd,
    IN  LPARAM  lParam
)
{
    PPEAP_DEFAULT_CRED_DIALOG           pDefaultCredDialog;

    SetWindowLongPtr( hWnd, DWLP_USER, lParam);

    pDefaultCredDialog = (PPEAP_DEFAULT_CRED_DIALOG)lParam;

    pDefaultCredDialog->hWndUserName=
        GetDlgItem(hWnd, IDC_EDIT_USERNAME);

    pDefaultCredDialog->hWndPassword=
        GetDlgItem(hWnd, IDC_EDIT_PASSWORD);

    pDefaultCredDialog->hWndDomain=
        GetDlgItem(hWnd, IDC_EDIT_DOMAIN);

    SendMessage(pDefaultCredDialog->hWndUserName,
                EM_LIMITTEXT,
                UNLEN,
                0L
               );

    SendMessage(pDefaultCredDialog->hWndPassword,
                EM_LIMITTEXT,
                PWLEN,
                0L
               );

    SendMessage(pDefaultCredDialog->hWndDomain,
                EM_LIMITTEXT,
                DNLEN,
                0L
               );
    
    if ( pDefaultCredDialog->PeapDefaultCredentials.wszUserName[0] )
    {
        SetWindowText(  pDefaultCredDialog->hWndUserName,
                        pDefaultCredDialog->PeapDefaultCredentials.wszUserName
                     );                      
    }

    if ( pDefaultCredDialog->PeapDefaultCredentials.wszPassword[0] )
    {
        SetWindowText(  pDefaultCredDialog->hWndPassword,
                        pDefaultCredDialog->PeapDefaultCredentials.wszPassword
                     );                      
    }

    if ( pDefaultCredDialog->PeapDefaultCredentials.wszDomain[0] )
    {
        SetWindowText(  pDefaultCredDialog->hWndDomain,
                        pDefaultCredDialog->PeapDefaultCredentials.wszDomain
                     );                      
    }

    return(FALSE);
}

/*

Returns:
    TRUE: We prrocessed this message.
    FALSE: We did not prrocess this message.

Notes:
    Response to the WM_COMMAND message (Config UI).

*/

BOOL
DefaultCredCommand(
    IN  PPEAP_DEFAULT_CRED_DIALOG       pDefaultCredDialog,
    IN  WORD                            wNotifyCode,
    IN  WORD                            wId,
    IN  HWND                            hWndDlg,
    IN  HWND                            hWndCtrl
)
{

    switch(wId)
    {

        case IDOK:
            //
            //grab info from the fields and set it in 
            //the logon dialog structure
            //
            GetWindowText( pDefaultCredDialog->hWndUserName,
                           pDefaultCredDialog->PeapDefaultCredentials.wszUserName,
                           UNLEN+1
                         );

            GetWindowText( pDefaultCredDialog->hWndPassword,
                           pDefaultCredDialog->PeapDefaultCredentials.wszPassword,
                           PWLEN+1
                         );

            GetWindowText ( pDefaultCredDialog->hWndDomain,
                            pDefaultCredDialog->PeapDefaultCredentials.wszDomain,
                            DNLEN+1
                          );                            
        // Fall through

        case IDCANCEL:

            EndDialog(hWndDlg, wId);
            return(TRUE);

        default:

            return(FALSE);
    }
}


INT_PTR CALLBACK
DefaultCredDialogProc(
    IN  HWND    hWnd,
    IN  UINT    unMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    PPEAP_DEFAULT_CRED_DIALOG       pDefaultCredDialog;

    switch (unMsg)
    {
    case WM_INITDIALOG:
        
        return(DefaultCredInitDialog(hWnd, lParam));

    case WM_HELP:
    case WM_CONTEXTMENU:
    {
        ContextHelp(g_adwHelp, hWnd, unMsg, wParam, lParam);
        break;
    }

    case WM_COMMAND:

        pDefaultCredDialog = (PPEAP_DEFAULT_CRED_DIALOG)GetWindowLongPtr(hWnd, DWLP_USER);

        return(DefaultCredCommand(pDefaultCredDialog, HIWORD(wParam), LOWORD(wParam),
                       hWnd, (HWND)lParam));
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\eaptls\eaptls.c ===
/*

Copyright (c) 1997, Microsoft Corporation, all rights reserved

Description:
    PPP EAP TLS Authentication Protocol. Based on RFC xxxx.

History:
    Oct 9, 1997: Vijay Baliga created original version.

Notes:

    Server                                      Client

    [Initial]                                   [Initial]

    TLS Start
    [SentStart]             ------------------>

                                                TLS client_hello
                            <------------------ [SentHello]

    TLS server_hello
    TLS certificate
    TLS server_key_exchange
    TLS server_hello_done
    [SentHello]             ------------------>

                                                TLS certificate
                                                TLS client_key_exchange
                                                TLS change_cipher_spec
                                                TLS finished
                            <------------------ [SentFinished]

    TLS change_cipher_spec
    TLS finished
    [SentFinished]          ------------------>

                                                NULL/TLS Alert
                            <------------------ [RecdFinished]

    Success/Failure
    [SentResult]            ------------------>

                                                [RecdResult]

*/

#include <nt.h>         // Required by windows.h
#include <ntrtl.h>      // Required by windows.h
#include <nturtl.h>     // Required by windows.h
#include <windows.h>    // Win32 base API's
#include <shlwapi.h>
#include <schannel.h>

#include <rtutils.h>    // For RTASSERT, TraceVprintfEx
#include <issperr.h>    // For SEC_E_OK
#include <wintrust.h>   // For WINTRUST_DATA
#include <lmcons.h>     // For UNLEN
#include <rasauth.h>    // Required by raseapif.h
#include <raseapif.h>   // For EAPCODE_Request
#include <raserror.h>   // For ERROR_PPP_INVALID_PACKET
#include <mprlog.h>     // For ROUTERLOG_CANT_GET_SERVER_CRED
#include <stdio.h>      // For sprintf
#include <resource.h>   // For IDS_CANT_VALIDATE_SERVER_TEXT
#include <eaptypeid.h>

#define SECURITY_WIN32
#include <security.h>   // For GetUserNameExA, CredHandle

#define INCL_HOSTWIRE
#define INCL_RASAUTHATTRIBUTES
#include <ppputil.h>    // For HostToWireFormat16, RasAuthAttributeInsert

#define ALLOC_EAPTLS_GLOBALS
#include <eaptls.h>

//
// Internal functions
//
void FreeCachedCredentials(EAPTLSCB * pEapTlsCb);

void SetCachedCredentials (EAPTLSCB * pEapTlsCb);

DWORD PeapCheckCookie ( PPEAPCB pPeapCb, 
                        PEAP_COOKIE *pCookie, 
                        DWORD cbCookie 
                      );

DWORD PeapCreateCookie ( PPEAPCB    pPeapCb,
                         PBYTE   *  ppbCookie,
                         DWORD   *  pcbCookie
                         );

DWORD   PeapGetCredentials(
            IN VOID   * pWorkBuf,
            OUT VOID ** ppCredentials);

DWORD
GetCredentialsFromUserProperties(
                EAPTLSCB *pUserProp,
                VOID **ppCredentials);


DWORD CreatePEAPTLVStatusMessage (  PPEAPCB            pPeapCb,
                                    PPP_EAP_PACKET *   pPacket, 
                                    DWORD              cbPacket,
                                    BOOL               fRequest,
                                    WORD               wValue  //Success or Failure
                                 );

DWORD GetPEAPTLVStatusMessageValue ( PPEAPCB  pPeapCb, 
                                     PPP_EAP_PACKET * pPacket, 
                                     WORD * pwValue 
                                   );


DWORD CreatePEAPTLVNAKMessage (  PPEAPCB            pPeapCb,
                                 PPP_EAP_PACKET *   pPacket, 
                                 DWORD              cbPacket
                                 );
DWORD 
CreateOIDAttributes ( 
	IN EAPTLSCB *		pEapTlsCb, 
	PCERT_ENHKEY_USAGE	pUsage,
    PCCERT_CHAIN_CONTEXT    pCCertChainContext);

BOOL fIsPEAPTLVMessage ( PPEAPCB pPeapCb,
                     PPP_EAP_PACKET * pPacket
                     );

extern const DWORD g_adwHelp[];
VOID
ContextHelp(
    IN  const   DWORD*  padwMap,
    IN          HWND    hWndDlg,
    IN          UINT    unMsg,
    IN          WPARAM  wParam,
    IN          LPARAM  lParam
);


/*

Notes:
    g_szEapTlsCodeName[0..MAXEAPCODE] contains the names of the various
    EAP codes.

*/

static  CHAR*   g_szEapTlsCodeName[]    =
{
    "Unknown",
    "Request",
    "Response",
    "Success",
    "Failure",
};



/*

Notes:
    To protect us from denial of service attacks.

*/

#define DEFAULT_MAX_BLOB_SIzE   0x4000
DWORD g_dwMaxBlobSize           = DEFAULT_MAX_BLOB_SIzE;


/*

Notes:
    Configurable via registry values.

*/


BOOL			g_fIgnoreNoRevocationCheck  = FALSE;
BOOL			g_fIgnoreRevocationOffline  = FALSE;
BOOL			g_fNoRootRevocationCheck    = TRUE;
BOOL			g_fNoRevocationCheck        = FALSE;

//
// Globals for cached credentials
//

#define         VPN_CACHED_CREDS_INDEX              0
#define         WIRELESS_CACHED_CREDS_INDEX         1
#define         VPN_PEAP_CACHED_CREDS_INDEX         2
#define         WIRELESS_PEAP_CACHED_CREDS_INDEX    3

BOOL                g_fCriticalSectionInitialized = FALSE;
CRITICAL_SECTION    g_csProtectCachedCredentials;

typedef struct _EAPTLS_CACHED_CREDS
{
    BOOL            fCachedCredentialInitialized;
    CredHandle      hCachedCredential;
    BYTE *          pbHash;
    DWORD           cbHash;
    PCCERT_CONTEXT  pcCachedCertContext;
	LUID			AuthenticatedSessionLUID;	//Session Id LUID

} EAPTLS_CACHED_CREDS;

EAPTLS_CACHED_CREDS     g_CachedCreds[4];

#if 0
/*
CredHandle		g_hCachedCredential;				//Cached Server and last client Credential 
BOOL			g_fCachedCredentialInitialized = FALSE;
BYTE	*		g_pbHash = NULL;								//cached hash and 
DWORD			g_cbHash = 0;									//size of the hash
PCCERT_CONTEXT	g_pcCachedCertContext = NULL;					//cached Certificate Context

//
// Cached credentials for PEAP
//
CredHandle		g_hPEAPCachedCredential;				//Cached Server and last client Credential 
BOOL			g_fPEAPCachedCredentialInitialized = FALSE;
BYTE	*		g_pbPEAPHash = NULL;								//cached hash and 
DWORD			g_cbPEAPHash = 0;									//size of the hash
PCCERT_CONTEXT	g_pcPEAPCachedCertContext = NULL;					//cached Certificate Context
*/
#endif

//Peap Globals
PPEAP_EAP_INFO  g_pEapInfo = NULL;

/*
* This function encrypts the PIN
* 
*/

DWORD EncryptData
( 
    IN PBYTE  pbPlainData, 
    IN DWORD  cbPlainData,
    OUT PBYTE * ppEncData,
    OUT DWORD * pcbEncData
)
{
    DWORD           dwRetCode = NO_ERROR;
    DATA_BLOB       DataIn;
    DATA_BLOB       DataOut;
    
    
    EapTlsTrace("EncryptData");

    if ( !pbPlainData || !cbPlainData )
    {
        dwRetCode = ERROR_INVALID_DATA;
        goto done;
    }

    ZeroMemory(&DataIn, sizeof(DataIn) );
    ZeroMemory(&DataOut, sizeof(DataOut) );

    *ppEncData = NULL;
    *pcbEncData = 0;

    DataIn.pbData = pbPlainData;
    DataIn.cbData = cbPlainData;

    if ( ! CryptProtectData ( &DataIn,
                            EAPTLS_8021x_PIN_DATA_DESCR,
                            NULL,
                            NULL,
                            NULL,
                            CRYPTPROTECT_UI_FORBIDDEN|CRYPTPROTECT_LOCAL_MACHINE,
                            &DataOut
                          )
       )
    {
        dwRetCode = GetLastError();
        EapTlsTrace("CryptProtectData failed.  Error: 0x%x", dwRetCode);
        goto done;
    }

    *ppEncData = DataOut.pbData;
    *pcbEncData = DataOut.cbData;
done:
    EapTlsTrace("EncryptData done.");
    return dwRetCode;
}

/*
* Decrypt the PIN here.
*/

DWORD DecryptData
( 
    IN PBYTE  pbEncData, 
    IN DWORD  cbEncData,
    OUT PBYTE * ppbPlainData,
    OUT DWORD * pcbPlainData
)
{
    DWORD           dwRetCode = NO_ERROR;
    DATA_BLOB       DataIn;
    DATA_BLOB       DataOut;
    LPWSTR          pDescrOut = NULL;

    EapTlsTrace("DecryptData");

    if ( !pbEncData || !cbEncData )
    {
        dwRetCode = ERROR_INVALID_DATA;
        goto done;
    }
    *ppbPlainData = 0;
    *pcbPlainData = 0;

    ZeroMemory(&DataIn, sizeof(DataIn));
    ZeroMemory(&DataOut, sizeof(DataOut));

    DataIn.pbData = pbEncData;
    DataIn.cbData = cbEncData;

    
    if ( !CryptUnprotectData( &DataIn,
                              &pDescrOut,
                              NULL,
                              NULL,
                              NULL,
                              CRYPTPROTECT_UI_FORBIDDEN,
                              &DataOut
                            )
       )
    {
        dwRetCode = GetLastError();
        EapTlsTrace("CryptUnprotectData failed. Error: 0x%x", dwRetCode );
        goto done;
    }

    if ( lstrcmp( pDescrOut, EAPTLS_8021x_PIN_DATA_DESCR ) )
    {
        EapTlsTrace("Description of this data does not match expected value. Discarding data");
        dwRetCode = ERROR_INVALID_DATA;
        goto done;    
    }
    
    *ppbPlainData = DataOut.pbData;
    *pcbPlainData = DataOut.cbData;

done:

    EapTlsTrace("DecryptData done.");
    return dwRetCode;
}




/*

Returns:
    TRUE: Packet is valid
    FALSE: Packet is badly formed

Notes:
    Returns TRUE iff the EapTls packet *pPacket is correctly formed or pPacket 
    is NULL.

*/

BOOL
FValidPacket(
    IN  EAPTLS_PACKET*  pPacket
)
{
    WORD    wLength;
    BYTE    bCode;

    if (NULL == pPacket)
    {
        return(TRUE);
    }

    wLength = WireToHostFormat16(pPacket->pbLength);
    bCode = pPacket->bCode;

    switch (bCode)
    {
    case EAPCODE_Request:
    case EAPCODE_Response:

        if (PPP_EAP_PACKET_HDR_LEN + 1 > wLength)
        {
            EapTlsTrace("EAP %s packet does not have Type octet",
                g_szEapTlsCodeName[bCode]);

            return(FALSE);
        }

        if (PPP_EAP_TLS != pPacket->bType)
        {
            // We are not concerned with this packet. It is not TLS.

            return(TRUE);
        }

        if (EAPTLS_PACKET_HDR_LEN > wLength)
        {
            EapTlsTrace("EAP TLS %s packet does not have Flags octet",
                g_szEapTlsCodeName[bCode]);

            return(FALSE);
        }

        if ((pPacket->bFlags & EAPTLS_PACKET_FLAG_LENGTH_INCL) &&
            EAPTLS_PACKET_HDR_LEN_MAX > wLength)
        {
            EapTlsTrace("EAP TLS %s packet with First fragment flag does "
                "not have TLS blob size octects",
                g_szEapTlsCodeName[bCode]);
        }

        break;

    case EAPCODE_Success:
    case EAPCODE_Failure:

        if (PPP_EAP_PACKET_HDR_LEN != wLength)
        {
            EapTlsTrace("EAP TLS %s packet has length %d",
                g_szEapTlsCodeName[bCode], wLength);

            return(FALSE);
        }

        break;

    default:

        EapTlsTrace("Invalid code in EAP packet: %d", bCode);
        return(FALSE);
        break;
    }

    return(TRUE);
}

/*

Returns:
    VOID

Notes:
    Print the contents of the EapTls packet *pPacket. pPacket can be NULL.
    fInput: TRUE iff we are receiving the packet
    
*/

VOID
PrintEapTlsPacket(
    IN  EAPTLS_PACKET*  pPacket,
    IN  BOOL            fInput
)
{
    BYTE    bCode;
    WORD    wLength;
    BOOL    fLengthIncluded = FALSE;
    BOOL    fMoreFragments  = FALSE;
    BOOL    fTlsStart       = FALSE;
    DWORD   dwType          = 0;
    DWORD   dwBlobLength    = 0;

    if (NULL == pPacket)
    {
        return;
    }

    bCode = pPacket->bCode;

    if (bCode > MAXEAPCODE)
    {
        bCode = 0;
    }

    wLength = WireToHostFormat16(pPacket->pbLength);

    if (   FValidPacket(pPacket)
        && PPP_EAP_TLS == pPacket->bType
        && (   EAPCODE_Request == pPacket->bCode
            || EAPCODE_Response == pPacket->bCode))
    {
        fLengthIncluded = pPacket->bFlags & EAPTLS_PACKET_FLAG_LENGTH_INCL;
        fMoreFragments = pPacket->bFlags & EAPTLS_PACKET_FLAG_MORE_FRAGMENTS;
        fTlsStart = pPacket->bFlags & EAPTLS_PACKET_FLAG_TLS_START;
        dwType = pPacket->bType;

        if (fLengthIncluded)
        {
            dwBlobLength = WireToHostFormat32(pPacket->pbData);
        }
    }

    EapTlsTrace("%s %s (Code: %d) packet: Id: %d, Length: %d, Type: %d, "
        "TLS blob length: %d. Flags: %s%s%s",
        fInput ? ">> Received" : "<< Sending",
        g_szEapTlsCodeName[bCode], pPacket->bCode, pPacket->bId, wLength,
        dwType, dwBlobLength,
        fLengthIncluded ? "L" : "",
        fMoreFragments ? "M" : "",
        fTlsStart ? "S" : "");
}

/*

Returns:
    Error codes only from winerror.h, raserror.h or mprerror.h

Notes:
    RasEapGetInfo entry point called by the EAP-PPP engine.
    
*/

DWORD
RasEapGetInfo(
    IN  DWORD           dwEapTypeId,
    OUT PPP_EAP_INFO*   pInfo
)
{
    DWORD   dwErr   = NO_ERROR;

    EapTlsTrace("RasEapGetInfo");
    
    //ZeroMemory ( g_CachedCreds, sizeof(EAPTLS_CACHED_CREDS) * 4 );
    RTASSERT(NULL != pInfo);

    if (PPP_EAP_TLS != dwEapTypeId 
#ifdef IMPL_PEAP
        && PPP_EAP_PEAP != dwEapTypeId         
#endif
       )
    {
        EapTlsTrace("EAP Type %d is not supported", dwEapTypeId);
        dwErr = ERROR_NOT_SUPPORTED;
        goto LDone;
    }

    ZeroMemory(pInfo, sizeof(PPP_EAP_INFO));
    if ( PPP_EAP_TLS == dwEapTypeId )
    {        
        pInfo->dwEapTypeId          = PPP_EAP_TLS;
        pInfo->RasEapInitialize     = EapTlsInitialize;
        pInfo->RasEapBegin          = EapTlsBegin;
        pInfo->RasEapEnd            = EapTlsEnd;
        pInfo->RasEapMakeMessage    = EapTlsMakeMessage;
    }
    else
    {
        pInfo->dwEapTypeId          = PPP_EAP_PEAP;
        pInfo->RasEapInitialize     = EapPeapInitialize;
        pInfo->RasEapBegin          = EapPeapBegin;
        pInfo->RasEapEnd            = EapPeapEnd;
        pInfo->RasEapMakeMessage    = EapPeapMakeMessage;
    }
    
LDone:

    return(dwErr);
}


//////////////////////////////////////////
////// Dialog procs for interactive UI
//////////////////////////////////////////
//// Server Configuration
//
BOOL
ValidateServerInitDialog(
    IN  HWND    hWnd,
    IN  LPARAM  lParam
)
{
    EAPTLS_VALIDATE_SERVER       *   pValidateServer;
    


    SetWindowLongPtr(hWnd, DWLP_USER, lParam);


    pValidateServer = (EAPTLS_VALIDATE_SERVER *)lParam;
    
    //Set the Dialog Title
    SetWindowText( hWnd, pValidateServer->awszTitle );

    SetWindowText ( GetDlgItem(hWnd, IDC_MESSAGE), 
                     pValidateServer->awszWarning
                );

    if ( !pValidateServer->fShowCertDetails )
    {
        EnableWindow ( GetDlgItem(hWnd, IDC_BTN_VIEW_CERTIFICATE),
                        FALSE
                        );
        ShowWindow( GetDlgItem(hWnd, IDC_BTN_VIEW_CERTIFICATE),
                    SW_HIDE
                  );
    }
    return FALSE;

}


BOOL
ValidateServerCommand(
    IN  EAPTLS_VALIDATE_SERVER *pValidateServer,
    IN  WORD                wNotifyCode,
    IN  WORD                wId,
    IN  HWND                hWndDlg,
    IN  HWND                hWndCtrl
)
{
    BOOL                            fRetVal = FALSE;
    
    
    switch(wId)
    {
        case IDC_BTN_VIEW_CERTIFICATE:
            {
                HCERTSTORE          hCertStore = NULL;
                PCCERT_CONTEXT      pCertContext = NULL;
                CRYPT_HASH_BLOB     chb;
                WCHAR               szError[256];

                LoadString( GetResouceDLLHInstance(), IDS_NO_CERT_DETAILS,
                                szError, 255);

                
                hCertStore = CertOpenStore( CERT_STORE_PROV_SYSTEM,
                                            0,
                                            0,
                                            CERT_STORE_READONLY_FLAG |CERT_SYSTEM_STORE_CURRENT_USER,
                                            L"CA"
                                          );
                if ( !hCertStore )
                {
                    MessageBox ( hWndDlg,
                                 szError,
                                 pValidateServer->awszTitle,
                                 MB_OK|MB_ICONSTOP
                               );
                    break;
                }
        
                chb.cbData = pValidateServer->Hash.cbHash;
                chb.pbData = pValidateServer->Hash.pbHash;

                pCertContext = CertFindCertificateInStore(
                          hCertStore,
                          0,
                          0,
                          CERT_FIND_HASH,
                          &chb,
                          0);
                if ( NULL == pCertContext )
                {
                    MessageBox ( hWndDlg,
                                 szError,
                                 pValidateServer->awszTitle,
                                 MB_OK|MB_ICONSTOP
                               );
                    if ( hCertStore )
                        CertCloseStore( hCertStore, CERT_CLOSE_STORE_FORCE_FLAG );

                    break;
                }

                //
                // Show Cert detail 
                //
                ShowCertDetails ( hWndDlg, hCertStore, pCertContext );

                if ( pCertContext )
                    CertFreeCertificateContext(pCertContext);

                if ( hCertStore )
                    CertCloseStore( hCertStore, CERT_CLOSE_STORE_FORCE_FLAG );

                fRetVal = TRUE;
            }
            break;
        case IDOK:
        case IDCANCEL:
            //
            // Delete context from store
            //
            {
                HCERTSTORE          hCertStore = NULL;
                PCCERT_CONTEXT      pCertContext = NULL;
                CRYPT_HASH_BLOB     chb;


                
                hCertStore = CertOpenStore( CERT_STORE_PROV_SYSTEM,
                                            0,
                                            0,
                                            CERT_SYSTEM_STORE_CURRENT_USER,
                                            L"CA"
                                          );
                if ( hCertStore )
                {
        
                    chb.cbData = pValidateServer->Hash.cbHash;
                    chb.pbData = pValidateServer->Hash.pbHash;
                    pCertContext = CertFindCertificateInStore(
                              hCertStore,
                              0,
                              0,
                              CERT_FIND_HASH,
                              &chb,
                              0);
                    if ( pCertContext )
                        CertDeleteCertificateFromStore(pCertContext);

                    CertCloseStore( hCertStore, CERT_CLOSE_STORE_FORCE_FLAG );
                }

            }
            EndDialog(hWndDlg, wId);
            fRetVal = TRUE;
            break;
        default:
            break;
    }

    return fRetVal;
}


INT_PTR CALLBACK
ValidateServerDialogProc(
    IN  HWND    hWnd,
    IN  UINT    unMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    EAPTLS_VALIDATE_SERVER * pValidateServer;

    switch (unMsg)
    {
    case WM_INITDIALOG:
        
        return(ValidateServerInitDialog(hWnd, lParam));

    case WM_HELP:
    case WM_CONTEXTMENU:
    {
        ContextHelp(g_adwHelp, hWnd, unMsg, wParam, lParam);
        break;
    }

    case WM_COMMAND:

        pValidateServer = (EAPTLS_VALIDATE_SERVER *)GetWindowLongPtr(hWnd, DWLP_USER);

        return(ValidateServerCommand(pValidateServer, 
                            HIWORD(wParam), 
                            LOWORD(wParam),
                            hWnd, 
                            (HWND)lParam)
                           );
    }

    return(FALSE);
}




/*

Returns:
    Error codes only from winerror.h, raserror.h or mprerror.h

Notes:

*/

DWORD
InvokeValidateServerDialog(
    IN  HWND            hWndParent,
    IN  BYTE*           pUIContextData,
    IN  DWORD           dwSizeofUIContextData,
    OUT BYTE**          ppDataFromInteractiveUI,
    OUT DWORD*          pdwSizeOfDataFromInteractiveUI
)
{
    INT_PTR                 nRet;
    EAPTLS_VALIDATE_SERVER* pEapTlsValidateServer;
    BYTE*                   pbResult                = NULL;
    DWORD                   dwSizeOfResult;
    DWORD                   dwErr                   = NO_ERROR;

    *ppDataFromInteractiveUI = NULL;
    *pdwSizeOfDataFromInteractiveUI = 0;

    pbResult = LocalAlloc(LPTR, sizeof(BYTE));

    if (NULL == pbResult)
    {
        dwErr = GetLastError();
        goto LDone;
    }
    dwSizeOfResult = sizeof(BYTE);

    pEapTlsValidateServer = (EAPTLS_VALIDATE_SERVER*) pUIContextData;

    nRet = DialogBoxParam(
                GetResouceDLLHInstance(),
                MAKEINTRESOURCE(IDD_VALIDATE_SERVER),
                hWndParent, 
                ValidateServerDialogProc,
                (LPARAM)pEapTlsValidateServer);

    if (-1 == nRet)
    {
        dwErr = GetLastError();
        goto LDone;
    }
    else if (IDOK == nRet)
    {
        *pbResult = IDYES;
    }
    else
    {
        *pbResult = IDNO;
    }


    *ppDataFromInteractiveUI = pbResult;
    *pdwSizeOfDataFromInteractiveUI = dwSizeOfResult;
    pbResult = NULL;

LDone:

    LocalFree(pbResult);
    return(dwErr);
}

/*

Returns:
    Error codes only from winerror.h, raserror.h or mprerror.h

Notes:
    RasEapInvokeInteractiveUI entry point called by the EAP-PPP engine by name.

*/

DWORD
RasEapInvokeInteractiveUI(
    IN  DWORD           dwEapTypeId,
    IN  HWND            hWndParent,
    IN  BYTE*           pUIContextData,
    IN  DWORD           dwSizeofUIContextData,
    OUT BYTE**          ppDataFromInteractiveUI,
    OUT DWORD*          pdwSizeOfDataFromInteractiveUI
)
{
    DWORD                       dwRetCode = NO_ERROR;
    PPEAP_EAP_INFO              pEapList = NULL;
    PPEAP_EAP_INFO              pEapInfo = NULL;
    PPEAP_INTERACTIVE_UI        pPeapInteractiveUI = NULL;
    RASEAPINVOKEINTERACTIVEUI   pfnInvoke = NULL;
    RASEAPFREE                  pfnFree = NULL;

    if ( PPP_EAP_TLS == dwEapTypeId )
    {
        dwRetCode = InvokeValidateServerDialog(
                        hWndParent,
                        pUIContextData,
                        dwSizeofUIContextData,
                        ppDataFromInteractiveUI,
                        pdwSizeOfDataFromInteractiveUI);
    }
    else if ( PPP_EAP_PEAP == dwEapTypeId )
    {

        dwRetCode = PeapEapInfoGetList ( NULL, &pEapList );
        if ( NO_ERROR != dwRetCode || NULL == pEapList )
        {
            EapTlsTrace("Unable to load list of EAP Types on this machine.");
            goto LDone;
        }
        pPeapInteractiveUI = (PPEAP_INTERACTIVE_UI)pUIContextData;
        //
        // Load relevant IdentityUI DLL and then invoke 
        // the 
        dwRetCode = PeapEapInfoFindListNode (   pPeapInteractiveUI->dwEapTypeId, 
                                                pEapList, 
                                                &pEapInfo
                                            );
        if ( NO_ERROR != dwRetCode || NULL == pEapInfo )
        {
            EapTlsTrace("Cannot find configured PEAP in the list of EAP Types on this machine.");
            goto LDone;
        }
        if (    !((pfnInvoke) = (RASEAPINVOKEINTERACTIVEUI)
                                  GetProcAddress(
                                    pEapInfo->hEAPModule,
                                    "RasEapInvokeInteractiveUI"))

            ||  !((pfnFree ) = (RASEAPFREE)
                                 GetProcAddress(
                                    pEapInfo->hEAPModule,
                                    "RasEapFreeMemory")))
        {
            dwRetCode = GetLastError();
            EapTlsTrace("failed to get entrypoint. rc=%d", dwRetCode);
            goto LDone;
        }
        
        //
        // Invoke the entry point here
        //
        dwRetCode = pfnInvoke ( pPeapInteractiveUI->dwEapTypeId,
                                hWndParent,
                                pPeapInteractiveUI->bUIContextData,
                                pPeapInteractiveUI->dwSizeofUIContextData,
                                ppDataFromInteractiveUI,
                                pdwSizeOfDataFromInteractiveUI
                              );        
    }
    else
    {
        dwRetCode = ERROR_INVALID_PARAMETER;
    }
LDone:
    PeapEapInfoFreeList( pEapList );

    return dwRetCode;
}

/*

Returns:
    Error codes only from winerror.h, raserror.h or mprerror.h

Notes:
    Called to get a context buffer for this EAP session and pass initialization 
    information. This will be called before any other call is made.
    
*/

DWORD
EapTlsBegin(
    OUT VOID**          ppWorkBuffer,
    IN  PPP_EAP_INPUT*  pPppEapInput
)
{
    DWORD       dwErr       = NO_ERROR;
    LONG        lRet;
    HKEY        hKey        = NULL;
    DWORD       dwType;
    DWORD       dwValue;
    DWORD       dwSize;
    BOOL        fServer     = FALSE;
    BOOL        fWinLogonData   = FALSE;
    EAPTLSCB*   pEapTlsCb   = NULL;
    EAPTLS_CONN_PROPERTIES * pConnProp = NULL;
    PBYTE       pbDecPIN = NULL;
    DWORD       cbDecPIN = 0;
    EAPTLS_USER_PROPERTIES   *   pUserProp = NULL;
    


    RTASSERT(NULL != ppWorkBuffer);
    RTASSERT(NULL != pPppEapInput);

    EapTlsTrace("");  // Blank line
    EapTlsTrace("EapTlsBegin(%ws)",
        pPppEapInput->pwszIdentity ? pPppEapInput->pwszIdentity : L"");
#if WINVER > 0x0500
    //This piece of code causes boot time perf hit
    //So it is removed until XPSP2
#if 0
    dwErr = VerifyCallerTrust(_ReturnAddress());
    if ( NO_ERROR != dwErr )
    {
        EapTlsTrace("Unauthorized use of TLS attempted");
        goto LDone;
    }
#endif
#endif
    // Allocate the context buffer

    pEapTlsCb = LocalAlloc(LPTR, sizeof(EAPTLSCB));

    if (NULL == pEapTlsCb)
    {
        dwErr = GetLastError();
        EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
        goto LDone;
    }

    pEapTlsCb->EapTlsState = EAPTLS_STATE_INITIAL;
    EapTlsTrace("State change to %s", g_szEapTlsState[pEapTlsCb->EapTlsState]);

    pEapTlsCb->fFlags = (pPppEapInput->fAuthenticator) ?
                            EAPTLSCB_FLAG_SERVER : 0;
    pEapTlsCb->fFlags |= (pPppEapInput->fFlags & RAS_EAP_FLAG_ROUTER) ?
                           EAPTLSCB_FLAG_ROUTER : 0;
    pEapTlsCb->fFlags |= (pPppEapInput->fFlags & RAS_EAP_FLAG_LOGON) ?
                            EAPTLSCB_FLAG_LOGON : 0;
    pEapTlsCb->fFlags |= (pPppEapInput->fFlags & RAS_EAP_FLAG_NON_INTERACTIVE) ?
                            EAPTLSCB_FLAG_NON_INTERACTIVE : 0;
    pEapTlsCb->fFlags |= (pPppEapInput->fFlags & RAS_EAP_FLAG_FIRST_LINK) ?
                            EAPTLSCB_FLAG_FIRST_LINK : 0;
    pEapTlsCb->fFlags |= (pPppEapInput->fFlags & RAS_EAP_FLAG_MACHINE_AUTH) ?
                            EAPTLSCB_FLAG_MACHINE_AUTH : 0;
	pEapTlsCb->fFlags |= (pPppEapInput->fFlags & RAS_EAP_FLAG_GUEST_ACCESS) ?
							EAPTLSCB_FLAG_GUEST_ACCESS : 0;

    pEapTlsCb->fFlags |= (pPppEapInput->fFlags & RAS_EAP_FLAG_8021X_AUTH) ?
                            EAPTLSCB_FLAG_8021X_AUTH : 0;

    pEapTlsCb->fFlags |= (pPppEapInput->fFlags & EAPTLSCB_FLAG_EXECUTING_PEAP )?
                            EAPTLSCB_FLAG_EXECUTING_PEAP : 0;


    if (pPppEapInput->fFlags & RAS_EAP_FLAG_8021X_AUTH)
    {
        EapTlsTrace("EapTlsBegin: Detected 8021X authentication");
    }


    if ( pEapTlsCb->fFlags & EAPTLSCB_FLAG_EXECUTING_PEAP )
    {
        EapTlsTrace("EapTlsBegin: Detected PEAP authentication");
    }


    pEapTlsCb->fFlags |= EAPTLSCB_FLAG_HCRED_INVALID;
    pEapTlsCb->fFlags |= EAPTLSCB_FLAG_HCTXT_INVALID;

    if ( pEapTlsCb->fFlags & EAPTLSCB_FLAG_SERVER )
    {
        fServer = TRUE;

        pEapTlsCb->hEventLog = pPppEapInput->hReserved;

        pEapTlsCb->fContextReq = ASC_REQ_SEQUENCE_DETECT    |
                                 ASC_REQ_REPLAY_DETECT      |
                                 ASC_REQ_CONFIDENTIALITY    |
                                 ASC_REQ_MUTUAL_AUTH        |
                                 ASC_RET_EXTENDED_ERROR     |
                                 ASC_REQ_ALLOCATE_MEMORY    |
                                 ASC_REQ_STREAM;

        //
        //Server will always allow guest access. 
        //
        if ( pEapTlsCb->fFlags & EAPTLSCB_FLAG_GUEST_ACCESS  || 
             pEapTlsCb->fFlags & EAPTLSCB_FLAG_EXECUTING_PEAP
           )
                pEapTlsCb->fContextReq |= ASC_REQ_MUTUAL_AUTH;

        if ( pEapTlsCb->fFlags & EAPTLSCB_FLAG_EXECUTING_PEAP )
        {
            //
            // We are executing PEap.  So take the user props from
            // PppEapInput rather than serverconfigdataio.
            //
            dwErr = ReadUserData(pPppEapInput->pUserData, 
                        pPppEapInput->dwSizeOfUserData, &(pEapTlsCb->pUserProp));

            if (NO_ERROR != dwErr)
            {
                goto LDone;
            }            
        }
        else
        {
            dwErr = ServerConfigDataIO(TRUE /* fRead */, NULL /* pwszMachineName */,
                        (BYTE**)&(pEapTlsCb->pUserProp), 0);

            if (NO_ERROR != dwErr)
            {
                goto LDone;
            }
        }

        pEapTlsCb->bId = pPppEapInput->bInitialId;
    }
    else
    {
        //
        // Client side config for TLS
        //

        pEapTlsCb->fContextReq = ISC_REQ_SEQUENCE_DETECT    |
                                 ISC_REQ_REPLAY_DETECT      |
                                 ISC_REQ_CONFIDENTIALITY    |
                                 ISC_RET_EXTENDED_ERROR     |
                                 ISC_REQ_ALLOCATE_MEMORY    |
                                 ISC_REQ_USE_SUPPLIED_CREDS |
                                 ISC_REQ_STREAM;

        pEapTlsCb->hTokenImpersonateUser = pPppEapInput->hTokenImpersonateUser;


#if 0
        if (NULL == pPppEapInput->pUserData)
        {
            dwErr = ERROR_INVALID_DATA;
            EapTlsTrace("No user data!");
            goto LDone;
        }
#endif

        if (pPppEapInput->pUserData != NULL)
        {
            if (0 != *(DWORD*)(pPppEapInput->pUserData))
            {
                fWinLogonData = TRUE;
            }
        }
        if (fWinLogonData)
        {
            // Data from Winlogon

            pEapTlsCb->fFlags |= EAPTLSCB_FLAG_WINLOGON_DATA;

            pEapTlsCb->pUserData = LocalAlloc(LPTR, 
                pPppEapInput->dwSizeOfUserData);

            if (NULL == pEapTlsCb->pUserData)
            {
                dwErr = GetLastError();
                EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
                goto LDone;
            }

            CopyMemory(pEapTlsCb->pUserData, pPppEapInput->pUserData,
                pPppEapInput->dwSizeOfUserData);
            pEapTlsCb->dwSizeOfUserData = pPppEapInput->dwSizeOfUserData;
        }
        else
        {

            dwErr = ReadUserData(pPppEapInput->pUserData, 
                        pPppEapInput->dwSizeOfUserData, &(pEapTlsCb->pUserProp));

            if (NO_ERROR != dwErr)
            {
                goto LDone;
            }
        }
    }

    dwErr = ReadConnectionData( ( pPppEapInput->fFlags & RAS_EAP_FLAG_8021X_AUTH ),
                                pPppEapInput->pConnectionData, 
                                pPppEapInput->dwSizeOfConnectionData, 
                                &pConnProp);

    if (NO_ERROR != dwErr)
    {
        goto LDone;
    }
    
    dwErr = ConnPropGetV1Struct ( pConnProp, &(pEapTlsCb->pConnProp) );
    if ( NO_ERROR != dwErr )
    {
        goto LDone;
    }

    //
    // Check to see if it is a 8021x and smart card user.
    // If so, decrypt the pin if one is present
    //

    
    if ( !(pEapTlsCb->fFlags & EAPTLSCB_FLAG_SERVER)  &&
         pEapTlsCb->fFlags & EAPTLSCB_FLAG_8021X_AUTH &&  
         pEapTlsCb->pConnProp &&
         !(pEapTlsCb->pConnProp->fFlags & EAPTLS_CONN_FLAG_REGISTRY) 
         
       )
    {
        if ( NO_ERROR != DecryptData ( 
                            (PBYTE)pEapTlsCb->pUserProp->pwszPin, 
                            pEapTlsCb->pUserProp->dwSize - sizeof(EAPTLS_USER_PROPERTIES)
                            - ( ( wcslen(pEapTlsCb->pUserProp->pwszDiffUser) + 1 ) * sizeof (WCHAR) ),
                            &pbDecPIN,
                            &cbDecPIN
                          )
           )
        {
            //
            //Dummy pin allocation
            //
            pbDecPIN = LocalAlloc(LPTR, 5);
            cbDecPIN = lstrlen((LPWSTR)pbDecPIN);
        }

        AllocUserDataWithNewPin(pEapTlsCb->pUserProp, pbDecPIN, cbDecPIN, &pUserProp);

        LocalFree(pEapTlsCb->pUserProp);
        pEapTlsCb->pUserProp = pUserProp;

    }


    // Save the identity. On the authenticatee side, this was obtained by
    // calling RasEapGetIdentity; on the authenticator side this was
    // obtained by the Identity request message.

    wcsncpy(pEapTlsCb->awszIdentity,
        pPppEapInput->pwszIdentity ? pPppEapInput->pwszIdentity : L"", UNLEN);

    _wcslwr(pEapTlsCb->awszIdentity);

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, EAPTLS_KEY_13, 0, KEY_READ, 
                &hKey);

    if (ERROR_SUCCESS == lRet)
    {
        dwSize = sizeof(dwValue);

        lRet = RegQueryValueEx(hKey, EAPTLS_VAL_MAX_TLS_MESSAGE_LENGTH, 
                    NULL, &dwType, (BYTE*)&dwValue, &dwSize);

        if (   (ERROR_SUCCESS == lRet)
            && (REG_DWORD == dwType))
        {
            g_dwMaxBlobSize = dwValue;
        }
        else
        {
            g_dwMaxBlobSize = DEFAULT_MAX_BLOB_SIzE;
        }

        EapTlsTrace("MaxTLSMessageLength is now %d", g_dwMaxBlobSize);

        if (fServer)
        {
            dwSize = sizeof(dwValue);

            lRet = RegQueryValueEx(hKey, EAPTLS_VAL_IGNORE_NO_REVOCATION_CHECK, 
                        NULL, &dwType, (BYTE*)&dwValue, &dwSize);

            if (   (ERROR_SUCCESS == lRet)
                && (REG_DWORD == dwType))
            {
                g_fIgnoreNoRevocationCheck = dwValue;
            }
            else
            {
                g_fIgnoreNoRevocationCheck = FALSE;
            }

            EapTlsTrace("CRYPT_E_NO_REVOCATION_CHECK will %sbe ignored",
                g_fIgnoreNoRevocationCheck ? "" : "not ");

            dwSize = sizeof(dwValue);

            lRet = RegQueryValueEx(hKey, EAPTLS_VAL_IGNORE_REVOCATION_OFFLINE, 
                        NULL, &dwType, (BYTE*)&dwValue, &dwSize);

            if (   (ERROR_SUCCESS == lRet)
                && (REG_DWORD == dwType))
            {
                g_fIgnoreRevocationOffline = dwValue;
            }
            else
            {
                g_fIgnoreRevocationOffline = FALSE;
            }

            EapTlsTrace("CRYPT_E_REVOCATION_OFFLINE will %sbe ignored",
                g_fIgnoreRevocationOffline ? "" : "not ");

            dwSize = sizeof(dwValue);

            lRet = RegQueryValueEx(hKey, EAPTLS_VAL_NO_ROOT_REVOCATION_CHECK, 
                        NULL, &dwType, (BYTE*)&dwValue, &dwSize);

            if (   (ERROR_SUCCESS == lRet)
                && (REG_DWORD == dwType))
            {
                g_fNoRootRevocationCheck = dwValue;
            }
            else
            {
                g_fNoRootRevocationCheck = TRUE;
            }

            EapTlsTrace("The root cert will %sbe checked for revocation",
                g_fNoRootRevocationCheck ? "not " : "");

            dwSize = sizeof(dwValue);

            lRet = RegQueryValueEx(hKey, EAPTLS_VAL_NO_REVOCATION_CHECK, 
                        NULL, &dwType, (BYTE*)&dwValue, &dwSize);

            if (   (ERROR_SUCCESS == lRet)
                && (REG_DWORD == dwType))
            {
                g_fNoRevocationCheck = dwValue;
            }
            else
            {
                g_fNoRevocationCheck = FALSE;
            }

            EapTlsTrace("The cert will %sbe checked for revocation",
                g_fNoRevocationCheck ? "not " : "");
        }

        RegCloseKey(hKey);
    }

    // pbBlobIn, pbBlobOut, and pAttribues are initially NULL and cbBlobIn,
    // cbBlobInBuffer, cbBlobOut, cbBlobOutBuffer, dwBlobOutOffset,
    // dwBlobOutOffsetNew, and dwBlobInRemining are all 0.

    // bCode, dwErr are also 0.

LDone:

    LocalFree(pConnProp);
    LocalFree(pbDecPIN);

    if (   (NO_ERROR != dwErr)
        && (NULL != pEapTlsCb))
    {        
        LocalFree(pEapTlsCb->pUserProp);
        LocalFree(pEapTlsCb->pConnProp);
        LocalFree(pEapTlsCb->pUserData);
        LocalFree(pEapTlsCb);
        pEapTlsCb = NULL;
    }

    *ppWorkBuffer = pEapTlsCb;

    return(dwErr);
}

/*

Returns:
    Error codes only from winerror.h, raserror.h or mprerror.h

Notes:
    Called to free the context buffer for this EAP session. Called after this 
    session is completed successfully or not.

*/

DWORD
EapTlsEnd(
    IN  EAPTLSCB*   pEapTlsCb
)
{
    SECURITY_STATUS Status;

    EapTlsTrace("EapTlsEnd");  // Blank line

    if (NULL != pEapTlsCb)
    {
        EapTlsTrace("EapTlsEnd(%ws)",
            pEapTlsCb->awszIdentity ? pEapTlsCb->awszIdentity : L"");

        if (NULL != pEapTlsCb->pCertContext)
        {
            //
            // Since we are using cached creds dont free the 
            // cert context.
            //
#if 0
			if ( !(EAPTLSCB_FLAG_SERVER & pEapTlsCb->fFlags ) )
				CertFreeCertificateContext(pEapTlsCb->pCertContext);
#endif
            // Always returns TRUE;
            pEapTlsCb->pCertContext = NULL;
        }

        if (!(EAPTLSCB_FLAG_HCTXT_INVALID & pEapTlsCb->fFlags))
        {
            Status = DeleteSecurityContext(&pEapTlsCb->hContext);

            if (SEC_E_OK != Status)
            {
                EapTlsTrace("DeleteSecurityContext failed and returned 0x%x", 
                    Status);
            }
        }

        if (!(EAPTLSCB_FLAG_HCRED_INVALID & pEapTlsCb->fFlags))
        {
            //
			// Dont free the credentials handle.  We are using 
            // cached credentials.
            //
#if 0
			if ( !(EAPTLSCB_FLAG_SERVER & pEapTlsCb->fFlags ) )
			{
				EapTlsTrace("Freeing Credentials handle: flags are 0x%x", 
						pEapTlsCb->fFlags);

				Status = FreeCredentialsHandle(&pEapTlsCb->hCredential);
				if (SEC_E_OK != Status)
				{
					EapTlsTrace("FreeCredentialsHandle failed and returned 0x%x", 
						Status);
				}
			}
#endif
			ZeroMemory( &pEapTlsCb->hCredential, sizeof(CredHandle));

        }

        pEapTlsCb->fFlags |= EAPTLSCB_FLAG_HCRED_INVALID;
        pEapTlsCb->fFlags |= EAPTLSCB_FLAG_HCTXT_INVALID;

        if (NULL != pEapTlsCb->pAttributes)
        {
            RasAuthAttributeDestroy(pEapTlsCb->pAttributes);
        }
        LocalFree(pEapTlsCb->pUserProp);
        LocalFree(pEapTlsCb->pConnProp);
        LocalFree(pEapTlsCb->pNewConnProp);
        LocalFree(pEapTlsCb->pUserData);
        LocalFree(pEapTlsCb->pbBlobIn);
        LocalFree(pEapTlsCb->pbBlobOut);        
        LocalFree(pEapTlsCb->pUIContextData);

        if(NULL != pEapTlsCb->pSavedPin)
        {
            if(NULL != pEapTlsCb->pSavedPin->pwszPin)
            {
                ZeroMemory(pEapTlsCb->pSavedPin->pwszPin,
                           wcslen(pEapTlsCb->pSavedPin->pwszPin)
                           * sizeof(WCHAR));

                LocalFree(pEapTlsCb->pSavedPin->pwszPin);
            }

            LocalFree(pEapTlsCb->pSavedPin);
        }


        //
        // auth result is not good or we are waiting for user ok 
        //and we are a client.
        //
        if ( ( NO_ERROR != pEapTlsCb->dwAuthResultCode ||
             EAPTLS_STATE_WAIT_FOR_USER_OK == pEapTlsCb->EapTlsState )&&
             !( pEapTlsCb->fFlags & EAPTLSCB_FLAG_SERVER )
           )           
        {
			EapTlsTrace("Auth failed so freeing cached creds.");				
            EnterCriticalSection ( &g_csProtectCachedCredentials );
            FreeCachedCredentials(pEapTlsCb);
            LeaveCriticalSection ( &g_csProtectCachedCredentials );
        }

        ZeroMemory(pEapTlsCb, sizeof(EAPTLSCB));
        LocalFree(pEapTlsCb);

    }

    return(NO_ERROR);
}

/*

Returns:
    Error codes only from winerror.h, raserror.h or mprerror.h

Notes:
    Called to reset everything in pEapTlsCb (except awszIdentity, the flag 
    indicating whether we are the server/router, fContextReq, pConnProp, 
    UserProp and hTokenImpersonateUser) to the initial state, for example, when 
    a client gets a TLS Start packet.

*/

DWORD
EapTlsReset(
    IN  EAPTLSCB*   pEapTlsCb
)
{
    SECURITY_STATUS Status;
    DWORD           dwErr   = NO_ERROR;
    DWORD           fFlags;

    EapTlsTrace("EapTlsReset");

    RTASSERT(NULL != pEapTlsCb);

    pEapTlsCb->EapTlsState = EAPTLS_STATE_INITIAL;
    EapTlsTrace("State change to %s", g_szEapTlsState[pEapTlsCb->EapTlsState]);

    // Forget all the flags, except whether we are a server/client, router

    fFlags = pEapTlsCb->fFlags;
    pEapTlsCb->fFlags = fFlags & EAPTLSCB_FLAG_SERVER;
    pEapTlsCb->fFlags |= fFlags & EAPTLSCB_FLAG_ROUTER;
    pEapTlsCb->fFlags |= fFlags & EAPTLSCB_FLAG_LOGON;
    pEapTlsCb->fFlags |= fFlags & EAPTLSCB_FLAG_WINLOGON_DATA;
    pEapTlsCb->fFlags |= fFlags & EAPTLSCB_FLAG_NON_INTERACTIVE;
    pEapTlsCb->fFlags |= fFlags & EAPTLSCB_FLAG_FIRST_LINK;
    pEapTlsCb->fFlags |= fFlags & EAPTLSCB_FLAG_MACHINE_AUTH;
    pEapTlsCb->fFlags |= fFlags & EAPTLSCB_FLAG_GUEST_ACCESS;
    pEapTlsCb->fFlags |= fFlags & EAPTLSCB_FLAG_8021X_AUTH;
    pEapTlsCb->fFlags |= fFlags & EAPTLSCB_FLAG_EXECUTING_PEAP;

    // awszIdentity, hTokenImpersonateUser, pConnProp, UserProp remain the same

    if (NULL != pEapTlsCb->pCertContext)
    {
        //
        // We are using cached creds now.  So no need to 
        // release the context
        //
#if 0
		if ( !(EAPTLSCB_FLAG_SERVER & pEapTlsCb->fFlags ) )
			CertFreeCertificateContext(pEapTlsCb->pCertContext);
#endif
        // Always returns TRUE;
        pEapTlsCb->pCertContext = NULL;
    }

    if (!(EAPTLSCB_FLAG_HCTXT_INVALID & fFlags))
    {
        Status = DeleteSecurityContext(&pEapTlsCb->hContext);

        if (SEC_E_OK != Status)
        {
            EapTlsTrace("DeleteSecurityContext failed and returned 0x%x", 
                Status);
        }

        ZeroMemory(&pEapTlsCb->hContext, sizeof(CtxtHandle));
    }

    if (!(EAPTLSCB_FLAG_HCRED_INVALID & fFlags))
    {
        //
        // Since we cache client ans server creds, we dont 
        // free the credentials handle anymore.
        //
#if 0
		if ( !(EAPTLSCB_FLAG_SERVER & pEapTlsCb->fFlags ) )
		{

			EapTlsTrace("Freeing Credentials handle: flags are 0x%x", 
					pEapTlsCb->fFlags);

			//if this is a server we are using cached creds
			Status = FreeCredentialsHandle(&pEapTlsCb->hCredential);

			if (SEC_E_OK != Status)
			{
				EapTlsTrace("FreeCredentialsHandle failed and returned 0x%x", 
					Status);
			}
		}
#endif 
			ZeroMemory(&pEapTlsCb->hCredential, sizeof(CredHandle));
		
    }

    pEapTlsCb->fFlags |= EAPTLSCB_FLAG_HCRED_INVALID;
    pEapTlsCb->fFlags |= EAPTLSCB_FLAG_HCTXT_INVALID;

    if (NULL != pEapTlsCb->pAttributes)
    {
        RasAuthAttributeDestroy(pEapTlsCb->pAttributes);
        pEapTlsCb->pAttributes = NULL;
    }

    // fContextReq remains the same

    LocalFree(pEapTlsCb->pbBlobIn);
    pEapTlsCb->pbBlobIn = NULL;
    pEapTlsCb->cbBlobIn = pEapTlsCb->cbBlobInBuffer = 0;
    pEapTlsCb->dwBlobInRemining = 0;

    LocalFree(pEapTlsCb->pbBlobOut);
    pEapTlsCb->pbBlobOut = NULL;
    pEapTlsCb->cbBlobOut = pEapTlsCb->cbBlobOutBuffer = 0;
    pEapTlsCb->dwBlobOutOffset = pEapTlsCb->dwBlobOutOffsetNew = 0;

    LocalFree(pEapTlsCb->pUIContextData);
    pEapTlsCb->pUIContextData = NULL;

    pEapTlsCb->dwAuthResultCode = NO_ERROR;

	dwErr = GetCredentials(pEapTlsCb);

    if (NO_ERROR == dwErr)
    {
        pEapTlsCb->fFlags &= ~EAPTLSCB_FLAG_HCRED_INVALID;
    }

    return(dwErr);
}

/*

Returns:
    Error codes only from winerror.h, raserror.h or mprerror.h.

Notes:
    Called to process an incoming packet and/or send a packet. cbSendPacket is 
    the size in bytes of the buffer pointed to by pSendPacket.

*/

DWORD
EapTlsMakeMessage(
    IN  EAPTLSCB*       pEapTlsCb,
    IN  PPP_EAP_PACKET* pInput,
    OUT PPP_EAP_PACKET* pOutput,
    IN  DWORD           cbSendPacket,
    OUT PPP_EAP_OUTPUT* pEapOutput,
    IN  PPP_EAP_INPUT*  pEapInput
)
{
    EAPTLS_PACKET*  pReceivePacket  = (EAPTLS_PACKET*) pInput;
    EAPTLS_PACKET*  pSendPacket     = (EAPTLS_PACKET*) pOutput;
    DWORD           dwErr           = NO_ERROR;
    BOOL            fServer         = FALSE;
    BOOL            fRouter         = FALSE;

    RTASSERT(NULL != pEapTlsCb);
    RTASSERT(NULL != pEapOutput);

    EapTlsTrace("");  // Blank line
    EapTlsTrace("EapTlsMakeMessage(%ws)",
        pEapTlsCb->awszIdentity ? pEapTlsCb->awszIdentity : L"");

    PrintEapTlsPacket(pReceivePacket, TRUE /* fInput */);

    if (!FValidPacket(pReceivePacket))
    {
        pEapOutput->Action = EAPACTION_NoAction;
        return(ERROR_PPP_INVALID_PACKET);
    }

    fServer = pEapTlsCb->fFlags & EAPTLSCB_FLAG_SERVER;
    fRouter = pEapTlsCb->fFlags & EAPTLSCB_FLAG_ROUTER;

    if (   !fServer
        && !fRouter
        && !(EAPTLSCB_FLAG_LOGON & pEapTlsCb->fFlags)
        && !(EAPTLSCB_FLAG_MACHINE_AUTH & pEapTlsCb->fFlags)
        && !(EAPTLSCB_FLAG_GUEST_ACCESS & pEapTlsCb->fFlags)
        && !(EAPTLSCB_FLAG_EXECUTING_PEAP & pEapTlsCb->fFlags)
        && !ImpersonateLoggedOnUser(pEapTlsCb->hTokenImpersonateUser))
    {
        dwErr = GetLastError();
        EapTlsTrace("ImpersonateLoggedOnUser(%d) failed and returned 0x%x",
            pEapTlsCb->hTokenImpersonateUser, dwErr);
        pEapOutput->Action = EAPACTION_NoAction;
        return(dwErr);
    }

    if (fServer)
    {
        dwErr = EapTlsSMakeMessage(pEapTlsCb, pReceivePacket, pSendPacket, 
                cbSendPacket, pEapOutput, pEapInput);
    }
    else
    {
        dwErr = EapTlsCMakeMessage(pEapTlsCb, pReceivePacket, pSendPacket, 
                cbSendPacket, pEapOutput, pEapInput);

        if ( pEapOutput->Action == EAPACTION_Done &&
             pEapOutput->dwAuthResultCode == NO_ERROR
           )
        {
            //
            // Auth is done and result is good Cache Credentials here
            // and we are a client
            if ( !( pEapTlsCb->fFlags & EAPTLSCB_FLAG_USING_CACHED_CREDS ) )
            {
                //
                // If we are not using cached credentials
                //
	            SetCachedCredentials (pEapTlsCb);
            }

        }
             
    }

    if (   !fServer
        && !fRouter
        && !(EAPTLSCB_FLAG_LOGON & pEapTlsCb->fFlags)
        && !RevertToSelf())
    {
        EapTlsTrace("RevertToSelf failed and returned 0x%x", GetLastError());
    }

    return(dwErr);
}

/*

Returns:

Notes:

*/

DWORD
AssociatePinWithCertificate(
    IN  PCCERT_CONTEXT          pCertContext,
    IN  EAPTLS_USER_PROPERTIES* pUserProp,
	IN  BOOL					fErasePIN,
	IN  BOOL					fCheckNullPin
)
{
    DWORD                   cbData;
    CRYPT_KEY_PROV_INFO*    pCryptKeyProvInfo   = NULL;
    HCRYPTPROV              hProv               = 0;
    DWORD                   count;
    CHAR*                   pszPin              = NULL;
    UNICODE_STRING          UnicodeString;
    DWORD                   dwErr               = NO_ERROR;

    EapTlsTrace("AssociatePinWithCertificate");

    cbData = 0;

    if (!CertGetCertificateContextProperty(
                pCertContext,
                CERT_KEY_PROV_INFO_PROP_ID,
                NULL,
                &cbData))
    {
        dwErr = GetLastError();
        EapTlsTrace("CertGetCertificateContextProperty failed: 0x%x", dwErr);
        goto LDone;
    }

    pCryptKeyProvInfo = LocalAlloc(LPTR, cbData);

    if (NULL == pCryptKeyProvInfo)
    {
        dwErr = GetLastError();
        EapTlsTrace("Out of memory");
        goto LDone;
    }

    if (!CertGetCertificateContextProperty(
                pCertContext,
                CERT_KEY_PROV_INFO_PROP_ID,
                pCryptKeyProvInfo,
                &cbData))
    {
        dwErr = GetLastError();
        EapTlsTrace("CertGetCertificateContextProperty failed: 0x%x", dwErr);
        goto LDone;
    }

    if (!CryptAcquireContext(
                &hProv,
                pCryptKeyProvInfo->pwszContainerName,
                pCryptKeyProvInfo->pwszProvName,
                pCryptKeyProvInfo->dwProvType,
                (pCryptKeyProvInfo->dwFlags &
                 ~CERT_SET_KEY_PROV_HANDLE_PROP_ID) |
                 CRYPT_SILENT))
    {
        dwErr = GetLastError();
        EapTlsTrace("CryptAcquireContext failed: 0x%x", dwErr);
        goto LDone;
    }

    if (pUserProp->pwszPin[0] != 0)
    {
		if ( fErasePIN )
			DecodePin(pUserProp);

        count = WideCharToMultiByte(
                    CP_UTF8,
                    0,
                    pUserProp->pwszPin,
                    -1,
                    NULL,
                    0,
                    NULL,
                    NULL);

        if (0 == count)
        {
            dwErr = GetLastError();
            EapTlsTrace("WideCharToMultiByte failed: %d", dwErr);
            goto LDone;
        }

        pszPin = LocalAlloc(LPTR, count);

        if (NULL == pszPin)
        {
            dwErr = GetLastError();
            EapTlsTrace("LocalAlloc failed: 0x%x", dwErr);
            goto LDone;
        }

        count = WideCharToMultiByte(
                    CP_UTF8,
                    0,
                    pUserProp->pwszPin,
                    -1,
                    pszPin,
                    count,
                    NULL,
                    NULL);

        if (0 == count)
        {
            dwErr = GetLastError();
            EapTlsTrace("WideCharToMultiByte failed: %d", dwErr);
            goto LDone;
        }
	}
	else
	{

		if ( fCheckNullPin )
		{
		   //
		   //we got an empty pin.  So all we do is an alloc
		   //and nothing else.
		   //
		   pszPin = LocalAlloc(LPTR, 5 );
		   if (NULL == pszPin)
		   {
			   dwErr = GetLastError();
			   EapTlsTrace("LocalAlloc failed: 0x%x", dwErr);
			   goto LDone;
		   }
		   count = 2;
		}
	}

	
	if ( pszPin )
	{
		if (!CryptSetProvParam(
					hProv,
					PP_KEYEXCHANGE_PIN,
					pszPin,
					0))
		{
			dwErr = GetLastError();
			EapTlsTrace("CryptSetProvParam failed: 0x%x", dwErr);
			ZeroMemory(pszPin, count);
			goto LDone;
		}
        ZeroMemory(pszPin, count);

	}


    if (!CertSetCertificateContextProperty(
                pCertContext,
                CERT_KEY_PROV_HANDLE_PROP_ID,
                0,
                (VOID*)hProv))
    {
        dwErr = GetLastError();
        EapTlsTrace("CertSetCertificateContextProperty failed: 0x%x", dwErr);
        goto LDone;
    }

    // Since I didn't set CERT_STORE_NO_CRYPT_RELEASE_FLAG in the above call,
    // the hProv is implicitly released when either the property is set to NULL
    // or on the final free of the CertContext.

    hProv = 0;

LDone:

    if (0 != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }

    LocalFree(pCryptKeyProvInfo);
    LocalFree(pszPin);

	// Nuke the PIN.
	if ( fErasePIN )
    {
        pUserProp->usLength = 0;
        pUserProp->usMaximumLength = 0;
        ZeroMemory(pUserProp->pwszPin, wcslen(pUserProp->pwszPin) * sizeof(WCHAR));
    }

    return(dwErr);
}

void FreeCachedCredentials ( EAPTLSCB * pEapTlsCb )
{
	SECURITY_STATUS     Status;
    DWORD               dwIndex = 0;
    EapTlsTrace ("FreeCachedCredentials");

    if ( pEapTlsCb->fFlags & EAPTLSCB_FLAG_EXECUTING_PEAP )
    {
        if ( pEapTlsCb->fFlags & EAPTLSCB_FLAG_8021X_AUTH )
        {
            dwIndex = WIRELESS_PEAP_CACHED_CREDS_INDEX;
        }
        else
        {
            dwIndex = VPN_PEAP_CACHED_CREDS_INDEX;
        }
    }
    else
    {
        if ( pEapTlsCb->fFlags & EAPTLSCB_FLAG_8021X_AUTH )
        {
            dwIndex = WIRELESS_CACHED_CREDS_INDEX;
        }
        else
        {
            dwIndex = VPN_CACHED_CREDS_INDEX;
        }
    }

	if ( NULL != g_CachedCreds[dwIndex].pbHash )
    {
		LocalFree( g_CachedCreds[dwIndex].pbHash );
        g_CachedCreds[dwIndex].pbHash = NULL;
    }

	if ( g_CachedCreds[dwIndex].fCachedCredentialInitialized )
	{
		EapTlsTrace("Freeing Credentials handle for index %d.", dwIndex);

        Status = FreeCredentialsHandle(&(g_CachedCreds[dwIndex].hCachedCredential));
        if (SEC_E_OK != Status)
        {
            EapTlsTrace("FreeCredentialsHandle failed and returned 0x%x", 
                Status);
        }
	}

	g_CachedCreds[dwIndex].fCachedCredentialInitialized = FALSE;

	ZeroMemory( &(g_CachedCreds[dwIndex].hCachedCredential), sizeof(CredHandle));

	g_CachedCreds[dwIndex].cbHash = 0;

	if ( g_CachedCreds[dwIndex].pcCachedCertContext )
	{
		CertFreeCertificateContext ( g_CachedCreds[dwIndex].pcCachedCertContext );
		g_CachedCreds[dwIndex].pcCachedCertContext = NULL;
	}
}


DWORD IsTLSSessionReconnect ( EAPTLSCB  * pEapTlsCb,
                              BOOL  *    pfIsReconnect
                          )
{
    DWORD                           dwRetCode = NO_ERROR;
    SecPkgContext_SessionInfo       SessionInfo;

    EapTlsTrace("IsTLSSessionReconnect");

    ZeroMemory ( &SessionInfo, sizeof(SessionInfo) );

    dwRetCode = QueryContextAttributes(&(pEapTlsCb->hContext),
                                       SECPKG_ATTR_SESSION_INFO,
                                       (PVOID)&SessionInfo
                                      );
    if(dwRetCode != SEC_E_OK)
    {
        EapTlsTrace ("QueryContextAttributes failed querying session info 0x%x", dwRetCode);
    }
    else
    {
        *pfIsReconnect = ( SessionInfo.dwFlags & SSL_SESSION_RECONNECT );
    }

    return dwRetCode;
}

//
// TLS Fast reconnect and cookie management functions
//

DWORD SetTLSFastReconnect ( EAPTLSCB * pEapTlsCb , BOOL fEnable)
{
    DWORD                   dwRetCode = NO_ERROR;
    BOOL                    fReconnect = FALSE;
    SCHANNEL_SESSION_TOKEN  SessionToken = {0};
    SecBufferDesc           OutBuffer;
    SecBuffer               OutBuffers[1];

    EapTlsTrace ("SetTLSFastReconnect");
    
    dwRetCode = IsTLSSessionReconnect ( pEapTlsCb, &fReconnect );
    if ( SEC_E_OK != dwRetCode )
    {
        return dwRetCode;
    }

    if ( fEnable )
    {
        //
        // We ahve been asked to enable fast reconnects.
        // Check to see if we are already enabled for reconnects
        // If so, we dont have to do this again.
        //
        if ( fReconnect )
        {
            EapTlsTrace ("The session is already setup for reconnects.  No need to enable.");
            return NO_ERROR;
        }
    }
    else
    {
        if ( !fReconnect )
        {
            EapTlsTrace("The session is not setup for fast reconnects.  No need to disable.");
            return NO_ERROR;
        }
    }
    SessionToken.dwTokenType = SCHANNEL_SESSION;
    SessionToken.dwFlags = 
        ( fEnable ? SSL_SESSION_ENABLE_RECONNECTS:
                    SSL_SESSION_DISABLE_RECONNECTS
        );
    
    OutBuffers[0].pvBuffer   = &SessionToken;
    OutBuffers[0].BufferType = SECBUFFER_TOKEN;
    OutBuffers[0].cbBuffer   = sizeof(SessionToken);

    OutBuffer.cBuffers  = 1;
    OutBuffer.pBuffers  = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    dwRetCode = ApplyControlToken (&(pEapTlsCb->hContext), &OutBuffer);
    if(dwRetCode != SEC_E_OK)
    {
        EapTlsTrace("Error enabling Fast Reconnects : 0x%x", dwRetCode);
    }
    else
    {
        EapTlsTrace ("Fast Reconnects Enabled/Disabled");
    }
    
    return dwRetCode;
}



//
// Get Session Cookie information
//

DWORD GetTLSSessionCookie ( EAPTLSCB * pEapTlsCb,
                            PBYTE *    ppbCookie,
                            DWORD *    pdwCookie,
                            BOOL  *    pfIsReconnect
                          )
{
    DWORD                           dwRetCode = NO_ERROR;
    SecPkgContext_SessionAppData    AppData;

    RTASSERT(NULL != pEapTlsCb);
    RTASSERT(NULL != ppbCookie);
    RTASSERT(NULL != pdwCookie);

    EapTlsTrace ("GetTLSSessionCookie");

    *ppbCookie = NULL;
    *pdwCookie = 0;
    *pfIsReconnect = FALSE;


    dwRetCode = IsTLSSessionReconnect ( pEapTlsCb,
                                        pfIsReconnect
                                        );                                        
    if(dwRetCode != SEC_E_OK)
    {
        EapTlsTrace ("QueryContextAttributes failed querying session info 0x%x", dwRetCode);
    }
    else
    {
        if ( *pfIsReconnect )
        {   
            EapTlsTrace ("Session Reconnected.");
            *pfIsReconnect = TRUE;
            

            //
            // Get the cookie
            //
            ZeroMemory(&AppData, sizeof(AppData));
            dwRetCode = QueryContextAttributes(&(pEapTlsCb->hContext),
                                               SECPKG_ATTR_APP_DATA,
                                               (PVOID)&AppData);
            if(dwRetCode != SEC_E_OK)
            {
                EapTlsTrace("QueryContextAttributes failed querying session cookie.  Error 0x%x", dwRetCode);
            }
            else
            {
                *ppbCookie = (PBYTE)LocalAlloc (LPTR, AppData.cbAppData );
                if ( NULL == *ppbCookie )
                {
                    EapTlsTrace("Failed allocating memory for session cookie");
                    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    CopyMemory( *ppbCookie, AppData.pbAppData, AppData.cbAppData );
                    *pdwCookie = AppData.cbAppData;
                }
                // Free returned buffer.
                FreeContextBuffer(AppData.pbAppData);
            } 
        }
    }
        
    
    return dwRetCode;
}
                            
//
// Setup the session attributes to set the cookie and to enable/disable
// session reconnects
//

DWORD SetTLSSessionCookie ( EAPTLSCB *  pEapTlsCb, 
                            PBYTE       pbCookie,
                            DWORD       cbCookie
                          )
{
    DWORD                           dwRetCode = NO_ERROR;
    SecPkgContext_SessionAppData    AppData;

    EapTlsTrace ("SetTLSSessionCookie");

    ZeroMemory(&AppData, sizeof(AppData));

    AppData.pbAppData = pbCookie;
    AppData.cbAppData = cbCookie;

    dwRetCode = SetContextAttributes(&(pEapTlsCb->hContext),
                                     SECPKG_ATTR_APP_DATA,
                                     (PVOID)&AppData,
                                     sizeof(AppData)
                                    );
    if(dwRetCode != SEC_E_OK)
    {
        EapTlsTrace ("SetContextAttributes returned error 0x%x setting session cookie\n", dwRetCode);
    }
    else
    {
        EapTlsTrace ("Session cookie set successfully \n");
    }
    
    return dwRetCode;
}



void SetCachedCredentials (EAPTLSCB * pEapTlsCb)
{	
    DWORD           dwIndex = 0;
    TOKEN_STATISTICS TokenStats;
    DWORD            TokenStatsSize = 0;
    HANDLE           CurrentThreadToken = NULL;
    DWORD           dwRetCode=0;
    EapTlsTrace("SetCachedCredentials");
    if ( pEapTlsCb->fFlags & EAPTLSCB_FLAG_EXECUTING_PEAP )
    {
        if ( pEapTlsCb->fFlags & EAPTLSCB_FLAG_8021X_AUTH )
        {
            dwIndex = WIRELESS_PEAP_CACHED_CREDS_INDEX;
        }
        else
        {
            dwIndex = VPN_PEAP_CACHED_CREDS_INDEX;
        }
    }
    else
    {
        if ( pEapTlsCb->fFlags & EAPTLSCB_FLAG_8021X_AUTH )
        {
            dwIndex = WIRELESS_CACHED_CREDS_INDEX;
        }
        else
        {
            dwIndex = VPN_CACHED_CREDS_INDEX;
        }
    }

    EnterCriticalSection ( &g_csProtectCachedCredentials );
    //
    // Free any existing cached credentials. 
    //
    
    FreeCachedCredentials(pEapTlsCb);
    if ( !(pEapTlsCb->fFlags & EAPTLSCB_FLAG_SERVER ) )
    {
        if ( ! OpenThreadToken(
                    GetCurrentThread(),
                    TOKEN_QUERY,
                    TRUE,
                    &CurrentThreadToken
                    )
        )
        {
            EapTlsTrace("OpenThreadToken Failed with Error 0x%x", GetLastError() );
            goto done;
        }

        ZeroMemory ( &TokenStats, sizeof(TokenStats) );

        if ( !GetTokenInformation(
                    CurrentThreadToken,
                    TokenStatistics,
                    &TokenStats,
                    sizeof(TOKEN_STATISTICS),
                    &TokenStatsSize
                    )
        )
        {
            EapTlsTrace("OpenThreadToken Failed with Error 0x%x", GetLastError() );
            goto done;
        }
    }
    if ( EAPTLSCB_FLAG_LOGON & pEapTlsCb->fFlags )
    {
        EapTlsTrace("Not setting cached credentials.");
        goto done;
    }

    g_CachedCreds[dwIndex].pbHash = (PBYTE)LocalAlloc ( LPTR, pEapTlsCb->pUserProp->Hash.cbHash );
	if ( NULL != g_CachedCreds[dwIndex].pbHash )
	{
		memcpy ( g_CachedCreds[dwIndex].pbHash , 
                 pEapTlsCb->pUserProp->Hash.pbHash, 
                 pEapTlsCb->pUserProp->Hash.cbHash 
               );
		g_CachedCreds[dwIndex].cbHash = pEapTlsCb->pUserProp->Hash.cbHash;
		g_CachedCreds[dwIndex].hCachedCredential = pEapTlsCb->hCredential;
		g_CachedCreds[dwIndex].pcCachedCertContext = pEapTlsCb->pCertContext;
		g_CachedCreds[dwIndex].fCachedCredentialInitialized = TRUE;
        if ( !(pEapTlsCb->fFlags & EAPTLSCB_FLAG_SERVER ) )
        {
            CopyMemory ( &g_CachedCreds[dwIndex].AuthenticatedSessionLUID,
                         &TokenStats.AuthenticationId,
                         sizeof( g_CachedCreds[dwIndex].AuthenticatedSessionLUID)
                       );
        }
	}

done:
    LeaveCriticalSection ( &g_csProtectCachedCredentials );
    return;
}

BOOL GetCachedCredentials ( EAPTLSCB * pEapTlsCb )
{
	BOOL	    fCachedCreds = FALSE;
    DWORD       dwIndex = 0;
	TOKEN_STATISTICS TokenStats;
	DWORD            TokenStatsSize = 0;
	HANDLE           CurrentThreadToken = NULL;
	DWORD           dwRetCode=0;

	EapTlsTrace("GetCachedCredentials");

    if ( pEapTlsCb->fFlags & EAPTLSCB_FLAG_EXECUTING_PEAP )
    {
        if ( pEapTlsCb->fFlags & EAPTLSCB_FLAG_8021X_AUTH )
        {
            dwIndex = WIRELESS_PEAP_CACHED_CREDS_INDEX;
        }
        else
        {
            dwIndex = VPN_PEAP_CACHED_CREDS_INDEX;
        }
    }
    else
    {
        if ( pEapTlsCb->fFlags & EAPTLSCB_FLAG_8021X_AUTH )
        {
            dwIndex = WIRELESS_CACHED_CREDS_INDEX;
        }
        else
        {
            dwIndex = VPN_CACHED_CREDS_INDEX;
        }
    }

    EnterCriticalSection ( &g_csProtectCachedCredentials );
    if ( !(pEapTlsCb->fFlags & EAPTLSCB_FLAG_SERVER ) )
    {
        if ( ! OpenThreadToken(
                    GetCurrentThread(),
                    TOKEN_QUERY,
                    TRUE,
                    &CurrentThreadToken
                    )
        )
        {
            EapTlsTrace("OpenThreadToken Failed with Error 0x%x", GetLastError() );
            FreeCachedCredentials(pEapTlsCb);
            goto LDone;
        }

        ZeroMemory ( &TokenStats, sizeof(TokenStats) );

        if ( !GetTokenInformation(
                    CurrentThreadToken,
                    TokenStatistics,
                    &TokenStats,
                    sizeof(TOKEN_STATISTICS),
                    &TokenStatsSize
                    )
        )
        {
            EapTlsTrace("OpenThreadToken Failed with Error 0x%x", GetLastError() );
            FreeCachedCredentials(pEapTlsCb);
            goto LDone;
        }
    }
    if ( pEapTlsCb->fFlags & EAPTLSCB_FLAG_EXECUTING_PEAP )
    {
	    if ( FALSE == g_CachedCreds[dwIndex].fCachedCredentialInitialized || 		     
             NULL == pEapTlsCb->pUserProp ||
             EAPTLSCB_FLAG_LOGON & pEapTlsCb->fFlags
		    )
	    {
            //
		    // bad or missing cached data.  Or Winlogon scenario
            // so cleanup the creds setup globally and return
            //
            FreeCachedCredentials(pEapTlsCb);
		    goto LDone;
	    }

		//set the stuff in 
		CopyMemory ( &pEapTlsCb->hCredential, &g_CachedCreds[dwIndex].hCachedCredential, sizeof(CredHandle) );		

		EapTlsTrace("PEAP GetCachedCredentials: Using cached credentials.");
		fCachedCreds = TRUE;
    }
    else
    {
	    if ( FALSE == g_CachedCreds[dwIndex].fCachedCredentialInitialized || 
		     NULL == g_CachedCreds[dwIndex].pbHash ||
		     0 ==  g_CachedCreds[dwIndex].cbHash ||
		     NULL == g_CachedCreds[dwIndex].pcCachedCertContext ||
             NULL == pEapTlsCb->pUserProp ||
             EAPTLSCB_FLAG_LOGON & pEapTlsCb->fFlags
		    )
	    {
            //
		    // bad or missing cached data.  Or Winlogon scenario
            // so cleanup the creds setup globally and return
            //
            FreeCachedCredentials(pEapTlsCb);
		    goto LDone;
	    }
        //
        // If we are not a server check to see if
        // the LUID in the cache is same as one in the cache
        // If not, wipe out the creds.
        //
        if ( !( pEapTlsCb->fFlags & EAPTLSCB_FLAG_SERVER) )
        {
            if ( !( RtlEqualLuid(&(TokenStats.AuthenticationId), &(g_CachedCreds[dwIndex].AuthenticatedSessionLUID) ) ) )
            {
                FreeCachedCredentials(pEapTlsCb);
                goto LDone;
            }
        }
	    //check to see if the hash matches
        if (	g_CachedCreds[dwIndex].cbHash == pEapTlsCb->pUserProp->Hash.cbHash &&
			    !memcmp ( g_CachedCreds[dwIndex].pbHash, pEapTlsCb->pUserProp->Hash.pbHash, g_CachedCreds[dwIndex].cbHash )
	       )
	    {
		    //Hash matches
		    //set the stuff in 
		    CopyMemory ( &pEapTlsCb->hCredential, &(g_CachedCreds[dwIndex].hCachedCredential), sizeof(CredHandle) );
		    pEapTlsCb->pCertContext = g_CachedCreds[dwIndex].pcCachedCertContext;
		    fCachedCreds = TRUE;

            EapTlsTrace("GetCachedCredentials: Using cached credentials.");
	    }
    }	
LDone:
    LeaveCriticalSection( &g_csProtectCachedCredentials );
	return fCachedCreds;
}

/*

Returns:
    Error codes only from winerror.h, raserror.h or mprerror.h

Notes:
    Get the credentials. fServer is TRUE iff we are the server. Remember to
    call FreeCredentialsHandle(hCredential) at some point.

*/

DWORD
GetCredentials(
    IN  EAPTLSCB*   pEapTlsCb
)
{
    SCHANNEL_CRED   SchannelCred;
    TimeStamp       tsExpiry;
    DWORD           dwErr               = NO_ERROR;
    SECURITY_STATUS Status;
    HCERTSTORE      hCertStore          = NULL;
    PCCERT_CONTEXT  pCertContext        = NULL;
    DWORD           dwCertFlags;
    DWORD           dwSchCredFlags      = 0;
    BOOL            fServer             = FALSE;
    BOOL            fRouter             = FALSE;
    WCHAR*          pwszName            = NULL;
    CRYPT_HASH_BLOB HashBlob;

    EapTlsTrace("GetCredentials");

    if (pEapTlsCb->fFlags & EAPTLSCB_FLAG_SERVER)
    {
        fServer = TRUE;
        dwCertFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
        EapTlsTrace("Flag is Server and Store is local Machine");
    }
    else if (pEapTlsCb->fFlags & EAPTLSCB_FLAG_ROUTER)
    {
        fRouter = TRUE;
        dwCertFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
        EapTlsTrace("Flag is Router and Store is local Machine");
    }
    else if ( pEapTlsCb->fFlags & EAPTLSCB_FLAG_MACHINE_AUTH )
    {
        dwCertFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
        EapTlsTrace("Flag is Machine Auth and Store is local Machine");
    }
    else
    {
        dwCertFlags = CERT_SYSTEM_STORE_CURRENT_USER;
        EapTlsTrace("Flag is Client and Store is Current User");
    }


    if (   !(pEapTlsCb->fFlags & EAPTLSCB_FLAG_SERVER)
        && !(pEapTlsCb->fFlags & EAPTLSCB_FLAG_WINLOGON_DATA)
        && !(pEapTlsCb->fFlags & EAPTLSCB_FLAG_GUEST_ACCESS)
        && !(pEapTlsCb->fFlags & EAPTLSCB_FLAG_EXECUTING_PEAP)
       )

    {

        if(     !(pEapTlsCb->pConnProp->fFlags & EAPTLS_CONN_FLAG_REGISTRY)
            &&  (pEapTlsCb->pUserProp->pwszPin[0] != 0))
        {
            //
            // Make a copy of the pin and save it in the control block
            // for saving it in the credmgr. This will be wiped out
            // when ppp engine queries for the creds.
            //
            DecodePin(pEapTlsCb->pUserProp);

            pEapTlsCb->pSavedPin = LocalAlloc(LPTR,
                                     sizeof(EAPTLS_PIN));

            if(NULL != pEapTlsCb->pSavedPin)
            {
                pEapTlsCb->pSavedPin->pwszPin =
                            LocalAlloc(LPTR,
                             sizeof(WCHAR) *
                             (wcslen(pEapTlsCb->pUserProp->pwszPin) + 1));

                if(NULL != pEapTlsCb->pSavedPin->pwszPin)
                {
                    UNICODE_STRING UnicodeStringPin;
                    UCHAR ucSeed;

                    wcscpy(pEapTlsCb->pSavedPin->pwszPin,
                           pEapTlsCb->pUserProp->pwszPin);

                    RtlInitUnicodeString(&UnicodeStringPin,
                                        pEapTlsCb->pSavedPin->pwszPin);

                    RtlRunEncodeUnicodeString(&ucSeed, &UnicodeStringPin);
                    pEapTlsCb->pSavedPin->usLength = UnicodeStringPin.Length;
                    pEapTlsCb->pSavedPin->usMaximumLength =
                                            UnicodeStringPin.MaximumLength;
                    pEapTlsCb->pSavedPin->ucSeed = ucSeed;
                }
                else
                {
                    LocalFree(pEapTlsCb->pSavedPin);
                    pEapTlsCb->pSavedPin = NULL;
                }
            }

            EncodePin(pEapTlsCb->pUserProp);
        }
    }

	//Check to see if we can get cached credentials
	if ( GetCachedCredentials ( pEapTlsCb ) )
	{
		//got cached creds
        pEapTlsCb->fFlags |= EAPTLSCB_FLAG_USING_CACHED_CREDS;
		goto LDone;
	}

    if (EAPTLSCB_FLAG_WINLOGON_DATA & pEapTlsCb->fFlags)
    {
        dwErr = GetCertFromLogonInfo(pEapTlsCb->pUserData,
                    pEapTlsCb->dwSizeOfUserData, &pCertContext);

        if (NO_ERROR != dwErr)
        {
            goto LDone;
        }
    }
    else
    {
        if ( ( pEapTlsCb->fFlags & EAPTLSCB_FLAG_GUEST_ACCESS  ||
               pEapTlsCb->fFlags & EAPTLSCB_FLAG_EXECUTING_PEAP
             ) 
             && !fServer && !fRouter )

		{
			//if this is guest access and this is a client then
			//no need to get the cert etc.
			EapTlsTrace("No Cert Store.  Guest Access requested");
		}
		else
		{

            // Open the "MY" certificate store.
            hCertStore = CertOpenStore(
                                CERT_STORE_PROV_SYSTEM_A,
                                X509_ASN_ENCODING,
                                0,
                                dwCertFlags | CERT_STORE_READONLY_FLAG,
                                "MY");

            if (NULL == hCertStore)
            {
                dwErr = GetLastError();
                EapTlsTrace("CertOpenStore failed and returned 0x%x", dwErr);
                goto LDone;
            }

            HashBlob.cbData = pEapTlsCb->pUserProp->Hash.cbHash;
            HashBlob.pbData = pEapTlsCb->pUserProp->Hash.pbHash;

            pCertContext = CertFindCertificateInStore(hCertStore, X509_ASN_ENCODING,
                                0, CERT_FIND_HASH, &HashBlob, NULL);

            if (NULL == pCertContext)
            {
            
                if (   fServer
                    || fRouter)
                {
                    WCHAR*  apwsz[1];

                    apwsz[0] = pEapTlsCb->awszIdentity;

                    if (0 == HashBlob.cbData)
                    {
                        RouterLogInformation(pEapTlsCb->hEventLog,
                            ROUTERLOG_EAP_TLS_CERT_NOT_CONFIGURED, 1, apwsz, 0);
                    }
                    else
                    {
                        RouterLogWarning(pEapTlsCb->hEventLog,
                            ROUTERLOG_EAP_TLS_CERT_NOT_FOUND, 1, apwsz, 0);
                    }

                    dwErr = GetDefaultMachineCert(hCertStore, &pCertContext);

                    if (NO_ERROR != dwErr)
                    {
                        goto LDone;
                    }
				    //Now set the user property correctly so that next time we 
				    //can find the certificate
				    pEapTlsCb->pUserProp->Hash.cbHash = MAX_HASH_SIZE;

				    if (!CertGetCertificateContextProperty(pCertContext,
						    CERT_HASH_PROP_ID, pEapTlsCb->pUserProp->Hash.pbHash,
						    &(pEapTlsCb->pUserProp->Hash.cbHash)))
				    {
					    //not an issue if it fails here.  
					    //next time on it will get the default machine cert again
					    EapTlsTrace("CertGetCertificateContextProperty failed and "
						    "returned 0x%x", GetLastError());
					    
				    }
				    //
				    //Should not be an issue if this fails
				    //Write the config back to the registry
				    //It will always be local registry here
				    //
			        ServerConfigDataIO(	FALSE , 
									    NULL ,
									    (PBYTE *)&(pEapTlsCb->pUserProp), 
									    sizeof(EAPTLS_USER_PROPERTIES) 
								      );

                }
                else
                {
                    dwErr = GetLastError();
                    EapTlsTrace("CertFindCertificateInStore failed and returned "
                        "0x%x", dwErr);
                    goto LDone;
                }
            }
        }
    }

    if (   !(pEapTlsCb->fFlags & EAPTLSCB_FLAG_SERVER)
        && !(pEapTlsCb->fFlags & EAPTLSCB_FLAG_WINLOGON_DATA)
        && !(pEapTlsCb->fFlags & EAPTLSCB_FLAG_GUEST_ACCESS)
        && !(pEapTlsCb->fFlags & EAPTLSCB_FLAG_EXECUTING_PEAP)
       )

    {

        dwErr = AssociatePinWithCertificate(
                    pCertContext,
                    pEapTlsCb->pUserProp,
					TRUE,
					!(pEapTlsCb->pConnProp->fFlags & EAPTLS_CONN_FLAG_REGISTRY));

        if (NO_ERROR != dwErr)
        {
            goto LDone;
        }
    }

    if ( !(pEapTlsCb->fFlags & EAPTLSCB_FLAG_GUEST_ACCESS ) && 
         !(pEapTlsCb->fFlags & EAPTLSCB_FLAG_EXECUTING_PEAP )
       )
	{

        if (FCertToStr(pCertContext, 0, fServer || fRouter, &pwszName))
        {
            EapTlsTrace("The name in the certificate is: %ws", pwszName);
            LocalFree(pwszName);
        }
    }
    else
    {
   		EapTlsTrace("No Cert Name.  Guest access requested");
    }

    // Build Schannel credential structure.

    ZeroMemory(&SchannelCred, sizeof(SchannelCred));
    SchannelCred.dwVersion = SCHANNEL_CRED_VERSION;


    if ( pEapTlsCb->fFlags & EAPTLSCB_FLAG_GUEST_ACCESS ||
         pEapTlsCb->fFlags & EAPTLSCB_FLAG_EXECUTING_PEAP
       )
	{
		//Guest Access and server so set the cert context
		//or elase there is no need.
		if ( fServer )
		{
			SchannelCred.cCreds = 1;
			SchannelCred.paCred = &pCertContext;
		}
	}
	else
	{
	    SchannelCred.cCreds = 1;
		SchannelCred.paCred = &pCertContext;
	}

    SchannelCred.grbitEnabledProtocols = SP_PROT_TLS1;

    if (fServer)
    {
        if (!g_fNoRevocationCheck)
        {
            if (g_fNoRootRevocationCheck)
            {
                dwSchCredFlags = SCH_CRED_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
            }
            else
            {
                dwSchCredFlags = SCH_CRED_REVOCATION_CHECK_CHAIN;
            }

            if (g_fIgnoreNoRevocationCheck)
            {
                dwSchCredFlags |= SCH_CRED_IGNORE_NO_REVOCATION_CHECK;
            }

            if (g_fIgnoreRevocationOffline)
            {
                dwSchCredFlags |= SCH_CRED_IGNORE_REVOCATION_OFFLINE;
            }
        }
        //
        // Start with disabling fast for PEAP reconnects.  
        // Once the full handshake is done,
        // decide if we want to allow reconnects.
        //
        dwSchCredFlags |= SCH_CRED_DISABLE_RECONNECTS;
    }
    else
    {
        dwSchCredFlags = SCH_CRED_NO_SERVERNAME_CHECK |
                               SCH_CRED_NO_DEFAULT_CREDS;

        if (EAPTLS_CONN_FLAG_NO_VALIDATE_CERT & pEapTlsCb->pConnProp->fFlags)
        {
            dwSchCredFlags |= SCH_CRED_MANUAL_CRED_VALIDATION;
            EapTlsTrace("Will NOT validate server cert");
        }
        else
        {
            dwSchCredFlags |= SCH_CRED_AUTO_CRED_VALIDATION;
            EapTlsTrace("Will validate server cert");
        }
    }



    SchannelCred.dwFlags = dwSchCredFlags;

    // Create the SSPI credentials.

    Status = AcquireCredentialsHandle(
                        NULL,                       // Name of principal
                        UNISP_NAME,                 // Name of package
                        // Flags indicating use
                        fServer ? SECPKG_CRED_INBOUND : SECPKG_CRED_OUTBOUND,
                        NULL,                       // Pointer to logon ID
                        &SchannelCred,              // Package specific data
                        NULL,                       // Pointer to GetKey() func
                        NULL,                       // Value to pass to GetKey()
                        &(pEapTlsCb->hCredential),  // (out) Credential Handle
                        &tsExpiry);                 // (out) Lifetime (optional)

    if (SEC_E_OK != Status)
    {
        dwErr = Status;
        EapTlsTrace("AcquireCredentialsHandle failed and returned 0x%x", dwErr);
        goto LDone;
    }

    // We needn't store the cert context if we get it by calling 
    // CertFindCertificateInStore. However, if we get it by calling 
    // ScHelperGetCertFromLogonInfo, and we free it, then the hProv will become 
    // invalid. In the former case, there is no hProv associated with the cert 
    // context and schannel does the CryptAcquireContext itself. In the latter 
    // case, there is an hProv associated, and it is invalid after the cert 
    // context is freed.

    pEapTlsCb->pCertContext = pCertContext;
    pCertContext = NULL;
    //
    // If we are a server set cached creds here
    //
    if ( fServer )
    {
        SetCachedCredentials ( pEapTlsCb );
    }
LDone:

    if (NULL != pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
        // Always returns TRUE;
    }

    if (NULL != hCertStore)
    {
        if (!CertCloseStore(hCertStore, 0))
        {
            EapTlsTrace("CertCloseStore failed and returned 0x%x",
                GetLastError());
        }
    }

    if (   (dwErr != NO_ERROR)
        && fServer)
    {
        RouterLogErrorString(pEapTlsCb->hEventLog,
            ROUTERLOG_CANT_GET_SERVER_CRED, 0, NULL, dwErr, 0);
    }

    return(dwErr);
}

/*

Returns:
    Error codes only from winerror.h, raserror.h or mprerror.h.

Notes:
    Looks at *pEapTlsCb and builds an EAP TLS packet in *pSendPacket. 
    cbSendPacket is the number of bytes available in pSendPacket.

    This function looks at the fields bCode, bId, fFlags, cbBlobOut, pbBlobOut, 
    and dwBlobOutOffset in pEapTlsCb. It may also set the field 
    dwBlobOutOffsetNew.

*/

DWORD
BuildPacket(
    OUT EAPTLS_PACKET*  pSendPacket,
    IN  DWORD           cbSendPacket,
    IN  EAPTLSCB*       pEapTlsCb
)
{
    WORD    wLength;
    BOOL    fLengthIncluded     = FALSE;
    DWORD   dwBytesRemaining;
    DWORD   dwBytesToBeSent;
    DWORD   dwErr               = NO_ERROR;

    EapTlsTrace("BuildPacket");

    RTASSERT(NULL != pEapTlsCb);

    if (0xFFFF < cbSendPacket)
    {
        // We never send more than 0xFFFF bytes at a time, since the length 
        // field in EAPTLS_PACKET has two octets

        cbSendPacket = 0xFFFF;
    }

    if (   (NULL == pSendPacket)
        || (cbSendPacket < PPP_EAP_PACKET_HDR_LEN))
    {
        EapTlsTrace("pSendPacket is NULL or too small (size: %d)",
            cbSendPacket);
        dwErr = TYPE_E_BUFFERTOOSMALL;
        goto LDone;
    }

    pSendPacket->bCode = pEapTlsCb->bCode;
    pSendPacket->bId = pEapTlsCb->bId;
    HostToWireFormat16(PPP_EAP_PACKET_HDR_LEN, pSendPacket->pbLength);

    switch (pEapTlsCb->bCode)
    {
    case EAPCODE_Success:
    case EAPCODE_Failure:

        goto LDone;

        break;

    case EAPCODE_Request:
    case EAPCODE_Response:

        if (cbSendPacket < EAPTLS_PACKET_HDR_LEN_MAX +
                           1 /* Send at least one octet of the TLS blob */)
        {
            // We are being conservative here. It is possible that the buffer 
            // is not really too small.

            EapTlsTrace("pSendPacket is too small. Size: %d", cbSendPacket);
            dwErr = TYPE_E_BUFFERTOOSMALL;
            goto LDone;
        }

        // pSendPacket->bCode = pEapTlsCb->bCode;
        // pSendPacket->bId = pEapTlsCb->bId;
        pSendPacket->bType = PPP_EAP_TLS;
        pSendPacket->bFlags = 0;

        break;

    default:

        EapTlsTrace("Unknown EAP code: %d", pEapTlsCb->bCode);
        RTASSERT(FALSE);
        dwErr = E_FAIL;
        goto LDone;
        break;
    }

    // If we reach here, it means that the packet is a request or a response

    if (   (0 == pEapTlsCb->cbBlobOut)
        || (NULL == pEapTlsCb->pbBlobOut))
    {
        // We want to send an empty request or response

        if (   (EAPTLSCB_FLAG_SERVER & pEapTlsCb->fFlags)
            && (EAPTLS_STATE_INITIAL == pEapTlsCb->EapTlsState))
        {
            pSendPacket->bFlags |= EAPTLS_PACKET_FLAG_TLS_START;
        }

        HostToWireFormat16(EAPTLS_PACKET_HDR_LEN, pSendPacket->pbLength);
        goto LDone;
    }

    // If we reach here, it means that the packet is a non empty request or 
    // response.

    if (0 == pEapTlsCb->dwBlobOutOffset)
    {
        // We are sending the first bytes of the blob. Let us tell the peer how 
        // big the blob is

        fLengthIncluded = TRUE;
        pSendPacket->bFlags |= EAPTLS_PACKET_FLAG_LENGTH_INCL;
        wLength = EAPTLS_PACKET_HDR_LEN_MAX;
    }
    else
    {
        wLength = EAPTLS_PACKET_HDR_LEN;
    }

    dwBytesRemaining = pEapTlsCb->cbBlobOut - pEapTlsCb->dwBlobOutOffset;
    dwBytesToBeSent = cbSendPacket - wLength;

    if (dwBytesRemaining < dwBytesToBeSent)
    {
        dwBytesToBeSent = dwBytesRemaining;
    }

    if (dwBytesRemaining > dwBytesToBeSent)
    {
        // We need to send more fragments

        pSendPacket->bFlags |= EAPTLS_PACKET_FLAG_MORE_FRAGMENTS;
    }

    RTASSERT(dwBytesToBeSent + EAPTLS_PACKET_HDR_LEN_MAX <= 0xFFFF);

    wLength += (WORD) dwBytesToBeSent;
    HostToWireFormat16(wLength, pSendPacket->pbLength);

    if (fLengthIncluded)
    {
        HostToWireFormat32(pEapTlsCb->cbBlobOut, pSendPacket->pbData);
    }

    RTASSERT(NULL != pEapTlsCb->pbBlobOut);

    CopyMemory(pSendPacket->pbData + (fLengthIncluded ? 4 : 0),
               pEapTlsCb->pbBlobOut + pEapTlsCb->dwBlobOutOffset,
               dwBytesToBeSent);

    pEapTlsCb->dwBlobOutOffsetNew = pEapTlsCb->dwBlobOutOffset +
                                    dwBytesToBeSent;

LDone:

    if (NO_ERROR == dwErr)
    {
        PrintEapTlsPacket(pSendPacket, FALSE /* fInput */);
    }

    return(dwErr);
}

/*

Returns:
    Error codes only from winerror.h, raserror.h or mprerror.h.

Notes:
    The pwszIdentity obtained from PPP_EAP_INPUT (on the server side) is of the
    form <DOMAIN>\<user>.

    We ask schannel to map the cert to a user object, get the user name and 
    domain name, and make sure that they match pwszIdentity.

*/

DWORD
CheckUserName(
    IN      CtxtHandle      hContext,
    IN      WCHAR*          pwszIdentity
)
{
    DWORD               dwErr                                       = NO_ERROR;
    SECURITY_STATUS     Status;
    HANDLE              Token;
    BOOL                fTokenAcquired                              = FALSE;
    BOOL                fImpersonating                              = FALSE;
    DWORD               dwNumChars;
    WCHAR               pwszUserName[UNLEN + DNLEN + 2];

    EapTlsTrace("CheckUserName");

    Status = QuerySecurityContextToken(&hContext, &Token);

    if (SEC_E_OK != Status)
    {
        EapTlsTrace("QuerySecurityContextToken failed and returned 0x%x",
            Status);
        dwErr = Status;
        goto LDone;
    }

    fTokenAcquired = TRUE;

    if (!ImpersonateLoggedOnUser(Token))
    {
        dwErr = GetLastError();
        EapTlsTrace("ImpersonateLoggedOnUser failed and returned 0x%x",
            dwErr);
        goto LDone;
    }

    fImpersonating = TRUE;

    dwNumChars = UNLEN + DNLEN + 2;

    if (!GetUserNameEx(NameSamCompatible, pwszUserName, &dwNumChars))
    {
        dwErr =  GetLastError();
        EapTlsTrace("GetUserNameExA failed and returned %d", dwErr);
        goto LDone;
    }

    if (_wcsicmp(pwszIdentity, pwszUserName))
    {
        EapTlsTrace("The user claims to be %ws, but is actually %ws",
            pwszIdentity, pwszUserName);
        dwErr = SEC_E_LOGON_DENIED;
        goto LDone;
    }

LDone:

    if (fImpersonating)
    {
        if (!RevertToSelf())
        {
            EapTlsTrace("RevertToSelf failed and returned 0x%x",
                GetLastError());
        }
    }

    if (fTokenAcquired)
    {
        CloseHandle(Token);
    }

    return(dwErr);
}

/*

Returns:
    Error codes only from winerror.h, raserror.h or mprerror.h.

Notes:
    Checks to see if the cert sent by the server is of the right type.
    Also checks the name in the cert, the issuer, etc, if necessary.

*/

DWORD
AuthenticateServer(
    IN  EAPTLSCB*       pEapTlsCb,
    OUT BOOL*           pfWaitForUserOK
)
{
    SECURITY_STATUS         Status;
    PCERT_CONTEXT           pCertContextServer          = NULL;
    EAPTLS_HASH             Hash;
    EAPTLS_HASH             ServerCertHash;
    BOOL                    fHashOK                     = FALSE;
    BOOL                    fNameOK                     = FALSE;
    WCHAR*                  pwszRootCAName              = NULL;
    WCHAR*                  pwszServerName              = NULL;
    WCHAR*                  pwszSavedName               = NULL;
    WCHAR                   awszTitle[NUM_CHARS_TITLE];
    WCHAR*                  pwszFormat                  = NULL;
    WCHAR*                  pwszWarning                 = NULL;
    DWORD                   dwSizeOfWszWarning;
    DWORD                   dwStrLenSaved;
    DWORD                   dwStrLenServer;
    DWORD                   dwStrLenRootCA;
    EAPTLS_CONN_PROPERTIES_V1 * pConnProp                   = NULL;
    EAPTLS_VALIDATE_SERVER* pEapTlsValidateServer;
    DWORD                   dw = 0;
    DWORD                   dwErr                       = NO_ERROR;
	PCERT_ENHKEY_USAGE		pUsage						= NULL;
    DWORD                   dwSizeOfGPRootHashBlob = 0;
    BOOL                    fRootCheckRequired = TRUE;      //By default root check is required
    HCERTSTORE              hCertStore = NULL;
	PBYTE					pbHashTemp = NULL;

    EapTlsTrace("AuthenticateServer");

    RTASSERT(NULL != pEapTlsCb);

    *pfWaitForUserOK = FALSE;

    //
    //if we are doing guest authentication, we always have to authenticate the 
    //server.
    //
    
    if ( ! (pEapTlsCb->fFlags & EAPTLSCB_FLAG_GUEST_ACCESS ) &&
            EAPTLS_CONN_FLAG_NO_VALIDATE_CERT & pEapTlsCb->pConnProp->fFlags)
    {
        // We are done
        goto LDone;
    }

    Status = QueryContextAttributes(&(pEapTlsCb->hContext), 
                SECPKG_ATTR_REMOTE_CERT_CONTEXT, &pCertContextServer);

    if (SEC_E_OK != Status)
    {
        RTASSERT(NULL == pCertContextServer);

        EapTlsTrace("QueryContextAttributes failed and returned 0x%x", Status);
        dwErr = Status;
        goto LDone;
    }

	if ( ( dwErr = DwGetEKUUsage ( pCertContextServer, &pUsage )) != ERROR_SUCCESS )
	{
        EapTlsTrace("The server's cert does not have the 'Server "
            "Authentication' usage");        
        goto LDone;

	}

    if (!FCheckUsage(pCertContextServer, pUsage, TRUE /* fServer */))
    {
        EapTlsTrace("The server's cert does not have the 'Server "
            "Authentication' usage");
        dwErr = E_FAIL;
        goto LDone;
    }

    dwErr = GetRootCertHashAndNameVerifyChain(pCertContextServer, 
                                              &Hash, 
                                              &pwszRootCAName, 
                                              (pEapTlsCb->fFlags & EAPTLSCB_FLAG_8021X_AUTH ),
                                              &fRootCheckRequired);
    if (NO_ERROR != dwErr)
    {
        goto LDone;
    }

    EapTlsTrace("Root CA name: %ws", pwszRootCAName);
    dwStrLenRootCA = wcslen(pwszRootCAName);
    //If there is no root check required, the stuff is good to go.
    if ( !fRootCheckRequired )
        fHashOK = TRUE;

#if 0
    //
    //Check to see if the new flag has been passed in to 
    //see if GP needs to be validated.
    //
    if ( pEapTlsCb->fFlags & EAPTLSCB_FLAG_8021X_AUTH )
    {
        
        EapTlsTrace( "8021X Flag Set.  Will check for group policy hashes.");

        //
        //Lookup  GP and see if we have the hashes to 
        //check against.
        //
        dwErr = ReadGPCARootHashes( &dwSizeOfGPRootHashBlob,
                                    &pbGPRootHashBlob
                                  );
        if ( ERROR_SUCCESS == dwErr && pbGPRootHashBlob )
        {
            for ( dw = 0; dw < dwSizeOfGPRootHashBlob/MAX_HASH_SIZE; dw++ )
            {
                if ( !memcmp( pbGPRootHashBlob + ( dw * MAX_HASH_SIZE ), Hash.pbHash, MAX_HASH_SIZE  ) )
                {
                    EapTlsTrace( "8021X Found Hash match in GP");
                    fHashOK = TRUE;
                    break;
                }
            }
            
        }
        else
        {
            dwErr = NO_ERROR;
            EapTlsTrace ("Could not get group policy hashes to check cert.  Ignoring check.");
        }

    }
    else
    {
        EapTlsTrace( "8021X Flag NOT Set. Will not check for group policy hashes.");
    }
#endif
    
    //
    //Check to see if the hash for the root cert is in the list of
    //hashes saved
    //
    if ( !fHashOK )
    {	
        for ( dw = 0; dw <  pEapTlsCb->pConnProp->dwNumHashes; dw ++ )
        {			

            if (!memcmp(    ( pEapTlsCb->pConnProp->bData + ( dw * sizeof(EAPTLS_HASH) ) ),
                            &Hash,
                            sizeof(EAPTLS_HASH)
                        )
               )               
            {
				EapTlsTrace ("Found Hash");
                fHashOK = TRUE;
                break;
            }
        }
    }


    pwszSavedName = (LPWSTR)(pEapTlsCb->pConnProp->bData + sizeof(EAPTLS_HASH) * pEapTlsCb->pConnProp->dwNumHashes);
    
    if (!FCertToStr(pCertContextServer, 0, TRUE, &pwszServerName))
    {
        dwErr = E_FAIL;
        goto LDone;
    }

    EapTlsTrace("Server name: %ws", pwszServerName);
    EapTlsTrace("Server name specified: %ws", pwszSavedName);
    dwStrLenServer = wcslen(pwszServerName);
    dwStrLenSaved = wcslen(pwszSavedName);

    if (pEapTlsCb->pConnProp->fFlags & EAPTLS_CONN_FLAG_NO_VALIDATE_NAME)
    {
        fNameOK = TRUE;
    }

   //
   // Check to see if the new server name is in the list that is
   // saved.
   //

   if (   (0 != dwStrLenSaved)
       && StrStrI(pwszSavedName,
                       pwszServerName ))
   {
       fNameOK = TRUE;
       dwStrLenServer=0;
   }

    if (   fHashOK
        && fNameOK)
    {
        goto LDone;
    }

    if (pEapTlsCb->fFlags & EAPTLSCB_FLAG_NON_INTERACTIVE)
    {
        EapTlsTrace("No interactive UI's allowed");
        dwErr = E_FAIL;
        goto LDone;
    }

    if (!LoadString(GetHInstance(), IDS_VALIDATE_SERVER_TITLE,
            awszTitle, NUM_CHARS_TITLE))
    {
        awszTitle[0] = 0;
    }

    if (fNameOK && !fHashOK)
    {
        pwszFormat = WszFromId(GetResouceDLLHInstance(), IDS_VALIDATE_SERVER_TEXT);

        if (NULL == pwszFormat)
        {
            dwErr = ERROR_ALLOCATING_MEMORY;
            EapTlsTrace("WszFromId(%d) failed", IDS_VALIDATE_SERVER_TEXT);
            goto LDone;
        }

        dwSizeOfWszWarning =
                (wcslen(pwszFormat) + dwStrLenRootCA) * sizeof(WCHAR);
        pwszWarning = LocalAlloc(LPTR, dwSizeOfWszWarning);

        if (NULL == pwszWarning)
        {
            dwErr = GetLastError();
            EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
            goto LDone;
        }

        swprintf(pwszWarning, pwszFormat, pwszRootCAName);
    }
    else if (!fNameOK && fHashOK)
    {
        pwszFormat = WszFromId(GetResouceDLLHInstance(), IDS_VALIDATE_NAME_TEXT);

        if (NULL == pwszFormat)
        {
            dwErr = ERROR_ALLOCATING_MEMORY;
            EapTlsTrace("WszFromId(%d) failed", IDS_VALIDATE_NAME_TEXT);
            goto LDone;
        }

        dwSizeOfWszWarning = 
                (wcslen(pwszFormat) + dwStrLenServer) * sizeof(WCHAR);
        pwszWarning = LocalAlloc(LPTR, dwSizeOfWszWarning);

        if (NULL == pwszWarning)
        {
            dwErr = GetLastError();
            EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
            goto LDone;
        }

        swprintf(pwszWarning, pwszFormat, pwszServerName);
    }
    else
    {
        RTASSERT(!fNameOK && !fHashOK);

        pwszFormat = WszFromId(GetResouceDLLHInstance(), 
                        IDS_VALIDATE_SERVER_WITH_NAME_TEXT);

        if (NULL == pwszFormat)
        {
            dwErr = ERROR_ALLOCATING_MEMORY;
            EapTlsTrace("WszFromId(%d) failed",
                    IDS_VALIDATE_SERVER_WITH_NAME_TEXT);
            goto LDone;
        }

        dwSizeOfWszWarning =
                (wcslen(pwszFormat) + dwStrLenRootCA + dwStrLenServer) *
                    sizeof(WCHAR);
        pwszWarning = LocalAlloc(LPTR, dwSizeOfWszWarning);

        if (NULL == pwszWarning)
        {
            dwErr = GetLastError();
            EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
            goto LDone;
        }

        swprintf(pwszWarning, pwszFormat, pwszServerName, pwszRootCAName);
    }

    // If the server name is itg1.msft.com, we want to only store msft.com
/*
    for (dw = 0; dw < dwStrLenServer; dw++)
    {
        if (L'.' == pwszServerName[dw])
        {
            break;
        }
    }
*/
    //
    //We need to add a new entry to conn prop here
    // Add new hash and append the server name...
    //
    pConnProp = LocalAlloc( LPTR,
                            sizeof(EAPTLS_CONN_PROPERTIES_V1) +
                            sizeof(EAPTLS_HASH) * ( pEapTlsCb->pConnProp->dwNumHashes + 1 ) +
                            dwStrLenServer * sizeof(WCHAR) + 
                            sizeof(WCHAR) +         //This is for the NULL
                            sizeof(WCHAR) +         //This is for the delimiter
                            dwStrLenSaved * sizeof(WCHAR));

    if (NULL == pConnProp)
    {
        dwErr = GetLastError();
        EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
        goto LDone;
    }

    CopyMemory(pConnProp, pEapTlsCb->pConnProp, sizeof(EAPTLS_CONN_PROPERTIES_V1));

    //One extra char for ;
    pConnProp->dwSize = sizeof(EAPTLS_CONN_PROPERTIES_V1) +
                        sizeof(EAPTLS_HASH) * ( pEapTlsCb->pConnProp->dwNumHashes + 1 ) +
                        dwStrLenServer * sizeof(WCHAR) + sizeof(WCHAR) + sizeof(WCHAR) +
                        dwStrLenSaved * sizeof(WCHAR);

    pConnProp->dwNumHashes ++;

    CopyMemory( pConnProp->bData,
                pEapTlsCb->pConnProp->bData,
                sizeof(EAPTLS_HASH) * pEapTlsCb->pConnProp->dwNumHashes);

    CopyMemory( pConnProp->bData + sizeof(EAPTLS_HASH) * pEapTlsCb->pConnProp->dwNumHashes,
                &Hash,
                sizeof(EAPTLS_HASH)
              );

    if ( dwStrLenSaved )
    {
        wcsncpy (   (LPWSTR)(pConnProp->bData + sizeof(EAPTLS_HASH) * pConnProp->dwNumHashes),
                    (LPWSTR)(pEapTlsCb->pConnProp->bData + sizeof(EAPTLS_HASH) * pEapTlsCb->pConnProp->dwNumHashes),
                    dwStrLenSaved
                );
        if ( dwStrLenServer )
        {
            wcscat ( (LPWSTR)(pConnProp->bData + sizeof(EAPTLS_HASH) * pConnProp->dwNumHashes + dwStrLenSaved * sizeof(WCHAR)),
                        L";"
                    );

            wcscat ( (LPWSTR)(pConnProp->bData + sizeof(EAPTLS_HASH) * pConnProp->dwNumHashes + dwStrLenSaved * sizeof(WCHAR) + sizeof(WCHAR)),
                        pwszServerName
                    );
        }
    }
    else
    {
        wcscpy((LPWSTR)(pConnProp->bData + sizeof(EAPTLS_HASH) * pConnProp->dwNumHashes + dwStrLenSaved * sizeof(WCHAR)),
                pwszServerName
              );
    }
        
    LocalFree(pEapTlsCb->pUIContextData);
    pEapTlsCb->pUIContextData = LocalAlloc(LPTR,
                        sizeof(EAPTLS_VALIDATE_SERVER) + dwSizeOfWszWarning);

    if (NULL == pEapTlsCb->pUIContextData)
    {
        dwErr = GetLastError();
        EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
        goto LDone;
    }

    //
    // Get the Hash of server certificate
    //
    ZeroMemory( &ServerCertHash, sizeof(ServerCertHash) );

    ServerCertHash.cbHash = MAX_HASH_SIZE;

    if (!CertGetCertificateContextProperty(pCertContextServer, CERT_HASH_PROP_ID,
            ServerCertHash.pbHash, &(ServerCertHash.cbHash)))
    {
        dwErr = GetLastError();
        EapTlsTrace("CertGetCertificateContextProperty failed and "
            "returned 0x%x", dwErr);
        goto LDone;
    }

    //
    // Open my store in local machine and add this certificate in it
    //

    hCertStore = CertOpenStore( CERT_STORE_PROV_SYSTEM,
                                0,
                                0,
                                CERT_SYSTEM_STORE_CURRENT_USER,
                                L"CA"
                              );

    if ( NULL == hCertStore )
    {
        dwErr = GetLastError();
        EapTlsTrace("CertOpenStore failed with error 0x%x", dwErr );
        goto LDone;
    }

    //
    // add this context to the store
    //

    if ( !CertAddCertificateContextToStore( hCertStore,
                                                pCertContextServer,
                                                CERT_STORE_ADD_ALWAYS,
                                                NULL
                                              )
        )
    {
        dwErr = GetLastError();
        EapTlsTrace("CertAddCertCertificateContextToStore failed with error 0x%x", dwErr );
        goto LDone;
    }


    pEapTlsValidateServer =(EAPTLS_VALIDATE_SERVER*)(pEapTlsCb->pUIContextData);

    pEapTlsValidateServer->dwSize =
            sizeof(EAPTLS_VALIDATE_SERVER) + dwSizeOfWszWarning;

    //Show this button iff it is not winlogon scenario.

    pEapTlsValidateServer->fShowCertDetails = !(pEapTlsCb->fFlags & EAPTLSCB_FLAG_LOGON);

    //pEapTlsValidateServer->fShowCertDetails = TRUE;

    CopyMemory( &(pEapTlsValidateServer->Hash),
                &ServerCertHash,
                sizeof(ServerCertHash)
              );

    wcscpy(pEapTlsValidateServer->awszTitle, awszTitle);
    wcscpy(pEapTlsValidateServer->awszWarning, pwszWarning);

    *pfWaitForUserOK = TRUE;

LDone:

    if (NO_ERROR == dwErr)
    {
        LocalFree(pEapTlsCb->pNewConnProp);
        pEapTlsCb->pNewConnProp = pConnProp;
        pConnProp = NULL;
    }

	if ( pUsage )
	{
		LocalFree(pUsage);
		pUsage = NULL;
	}

    if (NULL != pCertContextServer)
    {
        CertFreeCertificateContext(pCertContextServer);
        // Always returns TRUE;
    }

    if ( hCertStore )
    {
        CertCloseStore(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG );
    }

    LocalFree(pwszRootCAName);
    LocalFree(pwszServerName);
    LocalFree(pwszWarning);
    LocalFree(pwszFormat);
    LocalFree(pConnProp);
#if 0
    if (NULL != pbGPRootHashBlob)
    {
        LocalFree(pbGPRootHashBlob);
    }
#endif

    if (NO_ERROR != dwErr)
    {
        dwErr = ERROR_UNABLE_TO_AUTHENTICATE_SERVER;
    }

    return(dwErr);
}

/*

Returns:
    Error codes only from winerror.h, raserror.h or mprerror.h.

Notes:

*/

DWORD
AuthenticateUser(
    IN  EAPTLSCB*       pEapTlsCb
)
{
    PCERT_CONTEXT           pCertContextUser        = NULL;
    SECURITY_STATUS         Status;
    DWORD                   dwErr                   = NO_ERROR;
	PCERT_ENHKEY_USAGE	    pUsage					= NULL;
    PCCERT_CHAIN_CONTEXT    pCCertChainContext      = NULL;
    
    EapTlsTrace("AuthenticateUser");

    RTASSERT(NULL != pEapTlsCb);

    Status = QueryContextAttributes(&(pEapTlsCb->hContext), 
                SECPKG_ATTR_REMOTE_CERT_CONTEXT, &pCertContextUser);

    if (SEC_E_OK != Status)
    {
        RTASSERT(NULL == pCertContextUser);

        EapTlsTrace("QueryContextAttributes failed and returned 0x%x", Status);
		//
        //Now that we have default setting of guest access, 
        //if there are no credentials it is fine.  Just send the error back to IAS 
        //and let it decide what has to be done here.
        //

		if ( Status != SEC_E_NO_CREDENTIALS )
        {
			dwErr = SEC_E_LOGON_DENIED;
        }
        else
        {
            if ( pEapTlsCb->fFlags & EAPTLSCB_FLAG_EXECUTING_PEAP )
            {
                EapTlsTrace("Got no credentials from the client and executing PEAP.  This is a success for eaptls.");
                dwErr = NO_ERROR;
                goto LDone;
            }
            else
            {
                EapTlsTrace("Got no credentials from the client. Will send success with authresult as SEC_E_NO_CREDENTIALS");
                dwErr = Status;
            }
        }
        goto LDone;
    }


	if ( ( dwErr = DwGetEKUUsage ( pCertContextUser,&pUsage ) ) != ERROR_SUCCESS )
	{
        EapTlsTrace("The user's cert does not have correct usage");        
        goto LDone;
	}
#if WINVER > 0x0500
    //
    // Check to see if the certificate policy is all 
    // fine.  Now that we allow guest access we definitely need to 
    // see manually if the cert chain is valid.
    //
    

    if ( ( dwErr = DwCheckCertPolicy(pCertContextUser, &pCCertChainContext ) ) != ERROR_SUCCESS)
    {
        EapTlsTrace("The user's cert does not have correct usage.");        
        goto LDone;
    }

    if ( NULL == pCCertChainContext )
    {
        EapTlsTrace("No Chain Context for from the certificate.");
        dwErr = SEC_E_CERT_UNKNOWN;
        goto LDone;

    }

#else
    //
    // We dont have to check Usage separately any more
    // This will be done as a part of policy verification
    // on the chain.
    //
    if (!FCheckUsage(pCertContextUser, pUsage, FALSE))
    {
        EapTlsTrace("The user's cert does not have correct usage");
        dwErr = SEC_E_CERT_UNKNOWN;
        goto LDone;
    }

#endif



    dwErr = CheckUserName(pEapTlsCb->hContext, pEapTlsCb->awszIdentity);
    if (NO_ERROR != dwErr)
    {
        //Special case handling for bug id:96347
        //if ( dwErr != SEC_E_MULTIPLE_ACCOUNTS )
            //dwErr = SEC_E_LOGON_DENIED;
        goto LDone;
    }

	//Put OIDs in RAS Attributes so that we can send then across to IAS
	dwErr = CreateOIDAttributes ( pEapTlsCb, pUsage, pCCertChainContext );
	if ( NO_ERROR != dwErr )
	{
		dwErr = SEC_E_LOGON_DENIED;
		goto LDone;
	}


LDone:

	if ( pUsage )
	{
		LocalFree ( pUsage );
		pUsage = NULL;
	}
    if (NULL != pCertContextUser)
    {
        CertFreeCertificateContext(pCertContextUser);
        // Always returns TRUE;
    }

    if ( pCCertChainContext )
    {
        CertFreeCertificateChain ( pCCertChainContext );
    }
    
    return(dwErr);
}


DWORD 
CreateOIDAttributes ( 
	IN EAPTLSCB *		pEapTlsCb, 
	PCERT_ENHKEY_USAGE	pUsage,
    PCCERT_CHAIN_CONTEXT    pCCertChainContext )
{
	DWORD	            dwErr = NO_ERROR;
	DWORD	            dwIndex, dwIndex1;
    DWORD               dwNumAttrs = 0;
    PCERT_ENHKEY_USAGE  pIssuanceUsage = NULL;

    EapTlsTrace("CreateOIDAttributes");

#if WINVER > 0x0500
    if ( pCCertChainContext )
        pIssuanceUsage = pCCertChainContext->rgpChain[0]->rgpElement[0]->pIssuanceUsage;
#endif
	
    if (NULL != pEapTlsCb->pAttributes)
    {
        RasAuthAttributeDestroy(pEapTlsCb->pAttributes);
        pEapTlsCb->pAttributes = NULL;
    }


    if ( pIssuanceUsage )
    {
        dwNumAttrs = pIssuanceUsage->cUsageIdentifier;
    }

    dwNumAttrs+=pUsage->cUsageIdentifier;
    //Need to allocate one extra for raatMinimum.  The function automatically terminates 
    // with raat minimum
    pEapTlsCb->pAttributes = RasAuthAttributeCreate(dwNumAttrs);

    if (NULL == pEapTlsCb->pAttributes)
    {
        dwErr =  GetLastError();
        EapTlsTrace("RasAuthAttributeCreate failed and returned %d",
            dwErr);
        goto LDone;
    }
    dwIndex = 0;
    while (pUsage->cUsageIdentifier)
    {
		dwErr = RasAuthAttributeInsert(
					dwIndex,
					pEapTlsCb->pAttributes,
					raatCertificateOID,
					FALSE,
					strlen(pUsage->rgpszUsageIdentifier[dwIndex]),
					pUsage->rgpszUsageIdentifier[dwIndex]);

		if (NO_ERROR != dwErr)
		{
			EapTlsTrace("RasAuthAttributeInsert failed for EKU usage and returned %d", dwErr);
			goto LDone;
		}
        dwIndex++;
        pUsage->cUsageIdentifier--;
	}
    dwIndex1 = 0;
    while ( pIssuanceUsage && pIssuanceUsage->cUsageIdentifier )
    {
		dwErr = RasAuthAttributeInsert(
					dwIndex,
					pEapTlsCb->pAttributes,
					raatCertificateOID,
					FALSE,
					strlen(pIssuanceUsage->rgpszUsageIdentifier[dwIndex1]),
					pIssuanceUsage->rgpszUsageIdentifier[dwIndex1]);

		if (NO_ERROR != dwErr)
		{
			EapTlsTrace("RasAuthAttributeInsert failed for Issuance Usage and returned %d", dwErr);
			goto LDone;
		}
        dwIndex++;
        dwIndex1++;
        pIssuanceUsage->cUsageIdentifier--;
    }
    

LDone:
	return dwErr;
}




/*

Returns:
    Error codes only from winerror.h, raserror.h or mprerror.h.

Notes:
    Creates a RAS_AUTH_ATTRIBUTE with the MPPE key in pEapTlsCb->pAttributes.

*/

DWORD
CreateMPPEKeyAttributes(
    IN  EAPTLSCB*           pEapTlsCb
)
{
    SECURITY_STATUS             Status;
    SecPkgContext_EapKeyBlock   EapKeyBlock;
    BYTE                        MPPEKey[56];
    BYTE*                       pSendKey;
    BYTE*                       pRecvKey;
    DWORD                       dwErr           = NO_ERROR;
    RAS_AUTH_ATTRIBUTE  *       pAttrTemp = NULL;


    EapTlsTrace("CreateMPPEKeyAttributes");

    Status = QueryContextAttributes(&(pEapTlsCb->hContext),
                SECPKG_ATTR_EAP_KEY_BLOCK, &EapKeyBlock);

    if (SEC_E_OK != Status)
    {
        EapTlsTrace("QueryContextAttributes failed and returned 0x%x", Status);
        dwErr = Status;
        goto LDone;
    }
#if 0
    if (NULL != pEapTlsCb->pAttributes)
    {
        RasAuthAttributeDestroy(pEapTlsCb->pAttributes);
        pEapTlsCb->pAttributes = NULL;
    }


	pEapTlsCb->pAttributes = RasAuthAttributeCreate(2);

#endif

    
	pAttrTemp = RasAuthAttributeCopyWithAlloc ( pEapTlsCb->pAttributes, 2 );
    if (NULL == pAttrTemp )
    {
        dwErr =  GetLastError();
        EapTlsTrace("RasAuthAttributeCopyWithAlloc failed and returned %d",
            dwErr);
        goto LDone;
    }

    if ( pEapTlsCb->pAttributes )
    {
        RasAuthAttributeDestroy(pEapTlsCb->pAttributes);
    }
    
    pEapTlsCb->pAttributes = pAttrTemp;
    
    if (pEapTlsCb->fFlags & EAPTLSCB_FLAG_SERVER)
    {
        pSendKey = EapKeyBlock.rgbKeys + 32;
        pRecvKey = EapKeyBlock.rgbKeys;
    }
    else
    {
        pSendKey = EapKeyBlock.rgbKeys;
        pRecvKey = EapKeyBlock.rgbKeys + 32;
    }

#if 0
    EapTlsTrace("Send Key");
    TraceDumpEx(g_dwEapTlsTraceId, 1, pSendKey, 32, 4,1,NULL);
    EapTlsTrace("Receive Key");
    TraceDumpEx(g_dwEapTlsTraceId, 1, pRecvKey, 32, 4,1,NULL);
#endif

    ZeroMemory(MPPEKey, sizeof(MPPEKey));

    HostToWireFormat32(311, MPPEKey);           // Vendor Id

    MPPEKey[4] = 16;                            // MS-MPPE-Send-Key
    MPPEKey[5] = 1 + 1 + 2 + 1 + 32 + 15;       // Vendor Length
    // MPPEKey[6-7] is the zero-filled salt field
    MPPEKey[8] = 32;                            // Key-Length
    CopyMemory(MPPEKey + 9, pSendKey, 32);      // Key
    // MPPEKey[41-55] is the Padding (zero octets)

    

    dwErr = RasAuthAttributeInsert(
                0,
                pEapTlsCb->pAttributes,
                raatVendorSpecific,
                FALSE,
                56,
                MPPEKey);

    if (NO_ERROR != dwErr)
    {
        EapTlsTrace("RasAuthAttributeInsert failed and returned %d", dwErr);
        goto LDone;
    }

    // Change only the fields that are different for MS-MPPE-Recv-Key

    MPPEKey[4] = 17;                            // MS-MPPE-Recv-Key
    CopyMemory(MPPEKey + 9, pRecvKey, 32);      // Key

    dwErr = RasAuthAttributeInsert(
                1,
                pEapTlsCb->pAttributes,
                raatVendorSpecific,
                FALSE,
                56,
                MPPEKey);

    if (NO_ERROR != dwErr)
    {
        EapTlsTrace("RasAuthAttributeInsert failed and returned %d", dwErr);
        goto LDone;
    }

LDone:

    return(dwErr);
}

/*

Returns:

Notes:

*/

VOID
RespondToResult(
    IN  EAPTLSCB*       pEapTlsCb,
    IN  PPP_EAP_OUTPUT* pEapOutput
)
{
    EAPTLS_USER_PROPERTIES* pUserProp;
    DWORD                   dwErr = NO_ERROR;
    PBYTE                   pbEncPIN = NULL;       //Encrypted PIN
    DWORD                   cbEncPIN = 0;

    RTASSERT(   (EAPTLSCB_FLAG_SUCCESS & pEapTlsCb->fFlags)
             || (NO_ERROR != pEapTlsCb->dwAuthResultCode));

    EapTlsTrace("Negotiation %s",
        (EAPTLSCB_FLAG_SUCCESS & pEapTlsCb->fFlags) ?
            "successful" : "unsuccessful");

    pEapOutput->pUserAttributes = pEapTlsCb->pAttributes;
    pEapOutput->dwAuthResultCode = pEapTlsCb->dwAuthResultCode;

    //
    //Duplicate checks all over are bogus.  Need to cleanup this
    //part later.
    //

    if (!(pEapTlsCb->fFlags & EAPTLSCB_FLAG_ROUTER) && 
        !(pEapTlsCb->fFlags & EAPTLSCB_FLAG_WINLOGON_DATA)
       )
    {
        
        //
        // If this is a 802.1x and a smart card based 
        // client then dont instruct to save user
        // data.  

        if ( pEapTlsCb->fFlags & EAPTLSCB_FLAG_8021X_AUTH &&
             !(pEapTlsCb->pConnProp->fFlags & EAPTLS_CONN_FLAG_REGISTRY)
           )
        {
            pEapOutput->fSaveUserData = FALSE;
        }
        else
        { 
            pEapOutput->fSaveUserData = TRUE;
        }

    }


    if (   (EAPTLSCB_FLAG_SUCCESS & pEapTlsCb->fFlags)
        && (NULL != pEapTlsCb->pUserProp))
    {
        if ( pEapTlsCb->fFlags & EAPTLSCB_FLAG_8021X_AUTH &&
             !(pEapTlsCb->pConnProp->fFlags & EAPTLS_CONN_FLAG_REGISTRY)
           )
        {
            //
            // Encrypt PIN and send it back
            //

            dwErr = EncryptData ( (PBYTE)pEapTlsCb->pUserProp->pwszPin, 
                                    lstrlen(pEapTlsCb->pUserProp->pwszPin) * sizeof(WCHAR),
                                    &pbEncPIN,
                                    &cbEncPIN
                                );

            if ( NO_ERROR != dwErr )
            {
                //
                //Encryption failed.  So wipe Out the PIN
                //Do a dummy allocation
                //
                pbEncPIN = (PBYTE)LocalAlloc(LPTR,5);
                cbEncPIN = lstrlen( (LPWSTR)pbEncPIN );
            }
            
        }
        else
        {
            pbEncPIN = (PBYTE)LocalAlloc(LPTR, 5);;
            cbEncPIN = lstrlen( (LPWSTR)pbEncPIN );
        }

        dwErr = AllocUserDataWithNewPin(pEapTlsCb->pUserProp, pbEncPIN, cbEncPIN, &pUserProp);


        LocalFree(pEapTlsCb->pUserProp);
        pEapTlsCb->pUserProp = pUserProp;

        pEapOutput->pUserData = (BYTE*)pUserProp;
        if (NULL != pUserProp)
        {
            pEapOutput->dwSizeOfUserData = pUserProp->dwSize;
        }
        else
        {
            pEapOutput->dwSizeOfUserData = 0;
        }

        if (NULL != pEapTlsCb->pNewConnProp)
        {
            pEapOutput->fSaveConnectionData = TRUE;
            //
            //Convert back to the cludgy v0 + v1 extra here
            //
            dwErr = ConnPropGetV0Struct ( pEapTlsCb->pNewConnProp, (EAPTLS_CONN_PROPERTIES ** )&(pEapOutput->pConnectionData) );
            pEapOutput->dwSizeOfConnectionData = 
                ((EAPTLS_CONN_PROPERTIES *) (pEapOutput->pConnectionData) )->dwSize;                
        }
    }
    else
    {
        pEapOutput->pUserData = NULL;
        pEapOutput->dwSizeOfUserData = 0;
    }

    LocalFree ( pbEncPIN );

    pEapOutput->Action = EAPACTION_Done;
}

/*

Returns:

Notes:

*/

VOID
GetAlert(
    IN  EAPTLSCB*       pEapTlsCb,
    IN  EAPTLS_PACKET*  pReceivePacket
)
{
    BOOL                fLengthIncluded;
    DWORD               dwBlobSizeReceived;

    SecBuffer           InBuffers[4];
    SecBufferDesc       Input;

    DWORD               dwAuthResultCode;
    SECURITY_STATUS     Status;

    EapTlsTrace("GetAlert");

    if (PPP_EAP_TLS != pReceivePacket->bType)
    {
        dwAuthResultCode = E_FAIL;
        goto LDone;
    }

    if (pEapTlsCb->fFlags & EAPTLSCB_FLAG_HCTXT_INVALID)
    {
        EapTlsTrace("hContext is not valid");
        dwAuthResultCode = ERROR_INVALID_HANDLE;
        goto LDone;
    }

    fLengthIncluded = pReceivePacket->bFlags & EAPTLS_PACKET_FLAG_LENGTH_INCL;

    dwBlobSizeReceived = WireToHostFormat16(pReceivePacket->pbLength) -
                         (fLengthIncluded ? EAPTLS_PACKET_HDR_LEN_MAX :
                                            EAPTLS_PACKET_HDR_LEN);


    if (dwBlobSizeReceived > pEapTlsCb->cbBlobInBuffer)
    {
        EapTlsTrace("Reallocating input TLS blob buffer");

        LocalFree(pEapTlsCb->pbBlobIn);
        pEapTlsCb->pbBlobIn = NULL;
        pEapTlsCb->cbBlobInBuffer = 0;

        pEapTlsCb->pbBlobIn = LocalAlloc(LPTR, dwBlobSizeReceived);

        if (NULL == pEapTlsCb->pbBlobIn)
        {
            dwAuthResultCode = GetLastError();
            EapTlsTrace("LocalAlloc failed and returned %d", dwAuthResultCode);
            goto LDone;
        }

        pEapTlsCb->cbBlobInBuffer = dwBlobSizeReceived;
    }

    CopyMemory(pEapTlsCb->pbBlobIn,
               pReceivePacket->pbData + (fLengthIncluded ? 4 : 0),
               dwBlobSizeReceived);

    pEapTlsCb->cbBlobIn = dwBlobSizeReceived;

    InBuffers[0].pvBuffer   = pEapTlsCb->pbBlobIn;
    InBuffers[0].cbBuffer   = pEapTlsCb->cbBlobIn;
    InBuffers[0].BufferType = SECBUFFER_DATA;

    InBuffers[1].BufferType = SECBUFFER_EMPTY;
    InBuffers[2].BufferType = SECBUFFER_EMPTY;
    InBuffers[3].BufferType = SECBUFFER_EMPTY;

    Input.cBuffers          = 4;
    Input.pBuffers          = InBuffers;
    Input.ulVersion         = SECBUFFER_VERSION;

    Status = DecryptMessage(&(pEapTlsCb->hContext), &Input, 0, 0);

    dwAuthResultCode = Status;

LDone:

    if (SEC_E_OK == dwAuthResultCode)
    {
        RTASSERT(FALSE);
        dwAuthResultCode = E_FAIL;
    }

    EapTlsTrace("Error 0x%x", dwAuthResultCode);

    pEapTlsCb->dwAuthResultCode = dwAuthResultCode;
    pEapTlsCb->fFlags &= ~EAPTLSCB_FLAG_SUCCESS;
}

/*

Returns:

Notes:
    Calls [Initialize|Accept]SecurityContext.

*/

SECURITY_STATUS
SecurityContextFunction(
    IN  EAPTLSCB*       pEapTlsCb
)
{
    SecBufferDesc       Input;
    SecBuffer           InBuffers[2];
    SecBufferDesc       Output;
    SecBuffer           OutBuffers[1];

    DWORD               dwBlobSizeRequired;

    ULONG               fContextAttributes;
    ULONG               fContextReq;
    TimeStamp           tsExpiry;

    BOOL                fServer;
    BOOL                fTlsStart;
    BOOL                fRepeat;
    SECURITY_STATUS     Status;
    SECURITY_STATUS     StatusTemp;

    EapTlsTrace("SecurityContextFunction");

    RTASSERT(NULL != pEapTlsCb);

    fServer = pEapTlsCb->fFlags & EAPTLSCB_FLAG_SERVER;

    if (fServer)
    {
        fTlsStart = (EAPTLS_STATE_SENT_START == pEapTlsCb->EapTlsState);
    }
    else
    {
        fTlsStart = (EAPTLS_STATE_INITIAL == pEapTlsCb->EapTlsState);
    }

    fContextReq = pEapTlsCb->fContextReq;

    fRepeat = TRUE;

    while (fRepeat)
    {
        // Set up the input buffers. InBuffers[0] is used to pass in data
        // received from the server. Schannel will consume some or all of this.
        // The amount of the leftover data (if any) will be placed in
        // InBuffers[1].cbBuffer and InBuffers[1].BufferType will be set to
        // SECBUFFER_EXTRA.

        InBuffers[0].pvBuffer   = pEapTlsCb->pbBlobIn;
        InBuffers[0].cbBuffer   = pEapTlsCb->cbBlobIn;
        InBuffers[0].BufferType = SECBUFFER_TOKEN;

        InBuffers[1].pvBuffer   = NULL;
        InBuffers[1].cbBuffer   = 0;
        InBuffers[1].BufferType = SECBUFFER_EMPTY;

        Input.cBuffers          = 2;
        Input.pBuffers          = InBuffers;
        Input.ulVersion         = SECBUFFER_VERSION;

        // Set up the output buffers.

        OutBuffers[0].pvBuffer  = NULL;
        OutBuffers[0].cbBuffer  = 0;
        OutBuffers[0].BufferType= SECBUFFER_TOKEN;

        Output.cBuffers         = 1;
        Output.pBuffers         = OutBuffers;
        Output.ulVersion        = SECBUFFER_VERSION;

        if (fServer)
        {
            // Call AcceptSecurityContext.

            Status = AcceptSecurityContext(
                            &(pEapTlsCb->hCredential),
                            fTlsStart ? NULL : &(pEapTlsCb->hContext),
                            &Input,
                            fContextReq,
                            SECURITY_NETWORK_DREP,
                            &(pEapTlsCb->hContext),
                            &Output,
                            &fContextAttributes,
                            &tsExpiry);

            EapTlsTrace("AcceptSecurityContext returned 0x%x", Status);
        }
        else
        {
            // Call InitializeSecurityContext.

            // The pszTargetName is used for cache indexing, so if you pass in
            // NULL then you will likely take a perf hit, maybe a large one.

            Status = InitializeSecurityContext(
                            &(pEapTlsCb->hCredential),
                            fTlsStart ? NULL : &(pEapTlsCb->hContext),
                            pEapTlsCb->awszIdentity /* pszTargetName */,
                            fContextReq,
                            0,
                            SECURITY_NETWORK_DREP,
                            (fTlsStart) ? NULL : &Input,
                            0,
                            &(pEapTlsCb->hContext),
                            &Output,
                            &fContextAttributes,
                            &tsExpiry);
                            
            EapTlsTrace("InitializeSecurityContext returned 0x%x", Status);
        }

        if (!FAILED(Status))
        {
            // If the first call to ASC fails (perhaps because the client sent
            // bad stuff, even though we have nothing wrong on our side), then
            // schannel will not return an hContext to the application. The
            // application should not call DSC in this case, even if it looks
            // like schannel messed up and returned a handle.

            pEapTlsCb->fFlags &= ~EAPTLSCB_FLAG_HCTXT_INVALID;
        }

        // If [Accept|Initialize]SecurityContext was successful (or if the error 
        // was one of the special extended ones), send the contents of the
        // output buffer to the peer.

        if (SEC_E_OK == Status                  ||
            SEC_I_CONTINUE_NEEDED == Status     ||
            FAILED(Status) && (fContextAttributes & ISC_RET_EXTENDED_ERROR))
        {
            if (0 != OutBuffers[0].cbBuffer && NULL != OutBuffers[0].pvBuffer)
            {
                dwBlobSizeRequired = OutBuffers[0].cbBuffer;

                if (dwBlobSizeRequired > pEapTlsCb->cbBlobOutBuffer)
                {
                    LocalFree(pEapTlsCb->pbBlobOut);

                    pEapTlsCb->pbBlobOut = NULL;
                    pEapTlsCb->cbBlobOut = 0;
                    pEapTlsCb->cbBlobOutBuffer = 0;
                }

                if (NULL == pEapTlsCb->pbBlobOut)
                {
                    pEapTlsCb->pbBlobOut = LocalAlloc(LPTR, dwBlobSizeRequired);

                    if (NULL == pEapTlsCb->pbBlobOut)
                    {
                        pEapTlsCb->cbBlobOut = 0;
                        pEapTlsCb->cbBlobOutBuffer = 0;
                        Status = GetLastError();
                        EapTlsTrace("LocalAlloc failed and returned %d",
                            Status);
                        goto LWhileEnd;
                    }
                    

                    pEapTlsCb->cbBlobOutBuffer = dwBlobSizeRequired;
                }

                CopyMemory(pEapTlsCb->pbBlobOut, OutBuffers[0].pvBuffer, 
                    dwBlobSizeRequired);

                pEapTlsCb->cbBlobOut = dwBlobSizeRequired;
                pEapTlsCb->dwBlobOutOffset = pEapTlsCb->dwBlobOutOffsetNew = 0;
            }
        }

        // Copy any leftover data from the "extra" buffer.

        if (InBuffers[1].BufferType == SECBUFFER_EXTRA)
        {
            MoveMemory(pEapTlsCb->pbBlobIn,
                pEapTlsCb->pbBlobIn +
                    (pEapTlsCb->cbBlobIn - InBuffers[1].cbBuffer),
                InBuffers[1].cbBuffer);

            pEapTlsCb->cbBlobIn = InBuffers[1].cbBuffer;
        }
        else
        {
            pEapTlsCb->cbBlobIn = 0;
        }

LWhileEnd:

        if (NULL != OutBuffers[0].pvBuffer)
        {
            StatusTemp = FreeContextBuffer(OutBuffers[0].pvBuffer);

            if (SEC_E_OK != StatusTemp)
            {
                EapTlsTrace("FreeContextBuffer failed and returned 0x%x",
                    StatusTemp);
            }
        }

        // ASC (and ISC) will sometimes only consume part of the input buffer,
        // and return a zero length output buffer. In this case, we must just
        // call ASC again (with the input buffer adjusted appropriately).

        if (   (0 == OutBuffers[0].cbBuffer)
            && (SEC_I_CONTINUE_NEEDED == Status))
        {
            EapTlsTrace("Reapeating SecurityContextFunction loop...");
        }
        else
        {
            fRepeat = FALSE;
        }
    }

    return(Status);
}

/*

Returns:
    A TLS alert corresponding to the error.

Notes:

*/

DWORD
AlertFromError(
    IN  DWORD   * pdwErr,
    IN  BOOL      fTranslateError
)
{
    DWORD   dwAlert;
	DWORD	dwErr = *pdwErr;

    switch (dwErr)
    {
    case SEC_E_MESSAGE_ALTERED:
        dwAlert = TLS1_ALERT_BAD_RECORD_MAC;
        break;

    case SEC_E_DECRYPT_FAILURE:
        dwAlert = TLS1_ALERT_DECRYPTION_FAILED;
        break;

    case SEC_E_CERT_UNKNOWN:
        dwAlert = TLS1_ALERT_BAD_CERTIFICATE;
        break;

    case CRYPT_E_REVOKED:
        dwAlert = TLS1_ALERT_CERTIFICATE_REVOKED;
        break;

    case SEC_E_CERT_EXPIRED:
        dwAlert = TLS1_ALERT_CERTIFICATE_EXPIRED;
        break;

    case SEC_E_UNTRUSTED_ROOT:
        dwAlert = TLS1_ALERT_UNKNOWN_CA;
        break;

    case SEC_E_LOGON_DENIED:
    case ERROR_UNABLE_TO_AUTHENTICATE_SERVER:
    case SEC_E_NO_IMPERSONATION:
        dwAlert = TLS1_ALERT_ACCESS_DENIED;
        break;

    case SEC_E_ILLEGAL_MESSAGE:
        dwAlert = TLS1_ALERT_DECODE_ERROR;
        break;

    case SEC_E_UNSUPPORTED_FUNCTION:
        dwAlert = TLS1_ALERT_PROTOCOL_VERSION;
        break;

    case SEC_E_ALGORITHM_MISMATCH:
        dwAlert = TLS1_ALERT_INSUFFIENT_SECURITY;
        break;
    
#if WINVER > 0x0500
    case SEC_E_MULTIPLE_ACCOUNTS: //Special case handling for : 96347
    
        dwAlert = TLS1_ALERT_CERTIFICATE_UNKNOWN;       
        break;
#endif
    default:
        dwAlert = TLS1_ALERT_ACCESS_DENIED;
        //We have been instructed to translate the error.  So do that.
        if ( fTranslateError )
		    *pdwErr = SEC_E_LOGON_DENIED;
        break;
    }

    return(dwAlert);
}

/*

Returns:

Notes:

*/

VOID
MakeAlert(
    IN  EAPTLSCB*   pEapTlsCb,
    IN  DWORD       dwAlert,
    IN  BOOL        fManualAlert
)
{
    #define                 NUM_ALERT_BYTES                             7
    static BYTE             pbAlert[NUM_ALERT_BYTES - 1]
                            = {0x15, 0x03, 0x01, 0x00, 0x02, 0x02};

    SCHANNEL_ALERT_TOKEN    Token;
    SecBufferDesc           OutBuffer;
    SecBuffer               OutBuffers[1];
    BOOL                    fZeroBlobOut                                = TRUE;
    DWORD                   Status;
    DWORD                   dwErr;

    EapTlsTrace("MakeAlert(%d, %s)",
        dwAlert, fManualAlert ? "Manual" : "Schannel");

    if (fManualAlert)
    {
        if (NUM_ALERT_BYTES > pEapTlsCb->cbBlobOutBuffer)
        {
            LocalFree(pEapTlsCb->pbBlobOut);

            pEapTlsCb->pbBlobOut = NULL;
            pEapTlsCb->cbBlobOut = 0;
            pEapTlsCb->cbBlobOutBuffer = 0;
        }

        if (NULL == pEapTlsCb->pbBlobOut)
        {
            pEapTlsCb->pbBlobOut = LocalAlloc(LPTR, NUM_ALERT_BYTES);

            if (NULL == pEapTlsCb->pbBlobOut)
            {
                pEapTlsCb->cbBlobOut = 0;
                pEapTlsCb->cbBlobOutBuffer = 0;
                dwErr = GetLastError();
                EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
                goto LDone;
            }
            
            pEapTlsCb->cbBlobOutBuffer = NUM_ALERT_BYTES;
        }

        CopyMemory(pEapTlsCb->pbBlobOut, pbAlert, NUM_ALERT_BYTES - 1);
        pEapTlsCb->pbBlobOut[NUM_ALERT_BYTES - 1] = (BYTE) dwAlert;
        pEapTlsCb->cbBlobOut = NUM_ALERT_BYTES;

        fZeroBlobOut = FALSE;
        goto LDone;
    }

    if (pEapTlsCb->fFlags & EAPTLSCB_FLAG_HCTXT_INVALID)
    {
        EapTlsTrace("hContext is not valid");
        goto LDone;
    }

    Token.dwTokenType   = SCHANNEL_ALERT;
    Token.dwAlertType   = TLS1_ALERT_FATAL;
    Token.dwAlertNumber = dwAlert;

    OutBuffers[0].pvBuffer   = &Token;
    OutBuffers[0].cbBuffer   = sizeof(Token);
    OutBuffers[0].BufferType = SECBUFFER_TOKEN;

    OutBuffer.cBuffers  = 1;
    OutBuffer.pBuffers  = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    Status = ApplyControlToken(&(pEapTlsCb->hContext), &OutBuffer);

    if (FAILED(Status)) 
    {
        EapTlsTrace("ApplyControlToken failed and returned 0x%x", Status);
        goto LDone;
    }

    Status = SecurityContextFunction(pEapTlsCb);

    fZeroBlobOut = FALSE;

LDone:

    if (fZeroBlobOut)
    {
        pEapTlsCb->cbBlobOut = pEapTlsCb->dwBlobOutOffset = 
            pEapTlsCb->dwBlobOutOffsetNew = 0;
    }
}

/*

Returns:
    Error codes only from winerror.h, raserror.h or mprerror.h.

Notes:
    Called to process an incoming packet. We collect all the fragments that the 
    peer want to send and only then call SecurityContextFunction. There are two 
    reasons for this: 1) [Initialize|Accept]SecurityContext sometimes generates 
    an output even when the incoming message is incomplete. The RFC requires us 
    to send an empty Request/Response. 2) A rogue peer may carefully construct 
    a valid 80 MB TLS blob in a denial of service attack. There is no easy way 
    to guard against this.

    Errors should be returned from this function for things like LocalAlloc 
    failing. Not because we got something bad from the peer. If an error is 
    returned from this function, then we should use EAPACTION_NoAction. Perhaps 
    we can succeed next time.

    Before calling [Initialize|Accept]SecurityContext, it is OK to return an 
    error for things like LocalAlloc failing. After calling the function, 
    however, we should always return NO_ERROR, and if something failed, set 
    pEapTlsCb->dwAuthResultCode, and go to the state nFinalState. This is 
    because we cannot call [Initialize|Accept]SecurityContext again.

*/

DWORD
MakeReplyMessage(
    IN  EAPTLSCB*       pEapTlsCb,
    IN  EAPTLS_PACKET*  pReceivePacket
)
{
    BOOL                fLengthIncluded         = FALSE;
    BOOL                fMoreFragments          = FALSE;
    BOOL                fManualAlert            = FALSE;
    BOOL                fWaitForUserOK          = FALSE;
    BOOL                fServer;

    DWORD               dwBlobSizeReceived;
    DWORD               dwBlobSizeRequired      = 0;
    DWORD               dwBlobSizeNew;
    BYTE*               pbBlobOld;

    int                 nFinalState;
    SECURITY_STATUS     Status;
    DWORD               dwAlert                 = 0;
    WCHAR*              apwszWarning[1];
    DWORD               dwAuthResultCode        = NO_ERROR;
    DWORD               dwErr                   = NO_ERROR;
    DWORD               dwNoCredCode            = NO_ERROR;
    BOOL                fTranslateError         = FALSE;

    EapTlsTrace("MakeReplyMessage");

    RTASSERT(NULL != pEapTlsCb);
    RTASSERT(NULL != pReceivePacket);

    if (PPP_EAP_TLS != pReceivePacket->bType)
    {
        // Don't go to LDone. We don't want to change
        // pEapTlsCb->dwAuthResultCode

        return(ERROR_PPP_INVALID_PACKET);
    }

    fLengthIncluded = pReceivePacket->bFlags & EAPTLS_PACKET_FLAG_LENGTH_INCL;

    if (pEapTlsCb->fFlags & EAPTLSCB_FLAG_SERVER)
    {
        fServer = TRUE;
        nFinalState = EAPTLS_STATE_SENT_FINISHED;
    }
    else
    {
        fServer = FALSE;
        nFinalState = EAPTLS_STATE_RECD_FINISHED;
    }

    fMoreFragments = pReceivePacket->bFlags & EAPTLS_PACKET_FLAG_MORE_FRAGMENTS;

    dwBlobSizeReceived = WireToHostFormat16(pReceivePacket->pbLength) -
                         (fLengthIncluded ? EAPTLS_PACKET_HDR_LEN_MAX :
                                            EAPTLS_PACKET_HDR_LEN);

    if (!(pEapTlsCb->fFlags & EAPTLSCB_FLAG_RECEIVING_FRAGMENTS))
    {
        // We haven't received any fragment yet. Make sure that we have the 
        // right amount of memory allocated in pbBlobIn.

        if (!fMoreFragments)
        {
            dwBlobSizeRequired = pEapTlsCb->cbBlobIn + dwBlobSizeReceived;
        }
        else
        {
            // This is the first of many fragments.

            if (!fLengthIncluded)
            {
                EapTlsTrace("TLS Message Length is required");
                dwAuthResultCode = ERROR_INVALID_PARAMETER;
                dwAlert = TLS1_ALERT_ILLEGAL_PARAMETER;
                goto LDone;
            }
            else
            {
                dwBlobSizeNew = WireToHostFormat32(pReceivePacket->pbData);

                if (g_dwMaxBlobSize < dwBlobSizeNew)
                {
                    EapTlsTrace("Blob size %d is unacceptable", dwBlobSizeNew);
                    dwAuthResultCode = ERROR_INVALID_PARAMETER;
                    dwAlert = TLS1_ALERT_ILLEGAL_PARAMETER;
                    goto LDone;
                }
                else
                {
                    dwBlobSizeRequired = pEapTlsCb->cbBlobIn + dwBlobSizeNew;
                    pEapTlsCb->dwBlobInRemining = dwBlobSizeNew;
                    pEapTlsCb->fFlags |= EAPTLSCB_FLAG_RECEIVING_FRAGMENTS;
                }
            }
        }

        if (dwBlobSizeRequired > pEapTlsCb->cbBlobInBuffer)
        {
            EapTlsTrace("Reallocating input TLS blob buffer");

            pbBlobOld = pEapTlsCb->pbBlobIn;
            pEapTlsCb->pbBlobIn = LocalAlloc(LPTR, dwBlobSizeRequired);

            if (NULL == pEapTlsCb->pbBlobIn)
            {
                pEapTlsCb->pbBlobIn = pbBlobOld;
                dwErr = GetLastError();
                EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
                goto LDone;
            }

            pEapTlsCb->cbBlobInBuffer = dwBlobSizeRequired;
            if (0 != pEapTlsCb->cbBlobIn)
            {
                RTASSERT(NULL != pbBlobOld);
                CopyMemory(pEapTlsCb->pbBlobIn, pbBlobOld, pEapTlsCb->cbBlobIn);
            }
            LocalFree(pbBlobOld);
        }
    }

    if (pEapTlsCb->fFlags & EAPTLSCB_FLAG_RECEIVING_FRAGMENTS)
    {
        if (pEapTlsCb->dwBlobInRemining < dwBlobSizeReceived)
        {
            EapTlsTrace("Peer is sending more bytes than promised");
            dwAuthResultCode = ERROR_INVALID_PARAMETER;
            dwAlert = TLS1_ALERT_ILLEGAL_PARAMETER;
            goto LDone;
        }
        else
        {
            pEapTlsCb->dwBlobInRemining -= dwBlobSizeReceived;

            if (0 == pEapTlsCb->dwBlobInRemining)
            {
                pEapTlsCb->fFlags &= ~EAPTLSCB_FLAG_RECEIVING_FRAGMENTS;

                if (fMoreFragments)
                {
                    // No need to send an alert here.
                    EapTlsTrace("Peer has sent the entire TLS blob, but wants "
                        "to send more.");
                }
            }
        }
    }

    // Now we are sure that pEapTlsCb->pbBlobIn is big enough to hold all
    // the information.

    CopyMemory(pEapTlsCb->pbBlobIn + pEapTlsCb->cbBlobIn,
               pReceivePacket->pbData + (fLengthIncluded ? 4 : 0),
               dwBlobSizeReceived);

    pEapTlsCb->cbBlobIn += dwBlobSizeReceived;

    if (!(pEapTlsCb->fFlags & EAPTLSCB_FLAG_RECEIVING_FRAGMENTS))
    {
        Status = SecurityContextFunction(pEapTlsCb);
        //
        // Need to write a function to map the SSPI error
        // to nice and rosy RAS error
        //
#if WINVER > 0x0500
        if ( Status == SEC_E_UNTRUSTED_ROOT )
        {
            dwAuthResultCode = ERROR_VALIDATING_SERVER_CERT;
        }
        else
        {
            dwAuthResultCode = Status;
        }
#else
        dwAuthResultCode = Status;
#endif
        if (SEC_E_OK == Status)
        {
            if (fServer)
            {
                /*

                Normally, the server calls ASC for the last time (from state 
                EAPTLS_STATE_SENT_HELLO), gets the blob that contains TLS 
                change_cipher_spec, and then checks to see if the user is OK 
                (AuthenticateUser, etc). However, if the server then wants to 
                send an alert, and wants schannel to create it, it has to undo 
                the TLS change_cipher_spec first. Instead, it constructs the 
                alert itself.

                */

                fManualAlert = TRUE;
                dwAuthResultCode = AuthenticateUser(pEapTlsCb);
                if ( SEC_E_NO_CREDENTIALS == dwAuthResultCode )
                {
                    dwNoCredCode = dwAuthResultCode;
                    dwAuthResultCode = NO_ERROR;
                }
                fTranslateError = FALSE;
            }
            else
            {
                dwAuthResultCode = AuthenticateServer(pEapTlsCb,
                                        &fWaitForUserOK);
                fTranslateError = TRUE;
            }

            if (NO_ERROR != dwAuthResultCode  )
            {
                dwAlert = AlertFromError(&dwAuthResultCode, fTranslateError);
                goto LDone;
            }
            

            //
            // Since we've started with no fast reconnect
            // Session established successfully.  
            // Now setup TLS fast reconnect.
            // 
            if ( fServer )
            {
                dwAuthResultCode = SetTLSFastReconnect(pEapTlsCb, TRUE);
                if ( NO_ERROR != dwAuthResultCode )
                {
                    dwAlert = TLS1_ALERT_INTERNAL_ERROR;
                    goto LDone;
                }       
            }
            dwAuthResultCode = CreateMPPEKeyAttributes(pEapTlsCb);

            if (NO_ERROR != dwAuthResultCode)
            {
                dwAlert = TLS1_ALERT_INTERNAL_ERROR;
                goto LDone;
            }

            if (fWaitForUserOK)
            {
                pEapTlsCb->EapTlsState = EAPTLS_STATE_WAIT_FOR_USER_OK;
                EapTlsTrace("State change to %s",
                    g_szEapTlsState[pEapTlsCb->EapTlsState]);
                goto LDone;
            }
        }

        if (SEC_E_OK == Status)
        {
            pEapTlsCb->fFlags |= EAPTLSCB_FLAG_SUCCESS;
            pEapTlsCb->EapTlsState = nFinalState;
            EapTlsTrace("State change to %s",
                g_szEapTlsState[pEapTlsCb->EapTlsState]);
        }

        if (SEC_I_CONTINUE_NEEDED == dwAuthResultCode)
        {
            dwAuthResultCode = NO_ERROR;

            pEapTlsCb->EapTlsState = fServer ?
                g_nEapTlsServerNextState[pEapTlsCb->EapTlsState]:
                g_nEapTlsClientNextState[pEapTlsCb->EapTlsState];

            EapTlsTrace("State change to %s",
                g_szEapTlsState[pEapTlsCb->EapTlsState]);
        }
    }

LDone:

    if (0 != dwAlert)
    {
        RTASSERT(NO_ERROR != dwAuthResultCode);
        pEapTlsCb->cbBlobIn = pEapTlsCb->dwBlobInRemining = 0;
        pEapTlsCb->fFlags &= ~EAPTLSCB_FLAG_RECEIVING_FRAGMENTS;
        pEapTlsCb->fFlags &= ~EAPTLSCB_FLAG_SUCCESS;
        MakeAlert(pEapTlsCb, dwAlert, fManualAlert);
    }

    if (NO_ERROR != dwAuthResultCode)
    {
        pEapTlsCb->fFlags &= ~EAPTLSCB_FLAG_SUCCESS;
        if (nFinalState != pEapTlsCb->EapTlsState)
        {
            pEapTlsCb->EapTlsState = nFinalState;
            EapTlsTrace("State change to %s. Error: 0x%x",
                g_szEapTlsState[pEapTlsCb->EapTlsState], dwAuthResultCode);
        }
        //Commented per bug #'s 475244 and 478128
        /*
        if (fServer)
        {
            apwszWarning[0] = pEapTlsCb->awszIdentity ?
                                    pEapTlsCb->awszIdentity : L"";
            
            
            RouterLogErrorString(pEapTlsCb->hEventLog,
                ROUTERLOG_EAP_AUTH_FAILURE, 1, apwszWarning,
                dwAuthResultCode, 1);
            
        }
        */
    }

    if ( dwNoCredCode == NO_ERROR )
    {
        pEapTlsCb->dwAuthResultCode = dwAuthResultCode;
    }
    else
    {
        EapTlsTrace ( "No Credentials got from the client.  Returning 0x%d", dwNoCredCode);
        pEapTlsCb->dwAuthResultCode = dwNoCredCode;
    }

    return(dwErr);
}

/*

Returns:
    Error codes only from winerror.h, raserror.h or mprerror.h.

Notes:
    Called by the client to process an incoming packet and/or send a packet. 
    cbSendPacket is the size in bytes of the buffer pointed to by pSendPacket.
    This function is called only after FValidPacket(pReceivePacket) returns 
    TRUE. If pEapOutput->Action is going to be EAPACTION_SendAndDone or
    EAPACTION_Done, make sure that pEapOutput->dwAuthResultCode has been set.
    If dwAuthResultCode is NO_ERROR, make sure that pEapOutput->pUserAttributes
    has been set.

*/

DWORD
EapTlsCMakeMessage(
    IN  EAPTLSCB*       pEapTlsCb,
    IN  EAPTLS_PACKET*  pReceivePacket,
    OUT EAPTLS_PACKET*  pSendPacket,
    IN  DWORD           cbSendPacket,
    OUT PPP_EAP_OUTPUT* pEapOutput,
    IN  PPP_EAP_INPUT*  pEapInput
)
{
    EAPTLS_USER_PROPERTIES* pUserProp           = NULL;
    DWORD                   dwAuthResultCode;
    DWORD                   dwErr               = NO_ERROR;

    EapTlsTrace("EapTlsCMakeMessage");

    // Response packets should not be sent with any timeout

    if (   (NULL != pReceivePacket)
        && (EAPCODE_Request == pReceivePacket->bCode))
    {
        if (   (pEapTlsCb->bId == pReceivePacket->bId)
            && (EAPTLS_STATE_INITIAL != pEapTlsCb->EapTlsState))
        {
            // The server is repeating its request. Resend our last response.

            pEapTlsCb->bCode = EAPCODE_Response;
            dwErr = BuildPacket(pSendPacket, cbSendPacket, pEapTlsCb);

            if (NO_ERROR != dwErr)
            {
                pEapOutput->Action = EAPACTION_NoAction;
            }
            else
            {
                EapTlsTrace("Resending response for request %d",
                    pEapTlsCb->bId);
                pEapOutput->Action = EAPACTION_Send;
            }

            goto LDone;
        }
        else if (pReceivePacket->bFlags & EAPTLS_PACKET_FLAG_TLS_START)
        {
            // The server wants to renogitiate

            dwErr = EapTlsReset(pEapTlsCb);

            if (NO_ERROR != dwErr)
            {
                pEapOutput->Action = EAPACTION_NoAction;
                goto LDone;
            }
        }
    }

    if (NULL != pReceivePacket)
    {
        // We are not getting the same old request. Therefore, whatever we sent 
        // last time has reached the server.

        pEapTlsCb->dwBlobOutOffset = pEapTlsCb->dwBlobOutOffsetNew;

        if (pEapTlsCb->dwBlobOutOffset == pEapTlsCb->cbBlobOut)
        {
            // We have sent whatever we wanted to send

            pEapTlsCb->cbBlobOut = 0;
            pEapTlsCb->dwBlobOutOffset = pEapTlsCb->dwBlobOutOffsetNew = 0;
        }
    }

    switch (pEapTlsCb->EapTlsState)
    {
    case EAPTLS_STATE_INITIAL:
    case EAPTLS_STATE_SENT_HELLO:
    case EAPTLS_STATE_SENT_FINISHED:

        if (NULL == pReceivePacket)
        {
            // We are called once in the initial state. Since we are the
            // authenticatee, we do nothing, and wait for a request pakcet
            // from the authenticator.

            pEapOutput->Action = EAPACTION_NoAction;
            goto LDone;
        }
        /*
        else if (EAPCODE_Failure == pReceivePacket->bCode)
        {
            EapTlsTrace("Negotiation result according to peer: failure");
            pEapTlsCb->dwAuthResultCode = E_FAIL;
            pEapTlsCb->fFlags &= ~EAPTLSCB_FLAG_SUCCESS;
            RespondToResult(pEapTlsCb, pEapOutput);
            goto LDone;
        }
        */
        else if (EAPCODE_Request != pReceivePacket->bCode)
        {
            // We shouldn't get any other packet in this state so
            // we simply drop this invalid packet

            EapTlsTrace("Code %d unexpected in state %s",
                pReceivePacket->bCode, g_szEapTlsState[pEapTlsCb->EapTlsState]);
            pEapOutput->Action = EAPACTION_NoAction;
            dwErr = ERROR_PPP_INVALID_PACKET;
            goto LDone;
        }
        else
        {
            if (0 != pEapTlsCb->cbBlobOut)
            {
                // We still have some stuff to send

                if (WireToHostFormat16(pReceivePacket->pbLength) ==
                    EAPTLS_PACKET_HDR_LEN)
                {
                    // The server is asking for more stuff by sending an empty
                    // request.

                    pEapTlsCb->bId = pReceivePacket->bId;
                    pEapTlsCb->bCode = EAPCODE_Response;
                    dwErr = BuildPacket(pSendPacket, cbSendPacket, pEapTlsCb);

                    if (NO_ERROR != dwErr)
                    {
                        pEapOutput->Action = EAPACTION_NoAction;
                    }
                    else
                    {
                        pEapOutput->Action = EAPACTION_Send;
                    }

                    goto LDone;
                }
                else
                {
                    // We had more stuff to send, but the peer already wants to 
                    // say something. Let us forget our stuff.

                    pEapTlsCb->cbBlobOut = 0;
                    pEapTlsCb->dwBlobOutOffset = 0;
                    pEapTlsCb->dwBlobOutOffsetNew = 0;
                }
            }

            // Build the response packet

            dwErr = MakeReplyMessage(pEapTlsCb, pReceivePacket);

            if (NO_ERROR != dwErr)
            {
                pEapOutput->Action = EAPACTION_NoAction;
                goto LDone;
            }

            if (EAPTLS_STATE_WAIT_FOR_USER_OK == pEapTlsCb->EapTlsState)
            {
                EAPTLS_VALIDATE_SERVER* pEapTlsValidateServer;

                pEapOutput->Action = EAPACTION_NoAction;
                pEapOutput->fInvokeInteractiveUI = TRUE;
                pEapTlsValidateServer =
                    (EAPTLS_VALIDATE_SERVER*) (pEapTlsCb->pUIContextData);
                pEapOutput->dwSizeOfUIContextData = 
                            pEapTlsValidateServer->dwSize;
                pEapOutput->pUIContextData = pEapTlsCb->pUIContextData;
                pEapTlsCb->bNextId = pReceivePacket->bId;
            }
            else
            {
                pEapTlsCb->bId = pReceivePacket->bId;
                pEapTlsCb->bCode = EAPCODE_Response;
                dwErr = BuildPacket(pSendPacket, cbSendPacket, pEapTlsCb);

                if (NO_ERROR != dwErr)
                {
                    pEapOutput->Action = EAPACTION_NoAction;
                }
                else
                {
                    pEapOutput->Action = EAPACTION_Send;
                }
            }

            goto LDone;
        }

        break;

    case EAPTLS_STATE_WAIT_FOR_USER_OK:

        if (   (NULL == pEapInput)
            || (!pEapInput->fDataReceivedFromInteractiveUI))
        {
            pEapOutput->Action = EAPACTION_NoAction;
            break;
        }

        LocalFree(pEapTlsCb->pUIContextData);
        pEapTlsCb->pUIContextData = NULL;

        if (   (pEapInput->dwSizeOfDataFromInteractiveUI != sizeof(BYTE))
            || (IDNO == *(pEapInput->pDataFromInteractiveUI)))
        {
            EapTlsTrace("User chose not to accept the server", dwErr);

            dwAuthResultCode = ERROR_UNABLE_TO_AUTHENTICATE_SERVER;
            pEapTlsCb->cbBlobIn = pEapTlsCb->dwBlobInRemining = 0;
            pEapTlsCb->fFlags &= ~EAPTLSCB_FLAG_RECEIVING_FRAGMENTS;
            pEapTlsCb->fFlags &= ~EAPTLSCB_FLAG_SUCCESS;
            MakeAlert(pEapTlsCb,
                AlertFromError(&dwAuthResultCode, TRUE),
                FALSE);
        }
        else
        {
            EapTlsTrace("User chose to accept the server", dwErr);
            pEapTlsCb->fFlags |= EAPTLSCB_FLAG_SUCCESS;
            dwAuthResultCode = NO_ERROR;
        }

        pEapTlsCb->EapTlsState = EAPTLS_STATE_RECD_FINISHED;
        EapTlsTrace("State change to %s. Error: 0x%x",
            g_szEapTlsState[pEapTlsCb->EapTlsState],
            dwAuthResultCode);
        pEapTlsCb->dwAuthResultCode = dwAuthResultCode;

        pEapTlsCb->bId = pEapTlsCb->bNextId;
        pEapTlsCb->bCode = EAPCODE_Response;
        dwErr = BuildPacket(pSendPacket, cbSendPacket, pEapTlsCb);

        if (NO_ERROR != dwErr)
        {
            pEapOutput->Action = EAPACTION_NoAction;
        }
        else
        {
            pEapOutput->Action = EAPACTION_Send;
        }

        break;

    case EAPTLS_STATE_RECD_FINISHED:

        if (NULL == pReceivePacket)
        {
            // If we did not receive a packet then we check to see if the
            // fSuccessPacketReceived flag is set (we received an NCP packet: 
            // an implicit EAP-Success).

            if (   (NULL != pEapInput)
                && (pEapInput->fSuccessPacketReceived))
            {
                // The peer thinks that the negotiation was successful

                EapTlsTrace("Negotiation result according to peer: success");
                RespondToResult(pEapTlsCb, pEapOutput);
            }
            else
            {
                pEapOutput->Action = EAPACTION_NoAction;
            }

            goto LDone;
        }
        else
        {
            switch (pReceivePacket->bCode)
            {
            case EAPCODE_Success:
            case EAPCODE_Failure:

                if (pReceivePacket->bId != pEapTlsCb->bId)
                {
                    EapTlsTrace("Success/Failure packet has invalid id: %d. "
                        "Expected: %d",
                        pReceivePacket->bId, pEapTlsCb->bId);
                }

                EapTlsTrace("Negotiation result according to peer: %s",
                    (EAPCODE_Success == pReceivePacket->bCode) ? 
                        "success" : "failure");
                RespondToResult(pEapTlsCb, pEapOutput);

                goto LDone;

                break;

            case EAPCODE_Request:
            case EAPCODE_Response:
            default:

                if ( pEapTlsCb->fFlags & EAPTLSCB_FLAG_EXECUTING_PEAP )
                {
                    //
                    // if we are in peap, no success is send back.
                    // instead identity request is send across.
                    // Complete 
                    if ( pReceivePacket->bCode == EAPCODE_Request )
                    {
                        RespondToResult(pEapTlsCb, pEapOutput);
                        goto LDone;
                    }
                    EapTlsTrace("Unexpected code: %d in state %s",
                        pReceivePacket->bCode,
                        g_szEapTlsState[pEapTlsCb->EapTlsState]);

                    pEapOutput->Action = EAPACTION_NoAction;

                }
                else
                {
                    EapTlsTrace("Unexpected code: %d in state %s",
                        pReceivePacket->bCode,
                        g_szEapTlsState[pEapTlsCb->EapTlsState]);

                    pEapOutput->Action = EAPACTION_NoAction;
                    goto LDone;
                }

                break;
            }
        }

        break;

    default:

        EapTlsTrace("Why is the client in this state: %d?",
            pEapTlsCb->EapTlsState);
        RTASSERT(FALSE);
        pEapOutput->Action = EAPACTION_NoAction;
        dwErr = ERROR_PPP_INVALID_PACKET;
        break;
    }

LDone:

    return(dwErr);
}

/*

Returns:
    Error codes only from winerror.h, raserror.h or mprerror.h.

Notes:
    Called by the server to process an incoming packet and/or send a packet. 
    cbSendPacket is the size in bytes of the buffer pointed to by pSendPacket.
    This function is called only after FValidPacket(pReceivePacket) returns 
    TRUE. If pEapOutput->Action is going to be EAPACTION_SendAndDone or
    EAPACTION_Done, make sure that pEapOutput->dwAuthResultCode has been set.
    If dwAuthResultCode is NO_ERROR, make sure that pEapOutput->pUserAttributes
    has been set.

*/

DWORD
EapTlsSMakeMessage(
    IN  EAPTLSCB*       pEapTlsCb,
    IN  EAPTLS_PACKET*  pReceivePacket,
    OUT EAPTLS_PACKET*  pSendPacket,
    IN  DWORD           cbSendPacket,
    OUT PPP_EAP_OUTPUT* pEapOutput,
    IN  PPP_EAP_INPUT*  pEapInput
)
{
    DWORD               dwErr           = NO_ERROR;
    BOOL                fSessionResumed = FALSE;

    EapTlsTrace("EapTlsSMakeMessage");

    if (   (NULL != pReceivePacket)
        && (EAPCODE_Response == pReceivePacket->bCode)
        && (pReceivePacket->bId == pEapTlsCb->bId))
    {
        // Whatever we sent last time has reached the client.

        pEapTlsCb->dwBlobOutOffset = pEapTlsCb->dwBlobOutOffsetNew;

        if (pEapTlsCb->dwBlobOutOffset == pEapTlsCb->cbBlobOut)
        {
            // We have sent whatever we wanted to send

            pEapTlsCb->cbBlobOut = 0;
            pEapTlsCb->dwBlobOutOffset = pEapTlsCb->dwBlobOutOffsetNew = 0;
        }
    }

    switch (pEapTlsCb->EapTlsState)
    {
    case EAPTLS_STATE_INITIAL:

        // Create a Request packet

        dwErr = EapTlsReset(pEapTlsCb);

        if (NO_ERROR != dwErr)
        {
            pEapOutput->Action = EAPACTION_NoAction;
            goto LDone;
        }

        // pEapTlsCb->bId already has bInitialId
        pEapTlsCb->bCode = EAPCODE_Request;
        dwErr = BuildPacket(pSendPacket, cbSendPacket, pEapTlsCb);

        if (NO_ERROR != dwErr)
        {
            pEapOutput->Action = EAPACTION_NoAction;
            goto LDone;
        }

        // Request messages must be sent with a timeout

        pEapOutput->Action = EAPACTION_SendWithTimeoutInteractive;

        pEapTlsCb->EapTlsState = EAPTLS_STATE_SENT_START;
        EapTlsTrace("State change to %s",
            g_szEapTlsState[pEapTlsCb->EapTlsState]);

        goto LDone;

        break;

    case EAPTLS_STATE_SENT_START:
    case EAPTLS_STATE_SENT_HELLO:
    case EAPTLS_STATE_SENT_FINISHED:

        if (NULL == pReceivePacket)
        {
            // We timed out waiting for a response from the authenticatee.
            // we need to resend with the same Id.

            pEapTlsCb->bCode = EAPCODE_Request;
            dwErr = BuildPacket(pSendPacket, cbSendPacket, pEapTlsCb);

            if (NO_ERROR != dwErr)
            {
                pEapOutput->Action = EAPACTION_NoAction;
            }
            else
            {
                EapTlsTrace("Resending request %d", pEapTlsCb->bId);
                pEapOutput->Action = EAPACTION_SendWithTimeoutInteractive;
            }

            goto LDone;
        }
        else if (EAPCODE_Response != pReceivePacket->bCode)
        {
            // We should only get responses

            EapTlsTrace("Ignoring non response packet from client");
            pEapOutput->Action = EAPACTION_NoAction;
            dwErr = ERROR_PPP_INVALID_PACKET;
            goto LDone;
        }
        else if (pReceivePacket->bId != pEapTlsCb->bId)
        {
            EapTlsTrace("Ignoring duplicate response packet");
            pEapOutput->Action = EAPACTION_NoAction;
            goto LDone;
        }
        else
        {
            // We have received a response with the right Id.

            if (0 != pEapTlsCb->cbBlobOut)
            {
                // We still have some stuff to send

                if (WireToHostFormat16(pReceivePacket->pbLength) ==
                    EAPTLS_PACKET_HDR_LEN)
                {
                    // The client is asking for more stuff by sending an empty
                    // response.

                    pEapTlsCb->bId++;
                    pEapTlsCb->bCode = EAPCODE_Request;
                    dwErr = BuildPacket(pSendPacket, cbSendPacket, pEapTlsCb);

                    if (NO_ERROR != dwErr)
                    {
                        pEapOutput->Action = EAPACTION_NoAction;
                    }
                    else
                    {
                        pEapOutput->Action =
                            EAPACTION_SendWithTimeoutInteractive;
                    }

                    goto LDone;
                }
                else
                {
                    // We had more stuff to send, but the peer already wants to 
                    // say something. Let us forget our stuff.

                    pEapTlsCb->cbBlobOut = 0;
                    pEapTlsCb->dwBlobOutOffset = 0;
                    pEapTlsCb->dwBlobOutOffsetNew = 0;
                }
            }

            if (EAPTLS_STATE_SENT_FINISHED != pEapTlsCb->EapTlsState)
            {
                // We don't have any more stuff to send.

                // Build the response packet

                dwErr = MakeReplyMessage(pEapTlsCb, pReceivePacket);

                if (NO_ERROR != dwErr)
                {
                    pEapOutput->Action = EAPACTION_NoAction;
                    goto LDone;
                }

                if (   (0 == pEapTlsCb->cbBlobOut)
                    && (EAPTLS_STATE_SENT_FINISHED == pEapTlsCb->EapTlsState))
                {
                    // If the client sent an alert, send Failure immediately.
                    // Do not send one more request.

                    if (!(pEapTlsCb->fFlags & EAPTLSCB_FLAG_SUCCESS))
                    {
                        RTASSERT(NO_ERROR != pEapTlsCb->dwAuthResultCode);
                    }
                    else
                    {
                        fSessionResumed = TRUE;
                    }
                }
                else
                {
                    pEapTlsCb->bId++;
                    pEapTlsCb->bCode = EAPCODE_Request;
                    dwErr = BuildPacket(pSendPacket, cbSendPacket, pEapTlsCb);

                    if (NO_ERROR != dwErr)
                    {
                        pEapOutput->Action = EAPACTION_NoAction;
                    }
                    else
                    {
                        pEapOutput->Action =
                            EAPACTION_SendWithTimeoutInteractive;
                    }

                    goto LDone;
                }
            }

            if (!(pEapTlsCb->fFlags & EAPTLSCB_FLAG_SUCCESS))
            {
                EapTlsTrace("Negotiation unsuccessful");
                pEapTlsCb->bCode = EAPCODE_Failure;
            }
            else
            {
                if (   (WireToHostFormat16(pReceivePacket->pbLength) ==
                            EAPTLS_PACKET_HDR_LEN)
                    || fSessionResumed)
                {
                    EapTlsTrace("Negotiation successful");
                    pEapTlsCb->bCode = EAPCODE_Success;
                }
                else
                {
                    // We got an alert from the client

                    EapTlsTrace("Client sent an alert; "
                        "negotiation unsuccessful");

                    GetAlert(pEapTlsCb, pReceivePacket);
                    pEapTlsCb->bCode = EAPCODE_Failure;
                }
            }

            // pEapTlsCb->bId should be the same as that of the last 
            // request.

            dwErr = BuildPacket(pSendPacket, cbSendPacket, pEapTlsCb);

            if (NO_ERROR != dwErr)
            {
                pEapOutput->Action = EAPACTION_NoAction;
            }
            else
            {
#if 0
                RTASSERT(   (   EAPCODE_Failure == pEapTlsCb->bCode
                             && NO_ERROR != pEapTlsCb->dwAuthResultCode)
                         || (   EAPCODE_Success == pEapTlsCb->bCode
                             && NO_ERROR == pEapTlsCb->dwAuthResultCode));
#endif

                EapTlsTrace ("AuthResultCode = (%ld), bCode = (%ld)",
                        pEapTlsCb->dwAuthResultCode,
                        pEapTlsCb->bCode);

                pEapOutput->pUserAttributes = pEapTlsCb->pAttributes;
                pEapOutput->dwAuthResultCode = pEapTlsCb->dwAuthResultCode;
                pEapOutput->Action = EAPACTION_SendAndDone;
            }

            goto LDone;
        }

        break;

    default:

        EapTlsTrace("Why is the server in this state: %d?",
            pEapTlsCb->EapTlsState);
        RTASSERT(FALSE);
        pEapOutput->Action = EAPACTION_NoAction;
        dwErr = ERROR_PPP_INVALID_PACKET;
        break;
    }

LDone:

    return(dwErr);
}

DWORD
RasEapGetCredentials(
    IN DWORD    dwTypeId,
    IN VOID   * pWorkBuf,
    OUT VOID ** ppCredentials)
{
    EAPTLSCB *pEapTlsCb = (EAPTLSCB *)pWorkBuf;

    if(PPP_EAP_PEAP == dwTypeId)
    {
        return PeapGetCredentials(
                    pWorkBuf,
                    ppCredentials);
    }
    else if(    (PPP_EAP_TLS != dwTypeId)
            ||  (NULL == pEapTlsCb))
    {
        return E_INVALIDARG;
    }

    //
    // Get TLS credentials here and return them in the
    // pCredentials blob.
    //
    return GetCredentialsFromUserProperties(pEapTlsCb,
                                            ppCredentials);

}

/////////////////////////////All PEAP related stuff //////////////////////////////////


DWORD
EapPeapInitialize(
    IN  BOOL    fInitialize
)
{
    DWORD               dwRetCode = NO_ERROR;
    static  DWORD       dwRefCount = 0;

    
    EapTlsInitialize(fInitialize); 

    //
    // Get a list of all EapTypes that can be Peap enabled 
    //
    if ( fInitialize )
    {
        if ( !dwRefCount )
        {

            ZeroMemory ( &(g_CachedCreds[VPN_PEAP_CACHED_CREDS_INDEX]), 
                         sizeof(EAPTLS_CACHED_CREDS) );
            ZeroMemory ( &(g_CachedCreds[WIRELESS_PEAP_CACHED_CREDS_INDEX]), 
                         sizeof(EAPTLS_CACHED_CREDS) );
            dwRetCode = PeapEapInfoGetList ( NULL, &g_pEapInfo);
        }
        dwRefCount++;
    }
    else
    {
        dwRefCount --;
        if ( !dwRefCount )
        {
            PeapEapInfoFreeList( g_pEapInfo );
            g_pEapInfo = NULL;
        }
    }
    
    
    return dwRetCode;
}

DWORD
EapPeapBegin(
    OUT VOID**          ppWorkBuffer,
    IN  PPP_EAP_INPUT*  pPppEapInput
)
{
    DWORD                       dwRetCode = NO_ERROR;
    PPEAPCB                     pPeapCB = NULL;    
    PPP_EAP_INPUT               PppEapInputToTls;
    EAPTLS_USER_PROPERTIES      EapTlsUserProp;
    PEAP_ENTRY_USER_PROPERTIES UNALIGNED * pEntryUserProp = NULL;
    PEAP_ENTRY_CONN_PROPERTIES UNALIGNED * pEntryConnProp = NULL;

    EapTlsTrace("EapPeapBegin");

    RTASSERT(NULL != ppWorkBuffer);
    RTASSERT(NULL != pPppEapInput);
#if 0
    dwRetCode = VerifyCallerTrust(_ReturnAddress());
    if ( NO_ERROR != dwRetCode )
    {        
        EapTlsTrace("Unauthorized use of PEAP attempted");
        goto LDone;
    }
#endif

    pPeapCB = (PPEAPCB)LocalAlloc(LPTR, sizeof(PEAPCB) );
    if ( NULL == pPeapCB )
    {
        EapTlsTrace("Error allocating memory for PEAPCB");
        dwRetCode = ERROR_OUTOFMEMORY;
        goto LDone;
    }

    //
    // Get info for each of the configured eap types and call
    // initialze and then begin 
    //
    pPeapCB->PeapState = PEAP_STATE_INITIAL;
    if ( pPppEapInput->fAuthenticator )
    {
        pPeapCB->dwFlags |= PEAPCB_FLAG_SERVER;
    }

    pPppEapInput->fFlags & RAS_EAP_FLAG_ROUTER ? 
        pPeapCB->dwFlags |= PEAPCB_FLAG_ROUTER:0;

    pPppEapInput->fFlags & RAS_EAP_FLAG_NON_INTERACTIVE ?
        pPeapCB->dwFlags |= PEAPCB_FLAG_NON_INTERACTIVE:0;

    pPppEapInput->fFlags & RAS_EAP_FLAG_LOGON ?
        pPeapCB->dwFlags |= PEAPCB_FLAG_LOGON:0;

    pPppEapInput->fFlags & RAS_EAP_FLAG_PREVIEW ?
        pPeapCB->dwFlags |= PEAPCB_FLAG_PREVIEW:0;

    pPppEapInput->fFlags & RAS_EAP_FLAG_FIRST_LINK ?
        pPeapCB->dwFlags |= PEAPCB_FLAG_FIRST_LINK:0;
    
    pPppEapInput->fFlags & RAS_EAP_FLAG_MACHINE_AUTH ?
        pPeapCB->dwFlags |= PEAPCB_FLAG_MACHINE_AUTH:0;

    pPppEapInput->fFlags & RAS_EAP_FLAG_GUEST_ACCESS?
        pPeapCB->dwFlags |= PEAPCB_FLAG_GUEST_ACCESS :0;

    pPppEapInput->fFlags & RAS_EAP_FLAG_8021X_AUTH ?
        pPeapCB->dwFlags |= PEAPCB_FLAG_8021X_AUTH:0;
                                                    
    pPeapCB->hTokenImpersonateUser = pPppEapInput->hTokenImpersonateUser;

    if ( pPppEapInput->pwszPassword )
    {
        wcsncpy ( pPeapCB->awszPassword, pPppEapInput->pwszPassword, PWLEN );
    }

    if ( pPeapCB->dwFlags & PEAPCB_FLAG_SERVER )
    {
        //
        // Read Server Configuration from the registry
        //
        dwRetCode = PeapServerConfigDataIO(TRUE /* fRead */, NULL /* pwszMachineName */,
                    (BYTE**)&(pPeapCB->pUserProp), 0);
        if ( NO_ERROR != dwRetCode )
        {
            EapTlsTrace("Error reading server configuration. 0x%x", dwRetCode );
            goto LDone;
        }
        
        // 
        // For all configured PEAP types load EAPINFO 
        //
        dwRetCode = PeapGetFirstEntryUserProp ( pPeapCB->pUserProp, 
                                                &pEntryUserProp
                                              );

        if ( NO_ERROR != dwRetCode )
        {
            EapTlsTrace("Error PEAP not configured correctly. 0x%x", dwRetCode );
            goto LDone;
        }
        //
        // Get the selected EAP type
        //
        dwRetCode = PeapEapInfoCopyListNode (   pEntryUserProp->dwEapTypeId, 
                                                g_pEapInfo, 
                                                &pPeapCB->pEapInfo
                                            );
        if ( NO_ERROR != dwRetCode || NULL == pPeapCB->pEapInfo )
        {
            EapTlsTrace("Cannot find configured PEAP in the list of EAP Types on this machine.");
            goto LDone;
        }
        //
        // Check to see if we are enabled to do fast reconnect
        //
        if ( pPeapCB->pUserProp->dwFlags & PEAP_USER_FLAG_FAST_ROAMING )
        {
            pPeapCB->dwFlags |= PEAPCB_FAST_ROAMING;
        }

    }
    else
    {
        //
        // This is a client.  So get PEAP conn prop and
        // user prop
        //
        dwRetCode = PeapReadConnectionData( ( pPppEapInput->fFlags & RAS_EAP_FLAG_8021X_AUTH ),
                                            pPppEapInput->pConnectionData, 
                                            pPppEapInput->dwSizeOfConnectionData,
                                            &(pPeapCB->pConnProp)
                                          );

        if (NO_ERROR != dwRetCode)
        {
            EapTlsTrace("Error Reading Connection Data. 0x%x", dwRetCode);
            goto LDone;
        }
        //
        // Read user data now
        //

        dwRetCode = PeapReadUserData( pPppEapInput->pUserData,
                                      pPppEapInput->dwSizeOfUserData,
                                        &(pPeapCB->pUserProp)
                                    );
        if ( NO_ERROR != dwRetCode )
        {
            EapTlsTrace("Error Reading User Data. 0x%x", dwRetCode);
            goto LDone;
        }

        dwRetCode = PeapGetFirstEntryConnProp ( pPeapCB->pConnProp,
                                                &pEntryConnProp
                                              );
        if ( NO_ERROR != dwRetCode )
        {
            EapTlsTrace("Error PEAP not configured correctly. 0x%x", dwRetCode );
            goto LDone;
        }

        //
        // Get the selected EAP type
        //
        dwRetCode = PeapEapInfoCopyListNode (   pEntryConnProp->dwEapTypeId, 
                                                g_pEapInfo, 
                                                &pPeapCB->pEapInfo
                                            );
        if ( NO_ERROR != dwRetCode || NULL == pPeapCB->pEapInfo )
        {
            EapTlsTrace("Cannot find configured PEAP in the list of EAP Types on this machine.");
            goto LDone;
        }
        //
        // Check to see if we are enabled to do fast reconnect
        //
        

        if ( pPeapCB->pConnProp->dwFlags & PEAP_CONN_FLAG_FAST_ROAMING )
        {
            pPeapCB->dwFlags |= PEAPCB_FAST_ROAMING;
        }

    }

    //
    // Call Initialize and Begin for the
    // configured EAP type.
    // Call Begin for EapTls.
    // We need to create PPP_EAP_INFO for this
    //

    //
    // Call Begin for EapTlsBegin first
    //
    ZeroMemory ( &PppEapInputToTls, sizeof(PppEapInputToTls) );
    CopyMemory ( &PppEapInputToTls, pPppEapInput, sizeof(PppEapInputToTls) );

    PppEapInputToTls.dwSizeInBytes = sizeof(PppEapInputToTls);
    PppEapInputToTls.fFlags = pPppEapInput->fFlags | EAPTLSCB_FLAG_EXECUTING_PEAP;
    if ( pPeapCB->pConnProp )
    {
        //
        // Get the V0 struct required by eaptls
        //
        ConnPropGetV0Struct ( &(pPeapCB->pConnProp->EapTlsConnProp), 
                (EAPTLS_CONN_PROPERTIES **) &(PppEapInputToTls.pConnectionData) );
        PppEapInputToTls.dwSizeOfConnectionData = 
                ((EAPTLS_CONN_PROPERTIES *) (PppEapInputToTls.pConnectionData) )->dwSize;
    }

    ZeroMemory( &EapTlsUserProp, sizeof(EapTlsUserProp) );
    EapTlsUserProp.dwVersion = 1;
    EapTlsUserProp.dwSize = sizeof(EapTlsUserProp);
    CopyMemory ( &EapTlsUserProp.Hash, 
                 &(pPeapCB->pUserProp->CertHash),
                sizeof(EapTlsUserProp.Hash)
               );

    
    PppEapInputToTls.pUserData = (VOID *)&EapTlsUserProp;

    PppEapInputToTls.dwSizeOfUserData = sizeof(EapTlsUserProp);

    dwRetCode = EapTlsBegin (   (VOID **)&(pPeapCB->pEapTlsCB),
                                &PppEapInputToTls
                            );

    //
    // Save the identity for later use
    //
    wcsncpy(pPeapCB->awszIdentity,
                pPppEapInput->pwszIdentity ? pPppEapInput->pwszIdentity : L"", UNLEN + DNLEN);    

    *ppWorkBuffer = (VOID *)pPeapCB;    

LDone:
    if ( PppEapInputToTls.pConnectionData )
        LocalFree ( PppEapInputToTls.pConnectionData );
    EapTlsTrace("EapPeapBegin done");
    return dwRetCode;
}


DWORD
EapPeapEnd(
    IN  PPEAPCB   pPeapCb
)
{
    DWORD dwRetCode = NO_ERROR;
    EapTlsTrace("EapPeapEnd");
    //
    // call end for eaptls and each of the peap types
    // configured first and then execute code for 
    // peap end.
    if ( pPeapCb )
    {
        dwRetCode = EapTlsEnd((VOID *)pPeapCb->pEapTlsCB);

        //Call the embedded type's end here
        if ( pPeapCb->pEapInfo )
        {
            dwRetCode = pPeapCb->pEapInfo->PppEapInfo.RasEapEnd
                ( pPeapCb->pEapInfo->pWorkBuf);
            pPeapCb->pEapInfo->pWorkBuf = NULL;
            LocalFree ( pPeapCb->pEapInfo );
            pPeapCb->pEapInfo = NULL;
        }
        
        
        LocalFree ( pPeapCb->pConnProp );

        LocalFree ( pPeapCb->pUserProp );

        LocalFree ( pPeapCb->pUIContextData );

        if ( pPeapCb->pPrevReceivePacket )
        {
            LocalFree ( pPeapCb->pPrevReceivePacket );
        }

        if ( pPeapCb->pPrevDecData )
        {
            LocalFree ( pPeapCb->pPrevDecData );
        }

    #ifdef USE_CUSTOM_TUNNEL_KEYS
        if ( pPeapCb->hSendKey )
        {
            CryptDestroyKey ( pPeapCb->hSendKey );
        }
        if ( pPeapCb->hRecvKey )
        {
            CryptDestroyKey ( pPeapCb->hRecvKey );
        }
    #endif
        if ( pPeapCb->hProv )
        {
            CryptReleaseContext(pPeapCb->hProv, 0 );
        }
        if ( pPeapCb->pbIoBuffer )
        {
            LocalFree ( pPeapCb->pbIoBuffer );
        }
        LocalFree ( pPeapCb );
        pPeapCb = NULL;
    }
    EapTlsTrace("EapPeapEnd done");
    return dwRetCode;
}


//
// Check to see if this is a duplicate packet received.
//
BOOL
IsDuplicatePacket
(
 IN     PPEAPCB             pPeapCb,
 IN     PPP_EAP_PACKET *    pNewPacket
)
{
    BOOL        fRet = FALSE;
    WORD        wPacketLen = 0;

    EapTlsTrace("IsDuplicatePacket");

    wPacketLen = WireToHostFormat16 ( pNewPacket->Length );

    if ( wPacketLen == pPeapCb->cbPrevReceivePacket )
    {
        //
        // We have the same packet length
        // Now compare the packet and see 
        // if it is the same
        //
        if ( pPeapCb->pPrevReceivePacket )
        {
            if ( !memcmp( pNewPacket, pPeapCb->pPrevReceivePacket, wPacketLen ) )
            {
                //
                // we got a dup packet
                //
                EapTlsTrace("Got Duplicate Packet");
                fRet = TRUE;

            }
        }
    }

    return fRet;
}


DWORD
PeapDecryptTunnelData
(
 IN     PPEAPCB         pPeapCb,
 IN OUT PBYTE           pbData,
 IN     DWORD           dwSizeofData
)
{
    SecBufferDesc   SecBufferDesc;
    SecBuffer       SecBuffer[4];
    SECURITY_STATUS status;
    INT             i = 0;

    EapTlsTrace("PeapDecryptTunnelData dwSizeofData = 0x%x, pData = 0x%x", dwSizeofData, pbData);

    //
    // Use the schannel context to encrypt data
    // 
    SecBufferDesc.ulVersion = SECBUFFER_VERSION;
    SecBufferDesc.cBuffers = 4;
    SecBufferDesc.pBuffers = SecBuffer;


    SecBuffer[0].cbBuffer = dwSizeofData;
    SecBuffer[0].BufferType = SECBUFFER_DATA;
    SecBuffer[0].pvBuffer = pbData;

    SecBuffer[1].BufferType = SECBUFFER_EMPTY;
    SecBuffer[2].BufferType = SECBUFFER_EMPTY;
    SecBuffer[3].BufferType = SECBUFFER_EMPTY;

    status = DecryptMessage ( &(pPeapCb->pEapTlsCB->hContext),
                                &SecBufferDesc,
                                0,
                                0
                            );
    EapTlsTrace("PeapDecryptTunnelData completed with status 0x%x", status);

    if ( SEC_E_OK == status )
    {
        //
        // Copy over the decrypted data to our io buffer
        //
        while (  i < 4 )
        {
            if(SecBuffer[i].BufferType == SECBUFFER_DATA)
            {
                CopyMemory ( pPeapCb->pbIoBuffer,
                             SecBuffer[i].pvBuffer,
                             SecBuffer[i].cbBuffer
                           );

                pPeapCb->dwIoBufferLen = SecBuffer[i].cbBuffer;
                break;
            }
            i++;
        }
    }

    return status;

}


// 
// Use this function on client side.  
// This will first check to see if this is a duplicate packet
// If so, it will replace the current packet with duplicate
// one.  Or else it will continue with decryption
//
DWORD
PeapClientDecryptTunnelData
(
 IN     PPEAPCB         pPeapCb,
 IN     PPP_EAP_PACKET* pReceivePacket,
 IN     WORD            wOffset
)
{
    DWORD   dwRetCode = NO_ERROR;
    

    EapTlsTrace ("PeapClientDecryptTunnelData");

    if ( !pReceivePacket )
    {
        EapTlsTrace ("Got an empty packet");
        goto LDone;
    }
    if ( IsDuplicatePacket ( pPeapCb,
                             pReceivePacket
                           )
       )
    {
        //
        // Received a duplicate packet
        //
        // So set the data to what was decrypted in the past...
        //
        if ( pPeapCb->pPrevDecData )
        {
            CopyMemory (    &(pReceivePacket->Data[wOffset]),
                            pPeapCb->pPrevDecData,
                            pPeapCb->cbPrevDecData
                        );
            pPeapCb->pbIoBuffer = pPeapCb->pPrevDecData;
            pPeapCb->dwIoBufferLen = pPeapCb->cbPrevDecData;

            HostToWireFormat16 ( (WORD)(sizeof(PPP_EAP_PACKET) + pPeapCb->cbPrevDecData +1),
                                pReceivePacket->Length
                            );
        }
        else
        {
            EapTlsTrace("Got an unexpected duplicate packet");
            dwRetCode =    SEC_E_MESSAGE_ALTERED;
        }
    }
    else
    {
        if ( pPeapCb->pPrevReceivePacket )
        {
            LocalFree(pPeapCb->pPrevReceivePacket);
            pPeapCb->pPrevReceivePacket = NULL;
            pPeapCb->cbPrevReceivePacket = 0;
        }
        if ( pPeapCb->pPrevDecData )
        {
            LocalFree ( pPeapCb->pPrevDecData );
            pPeapCb->pPrevDecData = NULL;
            pPeapCb->cbPrevDecData = 0;
        }
        pPeapCb->pPrevReceivePacket = 
            (PPP_EAP_PACKET*)LocalAlloc(LPTR, WireToHostFormat16(pReceivePacket->Length) );
        if ( pPeapCb->pPrevReceivePacket )
        {
            pPeapCb->cbPrevReceivePacket = WireToHostFormat16(pReceivePacket->Length);
            CopyMemory ( pPeapCb->pPrevReceivePacket, 
                         pReceivePacket, 
                         pPeapCb->cbPrevReceivePacket 
                       );
        }
        //
        // Received a new packet.  So we need to decrypt it.
        //
        dwRetCode = PeapDecryptTunnelData ( pPeapCb,
                                            &(pReceivePacket->Data[2]),
                                            WireToHostFormat16(pReceivePacket->Length)
                                            - ( sizeof(PPP_EAP_PACKET) + 1 ) 
                                        );
        if ( NO_ERROR != dwRetCode )
        {
            // We could not decrypt the tunnel traffic
            // So we silently discard this packet.
            EapTlsTrace ("Failed to decrypt packet.");
            //
            // Wipe out the prev receive packet
            //
            if ( pPeapCb->pPrevReceivePacket )
            {
                LocalFree(pPeapCb->pPrevReceivePacket);
                pPeapCb->pPrevReceivePacket = NULL;
                pPeapCb->cbPrevReceivePacket = 0;
            }

            goto LDone;
        }

        CopyMemory (    &(pReceivePacket->Data[wOffset]),
                        pPeapCb->pbIoBuffer,
                        pPeapCb->dwIoBufferLen
                    );
        pPeapCb->pPrevDecData = (PBYTE)LocalAlloc (  LPTR, pPeapCb->dwIoBufferLen );
        if ( pPeapCb->pPrevDecData )
        {
            CopyMemory ( pPeapCb->pPrevDecData , 
                         pPeapCb->pbIoBuffer, 
                         pPeapCb->dwIoBufferLen
                        );
            pPeapCb->cbPrevDecData = (WORD)pPeapCb->dwIoBufferLen;
        }
        HostToWireFormat16 ( (WORD)(sizeof(PPP_EAP_PACKET) + pPeapCb->dwIoBufferLen +1),
                            pReceivePacket->Length
                        );
    }
LDone:
    return dwRetCode;
}
                            

DWORD
PeapEncryptTunnelData
(
 IN     PPEAPCB         pPeapCb,
 IN OUT PBYTE           pbData,
 IN     DWORD           dwSizeofData
)
{
    SecBufferDesc   SecBufferDesc;
    SecBuffer       SecBuffer[4];
    SECURITY_STATUS status;

    EapTlsTrace("PeapEncryptTunnelData");
    
    //
    // Use the schannel context to encrypt data
    // 
    SecBufferDesc.ulVersion = SECBUFFER_VERSION;
    SecBufferDesc.cBuffers = 4;
    SecBufferDesc.pBuffers = SecBuffer;

    SecBuffer[0].cbBuffer = pPeapCb->PkgStreamSizes.cbHeader;
    SecBuffer[0].BufferType = SECBUFFER_STREAM_HEADER;
    SecBuffer[0].pvBuffer = pPeapCb->pbIoBuffer;

    CopyMemory ( pPeapCb->pbIoBuffer+pPeapCb->PkgStreamSizes.cbHeader,
                 pbData,
                 dwSizeofData
               );

    SecBuffer[1].cbBuffer = dwSizeofData;
    SecBuffer[1].BufferType = SECBUFFER_DATA;
    SecBuffer[1].pvBuffer = pPeapCb->pbIoBuffer+pPeapCb->PkgStreamSizes.cbHeader;

    SecBuffer[2].cbBuffer = pPeapCb->PkgStreamSizes.cbTrailer;
    SecBuffer[2].BufferType = SECBUFFER_STREAM_TRAILER;
    SecBuffer[2].pvBuffer = pPeapCb->pbIoBuffer + pPeapCb->PkgStreamSizes.cbHeader + dwSizeofData;

    SecBuffer[3].BufferType = SECBUFFER_EMPTY;

    status = EncryptMessage ( &(pPeapCb->pEapTlsCB->hContext),
                                0,
                                &SecBufferDesc,
                                0
                            );
    pPeapCb->dwIoBufferLen =    SecBuffer[0].cbBuffer + 
                                SecBuffer[1].cbBuffer +
                                SecBuffer[2].cbBuffer ;
    EapTlsTrace("PeapEncryptTunnelData completed with status 0x%x", status);
    return status;
}


DWORD
PeapGetTunnelProperties 
(
IN  PPEAPCB         pPeapCb 
)
{
    SECURITY_STATUS         status;

    EapTlsTrace("PeapGetTunnelProperties");
    status = QueryContextAttributes 
                    ( &(pPeapCb->pEapTlsCB->hContext),
                      SECPKG_ATTR_CONNECTION_INFO,
                      &(pPeapCb->PkgConnInfo)
                    );
    if (SEC_E_OK != status)
    {
        EapTlsTrace ( "QueryContextAttributes for CONN_INFO failed with error 0x%x", status );
        goto LDone;
    }

    status = QueryContextAttributes 
                    ( &(pPeapCb->pEapTlsCB->hContext),
                      SECPKG_ATTR_STREAM_SIZES,
                      &(pPeapCb->PkgStreamSizes)
                    );
    if (SEC_E_OK != status)
    {
        EapTlsTrace ( "QueryContextAttributes for STREAM_SIZES failed with error 0x%x", status );
        goto LDone;
    }

    EapTlsTrace ( "Successfully negotiated TLS with following parameters"
                  "dwProtocol = 0x%x, Cipher= 0x%x, CipherStrength=0x%x, Hash=0x%x",
                  pPeapCb->PkgConnInfo.dwProtocol,
                  pPeapCb->PkgConnInfo.aiCipher,
                  pPeapCb->PkgConnInfo.dwCipherStrength,
                  pPeapCb->PkgConnInfo.aiHash
                );

    pPeapCb->pbIoBuffer = (PBYTE)LocalAlloc ( LPTR, 
                                    pPeapCb->PkgStreamSizes.cbHeader + 
                                    pPeapCb->PkgStreamSizes.cbTrailer + 
                                    pPeapCb->PkgStreamSizes.cbMaximumMessage
                                    );
    if ( NULL == pPeapCb->pbIoBuffer )
    {

        EapTlsTrace ( "Cannot allocate memory for IoBuffer");
        status = ERROR_OUTOFMEMORY;

    }
                                                        
LDone:
    EapTlsTrace("PeapGetTunnelProperties done");
    return status;
}


DWORD
EapPeapCMakeMessage(
    IN  PPEAPCB         pPeapCb,
    IN  PPP_EAP_PACKET* pReceivePacket,
    OUT PPP_EAP_PACKET* pSendPacket,
    IN  DWORD           cbSendPacket,
    OUT PPP_EAP_OUTPUT* pEapOutput,
    IN  PPP_EAP_INPUT*  pEapInput
)
{
    DWORD                                       dwRetCode = NO_ERROR;
    PPP_EAP_INPUT                               EapTypeInput;    
    WORD                                        wPacketLength;
    PEAP_ENTRY_CONN_PROPERTIES UNALIGNED *      pEntryConnProp = NULL;
    PEAP_ENTRY_USER_PROPERTIES UNALIGNED *      pEntryUserProp = NULL;
    PBYTE                                       pbCookie = NULL;
    DWORD                                       cbCookie = 0;
    BOOL                                        fIsReconnect = FALSE;
    BOOL                                        fReceivedTLV = FALSE;
    DWORD                                       dwVersion = 0;
    WORD                                        wValue = 0;
    BOOL                                        fImpersonating = FALSE;

    EapTlsTrace("EapPeapCMakeMessage");
    if ( !(pPeapCb->dwFlags & PEAPCB_FLAG_SERVER ) &&
         !(pPeapCb->dwFlags & PEAPCB_FLAG_ROUTER) &&  
         !(pPeapCb->dwFlags & PEAPCB_FLAG_MACHINE_AUTH ) &&
         !(pPeapCb->dwFlags & PEAPCB_FLAG_LOGON )
       )
    {
         if(!ImpersonateLoggedOnUser(pPeapCb->hTokenImpersonateUser) )
        {
            dwRetCode = GetLastError();
            EapTlsTrace ("PEAP: ImpersonateLoggedonUser failed and returned 0x%x", dwRetCode);
            return dwRetCode;
        }
        fImpersonating = TRUE;
    }
    switch ( pPeapCb->PeapState )
    {
    case PEAP_STATE_INITIAL:
        EapTlsTrace("PEAP:PEAP_STATE_INITIAL");
        //
        // Start the EapTls Conversation here.  
        //
        //Receive Packet will be NULL.  Call EapTlsSMakeMessage
        //
        if ( pReceivePacket )
        {
            pReceivePacket->Data[0] = PPP_EAP_TLS;
        }
        
        dwRetCode = EapTlsCMakeMessage( pPeapCb->pEapTlsCB,
                                        (EAPTLS_PACKET *)pReceivePacket, 
                                        (EAPTLS_PACKET *)pSendPacket,
                                        cbSendPacket,
                                        pEapOutput,
                                        pEapInput
                                      );
        if ( NO_ERROR == dwRetCode )
        {
            //change the packet to show peap
            pSendPacket->Data[0] = PPP_EAP_PEAP;
            if ( pReceivePacket )
                dwVersion = ((EAPTLS_PACKET *)pReceivePacket)->bFlags & 0x03;
            if ( dwVersion != EAPTLS_PACKET_CURRENT_VERSION )
            {
                ((EAPTLS_PACKET *)pSendPacket)->bFlags |= EAPTLS_PACKET_LOWEST_SUPPORTED_VERSION;
            }
            else
            {
                ((EAPTLS_PACKET *)pSendPacket)->bFlags |= EAPTLS_PACKET_CURRENT_VERSION;
            }
        }
        pPeapCb->PeapState = PEAP_STATE_TLS_INPROGRESS;
        break;

    case PEAP_STATE_TLS_INPROGRESS:
        EapTlsTrace("PEAP:PEAP_STATE_TLS_INPROGRESS");
        if ( pReceivePacket && 
             ( pReceivePacket->Code ==  EAPCODE_Request ||
               pReceivePacket->Code == EAPCODE_Response
             )
           )
        {
            pReceivePacket->Data[0] = PPP_EAP_TLS;
        }

        //
        // We could either get a TLV_Success Request or 
        // and identity request as a termination packet.  
        // Both of these are encrypted using the keys.
        // PAss them on to TLS and when it sends a success
        // back, decrypt to see if it was a success or 
        // identity.
        //
        
        dwRetCode = EapTlsCMakeMessage( pPeapCb->pEapTlsCB,
                                        (EAPTLS_PACKET *)pReceivePacket, 
                                        (EAPTLS_PACKET *)pSendPacket,
                                        cbSendPacket,
                                        pEapOutput,
                                        pEapInput
                                      );
        
        if ( NO_ERROR == dwRetCode )
        {          
            //
            // if interactive UI was requested, wrap the data in 
            // in PEAP interactive UI structure
            //
            if ( pEapOutput->fInvokeInteractiveUI )
            {
                if ( pPeapCb->pUIContextData )
                {
                    LocalFree ( pPeapCb->pUIContextData );
                    pPeapCb->pUIContextData = NULL;

                }
                pPeapCb->pUIContextData = (PPEAP_INTERACTIVE_UI) 
                            LocalAlloc(LPTR, 
                            sizeof(PEAP_INTERACTIVE_UI) + pEapOutput->dwSizeOfUIContextData );
                if ( NULL == pPeapCb->pUIContextData )
                {
                    EapTlsTrace("Error allocating memory for PEAP context data");
                    dwRetCode = ERROR_OUTOFMEMORY;
                    goto LDone;
                }
                pPeapCb->pUIContextData->dwEapTypeId = PPP_EAP_TLS;
                pPeapCb->pUIContextData->dwSizeofUIContextData 
                    = pEapOutput->dwSizeOfUIContextData;
                CopyMemory( pPeapCb->pUIContextData->bUIContextData,
                            pEapOutput->pUIContextData,
                            pEapOutput->dwSizeOfUIContextData
                          );
                pEapOutput->pUIContextData = (PBYTE)pPeapCb->pUIContextData;
                pEapOutput->dwSizeOfUIContextData = 
                    sizeof(PEAP_INTERACTIVE_UI) + pEapOutput->dwSizeOfUIContextData;
            }
            else if ( pEapOutput->Action == EAPACTION_Done )
            {                
                if ( pEapOutput->dwAuthResultCode == NO_ERROR )
                {
                    //
                    // PEAP auth was successful.  Carefully keep the MPPE 
                    // session keys returned so that we can encrypt the
                    // channel.  From now on everything will be encrypted.
                    //

                    // if we're enabled for fast reconnect check to see if this
                    // was a reconnect and see if the cookie is valid.
                    // 


                    //
                    // Check to see if we were send back a success or if we were send back an 
                    // identity request.
                    //
                    if ( !( pPeapCb->pEapTlsCB->fFlags & EAPTLSCB_FLAG_USING_CACHED_CREDS ) )
                    {
                        //
                        // If we are not using cached credentials
                        //
	                    SetCachedCredentials (pPeapCb->pEapTlsCB);
                    }

                    
                    pPeapCb->pTlsUserAttributes = pEapOutput->pUserAttributes;
                    dwRetCode = PeapGetTunnelProperties ( pPeapCb );
                    if (NO_ERROR != dwRetCode )
                    {                        
                        break;
                    }
                    pEapOutput->pUserAttributes = NULL;
                    pEapOutput->Action = EAPACTION_NoAction;


                    //
                    // Check to see if we need to save connection and user data
                    // for TLS
                    if ( pEapOutput->fSaveConnectionData )
                    {
                        //
                        // save connection data in PEAP control
                        // block and then finally when auth is done 
                        // We send back a save command.
                        // 
                        
                        if ( ConnPropGetV1Struct ( (EAPTLS_CONN_PROPERTIES *) pEapOutput->pConnectionData,
                                                &(pPeapCb->pNewTlsConnProp) ) == NO_ERROR )
                        {
                            pPeapCb->fTlsConnPropDirty = TRUE;
                        }                        
                        pEapOutput->fSaveConnectionData = FALSE;
                    }
                    if ( pEapOutput->fSaveUserData )
                    {
                        //
                        // There is nothing to save in user data for PEAP.
                        // But the flag is left here just in case...
                        pPeapCb->fTlsUserPropDirty = TRUE;
                        pEapOutput->fSaveUserData = FALSE;
                    }
    case PEAP_STATE_FAST_ROAMING_IDENTITY_REQUEST:
                    //
                    // EAPTLS terminated with an identity request
                    // so process the received identity request here
                    if ( pReceivePacket )
                    {
                        //
                        // This can be either an identity packet or
                        // an TLV_Success packet.
                        //
                        dwRetCode = PeapClientDecryptTunnelData(pPeapCb,pReceivePacket, 2);
                        if ( NO_ERROR != dwRetCode )
                        {
                            EapTlsTrace("PeapDecryptTunnelData failed: silently discarding packet");
                            dwRetCode = NO_ERROR;
                            pEapOutput->Action = EAPACTION_NoAction;                
                            break;
                        }
/*

                        wPacketLength = WireToHostFormat16(pReceivePacket->Length);
                        dwRetCode = PeapDecryptTunnelData ( pPeapCb,
                                                            &(pReceivePacket->Data[2]),
                                                            wPacketLength 
                                                            - ( sizeof(PPP_EAP_PACKET) + 1 ) 
                                                        );
                        if ( NO_ERROR != dwRetCode )
                        {
                            // We could not decrypt the tunnel traffic
                            // So we silently discard this packet.
                            EapTlsTrace("PeapDecryptTunnelData failed: silently discarding packet");
                            dwRetCode = NO_ERROR;
                            pEapOutput->Action = EAPACTION_NoAction;                
                            break;
                        }
                        CopyMemory (    &(pReceivePacket->Data[2]),
                                        pPeapCb->pbIoBuffer,
                                        pPeapCb->dwIoBufferLen
                                    );

                        HostToWireFormat16 ( (WORD)(sizeof(PPP_EAP_PACKET) + pPeapCb->dwIoBufferLen +1),
                                            pReceivePacket->Length
                                        );
*/                      
                        pReceivePacket->Data[0] = PPP_EAP_PEAP;
                        //This is an AVP message
                        if ( pReceivePacket->Data[8] == MS_PEAP_AVP_TYPE_STATUS && 
                             pReceivePacket->Data[6] == PEAP_TYPE_AVP 
                           ) 
                        {
                            //This is a TLV message

                            dwRetCode =  GetPEAPTLVStatusMessageValue ( pPeapCb, 
                                                                        pReceivePacket, 
                                                                        &wValue 
                                                                      );
                            if ( NO_ERROR != dwRetCode || wValue != MS_PEAP_AVP_VALUE_SUCCESS )
                            {
                                EapTlsTrace("Got invalid TLV when expecting TLV_SUCCESS.  Silently discarding.");
                                dwRetCode = NO_ERROR;
                                pEapOutput->Action = EAPACTION_NoAction;                
                                break;
                            }

                            

                            //
                            // Check to see if this is a success.  If this is a success, server wants to
                            // do fast roaming.  Check to see if this is a fast reconnect and 
                            // if this is a fast reconnect, get cookie and compare it
                            // if all's fine then send a success response or else send a failure
                            // response.  If none of this works then fail auth with an internal 
                            // error.
                            //
                            if ( pPeapCb->dwFlags &  PEAPCB_FAST_ROAMING )
                            {
                                dwRetCode = GetTLSSessionCookie ( pPeapCb->pEapTlsCB,
                                                                    &pbCookie,
                                                                    &cbCookie,
                                                                    &fIsReconnect
                                                                );
                                if ( NO_ERROR != dwRetCode)
                                {
                                    //There was an error getting session cookie.
                                    //Or there is no cookie and this is a reconnet
                                    // So fail the request.
                                    EapTlsTrace("Error getting cookie for a reconnected session.  Failing auth");
                                    // We cannot encrypt and send stuff across here.  
                                    // Reconnected Session state is invalid.                                    
                                    pEapOutput->dwAuthResultCode = dwRetCode;
                                    pPeapCb->PeapState = PEAP_STATE_EAP_TYPE_FINISHED;
                                    pEapOutput->Action = EAPACTION_Done;                                    
                                    break;
                                }

                                if ( fIsReconnect )
                                {
                                    if ( cbCookie == 0 )
                                    {

                                        //There was an error getting session cookie.
                                        //Or there is no cookie and this is a reconnet
                                        // So fail the request.
                                        EapTlsTrace("Error getting cookie for a reconnected session.  Failing auth");
                                        dwRetCode = SetTLSFastReconnect ( pPeapCb->pEapTlsCB , FALSE);
                                        // We cannot encrypt and send stuff across here.  
                                        // Reconnected Session state is invalid.
                                        dwRetCode = ERROR_INTERNAL_ERROR;
                                        pEapOutput->dwAuthResultCode = dwRetCode;
                                        pPeapCb->PeapState = PEAP_STATE_EAP_TYPE_FINISHED;
                                        pEapOutput->Action = EAPACTION_Done;                                    
                                        break;
                                    }

                                    //
                                    // This is a server
                                    // Check to see if the cookie is fine.  
                                    // If it is fine then there is no need to reauth.
                                    // So send back a PEAP_SUCCESS response packet
                                    // and change our state to PEAP_SUCCESS_SEND
                                    // 
                                    EapTlsTrace ("TLS session fast reconnected");
                                    dwRetCode = PeapCheckCookie ( pPeapCb, (PPEAP_COOKIE)pbCookie, cbCookie );
                                    if ( NO_ERROR != dwRetCode )
                                    {
                                        
                                        //
                                        // So invalidate the session for fast reconnect
                                        // and fail auth.  Next time a full reconnect will happen
                                        //
                                        dwRetCode = SetTLSFastReconnect ( pPeapCb->pEapTlsCB , FALSE);
                                        if ( NO_ERROR != dwRetCode )
                                        {                                
                                            //
                                            // This is an internal error 
                                            // So disconnect the session.
                                            //
                                            pEapOutput->dwAuthResultCode = dwRetCode;
                                            pEapOutput->Action = EAPACTION_Done;
                                            pPeapCb->PeapState = PEAP_STATE_EAP_TYPE_FINISHED;
                                            break;
                                        }
                                        EapTlsTrace ("Error validating the cookie.  Failing auth");
                                        pEapOutput->dwAuthResultCode = dwRetCode;
                                        pPeapCb->PeapState = PEAP_STATE_EAP_TYPE_FINISHED;
                                        pEapOutput->Action = EAPACTION_Done;
                                        break;

                                    }
                                    else
                                    {
                                        //
                                        // Cookie is fine.
                                        //
                                        //
                                        // Send a PEAP success  TLV response.  
                                        //

                                        dwRetCode = CreatePEAPTLVStatusMessage ( pPeapCb,
                                                                    pSendPacket, 
                                                                    cbSendPacket,
                                                                    FALSE,          //Response
                                                                    MS_PEAP_AVP_VALUE_SUCCESS
                                                                );
                                        if ( NO_ERROR != dwRetCode )
                                        {
                                            // Internal error
                                            break;
                                        }
                                        
                                        pEapOutput->Action = EAPACTION_Send;
                                        pPeapCb->PeapState = PEAP_STATE_PEAP_SUCCESS_SEND;
                                        pPeapCb->dwAuthResultCode = NO_ERROR;
                                        break;
                                    }
                                }
                                else
                                {
                                    // server is expecting fast roaming and we are not configured to do it.
                                    // send a fail tlv here
                                    EapTlsTrace("Server expects fast roaming and we dont.  Sending PEAP_Failure");
                                    dwRetCode = CreatePEAPTLVStatusMessage ( pPeapCb,
                                                                pSendPacket, 
                                                                cbSendPacket,
                                                                FALSE,          //Response
                                                                MS_PEAP_AVP_VALUE_FAILURE
                                                            );
                                    if ( NO_ERROR != dwRetCode )
                                    {
                                        // Internal error
                                        break;
                                    }

                                    
                                    pEapOutput->Action = EAPACTION_Send;
                                    pPeapCb->PeapState = PEAP_STATE_FAST_ROAMING_IDENTITY_REQUEST;
                                    pPeapCb->dwAuthResultCode = NO_ERROR;
                                    break;                                   
                                }
                            }
                            else
                            {
                                // Server is requesting fast roaming but we're not setup to do so.
                                // So send back a fail request so that the auth fails.
                                dwRetCode = CreatePEAPTLVStatusMessage ( pPeapCb,
                                                            pSendPacket, 
                                                            cbSendPacket,
                                                            FALSE,          //Response
                                                            MS_PEAP_AVP_VALUE_FAILURE
                                                        );
                                if ( NO_ERROR != dwRetCode )
                                {
                                    // Internal error
                                    break;
                                }
                                //
                                // We can expect to get back an encrypted identity request 
                                // Since the client is not setup to do fast roaming and the
                                // server is, we fail the success and expect identity
                                // request.
                                //
                                pEapOutput->Action = EAPACTION_Send;
                                pPeapCb->PeapState = PEAP_STATE_FAST_ROAMING_IDENTITY_REQUEST;
                                pPeapCb->dwAuthResultCode = NO_ERROR;
                                break;

                            }
                            break;
                        }
                        else
                        {

                            if ( pReceivePacket->Data[2] != PEAP_EAPTYPE_IDENTITY )
                            {
                                EapTlsTrace ("Got unexpected packet when expecting PEAP identity request.  Silently discarding packet.");
                                dwRetCode = NO_ERROR;
                                pEapOutput->Action = EAPACTION_NoAction;
                                break;
                            }
                        }
                        //If we've come this far, it must be an identity request.
                        pSendPacket->Code = EAPCODE_Response;
                        pSendPacket->Id = pReceivePacket->Id;
                        CopyMemory (    pPeapCb->awszTypeIdentity,
                                        pPeapCb->awszIdentity,
                                        ( DNLEN+ UNLEN) * sizeof(WCHAR)
                                    );

                        //
                        //length = sizeof header + 1 byte for code identity + strlen of identity
                        //

                        pSendPacket->Data[0] = PPP_EAP_PEAP;
                        pSendPacket->Data[1] = EAPTLS_PACKET_CURRENT_VERSION;
                        pSendPacket->Data[2] = PEAP_EAPTYPE_IDENTITY;

                        //copy the identity over
                        if ( 0 == WideCharToMultiByte(
                                       CP_ACP,
                                       0,
                                       pPeapCb->awszIdentity,
                                       -1,
                                       (LPSTR)&(pSendPacket->Data[3]),
                                       UNLEN + DNLEN+ 1,
                                       NULL,
                                       NULL ) 
                         )
                        {
                            //
                            // This is an internal error.  There is no concept of PEAP_SUCCESS/FAIL TLV here.
                            //
                            dwRetCode = GetLastError();
                            EapTlsTrace("Unable to convert from widechar to multibyte 0x%x", dwRetCode );
                            goto LDone;
                        }

                        dwRetCode = PeapEncryptTunnelData ( pPeapCb,
                                                            &(pSendPacket->Data[2]),
                                                            1+wcslen(pPeapCb->awszIdentity)
                                                          );
                        if ( NO_ERROR != dwRetCode )
                        {                            
                            break;
                        }

                        //Copy over the encrypted data into send buffer
                        CopyMemory (    &(pSendPacket->Data[2]), 
                                        pPeapCb->pbIoBuffer, 
                                        pPeapCb->dwIoBufferLen 
                                   );

                        HostToWireFormat16
                        (
                            (WORD)(sizeof(PPP_EAP_PACKET)+  1 +pPeapCb->dwIoBufferLen),
                            pSendPacket->Length
                        );
                       
                        pEapOutput->Action = EAPACTION_Send;
                        pPeapCb->PeapState = PEAP_STATE_IDENTITY_RESPONSE_SENT;
                    }
                    else
                    {
                        pEapOutput->Action = EAPACTION_NoAction;
                        EapTlsTrace("Got empty packet when expecting identity request.  Ignoring.");
                    }                    
                }                
            }
            else
            {
                //change the packet to show peap
                pSendPacket->Data[0] = PPP_EAP_PEAP;
            }
        }        
        break;
    case PEAP_STATE_IDENTITY_RESPONSE_SENT:
        EapTlsTrace("PEAP:PEAP_STATE_IDENTITY_RESPONSE_SENT");
        //
        // Call begin for eap dll
        //
        // Check to see if we are configured to do this eap type.
        // if not send a NAK back with desired EAP type.
        //

        if ( !pPeapCb->fInvokedInteractiveUI )
        {
            if ( pReceivePacket && pReceivePacket->Code != EAPCODE_Failure )
            {
                dwRetCode = PeapClientDecryptTunnelData ( pPeapCb, pReceivePacket, 0);
                if ( NO_ERROR != dwRetCode )
                {
                    EapTlsTrace("PeapDecryptTunnelData failed: silently discarding packet");
                    dwRetCode = NO_ERROR;
                    pEapOutput->Action = EAPACTION_NoAction;                
                    break;
                }
    /*
                wPacketLength = WireToHostFormat16( pReceivePacket->Length );

                dwRetCode = PeapDecryptTunnelData ( pPeapCb,
                                                    &(pReceivePacket->Data[2]),
                                                    wPacketLength 
                                                    - ( sizeof(PPP_EAP_PACKET) + 1 )
                                                );
                if ( NO_ERROR != dwRetCode )
                {
                    // We could not decrypt the tunnel traffic
                    // So we silently discard this packet.
                    EapTlsTrace("PeapDecryptTunnelData failed: silently discarding packet");
                    dwRetCode = NO_ERROR;
                    pEapOutput->Action = EAPACTION_NoAction;                
                    break;
                }
                
                CopyMemory (   pReceivePacket->Data,
                            pPeapCb->pbIoBuffer,
                            pPeapCb->dwIoBufferLen
                        );

                HostToWireFormat16 ( (WORD)(sizeof(PPP_EAP_PACKET) + pPeapCb->dwIoBufferLen -1),
                                    pReceivePacket->Length
                                );
    */
            }
            else if ( pReceivePacket && pReceivePacket->Code == EAPCODE_Failure )
            {
                //
                // Fail auth because we have not yet got the Success/Fail TLV 
                // The server may not be configured to handle this EAP Type.
                //
                EapTlsTrace ( "Got a failure when negotiating EAP types in PEAP.");
                pEapOutput->Action = EAPACTION_Done;
                pEapOutput->dwAuthResultCode = ERROR_AUTHENTICATION_FAILURE;
                break;
            }

        }

        
        if ( pReceivePacket && 
             pReceivePacket->Code != EAPCODE_Request

           )
        {
            EapTlsTrace("Invalid packet received. Ignoring");
            pEapOutput->Action = EAPACTION_NoAction;
        }
        else
        {
            //
            // Check to see if this is a TLV packet other than success/fail.
            // If so, send back a NAK.
            //

            if ( !pPeapCb->fInvokedInteractiveUI  &&
                 pPeapCb->pEapInfo->dwTypeId != pReceivePacket->Data[0] )
            {
                //Send a NAK back with the desired typeid
                pSendPacket->Code = EAPCODE_Response;
                pSendPacket->Id = pReceivePacket->Id;
                pSendPacket->Data[0] = PPP_EAP_PEAP;
                pSendPacket->Data[1] = EAPTLS_PACKET_CURRENT_VERSION;
                pSendPacket->Data[2] = PEAP_EAPTYPE_NAK;
                pSendPacket->Data[3] = (BYTE)pPeapCb->pEapInfo->dwTypeId;


                //Encrypt 2 bytes of our NAK
                dwRetCode = PeapEncryptTunnelData ( pPeapCb,
                                                    &(pSendPacket->Data[2]),
                                                    2
                                                );
                if ( NO_ERROR != dwRetCode )
                {
                    //
                    // This is an internal error.  Cant do much here but to drop the
                    // connection.
                    //
                    break;
                }
                //
                // Copy over the buffer and readjust the lengths
                //
                CopyMemory ( &(pSendPacket->Data[2]), 
                            pPeapCb->pbIoBuffer, 
                            pPeapCb->dwIoBufferLen );

                HostToWireFormat16
                (
                    (WORD)(sizeof(PPP_EAP_PACKET) + 1 +pPeapCb->dwIoBufferLen),
                    pSendPacket->Length
                );


                pEapOutput->Action = EAPACTION_Send;
            }
            else
            {
                //call begin and then make message
                ZeroMemory ( &EapTypeInput, sizeof(EapTypeInput) );
                CopyMemory( &EapTypeInput, pEapInput, sizeof(EapTypeInput) );
                EapTypeInput.pwszIdentity = pPeapCb->awszTypeIdentity;
                
                if ( !pPeapCb->fInvokedInteractiveUI )
                {
                    //
                    // Set the user and connection data from peap cb 
                    //
                    dwRetCode = PeapGetFirstEntryConnProp ( pPeapCb->pConnProp,
                                                            &pEntryConnProp
                                                        );
                    if ( NO_ERROR != dwRetCode )
                    {
                        EapTlsTrace("Error getting entry connection properties. 0x%x", dwRetCode);
                        goto LDone;
                    }
                    dwRetCode = PeapGetFirstEntryUserProp ( pPeapCb->pUserProp,
                                                            &pEntryUserProp
                                                        );
                    if ( NO_ERROR != dwRetCode )
                    {
                        EapTlsTrace("Error getting entry user properties. 0x%x", dwRetCode);
                        goto LDone;
                    }
                    EapTypeInput.pConnectionData = pEntryConnProp->bData;
                    EapTypeInput.hTokenImpersonateUser = pPeapCb->hTokenImpersonateUser;

                    EapTypeInput.dwSizeOfConnectionData = 
                        pEntryConnProp->dwSize - sizeof(PEAP_ENTRY_CONN_PROPERTIES) + 1;

                    pPeapCb->dwFlags & PEAPCB_FLAG_ROUTER? 
                        EapTypeInput.fFlags |= RAS_EAP_FLAG_ROUTER :0;

                    pPeapCb->dwFlags & PEAPCB_FLAG_NON_INTERACTIVE?
                        EapTypeInput.fFlags |= RAS_EAP_FLAG_NON_INTERACTIVE:0;

                    pPeapCb->dwFlags & PEAPCB_FLAG_LOGON?
                        EapTypeInput.fFlags |= RAS_EAP_FLAG_LOGON :0;

                    pPeapCb->dwFlags & PEAPCB_FLAG_PREVIEW ?
                        EapTypeInput.fFlags |= RAS_EAP_FLAG_PREVIEW:0;

                    pPeapCb->dwFlags & PEAPCB_FLAG_FIRST_LINK?
                        EapTypeInput.fFlags |= RAS_EAP_FLAG_FIRST_LINK :0;
        
                    pPeapCb->dwFlags & PEAPCB_FLAG_MACHINE_AUTH ?
                        EapTypeInput.fFlags |= RAS_EAP_FLAG_MACHINE_AUTH:0;

                    pPeapCb->dwFlags & PEAPCB_FLAG_GUEST_ACCESS?
                        EapTypeInput.fFlags |= RAS_EAP_FLAG_GUEST_ACCESS :0;

                    pPeapCb->dwFlags & PEAPCB_FLAG_8021X_AUTH ?
                        EapTypeInput.fFlags |= RAS_EAP_FLAG_8021X_AUTH:0;

                    if ( pEntryUserProp->fUsingPeapDefault )
                    {
                        PPEAP_DEFAULT_CREDENTIALS pDefaultCred = 
                            (PPEAP_DEFAULT_CREDENTIALS)pEntryUserProp->bData;
                        // 
                        // there is no user data to send in this case.
                        // just set the identity and password.
                        //
                        EapTypeInput.pwszPassword = pDefaultCred->wszPassword;

                    }
                    else
                    {
                    
                        EapTypeInput.pUserData = pEntryUserProp->bData;
                        EapTypeInput.dwSizeOfUserData = 
                            pEntryUserProp->dwSize - sizeof(PEAP_ENTRY_USER_PROPERTIES) + 1;
                    }
                    if ( pPeapCb->awszPassword[0] )
                    {
                        EapTypeInput.pwszPassword = pPeapCb->awszPassword;
                    }
                    
                    EapTypeInput.bInitialId = pReceivePacket->Id;
                    //Call begin function 
                    dwRetCode = pPeapCb->pEapInfo->PppEapInfo.RasEapBegin( &(pPeapCb->pEapInfo->pWorkBuf ),
                                                                        &EapTypeInput
                                                                        );
                }
                if ( NO_ERROR == dwRetCode )
                {
                    if ( pPeapCb->fInvokedInteractiveUI )
                    {
                        pPeapCb->fInvokedInteractiveUI = FALSE;
                    }
                    //Call make message now
                    dwRetCode = pPeapCb->pEapInfo->PppEapInfo.RasEapMakeMessage
                        (   pPeapCb->pEapInfo->pWorkBuf,
                            pReceivePacket,
                            pSendPacket,
                            cbSendPacket-200,
                            pEapOutput,
                            &EapTypeInput
                        );
                    if ( NO_ERROR == dwRetCode )
                    {
                        if ( pEapOutput->fInvokeInteractiveUI )
                        {
                            if ( pPeapCb->pUIContextData )
                            {
                                LocalFree ( pPeapCb->pUIContextData );
                                pPeapCb->pUIContextData = NULL;

                            }
                            pPeapCb->pUIContextData = (PPEAP_INTERACTIVE_UI) 
                                        LocalAlloc(LPTR, 
                                        sizeof(PEAP_INTERACTIVE_UI) + pEapOutput->dwSizeOfUIContextData );
                            if ( NULL == pPeapCb->pUIContextData )
                            {
                                EapTlsTrace("Error allocating memory for PEAP context data");
                                dwRetCode = ERROR_OUTOFMEMORY;
                                goto LDone;
                            }
                            pPeapCb->pUIContextData->dwEapTypeId = pPeapCb->pEapInfo->dwTypeId;
                            pPeapCb->pUIContextData->dwSizeofUIContextData 
                                = pEapOutput->dwSizeOfUIContextData;
                            CopyMemory( pPeapCb->pUIContextData->bUIContextData,
                                        pEapOutput->pUIContextData,
                                        pEapOutput->dwSizeOfUIContextData
                                    );
                            pEapOutput->pUIContextData = (PBYTE)pPeapCb->pUIContextData;
                            pEapOutput->dwSizeOfUIContextData = 
                                sizeof(PEAP_INTERACTIVE_UI) + pEapOutput->dwSizeOfUIContextData;
                            pPeapCb->fInvokedInteractiveUI = TRUE;

                        }    
                        else 
                        {
                            wPacketLength = WireToHostFormat16(pSendPacket->Length);

                            dwRetCode = PeapEncryptTunnelData ( pPeapCb,
                                                                &(pSendPacket->Data[0]),
                                                                wPacketLength -sizeof(PPP_EAP_PACKET)+1
                                                            );
                            if ( NO_ERROR != dwRetCode )
                            {
                                //
                                // This is an internal error.  
                                // Cant do much here but to terminate connection
                                //
                                break;
                            }
                            pSendPacket->Data[0] = PPP_EAP_PEAP;
                            pSendPacket->Data[1] = EAPTLS_PACKET_CURRENT_VERSION;

                            CopyMemory (    &(pSendPacket->Data[2]), 
                                            pPeapCb->pbIoBuffer,
                                            pPeapCb->dwIoBufferLen
                                    );
                            HostToWireFormat16
                            (   (WORD)(sizeof(PPP_EAP_PACKET)+1+pPeapCb->dwIoBufferLen),
                                pSendPacket->Length
                            );
                            
                            //Set the Id of the packet send.  This should have been set 
                            //by the eap type.
                            pPeapCb->bId = pSendPacket->Id;


                            pPeapCb->PeapState = PEAP_STATE_EAP_TYPE_INPROGRESS;
                        }
                    }
                    else
                    {
                        EapTlsTrace (   "EapType %d failed in RasEapMakeMEssage and returned 0x%x", 
                            pPeapCb->pEapInfo->dwTypeId, 
                            dwRetCode 
                        );
                    }
                }
                else
                {
                    EapTlsTrace (   "EapType %d failed in RasEapBegin and returned 0x%x", 
                                    pPeapCb->pEapInfo->dwTypeId, 
                                    dwRetCode 
                                );
                    
                    //
                    // Send a PEAP failure here and wait for response from server.
                    //
                    pEapOutput->dwAuthResultCode = dwRetCode;
                    pEapOutput->Action = EAPACTION_Done;
                    pPeapCb->PeapState = PEAP_STATE_EAP_TYPE_FINISHED;
                }        

            }
            
        }
            
        
        break;
    case PEAP_STATE_EAP_TYPE_INPROGRESS:
        EapTlsTrace("PEAP:PEAP_STATE_EAP_TYPE_INPROGRESS");

        if ( pPeapCb->fInvokedInteractiveUI && !pEapInput->fDataReceivedFromInteractiveUI)
        {
            EapTlsTrace("Waiting on interactive UI.  Discarding packets sliently...");
            pEapOutput->Action = EAPACTION_NoAction;
            break;
        }
        ZeroMemory ( &EapTypeInput, sizeof(EapTypeInput) );

        CopyMemory( &EapTypeInput, pEapInput, sizeof(EapTypeInput) );

        EapTypeInput.pwszIdentity = pPeapCb->awszTypeIdentity;

        EapTypeInput.hTokenImpersonateUser = pPeapCb->hTokenImpersonateUser;
        

        // if we are executing interactive ui ,pReceivePacket will be NULL
        //
        if ( pReceivePacket && !pPeapCb->fInvokedInteractiveUI )
        {
            //Decrypt the packet

            if ( pReceivePacket->Code != EAPCODE_Success && 
                 pReceivePacket->Code != EAPCODE_Failure)
            {
                dwRetCode = PeapClientDecryptTunnelData ( pPeapCb, pReceivePacket, 2);
                if ( NO_ERROR != dwRetCode )
                {
                    EapTlsTrace("PeapDecryptTunnelData failed: silently discarding packet");
                    dwRetCode = NO_ERROR;
                    pEapOutput->Action = EAPACTION_NoAction;                
                    break;
                }
/*
                wPacketLength = WireToHostFormat16( pReceivePacket->Length );

                dwRetCode = PeapDecryptTunnelData ( pPeapCb,
                                                    &(pReceivePacket->Data[2]),
                                                    wPacketLength - ( sizeof(PPP_EAP_PACKET) + 1 )
                                                  );
                if ( NO_ERROR != dwRetCode )
                {
                    // We could not decrypt the tunnel traffic
                    // So we silently discard this packet.
                    EapTlsTrace("PeapDecryptTunnelData failed: silently discarding packet");
                    dwRetCode = NO_ERROR;
                    pEapOutput->Action = EAPACTION_NoAction;                
                    break;
                }
*/
                if ( pPeapCb->pbIoBuffer[6] == MS_PEAP_AVP_TYPE_STATUS && 
                     pPeapCb->pbIoBuffer[4] == PEAP_TYPE_AVP 
                   ) 
                {
                    wValue = 0;
                    CopyMemory ( &(pReceivePacket->Data[2]),
                                pPeapCb->pbIoBuffer,
                                pPeapCb->dwIoBufferLen
                            );
                    HostToWireFormat16 ( (WORD)( sizeof(PPP_EAP_PACKET) + 1 + pPeapCb->dwIoBufferLen),
                                        pReceivePacket->Length
                                    );
                    //
                    // This is a TLV.  So the auth succeeded or failed.
                    // Send a manufactured success or fail to the current  
                    // EAP type and then based on what the EAP type returns
                    // send a PEAP success/fail to the server.  Change the 
                    // state then to accept the EAP success or failure.
                    //
                    
                    
                    dwRetCode = GetPEAPTLVStatusMessageValue ( pPeapCb, 
                                                               pReceivePacket, 
                                                               &wValue 
                                                             );
                    if ( NO_ERROR == dwRetCode )
                    {                                                
                        if ( wValue == MS_PEAP_AVP_VALUE_SUCCESS )
                        {
                            pReceivePacket->Code = EAPCODE_Success;
                            EapTypeInput.fSuccessPacketReceived = TRUE;
                        }
                        else if ( wValue == MS_PEAP_AVP_VALUE_FAILURE )
                        {
                            pReceivePacket->Code = EAPCODE_Failure;
                        }
                        else
                        {
                            EapTlsTrace("Got an unrecognized TLV Message.  Silently discarding the packet");
                            dwRetCode = NO_ERROR;
                            break;
                        }
                        pPeapCb->fReceivedTLVSuccessFail = TRUE;
                        HostToWireFormat16 ( (WORD)4, pReceivePacket->Length );

                    }
                    else
                    {
                        EapTlsTrace("Got an unrecognized TLV Message.  Silently discarding the packet");
                        dwRetCode = NO_ERROR;
                        break;
                    }

                }
                else
                {
                    //
                    // Check to see if it is any type of TLV message
                    // We send a NAK back for any TLV message other than status
                    //
                    //
                    if ( fIsPEAPTLVMessage ( pPeapCb, pReceivePacket ) )
                    {
                        //Send back a NAK
                        dwRetCode =  CreatePEAPTLVNAKMessage (  pPeapCb,                                                            
                                                                pSendPacket, 
                                                                cbSendPacket
                                                        );
                        if ( NO_ERROR != dwRetCode )
                        {
                            // this is an internal error.  So cannot do much here 
                            // but to fail auth
                            EapTlsTrace ( "Error creating TLV NAK message.  Failing auth");                            
                        }

                        break;

                    }
                    else
                    {

                        CopyMemory ( pReceivePacket->Data,
                                    pPeapCb->pbIoBuffer,
                                    pPeapCb->dwIoBufferLen
                                );
                        HostToWireFormat16 ( (WORD)(sizeof(PPP_EAP_PACKET) + pPeapCb->dwIoBufferLen-1),
                                            pReceivePacket->Length
                                        );
                    }
                }
            }
            else
            {
                pReceivePacket->Data[0] = (BYTE)pPeapCb->pEapInfo->dwTypeId;
            }
            
        }
        if ( pEapInput->fDataReceivedFromInteractiveUI )
        {
            //we are done with interactive UI stuff...
            pPeapCb->fInvokedInteractiveUI = FALSE;
        }

        dwRetCode = pPeapCb->pEapInfo->PppEapInfo.RasEapMakeMessage
            (   pPeapCb->pEapInfo->pWorkBuf,
                pReceivePacket,
                pSendPacket,
                cbSendPacket-200,
                pEapOutput,
                &EapTypeInput
            );
        if ( NO_ERROR == dwRetCode )
        {

            //
            // if interactive UI was requested, wrap the data in 
            // in PEAP interactive UI structure
            //
            if ( pEapOutput->fInvokeInteractiveUI )
            {
                if ( pPeapCb->pUIContextData )
                {
                    LocalFree ( pPeapCb->pUIContextData );
                    pPeapCb->pUIContextData = NULL;

                }
                pPeapCb->pUIContextData = (PPEAP_INTERACTIVE_UI) 
                            LocalAlloc(LPTR, 
                            sizeof(PEAP_INTERACTIVE_UI) + pEapOutput->dwSizeOfUIContextData );
                if ( NULL == pPeapCb->pUIContextData )
                {
                    EapTlsTrace("Error allocating memory for PEAP context data");
                    dwRetCode = ERROR_OUTOFMEMORY;
                    goto LDone;
                }
                pPeapCb->pUIContextData->dwEapTypeId = pPeapCb->pEapInfo->dwTypeId;
                pPeapCb->pUIContextData->dwSizeofUIContextData 
                    = pEapOutput->dwSizeOfUIContextData;
                CopyMemory( pPeapCb->pUIContextData->bUIContextData,
                            pEapOutput->pUIContextData,
                            pEapOutput->dwSizeOfUIContextData
                          );
                pEapOutput->pUIContextData = (PBYTE)pPeapCb->pUIContextData;
                pEapOutput->dwSizeOfUIContextData = 
                    sizeof(PEAP_INTERACTIVE_UI) + pEapOutput->dwSizeOfUIContextData;
                pPeapCb->fInvokedInteractiveUI = TRUE;

            }    
            else if ( pEapOutput->Action == EAPACTION_Done || pEapOutput->Action == EAPACTION_Send )
            {
                if ( pEapOutput->Action == EAPACTION_Done  )
                {
                    // We are done with auth.  
                    if ( pPeapCb->fReceivedTLVSuccessFail != TRUE )
                    {
                        //
                        // Check to see what is the Auth result.  
                        // Based on that, we should send back a 
                        // PEAPSuccess / Fail
                        //
                        EapTlsTrace ("Failing Auth because we got a success/fail without TLV.");
                        dwRetCode = ERROR_INTERNAL_ERROR;
                        pPeapCb->fReceivedTLVSuccessFail = FALSE;
                        break;
                    }
                    pPeapCb->dwAuthResultCode = pEapOutput->dwAuthResultCode;
                    
                    dwRetCode = CreatePEAPTLVStatusMessage (  pPeapCb,
                                                pSendPacket, 
                                                cbSendPacket,
                                                FALSE,    //This is a response
                                                ( pEapOutput->dwAuthResultCode == NO_ERROR ?
                                                    MS_PEAP_AVP_VALUE_SUCCESS:
                                                    MS_PEAP_AVP_VALUE_FAILURE
                                                )
                                            );

                    if ( pEapOutput->dwAuthResultCode == NO_ERROR )
                    {
                        pPeapCb->PeapState = PEAP_STATE_PEAP_SUCCESS_SEND;
                    }
                    else
                    {
                        pPeapCb->PeapState = PEAP_STATE_PEAP_FAIL_SEND;
                    }
                    pEapOutput->Action = EAPACTION_Send;

                    if ( pEapOutput->dwAuthResultCode == NO_ERROR )
                    {

                        //Check to see if connectiondata and user data need to be saved
                        if ( pEapOutput->fSaveConnectionData )
                        {
                            //
                            // save connection data in PEAP control
                            // block and then finally when auth is done 
                            // We send back a save command.
                            // 
                            pPeapCb->pEapInfo->pbNewClientConfig = pEapOutput->pConnectionData;
                            pPeapCb->pEapInfo->dwNewClientConfigSize = pEapOutput->dwSizeOfConnectionData;
                            pPeapCb->fEntryConnPropDirty = TRUE;
                        }
                        if ( pEapOutput->fSaveUserData )
                        {
                            pPeapCb->pEapInfo->pbUserConfigNew = pEapOutput->pUserData;
                            pPeapCb->pEapInfo->dwNewUserConfigSize = pEapOutput->dwSizeOfUserData;
                            pPeapCb->fEntryUserPropDirty = TRUE;
                        }
                    }
                }
                else if ( pEapOutput->Action == EAPACTION_Send )
                {

                    //This has to be a request response.  So if the length is < sizeof(PPP_EAP_PACKET)
                    // We have a problem
                    wPacketLength = WireToHostFormat16(pSendPacket->Length);
                    if ( wPacketLength >= sizeof(PPP_EAP_PACKET) )
                    {
                        dwRetCode = PeapEncryptTunnelData ( pPeapCb,
                                                            &(pSendPacket->Data[0]),
                                                            wPacketLength - sizeof(PPP_EAP_PACKET)+1
                                                        );
                        if ( NO_ERROR != dwRetCode )
                        {
                            //
                            // This is an internal error.  So cannot send TLV's here
                            //
                            break;
                        }
                        CopyMemory ( &(pSendPacket->Data[2]), 
                                    pPeapCb->pbIoBuffer,
                                    pPeapCb->dwIoBufferLen
                                );
                        wPacketLength = (WORD)(sizeof(PPP_EAP_PACKET)+ 1 + pPeapCb->dwIoBufferLen);
                        pSendPacket->Data[0] = PPP_EAP_PEAP;
                        pSendPacket->Data[1] = EAPTLS_PACKET_CURRENT_VERSION;
                        //Readjust the length
                    
                        HostToWireFormat16
                        (   wPacketLength,
                            pSendPacket->Length
                        );
                    }
                }                
                else
                {
                    EapTlsTrace("Invalid length returned by Length");
                    dwRetCode = ERROR_INTERNAL_ERROR;
                }                
            }
            else
            {
                // we can get send / done / noaction from the client .
                // So this is a no action.  pass it on to EAP without 
                // any modification
            }
        }

        break;
    case PEAP_STATE_EAP_TYPE_FINISHED:
        EapTlsTrace("PEAP:PEAP_STATE_EAP_TYPE_FINISHED");
        break;
    case PEAP_STATE_PEAP_SUCCESS_SEND:
        EapTlsTrace("PEAP:PEAP_STATE_PEAP_SUCCESS_SEND");
        //
        // We got a PEAP_SUCCESS TLV inside the protected channel and have send 
        // a PEAP_SUCCESS response TLV.  So we should get an EAP_Success now.
        // Anything else will cause the connection to disconnect.
        //
        if ( pReceivePacket && pReceivePacket->Code == EAPCODE_Success )
        {
            //
            // Check to see if there is a need to create a new conn and/or user blob
            //
            if ( pPeapCb->fEntryConnPropDirty || 
                    pPeapCb->fTlsConnPropDirty
                )
            {
                PPEAP_CONN_PROP             pNewConnProp = NULL;
                PEAP_ENTRY_CONN_PROPERTIES UNALIGNED * pNewEntryProp = NULL;
                PEAP_ENTRY_CONN_PROPERTIES UNALIGNED * pEntryProp = NULL;
                DWORD                       dwSize = 0;

                //
                // We need to recreate our PEAP conn prop structure
                //

                dwSize = sizeof(PEAP_CONN_PROP);
                if (  pPeapCb->fTlsConnPropDirty )
                {
                    dwSize += pPeapCb->pNewTlsConnProp->dwSize;
                }
                else
                {
                    dwSize += pPeapCb->pConnProp->EapTlsConnProp.dwSize;
                }
                if ( pPeapCb->fEntryConnPropDirty )
                {
                    dwSize += sizeof(PEAP_ENTRY_CONN_PROPERTIES) + 
                        pPeapCb->pEapInfo->dwNewClientConfigSize -1;
                }
                else
                {
                    PeapGetFirstEntryConnProp ( pPeapCb->pConnProp, &pNewEntryProp );
                    dwSize += pNewEntryProp->dwSize;
                }
                pNewConnProp = (PPEAP_CONN_PROP)LocalAlloc (LPTR, dwSize );
                if ( pNewConnProp )
                {
                    pNewConnProp->dwVersion = 1;
                    pNewConnProp->dwSize = dwSize;
                    pNewConnProp->dwNumPeapTypes = 1;
                    if ( pPeapCb->fTlsConnPropDirty  )
                        CopyMemory ( &pNewConnProp->EapTlsConnProp,
                                        pPeapCb->pNewTlsConnProp,
                                        pPeapCb->pNewTlsConnProp->dwSize
                                    );
                    else
                        CopyMemory ( &pNewConnProp->EapTlsConnProp,
                                    &pPeapCb->pConnProp->EapTlsConnProp,
                                    pPeapCb->pConnProp->EapTlsConnProp.dwSize
                                    );
                    PeapGetFirstEntryConnProp ( pNewConnProp, &pNewEntryProp );

                    if ( pPeapCb->fEntryConnPropDirty )
                    {                                                               
                        pNewEntryProp->dwVersion = 1;
                        pNewEntryProp->dwEapTypeId = pPeapCb->pEapInfo->dwTypeId;
                        pNewEntryProp->dwSize =  sizeof( PEAP_ENTRY_CONN_PROPERTIES) + 
                            pPeapCb->pEapInfo->dwNewClientConfigSize -1;

                        CopyMemory (    pNewEntryProp->bData,
                                        pPeapCb->pEapInfo->pbNewClientConfig,
                                        pPeapCb->pEapInfo->dwNewClientConfigSize
                                    );                                                
                    }
                    else
                    {                                
                        PeapGetFirstEntryConnProp ( pPeapCb->pConnProp, &pEntryProp );
                        CopyMemory ( pNewEntryProp,
                                        pEntryProp,
                                        pEntryProp->dwSize
                                    );
                    }
                                            
                    LocalFree ( pPeapCb->pConnProp );
                    pPeapCb->pConnProp = pNewConnProp;
                    pEapOutput->fSaveConnectionData = TRUE;
                    pEapOutput->pConnectionData = (PBYTE)pNewConnProp;
                    pEapOutput->dwSizeOfConnectionData =  pNewConnProp->dwSize;
                }
            }
            //
            // check to see if the user props need to be saved
            //
            if ( pPeapCb->fEntryUserPropDirty )
            {
                PPEAP_USER_PROP             pNewUserProp = NULL;
                
                pNewUserProp = (PPEAP_USER_PROP) LocalAlloc( LPTR,
                                    sizeof( PEAP_USER_PROP ) + 
                                    pPeapCb->pEapInfo->dwNewUserConfigSize -1);
                if ( pNewUserProp )
                {
                    pNewUserProp->dwVersion = pPeapCb->pUserProp->dwVersion;
                    pNewUserProp->dwSize = sizeof( PEAP_USER_PROP ) +
                        pPeapCb->pEapInfo->dwNewUserConfigSize -1;
                    pNewUserProp->UserProperties.dwVersion = 1;
                    pNewUserProp->UserProperties.dwSize = sizeof(PEAP_ENTRY_USER_PROPERTIES) + 
                        pPeapCb->pEapInfo->dwNewUserConfigSize -1;
                    pNewUserProp->UserProperties.dwEapTypeId = 
                        pPeapCb->pEapInfo->dwTypeId;
                    CopyMemory ( pNewUserProp->UserProperties.bData,
                                    pPeapCb->pEapInfo->pbUserConfigNew,
                                    pPeapCb->pEapInfo->dwNewUserConfigSize
                                );
                    LocalFree ( pPeapCb->pUserProp);
                    pPeapCb->pUserProp = pNewUserProp;
                    pEapOutput->pUserData = (PBYTE)pNewUserProp;
                    pEapOutput->dwSizeOfUserData = pNewUserProp->dwSize;
                    pEapOutput->fSaveUserData = TRUE;
                }
                //
                // Set the cookie if we're enabled to do fast reconnect
                //
                if ( pPeapCb->dwFlags &  PEAPCB_FAST_ROAMING )
                {
                    dwRetCode = PeapCreateCookie (  pPeapCb,
                                                    &pbCookie,
                                                    &cbCookie
                                                 );
                    if ( NO_ERROR != dwRetCode )
                    {
                        EapTlsTrace("Failed to create session cookie.  Resetting fast reconnect");
                        dwRetCode = SetTLSFastReconnect ( pPeapCb->pEapTlsCB , FALSE);
                        if ( NO_ERROR != dwRetCode )
                        {                                
                            //
                            // This is an internal error 
                            // So disconnect the session.
                            //
                            pEapOutput->dwAuthResultCode = dwRetCode;
                            pEapOutput->Action = EAPACTION_Done;
                            pPeapCb->PeapState = PEAP_STATE_EAP_TYPE_FINISHED;
                            break;
                        }
                    }

                    dwRetCode = SetTLSSessionCookie ( pPeapCb->pEapTlsCB , 
                                                      pbCookie,
                                                      cbCookie
                                                    );
                    if ( NO_ERROR != dwRetCode )
                    {
                        EapTlsTrace("Failed to create session cookie.  Resetting fast reconnect");
                        dwRetCode = SetTLSFastReconnect ( pPeapCb->pEapTlsCB , FALSE);
                        if ( NO_ERROR != dwRetCode )
                        {                                
                            //
                            // This is an internal error 
                            // So disconnect the session.
                            //
                            pEapOutput->dwAuthResultCode = dwRetCode;
                            pEapOutput->Action = EAPACTION_Done;
                            pPeapCb->PeapState = PEAP_STATE_EAP_TYPE_FINISHED;
                            break;
                        }
                    }

                }


            }
            pPeapCb->PeapState = PEAP_STATE_EAP_TYPE_FINISHED;
            pEapOutput->pUserAttributes = pPeapCb->pTlsUserAttributes;
            pEapOutput->dwAuthResultCode = pPeapCb->dwAuthResultCode;
            pEapOutput->Action = EAPACTION_Done;
        }
        else if ( pReceivePacket && pReceivePacket->Code == EAPCODE_Failure )
        {
            //
            // We fail the connection.  Even though there is a success from PEAP
            //
            EapTlsTrace("We got a EAP_failure after we got a PEAP_SUCCESS.  Failing auth.");
            dwRetCode = ERROR_INTERNAL_ERROR;
            pEapOutput->dwAuthResultCode = ERROR_INTERNAL_ERROR;
            pEapOutput->Action = EAPACTION_Done;
        }
        else
        {
            if ( pReceivePacket )
                EapTlsTrace ("Received Packet with code %x when expecting success", pReceivePacket->Code);
            break;
        }

        break;
    case PEAP_STATE_PEAP_FAIL_SEND:
        EapTlsTrace("PEAP:PEAP_STATE_PEAP_FAIL_SEND");
        
        //
        // We have send PEAP_FAILURE TLV inside the protected channel 
        // So the only thing we should expect is a EAP_Failure from now on
        // Send back a EAP_FAIL with EAP_Done action.
        //
        if ( pReceivePacket && pReceivePacket->Code == EAPCODE_Failure )
        {            
            pEapOutput->dwAuthResultCode = pPeapCb->dwAuthResultCode;
            //We have failed auth so uncache the creds
            FreeCachedCredentials (pPeapCb->pEapTlsCB);
            pEapOutput->Action = EAPACTION_Done;
        }
        else if ( pReceivePacket && pReceivePacket->Code == EAPCODE_Success )
        {
            //
            // We fail the connection.  Even though there is a success from PEAP
            //
            EapTlsTrace("We got a EAP_Success after we got a PEAP_FAILURE.  Failing auth.");
            dwRetCode = ERROR_INTERNAL_ERROR;
            pEapOutput->dwAuthResultCode = ERROR_INTERNAL_ERROR;
            //We have failed auth so uncache the creds
            FreeCachedCredentials (pPeapCb->pEapTlsCB);
            pEapOutput->Action = EAPACTION_Done;
        }
        else
        {
            if ( pReceivePacket )
                EapTlsTrace ("Received Packet with code %x when expecting success", pReceivePacket->Code);
            break;
        }


    default:
        EapTlsTrace("PEAP:Invalid state");
    }
    if ( fImpersonating  )
    {
        if (!RevertToSelf() )
        {
            dwRetCode = GetLastError();
            EapTlsTrace("PEAP:RevertToSelf Failed and returned 0x%x", dwRetCode );
        }
    }
LDone:
    EapTlsTrace("EapPeapCMakeMessage done");
    return dwRetCode;
}

DWORD
EapPeapSMakeMessage(
    IN  PPEAPCB         pPeapCb,
    IN  PPP_EAP_PACKET*  pReceivePacket,
    OUT PPP_EAP_PACKET*  pSendPacket,
    IN  DWORD           cbSendPacket,
    OUT PPP_EAP_OUTPUT* pEapOutput,
    IN  PPP_EAP_INPUT*  pEapInput
)
{
    DWORD               dwRetCode = NO_ERROR;
    PPP_EAP_INPUT       EapTypeInput;
    WORD                wPacketLength;
    DWORD               dwVersion;
    PBYTE               pbCookie = NULL;
    DWORD               cbCookie = 0;
    BOOL                fIsReconnect = FALSE;

    EapTlsTrace("EapPeapSMakeMessage");

    switch ( pPeapCb->PeapState )
    {
    case PEAP_STATE_INITIAL:
        EapTlsTrace("PEAP:PEAP_STATE_INITIAL");
        //
        // Start the EapTls Conversation here.  
        //
        //Receive Packet will be NULL.  Call EapTlsSMakeMessage
        //
        //Note: Our version currently is 0.  So the packet will
        // be the same as eaptls packet.  In future, this needs
        // to change
        dwRetCode = EapTlsSMakeMessage( pPeapCb->pEapTlsCB,
                                        (EAPTLS_PACKET *)pReceivePacket, 
                                        (EAPTLS_PACKET *)pSendPacket,
                                        cbSendPacket,
                                        pEapOutput,
                                        pEapInput
                                      );
        if ( NO_ERROR == dwRetCode )
        {
            //change the packet to show peap
            pSendPacket->Data[0] = PPP_EAP_PEAP;
            //Set version 
            ((EAPTLS_PACKET *)pSendPacket)->bFlags |= 
                EAPTLS_PACKET_HIGHEST_SUPPORTED_VERSION;

        }
        pPeapCb->PeapState = PEAP_STATE_TLS_INPROGRESS;
        break;

    case PEAP_STATE_TLS_INPROGRESS:
        EapTlsTrace("PEAP:PEAP_STATE_TLS_INPROGRESS");
        
        if ( pReceivePacket )
        {
            if ( !(pPeapCb->dwFlags & PEAPCB_VERSION_OK) )
            {
                //
                // We have not done the version check yet.
                //
                dwVersion = ((EAPTLS_PACKET *)pReceivePacket)->bFlags & 0x03;
                if ( dwVersion > EAPTLS_PACKET_LOWEST_SUPPORTED_VERSION )
                {
                    //
                    // Send a fail code back and we're done.  The versions 
                    // of PEAP did not match
                    EapTlsTrace("Could not negotiate version successfully.");
                    EapTlsTrace("Requested version %ld, our lowest version %ld", 
                                 dwVersion, EAPTLS_PACKET_LOWEST_SUPPORTED_VERSION 
                               );
                    pSendPacket->Code = EAPCODE_Failure;
                    pPeapCb->PeapState = PEAP_STATE_EAP_TYPE_FINISHED;
                    break;
                }
                else
                {
                    pPeapCb->dwFlags |= PEAPCB_VERSION_OK;
                }
            }
            pReceivePacket->Data[0] = PPP_EAP_TLS;
        }
        
        dwRetCode = EapTlsSMakeMessage( pPeapCb->pEapTlsCB,
                                        (EAPTLS_PACKET *)pReceivePacket, 
                                        (EAPTLS_PACKET *)pSendPacket,
                                        cbSendPacket,
                                        pEapOutput,
                                        pEapInput
                                      );
        if ( NO_ERROR == dwRetCode )
        {
            //We are done with auth.  
            if ( pEapOutput->dwAuthResultCode == NO_ERROR &&
                 pSendPacket->Code == EAPCODE_Success
                )
            {
                //
                // auth was successful.  Carefully keep the MPPE 
                // session keys returned so that we can encrypt the
                // channel.  From now on everything will be encrypted.
                //
                pPeapCb->pTlsUserAttributes = pEapOutput->pUserAttributes;

                dwRetCode = PeapGetTunnelProperties ( pPeapCb );
                if (NO_ERROR != dwRetCode )
                {                        
                    break;
                }

                //
                // Check to see if we get the cookie.  If we get the cookie,
                // and it is a fast reconnect, then we compare which auth method 
                // was used previously.  If it is good, then 
                //
                if ( pPeapCb->dwFlags &  PEAPCB_FAST_ROAMING )
                {
                    dwRetCode = GetTLSSessionCookie ( pPeapCb->pEapTlsCB,
                                                        &pbCookie,
                                                        &cbCookie,
                                                        &fIsReconnect
                                                    );
                    if ( NO_ERROR != dwRetCode )
                    {
                        EapTlsTrace("Error getting cookie for a reconnected session.  Failing auth");
                        // We cannot encrypt and send stuff across here.  
                        // Reconnected Session state is invalid.                        
                        pEapOutput->dwAuthResultCode = dwRetCode;
                        pPeapCb->PeapState = PEAP_STATE_EAP_TYPE_FINISHED;
                        pEapOutput->Action = EAPACTION_Done;                                    
                        break;
                    }

                    if ( fIsReconnect )
                    {
                        if ( cbCookie == 0 )
                        {
                            //There was an error getting session cookie.
                            //Or there is no cookie and this is a reconnet
                            // So fail the request.
                            dwRetCode = SetTLSFastReconnect ( pPeapCb->pEapTlsCB , FALSE);
                            EapTlsTrace("Error getting cookie for a reconnected session.  Failing auth");
                            // We cannot encrypt and send stuff across here.  
                            // Reconnected Session state is invalid.
                            dwRetCode = ERROR_INTERNAL_ERROR;
                            pEapOutput->dwAuthResultCode = dwRetCode;
                            pPeapCb->PeapState = PEAP_STATE_EAP_TYPE_FINISHED;
                            pEapOutput->Action = EAPACTION_Done;                                    
                            break;
                        }
                        //
                        // This is a server
                        // Check to see if the cookie is fine.  
                        // If it is fine then there is no need to reauth.
                        // So send back a PEAP_SUCCESS request packet
                        // and change our state to PEAP_SUCCESS_SEND
                        // If not, proceed with auth and send identity request
                        // 
                        EapTlsTrace ("TLS session fast reconnected");
                        dwRetCode = PeapCheckCookie ( pPeapCb, (PPEAP_COOKIE)pbCookie, cbCookie );
                        if ( NO_ERROR != dwRetCode )
                        {
                            //
                            // So invalidate the session for fast reconnect
                            // and fail auth.  Next time a full reconnect will happen
                            //
                            dwRetCode = SetTLSFastReconnect ( pPeapCb->pEapTlsCB , FALSE);
                            if ( NO_ERROR != dwRetCode )
                            {                                
                                //
                                // This is an internal error 
                                // So disconnect the session.
                                //
                                pEapOutput->dwAuthResultCode = dwRetCode;
                                pEapOutput->Action = EAPACTION_Done;
                                pPeapCb->PeapState = PEAP_STATE_EAP_TYPE_FINISHED;
                                break;
                            }
                            EapTlsTrace ("Error validating the cookie.  Failing auth");

                            pEapOutput->dwAuthResultCode = dwRetCode;
                            pPeapCb->PeapState = PEAP_STATE_EAP_TYPE_FINISHED;
                            pEapOutput->Action = EAPACTION_Done;
                            break;
                        }
                        else
                        {
                            //
                            // Cookie is fine.
                            //
                            //
                            // Send a PEAP success TLV here.  
                            // We need to do this so that
                            // the client does not think he is spoofed.
                            //
                            dwRetCode = CreatePEAPTLVStatusMessage ( pPeapCb,
                                                        pSendPacket, 
                                                        cbSendPacket,
                                                        TRUE,
                                                        MS_PEAP_AVP_VALUE_SUCCESS
                                                    );
                            if ( NO_ERROR != dwRetCode )
                            {
                                break;
                            }

                            pPeapCb->fSendTLVSuccessforFastRoaming = TRUE;
                            pEapOutput->Action = EAPACTION_SendWithTimeoutInteractive;
                            pPeapCb->PeapState = PEAP_STATE_PEAP_SUCCESS_SEND;
                            pPeapCb->dwAuthResultCode = pEapOutput->dwAuthResultCode;
                            break;
                        }                        
                    }
                    else
                    {
                        //
                        // Go ahead with the auth and at the end, save the cookie
                        // Check to see if fast reconnect has been enabled.  If it has been enabled,
                        // Set the TLS state to enable fast reconnect.  If not do nothing at the 
                        // end of auth.
                        EapTlsTrace ("Full TLS handshake");

                    }
                }
                

                //Transfer the Id from eaptls control block to peap cb
                pPeapCb->bId = ++pPeapCb->pEapTlsCB->bId;

                pEapOutput->pUserAttributes = NULL;
                pEapOutput->Action = EAPACTION_SendWithTimeoutInteractive;
                pSendPacket->Code = EAPCODE_Request;
                pSendPacket->Id = pPeapCb->bId;

                //
                // Send encrypted identity request.
                //

                pSendPacket->Data[0] = PPP_EAP_PEAP;
                pSendPacket->Data[1] = EAPTLS_PACKET_CURRENT_VERSION;
                pSendPacket->Data[2] = PEAP_EAPTYPE_IDENTITY;
                
                //
                // Identity request needs to be encrypted.
                //
                dwRetCode = PeapEncryptTunnelData ( pPeapCb,
                                                    &(pSendPacket->Data[2]),
                                                    1
                                                  );
                if ( NO_ERROR != dwRetCode )
                {
                    break;
                }

                CopyMemory ( &(pSendPacket->Data[2]), 
                                pPeapCb->pbIoBuffer,
                                pPeapCb->dwIoBufferLen
                            );

                HostToWireFormat16
                (
                    (WORD)(sizeof(PPP_EAP_PACKET)+1 + pPeapCb->dwIoBufferLen),
                    pSendPacket->Length
                );
                
                pPeapCb->PeapState = PEAP_STATE_IDENTITY_REQUEST_SENT;
            }                            
            else
            {
                //change the packet to show peap
                pSendPacket->Data[0] = PPP_EAP_PEAP;
            }
        }        
        break;
    case PEAP_STATE_IDENTITY_REQUEST_SENT:
        EapTlsTrace("PEAP:PEAP_STATE_IDENTITY_REQUEST_SENT");
        //
        // Should get only identity response and nothing else
        // NOTE: in this implementation, this should match
        // the outer identity.  But at a later point, we 
        // may get many identities and any one of them should
        // match the outer identity.
        //
        // call begin in the eap dll and send back the blob got 
        // from begin.

        //decrypt tunnel data here
        if ( pReceivePacket )
        {
            dwRetCode = PeapDecryptTunnelData ( pPeapCb,
                                                &(pReceivePacket->Data[2]),
                                                WireToHostFormat16(pReceivePacket->Length) 
                                                - (sizeof(PPP_EAP_PACKET)+1)
                                              );
            if ( NO_ERROR != dwRetCode )
            {                
                // We could not decrypt the tunnel traffic
                // So we silently discard this packet.
                EapTlsTrace("PeapDecryptTunnelData failed: silently discarding packet");
                dwRetCode = NO_ERROR;
                pEapOutput->Action = EAPACTION_NoAction;                
                break;
            }
        }

        if ( pReceivePacket && 
             pReceivePacket->Code != EAPCODE_Response && 
             pPeapCb->pbIoBuffer[0] != PEAP_EAPTYPE_IDENTITY )
        {
            EapTlsTrace("Invalid packet received when expecting identity response");
            pEapOutput->Action = EAPACTION_NoAction;
        }
        else
        {
            if ( pReceivePacket && pReceivePacket->Id != pPeapCb->bId )
            {
                EapTlsTrace ("Ignoring packet with mismatched ids");
                pEapOutput->Action = EAPACTION_NoAction;
                break;
            }

            if ( pReceivePacket )
            {
                //
                // get the identity and create a ppp input and pass it on to dll begin
                // of the configured eap type.  
                //
                MultiByteToWideChar( CP_ACP,
                            0,
                            &pPeapCb->pbIoBuffer[1],
                            pPeapCb->dwIoBufferLen - 1,
                            pPeapCb->awszTypeIdentity,
                            DNLEN+UNLEN );
                ZeroMemory ( &EapTypeInput, sizeof(EapTypeInput) );

                if ( pEapInput )
                {
                    CopyMemory( &EapTypeInput, pEapInput, sizeof(EapTypeInput) );
                }
                else
                {
                    EapTypeInput.fFlags = RAS_EAP_FLAG_NON_INTERACTIVE;
                    EapTypeInput.fAuthenticator = TRUE;
                }
                EapTypeInput.pwszIdentity = pPeapCb->awszIdentity;

                EapTypeInput.bInitialId = ++ pPeapCb->bId;            

                // 
                // Call begin function
                //
                dwRetCode = pPeapCb->pEapInfo->PppEapInfo.RasEapBegin( &(pPeapCb->pEapInfo->pWorkBuf ),
                                                                    &EapTypeInput
                                                                    );
            }
            if ( NO_ERROR == dwRetCode )
            {
                //
                // Call make message now.  This MakeMessage is called in for the first time
                // So send the identity request that came across into this MakeMessage.
                //
                dwRetCode = pPeapCb->pEapInfo->PppEapInfo.RasEapMakeMessage
                    (   pPeapCb->pEapInfo->pWorkBuf,
                        NULL,
                        pSendPacket,
                        cbSendPacket-200,
                        pEapOutput,
                        &EapTypeInput
                    );
                if ( NO_ERROR == dwRetCode )
                {
                    if ( pEapOutput->Action == EAPACTION_Authenticate )
                    {
                        //
                        // do nothing here.  We are passing this on to RADIUS as is 
                        //
                    }
                    else
                    {
                        wPacketLength = WireToHostFormat16(pSendPacket->Length);
                        //Encrypt the entire packet that we need to nest
                        dwRetCode = PeapEncryptTunnelData ( pPeapCb,
                                                            &(pSendPacket->Data[0]),
                                                            wPacketLength - sizeof(PPP_EAP_PACKET)+1
                                                        );
                        if ( NO_ERROR != dwRetCode )
                        {
                            // 
                            // This is an internal error.  So we cannot send 
                            // a PEAP_Failure here
                            //
                            break;
                        }

                        pSendPacket->Data[0] = PPP_EAP_PEAP;
                        pSendPacket->Data[1] =EAPTLS_PACKET_CURRENT_VERSION;

                        CopyMemory ( &(pSendPacket->Data[2]), 
                                    pPeapCb->pbIoBuffer,
                                    pPeapCb->dwIoBufferLen
                                );
                    
                        //Readjust the length
                        wPacketLength = (WORD)(sizeof(PPP_EAP_PACKET) + 1 + pPeapCb->dwIoBufferLen);

                        HostToWireFormat16
                        (   wPacketLength,
                            pSendPacket->Length
                        );
                    
                        //Set the Id of the packet send.  This should have been set 
                        //by the eap type.
                        
                        pPeapCb->bId = pSendPacket->Id;

                        pPeapCb->PeapState = PEAP_STATE_EAP_TYPE_INPROGRESS;
                    }
                }
                else
                {
                    EapTlsTrace (   "EapType %d failed in RasEapMakeMEssage and returned 0x%x", 
                                    pPeapCb->pEapInfo->dwTypeId, 
                                    dwRetCode 
                                );
                }
            }
            else
            {
                EapTlsTrace (   "EapType %d failed in RasEapBegin and returned 0x%x", 
                                pPeapCb->pEapInfo->dwTypeId, 
                                dwRetCode 
                            );
                //
                // Send a PEAP failure TLV here.  We need to do this so that
                // the client does not think he is spoofed.
                //
                dwRetCode = CreatePEAPTLVStatusMessage (  pPeapCb,
                                              pSendPacket, 
                                              cbSendPacket,
                                              TRUE,
                                              MS_PEAP_AVP_VALUE_FAILURE
                                           );

                if ( NO_ERROR != dwRetCode )
                {
                    // 
                    // This is an internal error.  So we cannot send 
                    // a PEAP_Failure here
                    //
                    break;
                }
                
                pEapOutput->Action = EAPACTION_SendWithTimeoutInteractive;
                pPeapCb->PeapState = PEAP_STATE_PEAP_FAIL_SEND;
            }
        }
        break;    
    case PEAP_STATE_EAP_TYPE_INPROGRESS:
        EapTlsTrace("PEAP:PEAP_STATE_EAP_TYPE_INPROGRESS");
        //
        // Since we are doing only one EAP type now, if we get a NAK here,
        // it means that the client cannot execute the EAP Type that was send 
        // so send back a EAP_FAIL with proper error code        
        //
        if (    pReceivePacket && 
                pReceivePacket->Code != EAPCODE_Response &&
                pReceivePacket->Id != pPeapCb->bId 
            )
        {            
            EapTlsTrace("Received packet with some other code than response or the id does not match.  Ignoring packet");
            pEapOutput->Action = EAPACTION_NoAction;
        }
        else
        {
            if ( pReceivePacket )
            {
                
                dwRetCode = PeapDecryptTunnelData ( pPeapCb,
                                                    &(pReceivePacket->Data[2]),
                                                    WireToHostFormat16(pReceivePacket->Length) 
                                                    - ( sizeof(PPP_EAP_PACKET) + 1 )
                                                  );
                if ( NO_ERROR != dwRetCode )
                {                
                    // We could not decrypt the tunnel traffic
                    // So we silently discard this packet.
                    EapTlsTrace("PeapDecryptTunnelData failed: silently discarding packet");
                    dwRetCode = NO_ERROR;
                    pEapOutput->Action = EAPACTION_NoAction;                
                    break;
                }
            }

            if ( pReceivePacket && 
                 pPeapCb->pbIoBuffer[0] == PEAP_EAPTYPE_NAK )
            {
                //
                // Since we are setup to do only one EAP Type 
                // this is an error.  Or else we should call begin 
                // for next configured eap type.
                //
                EapTlsTrace("Error: Got NAK for selection protocol.  Discontinuing auth.");
                pEapOutput->Action = EAPACTION_Done;
                pEapOutput->dwAuthResultCode = ERROR_PROTOCOL_NOT_CONFIGURED;
                dwRetCode = NO_ERROR;
            }
            else
            {
                ZeroMemory ( &EapTypeInput, sizeof(EapTypeInput) );
                if ( pEapInput )
                {
                    CopyMemory( &EapTypeInput, pEapInput, sizeof(EapTypeInput) );
                }
                else
                {
                    EapTypeInput.fFlags = RAS_EAP_FLAG_NON_INTERACTIVE;
                    EapTypeInput.fAuthenticator = TRUE;
                }

                FFormatUserIdentity ( pPeapCb->awszTypeIdentity, &EapTypeInput.pwszIdentity  );
                
                if ( pReceivePacket )
                {
                    CopyMemory ( pReceivePacket->Data,
                                 pPeapCb->pbIoBuffer,
                                 pPeapCb->dwIoBufferLen
                               );

                    HostToWireFormat16 ( (WORD)(sizeof(PPP_EAP_PACKET) + pPeapCb->dwIoBufferLen -1),
                                         pReceivePacket->Length
                                       );                                   
                }

                dwRetCode = pPeapCb->pEapInfo->PppEapInfo.RasEapMakeMessage
                    (   pPeapCb->pEapInfo->pWorkBuf,
                        pReceivePacket,
                        pSendPacket,
                        cbSendPacket-200,
                        pEapOutput,
                        &EapTypeInput
                    );
                if ( NO_ERROR == dwRetCode )
                {   

                    //
                    // Need to translate ActionSendDone to ActionSend and then send peap 
                    // success.  
                    //
                    if ( pEapOutput->Action == EAPACTION_SendAndDone )
                    {
                        
                        //
                        // If the code is request or response, send the data across 
                        // and save our state in the context.  If it is success or fail
                        // there is no data to send back so the following logic will 
                        // work.
                        //

                        if ( pSendPacket->Code == EAPCODE_Request )
                        {
                            EapTlsTrace ("Invalid Code EAPCODE_Request send for Action Send and Done");
                            //
                            // Auth fails here.  We cannot handle EAPCODE_Request yet.
                            //
                            dwRetCode = ERROR_PPP_INVALID_PACKET;
                            break;
                        }
                    }

                    if ( pSendPacket->Code == EAPCODE_Success )
                    {
                        
                        //
                        // Send a PEAP success TLV here.  
                        // We need to do this so that
                        // the client does not think he is spoofed.
                        //
 
                        dwRetCode = CreatePEAPTLVStatusMessage ( pPeapCb,
                                                     pSendPacket, 
                                                     cbSendPacket,
                                                     TRUE,
                                                     MS_PEAP_AVP_VALUE_SUCCESS
                                                );
                        if ( NO_ERROR != dwRetCode )
                        {
                            // 
                            // This is an internal error.  So we cannot send 
                            // a PEAP_Failure here
                            //
                            break;
                        }

                        pEapOutput->Action = EAPACTION_SendWithTimeoutInteractive;
                        pPeapCb->PeapState = PEAP_STATE_PEAP_SUCCESS_SEND;
                        pPeapCb->dwAuthResultCode = pEapOutput->dwAuthResultCode;
                    }
                    else if ( pSendPacket->Code == EAPCODE_Failure )
                    {
                        
                        //
                        // Send a PEAP failure TLV here.  
                        // We need to do this so that
                        // the client does not think he is spoofed.
                        //
                        dwRetCode = CreatePEAPTLVStatusMessage (pPeapCb,
                                                    pSendPacket, 
                                                    cbSendPacket,
                                                    TRUE,
                                                    MS_PEAP_AVP_VALUE_FAILURE
                                                );

                        if ( NO_ERROR != dwRetCode )
                        {
                            // 
                            // This is an internal error.  So we cannot send 
                            // a PEAP_Failure here
                            //
                            break;
                        }
                        
                        pEapOutput->Action = EAPACTION_SendWithTimeoutInteractive;
                        pPeapCb->PeapState = PEAP_STATE_PEAP_FAIL_SEND;

                        pPeapCb->dwAuthResultCode = pEapOutput->dwAuthResultCode;                        
                    }
                    else if ( pEapOutput->Action == EAPACTION_Authenticate )
                    {
                        //
                        // do nothing here.  We are passing this on to RADIUS as is 
                        //
                    }
                    else
                    {
                        //This is an action send
                        wPacketLength = WireToHostFormat16(pSendPacket->Length);

                        dwRetCode = PeapEncryptTunnelData ( pPeapCb,
                                    &(pSendPacket->Data[0]),
                                    wPacketLength - sizeof(PPP_EAP_PACKET)+1
                                  );

                        pSendPacket->Data[0] = PPP_EAP_PEAP;
                        pSendPacket->Data[1] = EAPTLS_PACKET_CURRENT_VERSION;
                        
                        CopyMemory ( &(pSendPacket->Data[2]),
                                     pPeapCb->pbIoBuffer,
                                     pPeapCb->dwIoBufferLen
                                   );
                        pPeapCb->bId = pSendPacket->Id;
                        wPacketLength = (WORD)(sizeof(PPP_EAP_PACKET) + 1+ pPeapCb->dwIoBufferLen);
                        HostToWireFormat16
                        (   wPacketLength,
                            pSendPacket->Length
                        );
                    }
                }
                if ( EapTypeInput.pwszIdentity  )
                    LocalFree ( EapTypeInput.pwszIdentity  );

            }
        }

        break;
    case PEAP_STATE_EAP_TYPE_FINISHED:
        EapTlsTrace("PEAP:PEAP_STATE_EAP_TYPE_FINISHED");
        break;
    case PEAP_STATE_PEAP_SUCCESS_SEND:
        EapTlsTrace("PEAP:PEAP_STATE_PEAP_SUCCESS_SEND");
        //
        // We have send PEAP_SUCCESS TLV inside the protected channel 
        // So the only thing we should expect is a PEAP_SUCCESS TLV response
        // or a PEAP_FAILURE
        // If we get a PEAP_SUCCESS response back, then send back EAP_SUCCESS
        // with EAP_Done action.
        //
        if (    pReceivePacket && 
            pReceivePacket->Code != EAPCODE_Response &&
            pReceivePacket->Id != pPeapCb->bId 
            )
        {
            EapTlsTrace("Received packet with some other code than response or the id does not match.  Ignoring packet");
            pEapOutput->Action = EAPACTION_NoAction;
        }
        else
        {
            WORD wValue =0;
            if ( pReceivePacket )
            {
                dwRetCode = PeapDecryptTunnelData ( pPeapCb,
                                                    &(pReceivePacket->Data[2]),
                                                    WireToHostFormat16(pReceivePacket->Length) 
                                                    - (sizeof(PPP_EAP_PACKET)+1)
                                                    );
                if ( NO_ERROR != dwRetCode )
                {                
                    // We could not decrypt the tunnel traffic
                    // So we silently discard this packet.
                    EapTlsTrace("PeapDecryptTunnelData failed: silently discarding packet");
                    dwRetCode = NO_ERROR;
                    pEapOutput->Action = EAPACTION_NoAction;                
                    break;
                }
                CopyMemory (    &(pReceivePacket->Data[2]),
                                pPeapCb->pbIoBuffer,
                                pPeapCb->dwIoBufferLen
                            );

                wPacketLength = WireToHostFormat16(pReceivePacket->Length);

            }
            
            if ( GetPEAPTLVStatusMessageValue ( pPeapCb, 
                                                pReceivePacket, 
                                                &wValue 
                                              ) == ERROR_PPP_INVALID_PACKET
               )
            {
                EapTlsTrace ("Got invalid packet when expecting TLV SUCCESS.  Silently discarding packet.");
                dwRetCode = NO_ERROR;
                pEapOutput->Action = EAPACTION_NoAction;
                break;
            }

            if ( wValue == MS_PEAP_AVP_VALUE_SUCCESS )
            {
                pbCookie = NULL;
                cbCookie = 0;
                //
                // If we're enabled for fast reconnect, setup the cookie in the session
                // so that we can consume it later
                //
                if ( pPeapCb->dwFlags &  PEAPCB_FAST_ROAMING )
                {
                    dwRetCode = PeapCreateCookie (  pPeapCb,
                                                    &pbCookie,
                                                    &cbCookie
                                                 );
                    if ( NO_ERROR != dwRetCode )
                    {
                        EapTlsTrace("Failed to create session cookie.  Resetting fast reconnect");
                        dwRetCode = SetTLSFastReconnect ( pPeapCb->pEapTlsCB , FALSE);
                        if ( NO_ERROR != dwRetCode )
                        {                                
                            //
                            // This is an internal error 
                            // So disconnect the session.
                            //
                            pEapOutput->dwAuthResultCode = dwRetCode;
                            pEapOutput->Action = EAPACTION_Done;
                            pPeapCb->PeapState = PEAP_STATE_EAP_TYPE_FINISHED;
                            break;
                        }
                    }

                    dwRetCode = SetTLSSessionCookie ( pPeapCb->pEapTlsCB , 
                                                      pbCookie,
                                                      cbCookie
                                                    );
                    if ( NO_ERROR != dwRetCode )
                    {
                        EapTlsTrace("Failed to create session cookie.  Resetting fast reconnect");
                        dwRetCode = SetTLSFastReconnect ( pPeapCb->pEapTlsCB , FALSE);
                        if ( NO_ERROR != dwRetCode )
                        {                                
                            //
                            // This is an internal error 
                            // So disconnect the session.
                            //
                            pEapOutput->dwAuthResultCode = dwRetCode;
                            pEapOutput->Action = EAPACTION_Done;
                            pPeapCb->PeapState = PEAP_STATE_EAP_TYPE_FINISHED;
                            break;
                        }
                    }

                }

                pSendPacket->Code = EAPCODE_Success;
            }
            else if ( wValue == MS_PEAP_AVP_VALUE_FAILURE )
            {
                if ( pPeapCb->fSendTLVSuccessforFastRoaming )
                {
                    //
                    // We got a failure because the client does not support fast roaming.

                    //
                    // Send encrypted identity request.
                    // This is not good. We need to review and cleanup code 
                    // and make common functions.
                    pPeapCb->fSendTLVSuccessforFastRoaming = FALSE;
                    pSendPacket->Code = EAPCODE_Request;
                    pSendPacket->Id = ++ pPeapCb->bId;
                    pSendPacket->Data[0] = PPP_EAP_PEAP;
                    pSendPacket->Data[1] = EAPTLS_PACKET_CURRENT_VERSION;
                    pSendPacket->Data[2] = PEAP_EAPTYPE_IDENTITY;
                    
                    //
                    // Identity request needs to be encrypted.
                    //
                    dwRetCode = PeapEncryptTunnelData ( pPeapCb,
                                                        &(pSendPacket->Data[2]),
                                                        1
                                                    );
                    if ( NO_ERROR != dwRetCode )
                    {
                        break;
                    }

                    CopyMemory ( &(pSendPacket->Data[2]), 
                                    pPeapCb->pbIoBuffer,
                                    pPeapCb->dwIoBufferLen
                                );

                    HostToWireFormat16
                    (
                        (WORD)(sizeof(PPP_EAP_PACKET)+1 + pPeapCb->dwIoBufferLen),
                        pSendPacket->Length
                    );
                    pEapOutput->Action = EAPACTION_SendWithTimeoutInteractive;
                    pPeapCb->PeapState = PEAP_STATE_IDENTITY_REQUEST_SENT;
                    break;

                }
                else
                {
                    EapTlsTrace ("Got TLV_Failure when expecting TLV SUCCESS.  Failing Auth.");
                    pSendPacket->Code = EAPCODE_Failure;
                }
            }
            else
            {
                EapTlsTrace ("Got invalid packet when expecting TLV SUCCESS.  Silently discarding packet.");
                dwRetCode = NO_ERROR;
                pEapOutput->Action = EAPACTION_NoAction;
                break;                
            }
            pSendPacket->Id = ++ pPeapCb->bId;
            HostToWireFormat16( 4, pSendPacket->Length);

            //
            // Now we're done with Auth.  So send back a EAP_Success
            //
            //We are done with auth. No need to encrypt the packet here
            pEapOutput->Action = EAPACTION_SendAndDone;
            pPeapCb->PeapState = PEAP_STATE_EAP_TYPE_FINISHED;
            pEapOutput->dwAuthResultCode = pEapOutput->dwAuthResultCode;            
            if ( pEapOutput->dwAuthResultCode == NO_ERROR )
            {
                //return back the MPPE keys
                pEapOutput->pUserAttributes = pPeapCb->pTlsUserAttributes;
            }
        }
       
        break;
    case PEAP_STATE_PEAP_FAIL_SEND:
        EapTlsTrace("PEAP:PEAP_STATE_PEAP_FAIL_SEND");
        //
        // We have send PEAP_FAIL TLV inside the protected channel 
        // So the only thing we should expect is a PEAP_FAILURE TLV response
        // Send back a EAP_FAIL with EAP_Done action.
        //
        //
        // We have send PEAP_SUCCESS TLV inside the protected channel 
        // So the only thing we should expect is a PEAP_SUCCESS TLV response
        // or a PEAP_FAILURE
        // If we get a PEAP_SUCCESS response back, then send back EAP_SUCCESS
        // with EAP_Done action.
        //
        if (    pReceivePacket && 
            pReceivePacket->Code != EAPCODE_Response &&
            pReceivePacket->Id != pPeapCb->bId 
            )
        {
            EapTlsTrace("Received packet with some other code than response or the id does not match.  Ignoring packet");
            pEapOutput->Action = EAPACTION_NoAction;
        }
        else
        {
            WORD wValue =0;
            if ( pReceivePacket )
            {
                dwRetCode = PeapDecryptTunnelData ( pPeapCb,
                                                    &(pReceivePacket->Data[2]),
                                                    WireToHostFormat16(pReceivePacket->Length) 
                                                    - (sizeof(PPP_EAP_PACKET)+1)
                                                    );
                if ( NO_ERROR != dwRetCode )
                {                
                    // We could not decrypt the tunnel traffic
                    // So we silently discard this packet.
                    EapTlsTrace("PeapDecryptTunnelData failed: silently discarding packet");
                    dwRetCode = NO_ERROR;
                    pEapOutput->Action = EAPACTION_NoAction;                
                    break;
                }
                CopyMemory (    &(pReceivePacket->Data[2]),
                                pPeapCb->pbIoBuffer,
                                pPeapCb->dwIoBufferLen
                            );

                wPacketLength = WireToHostFormat16(pReceivePacket->Length);

            }
            if ( GetPEAPTLVStatusMessageValue ( pPeapCb, 
                                                pReceivePacket, 
                                                &wValue 
                                              ) == ERROR_PPP_INVALID_PACKET
               )
            {
                EapTlsTrace ("Got invalid packet when expecting TLV FAIL response.  Silently discarding packet.");
                dwRetCode = NO_ERROR;
                pEapOutput->Action = EAPACTION_NoAction;
                break;
            }
            if ( wValue != MS_PEAP_AVP_VALUE_FAILURE )
            {
                EapTlsTrace ("Got invalid packet when expecting TLV FAILURE response.  Silently discarding packet.");
                dwRetCode = NO_ERROR;
                pEapOutput->Action = EAPACTION_NoAction;
                break;
            }
                         
            //
            // Now we're done with Auth.  So send back a EAP_Success
            //
            pSendPacket->Code = EAPCODE_Failure;
            pSendPacket->Id = ++ pPeapCb->bId;
            HostToWireFormat16( 4, pSendPacket->Length);

            pEapOutput->Action = EAPACTION_SendAndDone;
            pPeapCb->PeapState = PEAP_STATE_EAP_TYPE_FINISHED;
            pEapOutput->dwAuthResultCode = pEapOutput->dwAuthResultCode;            
        }

        break;
#if 0
        /*
    case PEAP_STATE_REQUEST_SENDANDDONE:
        EapTlsTrace("PEAP:PEAP_STATE_REQUEST_SENDANDDONE");
        break;
        */
#endif
    default:
        EapTlsTrace("PEAP:Invalid state");
    }

    if ( pbCookie )
        LocalFree (pbCookie);

    EapTlsTrace("EapPeapSMakeMessage done");
    return dwRetCode;
}

BOOL FValidPeapPacket ( EAPTLS_PACKET * pReceivePacket )
{
    BOOL        fRet = FALSE;
    WORD        wLength;

    

    if ( NULL == pReceivePacket )
    {
        fRet = TRUE;
        goto done;
    }
    wLength = WireToHostFormat16( pReceivePacket->pbLength );
    switch (pReceivePacket->bCode)
    {
        case EAPCODE_Success:
        case EAPCODE_Failure:
            if (PPP_EAP_PACKET_HDR_LEN != wLength)
            {
                EapTlsTrace("PEAP Success/Fail packet has length %d",
                     wLength);
                return(FALSE);
            }
            break;

        case EAPCODE_Request:
        case EAPCODE_Response:
            if (PPP_EAP_PEAP != pReceivePacket->bType &&
                pReceivePacket->bType != PEAP_EAPTYPE_IDENTITY &&
                pReceivePacket->bType != PEAP_EAPTYPE_NAK   
                )
            {
                // We are not concerned with this packet. It is not TLS.
                EapTlsTrace("Got packet with type id other than PEAP and identity.");
                goto done;
            }
            break;
    }
    fRet = TRUE;
done:
    return fRet;
}

DWORD
EapPeapMakeMessage(
    IN  PPEAPCB         pPeapCb,
    IN  PPP_EAP_PACKET* pInput,
    OUT PPP_EAP_PACKET* pOutput,
    IN  DWORD           cbSendPacket,
    OUT PPP_EAP_OUTPUT* pEapOutput,
    IN  PPP_EAP_INPUT*  pEapInput
)
{
    DWORD       dwRetCode = NO_ERROR;
    

    EapTlsTrace("EapPeapMakeMessage");
    //
    //  Inititally this will start as eaptls 
    //  and then will go into each PEAP type configured.
    //  For this release we have only eapmschap v2
    //
    if (!FValidPeapPacket((EAPTLS_PACKET *)pInput))
    {
        pEapOutput->Action = EAPACTION_NoAction;
        return(ERROR_PPP_INVALID_PACKET);
    }       
    
    if (pPeapCb->dwFlags & PEAPCB_FLAG_SERVER)
    {
        dwRetCode = EapPeapSMakeMessage( pPeapCb, 
                                         pInput, 
                                         pOutput, 
                                         cbSendPacket, 
                                         pEapOutput, 
                                         pEapInput
                                       );
    }
    else
    {
        dwRetCode = EapPeapCMakeMessage( pPeapCb, 
                                         pInput, 
                                         pOutput, 
                                         cbSendPacket, 
                                         pEapOutput, 
                                         pEapInput
                                       );
    }
    EapTlsTrace("EapPeapMakeMessage done");
    return dwRetCode;
}

DWORD CreatePEAPTLVNAKMessage (  PPEAPCB            pPeapCb,
                                 PPP_EAP_PACKET *   pPacket, 
                                 DWORD              cbPacket
                                 )
{
    DWORD dwRetCode = NO_ERROR;

    EapTlsTrace("CreatePEAPTLVNAKMessage");

    pPacket->Code = EAPCODE_Response ;
    
    pPacket->Id = pPeapCb->bId ;
    //
    // The format of this packet is following:
    // Code = Request/Response
    // Id
    // Length
    // Data[0] = Type = PPP_EAP_PEAP
    // Data[1] = Flags + Version
    //
    
    //Data[2]Code - Request/Response
    //3      Id - Can be same as outer Id
    //4,5    Length - Length this packet
    //6      Type - PEAP_TYPE_AVP
    //7,8          Type - High Bit is set to Mandatory if it is so ( 2 octets )
    //9,10          Length - 2 octets
    //11...         Value 
    //          

    //
    // pPacket->Length is set below.
    //
    
    pPacket->Data[0] = (BYTE)PPP_EAP_PEAP;
    pPacket->Data[1] = EAPTLS_PACKET_CURRENT_VERSION;

    pPacket->Data[2] = EAPCODE_Response;
    pPacket->Data[3] = pPacket->Id;
    

    // Data 3 and 4 will have the length of inner packet.
    //

    HostToWireFormat16 ( 7, &(pPacket->Data[4]) );

    pPacket->Data[6] = (BYTE)PEAP_TYPE_AVP;

    pPacket->Data[7] = PEAP_AVP_FLAG_MANDATORY;

    pPacket->Data[8] = PEAP_EAPTYPE_NAK;


    //
    // Encrypt the TLV part of the packet
    //
    dwRetCode = PeapEncryptTunnelData ( pPeapCb,
                                        &(pPacket->Data[2]),
                                        7
                                        );
    if ( NO_ERROR != dwRetCode )
    {
        return dwRetCode;
    }

    CopyMemory ( &(pPacket->Data[2]), 
                    pPeapCb->pbIoBuffer,
                    pPeapCb->dwIoBufferLen
                );

    HostToWireFormat16
    (
        (WORD)(sizeof(PPP_EAP_PACKET)+ 1 + pPeapCb->dwIoBufferLen),
        pPacket->Length
    );

    return dwRetCode;
}
// Format:
//          Code - Request/Resp
//          Id 
//          Type - PEAP
//          Method - PEAP_TLV
//          TLV - Type - PEAPSuccess/PEAPFailure
//                Flags - 
//                Length - 
//                Value - 
//                
   
DWORD CreatePEAPTLVStatusMessage (  PPEAPCB            pPeapCb,
                                    PPP_EAP_PACKET *   pPacket, 
                                    DWORD              cbPacket,
                                    BOOL               fRequest,
                                    WORD               wValue  //Success or Failure
                                 )
{
    DWORD dwRetCode = NO_ERROR;



    EapTlsTrace("CreatePEAPTLVStatusMessage");

    pPacket->Code = ( fRequest ? EAPCODE_Request : EAPCODE_Response );
    
    pPacket->Id = ( fRequest ? ++ pPeapCb->bId : pPeapCb->bId );
    //
    // The format of this packet is following:
    // Code = Request/Response
    // Id
    // Length
    // Data[0] = Type = PPP_EAP_PEAP
    // Data[1] = Flags + Version
    //
    
    //Data[2]Code - Request/Response
    //3      Id - Can be same as outer Id
    //4,5    Length - Length this packet
    //6      Type - PEAP_TYPE_AVP
    //7,8          Type - High Bit is set to Mandatory if it is so ( 2 octets )
    //9,10          Length - 2 octets
    //11...         Value 
    //          

    //
    // pPacket->Length is set below.
    //
    
    pPacket->Data[0] = (BYTE)PPP_EAP_PEAP;
    pPacket->Data[1] = EAPTLS_PACKET_CURRENT_VERSION;

    pPacket->Data[2] = ( fRequest ? EAPCODE_Request : EAPCODE_Response );
    pPacket->Data[3] = pPacket->Id;
    

    // Data 3 and 4 will have the length of inner packet.
    //

    HostToWireFormat16 ( 11, &(pPacket->Data[4]) );

    pPacket->Data[6] = (BYTE)PEAP_TYPE_AVP;

    pPacket->Data[7] = PEAP_AVP_FLAG_MANDATORY;

    pPacket->Data[8] = MS_PEAP_AVP_TYPE_STATUS;

    //Value Size
    HostToWireFormat16 ( 2, &(pPacket->Data[9]) );

    //Value
    HostToWireFormat16 ( wValue, &(pPacket->Data[11]) );

    //
    // Encrypt the TLV part of the packet
    //
    dwRetCode = PeapEncryptTunnelData ( pPeapCb,
                                        &(pPacket->Data[2]),
                                        11
                                        );
    if ( NO_ERROR != dwRetCode )
    {
        return dwRetCode;
    }

    CopyMemory ( &(pPacket->Data[2]), 
                    pPeapCb->pbIoBuffer,
                    pPeapCb->dwIoBufferLen
                );

    HostToWireFormat16
    (
        (WORD)(sizeof(PPP_EAP_PACKET)+ 1 + pPeapCb->dwIoBufferLen),
        pPacket->Length
    );

    return dwRetCode;
}

//
// Check to see if this packet is other than success/fail
// TLV
//

BOOL fIsPEAPTLVMessage ( PPEAPCB pPeapCb,
                     PPP_EAP_PACKET * pPacket
                     )
{
    WORD wPacketLength = WireToHostFormat16 ( pPacket->Length );

    if ( wPacketLength < 6 )
        return FALSE;

    if ( pPacket->Data[6] != PEAP_TYPE_AVP )
        return FALSE;

    //minimum length required to hold at least one success/fail tlv

    if ( wPacketLength > 17 )
    {
        if ( pPacket->Data[8] != MS_PEAP_AVP_TYPE_STATUS )
        {
            //Save the Id for response
            if ( pPacket->Code == EAPCODE_Request )
                pPeapCb->bId = pPacket->Id;
            return TRUE;
        }
    }

    return ( FALSE);
}



DWORD GetPEAPTLVStatusMessageValue ( PPEAPCB  pPeapCb, 
                                     PPP_EAP_PACKET * pPacket, 
                                     WORD * pwValue 
                                   )
{
    DWORD   dwRetCode = ERROR_PPP_INVALID_PACKET;
    WORD    wLength = 0;
    EapTlsTrace("GetPEAPTLVStatusMessageValue");


    //
    // Check to see if this is a status message
    //

    //
    // The format of this packet is following:
    // Code = Request/Response
    // Id
    // Length
    // Data[0] = Type = PPP_EAP_PEAP
    // Data[1] = Flags + Version
    //
    
    //Data[2]Code - Request/Response
    //3      Id - Can be same as outer Id
    //4,5    Length - Length this packet
    //6      Type - PEAP_TYPE_AVP
    //7,8          Type - High Bit is set to Mandatory if it is so ( 2 octets )
    //9,10          Length - 2 octets
    //11...         Value 
    //          
    

    if ( pPacket->Data[0] != (BYTE)PPP_EAP_PEAP )
    {
        goto done;
    }


    if ( pPacket->Data[2] != EAPCODE_Request && pPacket->Data[2] != EAPCODE_Response )
    {
        goto done;
    }

    if ( pPacket->Data[6] != PEAP_TYPE_AVP )
    {
        goto done;
    }

    if ( pPacket->Data[8] != MS_PEAP_AVP_TYPE_STATUS )
    {
        goto done;
    }
    
    *pwValue = WireToHostFormat16 (&(pPacket->Data[11]));

    //Save the Id for response
    if ( pPacket->Code == EAPCODE_Request )
        pPeapCb->bId = pPacket->Id;

    dwRetCode = NO_ERROR;
done:
    return dwRetCode;
}


//
// PEAP cookie management functions
//

// Create a new cookie to store in cached session
//
DWORD PeapCreateCookie ( PPEAPCB    pPeapCb,
                         PBYTE   *  ppbCookie,
                         DWORD   *  pcbCookie
                       )
{
    DWORD                   dwRetCode = NO_ERROR;
    DWORD                   wCookieSize = 0;
    PPEAP_COOKIE            pCookie = NULL;
    RAS_AUTH_ATTRIBUTE *    pAttribute = pPeapCb->pTlsUserAttributes;

    EapTlsTrace("PeapCreateCookie");
    wCookieSize = sizeof(PEAP_COOKIE);
    if ( pPeapCb->dwFlags & PEAPCB_FLAG_SERVER )
    {
        wCookieSize += pPeapCb->pUserProp->dwSize;
    }
    else
    {
        wCookieSize += pPeapCb->pConnProp->dwSize;
    }
    pCookie = (PPEAP_COOKIE)LocalAlloc (LPTR, wCookieSize);
    if ( NULL == pCookie )
    {
        EapTlsTrace ("Error allocating cookie");
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    wcscpy ( pCookie->awszIdentity,
             pPeapCb->awszIdentity
             );
    if ( pPeapCb->dwFlags & PEAPCB_FLAG_SERVER )
    {
        CopyMemory ( pCookie->Data, pPeapCb->pUserProp, pPeapCb->pUserProp->dwSize );
    }
    else
    {
        CopyMemory ( pCookie->Data, pPeapCb->pConnProp, pPeapCb->pConnProp->dwSize );
    }
    *ppbCookie = (PBYTE)pCookie;
    *pcbCookie = wCookieSize;
done:
    return dwRetCode;
}
//
// Verify current information against the cached  
// cookie
//

DWORD PeapCheckCookie ( PPEAPCB pPeapCb, 
                        PEAP_COOKIE *pCookie, 
                        DWORD cbCookie 
                      )
{
    DWORD                           dwRetCode = NO_ERROR;
    PEAP_CONN_PROP *                pCookieConnProp;
    PEAP_USER_PROP *                pCookieUserProp;
    EapTlsTrace ( "PeapCheckCookie");

    //
    // Check to see if the saved and configured PEAP info matches
    //
    if ( pPeapCb->dwFlags & PEAPCB_FLAG_SERVER )
    {
        pCookieUserProp = (PEAP_USER_PROP *)pCookie->Data;
        if ( pCookieUserProp->dwSize != pPeapCb->pUserProp->dwSize )
        {
            EapTlsTrace ("Server config changed since the cookie was cached. Failing auth");
            dwRetCode = ERROR_INVALID_PEAP_COOKIE_CONFIG;
            goto done;
        }
        if ( memcmp ( pCookieUserProp, pPeapCb->pUserProp, pPeapCb->pUserProp->dwSize ) )
        {
            EapTlsTrace ("Server config changed since the cookie was cached. Failing auth");
            dwRetCode = ERROR_INVALID_PEAP_COOKIE_CONFIG;
            goto done;
        }
    }
    else
    {
        pCookieConnProp = (PEAP_CONN_PROP *)pCookie->Data;
    
        if ( pCookieConnProp->dwSize != pPeapCb->pConnProp->dwSize )
        {
            EapTlsTrace ("Connection Properties changed since the cookie was cached. Failing auth");
            dwRetCode = ERROR_INVALID_PEAP_COOKIE_CONFIG;
            goto done;
        }
        if ( memcmp ( pCookieConnProp, pPeapCb->pConnProp, pPeapCb->pConnProp->dwSize ) )
        {
            EapTlsTrace ("Connection Properties changed since the cookie was cached. Failing auth");
            dwRetCode = ERROR_INVALID_PEAP_COOKIE_CONFIG;
            goto done;
        }
    }
    if ( _wcsicmp ( pCookie->awszIdentity, pPeapCb->awszIdentity ) )
    {
        EapTlsTrace ("Identity in the cookie is %ws and peap got %ws", 
                      pCookie->awszIdentity,
                      pPeapCb->awszIdentity
                    );
        dwRetCode = ERROR_INVALID_PEAP_COOKIE_USER;
        goto done;
    }
    //config and Id matches so we are ok.
done:
    return dwRetCode;
}

//phew!  

DWORD
PeapGetCredentials(
        IN VOID   * pWorkBuf,
        OUT VOID ** ppCredentials)
{
    PEAPCB *pPeapCb = (PEAPCB *) pWorkBuf;
    DWORD dwRetCode;

    if(NULL == pPeapCb)
    {
        return E_INVALIDARG;
    }

    //
    // Redirect the call to the actual peap module.
    //
    if(pPeapCb->pEapInfo->RasEapGetCredentials != NULL)
    {
        return pPeapCb->pEapInfo->RasEapGetCredentials(
                        pPeapCb->pEapInfo->dwTypeId,
                        pPeapCb->pEapInfo->pWorkBuf,
                        ppCredentials);
    }

    return ERROR_FILE_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\eaptls\exports.cpp ===
/*

Copyright (c) 1997, Microsoft Corporation, all rights reserved

Description:
    Implementation of DLL Exports.

History:

*/

#include "ceapcfg.h"
#include <initguid.h>
#include <atlimpl.cpp>
#include "resource.h"

CComModule  _Module;
HINSTANCE   g_hInstance = NULL;

const IID IID_IEAPProviderConfig =  {0x66A2DB19,
                                    0xD706,
                                    0x11D0,
                                    {0xA3,0x7B,0x00,0xC0,0x4F,0xC9,0xDA,0x04}};

// Define the EAPTLS UI GUIDs here
const CLSID CLSID_EapCfg =          {0x58ab2366,
                                    0xd597,
                                    0x11d1,
                                    {0xb9,0x0e,0x00,0xc0,0x4f,0xc9,0xb2,0x63}};

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_EapCfg, CEapCfg)
END_OBJECT_MAP()

/*

Returns:

Notes:
    
*/

extern "C"
HINSTANCE
GetHInstance(
    VOID
)
{
    return(g_hInstance);
}

/*

Returns:

Notes:
    DLL Entry Point
    
*/

extern "C"
{
extern CRITICAL_SECTION g_csProtectCachedCredentials;
extern BOOL             g_fCriticalSectionInitialized;

BOOL WINAPI
DllMain(
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID      /*lpReserved*/
)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hInstance;
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        //
        // Check to see if the critical section is initialized.
        //
        if ( g_fCriticalSectionInitialized )
            DeleteCriticalSection( &g_csProtectCachedCredentials );
        _Module.Term();
    }

    return(TRUE);
}
}
/*

Returns:

Notes:
    Used to determine whether the DLL can be unloaded by OLE
    
*/

STDAPI
DllCanUnloadNow(
    VOID
)
{
    if (0 == _Module.GetLockCount())
    {
        return(S_OK);
    }
    else
    {
        return(S_FALSE);
    }
}

/*

Returns:

Notes:
    Returns a class factory to create an object of the requested type
    
*/

STDAPI
DllGetClassObject(
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID*     ppv
)
{
    return(_Module.GetClassObject(rclsid, riid, ppv));
}

/*

Returns:

Notes:
    Adds entries to the system registry. Registers object, typelib and all
    interfaces in typelib
    
*/

STDAPI
DllRegisterServer(
    VOID
)
{
    return(_Module.RegisterServer(FALSE /* bRegTypeLib */));
}

/*

Returns:

Notes:
    Removes entries from the system registry
    
*/

STDAPI
DllUnregisterServer(
    VOID
)
{
    _Module.UnregisterServer();
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\eaptls\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by rastls.rc
//
#include "xpsp1res.h"

#define IDD_USERNAME_PIN_UI             1003
#define IDC_EDIT_PIN                    1501
#define IDC_CHECK_SAVE_PIN              1502


#define IDR_EAPCFG                      1100

#define IDS_VALIDATE_SERVER_TITLE       1200
#define IDS_CANT_CONFIGURE_SERVER_TITLE 1204
#define IDS_CANT_CONFIGURE_SERVER_TEXT  1205
#define IDS_CONNECT                     1206
#define IDS_HELPFILE                    1207
#define IDS_PEAP_NO_SERVER_CERT         1208

#define IDH_RADIO_USE_CARD                  70000000
#define IDH_RADIO_USE_REGISTRY              70000001
#define IDH_CHECK_VALIDATE_CERT             70000002
#define IDH_CHECK_VALIDATE_NAME             70000003
#define IDH_EDIT_SERVER_NAME                70000004
#define IDH_COMBO_ROOT_CA_NAME              70000005
#define IDH_CHECK_DIFF_USER                 70000006
#define IDH_EDIT_FRIENDLY_NAME              70000007
#define IDH_EDIT_ISSUER                     70000008
#define IDH_EDIT_EXPIRATION                 70000009
#define IDH_COMBO_USER_NAME                 70000025
#define IDH_EDIT_DIFF_USER                  70000026
#define IDH_EDIT_PIN                        70000050
#define IDH_CHECK_SAVE_PIN                  70000051
#define IDH_COMBO_SERVER_NAME               70000100



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1026
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\eaptls\scard.c ===
/*

Copyright (c) 1997, Microsoft Corporation, all rights reserved

Description:
    Smart card helper functions.

History:
    13 Dec 1997: Amanda Matlosz created original version.
    12 May 1998: Vijay Baliga moved things around.

*/

#undef UNICODE

#include <winscard.h>
#include <wincrypt.h>
#include <rtutils.h>


VOID   
EapTlsTrace(
    IN  CHAR*   Format, 
    ... 
);


typedef
WINSCARDAPI LONG
(WINAPI *GETOPENCARDNAMEA)(
    OPENCARDNAMEA*
);

GETOPENCARDNAMEA    g_fnGetOpenCardNameA    = NULL;
HINSTANCE           g_hInstanceScardDlg     = NULL;

/*

Returns:

Notes:
    
*/

DWORD
LoadScardDlgDll(
    VOID
)
{
    DWORD   dwErr = NO_ERROR;

    if (NULL == g_hInstanceScardDlg)
    {
        g_hInstanceScardDlg = LoadLibrary("scarddlg.dll");
    }

    if (NULL == g_hInstanceScardDlg)
    {
        dwErr = GetLastError();
        EapTlsTrace("LoadLibrary(scarddlg.dll) failed and returned 0x%x",
            dwErr);
        goto LDone;
    }

    if (NULL == g_fnGetOpenCardNameA)
    {
        g_fnGetOpenCardNameA = (GETOPENCARDNAMEA)
            GetProcAddress(g_hInstanceScardDlg, "GetOpenCardNameA");
    }

    if (NULL == g_fnGetOpenCardNameA)
    {
        dwErr = GetLastError();
        EapTlsTrace("GetProcAddress(GetOpenCardNameA) failed and returned 0x%x",
            dwErr);
        goto LDone;
    }

LDone:

    return(dwErr);
}

/*

Returns:

Notes:
    
*/

VOID
FreeScardDlgDll(
    VOID
)
{
    if (NULL != g_hInstanceScardDlg)
    {
        FreeLibrary(g_hInstanceScardDlg);
        g_hInstanceScardDlg = NULL;
        g_fnGetOpenCardNameA = NULL;
    }
}

/*

Returns:

Notes:
    
*/

DWORD
LocalCryptGetProvParamW(
    IN  HCRYPTPROV      hProv,
    IN  DWORD           dwParam,
    OUT WCHAR**         ppwsz
)
{
    CHAR*   psz         = NULL;
    WCHAR*  pwszTemp    = NULL;
    DWORD   cb;
    int     count;
    BOOL    fSuccess;
    DWORD   dwErr       = NO_ERROR;

    fSuccess = CryptGetProvParam(hProv, dwParam, NULL, &cb, 0);

    if (!fSuccess)
    {
        dwErr = GetLastError();
        EapTlsTrace("CryptGetProvParam failed and returned 0x%x", dwErr);
        goto LDone;
    }

    psz = (CHAR*)LocalAlloc(LPTR, cb);

    if (NULL == psz)
    {
        dwErr = GetLastError();
        EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
        goto LDone;
    }

    fSuccess = CryptGetProvParam(hProv, dwParam, (BYTE*)psz, &cb, 0);

    if (!fSuccess)
    {
        dwErr = GetLastError();
        EapTlsTrace("CryptGetProvParam failed and returned 0x%x", dwErr);
        goto LDone;
    }

    count = MultiByteToWideChar(CP_UTF8, 0, psz, -1, NULL, 0);

    if (0 == count)
    {
        dwErr = GetLastError();
        EapTlsTrace("MultiByteToWideChar(%s) failed: %d", psz, dwErr);
        goto LDone;
    }

    pwszTemp = (WCHAR*)LocalAlloc(LPTR, count * sizeof(WCHAR));

    if (NULL == pwszTemp)
    {
        dwErr = GetLastError();
        EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
        goto LDone;
    }

    count = MultiByteToWideChar(CP_UTF8, 0, psz, -1, pwszTemp, count);

    if (0 == count)
    {
        dwErr = GetLastError();
        EapTlsTrace("MultiByteToWideChar(%s) failed: %d", psz, dwErr);
        goto LDone;
    }

    *ppwsz = pwszTemp;
    pwszTemp = NULL;

LDone:

    LocalFree(pwszTemp);
    LocalFree(psz);
    return(dwErr);
}

/*

Returns:

Notes:
    This internal routine generates a certificate context with (static)
    keyprov info suitable for CertStore-based operations.
    
*/

DWORD
BuildCertContext(
    IN  HCRYPTPROV      hProv,
    IN  BYTE*           pbCert,
    IN  DWORD           dwCertLen,
    OUT PCCERT_CONTEXT* ppCertContext
)
{
    CRYPT_KEY_PROV_INFO     KeyProvInfo;
    WCHAR*                  pwszContainerName   = NULL;
    WCHAR*                  pwszProviderName    = NULL;
    BOOL                    fCertContextCreated = FALSE;
    BOOL                    fSuccess;
    DWORD                   dwErr               = NO_ERROR;

    if (   (0 == hProv)
        || (NULL == pbCert)
        || (0 == dwCertLen))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto LDone;
    }

    RTASSERT(NULL != ppCertContext);

    // Convert the certificate into a cert context.

    *ppCertContext = CertCreateCertificateContext(
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        pbCert, dwCertLen);

    if (NULL == *ppCertContext)
    {
        dwErr = GetLastError();
        EapTlsTrace("CertCreateCertificateContext failed and returned 0x%x",
            dwErr);
        goto LDone;
    }

    fCertContextCreated = TRUE;

    //  Associate cryptprovider w/ the private key property of this cert

    dwErr = LocalCryptGetProvParamW(hProv, PP_CONTAINER, &pwszContainerName);

    if (NO_ERROR != dwErr)
    {
        goto LDone;
    }

    EapTlsTrace("Container: %ws", pwszContainerName);

    dwErr = LocalCryptGetProvParamW(hProv, PP_NAME, &pwszProviderName);

    if (NO_ERROR != dwErr)
    {
        goto LDone;
    }

    EapTlsTrace("Provider: %ws", pwszProviderName);

    // Set the cert context properties to reflect the prov info

    KeyProvInfo.pwszContainerName = pwszContainerName;
    KeyProvInfo.pwszProvName      = pwszProviderName;
    KeyProvInfo.dwProvType        = PROV_RSA_FULL;
    KeyProvInfo.dwFlags           = 0;
    KeyProvInfo.cProvParam        = 0;
    KeyProvInfo.rgProvParam       = NULL;
    KeyProvInfo.dwKeySpec         = AT_KEYEXCHANGE;

    fSuccess = CertSetCertificateContextProperty(
                    *ppCertContext,
                    CERT_KEY_PROV_INFO_PROP_ID,
                    0, 
                    (void *)&KeyProvInfo);

    if (!fSuccess)
    {
        dwErr = GetLastError();
        EapTlsTrace("CertSetCertificateContextProperty failed and returned "
            "0x%x", dwErr);
        goto LDone;
    }
    

LDone:

    if (NO_ERROR != dwErr)
    {
        if (fCertContextCreated)
        {
            CertFreeCertificateContext(*ppCertContext);
        }

        *ppCertContext = NULL;
    }

    LocalFree(pwszContainerName);
    LocalFree(pwszProviderName);

    return(dwErr);
}

/*

Returns:

Notes:
    The "Select Card" common dialog is raised, then the certificate is read 
    from the card, a certificate context complete with key prov info is 
    migrated to the cert store and also returned to the caller.

*/

DWORD
GetCertFromCard(
    OUT PCCERT_CONTEXT* ppCertContext
)
{
    CHAR*           pszReader       = NULL;
    CHAR*           pszCard         = NULL;
    DWORD           cbReaderOrCard  = MAX_PATH;
    SCARDCONTEXT    hContext        = 0;
    OPENCARDNAMEA   OpenCardName;
    CHAR*           pszProviderName = NULL;
    DWORD           cchProvider;
    HCRYPTPROV      hProv           = 0;
    HCRYPTKEY       hKey            = 0;
    DWORD           cbCertLen;
    BYTE*           pbCert          = NULL;
    HCERTSTORE      hCertStore      = NULL;

    BOOL            fSuccess;
    LONG            lErr;
    DWORD           dwErr           = NO_ERROR;

    EapTlsTrace("GetCertFromCard");

    RTASSERT(NULL != ppCertContext);

    dwErr = LoadScardDlgDll();

    if (NO_ERROR != dwErr)
    {
        goto LDone;
    }

    pszReader = (BYTE*)LocalAlloc(LPTR, cbReaderOrCard);

    if (NULL == pszReader)
    {
        dwErr = GetLastError();
        EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
        goto LDone;
    }

    pszCard = (BYTE*)LocalAlloc(LPTR, cbReaderOrCard);

    if (NULL == pszCard)
    {
        dwErr = GetLastError();
        EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
        goto LDone;
    }

    lErr = SCardEstablishContext(SCARD_SCOPE_USER, NULL, NULL, &hContext);

    if (SCARD_S_SUCCESS != lErr)
    {
        dwErr = lErr;
        EapTlsTrace("SCardEstablishContext failed and returned 0x%x", dwErr);
        goto LDone;
    }

    ZeroMemory(&OpenCardName, sizeof(OpenCardName));

    OpenCardName.dwStructSize           = sizeof(OpenCardName);
    OpenCardName.hSCardContext          = hContext;
    OpenCardName.lpstrCardNames         = NULL;
    OpenCardName.lpstrRdr               = pszReader;
    OpenCardName.nMaxRdr                = cbReaderOrCard;
    OpenCardName.lpstrCard              = pszCard;
    OpenCardName.nMaxCard               = cbReaderOrCard;
    OpenCardName.lpstrTitle             = "Select smartcard";
    OpenCardName.dwFlags                = SC_DLG_MINIMAL_UI;
    OpenCardName.dwShareMode            = 0;
    OpenCardName.dwPreferredProtocols   = 0;

    lErr = g_fnGetOpenCardNameA(&OpenCardName);

    if (SCARD_S_SUCCESS != lErr)
    {
        dwErr = lErr;
        EapTlsTrace("GetOpenCardNameA failed and returned 0x%x", dwErr);
        goto LDone;
    }

    EapTlsTrace("Reader: %s, Card: %s", pszReader, pszCard);

    RTASSERT(0 == OpenCardName.hCardHandle);

    pszProviderName = NULL;
    cchProvider = SCARD_AUTOALLOCATE;

    lErr = SCardGetCardTypeProviderNameA(hContext, OpenCardName.lpstrCard,
                SCARD_PROVIDER_CSP, (CHAR*) &pszProviderName, &cchProvider);

    if (SCARD_S_SUCCESS != lErr)
    {
        dwErr = lErr;
        EapTlsTrace("SCardGetCardTypeProviderNameA failed and returned 0x%x",
            dwErr);
        goto LDone;
    }

    if (NULL != pszProviderName)
    {
        EapTlsTrace("Provider: %s", pszProviderName);
    }

    // Load the CSP 

    fSuccess = CryptAcquireContext(&hProv, NULL /* default container */,
                    pszProviderName, PROV_RSA_FULL,
                    CRYPT_SILENT /* or 0, to show CSP UI as needed */);

    if (!fSuccess)
    {
        dwErr = GetLastError();
        EapTlsTrace("CryptAcquireContext failed and returned 0x%x", dwErr);
        goto LDone;
    }

    // Get the key handle.

    fSuccess = CryptGetUserKey(hProv, AT_KEYEXCHANGE, &hKey);

    if (!fSuccess)
    {
        dwErr = GetLastError();
        EapTlsTrace("CryptGetUserKey failed and returned 0x%x", dwErr);
        goto LDone;
    }

    // Upload the certificate.

    cbCertLen = 0;

    fSuccess = CryptGetKeyParam(hKey, KP_CERTIFICATE, NULL, &cbCertLen, 0);

    if (!fSuccess)
    {
        dwErr = GetLastError();

        if (ERROR_MORE_DATA != dwErr)
        {
            EapTlsTrace("CryptGetKeyParam(KP_CERTIFICATE) failed and returned "
                "0x%x", dwErr);
            goto LDone;
        }

        dwErr = NO_ERROR;
    }

    pbCert = (BYTE*)LocalAlloc(LPTR, cbCertLen);

    if (NULL == pbCert)
    {
        dwErr = GetLastError();
        EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
        goto LDone;
    }

    fSuccess = CryptGetKeyParam(hKey, KP_CERTIFICATE, pbCert, &cbCertLen, 0);

    if (!fSuccess)
    {
        dwErr = GetLastError();
        EapTlsTrace("CryptGetKeyParam(KP_CERTIFICATE) failed and returned "
            "0x%x", dwErr);
        goto LDone;
    }

    // Get the cert context...

    dwErr = BuildCertContext(hProv, pbCert, cbCertLen, ppCertContext);

    if (NO_ERROR != dwErr)
    {
        goto LDone;
    }

    // ...and migrate it to the My store

    hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, 0, hProv,
                    CERT_SYSTEM_STORE_CURRENT_USER, "MY");

    if (NULL == hCertStore)
    {
        dwErr = GetLastError();
        EapTlsTrace("CertOpenStore failed and returned 0x%x", dwErr);
        goto LDone;
    }

    fSuccess = CertAddCertificateContextToStore(hCertStore, *ppCertContext,
                    CERT_STORE_ADD_REPLACE_EXISTING, NULL);

    if (!fSuccess)
    {
        // This is OK. Don't return an error.

        EapTlsTrace("CertAddCertificateContextToStore failed and returned 0x%x",
            GetLastError());
    }

LDone:

    LocalFree(pszReader);
    LocalFree(pszCard);
    LocalFree(pbCert);

    if (0 != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }

    if (NULL != hCertStore)
    {
        CertCloseStore(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
    }

    if (NULL != pszProviderName)
    {
        SCardFreeMemory(hContext, pszProviderName);
    }

    if (0 != hContext)
    {
        SCardReleaseContext(hContext);
    }

    if (0 != hKey)
    {
        CryptDestroyKey(hKey);
    }

    RTASSERT(   (NO_ERROR == dwErr)
             || (NULL == *ppCertContext));

    if (   (NULL == *ppCertContext)
        && (NO_ERROR == dwErr))
    {
        EapTlsTrace("CertContext is NULL. Returning E_FAIL");
        dwErr = E_FAIL;
    }

    if (   (SCARD_W_CANCELLED_BY_USER == dwErr)
        || (SCARD_E_NO_READERS_AVAILABLE == dwErr))
    {
        dwErr = ERROR_CANCELLED;
    }

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\eaptls\util.c ===
/*

Copyright (c) 1997, Microsoft Corporation, all rights reserved

Description:

History:
    Nov 1997: Vijay Baliga created original version.
    Sep 1998: Vijay Baliga moved functions from eaptls.c and dialog.c to util.c    

*/

#include <nt.h>         // Required by windows.h
#include <ntrtl.h>      // Required by windows.h
#include <nturtl.h>     // Required by windows.h
#include <windows.h>    // Win32 base API's

#include <rasauth.h>    // Required by raseapif.h
#include <rtutils.h>    // For RTASSERT
#include <rasman.h>     // For EAPLOGONINFO
#include <wintrust.h>
#include <softpub.h>
#include <mscat.h>

#define SECURITY_WIN32
#include <security.h>   // For GetUserNameExA, CredHandle
#include <schannel.h>
#include <sspi.h>       // For CredHandle


#include <wincrypt.h>   // Required by sclogon.h
#include <winscard.h>   // For SCardListReadersA
#include <sclogon.h>    // For ScHelperGetCertFromLogonInfo
#include <cryptui.h>
#include <stdlib.h>
#include <raserror.h>
#include <commctrl.h>
#include <eaptypeid.h>
#include <eaptls.h>
#include <wincred.h>
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

extern CRITICAL_SECTION g_csProtectCachedCredentials;
extern BOOL             g_fCriticalSectionInitialized;
/*

Returns:
    void

Notes:
    Used for printing EAP TLS trace statements.
    
*/

VOID   
EapTlsTrace(
    IN  CHAR*   Format, 
    ... 
) 
{
    va_list arglist;

    RTASSERT(NULL != Format);

    va_start(arglist, Format);

    TraceVprintfExA(g_dwEapTlsTraceId, 
        0x00010000 | TRACE_USE_MASK | TRACE_USE_MSEC,
        Format,
        arglist);

    va_end(arglist);
}


HINSTANCE
GetResouceDLLHInstance(
    VOID
)
{
    static HINSTANCE hResourceModule = NULL;

    EapTlsTrace("GetResouceDLLHInstance");

    if ( !hResourceModule )
    {
        //
        // Change the name of this DLL as required for each service pack
        //

        hResourceModule = LoadLibrary ( L"xpsp1res.dll");
        if ( NULL == hResourceModule )
        {
            EapTlsTrace("LoadLibraryEx failed and returned %d",GetLastError());

        }
    }
    return(hResourceModule);
}


#if WINVER > 0x0500

DWORD CheckCallerIdentity ( HANDLE hWVTStateData )
{
    DWORD                       dwRetCode         = ERROR_ACCESS_DENIED;
    PCRYPT_PROVIDER_DATA        pProvData         = NULL;
    PCCERT_CHAIN_CONTEXT        pChainContext     = NULL;
    PCRYPT_PROVIDER_SGNR        pProvSigner       = NULL;
    CERT_CHAIN_POLICY_PARA      chainpolicyparams;
    CERT_CHAIN_POLICY_STATUS    chainpolicystatus;

    if (!(pProvData = WTHelperProvDataFromStateData(hWVTStateData)))
    {        
        goto done;
    }

    if (!(pProvSigner = WTHelperGetProvSignerFromChain(pProvData, 0, FALSE, 0)))
    {
        goto done;
    }

    chainpolicyparams.cbSize = sizeof(CERT_CHAIN_POLICY_PARA);

    //
    //
    // We do want to test for microsoft test root flags. and dont care 
    // for revocation flags...
    //
    chainpolicyparams.dwFlags = CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG |
                                CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG |
                                CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS;

    pChainContext = pProvSigner->pChainContext;


    if (!CertVerifyCertificateChainPolicy (
        CERT_CHAIN_POLICY_MICROSOFT_ROOT,
        pChainContext,
        &chainpolicyparams,
        &chainpolicystatus)) 
    {
        goto done;
    }
    else
    {
        if ( S_OK == chainpolicystatus.dwError )
        {
            dwRetCode = NO_ERROR;
        }
        else
        {
            //
            // Check the base policy to see if this 
            // is a Microsoft test root
            //
            if (!CertVerifyCertificateChainPolicy (
                CERT_CHAIN_POLICY_BASE,
                pChainContext,
                &chainpolicyparams,
                &chainpolicystatus)) 
            {
                goto done;
            }
            else
            {
                if ( S_OK == chainpolicystatus.dwError )
                {
                    dwRetCode = NO_ERROR;
                }
            }
            
        }
    }

done:
    return dwRetCode;
}



/*
*/

DWORD VerifyCallerTrust ( void * callersAddress )
{
    DWORD                       dwRetCode = NO_ERROR;
    HRESULT                     hr = S_OK;
    WINTRUST_DATA               wtData;
    WINTRUST_FILE_INFO          wtFileInfo;
    WINTRUST_CATALOG_INFO       wtCatalogInfo;
    BOOL                        fRet = FALSE;
    HCATADMIN                   hCATAdmin = NULL;
    static    BOOL              fOKToUseTLS = FALSE;

    GUID                    guidPublishedSoftware = WINTRUST_ACTION_GENERIC_VERIFY_V2;

    //
    // Following GUID is Mirosoft's Catalog System Root 
    //
    GUID                    guidCatSystemRoot = { 0xf750e6c3, 0x38ee, 0x11d1,{ 0x85, 0xe5, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } };
    HCATINFO                hCATInfo = NULL;
    CATALOG_INFO            CatInfo;
    HANDLE                  hFile = INVALID_HANDLE_VALUE;
    BYTE                    bHash[40];
    DWORD                   cbHash = 40;
    MEMORY_BASIC_INFORMATION        mbi;
    SIZE_T                          nbyte;
    DWORD                           nchar;
    wchar_t                         callersModule[MAX_PATH + 1];    


    if ( fOKToUseTLS )
    {
        goto done;
    }
    EapTlsTrace("Verifying caller...");  


    nbyte = VirtualQuery(
                callersAddress,
                &mbi,
                sizeof(mbi)
                );

    if (nbyte < sizeof(mbi))
    {
        dwRetCode = ERROR_ACCESS_DENIED;
        EapTlsTrace("Unauthorized use of TLS attempted");  
        goto done;
    }

    nchar = GetModuleFileNameW(
                (HMODULE)(mbi.AllocationBase),
                callersModule,
                MAX_PATH
                );

    if (nchar == 0)
    {
        dwRetCode = GetLastError();
        EapTlsTrace("Unauthorized use of TLS attempted");
        goto done;
    }


    //
    //
    // Try and see if WinVerifyTrust will verify
    // the signature as a standalone file
    //
    //

    ZeroMemory ( &wtData, sizeof(wtData) );
    ZeroMemory ( &wtFileInfo, sizeof(wtFileInfo) );


    wtData.cbStruct = sizeof(wtData);
    wtData.dwUIChoice = WTD_UI_NONE;
    wtData.fdwRevocationChecks = WTD_REVOKE_NONE;
    wtData.dwStateAction = WTD_STATEACTION_VERIFY;
    wtData.dwUnionChoice = WTD_CHOICE_FILE;
    wtData.pFile = &wtFileInfo;

    wtFileInfo.cbStruct = sizeof( wtFileInfo );
    wtFileInfo.pcwszFilePath = callersModule;

    hr = WinVerifyTrust (   NULL, 
                            &guidPublishedSoftware, 
                            &wtData
                        );

    if ( ERROR_SUCCESS == hr )
    {   
        //
        // Check to see if this is indeed microsoft
        // signed caller
        //
        dwRetCode = CheckCallerIdentity( wtData.hWVTStateData);
        wtData.dwStateAction = WTD_STATEACTION_CLOSE;
        WinVerifyTrust(NULL, &guidPublishedSoftware, &wtData);
        goto done;

    }

    wtData.dwStateAction = WTD_STATEACTION_CLOSE;
    WinVerifyTrust(NULL, &guidPublishedSoftware, &wtData);

    //
    // We did not find the file was signed.
    // So check the system catalog to see if
    // the file is in the catalog and the catalog 
    // is signed
    //

    //
    // Open the file
    //
    hFile = CreateFile (    callersModule,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                        );


    if ( INVALID_HANDLE_VALUE == hFile )
    {
        dwRetCode = GetLastError();
        goto done;

    }


    fRet = CryptCATAdminAcquireContext( &hCATAdmin,
                                        &guidCatSystemRoot,
                                        0
                                      );
    if ( !fRet )
    {
        dwRetCode = GetLastError();
        goto done;
    }

    //
    // Get the hash of the file here
    //

    fRet = CryptCATAdminCalcHashFromFileHandle ( hFile, 
                                                 &cbHash,
                                                 bHash,
                                                 0
                                                );

    if ( !fRet )
    {
        dwRetCode = GetLastError();
        goto done;
    }

    ZeroMemory(&CatInfo, sizeof(CatInfo));
    CatInfo.cbStruct = sizeof(CatInfo);

    ZeroMemory( &wtCatalogInfo, sizeof(wtCatalogInfo) );

    wtData.dwUnionChoice = WTD_CHOICE_CATALOG;
    wtData.dwStateAction = WTD_STATEACTION_VERIFY;
    wtData.pCatalog = &wtCatalogInfo;

    wtCatalogInfo.cbStruct = sizeof(wtCatalogInfo);

    wtCatalogInfo.hMemberFile = hFile;

    wtCatalogInfo.pbCalculatedFileHash = bHash;
    wtCatalogInfo.cbCalculatedFileHash = cbHash; 


    while ( ( hCATInfo = CryptCATAdminEnumCatalogFromHash ( hCATAdmin,
                                                            bHash,
                                                            cbHash,
                                                            0,
                                                            &hCATInfo
                                                          )
            )
          )
    {
        if (!(CryptCATCatalogInfoFromContext(hCATInfo, &CatInfo, 0)))
        {
            // should do something (??)
            continue;
        }

        wtCatalogInfo.pcwszCatalogFilePath = CatInfo.wszCatalogFile;

        hr = WinVerifyTrust (   NULL, 
                                &guidPublishedSoftware, 
                                &wtData
                            );

        if ( ERROR_SUCCESS == hr )
        {
            //
            // Verify that this file is trusted
            //

            dwRetCode = CheckCallerIdentity( wtData.hWVTStateData);
            wtData.dwStateAction = WTD_STATEACTION_CLOSE;
            WinVerifyTrust(NULL, &guidPublishedSoftware, &wtData);

            goto done;
        }
                                
    }

    //
    // File not found in any of the catalogs
    //
    dwRetCode = ERROR_ACCESS_DENIED;
                                                            

    

done:

    if ( hCATInfo )
    {
        CryptCATAdminReleaseCatalogContext( hCATAdmin, hCATInfo, 0 );
    }
    if ( hCATAdmin )
    {
        CryptCATAdminReleaseContext( hCATAdmin, 0 );
    }
    if ( hFile )
    {
        CloseHandle(hFile);
    }
    if ( NO_ERROR == dwRetCode )
        fOKToUseTLS = TRUE;
    return dwRetCode;
}

#endif
/*

Returns:
    NO_ERROR: iff Success

Notes:
    TraceRegister, RouterLogRegister, etc.
    
*/
extern g_CachedCreds[];
DWORD
EapTlsInitialize2(
    IN  BOOL    fInitialize,
    IN  BOOL    fUI
)
{
    static  DWORD   dwRefCount          = 0;
    DWORD           dwRetCode           = NO_ERROR; 

    if (fInitialize)
    {
        if (0 == dwRefCount)
        {
            ZeroMemory ( &(g_CachedCreds[0]), 
                sizeof(g_CachedCreds[0]) );
            ZeroMemory ( &(g_CachedCreds[1]), 
                         sizeof(g_CachedCreds[0]) );

            if (fUI)
            {
                g_dwEapTlsTraceId = TraceRegister(L"RASTLSUI");
               //
               // Initialize the common controls library for the controls we use.
               //
               {
                   INITCOMMONCONTROLSEX icc;
                   icc.dwSize = sizeof(icc);
                   icc.dwICC  = ICC_LISTVIEW_CLASSES;
                   InitCommonControlsEx (&icc);
               }
            }
            else
            {
                
                g_dwEapTlsTraceId = TraceRegister(L"RASTLS");
                
            }
            InitializeCriticalSection( &g_csProtectCachedCredentials );
            g_fCriticalSectionInitialized = TRUE;
            EapTlsTrace("EapTlsInitialize2");
        }

        dwRefCount++;
    }
    else
    {
        dwRefCount--;

        if (0 == dwRefCount)
        {
            EapTlsTrace("EapTls[Un]Initialize2");

            if (INVALID_TRACEID != g_dwEapTlsTraceId)
            {
                TraceDeregister(g_dwEapTlsTraceId);
                g_dwEapTlsTraceId = INVALID_TRACEID;
            }
            if ( g_fCriticalSectionInitialized )
            {
                DeleteCriticalSection( &g_csProtectCachedCredentials );
                g_fCriticalSectionInitialized = FALSE;
            }
            FreeScardDlgDll();
        }
    }

    return(dwRetCode);
}


/*

Returns:
    NO_ERROR: iff Success

Notes:
    
*/

DWORD
EapTlsInitialize(
    IN  BOOL    fInitialize
)
{

    return EapTlsInitialize2(fInitialize, FALSE /* fUI */);

}

/*

Returns:

Notes:
    Obfuscate PIN in place to foil memory scans for PINs.

*/

VOID
EncodePin(
    IN  EAPTLS_USER_PROPERTIES* pUserProp
)
{
    UNICODE_STRING  UnicodeString;
    UCHAR           ucSeed          = 0;

    RtlInitUnicodeString(&UnicodeString, pUserProp->pwszPin);
    RtlRunEncodeUnicodeString(&ucSeed, &UnicodeString);
    pUserProp->usLength = UnicodeString.Length;
    pUserProp->usMaximumLength = UnicodeString.MaximumLength;
    pUserProp->ucSeed = ucSeed;
}

/*

Returns:

Notes:

*/

VOID
DecodePin(
    IN  EAPTLS_USER_PROPERTIES* pUserProp
)
{
    UNICODE_STRING  UnicodeString;

    UnicodeString.Length = pUserProp->usLength;
    UnicodeString.MaximumLength = pUserProp->usMaximumLength;
    UnicodeString.Buffer = pUserProp->pwszPin;
    RtlRunDecodeUnicodeString(pUserProp->ucSeed, &UnicodeString);
}

/*

Returns:
    TRUE: Success
    FALSE: Failure

Notes:
    Converts FileTime to a printable form in *ppwszTime. If the function returns
    TRUE, the caller must ultimately call LocalFree(*ppwszTime).
    
*/

BOOL
FFileTimeToStr(
    IN  FILETIME    FileTime,
    OUT WCHAR**     ppwszTime
)
{
    SYSTEMTIME          SystemTime;
    FILETIME            LocalTime;
    int                 nBytesDate;
    int                 nBytesTime;
    WCHAR*              pwszTemp        = NULL;
    BOOL                fRet            = FALSE;

    RTASSERT(NULL != ppwszTime);

    if (!FileTimeToLocalFileTime(&FileTime, &LocalTime))
    {
        EapTlsTrace("FileTimeToLocalFileTime(%d %d) failed and returned %d",
            FileTime.dwLowDateTime, FileTime.dwHighDateTime,
            GetLastError());

        goto LDone;
    }

    if (!FileTimeToSystemTime(&LocalTime, &SystemTime))
    {
        EapTlsTrace("FileTimeToSystemTime(%d %d) failed and returned %d",
            LocalTime.dwLowDateTime, LocalTime.dwHighDateTime,
            GetLastError());

        goto LDone;
    }

    nBytesDate = GetDateFormat(LOCALE_USER_DEFAULT, 0, &SystemTime, NULL,
                    NULL, 0);

    if (0 == nBytesDate)
    {
        EapTlsTrace("GetDateFormat(%d %d %d %d %d %d %d %d) failed and "
            "returned %d",
            SystemTime.wYear, SystemTime.wMonth, SystemTime.wDayOfWeek,
            SystemTime.wDay, SystemTime.wHour, SystemTime.wMinute,
            SystemTime.wSecond, SystemTime.wMilliseconds,
            GetLastError());

        goto LDone;
    }

    nBytesTime = GetTimeFormat(LOCALE_USER_DEFAULT, 0, &SystemTime, NULL,
                    NULL, 0);

    if (0 == nBytesTime)
    {
        EapTlsTrace("GetTimeFormat(%d %d %d %d %d %d %d %d) failed and "
            "returned %d",
            SystemTime.wYear, SystemTime.wMonth, SystemTime.wDayOfWeek,
            SystemTime.wDay, SystemTime.wHour, SystemTime.wMinute,
            SystemTime.wSecond, SystemTime.wMilliseconds,
            GetLastError());

        goto LDone;
    }

    pwszTemp = LocalAlloc(LPTR, (nBytesDate + nBytesTime)*sizeof(WCHAR));

    if (NULL == pwszTemp)
    {
        EapTlsTrace("LocalAlloc failed and returned %d", GetLastError());
        goto LDone;
    }

    if (0 == GetDateFormat(LOCALE_USER_DEFAULT, 0, &SystemTime, NULL,
                    pwszTemp, nBytesDate))
    {
        EapTlsTrace("GetDateFormat(%d %d %d %d %d %d %d %d) failed and "
            "returned %d",
            SystemTime.wYear, SystemTime.wMonth, SystemTime.wDayOfWeek,
            SystemTime.wDay, SystemTime.wHour, SystemTime.wMinute,
            SystemTime.wSecond, SystemTime.wMilliseconds,
            GetLastError());

        goto LDone;
    }

    pwszTemp[nBytesDate - 1] = L' ';

    if (0 == GetTimeFormat(LOCALE_USER_DEFAULT, 0, &SystemTime, NULL,
                    pwszTemp + nBytesDate, nBytesTime))
    {
        EapTlsTrace("GetTimeFormat(%d %d %d %d %d %d %d %d) failed and "
            "returned %d",
            SystemTime.wYear, SystemTime.wMonth, SystemTime.wDayOfWeek,
            SystemTime.wDay, SystemTime.wHour, SystemTime.wMinute,
            SystemTime.wSecond, SystemTime.wMilliseconds,
            GetLastError());

        goto LDone;
    }

    *ppwszTime = pwszTemp;
    pwszTemp = NULL;
    fRet = TRUE;

LDone:

    LocalFree(pwszTemp);
    return(fRet);
}


BOOL FFormatMachineIdentity1 ( LPWSTR lpszMachineNameRaw, LPWSTR * lppszMachineNameFormatted )
{
    BOOL        fRetVal = FALSE;
    LPWSTR      lpwszPrefix = L"host/";

    RTASSERT(NULL != lpszMachineNameRaw );
    RTASSERT(NULL != lppszMachineNameFormatted );
    
    //
    // Prepend host/ to the UPN name
    //

    *lppszMachineNameFormatted = 
        (LPWSTR)LocalAlloc ( LPTR, ( wcslen ( lpszMachineNameRaw ) + wcslen ( lpwszPrefix ) + 2 )  * sizeof(WCHAR) );
    if ( NULL == *lppszMachineNameFormatted )
    {
        goto done;
    }
    
    wcscpy( *lppszMachineNameFormatted, lpwszPrefix );
    wcscat ( *lppszMachineNameFormatted, lpszMachineNameRaw ); 
    fRetVal = TRUE;
done:
    return fRetVal;
}

/*
   Returns:
    TRUE: Success
    FALSE: Failure
Notes:
    Gets the machine name from the cert as a fully qualified path hostname/path
    for example, hostname.redmond.microsoft.com and reformats it in the 
    domain\hostname format.
*/

BOOL FFormatMachineIdentity ( LPWSTR lpszMachineNameRaw, LPWSTR * lppszMachineNameFormatted )
{
    BOOL        fRetVal = TRUE;
    LPTSTR      s1 = lpszMachineNameRaw;
    LPTSTR      s2 = NULL;

    RTASSERT(NULL != lpszMachineNameRaw );
    RTASSERT(NULL != lppszMachineNameFormatted );
    //Need to add 2 more chars.  One for NULL and other for $ sign
    *lppszMachineNameFormatted = (LPTSTR )LocalAlloc ( LPTR, (wcslen(lpszMachineNameRaw) + 2)* sizeof(WCHAR) );
    if ( NULL == *lppszMachineNameFormatted )
    {
		return FALSE;
    }
    //find the first "." and that is the identity of the machine.
    //the second "." is the domain.
    //check to see if there at least 2 dots.  If not the raw string is 
    //the output string
    
    while ( *s1 )
    {
        if ( *s1 == '.' )
        {
            if ( !s2 )      //First dot
                s2 = s1;
            else            //second dot
                break;
        }
        s1++;
    }
    //can perform several additional checks here
    
    if ( *s1 != '.' )       //there are no 2 dots so raw = formatted
    {
        wcscpy ( *lppszMachineNameFormatted, lpszMachineNameRaw );
        goto done;
    }
    if ( s1-s2 < 2 )
    {
        wcscpy ( *lppszMachineNameFormatted, lpszMachineNameRaw );
        goto done;
    }
    memcpy ( *lppszMachineNameFormatted, s2+1, ( s1-s2-1) * sizeof(WCHAR));
    memcpy ( (*lppszMachineNameFormatted) + (s1-s2-1) , L"\\", sizeof(WCHAR));
    wcsncpy ( (*lppszMachineNameFormatted) + (s1-s2), lpszMachineNameRaw, s2-lpszMachineNameRaw );      

    
done:
	
	//Append the $ sign no matter what...
    wcscat ( *lppszMachineNameFormatted, L"$" );
    return fRetVal;
}

/*

Returns:
    TRUE: Success
    FALSE: Failure

Notes:
    Gets the name in the cert pointed to by pCertContext, and converts it to a 
    printable form in *ppwszName. If the function returns TRUE, the caller must
    ultimately call LocalFree(*ppwszName).
    
*/

BOOL
FUserCertToStr(
    IN  PCCERT_CONTEXT  pCertContext,
    OUT WCHAR**         ppwszName
)
{
    DWORD                   dwExtensionIndex;
    DWORD                   dwAltEntryIndex;
    CERT_EXTENSION*         pCertExtension;
    CERT_ALT_NAME_INFO*     pCertAltNameInfo;
    CERT_ALT_NAME_ENTRY*    pCertAltNameEntry;
    CERT_NAME_VALUE*        pCertNameValue;
    DWORD                   dwCertAltNameInfoSize;
    DWORD                   dwCertNameValueSize;
    WCHAR*                  pwszName                    = NULL;
    BOOL                    fExitOuterFor;
    BOOL                    fExitInnerFor;
    BOOL                    fRet                        = FALSE;

    // See if cert has UPN in AltSubjectName->otherName

    fExitOuterFor = FALSE;

    for (dwExtensionIndex = 0;
         dwExtensionIndex < pCertContext->pCertInfo->cExtension; 
         dwExtensionIndex++)
    {
        pCertAltNameInfo = NULL;

        pCertExtension = pCertContext->pCertInfo->rgExtension+dwExtensionIndex;

        if (strcmp(pCertExtension->pszObjId, szOID_SUBJECT_ALT_NAME2) != 0)
        {
            goto LOuterForEnd;
        }

        dwCertAltNameInfoSize = 0;

        if (!CryptDecodeObjectEx(
                    pCertContext->dwCertEncodingType,
                    X509_ALTERNATE_NAME,
                    pCertExtension->Value.pbData,
                    pCertExtension->Value.cbData,
                    CRYPT_DECODE_ALLOC_FLAG,
                    NULL,
                    (VOID*)&pCertAltNameInfo,
                    &dwCertAltNameInfoSize))
        {
            goto LOuterForEnd;
        }

        fExitInnerFor = FALSE;

        for (dwAltEntryIndex = 0;
             dwAltEntryIndex < pCertAltNameInfo->cAltEntry;
             dwAltEntryIndex++)
        {
            pCertNameValue = NULL;

            pCertAltNameEntry = pCertAltNameInfo->rgAltEntry + dwAltEntryIndex;

            if (   (CERT_ALT_NAME_OTHER_NAME !=
                        pCertAltNameEntry->dwAltNameChoice)
                || (NULL == pCertAltNameEntry->pOtherName)
                || (0 != strcmp(szOID_NT_PRINCIPAL_NAME, 
                            pCertAltNameEntry->pOtherName->pszObjId)))
            {
                goto LInnerForEnd;
            }

            // We found a UPN!

            dwCertNameValueSize = 0;

            if (!CryptDecodeObjectEx(
                        pCertContext->dwCertEncodingType,
                        X509_UNICODE_ANY_STRING,
                        pCertAltNameEntry->pOtherName->Value.pbData,
                        pCertAltNameEntry->pOtherName->Value.cbData,
                        CRYPT_DECODE_ALLOC_FLAG,
                        NULL,
                        (VOID*)&pCertNameValue,
                        &dwCertNameValueSize))
            {
                goto LInnerForEnd;
            }

            // One extra char for the terminating NULL.
            
            pwszName = LocalAlloc(LPTR, pCertNameValue->Value.cbData +
                                            sizeof(WCHAR));

            if (NULL == pwszName)
            {
                EapTlsTrace("LocalAlloc failed and returned %d",
                    GetLastError());

                fExitInnerFor = TRUE;
                fExitOuterFor = TRUE;

                goto LInnerForEnd;
            }

            CopyMemory(pwszName, pCertNameValue->Value.pbData,
                pCertNameValue->Value.cbData);

            *ppwszName = pwszName;
            pwszName = NULL;
            fRet = TRUE;

            fExitInnerFor = TRUE;
            fExitOuterFor = TRUE;

        LInnerForEnd:

            LocalFree(pCertNameValue);

            if (fExitInnerFor)
            {
                break;
            }
        }

    LOuterForEnd:

        LocalFree(pCertAltNameInfo);

        if (fExitOuterFor)
        {
            break;
        }
    }

    LocalFree(pwszName);
    return(fRet);
}

/*

Returns:
    TRUE: Success
    FALSE: Failure

Notes:
    Gets the name in the cert pointed to by pCertContext, and converts it to a 
    printable form in *ppwszName. If the function returns TRUE, the caller must
    ultimately call LocalFree(*ppwszName).
    
*/

BOOL
FOtherCertToStr(
    IN  PCCERT_CONTEXT  pCertContext,
    IN  DWORD           fFlags,
    OUT WCHAR**         ppwszName
)
{
    WCHAR*              pwszTemp    = NULL;
    DWORD               dwSize;
    BOOL                fRet        = FALSE;
    DWORD               dwType      = 0;

    RTASSERT(NULL != ppwszName);
    dwType = CERT_NAME_SIMPLE_DISPLAY_TYPE;
    dwSize = CertGetNameString(pCertContext,dwType  ,
                fFlags, NULL, NULL, 0);

    // dwSize is the number of characters, including the terminating NULL.

    if (dwSize <= 1)
    {
        EapTlsTrace("CertGetNameString for CERT_NAME_SIMPLE_DISPLAY_TYPE failed.");
        goto LDone;
    }

    pwszTemp = LocalAlloc(LPTR, dwSize*sizeof(WCHAR));

    if (NULL == pwszTemp)
    {
        EapTlsTrace("LocalAlloc failed and returned %d", GetLastError());
        goto LDone;
    }

    dwSize = CertGetNameString(pCertContext, dwType,
                fFlags, NULL, pwszTemp, dwSize);

    if (dwSize <= 1)
    {
        EapTlsTrace("CertGetNameString failed.");
        goto LDone;
    }

    *ppwszName = pwszTemp;
    pwszTemp = NULL;
    fRet = TRUE;

LDone:

    LocalFree(pwszTemp);
    return(fRet);
}


/*

Returns:
    TRUE: Success
    FALSE: Failure

Notes:
	Special function for getting the DNS machine name 
	from the machine auth certificate
*/

BOOL 
FMachineAuthCertToStr
	( 
	IN 	PCCERT_CONTEXT 	pCertContext, 
	OUT WCHAR		**	ppwszName
	)
{

    DWORD                   dwExtensionIndex;
    DWORD                   dwAltEntryIndex;
    CERT_EXTENSION*         pCertExtension;
    CERT_ALT_NAME_INFO*     pCertAltNameInfo;
    CERT_ALT_NAME_ENTRY*    pCertAltNameEntry;    
    DWORD                   dwCertAltNameInfoSize;
    WCHAR*                  pwszName                    = NULL;
    BOOL                    fExitOuterFor;
    BOOL                    fExitInnerFor;
    BOOL                    fRet                        = FALSE;

    // See if cert has UPN in AltSubjectName->otherName

    fExitOuterFor = FALSE;

    for (dwExtensionIndex = 0;
         dwExtensionIndex < pCertContext->pCertInfo->cExtension; 
         dwExtensionIndex++)
    {
        pCertAltNameInfo = NULL;

        pCertExtension = pCertContext->pCertInfo->rgExtension+dwExtensionIndex;

        if (strcmp(pCertExtension->pszObjId, szOID_SUBJECT_ALT_NAME2) != 0)
        {
            goto LOuterForEnd;
        }

        dwCertAltNameInfoSize = 0;

        if (!CryptDecodeObjectEx(
                    pCertContext->dwCertEncodingType,
                    X509_ALTERNATE_NAME,
                    pCertExtension->Value.pbData,
                    pCertExtension->Value.cbData,
                    CRYPT_DECODE_ALLOC_FLAG,
                    NULL,
                    (VOID*)&pCertAltNameInfo,
                    &dwCertAltNameInfoSize))
        {
            goto LOuterForEnd;
        }

        fExitInnerFor = FALSE;

        for (dwAltEntryIndex = 0;
             dwAltEntryIndex < pCertAltNameInfo->cAltEntry;
             dwAltEntryIndex++)
        {
            pCertAltNameEntry = pCertAltNameInfo->rgAltEntry + dwAltEntryIndex;

            if (   (CERT_ALT_NAME_DNS_NAME !=
                        pCertAltNameEntry->dwAltNameChoice)
                || (NULL == pCertAltNameEntry->pwszDNSName)
			   )
            {
                goto LInnerForEnd;
            }

            // We found the DNS Name!


            // One extra char for the terminating NULL.
            
            pwszName = LocalAlloc(LPTR, wcslen( pCertAltNameEntry->pwszDNSName ) * sizeof(WCHAR) +
                                            sizeof(WCHAR));

            if (NULL == pwszName)
            {
                EapTlsTrace("LocalAlloc failed and returned %d",
                    GetLastError());

                fExitInnerFor = TRUE;
                fExitOuterFor = TRUE;

                goto LInnerForEnd;
            }

            wcscpy (pwszName, pCertAltNameEntry->pwszDNSName );

            *ppwszName = pwszName;
            pwszName = NULL;
            fRet = TRUE;

            fExitInnerFor = TRUE;
            fExitOuterFor = TRUE;

        LInnerForEnd:

            if (fExitInnerFor)
            {
                break;
            }
        }

    LOuterForEnd:

        LocalFree(pCertAltNameInfo);

        if (fExitOuterFor)
        {
            break;
        }
    }

    LocalFree(pwszName);
    return(fRet);

}

/*

Returns:
    TRUE: Success
    FALSE: Failure

Notes:
    Gets the name in the cert pointed to by pCertContext, and converts it to a 
    printable form in *ppwszName. If the function returns TRUE, the caller must
    ultimately call LocalFree(*ppwszName).
    
*/

BOOL
FCertToStr(
    IN  PCCERT_CONTEXT  pCertContext,
    IN  DWORD           fFlags,
    IN  BOOL            fMachineCert,
    OUT WCHAR**         ppwszName
)
{
    if (!fMachineCert)
    {
        if (FUserCertToStr(pCertContext, ppwszName))
        {
            return(TRUE);
        }
    }

    return(FOtherCertToStr(pCertContext, fFlags, ppwszName));
}


#if 0
BOOL
FGetIssuerOrSubject ( IN PCCERT_CONTEXT pCertContext, 
                 IN DWORD          dwFlags,
                 OUT WCHAR **     ppszNameString
               )
{
    BOOL            fRet = TRUE;
    DWORD           cbNameString =0;    
    LPWSTR          lpwszNameString = NULL;
    //
    // Get the issued to field here
    //
    cbNameString = CertGetNameString(pCertContext,
                                    CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                    dwFlags,
                                    NULL,
                                    lpwszNameString,
                                    0
                                   );
    if ( 0 == cbNameString )
    {
        EapTlsTrace("Name String Item not found");
        fRet = FALSE;
        goto LDone;
    }

    lpwszNameString = (LPWSTR)LocalAlloc(LPTR, cbNameString );

    if ( NULL == lpwszNameString )
    {
        EapTlsTrace("Error allocing memory for name string");
        fRet = FALSE;
        goto LDone;
    }
    
    cbNameString = CertGetNameString(pCertContext,
                                    CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                    dwFlags,
                                    NULL,
                                    lpwszNameString,
                                    cbNameString
                                   );

    *ppszNameString = lpwszNameString;
    lpwszNameString = NULL;
LDone:

    LocalFree(lpwszNameString);

    return fRet;
}
#endif
/*

Returns:
    TRUE: Success
    FALSE: Failure

Notes:
    Stores the friendly name of the cert pointed to by pCertContext in 
    *ppwszName. If the function returns TRUE, the caller must ultimately call 
    LocalFree(*ppwszName).

*/

BOOL
FGetFriendlyName(
    IN  PCCERT_CONTEXT  pCertContext,
    OUT WCHAR**         ppwszName
)
{
    WCHAR*              pwszName    = NULL;
    DWORD               dwBytes;
    BOOL                fRet        = FALSE;

    RTASSERT(NULL != ppwszName);

    if (!CertGetCertificateContextProperty(pCertContext,
            CERT_FRIENDLY_NAME_PROP_ID, NULL, &dwBytes))
    {
        // If there is no Friendly Name property, don't print an error stmt.
        goto LDone;
    }

    pwszName = LocalAlloc(LPTR, dwBytes);

    if (NULL == pwszName)
    {
        EapTlsTrace("LocalAlloc failed and returned %d", GetLastError());
        goto LDone;
    }

    if (!CertGetCertificateContextProperty(pCertContext,
            CERT_FRIENDLY_NAME_PROP_ID, pwszName, &dwBytes))
    {
        EapTlsTrace("CertGetCertificateContextProperty failed and "
            "returned 0x%x", GetLastError());
        goto LDone;
    }

    *ppwszName = pwszName;
    pwszName = NULL;
    fRet = TRUE;

LDone:

    LocalFree(pwszName);
    return(fRet);
}

/*

Returns:
    TRUE iff there is a smart card reader installed.

Notes:
    This function was provided by Doug Barlow.

    If 0 is used as the SCARDCONTEXT parameter, it just looks in the registry 
    for defined readers. This will return a list of all readers ever installed 
    on the system. To actually detect the current state of the system, we have 
    to use a valid SCARDCONTEXT handle.

*/

BOOL
FSmartCardReaderInstalled(
    VOID
)
{
    LONG            lErr;
    DWORD           dwLen   = 0;
    SCARDCONTEXT    hCtx    = 0;
    BOOL            fReturn = FALSE;

    lErr = SCardListReadersA(0, NULL, NULL, &dwLen);

    fReturn = (   (NO_ERROR == lErr)
               && (2 * sizeof(CHAR) < dwLen));

    if (!fReturn)
    {
        goto LDone;
    }

    fReturn = FALSE;

    lErr = SCardEstablishContext(SCARD_SCOPE_USER, 0, 0, &hCtx);

    if (SCARD_S_SUCCESS != lErr)
    {
        goto LDone;
    }

    lErr = SCardListReadersA(hCtx, NULL, NULL, &dwLen);

    fReturn = (   (NO_ERROR == lErr)
               && (2 * sizeof(CHAR) < dwLen));

LDone:

    if (0 != hCtx)
    {
        SCardReleaseContext(hCtx);
    }
    
    return(fReturn);
}

//Get EKU Usage Blob out of the certificate Context

DWORD DwGetEKUUsage ( 
	IN PCCERT_CONTEXT			pCertContext,
	OUT PCERT_ENHKEY_USAGE	*	ppUsage
	)
{	
    DWORD				dwBytes = 0;
	DWORD				dwErr = ERROR_SUCCESS;
	PCERT_ENHKEY_USAGE	pUsage = NULL;

    EapTlsTrace("FGetEKUUsage");

    if (!CertGetEnhancedKeyUsage(pCertContext, 0, NULL, &dwBytes))
    {
        dwErr = GetLastError();

        if (CRYPT_E_NOT_FOUND == dwErr)
        {
            EapTlsTrace("No usage in cert");            
            goto LDone;
        }

        EapTlsTrace("FGetEKUUsage failed and returned 0x%x", dwErr);
        goto LDone;
    }

    pUsage = LocalAlloc(LPTR, dwBytes);

    if (NULL == pUsage)
    {
        dwErr = GetLastError();
        EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
        goto LDone;
    }

    if (!CertGetEnhancedKeyUsage(pCertContext, 0, pUsage, &dwBytes))
    {
        dwErr = GetLastError();
        EapTlsTrace("FGetEKUUsage failed and returned 0x%x", dwErr);
        goto LDone;
    }
	*ppUsage = pUsage;	
LDone:
	return dwErr;
}


/*
* This functionw will check to see if the registry based cert is
* a smart card cert and if the context can be opened in silent
* mode.  
*/

BOOL
FCheckSCardCertAndCanOpenSilentContext ( IN PCCERT_CONTEXT pCertContext )
{
    PCERT_ENHKEY_USAGE	    pUsageInternal = NULL;
    BOOL                    fRet = TRUE;
    DWORD                   dwIndex = 0;
    CRYPT_KEY_PROV_INFO *   pCryptKeyProvInfo = NULL;
    HCRYPTPROV              hProv = 0;    
    DWORD                   dwParam = 0;
    DWORD                   dwDataLen = 0;
#if 0
    //
    // This is not required anymore.  We use CertFindChainInStore
    // which will make sure if private key exists...
    //
    HCRYPTPROV              hProv1 = 0;    
#endif

    EapTlsTrace("FCheckSCardCertAndCanOpenSilentContext");

    if ( DwGetEKUUsage ( 	pCertContext,
							&pUsageInternal) != ERROR_SUCCESS
       )
    {        
       goto LDone;
    }


    for (dwIndex = 0; dwIndex < pUsageInternal->cUsageIdentifier; dwIndex++)
    {
        if ( !strcmp(pUsageInternal->rgpszUsageIdentifier[dwIndex],
                            szOID_KP_SMARTCARD_LOGON))
        {            
            EapTlsTrace("Found SCard Cert in registey.  Skipping...");
            goto LDone;
        }
    }

    //
    //there is no scard logon oid in the cert
    //So, now check to see if the csp is mixed mode
    //
    if (!CertGetCertificateContextProperty(
                pCertContext,
                CERT_KEY_PROV_INFO_PROP_ID,
                NULL,
                &dwDataLen))
    {
        EapTlsTrace("CertGetCertificateContextProperty failed: 0x%x", GetLastError());
        goto LDone;
    }

    pCryptKeyProvInfo = LocalAlloc(LPTR, dwDataLen);

    if (NULL == pCryptKeyProvInfo)
    {
        
        EapTlsTrace("Out of memory: 0x%x", GetLastError());
        goto LDone;
    }

    if (!CertGetCertificateContextProperty(
                pCertContext,
                CERT_KEY_PROV_INFO_PROP_ID,
                pCryptKeyProvInfo,
                &dwDataLen))
    {
        EapTlsTrace("CertGetCertificateContextProperty failed: 0x%x", GetLastError());
        goto LDone;
    }
    EapTlsTrace( "Acquiring Context for Container Name: %ws, ProvName: %ws, ProvType 0x%x", 
                pCryptKeyProvInfo->pwszContainerName,
                pCryptKeyProvInfo->pwszProvName,
                pCryptKeyProvInfo->dwProvType
               );

    if (!CryptAcquireContext(
                &hProv,
                pCryptKeyProvInfo->pwszContainerName,
                pCryptKeyProvInfo->pwszProvName,
                pCryptKeyProvInfo->dwProvType,
                (pCryptKeyProvInfo->dwFlags &
                 ~CERT_SET_KEY_PROV_HANDLE_PROP_ID) |
                 CRYPT_SILENT))
    {
        DWORD dwErr = GetLastError();
        /*
        if ( SCARD_E_NO_SMARTCARD == dwErr )
        {
            //This CSP requires a smart card do this is a smart
            //card cert in registry
            fRet = TRUE;
        }
        */
        EapTlsTrace("CryptAcquireContext failed. This CSP cannot be opened in silent mode.  skipping cert.Err: 0x%x", dwErr);
        goto LDone;
    }
    dwDataLen = sizeof(dwParam);
    if ( !CryptGetProvParam (   hProv,
                                PP_IMPTYPE,
                                (BYTE *)&dwParam,
                                &dwDataLen,
                                0
                            ))
    {
        EapTlsTrace("CryptGetProvParam failed: 0x%x", GetLastError());
        goto LDone;
    }
    
    //now check to see if CSP is MIXED
    if ( ( dwParam & (CRYPT_IMPL_MIXED | CRYPT_IMPL_REMOVABLE) ) == 
         (CRYPT_IMPL_MIXED | CRYPT_IMPL_REMOVABLE)
       )
    {
        EapTlsTrace("Found SCard Cert in registey.  Skipping...");
        goto LDone;
    }
    

#if 0
    //
    // This is not required anymore.  We use CertFindChainInStore 
    // which will make sure that private key exists...
    //

    //
    // Check to see if we have the private 
    // key corresponding to this cert
    // if not drop this cert.


    if (!CryptAcquireCertificatePrivateKey(
               pCertContext,
               CRYPT_ACQUIRE_COMPARE_KEY_FLAG | CRYPT_SILENT,
               NULL,
               &hProv1,
               NULL,
               NULL
               ))
    {
        EapTlsTrace("Found a certificate without private key.  Skipping.  Error 0x%x",GetLastError());
        goto LDone;
    }
    CryptReleaseContext(hProv1, 0);

#endif

    fRet = FALSE;
LDone:
    if ( pUsageInternal )
        LocalFree(pUsageInternal);

    if ( pCryptKeyProvInfo )
        LocalFree(pCryptKeyProvInfo);

    if (0 != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }

    return fRet;
}

/*
    Add selected certs to the
*/

VOID AddCertNodeToSelList ( EAPTLS_HASH * pHash,
                            DWORD dwNumHashes,
                            EAPTLS_CERT_NODE *  pNode,
                            EAPTLS_CERT_NODE ** ppSelCertList,      //This is an array of pointers
                            DWORD             * pdwNextSelCert
                          )
{


    DWORD               dw = 0;
    DWORD               dw1 = 0;

    RTASSERT(NULL != pNode);



    EapTlsTrace("Add Selected Cert to List");

    //No selected certificates
    if ( 0 == dwNumHashes  || !ppSelCertList )
        goto done;


    while ( dw < dwNumHashes )
    {
        if (!memcmp(&(pNode->Hash), (pHash+ dw), sizeof(EAPTLS_HASH)))
        {
            //
            //check to see if the node's already in the list.
            //iff not then add it.  Looks like there is some
            //problem with possible dup certs in the cert store
            //
            while ( dw1 < *pdwNextSelCert )
            {
                if ( ! memcmp( &(*(ppSelCertList+dw1))->Hash, &(pNode->Hash), sizeof(EAPTLS_HASH) ) )
                {
                    //This is a dup node in mmc.  So Skip it...
                    goto done;
                }
                dw1++;
            }
            *( ppSelCertList + *pdwNextSelCert ) = pNode;
            *pdwNextSelCert = *pdwNextSelCert + 1;
            break;
        }
        dw++;
    }

done:
    return;
}


/*

Returns:
    TRUE if no enhanced key usages exist, or pCertContext has the 
    szOID_PKIX_KP_SERVER_AUTH or szOID_PKIX_KP_CLIENT_AUTH usage depending on 
    whether fMachine is TRUE or FALSE.

Notes:

*/

BOOL
FCheckUsage(
    IN  PCCERT_CONTEXT		pCertContext,
	IN  PCERT_ENHKEY_USAGE	pUsage,
    IN  BOOL				fMachine
)
{
    DWORD               dwIndex;
    DWORD               dwErr;
    BOOL                fRet        = FALSE;
	PCERT_ENHKEY_USAGE	pUsageInternal = pUsage;
    EapTlsTrace("FCheckUsage");

	if ( NULL == pUsageInternal )
	{
		dwErr = DwGetEKUUsage ( 	pCertContext,
								&pUsageInternal);
		if ( dwErr != ERROR_SUCCESS )
			goto LDone;
	}

    for (dwIndex = 0; dwIndex < pUsageInternal->cUsageIdentifier; dwIndex++)
    {
        if (   (   fMachine
                && !strcmp(pUsageInternal->rgpszUsageIdentifier[dwIndex],
                            szOID_PKIX_KP_SERVER_AUTH))
            || (   !fMachine
                && !strcmp(pUsageInternal->rgpszUsageIdentifier[dwIndex],
                            szOID_PKIX_KP_CLIENT_AUTH)))
        {
            fRet = TRUE;
            break;
        }
    }

LDone:
	if ( NULL == pUsage )
	{
		if ( pUsageInternal )
			LocalFree(pUsageInternal);
	}
    return(fRet);
}



DWORD DwCheckCertPolicy 
( 
    IN      PCCERT_CONTEXT          pCertContext,
    OUT     PCCERT_CHAIN_CONTEXT  * ppCertChainContext
)
{
    DWORD                       dwRetCode = ERROR_SUCCESS;
    LPSTR                       lpszEnhUsage = szOID_PKIX_KP_CLIENT_AUTH;
    CERT_CHAIN_PARA             ChainPara;
    CERT_ENHKEY_USAGE           EnhKeyUsage;
    CERT_USAGE_MATCH            CertUsage;
    PCCERT_CHAIN_CONTEXT        pChainContext = NULL;
    CERT_CHAIN_POLICY_PARA      PolicyPara;
    CERT_CHAIN_POLICY_STATUS    PolicyStatus;
    
    EapTlsTrace("FCheckPolicy");

    *ppCertChainContext = NULL;

    ZeroMemory ( &ChainPara, sizeof(ChainPara) );
    ZeroMemory ( &EnhKeyUsage, sizeof(EnhKeyUsage) );
    ZeroMemory ( &CertUsage, sizeof(CertUsage) );

    EnhKeyUsage.rgpszUsageIdentifier = &lpszEnhUsage;

    EnhKeyUsage.cUsageIdentifier = 1;
    EnhKeyUsage.rgpszUsageIdentifier = &lpszEnhUsage;

    CertUsage.dwType = USAGE_MATCH_TYPE_AND;
    CertUsage.Usage = EnhKeyUsage;
    
    ChainPara.cbSize = sizeof(CERT_CHAIN_PARA);
    ChainPara.RequestedUsage = CertUsage;


    if(!CertGetCertificateChain(
                            NULL,
                            pCertContext,
                            NULL,
                            pCertContext->hCertStore,
                            &ChainPara,
                            0,
                            NULL,
                            &pChainContext))
    {
        dwRetCode = GetLastError();
        EapTlsTrace("CertGetCertificateChain failed and returned 0x%x", dwRetCode );
        pChainContext = NULL;
        goto LDone;
    }


    ZeroMemory( &PolicyPara, sizeof(PolicyPara) );
    PolicyPara.cbSize   = sizeof(PolicyPara);
    PolicyPara.dwFlags  = BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_END_ENTITY_FLAG;

    ZeroMemory( &PolicyStatus, sizeof(PolicyStatus) );

    //
    // The chain already has verified the policy.  
    // Chain context will have several bits set.
    // To get one error out of it, call CErtVerifyCertificateChainPolicy
    //

    if ( !CertVerifyCertificateChainPolicy( CERT_CHAIN_POLICY_NT_AUTH,
                                      pChainContext,
                                      &PolicyPara,
                                      &PolicyStatus
                                    )
       )
    {
        dwRetCode = GetLastError();
        EapTlsTrace( "CertVerifyCertificateChainPolicy failed. Continuing with root hash matching"
                     "GetLastError = 0x%x.", dwRetCode);
    }
    else
    {
        //
        //Check to see if the policy status is good.  If so, 
        //there is no need to check for connectoid hashes any more...
        //
        if ( PolicyStatus.dwError != 0 )
        {
            dwRetCode = PolicyStatus.dwError;
            EapTlsTrace( "CertVerifyCertificateChainPolicy succeeded but policy check failed 0x%x." 
                         , dwRetCode );
        }
        else
        {
            *ppCertChainContext = pChainContext;            
        }
    }
  
LDone:

    if ( dwRetCode != ERROR_SUCCESS && pChainContext )
    {
        CertFreeCertificateChain ( pChainContext );
    }

    EapTlsTrace("FCheckPolicy done.");
    return dwRetCode;
}

/*

Returns:
    TRUE iff the certificate is time valid.

Notes:

*/

BOOL FCheckTimeValidity ( 
	IN  PCCERT_CONTEXT  pCertContext
)
{
	BOOL			fRet = FALSE;
	SYSTEMTIME		SysTime;
	FILETIME		FileTime;
	EapTlsTrace("FCheckTimeValidity");
	GetSystemTime(&SysTime);
	if ( !SystemTimeToFileTime ( &SysTime, &FileTime ) )
	{
		EapTlsTrace ("Error converting from system time to file time %ld", GetLastError());
		goto done;
	}

	if ( CertVerifyTimeValidity ( &FileTime, pCertContext->pCertInfo ) )
	{
		//should return a 0 if the certificate is time valid.
		EapTlsTrace ( "Non Time Valid Certificate was encountered");
		goto done;
	}
	fRet = TRUE;
done:
	return fRet;
}
/*

Returns:
    TRUE iff the CSP is Microsoft RSA SChannel Cryptographic Provider.

Notes:

*/

BOOL
FCheckCSP(
    IN  PCCERT_CONTEXT  pCertContext
)
{
    DWORD                   dwBytes;
    CRYPT_KEY_PROV_INFO*    pCryptKeyProvInfo   = NULL;
    BOOL                    fRet                = FALSE;

    EapTlsTrace("FCheckCSP");

    if (!CertGetCertificateContextProperty(pCertContext,
            CERT_KEY_PROV_INFO_PROP_ID, NULL, &dwBytes))
    {
        EapTlsTrace("CertGetCertificateContextProperty failed and "
            "returned 0x%x", GetLastError());

        goto LDone;
    }

    pCryptKeyProvInfo = LocalAlloc(LPTR, dwBytes);

    if (NULL == pCryptKeyProvInfo)
    {
        EapTlsTrace("LocalAlloc failed and returned %d", GetLastError());
        goto LDone;
    }

    if (!CertGetCertificateContextProperty(pCertContext,
            CERT_KEY_PROV_INFO_PROP_ID, pCryptKeyProvInfo, &dwBytes))
    {
        EapTlsTrace("CertGetCertificateContextProperty failed and "
            "returned 0x%x", GetLastError());
        goto LDone;
    }

    fRet = (PROV_RSA_SCHANNEL == pCryptKeyProvInfo->dwProvType);
    if ( !fRet )
    {
        EapTlsTrace("Did not find a cert with a provider RSA_SCHANNEL or RSA_FULL");
    }

LDone:

    LocalFree(pCryptKeyProvInfo);

    return(fRet);
}

/*

Returns:
    NO_ERROR: iff Success

Notes:
    Gets the root cert hash of the cert represented by pCertContextServer.

*/

DWORD
GetRootCertHashAndNameVerifyChain(
    IN  PCERT_CONTEXT   pCertContextServer,
    OUT EAPTLS_HASH*    pHash,    
    OUT WCHAR**         ppwszName,
    IN  BOOL            fVerifyGP,
    OUT BOOL       *    pfRootCheckRequired
)
{
    PCCERT_CHAIN_CONTEXT    pChainContext   = NULL;
    CERT_CHAIN_PARA         ChainPara;
    PCERT_SIMPLE_CHAIN      pSimpleChain;
    PCCERT_CONTEXT          pCurrentCert;
    DWORD                   dwIndex;
    BOOL                    fRootCertFound  = FALSE;
    WCHAR*                  pwszName        = NULL;
    DWORD                   dwErr           = NO_ERROR;
    CERT_CHAIN_POLICY_PARA   PolicyPara;
    CERT_CHAIN_POLICY_STATUS PolicyStatus;

    ZeroMemory(&ChainPara, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);

    *pfRootCheckRequired = TRUE;

    if(!CertGetCertificateChain(
                            NULL,
                            pCertContextServer,
                            NULL,
                            pCertContextServer->hCertStore,
                            &ChainPara,
                            0,
                            NULL,
                            &pChainContext))
    {
        dwErr = GetLastError();

        EapTlsTrace("CertGetCertificateChain failed and returned 0x%x", dwErr);
        pChainContext = NULL;
        goto LDone;
    }

    //Get the hash and root cert name etc anyways...                                              
    pSimpleChain = pChainContext->rgpChain[0];

    for (dwIndex = 0; dwIndex < pSimpleChain->cElement; dwIndex++)
    {
        pCurrentCert = pSimpleChain->rgpElement[dwIndex]->pCertContext;

        if (CertCompareCertificateName(pCurrentCert->dwCertEncodingType, 
                                      &pCurrentCert->pCertInfo->Issuer,
                                      &pCurrentCert->pCertInfo->Subject))
        {
            fRootCertFound = TRUE;
            break;
        }
    }

    if (!fRootCertFound)
    {
        dwErr = ERROR_NOT_FOUND;
        goto LDone;
    }

    pHash->cbHash = MAX_HASH_SIZE;

    if (!CertGetCertificateContextProperty(pCurrentCert, CERT_HASH_PROP_ID,
            pHash->pbHash, &(pHash->cbHash)))
    {
        dwErr = GetLastError();
        EapTlsTrace("CertGetCertificateContextProperty failed and "
            "returned 0x%x", dwErr);
        goto LDone;
    }

    if (!FCertToStr(pCurrentCert, 0, TRUE, &pwszName))
    {
        dwErr = E_FAIL;
        goto LDone;
    }


    *ppwszName = pwszName;
    pwszName = NULL;

    if ( fVerifyGP )
    {
        EapTlsTrace( "Checking against the NTAuth store to verify the certificate chain.");

        ZeroMemory( &PolicyPara, sizeof(PolicyPara) );
        PolicyPara.cbSize   = sizeof(PolicyPara);
        PolicyPara.dwFlags  = BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_END_ENTITY_FLAG;
 
        ZeroMemory( &PolicyStatus, sizeof(PolicyStatus) );

        //Authnticate against the NTAuth store and see if all's cool.
        if ( !CertVerifyCertificateChainPolicy( CERT_CHAIN_POLICY_NT_AUTH,
                                          pChainContext,
                                          &PolicyPara,
                                          &PolicyStatus
                                        )
           )
        {
            EapTlsTrace( "CertVerifyCertificateChainPolicy failed. Continuing with root hash matching"
                         "GetLastError = 0x%x.", GetLastError());
        }
        else
        {
            //
            //Check to see if the policy status is good.  If so, 
            //there is no need to check for connectoid hashes any more...
            //
            if ( PolicyStatus.dwError != 0 )
            {
                EapTlsTrace( "CertVerifyCertificateChainPolicy succeeded but returned 0x%x." 
                             "Continuing with root hash matching.", PolicyStatus.dwError);                
            }
            else
            {
                *pfRootCheckRequired = FALSE;
            }
        }
    }
   

LDone:

    if (pChainContext)
    {
        CertFreeCertificateChain(pChainContext);
    }

    LocalFree(pwszName);

    return(dwErr);
}

/*

Returns:
    NO_ERROR: iff Success

Notes:
    Opens the EAP-TLS registry key, and returns the result in *phKeyEapTls. If 
    the function returns NO_ERROR, the caller must ultimately call 
    RegCloseKey(*phKeyEapTls).

*/

DWORD
OpenEapTlsRegistryKey(
    IN  WCHAR*  pwszMachineName,
    IN  REGSAM  samDesired,
    OUT HKEY*   phKeyEapTls
)
{
    HKEY    hKeyLocalMachine = NULL;
    BOOL    fHKeyLocalMachineOpened     = FALSE;
    BOOL    fHKeyEapTlsOpened           = FALSE;

    LONG    lRet;
    DWORD   dwErr                       = NO_ERROR;

    RTASSERT(NULL != phKeyEapTls);

    lRet = RegConnectRegistry(pwszMachineName, HKEY_LOCAL_MACHINE,
                &hKeyLocalMachine);
    if (ERROR_SUCCESS != lRet)
    {
        dwErr = lRet;
        EapTlsTrace("RegConnectRegistry(%ws) failed and returned %d",
            pwszMachineName ? pwszMachineName : L"NULL", dwErr);
        goto LDone;
    }
    fHKeyLocalMachineOpened = TRUE;

    lRet = RegOpenKeyEx(hKeyLocalMachine, EAPTLS_KEY_13, 0, samDesired,
                phKeyEapTls);
    if (ERROR_SUCCESS != lRet)
    {
        dwErr = lRet;
        EapTlsTrace("RegOpenKeyEx(%ws) failed and returned %d",
            EAPTLS_KEY_13, dwErr);
        goto LDone;
    }
    fHKeyEapTlsOpened = TRUE;

LDone:

    if (   fHKeyEapTlsOpened
        && (ERROR_SUCCESS != dwErr))
    {
        RegCloseKey(*phKeyEapTls);
    }

    if (fHKeyLocalMachineOpened)
    {
        RegCloseKey(hKeyLocalMachine);
    }

    return(dwErr);
}

/*

Returns:
    NO_ERROR: iff Success

Notes:
    Reads/writes the server's config data.

    If fRead is TRUE, and the function returns NO_ERROR, LocalFree(*ppUserProp) 
    must be called.

*/

DWORD
ServerConfigDataIO(
    IN      BOOL    fRead,
    IN      WCHAR*  pwszMachineName,
    IN OUT  BYTE**  ppData,
    IN      DWORD   dwNumBytes
)
{
    HKEY                    hKeyEapTls;
    EAPTLS_USER_PROPERTIES* pUserProp;
    BOOL                    fHKeyEapTlsOpened   = FALSE;
    BYTE*                   pData               = NULL;
    DWORD                   dwSize = 0;

    LONG                    lRet;
    DWORD                   dwType;
    DWORD                   dwErr               = NO_ERROR;

    RTASSERT(NULL != ppData);

    dwErr = OpenEapTlsRegistryKey(pwszMachineName,
                fRead ? KEY_READ : KEY_WRITE, &hKeyEapTls);
    if (ERROR_SUCCESS != dwErr)
    {
        goto LDone;
    }
    fHKeyEapTlsOpened = TRUE;

    if (fRead)
    {
        lRet = RegQueryValueEx(hKeyEapTls, EAPTLS_VAL_SERVER_CONFIG_DATA, NULL,
                &dwType, NULL, &dwSize);

        if (   (ERROR_SUCCESS != lRet)
            || (REG_BINARY != dwType)
            || (sizeof(EAPTLS_USER_PROPERTIES) != dwSize))
        {
            pData = LocalAlloc(LPTR, sizeof(EAPTLS_USER_PROPERTIES));

            if (NULL == pData)
            {
                dwErr = GetLastError();
                EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
                goto LDone;
            }

            pUserProp = (EAPTLS_USER_PROPERTIES*)pData;
            pUserProp->dwVersion = 0;
        }
        else
        {
            pData = LocalAlloc(LPTR, dwSize);

            if (NULL == pData)
            {
                dwErr = GetLastError();
                EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
                goto LDone;
            }

            lRet = RegQueryValueEx(hKeyEapTls, EAPTLS_VAL_SERVER_CONFIG_DATA,
                    NULL, &dwType, pData, &dwSize);

            if (ERROR_SUCCESS != lRet)
            {
                dwErr = lRet;
                EapTlsTrace("RegQueryValueEx(%ws) failed and returned %d",
                    EAPTLS_VAL_SERVER_CONFIG_DATA, dwErr);
                goto LDone; 
            }
        }

        pUserProp = (EAPTLS_USER_PROPERTIES*)pData;
        pUserProp->dwSize = sizeof(EAPTLS_USER_PROPERTIES);
        pUserProp->awszString[0] = 0;

        *ppData = pData;
        pData = NULL;
    }
    else
    {
        lRet = RegSetValueEx(hKeyEapTls, EAPTLS_VAL_SERVER_CONFIG_DATA, 0,
                REG_BINARY, *ppData, dwNumBytes);

        if (ERROR_SUCCESS != lRet)
        {
            dwErr = lRet;
            EapTlsTrace("RegSetValueEx(%ws) failed and returned %d",
                EAPTLS_VAL_SERVER_CONFIG_DATA, dwErr);
            goto LDone; 
        }
    }

LDone:

    if (fHKeyEapTlsOpened)
    {
        RegCloseKey(hKeyEapTls);
    }

    LocalFree(pData);

    return(dwErr);
}

/*

Returns:
    VOID

Notes:

*/

VOID
FreeCertList(
    IN  EAPTLS_CERT_NODE* pNode
)
{
    while (NULL != pNode)
    {
        LocalFree(pNode->pwszDisplayName);
        LocalFree(pNode->pwszFriendlyName);
        LocalFree(pNode->pwszIssuer);
        LocalFree(pNode->pwszExpiration);
        pNode = pNode->pNext;
    }
}

/*

Returns:
    VOID

Notes:
    Creates a linked list of certs from the pwszStoreName store. This list is 
    created in *ppCertList. *ppCert is made to point to the cert whose hash is 
    the same as the hash in *pHash. The linked list must eventually be freed by 
    calling FreeCertList.
    

*/

VOID
CreateCertList(
    IN  BOOL                fServer,
    IN  BOOL                fRouter,
    IN  BOOL                fRoot,
    OUT EAPTLS_CERT_NODE**  ppCertList,
    OUT EAPTLS_CERT_NODE**  ppCert,     //This is an array of pointers...
    IN  DWORD               dwNumHashes,
    IN  EAPTLS_HASH*        pHash,      //This is an array of hashes...
    IN  WCHAR*              pwszStoreName
)
{
    HCERTSTORE                      hCertStore      = NULL;
    EAPTLS_CERT_NODE*               pCertList       = NULL;
    EAPTLS_CERT_NODE*               pCert           = NULL;
    EAPTLS_CERT_NODE*               pLastNode       = NULL;
    PCCERT_CONTEXT                  pCertContext;
    BOOL                            fExitWhile;
    EAPTLS_CERT_NODE*               pNode;
    DWORD                           dwErr           = NO_ERROR;
    DWORD                           dwNextSelCert   = 0;
    PCCERT_CHAIN_CONTEXT            pChainContext   = NULL;
    CERT_CHAIN_FIND_BY_ISSUER_PARA  FindPara;

    RTASSERT(NULL != ppCertList);

    hCertStore = CertOpenStore(
                        CERT_STORE_PROV_SYSTEM,
                        0,
                        0,
                        CERT_STORE_READONLY_FLAG |
                        ((fServer || fRouter) ?
                            CERT_SYSTEM_STORE_LOCAL_MACHINE :
                            CERT_SYSTEM_STORE_CURRENT_USER),
                        pwszStoreName);

    if (NULL == hCertStore)
    {
        dwErr = GetLastError();
        EapTlsTrace("CertOpenSystemStore failed and returned 0x%x", dwErr);
        goto LDone;
    }

    //Changed from fRoot||fServer to fRoot only.
    if (fRoot)
    {
        pCertList = LocalAlloc(LPTR, sizeof(EAPTLS_CERT_NODE));

        if (NULL == pCertList)
        {
            dwErr = GetLastError();
            EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
            goto LDone;
        }

        pLastNode = pCertList;
    }

    fExitWhile      = FALSE;
    pCertContext    = NULL;
    ZeroMemory ( &FindPara, sizeof(FindPara) );

    FindPara.cbSize = sizeof(FindPara);
    FindPara.pszUsageIdentifier = szOID_PKIX_KP_CLIENT_AUTH;

    while (!fExitWhile)
    {
        dwErr = NO_ERROR;
        pNode = NULL;

        /*

        The returned pointer is freed when passed as the pPrevCertContext on a 
        subsequent call. Otherwise, the pointer must be freed by calling 
        CertFreeCertificateContext. A pPrevCertContext that is not NULL is 
        always freed by this function (through a call to 
        CertFreeCertificateContext), even for an error.

        */
        if ( fRoot || fRouter || fServer )
        {
            pCertContext = CertEnumCertificatesInStore(hCertStore, pCertContext);
        
            if (NULL == pCertContext)
            {
                fExitWhile = TRUE;
                goto LWhileEnd;
            }
        
            if (   !fRoot
                && !FCheckUsage(pCertContext, NULL, fServer))
            {
                goto LWhileEnd;
            }
        }
        else
        {
            //
            // Use CertFindChainInStore to get to the certificate
            //
            pChainContext = CertFindChainInStore ( hCertStore,
                                                   X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                                   0,
                                                   CERT_CHAIN_FIND_BY_ISSUER,
                                                   &FindPara,
                                                   pChainContext
                                                 );

            if ( NULL == pChainContext )
            {
                fExitWhile = TRUE;
                goto LWhileEnd;
            }

            //Set the cert context to appropriate value
            pCertContext = pChainContext->rgpChain[0]->rgpElement[0]->pCertContext;
        }
        
        //
        //Skip if it is smart card cached certificate
        //or we cannot open this csp in silent mode
        //This is done iff it is not root certs and server
        //

        if ( !fRoot 
            && !fServer
            && FCheckSCardCertAndCanOpenSilentContext ( pCertContext ) )
        {
            goto LWhileEnd;
        }

        
		if ( !FCheckTimeValidity(pCertContext ) )
		{
			goto LWhileEnd;
		}

        
        if (   fServer
            && !FCheckCSP(pCertContext))
        {
            goto LWhileEnd;
        }
        
        pNode = LocalAlloc(LPTR, sizeof(EAPTLS_CERT_NODE));

        if (NULL == pNode)
        {
            dwErr = GetLastError();
            EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
            fExitWhile = TRUE;
            goto LWhileEnd;
        }
        
        FGetFriendlyName(pCertContext, &(pNode->pwszFriendlyName));

        //
        // If there is no UPN name, this cert will be skipped here
        //

        if (   !FCertToStr(pCertContext, 0, fServer || fRouter,
                    &(pNode->pwszDisplayName))
            || !FCertToStr(pCertContext, CERT_NAME_ISSUER_FLAG, TRUE,
                    &(pNode->pwszIssuer))
            || !FFileTimeToStr(pCertContext->pCertInfo->NotAfter,
                    &(pNode->pwszExpiration)))
        {
            goto LWhileEnd;
        }
        
        pNode->Hash.cbHash = MAX_HASH_SIZE;

        if (!CertGetCertificateContextProperty(
                    pCertContext, CERT_HASH_PROP_ID, pNode->Hash.pbHash,
                    &(pNode->Hash.cbHash)))
        {
            dwErr = GetLastError();
            EapTlsTrace("CertGetCertificateContextProperty failed and "
                "returned 0x%x", dwErr);
            fExitWhile = TRUE;
            goto LWhileEnd;
        }
        
#if 0
        // This is not being used anywhere.  So dont worry about it.
        //
        // Get Issuer and subject information
        //

        FGetIssuerOrSubject (  pCertContext, 
                               0,
                                &(pNode->pwszIssuedTo)                                
                             );

        FGetIssuerOrSubject (  pCertContext, 
                               CERT_NAME_ISSUER_FLAG,
                                &(pNode->pwszIssuedBy)                                
                             );
#endif
        //
        // Finally copy the issued date into the structure
        //
        CopyMemory( &pNode->IssueDate, 
                    &pCertContext->pCertInfo->NotBefore,
                    sizeof(FILETIME)
                  );

        if (NULL == pLastNode)
        {
            pCertList = pLastNode = pNode;
        }
        else
        {
            pLastNode->pNext = pNode;
            pLastNode = pNode;
        }

        
        //Check if the hash for current node is in the list
        //that has been passed to us
        AddCertNodeToSelList (  pHash,
                                dwNumHashes,
                                pNode,
                                ppCert,     //This is an array of pointers
                                &dwNextSelCert
                          );
        
        pNode = NULL;
        

LWhileEnd:
        
        if (NULL != pNode)
        {
            LocalFree(pNode->pwszDisplayName);
            LocalFree(pNode->pwszFriendlyName);
            LocalFree(pNode->pwszIssuer);
            LocalFree(pNode->pwszExpiration);
            LocalFree(pNode);
            pNode = NULL;
        }
        
        if ( fRoot || fRouter )
        {
            if (   fExitWhile
                && (NULL != pCertContext))
            {
                CertFreeCertificateContext(pCertContext);
                // Always returns TRUE;
            }
        }
        else
        {
            if ( fExitWhile 
                && ( NULL != pChainContext ) 
               )
            {
                CertFreeCertificateChain(pChainContext);
            }
        }
        
    }

    // If we couldn't find an appropriate default cert, make the first
    // cert (if there is one) the default

    if (NULL == pCert)
    {
        pCert = pCertList;
    }

LDone:

    if (NO_ERROR != dwErr)
    {
        FreeCertList(pCertList);
    }
    else
    {
        *ppCertList = pCertList;        
    }

    if (NULL != hCertStore)
    {
        if (!CertCloseStore(hCertStore, 0))
        {
            EapTlsTrace("CertCloseStore failed and returned 0x%x",
                GetLastError());
        }
    }
    
}

DWORD
GetLocalMachineName ( 
    OUT WCHAR ** ppLocalMachineName
)
{
    DWORD       dwRetCode = NO_ERROR;
    WCHAR   *   pLocalMachineName = NULL;
    DWORD       dwLocalMachineNameLen = 0;

    if ( !GetComputerNameEx ( ComputerNameDnsFullyQualified,
                              pLocalMachineName,
                              &dwLocalMachineNameLen
                            )
       )
    {
        dwRetCode = GetLastError();
        if ( ERROR_MORE_DATA != dwRetCode )
            goto LDone;
        dwRetCode = NO_ERROR;
    }

    pLocalMachineName = (WCHAR *)LocalAlloc( LPTR, (dwLocalMachineNameLen * sizeof(WCHAR)) + sizeof(WCHAR) );
    if ( NULL == pLocalMachineName )
    {
        dwRetCode = GetLastError();
        goto LDone;
    }

    if ( !GetComputerNameEx ( ComputerNameDnsFullyQualified,
                              pLocalMachineName,
                              &dwLocalMachineNameLen
                            )
       )
    {
        dwRetCode = GetLastError();
        goto LDone;
    }

    *ppLocalMachineName = pLocalMachineName;

    pLocalMachineName = NULL;

LDone:

    LocalFree(pLocalMachineName);

    return dwRetCode;
}

/*

Returns:
    NO_ERROR: iff Success

Notes:
    If this function returns NO_ERROR,
    CertFreeCertificateContext(*ppCertContext) must be called.

*/

DWORD
GetDefaultClientMachineCert(
    IN  HCERTSTORE      hCertStore,
    OUT PCCERT_CONTEXT* ppCertContext
)
{
    CTL_USAGE       CtlUsage;
    CHAR*           szUsageIdentifier;
    PCCERT_CONTEXT  pCertContext = NULL;
    EAPTLS_HASH     FirstCertHash;   //This is the hash of first cert
                                            //with client auth found in the store
    PCCERT_CONTEXT  pCertContextPrev = NULL;    //Previous context in the search

    EAPTLS_HASH     SelectedCertHash;    //Hash of the certificate last selected 
    FILETIME        SelectedCertNotBefore;      //Not Before date of last selected 
    EAPTLS_HASH     TempHash;               //Scratch variable
    WCHAR       *   pwszIdentity = NULL;        //Machine Name in the cert
    WCHAR       *   pLocalMachineName = NULL;   //Local Machine Name    
    DWORD           dwErr = NO_ERROR;
    BOOL            fGotIdentity;
    CRYPT_HASH_BLOB             HashBlob;

    EapTlsTrace("GetDefaultClientMachineCert");

    RTASSERT(NULL != ppCertContext);

    ZeroMemory( &SelectedCertHash, sizeof(SelectedCertHash) );
    ZeroMemory( &SelectedCertNotBefore, sizeof(SelectedCertNotBefore) );

    *ppCertContext = NULL;

    dwErr = GetLocalMachineName ( &pLocalMachineName );
    if ( NO_ERROR != dwErr )
    {
        EapTlsTrace("Error getting LocalMachine Name 0x%x",
            dwErr);
        goto LDone;
    }

    szUsageIdentifier = szOID_PKIX_KP_CLIENT_AUTH;

    CtlUsage.cUsageIdentifier = 1;
    CtlUsage.rgpszUsageIdentifier = &szUsageIdentifier;
    
    pCertContext = CertFindCertificateInStore(hCertStore,
                                              X509_ASN_ENCODING, 
                                              0, 
                                              CERT_FIND_ENHKEY_USAGE,
                                              &CtlUsage, 
                                              NULL);

    if ( NULL == pCertContext )
    {
        dwErr = GetLastError();
        EapTlsTrace("CertFindCertificateInStore failed and returned 0x%x",
            dwErr);
        if ( CRYPT_E_NOT_FOUND == dwErr )
        {
            dwErr = ERROR_NO_EAPTLS_CERTIFICATE;
        }

        goto LDone;
    }

    FirstCertHash.cbHash = MAX_HASH_SIZE;
    //
    //Store the hash of first cert.  In case we dont find any cert that exactly matches
    //the filtering, we need to use this.
    if (!CertGetCertificateContextProperty( pCertContext,
                                            CERT_HASH_PROP_ID, 
                                            FirstCertHash.pbHash,
                                            &(FirstCertHash.cbHash)
                                          )
        )
    {
        dwErr = GetLastError();
        EapTlsTrace("CertGetCertificateContextProperty failed and "
            "returned 0x%x", dwErr);
        goto LDone;
    }

    do
    {

        //Check time validity of the cert.
	    if ( !FCheckTimeValidity( pCertContext) )
	    {
            //cert expired. So skip it
            EapTlsTrace("Found expired Cert.  Skipping this cert.");
		    goto LWhileEnd;
	    }
        fGotIdentity = FALSE;
        //
        //Get the subject Alt Name 
        //
        if ( FMachineAuthCertToStr(pCertContext, &pwszIdentity) )
        {
            fGotIdentity = TRUE;
        }
        else
        {
            EapTlsTrace("Could not get identity from subject alt name.");
            
			if ( FCertToStr(pCertContext, 0, TRUE, &pwszIdentity))
			{
                fGotIdentity = TRUE;
            }
        }

        if ( fGotIdentity )
        {
            //
            //Check to see if this is the same identity as this machine 
            //
            if ( !_wcsicmp ( pwszIdentity, pLocalMachineName ) )
            {
                //
                //Store the hash of cert.

                TempHash.cbHash = MAX_HASH_SIZE;

                if (!CertGetCertificateContextProperty( pCertContext,
                                                        CERT_HASH_PROP_ID, 
                                                        TempHash.pbHash,
                                                        &(TempHash.cbHash)
                                                      )
                   )
                {
                    EapTlsTrace("CertGetCertificateContextProperty failed and "
                        "returned 0x%x.  Skipping this certificate", GetLastError());
                    goto LWhileEnd;
                }

                //
                //Got a cert so if there is already a cert selected,
                //compare the file time of this cert with the one
                //already selected.  If this is more recent, use this
                //one.
                //
                if ( SelectedCertHash.cbHash )
                {
                    if ( CompareFileTime(   &SelectedCertNotBefore, 
                                            &(pCertContext->pCertInfo->NotBefore)
                                        ) < 0                                        
                       )
                    {
                        //Got a newer cert so replace the old cert with new one
                        CopyMemory (    &SelectedCertHash, 
                                        &TempHash,
                                        sizeof(SelectedCertHash)
                                    );
                        CopyMemory (    &SelectedCertNotBefore,
                                        &(pCertContext->pCertInfo->NotBefore),
                                        sizeof( SelectedCertNotBefore )
                                   );

                    }
                }
                else
                {
                    //
                    //This is the first cert.  So copy over the hash and
                    //file time.
                    CopyMemory (    &SelectedCertHash, 
                                    &TempHash,
                                    sizeof(SelectedCertHash)
                                );
                    CopyMemory (    &SelectedCertNotBefore,
                                    &(pCertContext->pCertInfo->NotBefore),
                                    sizeof( SelectedCertNotBefore )
                               );
                }

            }
            else
            {
                EapTlsTrace("Could not get identity from the cert.  skipping this cert.");
            }
        }
        else
        {
            EapTlsTrace("Could not get identity from the cert.  skipping this cert.");
        }


LWhileEnd:
        pCertContextPrev = pCertContext;
        if ( pwszIdentity )
        {
            LocalFree ( pwszIdentity );
            pwszIdentity  = NULL;
        }
        //Get the next certificate.
        pCertContext = CertFindCertificateInStore(hCertStore,
                                                  X509_ASN_ENCODING, 
                                                  0, 
                                                  CERT_FIND_ENHKEY_USAGE,
                                                  &CtlUsage, 
                                                  pCertContextPrev );

    }while ( pCertContext );


    //
    //Now that we have enumerated all the certs,
    //check to see if we have a selected cert.  If no selected 
    //cert is present, send back the first cert.  
    //
    if ( SelectedCertHash.cbHash )
    {
        EapTlsTrace("Found Machine Cert based on machinename, client auth, time validity.");
        HashBlob.cbData = SelectedCertHash.cbHash;
        HashBlob.pbData = SelectedCertHash.pbHash;
    }
    else
    {
        EapTlsTrace("Did not find Machine Cert based on the given machinename, client auth, time validity. Using the first cert with Client Auth OID.");
        HashBlob.cbData = FirstCertHash.cbHash;
        HashBlob.pbData = FirstCertHash.pbHash;
    }
    *ppCertContext = CertFindCertificateInStore(hCertStore, X509_ASN_ENCODING,
                    0, CERT_FIND_HASH, &HashBlob, NULL);

   if (NULL == *ppCertContext)
   {
        dwErr = GetLastError();
        EapTlsTrace("CertFindCertificateInStore failed with 0x%x.", dwErr);
        if ( CRYPT_E_NOT_FOUND == dwErr )
        {
            dwErr = ERROR_NO_EAPTLS_CERTIFICATE;
        }

   }

LDone:

    LocalFree (pLocalMachineName);
    LocalFree (pwszIdentity);

    if ( NO_ERROR != dwErr )
    {
        if ( pCertContext )
        {
            CertFreeCertificateContext( pCertContext );

        }
    }

    EapTlsTrace("GetDefaultClientMachineCert done.");
    return(dwErr);
}

/*

Returns:
    NO_ERROR: iff Success

Notes:
    If this function returns NO_ERROR,
    CertFreeCertificateContext(*ppCertContext) must be called.

*/

DWORD
GetDefaultMachineCert(
    IN  HCERTSTORE      hCertStore,
    OUT PCCERT_CONTEXT* ppCertContext
)
{
    CTL_USAGE       CtlUsage;
    CHAR*           szUsageIdentifier;
    PCCERT_CONTEXT  pCertContext;

    DWORD           dwErr               = NO_ERROR;
	EapTlsTrace("GetDefaultMachineCert");
    RTASSERT(NULL != ppCertContext);

    *ppCertContext = NULL;

    szUsageIdentifier = szOID_PKIX_KP_SERVER_AUTH;

    CtlUsage.cUsageIdentifier = 1;
    CtlUsage.rgpszUsageIdentifier = &szUsageIdentifier;

    pCertContext = CertFindCertificateInStore(hCertStore,
                        X509_ASN_ENCODING, 0, CERT_FIND_ENHKEY_USAGE,
                        &CtlUsage, NULL);

    if (NULL == pCertContext)
    {
        dwErr = GetLastError();
        EapTlsTrace("CertFindCertificateInStore failed and returned 0x%x",
            dwErr);
        goto LDone;
    }

    *ppCertContext = pCertContext;

LDone:

    return(dwErr);
}

/*

Returns:

Notes:
    Stolen from \private\windows\gina\msgina\wlsec.c

*/

VOID
RevealPassword(
    IN  UNICODE_STRING* pHiddenPassword
)
{
    SECURITY_SEED_AND_LENGTH*   SeedAndLength;
    UCHAR                       Seed;

    SeedAndLength = (SECURITY_SEED_AND_LENGTH*)&pHiddenPassword->Length;
    Seed = SeedAndLength->Seed;
    SeedAndLength->Seed = 0;

    RtlRunDecodeUnicodeString(Seed, pHiddenPassword);
}

DWORD GetMBytePIN ( WCHAR * pwszPIN, CHAR ** ppszPIN )
{
    DWORD count = 0;
    CHAR *  pszPin = NULL;
    DWORD dwErr = NO_ERROR;

   count = WideCharToMultiByte(
               CP_UTF8,
               0,
               pwszPIN,
               -1,
               NULL,
               0,
               NULL,
               NULL);

   if (0 == count)
   {
       dwErr = GetLastError();
       EapTlsTrace("WideCharToMultiByte failed: %d", dwErr);
       goto LDone;
   }

   pszPin = LocalAlloc(LPTR, count);

   if (NULL == pszPin)
   {
       dwErr = GetLastError();
       EapTlsTrace("LocalAlloc failed: 0x%x", dwErr);
       goto LDone;
   }

   count = WideCharToMultiByte(
               CP_UTF8,
               0,
               pwszPIN,
               -1,
               pszPin,
               count,
               NULL,
               NULL);

   if (0 == count)
   {
       dwErr = GetLastError();
       EapTlsTrace("WideCharToMultiByte failed: %d", dwErr);
       goto LDone;
   }
    *ppszPIN = pszPin;
LDone:
    if ( NO_ERROR != dwErr )
    {
        if ( pszPin )
            LocalFree(pszPin);
    }
    return dwErr;
}
/*

Returns:
    NO_ERROR: iff Success

Notes:

*/

DWORD
GetCertFromLogonInfo(
    IN  BYTE*           pUserDataIn,
    IN  DWORD           dwSizeOfUserDataIn,
    OUT PCCERT_CONTEXT* ppCertContext
)
{
    EAPLOGONINFO*   pEapLogonInfo   = (EAPLOGONINFO*)pUserDataIn;
    BYTE*           pbLogonInfo     = NULL;
    BYTE*           pbPinInfo;
    WCHAR*          wszPassword     = NULL;
    CHAR*           pszPIN          = NULL;  //Multibyte Version of the PIN
    UNICODE_STRING  UnicodeString;
    PCCERT_CONTEXT  pCertContext    = NULL;
    BOOL            fInitialized    = FALSE;
    NTSTATUS        Status;
    DWORD           dwErr           = NO_ERROR;
    CERT_KEY_CONTEXT stckContext;
    DWORD            cbstckContext= sizeof(CERT_KEY_CONTEXT);
	

    EapTlsTrace("GetCertFromLogonInfo");
    RTASSERT(NULL != ppCertContext);

    *ppCertContext = NULL;

    if (   0 == pEapLogonInfo->dwLogonInfoSize
        || 0 == pEapLogonInfo->dwPINInfoSize 
        || 0 == dwSizeOfUserDataIn)
    {
        dwErr = E_FAIL;
        goto LDone;
    }

    pbLogonInfo = LocalAlloc(LPTR, pEapLogonInfo->dwLogonInfoSize);

    if (NULL == pbLogonInfo)
    {
        dwErr = GetLastError();
        EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
        goto LDone;
    }

    CopyMemory(pbLogonInfo,
        (BYTE*)pEapLogonInfo + pEapLogonInfo->dwOffsetLogonInfo,
        pEapLogonInfo->dwLogonInfoSize);

    pbPinInfo = (BYTE*)pEapLogonInfo + pEapLogonInfo->dwOffsetPINInfo;

    wszPassword = LocalAlloc(LPTR, pEapLogonInfo->dwPINInfoSize);

    if (NULL == wszPassword)
    {
        dwErr = GetLastError();
        EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
        goto LDone;
    }

    CopyMemory(wszPassword, pbPinInfo + 2 * sizeof(USHORT),
        pEapLogonInfo->dwPINInfoSize - 2 * sizeof(USHORT));

    UnicodeString.Length = *((USHORT*)pbPinInfo);
    UnicodeString.MaximumLength = *((USHORT*)pbPinInfo + 1);
    UnicodeString.Buffer = wszPassword;

    Status = ScHelperInitializeContext(pbLogonInfo, 
                pEapLogonInfo->dwLogonInfoSize);

    if (STATUS_SUCCESS != Status)
    {
        dwErr = Status;
        EapTlsTrace("ScHelperInitializeContext failed and returned 0x%x", 
            dwErr);
        goto LDone;
    }

    fInitialized = TRUE;

    RevealPassword(&UnicodeString);

    Status = ScHelperGetCertFromLogonInfo(pbLogonInfo, &UnicodeString,
                &pCertContext);

    if (STATUS_SUCCESS != Status)
    {
        dwErr = Status;
        EapTlsTrace("ScHelperGetCertFromLogonInfo failed and returned 0x%x",
            dwErr);
        goto LDone;
    }
    //BUGID: 260728 - ScHelperGetCertFromLogonInfo does not associate the PIN
    // with certificate context.  Hence the following lines of code are needed
    // to do the needful.

    if ( ! CertGetCertificateContextProperty ( pCertContext,
                                               CERT_KEY_CONTEXT_PROP_ID,
                                               &stckContext,
                                               &cbstckContext
                                             )
       )
    {
        dwErr = Status = GetLastError();
        EapTlsTrace ("CertGetCertificateContextProperty failed and returned 0x%x",
                      dwErr 
                    );
        goto LDone;
    }
    dwErr =  GetMBytePIN ( wszPassword, &pszPIN );
    if ( dwErr != NO_ERROR )
    {
        goto LDone;
    }
    
    if (!CryptSetProvParam(
                 stckContext.hCryptProv,
                 PP_KEYEXCHANGE_PIN,
                 pszPIN,
                 0))
    {
        dwErr = GetLastError();
        EapTlsTrace("CryptSetProvParam failed: 0x%x", dwErr);
        ZeroMemory(pszPIN, strlen(pszPIN));
        goto LDone;
    }

    // Zero the entire allocated buffer.
    ZeroMemory(wszPassword, pEapLogonInfo->dwPINInfoSize);
	ZeroMemory(pszPIN, strlen(pszPIN));
    *ppCertContext = pCertContext;
    pCertContext = NULL;

LDone:

    if (fInitialized)
    {
        ScHelperRelease(pbLogonInfo);
    }

    if (NULL != pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
        // Always returns TRUE;
    }

    LocalFree(wszPassword);
    LocalFree(pbLogonInfo);
	if ( pszPIN )
		LocalFree ( pszPIN );

    return(dwErr);
}

/*

Returns:
    NO_ERROR: iff Success

Notes:
    If this function returns TRUE, LocalFree(*ppwszIdentity) must be called.

*/

DWORD
GetIdentityFromLogonInfo(
    IN  BYTE*   pUserDataIn,
    IN  DWORD   dwSizeOfUserDataIn,
    OUT WCHAR** ppwszIdentity
)
{
    WCHAR*          pwszIdentity    = NULL;
    PCCERT_CONTEXT  pCertContext    = NULL;
    DWORD           dwErr           = NO_ERROR;

    RTASSERT(NULL != pUserDataIn);
    RTASSERT(NULL != ppwszIdentity);

    *ppwszIdentity = NULL;

    dwErr = GetCertFromLogonInfo(pUserDataIn, dwSizeOfUserDataIn,
                &pCertContext);

    if (NO_ERROR != dwErr)
    {
        goto LDone;
    }

    if (FCertToStr(pCertContext, 0, FALSE, &pwszIdentity))
    {
        EapTlsTrace("(logon info) The name in the certificate is: %ws",
            pwszIdentity);
        *ppwszIdentity = pwszIdentity;
        pwszIdentity = NULL;
    }

LDone:

    LocalFree(pwszIdentity);

    if (NULL != pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
        // Always returns TRUE;
    }

    return(dwErr);
}

/*

Returns:
    NO_ERROR: iff Success

Notes:
        There are two types of structures that can come in:
        1. Version 0 structure which comes in as a a part of 
            CM profile created on w2k or as a part of a 
            connectoid that gor upgraded from w2k
            We change the data structure to new v1
            data structure here
        2. Get a version 1 structure and it is all cool.

    Note that the first x bytes of version 1 data structure
    are exactly the same as version 0.

*/

DWORD
ReadConnectionData(
    IN  BOOL                        fWireless,
    IN  BYTE*                       pConnectionDataIn,
    IN  DWORD                       dwSizeOfConnectionDataIn,
    OUT EAPTLS_CONN_PROPERTIES**    ppConnProp
)
{
    DWORD                       dwErr       = NO_ERROR;
    EAPTLS_CONN_PROPERTIES*     pConnProp   = NULL;
    EAPTLS_CONN_PROPERTIES*     pConnPropv1  = NULL;
    
    RTASSERT(NULL != ppConnProp);
    
    if ( dwSizeOfConnectionDataIn < sizeof(EAPTLS_CONN_PROPERTIES) )
    {        
        pConnProp = LocalAlloc(LPTR, sizeof(EAPTLS_CONN_PROPERTIES) + sizeof(EAPTLS_CONN_PROPERTIES_V1_EXTRA));

        if (NULL == pConnProp)
        {
            dwErr = GetLastError();
            EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
            goto LDone;
        }
        //This is a new structure
        pConnProp->dwVersion = 2;
        
        pConnProp->dwSize = sizeof(EAPTLS_CONN_PROPERTIES);
        if ( fWireless )
        {
            //
            // Set the defaults appropriately
            //
            pConnProp->fFlags |= EAPTLS_CONN_FLAG_REGISTRY;
            pConnProp->fFlags |= EAPTLS_CONN_FLAG_SIMPLE_CERT_SEL;
            pConnProp->fFlags |= EAPTLS_CONN_FLAG_NO_VALIDATE_NAME;

        }
    }
    else
    {
        RTASSERT(NULL != pConnectionDataIn);

        //
        //Check to see if this is a version 0 structure
        //If it is a version 0 structure then we migrate it to version1
        //
        
        pConnProp = LocalAlloc(LPTR, dwSizeOfConnectionDataIn);

        if (NULL == pConnProp)
        {
            dwErr = GetLastError();
            EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
            goto LDone;
        }

        // If the user has mucked with the phonebook, we mustn't be affected.
        // The size must be correct.
        
        CopyMemory(pConnProp, pConnectionDataIn, dwSizeOfConnectionDataIn);

        pConnProp->dwSize = dwSizeOfConnectionDataIn;
                
        //
        // The Unicode string must be NULL terminated.
        //
        /*
        ((BYTE*)pConnProp)[dwSizeOfConnectionDataIn - 2] = 0;
        ((BYTE*)pConnProp)[dwSizeOfConnectionDataIn - 1] = 0;
        */

        pConnPropv1 = LocalAlloc(LPTR, 
                                dwSizeOfConnectionDataIn + 
                                sizeof(EAPTLS_CONN_PROPERTIES_V1_EXTRA)
                               );
        if ( NULL == pConnPropv1 )
        {
            dwErr = GetLastError();
            EapTlsTrace("LocalAlloc failed while allocating v1 structure and returned %d", dwErr );
            goto LDone;
        }
        CopyMemory ( pConnPropv1, pConnProp, dwSizeOfConnectionDataIn);
		
        //
        //Check to see if the original struct has hash set
        //
		/*
        if ( pConnProp->Hash.cbHash )
        {
            ConnPropSetNumHashes( pConnPropv1, 1 );
        }
		*/

        if ( 2 != pConnPropv1->dwVersion  )
        {
            if ( pConnPropv1->fFlags & EAPTLS_CONN_FLAG_REGISTRY )
            {
                pConnPropv1->fFlags |= EAPTLS_CONN_FLAG_SIMPLE_CERT_SEL;
            }
            pConnPropv1->dwVersion = 2;
        }
        
        LocalFree ( pConnProp );
        pConnProp = pConnPropv1;
        pConnPropv1 = NULL;
    }

    *ppConnProp = pConnProp;
    pConnProp = NULL;

LDone:
    
    LocalFree(pConnProp);
    LocalFree(pConnPropv1);
    return(dwErr);
}

/*

Returns:
    NO_ERROR: iff Success

Notes:

*/

DWORD
ReadUserData(
    IN  BYTE*                       pUserDataIn,
    IN  DWORD                       dwSizeOfUserDataIn,
    OUT EAPTLS_USER_PROPERTIES**    ppUserProp
)
{
    DWORD                       dwErr       = NO_ERROR;
    EAPTLS_USER_PROPERTIES*     pUserProp   = NULL;

    RTASSERT(NULL != ppUserProp);

    if (dwSizeOfUserDataIn < sizeof(EAPTLS_USER_PROPERTIES))
    {
        pUserProp = LocalAlloc(LPTR, sizeof(EAPTLS_USER_PROPERTIES));

        if (NULL == pUserProp)
        {
            dwErr = GetLastError();
            EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
            goto LDone;
        }

        pUserProp->dwVersion = 0;
        pUserProp->dwSize = sizeof(EAPTLS_USER_PROPERTIES);
        pUserProp->pwszDiffUser = pUserProp->awszString;
        pUserProp->dwPinOffset = 0;
        pUserProp->pwszPin = pUserProp->awszString + pUserProp->dwPinOffset;
    }
    else
    {
        RTASSERT(NULL != pUserDataIn);

        pUserProp = LocalAlloc(LPTR, dwSizeOfUserDataIn);

        if (NULL == pUserProp)
        {
            dwErr = GetLastError();
            EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
            goto LDone;
        }

        CopyMemory(pUserProp, pUserDataIn, dwSizeOfUserDataIn);

        // If someone has mucked with the registry, we mustn't
        // be affected.

        pUserProp->dwSize = dwSizeOfUserDataIn;
        pUserProp->pwszDiffUser = pUserProp->awszString;
        pUserProp->pwszPin = pUserProp->awszString + pUserProp->dwPinOffset;
    }

    *ppUserProp = pUserProp;
    pUserProp = NULL;

LDone:

    LocalFree(pUserProp);
    return(dwErr);
}

/*

Returns:
    NO_ERROR: iff Success

Notes:

*/

DWORD
AllocUserDataWithNewIdentity(
    IN  EAPTLS_USER_PROPERTIES*     pUserProp,
    IN  WCHAR*                      pwszIdentity,
    OUT EAPTLS_USER_PROPERTIES**    ppUserProp
)
{
    DWORD                   dwNumChars;
    EAPTLS_USER_PROPERTIES* pUserPropTemp   = NULL;
    DWORD                   dwSize;
    DWORD                   dwErr           = NO_ERROR;

    *ppUserProp = NULL;

    dwNumChars = wcslen(pwszIdentity);
    dwSize = sizeof(EAPTLS_USER_PROPERTIES) +
             (dwNumChars + wcslen(pUserProp->pwszPin) + 1) * sizeof(WCHAR);
    pUserPropTemp = LocalAlloc(LPTR, dwSize);

    if (NULL == pUserPropTemp)
    {
        dwErr = GetLastError();
        EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
        goto LDone;
    }

    CopyMemory(pUserPropTemp, pUserProp, sizeof(EAPTLS_USER_PROPERTIES));
    pUserPropTemp->dwSize = dwSize;

    pUserPropTemp->pwszDiffUser = pUserPropTemp->awszString;
    wcscpy(pUserPropTemp->pwszDiffUser, pwszIdentity);

    pUserPropTemp->dwPinOffset = dwNumChars + 1;
    pUserPropTemp->pwszPin = pUserPropTemp->awszString +
        pUserPropTemp->dwPinOffset;
    wcscpy(pUserPropTemp->pwszPin, pUserProp->pwszPin);

    *ppUserProp = pUserPropTemp;
    pUserPropTemp = NULL;

    ZeroMemory(pUserProp, pUserProp->dwSize);

LDone:

    LocalFree(pUserPropTemp);
    return(dwErr);
}

/*

Returns:
    NO_ERROR: iff Success

Notes:

*/

DWORD
AllocUserDataWithNewPin(
    IN  EAPTLS_USER_PROPERTIES*     pUserProp,
    IN  PBYTE                       pbPin,
    IN  DWORD                       cbPin,
    OUT EAPTLS_USER_PROPERTIES**    ppUserProp
)
{
    DWORD                   dwNumChars;
    EAPTLS_USER_PROPERTIES* pUserPropTemp   = NULL;
    DWORD                   dwSize;
    DWORD                   dwErr           = NO_ERROR;

    *ppUserProp = NULL;

    dwNumChars = wcslen(pUserProp->pwszDiffUser);

    dwSize = sizeof(EAPTLS_USER_PROPERTIES) +
             (dwNumChars + 1 ) * sizeof(WCHAR) + cbPin;

    pUserPropTemp = LocalAlloc(LPTR, dwSize);

    if (NULL == pUserPropTemp)
    {
        dwErr = GetLastError();
        EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
        goto LDone;
    }

    CopyMemory(pUserPropTemp, pUserProp, sizeof(EAPTLS_USER_PROPERTIES));
    pUserPropTemp->dwSize = dwSize;

    pUserPropTemp->pwszDiffUser = pUserPropTemp->awszString;
    wcscpy(pUserPropTemp->pwszDiffUser, pUserProp->pwszDiffUser);

    pUserPropTemp->dwPinOffset = dwNumChars + 1;
    pUserPropTemp->pwszPin = pUserPropTemp->awszString +
        pUserPropTemp->dwPinOffset;

    CopyMemory(pUserPropTemp->pwszPin, pbPin, cbPin);

    *ppUserProp = pUserPropTemp;
    pUserPropTemp = NULL;

    ZeroMemory(pUserProp, pUserProp->dwSize);

LDone:

    LocalFree(pUserPropTemp);
    return(dwErr);
}


/*

Returns:

Notes:
    String resource message loader routine. Returns the address of a string 
    corresponding to string resource dwStringId or NULL if error. It is caller's
    responsibility to LocalFree the returned string.

*/

WCHAR*
WszFromId(
    IN  HINSTANCE   hInstance,
    IN  DWORD       dwStringId
)
{
    WCHAR*  wszBuf  = NULL;
    int     cchBuf  = 256;
    int     cchGot;

    for (;;)
    {
        wszBuf = LocalAlloc(LPTR, cchBuf * sizeof(WCHAR));

        if (NULL == wszBuf)
        {
            break;
        }

        /*

        LoadString wants to deal with character-counts rather than 
        byte-counts...weird. Oh, and if you're thinking I could FindResource 
        then SizeofResource to figure out the string size, be advised it 
        doesn't work. From perusing the LoadString source, it appears the 
        RT_STRING resource type requests a segment of 16 strings not an 
        individual string.

        */
        
        cchGot = LoadStringW(hInstance, (UINT)dwStringId, wszBuf, cchBuf);

        if (cchGot < cchBuf - 1)
        {
            // Good, got the whole string.

            break;
        }

        // Uh oh, LoadStringW filled the buffer entirely which could mean the
        // string was truncated. Try again with a larger buffer to be sure it
        // wasn't.

        LocalFree(wszBuf);
        cchBuf += 256;
    }

    return(wszBuf);
}


/*
    Following functions are required around the
    messy CONN_PROP structure to support v1/v0 etc.
    This is really bad.
    All the functions assume that version 1.0 format
    is passed in.
*/

EAPTLS_CONN_PROPERTIES_V1_EXTRA UNALIGNED * ConnPropGetExtraPointer (EAPTLS_CONN_PROPERTIES * pConnProp)
{
    return (EAPTLS_CONN_PROPERTIES_V1_EXTRA UNALIGNED *) 
                ( pConnProp->awszServerName + wcslen(pConnProp->awszServerName) + 1);
}

DWORD ConnPropGetNumHashes(EAPTLS_CONN_PROPERTIES * pConnProp )
{
    EAPTLS_CONN_PROPERTIES_V1_EXTRA UNALIGNED * pExtra = ConnPropGetExtraPointer(pConnProp);
        
    return pExtra->dwNumHashes;
}


void ConnPropSetNumHashes(EAPTLS_CONN_PROPERTIES * pConnProp, DWORD dwNumHashes )
{
    EAPTLS_CONN_PROPERTIES_V1_EXTRA UNALIGNED * pExtra = ConnPropGetExtraPointer(pConnProp);
    pExtra->dwNumHashes = dwNumHashes;
    return;
}


DWORD ConnPropGetV1Struct ( EAPTLS_CONN_PROPERTIES * pConnProp, EAPTLS_CONN_PROPERTIES_V1 ** ppConnPropv1 )
{
    DWORD                                           dwRetCode = NO_ERROR;
    EAPTLS_CONN_PROPERTIES_V1  *                    pConnPropv1 = NULL;
    EAPTLS_CONN_PROPERTIES_V1_EXTRA UNALIGNED *     pExtra = ConnPropGetExtraPointer(pConnProp);
    

    //
    //This function assumes that the struct that comes in is at
    //version 1.  Which means at least sizeof(EAPTLS_CONN_PROPERTIES) +
    //EAPTLS_CONN_PROPERTIES_V1_EXTRA in size.
    //

    //
    //First get the amount of memory required to be allocated
    //
    
    pConnPropv1 = LocalAlloc (  LPTR,
                                sizeof( EAPTLS_CONN_PROPERTIES_V1 ) + //sizeof the basic struct
                                pExtra->dwNumHashes * sizeof( EAPTLS_HASH ) + //num hashes
                                wcslen( pConnProp->awszServerName ) * sizeof(WCHAR) + sizeof(WCHAR)//sizeof the string
                             );
    if ( NULL == pConnPropv1 )
    {
        dwRetCode = GetLastError();
        goto LDone;
    }

    //
    //Convert the structure
    //
    if ( pConnProp->dwVersion <= 1 )
        pConnPropv1->dwVersion = 1;
    else
        pConnPropv1->dwVersion = 2;

    pConnPropv1->dwSize = sizeof( EAPTLS_CONN_PROPERTIES_V1 ) +
                          pExtra->dwNumHashes * sizeof( EAPTLS_HASH ) +
                          wcslen( pConnProp->awszServerName ) * sizeof(WCHAR) + sizeof(WCHAR);

    pConnPropv1->fFlags = pConnProp->fFlags;

    pConnPropv1->dwNumHashes = pExtra->dwNumHashes;

    if ( pExtra->dwNumHashes )
    {
        CopyMemory( pConnPropv1->bData, &(pConnProp->Hash), sizeof(EAPTLS_HASH) );
        if ( pExtra->dwNumHashes >1 )
        {
            CopyMemory ( pConnPropv1->bData + sizeof(EAPTLS_HASH), 
                         pExtra->bData, 
                         (pExtra->dwNumHashes -1 ) * sizeof(EAPTLS_HASH)
                       );

        }
    }

    //Copy the server name
    wcscpy( (WCHAR *)( pConnPropv1->bData + (pExtra->dwNumHashes * sizeof(EAPTLS_HASH) ) ),
            pConnProp->awszServerName
          );

    *ppConnPropv1 = pConnPropv1;
    pConnPropv1 = NULL;


LDone:
    LocalFree(pConnPropv1);
    return dwRetCode;
}


DWORD ConnPropGetV0Struct ( EAPTLS_CONN_PROPERTIES_V1 * pConnPropv1, EAPTLS_CONN_PROPERTIES ** ppConnProp )
{
    DWORD                       dwRetCode = NO_ERROR;
    EAPTLS_CONN_PROPERTIES  *   pConnProp = NULL;
    DWORD                       dwSize = 0;
    EAPTLS_CONN_PROPERTIES_V1_EXTRA UNALIGNED *   pExtrav1 = NULL;
    //
    //First calulate the amount of memory to allocate
    //
    dwSize = sizeof(EAPTLS_CONN_PROPERTIES) + 
            (pConnPropv1->dwNumHashes?( pConnPropv1->dwNumHashes - 1 ) * sizeof(EAPTLS_HASH):0) + 
      ( wcslen( (LPWSTR) (pConnPropv1->bData + (pConnPropv1->dwNumHashes * sizeof(EAPTLS_HASH)) ) )  * sizeof(WCHAR) ) + sizeof(WCHAR);

    pConnProp = LocalAlloc ( LPTR, dwSize );

    if ( NULL == pConnProp )
    {
        dwRetCode = GetLastError();
        goto LDone;
    }

    if ( pConnPropv1->dwVersion <= 1 )
        pConnProp->dwVersion = 1;
    else
        pConnProp->dwVersion = 2;    

    pConnProp->dwSize = dwSize;
    pConnProp->fFlags = pConnPropv1->fFlags;
    if ( pConnPropv1->dwNumHashes > 0 )
    {
        CopyMemory( &(pConnProp->Hash), pConnPropv1->bData, sizeof(EAPTLS_HASH));
    }
    if ( pConnPropv1->bData ) 
    {
        wcscpy  (    pConnProp->awszServerName,
                    (LPWSTR )(pConnPropv1->bData + sizeof( EAPTLS_HASH ) * pConnPropv1->dwNumHashes)
                );
    }
    pExtrav1 = (EAPTLS_CONN_PROPERTIES_V1_EXTRA UNALIGNED *)(pConnProp->awszServerName +
                wcslen( pConnProp->awszServerName) + 1);
                
    pExtrav1->dwNumHashes = pConnPropv1->dwNumHashes;

    if ( pExtrav1->dwNumHashes > 1 )
    {
        CopyMemory( pExtrav1->bData, 
                    pConnPropv1->bData + sizeof(EAPTLS_HASH), 
                    ( pConnPropv1->dwNumHashes - 1 ) * sizeof(EAPTLS_HASH)
                  );
    }
    *ppConnProp = pConnProp;
    pConnProp = NULL;
LDone:
    LocalFree(pConnProp);
    return dwRetCode;
}


void ShowCertDetails ( HWND hWnd, HCERTSTORE hStore, PCCERT_CONTEXT pCertContext)
{
    CRYPTUI_VIEWCERTIFICATE_STRUCT  vcs;
    BOOL                            fPropertiesChanged = FALSE;

    ZeroMemory (&vcs, sizeof (vcs));
    vcs.dwSize = sizeof (vcs);
    vcs.hwndParent = hWnd;
    vcs.pCertContext = pCertContext;
    vcs.cStores = 1;
    vcs.rghStores = &hStore;
    vcs.dwFlags |= (CRYPTUI_DISABLE_EDITPROPERTIES|CRYPTUI_DISABLE_ADDTOSTORE);
    CryptUIDlgViewCertificate (&vcs, &fPropertiesChanged);            
    return;
}

#if 0
// Location of policy parameters
#define cwszEAPOLPolicyParams   L"Software\\Policies\\Microsoft\\Windows\\Network Connections\\8021X"
#define cszCARootHash           "8021XCARootHash"
#define SIZE_OF_CA_CONV_STR     3
#define SIZE_OF_HASH            20
 

//
// ReadGPCARootHashes
//
// Description:
//
// Function to read parameters created by policy downloads
//  Currently, 8021XCARootHash will be downloaded to the HKLM
// 
// Arguments:
//      pdwSizeOfRootHashBlob - Size of hash blob in bytes. Each root CA hash 
//                              will be of SIZE_OF_HASH bytes
//      ppbRootHashBlob - Pointer to hash blob. Caller should free it using
//                              LocalFree
//
// Return values:
//      ERROR_SUCCESS - success
//      !ERROR_SUCCESS - error
//

DWORD
ReadGPCARootHashes(
        DWORD   *pdwSizeOfRootHashBlob,
        PBYTE   *ppbRootHashBlob
)
{
    HKEY    hKey = NULL;
    DWORD   dwType = 0;
    DWORD   dwSize = 0;
    CHAR    *pszCARootHash = NULL;
    DWORD   i = 0;
    CHAR    cszCharConv[SIZE_OF_CA_CONV_STR];
    BYTE    *pbRootHashBlob = NULL;
    DWORD   dwSizeOfHashBlob = 0;
    LONG    lError = ERROR_SUCCESS;

    lError = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            cwszEAPOLPolicyParams,
            0,
            KEY_READ,
            &hKey
            );

    if (lError != ERROR_SUCCESS)
    {
        EapTlsTrace("ReadCARootHashes: RegOpenKeyEx failed with error %ld",
                lError);
        goto LDone;
    }

    lError = RegQueryValueExA(
            hKey,
            cszCARootHash,
            0,
            &dwType,
            NULL,
            &dwSize
            );

    if (lError == ERROR_SUCCESS)
    {
        // Each SHA1 hash will be 2*SIZE_OF_HASH chars
        // Each BYTE in the hash will be represented by 2 CHARs,
        // 1 for each nibble
        // The hashblob should contain an integral number of hashes
        if ((dwSize-1*sizeof(CHAR))%(2*SIZE_OF_HASH*sizeof(CHAR)))
        {
            EapTlsTrace("ReadCARootHashes: Invalid hash length (%ld)",
                    dwSize);
            goto LDone;
        }

        pszCARootHash = (CHAR *)LocalAlloc(LPTR, dwSize);
        if (pszCARootHash == NULL)
        {
            lError = GetLastError();
            EapTlsTrace("ReadCARootHashes: LocalAlloc failed for pwszCARootHash");
            goto LDone;
        }

        lError = RegQueryValueExA(
                hKey,
                cszCARootHash,
                0,
                &dwType,
                (BYTE *)pszCARootHash,
                &dwSize
                );

        if (lError != ERROR_SUCCESS)
        {
            EapTlsTrace("ReadCARootHashes: RegQueryValueEx 2 failed with error (%ld)",
                    lError);
            goto LDone;
        }

        dwSizeOfHashBlob = (dwSize-1*sizeof(CHAR))/(2*sizeof(CHAR));

        if ((pbRootHashBlob = LocalAlloc ( LPTR, dwSizeOfHashBlob*sizeof(BYTE))) == NULL)
        {
            lError = GetLastError();
            EapTlsTrace("ReadCARootHashes: LocalAlloc failed for pbRootHashBlob");
            goto LDone;
        }

        for (i=0; i<dwSizeOfHashBlob; i++)
        {
            ZeroMemory(cszCharConv, SIZE_OF_CA_CONV_STR);
            cszCharConv[0]=pszCARootHash[2*i];
            cszCharConv[1]=pszCARootHash[2*i+1];
            pbRootHashBlob[i] = (BYTE)strtol(cszCharConv, NULL, 16);
        }

    }
    else
    {
        EapTlsTrace("ReadCARootHashes: 802.1X Policy Parameters RegQueryValueEx 1 failed with error (%ld)",
            lError);
            goto LDone;
    }

LDone:

    if (lError != ERROR_SUCCESS)
    {
        if (pbRootHashBlob != NULL)
        {
            LocalFree(pbRootHashBlob);
        }
    }
    else
    {
        *ppbRootHashBlob = pbRootHashBlob;
        *pdwSizeOfRootHashBlob = dwSizeOfHashBlob;
    }


    if (hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    if (pszCARootHash != NULL)
    {
        LocalFree(pszCARootHash);
    }

    return lError;
}

#endif

///////////////////////  ALL PEAP related utils go here  ///////////////////////////


DWORD
PeapGetFirstEntryUserProp ( PPEAP_USER_PROP pUserProp, 
                            PEAP_ENTRY_USER_PROPERTIES UNALIGNED ** ppEntryProp
                          )
{
    
    
    * ppEntryProp = &( pUserProp->UserProperties );
    return NO_ERROR;
}

DWORD
PeapGetFirstEntryConnProp ( PPEAP_CONN_PROP pConnProp,
                            PEAP_ENTRY_CONN_PROPERTIES UNALIGNED ** ppEntryProp
                          )
{
    DWORD                           dwRetCode = NO_ERROR;
    PEAP_ENTRY_CONN_PROPERTIES     UNALIGNED *pFirstEntryConnProp = NULL;    
    LPWSTR                          lpwszServerName;
    RTASSERT ( NULL != pConnProp );
    RTASSERT ( NULL != ppEntryProp );

    lpwszServerName = 
    (LPWSTR )(pConnProp->EapTlsConnProp.bData + 
    sizeof( EAPTLS_HASH ) * pConnProp->EapTlsConnProp.dwNumHashes);

    
    //Get the first entry in connprop
    
    pFirstEntryConnProp  = ( PEAP_ENTRY_CONN_PROPERTIES UNALIGNED *) 
                ( pConnProp->EapTlsConnProp.bData 
                + pConnProp->EapTlsConnProp.dwNumHashes * sizeof(EAPTLS_HASH) + 
                (lpwszServerName? wcslen(lpwszServerName) * sizeof(WCHAR):0) + 
                 sizeof(WCHAR)
                );
     
    if (NULL == pFirstEntryConnProp )
    {
        dwRetCode = ERROR_NOT_FOUND;
        goto LDone;
    }
    
    *ppEntryProp = pFirstEntryConnProp;
LDone:
    return dwRetCode;
}

DWORD
PeapReadConnectionData(
    IN BOOL                         fWireless,
    IN  BYTE*                       pConnectionDataIn,
    IN  DWORD                       dwSizeOfConnectionDataIn,
    OUT PPEAP_CONN_PROP*            ppConnProp
)
{
    DWORD                       dwRetCode = NO_ERROR;
    PPEAP_CONN_PROP             pConnProp   = NULL;
    PEAP_ENTRY_CONN_PROPERTIES UNALIGNED * pEntryProp = NULL;
    EapTlsTrace("PeapReadConnectionData");

    RTASSERT(NULL != ppConnProp);
    
    if ( dwSizeOfConnectionDataIn < sizeof(PEAP_CONN_PROP) )
    {        
        pConnProp = LocalAlloc(LPTR, sizeof(PEAP_CONN_PROP) + sizeof(PEAP_ENTRY_CONN_PROPERTIES)+ sizeof(WCHAR));

        if (NULL == pConnProp)
        {
            dwRetCode = GetLastError();
            EapTlsTrace("LocalAlloc failed and returned %d", dwRetCode);
            goto LDone;
        }
        //This is a new structure
        pConnProp->dwVersion = 1;
        pConnProp->dwSize = sizeof(PEAP_CONN_PROP) + sizeof(PEAP_ENTRY_CONN_PROPERTIES);
        pConnProp->EapTlsConnProp.dwVersion = 1;
        pConnProp->EapTlsConnProp.dwSize = sizeof(EAPTLS_CONN_PROPERTIES_V1);
        pConnProp->EapTlsConnProp.fFlags |= EAPTLS_CONN_FLAG_REGISTRY;
        pConnProp->EapTlsConnProp.fFlags |= EAPTLS_CONN_FLAG_SIMPLE_CERT_SEL;

        pConnProp->dwNumPeapTypes = 1;

        //pEntryProp = (PPEAP_ENTRY_CONN_PROPERTIES)(((PBYTE)(pConnProp)) + sizeof(PEAP_CONN_PROP) + sizeof(WCHAR));
        pEntryProp = ( PEAP_ENTRY_CONN_PROPERTIES UNALIGNED *) 
                ( pConnProp->EapTlsConnProp.bData 
                + pConnProp->EapTlsConnProp.dwNumHashes * sizeof(EAPTLS_HASH) +                 
                 sizeof(WCHAR)
                );
        //
        // Also setup the first peap entry conn prop and set it to
        // eapmschapv2
        //
        if ( fWireless )
        {
            pConnProp->EapTlsConnProp.fFlags |= EAPTLS_CONN_FLAG_NO_VALIDATE_NAME;
        }
        pEntryProp->dwVersion = 1;
        pEntryProp->dwSize = sizeof(PEAP_ENTRY_CONN_PROPERTIES);
        pEntryProp->dwEapTypeId = PPP_EAP_MSCHAPv2;

    }
    else
    {
        RTASSERT(NULL != pConnectionDataIn);

        //
        //Check to see if this is a version 0 structure
        //If it is a version 0 structure then we migrate it to version1
        //
        
        pConnProp = LocalAlloc(LPTR, dwSizeOfConnectionDataIn);

        if (NULL == pConnProp)
        {
            dwRetCode = GetLastError();
            EapTlsTrace("LocalAlloc failed and returned %d", dwRetCode);
            goto LDone;
        }

        // If the user has mucked with the phonebook, we mustn't be affected.
        // The size must be correct.
        
        CopyMemory(pConnProp, pConnectionDataIn, dwSizeOfConnectionDataIn);

        pConnProp->dwSize = dwSizeOfConnectionDataIn;
        pConnProp->EapTlsConnProp.fFlags |= EAPTLS_CONN_FLAG_REGISTRY;
    }

    *ppConnProp = pConnProp;
    pConnProp = NULL;

LDone:
    
    LocalFree(pConnProp);
    return dwRetCode;
}

DWORD
PeapReDoUserData (
    IN  DWORD                dwNewTypeId,
    OUT PPEAP_USER_PROP*     ppNewUserProp
)
{
    DWORD                       dwRetCode = NO_ERROR;
    PPEAP_USER_PROP             pUserProp = NULL; 

    EapTlsTrace("PeapReDoUserData");

    pUserProp = LocalAlloc(LPTR, sizeof(PEAP_USER_PROP));

    if (NULL == pUserProp)
    {
        dwRetCode = GetLastError();
        EapTlsTrace("LocalAlloc failed and returned %d", dwRetCode);
        goto LDone;
    }
    pUserProp->dwVersion = 1;
    pUserProp->dwSize = sizeof(PEAP_USER_PROP);        
    //
    // Setup the default user prop...
    //
    pUserProp->UserProperties.dwVersion = 1;
    pUserProp->UserProperties.dwSize = sizeof(PEAP_ENTRY_USER_PROPERTIES);
    pUserProp->UserProperties.dwEapTypeId = dwNewTypeId;
    *ppNewUserProp = pUserProp;
LDone:
    return dwRetCode;
}

DWORD
PeapReadUserData(
    IN  BYTE*                       pUserDataIn,
    IN  DWORD                       dwSizeOfUserDataIn,
    OUT PPEAP_USER_PROP*      ppUserProp
)
{
    DWORD                       dwErr = NO_ERROR;
    PPEAP_USER_PROP             pUserProp; 

    EapTlsTrace("PeapReadUserData");

    if (dwSizeOfUserDataIn < sizeof(PEAP_USER_PROP))
    {
        pUserProp = LocalAlloc(LPTR, sizeof(PEAP_USER_PROP));

        if (NULL == pUserProp)
        {
            dwErr = GetLastError();
            EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
            goto LDone;
        }
        pUserProp->dwVersion = 1;
        pUserProp->dwSize = sizeof(PEAP_USER_PROP);        
        //
        // Setup the default user prop...
        //
        pUserProp->UserProperties.dwVersion = 1;
        pUserProp->UserProperties.dwSize = sizeof(PEAP_ENTRY_USER_PROPERTIES);
        pUserProp->UserProperties.dwEapTypeId = PPP_EAP_MSCHAPv2;
    }
    else
    {
        RTASSERT(NULL != pUserDataIn);
        

        pUserProp = LocalAlloc(LPTR, dwSizeOfUserDataIn);

        if (NULL == pUserProp)
        {
            dwErr = GetLastError();
            EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
            goto LDone;
        }

        CopyMemory(pUserProp, pUserDataIn, dwSizeOfUserDataIn);

        pUserProp->dwVersion = 1; 
        pUserProp->dwSize = dwSizeOfUserDataIn;
        
    }

    *ppUserProp = pUserProp;
    pUserProp = NULL;

LDone:

   LocalFree(pUserProp);
   return dwErr;
}

//
// Add node at the head
//

DWORD 
PeapEapInfoAddListNode (PPEAP_EAP_INFO * ppEapInfo)
{
    PPEAP_EAP_INFO  pEapInfo = NULL;
    DWORD           dwRetCode = NO_ERROR;

    pEapInfo = (PPEAP_EAP_INFO)LocalAlloc(LPTR, sizeof(PEAP_EAP_INFO));

    if ( NULL == pEapInfo )
    {
        dwRetCode = ERROR_OUTOFMEMORY;
        goto LDone;
    }

    if ( NULL == *ppEapInfo )
    {
        *ppEapInfo = pEapInfo;
    }
    else
    {
        pEapInfo->pNext = *ppEapInfo;
        *ppEapInfo = pEapInfo;
    }
LDone:
    return dwRetCode;
}

DWORD 
PeapEapInfoCopyListNode (   DWORD dwTypeId, 
    PPEAP_EAP_INFO pEapInfoList, 
    PPEAP_EAP_INFO * ppEapInfo )
{
    DWORD           dwRetCode = ERROR_NOT_FOUND;
    PPEAP_EAP_INFO  pEapInfoListInternal = pEapInfoList;
    while ( pEapInfoListInternal )
    {
        if ( pEapInfoListInternal->dwTypeId == dwTypeId )
        {
            *ppEapInfo = LocalAlloc( LPTR, sizeof(PEAP_EAP_INFO) );
            if ( NULL == *ppEapInfo )
            {
                dwRetCode = ERROR_OUTOFMEMORY;
                goto LDone;
            }
            CopyMemory ( *ppEapInfo, pEapInfoListInternal, sizeof(PEAP_EAP_INFO) );
            dwRetCode = NO_ERROR;
            goto LDone;
        }
        pEapInfoListInternal = pEapInfoListInternal->pNext;
    }
    
LDone:
    return dwRetCode;

}

DWORD
PeapEapInfoFindListNode (   DWORD dwTypeId, 
    PPEAP_EAP_INFO pEapInfoList, 
    PPEAP_EAP_INFO * ppEapInfo )
{
    DWORD           dwRetCode = ERROR_NOT_FOUND;
    PPEAP_EAP_INFO  pEapInfoListInternal = pEapInfoList;
    while ( pEapInfoListInternal )
    {
        if ( pEapInfoListInternal->dwTypeId == dwTypeId )
        {
            *ppEapInfo = pEapInfoListInternal;
            dwRetCode = NO_ERROR;
            goto LDone;
        }
        pEapInfoListInternal = pEapInfoListInternal->pNext;
    }
    
LDone:
    return dwRetCode;
}

VOID
PeapEapInfoFreeNodeData ( PPEAP_EAP_INFO pEapInfo )
{
    LocalFree ( pEapInfo->lpwszFriendlyName );
    LocalFree ( pEapInfo->lpwszConfigUIPath );
    LocalFree ( pEapInfo->lpwszIdentityUIPath );
    LocalFree ( pEapInfo->lpwszConfigClsId );
    LocalFree ( pEapInfo->pbNewClientConfig );
    LocalFree ( pEapInfo->lpwszInteractiveUIPath );
    LocalFree ( pEapInfo->lpwszPath);
    if ( pEapInfo->hEAPModule )
    {
        FreeLibrary(pEapInfo->hEAPModule);
    }

}

VOID
PeapEapInfoRemoveHeadNode(PPEAP_EAP_INFO * ppEapInfo)
{
    PPEAP_EAP_INFO      pEapInfo = *ppEapInfo;

    if ( pEapInfo )
    {
        *ppEapInfo = pEapInfo->pNext;
        PeapEapInfoFreeNodeData(pEapInfo);
        LocalFree ( pEapInfo );
    }
}
VOID
PeapEapInfoFreeList ( PPEAP_EAP_INFO  pEapInfo )
{
    PPEAP_EAP_INFO      pNext;
    while ( pEapInfo )
    {
        pNext = pEapInfo->pNext;
        PeapEapInfoFreeNodeData(pEapInfo);
        LocalFree ( pEapInfo );
        pEapInfo = pNext;
    }
}

DWORD
PeapEapInfoReadSZ (HKEY hkeyPeapType, 
                     LPWSTR pwszValue, 
                     LPWSTR * ppValueData )
{

    DWORD   dwRetCode = NO_ERROR;
    DWORD   dwType = 0;
    DWORD   cbValueDataSize =0;
    PBYTE   pbValue = NULL;
    

    dwRetCode = RegQueryValueEx(
                           hkeyPeapType,
                           pwszValue,
                           NULL,
                           &dwType,
                           pbValue,
                           &cbValueDataSize );

    if ( dwRetCode != NO_ERROR )
    {
        goto LDone;       
    }

    pbValue = (PBYTE)LocalAlloc ( LPTR, cbValueDataSize );
    if ( NULL == pbValue )
    {
        dwRetCode = ERROR_OUTOFMEMORY;
        goto LDone;
    }

    dwRetCode = RegQueryValueEx(
                           hkeyPeapType,
                           pwszValue,
                           NULL,
                           &dwType,
                           pbValue,
                           &cbValueDataSize );

    if ( dwRetCode != NO_ERROR )
    {
        goto LDone;       
    }

    *ppValueData = (LPWSTR)pbValue;
    pbValue = NULL;

LDone:
    LocalFree ( pbValue );
    return dwRetCode;

}



DWORD
PeapEapInfoExpandSZ (HKEY hkeyPeapType, 
                     LPWSTR pwszValue, 
                     LPWSTR * ppValueData )
{
    DWORD   dwRetCode = NO_ERROR;
    DWORD   dwType = 0;
    DWORD   cbValueDataSize =0;
    PBYTE   pbValue = NULL;
    PBYTE   pbExpandedValue = NULL;

    dwRetCode = RegQueryValueEx(
                           hkeyPeapType,
                           pwszValue,
                           NULL,
                           &dwType,
                           pbValue,
                           &cbValueDataSize );

    if ( dwRetCode != NO_ERROR )
    {
        goto LDone;       
    }

    pbValue = (PBYTE)LocalAlloc ( LPTR, cbValueDataSize );
    if ( NULL == pbValue )
    {
        dwRetCode = ERROR_OUTOFMEMORY;
        goto LDone;
    }

    dwRetCode = RegQueryValueEx(
                           hkeyPeapType,
                           pwszValue,
                           NULL,
                           &dwType,
                           pbValue,
                           &cbValueDataSize );

    if ( dwRetCode != NO_ERROR )
    {
        goto LDone;       
    }
    
    //now Expand the exvironment string

    cbValueDataSize = ExpandEnvironmentStrings( (LPWSTR)pbValue, NULL, 0 );

    pbExpandedValue = (PBYTE)LocalAlloc ( LPTR, cbValueDataSize  * sizeof(WCHAR) );
    if ( NULL == pbExpandedValue )
    {
        dwRetCode = ERROR_OUTOFMEMORY;
        goto LDone;
    }

    cbValueDataSize = ExpandEnvironmentStrings( (LPWSTR)pbValue, 
                                        (LPWSTR)pbExpandedValue, sizeof(WCHAR) * cbValueDataSize );

    if ( cbValueDataSize == 0 )
    {
        dwRetCode = GetLastError();
        goto LDone;
    }
    
    *ppValueData = (LPWSTR)pbExpandedValue;
    pbExpandedValue = NULL;
LDone:
    LocalFree ( pbValue );
    LocalFree ( pbExpandedValue );
    return dwRetCode;
}

BOOL
IsPeapCrippled(HKEY hKeyLM)
{
    BOOL    fRetCode = FALSE;
    DWORD   dwRetCode = NO_ERROR;
    HKEY    hCripple = 0;
    DWORD   dwValue = 0;
    DWORD   dwType = 0;
    DWORD   cbValueDataSize = sizeof(DWORD);

    dwRetCode  = RegOpenKeyEx( hKeyLM, 
                              PEAP_KEY_PEAP, 
                              0, 
                              KEY_READ, 
                              &hCripple 
                            );   

    if (NO_ERROR != dwRetCode)
    {
       goto LDone;
    }

    dwRetCode = RegQueryValueEx(
                           hCripple,
                           PEAP_CRIPPLE_VALUE,                           
                           NULL,
                           &dwType,
                           (PBYTE)&dwValue,
                           &cbValueDataSize );

    if ( dwRetCode != NO_ERROR )
    {
        goto LDone;       
    }
    
    if ( dwValue != 0 )
    {
        fRetCode = TRUE;
    }

LDone:
    if ( hCripple )
        RegCloseKey ( hCripple );

    return fRetCode;
    
}

//
// Get a list of all EAP types configured for PEAP.
//

DWORD
PeapEapInfoGetList ( LPWSTR lpwszMachineName, PPEAP_EAP_INFO * ppEapInfo)
{
    DWORD           dwRetCode = NO_ERROR;
    HKEY            hKeyLM =0;
    HKEY            hKeyPeap = 0;
    HKEY            hkeyPeapType = 0;
    DWORD           dwIndex;
    DWORD           cb;
    WCHAR           wszPeapType[200];
    DWORD           dwEapTypeId = 0;
    FARPROC         pRasEapGetInfo;

    dwRetCode = RegConnectRegistry ( lpwszMachineName, 
                                     HKEY_LOCAL_MACHINE,
                                     &hKeyLM
                                   );

    if ( NO_ERROR != dwRetCode )
    {
        goto LDone;
    }


                                       
   dwRetCode  = RegOpenKeyEx( hKeyLM, 
                              PEAP_KEY_EAP, 
                              0, 
                              KEY_READ, 
                              &hKeyPeap 
                            );   

   if (NO_ERROR != dwRetCode)
   {
       goto LDone;
   }



   for (dwIndex = 0; TRUE; ++dwIndex)
   {
        cb = sizeof(wszPeapType) / sizeof(WCHAR);
        dwRetCode = RegEnumKeyEx(   hKeyPeap, 
                                    dwIndex, 
                                    wszPeapType, 
                                    &cb, 
                                    NULL, 
                                    NULL, 
                                    NULL, 
                                    NULL 
                                 );
        if (dwRetCode != NO_ERROR)
        {
            // Includes "out of items", the normal loop termination.
            //
            dwRetCode = NO_ERROR;
            break;
        }
        dwRetCode = RegOpenKeyEx(   hKeyPeap, 
                                    wszPeapType, 
                                    0, 
                                    KEY_READ, 
                                    &hkeyPeapType 
                                );
        if (dwRetCode != NO_ERROR)
        {
            dwRetCode = NO_ERROR;
            continue;
        }

        dwEapTypeId = _wtol(wszPeapType);

        if ( dwEapTypeId == PPP_EAP_PEAP )
        {
            dwRetCode = NO_ERROR;
            continue;
        }

        {
            //
            // Check to see if we support this in peap
            // By default we do.
            DWORD dwRolesSupported = 0;
            DWORD cbValueSize = sizeof(dwRolesSupported);
            DWORD dwType = 0;

            dwRetCode = RegQueryValueEx(
                                hkeyPeapType,
                                PEAP_REGVAL_ROLESSUPPORTED,                           
                                NULL,
                                &dwType,
                                (PBYTE)&dwRolesSupported,
                                &cbValueSize );

            if ( dwRetCode == NO_ERROR )
            {
                //
                // We dont allow this method in PEAP.
                //
                if ( RAS_EAP_ROLE_EXCLUDE_IN_PEAP & dwRolesSupported )
                {
                    continue;
                }
            }
        }

        //
        // Read the required information and setup the node here
        //

        dwRetCode = PeapEapInfoAddListNode (ppEapInfo);
        if ( NO_ERROR != dwRetCode )
        {
            goto LDone;
        }

        // 
        // Setup the list node - if any of these entries are not
        // found skip the entry
        //
        (*ppEapInfo)->dwTypeId = dwEapTypeId;

        dwRetCode = PeapEapInfoReadSZ (   hkeyPeapType,
                                          PEAP_REGVAL_FRIENDLYNAME,
                                          &((*ppEapInfo)->lpwszFriendlyName )
                                        );
        if ( NO_ERROR != dwRetCode )
        {
            if ( ERROR_FILE_NOT_FOUND == dwRetCode )
            {
                PeapEapInfoRemoveHeadNode(ppEapInfo);
                dwRetCode = NO_ERROR;
                continue;
            }
            goto LDone;
        }

        dwRetCode = PeapEapInfoExpandSZ (   hkeyPeapType,
                                            PEAP_REGVAL_CONFIGDLL,
                                            &((*ppEapInfo)->lpwszConfigUIPath )
                                        );
        if ( NO_ERROR != dwRetCode )
        {
            if ( ERROR_FILE_NOT_FOUND == dwRetCode )
            {
                // it is fine to have no config stuff any more.
                // We show the default identity                
                dwRetCode = NO_ERROR;                
            }
            else
            {
                goto LDone;
            }
        }        

        dwRetCode = PeapEapInfoExpandSZ (   hkeyPeapType,
                                            PEAP_REGVAL_IDENTITYDLL,
                                            &((*ppEapInfo)->lpwszIdentityUIPath )
                                        );
        if ( NO_ERROR != dwRetCode )
        {
            if ( ERROR_FILE_NOT_FOUND == dwRetCode )
            {
                //
                // It is fine if we dont have any identity UI.  Peap
                // will provide a default identity UI
                //                
                dwRetCode = NO_ERROR;                
            }
            else
            {
                goto LDone;
            }
        }

        dwRetCode = PeapEapInfoExpandSZ (   hkeyPeapType,
                                            PEAP_REGVAL_INTERACTIVEUIDLL,
                                            &((*ppEapInfo)->lpwszInteractiveUIPath )
                                        );
        if ( NO_ERROR != dwRetCode )
        {
            if ( ERROR_FILE_NOT_FOUND == dwRetCode )
            {
                //It is fine if we dont have interactive UI
                //
                dwRetCode = NO_ERROR;
            }
            else
            {
                goto LDone;
            }
        }

        dwRetCode = PeapEapInfoReadSZ ( hkeyPeapType,
                                        PEAP_REGVAL_CONFIGCLSID,
                                        &((*ppEapInfo)->lpwszConfigClsId )
                                       );
        if ( NO_ERROR != dwRetCode )
        {
            if ( ERROR_FILE_NOT_FOUND == dwRetCode )
            {
                //
                // Missing config clsid is also fine
                dwRetCode = NO_ERROR;
            }
            else
            {
                goto LDone;
            }
        }

        dwRetCode = PeapEapInfoExpandSZ ( hkeyPeapType,
                                        PEAP_REGVAL_PATH,
                                        &((*ppEapInfo)->lpwszPath )
                                       );
        if ( NO_ERROR != dwRetCode )
        {
            //
            // This is not acceptable.  So this is a problem.
            //
            if ( ERROR_FILE_NOT_FOUND == dwRetCode )
            {
                PeapEapInfoRemoveHeadNode(ppEapInfo);
                dwRetCode = NO_ERROR;
                continue;
            }
            goto LDone;
        }

        //
        // Now get the EAP INFO from the DLL.
        //
        (*ppEapInfo)->hEAPModule = LoadLibrary( ( (*ppEapInfo)->lpwszPath ) );
        if ( NULL == (*ppEapInfo)->hEAPModule )
        {
            dwRetCode = GetLastError();
            goto LDone;
        }
        
        pRasEapGetInfo = GetProcAddress( (*ppEapInfo)->hEAPModule , 
                                         "RasEapGetInfo" 
                                       );

        if ( pRasEapGetInfo == (FARPROC)NULL )
        {
            dwRetCode = GetLastError();

            goto LDone;
        }

        (*ppEapInfo)->RasEapGetCredentials =  (DWORD (*) (
                                    DWORD,VOID *, VOID **))
                                    GetProcAddress((*ppEapInfo)->hEAPModule,
                                                        "RasEapGetCredentials");


        (*ppEapInfo)->PppEapInfo.dwSizeInBytes = sizeof( PPP_EAP_INFO );

        dwRetCode = (DWORD) (*pRasEapGetInfo)( dwEapTypeId,
                                              &((*ppEapInfo)->PppEapInfo) );

        if ( dwRetCode != NO_ERROR )
        {
            goto LDone;
        }
        
        //
        // Call initialize function here
        //
        if ( (*ppEapInfo)->PppEapInfo.RasEapInitialize )
        {
            (*ppEapInfo)->PppEapInfo.RasEapInitialize(TRUE);
        }
        RegCloseKey(hkeyPeapType);
        hkeyPeapType = 0;
   }
LDone:
    if ( hkeyPeapType )
        RegCloseKey(hkeyPeapType);

    if ( hKeyPeap )
        RegCloseKey(hKeyPeap);

    if ( hKeyLM )
        RegCloseKey(hKeyLM);
    
    if ( NO_ERROR != dwRetCode )
    {
        PeapEapInfoFreeList( *ppEapInfo );
    }

    return dwRetCode;
}



DWORD
PeapEapInfoSetConnData ( PPEAP_EAP_INFO pEapInfo, PPEAP_CONN_PROP pPeapConnProp )
{
    DWORD                           dwRetCode = NO_ERROR;
    PEAP_ENTRY_CONN_PROPERTIES UNALIGNED *pEntryProp = NULL;
    PPEAP_EAP_INFO                  pEapInfoLocal;
    DWORD                           dwCount;

    RTASSERT(NULL != pPeapConnProp);
    RTASSERT(NULL != pEapInfo);

    if ( !pPeapConnProp->dwNumPeapTypes )
    {
        goto LDone;
    }
    //
    // Right now there is only one EAP Type in the list
    // So it should not be a problem with this stuff now

    pEntryProp = ( PEAP_ENTRY_CONN_PROPERTIES*) 
            ( pPeapConnProp->EapTlsConnProp.bData 
            + pPeapConnProp->EapTlsConnProp.dwNumHashes * sizeof(EAPTLS_HASH) +                 
                sizeof(WCHAR)
            );

    pEapInfoLocal = pEapInfo;
    while( pEapInfoLocal )
    {
        if ( pEapInfoLocal->dwTypeId == pEntryProp->dwEapTypeId )
        {
            if ( pEntryProp->dwSize > sizeof(PEAP_ENTRY_CONN_PROPERTIES))
            {
                pEapInfoLocal->pbClientConfigOrig = pEntryProp->bData;
                pEapInfoLocal->dwClientConfigOrigSize = pEntryProp->dwSize - 
                                sizeof(PEAP_ENTRY_CONN_PROPERTIES) + 1;
            }
            else
            {
                pEapInfoLocal->pbClientConfigOrig = NULL;
                pEapInfoLocal->dwClientConfigOrigSize = 0;

            }
            break;
        }
        pEapInfoLocal = pEapInfoLocal->pNext;
    }

#if 0
    for ( dwCount = 0; dwCount < pPeapConnProp->dwNumPeapTypes; dwCount ++ )
    {
        pEntryProp = (PEAP_ENTRY_CONN_PROPERTIES UNALIGNED * )(((BYTE UNALIGNED *)&(pPeapConnProp->EapTlsConnProp)) + 
            pPeapConnProp->EapTlsConnProp.dwSize + 
            sizeof(PEAP_ENTRY_CONN_PROPERTIES) * dwCount);

        pEapInfoLocal = pEapInfo;

        while( pEapInfoLocal )
        {
            if ( pEapInfoLocal->dwTypeId == pEntryProp->dwEapTypeId )
            {
                if ( pEntryProp->dwSize > sizeof(PEAP_ENTRY_CONN_PROPERTIES))
                {
                    pEapInfoLocal->pbClientConfigOrig = pEntryProp->bData;
                    pEapInfoLocal->dwClientConfigOrigSize = pEntryProp->dwSize - 
                                    sizeof(PEAP_ENTRY_CONN_PROPERTIES) + 1;
                }
                else
                {
                    pEapInfoLocal->pbClientConfigOrig = NULL;
                    pEapInfoLocal->dwClientConfigOrigSize = 0;

                }
                break;
            }
            pEapInfoLocal = pEapInfoLocal->pNext;
        }
    }
#endif    
LDone:
    return dwRetCode;
}


DWORD PeapEapInfoInvokeIdentityUI ( HWND hWndParent, 
                                    PPEAP_EAP_INFO pEapInfo,
                                    const WCHAR * pwszPhoneBook,
                                    const WCHAR * pwszEntry,
                                    PBYTE         pbUserDataIn, // Got when using Winlogon
                                    DWORD         cbUserDataIn, // Got when using Winlogon
                                    WCHAR** ppwszIdentityOut,
                                    DWORD fFlags)
{
    DWORD                   dwRetCode = NO_ERROR;
    PBYTE                   pbUserDataNew = NULL;
    DWORD                   dwSizeOfUserDataNew = 0;
    RASEAPGETIDENTITY       pIdenFunc = NULL;
    RASEAPFREE              pFreeFunc = NULL;

    RTASSERT ( NULL != pEapInfo );
    RTASSERT ( NULL != pEapInfo->lpwszIdentityUIPath );

    pIdenFunc = (RASEAPGETIDENTITY)
                   GetProcAddress(pEapInfo->hEAPModule, "RasEapGetIdentity");

    if ( pIdenFunc == NULL)
    {
        dwRetCode = GetLastError();
        goto LDone;
    }

    pFreeFunc = (RASEAPFREE) GetProcAddress(pEapInfo->hEAPModule, "RasEapFreeMemory");
    if ( pFreeFunc == NULL )
    {
        dwRetCode = GetLastError();
        goto LDone;
    }

    dwRetCode = pIdenFunc ( pEapInfo->dwTypeId,
                            hWndParent,
                            fFlags,
                            pwszPhoneBook,
                            pwszEntry,
                            pEapInfo->pbClientConfigOrig,
                            pEapInfo->dwClientConfigOrigSize,
                            ( fFlags & RAS_EAP_FLAG_LOGON ?
                                pbUserDataIn:
                                pEapInfo->pbUserConfigOrig
                            ),
                            ( fFlags & RAS_EAP_FLAG_LOGON ?
                                cbUserDataIn:
                                pEapInfo->dwUserConfigOrigSize
                            ),
                            &pbUserDataNew,
                            &dwSizeOfUserDataNew,
                            ppwszIdentityOut
                          );
    if ( NO_ERROR != dwRetCode )
    {
        goto LDone;
    }
    if ( pbUserDataNew  && 
         dwSizeOfUserDataNew
       )
    {
        //
        // we have new user data
        //
        pEapInfo->pbUserConfigNew = (PBYTE)LocalAlloc (LPTR, dwSizeOfUserDataNew );
        if ( NULL == pEapInfo->pbUserConfigNew )
        {
            dwRetCode = ERROR_OUTOFMEMORY;
            goto LDone;
        }
    
        CopyMemory ( pEapInfo->pbUserConfigNew,
                     pbUserDataNew,
                     dwSizeOfUserDataNew
                   );

        pEapInfo->dwNewUserConfigSize = dwSizeOfUserDataNew;
    }
       
LDone:
    pFreeFunc( pbUserDataNew );
    return dwRetCode;
}


DWORD PeapEapInfoInvokeClientConfigUI ( HWND hWndParent, 
                                        PPEAP_EAP_INFO pEapInfo,
                                        DWORD fFlags)
{
    DWORD                   dwRetCode = NO_ERROR;
    RASEAPINVOKECONFIGUI    pInvokeConfigUI;
    RASEAPFREE              pFreeConfigUIData;
    PBYTE                   pConnDataOut = NULL;
    DWORD                   dwConnDataOut = 0;

    RTASSERT ( NULL != pEapInfo );
    RTASSERT ( NULL != pEapInfo->lpwszConfigUIPath );
    

    if ( !(pInvokeConfigUI =
            (RASEAPINVOKECONFIGUI )GetProcAddress(
                  pEapInfo->hEAPModule, "RasEapInvokeConfigUI" ))
        || !(pFreeConfigUIData =
              (RASEAPFREE) GetProcAddress(
                  pEapInfo->hEAPModule, "RasEapFreeMemory" )) 
       )
    {
        dwRetCode = GetLastError();
        goto LDone;
    }

    dwRetCode = pInvokeConfigUI (   pEapInfo->dwTypeId,
                                    hWndParent,
                                    fFlags,
                                    (pEapInfo->pbNewClientConfig?
                                    pEapInfo->pbNewClientConfig:
                                    pEapInfo->pbClientConfigOrig
                                    ),
                                    (pEapInfo->pbNewClientConfig?
                                     pEapInfo->dwNewClientConfigSize:
                                     pEapInfo->dwClientConfigOrigSize
                                    ),
                                    &pConnDataOut,
                                    &dwConnDataOut
                                );
    if ( NO_ERROR != dwRetCode )
    {
        goto LDone;
    }
    if ( pConnDataOut && dwConnDataOut )
    {
        if ( pEapInfo->pbNewClientConfig )
        {
            LocalFree(pEapInfo->pbNewClientConfig );
            pEapInfo->pbNewClientConfig = NULL;
            pEapInfo->dwNewClientConfigSize = 0;
        }
        pEapInfo->pbNewClientConfig = (PBYTE)LocalAlloc ( LPTR, dwConnDataOut );
        if ( NULL == pEapInfo->pbNewClientConfig )
        {
            dwRetCode = ERROR_OUTOFMEMORY;
            goto LDone;
        }
        CopyMemory( pEapInfo->pbNewClientConfig,
                    pConnDataOut,
                    dwConnDataOut
                  );
        pEapInfo->dwNewClientConfigSize = dwConnDataOut;
    }
LDone:
    if ( pConnDataOut )
        pFreeConfigUIData(pConnDataOut);
    return dwRetCode;
}


DWORD
OpenPeapRegistryKey(
    IN  WCHAR*  pwszMachineName,
    IN  REGSAM  samDesired,
    OUT HKEY*   phKeyPeap
)
{
    HKEY    hKeyLocalMachine = NULL;
    BOOL    fHKeyLocalMachineOpened     = FALSE;
    BOOL    fHKeyPeapOpened           = FALSE;
    LONG    lRet;
    DWORD   dwErr                       = NO_ERROR;

    RTASSERT(NULL != phKeyPeap);

    lRet = RegConnectRegistry(pwszMachineName, HKEY_LOCAL_MACHINE,
                &hKeyLocalMachine);
    if (ERROR_SUCCESS != lRet)
    {
        dwErr = lRet;
        EapTlsTrace("RegConnectRegistry(%ws) failed and returned %d",
            pwszMachineName ? pwszMachineName : L"NULL", dwErr);
        goto LDone;
    }
    fHKeyLocalMachineOpened = TRUE;

    lRet = RegOpenKeyEx(hKeyLocalMachine, PEAP_KEY_25, 0, samDesired,
                phKeyPeap);
    if (ERROR_SUCCESS != lRet)
    {
        dwErr = lRet;
        EapTlsTrace("RegOpenKeyEx(%ws) failed and returned %d",
            PEAP_KEY_25, dwErr);
        goto LDone;
    }
    fHKeyPeapOpened = TRUE;

LDone:

    if (   fHKeyPeapOpened
        && (ERROR_SUCCESS != dwErr))
    {
        RegCloseKey(*phKeyPeap);
    }

    if (fHKeyLocalMachineOpened)
    {
        RegCloseKey(hKeyLocalMachine);
    }

    return(dwErr);
}



DWORD
PeapServerConfigDataIO(
    IN      BOOL    fRead,
    IN      WCHAR*  pwszMachineName,
    IN OUT  BYTE**  ppData,
    IN      DWORD   dwNumBytes
)
{
    HKEY                    hKeyPeap;
    PEAP_USER_PROP*         pUserProp;
    BOOL                    fHKeyPeapOpened   = FALSE;
    BYTE*                   pData               = NULL;
    DWORD                   dwSize = 0;

    LONG                    lRet;
    DWORD                   dwType;
    DWORD                   dwErr               = NO_ERROR;

    RTASSERT(NULL != ppData);

    dwErr = OpenPeapRegistryKey(pwszMachineName,
                fRead ? KEY_READ : KEY_WRITE, &hKeyPeap);
    if (ERROR_SUCCESS != dwErr)
    {
        goto LDone;
    }
    fHKeyPeapOpened = TRUE;

    if (fRead)
    {
        lRet = RegQueryValueEx(hKeyPeap, PEAP_VAL_SERVER_CONFIG_DATA, NULL,
                &dwType, NULL, &dwSize);

        if (   (ERROR_SUCCESS != lRet)
            || (REG_BINARY != dwType)
            || (sizeof(PEAP_USER_PROP) != dwSize))
        {
            pData = LocalAlloc(LPTR, sizeof(PEAP_USER_PROP));

            if (NULL == pData)
            {
                dwErr = GetLastError();
                EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
                goto LDone;
            }

            pUserProp = (PEAP_USER_PROP*)pData;
            pUserProp->dwVersion = 0;
        }
        else
        {
            pData = LocalAlloc(LPTR, dwSize);

            if (NULL == pData)
            {
                dwErr = GetLastError();
                EapTlsTrace("LocalAlloc failed and returned %d", dwErr);
                goto LDone;
            }

            lRet = RegQueryValueEx(hKeyPeap, PEAP_VAL_SERVER_CONFIG_DATA,
                    NULL, &dwType, pData, &dwSize);

            if (ERROR_SUCCESS != lRet)
            {
                dwErr = lRet;
                EapTlsTrace("RegQueryValueEx(%ws) failed and returned %d",
                    EAPTLS_VAL_SERVER_CONFIG_DATA, dwErr);
                goto LDone; 
            }
        }

        pUserProp = (PEAP_USER_PROP*)pData;
        pUserProp->dwSize = sizeof(PEAP_USER_PROP);

        *ppData = pData;
        pData = NULL;
    }
    else
    {
        lRet = RegSetValueEx(hKeyPeap, PEAP_VAL_SERVER_CONFIG_DATA, 0,
                REG_BINARY, *ppData, dwNumBytes);

        if (ERROR_SUCCESS != lRet)
        {
            dwErr = lRet;
            EapTlsTrace("RegSetValueEx(%ws) failed and returned %d",
                PEAP_VAL_SERVER_CONFIG_DATA, dwErr);
            goto LDone; 
        }
    }

LDone:

    if (fHKeyPeapOpened)
    {
        RegCloseKey(hKeyPeap);
    }

    LocalFree(pData);

    return(dwErr);
}

DWORD
GetIdentityFromUserName ( 
LPWSTR lpszUserName,
LPWSTR lpszDomain,
LPWSTR * ppwszIdentity
)
{
    DWORD   dwRetCode = NO_ERROR;
    DWORD   dwNumBytes;

    //domain+ user + '\' + null
    dwNumBytes = (wcslen(lpszUserName) + wcslen(lpszDomain) + 1 + 1) * sizeof(WCHAR);
    *ppwszIdentity = LocalAlloc ( LPTR, dwNumBytes);
    if ( NULL == *ppwszIdentity )
    {
        dwRetCode = ERROR_OUTOFMEMORY;
        goto LDone;
    }
    
    
    if ( *lpszDomain )
    {
        wcsncpy ( *ppwszIdentity, lpszDomain, DNLEN );
    
        wcscat( *ppwszIdentity, L"\\");
    }

    wcscat ( *ppwszIdentity, lpszUserName );

LDone:
    return dwRetCode;
}

//
// Format identity as domain\user.  this is ok because our identity inside has not been
// tampered with
//

BOOL FFormatUserIdentity ( LPWSTR lpszUserNameRaw, LPWSTR * lppszUserNameFormatted )
{
    BOOL        fRetVal = TRUE;
    LPTSTR      s1 = NULL;
    LPTSTR      s2 = NULL;

    RTASSERT(NULL != lpszUserNameRaw );
    RTASSERT(NULL != lppszUserNameFormatted );
    //Need to add 2 more chars.  One for NULL and other for $ sign
    *lppszUserNameFormatted = (LPTSTR )LocalAlloc ( LPTR, (wcslen(lpszUserNameRaw ) + 2)* sizeof(WCHAR) );
    if ( NULL == *lppszUserNameFormatted )
    {
		return FALSE;
    }
    //find the first "@" and that is the identity of the machine.
    //the second "." is the domain.
    //check to see if there at least 2 dots.  If not the raw string is 
    //the output string
    s1 = wcschr ( lpszUserNameRaw, '@' );
    if ( s1 )
    {
        //
        // get the first .
        //
        s2 = wcschr ( s1, '.');

    }
    if ( s1 && s2 )
    {
        memcpy ( *lppszUserNameFormatted, s1+1, (s2-s1-1) * sizeof(WCHAR)) ;
        memcpy ( (*lppszUserNameFormatted) + (s2-s1-1), L"\\", sizeof(WCHAR));
        memcpy ( (*lppszUserNameFormatted)+ (s2-s1), lpszUserNameRaw, (s1-lpszUserNameRaw) * sizeof(WCHAR) );
    }
    else
    {
        wcscpy ( *lppszUserNameFormatted, lpszUserNameRaw );
    }
   
    return fRetVal;
}

VOID
GetMarshalledCredFromHash(
                            PBYTE pbHash,
                            DWORD cbHash,
                            CHAR  *pszMarshalledCred,
                            DWORD cchCredSize)
{

    CERT_CREDENTIAL_INFO    CertCredInfo;
    CHAR                    *pszMarshalledCredLocal = NULL;

    CertCredInfo.cbSize = sizeof(CertCredInfo);

    memcpy (CertCredInfo.rgbHashOfCert,
                pbHash,
                cbHash
           );

    if (CredMarshalCredentialA(CertCredential,
                              (PVOID) &CertCredInfo,
                              &pszMarshalledCredLocal
                              ))
    {
        //
        // Got Marshalled Credential from the cert
        // Set it in the username field
        //

        ASSERT( NULL != pszMarshalledCredLocal );
        (VOID) StringCchCopyA (pszMarshalledCred,
                        cchCredSize,
                        pszMarshalledCredLocal );

        CredFree ( pszMarshalledCredLocal );
    }
    else
    {
        EapTlsTrace("CredMarshalCredential Failed with Error:0x%x",
                    GetLastError());
    }
}

DWORD
GetCredentialsFromUserProperties(
                EAPTLSCB *pEapTlsCb,
                VOID **ppCredentials)
{
    DWORD dwRetCode = ERROR_SUCCESS;
    RASMAN_CREDENTIALS *pCreds = NULL;

    //
    // Note: Its important that this allocation is made from
    // the process heap. Ppp engine needs to change otherwise.
    //
    pCreds = LocalAlloc(LPTR, sizeof(RASMAN_CREDENTIALS));
    if(NULL == pCreds)
    {
        dwRetCode = GetLastError();
        goto done;
    }

    if(     (NULL != pEapTlsCb->pSavedPin)
        &&  (NULL != pEapTlsCb->pSavedPin->pwszPin))
    {
        UNICODE_STRING UnicodeString;

        //
        // Decode the saved pin
        //
        UnicodeString.Length = pEapTlsCb->pSavedPin->usLength;
        UnicodeString.MaximumLength = pEapTlsCb->pSavedPin->usMaximumLength;
        UnicodeString.Buffer = pEapTlsCb->pSavedPin->pwszPin;
        RtlRunDecodeUnicodeString(pEapTlsCb->pSavedPin->ucSeed,
                                 &UnicodeString);

        (VOID)StringCchCopyW(pCreds->wszPassword,
                       PWLEN,
                       pEapTlsCb->pSavedPin->pwszPin);

        ZeroMemory(pEapTlsCb->pSavedPin->pwszPin,
                wcslen(pEapTlsCb->pSavedPin->pwszPin) * sizeof(WCHAR));

        LocalFree(pEapTlsCb->pSavedPin->pwszPin);
        LocalFree(pEapTlsCb->pSavedPin);
        pEapTlsCb->pSavedPin = NULL;
    }

    if(NULL != pEapTlsCb->pUserProp)
    {
        GetMarshalledCredFromHash(
                        pEapTlsCb->pUserProp->Hash.pbHash,
                        pEapTlsCb->pUserProp->Hash.cbHash,
                        pCreds->szUserName,
                        UNLEN);
    }

    pCreds->dwFlags = RASCRED_EAP;

done:

    *ppCredentials = (VOID *) pCreds;
    return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\engine\auth.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    auth.c
//
// Description: Contains FSM code to handle and authentication protocols.
//
// History:
//          Nov 11,1993.    NarenG          Created original version.
//          Jan 09,1995     RamC            Save Lsa hToken in the PCB structure
//                                          This will be closed
//                                          in ProcessLineDownWorker() routine 
//                                          to release the RAS license.

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>     // needed for winbase.h

#include <windows.h>    // Win32 base API's
#include <stdlib.h>
#include <string.h>
#include <wchar.h>

#include <lmcons.h>
#include <raserror.h>
#include <rasman.h>
#include <rtutils.h>
#include <mprlog.h>
#include <mprerror.h>
#include <rasppp.h>
#include <pppcp.h>
#include <ppp.h>
#include <auth.h>
#include <smevents.h>
#include <smaction.h>
#include <lcp.h>
#include <timer.h>
#include <util.h>
#include <worker.h>
#define INCL_RASAUTHATTRIBUTES
#define INCL_MISC
#include <ppputil.h>

DWORD
EapGetCredentials(
        VOID *pWorkBuf,
        VOID *ppCredentials);


//**
//
// Call:        SetMsChapMppeKeys
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Set the MS-CHAP-MPPE-Keys with NDISWAN
//
DWORD
SetMsChapMppeKeys(
    IN  HPORT                   hPort, 
    IN  RAS_AUTH_ATTRIBUTE *    pAttribute,
    IN  BYTE *                  pChallenge,
    IN  BYTE *                  pResponse,
    IN  DWORD                   AP,
    IN  DWORD                   APData
)
{
    RAS_COMPRESSION_INFO rciSend;
    RAS_COMPRESSION_INFO rciReceive;
    DWORD                dwRetCode      = NO_ERROR;

    ASSERT( 8 == sizeof( rciSend.RCI_LMSessionKey ) );

    ASSERT( 16 == sizeof( rciSend.RCI_UserSessionKey ) );

    //
    // Length of key is 8 (LM key) + 16 (NT key)
    //

    if ( pAttribute->dwLength < ( 6 + 8 + 16 ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    ZeroMemory( &rciSend, sizeof( rciSend ) );
    rciSend.RCI_MacCompressionType = 0xFF;

    CopyMemory( rciSend.RCI_LMSessionKey,
                ((PBYTE)(pAttribute->Value))+6,
                8 );

    CopyMemory( rciSend.RCI_UserSessionKey,
                ((PBYTE)(pAttribute->Value))+6+8,
                16 );

    CopyMemory( rciSend.RCI_Challenge, pChallenge, 8 );

    CopyMemory( rciSend.RCI_NTResponse, pResponse, 24 );

    rciSend.RCI_Flags = CCP_SET_KEYS;

    ZeroMemory( &rciReceive, sizeof( rciReceive ) );

    rciReceive.RCI_MacCompressionType = 0xFF;

    CopyMemory( rciReceive.RCI_LMSessionKey,
                ((PBYTE)(pAttribute->Value))+6,
                8 );

    CopyMemory( rciReceive.RCI_UserSessionKey,
                ((PBYTE)(pAttribute->Value))+6+8,
                16 );

    CopyMemory( rciReceive.RCI_Challenge, pChallenge, 8 );

    CopyMemory( rciReceive.RCI_NTResponse, pResponse, 24 );

    rciReceive.RCI_Flags = CCP_SET_KEYS;

    rciSend.RCI_AuthType    = AUTH_USE_MSCHAPV2;
    rciReceive.RCI_AuthType = AUTH_USE_MSCHAPV2;

    if ( ( AP == PPP_CHAP_PROTOCOL ) &&
         ( APData == PPP_CHAP_DIGEST_MSEXT ))
    {
        rciSend.RCI_AuthType    = AUTH_USE_MSCHAPV1;
        rciReceive.RCI_AuthType = AUTH_USE_MSCHAPV1;
    }

    dwRetCode = RasCompressionSetInfo(hPort,&rciSend,&rciReceive);

    if ( dwRetCode != NO_ERROR )
    {
        PppLog( 1,"RasCompressionSetInfo failed, Error=%d", dwRetCode );
    }

    return( dwRetCode );
}

//**
//
// Call:        SetMsMppeSendRecvKeys
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Set the MS-MPPE-Send-Key and MS-MPPE-Recv-Key with NDISWAN
//
DWORD
SetMsMppeSendRecvKeys(
    IN  HPORT                   hPort, 
    IN  RAS_AUTH_ATTRIBUTE *    pAttributeSendKey,
    IN  RAS_AUTH_ATTRIBUTE *    pAttributeRecvKey
)
{
    RAS_COMPRESSION_INFO rciSend;
    RAS_COMPRESSION_INFO rciRecv;
    DWORD                dwRetCode      = NO_ERROR;

    //
    // 4: for Vendor-Id.
    //
    // The Microsoft Vendor-specific RADIUS Attributes draft says that 
    // Vendor-Length should be > 4.
    //

    if ( pAttributeSendKey->dwLength <= ( 4 + 4 ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    ZeroMemory( &rciSend, sizeof( rciSend ) );

    rciSend.RCI_MacCompressionType = 0xFF;

    rciSend.RCI_EapKeyLength = *(((BYTE*)(pAttributeSendKey->Value))+8);

    CopyMemory( rciSend.RCI_EapKey,
                ((BYTE*)(pAttributeSendKey->Value))+9,
                rciSend.RCI_EapKeyLength );

    rciSend.RCI_Flags = CCP_SET_KEYS;
    rciSend.RCI_AuthType = AUTH_USE_EAP;

    if ( pAttributeRecvKey->dwLength <= ( 4 + 4 ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    ZeroMemory( &rciRecv, sizeof( rciRecv ) );

    rciRecv.RCI_MacCompressionType = 0xFF;

    rciRecv.RCI_EapKeyLength = *(((BYTE*)(pAttributeRecvKey->Value))+8);

    CopyMemory( rciRecv.RCI_EapKey,
                ((BYTE*)(pAttributeRecvKey->Value))+9,
                rciRecv.RCI_EapKeyLength );

    rciRecv.RCI_Flags = CCP_SET_KEYS;
    rciRecv.RCI_AuthType = AUTH_USE_EAP;

    dwRetCode = RasCompressionSetInfo(hPort,&rciSend,&rciRecv);

    if ( dwRetCode != NO_ERROR )
    {
        PppLog( 1,"RasCompressionSetInfo failed, Error=%d", dwRetCode );
    }

    return( dwRetCode );
}

//**
//
// Call:        SetUserAuthorizedAttributes
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
SetUserAuthorizedAttributes(
    IN  PCB *                   pPcb, 
    IN  RAS_AUTH_ATTRIBUTE *    pUserAttributes,
    IN  BOOL                    fAuthenticator,
    IN  BYTE *                  pChallenge,
    IN  BYTE *                  pResponse
)
{
    RAS_AUTH_ATTRIBUTE *    pAttribute;
    RAS_AUTH_ATTRIBUTE *    pAttributeSendKey;
    RAS_AUTH_ATTRIBUTE *    pAttributeRecvKey;
    DWORD                   dwRetCode;
    DWORD                   dwEncryptionPolicy  = 0;
    DWORD                   dwEncryptionTypes   = 0;
    BOOL                    fL2tp               = FALSE;
    BOOL                    fPptp               = FALSE;

    CreateAccountingAttributes( pPcb );

    if ( RAS_DEVICE_TYPE( pPcb->dwDeviceType ) == RDT_Tunnel_L2tp )
    {
         fL2tp = TRUE;
    }

    if ( RAS_DEVICE_TYPE( pPcb->dwDeviceType ) == RDT_Tunnel_Pptp )
    {
         fPptp = TRUE;
    }

    //
    // Find out if we are to require encrypted data using MPPE
    //

    pAttribute = RasAuthAttributeGetVendorSpecific( 311, 7, pUserAttributes );

    if ( pAttribute != NULL )
    {
        dwEncryptionPolicy
                = WireToHostFormat32(((BYTE*)(pAttribute->Value))+6);

        pAttribute = RasAuthAttributeGetVendorSpecific( 311, 
                                                        8, 
                                                        pUserAttributes );
        if ( pAttribute != NULL )
        {
            dwEncryptionTypes
                    = WireToHostFormat32(((BYTE*)(pAttribute->Value))+6);

            if ( dwEncryptionPolicy == 2 )
            {
                if (!fL2tp)
                {
                    //
                    // Find out what types of encryption are to be required
                    //

                    if (   ( dwEncryptionTypes & 0x00000002 )
                        || ( dwEncryptionTypes & 0x00000008 ) )
                    {
                        pPcb->ConfigInfo.dwConfigMask
                                            |= PPPCFG_RequireEncryption;
                        PppLog( 1,"Encryption" );
                    }

                    if ( dwEncryptionTypes & 0x00000004 )
                    {
                        pPcb->ConfigInfo.dwConfigMask 
                                            |= PPPCFG_RequireStrongEncryption;
                        PppLog( 1,"Strong encryption" );
                    }

                    if ( dwEncryptionTypes == 0 )
                    {
                        pPcb->ConfigInfo.dwConfigMask
                                            |= PPPCFG_DisableEncryption;
                        PppLog( 1,"Encryption is not allowed" );
                    }
                }
            }
            else if ( dwEncryptionPolicy == 1 )
            {
                //
                // Find out what types of encryption are to be allowed
                //

                if ( !fL2tp && !dwEncryptionTypes )
                {
                    pPcb->ConfigInfo.dwConfigMask |= PPPCFG_DisableEncryption;
                    PppLog( 1,"Encryption is not allowed" );
                }
            }
        }
    }

    //
    // Set encryption keys if we got them, provided we have not already done so
    //

    if ( !( pPcb->fFlags & PCBFLAG_MPPE_KEYS_SET ) )
    {
        pAttribute = RasAuthAttributeGetVendorSpecific(
                                311, 12, pUserAttributes);

        if ( pAttribute != NULL ) 
        {
            //
            // Set the MS-CHAP-MPPE-Keys with NDISWAN
            //

            LCPCB * pLcpCb = (LCPCB*)(pPcb->LcpCb.pWorkBuf);
            DWORD   AP;
            DWORD   APData = 0;

            AP = ( fAuthenticator ? pLcpCb->Local.Work.AP :
                                    pLcpCb->Remote.Work.AP );

            if ( AP == PPP_CHAP_PROTOCOL )
            {
                APData = ( fAuthenticator ? *(pLcpCb->Local.Work.pAPData) :
                                            *(pLcpCb->Remote.Work.pAPData) );
            }

            dwRetCode = SetMsChapMppeKeys( pPcb->hPort,
                                           pAttribute,
                                           pChallenge,
                                           pResponse,
                                           AP,
                                           APData
                                         );

            if ( NO_ERROR != dwRetCode )
            {
                return( dwRetCode );
            }

            PppLog( 1,"MS-CHAP-MPPE-Keys set" );

            pPcb->fFlags |= PCBFLAG_MPPE_KEYS_SET;
        }

        pAttributeSendKey = RasAuthAttributeGetVendorSpecific( 311, 16,
                                pUserAttributes );
        pAttributeRecvKey = RasAuthAttributeGetVendorSpecific( 311, 17,
                                pUserAttributes );

        if (   ( pAttributeSendKey != NULL ) 
            && ( pAttributeRecvKey != NULL ) )
        {
            //
            // Set the MS-MPPE-Send-Key and MS-MPPE-Recv-Key with NDISWAN
            //

            dwRetCode = SetMsMppeSendRecvKeys( pPcb->hPort,
                                               pAttributeSendKey,
                                               pAttributeRecvKey
                                             );

            if ( NO_ERROR != dwRetCode )
            {
                return( dwRetCode );
            }

            PppLog( 1,"MPPE-Send/Recv-Keys set" );

            pPcb->fFlags |= PCBFLAG_MPPE_KEYS_SET;
        }
    }

    //
    // Check if L2tp is being used
    //

    if ( fL2tp )
    {
        DWORD   dwMask          = 0;
        DWORD   dwSize          = sizeof(DWORD);
        DWORD   dwConfigMask;

        dwRetCode = RasGetPortUserData( pPcb->hPort, PORT_IPSEC_INFO_INDEX,
                        (BYTE*) &dwMask, &dwSize );

        if ( NO_ERROR != dwRetCode )
        {
            PppLog( 1, "RasGetPortUserData failed: 0x%x", dwRetCode );

            dwRetCode = NO_ERROR;
        }

        PppLog( 1, "Checking encryption. Policy=0x%x,Types=0x%x,Mask=0x%x",
            dwEncryptionPolicy, dwEncryptionTypes, dwMask );

        if ( dwMask == RASMAN_IPSEC_ESP_DES )
        {
            pPcb->pBcb->fFlags |= BCBFLAG_BASIC_ENCRYPTION;
        }
        else if ( dwMask == RASMAN_IPSEC_ESP_3_DES )
        {
            pPcb->pBcb->fFlags |= BCBFLAG_STRONGEST_ENCRYPTION;
        }

        if ( !fAuthenticator )
        {
            //
            // If the user requires maximum encryption (3DES), but we 
            // negotiated weaker encryption (56-bit DES), then return an error.
            //

            dwConfigMask = pPcb->ConfigInfo.dwConfigMask;

            if (    ( dwConfigMask & PPPCFG_RequireStrongEncryption )
                && !( dwConfigMask & PPPCFG_RequireEncryption )
                && !( dwConfigMask & PPPCFG_DisableEncryption )
                &&  ( dwMask != RASMAN_IPSEC_ESP_3_DES ) )
            {
                return( ERROR_NO_REMOTE_ENCRYPTION );
            }

            //
            // We are done with the PPPCFG_Require*Encryption flags. Let us now
            // turn them off because we don't care what kind of encryption CCP 
            // negotiates.
            //

            pPcb->ConfigInfo.dwConfigMask &= ~PPPCFG_RequireStrongEncryption;
            pPcb->ConfigInfo.dwConfigMask &= ~PPPCFG_RequireEncryption;
        }
        else if ( dwEncryptionPolicy != 0 )
        {
            BOOL    fPolicyError    = FALSE;

            //
            // There is an encryption policy
            //

            switch ( dwMask )
            {
            case 0:

                if (   ( dwEncryptionPolicy ==  2 )
                    && ( dwEncryptionTypes != 0 ) )
                {
                    fPolicyError = TRUE;
                    break;
                }

                break;

            case RASMAN_IPSEC_ESP_DES:

                if (   !( dwEncryptionTypes & 0x00000002 )
                    && !( dwEncryptionTypes & 0x00000008 ) )
                {
                    fPolicyError = TRUE;
                    break;
                }

                break;

            case RASMAN_IPSEC_ESP_3_DES:

                if (!( dwEncryptionTypes & 0x00000004 ) )
                {
                    fPolicyError = TRUE;
                    break;
                }

                break;
            }

            if ( fPolicyError )
            {
                //
                // We need to send an Accounting Stop if RADIUS sends an Access
                // Accept but we still drop the line.
                //

                pPcb->fFlags |= PCBFLAG_SERVICE_UNAVAILABLE;

                return( ERROR_NO_REMOTE_ENCRYPTION );
            }
        }
    }

    //
    // If we require encryption make sure we have the keys and that CCP is 
    // loaded.
    //

    if ( pPcb->ConfigInfo.dwConfigMask & ( PPPCFG_RequireEncryption        |
                                           PPPCFG_RequireStrongEncryption ) )
    {
        if (   !( pPcb->fFlags & PCBFLAG_MPPE_KEYS_SET )
            || ( GetCpIndexFromProtocol( PPP_CCP_PROTOCOL ) == -1 ) )
        {
            //
            // We need to send an Accounting Stop if RADIUS sends an Access
            // Accept but we still drop the line.
            //

            pPcb->fFlags |= PCBFLAG_SERVICE_UNAVAILABLE;

            return( ERROR_NO_LOCAL_ENCRYPTION );
        }
    }
    
    //
    // If we are not the authenticator then there is nothing more to set
    //

    if ( !fAuthenticator )
    {
        return( NO_ERROR );
    }
    
    //
    // Check framed protocol attribute. It must be PPP.
    // 

    pAttribute = RasAuthAttributeGet( raatFramedProtocol, pUserAttributes );

    if ( pAttribute != NULL )
    {
        if ( PtrToUlong(pAttribute->Value) != 1 )
        {
            //
            // We need to send an Accounting Stop if RADIUS sends an Access
            // Accept but we still drop the line.
            //

            pPcb->fFlags |= PCBFLAG_SERVICE_UNAVAILABLE;

            return( ERROR_UNKNOWN_FRAMED_PROTOCOL );
        }
    }
    
    //
    // Check tunnel type attribute. It must be correct.
    // 

    pAttribute = RasAuthAttributeGet( raatTunnelType, pUserAttributes );

    if ( pAttribute != NULL )
    {
        DWORD   dwTunnelType    = PtrToUlong(pAttribute->Value);

        if (   ( fL2tp && ( dwTunnelType != 3 ) )
            || ( fPptp && ( dwTunnelType != 1 ) ) )
        {
            //
            // We need to send an Accounting Stop if RADIUS sends an Access
            // Accept but we still drop the line.
            //

            pPcb->fFlags |= PCBFLAG_SERVICE_UNAVAILABLE;

            return( ERROR_WRONG_TUNNEL_TYPE );
        }
    }

    //
    // Get the logon domain attribute
    //

    pAttribute = RasAuthAttributeGetVendorSpecific( 311, 10, pUserAttributes );

    if ( pAttribute != NULL )
    {
        DWORD cbDomain = sizeof( pPcb->pBcb->szRemoteDomain ) - 1;

        if ( ( pAttribute->dwLength - 7 ) < cbDomain )
        {
            cbDomain = pAttribute->dwLength - 7;
        }
    
        ZeroMemory( pPcb->pBcb->szRemoteDomain,   
                    sizeof( pPcb->pBcb->szRemoteDomain ) );

        CopyMemory( pPcb->pBcb->szRemoteDomain, 
                    (LPSTR)((PBYTE)(pAttribute->Value)+7),
                    cbDomain );

        PppLog( 2, "Auth Attribute Domain = %s", pPcb->pBcb->szRemoteDomain);
    }

    //
    // Setup callback information, default is no callback 
    //

    pPcb->fCallbackPrivilege  = RASPRIV_NoCallback;
    pPcb->szCallbackNumber[0] = (CHAR)NULL;

    pAttribute = RasAuthAttributeGet( raatServiceType, pUserAttributes );

    if ( pAttribute != NULL ) 
    {
        if ( PtrToUlong(pAttribute->Value) == 4 )
        {
            //
            // If service type is callback framed
            //
        
            pAttribute=RasAuthAttributeGet(raatCallbackNumber,pUserAttributes);

            if ( ( pAttribute == NULL ) || ( pAttribute->dwLength == 0 ) )
            {
                pPcb->fCallbackPrivilege = RASPRIV_NoCallback |
                                           RASPRIV_CallerSetCallback;

                pPcb->szCallbackNumber[0] = (CHAR)NULL;

                PppLog(2,"Auth Attribute Caller Specifiable callback");
            }
            else
            {
                pPcb->fCallbackPrivilege = RASPRIV_AdminSetCallback;

                ZeroMemory(pPcb->szCallbackNumber, 
                           sizeof(pPcb->szCallbackNumber));

                CopyMemory( pPcb->szCallbackNumber, 
                            pAttribute->Value,
                            pAttribute->dwLength );

                PppLog( 2, "Auth Attribute Forced callback to %s",
                            pPcb->szCallbackNumber );

                //
                // Don't accept BAP Call-Requests. Otherwise, when the client 
                // calls us, we will drop the line and callback. The first call 
                // would be a waste.
                //

                pPcb->pBcb->fFlags &= ~BCBFLAG_CAN_ACCEPT_CALLS;
            }
        }
        else if ( PtrToUlong(pAttribute->Value) != 2 )
        {
            PppLog( 2, "Service Type %d is not of type Framed",
                        PtrToUlong(pAttribute->Value) );

            //
            // We need to send an Accounting Stop if RADIUS sends an Access
            // Accept but we still drop the line.
            //

            pPcb->fFlags |= PCBFLAG_SERVICE_UNAVAILABLE;

            return( ERROR_UNKNOWN_SERVICE_TYPE );
        }
    }

    if (   ( pPcb->fCallbackPrivilege & RASPRIV_CallerSetCallback )
        || ( pPcb->fCallbackPrivilege & RASPRIV_AdminSetCallback ) )
    {
        pPcb->pBcb->fFlags |= BCBFLAG_CAN_CALL;
    }

    //
    // Use idle-timeout value if we got one.
    //

    pAttribute = RasAuthAttributeGet( raatIdleTimeout, pUserAttributes );

    if ( pAttribute != NULL )
    {
        pPcb->dwAutoDisconnectTime = PtrToUlong(pAttribute->Value); 

    }
    else
    {
        pPcb->dwAutoDisconnectTime = PppConfigInfo.dwDefaulIdleTimeout;
    }

    PppLog( 2, "Auth Attribute Idle Timeout Seconds = %d",  
                pPcb->dwAutoDisconnectTime );

    //
    // Use MaxChannels value if we got one.
    //

    pAttribute = RasAuthAttributeGet( raatPortLimit, pUserAttributes );

    if ( pAttribute != NULL )
    {
        if ( PtrToUlong(pAttribute->Value) > 0 )
        {
            pPcb->pBcb->dwMaxLinksAllowed = PtrToUlong(pAttribute->Value);
        }
        else
        {
            pPcb->pBcb->dwMaxLinksAllowed =  PppConfigInfo.dwDefaultPortLimit;
        }
    }
    else
    {
        pPcb->pBcb->dwMaxLinksAllowed =  PppConfigInfo.dwDefaultPortLimit;
    }

    PppLog( 2, "AuthAttribute MaxChannelsAllowed = %d",
                pPcb->pBcb->dwMaxLinksAllowed );

    //
    // See if BAP is required
    //

    pAttribute = RasAuthAttributeGetVendorSpecific( 311, 13, pUserAttributes );

    if ( pAttribute != NULL )
    {
        if ( WireToHostFormat32( (PBYTE)(pAttribute->Value)+6 ) == 2 )
        {
            PppLog( 2, "AuthAttribute BAPRequired" ); 

            pPcb->pBcb->fFlags |= BCBFLAG_BAP_REQUIRED;
        }
    }

    //
    // For the server never send a request bring up the line
    //

    pPcb->pBcb->BapParams.dwDialExtraPercent       = 100;
    pPcb->pBcb->BapParams.dwDialExtraSampleSeconds = 100;

    pAttribute = RasAuthAttributeGetVendorSpecific( 311, 14, pUserAttributes );

    if ( ( pAttribute != NULL ) && ( pAttribute->dwLength == 10 ) )
    {
        pPcb->pBcb->BapParams.dwHangUpExtraPercent = 
              WireToHostFormat32( ((BYTE *)(pAttribute->Value))+6 );

        PppLog( 2, "AuthAttribute BAPLineDownLimit = %d",
                    pPcb->pBcb->BapParams.dwHangUpExtraPercent ); 
    }
    else
    {
        pPcb->pBcb->BapParams.dwHangUpExtraPercent =    
                                            PppConfigInfo.dwHangupExtraPercent;
    }

    pAttribute = RasAuthAttributeGetVendorSpecific( 311, 15, pUserAttributes );

    if ( ( pAttribute != NULL ) && ( pAttribute->dwLength == 10 ) )
    {
        pPcb->pBcb->BapParams.dwHangUpExtraSampleSeconds = 
              WireToHostFormat32( ((BYTE *)(pAttribute->Value))+6 );

        PppLog( 2, "AuthAttribute BAPLineDownTime = %d",
                    pPcb->pBcb->BapParams.dwHangUpExtraSampleSeconds );
    }
    else
    {
        pPcb->pBcb->BapParams.dwHangUpExtraSampleSeconds = 
                                    PppConfigInfo.dwHangUpExtraSampleSeconds;
    }

    return( NO_ERROR );
}

//**
//
// Call:        RasAuthenticateUserWorker
//
// Returns:     None.
//
// Description:
//
VOID
RasAuthenticateUserWorker(
    PVOID pContext
)
{
    PCB_WORK_ITEM * pWorkItem = (PCB_WORK_ITEM *)pContext;

    pWorkItem->PppMsg.AuthInfo.dwError = 
                    (*PppConfigInfo.RasAuthProviderAuthenticateUser)( 
                                pWorkItem->PppMsg.AuthInfo.pInAttributes,
                                &(pWorkItem->PppMsg.AuthInfo.pOutAttributes),
                                &(pWorkItem->PppMsg.AuthInfo.dwResultCode) );

    RasAuthAttributeDestroy( pWorkItem->PppMsg.AuthInfo.pInAttributes );

    InsertWorkItemInQ( pWorkItem );
}

//**
//
// Call:        RasAuthenticateClient
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
RasAuthenticateClient(
    IN  HPORT                   hPort,
    IN  RAS_AUTH_ATTRIBUTE *    pInAttributes
)
{
    PCB *               pPcb        = GetPCBPointerFromhPort( hPort );
    LCPCB *             pLcpCb      = NULL;
    PCB_WORK_ITEM *     pWorkItem   = NULL;
    DWORD               dwRetCode   = NO_ERROR;
    
    if ( pPcb == NULL )
    {
        RasAuthAttributeDestroy( pInAttributes );

        return( ERROR_INVALID_PORT_HANDLE );
    }

    pLcpCb = (LCPCB*)(pPcb->LcpCb.pWorkBuf);

    pWorkItem = (PCB_WORK_ITEM *)LOCAL_ALLOC( LPTR, sizeof(PCB_WORK_ITEM) );

    if ( pWorkItem == (PCB_WORK_ITEM *)NULL )
    {
        LogPPPEvent( ROUTERLOG_NOT_ENOUGH_MEMORY, GetLastError() );

        RasAuthAttributeDestroy( pInAttributes );

        return( GetLastError() );
    }

    pWorkItem->hPort                            = hPort;
    pWorkItem->dwPortId                         = pPcb->dwPortId;
    pWorkItem->Protocol                         = pLcpCb->Local.Work.AP;
    pWorkItem->PppMsg.AuthInfo.pInAttributes    = pInAttributes;
    pWorkItem->PppMsg.AuthInfo.dwId             = GetUId( pPcb, LCP_INDEX );
    pWorkItem->Process                          = ProcessAuthInfo;

    pPcb->dwOutstandingAuthRequestId = pWorkItem->PppMsg.AuthInfo.dwId;
    
    dwRetCode = RtlNtStatusToDosError( RtlQueueWorkItem( RasAuthenticateUserWorker, 
                                                         pWorkItem, 
                                                         WT_EXECUTEDEFAULT ) );
    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pInAttributes );

        LOCAL_FREE( pWorkItem );
    }

    return( dwRetCode );
}

//**
//
// Call:        RemoteError
//
// Returns:     DWORD - Remote version of this error
//
// Description: Called by a client authenticating the server.
//
DWORD
RemoteError( 
    IN DWORD dwError 
)
{
    switch( dwError )
    {
    case ERROR_NO_DIALIN_PERMISSION:
        return( ERROR_REMOTE_NO_DIALIN_PERMISSION );

    case ERROR_PASSWD_EXPIRED:
        return( ERROR_REMOTE_PASSWD_EXPIRED );

    case ERROR_ACCT_DISABLED:
        return( ERROR_REMOTE_ACCT_DISABLED );

    case ERROR_RESTRICTED_LOGON_HOURS:
        return( ERROR_REMOTE_RESTRICTED_LOGON_HOURS );

    case ERROR_AUTHENTICATION_FAILURE:
        return( ERROR_REMOTE_AUTHENTICATION_FAILURE );

    case ERROR_REQ_NOT_ACCEP:
        return( ERROR_LICENSE_QUOTA_EXCEEDED );

    default:
        return( dwError );
    }
}

//**
//
// Call:        ApIsAuthenticatorPacket
//
// Returns:     TRUE  - Packet belongs to authenticator
//              FALSE - Otherwise
//
// Description: Called to figure out whether to send the auth packet to the
//              authenticator or authenticatee.
//
BOOL
ApIsAuthenticatorPacket(
    IN DWORD         CpIndex,
    IN BYTE          bConfigCode
)
{
    switch( CpTable[CpIndex].CpInfo.Protocol )
    {
    case PPP_PAP_PROTOCOL:
        
        switch( bConfigCode )
        {
        case 1:
            return( TRUE );
        default:
            return( FALSE );
        }
        break;

    case PPP_CHAP_PROTOCOL:

        switch( bConfigCode )
        {
        case 2:
        case 5:
        case 6:
        case 7:
            return( TRUE );
        default:
            return( FALSE );
        }
        break;

    case PPP_SPAP_NEW_PROTOCOL:

        switch( bConfigCode )
        {
        case 1:
        case 6:
            return( TRUE );
        default:
            return( FALSE );
        }

        break;

    case PPP_EAP_PROTOCOL:

        switch( bConfigCode )
        {
        case 2:
            return( TRUE );
        default:
            return( FALSE );
        }

        break;

    default:
        PPP_ASSERT( FALSE );
    }

    PPP_ASSERT( FALSE );

    return( FALSE );
}

//**
//
// Call:        ApStart
//
// Returns:     TRUE  - Success
//              FALSE - Otherwise
//
// Description: Called to initiatialze the authetication protocol and to
//              initiate to authentication.
//
BOOL
ApStart(
    IN PCB * pPcb,
    IN DWORD CpIndex,
    IN BOOL  fAuthenticator
)
{
    DWORD           dwRetCode;
    PPPAP_INPUT     PppApInput;
    LCPCB *         pLcpCb      = (LCPCB*)(pPcb->LcpCb.pWorkBuf);
    CPCB *          pCpCb       = ( fAuthenticator ) 
                                    ? &(pPcb->AuthenticatorCb)
                                    : &(pPcb->AuthenticateeCb);

    pCpCb->fConfigurable = TRUE;
    pCpCb->State         = FSM_INITIAL;
    pCpCb->Protocol      = CpTable[CpIndex].CpInfo.Protocol;
    pCpCb->LastId        = (DWORD)-1;
    InitRestartCounters( pPcb, pCpCb );

    ZeroMemory( &PppApInput, sizeof( PppApInput ) );

    PppApInput.hPort                 = pPcb->hPort;
    PppApInput.fServer               = fAuthenticator;
    PppApInput.fRouter               = ( ROUTER_IF_TYPE_FULL_ROUTER == 
                                         pPcb->pBcb->InterfaceInfo.IfType );
    PppApInput.Luid                  = pPcb->Luid;
    PppApInput.dwEapTypeToBeUsed     = pPcb->dwEapTypeToBeUsed;
    PppApInput.hTokenImpersonateUser = pPcb->pBcb->hTokenImpersonateUser;
    PppApInput.pCustomAuthConnData   = pPcb->pBcb->pCustomAuthConnData;
    PppApInput.pCustomAuthUserData   = pPcb->pBcb->pCustomAuthUserData;
    PppApInput.EapUIData             = pPcb->pBcb->EapUIData;
    PppApInput.fLogon                = ( pPcb->pBcb->fFlags & 
                                         BCBFLAG_LOGON_USER_DATA );
    PppApInput.fNonInteractive       = ( pPcb->fFlags & 
                                         PCBFLAG_NON_INTERACTIVE );
    PppApInput.fConfigInfo           = pPcb->ConfigInfo.dwConfigMask;

    if ( fAuthenticator )
    {
        PppApInput.dwRetries                = pPcb->dwAuthRetries;
        PppApInput.pAPData                  = pLcpCb->Local.Work.pAPData;
        PppApInput.APDataSize               = pLcpCb->Local.Work.APDataSize;
        PppApInput.pUserAttributes          = pPcb->pUserAttributes;

        ZeroMemory( &pPcb->pBcb->szRemoteUserName, 
                    sizeof( pPcb->pBcb->szRemoteUserName ) );
    }
    else
    {
        //
        // If we are a server and we do not know who is dialing in and therefore
        // do not have credentials to use for being authenticated by the 
        // remote peer, then we wait till we do.
        //

        if ( pPcb->fFlags & PCBFLAG_IS_SERVER )
        {
            if ( strlen( pPcb->pBcb->szRemoteUserName ) == 0 )
            {
                PppLog(1,"Remote user not identifiable at this time, waiting");

                return( FALSE );
            }
        
            //
            // Ok we know who is dialed in so get credentials to used for this
            // connection.      
            //

            dwRetCode =  GetCredentialsFromInterface( pPcb );

            if ( dwRetCode != NO_ERROR )
            {
                //
                // We do not have credentials to use for this user so we
                // renegotiate LCP and do not accept the authentication option
                //

                PppLog( 1, "No credentials available to use for user=%s",
                           pPcb->pBcb->szRemoteUserName );

                FsmDown( pPcb, LCP_INDEX );

                pLcpCb->Remote.WillNegotiate &= (~LCP_N_AUTHENT); 

                FsmUp( pPcb, LCP_INDEX );

                return( FALSE );
            }
        }

        //
        // Decode the password
        //

        DecodePw( pPcb->pBcb->chSeed, pPcb->pBcb->szPassword );
        DecodePw( pPcb->pBcb->chSeed, pPcb->pBcb->szOldPassword );

        PppApInput.pszUserName          = pPcb->pBcb->szLocalUserName;
        PppApInput.pszPassword          = pPcb->pBcb->szPassword;
        PppApInput.pszDomain            = pPcb->pBcb->szLocalDomain;
        PppApInput.pszOldPassword       = pPcb->pBcb->szOldPassword;
        PppApInput.pAPData              = pLcpCb->Remote.Work.pAPData;
        PppApInput.APDataSize           = pLcpCb->Remote.Work.APDataSize;
        PppApInput.dwInitialPacketId    = (DWORD)GetUId( pPcb, CpIndex );

        if ( CpTable[CpIndex].CpInfo.Protocol == PPP_EAP_PROTOCOL )
        {
            PppApInput.fPortWillBeBundled = WillPortBeBundled( pPcb );
            PppApInput.fThisIsACallback =
                        ( pPcb->fFlags & PCBFLAG_THIS_IS_A_CALLBACK );
        }
    }

    dwRetCode = (CpTable[CpIndex].CpInfo.RasCpBegin)(&(pCpCb->pWorkBuf),
                                                     &PppApInput );

    if ( !fAuthenticator )
    {
        //
        // Encode the password back
        //

        EncodePw( pPcb->pBcb->chSeed, pPcb->pBcb->szPassword );
        EncodePw( pPcb->pBcb->chSeed, pPcb->pBcb->szOldPassword );
    }

    if ( dwRetCode != NO_ERROR )
    {
        pPcb->LcpCb.dwError = dwRetCode;

        NotifyCallerOfFailure( pPcb, dwRetCode );

        return( FALSE );
    }
    PppLog(1,"Calling APWork in APStart");
    ApWork( pPcb, CpIndex, NULL, NULL, fAuthenticator );

    return( TRUE );
}

//**
//
// Call:        ApStop
//
// Returns:     none
//
// Description: Called to stop the authentication machine.
//
VOID
ApStop(
    IN PCB *    pPcb,
    IN DWORD    CpIndex,
    IN BOOL     fAuthenticator
)
{
    CPCB * pCpCb = ( fAuthenticator )  
                        ? &(pPcb->AuthenticatorCb) 
                        : &(pPcb->AuthenticateeCb);

    if ( pCpCb->pWorkBuf == NULL )
    {
        return;
    }

    pCpCb->Protocol      = 0;
    pCpCb->fConfigurable = FALSE;
       

    if ( pCpCb->LastId != (DWORD)-1 )
    {
        RemoveFromTimerQ( 
                      pPcb->dwPortId,
                      pCpCb->LastId,
                      CpTable[CpIndex].CpInfo.Protocol,
                      fAuthenticator,
                      TIMER_EVENT_TIMEOUT );
    }

    (CpTable[CpIndex].CpInfo.RasCpEnd)( pCpCb->pWorkBuf );

    pCpCb->pWorkBuf = NULL;
}

//**
//
// Call:            ApWork
//
// Returns:         none
//
// Description: Called when and authentication packet was received or
//              a timeout occurred or to initiate authentication.
//
VOID
ApWork(
    IN PCB *         pPcb,
    IN DWORD         CpIndex,
    IN PPP_CONFIG *  pRecvConfig,
    IN PPPAP_INPUT * pApInput,
    IN BOOL          fAuthenticator
)
{
    DWORD           dwRetCode;
    DWORD           dwLength;
    PPPAP_RESULT    ApResult;
    PPP_CONFIG *    pSendConfig = (PPP_CONFIG*)(pPcb->pSendBuf->Information);
    LCPCB *         pLcpCb      =  (LCPCB*)(pPcb->LcpCb.pWorkBuf);
    CPCB *          pCpCb       = ( fAuthenticator )  
                                    ? &(pPcb->AuthenticatorCb) 
                                    : &(pPcb->AuthenticateeCb);

    //
    // If the protocol has not been started yet, call ApStart
    //

    if ( pCpCb->pWorkBuf == NULL )
    {
        if ( !ApStart( pPcb, CpIndex, fAuthenticator ) )
        {
            return;
        }
    }

    ZeroMemory( &ApResult, sizeof(ApResult) );

    dwRetCode = (CpTable[CpIndex].CpInfo.RasApMakeMessage)(
                                pCpCb->pWorkBuf,
                                pRecvConfig,
                                pSendConfig,
                                ((pLcpCb->Remote.Work.MRU > LCP_DEFAULT_MRU)
                                ? LCP_DEFAULT_MRU : pLcpCb->Remote.Work.MRU)
                                - PPP_PACKET_HDR_LEN,
                                &ApResult,
                                pApInput );

    if ( NULL != ApResult.szReplyMessage )
    {
        LocalFree( pPcb->pBcb->szReplyMessage );

        pPcb->pBcb->szReplyMessage = ApResult.szReplyMessage;
    }

    if ( dwRetCode != NO_ERROR )
    {
        switch( dwRetCode )
        {
        case ERROR_PPP_INVALID_PACKET:

            PppLog( 1, "Silently discarding invalid auth packet on port %d",
                    pPcb->hPort );
            break;

        default:

            pPcb->LcpCb.dwError = dwRetCode;

            PppLog( 1, "Auth Protocol %x returned error %d",
                        CpTable[CpIndex].CpInfo.Protocol, dwRetCode );

            if ( fAuthenticator )
            {
                //
                // Get the username from the CP if it supplies one.     
                //

                if ( strlen( ApResult.szUserName ) > 0 )
                {
                    strcpy( pPcb->pBcb->szRemoteUserName, ApResult.szUserName );
                }
            }

            NotifyCallerOfFailure( pPcb, dwRetCode );

            break;
        }

        return;
    }

    //
    // Check to see if we have to save any user data
    //

    if ( ( !fAuthenticator ) && ( ApResult.fSaveUserData ) )
    {
        dwRetCode = RasSetEapUserDataA(
                        pPcb->pBcb->hTokenImpersonateUser,
                        pPcb->pBcb->szPhonebookPath,
                        pPcb->pBcb->szEntryName,
                        ApResult.pUserData,
                        ApResult.dwSizeOfUserData );

        PppLog( 2, "Saved EAP data for user, dwRetCode = %d", dwRetCode );
    }

    //
    // Check to see if we have to save any connection data
    //

    if ( ( !fAuthenticator ) && ( ApResult.fSaveConnectionData ) &&
         ( 0 != ApResult.SetCustomAuthData.dwSizeOfConnectionData ) )
    {
        NotifyCaller( pPcb, PPPMSG_SetCustomAuthData,
                      &(ApResult.SetCustomAuthData) );

        PppLog( 2, "Saved EAP data for connection" );
    }

    switch( ApResult.Action )
    {

    case APA_Send:
    case APA_SendWithTimeout:
    case APA_SendWithTimeout2:
    case APA_SendAndDone:

        HostToWireFormat16( (WORD)CpTable[CpIndex].CpInfo.Protocol,
                                        (PBYTE)(pPcb->pSendBuf->Protocol) );

        dwLength = WireToHostFormat16( pSendConfig->Length );

        LogPPPPacket(FALSE,pPcb,pPcb->pSendBuf,dwLength+PPP_PACKET_HDR_LEN);

        if ( ( dwRetCode = PortSendOrDisconnect( pPcb,
                                    (dwLength + PPP_PACKET_HDR_LEN)))
                                                != NO_ERROR )
        {
            return;
        }

        pCpCb->LastId = (DWORD)-1;

        if ( ( ApResult.Action == APA_SendWithTimeout ) ||
             ( ApResult.Action == APA_SendWithTimeout2 ) )
        {
            pCpCb->LastId = ApResult.bIdExpected;

            InsertInTimerQ( pPcb->dwPortId,
                            pPcb->hPort,
                            pCpCb->LastId,
                            CpTable[CpIndex].CpInfo.Protocol,
                            fAuthenticator,
                            TIMER_EVENT_TIMEOUT,
                            pPcb->RestartTimer );

            //
            // For SendWithTimeout2 we increment the ConfigRetryCount. This
            // means send with infinite retry count
            //

            if ( ApResult.Action == APA_SendWithTimeout2 )
            {
                (pCpCb->ConfigRetryCount)++;
            }
        }

        if ( ApResult.Action != APA_SendAndDone )
        {
            break;
        }

    case APA_Done:

        switch( ApResult.dwError )
        {
        case NO_ERROR:

            //
            // If authentication was successful
            //

            if ( CpTable[CpIndex].CpInfo.Protocol == PPP_EAP_PROTOCOL )
            {
                if ( fAuthenticator )
                {
                    pPcb->dwServerEapTypeId = ApResult.dwEapTypeId;
                }
                else
                {
                    VOID *pCredentials = NULL;

                    pPcb->dwClientEapTypeId = ApResult.dwEapTypeId;

                    //
                    // Call the eap dll to collect credentials here
                    // so that they can be passed to rasman to be
                    // saved in the cred manager.
                    //
                    if(     (NO_ERROR == EapGetCredentials(pCpCb->pWorkBuf,
                                                          &pCredentials))
                        &&  (NULL != pCredentials))
                    {
                        //
                        // Below call is not fatal.
                        //
                        (void) RasSetPortUserData(
                                    pPcb->hPort,
                                    PORT_CREDENTIALS_INDEX,
                                    pCredentials,
                                    sizeof(RASMAN_CREDENTIALS));

                        ZeroMemory(pCredentials,
                                        sizeof(RASMAN_CREDENTIALS));
                        LocalFree(pCredentials);
                    }
                }
            }

            if ( fAuthenticator )
            {
                RAS_AUTH_ATTRIBUTE * pAttribute;
                RAS_AUTH_ATTRIBUTE * pUserAttributes = NULL;

                if ( NULL != pPcb->pBcb->szRemoteIdentity )
                {
                    LOCAL_FREE( pPcb->pBcb->szRemoteIdentity );

                    pPcb->pBcb->szRemoteIdentity = NULL;
                }

                pPcb->pBcb->szRemoteIdentity =
                    LOCAL_ALLOC( LPTR, strlen( ApResult.szUserName ) + 1 );

                if ( NULL == pPcb->pBcb->szRemoteIdentity )
                {
                    dwRetCode = GetLastError();

                    pPcb->LcpCb.dwError = dwRetCode;

                    NotifyCallerOfFailure( pPcb, dwRetCode );

                    return;
                }

                strcpy( pPcb->pBcb->szRemoteIdentity, ApResult.szUserName );

                dwRetCode = ExtractUsernameAndDomain( 
                                          ApResult.szUserName,
                                          pPcb->pBcb->szRemoteUserName, 
                                          NULL );

                if ( dwRetCode != NO_ERROR )
                {
                    pPcb->LcpCb.dwError = dwRetCode;

                    NotifyCallerOfFailure( pPcb, dwRetCode );

                    return;
                }

                if ( 0 == pPcb->pBcb->szLocalUserName[0] )
                {
                    if ( NO_ERROR != GetCredentialsFromInterface( pPcb ) )
                    {
                        pPcb->pBcb->szLocalUserName[0] = 
                        pPcb->pBcb->szPassword[0]      = 
                        pPcb->pBcb->szLocalDomain[0]   = 0;
                    }
                }

                if ( ApResult.pUserAttributes != NULL )
                {
                    pPcb->pAuthProtocolAttributes = ApResult.pUserAttributes;
                    
                    pUserAttributes = ApResult.pUserAttributes;
                }
                else
                {
                    pUserAttributes = pPcb->pAuthenticatorAttributes;
                }

                //
                // Set all the user connection parameters authorized by the
                // back-end authenticator
                //

                dwRetCode = SetUserAuthorizedAttributes(
                                                pPcb, 
                                                pUserAttributes,
                                                fAuthenticator,
                                                (BYTE*)&(ApResult.abChallenge),
                                                (BYTE*)&(ApResult.abResponse));

                if ( dwRetCode != NO_ERROR )
                {
                    pPcb->LcpCb.dwError = dwRetCode;

                    NotifyCallerOfFailure( pPcb, dwRetCode );

                    return;
                }

                //
                // If we are a server and we negotiated to be authenticated 
                // by the remote peer we can do so now that we know who 
                // is dialed in.
                //

                if ( ( pLcpCb->Remote.Work.AP != 0 )            &&
                     ( pPcb->AuthenticateeCb.pWorkBuf == NULL ) &&
                     ( pPcb->AuthenticateeCb.fConfigurable )    &&
                     ( pPcb->fFlags & PCBFLAG_IS_SERVER  ) )
                {
                    CpIndex = GetCpIndexFromProtocol( pLcpCb->Remote.Work.AP );

                    PPP_ASSERT(( CpIndex != (DWORD)-1 ));

                    if ( !ApStart( pPcb, CpIndex, FALSE ) )
                    {
                        return;
                    }
                }
            }
            else
            {
                //
                // Get the username from the CP if it supplies one.     
                //

                if (   ( strlen( pPcb->pBcb->szLocalUserName ) == 0 )
                    && ( strlen( ApResult.szUserName ) > 0 ) )
                {
                    strcpy( pPcb->pBcb->szLocalUserName, ApResult.szUserName );
                }

                dwRetCode = SetUserAuthorizedAttributes(
                                            pPcb, 
                                            ApResult.pUserAttributes,
                                            fAuthenticator,
                                            (BYTE*)&(ApResult.abChallenge),
                                            (BYTE*)&(ApResult.abResponse));

                if ( dwRetCode != NO_ERROR )
                {
                    pPcb->LcpCb.dwError = dwRetCode;

                    NotifyCallerOfFailure( pPcb, dwRetCode );

                    return;
                }

                pPcb->pAuthProtocolAttributes = ApResult.pUserAttributes;
            }

            pCpCb->State = FSM_OPENED;

            FsmThisLayerUp( pPcb, CpIndex );

            break;

        case ERROR_PASSWD_EXPIRED:

            if ( pPcb->fFlags & PCBFLAG_IS_SERVER )
            {
                //
                // We are a server and hence in non-interactive mode and
                // hence we cannot do this.
                //

                pPcb->LcpCb.dwError = ApResult.dwError;

                NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );

                return;
            }
            else
            {
                //
                // Password has expired so the user has to change his/her
                // password.
                //

                NotifyCaller( pPcb, PPPMSG_ChangePwRequest, NULL );
            }
                
            break;

        default:

            //
            // If we can retry with a new password then tell the client to
            // get a new one from the user.
            //

            if ( (!fAuthenticator) && ( ApResult.fRetry ))
            {
                if ( pPcb->fFlags & PCBFLAG_IS_SERVER )
                {
                    //
                    // We are a server and hence in non-interactive mode and
                    // hence we cannot do this.
                    //

                    pPcb->LcpCb.dwError = ApResult.dwError;

                    NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );

                    return;
                }
                else
                {
                    PppLog( 2, "Sending auth retry message to UI" );

                    NotifyCaller( pPcb, PPPMSG_AuthRetry, &(ApResult.dwError) );
                }
            }
            else
            {
                PppLog( 1, "Auth Protocol %x terminated with error %d",
                           CpTable[CpIndex].CpInfo.Protocol, ApResult.dwError );

                if ( ApResult.szUserName[0] != (CHAR)NULL )
                {
                    strcpy( pPcb->pBcb->szRemoteUserName, ApResult.szUserName );
                }

                if ( !( pPcb->fFlags & PCBFLAG_IS_SERVER ) && 
                      ( fAuthenticator) )
                {
                    pPcb->LcpCb.dwError = RemoteError( ApResult.dwError );
                }
                else
                {
                    pPcb->LcpCb.dwError = ApResult.dwError;
                }

                NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );

                return;
            }

            break;
        }

        break;

    case APA_Authenticate:

        if ( fAuthenticator )
        {
            DWORD                dwIndex                = 0;
            DWORD                dwExtraAttributes      = 0;
            DWORD                dwNumUserAttributes    = 0;
            RAS_AUTH_ATTRIBUTE * pUserAttributes        = NULL;

            for ( dwNumUserAttributes = 0; 
                  pPcb->pUserAttributes[dwNumUserAttributes].raaType 
                                                                != raatMinimum;
                  dwNumUserAttributes++ );

            if ( CpTable[CpIndex].CpInfo.Protocol == PPP_EAP_PROTOCOL )
            {
                //
                // One more for Framed-MTU
                //

                dwExtraAttributes = 1;
            }

            pUserAttributes = RasAuthAttributeCopyWithAlloc(
                                    ApResult.pUserAttributes,
                                    dwNumUserAttributes + dwExtraAttributes );

            if ( pUserAttributes == NULL )
            {
                dwRetCode = GetLastError();

                pPcb->LcpCb.dwError = dwRetCode;

                NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );

                return;
            }

            if ( dwExtraAttributes )
            {
                ULONG mru = (pLcpCb->Remote.Work.MRU > LCP_DEFAULT_MRU) ?
                            LCP_DEFAULT_MRU : pLcpCb->Remote.Work.MRU;
                //
                // Insert the Framed-MTU attribute at the start.
                //

                dwRetCode = RasAuthAttributeInsert( 
                                0,
                                pUserAttributes,
                                raatFramedMTU,
                                FALSE,
                                4,
                                (LPVOID) 
                                ( UlongToPtr(mru)) );

                if ( dwRetCode != NO_ERROR )
                {
                    RasAuthAttributeDestroy( pUserAttributes );

                    pPcb->LcpCb.dwError = dwRetCode;

                    NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );

                    return;
                }
            }

            //
            // Insert the extra (user) attributes at the start. Attributes
            // returned by the auth protocol follow.
            //

            for ( dwIndex = 0; dwIndex < dwNumUserAttributes; dwIndex++ )
            {
                dwRetCode = RasAuthAttributeInsert( 
                                dwIndex + dwExtraAttributes,
                                pUserAttributes,
                                pPcb->pUserAttributes[dwIndex].raaType,
                                FALSE,
                                pPcb->pUserAttributes[dwIndex].dwLength,
                                pPcb->pUserAttributes[dwIndex].Value );

                if ( dwRetCode != NO_ERROR )
                {
                    RasAuthAttributeDestroy( pUserAttributes );

                    pPcb->LcpCb.dwError = dwRetCode;

                    NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );

                    return;
                }
            }

            dwRetCode = RasAuthenticateClient( pPcb->hPort, pUserAttributes );

            if ( dwRetCode != NO_ERROR )
            {
                pPcb->LcpCb.dwError = dwRetCode;

                NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );

                return;
            }
        }
        
        break;

    case APA_NoAction:

        break;

    default:

        break;
    }

    //
    // Check to see if we have to bring up the UI for EAP
    //

    if ( ( !fAuthenticator ) && ( ApResult.fInvokeEapUI ) )
    {
        NotifyCaller(pPcb, PPPMSG_InvokeEapUI, &(ApResult.InvokeEapUIData));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\engine\bap.h ===
/*

Copyright (c) 1997, Microsoft Corporation, all rights reserved

File:
    bap.h

Description:
    Remote Access PPP Bandwidth Allocation Protocol. Include ppp.h and rasman.h 
    before including this file.

History:
    Mar 27, 1997: Vijay Baliga created original version.

*/

#ifndef _BAP_H_
#define _BAP_H_

// BAP packet types 

#define BAP_PACKET_CALL_REQ         0x01    // Call-Request
#define BAP_PACKET_CALL_RESP        0x02    // Call-Response
#define BAP_PACKET_CALLBACK_REQ     0x03    // Callback-Request
#define BAP_PACKET_CALLBACK_RESP    0x04    // Callback-Response
#define BAP_PACKET_DROP_REQ         0x05    // Link-Drop-Query-Request
#define BAP_PACKET_DROP_RESP        0x06    // Link-Drop-Query-Response
#define BAP_PACKET_STATUS_IND       0x07    // Call-Status-Indication
#define BAP_PACKET_STAT_RESP        0x08    // Call-Status-Response
#define BAP_PACKET_LIMIT            0x08    // Highest number we can handle

// BAP option types

#define BAP_OPTION_LINK_TYPE        0x01    // Link-Type
#define BAP_OPTION_PHONE_DELTA      0x02    // Phone-Delta
#define BAP_OPTION_NO_PH_NEEDED     0x03    // No-Phone-Number-Needed
#define BAP_OPTION_REASON           0x04    // Reason
#define BAP_OPTION_LINK_DISC        0x05    // Link-Discriminator
#define BAP_OPTION_CALL_STATUS      0x06    // Call-Status
#define BAP_OPTION_LIMIT            0x06    // Highest number we can handle

// BAP sub-option types

#define BAP_SUB_OPTION_UNIQUE_DIGITS    0x01    // Unique-Digits
#define BAP_SUB_OPTION_SUBSCRIB_NUM     0x02    // Subscriber-Number
#define BAP_SUB_OPTION_SUB_ADDR         0x03    // Phone-Number-Sub-Address

// BAP options

#define BAP_N_LINK_TYPE     (1 << BAP_OPTION_LINK_TYPE)
#define BAP_N_PHONE_DELTA   (1 << BAP_OPTION_PHONE_DELTA)
#define BAP_N_NO_PH_NEEDED  (1 << BAP_OPTION_NO_PH_NEEDED)
#define BAP_N_REASON        (1 << BAP_OPTION_REASON)
#define BAP_N_LINK_DISC     (1 << BAP_OPTION_LINK_DISC)
#define BAP_N_CALL_STATUS   (1 << BAP_OPTION_CALL_STATUS)

// BAP response code

#define BAP_RESPONSE_ACK            0x00    // Request-Ack
#define BAP_RESPONSE_NAK            0x01    // Request-Nak
#define BAP_RESPONSE_REJ            0x02    // Request-Rej
#define BAP_RESPONSE_FULL_NAK       0x03    // Request-Full-Nak

// The time we give to a favored peer to bring down a link

#define BAP_TIMEOUT_FAV_PEER        45

typedef struct _RASDIAL_ARGS
{
    BOOL                fServerRouter;
    HRASCONN            hRasConn;
    RASDIALPARAMS       RasDialParams;
    RASDIALEXTENSIONS   RasDialExtensions;
    PPP_INTERFACE_INFO  InterfaceInfo;
    CHAR*               szPhonebookPath;
    BYTE*               pbEapInfo;
    CHAR				chSeed;			//Seed used for encoding the password

} RASDIAL_ARGS;

// Functions

VOID   
BapTrace(
    CHAR*   Format, 
    ... 
);

BOOL
FGetOurPhoneNumberFromHPort(
    IN  HPORT   hPort,
    OUT CHAR*   szOurPhoneNumber
);

VOID
BapEventAddLink(
    IN BCB* pBcbLocal
);

VOID
BapEventDropLink(
    IN BCB* pBcbLocal
);

// PCB and PPP_PACKET need ppp.h

VOID
BapEventReceive(
    IN BCB*         pBcbLocal,
    IN PPP_PACKET*  pPacket,
    IN DWORD        dwPacketLength
);

VOID
BapEventTimeout(
    IN BCB*     pBcbLocal,
    IN DWORD    dwId
);

// BAP_CALL_RESULT needs ppp.h

VOID
BapEventCallResult(
    IN BCB*             pBcbLocal,
    IN BAP_CALL_RESULT* pBapCallResult
);

VOID
BapSetPolicy(
    BCB*    pBcb
);

HPORT
RasGetHport( 
    IN      HRASCONN    hRasConnSubEntry 
);

#endif // #ifndef _BAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\engine\bltincps.h ===
/*

Copyright (c) 1997, Microsoft Corporation, all rights reserved

File:
    bltincps.h

Description:

History:
    Dec 19, 1997: Vijay Baliga created original version.

*/

#ifndef _BLTINCPS_H_
#define _BLTINCPS_H_

// RasBacp

LONG_PTR
BacpGetInfo(
    IN  DWORD       dwProtocolId,
    OUT PPPCP_INFO* pCpInfo
);

// RasIpCp

LONG_PTR
IpcpGetInfo(
    IN  DWORD       dwProtocolId,
    OUT PPPCP_INFO* pCpInfo
);

LONG_PTR
IpcpDhcpInform(
    IN VOID*        pwb,
    IN VOID*        pDhcpInform
);

VOID
RasSrvrDhcpCallback(
    IN  ULONG       nboIpAddr
);

// RasCbcp

LONG_PTR
CbCPGetInfo(
    IN  DWORD       dwProtocolId,
    OUT PPPCP_INFO* pCpInfo
);

// RasCcp

LONG_PTR
CcpGetInfo(
    IN  DWORD       dwProtocolId,
    OUT PPPCP_INFO* pCpInfo
);

// RasChap

LONG_PTR
ChapGetInfo(
    IN  DWORD       dwProtocolId,
    OUT PPPCP_INFO* pCpInfo
);

// RasEap

LONG_PTR
EapGetInfo(
    IN  DWORD       dwProtocolId,
    OUT PPPCP_INFO* pCpInfo
);

// RasIpxCp

LONG_PTR
IpxCpGetInfo(
    IN  DWORD       dwProtocolId,
    OUT PPPCP_INFO* pCpInfo
);

// RasNbfCp

LONG_PTR
NbfCpGetInfo(
    IN  DWORD       dwProtocolId,
    OUT PPPCP_INFO* pCpInfo
);

// RasPap

LONG_PTR
PapGetInfo(
    IN  DWORD       dwProtocolId,
    OUT PPPCP_INFO* pCpInfo
);

// RasSPap

LONG_PTR
SPAPGetInfo(
    IN  DWORD       dwProtocolId,
    OUT PPPCP_INFO* pCpInfo
);

// RasAtcp

LONG_PTR
AtcpGetInfo(
    IN  DWORD       dwProtocolId,
    OUT PPPCP_INFO* pCpInfo
);

// BuiltInCps

typedef struct _BUILT_IN_CP
{
    DWORD   dwProtocolId;   // The Protocol Id for the CP

    PROC    pRasCpGetInfo;  // The RasCpGetInfo for the CP

    CHAR*   szNegotiateCp;  // Value in the registry

    BOOL    fLoad;          // Load this CP

} BUILT_IN_CP;

#ifdef ALLOC_BLTINCPS_GLOBALS

BUILT_IN_CP BuiltInCps[] =
{
    {PPP_IPCP_PROTOCOL,     IpcpGetInfo,    "NegotiateIpCp",    TRUE},
    {PPP_BACP_PROTOCOL,     BacpGetInfo,    "NegotiateBacp",    TRUE},
    {PPP_CBCP_PROTOCOL,     CbCPGetInfo,    "NegotiateCbCP",    TRUE},
    {PPP_CCP_PROTOCOL,      CcpGetInfo,     "NegotiateCcp",     TRUE},
    {PPP_EAP_PROTOCOL,      EapGetInfo,     "NegotiateEap",     TRUE},
    {PPP_IPXCP_PROTOCOL,    IpxCpGetInfo,   "NegotiateIpx",     TRUE},
    {PPP_PAP_PROTOCOL,      PapGetInfo,     "NegotiatePap",     TRUE},
    {PPP_ATCP_PROTOCOL,     AtcpGetInfo,    "NegotiateAtcp",    TRUE},
    {PPP_SPAP_NEW_PROTOCOL, SPAPGetInfo,    "NegotiateSPAP",    TRUE}
};

#else // !ALLOC_BLTINCPS_GLOBALS

extern  BUILT_IN_CP BuiltInCps[];

#endif // ALLOC_BLTINCPS_GLOBALS

#define NUM_BUILT_IN_CPS (sizeof(BuiltInCps)/sizeof(BUILT_IN_CP))

#endif // #ifndef _BLTINCPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\engine\bap.c ===
/*

Copyright (c) 1997, Microsoft Corporation, all rights reserved

Description:
    Remote Access PPP Bandwidth Allocation Protocol routines. Based on 
    RFC 2125.

History:
    Mar 27, 1997: Vijay Baliga created original version.

Overview:
    When NdisWan tells us that a link has to be added or dropped, 
    BapEventAddLink or BapEventDropLink gets called. They call FFillBapCb to 
    fill in the BAPCB structure of the bundle. The BAPCB structure is mostly 
    used for holding values of the various BAP Datagram Options. FFillBapCb 
    calls FGetAvailableLink[ClientOrRouter | NonRouterServer] to see if links 
    are available, and if so, to choose one. If FFillBapCb returns FALSE, then 
    we cannot satisfy NdisWan's request. Otherwise, we call 
    FSendInitialBapRequest to send the request to the peer.

    When we get a packet from the peer, BapEventReceive gets called. It calls 
    the various BapEventRecv* functions, eg BapEventRecvCallOrCallbackReq, 
    BapEventRecvDropResp, etc. We respond by calling FSendBapResponse.

    Before we send a Callback-Request, or ACK a Call-Request, we call 
    FListenForCall if we are a non-router client. Routers and servers are 
    always listening anyway, so we don't explicitly start listening.

    If our Call-Request is ACK'ed or we ACK a Callback-Request, we call FCall 
    to add another link to the multilink bundle. Clients and routers call 
    RasDial. Non-router servers send messages to Ddm.

    The bundles are always in one of several BAP_STATEs, eg BAP_STATE_INITIAL 
    (the rest state), BAP_STATE_CALLING, etc. Call-Requests and 
    Callback-Requests are NAK'ed unless the state is INITIAL, SENT_CALL_REQ, or 
    SENT_CALLBACK_REQ (the latter two to resolve race conditions). 
    Drop-Requests are NAK'ed unless the state is INITIAL or SEND_DROP_REQ (the 
    latter to resolve race conditions).

Note on Dropping Links:
    We want to forcibly drop links when the utilization falls below a cutoff. 
    The server wants to do this to prevent users from hogging ports. The client 
    wants to do this to save money on calls.

    Before sending a BAP_PACKET_DROP_REQ, we note down the number of active 
    links (in BapCb.dwLinCount) and set fForceDropOnNak to TRUE. If the packet 
    times out or we get any response other than ACK, we summarily drop the link 
    by calling FsmClose if the number of active links has not decreased and 
    fForceDropOnNak is still TRUE.

    fForceDropOnNak is set to FALSE if there is a race condition and we are not
    the favored peer. We then mark the link for dropping and insert an item in 
    the timer queue. After BAP_TIMEOUT_FAV_PEER sec, if the peer has still not 
    dropped the link, and we have at least two active links, we summarily drop 
    the link by calling FsmClose.

Note on the "previously known number" for calculating Phone-Deltas:

    1) Client sending its numbers to the server (425 882 5759 and 425 882 5760)
       Client sends 011 91 425 882 5759. Server dials it.
       Client sends 011 91 425 882 5760. Server applies delta to above number.

    2) Server sending its numbers to the client. Client called 882 5759 first.
       (425 882 5759, 425 882 5660, 425 882 5758, 425 882 6666)
       Server sends 660. Client applies delta to first number.
       Server sends 758 (not just 8). Client applies delta to first number.
       Server sends 6666. Client applies delta to first number.

       This works irrespective of whether the 3rd party client applies delta to 
       the first number or the last number.

       If the client gets 011 91 425 882 5660, it must just dial the last 7 
       digits, since it dialed only 7 digits the first time.

*/

#include <nt.h>         // Required by windows.h
#include <ntrtl.h>      // Required by windows.h
#include <nturtl.h>     // Required by windows.h
#include <windows.h>    // Win32 base API's

#include <raserror.h>   // For ERROR_BUFFER_TOO_SMALL, etc
#include <mprerror.h>   // For ERROR_BAP_DISCONNECTED, etc
#include <mprlog.h>     // For ROUTERLOG_BAP_DISCONNECTED, etc
#include <rasman.h>     // Required by pppcp.h
#include <pppcp.h>      // For PPP_CONFIG_HDR_LEN, PPP_BACP_PROTOCOL, etc

#include <ppp.h>        // For PCB, PPP_PACKET, etc. Reqd by bap.h
#include <rtutils.h>    // For RTASSERT (PPP_ASSERT)
#include <util.h>       // For GetCpIndexFromProtocol(), etc
#include <timer.h>      // For InsertInTimerQ(), RemoveFromTimerQ()
#include <smevents.h>   // For FsmClose()
#include <worker.h>     // For ProcessCallResult()
#include <bap.h>
#include <rasbacp.h>    // For BACPCB

#define BAP_KEY_CLIENT_CALLBACK "Software\\Microsoft\\RAS Phonebook\\Callback"
#define BAP_KEY_SERVER_CALLBACK "Software\\Microsoft\\Router Phonebook\\Callback"
#define BAP_VAL_NUMBER          "Number"

/*

Description:
    g_dwMandatoryOptions[BAP_PACKET_foo] contains the mandatory options for BAP 
    Datagram BAP_PACKET_foo.

*/

static DWORD g_dwMandatoryOptions[] =
{
    0,
    BAP_N_LINK_TYPE,
    0,
    BAP_N_LINK_TYPE | BAP_N_PHONE_DELTA,
    0,
    BAP_N_LINK_DISC,
    0,
    BAP_N_CALL_STATUS,
    0
};

/*

Returns:
    void

Description:
    Used for printing BAP trace statements.
    
*/

VOID   
BapTrace(
    IN  CHAR*   Format, 
    ... 
) 
{
    va_list arglist;

    va_start(arglist, Format);

    TraceVprintfEx(DwBapTraceId, 
                   0x00010000 | TRACE_USE_MASK | TRACE_USE_MSEC,
                   Format,
                   arglist);

    va_end(arglist);
}

/*

Returns:
    TRUE: Success
    FALSE: Failure

Description:
    Calls RasPortEnum() and returns an array of RASMAN_PORT's in *ppRasmanPort 
    and the number of elements in the array in *pdwNumPorts. If this function 
    fails, *ppRasmanPort will be NULL and *pdwNumPorts will be 0. If this 
    function succeeds, the caller must call LOCAL_FREE(*ppRasmanPort);

*/

BOOL
FEnumPorts(
    OUT RASMAN_PORT**   ppRasmanPort,
    OUT DWORD*          pdwNumPorts
)
{
    DWORD   dwErr;
    DWORD   dwSize;
    DWORD   dwNumEntries;
    BOOL    fRet            = FALSE;

    PPP_ASSERT(NULL != ppRasmanPort);
    PPP_ASSERT(NULL != pdwNumPorts);

    *ppRasmanPort = NULL;

    dwSize = 0;
    dwErr = RasPortEnum(NULL, NULL /* buffer */, &dwSize, &dwNumEntries);
    PPP_ASSERT(ERROR_BUFFER_TOO_SMALL == dwErr);

    *ppRasmanPort = (RASMAN_PORT*) LOCAL_ALLOC(LPTR, dwSize);
    if (NULL == *ppRasmanPort)
    {
        BapTrace("FEnumPorts: Out of memory.");
        goto LDone;
    }

    dwErr = RasPortEnum(NULL, (BYTE*)*ppRasmanPort, &dwSize, &dwNumEntries);
    if (NO_ERROR != dwErr)
    {
        BapTrace("FEnumPorts: RasPortEnum returned error %d", dwErr);
        goto LDone;
    }

    fRet = TRUE;

LDone:

    if (!fRet)
    {
        if (NULL != *ppRasmanPort)
        {
            LOCAL_FREE(*ppRasmanPort);
        }

        *ppRasmanPort = NULL;
        *pdwNumPorts = 0;
    }

    *pdwNumPorts = dwNumEntries;
    return(fRet);
}

/*

Returns:
    TRUE: ASCII digits
    FALSE: not ASCII digits

Description:
    Looks at dwLength bytes in *pByte. Returns TRUE iff all of them are ASCII 
    digits.

*/

BOOL
FAsciiDigits(
    IN  BYTE*   pByte,
    IN  DWORD   dwLength    
)
{
    PPP_ASSERT(NULL != pByte);

    while (dwLength--)
    {
        if (!isdigit(pByte[dwLength]))
        {
            if (FDoBapOnVpn && '.' == pByte[dwLength])
            {
                continue;
            }
            else
            {
                return(FALSE);
            }
        }
    }

    return(TRUE);
}

/*

Returns:
    TRUE: Success
    FALSE: Failure

Description:
    Given a pointer to a RASMAN_PORT, this function returns the link type (in 
    *pdwLinkType) and link speed in kbps (in *pdwLinkSpeed) for the associated 
    port. The link type is the same as the Link Type in the Link-Type BAP 
    option: 1 for ISDN, 2 for X.25, and 4 for modem. If this function fails, 
    *pdwLinkType and *pdwLinkSpeed will be set to 0.

*/

BOOL
FGetLinkTypeAndSpeedFromRasmanPort(
    IN  RASMAN_PORT*    pRasmanPort, 
    OUT DWORD*          pdwLinkType, 
    OUT DWORD*          pdwLinkSpeed
)
{
    BOOL    fRet = TRUE;

    PPP_ASSERT(NULL != pRasmanPort);
    PPP_ASSERT(NULL != pdwLinkType);
    PPP_ASSERT(NULL != pdwLinkSpeed);

    if (!lstrcmpi(pRasmanPort->P_DeviceType, RASDT_Isdn))
    {
        *pdwLinkType = 1;
        *pdwLinkSpeed = 64;
    }
    else if (!lstrcmpi(pRasmanPort->P_DeviceType, RASDT_X25))
    {
        *pdwLinkType = 2;
        *pdwLinkSpeed = 56;
    }
    else if (!lstrcmpi(pRasmanPort->P_DeviceType, RASDT_Modem))
    {
        *pdwLinkType = 4;
        *pdwLinkSpeed = 56;
    }
    else if (FDoBapOnVpn && !lstrcmpi(pRasmanPort->P_DeviceType, RASDT_Vpn))
    {
        *pdwLinkType = 32;
        *pdwLinkSpeed = 10000;
    }
    else
    {
        // BapTrace("Unknown LinkType %s", pRasmanPort->P_DeviceType);
        *pdwLinkType = 0;
        *pdwLinkSpeed = 0;
        fRet = FALSE;
    }

    return(fRet);
}

/*

Returns:
    TRUE: Success
    FALSE: Failure

Description:
    Given an hPort, this function tries to find out the phone number that the 
    peer can dial to connect to the device that the port belongs to. The phone 
    number (only ASCII digits, and with at most RAS_MaxCallbackNumber chars) is
    returned in szOurPhoneNumber.

*/

BOOL
FGetOurPhoneNumberFromHPort(
    IN  HPORT   hPort,
    OUT CHAR*   szOurPhoneNumber
)
{
    BOOL                fRet                = FALSE;
    RAS_CONNECT_INFO*   pRasConnectInfo     = NULL;
    DWORD               dwSize;
    DWORD               dwErr;

    ZeroMemory(szOurPhoneNumber, (RAS_MaxCallbackNumber + 1) * sizeof(CHAR));

    dwSize = 0;
    dwErr = RasGetConnectInfo(hPort, &dwSize, NULL);
    if (ERROR_BUFFER_TOO_SMALL != dwErr)
    {
        BapTrace("RasGetConnectInfo failed and returned 0x%x", dwErr);
        goto LDone;
    }

    pRasConnectInfo = (RAS_CONNECT_INFO*) LOCAL_ALLOC(LPTR, dwSize);
    if (NULL == pRasConnectInfo)
    {
        BapTrace("FGetOurPhoneNumbersFromHPort: Out of memory.");
        goto LDone;
    }

    dwErr = RasGetConnectInfo(hPort, &dwSize, pRasConnectInfo);
    if (NO_ERROR != dwErr)
    {
        BapTrace("RasGetConnectInfo failed and returned 0x%x", dwErr);
        goto LDone;
    }

    if (   (0 < pRasConnectInfo->dwCalledIdSize)
        && (0 != pRasConnectInfo->pszCalledId[0]))
    {
        strncpy(szOurPhoneNumber, pRasConnectInfo->pszCalledId, 
            RAS_MaxCallbackNumber);
    }
    else if (   (0 < pRasConnectInfo->dwAltCalledIdSize)
             && (0 != pRasConnectInfo->pszAltCalledId[0]))
    {
        strncpy(szOurPhoneNumber, pRasConnectInfo->pszAltCalledId, 
            RAS_MaxCallbackNumber);
    }

    fRet = TRUE;

LDone:

    if (NULL != pRasConnectInfo)
    {
        LOCAL_FREE(pRasConnectInfo);
    }

    return(fRet);
}

/*

Returns:
    TRUE: Success
    FALSE: Failure

Description:
    Given a port name, szPortName, this function tries to find out the phone 
    number that the peer has to dial to connect to the port. The phone number 
    is returned in szOurPhoneNumber, whose size must be at least 
    RAS_MaxCallbackNumber + 1. If we are the server or the router, 
    fRouterPhoneBook must be TRUE and szTextualSid is ignored. Otherwise, 
    fRouterPhoneBook must be FALSE and szTextualSid must contain the 
    textual sid of the logged on user.

*/

BOOL
FGetOurPhoneNumberFromPortName(
    IN  CHAR*   szPortName,
    OUT CHAR*   szOurPhoneNumber,
    IN  BOOL    fRouterPhoneBook,
    IN  CHAR*   szTextualSid
)
{
    BOOL        fRet                    = FALSE;

    HKEY        hKeyCallback;
    BOOL        fCloseHKeyCallback      = FALSE;

    HKEY        hKey;
    DWORD       dwIndex;
    DWORD       dwSize;
    FILETIME    FileTime;
    CHAR        szCallbackNumber[RAS_MaxCallbackNumber + 1];
    DWORD       dwErr;

    // The size has been obtained from DeviceAndPortFromPsz in noui.c:
    CHAR        szDeviceAndPort[RAS_MaxDeviceName + 2 + MAX_PORT_NAME + 1 + 1];
    CHAR*       pchStart;
    CHAR*       pchEnd;
    CHAR*       szCallback;

    PPP_ASSERT(NULL != szPortName);
    PPP_ASSERT(NULL != szOurPhoneNumber);

    if (fRouterPhoneBook)
    {
        szCallback = BAP_KEY_SERVER_CALLBACK;
    }
    else
    {
        szCallback = BAP_KEY_CLIENT_CALLBACK;
    }

    fCloseHKeyCallback = FALSE;
    if (fRouterPhoneBook)
    {
        dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szCallback, 0, KEY_READ,
                    &hKeyCallback);
        if (NO_ERROR != dwErr)
        {
            BapTrace("RegOpenKeyEx on %s returned error %d", szCallback, dwErr);
            goto LDone;
        }
    }
    else
    {
        if (NULL == szTextualSid)
        {
            BapTrace("Textual Sid is not known");
            goto LDone;
        }

        dwErr = RegOpenKeyEx(HKEY_USERS, szTextualSid, 0, KEY_READ, &hKey);
        if (NO_ERROR != dwErr)
        {
            BapTrace("RegOpenKeyEx on %s returned error %d", szTextualSid,
                dwErr);
            goto LDone;
        }

        dwErr = RegOpenKeyEx(hKey, szCallback, 0, KEY_READ, &hKeyCallback);
        RegCloseKey(hKey);
        if (NO_ERROR != dwErr)
        {
            BapTrace("RegOpenKeyEx on %s returned error %d", szCallback, dwErr);
            goto LDone;
        }
    }
    fCloseHKeyCallback = TRUE;

    dwIndex = 0;
    while (TRUE)
    {
        dwSize = sizeof(szDeviceAndPort);
        dwErr = RegEnumKeyEx(hKeyCallback, dwIndex++,
            szDeviceAndPort, &dwSize,
            NULL, NULL, NULL, &FileTime);

        if (ERROR_NO_MORE_ITEMS == dwErr)
        {
            break;
        }

        if (ERROR_MORE_DATA == dwErr)
        {
            BapTrace("The buffer is too small for key %d in %s",
                dwIndex, szCallback);
            continue;
        }

        if (NO_ERROR != dwErr)
        {
            BapTrace("RegEnumKeyEx on %s returned error %d",
                szCallback, dwErr);
            break;
        }

        pchEnd = szDeviceAndPort + strlen(szDeviceAndPort) - 1;
        pchStart = pchEnd;
        while (szDeviceAndPort < pchStart)
        {
            if ('(' == *pchStart)
            {
                break;
            }
            else
            {
                pchStart -= 1;
            }
        }

        if (   (szDeviceAndPort < pchStart) && (pchStart < pchEnd)
            && ('(' == *pchStart) && (')' == *pchEnd))
        {
            *pchEnd = 0;
            pchStart += 1;
        }
        else
        {
            BapTrace("Invalid DeviceAndPort %s in key %s",
                szDeviceAndPort, szCallback);
            continue;
        }

        if (!lstrcmpi(pchStart, szPortName))
        {
            *pchEnd = ')';
            dwErr = RegOpenKeyEx(hKeyCallback, szDeviceAndPort, 0, KEY_READ, 
                        &hKey);
            if (NO_ERROR != dwErr)
            {
                BapTrace("RegOpenKeyEx on %s returned error %d", szDeviceAndPort, 
                    dwErr);
                break;
            }

            dwSize = RAS_MaxCallbackNumber + 1;
            dwErr = RegQueryValueEx(hKey, BAP_VAL_NUMBER, NULL, NULL, 
                szCallbackNumber, &dwSize);
            RegCloseKey(hKey);

            if (NO_ERROR != dwErr)
            {
                BapTrace("RegQueryValueEx on %s\\%s failed. Error: %d",
                    szDeviceAndPort, BAP_VAL_NUMBER, dwErr);
                break;
            }

            RemoveNonNumerals(szCallbackNumber);

            if (szCallbackNumber[0])
            {
                lstrcpy(szOurPhoneNumber, szCallbackNumber);
                fRet = TRUE;
            }

            break;
        }
    }

LDone:

    if (fCloseHKeyCallback)
    {
        RegCloseKey(hKeyCallback);
    }

    if (!fRet)
    {
        BapTrace("No callback number for port %s", szPortName);
    }

    return(fRet);
}

/*

Returns:
    TRUE: Success
    FALSE: Failure

Description:
    Writes a Phone-Delta in pbPhoneDelta using szOurPhoneNumber as the phone 
    number to send to the peer and szBasePhoneNumber as the "previously known 
    number". If the lengths of the szOurPhoneNumber and szBasePhoneNumber are 
    different, or if szBasePhoneNumber is NULL, it writes the entire 
    PhoneNumber into pbPhoneDelta. Otherwise, the unique portion of 
    szBasePhoneNumber is overwritten with X's so that the unique portion will 
    never decrease.

    *pdwNumBytes contains the number of bytes the function can write in 
    pbPhoneDelta. On exit, it is decremented by the number of bytes actually 
    written.

    NOTE: NOTE: NOTE: NOTE: NOTE:

    If the function returns FALSE, nothing will be written in pbPhoneDelta and 
    *pdwNumBytes will be left unchanged.

*/

BOOL
FWritePhoneDelta(
    IN      CHAR*   szOurPhoneNumber,
    IN      CHAR*   szBasePhoneNumber,
    OUT     BYTE*   pbPhoneDelta,
    IN OUT  DWORD*  pdwNumBytes)
{
    DWORD   dwNumCharsPhoneNumber;
    DWORD   dwNumCharsBase          = 0;
    DWORD   dwDeltaIndex;
    DWORD   dwTemp;
    DWORD   dwNumCharsUnique;
    BOOL    fRet                    = FALSE;

    PPP_ASSERT(NULL != szOurPhoneNumber);
    PPP_ASSERT(NULL != pbPhoneDelta);
    PPP_ASSERT(NULL != pdwNumBytes);

    dwNumCharsPhoneNumber = lstrlen(szOurPhoneNumber);
    if (0 == dwNumCharsPhoneNumber)
    {
        BapTrace("szOurPhoneNumbers is an empty string");
        goto LDone;
    }

    if (NULL != szBasePhoneNumber)
    {
        dwNumCharsBase = lstrlen(szBasePhoneNumber);
    }

    dwDeltaIndex = 0;

    if ((NULL != szBasePhoneNumber) &&
        (dwNumCharsPhoneNumber == dwNumCharsBase))
    {
        // Find the substring of szOurPhoneNumber that differs from 
        // szBasePhoneNumber.

        while ((0 != szOurPhoneNumber[dwDeltaIndex]) &&
               (szOurPhoneNumber[dwDeltaIndex] == 
                szBasePhoneNumber[dwDeltaIndex]))
        {
            dwDeltaIndex++;
        }

        for (dwTemp = dwDeltaIndex; 0 != szBasePhoneNumber[dwTemp];
             dwTemp++)
        {
            // We want to make sure that the Unique portion will increase 
            // each time, ie if we sent 3 unique digits last time, this time 
            // we should send atleast 3. This is because we don't know
            // whether the peer will apply the phone delta to the first
            // number received or the latest one.

            szBasePhoneNumber[dwTemp] = 'X';
        }
    }

    // The unique part of szOurPhoneNumber begins at 
    // szOurPhoneNumber[dwDeltaIndex].

    dwNumCharsUnique = dwNumCharsPhoneNumber - dwDeltaIndex;

    if (0 == dwNumCharsUnique)
    {
        // Other implementations may not be able to handle 0 Unique-Digits 
        dwNumCharsUnique = 1;
        dwDeltaIndex -= 1;
    }

#if 0
    // Do not remove this code. It shows how we would have handled 0 
    // Unique-Digits.
    if (0 == dwNumCharsUnique)
    {
        // szOurPhoneNumber and szBasePhoneNumber are the same.

        if (1 > *pdwNumBytes)
        {
            BapTrace("No space in pbPhoneDelta");
            return(FALSE);
        }

        // See BAPCB comments for an explanation of the 0xFF weirdness.
        pbPhoneDelta[0] = 0xFF;
        *pdwNumBytes -= 1;

        return(TRUE);
    }
#endif

    RTASSERT(FAsciiDigits(szOurPhoneNumber + dwDeltaIndex,
                dwNumCharsUnique));

    // Our phone numbers should have no more than RAS_MaxPhoneNumber (128)
    // digits.
    PPP_ASSERT(0xFF >= dwNumCharsUnique);

    if (dwNumCharsUnique + 4 > *pdwNumBytes)
    {
        BapTrace("Not enough space in pbPhoneDelta. Delta: %s. "
            "Bytes available: %d",
            szOurPhoneNumber + dwDeltaIndex, *pdwNumBytes);

        goto LDone;
    }

    // We have a phone delta
    fRet = TRUE;

    // See the format for writing Phone-Deltas in the BAPCB documentation.
    pbPhoneDelta[0] = (BYTE) dwNumCharsUnique;
    pbPhoneDelta[1] = 0;
    lstrcpy(pbPhoneDelta + 2, szOurPhoneNumber + dwDeltaIndex);
    pbPhoneDelta[dwNumCharsUnique + 2] = 0;
    pbPhoneDelta[dwNumCharsUnique + 3] = 0;

    *pdwNumBytes -= dwNumCharsUnique + 4;

LDone:

    return(fRet);
}

/*

Returns:
    TRUE: Success
    FALSE: Failure

Description:
    Reads the Phone-Delta in pbPhoneDelta into szPeerPhoneNumber using 
    szBasePhoneNumber as the "previously known number".

    If szBasePhoneNumber is NULL, it writes only the Phone-Delta into 
    szPeerPhoneNumber.

    If the Phone-Delta is larger than the szBasePhoneNumber, it writes only the 
    last strlen(szBasePhoneNumber) number of digits into szPeerPhoneNumber. If 
    szBasePhoneNumber is 882 5759, and the delta is 425 713 5748, we should 
    dial 713 5748, not the whole number.

    If szBasePhoneNumber is not NULL and contains an empty string, 
    szPeerPhoneNumber is written to it.

    It returns the number of bytes read from pbPhoneDelta in *pdwBytesRead.

*/

BOOL
FReadPhoneDelta(
    OUT     CHAR*   szPeerPhoneNumber,
    IN      CHAR*   szBasePhoneNumber,
    IN      BYTE*   pbPhoneDelta,
    OUT     DWORD*  pdwBytesRead)
{
    DWORD   dwNumCharsPhoneNumber;
    DWORD   dwNumCharsBase          = 0;
    DWORD   dwNumCharsDelta;
    DWORD   dwDeltaIndex;
    DWORD   dwNumCharsUnique;

    PPP_ASSERT(NULL != szPeerPhoneNumber);
    PPP_ASSERT(NULL != pbPhoneDelta);

    if (NULL != szBasePhoneNumber)
    {
        dwNumCharsBase = lstrlen(szBasePhoneNumber);
    }

    dwNumCharsDelta = pbPhoneDelta[0];

    // FReadOptions() makes sure that the bytes in the Subscriber-Number are all
    // ASCII digits.

    if (0xFF == dwNumCharsDelta)
    {
        // Unique-Digits is 0. See BAPCB comments.

        if (NULL != szBasePhoneNumber)
        {
            lstrcpy(szPeerPhoneNumber, szBasePhoneNumber);
            *pdwBytesRead = 1;
            return(TRUE);
        }
        else
        {
            BapTrace("Unique-Digits is 0, but there is no "
                "\"previously known number\"");
            return(FALSE);
        }
    }
    else if (0 == dwNumCharsBase)
    {
        // Note that pbPhoneDelta contains only the unique digits part of the 
        // Subscriber-Number Sub-Option. The leading non unique digits sent by 
        // the peer are ignored. See the BAPCB comments.

        lstrcpy(szPeerPhoneNumber, pbPhoneDelta + 2);
    }
    else
    {
        // If szBasePhoneNumber were NULL, we would have
        // (0 == dwNumCharsBase) above

        PPP_ASSERT(NULL != szBasePhoneNumber);

        if (dwNumCharsDelta > dwNumCharsBase)
        {
            // If szBasePhoneNumber is 882 5759, and the peer sent us
            // 425 713 5748, we should dial 713 5748, not the whole number.
            lstrcpy(szPeerPhoneNumber,
                pbPhoneDelta + 2 + dwNumCharsDelta - dwNumCharsBase);
        }
        else
        {
            lstrcpy(szPeerPhoneNumber, szBasePhoneNumber);
            lstrcpy(szPeerPhoneNumber + dwNumCharsBase - dwNumCharsDelta,
                pbPhoneDelta + 2);
        }
    }

    if (   (NULL != szBasePhoneNumber)
        && (0 == szBasePhoneNumber[0]))
    {
        lstrcpy(szBasePhoneNumber, szPeerPhoneNumber);
    }

    *pdwBytesRead = 2 + lstrlen(pbPhoneDelta + 2) + 1;
    *pdwBytesRead += lstrlen(pbPhoneDelta + *pdwBytesRead) + 1;
    return(TRUE);
}

/*

Returns:
    TRUE: Success
    FALSE: Failure

Description:
    This function must only be called by clients or routers.

    It tries to find a free link in the entry szEntryName in the phone book 
    szPhonebookPath. fCallOut is TRUE iff we will dial out on the link. fRouter 
    is TRUE iff we are a router. szTextualSid contains the textual sid of the 
    logged on user. It is required iff pbPhoneDelta is not NULL and fRouter is 
    FALSE.

    If *pdwLinkType is 0, it doesn't care about the link type and sets 
    *pdwLinkType and *pdwLinkSpeed (link speed in kbps). Otherwise, the type of 
    the free link must match *pdwLinkType. The link type is the same as the 
    Link Type in the Link-Type BAP option: 1 for ISDN, 2 for X.25, and 4 for 
    modem.

    If szPeerPhoneNumber is not NULL, it fills it up with the peer's phone 
    number (the number that we will have to dial). If pbPhoneDelta is not NULL, 
    it fills it up with one (!fRouter) or more (fRouter) Phone-Deltas (the 
    numbers that the peer will have to dial). Each Phone-Delta is calculated 
    with szBasePhoneNumber as the "previously known number". szBasePhoneNumber 
    MUST be NULL if we are not the server. A non-router client does not want 
    to do multiple RasPortListen()'s, and hence will send only one Phone-Delta.

    If pdwSubEntryIndex is not NULL, the 1-based index of the subentry in 
    szEntryName that corresponds to the free link is put in *pdwSubEntryIndex. 
    If szPortName is not NULL, it fills it up with the name of the port 
    corresponding to the free link. szPortName is needed to do a 
    RasPortListen().

    Sanity check: If *pdwLinkType is 0 (any link will do), pbPhoneDelta must be 
    NULL. Ie if we are NAK'ing a request, we mustn't send any Phone-Delta.

    NOTE: NOTE: NOTE: NOTE: NOTE:

    This function is very similar to FGetAvailableLinkNonRouterServer(). If you 
    change one, you probably need to change the other too.

*/

BOOL
FGetAvailableLinkClientOrRouter(
    IN      PCB*    pPcbLocal,
    IN      CHAR*   szPhonebookPath,
    IN      CHAR*   szEntryName,
    IN      BOOL    fCallOut,
    IN      BOOL    fRouter,
    IN      CHAR*   szTextualSid,
    IN OUT  DWORD*  pdwLinkType,
    IN OUT  DWORD*  pdwLinkSpeed,
    OUT     CHAR*   szPeerPhoneNumber,
    OUT     DWORD*  pdwSubEntryIndex,
    OUT     BYTE*   pbPhoneDelta,
    OUT     CHAR*   szPortName,
    IN      CHAR*   szBasePhoneNumber
)
{
    BOOL            fRet                = FALSE;
    DWORD           dwErr;

    RASMAN_PORT*    pRasmanPort         = NULL;
    DWORD           dwNumPorts;

    RASENTRY*       pRasEntry           = NULL;
    DWORD           dwBufferSize;

    DWORD           dwSubEntryIndex;
    RASSUBENTRY*    pRasSubEntry        = NULL;

    DWORD           dwPcbIndex;

    DWORD           dwPortIndex;
    RASMAN_INFO     RasmanInfo;

    DWORD           dwLinkType;
    DWORD           dwLinkSpeed;
    CHAR            szOurPhoneNumber[RAS_MaxCallbackNumber + 2]; // MULTI_SZ
    DWORD           dwNumChars;
    BOOL            fPortAvailable;
    RASMAN_USAGE    RasmanUsage;
    BOOL            fExitOuterFor;

    PPP_ASSERT(NULL != szPhonebookPath);
    PPP_ASSERT(NULL != szEntryName);
    PPP_ASSERT(NULL != pdwLinkType);
    PPP_ASSERT(NULL != pdwLinkSpeed);

    // We do this in order to keep szOurPhoneNumber a MULTI_SZ
    ZeroMemory(szOurPhoneNumber, RAS_MaxCallbackNumber + 2);

    // We don't care about the link type. Any link will do.
    if (0 == *pdwLinkType)
    {
        // Set *pdwLinkSpeed, in case we return an error.
        *pdwLinkSpeed = 0;
    }

    if (!FEnumPorts(&pRasmanPort, &dwNumPorts))
    {
        goto LDone;
    }

    if (NULL != pbPhoneDelta)
    {
        // FWritePhoneDelta will write Phone-Delta's into pbPhoneDelta. We want
        // the very next byte to be 0. (See BAPCB documentation).
        ZeroMemory(pbPhoneDelta, BAP_PHONE_DELTA_SIZE + 1);

        // The size (in bytes) of pbPhoneDelta available. Note that the last
        // byte is reserved for the terminating 0, which is why we do not set
        // dwNumChars to BAP_PHONE_DELTA_SIZE + 1;
        dwNumChars = BAP_PHONE_DELTA_SIZE;
    }

    dwBufferSize = 0;
    dwErr = RasGetEntryProperties(szPhonebookPath, szEntryName, NULL, 
                &dwBufferSize, NULL, NULL);

    if (ERROR_BUFFER_TOO_SMALL != dwErr)
    {
        BapTrace("RasGetEntryProperties(%s, %s) returned error %d",
            szPhonebookPath, szEntryName, dwErr);
        goto LDone;
    }

    pRasEntry = LOCAL_ALLOC(LPTR, dwBufferSize);
    if (NULL == pRasEntry)
    {
        BapTrace("FGetAvailableLinkClientOrRouter: Out of memory.");
        goto LDone;
    }

    pRasEntry->dwSize = sizeof(RASENTRY);
    dwErr = RasGetEntryProperties(szPhonebookPath, szEntryName, pRasEntry, 
                &dwBufferSize, NULL, NULL);

    if (0 != dwErr)
    {
        BapTrace("RasGetEntryProperties(%s, %s) returned error %d",
            szPhonebookPath, szEntryName, dwErr);
        goto LDone;
    }

    fExitOuterFor = FALSE;
    
    for (dwSubEntryIndex = 1;
         dwSubEntryIndex <= pRasEntry->dwSubEntries;
         dwSubEntryIndex++)
    {
        pRasSubEntry = NULL;

        for (dwPcbIndex = 0;
             dwPcbIndex < pPcbLocal->pBcb->dwPpcbArraySize;
             dwPcbIndex++)
        {
            if (   (NULL != pPcbLocal->pBcb->ppPcb[dwPcbIndex])
                && (dwSubEntryIndex ==
                        pPcbLocal->pBcb->ppPcb[dwPcbIndex]->dwSubEntryIndex))
            {
                // This sub entry is already connected
                goto LOuterForEnd;
            }
        }

        dwBufferSize = 0;
        dwErr = RasGetSubEntryProperties(szPhonebookPath, szEntryName, 
                    dwSubEntryIndex, NULL, &dwBufferSize, NULL, NULL);

        if (ERROR_BUFFER_TOO_SMALL != dwErr)
        {
            BapTrace("RasGetSubEntryProperties(%s, %s, %d) returned error %d",
                szPhonebookPath, szEntryName, dwSubEntryIndex, dwErr);
            goto LOuterForEnd;
        }

        pRasSubEntry = LOCAL_ALLOC(LPTR, dwBufferSize);
        if (NULL == pRasSubEntry)
        {
            BapTrace("FGetAvailableLinkClientOrRouter: Out of memory.");
            goto LOuterForEnd;
        }

        pRasSubEntry->dwSize = sizeof(RASSUBENTRY);
        dwErr = RasGetSubEntryProperties(szPhonebookPath, szEntryName, 
                    dwSubEntryIndex, pRasSubEntry, &dwBufferSize, NULL, NULL);

        if (0 != dwErr)
        {
            BapTrace("RasGetSubEntryProperties(%s, %s, %d) returned error %d",
                szPhonebookPath, szEntryName, dwSubEntryIndex, dwErr);
            goto LOuterForEnd;
        }

        for (dwPortIndex = 0;
             dwPortIndex < dwNumPorts;
             dwPortIndex++)
        {
            // For each sub entry, find the port that corresponds to it. See if 
            // it is available.

            if (lstrcmpi(pRasmanPort[dwPortIndex].P_DeviceName,
                    pRasSubEntry->szDeviceName))
            {
                // This is not the port we want
                continue;
            }

            RasmanUsage = pRasmanPort[dwPortIndex].P_ConfiguredUsage;

            if (fRouter)
            {
                // Make sure that the port is a router port.

                if (!(RasmanUsage & CALL_ROUTER))
                {
                    continue;
                }
            }
            else
            {
                // If fCallOut is TRUE, make sure that we can call out on this 
                // port.

                if (fCallOut && !(RasmanUsage & CALL_OUT))
                {
                    continue;
                }
            }
            
            dwErr = RasGetInfo(NULL, pRasmanPort[dwPortIndex].P_Handle,
                        &RasmanInfo);

            fPortAvailable = FALSE;

            if (ERROR_PORT_NOT_OPEN == dwErr)
            {
                /*

                If fCallOut is TRUE, we will call RasDial(). 
                ERROR_PORT_NOT_OPEN is good. Otherwise, if we are not the 
                router, we will call RasPortOpen() and RasPortListen(), so it 
                is fine. The port is unacceptable *iff* a router wants to 
                listen on it.

                */

                fPortAvailable = fCallOut || !fRouter;
            }
            else if ((LISTENING == RasmanInfo.RI_ConnState) &&
                     ((RasmanUsage & CALL_ROUTER) ||
                      (RasmanUsage & CALL_IN)))
            {
                /*

                We can use the port if the server or the router is doing a 
                listen. We cannot use the port if it is in the LISTENING state 
                because a client called RasDial() on it and is expecting a 
                callback. If neither CALL_ROUTER nor CALL_IN is true, we know 
                that it is a client doing a listen. Otherwise, we don't know, 
                but we will assume that it is available and handle errors 
                later. 

                */

                fPortAvailable = TRUE;
            }

            if (!fPortAvailable)
            {
                continue;
            }

            if (!FGetLinkTypeAndSpeedFromRasmanPort(
                    pRasmanPort + dwPortIndex, &dwLinkType, &dwLinkSpeed))
            {
                continue;
            }

            if (0 == *pdwLinkType)
            {
                *pdwLinkType = dwLinkType;
                *pdwLinkSpeed = dwLinkSpeed;
            }
            else if (dwLinkType != *pdwLinkType)
            {
                continue;
            }

            if (szPortName)
            {
                lstrcpy(szPortName, pRasmanPort[dwPortIndex].P_PortName);
            }

            if (pbPhoneDelta)
            {
                // If our phone number is requested and we cannot supply it, we 
                // must return FALSE.

                if (!FGetOurPhoneNumberFromPortName(
                        pRasmanPort[dwPortIndex].P_PortName,
                        szOurPhoneNumber, fRouter, szTextualSid))
                {
                    continue;
                }

                if (!FWritePhoneDelta(szOurPhoneNumber, szBasePhoneNumber,
                        pbPhoneDelta + BAP_PHONE_DELTA_SIZE - dwNumChars,
                        &dwNumChars))
                {
                    continue;
                }
            }

            if (szPeerPhoneNumber)
            {
                lstrcpy(szPeerPhoneNumber, pRasSubEntry->szLocalPhoneNumber);
            }

            if (pdwSubEntryIndex)
            {
                *pdwSubEntryIndex = dwSubEntryIndex;
            }

            BapTrace("FGetAvailableLinkClientOrRouter: Portname is %s",
                pRasmanPort[dwPortIndex].P_PortName);
            fRet = TRUE;

            if (!pbPhoneDelta || !fRouter)
            {
                // We don't want to collect all our Phone-Deltas.
                fExitOuterFor = TRUE;
                goto LOuterForEnd;
            }
        }

LOuterForEnd:

        if (NULL != pRasSubEntry)
        {
            LOCAL_FREE(pRasSubEntry);
        }

        if (fExitOuterFor)
        {
            break;
        }
    }

LDone:

    if (NULL != pRasmanPort)
    {
        LOCAL_FREE(pRasmanPort);
    }

    if (NULL != pRasEntry)
    {
        LOCAL_FREE(pRasEntry);
    }

    return(fRet);
}

/*

Returns:
    TRUE: Success
    FALSE: Failure

Description:
    This function must only be called by servers that are not routers.

    It tries to find a free link that the server can use. fCallOut is TRUE iff 
    we will dial out on the link. If *pdwLinkType is 0, it doesn't care about 
    the link type and sets *pdwLinkType and *pdwLinkSpeed (link speed in kbps). 
    Otherwise, the type of the free link must match *pdwLinkType. The link type
    is the same as the Link Type in the Link-Type BAP option: 1 for ISDN, 2 for 
    X.25, and 4 for modem.

    If fCallOut is TRUE, the handle of the port that the server will call out 
    on will be put in *phPort.

    If pbPhoneDelta is not NULL, it fills it up with our Phone-Deltas (the 
    numbers that the peer can dial). Each Phone-Delta is calculated with 
    szBasePhoneNumber as the "previously known number". szBasePhoneNumber can 
    be NULL.

    Sanity check: If *pdwLinkType is 0 (any link will do), pbPhoneDelta must be 
    NULL. Ie if we are NAK'ing a request, we mustn't send any Phone-Delta.

    NOTE: NOTE: NOTE: NOTE: NOTE:

    This function is very similar to FGetAvailableLinkClientOrRouter(). If you 
    change one, you probably need to change the other too.

*/

BOOL
FGetAvailableLinkNonRouterServer(
    IN      BOOL    fCallOut,
    IN OUT  DWORD*  pdwLinkType,
    IN OUT  DWORD*  pdwLinkSpeed,
    OUT     HPORT*  phPort,
    OUT     BYTE*   pbPhoneDelta,
    IN      CHAR*   szBasePhoneNumber
)
{
    BOOL            fRet                = FALSE;
    DWORD           dwErr;

    RASMAN_PORT*    pRasmanPort         = NULL;
    DWORD           dwNumPorts;

    DWORD           dwPortIndex;
    RASMAN_INFO     RasmanInfo;

    DWORD           dwLinkType;
    DWORD           dwLinkSpeed;
    CHAR            szOurPhoneNumber[RAS_MaxCallbackNumber + 1];
    DWORD           dwNumChars;
    BOOL            fPortAvailable;
    RASMAN_USAGE    RasmanUsage;

    PPP_ASSERT(NULL != pdwLinkType);
    PPP_ASSERT(NULL != pdwLinkSpeed);

    // We don't care about the link type. Any link will do.
    if (0 == *pdwLinkType)
    {
        // Set *pdwLinkSpeed, in case we return an error.

        // We shouldn't be sending a Phone-Delta if we are NAK'ing a 
        // Call-Request or Callback-Request and sending a Link-Type
        PPP_ASSERT(NULL == pbPhoneDelta);

        *pdwLinkSpeed = 0;
    }
    
    if (!FEnumPorts(&pRasmanPort, &dwNumPorts))
    {
        goto LDone;
    }

    if (NULL != pbPhoneDelta)
    {
        // FWritePhoneDelta will write Phone-Delta's into pbPhoneDelta. We want
        // the very next byte to be 0. (See BAPCB documentation).
        ZeroMemory(pbPhoneDelta, BAP_PHONE_DELTA_SIZE + 1);

        // The size (in bytes) of pbPhoneDelta available. Note that the last
        // byte is reserved for the terminating 0, which is why we do not set
        // dwNumChars to BAP_PHONE_DELTA_SIZE + 1;
        dwNumChars = BAP_PHONE_DELTA_SIZE;
    }

    for (dwPortIndex = 0; dwPortIndex < dwNumPorts; dwPortIndex++)
    {
        RasmanUsage = pRasmanPort[dwPortIndex].P_ConfiguredUsage;

        // If fCallOut is TRUE, make sure that we can call out on this 
        // port. Else, make sure that we can accept calls on this port.

        if ((fCallOut  && !(RasmanUsage & CALL_OUT)) ||
            (!fCallOut && !(RasmanUsage & CALL_IN)))
        {
            continue;
        }
        
        dwErr = RasGetInfo(NULL, pRasmanPort[dwPortIndex].P_Handle, &RasmanInfo);

        fPortAvailable = FALSE;

        if (ERROR_PORT_NOT_OPEN == dwErr)
        {
            /*

            If fCallOut is TRUE, we will open the port and call out, so 
            ERROR_PORT_NOT_OPEN is fine. Otherwise, the port is unacceptable.

            */

            fPortAvailable = fCallOut;
        }
        else if ( NO_ERROR != dwErr)
        {
            continue;
        }
        else if ((LISTENING == RasmanInfo.RI_ConnState) &&
                 ((RasmanUsage & CALL_ROUTER) ||
                  (RasmanUsage & CALL_IN)))
        {
            /*

            We can use the port if the server or the router is doing a listen. 
            We cannot use the port if it is in the LISTENING state because 
            a client called RasDial() on it and is expecting a callback. If 
            neither CALL_ROUTER nor CALL_IN is true, we know that it is a 
            client doing a listen. Otherwise, we don't know, but we will 
            assume that it is available and handle errors later. 

            */

            fPortAvailable = TRUE;
        }

        if (!fPortAvailable)
        {
            continue;
        }

        if (!FGetLinkTypeAndSpeedFromRasmanPort(
                pRasmanPort + dwPortIndex, &dwLinkType, &dwLinkSpeed))
        {
            continue;
        }

        if (0 == *pdwLinkType)
        {
            *pdwLinkType = dwLinkType;
            *pdwLinkSpeed = dwLinkSpeed;
        }
        else if (dwLinkType != *pdwLinkType)
        {
            continue;
        }

        if (phPort)
        {
            *phPort = pRasmanPort[dwPortIndex].P_Handle;
        }

        if (pbPhoneDelta)
        {
            // If our phone number is requested and we cannot supply it, we 
            // must return FALSE.

            if (!FGetOurPhoneNumberFromHPort(
                    pRasmanPort[dwPortIndex].P_Handle,
                    szOurPhoneNumber))
            {
                continue;
            }

            if (!FWritePhoneDelta(szOurPhoneNumber, szBasePhoneNumber,
                    pbPhoneDelta + BAP_PHONE_DELTA_SIZE - dwNumChars,
                    &dwNumChars))
            {
                continue;
            }
        }

        BapTrace("FGetAvailableLinkNonRouterServer: Portname is %s",
            pRasmanPort[dwPortIndex].P_PortName);
        fRet = TRUE;

        if (!pbPhoneDelta)
        {
            // We don't want to collect all our Phone-Deltas.
            break;
        }
    }

LDone:

    if (NULL != pRasmanPort)
    {
        LOCAL_FREE(pRasmanPort);
    }

    return(fRet);
}

/*

Returns:
    TRUE: Success
    FALSE: Failure

Description:
    If fServer is TRUE, it calls FGetAvailableLinkNonRouterServer() with the 
    appropriate arguments. Otherwise it calls FGetAvailableLinkClientOrRouter().

*/

BOOL
FGetAvailableLink(
    IN      PCB*    pPcbLocal,
    IN      BOOL    fServer,
    IN      BOOL    fRouter,
    IN      BOOL    fCallOut,
    IN      CHAR*   szPhonebookPath,
    IN      CHAR*   szEntryName,
    IN      CHAR*   szTextualSid,
    IN OUT  DWORD*  pdwLinkType,
    IN OUT  DWORD*  pdwLinkSpeed,
    OUT     CHAR*   szPeerPhoneNumber,
    OUT     DWORD*  pdwSubEntryIndex,
    OUT     HPORT*  phPort,
    OUT     BYTE*   pbPhoneDelta,
    OUT     CHAR*   szPortName,
    IN      CHAR*   szBasePhoneNumber
)
{
    if (fServer && !fRouter)
    {
        return(FGetAvailableLinkNonRouterServer(
                fCallOut,
                pdwLinkType,
                pdwLinkSpeed,
                phPort,
                pbPhoneDelta,
                szBasePhoneNumber));
    }
    else
    {
        return(FGetAvailableLinkClientOrRouter(
                pPcbLocal,
                szPhonebookPath,
                szEntryName,
                fCallOut,
                fRouter,
                szTextualSid,
                pdwLinkType,
                pdwLinkSpeed,
                szPeerPhoneNumber,
                pdwSubEntryIndex,
                pbPhoneDelta,
                szPortName,
                szBasePhoneNumber));
    }
}

/*

Returns:
    VOID

Description:
    The PPP thread mustn't call RasDial. Otherwise, a deadlock will occur in 
    the following case. The user tries to hang up a connectoid from the UI. 
    RasHangUp acquires csStopLock, calls StopPPP, and waits for StopPPP to 
    return. Meanwhile, if the PPP thread calls RasDial, it will wait for 
    csStopLock.

*/

VOID
RasDialThreadFunc(
    IN  VOID*   pVoid
)
{
    RASDIAL_ARGS*   pRasDialArgs        = pVoid;
    RASDIALPARAMS*  pRasDialParams;
    HRASCONN        hRasConn            = NULL;
    HRASCONN        hRasConnSubEntry    = NULL;
    PCB_WORK_ITEM*  pWorkItem;
    DWORD           dwErr;

    PPP_ASSERT(NULL != pRasDialArgs);

    pRasDialParams = &(pRasDialArgs->RasDialParams);

    BapTrace("Dialing %s using %s(%d)...",
        pRasDialParams->szPhoneNumber, 
        pRasDialParams->szEntryName,
        pRasDialParams->dwSubEntry);

    DecodePw(pRasDialArgs->chSeed, pRasDialArgs->RasDialParams.szPassword);        

    dwErr = RasDial(
                &(pRasDialArgs->RasDialExtensions),
                pRasDialArgs->szPhonebookPath,
                &(pRasDialArgs->RasDialParams),
                2 /* dwNotifierType */,
                NULL,
                &hRasConn);

    EncodePw(pRasDialArgs->chSeed, pRasDialArgs->RasDialParams.szPassword);

    BapTrace(" ");
    BapTrace("RasDial returned %d on HCONN 0x%x",
        dwErr, pRasDialArgs->RasDialParams.dwCallbackId);

    if (NO_ERROR != dwErr)
    {
        goto LDone;
    }

    // By this time, PPP has been negotiated on the new link and the new link 
    // has been bundled or not (if the user disconnected the connection). If it 
    // has not been bundled, then pRasDialArgs->hRasConn is invalid and
    // RasGetSubEntryHandle will fail.

    if (pRasDialArgs->fServerRouter)
    {
        hRasConnSubEntry = hRasConn;
    }
    else
    {
        dwErr = RasGetSubEntryHandle(pRasDialArgs->hRasConn,
                    pRasDialParams->dwSubEntry, &hRasConnSubEntry);

        if (NO_ERROR != dwErr)
        {
            BapTrace("RasGetSubEntryHandle failed and returned %d", dwErr);
            goto LDone;
        }
    }

LDone:

    pWorkItem = (PCB_WORK_ITEM*) LOCAL_ALLOC(LPTR, sizeof(PCB_WORK_ITEM));

    if (pWorkItem == NULL)
    {
        dwErr = GetLastError();
        BapTrace("Couldn't allocate memory for ProcessCallResult");
    }
    else
    {
        // Inform the worker thread that we know the result of the 
        // call attempt.
        pWorkItem->Process = ProcessCallResult;
        pWorkItem->hConnection = (HCONN)
                                    (pRasDialArgs->RasDialParams.dwCallbackId);
        pWorkItem->PppMsg.BapCallResult.dwResult = dwErr;
        pWorkItem->PppMsg.BapCallResult.hRasConn = hRasConnSubEntry;
        InsertWorkItemInQ(pWorkItem);
    }

    if (NO_ERROR != dwErr)
    {
        if (NULL != hRasConnSubEntry)
        {
            // Perhaps we couldn't alloc a PCB_WORK_ITEM.
            dwErr = RasHangUp(hRasConnSubEntry);
        }

        if (NULL != hRasConn)
        {
            dwErr = RasHangUp(hRasConn);
        }

        if (0 != dwErr)
        {
            BapTrace("RasHangup failed and returned %d", dwErr);
        }
    }

    if (NULL != pRasDialArgs->pbEapInfo)
    {
        LOCAL_FREE(pRasDialArgs->pbEapInfo);
    }
    LOCAL_FREE(pRasDialArgs->szPhonebookPath);
    LOCAL_FREE(pRasDialArgs);
}

/*

Returns:
    TRUE: Success
    FALSE: Failure

Description:
    Places a call to the peer. pBcbLocal represents the bundle that wants to
    call.

*/

BOOL
FCall(
    IN  BCB*    pBcbLocal
)
{
    NTSTATUS            Status;
    DWORD               dwErr;
    BAPCB*              pBapCbLocal;
    PPP_MESSAGE         PppMsg;
    BOOL                fRouter;
    BOOL                fServer;
    BOOL                fClientOrRouter;
    DWORD               dwBytesRead;
    PCB*                pPcbLocal;
    BOOL                fRet                = FALSE;
    RASMAN_INFO         RasmanInfo;
    RASDIAL_ARGS*       pRasDialArgs        = NULL;
    RASDIALPARAMS*      pRasDialParams;
    RASDIALEXTENSIONS*  pRasDialExtensions;

    PPP_ASSERT(NULL != pBcbLocal);

    pBapCbLocal = &(pBcbLocal->BapCb);

    pRasDialArgs = LOCAL_ALLOC(LPTR, sizeof(RASDIAL_ARGS));
    if (NULL == pRasDialArgs)
    {
        BapTrace("Out of memory. Can't call on HCONN 0x%x",
            pBcbLocal->hConnection);
        goto LDone;
    }
	pRasDialArgs->chSeed = pBcbLocal->chSeed;
    pRasDialParams = &(pRasDialArgs->RasDialParams);
    pRasDialExtensions = &(pRasDialArgs->RasDialExtensions);

    fServer = (pBcbLocal->fFlags & BCBFLAG_IS_SERVER) != 0;
    fRouter =
        (ROUTER_IF_TYPE_FULL_ROUTER == pBcbLocal->InterfaceInfo.IfType);
    fClientOrRouter = !fServer || fRouter;

    ZeroMemory(&PppMsg, sizeof(PppMsg));

    if (!pBapCbLocal->fPeerSuppliedPhoneNumber)
    {
        PPP_ASSERT(fClientOrRouter);
        pRasDialParams->szPhoneNumber[0] = 0;
    }
    else
    {
        PPP_ASSERT(NULL != pBapCbLocal->pbPhoneDeltaRemote);

        if (!FReadPhoneDelta(
                fClientOrRouter ?
                    pRasDialParams->szPhoneNumber :
                    PppMsg.ExtraInfo.BapCallbackRequest.szCallbackNumber,
                fServer ? pBapCbLocal->szClientPhoneNumber :
                          pBapCbLocal->szServerPhoneNumber,
                pBapCbLocal->pbPhoneDeltaRemote +
                    pBapCbLocal->dwPhoneDeltaRemoteOffset,
                &dwBytesRead))
        {
            goto LDone;
        }
        else
        {
            pBapCbLocal->dwPhoneDeltaRemoteOffset += dwBytesRead;
        }
    }

    pPcbLocal = GetPCBPointerFromBCB(pBcbLocal);
    if (NULL == pPcbLocal)
    {
        BapTrace("FCall: No links in HCONN 0x%x!", pBcbLocal->hConnection);
        goto LDone;
    }

    if (!fClientOrRouter)
    {
        // Non-router server
        // Don't call RasDial. Instead ask Ddm to call

        PppMsg.hPort = pBapCbLocal->hPort;
        PppMsg.dwMsgId = PPPDDMMSG_BapCallbackRequest;

        PppMsg.ExtraInfo.BapCallbackRequest.hConnection =
            pBcbLocal->hConnection;

        PppConfigInfo.SendPPPMessageToDdm(&PppMsg);

        BapTrace("Dialing %s on port %d...",
            PppMsg.ExtraInfo.BapCallbackRequest.szCallbackNumber,
            pBapCbLocal->hPort);
    }
    else
    {
        dwErr = RasGetInfo(NULL, pPcbLocal->hPort, &RasmanInfo);
        if (NO_ERROR != dwErr)
        {
            BapTrace("RasGetInfo failed on hPort %d. Error: %d",
                pPcbLocal->hPort, dwErr);
            goto LDone;
        }

        pRasDialArgs->hRasConn = RasmanInfo.RI_ConnectionHandle;

        pRasDialExtensions->dwSize = sizeof(RASDIALEXTENSIONS);

        if (fRouter)
        {
            pRasDialArgs->fServerRouter = fServer;
            pRasDialExtensions->dwfOptions = RDEOPT_Router;
            CopyMemory(&(pRasDialArgs->InterfaceInfo),
                &(pBcbLocal->InterfaceInfo), sizeof(PPP_INTERFACE_INFO));
            pRasDialExtensions->reserved
                = (ULONG_PTR)&(pRasDialArgs->InterfaceInfo);
        }

        if (   (NULL != pBcbLocal->pCustomAuthUserData)
            && (0 != pBcbLocal->pCustomAuthUserData->cbCustomAuthData))
        {
            pRasDialArgs->pbEapInfo = LOCAL_ALLOC(LPTR,
                pBcbLocal->pCustomAuthUserData->cbCustomAuthData);
            if (NULL == pRasDialArgs->pbEapInfo)
            {
                BapTrace("Out of memory. Can't call on HCONN 0x%x",
                    pBcbLocal->hConnection);
                goto LDone;
            }
            CopyMemory(pRasDialArgs->pbEapInfo,
                pBcbLocal->pCustomAuthUserData->abCustomAuthData,
                pBcbLocal->pCustomAuthUserData->cbCustomAuthData);

            pRasDialExtensions->RasEapInfo.dwSizeofEapInfo =
                pBcbLocal->pCustomAuthUserData->cbCustomAuthData;
            pRasDialExtensions->RasEapInfo.pbEapInfo =
                pRasDialArgs->pbEapInfo;

            if (pBcbLocal->fFlags & BCBFLAG_LOGON_USER_DATA)
            {
                pRasDialExtensions->dwfOptions = RDEOPT_NoUser;
            }
        }

        pRasDialParams->dwSize = sizeof(RASDIALPARAMS);
        lstrcpy(pRasDialParams->szEntryName, pBcbLocal->szEntryName);
        lstrcpy(pRasDialParams->szUserName, pBcbLocal->szLocalUserName);
        lstrcpy(pRasDialParams->szPassword, pBcbLocal->szPassword);
        lstrcpy(pRasDialParams->szDomain, pBcbLocal->szLocalDomain);
        pRasDialParams->dwCallbackId = HandleToUlong(pBcbLocal->hConnection);
        pRasDialParams->dwSubEntry = pBapCbLocal->dwSubEntryIndex;

        pRasDialArgs->szPhonebookPath =
            LOCAL_ALLOC(LPTR, strlen(pBcbLocal->szPhonebookPath) + 1);
        if (NULL == pRasDialArgs->szPhonebookPath)
        {
            BapTrace("Out of memory. Can't call on HCONN 0x%x",
                pBcbLocal->hConnection);
            goto LDone;
        }
        lstrcpy(pRasDialArgs->szPhonebookPath, pBcbLocal->szPhonebookPath);

        Status = RtlQueueWorkItem( RasDialThreadFunc, pRasDialArgs,
                    WT_EXECUTEDEFAULT);

        if (STATUS_SUCCESS != Status)
        {
            BapTrace("RtlQueueWorkItem failed and returned %d", Status);
            goto LDone;
        }

        pRasDialArgs = NULL; // This will be freed by RasDialThreadFunc
    }

    fRet = TRUE;

LDone:

    if (NULL != pRasDialArgs)
    {
        if (NULL != pRasDialArgs->szPhonebookPath)
        {
            LOCAL_FREE(pRasDialArgs->szPhonebookPath);
        }

        if (NULL != pRasDialArgs->pbEapInfo)
        {
            LOCAL_FREE(pRasDialArgs->pbEapInfo);
        }

        LOCAL_FREE(pRasDialArgs);
    }

    return(fRet);
}

/*

Returns:
    TRUE: Success
    FALSE: Failure

Description:
    pBcbLocal represents the bundle that wants to call. pBapCbRemote is filled 
    with the options sent by the peer. This function allocates 
    pbPhoneDeltaRemote and sets dwPhoneDeltaRemoteOffset and 
    fPeerSuppliedPhoneNumber in pBapCbLocal before calling FCall to do the 
    actual work.

*/

BOOL
FCallInitial(
    IN  BCB*    pBcbLocal,
    IN  BAPCB*  pBapCbRemote
)
{
    BAPCB*  pBapCbLocal;
    BOOL    fCall;
    BOOL    fRet;

    PPP_ASSERT(NULL != pBcbLocal);
    PPP_ASSERT(NULL != pBapCbRemote);

    pBapCbLocal = &(pBcbLocal->BapCb);

    // If the peer is responding to our Call-Request and we had sent the 
    // No-Phone-Number-Needed option, we don't need any phone number. In all 
    // other cases, the peer must have supplied a phone number.

    fCall = (BAP_PACKET_CALL_RESP == pBapCbRemote->dwType);
    pBapCbLocal->fPeerSuppliedPhoneNumber =
        !(fCall && (pBapCbLocal->dwOptions & BAP_N_NO_PH_NEEDED));

    // pbPhoneDeltaRemote is initially NULL and we always set it to NULL after
    // we deallocate it.
    PPP_ASSERT(NULL == pBapCbLocal->pbPhoneDeltaRemote);

    if (pBapCbLocal->fPeerSuppliedPhoneNumber)
    {
        pBapCbLocal->pbPhoneDeltaRemote =
            LOCAL_ALLOC(LPTR, BAP_PHONE_DELTA_SIZE + 1);

        if (NULL == pBapCbLocal->pbPhoneDeltaRemote)
        {
            BapTrace("Out of memory");
            fRet = FALSE;
            goto LDone;
        }

        if (NULL != pBapCbLocal->pbPhoneDeltaRemote)
        {
            CopyMemory(pBapCbLocal->pbPhoneDeltaRemote,
                pBapCbRemote->pbPhoneDelta,
                BAP_PHONE_DELTA_SIZE + 1);
            pBapCbLocal->dwPhoneDeltaRemoteOffset = 0;

            // FReadOptions() makes sure that there is at least one Phone-Delta
            PPP_ASSERT(0 != pBapCbLocal->pbPhoneDeltaRemote[0]);
        }
    }

    fRet = FCall(pBcbLocal);

    if (!fRet)
    {
        if (NULL != pBapCbLocal->pbPhoneDeltaRemote)
        {
            LOCAL_FREE(pBapCbLocal->pbPhoneDeltaRemote);
        }
        pBapCbLocal->pbPhoneDeltaRemote = NULL;
    }
    else
    {
        // BapEventCallResult will get called at some point, and we will free
        // pBapCbLocal->pbPhoneDeltaRemote.
    }

LDone:

    return(fRet);
}

/*

Returns:
    TRUE: Success
    FALSE: Failure

Description:
    Listens for incoming calls on the port named szPortName. dwSubEntryIndex is 
    the index of the phonebook sub entry that corresponds to that port. 
    pPcbLocal is any PCB in the bbundle that wants to do the listen. This 
    function should be called by non-router clients only.

*/

BOOL
FListenForCall(
    IN  CHAR*   szPortName,
    IN  DWORD   dwSubEntryIndex,
    IN  PCB*    pPcbLocal
)
{
    DWORD       dwErr;
    HPORT       hPort;
    BOOL        fCloseHPort = FALSE;
    PCB*        pPcbOther;
    PCB*        pPcbNew     = NULL;
    DWORD       dwIndex;
    RASMAN_INFO RasmanInfo;
    BOOL        fRet        = FALSE;
    HCONN       hConnection;

    PPP_ASSERT(NULL != szPortName);
    PPP_ASSERT(NULL != pPcbLocal);

    hConnection = pPcbLocal->pBcb->hConnection;

    dwErr = RasGetInfo(NULL, pPcbLocal->hPort, &RasmanInfo);
    if (NO_ERROR != dwErr)
    {
        BapTrace("RasGetInfo failed on hPort %d. Error: %d",
            pPcbLocal->hPort, dwErr);
        goto LDone;
    }

    pPcbNew = (PCB *)LOCAL_ALLOC(LPTR, sizeof(PCB));
    if (NULL == pPcbNew)
    {
        BapTrace("Out of memory. Can't accept a call on HCONN 0x%x",
            hConnection);
        goto LDone;
    }

    dwErr = AllocateAndInitBcb(pPcbNew);
    if (NO_ERROR != dwErr)
    {
        BapTrace("Out of memory. Can't accept a call on HCONN 0x%x",
            hConnection);
        goto LDone;
    }

    dwErr = RasPortOpen(szPortName, &hPort, NULL /* notifier */);
    if (NO_ERROR != dwErr)
    {
        BapTrace("RasPortOpen failed on HCONN 0x%x. Error: %d",
            hConnection, dwErr);
        goto LDone;
    }
    fCloseHPort = TRUE;

    pPcbOther = GetPCBPointerFromhPort(hPort);

    if (NULL != pPcbOther)
    {
        BapTrace("hPort %d not cleaned up yet", hPort);
        goto LDone;
    }

    dwErr = RasAddConnectionPort(RasmanInfo.RI_ConnectionHandle, hPort, 
                dwSubEntryIndex);
    if (NO_ERROR != dwErr)
    {
        BapTrace("RasAddConnectionPort failed with hPort %d and HRASCONN 0x%x. "
            "Error: %d",
            hPort, RasmanInfo.RI_ConnectionHandle, dwErr);
        goto LDone;
    }

    dwIndex = HashPortToBucket(hPort);

    dwErr = RasPortListen(hPort, PppConfigInfo.dwBapListenTimeoutSeconds,
                INVALID_HANDLE_VALUE);
    if (NO_ERROR != dwErr && PENDING != dwErr)
    {
        BapTrace("RasPortListen failed on HCONN 0x%x. Error: %d",
            hConnection, dwErr);
        goto LDone;
    }

    BapTrace("RasPortListen called on hPort %d for HCONN 0x%x",
        hPort, hConnection);

    pPcbNew->hPort = hPort;
    pPcbNew->hConnection = hConnection;
    pPcbNew->fFlags = PCBFLAG_PORT_IN_LISTENING_STATE;
    lstrcpy(pPcbNew->szPortName, szPortName);

    // Insert NewPcb into PCB hash table
    PppLog(2, "Inserting port in bucket # %d", dwIndex);
    pPcbNew->pNext = PcbTable.PcbBuckets[dwIndex].pPorts;
    PcbTable.PcbBuckets[dwIndex].pPorts = pPcbNew;

    fRet = TRUE;

    pPcbLocal->pBcb->fFlags |= BCBFLAG_LISTENING;

LDone:

    if (!fRet)
    {
        if (NULL != pPcbNew)
        {
            DeallocateAndRemoveBcbFromTable(pPcbNew->pBcb);
            LOCAL_FREE(pPcbNew);
        }

        if (fCloseHPort)
        {
            RasPortClose(hPort);
        }
    }

    return(fRet);
}

/*

Returns:
    TRUE: We are willing to add a link to the bundle
    FALSE: No more links in the bundle right now

Description:
    Considers the bandwidth utilization on the bundle represented by pBcbLocal 
    and says whether the BAP policy allows us to add another link.

    When the server receives a call[back] request, it will ACK if the 
    utilization is more than the lower threshold for the sample period and the 
    user's max link limit has not been reached. Otherwise, it will NAK.

    When a client receives a call[back] request, it will ACK if the utilization
    is more than the upper threshold for the sample period. Otherwise, it will
    NAK.

*/

BOOL
FOkToAddLink(
    IN BCB *    pBcbLocal
)
{
    PCB*                            pPcbLocal;
    RAS_GET_BANDWIDTH_UTILIZATION   Util;
    DWORD                           dwLowThreshold;
    DWORD                           dwHighThreshold;
    DWORD                           dwUpPeriod;
    DWORD                           dwDownPeriod;
    DWORD                           dwErr;

    return(TRUE);
#if 0
    pPcbLocal = GetPCBPointerFromBCB(pBcbLocal);
    if (NULL == pPcbLocal)
    {
        BapTrace("FOkToAddLink: No links in HCONN 0x%x!",
            pBcbLocal->hConnection);
        return(FALSE);
    }

    dwErr = RasGetBandwidthUtilization(pPcbLocal->hPort, &Util);
    if (NO_ERROR != dwErr)
    {
        BapTrace("RasGetBandwidthUtilization failed and returned %d", dwErr);
        return(FALSE);
    }

    dwDownPeriod = pBcbLocal->BapParams.dwHangUpExtraSampleSeconds;
    dwUpPeriod = pBcbLocal->BapParams.dwDialExtraSampleSeconds;

    BapTrace("Utilization: "
        "%d sec: (Xmit: %d%%, Recv: %d%%), "
        "%d sec: (Xmit: %d%%, Recv: %d%%)",
        dwUpPeriod, Util.ulUpperXmitUtil, Util.ulUpperRecvUtil,
        dwDownPeriod, Util.ulLowerXmitUtil, Util.ulLowerRecvUtil);

    dwLowThreshold = pBcbLocal->BapParams.dwHangUpExtraPercent;
    dwHighThreshold = pBcbLocal->BapParams.dwDialExtraPercent;

    if (pBcbLocal->fFlags & BCBFLAG_IS_SERVER)
    {
        if (   (Util.ulLowerXmitUtil > dwLowThreshold)
            || (Util.ulLowerRecvUtil > dwLowThreshold))
        {
            return(TRUE);
        }
    }
    else
    {
        if (   (Util.ulUpperXmitUtil > dwHighThreshold)
            || (Util.ulUpperRecvUtil > dwHighThreshold))
        {
            return(TRUE);
        }
    }

    return(FALSE);
#endif
}

/*

Returns:
    TRUE: We are willing to drop a link from the bundle
    FALSE: We need all the links in the bundle

Description:
    Considers the bandwidth utilization on the bundle represented by pBcbLocal 
    and says whether the BAP policy allows us to drop a link.

    When the server receives a drop request, it will always ACK.

    When a client receives a drop request, it will ACK if the utilization is
    less than the lower threshold for the sample period. Otherwise, it will NAK.
*/

BOOL
FOkToDropLink(
    IN BCB *    pBcbLocal,
    IN BAPCB *  pBapCbRemote
)
{
    PCB*                            pPcbLocal;
    RAS_GET_BANDWIDTH_UTILIZATION   Util;
    DWORD                           dwLowThreshold;
    DWORD                           dwUpPeriod;
    DWORD                           dwDownPeriod;
    DWORD                           dwErr;

    if (pBcbLocal->fFlags & BCBFLAG_IS_SERVER)
    {
        return(TRUE);
    }

    pPcbLocal = GetPCBPointerFromBCB(pBcbLocal);
    if (NULL == pPcbLocal)
    {
        BapTrace("FOkToAddLink: No links in HCONN 0x%x!",
            pBcbLocal->hConnection);
        return(FALSE);
    }

    dwErr = RasGetBandwidthUtilization(pPcbLocal->hPort, &Util);
    if (NO_ERROR != dwErr)
    {
        BapTrace("RasGetBandwidthUtilization failed and returned %d", dwErr);
        return(FALSE);
    }

    dwDownPeriod = pBcbLocal->BapParams.dwHangUpExtraSampleSeconds;
    dwUpPeriod = pBcbLocal->BapParams.dwDialExtraSampleSeconds;

    BapTrace("Utilization: "
        "%d sec: (Xmit: %d%%, Recv: %d%%), "
        "%d sec: (Xmit: %d%%, Recv: %d%%)",
        dwUpPeriod, Util.ulUpperXmitUtil, Util.ulUpperRecvUtil,
        dwDownPeriod, Util.ulLowerXmitUtil, Util.ulLowerRecvUtil);

    dwLowThreshold = pBcbLocal->BapParams.dwHangUpExtraPercent;

    if (   (Util.ulLowerXmitUtil < dwLowThreshold)
        && (Util.ulLowerRecvUtil < dwLowThreshold))
    {
        return(TRUE);
    }

    return(FALSE);
}

/*

Returns:
    TRUE: Upper limit reached
    FALSE: Upper limit not reached

Description:
    Returns TRUE iff we can add another link to the multilink bundle 
    represented by pBclLocal. This function is used to Full-Nak a 
    Call[back]-Request.

*/

BOOL
FUpperLimitReached(
    IN BCB *    pBcbLocal
)
{
    if (NumLinksInBundle(pBcbLocal) >= pBcbLocal->dwMaxLinksAllowed)
    {
        return(TRUE);
    }

    return(FALSE);
}

/*

Returns:
    TRUE: Success
    FALSE: Failure

Description:
    Fills in some of the fields of pBcbLocal->BapCb (our BapCb) by considering 
    pBapCbRemote (the BapCb sent by the peer). dwPacketType is the type of 
    packet that we want to send.

    For all packet types:
        dwType      = dwPacketType
        dwOptions   = the options (see BAP_N_*), whose values have been set

    BAP_PACKET_CALL_REQ:
        dwLinkType, dwLinkSpeed

    BAP_PACKET_CALL_RESP:
        dwLink-Type+, pbPhoneDelta+

    BAP_PACKET_CALLBACK_REQ:
        dwLinkType, dwLinkSpeed, pbPhoneDelta

    BAP_PACKET_CALLBACK_RESP:
        dwLink-Type+

    BAP_PACKET_DROP_REQ:
        dwLinkDiscriminator

    + indicates that the field may not be filled in.
*/

BOOL
FFillBapCb(
    IN  DWORD   dwPacketType,
    OUT BCB*    pBcbLocal,
    IN  BAPCB*  pBapCbRemote
)
{
    DWORD   dwOptions   = 0;
    BOOL    fResult     = TRUE;
    BOOL    fServer;
    BOOL    fRouter;
    PCB*    pPcbLocal;
    LCPCB*  pLcpCb;
    BAPCB*  pBapCbLocal;
    BOOL    fCall;
    BOOL    fGetOurPhoneNumber;
    DWORD   dwLength;

    PPP_ASSERT(NULL != pBcbLocal);
    pBapCbLocal = &(pBcbLocal->BapCb);
    PPP_ASSERT(BAP_STATE_INITIAL == pBapCbLocal->BapState);

    if (((BAP_PACKET_CALL_REQ == dwPacketType) &&
         (pBcbLocal->fFlags & BCBFLAG_PEER_CANT_ACCEPT_CALLS)) ||
        ((BAP_PACKET_CALLBACK_REQ == dwPacketType) &&
         (pBcbLocal->fFlags & BCBFLAG_PEER_CANT_CALL)))
    {
        BapTrace("FFillBapCb: Peer rejects %s",
            BAP_PACKET_CALL_REQ == dwPacketType ? "Call-Requests" :
                                                  "Callback-Requests");
        fResult = FALSE;
        goto LDone;
    }

    pPcbLocal = GetPCBPointerFromBCB(pBcbLocal);
    if (NULL == pPcbLocal)
    {
        BapTrace("FFillBapCb: No links in HCONN 0x%x!", pBcbLocal->hConnection);
        fResult = FALSE;
        goto LDone;
    }

    fServer = (pBcbLocal->fFlags & BCBFLAG_IS_SERVER) != 0;
    fRouter =
        (ROUTER_IF_TYPE_FULL_ROUTER == pBcbLocal->InterfaceInfo.IfType);

    if (dwPacketType == BAP_PACKET_CALL_REQ ||
        dwPacketType == BAP_PACKET_CALLBACK_REQ ||
        dwPacketType == BAP_PACKET_CALL_RESP ||
        dwPacketType == BAP_PACKET_CALLBACK_RESP)
    {
        if (FUpperLimitReached(pBcbLocal))
        {
            BapTrace("FFillBapCb: Link limit reached on HCONN 0x%x: %d",
                pBcbLocal->hConnection,
                pBcbLocal->dwMaxLinksAllowed);
            fResult = FALSE;
            goto LDone;
        }
    }

    switch(dwPacketType)
    {
    case BAP_PACKET_CALL_REQ:
    case BAP_PACKET_CALLBACK_REQ:

        PPP_ASSERT(!fServer);
        
        fCall = (BAP_PACKET_CALL_REQ == dwPacketType);

        if (pBapCbRemote != NULL)
        {
            // The peer NAK'ed our Call-Request or Callback-Request and 
            // specified a different link type in the NAK.

            pBapCbLocal->dwLinkType = pBapCbRemote->dwLinkType;
            pBapCbLocal->dwLinkSpeed = pBapCbRemote->dwLinkSpeed;
        }
        else
        {
            // We don't have any link type preference

            pBapCbLocal->dwLinkType = 0;
        }

        if (!FGetAvailableLinkClientOrRouter(
                pPcbLocal,
                pBcbLocal->szPhonebookPath,
                pBcbLocal->szEntryName,
                fCall,
                fRouter,
                pBcbLocal->szTextualSid,
                &(pBapCbLocal->dwLinkType),
                &(pBapCbLocal->dwLinkSpeed),
                fCall ? pBapCbLocal->szPeerPhoneNumber : NULL,
                &(pBapCbLocal->dwSubEntryIndex),
                fCall ? NULL : pBapCbLocal->pbPhoneDelta,
                fCall ? NULL : pBapCbLocal->szPortName,
                NULL /* szBasePhoneNumber */))
        {
            BapTrace("FFillBapCb: Requested link type not available");
            fResult = FALSE;
            goto LDone;
        }

        dwOptions = BAP_N_LINK_TYPE;

        if (fCall)
        {
            if (pBapCbLocal->szPeerPhoneNumber[0])
            {
                dwOptions |= BAP_N_NO_PH_NEEDED;
            }
        }
        else
        {
            // If we ask for our phone number, FGetAvailableLinkClientOrRouter() 
            // must provide it or return FALSE
            PPP_ASSERT(pBapCbLocal->pbPhoneDelta[0]);

            dwOptions |= BAP_N_PHONE_DELTA;
        }
        
        break;

    case BAP_PACKET_CALL_RESP:
    case BAP_PACKET_CALLBACK_RESP:

        PPP_ASSERT(NULL != pBapCbRemote);

        fCall = (BAP_PACKET_CALL_RESP == dwPacketType);

        // We need to send our phone number to the peer if we are responding to 
        // a Call-Request and the peer has not sent the No-Phone-Number-Needed 
        // option.
        fGetOurPhoneNumber = fCall &&
            !(pBapCbRemote->dwOptions & BAP_N_NO_PH_NEEDED);

        // Case nRS:  fServer && !fRouter (Non-Router Servers)
        // Case CR:  !fServer ||  fRouter (Clients and Routers)
        // Case SR:   fServer ||  fRouter (Servers and Routers)

        if (FGetAvailableLink(
                pPcbLocal,
                fServer,
                fRouter,
                !fCall,
                pBcbLocal->szPhonebookPath,     // Meaningless in Case nRS
                pBcbLocal->szEntryName,         // Meaningless in Case nRS
                pBcbLocal->szTextualSid,        // Meaningless in Case SR
                &(pBapCbRemote->dwLinkType),
                &(pBapCbRemote->dwLinkSpeed),
                pBapCbLocal->szPeerPhoneNumber, // Meaningless in Case nRS
                &(pBapCbLocal->dwSubEntryIndex),// Meaningless in Case nRS
                &(pBapCbLocal->hPort),          // Meaningless in Case CR
                fGetOurPhoneNumber ? pBapCbLocal->pbPhoneDelta : NULL,

                // Meaningless in Case SR
                fCall ? pBapCbLocal->szPortName : NULL,

                fGetOurPhoneNumber && fServer ?
                    pBapCbLocal->szServerPhoneNumber : NULL))
        {
            if (fGetOurPhoneNumber)
            {
                // If we ask for our phone number, FGetAvailableLink()
                // must provide it or return FALSE
                PPP_ASSERT(pBapCbLocal->pbPhoneDelta[0]);

                dwOptions = BAP_N_PHONE_DELTA;
            }
        }
        else
        {
            // We don't have the link type requested. Fill BapCb with
            // details of a link type that we do have.

            BapTrace("FFillBapCb: Requested link type not available. "
                "Let us tell the peer what we have.");

            fResult = FALSE;

            // If fGetOurPhoneNumber, assume that the peer doesn't have any 
            // phone number. So send him a new link type only if we have its 
            // phone number.

            // We don't have any link type preference
            pBapCbLocal->dwLinkType = 0;

            if (FGetAvailableLink(
                    pPcbLocal,
                    fServer,
                    fRouter,
                    !fCall,
                    pBcbLocal->szPhonebookPath,     // Meaningless in Case nRS
                    pBcbLocal->szEntryName,         // Meaningless in Case nRS
                    pBcbLocal->szTextualSid,        // Meaningless in Case SR
                    &(pBapCbLocal->dwLinkType),
                    &(pBapCbLocal->dwLinkSpeed),
                    NULL /* szPeerPhoneNumber */,
                    NULL /* pdwSubEntryIndex */,
                    NULL /* phPort */,
                    NULL /* pbPhoneDelta */,
                    NULL /* szPortName */,
                    NULL /* szBasePhoneNumber */))
            {
                dwOptions = BAP_N_LINK_TYPE;
            }
        }

        break;

    case BAP_PACKET_DROP_REQ:

        if (NumLinksInBundle(pBcbLocal) <= 1)
        {
            BapTrace("FFillBapCb: Only one link in the bundle");
            fResult = FALSE;
        }
        else
        {
            // This will cause the link represented by pPcbLocal to get dropped.
            // This link happens to have the highest dwSubEntryIndex, so we are
            // happy.

            pLcpCb = (LCPCB*)(pPcbLocal->LcpCb.pWorkBuf);
            PPP_ASSERT(pLcpCb->Remote.Work.dwLinkDiscriminator <= 0xFFFF);
            pBapCbLocal->dwLinkDiscriminator =
                pLcpCb->Remote.Work.dwLinkDiscriminator;
            dwOptions = BAP_N_LINK_DISC;
        }

        break;
    }

LDone:    

    pBapCbLocal->dwType = dwPacketType;
    pBapCbLocal->dwOptions = dwOptions;
    return(fResult);
}

/*

Returns:
    void

Description:
    This function asks NdisWan to inform us if the bandwidth utilization for 
    the bundle represented by pBcb goes out of the desired range for a given 
    amount of time.

*/

VOID
BapSetPolicy(
    IN BCB * pBcb
)
{
    DWORD   dwLowThreshold;
    DWORD   dwHighThreshold;
    DWORD   dwLowSamplePeriod;
    DWORD   dwHighSamplePeriod;
    DWORD   dwErr;

    PPP_ASSERT(NULL != pBcb);

    dwLowThreshold      = pBcb->BapParams.dwHangUpExtraPercent;
    dwLowSamplePeriod   = pBcb->BapParams.dwHangUpExtraSampleSeconds;
    dwHighThreshold     = pBcb->BapParams.dwDialExtraPercent;
    dwHighSamplePeriod  = pBcb->BapParams.dwDialExtraSampleSeconds;

    dwErr = RasSetBapPolicy(pBcb->hConnection,
                dwLowThreshold, dwLowSamplePeriod,
                dwHighThreshold, dwHighSamplePeriod);

    if (NO_ERROR != dwErr)
    {
        BapTrace("RasPppSetBapPolicy returned error %d", dwErr);
        return;
    }

    BapTrace("BapSetPolicy on HCONN 0x%x: Low: %d%% for %d sec; "
        "High: %d%% for %d sec",
        pBcb->hConnection,
        dwLowThreshold, dwLowSamplePeriod,
        dwHighThreshold, dwHighSamplePeriod);
}

/*

Returns:
    void

Description:
    Increments dwId in pBcb->BapCb.

*/

VOID
IncrementId(
    IN BCB* pBcb
)
{
    DWORD*  pdwLastId;
    BYTE    bId;

    pdwLastId = &(pBcb->BapCb.dwId);
    bId = (BYTE)(*pdwLastId);
    
    // 0 -> FF -> 0 -> ...
    bId++;
    *pdwLastId = bId;
}

/*

Returns:
    void

Description:
    Used for displaying BAP packets. fReceived is TRUE iff the packet was 
    received from the peer. hPort represents the port on which the packet was 
    sent/received. pBcb represents the bundle that owns this packet. pPacket 
    points to the packet that was sent/received and cbPacket is the number of 
    bytes in the packet. 
    
*/

VOID
LogBapPacket(
    IN BOOL         fReceived,
    IN HPORT        hPort,
    IN BCB*         pBcb,
    IN PPP_PACKET*  pPacket,
    IN DWORD        cbPacket
)
{
    BAP_RESPONSE*   pBapResponse;
    DWORD           dwType;

    static CHAR* szBapResponseName[] =
    {
        "ACK",
        "NAK",
        "REJ",
        "FULL-NAK"
    };

    PPP_ASSERT(NULL != pBcb);
    PPP_ASSERT(NULL != pPacket);

    pBapResponse = (BAP_RESPONSE *)(pPacket->Information);
    dwType = pBapResponse->Type;
    
    BapTrace(" ");

    BapTrace("Number of links in HCONN 0x%x: %d", pBcb->hConnection,
        NumLinksInBundle(pBcb));
    BapTrace("%sBAP packet %s:",
        fReceived ? ">" : "<", fReceived ? "received" : "sent");
    BapTrace("%sType: %s, Length: %d, Id: 0x%x, HCONN: 0x%x, hPort: %d%s",
        fReceived ? ">" : "<",
        dwType <= BAP_PACKET_LIMIT ?
            SzBapPacketName[dwType] : "UNKNOWN",
        cbPacket, pBapResponse->Id,
        pBcb->hConnection, hPort,
        hPort == (HPORT) -1 ? " (not known)" : "");

    TraceDumpExA(DwBapTraceId,
        0x00010000 | TRACE_USE_MASK | TRACE_USE_MSEC,
        (CHAR*)pPacket, 
        cbPacket, 
        1,
        FALSE,
        fReceived ? ">" : "<");

    if (((dwType == BAP_PACKET_CALL_RESP) ||
         (dwType == BAP_PACKET_CALLBACK_RESP) ||
         (dwType == BAP_PACKET_DROP_RESP)) &&
        pBapResponse->ResponseCode <= BAP_RESPONSE_FULL_NAK)
    {
        BapTrace("%sResponse Code: %s", fReceived ? ">" : "<",
            szBapResponseName[pBapResponse->ResponseCode]);
    }
    
    BapTrace(" ");
}

/*

Returns:
    TRUE: Favored-Peer
    FALSE: not Favored-Peer

Description:
    Returns TRUE iff the peer represented by pBcb is the favored peer.

*/

BOOL
FFavoredPeer(
    IN BCB* pBcb
)
{
    DWORD   dwCpIndex;
    CPCB*   pCpCb;
    BACPCB* pBacpCb;
    PCB*    pPcb;

    dwCpIndex = GetCpIndexFromProtocol(PPP_BACP_PROTOCOL);
    PPP_ASSERT((DWORD)-1 != dwCpIndex);
    PPP_ASSERT(NULL != pBcb);

    pPcb = GetPCBPointerFromBCB(pBcb);

    if (NULL == pPcb)
    {
        BapTrace("FFavoredPeer: No links in HCONN 0x%x!", pBcb->hConnection);
        return(TRUE);
    }

    if (dwCpIndex != (DWORD)-1)
    {
        pCpCb = GetPointerToCPCB(pPcb, dwCpIndex);
        PPP_ASSERT(NULL != pCpCb);

        if (NULL != pCpCb)
        {
            pBacpCb = (BACPCB *)(pCpCb->pWorkBuf);

            /*

            The favored peer is the peer that transmits the lowest Magic-Number 
            in its Favored-Peer Configuration Option.

            */

            return(pBacpCb->dwLocalMagicNumber < pBacpCb->dwRemoteMagicNumber);
        }
    }

    return(TRUE);
}

/*

Returns:
    TRUE: Success
    FALSE: Failure

Description:
    Looks in the bundle represented by pBcb, for a link whose Link 
    Discriminator = dwLinkDiscriminator. If fRemote, the remote Link 
    Discriminator is used. Else the local one is used. Returns the pPcb of the 
    link in ppPcb.

*/

BOOL
FGetPcbOfLink(
    IN BCB*     pBcb,
    IN DWORD    dwLinkDiscriminator,
    IN BOOL     fRemote,
    OUT PCB**   ppPcb
)
{
    DWORD   dwForIndex;
    LCPCB*  pLcpCb;

    PPP_ASSERT(NULL != pBcb);
    PPP_ASSERT(0xFFFF >= dwLinkDiscriminator);
    PPP_ASSERT(NULL != ppPcb);

    for (dwForIndex = 0; dwForIndex < pBcb->dwPpcbArraySize; dwForIndex++)
    {
        // Look at all the ports in the bundle for the port with the right Link 
        // Discriminator.

        *ppPcb = pBcb->ppPcb[dwForIndex];

        if (*ppPcb != NULL)
        {
            pLcpCb = (LCPCB*)((*ppPcb)->LcpCb.pWorkBuf);
            PPP_ASSERT(NULL != pLcpCb);

            if (fRemote)
            {
                PPP_ASSERT(pLcpCb->Remote.Work.dwLinkDiscriminator <= 0xFFFF);
                if (pLcpCb->Remote.Work.dwLinkDiscriminator ==
                    dwLinkDiscriminator)
                {
                    return(TRUE);
                }
            }
            else
            {
                PPP_ASSERT(pLcpCb->Local.Work.dwLinkDiscriminator <= 0xFFFF);
                if (pLcpCb->Local.Work.dwLinkDiscriminator ==
                    dwLinkDiscriminator)
                {
                    return(TRUE);
                }
            }
        }
    }

    BapTrace("FGetPcbOfLink: There is no link in HCONN 0x%x, whose remote "
        "Link Disc is %d",
        pBcb->hConnection, dwLinkDiscriminator);

    *ppPcb = NULL;
    return(FALSE);
}

/*

Returns:
    TRUE: Success
    FALSE: Failure

Description:
    Scans the BAP Datagram Options in the PPP packet pPacket. dwPacketType is 
    the BAP Datagram Type (see BAP_PACKET_*). dwLength is the BAP Datagram 
    Length. pBapCbRemote (including dwType and dwOptions) is filled up using 
    these options.

*/

BOOL
FReadOptions(
    IN  PPP_PACKET* pPacket,
    IN  DWORD       dwPacketType,
    IN  DWORD       dwLength,
    OUT BAPCB*      pBapCbRemote
)
{
    PPP_OPTION* pOption;
    BYTE*       pbData;
    DWORD       dwIndex                 = 0;
    DWORD       dwUniqueDigits;
    DWORD       dwSubscribNumLength;
    BYTE*       pbNumberOption;
    BYTE*       pbSubAddrOption;
    DWORD       dwPhoneDeltaLength;

    PPP_ASSERT(NULL != pPacket);
    PPP_ASSERT(NULL != pBapCbRemote);
    
    if (dwPacketType > BAP_PACKET_LIMIT)
    {
        BapTrace("Unknown BAP Datagram Type: %d", dwPacketType);
        return(FALSE);
    }
    
    if (dwPacketType == BAP_PACKET_CALL_RESP ||
        dwPacketType == BAP_PACKET_CALLBACK_RESP ||
        dwPacketType == BAP_PACKET_DROP_RESP ||
        dwPacketType == BAP_PACKET_STAT_RESP)
    {
        if (BAP_RESPONSE_HDR_LEN > dwLength)
        {
            return(FALSE);
        }

        pOption = (PPP_OPTION *)(pPacket->Information + BAP_RESPONSE_HDR_LEN);
        dwLength -= BAP_RESPONSE_HDR_LEN;
    }
    else
    {
        if (PPP_CONFIG_HDR_LEN > dwLength)
        {
            return(FALSE);
        }

        pOption = (PPP_OPTION *)(pPacket->Information + PPP_CONFIG_HDR_LEN);
        dwLength -= PPP_CONFIG_HDR_LEN;
    }

    ZeroMemory(pBapCbRemote, sizeof(BAPCB));
    pBapCbRemote->dwType = dwPacketType;

    while(dwLength > 0)
    {
        if (0 == pOption->Length || dwLength < pOption->Length)
        {
            BapTrace("FReadOptions: Invalid BAP Datagram Length");
            return(FALSE);
        }

        dwLength -= pOption->Length;

        if (pOption->Type <= BAP_OPTION_LIMIT)
        {
            pBapCbRemote->dwOptions |= (1 << pOption->Type);
        }

        switch(pOption->Type)
        {
        case BAP_OPTION_LINK_TYPE:

            if (pOption->Length != PPP_OPTION_HDR_LEN + 3)
            {
                BapTrace("FReadOptions: Invalid length for Link-Type: %d",
                    pOption->Length);
                return(FALSE);
            }
            
            pBapCbRemote->dwLinkSpeed = WireToHostFormat16(pOption->Data);
            pBapCbRemote->dwLinkType = pOption->Data[2];

            if (0 == pBapCbRemote->dwLinkType)
            {
                // In FGetAvailableLink(), we interpret Link Type 0 to 
                // mean "any link"

                BapTrace("FReadOptions: Invalid Link-Type: 0");
                return(FALSE);
            }

            break;

        case BAP_OPTION_PHONE_DELTA:

            /*
            
            An implementation MAY include more than one Phone-Delta option in a 
            response.

            dwIndex is the index into pBapCbRemote->pbPhoneDelta where we should 
            start writing.

            If the only Sub-Options are Unique-Digits and Subscriber-Number, 
            the number of bytes we want to store is pOption->Length - 3. 

            Eg, if we get
                02 11 (01 3 4) (02 6 9 9 9 9)
            we store
                4 0 9 9 9 9 0 0, ie 11 - 3 = 8 bytes

            If Phone-Number-Sub-Address is also present, we will need 
            pOption->Length - 5 bytes in pBapCbRemote->pbPhoneDelta.

            Eg, if we get
                02 15 (01 3 4) (02 6 9 9 9 9) (03 4 9 9)
            we store
                4 0 9 9 9 9 0 9 9 0, ie 15 - 5 = 10 bytes

            pbPhoneDelta has BAP_PHONE_DELTA_SIZE + 1 bytes, and we put the 
            terminating 0 byte after we have read all the Options.

            */

            if (dwIndex + pOption->Length - 3 <= BAP_PHONE_DELTA_SIZE)
            {
                // Read the Phone-Delta option

                pbData = pOption->Data;
                dwPhoneDeltaLength = pOption->Length - PPP_OPTION_HDR_LEN;

                dwUniqueDigits = 0;
                pbNumberOption = pbSubAddrOption = NULL;

                while(dwPhoneDeltaLength > 0)
                {
                    /*

                    Read the Sub-Options.

                    If there are multiple Sub-Options of the same type (which 
                    shouldn't really happen), we remember only the last 
                    Sub-Option of each type.

                    */

                    // pbData[1] contains Sub-Option Length

                    if (2 > pbData[1] || dwPhoneDeltaLength < pbData[1])
                    {
                        BapTrace("FReadOptions: Invalid BAP Datagram "
                            "Sub-Option Length");
                        return(FALSE);
                    }

                    dwPhoneDeltaLength -= pbData[1];

                    // pbData[0] contains Sub-Option Type

                    switch(pbData[0])
                    {
                    case BAP_SUB_OPTION_UNIQUE_DIGITS:
                
                        if (pbData[1] != 3)
                        {
                            BapTrace("FReadOptions: Invalid length for "
                                "Unique-Digits: %d",
                                pbData[1]);
                            return(FALSE);
                        }

                        dwUniqueDigits = pbData[2];
                        break;

                    case BAP_SUB_OPTION_SUBSCRIB_NUM:

                        dwSubscribNumLength = pbData[1] - 2;

                        if (dwSubscribNumLength > MAX_PHONE_NUMBER_LEN)
                        {
                            BapTrace("FReadOptions: Subscriber-Number too "
                                "long: %d",
                                pbData[1] - 2);
                            return(FALSE);
                        }

                        pbNumberOption = pbData;

                        if (!FAsciiDigits(pbNumberOption + 2,
                                dwSubscribNumLength))
                        {
                            BapTrace("FReadOptions: Subscriber-Number contains "
                                "bytes other than ASCII digits");
                            return(FALSE);
                        }

                        break;

                    case BAP_SUB_OPTION_SUB_ADDR:

                        if (pbData[1] - 2 > MAX_PHONE_NUMBER_LEN)
                        {
                            BapTrace("FReadOptions: Phone-Number-Sub-Address "
                                "too long: %d",
                                pbData[1] - 2);
                            return(FALSE);
                        }

                        pbSubAddrOption = pbData;

                        if (!FAsciiDigits(pbSubAddrOption + 2,
                                pbSubAddrOption[1] - 2))
                        {
                            BapTrace("FReadOptions: Phone-Number-Sub-Address "
                                "contains bytes other than ASCII digits");
                            return(FALSE);
                        }
                        break;

                    default:

                        BapTrace("FReadOptions: Unknown Phone-Delta Sub-Option "
                            "Type %d",
                            pbData[0]);
                        break;
                    }

                    pbData += pbData[1];
                }

                if (pbNumberOption == NULL ||
                    dwUniqueDigits > dwSubscribNumLength)
                {
                    BapTrace("FReadOptions: Invalid Unique-Digits or "
                        "Subscriber-Number in Phone-Delta");
                    return(FALSE);
                }

                if (0 == dwUniqueDigits)
                {
                    // We cannot write 0 0 0. See BAPCB comments
                    pBapCbRemote->pbPhoneDelta[dwIndex++] = 0xFF;
                }
                else
                {
                    pBapCbRemote->pbPhoneDelta[dwIndex++] = (BYTE)dwUniqueDigits;
                    pBapCbRemote->pbPhoneDelta[dwIndex++] = 0;

                    CopyMemory(pBapCbRemote->pbPhoneDelta + dwIndex,
                       pbNumberOption + 2 + dwSubscribNumLength - dwUniqueDigits, 
                       dwSubscribNumLength);
                    dwIndex += pbNumberOption[1] - 2;
                    pBapCbRemote->pbPhoneDelta[dwIndex++] = 0;

                    if (pbSubAddrOption != NULL)
                    {
                        CopyMemory(pBapCbRemote->pbPhoneDelta + dwIndex,
                            pbSubAddrOption + 2, pbSubAddrOption[1] - 2);
                        dwIndex += pbSubAddrOption[1] - 2;
                    }
                    pBapCbRemote->pbPhoneDelta[dwIndex++] = 0;
                }
            }
            else if (dwIndex == 0)
            {
                // We were unable to read any Phone-Deltas
                BapTrace("FReadOptions: Couldn't read any Phone-Delta");
                return(FALSE);
            }
            
            break;
        
        case BAP_OPTION_NO_PH_NEEDED:
    
            if (pOption->Length != PPP_OPTION_HDR_LEN)
            {
                BapTrace("FReadOptions: Invalid length for "
                    "No-Phone-Number-Needed: %d",
                    pOption->Length);
                return(FALSE);
            }

            // In pBapCbRemote->dwOptions, we remember that we have seen this 
            // option. We don't need to do anything else.

            break;
        
        case BAP_OPTION_REASON:

            break;
        
        case BAP_OPTION_LINK_DISC:
    
            if (pOption->Length != PPP_OPTION_HDR_LEN + 2)
            {
                BapTrace("FReadOptions: Invalid length for "
                    "Link-Discriminator: %d",
                    pOption->Length);
                return(FALSE);
            }

            pBapCbRemote->dwLinkDiscriminator
                = WireToHostFormat16(pOption->Data);
        
            break;
        
        case BAP_OPTION_CALL_STATUS:
    
            if (pOption->Length != PPP_OPTION_HDR_LEN + 2)
            {
                BapTrace("FReadOptions: Invalid length for Call-Status: %d",
                    pOption->Length);
                return(FALSE);
            }

            pBapCbRemote->dwStatus = pOption->Data[0];
            pBapCbRemote->dwAction = pOption->Data[1];
        
            break;

        default:

            // Perhaps this is a new option that we don't recognize
            BapTrace("FReadOptions: Unknown BAP Datagram Option: 0x%x",
                pOption->Type);
            break;
        }

        pOption = (PPP_OPTION *)((BYTE*)pOption + pOption->Length);
    }

    // The terminating 0 byte in pbPhoneDelta.
    PPP_ASSERT(dwIndex <= BAP_PHONE_DELTA_SIZE + 1);
    pBapCbRemote->pbPhoneDelta[dwIndex++] = 0;

    if (g_dwMandatoryOptions[dwPacketType] & ~pBapCbRemote->dwOptions)
    {
        BapTrace("FReadOptions: Missing options: Scanned options: 0x%x, "
            "Mandatory options: 0x%x",
            pBapCbRemote->dwOptions, g_dwMandatoryOptions[dwPacketType]);

        return(FALSE);
    }
    else
    {
        return(TRUE);
    }
}

/*

Returns:
    TRUE: Success
    FALSE: Failure

Description:
    Writes one (or more in the case of Phone-Delta) BAP Datagram Option of type 
    dwOptionType (see BAP_OPTION_*) into **ppOption, by looking at the fields 
    in pBapCbLocal. *ppOption is updated to point to the place where the next 
    option should go. *pcbOption contains the number of free bytes in 
    *ppOption. It is decreased by the number of free bytes used up. *ppOption 
    and *pcbOption are not modified if the function returns FALSE.

*/

BOOL
FMakeBapOption(
    IN      BAPCB*          pBapCbLocal,
    IN      DWORD           dwOptionType,
    IN      PPP_OPTION**    ppOption,
    IN OUT  DWORD*          pcbOption
)
{
    DWORD           dwLength;
    DWORD           dwNumberOptionSize;
    DWORD           dwSubAddrOptionSize;
    BYTE*           pbData;
    DWORD           dwIndex;
    DWORD           dwTempIndex;
    DWORD           dwSubAddrIndex;
    DWORD           fAtLeastOnePhoneDelta   = FALSE;
    PPP_OPTION*     pOption;

    PPP_ASSERT(NULL != pBapCbLocal);
    PPP_ASSERT(NULL != ppOption);
    PPP_ASSERT(NULL != pcbOption);

    pOption = *ppOption;

    PPP_ASSERT(NULL != pOption);

    switch(dwOptionType)
    {
    case BAP_OPTION_LINK_TYPE:
    
        dwLength = PPP_OPTION_HDR_LEN + 3;
        if (*pcbOption < dwLength)
        {
            BapTrace("FMakeBapOption: Buffer too small for Link-Type. "
                "Size: %d, Reqd: %d",
                *pcbOption, dwLength);
            return(FALSE);
        }

        pOption->Length = (BYTE)dwLength;
        PPP_ASSERT(pBapCbLocal->dwLinkSpeed <= 0xFFFF);
        HostToWireFormat16((WORD)(pBapCbLocal->dwLinkSpeed), pOption->Data);
        PPP_ASSERT(pBapCbLocal->dwLinkType <= 0xFF);
        pOption->Data[2] = (BYTE)(pBapCbLocal->dwLinkType);
        
        break;
        
    case BAP_OPTION_PHONE_DELTA:

        dwIndex = 0;
        
        while (pBapCbLocal->pbPhoneDelta[dwIndex])
        {
            if (0xFF == pBapCbLocal->pbPhoneDelta[dwIndex])
            {
                // Unique-Digits is 0. See BAPCB comments

                dwNumberOptionSize = 2;
                dwSubAddrOptionSize = 0;
                dwTempIndex = dwIndex + 1;
            }
            else
            {
                // Write as many Phone-Delta options as possible

                dwTempIndex = dwIndex + 2;

                dwNumberOptionSize = 0;
                while (pBapCbLocal->pbPhoneDelta[dwTempIndex++])
                {
                    dwNumberOptionSize++;
                }
                PPP_ASSERT(dwNumberOptionSize <= MAX_PHONE_NUMBER_LEN);
                // Increase by 2 to accommodate Sub-Option Type and Sub-Option
                // Len
                dwNumberOptionSize += 2;

                dwSubAddrIndex = dwTempIndex;

                dwSubAddrOptionSize = 0;
                while (pBapCbLocal->pbPhoneDelta[dwTempIndex++])
                {
                    dwSubAddrOptionSize++;
                }
                PPP_ASSERT(dwSubAddrOptionSize <= MAX_PHONE_NUMBER_LEN);

                if (0 != dwSubAddrOptionSize)
                {
                    // Increase by 2 to accommodate Sub-Option Type and
                    // Sub-Option Len
                    dwSubAddrOptionSize += 2;
                }
            }

            dwLength = PPP_OPTION_HDR_LEN + 3 /* for Unique-Digits */ +
                dwNumberOptionSize + dwSubAddrOptionSize;
                   
            if (*pcbOption < dwLength || 0xFF < dwLength)
            {
                break;
            }

            pOption->Type = (BYTE)dwOptionType;
            pOption->Length = (BYTE)dwLength;
            pbData = pOption->Data;

            pbData[0] = BAP_SUB_OPTION_UNIQUE_DIGITS;
            pbData[1] = 3;
            pbData[2] = pBapCbLocal->pbPhoneDelta[dwIndex];
            if (0xFF == pbData[2])
            {
                // Unique-Digits is 0. See BAPCB comments
                pbData[2] = 0;
            }
            pbData += 3;

            pbData[0] = BAP_SUB_OPTION_SUBSCRIB_NUM;
            PPP_ASSERT(dwNumberOptionSize <= 0xFF);
            pbData[1] = (BYTE)dwNumberOptionSize;
            CopyMemory(pbData + 2, pBapCbLocal->pbPhoneDelta + dwIndex + 2, 
                dwNumberOptionSize - 2);
            pbData += dwNumberOptionSize;

            if (0 != dwSubAddrOptionSize)
            {
                pbData[0] = BAP_SUB_OPTION_SUB_ADDR;
                PPP_ASSERT(dwSubAddrOptionSize <= 0xFF);
                pbData[1] = (BYTE)dwSubAddrOptionSize;
                CopyMemory(pbData + 2,
                    pBapCbLocal->pbPhoneDelta + dwSubAddrIndex, 
                    dwSubAddrOptionSize - 2);
            }

            *pcbOption -= dwLength;
            pOption = (PPP_OPTION *)((BYTE *)pOption + dwLength);
            dwIndex = dwTempIndex;
            fAtLeastOnePhoneDelta = TRUE;
        }

        if (!fAtLeastOnePhoneDelta)
        {
            BapTrace("FMakeBapOption: Buffer too small for Phone-Delta. "
                "Size: %d, Reqd: %d",
                *pcbOption, dwLength);
            return(FALSE);
        }
        else
        {
            // We need to return from here. We don't want to set pOption->Type.
            *ppOption = pOption;
            return(TRUE);
        }
        
        break;
        
    case BAP_OPTION_NO_PH_NEEDED:
    
        dwLength = PPP_OPTION_HDR_LEN;
        if (*pcbOption < dwLength)
        {
            BapTrace("FMakeBapOption: Buffer too small for "
                "No-Phone-Number-Needed. Size: %d, Reqd: %d",
                *pcbOption, dwLength);
            return(FALSE);
        }

        pOption->Length = (BYTE)dwLength;
        break;
        
    case BAP_OPTION_REASON:

        dwLength = PPP_OPTION_HDR_LEN;
        break;
        
    case BAP_OPTION_LINK_DISC:
    
        dwLength = PPP_OPTION_HDR_LEN + 2;
        if (*pcbOption < dwLength)
        {
            BapTrace("FMakeBapOption: Buffer too small for Link-Discriminator. "
                "Size: %d, Reqd: %d",
                *pcbOption, dwLength);
            return(FALSE);
        }

        pOption->Length = (BYTE)dwLength;
        PPP_ASSERT(pBapCbLocal->dwLinkDiscriminator <= 0xFFFF);
        HostToWireFormat16((WORD)(pBapCbLocal->dwLinkDiscriminator),
            pOption->Data);
        
        break;
        
    case BAP_OPTION_CALL_STATUS:
    
        dwLength = PPP_OPTION_HDR_LEN + 2;
        if (*pcbOption < dwLength)
        {
            BapTrace("FMakeBapOption: Buffer too small for Call-Status. "
                "Size: %d, Reqd: %d",
                *pcbOption, dwLength);
            return(FALSE);
        }

        pOption->Length = (BYTE)dwLength;
        PPP_ASSERT(pBapCbLocal->dwStatus <= 0xFF);
        pOption->Data[0] = (BYTE)(pBapCbLocal->dwStatus);
        PPP_ASSERT(pBapCbLocal->dwAction <= 0xFF);
        pOption->Data[1] = (BYTE)(pBapCbLocal->dwAction);
        
        break;

    default:
        BapTrace("FMakeBapOption: Unknown BAP Datagram Option: %d. Ignoring.", 
            dwOptionType);
        return(FALSE);
    }

    *ppOption = (PPP_OPTION *)((BYTE *)pOption + dwLength);
    *pcbOption -= dwLength;
    pOption->Type = (BYTE)dwOptionType;
    return(TRUE);
}

/*

Returns:
    TRUE: Success
    FALSE: Failure

Description:
    Writes BAP Datagram Options specified by dwOptions (see BAP_N_*) into 
    pbData, by consulting pBapCbLocal. *pcbOptions contains the number of free 
    bytes in pbData. It is decreased by the number of free bytes used up. 
    *pcbOptions may be modified even if the function returns FALSE.

*/

BOOL
FBuildBapOptionList(
    IN      BAPCB*  pBapCbLocal,
    IN      DWORD   dwOptions,
    IN      BYTE*   pbData,
    IN OUT  DWORD*  pcbOptions
)
{
    DWORD           dwOptionType; 
    PPP_OPTION*     pOption;

    PPP_ASSERT(NULL != pBapCbLocal);
    PPP_ASSERT(NULL != pbData);
    PPP_ASSERT(NULL != pcbOptions);

    pOption = (PPP_OPTION *) pbData;

    for (dwOptionType = 1; dwOptionType <= BAP_OPTION_LIMIT;
         dwOptionType++) 
    {
        if (dwOptions & (1 << dwOptionType)) 
        {
            if (!FMakeBapOption(pBapCbLocal, dwOptionType, &pOption, 
                    pcbOptions))
            {
                return(FALSE);
            }
        }
    }

    return(TRUE);
}

/*

Returns:
    TRUE: Success
    FALSE: Failure

Description:
    Sends the BAP packet in pPcb->pSendBuf. dwId is the Identifier and dwLength 
    is the length of the BAP Datagram. We also add a timeout element so that we 
    can retransmit the datagram if it doesn't reach the peer. fInsertInTimerQ 
    is TRUE if an element has to be inserted in the timer queue.

*/

BOOL
FSendBapPacket(
    IN  PCB*    pPcb,
    IN  DWORD   dwId,
    IN  DWORD   dwLength,
    IN  BOOL    fInsertInTimerQ
)
{
    DWORD   dwErr;
    LCPCB*  pLcpCb;

    PPP_ASSERT(NULL != pPcb);
    PPP_ASSERT(0xFF >= dwId);
    
    pLcpCb = (LCPCB *)(LCPCB*)(pPcb->LcpCb.pWorkBuf);
    PPP_ASSERT(NULL != pLcpCb);

    if (dwLength > LCP_DEFAULT_MRU && dwLength > pLcpCb->Remote.Work.MRU)
    {
        BapTrace("FSendBapPacket: BAP packet too long. Length = %d. MRU = %d",
            dwLength, pLcpCb->Remote.Work.MRU);
        return(FALSE);
    }

    dwLength += PPP_PACKET_HDR_LEN;
    PPP_ASSERT(dwLength <= 0xFFFF);
    LogBapPacket(FALSE /* fReceived */, pPcb->hPort, pPcb->pBcb, pPcb->pSendBuf,
        dwLength);

    if ((dwErr = PortSendOrDisconnect(pPcb, dwLength)) != NO_ERROR)
    {
        BapTrace("FSendBapPacket: PortSendOrDisconnect failed and returned %d",
            dwErr);
        return(FALSE);
    }

    if (fInsertInTimerQ)
    {
        InsertInTimerQ(pPcb->pBcb->dwBundleId, pPcb->pBcb->hConnection, dwId, 
            PPP_BAP_PROTOCOL, FALSE /* fAuthenticator */, TIMER_EVENT_TIMEOUT,
            pPcb->RestartTimer);
    }

    return(TRUE);
}

/*

Returns:
    TRUE: Success
    FALSE: Failure

Description:
    Builds a BAP Request or Indication Datagram using the options specified by 
    pBcbLocal->BapCb.dwOptions and the values in pBcbLocal->BapCb and sends it.

*/

BOOL
FSendBapRequest(
    IN  BCB*   pBcbLocal
)
{
    DWORD           dwLength;
    BAPCB*          pBapCbLocal;
    PPP_CONFIG*     pSendConfig;
    PCB*            pPcb;

    PPP_ASSERT(NULL != pBcbLocal);

    pBapCbLocal = &(pBcbLocal->BapCb);
    pPcb = GetPCBPointerFromBCB(pBcbLocal);

    if (NULL == pPcb)
    {
        BapTrace("FSendBapRequest: No links in HCONN 0x%x!",
            pBcbLocal->hConnection);
        return(FALSE);
    }

    pSendConfig = (PPP_CONFIG *)(pPcb->pSendBuf->Information);
    
    // Remaining free space in buffer, ie size of pSendConfig->Data
    dwLength = LCP_DEFAULT_MRU - PPP_PACKET_HDR_LEN - PPP_CONFIG_HDR_LEN;
    
    if (!FBuildBapOptionList(pBapCbLocal, pBapCbLocal->dwOptions,
            pSendConfig->Data, &dwLength))
    {
        return(FALSE);
    }

    dwLength = LCP_DEFAULT_MRU - PPP_PACKET_HDR_LEN - dwLength;

    HostToWireFormat16(PPP_BAP_PROTOCOL, pPcb->pSendBuf->Protocol);

    PPP_ASSERT(pBapCbLocal->dwType <= 0xFF);
    pSendConfig->Code = (BYTE)(pBapCbLocal->dwType);
    PPP_ASSERT(pBapCbLocal->dwId <= 0xFF);
    pSendConfig->Id = (BYTE)(pBapCbLocal->dwId);
    PPP_ASSERT(dwLength <= 0xFFFF);
    HostToWireFormat16((WORD)dwLength, pSendConfig->Length);

    return(FSendBapPacket(pPcb, pBapCbLocal->dwId, dwLength,
        TRUE /* fInsertInTimerQ */));
}

/*

Returns:
    TRUE: Success
    FALSE: Failure

Description:
    Same as FSendBapRequest, except that pBcbLocal->BapCb.dwRetryCount is 
    initialized. FSendInitialBapRequest should be used to send the first BAP 
    Request or Indication Datagram and FSendBapRequest should be used to send 
    the subsequent datagrams after timeouts.

*/

BOOL
FSendInitialBapRequest(
    IN  BCB*    pBcbLocal
)
{
    BAPCB*  pBapCbLocal;

    PPP_ASSERT(NULL != pBcbLocal);
    pBapCbLocal = &(pBcbLocal->BapCb);

    pBapCbLocal->dwRetryCount = PppConfigInfo.MaxConfigure;
    if (BAP_PACKET_STATUS_IND == pBapCbLocal->dwType)
    {
        /*

        Call-Status-Indication packets MUST use the same Identifier as was used 
        by the original Call-Request or Callback-Request that was used to 
        initiate the call.

        */

        pBapCbLocal->dwId = pBapCbLocal->dwStatusIndicationId;
    }
    else
    {
        IncrementId(pBcbLocal);
    }

    return(FSendBapRequest(pBcbLocal));
}

/*

Returns:
    TRUE: Success
    FALSE: Failure

Description:
    Builds a BAP Response Datagram using the options specified by dwOptions and 
    the values in pBcbLocal->BapCb and sends it. The BAP Datagram Type, 
    Identifier, and Response Code are specified in dwType, dwId, and 
    dwResponseCode.

    We cannot use dwOptions and dwType from pBcbLocal->BapCb because we 
    sometimes call FSendBapResponse without calling FFillBapCb first. We may be 
    in a BAP_STATE_SENT_* at this point, and we don't want to modify 
    pBcbLocal->BapCb.

*/

BOOL
FSendBapResponse(
    IN  BCB*    pBcbLocal,
    IN  DWORD   dwOptions,
    IN  DWORD   dwType,
    IN  DWORD   dwId,
    IN  DWORD   dwResponseCode
)
{
    DWORD           dwLength;
    BAPCB*          pBapCbLocal;
    BAP_RESPONSE*   pBapResponse;
    PCB*            pPcb;

    PPP_ASSERT(NULL != pBcbLocal);

    pBapCbLocal = &(pBcbLocal->BapCb);
    pPcb = GetPCBPointerFromBCB(pBcbLocal);

    if (NULL == pPcb)
    {
        BapTrace("FSendBapResponse: No links in HCONN 0x%x!",
            pBcbLocal->hConnection);
        return(FALSE);
    }

    pBapResponse = (BAP_RESPONSE *)(pPcb->pSendBuf->Information);

    // Remaining free space in buffer, ie size of pBapResponse->Data
    dwLength = LCP_DEFAULT_MRU - PPP_PACKET_HDR_LEN - BAP_RESPONSE_HDR_LEN;

    if (!FBuildBapOptionList(pBapCbLocal, dwOptions, pBapResponse->Data,
            &dwLength))
    {
        return(FALSE);
    }

    dwLength = LCP_DEFAULT_MRU - PPP_PACKET_HDR_LEN - dwLength;

    HostToWireFormat16(PPP_BAP_PROTOCOL, pPcb->pSendBuf->Protocol);

    PPP_ASSERT(dwType <= 0xFF);
    pBapResponse->Type = (BYTE) dwType;
    PPP_ASSERT(dwId <= 0xFF);
    pBapResponse->Id = (BYTE) dwId;
    PPP_ASSERT(dwLength <= 0xFFFF);
    HostToWireFormat16((WORD)dwLength, pBapResponse->Length);
    PPP_ASSERT(dwResponseCode <= 0xFF);
    pBapResponse->ResponseCode = (BYTE) dwResponseCode;

    return(FSendBapPacket(pPcb, dwId, dwLength, FALSE /* fInsertInTimerQ */));
}

/*

Returns:
    void

Description:
    Called when NDISWAN determines that a link has to be added to the bundle 
    represented pBcbLocal

*/

VOID
BapEventAddLink(
    IN BCB*     pBcbLocal
)
{
    BAP_STATE*  pBapState;
    PCB*        pPcbLocal;
    BAPCB*      pBapCbLocal;

    PPP_ASSERT(NULL != pBcbLocal);
    pBapState = &(pBcbLocal->BapCb.BapState);
    PPP_ASSERT(BAP_STATE_LIMIT >= *pBapState);

    if (!(pBcbLocal->fFlags & BCBFLAG_CAN_DO_BAP))
    {
        BapTrace("BapEventAddLink called on HCONN 0x%x without BACP",
            pBcbLocal->hConnection);
        return;
    }

    BapTrace(" ");
    BapTrace("BapEventAddLink on HCONN 0x%x", pBcbLocal->hConnection);

    if (pBcbLocal->fFlags & BCBFLAG_LISTENING)
    {
        BapTrace("Still listening; must ignore BapEventAddLink");
        return;
    }

    switch(*pBapState)
    {
    case BAP_STATE_INITIAL:
        
        if (pBcbLocal->fFlags & BCBFLAG_CAN_ACCEPT_CALLS)
        {
            // If we can accept calls, we prefer to be called (to save us the 
            // cost of calling).

            if (FFillBapCb(BAP_PACKET_CALLBACK_REQ, pBcbLocal,
                    NULL /* pBapCbRemote */))
            {
                pPcbLocal = GetPCBPointerFromBCB(pBcbLocal);
                pBapCbLocal = &(pBcbLocal->BapCb);

                if (NULL == pPcbLocal)
                {
                    BapTrace("BapEventRecvCallOrCallbackReq: No links in "
                        "HCONN 0x%x!",
                        pBcbLocal->hConnection);
                    return;
                }

                if ((pBcbLocal->fFlags & BCBFLAG_IS_SERVER) ||
                    (ROUTER_IF_TYPE_FULL_ROUTER ==
                     pPcbLocal->pBcb->InterfaceInfo.IfType) ||
                    FListenForCall(pBapCbLocal->szPortName, 
                        pBapCbLocal->dwSubEntryIndex, pPcbLocal))
                {
                    // Servers and routers are already listening. We have to 
                    // call  FListenForCall() only for non-router clients.

                    // We do a listen first and then send the Callback-Request
                    // because the peer may send an ACK and call back
                    // immediately before we have a chance to do a listen.

                    if (FSendInitialBapRequest(pBcbLocal))
                    {
                        *pBapState = BAP_STATE_SENT_CALLBACK_REQ;
                        BapTrace("BAP state change to %s on HCONN 0x%x",
                            SzBapStateName[*pBapState], pBcbLocal->hConnection);
                        return;
                    }
                }

                // FListenForCall may have failed because we chose an 
                // inappropriate port. Sending a Call-Request will not work
                // because, most probably, we will select the same port.
                return;
            }
        }

        // We cannot accept calls, so we will call.

        if ((pBcbLocal->fFlags & BCBFLAG_CAN_CALL) &&
            FFillBapCb(BAP_PACKET_CALL_REQ, pBcbLocal,
                NULL /* pBapCbRemote */))
        {
            if (FSendInitialBapRequest(pBcbLocal))
            {
                *pBapState = BAP_STATE_SENT_CALL_REQ;
                BapTrace("BAP state change to %s on HCONN 0x%x",
                    SzBapStateName[*pBapState], pBcbLocal->hConnection);
            }
        }

        break;

    default:

        BapTrace("BapEventAddLink ignored on HCONN 0x%x from state %s.",
            pBcbLocal->hConnection, SzBapStateName[*pBapState]);
        break;
    }
}

/*

Returns:
    void

Description:
    Called when NDISWAN determines that a link has to be dropped from the 
    bundle represented by pBcbLocal

*/

VOID
BapEventDropLink(
    IN BCB*     pBcbLocal
)
{
    BAP_STATE*  pBapState;
    BAPCB*      pBapCbLocal;

    PPP_ASSERT(NULL != pBcbLocal);

    pBapCbLocal = &(pBcbLocal->BapCb);
    pBapState = &(pBapCbLocal->BapState);

    PPP_ASSERT(BAP_STATE_LIMIT >= *pBapState);

    if (!(pBcbLocal->fFlags & BCBFLAG_CAN_DO_BAP))
    {
        BapTrace("BapEventAddLink called on HCONN 0x%x without BACP",
            pBcbLocal->hConnection);
        return;
    }
    
    BapTrace(" ");
    BapTrace("BapEventDropLink on HCONN 0x%x", pBcbLocal->hConnection);
    
    switch(*pBapState)
    {
    case BAP_STATE_INITIAL:
    
        if (FFillBapCb(BAP_PACKET_DROP_REQ, pBcbLocal,
                NULL /* pBapCbRemote */))
        {
            // See note "Dropping Links" at the top of the file
            pBapCbLocal->dwLinkCount = NumLinksInBundle(pBcbLocal);
            pBapCbLocal->fForceDropOnNak = TRUE;
            
            if (FSendInitialBapRequest(pBcbLocal))
            {
                *pBapState = BAP_STATE_SENT_DROP_REQ;
                BapTrace("BAP state change to %s on HCONN 0x%x",
                    SzBapStateName[*pBapState], pBcbLocal->hConnection);
            }
        }

        break;

    case BAP_STATE_SENT_CALL_REQ:
    case BAP_STATE_SENT_CALLBACK_REQ:

        // We wanted to add a link, but we have now changed our minds.
        *pBapState = BAP_STATE_INITIAL;
        BapTrace("BAP state change to %s on HCONN 0x%x",
            SzBapStateName[*pBapState], pBcbLocal->hConnection);

        // Do not retransmit the request.
        RemoveFromTimerQ(pBcbLocal->dwBundleId, pBapCbLocal->dwId, 
            PPP_BAP_PROTOCOL, FALSE /* fAuthenticator */, TIMER_EVENT_TIMEOUT);

        break;

    default:

        BapTrace("BapEventDropLink ignored on HCONN 0x%x from state %s.",
            pBcbLocal->hConnection, SzBapStateName[*pBapState]);
        break;
    }
}

/*

Returns:
    void

Description:
    Called when a Call-Request or Callback-Request BAP Datagram is received. 
    fCall is TRUE if it is a Call-Request. pBcbLocal represents the bundle that 
    receives the Request. The BAP Datagram Options sent by the peer are in 
    *pBapCbRemote. The Identifier of the BAP Datagram sent by the peer is in 
    dwId.

*/

VOID
BapEventRecvCallOrCallbackReq(
    IN BOOL     fCall,
    IN BCB*     pBcbLocal,
    IN BAPCB*   pBapCbRemote,
    IN DWORD    dwId
)
{
    BAPCB*          pBapCbLocal;
    DWORD           dwOptions       = 0;
    DWORD           dwResponseCode;
    DWORD           dwPacketType    = fCall ? BAP_PACKET_CALL_RESP :
                                              BAP_PACKET_CALLBACK_RESP;
    BAP_STATE*      pBapState;
    CHAR*           szRequest       = fCall ? "Call-Request" : "Callback-Request";
    PCB*            pPcbLocal;
    BOOL            fServer;
    BAP_CALL_RESULT BapCallResult;

    PPP_ASSERT(NULL != pBcbLocal);
    PPP_ASSERT(NULL != pBapCbRemote);
    PPP_ASSERT(0xFF >= dwId);

    pBapCbLocal = &(pBcbLocal->BapCb);
    pBapState = &(pBapCbLocal->BapState);

    PPP_ASSERT(BAP_STATE_LIMIT >= *pBapState);

    BapTrace("BapEventRecvCallOrCallbackReq on HCONN 0x%x",
        pBcbLocal->hConnection);
    
    if ((!fCall && !(pBcbLocal->fFlags & BCBFLAG_CAN_CALL)) ||
        (fCall && !(pBcbLocal->fFlags & BCBFLAG_CAN_ACCEPT_CALLS)))
    {
        BapTrace("Rejecting %s on HCONN 0x%x", szRequest,
            pBcbLocal->hConnection);
        dwResponseCode = BAP_RESPONSE_REJ;
    }
    else if (FUpperLimitReached(pBcbLocal))
    {
        BapTrace("Full-Nak'ing %s on HCONN 0x%x: upper limit reached",
            szRequest, pBcbLocal->hConnection);
        dwResponseCode = BAP_RESPONSE_FULL_NAK;
    }
    else
    {
        switch (*pBapState)
        {
        case BAP_STATE_SENT_DROP_REQ:
        case BAP_STATE_SENT_STATUS_IND:
        case BAP_STATE_CALLING:
        case BAP_STATE_LISTENING:

            BapTrace("Nak'ing %s on HCONN 0x%x from state %s",
                szRequest, pBcbLocal->hConnection, SzBapStateName[*pBapState]);
            dwResponseCode = BAP_RESPONSE_NAK;
            break;

        case BAP_STATE_INITIAL:
        case BAP_STATE_SENT_CALL_REQ:
        case BAP_STATE_SENT_CALLBACK_REQ:

            if ((*pBapState != BAP_STATE_INITIAL && FFavoredPeer(pBcbLocal)) ||
                (*pBapState == BAP_STATE_INITIAL && !FOkToAddLink(pBcbLocal)))
            {
                // If a race condition occurs and we are the favored peer, then 
                // NAK. If our algo does not allow us to add a link (based on 
                // the bandwidth utilization), then NAK.
                BapTrace("Nak'ing %s on HCONN 0x%x from state %s%s",
                    szRequest,
                    pBcbLocal->hConnection, 
                    SzBapStateName[*pBapState],
                    *pBapState != BAP_STATE_INITIAL ?
                        ": we are the favored peer" : "");
                dwResponseCode = BAP_RESPONSE_NAK;
            }
            else
            {
                // State is Initial and it is OK to add a link or
                // State is Sent-Call[back]_Req and we are not the favored peer
                // (so we should drop our request and agree to the peer's 
                // request).

                if (*pBapState != BAP_STATE_INITIAL)
                {
                    *pBapState = BAP_STATE_INITIAL;
                    BapTrace("BAP state change to %s on HCONN 0x%x: we are not "
                        "the favored peer",
                        SzBapStateName[*pBapState], pBcbLocal->hConnection);

                    // Do not retransmit the request. 
                    RemoveFromTimerQ(pBcbLocal->dwBundleId, pBapCbLocal->dwId,
                        PPP_BAP_PROTOCOL, FALSE /* fAuthenticator */,
                        TIMER_EVENT_TIMEOUT);
                }

                if (FFillBapCb(dwPacketType, pBcbLocal, pBapCbRemote))
                {
                    BapTrace("Ack'ing %s on HCONN 0x%x",
                        szRequest, pBcbLocal->hConnection);
                    dwOptions = pBapCbLocal->dwOptions;
                    dwResponseCode = BAP_RESPONSE_ACK;
                }
                else if (pBapCbLocal->dwOptions & BAP_N_LINK_TYPE)
                {
                    // We don't have the link type requested

                    BapTrace("Nak'ing %s on HCONN 0x%x: link type not available",
                        szRequest, pBcbLocal->hConnection);
                    dwOptions = pBapCbLocal->dwOptions;
                    dwResponseCode = BAP_RESPONSE_NAK;
                }
                else
                {
                    // We don't know our own phone number or no link is 
                    // available

                    BapTrace("Full-Nak'ing %s on HCONN 0x%x: no link available",
                        szRequest, pBcbLocal->hConnection);
                    dwResponseCode = BAP_RESPONSE_FULL_NAK;
                }
            }

            break;

        default:

            PPP_ASSERT(FALSE);
            BapTrace("In weird state: %d", *pBapState);
            return;
        }
    }

    pPcbLocal = GetPCBPointerFromBCB(pBcbLocal);

    if (NULL == pPcbLocal)
    {
        BapTrace("BapEventRecvCallOrCallbackReq: No links in HCONN 0x%x!",
            pBcbLocal->hConnection);
        return;
    }

    fServer = (pBcbLocal->fFlags & BCBFLAG_IS_SERVER) != 0;

    if (BAP_RESPONSE_ACK == dwResponseCode &&
        fCall && !fServer &&
        (ROUTER_IF_TYPE_FULL_ROUTER != pBcbLocal->InterfaceInfo.IfType))
    {
        // If we received a Call-Request and agreed to accept the call, we 
        // have to start listening if we are a non-router client. Servers 
        // and routers are always listening, so we do nothing.

        // We do a listen first and then send the ACK to the Call-Request 
        // because the peer may start dialing as soon as it gets the ACK.

        if (FListenForCall(pBapCbLocal->szPortName,
                pBapCbLocal->dwSubEntryIndex, pPcbLocal))
        {
            *pBapState = BAP_STATE_LISTENING;
            BapTrace("BAP state change to %s on HCONN 0x%x",
                SzBapStateName[*pBapState], pBcbLocal->hConnection);
        }
        else
        {
            BapTrace("Nak'ing %s on HCONN 0x%x",
                szRequest, pBcbLocal->hConnection);

            dwOptions = 0;
            dwResponseCode = BAP_RESPONSE_NAK;
        }
    }

    if (FSendBapResponse(pBcbLocal, dwOptions, dwPacketType, dwId,
            dwResponseCode))
    {
        if (!fCall && (BAP_RESPONSE_ACK == dwResponseCode))
        {
            // We received a Callback-Request and we agreed to call.
            if (FCallInitial(pBcbLocal, pBapCbRemote))
            {
                pBapCbLocal->dwStatusIndicationId = dwId;
                *pBapState = BAP_STATE_CALLING;
                BapTrace("BAP state change to %s on HCONN 0x%x",
                    SzBapStateName[*pBapState], pBcbLocal->hConnection);
            }
            else
            {
                BapCallResult.dwResult = ERROR_INVALID_FUNCTION;
                BapCallResult.hRasConn = (HRASCONN)-1;
                BapEventCallResult(pBcbLocal, &BapCallResult);
            }
        }
    }
}

/*

Returns:
    void

Description:
    Called when a Link-Drop-Query-Request BAP Datagram is received. pBcbLocal 
    represents the bundle that receives the Request. The BAP Datagram Options 
    sent by the peer are in *pBapCbRemote. The Identifier of the BAP Datagram 
    sent by the peer is in dwId.

*/

VOID
BapEventRecvDropReq(
    IN BCB*     pBcbLocal,
    IN BAPCB*   pBapCbRemote,
    IN DWORD    dwId
)
{
    BAPCB*      pBapCbLocal;
    BAP_STATE*  pBapState;
    DWORD       dwResponseCode;
    PCB*        pPcbDrop;
    CHAR*       psz[2];

    PPP_ASSERT(NULL != pBcbLocal);
    PPP_ASSERT(NULL != pBapCbRemote);
    PPP_ASSERT(0xFF >= dwId);

    pBapCbLocal = &(pBcbLocal->BapCb);
    pBapState = &(pBapCbLocal->BapState);

    PPP_ASSERT(BAP_STATE_LIMIT >= *pBapState);

    BapTrace("BapEventRecvDropReq on HCONN 0x%x", pBcbLocal->hConnection);

    if (!(pBcbLocal->fFlags & BCBFLAG_IS_SERVER))
    {
        psz[0] = pBcbLocal->szEntryName;
        psz[1] = pBcbLocal->szLocalUserName;
        PppLogInformation(ROUTERLOG_BAP_WILL_DISCONNECT, 2, psz);
    }

    if (NumLinksInBundle(pBcbLocal) == 1)
    {
        // Do not agree to drop the last link
        BapTrace("Full-Nak'ing Link-Drop-Query-Request on HCONN 0x%x: last link",
            pBcbLocal->hConnection);
        dwResponseCode = BAP_RESPONSE_FULL_NAK;
    }
    else
    {
        switch(*pBapState)
        {
        case BAP_STATE_SENT_CALL_REQ:
        case BAP_STATE_SENT_CALLBACK_REQ:
        case BAP_STATE_SENT_STATUS_IND:
        case BAP_STATE_CALLING:
        case BAP_STATE_LISTENING:

            BapTrace("Nak'ing Link-Drop-Query-Request on HCONN 0x%x from "
                "state %s",
                pBcbLocal->hConnection, SzBapStateName[*pBapState]);
            dwResponseCode = BAP_RESPONSE_NAK;
            break;

        case BAP_STATE_INITIAL:
        case BAP_STATE_SENT_DROP_REQ:

            if (!FGetPcbOfLink(pBcbLocal, pBapCbRemote->dwLinkDiscriminator,
                    FALSE /* fRemote */, &pPcbDrop) ||
                (*pBapState != BAP_STATE_INITIAL && FFavoredPeer(pBcbLocal)) ||
                (*pBapState == BAP_STATE_INITIAL &&
                 !FOkToDropLink(pBcbLocal, pBapCbRemote)))
            {
                // The link discriminator sent by the peer is wrong. Or
                // There is a race condition and we are the favored peer. Or
                // Our algo does not allow us to drop a link (based on the 
                // bandwidth utilization).
                BapTrace("Nak'ing Link-Drop-Query-Request on HCONN 0x%x from "
                    "state %s%s",
                    pBcbLocal->hConnection, 
                    SzBapStateName[*pBapState],
                    *pBapState != BAP_STATE_INITIAL ?
                        ": we are the favored peer" : "");
                dwResponseCode = BAP_RESPONSE_NAK;
            }
            else
            {
                // State is Initial and it is OK to drop a link or
                // State is Sent-Drop_Req and we are not the favored peer
                // (so we should drop our request and agree to the peer's 
                // request).

                if (*pBapState != BAP_STATE_INITIAL)
                {
                    *pBapState = BAP_STATE_INITIAL;
                    BapTrace("BAP state change to %s on HCONN 0x%x: we are not "
                        "the favored peer",
                        SzBapStateName[*pBapState], pBcbLocal->hConnection);

                    // We will get a NAK from the peer. That is OK. He will be 
                    // dropping a link. We don't have to drop any link.
                    pBapCbLocal->fForceDropOnNak = FALSE;

                    // Do not retransmit the request.
                    RemoveFromTimerQ(pBcbLocal->dwBundleId, pBapCbLocal->dwId,
                        PPP_BAP_PROTOCOL, FALSE /* fAuthenticator */,
                        TIMER_EVENT_TIMEOUT);

                    // Make sure that the peer will indeed drop this link.
                    InsertInTimerQ(pPcbDrop->dwPortId, pPcbDrop->hPort,
                        0 /* Id */, 0 /* Protocol */,
                        FALSE /* fAuthenticator */,
                        TIMER_EVENT_FAV_PEER_TIMEOUT,
                        BAP_TIMEOUT_FAV_PEER);
                }

                BapTrace("Ack'ing Link-Drop-Query-Request on HCONN 0x%x",
                    pBcbLocal->hConnection);
                dwResponseCode = BAP_RESPONSE_ACK;
            }

            break;

        default:

            PPP_ASSERT(FALSE);
        }
    }

    FSendBapResponse(pBcbLocal, 0 /* dwOptions */, BAP_PACKET_DROP_RESP,
        dwId, dwResponseCode);
}

/*

Returns:
    void

Description:
    Called when a Call-Status-Indication BAP Datagram is received. pBcbLocal 
    represents the bundle that receives the Indication. The BAP Datagram 
    Options sent by the peer are in *pBapCbRemote. The Identifier of the BAP 
    Datagram sent by the peer is in dwId.

*/

VOID
BapEventRecvStatusInd(
    IN BCB*     pBcbLocal,
    IN BAPCB*   pBapCbRemote,
    IN DWORD    dwId
)
{
    PPP_ASSERT(NULL != pBcbLocal);
    PPP_ASSERT(NULL != pBapCbRemote);
    PPP_ASSERT(0xFF >= dwId);

    BapTrace("BapEventRecvStatusInd on HCONN 0x%x", pBcbLocal->hConnection);

    FSendBapResponse(pBcbLocal, 0 /* dwOptions */, BAP_PACKET_STAT_RESP,
        dwId, BAP_RESPONSE_ACK);
}

/*

Returns:
    void

Description:
    Called when a Call-Response or Callback-Response BAP Datagram is received. 
    fCall is TRUE iff it is a Call-Response. pBcbLocal represents the bundle 
    that receives the Request. The BAP Datagram Options sent by the peer are in 
    *pBapCbRemote. The Identifier and Response Code of the BAP Datagram sent by 
    the peer are in dwId and dwResponseCode.

*/

VOID
BapEventRecvCallOrCallbackResp(
    IN BOOL     fCall,
    IN BCB*     pBcbLocal,
    IN BAPCB*   pBapCbRemote,
    IN DWORD    dwId,
    IN DWORD    dwResponseCode
)
{
    BAPCB*          pBapCbLocal;
    BAP_STATE*      pBapState;
    BAP_CALL_RESULT BapCallResult;

    PPP_ASSERT(NULL != pBcbLocal);
    PPP_ASSERT(NULL != pBapCbRemote);
    PPP_ASSERT(0xFF >= dwId);

    pBapCbLocal = &(pBcbLocal->BapCb);
    pBapState = &(pBapCbLocal->BapState);

    PPP_ASSERT(BAP_STATE_LIMIT >= *pBapState);

    BapTrace("BapEventRecvCallOrCallbackResp on HCONN 0x%x",
        pBcbLocal->hConnection);

    if ((fCall && (*pBapState != BAP_STATE_SENT_CALL_REQ)) ||
        (!fCall && (*pBapState != BAP_STATE_SENT_CALLBACK_REQ)) ||
        dwId != pBapCbLocal->dwId)
    {
        BapTrace("Discarding unexpected Call[back]-Response (ID = %d) on "
            "HCONN 0x%x", 
            dwId, pBcbLocal->hConnection);
        return;
    }

    *pBapState = BAP_STATE_INITIAL;
    BapTrace("BAP state change to %s on HCONN 0x%x",
        SzBapStateName[*pBapState], pBcbLocal->hConnection);

    // Do not retransmit the request.
    RemoveFromTimerQ(pBcbLocal->dwBundleId, dwId, PPP_BAP_PROTOCOL,
        FALSE /* fAuthenticator */, TIMER_EVENT_TIMEOUT);

    switch(dwResponseCode)
    {
    case BAP_RESPONSE_ACK:

        if (fCall)
        {
            if (FCallInitial(pBcbLocal, pBapCbRemote))
            {
                pBapCbLocal->dwStatusIndicationId = dwId;
                *pBapState = BAP_STATE_CALLING;
                BapTrace("BAP state change to %s on HCONN 0x%x",
                    SzBapStateName[*pBapState], pBcbLocal->hConnection);
            }
            else
            {
                BapCallResult.dwResult = ERROR_INVALID_FUNCTION;
                BapCallResult.hRasConn = (HRASCONN)-1;
                BapEventCallResult(pBcbLocal, &BapCallResult);
            }
        }

        break;
        
    case BAP_RESPONSE_NAK:

        if (pBapCbRemote->dwOptions & BAP_N_LINK_TYPE)
        {
            // The peer wants to use a different link type

            if (FFillBapCb(
                fCall ? BAP_PACKET_CALL_REQ : BAP_PACKET_CALLBACK_REQ,
                pBcbLocal, pBapCbRemote))
            {
                if (FSendInitialBapRequest(pBcbLocal))
                {
                    *pBapState = fCall ?
                        BAP_STATE_SENT_CALL_REQ : BAP_STATE_SENT_CALLBACK_REQ;
                    BapTrace("BAP state change to %s on HCONN 0x%x",
                        SzBapStateName[*pBapState], pBcbLocal->hConnection);
                }
            }
            else
            {
                BapTrace("We don't have the reqd link type: %d on HCONN 0x%x", 
                    pBapCbRemote->dwLinkType, pBcbLocal->hConnection);
            }
        }
        else
        {
            // The original Request MAY be retried after a little while.
            // So we will not do anything here.
        }

        break;
    
    case BAP_RESPONSE_REJ:

        // We always try to send a Callback-Request first. If the peer rejects 
        // it, we can try to send a Call-Request. If the peer rejects a 
        // Call-Request, there is nothing that we can do.

        pBcbLocal->fFlags |= (fCall ? BCBFLAG_PEER_CANT_ACCEPT_CALLS :
                                      BCBFLAG_PEER_CANT_CALL);

        if (pBcbLocal->fFlags & BCBFLAG_LISTENING)
        {
            BapTrace("Still listening; will not send Call-Request");
            break;
        }

        if (!fCall && (pBcbLocal->fFlags & BCBFLAG_CAN_CALL))
        {
            if (FFillBapCb(BAP_PACKET_CALL_REQ, pBcbLocal,
                    NULL /* pBapCbRemote */))
            {
                if (FSendInitialBapRequest(pBcbLocal))
                {
                    *pBapState = BAP_STATE_SENT_CALL_REQ;
                    BapTrace("BAP state change to %s on HCONN 0x%x",
                        SzBapStateName[*pBapState], pBcbLocal->hConnection);
                }
            }
        }

        break;
        
    case BAP_RESPONSE_FULL_NAK:

        // Do not try to add links till the total bandwidth of the bundle
        // has changed. However, we don't know the total bw. So we will not
        // do anything here. After all, this is not a MUST.

        break;

    default:

        BapTrace("Unknown Response Code %d received on HCONN 0x%x",
            dwResponseCode, pBcbLocal->hConnection);

        break;
    }
}

/*

Returns:
    void

Description:
    Called when a Link-Drop-Query-Response BAP Datagram is received. pBcbLocal 
    represents the bundle that receives the Response. The Identifier and 
    Response Code of the BAP Datagram sent by the peer are in dwId and 
    dwResponseCode.

*/

VOID
BapEventRecvDropResp(
    IN BCB*     pBcbLocal,
    IN DWORD    dwId,
    IN DWORD    dwResponseCode
)
{
    BAPCB*      pBapCbLocal;
    BAP_STATE*  pBapState;
    PCB*        pPcbDrop;

    PPP_ASSERT(NULL != pBcbLocal);
    PPP_ASSERT(0xFF >= dwId);

    pBapCbLocal = &(pBcbLocal->BapCb);
    pBapState = &(pBapCbLocal->BapState);

    PPP_ASSERT(BAP_STATE_LIMIT >= *pBapState);

    BapTrace("BapEventRecvDropResp on HCONN 0x%x", pBcbLocal->hConnection);

    if ((*pBapState != BAP_STATE_SENT_DROP_REQ) ||
        dwId != pBapCbLocal->dwId)
    {
        BapTrace("Discarding unexpected Link-Drop-Query-Response (ID = %d) on "
            "HCONN 0x%x", 
            dwId, pBcbLocal->hConnection);
        return;
    }

    *pBapState = BAP_STATE_INITIAL;
    BapTrace("BAP state change to %s on HCONN 0x%x",
        SzBapStateName[*pBapState], pBcbLocal->hConnection);

    // Do not retransmit the request.
    RemoveFromTimerQ(pBcbLocal->dwBundleId, dwId, PPP_BAP_PROTOCOL,
        FALSE /* fAuthenticator */, TIMER_EVENT_TIMEOUT);

    switch(dwResponseCode)
    {
    default:

        BapTrace("Unknown Response Code %d received on HCONN 0x%x",
            dwResponseCode, pBcbLocal->hConnection);

        // Fall through (perhaps we need to drop a link)

    case BAP_RESPONSE_NAK:        
    case BAP_RESPONSE_REJ:
    case BAP_RESPONSE_FULL_NAK:

        if (   (NumLinksInBundle(pBcbLocal) < pBapCbLocal->dwLinkCount)
            || !pBapCbLocal->fForceDropOnNak)
        {
            // Do not forcibly drop a link.
            break;
        }

        // Fall through (to forcibly drop a link)

    case BAP_RESPONSE_ACK:
    
        if (FGetPcbOfLink(pBcbLocal, pBapCbLocal->dwLinkDiscriminator,
                TRUE /* fRemote */, &pPcbDrop))
        {
            CHAR*   psz[3];

            if (!(pBcbLocal->fFlags & BCBFLAG_IS_SERVER))
            {
                psz[0] = pPcbDrop->pBcb->szEntryName;
                psz[1] = pPcbDrop->pBcb->szLocalUserName;
                psz[2] = pPcbDrop->szPortName;
                PppLogInformation(ROUTERLOG_BAP_DISCONNECTED, 3, psz);
            }

            BapTrace("Dropping link with hPort %d from HCONN 0x%x", 
                pPcbDrop->hPort, pBcbLocal->hConnection);
            pPcbDrop->LcpCb.dwError = ERROR_BAP_DISCONNECTED;
            FsmClose(pPcbDrop, LCP_INDEX);
        }

        break;
    }
}

/*

Returns:
    void

Description:
    Called when a Call-Status-Response BAP Datagram is received. pBcbLocal 
    represents the bundle that receives the Response. The Identifier and 
    Response Code of the BAP Datagram sent by the peer are in dwId and 
    dwResponseCode.

*/

VOID
BapEventRecvStatusResp(
    IN BCB*     pBcbLocal,
    IN DWORD    dwId,
    IN DWORD    dwResponseCode
)
{
    BAPCB*      pBapCbLocal;
    BAP_STATE*  pBapState;

    PPP_ASSERT(NULL != pBcbLocal);
    PPP_ASSERT(0xFF >= dwId);

    pBapCbLocal = &(pBcbLocal->BapCb);
    pBapState = &(pBapCbLocal->BapState);

    PPP_ASSERT(BAP_STATE_LIMIT >= *pBapState);

    BapTrace("BapEventRecvStatusResp on HCONN 0x%x", pBcbLocal->hConnection);

    if ((*pBapState != BAP_STATE_SENT_STATUS_IND) ||
        dwId != pBapCbLocal->dwId)
    {
        BapTrace("Discarding unexpected Call-Status-Response (ID = %d) on "
            "HCONN 0x%x", 
            dwId, pBcbLocal->hConnection);
        return;
    }

    // Do not retransmit the indication.
    RemoveFromTimerQ(pBcbLocal->dwBundleId, dwId, PPP_BAP_PROTOCOL,
        FALSE /* fAuthenticator */, TIMER_EVENT_TIMEOUT);

    if (pBapCbLocal->dwAction && FCall(pBcbLocal))
    {
        *pBapState = BAP_STATE_CALLING;

        // BapEventRecvStatusResp or BapEventTimeout will get called at some
        // point, and we will free pBapCbLocal->pbPhoneDeltaRemote.
    }
    else
    {
        *pBapState = BAP_STATE_INITIAL;
        if (NULL != pBapCbLocal->pbPhoneDeltaRemote)
        {
            LOCAL_FREE(pBapCbLocal->pbPhoneDeltaRemote);
        }
        pBapCbLocal->pbPhoneDeltaRemote = NULL;
    }

    BapTrace("BAP state change to %s on HCONN 0x%x",
        SzBapStateName[*pBapState], pBcbLocal->hConnection);
}

/*

Returns:
    void

Description:
    Called when a BAP Datagram is received. pBcbLocal represents the bundle 
    that receives the Datagram. pPacket is the PPP packet which contains the 
    Datagram. dwPacketLength is the number of bytes in the PPP packet.

*/

VOID
BapEventReceive(
    IN BCB*         pBcbLocal,
    IN PPP_PACKET*  pPacket,
    IN DWORD        dwPacketLength
)
{
    PPP_CONFIG*     pConfig;
    BAP_RESPONSE*   pResponse;
    DWORD           dwLength;
    DWORD           dwType;
    DWORD           dwId;
    BAPCB           BapCbRemote;

    PPP_ASSERT(NULL != pBcbLocal);
    PPP_ASSERT(NULL != pPacket);

    // We don't know whether we have received a request or a response. Let us 
    // grab pointers to both the request part and the response part.
    pConfig = (PPP_CONFIG *)(pPacket->Information);
    pResponse = (BAP_RESPONSE *)(pPacket->Information);

    // The Length, Type, and Id are always found in the same place, both for
    // requests and responses. So let us get those values, assuming that we have
    // received a request.
    dwLength = WireToHostFormat16(pConfig->Length);
    dwType = pConfig->Code;
    dwId = pConfig->Id;

    LogBapPacket(TRUE /* fReceived */, (HPORT)-1 /* hPort */,
        pBcbLocal, pPacket, dwPacketLength);
    
    if ((dwLength > dwPacketLength - PPP_PACKET_HDR_LEN) || 
        (dwLength < PPP_CONFIG_HDR_LEN) ||
        (dwType > BAP_PACKET_LIMIT) ||
        !FReadOptions(pPacket, dwType, dwLength, &BapCbRemote))
    {
        BapTrace("Silently discarding badly formed BAP packet");
        return;
    }
    
    switch(dwType)
    {
    case BAP_PACKET_CALL_REQ:

        BapEventRecvCallOrCallbackReq(
            TRUE /* fCall */,
            pBcbLocal,
            &BapCbRemote,
            dwId);
        return;

    case BAP_PACKET_CALL_RESP:

        BapEventRecvCallOrCallbackResp(
            TRUE /* fCall */,
            pBcbLocal,
            &BapCbRemote,
            dwId,
            pResponse->ResponseCode);
        return;

    case BAP_PACKET_CALLBACK_REQ:

        BapEventRecvCallOrCallbackReq(
            FALSE /* fCall */,
            pBcbLocal,
            &BapCbRemote,
            dwId);
        return;

    case BAP_PACKET_CALLBACK_RESP:

        BapEventRecvCallOrCallbackResp(
            FALSE /* fCall */,
            pBcbLocal,
            &BapCbRemote,
            dwId,
            pResponse->ResponseCode);
        return;

    case BAP_PACKET_DROP_REQ:

        BapEventRecvDropReq(
            pBcbLocal,
            &BapCbRemote,
            dwId);
        return;

    case BAP_PACKET_DROP_RESP:

        BapEventRecvDropResp(
            pBcbLocal,
            dwId,
            pResponse->ResponseCode);
        return;

    case BAP_PACKET_STATUS_IND:

        BapEventRecvStatusInd(
            pBcbLocal,
            &BapCbRemote,
            dwId);
        return;

    case BAP_PACKET_STAT_RESP:

        BapEventRecvStatusResp(
            pBcbLocal,
            dwId,
            pResponse->ResponseCode);
        return;

    default:

        // The check above should have caught this case.
        PPP_ASSERT(FALSE);
        return;
    }
}

/*

Returns:
    void

Description:
    Called when a BAP Request or Indication packet times out while waiting for 
    a Response. pBcbLocal represents the bundle that the packet was sent on. 
    The Identifier of the BAP Datagram is in dwId. 

*/

VOID
BapEventTimeout(
    IN BCB*     pBcbLocal,
    IN DWORD    dwId
)
{
    BAPCB*      pBapCbLocal;
    BAP_STATE*  pBapState;
    PCB*        pPcbDrop;

    PPP_ASSERT(NULL != pBcbLocal);

    pBapCbLocal = &(pBcbLocal->BapCb);
    pBapState = &(pBapCbLocal->BapState);

    PPP_ASSERT(BAP_STATE_LIMIT >= *pBapState);

    if (dwId != pBapCbLocal->dwId ||
        *pBapState == BAP_STATE_INITIAL ||
        *pBapState == BAP_STATE_CALLING)
    {
        BapTrace("Illegal timeout occurred. Id: %d, BapCb's Id: %d, "
            "BAP state: %s",
            dwId, pBapCbLocal->dwId, SzBapStateName[*pBapState]);
        return;
    }

    BapTrace("BAP packet (Type: %s, ID: %d) sent on HCONN 0x%x timed out.",
        pBapCbLocal->dwType <= BAP_PACKET_LIMIT ?
            SzBapPacketName[pBapCbLocal->dwType] : "UNKNOWN",
        dwId, pBcbLocal->hConnection);
    
    if (pBapCbLocal->dwRetryCount > 0)
    {
        // Send the packet once again
        (pBapCbLocal->dwRetryCount)--;
        FSendBapRequest(pBcbLocal);

        // BapEventRecvStatusResp or BapEventTimeout will get called at some
        // point, and we will free pBapCbLocal->pbPhoneDeltaRemote.
    }
    else
    {
        // We have sent the packet too many times. Discard it now.
        BapTrace("Request retry exceeded.");

        if (*pBapState == BAP_STATE_SENT_DROP_REQ)
        {
            // The peer did not respond to our Link-Drop-Query-Request. Perhaps 
            // we need to forcibly drop the link.

            if (NumLinksInBundle(pBcbLocal) >= pBapCbLocal->dwLinkCount &&
                pBapCbLocal->fForceDropOnNak)
            {
                if (FGetPcbOfLink(pBcbLocal, pBapCbLocal->dwLinkDiscriminator,
                        TRUE /*fRemote */, &pPcbDrop))
                {
                    CHAR*   psz[3];

                    if (!(pBcbLocal->fFlags & BCBFLAG_IS_SERVER))
                    {
                        psz[0] = pPcbDrop->pBcb->szEntryName;
                        psz[1] = pPcbDrop->pBcb->szLocalUserName;
                        psz[2] = pPcbDrop->szPortName;
                        PppLogInformation(ROUTERLOG_BAP_DISCONNECTED, 3, psz);
                    }

                    BapTrace("Dropping link with hPort %d from HCONN 0x%x", 
                        pPcbDrop->hPort, pBcbLocal->hConnection);
                    pPcbDrop->LcpCb.dwError = ERROR_BAP_DISCONNECTED;
                    FsmClose(pPcbDrop, LCP_INDEX);
                }
            }
        }

        if (NULL != pBapCbLocal->pbPhoneDeltaRemote)
        {
            LOCAL_FREE(pBapCbLocal->pbPhoneDeltaRemote);
        }
        pBapCbLocal->pbPhoneDeltaRemote = NULL;

        *pBapState = BAP_STATE_INITIAL;
        BapTrace("BAP state change to %s on HCONN 0x%x",
            SzBapStateName[*pBapState], pBcbLocal->hConnection);
    }
}

/*

Returns:
    void

Description:
    Called when we know the result of a call attempt. pBcbLocal represents the 
    bundle that called out. *pBapCallResult contains information about the call 
    attempt.
    
*/

VOID
BapEventCallResult(
    IN BCB*             pBcbLocal,
    IN BAP_CALL_RESULT* pBapCallResult
)
{
    BAPCB*      pBapCbLocal;
    BAP_STATE*  pBapState;
    DWORD       dwResult;
    HPORT       hPort;
    PCB*        pPcbNew;
    PPP_MESSAGE PppMsg;
    BOOL        fWillCallAgain;

    PPP_ASSERT(NULL != pBcbLocal);
    PPP_ASSERT(NULL != pBapCallResult);

    pBapCbLocal = &(pBcbLocal->BapCb);
    pBapState = &(pBapCbLocal->BapState);
    dwResult = pBapCallResult->dwResult;

    // If we have to use pbPhoneDeltaRemote, it had better not be NULL
    PPP_ASSERT(!pBapCbLocal->fPeerSuppliedPhoneNumber ||
               (NULL != pBapCbLocal->pbPhoneDeltaRemote));

    PPP_ASSERT(BAP_STATE_LIMIT >= *pBapState);

    // The call failed, but we have other numbers to try
    fWillCallAgain = (0 != dwResult) &&
        pBapCbLocal->fPeerSuppliedPhoneNumber &&
        (NULL != pBapCbLocal->pbPhoneDeltaRemote) &&
        (0 != 
        pBapCbLocal->pbPhoneDeltaRemote[pBapCbLocal->dwPhoneDeltaRemoteOffset]);

    BapTrace("BapEventCallResult (%s) on HCONN 0x%x",
        dwResult ? "failure" : "success",
        pBcbLocal->hConnection);
    *pBapState = BAP_STATE_INITIAL;
    BapTrace("BAP state change to %s on HCONN 0x%x",
        SzBapStateName[*pBapState],
        pBcbLocal->hConnection);

    pBapCbLocal->dwType = BAP_PACKET_STATUS_IND;
    pBapCbLocal->dwOptions = BAP_N_CALL_STATUS;
    pBapCbLocal->dwStatus = dwResult ? 255 : 0;
    pBapCbLocal->dwAction = fWillCallAgain;

    if (FSendInitialBapRequest(pBcbLocal))
    {
        *pBapState = BAP_STATE_SENT_STATUS_IND;
        BapTrace("BAP state change to %s on HCONN 0x%x",
            SzBapStateName[*pBapState], pBcbLocal->hConnection);

        // BapEventRecvStatusResp or BapEventTimeout will get called at some
        // point, and we will free pBapCbLocal->pbPhoneDeltaRemote.
    }
    else
    {
        if (NULL != pBapCbLocal->pbPhoneDeltaRemote)
        {
            LOCAL_FREE(pBapCbLocal->pbPhoneDeltaRemote);
        }
        pBapCbLocal->pbPhoneDeltaRemote = NULL;
    }

    if (0 == dwResult)
    {
        if ((HRASCONN)-1 != pBapCallResult->hRasConn)
        {
            CHAR*   psz[3];

            // hRasConn will be -1 if we are here because of a message from Ddm, 
            // not RasDial().
            hPort = RasGetHport(pBapCallResult->hRasConn);
            pPcbNew = GetPCBPointerFromhPort(hPort);
            if (NULL == pPcbNew)
            {
                BapTrace("BapEventCallResult: No PCB for new port %d in "
                    "HCONN 0x%x!",
                    hPort, pBcbLocal->hConnection);
                return;
            }

            psz[0] = pPcbNew->pBcb->szLocalUserName;
            psz[1] = pPcbNew->pBcb->szEntryName;
            psz[2] = pPcbNew->szPortName;
            PppLogInformation(ROUTERLOG_BAP_CLIENT_CONNECTED, 3, psz);

            if ((ROUTER_IF_TYPE_FULL_ROUTER ==
                 pPcbNew->pBcb->InterfaceInfo.IfType))
            {
                // Inform Ddm that a new link is up. This allows MprAdmin, for 
                // example, to display Active Connections correctly.
                ZeroMemory(&PppMsg, sizeof(PppMsg));
                PppMsg.hPort = hPort;
                PppMsg.dwMsgId = PPPDDMMSG_NewBapLinkUp;

                PppMsg.ExtraInfo.BapNewLinkUp.hRasConn =
                    pBapCallResult->hRasConn;

                PppConfigInfo.SendPPPMessageToDdm(&PppMsg);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\engine\callback.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    callback.c
//
// Description: Contains FSM code to handle and callback control protocol
//
// History:
//      April 11,1993.  NarenG          Created original version.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>     // needed for winbase.h

#include <windows.h>    // Win32 base API's
#include <stdlib.h>
#include <string.h>
#include <wchar.h>

#include <lmcons.h>
#include <raserror.h>
#include <rasman.h>
#include <rasppp.h>
#include <pppcp.h>
#include <ppp.h>
#include <auth.h>
#include <callback.h>
#include <smevents.h>
#include <smaction.h>
#include <lcp.h>
#include <timer.h>
#include <rtutils.h>
#include <util.h>
#include <worker.h>

//**
//
// Call:        CbStart
//
// Returns:     none
//
// Description: Called to initiatialze the callback control protocol and to
//              initiate to callback negotiation.
//
VOID
CbStart( 
    IN PCB * pPcb,
    IN DWORD CpIndex
)
{
    DWORD        dwRetCode;
    PPPCB_INPUT  PppCbInput;
    CPCB *       pCpCb = GetPointerToCPCB( pPcb, CpIndex );

    if ( NULL == pCpCb )
    {
        return;
    }
  
    PppCbInput.fServer             = pPcb->fFlags & PCBFLAG_IS_SERVER;
    PppCbInput.bfCallbackPrivilege = (BYTE)(pPcb->fCallbackPrivilege);
    PppCbInput.CallbackDelay       = ( pPcb->ConfigInfo.dwConfigMask & 
                                     PPPCFG_UseCallbackDelay )
                                     ? pPcb->ConfigInfo.dwCallbackDelay
                                     : PppConfigInfo.dwCallbackDelay;

    PppCbInput.pszCallbackNumber   = pPcb->szCallbackNumber;

    PppLog( 2, "CallbackPriv in CB = %x", PppCbInput.bfCallbackPrivilege );
    
    dwRetCode = (CpTable[CpIndex].CpInfo.RasCpBegin)(&(pCpCb->pWorkBuf),
                    &PppCbInput);

    if ( dwRetCode != NO_ERROR )
    {
        pPcb->LcpCb.dwError = dwRetCode;

        NotifyCallerOfFailure( pPcb, dwRetCode );

        return;
    }

    pCpCb->LastId = (DWORD)-1;
    InitRestartCounters( pPcb, pCpCb );

    CbWork( pPcb, CpIndex, NULL, NULL );
}

//**
//
// Call:        CbStop
//
// Returns:     none
//
// Description: Called to stop the callback control protocol machine.
//
VOID
CbStop( 
    IN PCB * pPcb,
    IN DWORD CpIndex
)
{
    CPCB * pCpCb = GetPointerToCPCB( pPcb, CpIndex );

    if ( NULL == pCpCb )
    {
        return;
    }

    if ( pCpCb->LastId != (DWORD)-1 )
    {
        RemoveFromTimerQ(       
                      pPcb->dwPortId,
                      pCpCb->LastId, 
                      CpTable[CpIndex].CpInfo.Protocol,
                      FALSE,  
                      TIMER_EVENT_TIMEOUT );
    }

    if ( pCpCb->pWorkBuf != NULL )
    {
        (CpTable[CpIndex].CpInfo.RasCpEnd)( pCpCb->pWorkBuf );

        pCpCb->pWorkBuf = NULL;
    }
}

//**
//
// Call:        CbWork
//
// Returns:     none
//
// Description: Called when and callback control protocol packet was received or
//              a timeout ocurred or to initiate callback negotiation.
//
VOID
CbWork(
    IN PCB *         pPcb,
    IN DWORD         CpIndex,
    IN PPP_CONFIG *  pRecvConfig,
    IN PPPCB_INPUT * pCbInput
)
{
    DWORD        dwRetCode;
    CPCB *       pCpCb       = GetPointerToCPCB( pPcb, CpIndex );
    PPP_CONFIG * pSendConfig = (PPP_CONFIG*)(pPcb->pSendBuf->Information);
    PPPCB_RESULT CbResult;
    DWORD        dwLength;

    if ( NULL == pCpCb )
    {
        return;
    }

    PPP_ASSERT( NULL != pCpCb->pWorkBuf );

    dwRetCode = (CpTable[CpIndex].CpInfo.RasApMakeMessage)(
                        pCpCb->pWorkBuf,
                        pRecvConfig,
                        pSendConfig,
                        LCP_DEFAULT_MRU 
                        - PPP_PACKET_HDR_LEN,
                        (PPPAP_RESULT*)&CbResult,
                        (PPPAP_INPUT*)pCbInput );

    if ( dwRetCode != NO_ERROR )
    {
        if ( dwRetCode == ERROR_PPP_INVALID_PACKET )
        {
            PppLog(1,
                   "Silently discarding invalid callback packet on port %d",
                   pPcb->hPort );

            return;
        }
        else
        {
            pPcb->LcpCb.dwError = dwRetCode;

            NotifyCallerOfFailure( pPcb, dwRetCode );

            return;
        }
    }

    switch( CbResult.Action )
    {

    case APA_Send:
    case APA_SendWithTimeout:
    case APA_SendWithTimeout2:
    case APA_SendAndDone:

        HostToWireFormat16( (WORD)CpTable[CpIndex].CpInfo.Protocol, 
                            (PBYTE)(pPcb->pSendBuf->Protocol) );

        dwLength = WireToHostFormat16( pSendConfig->Length );

        LogPPPPacket(FALSE,pPcb,pPcb->pSendBuf,dwLength+PPP_PACKET_HDR_LEN);

        if ( ( dwRetCode = PortSendOrDisconnect( pPcb,
                                        (dwLength + PPP_PACKET_HDR_LEN)))
                                            != NO_ERROR )
        {
            return;
        }

        pCpCb->LastId = (DWORD)-1;

        if ( ( CbResult.Action == APA_SendWithTimeout ) ||
             ( CbResult.Action == APA_SendWithTimeout2 ) )
        {
            pCpCb->LastId = CbResult.bIdExpected;

            InsertInTimerQ( pPcb->dwPortId,
                            pPcb->hPort, 
                            pCpCb->LastId, 
                            CpTable[CpIndex].CpInfo.Protocol,
                            FALSE,
                            TIMER_EVENT_TIMEOUT,
                            pPcb->RestartTimer );

            //
            // For SendWithTimeout2 we increment the ConfigRetryCount. This 
            // means send with infinite retry count
            //

            if ( CbResult.Action == APA_SendWithTimeout2 ) 
            {
                (pCpCb->ConfigRetryCount)++;
            }
        }

        if ( CbResult.Action != APA_SendAndDone )
            break;

    case APA_Done:

        if ( CbResult.bfCallbackPrivilege == RASPRIV_NoCallback )
        {
            //
            // If no callback was negotiated we continue on to the next
            // phase.
            //

            FsmThisLayerUp( pPcb, CpIndex );
        }
        else
        {
            if ( pPcb->fFlags & PCBFLAG_IS_SERVER )
            {
                //
                // If we are the server side we save the callback info
                //

                strcpy( pPcb->szCallbackNumber, CbResult.szCallbackNumber );

                pPcb->ConfigInfo.dwCallbackDelay = CbResult.CallbackDelay;

            }
            else
            {
                //
                // We are the client side so, we tell the server that we 
                // bringing the link down and we tell the client to 
                // prepare for callback
                //

                FsmClose( pPcb, LCP_INDEX );
            }

            pPcb->fFlags |= PCBFLAG_DOING_CALLBACK;
        }

        break;

    case APA_NoAction:

        //
        // If we are on the client then we need to get the callback number 
        // from the user.
        //

     
        if ( ( !(pPcb->fFlags & PCBFLAG_IS_SERVER) && 
             ( CbResult.fGetCallbackNumberFromUser ) ) ) 
        {
            NotifyCaller( pPcb, PPPMSG_CallbackRequest, NULL );
        }

        break;

    default:

        break;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\engine\auth.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    auth.h
//
// Description: Contains function prototypes for the authentication 
//              module
//
// History:
//      Nov 11,1993.    NarenG          Created original version.
//

VOID
ApStop( 
    IN PCB * pPcb,
    IN DWORD CpIndex,
    IN BOOL  fAuthenticator
);

VOID
ApWork(
    IN PCB *         pPcb,
    IN DWORD         CpIndex,
    IN PPP_CONFIG *  pRecvConfig,
    IN PPPAP_INPUT * pApInput,
    IN BOOL          fAuthenticator
);

BOOL
ApStart( 
    IN PCB * pPcb,
    IN DWORD CpIndex,
    IN BOOL  fAuthenticator
);

BOOL
ApIsAuthenticatorPacket(
    IN DWORD         CpIndex,
    IN BYTE          bConfigCode
);

DWORD
SetUserAuthorizedAttributes(
    IN  PCB *                   pPcb, 
    IN  RAS_AUTH_ATTRIBUTE *    pUserAttributes,
    IN  BOOL                    fAuthenticator,
    IN  BYTE *                  pChallenge,
    IN  BYTE *                  pResponse
);

DWORD
RasAuthenticateClient(
    IN  HPORT                   hPort,
    IN  RAS_AUTH_ATTRIBUTE *    pInAttributes
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\engine\init.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    init.c
//
// Description: This module contains all the code to initialize the PPP
//              engine.
//
// History:
//      Nov 11,1993.    NarenG          Created original version.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>     // needed for winbase.h

#include <windows.h>    // Win32 base API's
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <wchar.h>

#include <raserror.h>
#include <rasman.h>
#include <rtutils.h>
#include <mprlog.h>
#include <lmcons.h>
#include <rasppp.h>
#include <pppcp.h>
#include <lcp.h>
#define _ALLOCATE_GLOBALS_
#include <ppp.h>
#include <timer.h>
#include <util.h>
#include <worker.h>
#include <init.h>
#include <rasauth.h>
#include <bap.h>
#include <raseapif.h>
#define __NOT_INCLUDE_OpenRAS_IASProfileDlg__
#include <dialinusr.h>
#define ALLOC_BLTINCPS_GLOBALS
#include <bltincps.h>

// AFP Server Service registry parameter structure
//
typedef struct _PPP_REGISTRY_PARAMS {

    LPSTR       pszValueName;
    DWORD *     pValue;
    DWORD       Max;
    DWORD       dwDefValue;

} PPP_REGISTRY_PARAMS, *PPPP_REGISTRY_PARAMS;


PPP_REGISTRY_PARAMS PppRegParams[] =
{
    RAS_VALUENAME_MAXTERMINATE,
    &(PppConfigInfo.MaxTerminate),
    255,
    PPP_DEF_MAXTERMINATE,

    RAS_VALUENAME_MAXCONFIGURE,
    &(PppConfigInfo.MaxConfigure),
    255,
    PPP_DEF_MAXCONFIGURE,

    RAS_VALUENAME_MAXFAILURE,
    &(PppConfigInfo.MaxFailure),
    255,
    PPP_DEF_MAXFAILURE,

    RAS_VALUENAME_MAXREJECT,
    &(PppConfigInfo.MaxReject),
    255,
    PPP_DEF_MAXREJECT,

    RAS_VALUENAME_RESTARTTIMER,
    &(PppConfigInfo.DefRestartTimer),
    0xFFFFFFFF,
    PPP_DEF_RESTARTTIMER,

    RAS_VALUENAME_NEGOTIATETIME,
    &(PppConfigInfo.NegotiateTime),
    0xFFFFFFFF,
    PPP_DEF_NEGOTIATETIME,

    RAS_VALUENAME_CALLBACKDELAY,
    &(PppConfigInfo.dwCallbackDelay),
    255,
    PPP_DEF_CALLBACKDELAY,

    RAS_VALUENAME_PORTLIMIT,
    &(PppConfigInfo.dwDefaultPortLimit),
    0xFFFFFFFF,
    PPP_DEF_PORTLIMIT,

    RAS_VALUENAME_SESSIONTIMEOUT,
    &(PppConfigInfo.dwDefaultSessionTimeout),
    0xFFFFFFFF,
    PPP_DEF_SESSIONTIMEOUT,

    RAS_VALUENAME_IDLETIMEOUT,
    &(PppConfigInfo.dwDefaulIdleTimeout),
    0xFFFFFFFF,
    PPP_DEF_IDLETIMEOUT,

    RAS_VALUENAME_BAPTHRESHOLD,
    &(PppConfigInfo.dwHangupExtraPercent),
    100,
    RAS_DEF_BAPLINEDNLIMIT,

    RAS_VALUENAME_BAPTIME,
    &(PppConfigInfo.dwHangUpExtraSampleSeconds),
    0xFFFFFFFF,
    RAS_DEF_BAPLINEDNTIME,

    RAS_VALUENAME_BAPLISTENTIME,
    &(PppConfigInfo.dwBapListenTimeoutSeconds),
    0xFFFFFFFF,
    PPP_DEF_BAPLISTENTIME,

    RAS_VALUENAME_UNKNOWNPACKETTRACESIZE,
    &(PppConfigInfo.dwUnknownPacketTraceSize),
    0xFFFFFFFF,
    PPP_DEF_UNKNOWNPACKETTRACESIZE,

	RAS_ECHO_REQUEST_INTERVAL,
	&(PppConfigInfo.dwLCPEchoTimeInterval),
	0xFFFFFFFF,
	PPP_DEF_ECHO_REQUEST_INTERVAL,					//Default of 60 seconds

	RAS_ECHO_REQUEST_IDLE,
	&(PppConfigInfo.dwIdleBeforeEcho),
	0xFFFFFFFF,
	PPP_DEF_ECHO_REQUEST_IDLE,					//Default of 300 seconds

	RAS_ECHO_NUM_MISSED_ECHOS,
	&(PppConfigInfo.dwNumMissedEchosBeforeDisconnect),
	0xFFFFFFFF,
	PPP_DEF_ECHO_NUM_MISSED_ECHOS,					//Default of 3 tries

	RAS_DONTNEGOTIATE_MULTILINKONSINGLELINK,
	&(PppConfigInfo.dwDontNegotiateMultiLinkOnSingleLink),
	0xFFFFFFFF,
	0,
	
    NULL, NULL, 0, 0
};

static DLL_ENTRY_POINTS * pCpDlls  = (DLL_ENTRY_POINTS*)NULL;

HANDLE  HInstDLL;

//**
//
// Call:        LoadProtocolDlls
//
// Returns:     NO_ERROR        - Success
//              non-zero code   - Failure
//
// Description: This procedure enumerates all the Subkeys under the PPP key
//              and loads each AP or CP and fills up the DLL_ENTRY_POINTS
//              structure with the required entry points. It also will return
//              the total number of protocols in all the Dlls. Note that each
//              DLL could have up to PPPCP_MAXCPSPERDLL protocols.
//
DWORD
LoadProtocolDlls(
    IN  DLL_ENTRY_POINTS * pCpDlls,
    IN  DWORD              cCpDlls,
    IN  HKEY               hKeyProtocols,
    OUT DWORD *            pcTotalNumProtocols
)
{
    HKEY        hKeyCp             = (HKEY)NULL;
    LPSTR       pCpDllPath         = (LPSTR)NULL;
    LPSTR       pCpDllExpandedPath = (LPSTR)NULL;
    DWORD       dwKeyIndex;
    DWORD       dwRetCode;
    CHAR        chSubKeyName[100];
    DWORD       cbSubKeyName;
    DWORD       dwNumSubKeys;
    DWORD       dwMaxSubKeySize;
    DWORD       dwNumValues;
    DWORD       cbMaxValNameLen;
    DWORD       cbMaxValueDataSize;
    DWORD       dwSecDescLen;
    DWORD       ProtocolIds[PPPCP_MAXCPSPERDLL];
    DWORD       dwNumProtocolIds;
    FARPROC     pRasCpEnumProtocolIds;
    FARPROC     pRasCpGetInfo;
    DWORD       cbSize;
    DWORD       dwType;
    HINSTANCE   hInstance;

    //
    // Read the registry to find out the various control protocols to load.
    //

    for ( dwKeyIndex = 0; dwKeyIndex < cCpDlls; dwKeyIndex++ )
    {
        cbSubKeyName = sizeof( chSubKeyName );

        dwRetCode = RegEnumKeyEx(
                                hKeyProtocols,
                                dwKeyIndex,
                                chSubKeyName,
                                &cbSubKeyName,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                                );

        if ( ( dwRetCode != NO_ERROR )          &&
             ( dwRetCode != ERROR_MORE_DATA )   &&
             ( dwRetCode != ERROR_NO_MORE_ITEMS ) )
        {
            PppLogErrorString(ROUTERLOG_CANT_ENUM_REGKEYVALUES,0,
                              NULL,dwRetCode,0);
            break;
        }

        dwRetCode = RegOpenKeyEx(
                                hKeyProtocols,
                                chSubKeyName,
                                0,
                                KEY_QUERY_VALUE,
                                &hKeyCp );


        if ( dwRetCode != NO_ERROR )
        {
            PppLogErrorString(ROUTERLOG_CANT_OPEN_PPP_REGKEY,0,NULL,
                              dwRetCode,0);
            break;
        }

        //
        // Find out the size of the path value.
        //

        dwRetCode = RegQueryInfoKey(
                                hKeyCp,
                                NULL,
                                NULL,
                                NULL,
                                &dwNumSubKeys,
                                &dwMaxSubKeySize,
                                NULL,
                                &dwNumValues,
                                &cbMaxValNameLen,
                                &cbMaxValueDataSize,
                                NULL,
                                NULL
                                );

        if ( dwRetCode != NO_ERROR )
        {
            PppLogErrorString(ROUTERLOG_CANT_OPEN_PPP_REGKEY,0,NULL,
                              dwRetCode,0);
            break;
        }

        //
        // Allocate space for path and add one for NULL terminator
        //

        pCpDllPath = (LPBYTE)LOCAL_ALLOC( LPTR, ++cbMaxValueDataSize );

        if ( pCpDllPath == (LPBYTE)NULL )
        {
            dwRetCode = GetLastError();
            PppLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode);
            break;
        }

        //
        // Read in the path
        //

        dwRetCode = RegQueryValueEx(
                                hKeyCp,
                                RAS_VALUENAME_PATH,
                                NULL,
                                &dwType,
                                pCpDllPath,
                                &cbMaxValueDataSize
                                );

        if ( dwRetCode != NO_ERROR )
        {
            PppLogError(ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );
            break;
        }

        if ( ( dwType != REG_EXPAND_SZ ) && ( dwType != REG_SZ ) )
        {
            dwRetCode = ERROR_REGISTRY_CORRUPT;
            PppLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );
            break;
        }

        //
        // Replace the %SystemRoot% with the actual path.
        //

        cbSize = ExpandEnvironmentStrings( pCpDllPath, NULL, 0 );

        if ( cbSize == 0 )
        {
            dwRetCode = GetLastError();
            PppLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );
            break;
        }

        pCpDllExpandedPath = (LPSTR)LOCAL_ALLOC( LPTR, ++cbSize );

        if ( pCpDllExpandedPath == (LPSTR)NULL )
        {
            dwRetCode = GetLastError();
            PppLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode);
            break;
        }

        cbSize = ExpandEnvironmentStrings(
                                pCpDllPath,
                                pCpDllExpandedPath,
                                cbSize );
        if ( cbSize == 0 )
        {
            dwRetCode = GetLastError();
            PppLogError(ROUTERLOG_CANT_GET_REGKEYVALUES,0,NULL,dwRetCode);
            break;
        }

        hInstance = LoadLibrary( pCpDllExpandedPath );

        if ( hInstance == (HINSTANCE)NULL )
        {
            dwRetCode = GetLastError();
            PppLogErrorString( ROUTERLOG_PPP_CANT_LOAD_DLL,1,
                               &pCpDllExpandedPath,dwRetCode, 1);
            break;
        }

        pRasCpEnumProtocolIds = GetProcAddress( hInstance,
                                                "RasCpEnumProtocolIds" );

        if ( pRasCpEnumProtocolIds == (FARPROC)NULL )
        {
            dwRetCode = GetLastError();
            PppLogErrorString( ROUTERLOG_PPPCP_DLL_ERROR, 1,
                        &pCpDllExpandedPath, dwRetCode, 1);
            break;
        }

        pCpDlls[dwKeyIndex].pRasCpEnumProtocolIds = pRasCpEnumProtocolIds;

        dwRetCode = (DWORD) (*pRasCpEnumProtocolIds)( ProtocolIds, &dwNumProtocolIds );

        if ( dwRetCode != NO_ERROR )
        {
            PppLogErrorString(ROUTERLOG_PPPCP_DLL_ERROR, 1,
                              &pCpDllExpandedPath, dwRetCode, 1);
            break;
        }

        (*pcTotalNumProtocols) += dwNumProtocolIds;

        pRasCpGetInfo = GetProcAddress( hInstance, "RasCpGetInfo" );

        if ( pRasCpGetInfo == (FARPROC)NULL )
        {
            dwRetCode = GetLastError();
            PppLogErrorString(ROUTERLOG_PPPCP_DLL_ERROR, 1,
                              &pCpDllExpandedPath, dwRetCode, 1);
            break;
        }

        pCpDlls[dwKeyIndex].pRasCpGetInfo = pRasCpGetInfo;

        RegCloseKey( hKeyCp );

        hKeyCp = (HKEY)NULL;

        pCpDlls[dwKeyIndex].pszModuleName = pCpDllExpandedPath;
        pCpDlls[dwKeyIndex].hInstance = hInstance;

        if ( NULL != pCpDllPath )
            LOCAL_FREE( pCpDllPath );

        pCpDllPath = (LPSTR)NULL;

    }

    if ( hKeyCp != (HKEY)NULL )
        RegCloseKey( hKeyCp );

    if ( pCpDllPath != (LPSTR)NULL )
        LOCAL_FREE( pCpDllPath );

    return( dwRetCode );
}

//**
//
// Call:        ReadPPPKeyValues
//
// Returns:     NO_ERROR        - Success
//              Non-zero        - Failure
//
// Description: Will read in all the values in the PPP key.
//
DWORD
ReadPPPKeyValues(
    IN HKEY  hKeyPpp
)
{
    DWORD       dwIndex;
    DWORD       dwRetCode;
    DWORD       cbValueBuf;
    DWORD       dwType;

    //
    // Run through and get all the PPP values
    //

    for ( dwIndex = 0; PppRegParams[dwIndex].pszValueName != NULL; dwIndex++ )
    {
        cbValueBuf = sizeof( DWORD );

        dwRetCode = RegQueryValueEx(
                                hKeyPpp,
                                PppRegParams[dwIndex].pszValueName,
                                NULL,
                                &dwType,
                                (LPBYTE)(PppRegParams[dwIndex].pValue),
                                &cbValueBuf
                                );

        if ((dwRetCode != NO_ERROR) && (dwRetCode != ERROR_FILE_NOT_FOUND))
        {
            PppLogError(ROUTERLOG_CANT_GET_REGKEYVALUES,0,NULL,dwRetCode);
            break;
        }

        if ( dwRetCode == ERROR_FILE_NOT_FOUND )
        {
            *(PppRegParams[dwIndex].pValue) = PppRegParams[dwIndex].dwDefValue;

            dwRetCode = NO_ERROR;
        }
        else
        {
            if ( ( dwType != REG_DWORD ) ||
                 ( *(PppRegParams[dwIndex].pValue) > PppRegParams[dwIndex].Max))
            {
                CHAR * pChar = PppRegParams[dwIndex].pszValueName;

                PppLogWarning(ROUTERLOG_REGVALUE_OVERIDDEN, 1,&pChar);

                *(PppRegParams[dwIndex].pValue)
                                        = PppRegParams[dwIndex].dwDefValue;
            }
        }
    }

    if ( dwRetCode != NO_ERROR )
    {
        return( ERROR_REGISTRY_CORRUPT );
    }

    //
    // If value is zero use defaults.
    //

    if ( PppConfigInfo.MaxTerminate == 0 )
    {
        PppConfigInfo.MaxTerminate = PPP_DEF_MAXTERMINATE;
    }

    if ( PppConfigInfo.MaxFailure == 0 )
    {
        PppConfigInfo.MaxFailure = PPP_DEF_MAXFAILURE;
    }

    if ( PppConfigInfo.MaxConfigure == 0 )
    {
        PppConfigInfo.MaxConfigure = PPP_DEF_MAXCONFIGURE;
    }

    if ( PppConfigInfo.MaxReject == 0 )
    {
        PppConfigInfo.MaxReject = PPP_DEF_MAXREJECT;
    }

    //
    // Really the number for request retries so subtract one.
    //

    PppConfigInfo.MaxTerminate--;
    PppConfigInfo.MaxConfigure--;

    return( NO_ERROR );
}

//**
//
// Call:        ReadRegistryInfo
//
// Returns:     NO_ERROR                - Success
//              non-zero WIN32 error    - failure
//
// Description: Will read all PPP information in the registry. Will load the
//              control and authentication protocol dlls and
//              initialze the CpTable with information about the protocols.
//
DWORD
ReadRegistryInfo(
    OUT HKEY * phKeyPpp
)
{
    HKEY        hKeyProtocols       = (HKEY)NULL;
    DWORD       dwNumSubKeys        = 0;
    DWORD       dwMaxSubKeySize;
    DWORD       dwNumValues;
    DWORD       cbMaxValNameLen;
    DWORD       cbMaxValueDataSize;
    DWORD       dwSecDescLen;
    FILETIME    LastWrite;
    DWORD       dwRetCode;
    DWORD       ProtocolIds[PPPCP_MAXCPSPERDLL];
    DWORD       dwNumProtocolIds;
    DWORD       cTotalNumProtocols = 0;
    PPPCP_ENTRY CpEntry;
    DWORD       dwIndex;
    DWORD       cbValueBuf;
    DWORD       dwType;
    DWORD       dwValue;

    do
    {
        dwRetCode = RegOpenKeyEx(
                                HKEY_LOCAL_MACHINE,
                                RAS_KEYPATH_PPP,
                                0,
                                KEY_READ,
                                phKeyPpp );


        if ( dwRetCode != NO_ERROR)
        {
            PppLogErrorString(ROUTERLOG_CANT_OPEN_PPP_REGKEY,0,NULL,
                              dwRetCode,0);
            break;
        }

        dwRetCode = RegOpenKeyEx(
                                HKEY_LOCAL_MACHINE,
                                RAS_KEYPATH_PROTOCOLS,
                                0,
                                KEY_READ,
                                &hKeyProtocols );


        if ( dwRetCode != NO_ERROR)
        {
            PppLogErrorString(ROUTERLOG_CANT_OPEN_PPP_REGKEY,0,NULL,
                              dwRetCode,0);
            break;
        }

        //
        // Find out how many sub-keys or dlls there are
        //

        dwRetCode = RegQueryInfoKey(
                                 hKeyProtocols,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &dwNumSubKeys,
                                 &dwMaxSubKeySize,
                                 NULL,
                                 &dwNumValues,
                                 &cbMaxValNameLen,
                                 &cbMaxValueDataSize,
                                 NULL,
                                 NULL
                                );

        if ( dwRetCode != NO_ERROR )
        {
            PppLogErrorString(ROUTERLOG_CANT_OPEN_PPP_REGKEY,0,
                              NULL,dwRetCode,0);
            break;
        }

        //
        // Cannot have no APs or NCPs
        //

        if ( dwNumSubKeys == 0 )
        {
            PppLogError( ROUTERLOG_NO_AUTHENTICATION_CPS, 0, NULL, 0 );
            dwRetCode = ERROR_REGISTRY_CORRUPT;
            break;
        }

        dwRetCode = ReadPPPKeyValues( *phKeyPpp );

        if ( dwRetCode != NO_ERROR )
        {
            break;
        }

        LoadParserDll( PppConfigInfo.hKeyPpp );

        //
        // Allocate space to hold entry points for all the CP dlls
        //

        pCpDlls = (DLL_ENTRY_POINTS*)LOCAL_ALLOC( LPTR,
                                                  sizeof( DLL_ENTRY_POINTS )
                                                  * (dwNumSubKeys + 1) );

        if ( pCpDlls == (DLL_ENTRY_POINTS*)NULL )
        {
            dwRetCode = GetLastError();
            PppLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode );
            break;
        }

        pCpDlls[dwNumSubKeys].hInstance = INVALID_HANDLE_VALUE;

        //
        // Load all the AP and CP dlls and get their entry points
        //

        dwRetCode = LoadProtocolDlls(
                                pCpDlls,
                                dwNumSubKeys,
                                hKeyProtocols,
                                &cTotalNumProtocols );

        if ( dwRetCode != NO_ERROR )
            break;

        //
        // We now know how big the CpTable structure has to be so allocate space
        // for it. Add one for LCP.
        //

        CpTable = (PPPCP_ENTRY *)LOCAL_ALLOC( LPTR, sizeof( PPPCP_ENTRY ) *
                                                  ( cTotalNumProtocols + 1 ) );

        if ( CpTable == (PPPCP_ENTRY *)NULL)
        {
            dwRetCode = GetLastError();
            PppLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode );
            break;
        }

        //
        // Now fill up the table. First fill up information for LCP
        //

        dwRetCode = LcpGetInfo( PPP_LCP_PROTOCOL,
                                  &(CpTable[LCP_INDEX].CpInfo) );

        if ( dwRetCode != NO_ERROR )
        {
            CHAR * pChar = "LCP";
            PppLogErrorString(ROUTERLOG_PPPCP_DLL_ERROR, 1,
                              &pChar, dwRetCode, 1);
            break;
        }

        PppConfigInfo.NumberOfCPs = 1;
        PppConfigInfo.NumberOfAPs = 0;

        //
        // Fill up the table with the loaded APs and CPs. The CPs start from
        // 1 and increase the APs start from cTotolNumProtocols and go down.
        //

        for ( dwIndex = 0; dwIndex < dwNumSubKeys; dwIndex++ )
        {

            dwRetCode = (DWORD)(pCpDlls[dwIndex].pRasCpEnumProtocolIds)(
                                                        ProtocolIds,
                                                        &dwNumProtocolIds );
            if ( dwRetCode != NO_ERROR )
            {
                PppLogErrorString(
                          ROUTERLOG_PPPCP_DLL_ERROR,
                          1,
                          &(pCpDlls[dwIndex].pszModuleName),
                          dwRetCode,
                          1 );
                break;
            }

            if ( ( dwNumProtocolIds == 0 ) ||
                 ( dwNumProtocolIds > PPPCP_MAXCPSPERDLL ) )
            {
                dwRetCode = ERROR_INVALID_PARAMETER;

                PppLogErrorString(
                          ROUTERLOG_PPPCP_DLL_ERROR,
                          1,
                          &(pCpDlls[dwIndex].pszModuleName),
                          dwRetCode,
                          1 );
                break;
            }

            while( dwNumProtocolIds-- > 0 )
            {
                ZeroMemory( &CpEntry, sizeof( CpEntry ) );

                dwRetCode = (DWORD)(pCpDlls[dwIndex].pRasCpGetInfo)(
                                          ProtocolIds[dwNumProtocolIds],
                                          &CpEntry.CpInfo );


                if ( dwRetCode != NO_ERROR )
                {
                    PppLogErrorString(
                              ROUTERLOG_PPPCP_DLL_ERROR,
                              1,
                              &(pCpDlls[dwIndex].pszModuleName),
                              dwRetCode,
                              1 );
                    break;
                }

                if ( CpEntry.CpInfo.Protocol == PPP_IPCP_PROTOCOL )
                {
                    PppConfigInfo.RasIpcpDhcpInform =
                        (DWORD(*)(VOID*, PPP_DHCP_INFORM*))
                        IpcpDhcpInform;
                    PppConfigInfo.RasIphlpDhcpCallback =
                        (VOID(*)(ULONG))
                        RasSrvrDhcpCallback;
                }

                if ( CpEntry.CpInfo.RasCpInit != NULL )
                {
                    if (   (PPP_IPCP_PROTOCOL == CpEntry.CpInfo.Protocol)
                        || (PPP_IPXCP_PROTOCOL == CpEntry.CpInfo.Protocol)
                        || (PPP_NBFCP_PROTOCOL == CpEntry.CpInfo.Protocol)
                        || (PPP_ATCP_PROTOCOL == CpEntry.CpInfo.Protocol)
                       )
                    {
                        // Do not init the CP.
                    }
                    else
                    {
                        PppLog(1, "RasCpInit(%x, TRUE)", CpEntry.CpInfo.Protocol);

                        dwRetCode = CpEntry.CpInfo.RasCpInit(
                                        TRUE/* fInitialize */);

                        CpEntry.fFlags |= PPPCP_FLAG_INIT_CALLED;

                        if ( dwRetCode != NO_ERROR )
                        {
                            CHAR*   SubStringArray[2];

                            SubStringArray[0] = CpEntry.CpInfo.SzProtocolName;
                            SubStringArray[1] = pCpDlls[dwIndex].pszModuleName;

                            PppLogErrorString(
                                      ROUTERLOG_PPPCP_INIT_ERROR,
                                      2,
                                      SubStringArray,
                                      dwRetCode,
                                      2 );
                            break;
                        }
                        else
                        {
                            CpEntry.fFlags |= PPPCP_FLAG_AVAILABLE;
                        }
                    }
                }

                //
                // If this entry point is NULL we assume that this is a CP.
                //

                if ( CpEntry.CpInfo.RasApMakeMessage == NULL )
                {
                    if ( ( CpEntry.CpInfo.RasCpBegin             == NULL )  ||
                         ( CpEntry.CpInfo.RasCpEnd               == NULL )  ||
                         ( CpEntry.CpInfo.RasCpReset             == NULL )  ||
                         ( CpEntry.CpInfo.RasCpMakeConfigRequest == NULL )  ||
                         ( CpEntry.CpInfo.RasCpMakeConfigResult  == NULL )  ||
                         ( CpEntry.CpInfo.RasCpConfigAckReceived == NULL )  ||
                         ( CpEntry.CpInfo.RasCpConfigNakReceived == NULL )  ||
                         ( CpEntry.CpInfo.RasCpConfigRejReceived == NULL )  ||
                         ( CpEntry.CpInfo.Recognize > ( DISCARD_REQ + 1) ) )
                    {
                        dwRetCode = ERROR_INVALID_PARAMETER;

                        PppLogErrorString(
                                  ROUTERLOG_PPPCP_DLL_ERROR,
                                  1,
                                  &(pCpDlls[dwIndex].pszModuleName),
                                  dwRetCode,
                                  1 );
                        break;
                    }

                    CpTable[PppConfigInfo.NumberOfCPs++] = CpEntry;
                }
                else
                {
                    CpTable[cTotalNumProtocols-PppConfigInfo.NumberOfAPs]
                            = CpEntry;
                    PppConfigInfo.NumberOfAPs++;
                }
            }

            if ( dwRetCode != NO_ERROR )
                break;
        }

        if ( GetCpIndexFromProtocol( PPP_BACP_PROTOCOL ) == (DWORD)-1 )
        {
            PppConfigInfo.ServerConfigInfo.dwConfigMask &= ~PPPCFG_NegotiateBacp;
        }
        else if ( PppConfigInfo.ServerConfigInfo.dwConfigMask & 
                  PPPCFG_NegotiateBacp )
        {
            cbValueBuf = sizeof(DWORD);

            if (RegQueryValueEx(
                      *phKeyPpp, RAS_VALUENAME_DOBAPONVPN, 
                      NULL, &dwType,
                      (LPBYTE )&dwValue, &cbValueBuf ) == 0
                   && dwType == REG_DWORD
                   && cbValueBuf == sizeof(DWORD)
                   && dwValue)
            {
                FDoBapOnVpn = TRUE;

                BapTrace( "Allowing BAP over VPN's" );
            }
        }

    } while( FALSE );

    if ( dwRetCode != NO_ERROR )
    {
        if ( CpTable != (PPPCP_ENTRY *)NULL )
        {
            LOCAL_FREE( CpTable );
        }
    }

    if ( hKeyProtocols != (HKEY)NULL )
    {
        RegCloseKey( hKeyProtocols );
    }

    if ( pCpDlls != (DLL_ENTRY_POINTS*)NULL )
    {
        for ( dwIndex = 0; dwIndex < dwNumSubKeys; dwIndex++ )
        {
            if ( pCpDlls[dwIndex].pszModuleName != (LPSTR)NULL )
            {
                LOCAL_FREE( pCpDlls[dwIndex].pszModuleName );
            }
        }

        if ( dwRetCode != NO_ERROR )
        {
            LOCAL_FREE( pCpDlls );

            pCpDlls = NULL;
        }
    }

    return( dwRetCode );
}

//**
//
// Call:        InitializePPP
//
// Returns:     NO_ERROR        - Success
//              non-zero code   - Failure
//
// Description: Will initialize all global data and load and initialize the
//              Control and Authentication protocol dll.s
//
DWORD
InitializePPP(
    VOID
)
{
    DWORD               dwIndex;
    DWORD               dwTId;
    DWORD               dwRetCode;
    HANDLE              hThread;
    NT_PRODUCT_TYPE     NtProductType;

	srand ( (unsigned int)time ( NULL ) );
    PppConfigInfo.dwTraceId = TraceRegisterA( "PPP" );
    DwBapTraceId = TraceRegisterA( "BAP" );
    // PrivateTraceId = TraceRegisterA( "Private" );

    PppConfigInfo.hLogEvents = RouterLogRegister( TEXT("RemoteAccess") );

    PppConfigInfo.RasIpcpDhcpInform     = NULL;
    PppConfigInfo.RasIphlpDhcpCallback  = NULL;
    PppConfigInfo.dwLoggingLevel        = 3;

    //
    // Create DDM private heap
    //

    PppConfigInfo.hHeap = HeapCreate( 0, PPP_HEAP_INITIAL_SIZE,
                                         PPP_HEAP_MAX_SIZE );

    if ( PppConfigInfo.hHeap == NULL )
    {
        return( GetLastError() );
    }

    if ( (dwRetCode = ReadRegistryInfo(&(PppConfigInfo.hKeyPpp))) != NO_ERROR )
    {
        return( dwRetCode );
    }

    dwRetCode = InitEndpointDiscriminator(PppConfigInfo.EndPointDiscriminator);

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    PppConfigInfo.PortUIDGenerator = 0;

    //
    // Initialize global data-structures
    //

    //
    // Allocate hash table for PCBs
    //

    PcbTable.PcbBuckets = LOCAL_ALLOC( LPTR,
                                      sizeof( PCB_BUCKET ) *
                                      PcbTable.NumPcbBuckets );

    if ( PcbTable.PcbBuckets == NULL )
    {
        return( GetLastError() );
    }

    //
    // Allocate hash table for BCBs
    //

    PcbTable.BcbBuckets = LOCAL_ALLOC( LPTR,
                                      sizeof( BCB_BUCKET ) *
                                      PcbTable.NumPcbBuckets );

    if ( PcbTable.BcbBuckets == NULL )
    {
        LOCAL_FREE( PcbTable.PcbBuckets );

        return( GetLastError() );
    }

    for( dwIndex = 0; dwIndex < PcbTable.NumPcbBuckets; dwIndex++ )
    {
        PcbTable.PcbBuckets[dwIndex].pPorts = (PCB *)NULL;

        PcbTable.BcbBuckets[dwIndex].pBundles = (BCB *)NULL;
    }

    WorkItemQ.pQHead = (PCB_WORK_ITEM*)NULL;
    WorkItemQ.pQTail = (PCB_WORK_ITEM*)NULL;

    InitializeCriticalSection( &(WorkItemQ.CriticalSection) );

    WorkItemQ.hEventNonEmpty = CreateEvent( NULL, TRUE, FALSE, NULL );

    if ( WorkItemQ.hEventNonEmpty == (HANDLE)NULL )
    {
        return( GetLastError() );
    }

    TimerQ.hEventNonEmpty = CreateEvent( NULL, FALSE, FALSE, NULL );

    if ( TimerQ.hEventNonEmpty == (HANDLE)NULL )
    {
        return( GetLastError() );
    }

    PppConfigInfo.hEventChangeNotification = CreateEvent(NULL,FALSE,FALSE,NULL);

    if ( PppConfigInfo.hEventChangeNotification == (HANDLE)NULL )
    {
        return( GetLastError() );
    }

    RtlGetNtProductType( &NtProductType );

    if ( NtProductWinNt == NtProductType )
    {
        PppConfigInfo.fFlags |= PPPCONFIG_FLAG_WKSTA;
    }

    //
    // Create worker thread.
    //

    hThread = CreateThread( NULL, 0, WorkerThread, NULL, 0, &dwTId );

    if ( hThread == (HANDLE)NULL )
    {
        return( GetLastError() );
    }
    CloseHandle(hThread);

    return( NO_ERROR );
}

//**
//
// Call:        PPPCleanUp
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will de-allocate all allocated memory, close all handles and
//              reset all the global structures to 0.
//
VOID
PPPCleanUp(
    VOID
)
{
    DWORD   dwIndex;
    DWORD   dwError;
    DWORD   cTotalNumProtocols;

    //
    // Unload DLLs.
    //

    cTotalNumProtocols = PppConfigInfo.NumberOfCPs + PppConfigInfo.NumberOfAPs;

    if ( pCpDlls != NULL )
    {
        for ( dwIndex = 0; dwIndex < cTotalNumProtocols; dwIndex++ )
        {
            if ( CpTable[dwIndex].fFlags & PPPCP_FLAG_INIT_CALLED )
            {
                PppLog( 1, "RasCpInit(%x, FALSE)",
                    CpTable[dwIndex].CpInfo.Protocol );

                dwError = CpTable[dwIndex].CpInfo.RasCpInit(
                                FALSE /* fInitialize */ );

                if ( NO_ERROR != dwError )
                {
                    PppLog(
                        1,
                        "RasCpInit(FALSE) for protocol 0x%x returned error %d",
                        CpTable[dwIndex].CpInfo.Protocol,
                        dwError );
                }

                CpTable[dwIndex].fFlags &= ~PPPCP_FLAG_INIT_CALLED;
                CpTable[dwIndex].fFlags &= ~PPPCP_FLAG_AVAILABLE;
            }
        }

        for ( dwIndex = 0;
              pCpDlls[dwIndex].hInstance != INVALID_HANDLE_VALUE;
              dwIndex++ )
        {
            if ( pCpDlls[dwIndex].hInstance != NULL )
            {
                FreeLibrary( pCpDlls[dwIndex].hInstance );
            }
        }
        if ( pCpDlls )
            LOCAL_FREE( pCpDlls );

        pCpDlls = NULL;
    }

    RouterLogDeregister( PppConfigInfo.hLogEvents );

    DeleteCriticalSection( &(WorkItemQ.CriticalSection) );

    if ( TimerQ.hEventNonEmpty != NULL )
    {
        CloseHandle( TimerQ.hEventNonEmpty );
    }

    if ( WorkItemQ.hEventNonEmpty != NULL )
    {
        CloseHandle( WorkItemQ.hEventNonEmpty );
    }

    if ( PppConfigInfo.hEventChangeNotification != NULL )
    {
        CloseHandle( PppConfigInfo.hEventChangeNotification );
    }

    //
    // Destroy private heap
    //

    if ( PppConfigInfo.hHeap != NULL )
    {
        HeapDestroy( PppConfigInfo.hHeap );
    }

    if ( PppConfigInfo.dwTraceId != INVALID_TRACEID )
    {
        TraceDeregisterA( PppConfigInfo.dwTraceId );
    }

    if ( PppConfigInfo.hKeyPpp != (HKEY)NULL )
    {
        RegCloseKey( PppConfigInfo.hKeyPpp );
    }

    if ( NULL != PppConfigInfo.hInstanceParserDll )
    {
        FreeLibrary( PppConfigInfo.hInstanceParserDll );
    }

    if (NULL != PppConfigInfo.pszParserDllPath)
    {
        LOCAL_FREE(PppConfigInfo.pszParserDllPath);
    }
    PppConfigInfo.pszParserDllPath = NULL;

    PppConfigInfo.PacketFromPeer = NULL;
    PppConfigInfo.PacketToPeer = NULL;
    PppConfigInfo.PacketFree = NULL;

    //
    // TraceDeregisterA can handle INVALID_TRACEID gracefully
    //

    TraceDeregisterA( DwBapTraceId );

    ZeroMemory( &PcbTable, sizeof( PcbTable ) );

    ZeroMemory( &WorkItemQ, sizeof( WorkItemQ ) );

    ZeroMemory( &PppConfigInfo, sizeof( PppConfigInfo ) );

    ZeroMemory( &TimerQ, sizeof( TimerQ ) );

    CpTable = NULL;
}

//**
//
// Call:        DllEntryPoint
//
// Returns:     TRUE    - Success
//              FALSE   - Failure
//
// Description:
//
BOOL
DllEntryPoint(
    IN  HANDLE  hInstDLL,
    IN  DWORD   fdwReason,
    IN  LPVOID  lpvReserved
)
{
    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:

        HInstDLL = hInstDLL;
        DisableThreadLibraryCalls(hInstDLL);

        break;
    }

    return(TRUE);
}

//**
//
// Call:        RasCpEnumProtocolIds
//
// Returns:     NO_ERROR    - Success
//
// Description: This entry point is called to enumerate the number and the
//              control protocol Ids for the protocols contained in the module.
//
DWORD
RasCpEnumProtocolIds(
    OUT    DWORD * pdwProtocolIds,
    IN OUT DWORD * pcProtocolIds
)
{
    DWORD   dwIndex;
    HKEY    hKey;
    DWORD   dwErr;
    DWORD   dwType;
    DWORD   dwValue;
    DWORD   dwSize;

    PppLog(1, "RasCpEnumProtocolIds");

    RTASSERT(NUM_BUILT_IN_CPS <= PPPCP_MAXCPSPERDLL);

    *pcProtocolIds = 0;

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RAS_KEYPATH_BUILTIN, 0, KEY_READ,
                &hKey);

    if (ERROR_SUCCESS == dwErr)
    {
        for (dwIndex = 0; dwIndex < NUM_BUILT_IN_CPS; dwIndex++)
        {
            dwSize = sizeof(dwValue);

            dwErr = RegQueryValueEx(hKey, BuiltInCps[dwIndex].szNegotiateCp,
                        NULL, &dwType, (BYTE*)&dwValue, &dwSize);

            if (   ERROR_SUCCESS == dwErr
                && REG_DWORD == dwType
                && sizeof(DWORD) == dwSize
                && !dwValue)
            {
                BuiltInCps[dwIndex].fLoad = FALSE;
                PppLog(1, "%s is FALSE", BuiltInCps[dwIndex].szNegotiateCp);
            }
        }

        RegCloseKey(hKey);
    }

    for (dwIndex = 0; dwIndex < NUM_BUILT_IN_CPS; dwIndex++)
    {
        if (BuiltInCps[dwIndex].fLoad)
        {
            pdwProtocolIds[*pcProtocolIds] = BuiltInCps[dwIndex].dwProtocolId;
            PppLog(1, "Protocol %x", BuiltInCps[dwIndex].dwProtocolId);
            *pcProtocolIds += 1;
        }
    }

    return(NO_ERROR);
}

//**
//
// Call:    RasCpGetInfo
//
// Returns: NO_ERROR                - Success
//          ERROR_INVALID_PARAMETER - Protocol id is unrecogized
//
// Description: This entry point is called for get all information for the
//              control protocol in this module.
//
DWORD
RasCpGetInfo(
    IN  DWORD       dwProtocolId,
    OUT PPPCP_INFO* pCpInfo
)
{
    DWORD   dwIndex;

    PppLog(1, "RasCpGetInfo %x", dwProtocolId);

    for (dwIndex = 0; dwIndex < NUM_BUILT_IN_CPS; dwIndex++)
    {
        if (   (BuiltInCps[dwIndex].dwProtocolId == dwProtocolId)
            && BuiltInCps[dwIndex].fLoad)
        {
            return((DWORD)BuiltInCps[dwIndex].pRasCpGetInfo(
                            dwProtocolId, pCpInfo));
        }
    }

    return(ERROR_INVALID_PARAMETER);
}

VOID
PrivateTrace(
    IN  CHAR*   Format,
    ...
)
{
    va_list arglist;

    va_start(arglist, Format);

    TraceVprintfEx(PrivateTraceId,
                   0x00010000 | TRACE_USE_MASK | TRACE_USE_MSEC,
                   Format,
                   arglist);

    va_end(arglist);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\engine\init.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    init.h
//
// Description: This file contains prototypes of functions to initialize the
//              PPP engine
//
// History:
//          Nov 11,1993.        NarenG          Created original version.
//

DWORD
LoadProtocolDlls(
    IN  DLL_ENTRY_POINTS * pCpDlls,
    IN  DWORD              cCpDlls,
    IN  HKEY               hKeyPpp,
    OUT DWORD *            pcTotalNumProtocols 
);

DWORD
ReadPPPKeyValues(
    IN HKEY     hKeyPpp
);

DWORD
ReadRegistryInfo(
    OUT HKEY *  phkeyPpp
);

DWORD
InitializePPP(
    VOID
);

VOID
PPPCleanUp(
    VOID 
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\engine\lcp.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.     **/
/********************************************************************/

//***
//
// Filename:    lcp.h
//
// Description: 
//
// History:
//  Nov 11,1993.    NarenG      Created original version.
//

#ifndef _LCP_
#define _LCP_

//
// LCP option types 
//

#define LCP_OPTION_MRU          0x01
#define LCP_OPTION_ACCM         0x02
#define LCP_OPTION_AUTHENT      0x03
#define LCP_OPTION_MAGIC        0x05
#define LCP_OPTION_PFC          0x07
#define LCP_OPTION_ACFC         0x08
#define LCP_OPTION_CALLBACK     0x0D
#define LCP_OPTION_MRRU         0x11
#define LCP_OPTION_SHORT_SEQ    0x12
#define LCP_OPTION_ENDPOINT     0x13
#define LCP_OPTION_LINK_DISCRIM 0x17
#define LCP_OPTION_LIMIT        0x17    // highest # we can handle 

//
// Authentication protocols
//

#define  LCP_AP_FIRST           0x00000001
#define  LCP_AP_EAP             0x00000001
#define  LCP_AP_CHAP_MS_NEW     0x00000002
#define  LCP_AP_CHAP_MS         0x00000004
#define  LCP_AP_CHAP_MD5        0x00000008
#define  LCP_AP_SPAP_NEW        0x00000010
#define  LCP_AP_SPAP_OLD        0x00000020
#define  LCP_AP_PAP             0x00000040
#define  LCP_AP_MAX             0x00000080

//
// Table for LCP configuration requests 
//

typedef struct _LCP_OPTIONS 
{
    DWORD Negotiate;            // negotiation flags 

#define LCP_N_MRU               (1 << LCP_OPTION_MRU)
#define LCP_N_ACCM              (1 << LCP_OPTION_ACCM)
#define LCP_N_AUTHENT           (1 << LCP_OPTION_AUTHENT)
#define LCP_N_MAGIC             (1 << LCP_OPTION_MAGIC)
#define LCP_N_PFC               (1 << LCP_OPTION_PFC)
#define LCP_N_ACFC              (1 << LCP_OPTION_ACFC)
#define LCP_N_CALLBACK          (1 << LCP_OPTION_CALLBACK)
#define LCP_N_MRRU              (1 << LCP_OPTION_MRRU)
#define LCP_N_SHORT_SEQ         (1 << LCP_OPTION_SHORT_SEQ)
#define LCP_N_ENDPOINT          (1 << LCP_OPTION_ENDPOINT)
#define LCP_N_LINK_DISCRIM      (1 << LCP_OPTION_LINK_DISCRIM)

    DWORD MRU;                  // Maximum Receive Unit 
    DWORD ACCM;                 // Async Control Char Map 
    DWORD AP;                   // Authentication protocol 
    DWORD APDataSize;           // Auth. protocol data size in bytes
    PBYTE pAPData;              // Pointer Auth. protocol data
    DWORD MagicNumber;          // Magic number value 
    DWORD PFC;                  // Protocol field compression.
    DWORD ACFC;                 // Address and Control Field Compression.
    DWORD Callback;             // Callback
    DWORD MRRU;                 // Maximum Reconstructed Receive Unit
    DWORD ShortSequence;        // Short Sequence Number Header Format
    BYTE  EndpointDiscr[21];    // Endpoint Discriminator.
    DWORD dwEDLength;           // Length of Endpoint Discriminator
    DWORD dwLinkDiscriminator;  // Link Discriminator (for BAP/BACP)

} LCP_OPTIONS, *PLCP_OPTIONS;

#define PPP_NEGOTIATE_CALLBACK  0x06

//
// Other configuration option values 
//

#define LCP_ACCM_DEFAULT        0xFFFFFFFFL
#define LCP_MRU_HI              1500            // High MRU limit 
#define LCP_MRU_LO              128             // Lower MRU limit 
#define LCP_DEFAULT_MRU         1500

#define LCP_REQ_TRY             20              // REQ attempts

#define LCP_SPAP_VERSION        0x01000001

//
//  Local.Want:           Options to request.
//                        Contains desired value.
//                        Only non-default options need to be negotiated.
//                        Initially, all are default.
//  Local.WillNegotiate:  Options to accept in a NAK from remote.
//  local.Work:           Options currently being negotiated.
//                        Value is valid only when negotiate bit is set.
//
//  Remote.Want:          Options to suggest by NAK if not present in REQ.
//                        Contains desired value.
//  Remote.WillNegotiate: Options to accept in a REQ from remote.
//  Remote.Work:          Options currently being negotiated.
//                        Value is valid only when negotiate bit is set.
// 

typedef struct _LCP_SIDE
{
    DWORD       WillNegotiate;

    DWORD       fAPsAvailable;

    DWORD       fLastAPTried;

    DWORD       fOldLastAPTried;

    LCP_OPTIONS Want;

    LCP_OPTIONS Work;

} LCP_SIDE, *PLCP_SIDE;

//
// LCP control block 
//

typedef struct _LCPCB
{
    HPORT               hPort;
   
    BOOL                fServer;

    BOOL                fRouter;

    DWORD               dwMRUFailureCount;

    DWORD               dwMagicNumberFailureCount;

    PPP_CONFIG_INFO     PppConfigInfo;

    LCP_SIDE            Local;

    LCP_SIDE            Remote;

}LCPCB, *PLCPCB;

DWORD
LcpGetInfo(
    IN  DWORD       dwProtocolId,
    OUT PPPCP_INFO* pCpInfo
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\engine\lcp.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.     **/
/********************************************************************/

//***
//
// Filename:    lcp.c
//
// Description: Contains entry points to configure LCP.
//
// History:
//  Nov 11,1993.    NarenG      Created original version.
//
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>     // needed for winbase.h

#include <windows.h>    // Win32 base API's
#include <stdlib.h>
#include <string.h>
#include <wchar.h>

#include <lmcons.h>
#include <raserror.h>
#include <mprerror.h>
#include <rasman.h>
#include <rasppp.h>
#include <pppcp.h>
#include <ppp.h>
#include <smaction.h>
#include <lcp.h>
#include <timer.h>
#include <util.h>
#include <worker.h>

// 
// Default values
//

const static LCP_OPTIONS LcpDefault = 
{
    0,                  // Negotiation flags

    LCP_DEFAULT_MRU,    // Default value for MRU
    0xFFFFFFFF,         // Default ACCM value.
    0,                  // no authentication ( for client )  
    0,                  // no authentication data. ( for client )
    NULL,               // no authentication data. ( for client )
    0,                  // Magic Number.
    FALSE,              // Protocol field compression.
    FALSE,              // Address and Contorl-Field Compression.
    0,                  // Callback Operation message field
    LCP_DEFAULT_MRU,    // Default value for MRRU == MRU according to RFC1717
    0,                  // No short sequencing
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,   // No endpoint discriminator
    0,                  // Length of Endpoint Discriminator
    0                   // Link Discriminator (for BAP/BACP)
};

//
// Accept anything we understand in the NAK and in a REQ from a remote host
//

static DWORD LcpNegotiate = LCP_N_MRU       | LCP_N_ACCM     | LCP_N_MAGIC | 
                            LCP_N_PFC       | LCP_N_ACFC;
                
static DWORD SizeOfOption[] = 
{
    0,                          // unused 
    PPP_OPTION_HDR_LEN + 2,     // MRU 
    PPP_OPTION_HDR_LEN + 4,     // ACCM 
    PPP_OPTION_HDR_LEN + 2,     // authentication 
    0,                          // Unused.
    PPP_OPTION_HDR_LEN + 4,     // magic number 
    0,                          // Reserved, unused
    PPP_OPTION_HDR_LEN + 0,     // Protocol compression 
    PPP_OPTION_HDR_LEN + 0,     // Address/Control compression 
    0,                          // Unused
    0,                          // Unused
    0,                          // Unused
    0,                          // Unused
    PPP_OPTION_HDR_LEN + 1,     // Callback
    0,                          // Unused
    0,                          // Unused
    0,                          // Unused
    PPP_OPTION_HDR_LEN + 2,     // MRRU
    PPP_OPTION_HDR_LEN + 0,     // Short Sequence Header Format
    PPP_OPTION_HDR_LEN,         // Endpoint Discriminator
    0,                          // Unused
    0,                          // Unused
    0,                          // Unused
    PPP_OPTION_HDR_LEN + 2      // Link Discriminator (for BAP/BACP)
};

WORD WLinkDiscriminator = 0;    // Next Link Discriminator to use
BYTE BCount = 0;                // To make EndpointDiscriminator different


//**
//
// Call:        MakeAuthProtocolOption
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Given a certain authentication protocol, will construct the
//              configuration option for it.
//
DWORD
MakeAuthProtocolOption(
    IN LCP_SIDE *  pLcpSide
)
{
    switch( pLcpSide->fLastAPTried )
    {
    case LCP_AP_EAP:

        pLcpSide->Work.AP = PPP_EAP_PROTOCOL;

        if ( pLcpSide->Work.APDataSize != 0 )
        {
            pLcpSide->Work.APDataSize = 0;

            if ( pLcpSide->Work.pAPData != NULL )
            {
                LOCAL_FREE( pLcpSide->Work.pAPData );
                pLcpSide->Work.pAPData = NULL;
            }
        }

        break;

    case LCP_AP_CHAP_MS:
    case LCP_AP_CHAP_MS_NEW:
    default:

        pLcpSide->Work.AP = PPP_CHAP_PROTOCOL;

        if ( pLcpSide->Work.APDataSize != 1 )
        {
            pLcpSide->Work.APDataSize = 1;

            if ( NULL != pLcpSide->Work.pAPData )
            {
                LOCAL_FREE( pLcpSide->Work.pAPData );
                pLcpSide->Work.pAPData = NULL;
            }

            pLcpSide->Work.pAPData = (PBYTE)LOCAL_ALLOC( 
                                                LPTR,
                                                pLcpSide->Work.APDataSize );

            if ( pLcpSide->Work.pAPData == NULL )
            {
                pLcpSide->Work.APDataSize = 0;
                return( GetLastError() );
            }
        }

        if ( pLcpSide->fLastAPTried == LCP_AP_CHAP_MS_NEW )
        {
            *(pLcpSide->Work.pAPData) = PPP_CHAP_DIGEST_MSEXT_NEW;
        }
        else
        {
            *(pLcpSide->Work.pAPData) = PPP_CHAP_DIGEST_MSEXT;
        }

        break;

    case LCP_AP_CHAP_MD5:

        pLcpSide->Work.AP = PPP_CHAP_PROTOCOL;

        if ( pLcpSide->Work.APDataSize != 1 )
        {
            pLcpSide->Work.APDataSize = 1;

            if ( NULL != pLcpSide->Work.pAPData )
            {
                LOCAL_FREE( pLcpSide->Work.pAPData );
                pLcpSide->Work.pAPData = NULL;
            }

            pLcpSide->Work.pAPData = (PBYTE)LOCAL_ALLOC( 
                                                LPTR,
                                                pLcpSide->Work.APDataSize );

            if ( pLcpSide->Work.pAPData == NULL )
            {
                pLcpSide->Work.APDataSize = 0;
                return( GetLastError() );
            }
        }

        *(pLcpSide->Work.pAPData) = PPP_CHAP_DIGEST_MD5;

        break;

    case LCP_AP_SPAP_NEW:

        pLcpSide->Work.AP = PPP_SPAP_NEW_PROTOCOL;

        if ( pLcpSide->Work.APDataSize != 4 )
        {
            pLcpSide->Work.APDataSize = 4;

            if ( NULL != pLcpSide->Work.pAPData )
            {
                LOCAL_FREE( pLcpSide->Work.pAPData );
                pLcpSide->Work.pAPData = NULL;
            }

            pLcpSide->Work.pAPData = (PBYTE)LOCAL_ALLOC( 
                                                LPTR,
                                                pLcpSide->Work.APDataSize );

            if ( pLcpSide->Work.pAPData == NULL )
            {
                pLcpSide->Work.APDataSize = 0;
                return( GetLastError() );
            }
        }
                
        HostToWireFormat32( LCP_SPAP_VERSION, pLcpSide->Work.pAPData );

        break;

    case LCP_AP_PAP:

        pLcpSide->Work.AP = PPP_PAP_PROTOCOL;

        if ( pLcpSide->Work.APDataSize != 0 )
        {
            pLcpSide->Work.APDataSize = 0;

            if ( pLcpSide->Work.pAPData != NULL )
            {
                LOCAL_FREE( pLcpSide->Work.pAPData );
                pLcpSide->Work.pAPData = NULL;
            }
        }

        break;
    }

    return( NO_ERROR );
}

//**
//
// Call:    LcpBegin
//
// Returns: NO_ERROR    - Success
//      non-zero error  - Failure
//      
//
// Description: Called once before any other call to LCP is made. Allocate 
//      a work buffer and initialize it.
//
DWORD
LcpBegin(
    IN OUT VOID** ppWorkBuf, 
    IN     VOID*  pInfo
)
{
    LCPCB *                     pLcpCb;
    RAS_FRAMING_CAPABILITIES    RasFramingCapabilities;
    DWORD                       dwRetCode;
    DWORD                       dwIndex;
    PPPCP_INIT *                pPppCpInit;

    *ppWorkBuf = LOCAL_ALLOC( LPTR, sizeof( LCPCB ) );

    if ( *ppWorkBuf == NULL )
    {
        return( GetLastError() );
    }

    pLcpCb = (LCPCB *)*ppWorkBuf;
    pPppCpInit = (PPPCP_INIT *)pInfo;

    pLcpCb->fServer       = pPppCpInit->fServer;
    pLcpCb->hPort         = pPppCpInit->hPort;
    pLcpCb->PppConfigInfo = pPppCpInit->PppConfigInfo;;
    pLcpCb->fRouter       = ( pPppCpInit->IfType == 
                                                ROUTER_IF_TYPE_FULL_ROUTER );
    pLcpCb->dwMagicNumberFailureCount = 0;
    pLcpCb->dwMRUFailureCount = 2;
    
	//
	// Check to see if we need to override the  Negotiate Multi Link
	// send by the caller
	// BugID: WINSE 17061 Windows Bugs: 347562
	if ( PppConfigInfo.dwDontNegotiateMultiLinkOnSingleLink )
	{
		//remove NegotiateMultiLink from config info
		PppLog( 2, "Removing NegotiateMultilink due to registry override" );
		pLcpCb->PppConfigInfo.dwConfigMask &= ~PPPCFG_NegotiateMultilink;
	}

    //
    // Set up defaults
    //

    CopyMemory( &(pLcpCb->Local.Want),  &LcpDefault, sizeof( LCP_OPTIONS ) );
    CopyMemory( &(pLcpCb->Remote.Want), &LcpDefault, sizeof( LCP_OPTIONS ) );

    //
    // Get Framing information from the driver.
    //

    dwRetCode = RasGetFramingCapabilities( pLcpCb->hPort, 
                                           &RasFramingCapabilities );
    if ( dwRetCode != NO_ERROR )
    {
        LOCAL_FREE( *ppWorkBuf );

        return( dwRetCode );
    }

    pLcpCb->Local.WillNegotiate  = LcpNegotiate;
    pLcpCb->Remote.WillNegotiate = LcpNegotiate;
    
    pLcpCb->Local.Want.MRU  = RasFramingCapabilities.RFC_MaxFrameSize;
    pLcpCb->Remote.Want.MRU = RasFramingCapabilities.RFC_MaxFrameSize;

    pLcpCb->Local.Want.Negotiate  = LCP_N_MAGIC;
    pLcpCb->Remote.Want.Negotiate = LCP_N_MAGIC;

    if (RasFramingCapabilities.RFC_MaxFrameSize != LCP_DEFAULT_MRU) {
        pLcpCb->Local.Want.Negotiate  |= LCP_N_MRU;
        pLcpCb->Remote.Want.Negotiate |= LCP_N_MRU;
    }

    if ( RasFramingCapabilities.RFC_FramingBits & PPP_COMPRESS_ADDRESS_CONTROL )
    {
        pLcpCb->Local.Want.ACFC = TRUE;
        pLcpCb->Local.Want.Negotiate |= LCP_N_ACFC;

        pLcpCb->Remote.Want.ACFC = TRUE;
        pLcpCb->Remote.Want.Negotiate |= LCP_N_ACFC;
    }

    if ( RasFramingCapabilities.RFC_FramingBits & PPP_COMPRESS_PROTOCOL_FIELD )
    {
        pLcpCb->Local.Want.PFC = TRUE;
        pLcpCb->Local.Want.Negotiate |= LCP_N_PFC;

        pLcpCb->Remote.Want.PFC = TRUE;
        pLcpCb->Remote.Want.Negotiate |= LCP_N_PFC;
    }

    if ( RasFramingCapabilities.RFC_FramingBits & PPP_ACCM_SUPPORTED )
    {
        pLcpCb->Local.Want.ACCM = RasFramingCapabilities.RFC_DesiredACCM;
        pLcpCb->Local.Want.Negotiate |= LCP_N_ACCM;
    }

    if ( pLcpCb->PppConfigInfo.dwConfigMask & PPPCFG_NegotiateMultilink )
    {
        pLcpCb->Local.Want.dwEDLength = 
                ( PppConfigInfo.EndPointDiscriminator[0] == 1 ) ? 21 : 7;

        CopyMemory( pLcpCb->Local.Want.EndpointDiscr, 
                    PppConfigInfo.EndPointDiscriminator,
                    pLcpCb->Local.Want.dwEDLength );

        if (   ( pPppCpInit->dwDeviceType & RDT_Tunnel )
            && ( !pPppCpInit->fServer ) )
        {
            //
            // If a VPN connection goes down unexpectedly, the server doesn't 
            // realize this for upto 2 min. When the client redials, we don't 
            // want the server to bundle the old link and the new one. Hence, 
            // we change the EndpointDiscriminator.
            //

            BCount++;
            pLcpCb->Local.Want.EndpointDiscr[pLcpCb->Local.Want.dwEDLength-1]
                += BCount;
        }

        pLcpCb->Local.Want.Negotiate  |= LCP_N_ENDPOINT;
        pLcpCb->Remote.Want.Negotiate |= LCP_N_ENDPOINT;

        pLcpCb->Local.Want.MRRU = 
                        RasFramingCapabilities.RFC_MaxReconstructedFrameSize;
        pLcpCb->Remote.Want.MRRU = 1500; // Can always handle sending 1500

        pLcpCb->Local.Want.Negotiate  |= LCP_N_MRRU;
        pLcpCb->Remote.Want.Negotiate |= LCP_N_MRRU;

        if ( RasFramingCapabilities.RFC_FramingBits & 
             PPP_SHORT_SEQUENCE_HDR_FORMAT )
        {
            pLcpCb->Local.Want.ShortSequence = TRUE;
            pLcpCb->Local.Want.Negotiate |= LCP_N_SHORT_SEQ;

            pLcpCb->Remote.Want.ShortSequence = TRUE;
            pLcpCb->Remote.Want.Negotiate |= LCP_N_SHORT_SEQ;
        }

        pLcpCb->Local.WillNegotiate  |= ( LCP_N_SHORT_SEQ | LCP_N_ENDPOINT | 
                                          LCP_N_MRRU );
        pLcpCb->Remote.WillNegotiate |= ( LCP_N_SHORT_SEQ | LCP_N_ENDPOINT | 
                                          LCP_N_MRRU );

        if ( pLcpCb->PppConfigInfo.dwConfigMask & PPPCFG_NegotiateBacp )
        {
            pLcpCb->Local.Want.dwLinkDiscriminator = WLinkDiscriminator++;
            pLcpCb->Remote.Want.dwLinkDiscriminator = 0;

            pLcpCb->Local.Want.Negotiate |= LCP_N_LINK_DISCRIM;
            pLcpCb->Remote.Want.Negotiate |= LCP_N_LINK_DISCRIM;

            pLcpCb->Local.WillNegotiate |= LCP_N_LINK_DISCRIM;
            pLcpCb->Remote.WillNegotiate |= LCP_N_LINK_DISCRIM;
        }
    }

    //
    // We always negotiate callback if this is not a callback
    //

    if ( !pPppCpInit->fThisIsACallback )
    {
        //
        // If the CBCP dll is loaded
        //

        if ( GetCpIndexFromProtocol( PPP_CBCP_PROTOCOL ) != (DWORD)-1 ) 
        {
            if ( pLcpCb->PppConfigInfo.dwConfigMask & PPPCFG_UseLcpExtensions )
            {
                pLcpCb->Local.Want.Negotiate |= LCP_N_CALLBACK;
                pLcpCb->Local.Want.Callback = PPP_NEGOTIATE_CALLBACK;
            }

            pLcpCb->Local.WillNegotiate  |= LCP_N_CALLBACK; 
            pLcpCb->Remote.WillNegotiate |= LCP_N_CALLBACK; 
        }
    }

    //
    // Figure out what authentication protocols we may use for this connection.
    //

    if ( pLcpCb->PppConfigInfo.dwConfigMask & PPPCFG_NegotiatePAP )
    {
        pLcpCb->Local.fAPsAvailable  |= LCP_AP_PAP;
        pLcpCb->Remote.fAPsAvailable |= LCP_AP_PAP;
    }

    if ( pLcpCb->PppConfigInfo.dwConfigMask & PPPCFG_NegotiateMD5CHAP )
    {
        pLcpCb->Remote.fAPsAvailable |= LCP_AP_CHAP_MD5;
        pLcpCb->Local.fAPsAvailable  |= LCP_AP_CHAP_MD5;
    }

    if ( pLcpCb->PppConfigInfo.dwConfigMask & PPPCFG_NegotiateMSCHAP )
    {
        pLcpCb->Local.fAPsAvailable  |= LCP_AP_CHAP_MS;
        pLcpCb->Remote.fAPsAvailable |= LCP_AP_CHAP_MS;
    }

    if ( pLcpCb->PppConfigInfo.dwConfigMask & PPPCFG_NegotiateEAP )
    {
        pLcpCb->Remote.fAPsAvailable |= LCP_AP_EAP;
        pLcpCb->Local.fAPsAvailable  |= LCP_AP_EAP;
    }

    if ( pLcpCb->PppConfigInfo.dwConfigMask & PPPCFG_NegotiateSPAP )
    {
        pLcpCb->Local.fAPsAvailable  |= LCP_AP_SPAP_NEW;
        pLcpCb->Remote.fAPsAvailable |= LCP_AP_SPAP_NEW;
    }

    if ( pLcpCb->PppConfigInfo.dwConfigMask & PPPCFG_NegotiateStrongMSCHAP )
    {
        pLcpCb->Local.fAPsAvailable  |= LCP_AP_CHAP_MS_NEW;
        pLcpCb->Remote.fAPsAvailable |= LCP_AP_CHAP_MS_NEW;
    }

    if ( pLcpCb->PppConfigInfo.dwConfigMask & PPPCFG_AllowNoAuthOnDCPorts )
    {
        pLcpCb->Local.fAPsAvailable  = 0;
        pLcpCb->Remote.fAPsAvailable = 0;
    }

    //
    // Make sure we have at least one authentication protocol if we are a 
    // server or a router dialing out. Fail if we are not allow no 
    // authentication.
    //

    if ( ( pLcpCb->Local.fAPsAvailable == 0 ) && 
         ( !( pLcpCb->PppConfigInfo.dwConfigMask & 
                                    PPPCFG_AllowNoAuthentication ) ) &&
         ( ( pLcpCb->fServer ) || ( pLcpCb->fRouter ) ) )
    {
        LOCAL_FREE( *ppWorkBuf );
        return( ERROR_NO_AUTH_PROTOCOL_AVAILABLE );
    }
        
    PppLog( 2, "ConfigInfo = %x", pLcpCb->PppConfigInfo.dwConfigMask );
    PppLog( 2, "APs available = %x", pLcpCb->Local.fAPsAvailable );

    //
    // If this is the server side or we are a router dialing out, 
    // we need to request an authentication protocol.
    //

    if ( ( pLcpCb->Local.fAPsAvailable > 0 ) && 
         (( pLcpCb->fServer ) || 
          ( ( pLcpCb->fRouter ) && 
          ( pLcpCb->PppConfigInfo.dwConfigMask & PPPCFG_AuthenticatePeer ))))
    {
        pLcpCb->Local.Want.Negotiate |= LCP_N_AUTHENT;
        pLcpCb->Local.WillNegotiate  |= LCP_N_AUTHENT; 
        pLcpCb->Local.Work.APDataSize = 0;
        pLcpCb->Local.Work.pAPData = NULL;
    }

    //
    // If this is the client side and no protocol other than MSCHAP v2 and EAP 
    // is allowed, then we insist on being authenticated.
    //

    if (!( pLcpCb->fServer ))
    {
        if ( ( pLcpCb->Remote.fAPsAvailable & ~( LCP_AP_CHAP_MS_NEW |
                                                LCP_AP_EAP ) ) == 0 )
        {
            pLcpCb->Remote.Work.APDataSize = 0;
            pLcpCb->Remote.Work.pAPData = NULL;
            pLcpCb->Remote.WillNegotiate  |= LCP_N_AUTHENT; 
            pLcpCb->Remote.Want.Negotiate |= LCP_N_AUTHENT;
        }
    }

    //
    // Accept authentication if there are authentication protocols available
    // If it turns out that it is a client dialing in then authentication
    // will fail and we will renegotiate and this time we will reject
    // authentication option. See auth.c.
    //

    if ( pLcpCb->Remote.fAPsAvailable > 0 )
    {
        pLcpCb->Remote.Work.APDataSize = 0;
        pLcpCb->Remote.Work.pAPData = NULL;
        pLcpCb->Remote.WillNegotiate |= LCP_N_AUTHENT; 
    }

    return( NO_ERROR );
}

//**
//
// Call:    LcpEnd
//
// Returns: NO_ERROR - Success
//
// Description: Frees the LCP work buffer.
//
DWORD
LcpEnd(
    IN VOID * pWorkBuf
)
{
    LCPCB * pLcpCb = (LCPCB *)pWorkBuf;

    PppLog( 2, "LcpEnd");

    if ( pLcpCb->Local.Work.pAPData != (PBYTE)NULL )
    {
        LOCAL_FREE( pLcpCb->Local.Work.pAPData );
    }

    if ( pLcpCb->Remote.Work.pAPData != (PBYTE)NULL )
    {
        LOCAL_FREE( pLcpCb->Remote.Work.pAPData );
    }

    if ( pWorkBuf != NULL )
    {
        LOCAL_FREE( pWorkBuf );
    }

    return( NO_ERROR );
}


//**
//
// Call:    LcpReset
//
// Returns: NO_ERROR - Success
//
// Description: Called to reset the state of LCP. Will re-initialize the work
//      buffer.
//
DWORD
LcpReset(
    IN VOID * pWorkBuf
)
{
    LCPCB * pLcpCb = (LCPCB *)pWorkBuf;
    PVOID   pAPData;
    DWORD   APDataSize;
    DWORD   dwIndex;
    DWORD   dwRetCode;

    //
    // Make sure we have at least one authentication protocol if we are a
    // server or a router dialing out. Fail if we are not allow no
    // authentication.
    //

    if ( ( pLcpCb->Local.fAPsAvailable == 0 ) &&
         ( !( pLcpCb->PppConfigInfo.dwConfigMask &
                                    PPPCFG_AllowNoAuthentication ) ) &&
         ( ( pLcpCb->fServer ) || ( pLcpCb->fRouter ) ) )
    {
        return( ERROR_NO_AUTH_PROTOCOL_AVAILABLE );
    }

    pLcpCb->dwMagicNumberFailureCount = 0;

    if ( pLcpCb->Local.Want.Negotiate & LCP_N_MAGIC ) 
    {
        srand( GetCurrentTime() );

        //
        // Shift left since rand returns a max of 0x7FFF
        //

        pLcpCb->Local.Want.MagicNumber = ( rand() << 16 );

        pLcpCb->Local.Want.MagicNumber += rand();

        //
        // Make sure that this is not 0
        //

        if ( pLcpCb->Local.Want.MagicNumber == 0 )
        {
            pLcpCb->Local.Want.MagicNumber = 23;
        }

        pLcpCb->Remote.Want.MagicNumber = pLcpCb->Local.Want.MagicNumber + 1;
    }

    pAPData    = pLcpCb->Local.Work.pAPData;
    APDataSize = pLcpCb->Local.Work.APDataSize;

    CopyMemory( &(pLcpCb->Local.Work),
                &(pLcpCb->Local.Want),
                sizeof(LCP_OPTIONS) );

    pLcpCb->Local.Work.pAPData    = pAPData;
    pLcpCb->Local.Work.APDataSize = APDataSize;

    pAPData    = pLcpCb->Remote.Work.pAPData;
    APDataSize = pLcpCb->Remote.Work.APDataSize;

    CopyMemory( &(pLcpCb->Remote.Work),
                 &(pLcpCb->Remote.Want),
                 sizeof(LCP_OPTIONS));

    pLcpCb->Remote.Work.pAPData    = pAPData;
    pLcpCb->Remote.Work.APDataSize = APDataSize;

    if ( ( pLcpCb->Local.fAPsAvailable > 0 ) &&
         (( pLcpCb->fServer ) || 
         ( ( pLcpCb->fRouter ) && 
           ( pLcpCb->PppConfigInfo.dwConfigMask & PPPCFG_AuthenticatePeer ))))
    {
        //
        // Start with the highest order bit which is the strongest protocol.
        //

        for( dwIndex = 0, pLcpCb->Local.fLastAPTried = 1;
             !(( pLcpCb->Local.fLastAPTried << dwIndex ) & LCP_AP_MAX );
             dwIndex++ )
        {
            if ( ( pLcpCb->Local.fLastAPTried << dwIndex ) &
                                                ( pLcpCb->Local.fAPsAvailable ))
            {
                pLcpCb->Local.fLastAPTried =
                                        (pLcpCb->Local.fLastAPTried << dwIndex);
                break;
            }
        }

        pLcpCb->Local.fOldLastAPTried = pLcpCb->Local.fLastAPTried;

        dwRetCode = MakeAuthProtocolOption( &(pLcpCb->Local) );

        if ( dwRetCode != NO_ERROR )
        {
            return( dwRetCode );
        }
    }

    //
    // Do the same for remote.
    //

    if ( pLcpCb->Remote.fAPsAvailable > 0 )
    {
        for( dwIndex = 0, pLcpCb->Remote.fLastAPTried = LCP_AP_FIRST;
             !(( pLcpCb->Remote.fLastAPTried << dwIndex ) & LCP_AP_MAX);
             dwIndex++ )
        {
            if ( ( pLcpCb->Remote.fLastAPTried << dwIndex ) &
                                              ( pLcpCb->Remote.fAPsAvailable ) )
            {
                pLcpCb->Remote.fLastAPTried = 
                                    (pLcpCb->Remote.fLastAPTried << dwIndex);

                //
                // We need to back up one since we are the client and we haven't
                // sent this yet.
                //

                if ( pLcpCb->Remote.fLastAPTried == LCP_AP_FIRST )
                {
                    pLcpCb->Remote.fLastAPTried = 0;
                }
                else
                {
                    pLcpCb->Remote.fLastAPTried >>= 1; 
                }

                pLcpCb->Remote.fOldLastAPTried = pLcpCb->Remote.fLastAPTried;

                break;
            }
        }
    }

    return( NO_ERROR );
}

//**
//
// Call:    MakeOption
//
// Returns: NO_ERROR - Success
//      ERROR_BUFFER_TOO_SMALL - Buffer passed in is not large enough.
//      ERROR_INVALID_PARAMETER - Option type not recognized.
//
// Description: This is not an entry point, it is an internal procedure called
//      to build a particular option.
//
DWORD
MakeOption(
    IN LCP_OPTIONS * pOptionValues,
    IN DWORD         dwOptionType,
    IN PPP_OPTION *  pSendOption,
    IN DWORD         cbSendOption
)
{
    if ( cbSendOption < SizeOfOption[ dwOptionType ] )
        return( ERROR_BUFFER_TOO_SMALL );

    pSendOption->Type   = (BYTE)dwOptionType;
    pSendOption->Length = (BYTE)(SizeOfOption[ dwOptionType ]);

    switch( dwOptionType )
    {

    case LCP_OPTION_MRU:

        HostToWireFormat16( (WORD)(pOptionValues->MRU), pSendOption->Data );

        break;

    case LCP_OPTION_ACCM:

        HostToWireFormat32( pOptionValues->ACCM, pSendOption->Data );

        break;

    case LCP_OPTION_AUTHENT:

        HostToWireFormat16( (WORD)pOptionValues->AP, pSendOption->Data );

        //
        // First check to see if we have enough space to put the 
        // digest algorithm
        //

        if (cbSendOption<(SizeOfOption[dwOptionType]+pOptionValues->APDataSize))
        {
            return( ERROR_BUFFER_TOO_SMALL );
        }

        CopyMemory( pSendOption->Data+2, 
                    pOptionValues->pAPData,         
                    pOptionValues->APDataSize );

        pSendOption->Length += (BYTE)(pOptionValues->APDataSize);

        break;

    case LCP_OPTION_MAGIC:

        HostToWireFormat32( pOptionValues->MagicNumber, 
                pSendOption->Data );


        break;
    
    case LCP_OPTION_PFC:
    
        //
        // This is a boolean option, there is no value.
        //

        break;

    case LCP_OPTION_ACFC:

        //
        // This is a boolean option, there is no value.
        //

        break;

    case LCP_OPTION_CALLBACK:

        *(pSendOption->Data) = (BYTE)(pOptionValues->Callback);

        break;

    case LCP_OPTION_MRRU:    

        HostToWireFormat16( (WORD)(pOptionValues->MRRU), pSendOption->Data );

        break;

    case LCP_OPTION_SHORT_SEQ:

        //
        // This is a boolean option, there is no value.
        //

        break;

    case LCP_OPTION_ENDPOINT:

        //
        // First check to see if we have enough space to put the 
        // discriminator 
        //

        if ( cbSendOption < ( SizeOfOption[dwOptionType] + 
                              pOptionValues->dwEDLength ) )
        {
            return( ERROR_BUFFER_TOO_SMALL );
        }

        CopyMemory( pSendOption->Data, 
                    pOptionValues->EndpointDiscr, 
                    pOptionValues->dwEDLength );

        pSendOption->Length += (BYTE)( pOptionValues->dwEDLength );

        break;

    case LCP_OPTION_LINK_DISCRIM:

        HostToWireFormat16( (WORD)(pOptionValues->dwLinkDiscriminator),
            pSendOption->Data );

        break;
    
    default: 

        //
        // If we do not recognize the option
        //

        return( ERROR_INVALID_PARAMETER );

    }

    return( NO_ERROR );
    
}

//**
//
// Call:    CheckOption
//
// Returns: CONFIG_ACK
//      CONFIG_NAK
//      CONFIG_REJ
//
// Description: This is not an entry point. Called to check to see if an option
//      value is valid and if it is the new value is saved in the
//      work buffer.
//
DWORD
CheckOption( 
    IN LCPCB *      pLcpCb,
    IN LCP_SIDE *   pLcpSide,
    IN PPP_OPTION * pOption,
    IN BOOL         fMakingResult
)
{
    DWORD dwIndex;
    DWORD dwAPDataSize;
    DWORD dwRetCode = CONFIG_ACK;

    if ( pOption->Length < SizeOfOption[ pOption->Type ] )
        return( CONFIG_REJ );

    //
    // If we do not want to negotiate the option we CONFIG_REJ it.
    //

    if ( !( pLcpSide->WillNegotiate & (1 << pOption->Type)) )
        return( CONFIG_REJ );

    switch( pOption->Type )
    {

    case LCP_OPTION_MRU:
    
        pLcpSide->Work.MRU = WireToHostFormat16( pOption->Data );

        //
        // Check to see if this value is appropriate
        //

        if ( !fMakingResult )
        {
            //
            // We cannot receive bigger packets.
            //

            if ( pLcpSide->Work.MRU > pLcpSide->Want.MRU ) 
            {
                // 
                // Check to see if the server nak'd. If so
                // check to see if peer wants <= 1500 mru
                // and if we have already sent the request
                // 2 times, just ack peers mru.
                //
                if(pLcpSide->Work.MRU <= LCP_DEFAULT_MRU)
                {
                    if(pLcpCb->dwMRUFailureCount > 0)
                    {
                        pLcpCb->dwMRUFailureCount--;
                    }

                    if(pLcpCb->dwMRUFailureCount == 0)
                    {
                        break;
                    }
                }
                
                pLcpSide->Work.MRU = pLcpSide->Want.MRU;
                dwRetCode = CONFIG_NAK;
            }
        }

    break;

    case LCP_OPTION_ACCM:

        pLcpSide->Work.ACCM = WireToHostFormat32( pOption->Data );

        //
        // If we are responding to a request, we accept it blindly, if we are
        // processing a NAK, then the remote host may ask to escape more
        // control characters than we require, but must escape  at least the
        // control chars that we require.
        //

        if ( !fMakingResult )
        {
            if ( pLcpSide->Work.ACCM !=
                                ( pLcpSide->Work.ACCM | pLcpSide->Want.ACCM ) )
            {
                pLcpSide->Work.ACCM |= pLcpSide->Want.ACCM;
                dwRetCode = CONFIG_NAK;
            }
        }

        break;

    case LCP_OPTION_AUTHENT:

        pLcpSide->Work.AP = WireToHostFormat16( pOption->Data );

        //
        // If there was Authentication data.
        //

        if ( pOption->Length > PPP_OPTION_HDR_LEN + 2 )
        {
            dwAPDataSize = pOption->Length - PPP_OPTION_HDR_LEN - 2;

            if ( dwAPDataSize != pLcpSide->Work.APDataSize )
            {
                pLcpSide->Work.APDataSize = dwAPDataSize;

                if ( NULL != pLcpSide->Work.pAPData )
                {
                    LOCAL_FREE( pLcpSide->Work.pAPData );
                    pLcpSide->Work.pAPData = NULL;
                }

                pLcpSide->Work.pAPData = (PBYTE)LOCAL_ALLOC( 
                                                    LPTR,
                                                    pLcpSide->Work.APDataSize );

                if ( NULL == pLcpSide->Work.pAPData )
                {
                    pLcpSide->Work.APDataSize = 0;
                    return( CONFIG_REJ );
                }
            }

            CopyMemory( pLcpSide->Work.pAPData, 
                        pOption->Data+2, 
                        pLcpSide->Work.APDataSize );
        }
        else
        {
            pLcpSide->Work.APDataSize = 0;
        }

        pLcpSide->fOldLastAPTried = pLcpSide->fLastAPTried;

        switch( pLcpSide->Work.AP )
        {

        case PPP_CHAP_PROTOCOL:

            //
            // If CHAP is not available
            //    

            if ( !( pLcpSide->fAPsAvailable & ( LCP_AP_CHAP_MS      | 
                                                LCP_AP_CHAP_MD5     | 
                                                LCP_AP_CHAP_MS_NEW )))
            {
                dwRetCode = CONFIG_NAK;

                break;
            }

            //
            // If there was no digest algorithm then we respond with the 
            // digest algorithm the next time. To do this we need to back up 
            // one in the list of APs tried so that we try this AP again.
            //

            if ( pOption->Length < (PPP_OPTION_HDR_LEN + 3) )
            {
                pLcpSide->fLastAPTried = 0;

                dwRetCode = CONFIG_NAK;

                break;
            }

            if ( *(pLcpSide->Work.pAPData) == PPP_CHAP_DIGEST_MSEXT ) 
            {
                if ( !( pLcpSide->fAPsAvailable & LCP_AP_CHAP_MS ) )
                {
                    dwRetCode = CONFIG_NAK;
                }
            }
            else if ( *(pLcpSide->Work.pAPData) == PPP_CHAP_DIGEST_MSEXT_NEW )
            {
                if ( !( pLcpSide->fAPsAvailable & LCP_AP_CHAP_MS_NEW ) )
                {
                    dwRetCode = CONFIG_NAK;
                }
            }
            else if ( *(pLcpSide->Work.pAPData) == PPP_CHAP_DIGEST_MD5 ) 
            {
                if ( !( pLcpSide->fAPsAvailable & LCP_AP_CHAP_MD5 ) )
                {
                    dwRetCode = CONFIG_NAK;
                }
            }
            else
            {
                dwRetCode = CONFIG_NAK;
            }

            break;

        case PPP_PAP_PROTOCOL:

            if ( !( pLcpSide->fAPsAvailable & LCP_AP_PAP ) )
            {
                dwRetCode = CONFIG_NAK;
            }

            break;

        case PPP_EAP_PROTOCOL:

            if ( !( pLcpSide->fAPsAvailable & LCP_AP_EAP ) )
            {
                dwRetCode = CONFIG_NAK;
            }

            break;

        case PPP_SPAP_NEW_PROTOCOL:

            if ( !( pLcpSide->fAPsAvailable & LCP_AP_SPAP_NEW ) )
            {
                dwRetCode = CONFIG_NAK;

                break;
            }

            if ( pOption->Length < (PPP_OPTION_HDR_LEN+6) )
            {
                dwRetCode = CONFIG_NAK;

                //
                // We are a client responding to a remote CONFIG_REQ
                //

                if ( fMakingResult )
                {
                    pLcpSide->fLastAPTried = ( LCP_AP_SPAP_NEW >> 1 );
                }

                break;
            }

            //
            // If encryption algorithm is not 1. NAK with 1.
            //

            if (WireToHostFormat32(pLcpSide->Work.pAPData) != LCP_SPAP_VERSION)
            {
                //
                // We are a client responding to a remote CONFIG_REQ
                //

                if ( fMakingResult )
                {
                    pLcpSide->fLastAPTried = ( LCP_AP_SPAP_NEW >> 1 );
                }

                dwRetCode = CONFIG_NAK;

                break;
            }

            break;

        default:

            dwRetCode = CONFIG_NAK;
        
            break;
        }

        
        if ( dwRetCode == CONFIG_NAK )
        {
            //
            // The fLastAPTried is set to 0, then we set to LCP_AP_FIRST 
            // 

            if ( pLcpSide->fLastAPTried == 0 )
            {
                pLcpSide->fLastAPTried = LCP_AP_FIRST;             
            }

            //
            // We look for the next weakest protocol available.
            //

            for( dwIndex = 1; 
                 !(( pLcpSide->fLastAPTried << dwIndex ) & LCP_AP_MAX);
                 dwIndex++ )
            {
                if ( ( pLcpSide->fLastAPTried << dwIndex ) & pLcpSide->fAPsAvailable )
                {
                    pLcpSide->fLastAPTried = (pLcpSide->fLastAPTried<<dwIndex);

                    break;
                }
            }

            MakeAuthProtocolOption( pLcpSide ); 
        }

        break;

    case LCP_OPTION_MAGIC:

        pLcpSide->Work.MagicNumber = WireToHostFormat32( pOption->Data );

        if ( fMakingResult ) 
        {
            //
            // Ensure that magic numbers are different and that the remote
            // request does not contain a magic number of 0.
            //

            if ( (pLcpSide->Work.MagicNumber == pLcpCb->Local.Work.MagicNumber)
                 || ( pLcpSide->Work.MagicNumber == 0 ) )
            {
                if (pLcpSide->Work.MagicNumber==pLcpCb->Local.Work.MagicNumber)
                {
                    ++(pLcpCb->dwMagicNumberFailureCount);
                }

                //
                // Shift left since rand returns a max of 0x7FFF
                //

                pLcpSide->Work.MagicNumber = ( rand() << 16 );

                pLcpSide->Work.MagicNumber += rand();

                if ( pLcpSide->Work.MagicNumber == 0 )
                {
                    pLcpSide->Work.MagicNumber = 48;
                }

                dwRetCode = CONFIG_NAK;
            }
        }
        else
        {
            //
            // The remote peer NAK'ed with a magic number, check to see if
            // the magic number in the NAK is the same as what we NAK'ed last
            //

            if ( pLcpSide->Work.MagicNumber == pLcpCb->Remote.Work.MagicNumber )
            {
                ++(pLcpCb->dwMagicNumberFailureCount);

                //
                // Shift left since rand returns a max of 0x7FFF
                //

                pLcpSide->Work.MagicNumber = ( rand() << 16 );

                pLcpSide->Work.MagicNumber += rand();

                if ( pLcpSide->Work.MagicNumber == 0 )
                {
                    pLcpSide->Work.MagicNumber = 93;
                }

                dwRetCode = CONFIG_NAK;
            }
        }

        break;

    case LCP_OPTION_PFC:

        pLcpSide->Work.PFC = TRUE;

        if ( pLcpSide->Want.PFC == FALSE )
            dwRetCode = CONFIG_REJ;

        break;

    case LCP_OPTION_ACFC:

        pLcpSide->Work.ACFC = TRUE;

        if ( pLcpSide->Want.ACFC == FALSE )
            dwRetCode = CONFIG_REJ;

        break;

    case LCP_OPTION_CALLBACK:

        pLcpSide->Work.Callback = *(pOption->Data);

        //
        // If the Callback control protocol is not loaded.
        //

        if ( GetCpIndexFromProtocol(PPP_CBCP_PROTOCOL) == (DWORD)-1 ) 
        {
            dwRetCode = CONFIG_REJ;
        }
        else if ( pLcpSide->Work.Callback != PPP_NEGOTIATE_CALLBACK ) 
        {
            if ( fMakingResult )
            {
                //
                // We only understand this option.
                //

                pLcpSide->Work.Callback = PPP_NEGOTIATE_CALLBACK;
                dwRetCode = CONFIG_NAK;
            }
            else
            {
                //
                // If we are processing a NAK from the remote peer, then we
                // simply do not negotiate this option again.
                //

                dwRetCode = CONFIG_REJ;
            }
        }

        break;

    case LCP_OPTION_MRRU:    

        pLcpSide->Work.MRRU = WireToHostFormat16( pOption->Data );

        //
        // Check to see if this value is appropriate
        //

        if ( fMakingResult )
        {
            //
            // We cannot send smaller reconstructed packets.
            //

            if ( pLcpSide->Work.MRRU < pLcpSide->Want.MRRU ) 
            {
                pLcpSide->Work.MRRU = pLcpSide->Want.MRRU;
                dwRetCode = CONFIG_NAK;
            }
        }
        else
        {
            //
            // We cannot receive bigger reconstructed packets.
            //

            if ( pLcpSide->Work.MRRU > pLcpSide->Want.MRRU ) 
            {
                pLcpSide->Work.MRRU = pLcpSide->Want.MRRU;
                dwRetCode = CONFIG_NAK;
            }
        }

        break;

    case LCP_OPTION_SHORT_SEQ:

        pLcpSide->Work.ShortSequence = TRUE;

        if ( pLcpSide->Want.ShortSequence == FALSE )
            dwRetCode = CONFIG_REJ;

        break;

    case LCP_OPTION_ENDPOINT:

        //
        // If this option was NAKed then we do not change this value and
        // simply resend the config request
        //
        if ( !fMakingResult )
        {   
            break;
        }

        ZeroMemory( pLcpSide->Work.EndpointDiscr,
                    sizeof( pLcpSide->Work.EndpointDiscr ) );

        //
        // Make sure that the discriminator can fit into our storage allocated
        // for it, otherwise simply truncate and hope that it is unique. We do
        // not want to reject it since we want bundling to work.
        //

        if ( ( pOption->Length - PPP_OPTION_HDR_LEN ) >
                                 sizeof(pLcpSide->Work.EndpointDiscr) )
        {
            pLcpSide->Work.dwEDLength = sizeof( pLcpSide->Work.EndpointDiscr );
        }
        else
        {
            pLcpSide->Work.dwEDLength = pOption->Length - PPP_OPTION_HDR_LEN;
        }

        CopyMemory( pLcpSide->Work.EndpointDiscr,
                    pOption->Data,
                    pLcpSide->Work.dwEDLength );

        break;

    case LCP_OPTION_LINK_DISCRIM:

        pLcpSide->Work.dwLinkDiscriminator = WireToHostFormat16( pOption->Data );

        break;

    default:

        //
        // If we do not recognize the option we CONFIG_REJ it.
        //

        dwRetCode = CONFIG_REJ;

        break;
    }

    return( dwRetCode );
}

//**
//
// Call:    BuildOptionList
//
// Returns: NO_ERROR - Success
//      Non-zero returns from MakeOption
//
// Description: This is not an entry point. Will build a list of options 
//      either for a configure request or a configure result.
//
DWORD
BuildOptionList(
    IN OUT BYTE *    pOptions,
    IN OUT DWORD *   pcbOptions,    
    IN LCP_OPTIONS * LcpOptions,
    IN DWORD         Negotiate
)
{

    DWORD OptionType; 
    DWORD dwRetCode;
    DWORD cbOptionLength = *pcbOptions;  

    for ( OptionType = 1;
          OptionType <= LCP_OPTION_LIMIT; 
          OptionType++ ) 
    {
        if ( Negotiate & ( 1 << OptionType )) 
        {
            if ( ( dwRetCode = MakeOption( LcpOptions, 
                           OptionType, 
                           (PPP_OPTION *)pOptions, 
                           cbOptionLength ) ) != NO_ERROR )
                return( dwRetCode );

            cbOptionLength -= ((PPP_OPTION*)pOptions)->Length;
            pOptions       += ((PPP_OPTION*)pOptions)->Length;
        }
    }

    *pcbOptions -= cbOptionLength;

    return( NO_ERROR );
}

//**
//
// Call:        LcpMakeConfigRequest
//
// Returns: NO_ERROR - Success
//      Non-zero returns from BuildOptionList
//
// Description: This is a entry point that is called to make a configure 
//      request packet.
//
DWORD
LcpMakeConfigRequest(
    IN VOID *       pWorkBuffer,
    IN PPP_CONFIG * pSendConfig,
    IN DWORD        cbSendConfig
)
{
    LCPCB * pLcpCb   = (LCPCB*)pWorkBuffer;
    DWORD   dwRetCode;

    cbSendConfig -= PPP_CONFIG_HDR_LEN;

    dwRetCode = BuildOptionList( pSendConfig->Data, 
                 &cbSendConfig, 
                 &(pLcpCb->Local.Work),
                 pLcpCb->Local.Work.Negotiate );

    if ( dwRetCode != NO_ERROR )
        return( dwRetCode );

    pSendConfig->Code = CONFIG_REQ;

    HostToWireFormat16( (WORD)(cbSendConfig + PPP_CONFIG_HDR_LEN), 
            pSendConfig->Length );

    return( NO_ERROR );
}

//**
//
// Call:    LcpMakeConfigResult
//
// Returns:
//
// Description:
//
DWORD
LcpMakeConfigResult(
    IN  VOID *        pWorkBuffer,
    IN  PPP_CONFIG *  pRecvConfig,
    OUT PPP_CONFIG *  pSendConfig,
    IN  DWORD         cbSendConfig,
    IN  BOOL          fRejectNaks 
)
{
    DWORD        dwDesired;
    DWORD        dwRetCode;
    LCPCB *      pLcpCb      = (LCPCB*)pWorkBuffer;
    DWORD        ResultType  = CONFIG_ACK; 
    PPP_OPTION * pRecvOption = (PPP_OPTION *)(pRecvConfig->Data);
    PPP_OPTION * pSendOption = (PPP_OPTION *)(pSendConfig->Data);
    LONG         lSendLength = cbSendConfig - PPP_CONFIG_HDR_LEN;
    LONG         lRecvLength = WireToHostFormat16( pRecvConfig->Length )
                                    - PPP_CONFIG_HDR_LEN;

    //
    // Clear negotiate mask
    //

    pLcpCb->Remote.Work.Negotiate = 0;

    //
    // Process options requested by remote host
    //

    while( lRecvLength > 0 ) 
    {
        if ( pRecvOption->Length == 0 )
            return( ERROR_PPP_INVALID_PACKET );

        if ( ( lRecvLength -= pRecvOption->Length ) < 0 )
            return( ERROR_PPP_INVALID_PACKET );

        dwRetCode = CheckOption( pLcpCb, &(pLcpCb->Remote), pRecvOption, TRUE );

        //
        // If we were building an ACK and we got a NAK or reject OR
        // we were building a NAK and we got a reject.
        //

        if ( (( ResultType == CONFIG_ACK ) && ( dwRetCode != CONFIG_ACK )) ||
             (( ResultType == CONFIG_NAK ) && ( dwRetCode == CONFIG_REJ )) )
        {
            ResultType  = dwRetCode;
            pSendOption = (PPP_OPTION *)(pSendConfig->Data);
            lSendLength = cbSendConfig - PPP_CONFIG_HDR_LEN;
        }

        //
        // Remember that we processed this option
        //

        if ( ( dwRetCode != CONFIG_REJ ) && 
             ( pRecvOption->Type <= LCP_OPTION_LIMIT ) )
        {
            pLcpCb->Remote.Work.Negotiate |= ( 1 << pRecvOption->Type );
        }

        //
        // Add the option to the list.
        //

        if ( dwRetCode == ResultType )
        {
            //
            // If this option is to be rejected, simply copy the 
            // rejected option to the send buffer
            //

            if ( ( dwRetCode == CONFIG_REJ ) ||
                ( ( dwRetCode == CONFIG_NAK ) && ( fRejectNaks ) ) )
            {
                CopyMemory( pSendOption, pRecvOption, pRecvOption->Length );
            }
            else
            {
                if ( ( dwRetCode = MakeOption( &(pLcpCb->Remote.Work), 
                                        pRecvOption->Type,
                                        pSendOption, 
                                        lSendLength ) ) != NO_ERROR )
                    return( dwRetCode );
            }

            lSendLength -= pSendOption->Length;

            pSendOption  = (PPP_OPTION *)
               ( (BYTE *)pSendOption + pSendOption->Length );
        }

        pRecvOption = (PPP_OPTION *)((BYTE*)pRecvOption + pRecvOption->Length);
    }

    //
    // If this was an NAK and we have cannot send any more NAKS then we
    // make this a REJECT packet
    //

    if ( ( ResultType == CONFIG_NAK ) && fRejectNaks )
        pSendConfig->Code = CONFIG_REJ;
    else
        pSendConfig->Code = (BYTE)ResultType;
    
    HostToWireFormat16( (WORD)(cbSendConfig - lSendLength), 
            pSendConfig->Length );

    //
    // If we want to be authenticated, but the other side doesn't try to 
    // authenticate us, NAK with LCP_N_AUTHENT.
    //

    if ( ( pLcpCb->Remote.Want.Negotiate & LCP_N_AUTHENT ) &
        ~( pLcpCb->Remote.Work.Negotiate ) )
    {
        DWORD cbOptions;

        //
        // We cannot send a NAK if we are sending a REJECT
        // 

        if ( ResultType != CONFIG_REJ )
        {
            if ( pLcpCb->Remote.fAPsAvailable & LCP_AP_EAP )
            {
                pLcpCb->Remote.fLastAPTried = LCP_AP_EAP;
            }
            else
            {
                pLcpCb->Remote.fLastAPTried = LCP_AP_CHAP_MS_NEW;
            }

            MakeAuthProtocolOption( &(pLcpCb->Remote) );

            if ( ResultType == CONFIG_ACK )
            {
                ResultType  = CONFIG_NAK;
                pSendOption = (PPP_OPTION *)(pSendConfig->Data);
                lSendLength = cbSendConfig - PPP_CONFIG_HDR_LEN;
            }

            cbOptions = lSendLength;

            dwRetCode = BuildOptionList(
                            (BYTE*)pSendOption,
                            &cbOptions,
                            &(pLcpCb->Remote.Work),
                            LCP_N_AUTHENT );

            if ( dwRetCode != NO_ERROR )
            {
                return( dwRetCode );
            }

            pSendConfig->Code = CONFIG_NAK;
        
            HostToWireFormat16( (WORD)(cbSendConfig - lSendLength + cbOptions), 
                    pSendConfig->Length );
        }
    }

    //
    // If we are rejecting this packet then we restore the LastAPTried value
    //

    if ( pSendConfig->Code == CONFIG_REJ )
    {
        pLcpCb->Remote.fLastAPTried = pLcpCb->Remote.fOldLastAPTried;
    }
    else
    {
        pLcpCb->Remote.fOldLastAPTried = pLcpCb->Remote.fLastAPTried;
    }

    //
    // If we have more than 3 conflicts with the magic number then we assume
    // that we are talking with ourself.
    //

    if ((ResultType == CONFIG_NAK) && (pLcpCb->dwMagicNumberFailureCount > 3))
    {
        return( ERROR_PPP_LOOPBACK_DETECTED );
    }

    return( NO_ERROR );
}

//**
//
// Call:    LcpConfigAckReceived
//
// Returns:
//
// Description:
//
DWORD
LcpConfigAckReceived(
    IN VOID *       pWorkBuffer,
    IN PPP_CONFIG * pRecvConfig
)
{
    DWORD        dwRetCode;
    BYTE         ConfigReqSent[LCP_DEFAULT_MRU];
    LCPCB *      pLcpCb          = (LCPCB *)pWorkBuffer;
    PPP_OPTION * pRecvOption     = (PPP_OPTION *)(pRecvConfig->Data);
    DWORD        cbConfigReqSent = sizeof( ConfigReqSent );
    DWORD        dwLength        = WireToHostFormat16( pRecvConfig->Length )
                                                                - PPP_CONFIG_HDR_LEN;

    //
    // Get a copy of last request we sent 
    //

    dwRetCode = BuildOptionList( ConfigReqSent, 
                 &cbConfigReqSent,
                 &(pLcpCb->Local.Work),
                 pLcpCb->Local.Work.Negotiate );

    if ( dwRetCode != NO_ERROR )
        return( dwRetCode );

    //
    // Overall buffer length should match 
    //

    if ( dwLength != cbConfigReqSent )
    {
        //
        // Hack to work around WinCE bug on the server side only.
        // If we request EAP, WinCE ACKs without auth option.
        // Bug#333332  
        //

        LCP_OPTIONS * pOptionValues = &(pLcpCb->Local.Work);

        //
        // If we are a client then we simply return
        //

        if ( !pLcpCb->fServer )
            return( ERROR_PPP_INVALID_PACKET );

        //
        // If we requested EAP
        //

        if ( pOptionValues->AP == PPP_EAP_PROTOCOL )
        {
            DWORD dwIndex;

            //
            // Check to see if ACK did not contain the auth option
            //
            
            while ( dwLength > 0 )
            {
                if ( pRecvOption->Length == 0 )
                    return( ERROR_PPP_INVALID_PACKET );
                
                if ( (long)(dwLength -= pRecvOption->Length) < 0 )
                    return( ERROR_PPP_INVALID_PACKET );

                if ( pRecvOption->Length < SizeOfOption[ pRecvOption->Type ] )
                    return( ERROR_PPP_INVALID_PACKET );

                if ( pRecvOption->Type == LCP_OPTION_AUTHENT )
                    return( ERROR_PPP_INVALID_PACKET );

                pRecvOption = (PPP_OPTION *)((BYTE*)pRecvOption + pRecvOption->Length);
            }

            //
            // If we get here then no authentication option was sent in the ACK
            // so we need to treat this as a NAK. Go to the next auth protocol.
            //

            pLcpCb->Local.fLastAPTried = LCP_AP_EAP;             

            //
            // We look for the next weakest protocol available.
            //

            for( dwIndex = 1;
                 !(( pLcpCb->Local.fLastAPTried << dwIndex ) & LCP_AP_MAX);
                 dwIndex++ )
            {
                if ( ( pLcpCb->Local.fLastAPTried << dwIndex ) & 
                                                        pLcpCb->Local.fAPsAvailable )
                {
                    pLcpCb->Local.fLastAPTried = (pLcpCb->Local.fLastAPTried << dwIndex );

                    break;
                }
            }


            MakeAuthProtocolOption( &(pLcpCb->Local) );
        }

        return( ERROR_PPP_INVALID_PACKET );
    }

    //
    // Each byte should match 
    //

    if ( memcmp( ConfigReqSent, pRecvConfig->Data, dwLength ) != 0 )
        return( ERROR_PPP_INVALID_PACKET );

    return( NO_ERROR );
}

//**
//
// Call:    LcpConfigNakReceived
//
// Returns:
//
// Description:
//
DWORD
LcpConfigNakReceived(
    IN VOID *       pWorkBuffer,
    IN PPP_CONFIG * pRecvConfig
)
{
    DWORD        dwResult;
    LCPCB *      pLcpCb         = (LCPCB *)pWorkBuffer;
    PPP_OPTION * pOption        = (PPP_OPTION*)(pRecvConfig->Data);
    DWORD        dwLastOption   = 0;
    LONG         lcbRecvConfig  = WireToHostFormat16( pRecvConfig->Length )
                                    - PPP_CONFIG_HDR_LEN;

    //
    //  First, process in order.  Then, process extra "important" options 
    //

    while ( lcbRecvConfig > 0  )
    {
        if ( pOption->Length == 0 )
            return( ERROR_PPP_INVALID_PACKET );

        if ( ( lcbRecvConfig -= pOption->Length ) < 0 )
            return( ERROR_PPP_INVALID_PACKET );

        //
        // If this option was not requested, we mark it as negotiable
        //

        if ( ( pOption->Type <= LCP_OPTION_LIMIT ) &&
             ( pLcpCb->Local.WillNegotiate & (1 << pOption->Type) ) && 
            !( pLcpCb->Local.Work.Negotiate & (1 << pOption->Type) ) ) 
        {
            pLcpCb->Local.Work.Negotiate |= (1 << pOption->Type );
        } 

        dwLastOption = pOption->Type;

        dwResult = CheckOption( pLcpCb, &(pLcpCb->Local), pOption, FALSE );

        //
        // Update the negotiation status. If we cannot accept this option,
        // then we will not send it again. 
        //

        if (( dwResult == CONFIG_REJ ) && ( pOption->Type <= LCP_OPTION_LIMIT ))
            pLcpCb->Local.Work.Negotiate &= ~(1 << pOption->Type);

        pOption = (PPP_OPTION *)( (BYTE *)pOption + pOption->Length );
    }

    return( NO_ERROR );
}

//**
//
// Call:    LcpConfigRejReceived
//
// Returns:
//
// Description:
//
DWORD
LcpConfigRejReceived(
    IN VOID *       pWorkBuffer,
    IN PPP_CONFIG * pRecvConfig
)
{
    DWORD        dwRetCode;
    LCPCB *      pLcpCb         = (LCPCB *)pWorkBuffer;
    PPP_OPTION * pOption        = (PPP_OPTION*)(pRecvConfig->Data);
    DWORD        dwLastOption   = 0;
    BYTE         ReqOption[LCP_DEFAULT_MRU];
    LONG         lcbRecvConfig  = WireToHostFormat16( pRecvConfig->Length )
                                    - PPP_CONFIG_HDR_LEN;
    //
    // Process in order, checking for errors 
    //

    while ( lcbRecvConfig > 0  )
    {
        if ( pOption->Length == 0 )
            return( ERROR_PPP_INVALID_PACKET );

        if ( ( lcbRecvConfig -= pOption->Length ) < 0 )
            return( ERROR_PPP_INVALID_PACKET );

        //
        // Cannot receive an option out of order or an option that was
        // not requested.
        //

        if ( ( pOption->Type <= LCP_OPTION_LIMIT ) &&
             (( pOption->Type < dwLastOption ) || 
              ( !( pLcpCb->Local.Work.Negotiate & (1 << pOption->Type)))) ) 
            return( ERROR_PPP_INVALID_PACKET );

        //
        // If we are a server and the client rejects the authentication
        // protocol then we fail to converge, if we are not set to allow no
        // authentication.
        //

        if ( ( pLcpCb->Local.Want.Negotiate & LCP_N_AUTHENT ) &&
             ( pOption->Type == LCP_OPTION_AUTHENT )          &&
             ( !( pLcpCb->PppConfigInfo.dwConfigMask & 
                                    PPPCFG_AllowNoAuthentication ) ) )
        {
            return( ERROR_PEER_REFUSED_AUTH );
        }

        //
        // The option should not have been modified in any way
        //

        if ( ( dwRetCode = MakeOption( &(pLcpCb->Local.Work), 
                           pOption->Type, 
                           (PPP_OPTION *)ReqOption, 
                           sizeof( ReqOption ) ) ) != NO_ERROR )
            return( dwRetCode );

        if ( memcmp( ReqOption, pOption, pOption->Length ) != 0 )
            return( ERROR_PPP_INVALID_PACKET );

        dwLastOption = pOption->Type;

        //
        // The next configure request should not contain this option
        //

        if ( pOption->Type <= LCP_OPTION_LIMIT ) 
            pLcpCb->Local.Work.Negotiate &= ~(1 << pOption->Type);

        pOption = (PPP_OPTION *)( (BYTE *)pOption + pOption->Length );

    }

    return( NO_ERROR );
}

//**
//
// Call:    LcpThisLayerStarted
//
// Returns:
//
// Description:
//
DWORD
LcpThisLayerStarted( 
    IN VOID * pWorkBuffer 
)
{
    return( NO_ERROR );
}

//**
//
// Call:    LcpThisLayerFinished
//
// Returns:
//
// Description:
//
DWORD 
LcpThisLayerFinished( 
    IN VOID * pWorkBuffer 
)
{
    return( NO_ERROR );
}

//**
//
// Call:    LcpThisLayerUp
//
// Returns: None
//
// Description: Sets the framing parameters to what was negotiated.
//
DWORD
LcpThisLayerUp( 
    IN VOID * pWorkBuffer 
)
{
    DWORD               dwRetCode           = NO_ERROR;
    RAS_FRAMING_INFO    RasFramingInfo;
    DWORD               LocalMagicNumber;
    DWORD               RemoteMagicNumber;
    DWORD               LocalAuthProtocol;
    DWORD               RemoteAuthProtocol;
    LCPCB *             pLcpCb              = (LCPCB *)pWorkBuffer;
    PCB *               pPcb;

    pPcb = GetPCBPointerFromhPort( pLcpCb->hPort );

    if ( pPcb == (PCB *)NULL )
    {
        return( NO_ERROR );
    }

    ZeroMemory( &RasFramingInfo, sizeof( RasFramingInfo ) );

    if ( pLcpCb->Local.Work.Negotiate & LCP_N_MRU ) 
    {
        RasFramingInfo.RFI_MaxRecvFrameSize = pLcpCb->Local.Work.MRU;
    }
    else
    {
        RasFramingInfo.RFI_MaxRecvFrameSize = LcpDefault.MRU;
    }

    if ( pLcpCb->Local.Work.Negotiate & LCP_N_ACCM ) 
    {
        RasFramingInfo.RFI_RecvACCM = pLcpCb->Local.Work.ACCM;
    }
    else
    {
        RasFramingInfo.RFI_RecvACCM = LcpDefault.ACCM;
    }

    if ( pLcpCb->Local.Work.Negotiate & LCP_N_PFC ) 
    {
        RasFramingInfo.RFI_RecvFramingBits |= PPP_COMPRESS_PROTOCOL_FIELD;
    }

    if ( pLcpCb->Local.Work.Negotiate & LCP_N_ACFC ) 
    {
        RasFramingInfo.RFI_RecvFramingBits |= PPP_COMPRESS_ADDRESS_CONTROL;
    }

    if ( pLcpCb->Local.Work.Negotiate & LCP_N_SHORT_SEQ ) 
    {
        RasFramingInfo.RFI_RecvFramingBits |= PPP_SHORT_SEQUENCE_HDR_FORMAT;
    }

    if ( pLcpCb->Local.Work.Negotiate & LCP_N_AUTHENT ) 
    {
        LocalAuthProtocol = pLcpCb->Local.Work.AP;
    }
    else
    {
        LocalAuthProtocol     = LcpDefault.AP;
        pLcpCb->Local.Work.AP = LcpDefault.AP;
    }

    if ( pLcpCb->Local.Work.Negotiate & LCP_N_MAGIC ) 
    {
        LocalMagicNumber = pLcpCb->Local.Work.MagicNumber;
    }
    else
    {
        LocalMagicNumber = LcpDefault.MagicNumber;
    }

    if ( pLcpCb->Local.Work.Negotiate & LCP_N_MRRU ) 
    {
        RasFramingInfo.RFI_RecvFramingBits |= PPP_MULTILINK_FRAMING;

        RasFramingInfo.RFI_MaxRRecvFrameSize = pLcpCb->Local.Work.MRRU;
    }
    else
    {
        RasFramingInfo.RFI_MaxRRecvFrameSize = LcpDefault.MRRU;
    }

    if ( ( pLcpCb->Local.Work.Negotiate & LCP_N_LINK_DISCRIM ) &&
         ( pLcpCb->Remote.Work.Negotiate & LCP_N_LINK_DISCRIM ) )
    {
        pPcb->pBcb->fFlags |= BCBFLAG_CAN_DO_BAP;
    }

    RasFramingInfo.RFI_RecvFramingBits |= PPP_FRAMING;

    PppLog( 1, "LCP Local Options-------------");

    PppLog( 1, 
        "\tMRU=%d,ACCM=%d,Auth=%x,MagicNumber=%d,PFC=%s,ACFC=%s",
        RasFramingInfo.RFI_MaxRecvFrameSize, RasFramingInfo.RFI_RecvACCM,
        LocalAuthProtocol, LocalMagicNumber, 
        (RasFramingInfo.RFI_RecvFramingBits & PPP_COMPRESS_PROTOCOL_FIELD)
        ? "ON" : "OFF",
        ( RasFramingInfo.RFI_RecvFramingBits & PPP_COMPRESS_ADDRESS_CONTROL ) 
        ? "ON" : "OFF" );

    PppLog( 1, "\tRecv Framing = %s,SSHF=%s,MRRU=%d,LinkDiscrim=%x,BAP=%s",
        ( RasFramingInfo.RFI_RecvFramingBits & PPP_MULTILINK_FRAMING )
        ? "PPP Multilink" : "PPP",
        ( RasFramingInfo.RFI_RecvFramingBits & PPP_SHORT_SEQUENCE_HDR_FORMAT) 
        ? "ON" : "OFF", 
        RasFramingInfo.RFI_MaxRRecvFrameSize,
        pLcpCb->Local.Work.dwLinkDiscriminator,
        pPcb->pBcb->fFlags & BCBFLAG_CAN_DO_BAP ? "ON" : "OFF");

    if ( pLcpCb->Local.Work.Negotiate & LCP_N_ENDPOINT ) 
    {
        PppLog( 1, "\tED Class = %d, ED Value = %0*x%0*x%0*x%0*x%0*x",  
                    *(pLcpCb->Local.Work.EndpointDiscr),
                    8,WireToHostFormat32(pLcpCb->Local.Work.EndpointDiscr+1),
                    8,WireToHostFormat32(pLcpCb->Local.Work.EndpointDiscr+5),
                    8,WireToHostFormat32(pLcpCb->Local.Work.EndpointDiscr+9),
                    8,WireToHostFormat32(pLcpCb->Local.Work.EndpointDiscr+13),
                    8,WireToHostFormat32(pLcpCb->Local.Work.EndpointDiscr+17) );
    }

    if ( pLcpCb->Remote.Work.Negotiate & LCP_N_MRU ) 
    {
        RasFramingInfo.RFI_MaxSendFrameSize = pLcpCb->Remote.Work.MRU;
    }
    else
    {
        RasFramingInfo.RFI_MaxSendFrameSize = LcpDefault.MRU;
        pLcpCb->Remote.Work.MRU = LcpDefault.MRU;
    }

    if ( pLcpCb->Remote.Work.Negotiate & LCP_N_ACCM ) 
    {
        RasFramingInfo.RFI_SendACCM = pLcpCb->Remote.Work.ACCM;
    }
    else
    {
        RasFramingInfo.RFI_SendACCM = LcpDefault.ACCM;
    }
                    
    if ( pLcpCb->Remote.Work.Negotiate & LCP_N_PFC )
    {
        RasFramingInfo.RFI_SendFramingBits |= PPP_COMPRESS_PROTOCOL_FIELD;
    }

    if ( pLcpCb->Remote.Work.Negotiate & LCP_N_ACFC )
    {
        RasFramingInfo.RFI_SendFramingBits |= PPP_COMPRESS_ADDRESS_CONTROL;
    }

    if ( pLcpCb->Remote.Work.Negotiate & LCP_N_SHORT_SEQ ) 
    {
        RasFramingInfo.RFI_SendFramingBits |= PPP_SHORT_SEQUENCE_HDR_FORMAT;
    }

    if ( pLcpCb->Remote.Work.Negotiate & LCP_N_AUTHENT ) 
    {
        RemoteAuthProtocol = pLcpCb->Remote.Work.AP;
    }
    else
    {
        RemoteAuthProtocol          = LcpDefault.AP;
        pLcpCb->Remote.Work.AP      = LcpDefault.AP;
    }

    if ( pLcpCb->Remote.Work.Negotiate & LCP_N_MAGIC ) 
    {
        RemoteMagicNumber = pLcpCb->Remote.Work.MagicNumber;
    }
    else
    {
        RemoteMagicNumber = LcpDefault.MagicNumber;
    }

    if ( pLcpCb->Remote.Work.Negotiate & LCP_N_MRRU ) 
    {
        RasFramingInfo.RFI_SendFramingBits |= PPP_MULTILINK_FRAMING;

        RasFramingInfo.RFI_MaxRSendFrameSize = pLcpCb->Remote.Work.MRRU;
    }
    else
    {

        RasFramingInfo.RFI_MaxRSendFrameSize = LcpDefault.MRRU;
    }

    RasFramingInfo.RFI_SendFramingBits |= PPP_FRAMING;

    PppLog( 1, "LCP Remote Options-------------");

    PppLog( 1, "\tMRU=%d,ACCM=%d,Auth=%x,MagicNumber=%d,PFC=%s,ACFC=%s",
        RasFramingInfo.RFI_MaxSendFrameSize, RasFramingInfo.RFI_SendACCM,
        RemoteAuthProtocol, RemoteMagicNumber, 
        (RasFramingInfo.RFI_SendFramingBits & PPP_COMPRESS_PROTOCOL_FIELD) 
        ? "ON" : "OFF",
        (RasFramingInfo.RFI_SendFramingBits & PPP_COMPRESS_ADDRESS_CONTROL)
        ? "ON" : "OFF" );

    PppLog( 1, "\tSend Framing = %s,SSHF=%s,MRRU=%d,LinkDiscrim=%x",
        ( RasFramingInfo.RFI_SendFramingBits & PPP_MULTILINK_FRAMING )
        ? "PPP Multilink" : "PPP",
        ( RasFramingInfo.RFI_SendFramingBits & PPP_SHORT_SEQUENCE_HDR_FORMAT) 
        ? "ON" : "OFF", 
        RasFramingInfo.RFI_MaxRSendFrameSize,
        pLcpCb->Remote.Work.dwLinkDiscriminator );

    if ( pLcpCb->Remote.Work.Negotiate & LCP_N_ENDPOINT ) 
    {
        PppLog( 1, "\tED Class = %d, ED Value = %0*x%0*x%0*x%0*x%0*x",  
                    *(pLcpCb->Remote.Work.EndpointDiscr),
                    8,WireToHostFormat32(pLcpCb->Remote.Work.EndpointDiscr+1),
                    8,WireToHostFormat32(pLcpCb->Remote.Work.EndpointDiscr+5),
                    8,WireToHostFormat32(pLcpCb->Remote.Work.EndpointDiscr+9),
                    8,WireToHostFormat32(pLcpCb->Remote.Work.EndpointDiscr+13),
                    8,WireToHostFormat32(pLcpCb->Remote.Work.EndpointDiscr+17));
    }

    if ( pLcpCb->Local.Work.Negotiate & LCP_N_MRRU ) 
    {
        pPcb->fFlags |= PCBFLAG_CAN_BE_BUNDLED;
    }
    else
    {
        pPcb->fFlags &= ~PCBFLAG_CAN_BE_BUNDLED;
    }

    if ( ( pLcpCb->Local.Work.Negotiate & LCP_N_CALLBACK ) ||
         ( pLcpCb->Remote.Work.Negotiate & LCP_N_CALLBACK ) )
    {
        pPcb->fFlags |= PCBFLAG_NEGOTIATE_CALLBACK;
    }
    else
    {
        pPcb->fFlags &= ~PCBFLAG_NEGOTIATE_CALLBACK;
    }

    dwRetCode = RasPortSetFramingEx( pLcpCb->hPort, &RasFramingInfo );  

    //
    // This is a benign error and should not be logged. 
    //

    if ( dwRetCode == ERROR_NOT_CONNECTED )
    {
        return( NO_ERROR );
    }
    else
    {
        return( dwRetCode );
    }
}

//**
//
// Call:    LcpThisLayerDown
//
// Returns: NO_ERROR - Success
//      Non-zero return from RasPortSetFraming - Failure
//
// Description: Simply sets the framing parameters to the default values,
//      ie. ACCM = 0xFFFFFFFF, everything else is zeros.
//
DWORD 
LcpThisLayerDown( 
    IN VOID * pWorkBuffer 
)
{
    DWORD               dwRetCode;
    RAS_FRAMING_INFO    RasFramingInfo;
    LCPCB *             pLcpCb          = (LCPCB *)pWorkBuffer;

    ZeroMemory( &RasFramingInfo, sizeof( RasFramingInfo ) );

    RasFramingInfo.RFI_RecvACCM = LcpDefault.ACCM;
    RasFramingInfo.RFI_SendACCM = LcpDefault.ACCM;
    RasFramingInfo.RFI_SendFramingBits = PPP_FRAMING;
    RasFramingInfo.RFI_RecvFramingBits = PPP_FRAMING;

    dwRetCode = RasPortSetFramingEx( pLcpCb->hPort, &RasFramingInfo );  

    if ( dwRetCode == ERROR_NOT_CONNECTED )
    {
        return( NO_ERROR );
    }
    else
    {
        return( dwRetCode );
    }
}

//**
//
// Call:        LcpGetNegotiatedInfo
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
LcpGetNegotiatedInfo(
    IN  VOID*               pWorkBuffer,
    OUT PPP_LCP_RESULT *    pLcpResult
)
{
    LCPCB * pLcpCb = (LCPCB *)pWorkBuffer;

    if ( pLcpCb->Local.Work.Negotiate & LCP_N_MRRU )
    {
        pLcpResult->dwLocalFramingType |= PPP_MULTILINK_FRAMING;
    }
    else
    {
        pLcpResult->dwLocalFramingType |= PPP_FRAMING;
    }

    if ( pLcpCb->Local.Work.Negotiate & LCP_N_AUTHENT )
    {
        pLcpResult->dwLocalAuthProtocol = pLcpCb->Local.Work.AP;
    }
    else
    {
        pLcpResult->dwLocalAuthProtocol = LcpDefault.AP;
    }

    pLcpResult->dwLocalOptions = 0;

    if ( pLcpCb->Local.Work.Negotiate & LCP_N_PFC )
    {
        pLcpResult->dwLocalOptions |= PPPLCPO_PFC;
    }

    if ( pLcpCb->Local.Work.Negotiate & LCP_N_ACFC ) 
    {
        pLcpResult->dwLocalOptions |= PPPLCPO_ACFC;
    }

    if ( pLcpCb->Local.Work.Negotiate & LCP_N_SHORT_SEQ ) 
    {
        pLcpResult->dwLocalOptions |= PPPLCPO_SSHF;
    }

    if ( ( pLcpCb->Local.Work.APDataSize > 0 ) &&
         ( pLcpCb->Local.Work.APDataSize < 5 ) )
    {
        if ( pLcpCb->Local.Work.APDataSize == 1 ) 
        {
            pLcpResult->dwLocalAuthProtocolData = 
                                       (DWORD)*(pLcpCb->Local.Work.pAPData);
        }
        else if ( pLcpCb->Local.Work.APDataSize == 2 ) 
        {
            pLcpResult->dwLocalAuthProtocolData =   
                              WireToHostFormat16( pLcpCb->Local.Work.pAPData );
        }
        else
        {
            pLcpResult->dwLocalAuthProtocolData =   
                              WireToHostFormat32( pLcpCb->Local.Work.pAPData );
        }
    }
    else    
    {
        pLcpResult->dwLocalAuthProtocolData = 0;
    }

    if ( pLcpCb->Remote.Work.Negotiate & LCP_N_AUTHENT )
    {
        pLcpResult->dwRemoteAuthProtocol = pLcpCb->Remote.Work.AP;
    }
    else
    {
        pLcpResult->dwRemoteAuthProtocol = LcpDefault.AP;
    }

    if ( pLcpCb->Remote.Work.Negotiate & LCP_N_MRRU ) 
    {
        pLcpResult->dwRemoteFramingType |= PPP_MULTILINK_FRAMING;
    }
    else
    {
        pLcpResult->dwRemoteFramingType |= PPP_FRAMING;
    }

    pLcpResult->dwRemoteOptions = 0;

    if ( pLcpCb->Remote.Work.Negotiate & LCP_N_PFC )
    {
        pLcpResult->dwRemoteOptions |= PPPLCPO_PFC;
    }

    if ( pLcpCb->Remote.Work.Negotiate & LCP_N_ACFC ) 
    {
        pLcpResult->dwRemoteOptions |= PPPLCPO_ACFC;
    }

    if ( pLcpCb->Remote.Work.Negotiate & LCP_N_SHORT_SEQ ) 
    {
        pLcpResult->dwRemoteOptions |= PPPLCPO_SSHF;
    }

    if ( ( pLcpCb->Remote.Work.APDataSize > 0 ) &&
         ( pLcpCb->Remote.Work.APDataSize < 5 ) )
    {
        if ( pLcpCb->Remote.Work.APDataSize == 1 )
        {
            pLcpResult->dwRemoteAuthProtocolData = 
                                        (DWORD)*(pLcpCb->Remote.Work.pAPData);
        }
        else if ( pLcpCb->Remote.Work.APDataSize == 2 )
        {
            pLcpResult->dwRemoteAuthProtocolData =   
                              WireToHostFormat16( pLcpCb->Remote.Work.pAPData );
        }
        else
        {
            pLcpResult->dwRemoteAuthProtocolData =   
                              WireToHostFormat32( pLcpCb->Remote.Work.pAPData );
        }
    }
    else
    {
        pLcpResult->dwRemoteAuthProtocolData = 0;
    }

    return( NO_ERROR );
}

//**
//
// Call:    LcpGetInfo
//
// Returns: NO_ERROR        - Success
//      ERROR_INVALID_PARAMETER - Protocol id is unrecogized
//
// Description: This entry point is called for get all information for the
//      control protocol in this module.
//
DWORD
LcpGetInfo(
    IN  DWORD       dwProtocolId,
    OUT PPPCP_INFO* pCpInfo
)
{
    if ( dwProtocolId != PPP_LCP_PROTOCOL )
        return( ERROR_INVALID_PARAMETER );

    ZeroMemory( pCpInfo, sizeof( PPPCP_INFO ) );

    pCpInfo->Protocol               = PPP_LCP_PROTOCOL;
    pCpInfo->Recognize              = TIME_REMAINING + 1; 
    pCpInfo->RasCpBegin             = LcpBegin;
    pCpInfo->RasCpEnd               = LcpEnd;
    pCpInfo->RasCpReset             = LcpReset;
    pCpInfo->RasCpThisLayerStarted  = LcpThisLayerStarted;
    pCpInfo->RasCpThisLayerFinished = LcpThisLayerFinished;
    pCpInfo->RasCpThisLayerUp       = LcpThisLayerUp;
    pCpInfo->RasCpThisLayerDown     = LcpThisLayerDown;
    pCpInfo->RasCpMakeConfigRequest = LcpMakeConfigRequest;
    pCpInfo->RasCpMakeConfigResult  = LcpMakeConfigResult;
    pCpInfo->RasCpConfigAckReceived = LcpConfigAckReceived;
    pCpInfo->RasCpConfigNakReceived = LcpConfigNakReceived;
    pCpInfo->RasCpConfigRejReceived = LcpConfigRejReceived;
    pCpInfo->RasCpGetNegotiatedInfo = LcpGetNegotiatedInfo;

    return( NO_ERROR );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\engine\ppp.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    ppp.h
//
// Description: Contains structures and constants used by the PPP engine.
//
// History:
//      Nov 11,1993.    NarenG      Created original version.
//      Jan 9,1995      RamC        Added hToken to the PCB structure to store
//                                  the LSA token. This will be closed in the
//                                  ProcessLineDownWorker() routine to release
//                                  the RAS license.
//
//      Schematic of PPP Data Structures
//      ================================
//
//      |---------|
//      |  PCB    |                                             |-------|
//      |         |                                             |CPTable|
//      |  BCB*   |--------------->|-------|                    |       |
//      |---------|                |  BCB  |                    |-------|
//      | LCP CB  |                |       |                    |  LCP  |
//      |---------|                |-------|                    |-------|
//      |  AP     |(Authenticator) | NCP1CB|                    |  NCP1 |
//      |---------|                |-------|                    |-------|
//      |  AP     |(Authenticatee) | NCP2CB|                    |  NCP2 |
//      |---------|                |-------|                    |-------|
//      | LCP CB  |                | etc,..|                    |etc,.. |
//      |---------|                |-------|                    |-------|
//                                                              |  AP1  |
//                                                              |-------|
//                                                              |  AP2  |
//                                                              |-------|
//                                                              | etc,..|
//                                                              |-------|
//
//

#ifndef _PPP_
#define _PPP_

#include <rasauth.h>
#include <rasppp.h>

#define RAS_KEYPATH_PPP             \
   "SYSTEM\\CurrentControlSet\\Services\\RasMan\\ppp"

#define RAS_KEYPATH_PROTOCOLS       \
   "SYSTEM\\CurrentControlSet\\Services\\RasMan\\ppp\\ControlProtocols"

#define RAS_KEYPATH_REMOTEACCESS    \
   "SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters"

#define RAS_KEYPATH_EAP             \
   "SYSTEM\\CurrentControlSet\\Services\\RasMan\\ppp\\Eap"

#define RAS_KEYPATH_BUILTIN         \
   "SYSTEM\\CurrentControlSet\\Services\\RasMan\\ppp\\ControlProtocols\\BuiltIn"

#define RAS_VALUENAME_PATH                      "Path"
#define RAS_VALUENAME_MAXTERMINATE              "MaxTerminate"
#define RAS_VALUENAME_MAXCONFIGURE              "MaxConfigure"
#define RAS_VALUENAME_MAXFAILURE                "MaxFailure"
#define RAS_VALUENAME_MAXREJECT                 "MaxReject"
#define RAS_VALUENAME_RESTARTTIMER              "RestartTimer"
#define RAS_VALUENAME_NEGOTIATETIME             "NegotiateTime"
#define RAS_VALUENAME_CALLBACKDELAY             "DefaultCallbackDelay"
#define RAS_VALUENAME_PORTLIMIT                 "DefaultPortLimit"
#define RAS_VALUENAME_SESSIONTIMEOUT            "DefaultSessionTimeout"
#define RAS_VALUENAME_IDLETIMEOUT               "DefaultIdleTimeout"
#define RAS_VALUENAME_BAPTHRESHOLD              "LowerBandwidthThreshold"
#define RAS_VALUENAME_BAPTIME                   "TimeBelowTheshold"
#define RAS_VALUENAME_BAPLISTENTIME             "BapListenTimeout"
#define RAS_DONTNEGOTIATE_MULTILINKONSINGLELINK	"DontNegotiateMultiLinkOnSingleLink"
#define RAS_VALUENAME_UNKNOWNPACKETTRACESIZE    "UnknownPacketTraceSize"
#define RAS_ECHO_REQUEST_INTERVAL				"EchoRequestInterval"		//Interval between echo requests
#define RAS_ECHO_REQUEST_IDLE					"IdleTimeBeforeEcho"		//Idle time before the echo request starts
#define RAS_ECHO_NUM_MISSED_ECHOS				"MissedEchosBeforeDisconnect"	//Number of missed echos before disconnect.
#define RAS_VALUENAME_DOBAPONVPN                "DoBapOnVpn"
#define RAS_VALUENAME_PARSEDLLPATH              "ParseDllPath"
#define MS_RAS_WITH_MESSENGER                   "MSRAS-1-"
#define MS_RAS_WITHOUT_MESSENGER                "MSRAS-0-"
#define MS_RAS                                  "MSRAS"
#define MS_RAS_VERSION                          "MSRASV5.10"

#define PPP_DEF_MAXTERMINATE            2
#define PPP_DEF_MAXCONFIGURE            10
#define PPP_DEF_MAXFAILURE              5
#define PPP_DEF_MAXREJECT               5
#define PPP_DEF_RESTARTTIMER            3
#define PPP_DEF_AUTODISCONNECTTIME      20
#define PPP_DEF_NEGOTIATETIME           150
#define PPP_DEF_CALLBACKDELAY           12
#define PPP_DEF_PORTLIMIT               0xFFFFFFFF
#define PPP_DEF_SESSIONTIMEOUT          0
#define PPP_DEF_IDLETIMEOUT             0
#define PPP_DEF_BAPLISTENTIME           45
#define PPP_DEF_UNKNOWNPACKETTRACESIZE  64
#define PPP_DEF_ECHO_TEXT				"94ae90cc3531"
#define PPP_DEF_ECHO_REQUEST_INTERVAL	60
#define PPP_DEF_ECHO_REQUEST_IDLE		300
#define PPP_DEF_ECHO_NUM_MISSED_ECHOS	3
#define PPP_NUM_ACCOUNTING_ATTRIBUTES           39
#define PPP_NUM_USER_ATTRIBUTES                 21


//
// Note that the size of the BAP Phone-Delta option <= 0xFF
//

#define BAP_PHONE_DELTA_SIZE    0xFF

#define PPP_HEAP_INITIAL_SIZE   20000       // approx 20K
#define PPP_HEAP_MAX_SIZE       0           // Grow heap as required

//
// Debug trace component values
//

#define TRACE_LEVEL_1           (0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC)
#define TRACE_LEVEL_2           (0x00020000|TRACE_USE_MASK|TRACE_USE_MSEC)

//
// Event Logging macros
//

#define PppLogWarning( LogId, NumStrings, lpwsSubStringArray )                  \
    if ( PppConfigInfo.dwLoggingLevel > 1 ) {                                   \
        RouterLogWarning( PppConfigInfo.hLogEvents, LogId,                      \
                      NumStrings, lpwsSubStringArray, 0 ); }

#define PppLogError( LogId, NumStrings, lpwsSubStringArray, dwRetCode )         \
    if ( PppConfigInfo.dwLoggingLevel > 0 ) {                                   \
        RouterLogError( PppConfigInfo.hLogEvents, LogId,                        \
                        NumStrings, lpwsSubStringArray, dwRetCode ); }

#define PppLogErrorString(LogId,NumStrings,lpwsSubStringArray,dwRetCode,dwPos ) \
    if ( PppConfigInfo.dwLoggingLevel > 0 ) {                                   \
        RouterLogErrorString( PppConfigInfo.hLogEvents, LogId, NumStrings,      \
                              lpwsSubStringArray, dwRetCode, dwPos ); }

#define PppLogInformation( LogId, NumStrings, lpwsSubStringArray )              \
    if ( PppConfigInfo.dwLoggingLevel > 2 ) {                                   \
        RouterLogInformation( PppConfigInfo.hLogEvents,                         \
                          LogId, NumStrings, lpwsSubStringArray, 0 ); }

//General macros
#define GEN_RAND_ENCODE_SEED			((CHAR) ( 1 + rand() % 250 ))
//
// PPP packet header
//

typedef struct _PPP_PACKET
{
    BYTE        Protocol[2];    // Protocol Number

    BYTE        Information[1]; // Data

} PPP_PACKET, *PPPP_PACKET;

#define PPP_PACKET_HDR_LEN      ( sizeof( PPP_PACKET ) - 1 )

//
// PPP Link phases
//

typedef enum PPP_PHASE
{
    PPP_LCP,
    PPP_AP,
    PPP_NEGOTIATING_CALLBACK,
    PPP_NCP

} PPP_PHASE;

#define LCP_INDEX       0

//
// Different types of timer events that can occur
//

typedef enum TIMER_EVENT_TYPE
{
    TIMER_EVENT_TIMEOUT,
    TIMER_EVENT_AUTODISCONNECT,
    TIMER_EVENT_HANGUP,
    TIMER_EVENT_NEGOTIATETIME,
    TIMER_EVENT_SESSION_TIMEOUT,
    TIMER_EVENT_FAV_PEER_TIMEOUT,
    TIMER_EVENT_INTERIM_ACCOUNTING,
    TIMER_EVENT_LCP_ECHO

} TIMER_EVENT_TYPE;

//
// FSM states
//

typedef enum FSM_STATE
{
    FSM_INITIAL = 0,
    FSM_STARTING,
    FSM_CLOSED,
    FSM_STOPPED,
    FSM_CLOSING,
    FSM_STOPPING,
    FSM_REQ_SENT,
    FSM_ACK_RCVD,
    FSM_ACK_SENT,
    FSM_OPENED

} FSM_STATE;

//
// Phase of PPP connection.
//

typedef enum NCP_PHASE
{
    NCP_DEAD,
    NCP_CONFIGURING,
    NCP_UP,
    NCP_DOWN

} NCP_PHASE;

//
// BAP states
//

typedef enum BAP_STATE
{
    BAP_STATE_INITIAL,
    BAP_STATE_SENT_CALL_REQ,
    BAP_STATE_SENT_CALLBACK_REQ,
    BAP_STATE_SENT_DROP_REQ,
    BAP_STATE_SENT_STATUS_IND,
    BAP_STATE_CALLING,
    BAP_STATE_LISTENING
    
} BAP_STATE;

#define BAP_STATE_LIMIT BAP_STATE_LISTENING // Highest number we can handle

//
// List of messages to be collected by the owner of this port
//

typedef struct _CLIENT_MESSAGE
{
    struct _CLIENT_MESSAGE * pNext;

    PPP_MESSAGE              Msg;    

} CLIENT_MESSAGE, *PCLIENT_MESSAGE;

//
//  Values of the PCB->fFlags field
//

#define PCBFLAG_CAN_BE_BUNDLED      0x00000001  // MultiLink was negotiated
#define PCBFLAG_IS_BUNDLED          0x00000002  // This link is part of a bundle
#define PCBFLAG_IS_SERVER           0x00000004  // Port opened by server
#define PCBFLAG_THIS_IS_A_CALLBACK  0x00000008  // Current call is a callbak
#define PCBFLAG_NEGOTIATE_CALLBACK  0x00000010  // LCP indicates CBCP should run
#define PCBFLAG_DOING_CALLBACK      0x00000020  // Shutting down for callback
#define PCBFLAG_IS_ADVANCED_SERVER  0x00000040 
#define PCBFLAG_NCPS_INITIALIZED    0x00000080 
#define PCBFLAG_PORT_IN_LISTENING_STATE  \
                                    0x00000100  // We have done a RasPortOpen
                                                // on this port. We need to 
                                                // do a RasPortClose finally.
#define PCBFLAG_MPPE_KEYS_SET       0x00000200
#define PCBFLAG_CONNECTION_LOGGED   0x00000400
#define PCBFLAG_NON_INTERACTIVE     0x00000800  // We cannot display any UI
#define PCBFLAG_INTERIM_ACCT_SENT   0x00001000  // Interim accounting packet sent
#define PCBFLAG_SERVICE_UNAVAILABLE 0x00002000  // Acct-Terminate-Cause is
                                                // Service Unavailable
#define PCBFLAG_ACCOUNTING_STARTED  0x00004000  // Accounting has been started
#define PCBFLAG_STOPPED_MSG_SENT    0x00008000  // PPPMSG_Stopped has been sent 
                                                // to rasman
#define PCBFLAG_DISABLE_NETBT       0x00010000
#define PCBFLAG_RECVD_TERM_REQ      0x00020000

//
//  Values of the BCB->fFlags field
//

#define BCBFLAG_CAN_DO_BAP          0x00000001  // We can do BAP/BACP
#define BCBFLAG_CAN_CALL            0x00000002  // We can call out
#define BCBFLAG_CAN_ACCEPT_CALLS    0x00000004  // We can accept calls
#define BCBFLAG_PEER_CANT_CALL      0x00000008  // Peer rejects Callback-Requests
#define BCBFLAG_PEER_CANT_ACCEPT_CALLS  0x00000010  // Peer rejects Call-Requests
#define BCBFLAG_BAP_REQUIRED        0x00000020  // BAP is required
#define BCBFLAG_LOGON_USER_DATA     0x00000040  // The pCustomAuthUserData has
                                                // come from Winlogon
#define BCBFLAG_WKSTA_IN            0x00000080  // Incoming call on workstation
#define BCBFLAG_LISTENING           0x00000100  // Temporary hack till Rao 
                                                // provides RasPortCancelListen
#define BCBFLAG_IS_SERVER           0x00000200  // Port opened by server
#define BCBFLAG_IPCP_VJ_NEGOTIATED  0x00000400  // IPCP VJ negotiated
#define BCBFLAG_BASIC_ENCRYPTION    0x00000800  // 40-bit RC4/DES
#define BCBFLAG_STRONGER_ENCRYPTION 0x00001000  // 56-bit RC4/DES
#define BCBFLAG_STRONGEST_ENCRYPTION 0x00002000  // 128-bit RC4 or 3DES

//
// This structure is used at initialize time to load all the dlls.
//

typedef struct _DLL_ENTRY_POINTS
{
    FARPROC   pRasCpEnumProtocolIds;

    FARPROC   pRasCpGetInfo;

    CHAR *    pszModuleName;

    HINSTANCE hInstance;

} DLL_ENTRY_POINTS, *PDLL_ENTRY_POINTS;

//
// Contains all information pertaining to a control protocol
//

typedef struct _CONTROL_PROTOCOL_CONTROL_BLOCK
{
    FSM_STATE   State;          // State this FSM is in currently

    DWORD       Protocol;       // Protocol (used only for Auth. protocols)

    DWORD       LastId;         // ID of the last REQ sent

    PVOID       pWorkBuf;       // Pointer to work buffer for this CP.

    DWORD       ConfigRetryCount; // # of retries for Config requests.

    DWORD       TermRetryCount; // # of retries for Terminate requests.

    DWORD       NakRetryCount;  // # of retries for Nak

    DWORD       RejRetryCount;  // # of retries for Rej before terminating.

    DWORD       dwError;        // Contains error code if NCP failed

    BOOL        fConfigurable;  // Indicates if this protocol may be configured

    BOOL        fBeginCalled;   // RasCpBegin was successfully called.

    NCP_PHASE   NcpPhase;       // NCP_DEAD, NCP_CONFIGURING, NCP_UP, NCP_DOWN

} CPCB, *PCPCB;

//
// Contains all information pertaining to BAP
//

typedef struct _BAP_CONTROL_BLOCK
{
    BAP_STATE   BapState;
    
    //
    // Number of retries for request. Initialized in FSendInitialBapRequest.
    //
    DWORD       dwRetryCount;

    //
    // Number of links up when the last BAP_PACKET_DROP_REQ was sent. Set in 
    // BapEventDropLink.
    //
    DWORD       dwLinkCount;

    //
    // Forcibly drop the link if the peer NAKs. Useful when sending 
    // BAP_PACKET_DROP_REQ. Set in BapEventDropLink and BapEventRecvDropReq.
    //
    DWORD       fForceDropOnNak;

    //
    // The ID in the Call-Status-Indication packet should be the same as the one 
    // in last Call-Request sent or the last Callback-Request received. Set in 
    // BapEventRecvCallOrCallbackReq[Resp]
    //
    DWORD       dwStatusIndicationId;

    //
    // If we send a Callback-Request or receive a Call-Request, szPortName will 
    // contain the port to use for RasPortListen(). Non-Router Clients only.
    //
    CHAR        szPortName[MAX_PORT_NAME + 1];

    //
    // If we send a Call-Request or receive a Callback-Request, dwSubEntryIndex 
    // will contain the sub entry for RasDial() and szPeerPhoneNumber will 
    // contain the phone number to dial (Call-Request case). Clients and Routers
    // only.
    //
    DWORD       dwSubEntryIndex;

    CHAR        szPeerPhoneNumber[RAS_MaxPhoneNumber+1];

    //
    // If the server receives a Callback-Request, hPort will contain the port on 
    // which the server will call. Non-Router Servers only.
    //
    HPORT       hPort;

    //
    // For a client, szServerPhoneNumber is the phone number first dialed. For a 
    // server, szServerPhoneNumber is the phone number the client first dialed. 
    // Set in ProcessLineUpWorker.
    //
    CHAR *      szServerPhoneNumber;

    //
    // For a server, szClientPhoneNumber is the phone number first dialed.
    // Allocated in ProcessLineUpWorker, set in FReadPhoneDelta.
    //
    CHAR *      szClientPhoneNumber;

    //
    // pbPhoneDeltaRemote is allocated by FCallInitial(). At that time 
    // dwPhoneDeltaRemoteOffset is set to 0. Every time we pluck a Phone-Delta 
    // from pbPhoneDeltaRemote in FCall(), we increment dwPhoneDeltaRemoteOffset 
    // to point to the next Phone-Delta. When there are no more Phone-Deltas to 
    // pluck, we deallocate phPhoneDeltaRemote.
    //
    BOOL        fPeerSuppliedPhoneNumber; // We have to use pbPhoneDeltaRemote

    BYTE *      pbPhoneDeltaRemote;       // The Phone-Delta sent by the peer

    DWORD       dwPhoneDeltaRemoteOffset; // Offset into pbPhoneDeltaRemote

    //
    // The following variables hold values of the various BAP Datagram Options.
    //

    DWORD       dwOptions;      // The options to send. See BAP_OPTION_*

    DWORD       dwType;         // Type of last BAP REQ packet sent

    DWORD       dwId;           // ID of last BAP REQ packet sent.
                                // Initialized in AllocateAndInitBcb.

    DWORD       dwLinkSpeed;    // Link-Speed in Link-Type option

    DWORD       dwLinkType;     // Link-Type in Link-Type option

    //
    // If there are three Phone-Deltas with
    //
    // Unique-Digits = 4, Subscriber-Number = "1294", Sub-Address = "56",
    // Unique-Digits = 0, Subscriber-Number = "", Sub-Address = "",
    // Unique-Digits = 3, Subscriber-Number = "703", Sub-Address = "",
    //
    // pbPhoneDelta will have:
    // 4 0 '1' '2' '9' '4' 0 '5' '6' 0 FF 3 0 '7' '0' '3' 0 0 0
    //
    // 0's separate the Sub-Options. The last 0 inidicates that there are no 
    // more Phone-Deltas.
    //
    // Unique-Digits is equal to the size of the Subscriber-Number (we ignore 
    // additional digits sent by the peer). If Unique-Digits is 0, then we 
    // represent that Phone-Delta with one byte (0xFF) instead of 0 0 0 because 
    // the latter is indistinguishable from the termination of the Phone-Deltas.
    //
    // Phone-Deltas can only occupy the first BAP_PHONE_DELTA_SIZE bytes. The 
    // last byte must always be 0.
    //
    
    BYTE        pbPhoneDelta[BAP_PHONE_DELTA_SIZE + 1]; // Phone-Delta option
    
    DWORD       dwLinkDiscriminator;    // Link-Discriminator option

    DWORD       dwStatus;               // Status in Call-Status option

    DWORD       dwAction;               // Action in Call-Status option
    
} BAPCB;

struct _PORT_CONTROL_BLOCK;

//
// Multilinked Bundle Control Block
//

typedef struct _BCB
{
    struct _BCB *                   pNext;

    struct _PORT_CONTROL_BLOCK**    ppPcb;  // Array of back pointers to PCBs

    DWORD       dwLinkCount;            // Number of links in the bundle

    DWORD       dwAcctLinkCount;        // The value of raatAcctLinkCount

    DWORD       dwMaxLinksAllowed;      // Max number of links allowed

    DWORD       dwBundleId;             // Used for timeouts.

    DWORD       UId;                    // Bundle wide unique Id.

    HCONN       hConnection;            // Connection handle for this bundle.
                                        // This is unique and not recycled.

    DWORD       dwPpcbArraySize;        // Size of the back pointers array

    DWORD       fFlags;                 // See BCBFLAG_*

    HANDLE      hLicense;

    HANDLE      hTokenImpersonateUser;  // Valid for non router clients only

    PRAS_CUSTOM_AUTH_DATA   pCustomAuthConnData;    // Valid for clients only

    PRAS_CUSTOM_AUTH_DATA   pCustomAuthUserData;    // Valid for clients only

    PPP_EAP_UI_DATA         EapUIData;              // Valid for clients only

    PPP_BAPPARAMS           BapParams;    

    BAPCB       BapCb;

    DWORD       nboRemoteAddress;

    CHAR *      szPhonebookPath;        // For clients only

    CHAR *      szEntryName;            // For clients only

    CHAR *      szTextualSid;           // For clients only

    CHAR *      szReplyMessage;

    CHAR *      szRemoteIdentity;

    CHAR        chSeed;                 // seed for encrypting password

    CHAR        szRemoteUserName[UNLEN+1];

    CHAR        szRemoteDomain[DNLEN+1];

    CHAR        szLocalUserName[UNLEN+1];

    CHAR        szLocalDomain[DNLEN+1];

    CHAR        szPassword[PWLEN+1];

    CHAR        szOldPassword[PWLEN+1];

    CHAR       szComputerName[MAX_COMPUTERNAME_LENGTH + 
								sizeof( MS_RAS_WITH_MESSENGER ) + 1];//Peer's Name is
                               										//extracted from LCP 
                               										//identification message 
                               										//and stored here
    CHAR		szClientVersion[sizeof(MS_RAS_VERSION) + 1];		//Peer's version
    																//is stored here

    PPP_INTERFACE_INFO  InterfaceInfo;

    CPCB        CpCb[1];                            // C.P.s for the bundle.
    
}BCB,*PBCB;

//
// Contains all information regarding a port.
//

typedef struct _PORT_CONTROL_BLOCK
{
    struct _PORT_CONTROL_BLOCK * pNext;

    BCB *       pBcb;           // Pointer to the BCB if this port is bundled.

    HPORT       hPort;          // Handle to the RAS PORT

    BYTE        UId;            // Used to get port-wide unique Id.

    DWORD       RestartTimer;   // Seconds to wait before timing out.

    PPP_PACKET* pSendBuf;       // Pointer to send buffer

    PPP_PHASE   PppPhase;       // Phase the PPP connection process is in.

    DWORD       dwAuthRetries;

    DWORD       fFlags;         

    DWORD       dwDeviceType;

    DWORD       dwPortId;       // Used for timeouts on this port

    HPORT       hportBundleMember;//hPort of port that this port is bundled with

    DWORD       dwSessionTimeout;       // In Seconds

    DWORD       dwAutoDisconnectTime;   // In Seconds

    DWORD		dwLCPEchoTimeInterval;				//Time interval between LCP echos

	DWORD		dwIdleBeforeEcho;					//Idle time before the LCP echo begins

	DWORD		dwNumMissedEchosBeforeDisconnect;	//Num missed echos before disconnect

	DWORD		fEchoRequestSend;			//Flag indicating that echo request is send
											//and we are in the wait mode...
	
	DWORD		dwNumEchoResponseMissed;	//Number of Echo Responses missed...

    DWORD       fCallbackPrivilege;

    DWORD       dwOutstandingAuthRequestId;

    HCONN       hConnection;    // Set in BapEventRecvCallOrCallbackResp.
                                // Used in ProcessRasPortListenEvent.
    DWORD       dwEapTypeToBeUsed;

    DWORD       dwClientEapTypeId;

    DWORD       dwServerEapTypeId;

    RAS_AUTH_ATTRIBUTE * pUserAttributes;

    RAS_AUTH_ATTRIBUTE * pAuthenticatorAttributes;

    RAS_AUTH_ATTRIBUTE * pAuthProtocolAttributes;

    RAS_AUTH_ATTRIBUTE * pAccountingAttributes;

    PPP_CONFIG_INFO      ConfigInfo;

    DWORD       dwSubEntryIndex;        // Valid for clients only

    CPCB        CallbackCb;

    CPCB        AuthenticatorCb;

    CPCB        AuthenticateeCb;

    CPCB        LcpCb;  

    ULARGE_INTEGER       qwActiveTime;

    LUID        Luid;

    CHAR        szCallbackNumber[MAX_PHONE_NUMBER_LEN+1];

    CHAR        szPortName[MAX_PORT_NAME+1];
    
    DWORD		dwAccountingDone;		//Flag to signify that accounting is done.

} PCB, *PPCB;


//
// Bucket containing a linked list of Port Control Blocks.
//

typedef struct _PCB_BUCKET
{
    PCB *       pPorts;         // Pointer to list of ports in this bucket

} PCB_BUCKET, *PPCB_BUCKET;

//
// Bucket containing a linked list of Bundle Control Blocks.
//

typedef struct _BCB_BUCKET
{
    BCB *   pBundles;   // Pointer to list of ports in this bucket

} BCB_BUCKET, *PBCB_BUCKET;

#define MAX_NUMBER_OF_PCB_BUCKETS       61

//
// Array or hash table of buckets of Port Control Blocks and buckets of Bundle 
// Control Blocks
//

typedef struct _PCB_TABLE
{
    PCB_BUCKET*         PcbBuckets;     // Array of PCB buckets

    BCB_BUCKET*         BcbBuckets;     // Array of BCB buckets

    DWORD               NumPcbBuckets;  // Number of buckets in the array.

} PCB_TABLE, *PPCB_TABLE;

typedef struct _PPP_AUTH_INFO
{
    DWORD                   dwError;
    
    DWORD                   dwId;

    DWORD                   dwResultCode;

    RAS_AUTH_ATTRIBUTE *    pInAttributes;

    RAS_AUTH_ATTRIBUTE *    pOutAttributes;
    
} PPP_AUTH_INFO, *PPPP_AUTH_INFO;

//
// BAP call attempt result
//

typedef struct _BAP_CALL_RESULT
{
    DWORD       dwResult;

    HRASCONN    hRasConn;
    
} BAP_CALL_RESULT;

//
// Contains information regarding work to be done by the worker thread.
//

typedef struct _PCB_WORK_ITEM
{
    struct _PCB_WORK_ITEM  * pNext;

    VOID        (*Process)( struct _PCB_WORK_ITEM * pPcbWorkItem );

    HPORT       hPort;                  // Handle to RAS PORT

    HPORT       hConnection;            // Handle to the connection

    HANDLE      hEvent;                 // Handle to stop event

    BOOL        fServer;

    PPP_PACKET* pPacketBuf;             // Used to process receives

    DWORD       PacketLen;              // Used to process receives

    DWORD       dwPortId;               // Used to process timeouts

    DWORD       Id;                     // Used to process timeouts

    DWORD       Protocol;               // Used to process timeouts

    BOOL        fAuthenticator;         // Used to process timeouts

    TIMER_EVENT_TYPE TimerEventType;    // Used to process timeouts

    union
    {
        PPP_START               Start;
        PPPDDM_START            DdmStart;
        PPP_CALLBACK_DONE       CallbackDone;
        PPP_CALLBACK            Callback;
        PPP_CHANGEPW            ChangePw;
        PPP_RETRY               Retry;
        PPP_STOP                PppStop;
        PPP_INTERFACE_INFO      InterfaceInfo;
        PPP_AUTH_INFO           AuthInfo;
        PPP_BAP_EVENT           BapEvent;
        BAP_CALL_RESULT         BapCallResult;
        PPP_DHCP_INFORM         DhcpInform;
        PPP_EAP_UI_DATA         EapUIData;
        PPP_PROTOCOL_EVENT      ProtocolEvent;
        PPP_IP_ADDRESS_LEASE_EXPIRED
                                IpAddressLeaseExpired;
        PPP_POST_LINE_DOWN		PostLineDown;
    }
    PppMsg;

} PCB_WORK_ITEM, *PPCB_WORK_ITEM;


//
// Linked list of work items
//

typedef struct _PCB_WORK_ITEMQ
{
    struct _PCB_WORK_ITEM * pQHead;         // Head of work item Q

    struct _PCB_WORK_ITEM * pQTail;         // Tail of work item Q

    CRITICAL_SECTION        CriticalSection;// Mutex around this Q

    HANDLE                  hEventNonEmpty; // Indicates if the Q is non-empty

} PCB_WORK_ITEMQ, *PPCB_WORK_ITEMQ;

#define PPPCONFIG_FLAG_WKSTA    0x00000001  // Windows NT workstation
#define PPPCONFIG_FLAG_DIRECT   0x00000002  // Direct incoming call on wksta
#define PPPCONFIG_FLAG_TUNNEL   0x00000004  // Tunnel incoming call on wksta
#define PPPCONFIG_FLAG_DIALUP   0x00000008  // DailUp incoming call on wksta

//
// Structure containing PPP configuration data.
//

typedef struct _PPP_CONFIGURATION
{
    DWORD       NumberOfCPs;    // Number of CPs in the PCB, starting from 0

    DWORD       NumberOfAPs;    // Number of APs in the PCB, starting from
                                // NumberOfCPs + 1

    DWORD       DefRestartTimer;// Configurable default restart timer.

    DWORD       fFlags;

    //
    // Is RADIUS authentication being used?
    //

    BOOL        fRadiusAuthenticationUsed; 

    //
    // # of Terminate requests to send w/o receiving Terminate-Ack, def=2
    //

    DWORD       MaxTerminate;   

    //
    // # of Configure requests to send w/o receiving Configure-Ack/NaK/Reject
    // def=10

    DWORD       MaxConfigure;   

    //
    // # of Configure-Nak to send w/o sending a Configure-Ack. def=10
    //

    DWORD       MaxFailure;     

    //
    // # of Configure-Rej to send before assuming that the negotiation will
    // not terminate.

    DWORD       MaxReject;      

    //
    // High level timer for the PPP negotiation. If PPP does not complete
    // within this amount of time the line will be hung up.
    //

    DWORD       NegotiateTime;

    DWORD       dwCallbackDelay;

    DWORD       dwTraceId;

    DWORD       dwDefaultPortLimit;

    DWORD       dwDefaultSessionTimeout;

    DWORD       dwDefaulIdleTimeout;

    DWORD       dwHangUpExtraSampleSeconds;

    DWORD       dwHangupExtraPercent;

    DWORD       dwBapListenTimeoutSeconds;

    DWORD       dwUnknownPacketTraceSize;

    DWORD       dwDontNegotiateMultiLinkOnSingleLink;

    DWORD       dwLoggingLevel;

    DWORD		dwLCPEchoTimeInterval;				//Time interval between LCP echos

	DWORD		dwIdleBeforeEcho;					//Idle time before the LCP echo begins

	DWORD		dwNumMissedEchosBeforeDisconnect;	//Num missed echos before disconnect

    HANDLE      hLogEvents;

    HANDLE      hHeap;

    HANDLE      hEventChangeNotification;

    HKEY        hKeyPpp;

    HINSTANCE   hInstanceParserDll;

    CHAR*       pszParserDllPath;

    VOID        (*SendPPPMessageToDdm)( IN PPP_MESSAGE * PppMsg );

    DWORD       (*RasAuthProviderFreeAttributes)( 
                                    IN RAS_AUTH_ATTRIBUTE * pInAttributes );

    DWORD       (*RasAuthProviderAuthenticateUser)(
                                    IN  RAS_AUTH_ATTRIBUTE * pInAttributes,
                                    OUT PRAS_AUTH_ATTRIBUTE* ppOutAttributes,
                                    OUT DWORD *              lpdwResultCode);

    DWORD       (*RasAcctProviderStartAccounting)(
                                    IN  RAS_AUTH_ATTRIBUTE * pInAttributes,
                                    OUT PRAS_AUTH_ATTRIBUTE* ppOutAttributes);

    DWORD       (*RasAcctProviderInterimAccounting)(
                                    IN RAS_AUTH_ATTRIBUTE * pInAttributes,
                                    OUT PRAS_AUTH_ATTRIBUTE* ppOutAttributes);

    DWORD       (*RasAcctProviderStopAccounting)( 
                                    IN RAS_AUTH_ATTRIBUTE * pInAttributes,
                                    OUT PRAS_AUTH_ATTRIBUTE* ppOutAttributes);

    DWORD       (*RasAcctProviderFreeAttributes)(   
                                    IN RAS_AUTH_ATTRIBUTE * pInAttributes );

    DWORD       (*GetNextAccountingSessionId)( VOID );

    DWORD       (*RasIpcpDhcpInform)( IN VOID * pWorkBuf,
                                      IN PPP_DHCP_INFORM * pDhcpInform );

    VOID        (*RasIphlpDhcpCallback)( IN ULONG nboIpAddr );

    VOID        (*PacketFromPeer)(
                        IN  HANDLE  hPort,
                        IN  BYTE*   pbDataIn,
                        IN  DWORD   dwSizeIn,
                        OUT BYTE**  ppbDataOut,
                        OUT DWORD*  pdwSizeOut );

    VOID        (*PacketToPeer)(
                        IN  HANDLE  hPort,
                        IN  BYTE*   pbDataIn,
                        IN  DWORD   dwSizeIn,
                        OUT BYTE**  ppbDataOut,
                        OUT DWORD*  pdwSizeOut );

    VOID        (*PacketFree)(
                        IN  BYTE*   pbData );

    DWORD       dwNASIpAddress;

    DWORD       PortUIDGenerator;

    //
    // Server config info. Contains information as to what CPs to mark as
    // configurable
    //

    PPP_CONFIG_INFO ServerConfigInfo;

    CHAR        szNASIdentifier[MAX_COMPUTERNAME_LENGTH+1];

    //
    // This is the Multilink endpoint discriminator option. It is stored in 
    // network form. It contains the class and address fields.

    BYTE        EndPointDiscriminator[21];

} PPP_CONFIGURATION, *PPPP_CONFIGURATION;

//
//
// Timer queue item
//

typedef struct _TIMER_EVENT
{
    struct _TIMER_EVENT* pNext;

    struct _TIMER_EVENT* pPrev;

    TIMER_EVENT_TYPE EventType;

    DWORD        dwPortId;      // Id of the port/bundle REQ this timeout is for

    HPORT        hPort;         // Handle of the port REQ this timeout is for.

    DWORD        Protocol;      // Protocol for the timeout event.

    DWORD        Id;            // ID of the REQ this timeout is for

    BOOL         fAuthenticator;// Used to determine the side of Auth protocols

    DWORD        Delta;         // # of secs. to wait after prev. TIMER_EVENT

} TIMER_EVENT, *PTIMER_EVENT;

//
// Head of timer queue.
//

typedef struct _TIMER_Q {

    TIMER_EVENT * pQHead;

    HANDLE      hEventNonEmpty; // Indicates that the Q is not empty.   

} TIMER_Q, *PTIMER_Q;


//
// Context atructure for Stop Accounting 
//

typedef struct _STOP_ACCOUNTING_CONTEXT
{
	PCB					* 	pPcb;			//Pointer to the PCB 
	RAS_AUTH_ATTRIBUTE * 	pAuthAttributes;			//List of Authentication Attributes.
} STOP_ACCOUNTING_CONTEXT, * PSTOP_ACCOUNTING_CONTEXT ;
// Declare global data structures.
//

#ifdef _ALLOCATE_GLOBALS_

#define PPP_EXTERN

CHAR *FsmStates[] =
{
        "Initial",
        "Starting",
        "Closed",
        "Stopped",
        "Closing",
        "Stopping",
        "Req Sent",
        "Ack Rcvd",
        "Ack Sent",
        "Opened"
};

CHAR *FsmCodes[] =
{
        NULL,
        "Configure-Req",
        "Configure-Ack",
        "Configure-Nak",
        "Configure-Reject",
        "Terminate-Req",
        "Terminate-Ack",
        "Code-Reject",
        "Protocol-Reject",
        "Echo-Request",
        "Echo-Reply",
        "Discard-Request",
        "Identification",
        "Time-Remaining",
};

CHAR *SzBapStateName[] =
{
    "INITIAL",
    "SENT_CALL_REQ",
    "SENT_CALLBACK_REQ",
    "SENT_DROP_REQ",
    "SENT_STATUS_IND",
    "CALLING",
    "LISTENING"
};

CHAR *SzBapPacketName[] =
{
    "",
    "CALL_REQ",
    "CALL_RESP",
    "CALLBACK_REQ",
    "CALLBACK_RESP",
    "DROP_REQ",
    "DROP_RESP",
    "STATUS_IND",
    "STAT_RESP"
};

#else

#define PPP_EXTERN extern

extern CHAR *   FsmStates[];
extern CHAR *   FsmCodes[];
extern CHAR *   SzBapStateName[];
extern CHAR *   SzBapPacketName[];

#endif

PPP_EXTERN PCB_TABLE            PcbTable;

PPP_EXTERN PCB_WORK_ITEMQ       WorkItemQ;

PPP_EXTERN PPP_CONFIGURATION    PppConfigInfo;

PPP_EXTERN PPPCP_ENTRY *        CpTable;

PPP_EXTERN TIMER_Q              TimerQ;

PPP_EXTERN DWORD                DwBapTraceId;

PPP_EXTERN DWORD                PrivateTraceId;

// BAP is meaningless over VPN's. For testing purposes, we may want to allow it.

PPP_EXTERN BOOL                 FDoBapOnVpn;

VOID
PrivateTrace(
    IN  CHAR*   Format,
    ...
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\engine\callback.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    callback.h
//
// Description: Contains function prototypes for the callback module
//
// History:
//      April 11,1993.  NarenG          Created original version.
//

VOID
CbStart( 
    IN PCB * pPcb,
    IN DWORD CpIndex
);

VOID
CbStop( 
    IN PCB * pPcb,
    IN DWORD CpIndex
);

VOID
CbWork(
    IN PCB *         pPcb,
    IN DWORD         CpIndex,
    IN PPP_CONFIG *  pRecvConfig,
    IN PPPCB_INPUT * pCbInput
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\engine\pppapi.c ===
/* Copyright (c) 1993, Microsoft Corporation, all rights reserved
**
** rasppp.c
** Remote Access PPP APIs
**
** 11/15/93 Steve Cobb
*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>

#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <lmcons.h>
#include <rasauth.h>
#include <rasman.h>
#include <rasppp.h>
#include <ddmif.h>
#include <rtutils.h>
#include <mprlog.h>
#include <raserror.h>
#include <pppcp.h>
#include <ppp.h>
#include <util.h>
#include <init.h>
#include <worker.h>
#include <bap.h>
#include <raseapif.h>

//**
//
// Call:        StartPPP
//
// Returns:     NO_ERROR                - Success.
//              Non zero return code    - Failure
//
// Description:
//
DWORD APIENTRY
StartPPP(
    DWORD   NumPorts
)
{
    DWORD   dwRetCode;

    //
    // Read registry info, load CP DLLS, initialize globals etc.
    //

    PcbTable.NumPcbBuckets = ((DWORD)NumPorts > MAX_NUMBER_OF_PCB_BUCKETS)
                                    ? MAX_NUMBER_OF_PCB_BUCKETS
                                    : (DWORD)NumPorts;

    dwRetCode = InitializePPP();

    if ( dwRetCode != NO_ERROR )
    {
        PPPCleanUp();
    }
    else
    {
        PppLog( 2, "PPP Initialized successfully." );
    }

    return( dwRetCode );
}

//**
//
// Call:        StopPPP
//
// Returns:     NO_ERROR                - Success.
//              Non zero return code    - Failure
//
DWORD APIENTRY
StopPPP(
    HANDLE hEventStopPPP
)
{
    PCB_WORK_ITEM * pWorkItem;

    PppLog( 2, "StopPPP called" );

    //
    // Insert shutdown event
    //

    pWorkItem = (PCB_WORK_ITEM*)LOCAL_ALLOC(LPTR,sizeof(PCB_WORK_ITEM));

    if ( pWorkItem == (PCB_WORK_ITEM *)NULL )
    {
        return( GetLastError() );
    }

    pWorkItem->Process = ProcessStopPPP;

    pWorkItem->hEvent = hEventStopPPP;

    InsertWorkItemInQ( pWorkItem );

    return( NO_ERROR );
}

//**
//
// Call:        SendPPPMessageToEngine
//
// Returns:     NO_ERROR - Success
//              non-zero - FAILURE
//
// Description: Will create a PCB_WORK_ITEM from a PPPE_MESSAGE structure
//              received from client or rassrv and Send it to the engine.
//
DWORD APIENTRY
SendPPPMessageToEngine(
    IN PPPE_MESSAGE* pMessage
)
{
    PCB_WORK_ITEM * pWorkItem = (PCB_WORK_ITEM *)LOCAL_ALLOC(
                                                        LPTR,
                                                        sizeof(PCB_WORK_ITEM));

    if ( pWorkItem == (PCB_WORK_ITEM *)NULL )
    {
        LogPPPEvent( ROUTERLOG_NOT_ENOUGH_MEMORY, 0 );

        return( GetLastError() );
    }

    //
    // Set up PCB_WORK_ITEM structure from the PPPE_MESSAGE
    //

    pWorkItem->hPort = pMessage->hPort;

    switch( pMessage->dwMsgId )
    {
    case PPPEMSG_Start:

        pWorkItem->Process      = ProcessLineUp;
        pWorkItem->fServer      = FALSE;
        pWorkItem->PppMsg.Start = pMessage->ExtraInfo.Start;
		//Create a seed for encoding the password
		pMessage->ExtraInfo.Start.chSeed = pWorkItem->PppMsg.Start.chSeed = GEN_RAND_ENCODE_SEED;

        PppLog( 2, "PPPEMSG_Start recvd, d=%s, hPort=%d,callback=%d,"
                        "mask=%x,IfType=%d",
                        pMessage->ExtraInfo.Start.szDomain,
                        pWorkItem->hPort,
                        pMessage->ExtraInfo.Start.fThisIsACallback,
                        pMessage->ExtraInfo.Start.ConfigInfo.dwConfigMask,
                        pMessage->ExtraInfo.Start.PppInterfaceInfo.IfType );

        EncodePw( pWorkItem->PppMsg.Start.chSeed, pWorkItem->PppMsg.Start.szPassword );
        EncodePw( pMessage->ExtraInfo.Start.chSeed, pMessage->ExtraInfo.Start.szPassword );

        break;

    case PPPEMSG_Stop:

        PppLog( 2, "PPPEMSG_Stop recvd\r\n" );

        pWorkItem->Process          = ProcessClose;
        pWorkItem->PppMsg.PppStop   = pMessage->ExtraInfo.Stop;

        break;

    case PPPEMSG_Callback:

        PppLog( 2, "PPPEMSG_Callback recvd, hPort=%d\r\n",
                        pWorkItem->hPort);

        pWorkItem->Process      = ProcessGetCallbackNumberFromUser;
        pWorkItem->PppMsg.Callback  = pMessage->ExtraInfo.Callback;

        break;

    case PPPEMSG_ChangePw:

        PppLog( 2, "PPPEMSG_ChangePw recvd, hPort=%d\r\n",
                        pWorkItem->hPort);

        pWorkItem->Process      = ProcessChangePassword;
        pWorkItem->PppMsg.ChangePw  = pMessage->ExtraInfo.ChangePw;
		pWorkItem->PppMsg.ChangePw.chSeed = pMessage->ExtraInfo.ChangePw.chSeed = GEN_RAND_ENCODE_SEED;

        EncodePw( pWorkItem->PppMsg.ChangePw.chSeed, pWorkItem->PppMsg.ChangePw.szNewPassword );
        EncodePw( pMessage->ExtraInfo.ChangePw.chSeed, pMessage->ExtraInfo.ChangePw.szNewPassword );
        EncodePw( pWorkItem->PppMsg.ChangePw.chSeed, pWorkItem->PppMsg.ChangePw.szOldPassword );
        EncodePw( pMessage->ExtraInfo.ChangePw.chSeed, pMessage->ExtraInfo.ChangePw.szOldPassword );

        break;

    case PPPEMSG_Retry:

        PppLog( 2, "PPPEMSG_Retry recvd hPort=%d,u=%s",
                        pWorkItem->hPort,
                        pMessage->ExtraInfo.Start.szUserName );

        pWorkItem->Process      = ProcessRetryPassword;
        pWorkItem->PppMsg.Retry = pMessage->ExtraInfo.Retry;
		pWorkItem->PppMsg.Retry.chSeed = pMessage->ExtraInfo.Retry.chSeed = GEN_RAND_ENCODE_SEED;

        EncodePw( pWorkItem->PppMsg.Retry.chSeed, pWorkItem->PppMsg.Retry.szPassword );
        EncodePw( pMessage->ExtraInfo.Retry.chSeed, pMessage->ExtraInfo.Retry.szPassword );

        break;

    case PPPEMSG_Receive:

        pWorkItem->Process = ProcessReceive;
        pWorkItem->PacketLen = pMessage->ExtraInfo.Receive.dwNumBytes;

        PppLog( 2, "Packet received (%d bytes) for hPort %d",
            pWorkItem->PacketLen, pWorkItem->hPort );

        pWorkItem->pPacketBuf = (PPP_PACKET *)LOCAL_ALLOC(LPTR,
                                                          pWorkItem->PacketLen);
        if ( pWorkItem->pPacketBuf == (PPP_PACKET*)NULL )
        {
            LogPPPEvent( ROUTERLOG_NOT_ENOUGH_MEMORY, 0 );
            LOCAL_FREE( pWorkItem );

            return( GetLastError() );
        }

        CopyMemory( pWorkItem->pPacketBuf,
                    pMessage->ExtraInfo.Receive.pbBuffer,
                    pWorkItem->PacketLen );

        break;

    case PPPEMSG_LineDown:

        PppLog( 2, "PPPEMSG_LineDown recvd, hPort=%d\r\n",
                        pWorkItem->hPort);

        pWorkItem->Process = ProcessLineDown;

        break;

    case PPPEMSG_ListenResult:

        pWorkItem->Process = ProcessRasPortListenEvent;

        break;

    case PPPEMSG_BapEvent:

        BapTrace( "Threshold event on HCONN 0x%x. Type: %s, Threshold: %s",
            pMessage->hConnection,
            pMessage->ExtraInfo.BapEvent.fTransmit ? "transmit" : "receive",
            pMessage->ExtraInfo.BapEvent.fAdd ? "upper" : "lower");

        pWorkItem->Process = ProcessThresholdEvent;
        pWorkItem->hConnection = pMessage->hConnection;
        pWorkItem->PppMsg.BapEvent = pMessage->ExtraInfo.BapEvent;

        break;

    case PPPEMSG_DdmStart:

        pWorkItem->Process          = ProcessLineUp;
        pWorkItem->fServer          = TRUE;
        pWorkItem->PppMsg.DdmStart  = pMessage->ExtraInfo.DdmStart;

        break;

    case PPPEMSG_DdmCallbackDone:

        PppLog( 2, "PPPEMSG_DdmCallbackDone recvd\r\n" );

        pWorkItem->Process              = ProcessCallbackDone;
        pWorkItem->fServer              = TRUE;
        pWorkItem->PppMsg.CallbackDone  = pMessage->ExtraInfo.CallbackDone;

        break;

    case PPPEMSG_DdmInterfaceInfo:

        pWorkItem->Process      = ProcessInterfaceInfo;
        pWorkItem->fServer      = TRUE;
        pWorkItem->hConnection  = pMessage->hConnection;

        pWorkItem->PppMsg.InterfaceInfo = pMessage->ExtraInfo.InterfaceInfo;

        PppLog(2,"PPPEMSG_DdmInterfaceInfo recvd,IPXif=%x,IPif=%x,Type=%x\r\n",
                 pWorkItem->PppMsg.InterfaceInfo.hIPXInterface,
                 pWorkItem->PppMsg.InterfaceInfo.hIPInterface,
                 pWorkItem->PppMsg.InterfaceInfo.IfType );

        break;

    case PPPEMSG_DdmBapCallbackResult:

        pWorkItem->Process = ProcessCallResult;
        pWorkItem->hConnection = pMessage->hConnection;
        pWorkItem->PppMsg.BapCallResult.dwResult =
            pMessage->ExtraInfo.BapCallbackResult.dwCallbackResultCode;
        pWorkItem->PppMsg.BapCallResult.hRasConn = (HRASCONN) -1;

        break;

    case PPPEMSG_DhcpInform:

        pWorkItem->Process           = ProcessDhcpInform;
        pWorkItem->hConnection       = pMessage->hConnection;
        pWorkItem->PppMsg.DhcpInform = pMessage->ExtraInfo.DhcpInform;

        break;

    case PPPEMSG_EapUIData:

        pWorkItem->Process           = ProcessEapUIData;
        pWorkItem->PppMsg.EapUIData  = pMessage->ExtraInfo.EapUIData;

        break;

    case PPPEMSG_ProtocolEvent:

        pWorkItem->Process              = ProcessProtocolEvent;
        pWorkItem->PppMsg.ProtocolEvent = pMessage->ExtraInfo.ProtocolEvent;

        break;

    case PPPEMSG_DdmChangeNotification:

        pWorkItem->Process           = ProcessChangeNotification;

        break;

    case PPPEMSG_IpAddressLeaseExpired:

        pWorkItem->Process           = ProcessIpAddressLeaseExpired;
        pWorkItem->PppMsg.IpAddressLeaseExpired =
                                    pMessage->ExtraInfo.IpAddressLeaseExpired;

        break;

	case PPPEMSG_PostLineDown:
		pWorkItem->Process			= ProcessPostLineDown;
		pWorkItem->PppMsg.PostLineDown = 
									pMessage->ExtraInfo.PostLineDown;
		break;
    default:

        PppLog( 2,"Unknown IPC message %d received\r\n", pMessage->dwMsgId );

        LOCAL_FREE( pWorkItem );

        pWorkItem = (PCB_WORK_ITEM*)NULL;
    }

    if ( pWorkItem != NULL )
    {
        InsertWorkItemInQ( pWorkItem );
    }

    return( NO_ERROR );
}

//**
//
// Call:        PppDdmInit
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will initialize the entry point into DDM that it will call to
//              send DDM a PPP_MESSAGE
//
DWORD
PppDdmInit(
    IN  VOID (*SendPPPMessageToDdm)( PPP_MESSAGE * PppMsg ),
    IN  DWORD   dwServerFlags,
    IN  DWORD   dwLoggingLevel,
    IN  DWORD   dwNASIpAddress,
    IN  BOOL    fRadiusAuthentication,
    IN  LPVOID  lpfnRasAuthProviderAuthenticateUser,
    IN  LPVOID  lpfnRasAuthProviderFreeAttributes,
    IN  LPVOID  lpfnRasAcctProviderStartAccounting,
    IN  LPVOID  lpfnRasAcctProviderInterimAccounting,
    IN  LPVOID  lpfnRasAcctProviderStopAccounting,
    IN  LPVOID  lpfnRasAcctProviderFreeAttributes,
    IN  LPVOID  lpfnGetNextAccountingSessionId
)
{
    DWORD               dwRetCode;

    PppConfigInfo.SendPPPMessageToDdm            = SendPPPMessageToDdm;
    PppConfigInfo.ServerConfigInfo.dwConfigMask |= dwServerFlags;
    PppConfigInfo.dwNASIpAddress                 = dwNASIpAddress;
    PppConfigInfo.dwLoggingLevel                 = dwLoggingLevel;

    if ( dwNASIpAddress == 0 )
    {
        DWORD dwComputerNameLen = MAX_COMPUTERNAME_LENGTH + 1;

        //
        // Failed to get the LOCAL IP address, used computer name instead.
        //

        PppConfigInfo.dwNASIpAddress = 0;

        if ( !GetComputerNameA( PppConfigInfo.szNASIdentifier, 
                                &dwComputerNameLen ) ) 
        {
            return( GetLastError() );
        }
    }

    PppConfigInfo.fRadiusAuthenticationUsed = fRadiusAuthentication;

    PppConfigInfo.RasAuthProviderFreeAttributes = 
                                (DWORD(*)( RAS_AUTH_ATTRIBUTE *))
                                    lpfnRasAuthProviderFreeAttributes;

    PppConfigInfo.RasAuthProviderAuthenticateUser = 
                                (DWORD(*)( RAS_AUTH_ATTRIBUTE * ,
                                           PRAS_AUTH_ATTRIBUTE* ,
                                           DWORD *))
                                    lpfnRasAuthProviderAuthenticateUser;

    PppConfigInfo.RasAcctProviderStartAccounting = 
                                (DWORD(*)( RAS_AUTH_ATTRIBUTE *,
                                           PRAS_AUTH_ATTRIBUTE*))
                                    lpfnRasAcctProviderStartAccounting;

    PppConfigInfo.RasAcctProviderInterimAccounting = 
                                (DWORD(*)( RAS_AUTH_ATTRIBUTE * ,
                                           PRAS_AUTH_ATTRIBUTE*)) 
                                    lpfnRasAcctProviderInterimAccounting;

    PppConfigInfo.RasAcctProviderStopAccounting = 
                                (DWORD(*)( RAS_AUTH_ATTRIBUTE * ,
                                           PRAS_AUTH_ATTRIBUTE*))
                                    lpfnRasAcctProviderStopAccounting;

    PppConfigInfo.RasAcctProviderFreeAttributes = 
                                (DWORD(*)( RAS_AUTH_ATTRIBUTE *))
                                    lpfnRasAcctProviderFreeAttributes;

    PppConfigInfo.GetNextAccountingSessionId = 
                                (DWORD(*)(VOID))
                                    lpfnGetNextAccountingSessionId;

    return( NO_ERROR );
}

//**
//
// Call:        PppDdmDeInit
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
VOID
PppDdmDeInit(
    VOID
)
{
    return;
}

//**
//
// Call:        PppDdmCallbackDone
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will create a PPPEMSG_DdmCallbackDone and send it to the
//              worker thread of the PPP engine.
//
DWORD
PppDdmCallbackDone(
    IN HPORT    hPort,
    IN WCHAR*   pwszCallbackNumber
)
{
    PPPE_MESSAGE PppMessage;

    PppMessage.hPort    = hPort;
    PppMessage.dwMsgId  = PPPEMSG_DdmCallbackDone;

    wcstombs( PppMessage.ExtraInfo.CallbackDone.szCallbackNumber, 
              pwszCallbackNumber, 
              sizeof( PppMessage.ExtraInfo.CallbackDone.szCallbackNumber ) ); 

    return( SendPPPMessageToEngine( &PppMessage ) );
}

//**
//
// Call:        PppDdmStart
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will create a PPPEMSG_DdmStart and send it to the
//              worker thread of the PPP engine.
//
DWORD
PppDdmStart(
    IN HPORT                hPort,
    IN WCHAR *              wszPortName,
    IN CHAR*                pchFirstFrame,
    IN DWORD                cbFirstFrame,
    IN DWORD                dwAuthRetries
)
{
    PPPE_MESSAGE PppMessage;

    PppMessage.hPort    = hPort;
    PppMessage.dwMsgId  = PPPEMSG_DdmStart;

    PppMessage.ExtraInfo.DdmStart.dwAuthRetries = dwAuthRetries;

    wcstombs( PppMessage.ExtraInfo.DdmStart.szPortName, 
              wszPortName, 
              sizeof( PppMessage.ExtraInfo.DdmStart.szPortName ) ); 

    CopyMemory( &(PppMessage.ExtraInfo.DdmStart.achFirstFrame),
                pchFirstFrame, 
                sizeof( PppMessage.ExtraInfo.DdmStart.achFirstFrame ) );

    PppMessage.ExtraInfo.DdmStart.cbFirstFrame = cbFirstFrame;

    return( SendPPPMessageToEngine( &PppMessage ) );
}

							 


//**
//
// Call:        PppStop
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will create a PPPEMSG_Stop and send it to the
//              worker thread of the PPP engine.
//
DWORD
PppStop(
    IN HPORT                hPort
)
{
    PPPE_MESSAGE PppMessage;

    PppLog( 2, "PppStop\r\n" );

    PppMessage.hPort    = hPort;
    PppMessage.dwMsgId  = PPPEMSG_Stop;

    PppMessage.ExtraInfo.Stop.dwStopReason = NO_ERROR;

    return( SendPPPMessageToEngine( &PppMessage ) );
}

//**
//
// Call:        PppDdmStop
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will create a PPPEMSG_Stop and send it to the
//              worker thread of the PPP engine.
//
DWORD
PppDdmStop(
    IN HPORT                hPort,
    IN DWORD                dwStopReason
)
{
    PPPE_MESSAGE PppMessage;

    PppLog( 2, "PppDdmStop\r\n" );

    PppMessage.hPort    = hPort;
    PppMessage.dwMsgId  = PPPEMSG_Stop;

    PppMessage.ExtraInfo.Stop.dwStopReason = dwStopReason;

    return( SendPPPMessageToEngine( &PppMessage ) );
}

//**
//
// Call:        PppDdmSendInterfaceInfo
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will create a PPPEMSG_DdmInterfaceInfo and send it to the
//              worker thread of the PPP engine.
//
DWORD
PppDdmSendInterfaceInfo(
    IN HCONN                hConnection,
    IN PPP_INTERFACE_INFO * pInterfaceInfo
)
{
    PPPE_MESSAGE PppMessage;

    PppMessage.hConnection  = hConnection;
    PppMessage.dwMsgId      = PPPEMSG_DdmInterfaceInfo;

    PppMessage.ExtraInfo.InterfaceInfo = *pInterfaceInfo;

    return( SendPPPMessageToEngine( &PppMessage ) );
}

//**
//
// Call:        PppDdmBapCallbackResult
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will create a PPPEMSG_DdmBapCallbackResult and send it to the
//              worker thread of the PPP engine.
//
DWORD
PppDdmBapCallbackResult(
    IN HCONN    hConnection,
    IN DWORD    dwBapCallbackResultCode
)
{
    PPPE_MESSAGE PppMessage;

    PppMessage.hConnection = hConnection;
    PppMessage.dwMsgId = PPPEMSG_DdmBapCallbackResult;

    PppMessage.ExtraInfo.BapCallbackResult.dwCallbackResultCode
        = dwBapCallbackResultCode;

    return( SendPPPMessageToEngine( &PppMessage ) );
}

//**
//
// Call:        PppDdmChangeNotification
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
PppDdmChangeNotification(
    IN DWORD   dwServerFlags,
    IN DWORD   dwLoggingLevel
)
{
    PPPE_MESSAGE PppMessage;

    PppLog( 2, "PppDdmChangeNotification. New flags: 0x%x", dwServerFlags );

    PppMessage.dwMsgId = PPPEMSG_DdmChangeNotification;

    PppConfigInfo.ServerConfigInfo.dwConfigMask = dwServerFlags;

    PppConfigInfo.dwLoggingLevel = dwLoggingLevel;

    return( SendPPPMessageToEngine( &PppMessage ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\engine\smevents.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    smevents.c
//
// Description: This module contain the events processing code for the 
//              Finite State Machine for PPP.
//
// History:
//      Oct 25,1993.    NarenG          Created Original version.
//
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>     // needed for winbase.h

#include <windows.h>    // Win32 base API's
#include <stdlib.h>
#include <string.h>
#include <wchar.h>

#include <rasauth.h>
#include <raseapif.h>
#include <lmcons.h>
#include <raserror.h>
#include <rasman.h>
#include <rtutils.h>
#include <rasppp.h>
#include <pppcp.h>
#include <ppp.h>
#include <smaction.h>
#include <smevents.h>
#include <receive.h>
#include <auth.h>
#include <callback.h>
#include <lcp.h>
#include <timer.h>
#include <util.h>
#include <worker.h>
#include <bap.h>

static VOID (*ProcessPacket[])( PCB *           pPcb, 
                                DWORD           CpIndex, 
                                CPCB *          pCpCb, 
                                PPP_CONFIG *    pRecvConfig ) = 
{
    NULL,
    ReceiveConfigReq,
    ReceiveConfigAck,
    ReceiveConfigNakRej,
    ReceiveConfigNakRej,
    ReceiveTermReq,
    ReceiveTermAck,
    ReceiveCodeRej,
    NULL,
    ReceiveEchoReq,
    ReceiveEchoReply,
    ReceiveDiscardReq,
    ReceiveIdentification,
    ReceiveTimeRemaining 
};


/************************************************************************/
/*                      E V E N T   P R O C E S S I N G                 */
/************************************************************************/


//**
//
// Call:        FsmUp
//
// Returns:     none.
//
// Description: This is called after a Line Up event occurs.
//
VOID
FsmUp(
    IN PCB *  pPcb,
    IN DWORD  CpIndex
)
{
    CPCB * pCpCb = GetPointerToCPCB( pPcb, CpIndex );

    if ( pCpCb == NULL )
    {
        return;
    }

    PppLog( 2, "FsmUp event received for protocol %x on port %d",
                CpTable[CpIndex].CpInfo.Protocol, pPcb->hPort );

    if ( CpIndex == LCP_INDEX )
    {
        pPcb->PppPhase = PPP_LCP;
    }

    switch( pCpCb->State )
    {

    case FSM_INITIAL:

        pCpCb->State = FSM_CLOSED;

        break;

    case FSM_STARTING:

        InitRestartCounters( pPcb, pCpCb );

        if ( !FsmSendConfigReq( pPcb, CpIndex, FALSE ) )
        {
            //
            // If we couldn't even send the first configure request, we mark
            // this protocol as NOT CONFIGURABLE so that we protocol reject
            // this layer. We need to do this since FsmClose will not send
            // a terminate request in this state (as per the PPP FSM) and we
            // want to terminate this layer gracefully instead of simply
            // dropping all the clients packets and having the client
            // timeout.
            //

            pCpCb->fConfigurable = FALSE;

            return;
        }

        pCpCb->State = FSM_REQ_SENT;

        break;

    default:

        //
        // Already started 
        //

        PPP_ASSERT( pCpCb->State < 10 );

        PppLog( 2, "Illegal transition -> FsmUp received while in %s state",
                   FsmStates[pCpCb->State] );

        break;
    }
}

//**
//
// Call:        FsmOpen
//
// Returns:     None.
//
// Description: This is called after an Open event occurs.
//
VOID
FsmOpen(
    IN PCB *  pPcb,
    IN DWORD  CpIndex
)
{
    CPCB * pCpCb = GetPointerToCPCB( pPcb, CpIndex );

    if ( pCpCb == NULL )
    {
        return;
    }

    PppLog( 2,  "FsmOpen event received for protocol %x on port %d",
                CpTable[CpIndex].CpInfo.Protocol, pPcb->hPort );

    switch( pCpCb->State )
    {

    case FSM_INITIAL:

        if ( !FsmThisLayerStarted( pPcb, CpIndex ) )
            return;

        pCpCb->State = FSM_STARTING;

        break;

    case FSM_STARTING:
    case FSM_REQ_SENT:
    case FSM_ACK_RCVD:
    case FSM_ACK_SENT:

        break;

    case FSM_CLOSING:

        pCpCb->State = FSM_STOPPING;

        //
        // Fallthru
        //

    case FSM_OPENED:
    case FSM_STOPPED:
    case FSM_STOPPING:

        //
        // Restart option not implemented.
        //
        // FsmDown( pPcb, CpIndex );
        // FsmUp( pPcb, CpIndex );
        //

        break;

    case FSM_CLOSED:

        InitRestartCounters( pPcb, pCpCb );

        if ( !FsmSendConfigReq( pPcb, CpIndex, FALSE ) )
            return;

        pCpCb->State = FSM_REQ_SENT;

        break;

    default:

        PPP_ASSERT( pCpCb->State < 10 );

        PppLog( 2, "Illegal transition->FsmOpen received while in %s state",
                   FsmStates[pCpCb->State] );
        break;
    }
}

//**
//
// Call:        FsmDown
//
// Returns:     None.
//
// Description: Will get called after the physical line goes down.
//
VOID
FsmDown(
    IN PCB *    pPcb,
    IN DWORD    CpIndex
)
{
    CPCB *  pCpCb = GetPointerToCPCB( pPcb, CpIndex );

    if ( pCpCb == NULL )
    {
        return;
    }

    PppLog( 2, "FsmDown event received for protocol %x on port %d",
                CpTable[CpIndex].CpInfo.Protocol, pPcb->hPort );

    RemoveFromTimerQ( pPcb->dwPortId,
                      pCpCb->LastId,
                      CpTable[CpIndex].CpInfo.Protocol,
                      FALSE,
                      TIMER_EVENT_TIMEOUT );

    switch( pCpCb->State )
    {

    case FSM_CLOSED:
    case FSM_CLOSING:

        if ( !FsmReset( pPcb, CpIndex ) )
            return;

        pCpCb->State = FSM_INITIAL;

        break;

    case FSM_OPENED:

        if ( !FsmThisLayerDown( pPcb, CpIndex ) )
            return;

        //
        // Fallthru
        //

    case FSM_REQ_SENT:
    case FSM_ACK_RCVD:
    case FSM_ACK_SENT:
    case FSM_STOPPING:

        if ( !FsmReset( pPcb, CpIndex ) )
            return;

        pCpCb->State = FSM_STARTING;

        break;

    case FSM_STOPPED:

        if ( !FsmThisLayerStarted( pPcb, CpIndex ) )
            return;

        if ( !FsmReset( pPcb, CpIndex ) )
            return;

        pCpCb->State = FSM_STARTING;

        break;

    case FSM_STARTING:
    case FSM_INITIAL:
    default:

        PPP_ASSERT( pCpCb->State < 10 );

        PppLog( 2, "Illegal transition->FsmDown received while in %s state",
                   FsmStates[pCpCb->State] );
        break;
    }

    if ( CpIndex == LCP_INDEX )
    {
        pPcb->PppPhase = PPP_LCP;
    }
}

//**
//
// Call:        FsmClose
//
// Returns:     None.
//
// Description: Will get called when a close connection is requested.
//              NOTE: Call FsmThisLayerFinished in the states where we do
//                    not have to send a Term Req. and wait for a Term Ack. 
//                    This is done so that it is guaranteed that 
//                    FsmThisLayerFinished is called in ALL states. We need
//                    to do this since all processing of failures is done in
//                    the FsmThisLayerFinished call.
//                    
VOID
FsmClose(
    IN PCB * pPcb,
    IN DWORD CpIndex
)
{
    CPCB * pCpCb = GetPointerToCPCB( pPcb, CpIndex );

    if ( pCpCb == NULL )
    {
        return;
    }

    PppLog( 2, "FsmClose event received for protocol %x on port %d",
                CpTable[CpIndex].CpInfo.Protocol, pPcb->hPort );

    if ( CpIndex == LCP_INDEX )
    {
        pPcb->PppPhase = PPP_LCP;
    }

    //
    // We are closing this layer so remove any items from the timer Q
    //

    RemoveFromTimerQ( pPcb->dwPortId,
                      pCpCb->LastId,
                      CpTable[CpIndex].CpInfo.Protocol,
                      FALSE,
                      TIMER_EVENT_TIMEOUT );

    switch ( pCpCb->State ) 
    {

    case FSM_STARTING:

        pCpCb->State = FSM_INITIAL;

        if ( !FsmThisLayerFinished( pPcb, CpIndex, FALSE ) )
            return;

        break;

    case FSM_STOPPED:

        pCpCb->State = FSM_CLOSED;

        if ( !FsmThisLayerFinished( pPcb, CpIndex, FALSE ) )
            return;

        break;

    case FSM_STOPPING:

        pCpCb->State = FSM_CLOSING;

        if ( !FsmThisLayerFinished( pPcb, CpIndex, FALSE ) )
            return;

        break;

    case FSM_REQ_SENT:
    case FSM_OPENED:

        if ( !FsmThisLayerDown( pPcb, CpIndex ) )
            return;

        //
        // Fallthru 
        //

    case FSM_ACK_RCVD:
    case FSM_ACK_SENT:

        InitRestartCounters( pPcb, pCpCb );

        //
        // May not be able to do this because the link may be down.
        //

        FsmSendTermReq( pPcb, CpIndex );

        pCpCb->State = FSM_CLOSING;

        break;

    case FSM_CLOSING:
    case FSM_CLOSED:
    case FSM_INITIAL:

        if ( !FsmThisLayerFinished( pPcb, CpIndex, FALSE ) )
            return;

        //
        // nothing to do 
        //

        break;

    default:

        PPP_ASSERT( pCpCb->State < 10 );

        PppLog( 2,"Illegal transition->FsmClose received while in %s state",
                   FsmStates[pCpCb->State] );
        break;

    }
}

//**
//
// Call:        FsmTimeout
//
// Returns:     None
//
// Description: Called to process a timeout while waiting for reply 
//              from remote host.
//
VOID
FsmTimeout(
    IN PCB *    pPcb,
    IN DWORD    CpIndex,
    IN DWORD    Id,
    IN BOOL     fAuthenticator
)
{
    CPCB *      pCpCb  = GetPointerToCPCB( pPcb, CpIndex );
    LCPCB *     pLcpCb = (LCPCB*)(pPcb->LcpCb.pWorkBuf);

    if ( pCpCb == NULL )
    {
        //
        // If we got a timeout for an authentication CB that is no longer
        // active, we just ignore it.
        //

        return;
    }

    PppLog( 2, 
        "Recv timeout event received for portid=%d,Id=%d,Protocol=%x,fAuth=%d",
         pPcb->dwPortId, Id, CpTable[CpIndex].CpInfo.Protocol, fAuthenticator );

    // 
    // If we are authenticating we use the ConfigRetryCount
    //

    if ( CpIndex == GetCpIndexFromProtocol( fAuthenticator
                                                ? pLcpCb->Local.Work.AP
                                                : pLcpCb->Remote.Work.AP ) )
    {
        if ( pPcb->PppPhase == PPP_AP )
        {
            pCpCb = ( fAuthenticator ) 
                        ? &(pPcb->AuthenticatorCb) 
                        : &(pPcb->AuthenticateeCb);

            //
            // Silently discard timeouts for packets with Id < pPcb->LastId
            //

            if ( Id < pCpCb->LastId )
            {
                return;
            }

            if ( pCpCb->ConfigRetryCount > 0 ) 
            {
                (pCpCb->ConfigRetryCount)--;

                ApWork( pPcb, CpIndex, NULL, NULL, fAuthenticator );
            }
            else
            {
                //
                // If an error has already been set, do not change it.
                //

                if ( pPcb->LcpCb.dwError == NO_ERROR )
                {
                    pPcb->LcpCb.dwError = ERROR_PPP_TIMEOUT;
                }

                NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );
            }
        }

        return;
    } 
    else if ( CpIndex == GetCpIndexFromProtocol( PPP_CBCP_PROTOCOL ) )
    {
        if ( pPcb->PppPhase == PPP_NEGOTIATING_CALLBACK )
        {
            //
            // Silently discard timeouts for packets with Id < pPcb->LastId
            //

            if ( Id < pCpCb->LastId )
            {
                return;
            }

            if ( pCpCb->ConfigRetryCount > 0 ) 
            {
                (pCpCb->ConfigRetryCount)--;

                CbWork( pPcb, CpIndex, NULL, NULL );
            }
            else
            {
                //
                // If an error has already been set, do not change it.
                //

                if ( pPcb->LcpCb.dwError == NO_ERROR )
                {
                    pPcb->LcpCb.dwError = ERROR_PPP_TIMEOUT;
                }

                NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );
            }
        }
    }

    //
    // Silently discard timeouts for packets with Id < pPcb->LastId
    //

    if ( Id < pCpCb->LastId )
    {
        return;
    }

    switch( pCpCb->State ) 
    {

    case FSM_REQ_SENT:
    case FSM_ACK_RCVD:
    case FSM_ACK_SENT:

        if ( pCpCb->ConfigRetryCount > 0 ) 
        {
            (pCpCb->ConfigRetryCount)--;

            //
            // If we have not received any PPP frames from the server yet.
            //

            if ( ( CpIndex == LCP_INDEX ) && 
                 ( pPcb->LcpCb.dwError == ERROR_PPP_NO_RESPONSE ) &&
                 ( !(pPcb->fFlags & PCBFLAG_IS_SERVER) ) )
            {
                NotifyCaller( pPcb, PPPMSG_Progress, NULL );
            }

            // If the RestartTimer value is less then the configured 
            // restart timer value, then bump it up by one second.
            //

            if ( pPcb->RestartTimer < PppConfigInfo.DefRestartTimer )
            {
                (pPcb->RestartTimer)++;
            }

            if ( !FsmSendConfigReq( pPcb, CpIndex, TRUE ) ) 
                return;

            if ( pCpCb->State != FSM_ACK_SENT  )
                pCpCb->State = FSM_REQ_SENT;
        } 
        else 
        {
            PppLog( 1, "Request retry exceeded" );

            //
            // If the LCP layer exceeded its retry count
            //

            if ( pCpCb->dwError == NO_ERROR )
            {
                pCpCb->dwError = ERROR_PPP_TIMEOUT;
            }

            if ( !FsmThisLayerFinished( pPcb, CpIndex, TRUE ) )
                return;

            pCpCb->State = FSM_STOPPED;
        }

        break;

    case FSM_CLOSING:
    case FSM_STOPPING:

        if ( pCpCb->TermRetryCount > 0 ) 
        {
            (pCpCb->TermRetryCount)--;

            FsmSendTermReq( pPcb, CpIndex );
        } 
        else 
        {
            PppLog( 1, "Terminate retry exceeded" );

            if ( pCpCb->dwError == NO_ERROR )
            {
                pCpCb->dwError = ERROR_PPP_TIMEOUT;
            }

            if ( !FsmThisLayerFinished( pPcb, CpIndex, TRUE ) )
                return;

            pCpCb->State = ( pCpCb->State == FSM_CLOSING ) ? FSM_CLOSED 
                                                           : FSM_STOPPED;
        }

        break;

    case FSM_OPENED:
    case FSM_INITIAL:
    case FSM_STARTING:
    case FSM_CLOSED:
    case FSM_STOPPED:
    default:

        PPP_ASSERT( pCpCb->State < 10 );

        PppLog( 2, "Illegal transition->FsmTimeout rcvd while in %s state",
                   FsmStates[pCpCb->State] );
        break;
    }
}

//**
//
// Call:        FsmReceive
//
// Returns:     None
//
// Description: Called when a PPP packet is received. Will process the 
//              incomming packet.
//
VOID
FsmReceive(
    IN PCB *        pPcb,
    IN PPP_PACKET * pPacket,
    IN DWORD        dwPacketLength
)
{
    DWORD        dwProtocol;
    DWORD        CpIndex;
    PPP_CONFIG * pRecvConfig;
    CPCB *       pCpCb;
    DWORD        dwLength;
    LCPCB *      pLcpCb         = (LCPCB*)(pPcb->LcpCb.pWorkBuf);
    
    LogPPPPacket( TRUE, pPcb, pPacket, dwPacketLength );
	
    //
    // Validate length of packet
    //

    if ( dwPacketLength < ( PPP_PACKET_HDR_LEN + PPP_CONFIG_HDR_LEN ) ) 
    {
        PppLog( 1, "Silently discarding badly formed packet" );

        return;
    }

    dwProtocol = WireToHostFormat16( pPacket->Protocol );

    CpIndex = GetCpIndexFromProtocol( dwProtocol );

    switch( pPcb->PppPhase )
    {
    case PPP_NEGOTIATING_CALLBACK:

        //
        // Silently discard any packet other than LCP and Authentication 
        // and callback  packets if we are in the callback phase
        //

        if ( CpIndex == GetCpIndexFromProtocol( PPP_CBCP_PROTOCOL ) ) 
            break;

        //
        // Fallthru
        //

    case PPP_AP:

        //
        // Silently discard any packet other than LCP and Authentication 
        // packets if we are in the authentication phase
        //

        if ( CpIndex == GetCpIndexFromProtocol( pLcpCb->Local.Work.AP ) )
            break;

        if ( CpIndex == GetCpIndexFromProtocol( pLcpCb->Remote.Work.AP ) )
            break;

        //
        // If we are the authenticatee being authenticated by EAP, then if we
        // receive an NCP packet we should assume success. We do this by
        // generating a fake EAP_SUCCESS message and send it to the 
        // authenticatee. 
        //

        if (   ( pLcpCb->Remote.Work.AP == PPP_EAP_PROTOCOL )
            && ( pPcb->PppPhase == PPP_AP ) )
        {
            PPPAP_INPUT  ApInput;

            switch( dwProtocol ) 
            {
            case PPP_CBCP_PROTOCOL:
            case PPP_IPCP_PROTOCOL:
            case PPP_ATCP_PROTOCOL:
            case PPP_IPXCP_PROTOCOL:
            case PPP_NBFCP_PROTOCOL:
            case PPP_CCP_PROTOCOL:
            case PPP_BACP_PROTOCOL:

                PppLog( 1,"Received and NCP or CBCP packet before EAP success");

                ZeroMemory( &ApInput, sizeof( ApInput ) );

                ApInput.fSuccessPacketReceived = TRUE;

                CpIndex = GetCpIndexFromProtocol( PPP_EAP_PROTOCOL );

                if ( pPcb->AuthenticateeCb.LastId != (DWORD)-1 )
                {
                    RemoveFromTimerQ(
                          pPcb->dwPortId,
                          pPcb->AuthenticateeCb.LastId,
                          pLcpCb->Remote.Work.AP,
                          FALSE,
                          TIMER_EVENT_TIMEOUT );
                }

                ApWork( pPcb, CpIndex, NULL, &ApInput, FALSE );

                //
                // PppPhase will now be one of PPP_LCP (if ApWork failed),
                // PPP_NCP, or PPP_NEGOTIATING_CALLBACK. We will not call
                // this function recursively again.
                //
            
                //
                // Now process the NCP we received if we have passed 
                // authentication
                //

                if ( ( pPcb->PppPhase == PPP_NCP ) || 
                     ( pPcb->PppPhase == PPP_NEGOTIATING_CALLBACK ) )
                {
                    FsmReceive( pPcb, pPacket, dwPacketLength );
                }

                return;

            default:
        
                break;
            }
        }
             
        //
        // Fallthru
        //

    case PPP_LCP:

        //
        // Silently discard any packet other than LCP if we are in the
        // LCP or termination or authentication phases
        //

        if ( CpIndex != LCP_INDEX )
        {
            PppLog( 1, "Non-LCP packet received when LCP is not opened");
            PppLog( 1, "Packet being silently discarded" );

            return;
        }

        break;

    case PPP_NCP:

        //
        // We do not recognize this protocol
        //

        if ( CpIndex == (DWORD)-1 )
        {
            if ( dwProtocol == PPP_BAP_PROTOCOL )
            {
                CpIndex = GetCpIndexFromProtocol( PPP_BACP_PROTOCOL );

                if (CpIndex != (DWORD)-1)
                {
                    pCpCb = GetPointerToCPCB( pPcb, CpIndex );

                    if ( pCpCb->State == FSM_OPENED )
                    {
                        BapEventReceive( pPcb->pBcb, pPacket, dwPacketLength );
                        return;
                    }
                }

                BapTrace( "BAP packet silently discarded" );
                return;
            }
            
            //
            // If this is a Control Protocol then we reject it, otherwise we
            // we silently discard it.
            // We used to also check if the protocol is less than 0x0000BFFF,
            // but Shiva has proprietary NBFCP with id 0x0000CFEC and we need
            // to protocol reject it.
            //

            if ( dwProtocol >= 0x00008000 ) 
            {
                FsmSendProtocolRej( pPcb, pPacket, dwPacketLength );
            }
            else
            {
                PppLog( 1, "Network-layer packet rcvd."); 
                PppLog( 1, "Packet being silently discarded" );
            }

            return;
        }

        break;

    default:

        PppLog( 1, "Packet received being silently discarded" );
        return;
    }

    pCpCb = GetPointerToCPCB( pPcb, CpIndex );

    pRecvConfig = (PPP_CONFIG*)(pPacket->Information);

    //
    // We received a PPP packet so the remote host does support it
    //

    if ( pPcb->LcpCb.dwError == ERROR_PPP_NO_RESPONSE )
    {
        pPcb->LcpCb.dwError = NO_ERROR;
    }

    //
    // If we received a packet for a protocol that we have but do not
    // wish to configure then we send a configure reject.
    //

    if ( ( pCpCb == NULL ) || !(pCpCb->fConfigurable) )
    {
        FsmSendProtocolRej( pPcb, pPacket, dwPacketLength );

        return;
    }

    dwLength = WireToHostFormat16( pRecvConfig->Length );

    if ( ( dwLength > ( dwPacketLength - PPP_PACKET_HDR_LEN ) ) || 
         ( dwLength < PPP_CONFIG_HDR_LEN ) )
    {
        PppLog( 1,"Silently discarding badly formed packet" );

        return;
    }

    //
    // Not in ProcessPacket table since parameters to this are different.
    //

    if ( ( CpIndex == LCP_INDEX ) && ( pRecvConfig->Code == PROT_REJ ) )
    {
        ReceiveProtocolRej( pPcb, pPacket );

        return;
    }

    //
    // Make sure that the protocol can handle the config code sent.
    //

    if ( ( pRecvConfig->Code == 0 ) ||
         !( pRecvConfig->Code < CpTable[CpIndex].CpInfo.Recognize )  )
    {
        ReceiveUnknownCode( pPcb, CpIndex, pCpCb, pRecvConfig );

        return;
    }

    //
    // If we received an authentication packet. 
    //

    if ( CpIndex == GetCpIndexFromProtocol( pLcpCb->Local.Work.AP ) )
    {
        if ( ApIsAuthenticatorPacket( CpIndex, pRecvConfig->Code ) )
        {
            if ( pPcb->AuthenticatorCb.LastId != (DWORD)-1 ) 
            {
                //
                // If we have just received a packet we have been waiting for
                // then we stop the outstanding timout for it. We let the
                // APs do the Id matching.
                //

                if ( pRecvConfig->Id == pPcb->AuthenticatorCb.LastId )
                {
                    RemoveFromTimerQ( 
                          pPcb->dwPortId,
                          pPcb->AuthenticatorCb.LastId,
                          pLcpCb->Local.Work.AP,
                          TRUE,
                          TIMER_EVENT_TIMEOUT );
                }
            }

            ApWork( pPcb, CpIndex, pRecvConfig, NULL, TRUE );

            return;
        }
        else if ( CpIndex != GetCpIndexFromProtocol( pLcpCb->Remote.Work.AP ) )
        {
            //
            // Silently drop invalid packet, ie. Authenticatee's packet sent 
            // using Authenticater's protocol
            //

            PppLog( 1,
              "Authentication packet received being silently discarded");

            return;
        }
    }

    if ( CpIndex == GetCpIndexFromProtocol( pLcpCb->Remote.Work.AP ) )
    {
        if ( !ApIsAuthenticatorPacket( CpIndex, pRecvConfig->Code ) )
        {
            if ( pPcb->AuthenticateeCb.LastId != (DWORD)-1 )
            {
                //
                // If we have just received a packet we have been waiting for
                // then we stop the outstanding timout for it. We let the
                // APs do the Id matching.
                //

                if ( pRecvConfig->Id == pPcb->AuthenticateeCb.LastId )
                {
                    RemoveFromTimerQ(
                          pPcb->dwPortId,
                          pPcb->AuthenticateeCb.LastId,
                          pLcpCb->Remote.Work.AP,
                          FALSE,
                          TIMER_EVENT_TIMEOUT );
                }
            }

            ApWork( pPcb, CpIndex, pRecvConfig, NULL, FALSE );
        }
        else
        {
            //
            // Silently drop invalid packet, ie. Authenticator's packet sent 
            // using Authenticatee's protocol
            //

            PppLog( 1, 
                    "Authentication packet received being silently discarded");
        }

        return;
    }

    if ( CpIndex == GetCpIndexFromProtocol( PPP_CBCP_PROTOCOL ) ) 
    {
        if ( pCpCb->LastId != (DWORD)-1 )
        {
            //
            // If we have just received a packet we have been waiting for
            // then we stop the outstanding timout for it. We let the
            // CBCP do the Id matching.
            //

            if ( pRecvConfig->Id == pCpCb->LastId )
            {
                RemoveFromTimerQ( 
                          pPcb->dwPortId,
                          pCpCb->LastId, 
                          PPP_CBCP_PROTOCOL,
                          FALSE,
                          TIMER_EVENT_TIMEOUT );
            }
        }
        
        CbWork( pPcb, CpIndex, pRecvConfig, NULL );

    }
    else
    {
        //
        // Any combination of packets allowed here.
        //
		//if this is any packet and not Echo request packet,
		//and if the flag is set then reset the flag.
		if ( pRecvConfig->Code != ECHO_REPLY )
		{
			if ( pPcb->fEchoRequestSend ) pPcb->fEchoRequestSend = 0;
		}
        (*ProcessPacket[pRecvConfig->Code])(pPcb, CpIndex, pCpCb, pRecvConfig);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\engine\receive.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    receive.c
//
// Description: This module contains code to handle all packets received.
//
// History:
//      Oct 25,1993.    NarenG          Created Original version.
//
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>     // needed for winbase.h

#include <windows.h>    // Win32 base API's
#include <stdlib.h>
#include <string.h>
#include <wchar.h>

#include <lmcons.h>
#include <raserror.h>
#include <mprerror.h>
#include <mprlog.h>
#include <rasman.h>
#include <rtutils.h>
#include <rasppp.h>
#include <pppcp.h>
#include <ppp.h>
#include <smaction.h>
#include <smevents.h>
#include <receive.h>
#include <auth.h>
#include <lcp.h>
#include <timer.h>
#include <util.h>
#include <worker.h>
#define INCL_RASAUTHATTRIBUTES
#include <ppputil.h>

//**
//
// Call:        ReceiveConfigReq
//
// Returns:     None.
//
// Description: Handles an incomming CONFIG_REQ packet and related state
//              transitions.
//
VOID
ReceiveConfigReq( 
    IN PCB *        pPcb, 
    IN DWORD        CpIndex,
    IN CPCB *       pCpCb,
    IN PPP_CONFIG * pRecvConfig
)
{

    PPP_CONFIG * pSendConfig = (PPP_CONFIG*)(pPcb->pSendBuf->Information);
    BOOL         fAcked;

    switch( pCpCb->State ) 
    {

    case FSM_OPENED:            

        if ( !FsmThisLayerDown( pPcb, CpIndex ) )
            return;

        if ( !FsmSendConfigReq( pPcb, CpIndex, FALSE ) )
            return;

        if( !FsmSendConfigResult( pPcb, CpIndex, pRecvConfig, &fAcked ) )
            return;

        pCpCb->State = ( fAcked ) ? FSM_ACK_SENT : FSM_REQ_SENT;

        break;

    case FSM_STOPPED:

        InitRestartCounters( pPcb, pCpCb );

        if ( !FsmSendConfigReq( pPcb, CpIndex, FALSE ) ) 
            return;

        //
        // Fallthru 
        //

    case FSM_REQ_SENT:
    case FSM_ACK_SENT:          

        if ( !FsmSendConfigResult( pPcb, CpIndex, pRecvConfig, &fAcked ) )
            return;

        pCpCb->State = ( fAcked ) ? FSM_ACK_SENT : FSM_REQ_SENT;

        break;

    case FSM_ACK_RCVD:

        if ( !FsmSendConfigResult( pPcb, CpIndex, pRecvConfig, &fAcked ) )
            return;

        if( fAcked )
        {
            pCpCb->State = FSM_OPENED;

            FsmThisLayerUp( pPcb, CpIndex );
        }

        break;


    case FSM_CLOSED:

        FsmSendTermAck( pPcb, CpIndex, pRecvConfig );

        break;

    case FSM_CLOSING:
    case FSM_STOPPING:

        break;

    case FSM_STARTING:
    case FSM_INITIAL:
    default:

        PPP_ASSERT( pCpCb->State < 10 );

        PppLog(2,"Illegal transition->ConfigReq received while in %s state",
                   FsmStates[pCpCb->State] );
        break;
    }

}


//**
//
// Call:        ReceiveConfigAck
//
// Returns:     none.
//
// Description: Handles an incomming CONFIG_ACK packet and related state
//              transitions.
//
VOID
ReceiveConfigAck( 
    IN PCB *        pPcb, 
    IN DWORD        CpIndex,
    IN CPCB *       pCpCb,
    IN PPP_CONFIG * pRecvConfig
)
{
    //
    // The Id of the Ack HAS to match the Id of the last request sent
    // If it is different, then we should silently discard it.
    //

    if ( pRecvConfig->Id != pCpCb->LastId )
    {
        PppLog(1,
               "Config Ack rcvd. on port %d silently discarded. Invalid Id",
               pPcb->hPort );
        return;
    }

    switch( pCpCb->State )      
    {

    case FSM_REQ_SENT:

        if ( !FsmConfigResultReceived( pPcb, CpIndex, pRecvConfig ) )
            return;

        RemoveFromTimerQ( pPcb->dwPortId,
                          pRecvConfig->Id, 
                          CpTable[CpIndex].CpInfo.Protocol,
                          FALSE,
                          TIMER_EVENT_TIMEOUT );

        InitRestartCounters( pPcb, pCpCb );

        pCpCb->State = FSM_ACK_RCVD;

        break;

    case FSM_ACK_SENT:

        if ( !FsmConfigResultReceived( pPcb, CpIndex, pRecvConfig ) )
            return;

        RemoveFromTimerQ( pPcb->dwPortId, 
                          pRecvConfig->Id, 
                          CpTable[CpIndex].CpInfo.Protocol,
                          FALSE,
                          TIMER_EVENT_TIMEOUT );
        
        InitRestartCounters( pPcb, pCpCb );

        pCpCb->State = FSM_OPENED;

        FsmThisLayerUp( pPcb, CpIndex );

        break;

    case FSM_OPENED:            

        RemoveFromTimerQ( pPcb->dwPortId, 
                          pRecvConfig->Id, 
                          CpTable[CpIndex].CpInfo.Protocol,
                          FALSE,
                          TIMER_EVENT_TIMEOUT );

        if ( !FsmThisLayerDown( pPcb, CpIndex ) )
            return;

        //
        // Fallthru
        //

    case FSM_ACK_RCVD:  

        if ( !FsmSendConfigReq( pPcb, CpIndex, FALSE ) ) 
            return;

        pCpCb->State = FSM_REQ_SENT;
        
        break;

    case FSM_CLOSED:
    case FSM_STOPPED:

        RemoveFromTimerQ( pPcb->dwPortId, 
                          pRecvConfig->Id, 
                          CpTable[CpIndex].CpInfo.Protocol,
                          FALSE,
                          TIMER_EVENT_TIMEOUT );

        //
        // Out of Sync; kill the remote 
        //

        FsmSendTermAck( pPcb, CpIndex, pRecvConfig );

        break;

    case FSM_CLOSING:
    case FSM_STOPPING:

        //
        // We are attempting to close connection
        // wait for timeout to resend a Terminate Request 
        //

        break;

    case FSM_STARTING:
    case FSM_INITIAL:
    default:

        RemoveFromTimerQ( pPcb->dwPortId, 
                          pRecvConfig->Id, 
                          CpTable[CpIndex].CpInfo.Protocol,
                          FALSE,
                          TIMER_EVENT_TIMEOUT );

        PPP_ASSERT( pCpCb->State < 10 );

        PppLog(2,"Illegal transition->ConfigAck received while in %s state",
                  FsmStates[pCpCb->State] );
        break;
    }

}


//**
//
// Call:        ReceiveConfigNakRej
//
// Returns:     none.
//
// Description: Handles an incomming CONFIG_NAK or CONFIF_REJ packet and 
//              related state transitions.
//
VOID
ReceiveConfigNakRej( 
    IN PCB *        pPcb, 
    IN DWORD        CpIndex,
    IN CPCB *       pCpCb,
    IN PPP_CONFIG * pRecvConfig
)
{
    //
    // The Id of the Nak/Rej HAS to match the Id of the last request sent
    // If it is different, then we should silently discard it.
    //

    if ( pRecvConfig->Id != pCpCb->LastId )
    {
        PppLog(1,"Config Nak/Rej on port %d silently discarded. Invalid Id",
                pPcb->hPort );
        return;
    }

    switch( pCpCb->State ) 
    {

    case FSM_REQ_SENT:
    case FSM_ACK_SENT:

        if ( !FsmConfigResultReceived( pPcb, CpIndex, pRecvConfig ) )
            return;

        RemoveFromTimerQ( pPcb->dwPortId, 
                          pRecvConfig->Id, 
                          CpTable[CpIndex].CpInfo.Protocol,
                          FALSE,
                          TIMER_EVENT_TIMEOUT );

        InitRestartCounters( pPcb, pCpCb );

        if ( !FsmSendConfigReq( pPcb, CpIndex, FALSE ) )
            return;

        break;

    case FSM_OPENED:            

        RemoveFromTimerQ( pPcb->dwPortId, 
                          pRecvConfig->Id, 
                          CpTable[CpIndex].CpInfo.Protocol,
                          FALSE,
                          TIMER_EVENT_TIMEOUT );

        if ( !FsmThisLayerDown( pPcb, CpIndex ) )
            return;

        //
        // Fallthru
        //

    case FSM_ACK_RCVD:          

        if ( !FsmSendConfigReq( pPcb, CpIndex, FALSE ) )
            return;

        pCpCb->State = FSM_REQ_SENT;
        
        break;

    case FSM_CLOSED:
    case FSM_STOPPED:

        RemoveFromTimerQ( pPcb->dwPortId, 
                          pRecvConfig->Id, 
                          CpTable[CpIndex].CpInfo.Protocol,
                          FALSE,
                          TIMER_EVENT_TIMEOUT );
        //
        // Out of Sync; kill the remote 
        //

        FsmSendTermAck( pPcb, CpIndex, pRecvConfig );

        break;

    case FSM_CLOSING:
    case FSM_STOPPING:

        //
        // We are attempting to close connection
        // wait for timeout to resend a Terminate Request 
        //

        break;

    case FSM_STARTING:
    case FSM_INITIAL:
    default:

        RemoveFromTimerQ( pPcb->dwPortId, 
                          pRecvConfig->Id, 
                          CpTable[CpIndex].CpInfo.Protocol,
                          FALSE,
                          TIMER_EVENT_TIMEOUT );

        PPP_ASSERT( pCpCb->State < 10 );

        PppLog(2,"Illegal transition->CfgNakRej received while in %s state",
                 FsmStates[pCpCb->State] );
        break;
    }

}


//**
//
// Call:        ReceiveTermReq
//
// Returns:     none
//
// Description: Handles an incomming TERM_REQ packet and 
//              related state transitions.
//
VOID
ReceiveTermReq( 
    IN PCB *        pPcb, 
    IN DWORD        CpIndex,
    IN CPCB *       pCpCb,
    IN PPP_CONFIG * pConfig
)
{
    //
    // We are shutting down so do not resend any outstanding request.
    //

    RemoveFromTimerQ( pPcb->dwPortId, 
                      pCpCb->LastId,
                      CpTable[CpIndex].CpInfo.Protocol,
                      FALSE,
                      TIMER_EVENT_TIMEOUT );

    if ( CpIndex == LCP_INDEX )
    {
        //
        // If we are receiving a terminate request, remove any hangup event
        // that we may have put into the timer queue if there was a previous
        // LCP TermReq sent.

        RemoveFromTimerQ( pPcb->dwPortId, 
                          0, 
                          0, 
                          FALSE,
                          TIMER_EVENT_HANGUP );
    }

    switch( pCpCb->State ) 
    {

    case FSM_OPENED:

        if ( !FsmThisLayerDown( pPcb, CpIndex ) )
            return;

        //
        // Zero restart counters
        //

        pCpCb->ConfigRetryCount = 0;
        pCpCb->TermRetryCount   = 0;
        pCpCb->NakRetryCount    = 0;
        pCpCb->RejRetryCount    = 0;

        FsmSendTermAck( pPcb, CpIndex, pConfig );

        pCpCb->State = FSM_STOPPING;

        break;

    case FSM_ACK_RCVD:
    case FSM_ACK_SENT:
    case FSM_REQ_SENT:

        FsmSendTermAck( pPcb, CpIndex, pConfig );

        pCpCb->State = FSM_REQ_SENT;

        break;

    case FSM_CLOSED:
    case FSM_CLOSING:
    case FSM_STOPPED:
    case FSM_STOPPING:

        FsmSendTermAck( pPcb, CpIndex, pConfig );

        break;

    case FSM_STARTING:
    case FSM_INITIAL:
    default:

        PPP_ASSERT( pCpCb->State < 10 );

        PppLog(2,"Illegal transition->CfgNakRej received while in %s state",
                 FsmStates[pCpCb->State] );
        break;
    }

    if ( CpIndex == LCP_INDEX )
    {
        pPcb->fFlags |= PCBFLAG_RECVD_TERM_REQ;

        //
        // If we got a terminate request from the remote peer.
        //

        if ( pPcb->fFlags & PCBFLAG_DOING_CALLBACK ) {

            //
            // If we are the server side we need to tell the server
            // to callback.
            //
            if ( pPcb->fFlags & PCBFLAG_IS_SERVER ) {
                PPPDDM_CALLBACK_REQUEST PppDdmCallbackRequest;

                PppDdmCallbackRequest.fUseCallbackDelay = TRUE;
                PppDdmCallbackRequest.dwCallbackDelay =
                                            pPcb->ConfigInfo.dwCallbackDelay;

                strcpy( PppDdmCallbackRequest.szCallbackNumber,
                        pPcb->szCallbackNumber );

                PppLog( 2, "Notifying server to callback at %s, delay = %d",
                           PppDdmCallbackRequest.szCallbackNumber,
                           PppDdmCallbackRequest.dwCallbackDelay  );

                NotifyCaller( pPcb, 
                              PPPDDMMSG_CallbackRequest, 
                              &PppDdmCallbackRequest );
            }

            //
            // If we are the client?
            //
        }
        else
        {
            //
            // Check to see if the remote peer sent a Terminate Request reason
            //

            DWORD   dwLength  = WireToHostFormat16( pConfig->Length );
            LCPCB * pLcpCb    = (LCPCB*)(pPcb->LcpCb.pWorkBuf);
            DWORD   dwRetCode = ERROR_PPP_LCP_TERMINATED;
                
            if ( dwLength == PPP_CONFIG_HDR_LEN + 12 )
            {
                //
                // Check to see if this is our signature
                //

                if ( ( WireToHostFormat32( pConfig->Data ) == 
                                              pLcpCb->Remote.Work.MagicNumber )
                     &&
                     ( WireToHostFormat32( pConfig->Data + 4 ) == 3984756 ) )
                {
                    dwRetCode = WireToHostFormat32( pConfig->Data + 8 );

                    //
                    // Should not be larger than the highest winerror.h
                    //
                
                    if ( dwRetCode > ERROR_DHCP_ADDRESS_CONFLICT )
                    {
                        //
                        // Ignore this error
                        //

                        dwRetCode = ERROR_PPP_LCP_TERMINATED;
                    }

                    if ( dwRetCode == ERROR_NO_LOCAL_ENCRYPTION )
                    {
                        dwRetCode = ERROR_NO_REMOTE_ENCRYPTION;
                    }
                    else if ( dwRetCode == ERROR_NO_REMOTE_ENCRYPTION )
                    {
                        dwRetCode = ERROR_NO_LOCAL_ENCRYPTION;
                    }
                }
            }

            if ( pCpCb->dwError == NO_ERROR )
            {
                pCpCb->dwError = dwRetCode;
            }

            if ( !( pPcb->fFlags & PCBFLAG_IS_SERVER ) )
            {
                NotifyCallerOfFailure( pPcb, pCpCb->dwError );

                //
                // If we are a client check to see if the server disconnected us
                // because of autodisconnect.
                //
 
                if ( ( dwRetCode == ERROR_IDLE_DISCONNECTED ) ||
                     ( dwRetCode == ERROR_PPP_SESSION_TIMEOUT ) )
                {
                    CHAR * pszPortName = pPcb->szPortName;

                    PppLogInformation( 
                                ( dwRetCode == ERROR_IDLE_DISCONNECTED )
                                    ? ROUTERLOG_CLIENT_AUTODISCONNECT
                                    : ROUTERLOG_PPP_SESSION_TIMEOUT,
                                1,
                                &pszPortName );
                }
            }

            //
            // If the remote LCP is terminating we MUST wait at least one 
            // restart timer time period before we hangup.
            //

            InsertInTimerQ( pPcb->dwPortId,
                            pPcb->hPort,    
                            0, 
                            0, 
                            FALSE,
                            TIMER_EVENT_HANGUP, 
                            pPcb->RestartTimer );
        }
    }
    else
    {
        if ( pCpCb->dwError == NO_ERROR )
        {
            pCpCb->dwError = ERROR_PPP_NCP_TERMINATED;
        }

        FsmThisLayerFinished( pPcb, CpIndex, FALSE );
    }
}



//**
//
// Call:        ReceiveTermAck
//
// Returns:     none
//
// Description: Handles an incomming TERM_ACK packet and 
//              related state transitions.
//
VOID
ReceiveTermAck( 
    IN PCB *        pPcb, 
    IN DWORD        CpIndex,
    IN CPCB *       pCpCb,
    IN PPP_CONFIG * pRecvConfig
)
{
    //
    // The Id of the Term Ack HAS to match the Id of the last request sent
    // If it is different, then we should silently discard it.
    //

    if ( pRecvConfig->Id != pCpCb->LastId )
    {
        PppLog(1,"Term Ack with on port %d silently discarded. Invalid Id",
                pPcb->hPort );
        return;
    }

    switch( pCpCb->State ) 
    {

    case FSM_OPENED:

        if ( !FsmThisLayerDown( pPcb, CpIndex ) )
            return;

        if ( !FsmSendConfigReq( pPcb, CpIndex, FALSE ) )
            return;

        pCpCb->State = FSM_REQ_SENT;

        break;

    case FSM_ACK_RCVD:

        pCpCb->State = FSM_REQ_SENT;

        break;

    case FSM_CLOSING:
    case FSM_STOPPING:

        //
        // Remove the timeout for this Id from the timer Q
        //

        RemoveFromTimerQ( pPcb->dwPortId, 
                          pRecvConfig->Id,
                          CpTable[CpIndex].CpInfo.Protocol,
                          FALSE,
                          TIMER_EVENT_TIMEOUT );

        if ( !FsmThisLayerFinished( pPcb, CpIndex, TRUE ) )
            return;

        pCpCb->State = ( pCpCb->State == FSM_CLOSING ) ? FSM_CLOSED 
                                                       : FSM_STOPPED; 

        break;

    case FSM_REQ_SENT:
    case FSM_ACK_SENT:
    case FSM_CLOSED:
    case FSM_STOPPED:

        break;

    case FSM_STARTING:
    case FSM_INITIAL:
    default:

        PPP_ASSERT( pCpCb->State < 10 );

        PppLog( 2,"Illegal transition->CfgNakRej received while in %s state",
                   FsmStates[pCpCb->State] );
        break;
    }
}


//**
//
// Call:        ReceiveUnknownCode
//
// Returns:     none.
//
// Description: Handles a packet with an unknown/unrecognizable code and 
//              related state transitions.
//
VOID
ReceiveUnknownCode( 
    IN PCB *        pPcb, 
    IN DWORD        CpIndex,
    IN CPCB *       pCpCb,
    IN PPP_CONFIG * pConfig
)
{
    PppLog( 2, "Received packet with unknown code %d", pConfig->Code );

    switch( pCpCb->State ) 
    {

    case FSM_STOPPED:
    case FSM_STOPPING:
    case FSM_OPENED:
    case FSM_ACK_SENT:
    case FSM_ACK_RCVD:
    case FSM_REQ_SENT:
    case FSM_CLOSING:
    case FSM_CLOSED:

        FsmSendCodeReject( pPcb, CpIndex, pConfig );

        break;

    case FSM_STARTING:
    case FSM_INITIAL:
    default:

        PPP_ASSERT( pCpCb->State < 10 );

        PppLog( 2, "Illegal transition->UnknownCode rcvd while in %s state",
                   FsmStates[pCpCb->State] );
        break;
    }
}

//**
//
// Call:        ReceiveDiscardReq
//
// Returns:     none
//
// Description: Handles an incomming DISCARD_REQ packet and 
//              related state transitions.
//
VOID
ReceiveDiscardReq( 
    IN PCB *        pPcb, 
    IN DWORD        CpIndex,
    IN CPCB *       pCpCb,
    IN PPP_CONFIG * pConfig
)
{
    //
    // Simply discard the packet.
    //

    PppLog( 2, "Illegal transition->Discard rqst rcvd while in %s state",
                   FsmStates[pCpCb->State] );
}

//**
//
// Call:        ReceiveEchoReq
//
// Returns:     none
//
// Description: Handles an incomming ECHO_REQ packet and 
//              related state transitions.
//
VOID
ReceiveEchoReq( 
    IN PCB *        pPcb, 
    IN DWORD        CpIndex,
    IN CPCB *       pCpCb,
    IN PPP_CONFIG * pConfig
)
{
    //
    // Silently discard this packet if LCP is not in an opened state
    //
   
    if ( !IsLcpOpened( pPcb ) )
        return;

    switch( pCpCb->State ) 
    {

    case FSM_STOPPED:
    case FSM_STOPPING:
    case FSM_ACK_SENT:
    case FSM_ACK_RCVD:
    case FSM_REQ_SENT:
    case FSM_CLOSING:
    case FSM_CLOSED:
    case FSM_STARTING:
    case FSM_INITIAL:

        break;

    case FSM_OPENED:

        FsmSendEchoReply( pPcb, CpIndex, pConfig );

        break;

    default:

        PPP_ASSERT( pCpCb->State < 10 );

        PppLog( 2, "Illegal transition->UnknownCode rcvd while in %s state",
                   FsmStates[pCpCb->State] );
        break;
    }
}


//**
//
// Call:        ReceiveEchoReply
//
// Returns:     none
//
// Description: Handles an incomming ECHO_REPLY packet and 
//              related state transitions. The only Echo request we send
//              is to calculate the link speed, so we assume that we get called
//              only when we receive the reply.
//
VOID
ReceiveEchoReply( 
    IN PCB *        pPcb, 
    IN DWORD        CpIndex,
    IN CPCB *       pCpCb,
    IN PPP_CONFIG * pConfig
)
{
	LCPCB *      pLcpCb      = (LCPCB*)(pPcb->LcpCb.pWorkBuf);
	DWORD        dwLength    =  PPP_PACKET_HDR_LEN +
                            WireToHostFormat16( pConfig->Length );

    if ( dwLength > LCP_DEFAULT_MRU )
    { 
        dwLength = LCP_DEFAULT_MRU;
    }

    if ( dwLength < PPP_PACKET_HDR_LEN + PPP_CONFIG_HDR_LEN + 4 )
    {
        PppLog( 1, "Silently discarding invalid echo response packet on port=%d",
                    pPcb->hPort );

        return;
    }
	

    //
    // Pass on the echo reply to whoever send the echo request.
    //

	
	if ( !(pPcb->fFlags & PCBFLAG_IS_SERVER) && ( RAS_DEVICE_TYPE(pPcb->dwDeviceType) == RDT_PPPoE) && pPcb->dwIdleBeforeEcho )
	{
		if ( pPcb->fEchoRequestSend )
		{
			//check to see if we are getting the same text back on the echo
			if ( !memcmp( pConfig->Data+ 4, PPP_DEF_ECHO_TEXT, strlen(PPP_DEF_ECHO_TEXT)) )
			{
				//got the echo response for our echo request
				//so reset the flag.
				pPcb->fEchoRequestSend = 0;
				pPcb->dwNumEchoResponseMissed = 0;
			}
		}
	}
}


//**
//
// Call:        ReceiveCodeRej
//
// Returns:     none
//
// Description: Handles an incomming CODE_REJ packet and 
//              related state transitions.
//
VOID
ReceiveCodeRej( 
    IN PCB *        pPcb, 
    IN DWORD        CpIndex,
    IN CPCB *       pCpCb,
    IN PPP_CONFIG * pConfig
)
{
    pConfig = (PPP_CONFIG*)(pConfig->Data);

    PppLog( 2, "PPP Code Reject rcvd, rejected Code = %d", pConfig->Code );

    //
    // First check to see if these codes may be rejected without 
    // affecting implementation. Permitted code rejects
    //

    if ( CpIndex == LCP_INDEX )
    {
        switch( pConfig->Code )
        {

        case CONFIG_REQ:
        case CONFIG_ACK:
        case CONFIG_NAK:
        case CONFIG_REJ:
        case TERM_REQ:
        case TERM_ACK:
        case CODE_REJ:
        case PROT_REJ:
        case ECHO_REQ:
        case ECHO_REPLY:
        case DISCARD_REQ:

            //
            // Unpermitted code rejects.
            // 

            break;

        case IDENTIFICATION:
        case TIME_REMAINING:

            //
            // Turn these off.
            //

            pPcb->ConfigInfo.dwConfigMask &= (~PPPCFG_UseLcpExtensions);

            //
            // no break here no purpose.
            // 

        default:

            //
            // Permitted code rejects, we can still work.
            //

            switch ( pCpCb->State  )
            {

            case FSM_ACK_RCVD:

                pCpCb->State = FSM_REQ_SENT;
                break;

            default:

                break;
            }

            return;
        }
    }

    //
    // Log this error
    //

    //PPPLogEvent( PPP_EVENT_RECV_UNKNOWN_CODE, pConfig->Code );

    PppLog( 1, "Unpermitted code reject rcvd. on port %d", pPcb->hPort );

    //
    // Actually the remote side did not reject the protocol, it rejected
    // the code. But for all practical purposes we cannot talk with
    // the corresponding CP on the remote side. This is actually an
    // implementation error in the remote side.
    //

    pCpCb->dwError = ERROR_PPP_NOT_CONVERGING;

    RemoveFromTimerQ( pPcb->dwPortId, 
                      pCpCb->LastId,
                      CpTable[CpIndex].CpInfo.Protocol,
                      FALSE,
                      TIMER_EVENT_TIMEOUT );

    switch ( pCpCb->State  )
    {

    case FSM_CLOSING:
        
        if ( !FsmThisLayerFinished( pPcb, CpIndex, TRUE ) )
            return;

        pCpCb->State = FSM_CLOSED;

        break;

    case FSM_REQ_SENT:
    case FSM_ACK_RCVD:
    case FSM_ACK_SENT:
    case FSM_STOPPING:

        if ( !FsmThisLayerFinished( pPcb, CpIndex, TRUE ) )
            return;

        pCpCb->State = FSM_STOPPED;

        break;

    case FSM_OPENED:

        if ( !FsmThisLayerDown( pPcb, CpIndex ) )
            return;

        InitRestartCounters( pPcb, pCpCb );

        FsmSendTermReq( pPcb, CpIndex );

        pCpCb->State = FSM_STOPPING;

        break;

    case FSM_CLOSED:
    case FSM_STOPPED:
        
        break;

    case FSM_STARTING:
    case FSM_INITIAL:
    default:

        PPP_ASSERT( pCpCb->State < 10 );

        PppLog( 2, "Illegal transition->UnknownCode rcvd while in %s state",
                   FsmStates[pCpCb->State] );
        break;
    }

}

//**
//
// Call:        ReceiveProtocolRej
//
// Returns:     none
//
// Description: Handles an incomming PROT_REJ packet and 
//              related state transitions.
//
VOID
ReceiveProtocolRej( 
    IN PCB *        pPcb, 
    IN PPP_PACKET * pPacket
)
{
    PPP_CONFIG * pRecvConfig = (PPP_CONFIG *)(pPacket->Information);
    DWORD        dwProtocol  = WireToHostFormat16( pRecvConfig->Data );
    CPCB *       pCpCb;
    DWORD        CpIndex;

    PppLog( 2, "PPP Protocol Reject, Protocol = %x", dwProtocol );

    CpIndex = GetCpIndexFromProtocol( dwProtocol );

    if ( CpIndex == (DWORD)-1 )
    {
        return;
    }

    //
    // "Protocol Reject" in the middle of LCP (RXJ- in state 2-9) should cause 
    // immediate termination.
    //

    if ( LCP_INDEX == CpIndex )
    {
        pPcb->LcpCb.dwError = ERROR_PPP_NOT_CONVERGING;

        NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );

        return;
    }

    // 
    // If LCP is not in the opened state we silently discard this packet 
    //
   
    if ( !IsLcpOpened( pPcb ) )
    {
        PppLog(1,"Protocol Rej silently discarded on port %d. Lcp not open",
                 pPcb->hPort );
        return;
    }

    //
    // If remote peer rejected an Authentication protocol, then bring down
    // the link (LCP) since this should never happen.
    //

    if ( IsCpIndexOfAp( CpIndex ) )
    {
        CpIndex = LCP_INDEX;

        pCpCb = GetPointerToCPCB( pPcb, LCP_INDEX );

        pCpCb->dwError = ERROR_AUTH_PROTOCOL_REJECTED;
    }
    else
    {
        pCpCb = GetPointerToCPCB( pPcb, CpIndex );

        pCpCb->dwError = ERROR_PPP_CP_REJECTED;
    }

    RemoveFromTimerQ( pPcb->dwPortId, 
                      pCpCb->LastId,
                      CpTable[CpIndex].CpInfo.Protocol,
                      FALSE,
                      TIMER_EVENT_TIMEOUT );

    switch ( pCpCb->State  )
    {
    case FSM_CLOSING:
        
        if ( !FsmThisLayerFinished( pPcb, CpIndex, TRUE ) )
            return;

        pCpCb->State = FSM_CLOSED;

        break;

    case FSM_REQ_SENT:
    case FSM_ACK_RCVD:
    case FSM_ACK_SENT:
    case FSM_STOPPING:

        if ( !FsmThisLayerFinished( pPcb, CpIndex, TRUE ) )
            return;

        pCpCb->State = FSM_STOPPED;

        break;

    case FSM_OPENED:

        if ( !FsmThisLayerDown( pPcb, CpIndex ) )
            return;

        InitRestartCounters( pPcb, pCpCb );

        FsmSendTermReq( pPcb, CpIndex );

        pCpCb->State = FSM_STOPPING;

        break;

    case FSM_CLOSED:
    case FSM_STOPPED:
        
        break;

    case FSM_STARTING:
    case FSM_INITIAL:
    default:

        PPP_ASSERT( pCpCb->State < 10 );

        PppLog( 2, "Illegal transition->UnknownCode rcvd while in %s state",
                   FsmStates[pCpCb->State] );
        break;
    }
}

//**
//
// Call:        NbfCpCompletionRoutine
//
// Returns:     none
//
// Description: Called by a NBFCP when it has finished preparing a respose to
//              the client's add name request.
//
VOID 
NbfCpCompletionRoutine(  
    IN PCB *        pPcb,
    IN DWORD        CpIndex,
    IN CPCB *       pCpCb,
    IN PPP_CONFIG * pSendConfig
)
{
    BOOL    fAcked   = FALSE;
    DWORD   dwLength;
    DWORD   dwRetCode;

    switch( pSendConfig->Code )
    {

    case CONFIG_ACK:

        fAcked = TRUE;

        break;

    case CONFIG_NAK:

        if ( pCpCb->NakRetryCount > 0 )
        {
            (pCpCb->NakRetryCount)--;
        }
        else
        {
            pCpCb->dwError = ERROR_PPP_NOT_CONVERGING;

            NotifyCallerOfFailure( pPcb, pCpCb->dwError  );

            return;
        }

        break;

    case CONFIG_REJ:

        if ( pCpCb->RejRetryCount > 0 )
        {
            (pCpCb->RejRetryCount)--;
        }
        else
        {
            pCpCb->dwError = ERROR_PPP_NOT_CONVERGING;

            FsmClose( pPcb, CpIndex );

            return;
        }

        break;

    default:

        break;
    }

    HostToWireFormat16( (WORD)CpTable[CpIndex].CpInfo.Protocol,
                        (PBYTE)(pPcb->pSendBuf->Protocol) );

    dwLength = WireToHostFormat16( pSendConfig->Length );

    if ( ( dwLength + PPP_PACKET_HDR_LEN ) > LCP_DEFAULT_MRU )
    {
        pCpCb->dwError = ERROR_PPP_INVALID_PACKET;

        FsmClose( pPcb, CpIndex );

        return;
    }
    else
    {
        CopyMemory( pPcb->pSendBuf->Information, pSendConfig, dwLength );
    }

    LogPPPPacket(FALSE,pPcb,pPcb->pSendBuf,dwLength+PPP_PACKET_HDR_LEN);

    if ( ( dwRetCode =  PortSendOrDisconnect( pPcb,
                                    (dwLength + PPP_PACKET_HDR_LEN)))
                                        != NO_ERROR )
    {
        return;
    }

    switch ( pCpCb->State  )
    {

    case FSM_ACK_RCVD:

        if ( fAcked )
        {
            pCpCb->State = FSM_OPENED;

            FsmThisLayerUp( pPcb, CpIndex );
        }

        break;

    case FSM_OPENED:
    case FSM_ACK_SENT:
    case FSM_REQ_SENT:
    case FSM_STOPPED:

        pCpCb->State = fAcked ? FSM_ACK_SENT : FSM_REQ_SENT;
        
        break;

    case FSM_CLOSING:
    case FSM_STOPPING:

        //
        // no transition
        //

        break;

    case FSM_CLOSED:
    case FSM_STARTING:
    case FSM_INITIAL:
    default:

        PPP_ASSERT( pCpCb->State < 10 );

        PppLog( 2, "Illegal transition->ConfigReq rcvd while in %s state",
                   FsmStates[pCpCb->State] );

        break;
    }
}

//**
//
// Call:        CompletionRoutine
//
// Returns:     none
//
// Description: Called by a CP when it has completed an asynchronous operation.
//
VOID 
CompletionRoutine(  
    IN HCONN            hPortOrConnection,
    IN DWORD            Protocol,
    IN PPP_CONFIG *     pSendConfig,
    IN DWORD            dwError 
)
{
    DWORD  dwRetCode;
    CPCB * pCpCb;
    PCB *  pPcb;
    HPORT  hPort;
    DWORD  CpIndex = GetCpIndexFromProtocol( Protocol );

    if ( CpIndex == (DWORD)-1 )
    {
        return;
    }

    PppLog( 2, "CompletionRoutine called for protocol %x", 
                CpTable[CpIndex].CpInfo.Protocol );

    dwRetCode = RasBundleGetPort( NULL, (HCONN)hPortOrConnection, &hPort );

    if ( dwRetCode != NO_ERROR )
    {
        return;
    }

    pPcb = GetPCBPointerFromhPort( hPort );

    if ( pPcb == (PCB *)NULL )
    {
        return;
    }

    pCpCb = GetPointerToCPCB( pPcb, CpIndex );

    if ( pCpCb == NULL )
    {
        return;
    }

    if ( dwError != NO_ERROR )
    {
        pCpCb->dwError = dwError;

        PppLog( 1,
                "The control protocol for %x on port %d, returned error %d",
                CpTable[CpIndex].CpInfo.Protocol, hPort, dwError );

        FsmClose( pPcb, CpIndex );

        return;
    }
        
    switch( Protocol )
    {
    case PPP_NBFCP_PROTOCOL:
        
        NbfCpCompletionRoutine( pPcb, CpIndex, pCpCb, pSendConfig );

        break;

    case PPP_IPXCP_PROTOCOL:

        //      
        // If IPXCP is still in the OPENED state then call ThisLayerUp
        // otherwise ignore this call.
        //

        if ( pCpCb->State == FSM_OPENED )
        {
            FsmThisLayerUp( pPcb, CpIndex );
        }

        break;

    default:
        
        RTASSERT( FALSE );
        break;
    }

    return;
}

//**
//
// Call:        FsmConfigResultReceived
//
// Returns:     TRUE  - Success
//              FALSE - Otherwise 
//
// Description: This call will process a Config result ie Ack/Nak/Rej.
//
BOOL
FsmConfigResultReceived( 
    IN PCB *        pPcb, 
    IN DWORD        CpIndex,
    IN PPP_CONFIG * pRecvConfig 
)
{
    DWORD dwRetCode; 
    CPCB * pCpCb = GetPointerToCPCB( pPcb, CpIndex );

    if ( pCpCb == NULL )
    {
        return( FALSE );
    }

    switch( pRecvConfig->Code )
    {

    case CONFIG_NAK:

        dwRetCode = (CpTable[CpIndex].CpInfo.RasCpConfigNakReceived)(
                            pCpCb->pWorkBuf, pRecvConfig );
        break;

    case CONFIG_ACK:

        dwRetCode = (CpTable[CpIndex].CpInfo.RasCpConfigAckReceived)(
                            pCpCb->pWorkBuf, pRecvConfig );
        break;

    case CONFIG_REJ:

        dwRetCode = (CpTable[CpIndex].CpInfo.RasCpConfigRejReceived)(
                            pCpCb->pWorkBuf, pRecvConfig );
        break;

    default:

        return( FALSE );
    }

    if ( dwRetCode != NO_ERROR )
    {
        if ( dwRetCode == ERROR_PPP_INVALID_PACKET )
        {
            PppLog( 1, 
                    "Invalid packet received on port %d silently discarded",
                    pPcb->hPort );
        }
        else 
        {
            PppLog(1, 
                 "The control protocol for %x on port %d returned error %d",
                 CpTable[CpIndex].CpInfo.Protocol, pPcb->hPort, dwRetCode );

            if ( CpTable[CpIndex].CpInfo.Protocol == PPP_CCP_PROTOCOL )
            {
                //
                // If we need to force encryption but encryption negotiation
                // failed then we drop the link
                //

                if ( pPcb->ConfigInfo.dwConfigMask &
                            (PPPCFG_RequireEncryption      |
                             PPPCFG_RequireStrongEncryption ) )
                {
                    PppLog( 1, "Encryption is required" );

                    switch( dwRetCode )
                    {
                    case ERROR_NO_LOCAL_ENCRYPTION:
                    case ERROR_NO_REMOTE_ENCRYPTION:
                        pPcb->LcpCb.dwError = dwRetCode;
                        break;

                    case ERROR_PROTOCOL_NOT_CONFIGURED:
                        pPcb->LcpCb.dwError = ERROR_NO_LOCAL_ENCRYPTION;
                        break;

                    default:
                        pPcb->LcpCb.dwError = ERROR_NO_REMOTE_ENCRYPTION;
                        break;
                    }

                    //
                    // We need to send an Accounting Stop if RADIUS sends
                    // an Access Accept but we still drop the line.
                    //

                    pPcb->fFlags |= PCBFLAG_SERVICE_UNAVAILABLE;

                    //
                    // If we do FsmClose for CCP instead, the other side may
                    // conclude that PPP was negotiated successfully before we
                    // send an LCP Terminate Request.
                    //

                    FsmClose( pPcb, LCP_INDEX );

                    return( FALSE );
                }
            }

            pCpCb->dwError = dwRetCode;

            FsmClose( pPcb, CpIndex );
        }

        return( FALSE );
    }

    return( TRUE );
}

//**
//
// Call:        ReceiveIdentification
//
// Returns:     none
//
// Description: Handles an incomming IDENTIFICATION packet.
//
VOID
ReceiveIdentification( 
    IN PCB *            pPcb, 
    IN DWORD            CpIndex,
    IN CPCB *           pCpCb,
    IN PPP_CONFIG *     pRecvConfig
)
{
    DWORD dwLength = WireToHostFormat16( pRecvConfig->Length );
    RAS_AUTH_ATTRIBUTE *    pAttributes = pPcb->pUserAttributes;
    
    BYTE    MSRASClient[MAX_COMPUTERNAME_LENGTH  
            + sizeof(MS_RAS_WITH_MESSENGER) + 10];
    PBYTE   pbTempBuf = NULL;
            
    BYTE    MSRASClientVersion[30];
    DWORD   dwIndex = 0;
    DWORD   dwRetCode = NO_ERROR;

    PppLog( 2, "Identification packet received" );

    //
    // If we are a client we just discard this packet.
    //

    if ( !(pPcb->fFlags & PCBFLAG_IS_SERVER) )
    {
        return;
    }

    //
    // check to see if the identification is version.
    // if version store it in version field
    // or else store it in computer name field
    //
    // If this is not our identification message
    //

    if ( (dwLength < PPP_CONFIG_HDR_LEN+4+strlen(MS_RAS_WITH_MESSENGER)) ||
         (dwLength > PPP_CONFIG_HDR_LEN+4+
                     strlen(MS_RAS_WITH_MESSENGER)+MAX_COMPUTERNAME_LENGTH))
    {
        *(pPcb->pBcb->szComputerName) = (CHAR)NULL;
    	*(pPcb->pBcb->szClientVersion) = (CHAR)NULL;

        return;
    }

    for (dwIndex = 0; 
         pAttributes[dwIndex].raaType != raatMinimum;
         dwIndex ++);

    //
    // If theres no space in the user attributes list
    // expand the list for the one new attribute being
    // added.
    //
    if(dwIndex >= PPP_NUM_USER_ATTRIBUTES)
    {
        pAttributes = RasAuthAttributeCopyWithAlloc(
                            pPcb->pUserAttributes, 1);

        PppLog(1, "ReceiveIdentification: allocated new user list %p",
                pAttributes);

        if(NULL == pAttributes)
        {
            PppLog(1, "ReceiveIdentification: Failed to allocate attributes. %d",
                   GetLastError());
            return;
        }
    }

    //
    // Convert the ppp message into a string
    //
    pbTempBuf = LocalAlloc(LPTR, dwLength );
    if ( NULL == pbTempBuf )
    {
        PppLog( 1,
                "ReceiveIdentification: Failed to alloc memory %d",
                GetLastError()
              );
    }
    memcpy ( pbTempBuf,
             pRecvConfig->Data+4,
             dwLength - PPP_CONFIG_HDR_LEN - 4
           );

    //
    // And add the attribs to the list of User Attributes 
    //

    if ( strstr ( pbTempBuf, MS_RAS_WITHOUT_MESSENGER ) ||
    	 strstr ( pbTempBuf, MS_RAS_WITH_MESSENGER )
    	)
    {
        //
        // computer name
    	//
        ZeroMemory( pPcb->pBcb->szComputerName, 
    	            sizeof(pPcb->pBcb->szComputerName));
    	            
        CopyMemory( pPcb->pBcb->szComputerName, 
    				pbTempBuf, 
    				dwLength - PPP_CONFIG_HDR_LEN - 4 );

        //
        // Vendor-Id
        //
        HostToWireFormat32( 311, MSRASClient );

        //
        // Vendor-Type: MS-RAS-Client	- New
        //
        MSRASClient[4] = 34;

        //
        // Length
        //
        MSRASClient[5] = 2 + (BYTE) (dwLength - PPP_CONFIG_HDR_LEN - 4);

        //
        // Vendor-Id
        //
        CopyMemory ( MSRASClient + 6, 
                    pPcb->pBcb->szComputerName,
                    dwLength - PPP_CONFIG_HDR_LEN - 4) ;
                    
        pAttributes[dwIndex].raaType = raatReserved;
        
        dwRetCode = RasAuthAttributeInsert( dwIndex++,
                                pAttributes,
                                raatVendorSpecific,
                                FALSE,
                                6 + dwLength - PPP_CONFIG_HDR_LEN - 4,
                                &MSRASClient );
                                
        if ( NO_ERROR != dwRetCode )
        {
            PppLog( 2, "Error inserting user attribute = %s, %d", 
                    pPcb->pBcb->szComputerName, dwRetCode );
        }
        
        PppLog(2, "Remote identification = %s", pPcb->pBcb->szComputerName);
    	
    }
    else
    {
        //
        // version
        //
        ZeroMemory( pPcb->pBcb->szClientVersion,
        			sizeof( pPcb->pBcb->szClientVersion ) );

        CopyMemory( pPcb->pBcb->szClientVersion, 
        			pRecvConfig->Data+4, 
        			dwLength - PPP_CONFIG_HDR_LEN - 4 );

        //
        // Vendor-Id
        //
        HostToWireFormat32( 311, MSRASClientVersion );

        //
        // Vendor-Type: MS-RAS-Client-Version
        //
        MSRASClientVersion[4] = 35; 

        //
        // Vendor-Length
        //
        MSRASClientVersion[5] = (BYTE)(2 + dwLength - PPP_CONFIG_HDR_LEN - 4);
        CopyMemory( MSRASClientVersion + 6, 
                    pPcb->pBcb->szClientVersion, 
                    dwLength - PPP_CONFIG_HDR_LEN - 4 );
                    
        pAttributes[dwIndex].raaType = raatReserved;
        
        dwRetCode = RasAuthAttributeInsert( dwIndex++,
                                        pAttributes,
                                        raatVendorSpecific,
                                        FALSE,
                                        6 + dwLength - PPP_CONFIG_HDR_LEN - 4,
                                        &MSRASClientVersion );
                                        
        if ( dwRetCode != NO_ERROR )
        {
        	PppLog( 2, "Error inserting user attribute = %s, %d", pPcb->pBcb->szClientVersion, dwRetCode );
        }

        PppLog( 2, "Remote identification = %s", pPcb->pBcb->szClientVersion );
    }

    pAttributes[dwIndex].raaType  = raatMinimum;
    pAttributes[dwIndex].dwLength = 0;
    pAttributes[dwIndex].Value    = NULL;

    // 
    // If we allocated a new attribute list, free the old list and save
    // the new one.
    //
    if(pPcb->pUserAttributes != pAttributes)
    {
        PppLog(2, "ReceiveIdentification: Replaced userlist %p with %p",
               pPcb->pUserAttributes,
               pAttributes);
        RasAuthAttributeDestroy(pPcb->pUserAttributes);
        pPcb->pUserAttributes = pAttributes;
    }
    if ( pbTempBuf )
        LocalFree(pbTempBuf);
    return;
}

//**
//
// Call:        ReceiveTimeRemaining
//
// Returns:     none
//
// Description: Handles an incomming TIME_REMAINING packet.
//
VOID
ReceiveTimeRemaining( 
    IN PCB *            pPcb, 
    IN DWORD            CpIndex,
    IN CPCB *           pCpCb,
    IN PPP_CONFIG *     pRecvConfig
)
{
    DWORD dwLength = WireToHostFormat16( pRecvConfig->Length );

    PppLog( 2, "Time Remaining packet received");

    //
    // If we are a server we just discard this packet.
    //

    if ( pPcb->fFlags & PCBFLAG_IS_SERVER )
    {
        return;
    }

    //
    // If this is not our time remaining message
    //

    if ( dwLength != PPP_CONFIG_HDR_LEN + 8 + strlen( MS_RAS ) )
    {
        return;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\engine\smaction.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    smaction.c
//
// Description: This module contains actions that occure during state
//              transitions withing the Finite State Machine for PPP.
//
// History:
//      Oct 25,1993.    NarenG          Created original version.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>     // needed for winbase.h

#include <windows.h>    // Win32 base API's
#include <stdlib.h>
#include <string.h>
#include <wchar.h>

#include <ntlsapi.h>
#include <lmcons.h>
#include <raserror.h>
#include <rasman.h>
#include <rtutils.h>
#include <mprlog.h>
#include <mprerror.h>
#include <rasppp.h>
#include <pppcp.h>
#include <ppp.h>
#include <smaction.h>
#include <smevents.h>
#include <receive.h>
#include <auth.h>
#include <callback.h>
#include <receive.h>
#include <lcp.h>
#include <timer.h>
#include <util.h>
#include <worker.h>
#include <bap.h>

#define INCL_RASAUTHATTRIBUTES
#include <ppputil.h>

extern WORD WLinkDiscriminator; // Next Link Discriminator to use

//**
//
// Call:        FsmSendConfigReq
//
// Returns:     TRUE  - Config Req. sent successfully.
//              FALSE - Otherwise 
//
// Description: Called to send a configuration request 
//
BOOL
FsmSendConfigReq(
    IN PCB *        pPcb,
    IN DWORD        CpIndex,
    IN BOOL         fTimeout
)
{
    DWORD        dwRetCode;
    PPP_CONFIG * pSendConfig = (PPP_CONFIG*)(pPcb->pSendBuf->Information);
    CPCB *       pCpCb       = GetPointerToCPCB( pPcb, CpIndex );
    DWORD        dwLength;

    if ( pCpCb == NULL )
    {
        return( FALSE );
    }

    dwRetCode = (CpTable[CpIndex].CpInfo.RasCpMakeConfigRequest)( 
                                                pCpCb->pWorkBuf,
                                                pSendConfig,
                                                LCP_DEFAULT_MRU
                                                - PPP_PACKET_HDR_LEN );


    if ( dwRetCode != NO_ERROR )
    {
        pCpCb->dwError = dwRetCode;

        PppLog( 1,"The control protocol for %x, returned error %d",
                  CpTable[CpIndex].CpInfo.Protocol, dwRetCode );
        PppLog(1,"while making a configure request on port %d",pPcb->hPort);

        FsmClose( pPcb, CpIndex );

        return( FALSE );
    }

    HostToWireFormat16( (WORD)CpTable[CpIndex].CpInfo.Protocol, 
                        (PBYTE)(pPcb->pSendBuf->Protocol) );

    pSendConfig->Code = CONFIG_REQ;

    //
    // If we are resending a configure request because of a timeout, we do not 
    // use the id of the previous configure request, instead we get a new Id.
    // Id we do not, then the wrong Config-Req's and Config-Acks may be matched
    // up and we start getting crossed connections.
    //

    pSendConfig->Id = GetUId( pPcb, CpIndex );

    dwLength = WireToHostFormat16( pSendConfig->Length );

    LogPPPPacket(FALSE,pPcb,pPcb->pSendBuf,dwLength+PPP_PACKET_HDR_LEN);

    if ( (dwRetCode = PortSendOrDisconnect( pPcb,
                                (dwLength + PPP_PACKET_HDR_LEN)))
                                        != NO_ERROR )
    {
        return( FALSE );
    }

    pCpCb->LastId = pSendConfig->Id;

    InsertInTimerQ( pPcb->dwPortId,
                    pPcb->hPort, 
                    pCpCb->LastId, 
                    CpTable[CpIndex].CpInfo.Protocol,
                    FALSE,
                    TIMER_EVENT_TIMEOUT,
                    pPcb->RestartTimer );

    return( TRUE );
}


//**
//
// Call:        FsmSendTermReq
//
// Returns:     TRUE  - Termination Req. sent successfully.
//              FALSE - Otherwise 
//
// Description: Called to send a termination request. 
//
BOOL
FsmSendTermReq(
    IN PCB *    pPcb,
    IN DWORD    CpIndex
)
{
    DWORD        dwRetCode;
    PPP_CONFIG * pSendConfig = (PPP_CONFIG*)(pPcb->pSendBuf->Information);
    CPCB *       pCpCb       = GetPointerToCPCB( pPcb, CpIndex );
    LCPCB *      pLcpCb      = (LCPCB*)(pPcb->LcpCb.pWorkBuf);

    if ( pCpCb == NULL )
    {
        return( FALSE );
    }

    HostToWireFormat16( (WORD)(CpTable[CpIndex].CpInfo.Protocol), 
                        (PBYTE)(pPcb->pSendBuf->Protocol) );

    pSendConfig->Code = TERM_REQ;
    pSendConfig->Id   = GetUId( pPcb, CpIndex );

    HostToWireFormat16( (WORD)((PPP_CONFIG_HDR_LEN)+(sizeof(DWORD)*3)),
                        (PBYTE)(pSendConfig->Length) );

    HostToWireFormat32( pLcpCb->Local.Work.MagicNumber,
                                    (PBYTE)(pSendConfig->Data) );

    //
    // Signature
    //

    HostToWireFormat32( 3984756, (PBYTE)(pSendConfig->Data+4) );

    HostToWireFormat32( pCpCb->dwError, (PBYTE)(pSendConfig->Data+8) );

    LogPPPPacket( FALSE,pPcb,pPcb->pSendBuf,
                  PPP_PACKET_HDR_LEN+PPP_CONFIG_HDR_LEN+(sizeof(DWORD)*3) );

    if ( ( dwRetCode = PortSendOrDisconnect( pPcb,
                                                PPP_PACKET_HDR_LEN + 
                                                PPP_CONFIG_HDR_LEN +
                                                (sizeof(DWORD)*3)))
                                            != NO_ERROR )
    {
        return( FALSE );
    }

    pCpCb->LastId = pSendConfig->Id;

    dwRetCode = InsertInTimerQ( pPcb->dwPortId, 
                                pPcb->hPort, 
                                pCpCb->LastId, 
                                CpTable[CpIndex].CpInfo.Protocol, 
                                FALSE,
                                TIMER_EVENT_TIMEOUT,
                                pPcb->RestartTimer );

    if ( dwRetCode == NO_ERROR)
    {
        return( TRUE );
    }
    else
    {
        PppLog( 1, "InsertInTimerQ on port %d failed: %d",
                pPcb->hPort, dwRetCode );

        pPcb->LcpCb.dwError = dwRetCode;

        pPcb->fFlags |= PCBFLAG_STOPPED_MSG_SENT;

        NotifyCaller( pPcb,
                      ( pPcb->fFlags & PCBFLAG_IS_SERVER )
                            ? PPPDDMMSG_Stopped
                            : PPPMSG_Stopped,
                      &(pPcb->LcpCb.dwError) );

        return( FALSE );
    }
}

//**
//
// Call:        FsmSendTermAck
//
// Returns:     TRUE  - Termination Ack. sent successfully.
//              FALSE - Otherwise 
//
// Description: Caller to send a Termination Ack packet.
//
BOOL
FsmSendTermAck( 
    IN PCB *        pPcb, 
    IN DWORD        CpIndex, 
    IN PPP_CONFIG * pRecvConfig
)
{
    PPP_CONFIG * pSendConfig = (PPP_CONFIG*)(pPcb->pSendBuf->Information);
    DWORD        dwLength    =  PPP_PACKET_HDR_LEN +
                                WireToHostFormat16( pRecvConfig->Length );
    LCPCB *      pLcpCb      = (LCPCB*)(pPcb->LcpCb.pWorkBuf);
    DWORD        dwRetCode;

    if ( dwLength > LCP_DEFAULT_MRU )
    {
        dwLength = LCP_DEFAULT_MRU;
    }
                                        
    HostToWireFormat16( (WORD)CpTable[CpIndex].CpInfo.Protocol, 
                        (PBYTE)(pPcb->pSendBuf->Protocol) );

    pSendConfig->Code = TERM_ACK;
    pSendConfig->Id   = pRecvConfig->Id;

    HostToWireFormat16( (WORD)(dwLength - PPP_PACKET_HDR_LEN),
                        (PBYTE)(pSendConfig->Length) );

    CopyMemory( pSendConfig->Data, 
                pRecvConfig->Data, 
                dwLength - PPP_CONFIG_HDR_LEN - PPP_PACKET_HDR_LEN );
    
    LogPPPPacket( FALSE, pPcb, pPcb->pSendBuf, dwLength );

    if ( ( dwRetCode = PortSendOrDisconnect( pPcb, dwLength ) ) != NO_ERROR )
    {
        return( FALSE );
    }

    return( TRUE );
}

//**
//
// Call:        FsmSendConfigResult
//
// Returns:     TRUE  - Config Result sent successfully.
//              FALSE - Otherwise 
//
// Description: Called to send a Ack/Nak/Rej packet.
//
BOOL
FsmSendConfigResult(
    IN PCB *        pPcb,
    IN DWORD        CpIndex,
    IN PPP_CONFIG * pRecvConfig,
    IN BOOL *       pfAcked
)
{
    PPP_CONFIG * pSendConfig = (PPP_CONFIG*)(pPcb->pSendBuf->Information);
    CPCB *       pCpCb       = GetPointerToCPCB( pPcb, CpIndex );
    DWORD        dwLength;    
    DWORD        dwRetCode;

    *pfAcked = FALSE;

    if ( pCpCb == NULL )
    {
        return( FALSE );
    }

    ZeroMemory( pSendConfig, 30 );

    pSendConfig->Id = pRecvConfig->Id;

    dwRetCode = (CpTable[CpIndex].CpInfo.RasCpMakeConfigResult)( 
                                        pCpCb->pWorkBuf, 
                                        pRecvConfig,
                                        pSendConfig,
                                        LCP_DEFAULT_MRU - PPP_PACKET_HDR_LEN,
                                        ( pCpCb->NakRetryCount == 0 ));

    if ( dwRetCode == PENDING )
    {
        return( FALSE );
    }

    if ( dwRetCode == ERROR_PPP_INVALID_PACKET )
    {
        PppLog( 1, "Silently discarding invalid packet on port=%d",
                    pPcb->hPort );

        return( FALSE );
    }

    if ( dwRetCode != NO_ERROR )
    {
        pCpCb->dwError = dwRetCode;

        PppLog( 1, "The control protocol for %x, returned error %d",
                   CpTable[CpIndex].CpInfo.Protocol, dwRetCode );
        PppLog( 1, "while making a configure result on port %d", pPcb->hPort );

        FsmClose( pPcb, CpIndex );

        return( FALSE );
    }

    switch( pSendConfig->Code )
    {

    case CONFIG_ACK:

        *pfAcked = TRUE;

        break;

    case CONFIG_NAK:

        if ( pCpCb->NakRetryCount > 0 )
        {
            (pCpCb->NakRetryCount)--;
        }
        else
        {
            if ( CpTable[CpIndex].CpInfo.Protocol == PPP_CCP_PROTOCOL )
            {
                //
                // If we need to force encryption but encryption negotiation
                // failed then we drop the link
                //

                if ( pPcb->ConfigInfo.dwConfigMask &
                            (PPPCFG_RequireEncryption      |
                             PPPCFG_RequireStrongEncryption ) )
                {
                    PppLog( 1, "Encryption is required" );

                    //
                    // We need to send an Accounting Stop if RADIUS sends
                    // an Access Accept but we still drop the line.
                    //

                    pPcb->fFlags |= PCBFLAG_SERVICE_UNAVAILABLE;

                    //
                    // If we do FsmClose for CCP instead, the other side may
                    // conclude that PPP was negotiated successfully before we
                    // send an LCP Terminate Request.
                    //

                    pPcb->LcpCb.dwError = ERROR_NO_REMOTE_ENCRYPTION;

                    FsmClose( pPcb, LCP_INDEX );

                    return( FALSE );
                }
            }

            pCpCb->dwError = ERROR_PPP_NOT_CONVERGING;

            FsmClose( pPcb, CpIndex );

            return( FALSE );
        }

        break;

    case CONFIG_REJ:

        if ( pCpCb->RejRetryCount > 0 )
        {
            (pCpCb->RejRetryCount)--;
        }
        else
        {
            pCpCb->dwError = ERROR_PPP_NOT_CONVERGING;

            FsmClose( pPcb, CpIndex );

            return( FALSE );
        }

        break;

    default:

        break;
    }

    HostToWireFormat16( (WORD)CpTable[CpIndex].CpInfo.Protocol, 
                        (PBYTE)(pPcb->pSendBuf->Protocol) );

    pSendConfig->Id = pRecvConfig->Id;
    dwLength        = WireToHostFormat16( pSendConfig->Length );

    
        LogPPPPacket(FALSE,pPcb,pPcb->pSendBuf,dwLength+PPP_PACKET_HDR_LEN);
        if ( ( dwRetCode =  PortSendOrDisconnect( pPcb,
                                                                (dwLength + PPP_PACKET_HDR_LEN)))
                                                                                != NO_ERROR ) 
        {
                return( FALSE );
        }
    return( TRUE );
}


//**
//
// Call:        FsmSendEchoRequest
//
// Returns:     TRUE  - Echo reply sent successfully.
//              FALSE - Otherwise 
//
// Description: Called to send an Echo Rely packet
//
BOOL
FsmSendEchoRequest(
    IN PCB *        pPcb,   
        IN DWORD        CpIndex
)
{
        DWORD        dwRetCode = NO_ERROR;

        char             szEchoText[] = PPP_DEF_ECHO_TEXT;        

        LCPCB *      pLcpCb      = (LCPCB*)(pPcb->LcpCb.pWorkBuf);

        DWORD        dwLength    =  (DWORD)(PPP_PACKET_HDR_LEN + PPP_CONFIG_HDR_LEN + strlen( szEchoText)+ sizeof(pLcpCb->Local.Work.MagicNumber));

        PPP_CONFIG * pSendConfig = (PPP_CONFIG*)(pPcb->pSendBuf->Information);


    HostToWireFormat16( (WORD)CpTable[CpIndex].CpInfo.Protocol, 
                        (PBYTE)(pPcb->pSendBuf->Protocol) );


    pSendConfig->Code = ECHO_REQ;
        //Get a unique Id for this request
    pSendConfig->Id   = GetUId( pPcb, CpIndex );

    HostToWireFormat16( (WORD)(dwLength - PPP_PACKET_HDR_LEN),
                        (PBYTE)(pSendConfig->Length) );

    HostToWireFormat32( pLcpCb->Local.Work.MagicNumber,
                        (PBYTE)(pSendConfig->Data) );

    CopyMemory( pSendConfig->Data + 4, 
                szEchoText, 
                strlen(szEchoText));

    LogPPPPacket( FALSE, pPcb, pPcb->pSendBuf, dwLength );

    if ( ( dwRetCode = PortSendOrDisconnect( pPcb, dwLength ) ) != NO_ERROR )
    {
        return( FALSE );
    }

    return( TRUE );
}

//**
//
// Call:        FsmSendEchoReply
//
// Returns:     TRUE  - Echo reply sent successfully.
//              FALSE - Otherwise 
//
// Description: Called to send an Echo Rely packet
//
BOOL
FsmSendEchoReply(
    IN PCB *        pPcb,
    IN DWORD        CpIndex,
    IN PPP_CONFIG * pRecvConfig
)
{
    DWORD        dwRetCode;
    PPP_CONFIG * pSendConfig = (PPP_CONFIG*)(pPcb->pSendBuf->Information);
    DWORD        dwLength    =  PPP_PACKET_HDR_LEN +
                                WireToHostFormat16( pRecvConfig->Length );
    LCPCB *      pLcpCb      = (LCPCB*)(pPcb->LcpCb.pWorkBuf);

    if ( dwLength > LCP_DEFAULT_MRU )
    { 
        dwLength = LCP_DEFAULT_MRU;
    }

    if ( dwLength < PPP_PACKET_HDR_LEN + PPP_CONFIG_HDR_LEN + 4 )
    {
        PppLog( 1, "Silently discarding invalid packet on port=%d",
                    pPcb->hPort );

        return( FALSE );
    }

    HostToWireFormat16( (WORD)CpTable[CpIndex].CpInfo.Protocol, 
                        (PBYTE)(pPcb->pSendBuf->Protocol) );

    pSendConfig->Code = ECHO_REPLY;
    pSendConfig->Id   = pRecvConfig->Id;

    HostToWireFormat16( (WORD)(dwLength - PPP_PACKET_HDR_LEN),
                        (PBYTE)(pSendConfig->Length) );

    HostToWireFormat32( pLcpCb->Local.Work.MagicNumber,
                        (PBYTE)(pSendConfig->Data) );

    CopyMemory( pSendConfig->Data + 4, 
                pRecvConfig->Data + 4, 
                dwLength - PPP_CONFIG_HDR_LEN - PPP_PACKET_HDR_LEN - 4 );

    LogPPPPacket( FALSE, pPcb, pPcb->pSendBuf, dwLength );

    if ( ( dwRetCode = PortSendOrDisconnect( pPcb, dwLength ) ) != NO_ERROR )
    {
        return( FALSE );
    }

    return( TRUE );
}


//**
//
// Call:        FsmSendCodeReject
//
// Returns:     TRUE  - Code Reject sent successfully.
//              FALSE - Otherwise 
//
// Description: Called to send a Code Reject packet.
//
BOOL
FsmSendCodeReject( 
    IN PCB *        pPcb, 
    IN DWORD        CpIndex,
    IN PPP_CONFIG * pRecvConfig 
)
{
    DWORD        dwRetCode;
    PPP_CONFIG * pSendConfig = (PPP_CONFIG*)(pPcb->pSendBuf->Information);
    DWORD        dwLength    =  PPP_PACKET_HDR_LEN + 
                                PPP_CONFIG_HDR_LEN + 
                                WireToHostFormat16( pRecvConfig->Length );
    LCPCB *      pLcpCb      = (LCPCB*)(pPcb->LcpCb.pWorkBuf);

    if ( dwLength > LCP_DEFAULT_MRU )
        dwLength = LCP_DEFAULT_MRU;

    HostToWireFormat16( (WORD)CpTable[CpIndex].CpInfo.Protocol, 
                        (PBYTE)(pPcb->pSendBuf->Protocol) );

    pSendConfig->Code = CODE_REJ;
    pSendConfig->Id   = GetUId( pPcb, CpIndex );

    HostToWireFormat16( (WORD)(dwLength - PPP_PACKET_HDR_LEN),
                        (PBYTE)(pSendConfig->Length) );

    CopyMemory( pSendConfig->Data, 
                pRecvConfig, 
                dwLength - PPP_CONFIG_HDR_LEN - PPP_PACKET_HDR_LEN );

    LogPPPPacket( FALSE, pPcb, pPcb->pSendBuf, dwLength );

    if ( ( dwRetCode = PortSendOrDisconnect( pPcb, dwLength ) ) != NO_ERROR )
    {
        return( FALSE );
    }

    return( TRUE );
}
//**
//
// Call:        FsmSendProtocolRej
//
// Returns:     TRUE  - Protocol Reject sent successfully.
//              FALSE - Otherwise 
//
// Description: Called to send a protocol reject packet.
//
BOOL
FsmSendProtocolRej( 
    IN PCB *        pPcb, 
    IN PPP_PACKET * pPacket,
    IN DWORD        dwPacketLength 
)
{
    DWORD        dwRetCode;
    PPP_CONFIG * pRecvConfig = (PPP_CONFIG*)(pPacket->Information);
    PPP_CONFIG * pSendConfig = (PPP_CONFIG*)(pPcb->pSendBuf->Information);
    DWORD        dwLength    =  PPP_PACKET_HDR_LEN + 
                                PPP_CONFIG_HDR_LEN + 
                                dwPacketLength;
    LCPCB *      pLcpCb      = (LCPCB*)(pPcb->LcpCb.pWorkBuf);

    // 
    // If LCP is not in the opened state we cannot send a protocol reject
    // packet
    //
   
    if ( !IsLcpOpened( pPcb ) )
        return( FALSE );

    if ( dwLength > LCP_DEFAULT_MRU )
        dwLength = LCP_DEFAULT_MRU;

    HostToWireFormat16( (WORD)CpTable[LCP_INDEX].CpInfo.Protocol, 
                        (PBYTE)(pPcb->pSendBuf->Protocol) );

    pSendConfig->Code = PROT_REJ;
    pSendConfig->Id   = GetUId( pPcb, LCP_INDEX );

    HostToWireFormat16( (WORD)(dwLength - PPP_PACKET_HDR_LEN),
                        (PBYTE)(pSendConfig->Length) );

    CopyMemory( pSendConfig->Data, 
                pPacket, 
                dwLength - PPP_CONFIG_HDR_LEN - PPP_PACKET_HDR_LEN );

    LogPPPPacket( FALSE, pPcb, pPcb->pSendBuf, dwLength );

    if ( ( dwRetCode = PortSendOrDisconnect( pPcb, dwLength ) ) != NO_ERROR )
    {
        return( FALSE );
    }

    return( TRUE );
}

//**
//
// Call:    FsmSendIndentification
//
// Returns: TRUE  - Identification sent successfully.
//      FALSE - Otherwise
//
// Description: Called to send an LCP Identification message to the peer
//
BOOL
FsmSendIdentification(
    IN  PCB *   pPcb,
    IN  BOOL    fSendVersion
)
{
    DWORD        dwRetCode;
    PPP_CONFIG * pSendConfig = (PPP_CONFIG*)(pPcb->pSendBuf->Information);
    DWORD        dwLength    =  PPP_PACKET_HDR_LEN + PPP_CONFIG_HDR_LEN + 4;
    LCPCB *      pLcpCb      = (LCPCB*)(pPcb->LcpCb.pWorkBuf);

    if ( !(pPcb->ConfigInfo.dwConfigMask & PPPCFG_UseLcpExtensions) )
    {
        return( FALSE );
    }

    if ( fSendVersion )
    {
        CopyMemory( pSendConfig->Data + 4,
                    MS_RAS_VERSION,
                    strlen( MS_RAS_VERSION ) );

        dwLength += strlen( MS_RAS_VERSION );
    }
    else
    {
        //
        // If we couldn't get the computername for any reason
        //

        if ( *(pPcb->pBcb->szComputerName) == (CHAR)NULL )
        {
            return( FALSE );
        }

        CopyMemory( pSendConfig->Data + 4,
                    pPcb->pBcb->szComputerName,
                    strlen( pPcb->pBcb->szComputerName ) );

        dwLength += strlen( pPcb->pBcb->szComputerName );
    }

    HostToWireFormat16( (WORD)PPP_LCP_PROTOCOL,
                        (PBYTE)(pPcb->pSendBuf->Protocol) );

    pSendConfig->Code = IDENTIFICATION;
    pSendConfig->Id   = GetUId( pPcb, LCP_INDEX );

    HostToWireFormat16( (WORD)(dwLength - PPP_PACKET_HDR_LEN),
                        (PBYTE)(pSendConfig->Length) );

    HostToWireFormat32( pLcpCb->Local.Work.MagicNumber,
                        (PBYTE)(pSendConfig->Data) );

    LogPPPPacket( FALSE,pPcb,pPcb->pSendBuf,dwLength );

    if ( ( dwRetCode = PortSendOrDisconnect( pPcb, dwLength ) ) != NO_ERROR )
    {
        return( FALSE );
    }

    return( TRUE );
}

//**
//
// Call:        FsmSendTimeRemaining
//
// Returns:     TRUE  - TimeRemaining sent successfully.
//              FALSE - Otherwise 
//
// Description: Called to send an LCP Time Remaining packet from the server
//              to the client
//
BOOL
FsmSendTimeRemaining(
    IN PCB *    pPcb
)
{
    DWORD        dwRetCode;
    PPP_CONFIG * pSendConfig = (PPP_CONFIG*)(pPcb->pSendBuf->Information);
    DWORD        dwLength    =  PPP_PACKET_HDR_LEN + PPP_CONFIG_HDR_LEN + 8;
    LCPCB *      pLcpCb      = (LCPCB*)(pPcb->LcpCb.pWorkBuf);

    if ( !(pPcb->ConfigInfo.dwConfigMask & PPPCFG_UseLcpExtensions) )
    {
        return( FALSE );
    }

    dwLength += strlen( MS_RAS );

    HostToWireFormat16( (WORD)PPP_LCP_PROTOCOL,
                        (PBYTE)(pPcb->pSendBuf->Protocol) );

    pSendConfig->Code = TIME_REMAINING;
    pSendConfig->Id   = GetUId( pPcb, LCP_INDEX );

    HostToWireFormat16( (WORD)(dwLength - PPP_PACKET_HDR_LEN),
                        (PBYTE)(pSendConfig->Length) );

    HostToWireFormat32( pLcpCb->Local.Work.MagicNumber,
                        (PBYTE)(pSendConfig->Data) );

    HostToWireFormat32( 0, (PBYTE)(pSendConfig->Data+4) );

    CopyMemory( pSendConfig->Data + 8, MS_RAS, strlen( MS_RAS ) );

    LogPPPPacket( FALSE, pPcb, pPcb->pSendBuf, dwLength );

    if ( ( dwRetCode = PortSendOrDisconnect( pPcb, dwLength ) ) != NO_ERROR )
    {
        return( FALSE );
    }

    return( TRUE );
}

//**
//
// Call:        FsmInit
//
// Returns:     TRUE  - Control Protocol was successfully initialized
//              FALSE - Otherwise.
//
// Description: Called to initialize the state machine 
//
BOOL
FsmInit(
    IN PCB * pPcb,
    IN DWORD CpIndex
)
{
    DWORD       dwRetCode;
    PPPCP_INIT  PppCpInit;
    CPCB *      pCpCb       = GetPointerToCPCB( pPcb, CpIndex );

    if ( pCpCb == NULL )
    {
        return( FALSE );
    }

    PppLog( 1, "FsmInit called for protocol = %x, port = %d",
                CpTable[CpIndex].CpInfo.Protocol, pPcb->hPort );

    pCpCb->NcpPhase = NCP_CONFIGURING;
    pCpCb->dwError  = NO_ERROR;
    pCpCb->State    = FSM_INITIAL;

    PppCpInit.fServer           = (pPcb->fFlags & PCBFLAG_IS_SERVER);
    PppCpInit.hPort             = pPcb->hPort;
    PppCpInit.dwDeviceType      = pPcb->dwDeviceType;
    PppCpInit.CompletionRoutine = CompletionRoutine;
    PppCpInit.pszzParameters    = pPcb->pBcb->InterfaceInfo.szzParameters;
    PppCpInit.fThisIsACallback  = pPcb->fFlags & PCBFLAG_THIS_IS_A_CALLBACK;
    PppCpInit.IfType            = pPcb->pBcb->InterfaceInfo.IfType;
    PppCpInit.pszUserName       = pPcb->pBcb->szRemoteUserName;
    PppCpInit.pszPortName       = pPcb->szPortName;
    PppCpInit.hConnection       = pPcb->pBcb->hConnection;
    PppCpInit.pAttributes       = ( pPcb->pAuthProtocolAttributes ) 
                                    ? pPcb->pAuthProtocolAttributes 
                                    : pPcb->pAuthenticatorAttributes;
    PppCpInit.fDisableNetbt     = (pPcb->fFlags & PCBFLAG_DISABLE_NETBT);

    if ( pPcb->fFlags & PCBFLAG_IS_SERVER ) 
    {
        PppCpInit.PppConfigInfo = PppConfigInfo.ServerConfigInfo;

        if ( PppConfigInfo.ServerConfigInfo.dwConfigMask 
                                                & PPPCFG_AllowNoAuthOnDCPorts )
        {
            if ( RAS_DEVICE_CLASS( pPcb->dwDeviceType ) & RDT_Direct )
            {
                PppCpInit.PppConfigInfo.dwConfigMask |= 
                                                  PPPCFG_AllowNoAuthentication;
            }
            else
            {
                PppCpInit.PppConfigInfo.dwConfigMask &=
                                                  ~PPPCFG_AllowNoAuthOnDCPorts;
            }
        }
    }
    else
    {
        PppCpInit.PppConfigInfo = pPcb->ConfigInfo;
    }

    switch( CpTable[CpIndex].CpInfo.Protocol )
    {
    case PPP_IPCP_PROTOCOL:
        PppCpInit.hInterface = pPcb->pBcb->InterfaceInfo.hIPInterface;
        break;

    case PPP_IPXCP_PROTOCOL:
        PppCpInit.hInterface = pPcb->pBcb->InterfaceInfo.hIPXInterface;
        break;

    default:
        PppCpInit.hInterface = INVALID_HANDLE_VALUE;
        break;
    }

    dwRetCode = (CpTable[CpIndex].CpInfo.RasCpBegin)(
                        &(pCpCb->pWorkBuf), &PppCpInit );

    if ( dwRetCode != NO_ERROR )
    {
        PppLog( 1, "FsmInit for protocol = %x failed with error %d", 
                   CpTable[CpIndex].CpInfo.Protocol, dwRetCode );

        pCpCb->dwError = dwRetCode;

        pCpCb->fConfigurable = FALSE;
        
        return( FALSE );
    }

    pCpCb->fBeginCalled = TRUE;

    if ( !FsmReset( pPcb, CpIndex ) )
    {
        pCpCb->fConfigurable = FALSE;

        return( FALSE );
    }

    return( TRUE );
}

//**
//
// Call:        FsmReset
//
// Returns:     TRUE  - Control Protocol was successfully reset
//              FALSE - Otherwise.
//
// Description: Called to reset the state machine 
//
BOOL
FsmReset(
    IN PCB * pPcb,
    IN DWORD CpIndex
)
{
    DWORD  dwRetCode;
    CPCB * pCpCb = GetPointerToCPCB( pPcb, CpIndex );

    if ( pCpCb == NULL )
    {
        return( FALSE );
    }

    PppLog( 1, "FsmReset called for protocol = %x, port = %d",
               CpTable[CpIndex].CpInfo.Protocol, pPcb->hPort );

    pCpCb->LastId = 0;

    InitRestartCounters( pPcb, pCpCb );

    pCpCb->NakRetryCount = PppConfigInfo.MaxFailure;
    pCpCb->RejRetryCount = PppConfigInfo.MaxReject;

    dwRetCode = (CpTable[CpIndex].CpInfo.RasCpReset)( pCpCb->pWorkBuf );

    if ( dwRetCode != NO_ERROR )
    {
        PppLog( 1, "Reset for protocol = %x failed with error %d", 
                   CpTable[CpIndex].CpInfo.Protocol, dwRetCode );

        pCpCb->dwError = dwRetCode;

        FsmClose( pPcb, CpIndex );

        return( FALSE );
    }

    return( TRUE );
}


//**
//
// Call:        FsmThisLayerUp
//
// Returns:     TRUE  - Success
//              FALSE - Otherwise
//
// Description: Called when configuration negotiation is completed.
//
BOOL
FsmThisLayerUp(
    IN PCB *    pPcb,
    IN DWORD    CpIndex
)
{
    DWORD                 dwIndex;
    DWORD                 dwRetCode;
    PPP_PROJECTION_RESULT ProjectionResult;
    RAS_AUTH_ATTRIBUTE *  pUserAttributes       = NULL;
    NCP_PHASE             dwNcpState;
    BOOL                  fAreCPsDone           = FALSE;
    CPCB *                pCpCb                 = GetPointerToCPCB( pPcb, CpIndex );
    LCPCB *               pLcpCb;
    DWORD                 dwLinkDiscrim;
    BOOL                  fCanDoBAP             = FALSE;

    if ( NULL != pCpCb )
    {
        PppLog( 1, "FsmThisLayerUp called for protocol = %x, port = %d",
                   CpTable[CpIndex].CpInfo.Protocol, pPcb->hPort );

        if ( CpTable[CpIndex].CpInfo.RasCpThisLayerUp != NULL )
        {
            dwRetCode = (CpTable[CpIndex].CpInfo.RasCpThisLayerUp)(
                                                        pCpCb->pWorkBuf);

            if ( dwRetCode != NO_ERROR )
            {
                PppLog( 1, "FsmThisLayerUp for protocol=%x,port=%d,RetCode=%d",
                        CpTable[CpIndex].CpInfo.Protocol, pPcb->hPort,
                        dwRetCode);

                if ( dwRetCode != PENDING )
                {
                    pCpCb->dwError = dwRetCode;

                    FsmClose( pPcb, CpIndex );
                }

                return( FALSE );
            }
        }
    }
    else
    {
        PppLog( 1, "FsmThisLayerUp called in no auth case, port = %d",
                pPcb->hPort );
    }

    if ( CpIndex == GetCpIndexFromProtocol( PPP_BACP_PROTOCOL ) )
    {
        BapSetPolicy( pPcb->pBcb );
    }

    switch( pPcb->PppPhase )
    {
    case PPP_LCP:

        PppLog( 1, "LCP Configured successfully" );

        if (!( pPcb->fFlags & PCBFLAG_IS_SERVER ) )
        {
            AdjustHTokenImpersonateUser( pPcb );
        }

        //
        // Send Identification messages if we are a client.
        //

        if ( !(pPcb->fFlags & PCBFLAG_IS_SERVER) )
        {
            FsmSendIdentification( pPcb, TRUE );

            FsmSendIdentification( pPcb, FALSE );
        }

        //
        // If an Authentication protocol was negotiated 
        //

        pLcpCb = (LCPCB*)(pPcb->LcpCb.pWorkBuf);

        if ( ( pLcpCb->Local.Work.AP != 0 ) || ( pLcpCb->Remote.Work.AP != 0 ) )
        {
            //
            // Start authenticating
            //

            PppLog( 1, "Authenticating phase started" );

            pPcb->PppPhase = PPP_AP;

            //
            // Start server side authentication if one was negotiated   
            //

            if ( pLcpCb->Local.Work.AP != 0 ) 
            {
                CpIndex = GetCpIndexFromProtocol( pLcpCb->Local.Work.AP );

                PPP_ASSERT(( CpIndex != (DWORD)-1 ));

                ApStart( pPcb, CpIndex, TRUE );
            }

            //
            // Start client side negotiation if one was negotiated
            //

            if ( pLcpCb->Remote.Work.AP != 0 )
            {
                CpIndex = GetCpIndexFromProtocol( pLcpCb->Remote.Work.AP );

                PPP_ASSERT(( CpIndex != (DWORD)-1 ));

                ApStart( pPcb, CpIndex, FALSE );
            }

            break;
        }

        //
        // If we are a server and did not authenticate the user, then see if
        // Guests have dial-in privilege. In the case of DCC, we don't care if
        // Guests have the privilege. We allow the call to succeed.
        //

        if (   ( pPcb->fFlags & PCBFLAG_IS_SERVER )
            && ( pLcpCb->Local.Work.AP == 0 )
            && (0 == (pLcpCb->PppConfigInfo.dwConfigMask & PPPCFG_AllowNoAuthOnDCPorts)))
            // && ( ( RAS_DEVICE_CLASS( pPcb->dwDeviceType ) & RDT_Direct ) == 0 ))
        {
            pPcb->PppPhase = PPP_AP;

            pUserAttributes = RasAuthAttributeCopy(
                                            pPcb->pUserAttributes );

            if ( pUserAttributes == NULL )
            {
                dwRetCode = GetLastError();

                pPcb->LcpCb.dwError = dwRetCode;

                NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );

                return( FALSE );
            }

            dwRetCode = RasAuthenticateClient(pPcb->hPort, pUserAttributes);

            if ( dwRetCode != NO_ERROR )
            {
                pPcb->LcpCb.dwError = dwRetCode;

                NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );

                return( FALSE );
            }

            break;
        }

        //
        // If there was no authentication protocol negotiated, fallthru and
        // begin NCP configurations.
        //

    case PPP_AP:

        //
        // Make sure authentication phase is completed before moving on.
        //
        
        if ( pPcb->AuthenticatorCb.fConfigurable )
        {
            if ( pPcb->AuthenticatorCb.State != FSM_OPENED )
            {   
                break;
            }
        }

        if ( pPcb->AuthenticateeCb.fConfigurable )
        {
            if ( pPcb->AuthenticateeCb.State != FSM_OPENED )
            {
                break;
            }
        }

        NotifyCaller( pPcb, PPPDDMMSG_Authenticated, NULL );

        //
        // If we are to negotiate callback 
        //

        if ( pPcb->fFlags & PCBFLAG_NEGOTIATE_CALLBACK )
        {
            CpIndex = GetCpIndexFromProtocol( PPP_CBCP_PROTOCOL );

            PPP_ASSERT(( CpIndex != (DWORD)-1 ));

            //
            // Start callback
            //

            PppLog( 1, "Callback phase started" );

            pPcb->PppPhase = PPP_NEGOTIATING_CALLBACK;

            pCpCb = GetPointerToCPCB( pPcb, CpIndex );

            if ( NULL == pCpCb )
            {
                return( FALSE );
            }

            pCpCb->fConfigurable = TRUE;

            CbStart( pPcb, CpIndex );

            break;
        }
        else
        {
            //
            // If the remote peer did not negotiate callback during LCP and
            // the authenticated user HAS to be called back for security 
            // reasons, we bring the link down
            //

            if ( ( pPcb->fFlags & PCBFLAG_IS_SERVER ) &&
                 ( !(pPcb->fFlags & PCBFLAG_THIS_IS_A_CALLBACK) ) &&
                 ( pPcb->fCallbackPrivilege & RASPRIV_AdminSetCallback ) )
            {
                pPcb->LcpCb.dwError = ERROR_NO_DIALIN_PERMISSION;

                NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );

                //
                // We need to send an Accounting Stop if RADIUS sends an Access
                // Accept but we still drop the line.
                //

                pPcb->fFlags |= PCBFLAG_SERVICE_UNAVAILABLE;

                break;
            }
        }

        //
        // Fallthru
        //

    case PPP_NEGOTIATING_CALLBACK:

        //
        // Progress to NCP phase only if we are sure that we have passed the
        // callback phase
        //

        if ( ( pPcb->fFlags & PCBFLAG_NEGOTIATE_CALLBACK ) &&
             ( CpTable[CpIndex].CpInfo.Protocol != PPP_CBCP_PROTOCOL ) )
        {
            break;
        }

        if ( !(pPcb->fFlags & PCBFLAG_IS_SERVER) )
        {
            NotifyCaller( pPcb, PPPMSG_Projecting, NULL );
        }
        
        //
        // We may lose pPcb->pBcb when we call TryToBundleWithAnotherLink().
        // Save pPcb->pBcb->fFlags & BCBFLAG_CAN_DO_BAP first.
        //
        
        fCanDoBAP = pPcb->pBcb->fFlags & BCBFLAG_CAN_DO_BAP;

        //
        // If multilink was negotiated on this link check to see if this
        // link can be bundled and is not already bundled with another link
        //

        if ( ( pPcb->fFlags & PCBFLAG_CAN_BE_BUNDLED ) &&
             ( !(pPcb->fFlags & PCBFLAG_IS_BUNDLED ) ) )
        {
            //
            // If we are bundled with another link then skip NCP phase
            //

            dwRetCode = TryToBundleWithAnotherLink( pPcb );

            if ( dwRetCode != NO_ERROR )
            {
                pPcb->LcpCb.dwError = dwRetCode;
                
                NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );

                return( FALSE );
            }
        }

        //
        // If we are bundled
        //

        if ( pPcb->fFlags & PCBFLAG_IS_BUNDLED )
        {
            if ( pPcb->pBcb->fFlags & BCBFLAG_CAN_DO_BAP )
            {
                if ( !fCanDoBAP )
                {
                    // 
                    // A new link can join a bundle that does BAP only if the 
                    // link has negotiated Link Discriminator.
                    //
                
                    PppLog( 1, "Link to be terminated on hPort = %d because "
                            "it can't do BAP.",
                            pPcb->hPort );

                    pPcb->LcpCb.dwError = ERROR_PPP_NOT_CONVERGING;

                    NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );
                    
                    return( FALSE );
                }
                else
                {
                    //
                    // Reset the start time for the sample period. Now that the
                    // bandwidth has changed, ndiswan shouldn't ask us to bring
                    // links up or down based on what happened in the past.
                    //

                    BapSetPolicy( pPcb->pBcb );
                }

                if ( !FLinkDiscriminatorIsUnique( pPcb, &dwLinkDiscrim ) )
                {
                    PppLog( 1,
                            "New link discriminator %d to be negotiated for "
                            "port %d",
                            dwLinkDiscrim, pPcb->hPort );
                        
                    WLinkDiscriminator = (WORD) dwLinkDiscrim;
                    
                    FsmDown( pPcb, LCP_INDEX );

                    ((LCPCB*)
                     (pPcb->LcpCb.pWorkBuf))->Local.Work.dwLinkDiscriminator =
                        dwLinkDiscrim;

                    FsmUp( pPcb, LCP_INDEX );

                    return( FALSE );
                }
            }
            
            //
            // Get state of bundle NCPs
            //

            dwNcpState = QueryBundleNCPState( pPcb );

            switch ( dwNcpState )
            { 
            case NCP_CONFIGURING:

                pPcb->PppPhase = PPP_NCP;

                PppLog(2,"Bundle NCPs not done for port %d, wait", pPcb->hPort);

                NotifyCaller( pPcb, PPPDDMMSG_NewLink, NULL );

                break;

            case NCP_DOWN:

                pPcb->PppPhase = PPP_NCP;

                pPcb->LcpCb.dwError = ERROR_PPP_NO_PROTOCOLS_CONFIGURED;

                NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );

                return( FALSE );

            case NCP_UP:

                pPcb->PppPhase = PPP_NCP;

                NotifyCaller( pPcb, PPPDDMMSG_NewLink, NULL );

                NotifyCallerOfBundledProjection( pPcb );

                RemoveFromTimerQ( pPcb->dwPortId,  
                                  0, 
                                  0, 
                                  FALSE,
                                  TIMER_EVENT_NEGOTIATETIME );

                StartAutoDisconnectForPort( pPcb );
                                StartLCPEchoForPort ( pPcb );
                MakeStartAccountingCall( pPcb );

                break;

            case NCP_DEAD:

                //
                // NCPs still have not started so notify DDM that this a 
                // new bundle and get interface handles for this new bundle.
                //

                NotifyCaller( pPcb, PPPDDMMSG_NewBundle, NULL );

                break;
            }

            return( TRUE );
        }

        //
        // We are a client so we have all the interface handles already.
        // We are not part of a bundle, so initialize all NCPs
        //

        if ( !(pPcb->fFlags & PCBFLAG_IS_SERVER) ) 
        {
            dwRetCode = InitializeNCPs( pPcb, pPcb->ConfigInfo.dwConfigMask );

            if ( dwRetCode != NO_ERROR )
            {
                pPcb->LcpCb.dwError = dwRetCode;

                NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );

                return( FALSE );
            }

            // 
            // Start NCPs
            //

            StartNegotiatingNCPs( pPcb );
        
        }
        else
        {
            //
            // Take care of the RAS server policy on workstation. If we have 
            // already checked the policy for this link, don't check again.
            //

            if (    ( PppConfigInfo.fFlags & PPPCONFIG_FLAG_WKSTA )
                && !( pPcb->pBcb->fFlags & BCBFLAG_WKSTA_IN ) )
            {
                //
                // We did not bundle with another link. Allow atmost one
                // dial in client in each class.
                //

                if (   (   (pPcb->dwDeviceType & RDT_Tunnel)
                        && (PppConfigInfo.fFlags & PPPCONFIG_FLAG_TUNNEL))
                    || (   (pPcb->dwDeviceType & RDT_Direct)
                        && (PppConfigInfo.fFlags & PPPCONFIG_FLAG_DIRECT))
                    || (   !(pPcb->dwDeviceType & RDT_Tunnel)
                        && !(pPcb->dwDeviceType & RDT_Direct)
                        && (PppConfigInfo.fFlags & PPPCONFIG_FLAG_DIALUP)))
                {
                    pPcb->LcpCb.dwError = ERROR_USER_LIMIT;

                    PppLog( 2, "User limit reached. Flags: %d",
                            PppConfigInfo.fFlags );

                    NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );

                    return( FALSE );
                }

                if ( pPcb->dwDeviceType & RDT_Tunnel )
                {
                    PppConfigInfo.fFlags |= PPPCONFIG_FLAG_TUNNEL;
                }
                else if ( pPcb->dwDeviceType & RDT_Direct )
                {
                    PppConfigInfo.fFlags |= PPPCONFIG_FLAG_DIRECT;
                }
                else
                {
                    PppConfigInfo.fFlags |= PPPCONFIG_FLAG_DIALUP;
                }

                pPcb->pBcb->fFlags |= BCBFLAG_WKSTA_IN;
            }

            //
            // Increase client license count if we are on the recieving end
            // of the call.
            //

            if ( pPcb->pBcb->hLicense == INVALID_HANDLE_VALUE )
            {
                LS_STATUS_CODE      LsStatus;
                NT_LS_DATA          NtLSData;

                NtLSData.DataType    = NT_LS_USER_NAME;
                NtLSData.Data        = pPcb->pBcb->szLocalUserName;
                NtLSData.IsAdmin     = FALSE;

                LsStatus = NtLicenseRequest( 
                                "REMOTE_ACCESS",
                                "",  
                                (LS_HANDLE*)&(pPcb->pBcb->hLicense),
                                &NtLSData );

                if ( LsStatus != LS_SUCCESS )
                {
                    pPcb->LcpCb.dwError = 
                                ( LsStatus == LS_RESOURCES_UNAVAILABLE ) 
                                ? ERROR_OUTOFMEMORY
                                : ERROR_REQ_NOT_ACCEP;

                    NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );

                    return( FALSE );
                }
            }

            //
            // We are DDM and this is a new Bundle. 
            //

            NotifyCaller( pPcb, PPPDDMMSG_NewBundle, NULL );
        }

        break;

    case PPP_NCP:

        //
        // If we are a client and got rechallenged and we responded while we 
        // were in the NCP state then we are done.
        //

        pLcpCb = (LCPCB*)(pPcb->LcpCb.pWorkBuf);

        if ( pLcpCb->Remote.Work.AP != 0 )
        {
            if ( CpIndex == GetCpIndexFromProtocol( pLcpCb->Remote.Work.AP ) )
            {
                break;
            }
        }

        //
        // If we are a server and we got another auth request while we were
        // in NCP state, we are done
        //

        if ( pLcpCb->Local.Work.AP != 0 )
        {
            if ( CpIndex == GetCpIndexFromProtocol( pLcpCb->Local.Work.AP ) )
            {
                break;
            }
        }

        if ( NULL == pCpCb )
        {
            return( FALSE );
        }

        pCpCb->NcpPhase = NCP_UP;

        if ( ( CpTable[CpIndex].CpInfo.Protocol == PPP_NBFCP_PROTOCOL ) ||
             ( CpTable[CpIndex].CpInfo.Protocol == PPP_IPCP_PROTOCOL ) )
        {
            if ( !NotifyIPCPOfNBFCPProjection( pPcb, CpIndex ) )
            {
                return( FALSE );
            }
        }

        dwRetCode = AreNCPsDone(pPcb, CpIndex, &ProjectionResult, &fAreCPsDone);

        //
        // We failed to get information from CP with CpIndex.
        //

        if ( dwRetCode != NO_ERROR )
        {
            return( FALSE );
        }

        if ( fAreCPsDone == TRUE )
        {
            RemoveFromTimerQ( pPcb->dwPortId,  
                              0, 
                              0, 
                              FALSE,
                              TIMER_EVENT_NEGOTIATETIME );

            //
            // Notify the ras client and the ras server about the projections
            //

            if ( pPcb->fFlags & PCBFLAG_IS_SERVER ) 
            {
                NotifyCaller( pPcb, PPPDDMMSG_PppDone, &ProjectionResult );
            }
            else
            {
                RASMAN_INFO rasmanInfo;

                NotifyCaller(pPcb, PPPMSG_ProjectionResult, &ProjectionResult);

                NotifyCaller(pPcb, PPPMSG_PppDone, NULL);

                if ( RasGetInfo(NULL, pPcb->hPort, &rasmanInfo ) == NO_ERROR )
                {
                    RasSetConnectionUserData(
                                         rasmanInfo.RI_ConnectionHandle,
                                         1,
                                         (PBYTE)&ProjectionResult,
                                         sizeof( ProjectionResult ) );
                }
            }

            StartAutoDisconnectForPort( pPcb );
                        StartLCPEchoForPort ( pPcb );

            if ( !( pPcb->fFlags & PCBFLAG_IS_SERVER )  &&
                 !( pPcb->fFlags & PCBFLAG_CONNECTION_LOGGED ) )
            {
                LPSTR lpsSubStringArray[3];

                lpsSubStringArray[0] = pPcb->pBcb->szLocalUserName;
                lpsSubStringArray[1] = pPcb->pBcb->szEntryName; 
                lpsSubStringArray[2] = pPcb->szPortName;
        
                PppLogInformation( ROUTERLOG_CONNECTION_ESTABLISHED, 
                                   3,
                                   lpsSubStringArray );

                pPcb->fFlags |= PCBFLAG_CONNECTION_LOGGED;
            }

            //
            // If we are bundled, then we need to notify all other bundled ports
            // that PPP on that port is done too.
            //

            if ( pPcb->fFlags & PCBFLAG_IS_BUNDLED )
            {
                NotifyCompletionOnBundledPorts( pPcb );
            }

            MakeStartAccountingCall( pPcb );
        }

        break;

    default:

        break;
    }

    return( TRUE );
        
}

//**
//
// Call:        FsmThisLayerDown
//
// Returns:     TRUE  - Success
//              FALSE - Otherwise
//
// Description: Called when leaving the OPENED state.
//
BOOL
FsmThisLayerDown(
    IN PCB * pPcb,
    IN DWORD CpIndex
)
{
    DWORD       dwRetCode;
    DWORD       dwIndex;
    LCPCB *     pLcpCb;
    CPCB *      pCpCb = GetPointerToCPCB( pPcb, CpIndex );

    if ( pCpCb == NULL )
    {
        return( FALSE );
    }

    PppLog( 1, "FsmThisLayerDown called for protocol = %x, port = %d",
               CpTable[CpIndex].CpInfo.Protocol, pPcb->hPort );

    if ( CpTable[CpIndex].CpInfo.RasCpThisLayerDown != NULL )
    {
        dwRetCode = (CpTable[CpIndex].CpInfo.RasCpThisLayerDown)(
                        pCpCb->pWorkBuf );

        if ( dwRetCode != NO_ERROR )
        {
            PppLog( 1, "FsmThisLayerDown for protocol=%x,port=%d,RetCode=%d",
                        CpTable[CpIndex].CpInfo.Protocol,
                        pPcb->hPort,
                        dwRetCode );

            if ( pCpCb->dwError != NO_ERROR )
            {
                pCpCb->dwError = dwRetCode;
            }
        }
    }

    if ( CpIndex == LCP_INDEX )
    {
        //
        // If this port is not part of a bundle, or it is but is the only
        // remaining link in the bundle, then bring all the NCPs down.
        //

        if (  (!( pPcb->fFlags & PCBFLAG_IS_BUNDLED )) ||
              ( ( pPcb->fFlags & PCBFLAG_IS_BUNDLED ) &&
                ( pPcb->pBcb->dwLinkCount == 1 ) ) )
        {
            //
            // Bring all the NCPs down
            //
        
            for( dwIndex = LCP_INDEX+1; 
                 dwIndex < PppConfigInfo.NumberOfCPs;  
                 dwIndex++ )
            {
                pCpCb = GetPointerToCPCB( pPcb, dwIndex );

                if (   ( NULL != pCpCb )
                    && ( pCpCb->fConfigurable ) )
                {
                    FsmDown( pPcb, dwIndex );
                }
            }
        }

        pPcb->PppPhase = PPP_LCP;

        pLcpCb = (LCPCB*)(pPcb->LcpCb.pWorkBuf);

        dwIndex = GetCpIndexFromProtocol( pLcpCb->Local.Work.AP );
        
        if ( dwIndex != (DWORD)-1 )
        {
            ApStop( pPcb, dwIndex, TRUE );

            //
            // Setting this will allow all outstanding request that are
            // completed to be dropped
            //

            pPcb->dwOutstandingAuthRequestId = 0xFFFFFFFF;
        }

        dwIndex = GetCpIndexFromProtocol( pLcpCb->Remote.Work.AP );

        if ( dwIndex != (DWORD)-1 )
        {
            ApStop( pPcb, dwIndex, FALSE );
        }

        dwIndex = GetCpIndexFromProtocol( PPP_CBCP_PROTOCOL );

        if ( dwIndex != (DWORD)-1 )
        {
            CbStop( pPcb, dwIndex );
        }
    }
    else
    {
        pCpCb->NcpPhase = NCP_CONFIGURING;
    }

    return( TRUE );
}

//**
//
// Call:        FsmThisLayerStarted
//
// Returns:     TRUE  - Success
//              FALSE - Otherwise
//
// Description: Called when leaving the OPENED state.
//
BOOL
FsmThisLayerStarted(
    IN PCB *    pPcb,
    IN DWORD    CpIndex
)
{
    DWORD   dwRetCode;
    CPCB*   pCpCb       = GetPointerToCPCB( pPcb, CpIndex );

    if ( pCpCb == NULL )
    {
        return( FALSE );
    }

    PppLog( 1, "FsmThisLayerStarted called for protocol = %x, port = %d",
               CpTable[CpIndex].CpInfo.Protocol, pPcb->hPort );

    if ( CpTable[CpIndex].CpInfo.RasCpThisLayerStarted != NULL )
    {
        dwRetCode = (CpTable[CpIndex].CpInfo.RasCpThisLayerStarted)(
                        pCpCb->pWorkBuf);

        if ( dwRetCode != NO_ERROR )
        {
            pCpCb->dwError = dwRetCode;

            FsmClose( pPcb, CpIndex );

            return( FALSE );
        }
    }

    pCpCb->NcpPhase = NCP_CONFIGURING;

    return( TRUE );

}

//**
//
// Call:        FsmThisLayerFinished
//
// Returns:     TRUE  - Success
//              FALSE - Otherwise
//
// Description: Called when leaving the OPENED state.
//
BOOL
FsmThisLayerFinished(
    IN PCB * pPcb,
    IN DWORD CpIndex,
    IN BOOL  fCallCp
)
{
    DWORD                 dwRetCode;
    PPP_PROJECTION_RESULT ProjectionResult;
    CPCB *                pCpCb             = GetPointerToCPCB( pPcb, CpIndex );
    BOOL                  fAreCPsDone       = FALSE;

    if ( pCpCb == NULL )
    {
        return( FALSE );
    }

    PppLog( 1, "FsmThisLayerFinished called for protocol = %x, port = %d",
               CpTable[CpIndex].CpInfo.Protocol, pPcb->hPort );

    if ( ( CpTable[CpIndex].CpInfo.RasCpThisLayerFinished != NULL )
         && ( fCallCp ) )
    {
        dwRetCode = (CpTable[CpIndex].CpInfo.RasCpThisLayerFinished)(
                        pCpCb->pWorkBuf);

        if ( dwRetCode != NO_ERROR )
        {
            NotifyCallerOfFailure( pPcb,  dwRetCode );

            return( FALSE );
        }
    }

    //
    // Take care of special cases first.
    //

    switch ( CpTable[CpIndex].CpInfo.Protocol )
    {
    case PPP_LCP_PROTOCOL:

        //
        // If we are in the callback phase and LCP went down because of an
        // error.
        //

        //
        // If we LCP layer is finished and we are doing a callback
        //

        if ( pPcb->fFlags & PCBFLAG_DOING_CALLBACK ) 
        {
            if ( !(pPcb->fFlags & PCBFLAG_IS_SERVER) )
            {
                PppLog( 2, "pPcb->fFlags = %x", pPcb->fFlags ) ;

                NotifyCaller( pPcb, PPPMSG_Callback, NULL );

                //
                // We unset this flag now because if we get another 
                // FsmClose, it will call FsmThisLayerFinished (this routine)
                // again, and this time we will need to send a failure
                // message back, not Callback, so that the client can 
                // clean up.
                //

                pPcb->fFlags &= ~PCBFLAG_DOING_CALLBACK;
                
                return( TRUE );
            }
        }
        else
        {
            //
            // If this port is not part of a bundle, or it is but is the only
            // remaining link in the bundle, then call ThisLayerFinished for all
            // NCPs.
            //

            if (  (!( pPcb->fFlags & PCBFLAG_IS_BUNDLED )) ||
                  ( ( pPcb->fFlags & PCBFLAG_IS_BUNDLED ) &&
                    ( pPcb->pBcb->dwLinkCount == 1 ) ) )
            {
                DWORD   dwIndex;
                CPCB *  pNcpCb;

                for( dwIndex = LCP_INDEX+1; 
                     dwIndex < PppConfigInfo.NumberOfCPs;  
                     dwIndex++ )
                {
                    pNcpCb = GetPointerToCPCB( pPcb, dwIndex );

                    if ( pNcpCb->fConfigurable )
                    {
                        if ( NULL !=
                             CpTable[dwIndex].CpInfo.RasCpThisLayerFinished )
                        {
                            dwRetCode =
                                (CpTable[dwIndex].CpInfo.RasCpThisLayerFinished)
                                        (pNcpCb->pWorkBuf);

                            PppLog( 1, "FsmThisLayerFinished called for "
                                "protocol = %x, port = %d: %d",
                               CpTable[dwIndex].CpInfo.Protocol, pPcb->hPort,
                               dwRetCode );

                           dwRetCode = NO_ERROR;
                        }
                    }
                }
            }

            pPcb->fFlags |= PCBFLAG_STOPPED_MSG_SENT;

            NotifyCaller( pPcb,
                          ( pPcb->fFlags & PCBFLAG_IS_SERVER )
                                ? PPPDDMMSG_Stopped
                                : PPPMSG_Stopped,
                          &(pPcb->LcpCb.dwError) );

            return( FALSE );
        }

        break;

    case PPP_CCP_PROTOCOL:

        //
        // If we need to force encryption but encryption negotiation failed
        // then we drop the link
        //

        if ( pPcb->ConfigInfo.dwConfigMask & (PPPCFG_RequireEncryption      |
                                              PPPCFG_RequireStrongEncryption ) )
        {
            switch( pCpCb->dwError )
            {
            case ERROR_NO_LOCAL_ENCRYPTION:
            case ERROR_NO_REMOTE_ENCRYPTION:
                pPcb->LcpCb.dwError = pCpCb->dwError;
                break;

            case ERROR_PROTOCOL_NOT_CONFIGURED:
                pPcb->LcpCb.dwError = ERROR_NO_LOCAL_ENCRYPTION;
                break;

            default:
                pPcb->LcpCb.dwError = ERROR_NO_REMOTE_ENCRYPTION;
                break;
            }

            //
            // We need to send an Accounting Stop if RADIUS sends
            // an Access Accept but we still drop the line.
            //

            pPcb->fFlags |= PCBFLAG_SERVICE_UNAVAILABLE;

            NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );

            return( FALSE );
        }

        break;

    default:
        break;
    }

    switch( pPcb->PppPhase )
    {

    case PPP_NCP:

        //
        // This NCP failed to be configured. If there are more then
        // try to configure them.
        //

        pCpCb->NcpPhase = NCP_DOWN;

        if ( ( CpTable[CpIndex].CpInfo.Protocol == PPP_NBFCP_PROTOCOL ) ||
             ( CpTable[CpIndex].CpInfo.Protocol == PPP_IPCP_PROTOCOL ) )
        {
            if ( !NotifyIPCPOfNBFCPProjection( pPcb, CpIndex ) )
            {
                return( FALSE );
            }
        }

        //
        // Check to see if we are all done
        //

        dwRetCode = AreNCPsDone(pPcb, CpIndex, &ProjectionResult, &fAreCPsDone);

        //
        // We failed to get information from CP with CpIndex.
        //

        if ( dwRetCode != NO_ERROR )
        {
            return( FALSE );
        }

        if ( fAreCPsDone == TRUE )
        {
            RemoveFromTimerQ( pPcb->dwPortId, 
                              0,        
                              0,        
                              FALSE,
                              TIMER_EVENT_NEGOTIATETIME );

               
            //
            // Notify the ras client and the ras server about the projections
            //

            if ( pPcb->fFlags & PCBFLAG_IS_SERVER ) 
            {
                NotifyCaller( pPcb, PPPDDMMSG_PppDone, &ProjectionResult );
            }
            else
            {
                RASMAN_INFO rasmanInfo;

                NotifyCaller(pPcb, PPPMSG_ProjectionResult, &ProjectionResult);

                NotifyCaller(pPcb, PPPMSG_PppDone, NULL);

                //
                // We call RasSetConnectionUserData in FsmThisLayerUp and 
                // FsmThisLayerFinished, in case an NCP is renegotiated. An 
                // PPPMSG_ProjectionResult sent after PPPMSG_PppDone is ignored.
                // This is a bad hack. The real fix is to change RasDialMachine 
                // such that PPPMSG_ProjectionResult is not ignored.
                //

                //
                // We are commenting out RasSetConnectionUserData to work 
                // around bug 375125. A multilink call was made and the two 
                // links connected to two different servers. The second link 
                // only should go down in this case. However, IPCP failed 
                // for the second link, and RasSetConnectionUserData marked 
                // IPCP as failed for the first link also. Both links came down.
                //

#if 0
                if ( RasGetInfo(NULL, pPcb->hPort, &rasmanInfo ) == NO_ERROR )
                {
                    RasSetConnectionUserData( 
                                         rasmanInfo.RI_ConnectionHandle,
                                         1,
                                         (PBYTE)&ProjectionResult,
                                         sizeof( ProjectionResult ) );
                }
#endif
            }

            StartAutoDisconnectForPort( pPcb );
                        StartLCPEchoForPort ( pPcb );

            //
            // If we are bundled, then we need to notify all other bundled ports
            // that PPP on that port is done too.
            //

            if ( pPcb->fFlags & PCBFLAG_IS_BUNDLED )
            {
                NotifyCompletionOnBundledPorts( pPcb );
            }

            MakeStartAccountingCall( pPcb );
        }

        break;

    case PPP_AP:
    default:
        break;
  
    }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\engine\smevents.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    smevents.h
//
// Description: Prototypes for procedures contained in smevents.c
//
// History:
//      Nov 11,1993.    NarenG          Created original version.
//

VOID
FsmUp(
    IN PCB *    pPcb,
    IN DWORD    CpIndex
);


VOID
FsmOpen(
    IN PCB *    pPcb,
    IN DWORD    CpIndex
);

VOID
FsmDown(
    IN PCB *    pPcb,
    IN DWORD    CpIndex
);

VOID
FsmClose(
    IN PCB *    pPcb,
    IN DWORD    CpIndex
);

VOID
FsmTimeout(
    PCB *       pPcb,
    DWORD       CpIndex,
    DWORD       Id,
    BOOL        fAuthenticator
);

VOID
FsmReceive(
    IN PCB *            pPcb,
    IN PPP_PACKET *     pPacket,
    IN DWORD            dwPacketLength
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\engine\smaction.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    smaction.h
//
// Description: Function prototypes for smaction.c
//
// History:
//      Nov 11,1993.    NarenG          Created original version.
//

BOOL
FsmSendConfigReq(
    IN PCB *        pPcb,
    IN DWORD        CpIndex,
    IN BOOL         fTimeout
);

BOOL
FsmSendTermReq(
    IN PCB *        pPcb,
    IN DWORD        CpIndex
);

BOOL
FsmSendTermAck( 
    IN PCB *        pPcb, 
    IN DWORD        CpIndex, 
    IN PPP_CONFIG * pRecvConfig
);

BOOL
FsmSendConfigResult(
    IN PCB *        pPcb,
    IN DWORD        CpIndex,
    IN PPP_CONFIG * pRecvConfig,
    IN BOOL *       pfAcked
);

BOOL
FsmSendEchoRequest(
    IN PCB *        pPcb,   
	IN DWORD        CpIndex
);

BOOL
FsmSendEchoReply(
    IN PCB *        pPcb,
    IN DWORD        CpIndex,
    IN PPP_CONFIG * pRecvConfig
);

BOOL
FsmSendCodeReject( 
    IN PCB *        pPcb, 
    IN DWORD        CpIndex,
    IN PPP_CONFIG * pRecvConfig 
);

BOOL
FsmSendProtocolRej( 
    IN PCB *        pPcb, 
    IN PPP_PACKET * pPacket,
    IN DWORD        dwPacketLength
);

BOOL
FsmThisLayerUp(
    IN PCB *        pPcb,
    IN DWORD        CpIndex
);

BOOL
FsmThisLayerStarted(
    IN PCB *        pPcb,
    IN DWORD        CpIndex
);

BOOL
FsmThisLayerFinished(
    IN PCB *        pPcb,
    IN DWORD        CpIndex,
    IN BOOL         fCallCp
);

BOOL
FsmThisLayerDown(
    IN PCB *        pPcb,
    IN DWORD        CpIndex
);

BOOL
FsmInit(
    IN PCB *        pPcb,
    IN DWORD        CpIndex
);

BOOL
FsmReset(
    IN PCB *        pPcb,
    IN DWORD        CpIndex
);

BOOL
FsmSendIdentification(
    IN PCB *        pPcb,
    IN BOOL         fSendVersion
);

BOOL
FsmSendTimeRemaining(
    IN PCB *        pPcb
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\engine\receive.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    receive.h
//
// Description: Contains function prototype for the receive.c module
//
// History:
//      Nov 11,1993.    NarenG          Created original version.
//

VOID
ReceiveProtocolRej(     
    IN PCB*             pPcb,
    IN PPP_PACKET*      pPacket 
);

VOID
ReceiveUnknownCode(     
    IN PCB *            pPcb, 
    IN DWORD            CpIndex,
    IN CPCB *           pCpCb,
    IN PPP_CONFIG *     pRecvConfig 
);

VOID
ReceiveConfigReq(       
    IN PCB *            pPcb,
    IN DWORD            CpIndex,
    IN CPCB *           pCpCb,
    IN PPP_CONFIG *     pRecvConfig
);

VOID
ReceiveConfigAck(       
    IN PCB *            pPcb,
    IN DWORD            CpIndex,
    IN CPCB *           pCpCb,
    IN PPP_CONFIG *     pRecvConfig
);

VOID
ReceiveConfigNakRej(    
    IN PCB *            pPcb,
    IN DWORD            CpIndex,
    IN CPCB *           pCpCb,
    IN PPP_CONFIG *     pRecvConfig
);

VOID
ReceiveTermReq(         
    IN PCB *            pPcb,
    IN DWORD            CpIndex,
    IN CPCB *           pCpCb,
    IN PPP_CONFIG *     pRecvConfig
);

VOID
ReceiveTermAck(         
    IN PCB *            pPcb,
    IN DWORD            CpIndex,
    IN CPCB *           pCpCb,
    IN PPP_CONFIG *     pRecvConfig
);

VOID
ReceiveCodeRej(         
    IN PCB *            pPcb,
    IN DWORD            CpIndex,
    IN CPCB *           pCpCb,
    IN PPP_CONFIG*      pRecvConfig
);

VOID
ReceiveEchoReq(         
    IN PCB *            pPcb,
    IN DWORD            CpIndex,
    IN CPCB *           pCpCb,
    IN PPP_CONFIG *     pRecvConfig
);

VOID
ReceiveEchoReply(       
    IN PCB *            pPcb,
    IN DWORD            CpIndex,
    IN CPCB *           pCpCb,
    IN PPP_CONFIG *     pRecvConfig
);

VOID
ReceiveDiscardReq(      
    IN PCB *            pPcb,
    IN DWORD            CpIndex,
    IN CPCB *           pCpCb,
    IN PPP_CONFIG*      pRecvConfig
);

VOID 
CompletionRoutine(  
    IN HCONN            hPortOrConnection,
    IN DWORD            Protocol,
    IN PPP_CONFIG *     pSendConfig,
    IN DWORD            dwError 
);

BOOL
FsmConfigResultReceived( 
    IN PCB *            pPcb, 
    IN DWORD            CpIndex,
    IN PPP_CONFIG *     pReceiveConfig 
);

VOID
ReceiveIdentification( 
    IN PCB *            pPcb, 
    IN DWORD            CpIndex,
    IN CPCB *           pCpCb,
    IN PPP_CONFIG *     pRecvConfig
);

VOID
ReceiveTimeRemaining( 
    IN PCB *            pPcb, 
    IN DWORD            CpIndex,
    IN CPCB *           pCpCb,
    IN PPP_CONFIG *     pRecvConfig
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\engine\timer.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    timer.c
//
// Description: All timer queue related funtions live here.
//
// History:
//      Nov 11,1993.    NarenG          Created original version.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>     // needed for winbase.h

#include <windows.h>    // Win32 base API's
#include <stdlib.h>
#include <string.h>
#include <wchar.h>

#include <lmcons.h>
#include <rasman.h>
#include <mprlog.h>
#include <rasppp.h>
#include <pppcp.h>
#include <ppp.h>
#include <util.h>
#include <worker.h>
#include <timer.h>

//**
//
// Call:    MakeTimeoutWorkItem
//
// Returns: PCB_WORK_ITEM * - Pointer to the timeout work item
//          NULL            - On any error.
//
// Description:
//
PCB_WORK_ITEM *
MakeTimeoutWorkItem(
    IN DWORD            dwPortId,
    IN HPORT            hPort,
    IN DWORD            Protocol,
    IN DWORD            Id,
    IN BOOL             fAuthenticator,
    IN TIMER_EVENT_TYPE EventType
)
{
    PCB_WORK_ITEM * pWorkItem = (PCB_WORK_ITEM *)
                LOCAL_ALLOC( LPTR, sizeof( PCB_WORK_ITEM ) );

    if ( pWorkItem == (PCB_WORK_ITEM *)NULL )
    {
        LogPPPEvent( ROUTERLOG_NOT_ENOUGH_MEMORY, 0 );

        return( NULL );
    }

    pWorkItem->dwPortId         = dwPortId;
    pWorkItem->Id               = Id;
    pWorkItem->hPort            = hPort;
    pWorkItem->Protocol         = Protocol;
    pWorkItem->fAuthenticator   = fAuthenticator;
    pWorkItem->TimerEventType   = EventType;
    pWorkItem->Process          = ProcessTimeout;

    return( pWorkItem );
}

//**
//
// Call:        TimerTick
//
// Returns:     None.
//
// Description: Called each second if there are elements in the timeout queue.
//
VOID
TimerTick(
    OUT BOOL * pfQueueEmpty
)
{
    TIMER_EVENT * pTimerEvent;
    TIMER_EVENT * pTimerEventTmp;


    if ( ( pTimerEvent = TimerQ.pQHead ) == (TIMER_EVENT*)NULL ) 
    {
        *pfQueueEmpty = TRUE;

        return;
    }

    *pfQueueEmpty = FALSE;

    //
    // Decrement time on the first element 
    //

    if ( pTimerEvent->Delta > 0 )
    {
        (pTimerEvent->Delta)--; 

        return;
    }

    //
    // Now run through and remove all completed (delta 0) elements.
    //

    while ( (pTimerEvent != (TIMER_EVENT*)NULL) && (pTimerEvent->Delta == 0) ) 
    {
        pTimerEvent = pTimerEvent->pNext;
    }

    if ( pTimerEvent == (TIMER_EVENT*)NULL )
    {
        pTimerEvent = TimerQ.pQHead;

        TimerQ.pQHead = (TIMER_EVENT*)NULL;

    }
    else
    {
        pTimerEvent->pPrev->pNext = (TIMER_EVENT*)NULL;

        pTimerEvent->pPrev = (TIMER_EVENT*)NULL;

        pTimerEventTmp     = TimerQ.pQHead;

        TimerQ.pQHead      = pTimerEvent;

        pTimerEvent        = pTimerEventTmp;
    }

    //
    // Now make a timeout work item and put it in the work item Q for all the
    // items with delta == 0
    //

    while( pTimerEvent != (TIMER_EVENT*)NULL )
    {

        PCB_WORK_ITEM * pWorkItem = MakeTimeoutWorkItem(
                                                pTimerEvent->dwPortId,
                                                pTimerEvent->hPort,
                                                pTimerEvent->Protocol,
                                                pTimerEvent->Id,
                                                pTimerEvent->fAuthenticator,
                                                pTimerEvent->EventType );

        if ( pWorkItem == ( PCB_WORK_ITEM *)NULL )
        {
            LogPPPEvent( ROUTERLOG_NOT_ENOUGH_MEMORY, GetLastError() );
        }
        else
        {
            InsertWorkItemInQ( pWorkItem );
        }

        if ( pTimerEvent->pNext == (TIMER_EVENT *)NULL )
        {
            LOCAL_FREE( pTimerEvent );

            pTimerEvent = (TIMER_EVENT*)NULL;
        }
        else
        {
            pTimerEvent = pTimerEvent->pNext;

            LOCAL_FREE( pTimerEvent->pPrev );
        }

    }

}

//**
//
// Call:        InsertInTimerQ
//
// Returns:     NO_ERROR                        - Success
//              return from GetLastError()      - Failure
//
// Description: Adds a timeout element into the delta queue. If the Timer is not
//              started it is started. Since there is a LocalAlloc() call here -
//              this may fail in which case it will simply not insert it in the
//              queue and the request will never timeout. BAP passes in an HCONN in 
//              hPort.
//
DWORD
InsertInTimerQ(
    IN DWORD            dwPortId,
    IN HPORT            hPort,
    IN DWORD            Id,
    IN DWORD            Protocol,
    IN BOOL             fAuthenticator,
    IN TIMER_EVENT_TYPE EventType,
    IN DWORD            Timeout
)
{
    TIMER_EVENT * pLastEvent;
    TIMER_EVENT * pTimerEventWalker;
    TIMER_EVENT * pTimerEvent = (TIMER_EVENT *)LOCAL_ALLOC( LPTR,
                                                           sizeof(TIMER_EVENT));

    if ( pTimerEvent == (TIMER_EVENT *)NULL )
    {
        PppLog( 1, "InsertInTimerQ failed: out of memory" );

        return( GetLastError() );
    }

    PppLog( 2, 
            "InsertInTimerQ called portid=%d,Id=%d,Protocol=%x,"
            "EventType=%d,fAuth=%d",
            dwPortId, Id, Protocol, EventType, fAuthenticator );

    pTimerEvent->dwPortId       = dwPortId;
    pTimerEvent->Id             = Id;
    pTimerEvent->Protocol       = Protocol;
    pTimerEvent->hPort          = hPort;
    pTimerEvent->EventType      = EventType;
    pTimerEvent->fAuthenticator = fAuthenticator;
        
    for ( pTimerEventWalker = TimerQ.pQHead,
          pLastEvent        = pTimerEventWalker;

          ( pTimerEventWalker != NULL ) && 
          ( pTimerEventWalker->Delta < Timeout );

          pLastEvent        = pTimerEventWalker,
          pTimerEventWalker = pTimerEventWalker->pNext 
        )
    {
        Timeout -= pTimerEventWalker->Delta;
    }

    //
    // Insert before pTimerEventWalker. If pTimerEventWalker is NULL then 
    // we insert at the end of the list.
    //
    
    if ( pTimerEventWalker == (TIMER_EVENT*)NULL )
    {
        //
        // If the list was empty
        //

        if ( TimerQ.pQHead == (TIMER_EVENT*)NULL )
        {
            TimerQ.pQHead      = pTimerEvent;
            pTimerEvent->pNext = (TIMER_EVENT *)NULL;
            pTimerEvent->pPrev = (TIMER_EVENT *)NULL;

            //
            // Wake up thread since the Q is not empty any longer
            //

            SetEvent( TimerQ.hEventNonEmpty );
        }
        else
        {
            pLastEvent->pNext  = pTimerEvent;
            pTimerEvent->pPrev = pLastEvent;
            pTimerEvent->pNext = (TIMER_EVENT*)NULL;
        }
    }
    else if ( pTimerEventWalker == TimerQ.pQHead )
    {
        //
        // Insert before the first element
        //

        pTimerEvent->pNext   = TimerQ.pQHead;
        TimerQ.pQHead->pPrev = pTimerEvent;
        TimerQ.pQHead->Delta -= Timeout;
        pTimerEvent->pPrev   = (TIMER_EVENT*)NULL;
        TimerQ.pQHead        = pTimerEvent;
    }
    else
    {

        //
        // Insert middle element
        //

        pTimerEvent->pNext       = pLastEvent->pNext;
        pLastEvent->pNext        = pTimerEvent;
        pTimerEvent->pPrev       = pLastEvent;
        pTimerEventWalker->pPrev = pTimerEvent;
        pTimerEventWalker->Delta -= Timeout;
    }

    pTimerEvent->Delta = Timeout;

    return( NO_ERROR );
}

//**
//
// Call:        RemoveFromTimerQ
//
// Returns:     None.
//
// Description: Will remove a timeout event for a certain Id,hPort combination
//              from the delta Q.
//
VOID
RemoveFromTimerQ(
    IN DWORD            dwPortId,
    IN DWORD            Id,
    IN DWORD            Protocol,
    IN BOOL             fAuthenticator,
    IN TIMER_EVENT_TYPE EventType
)
{
    TIMER_EVENT * pTimerEvent;

    PppLog( 2, 
            "RemoveFromTimerQ called portid=%d,Id=%d,Protocol=%x,"
            "EventType=%d,fAuth=%d",
            dwPortId, Id, Protocol, EventType, fAuthenticator );

    for ( pTimerEvent = TimerQ.pQHead;

          ( pTimerEvent != (TIMER_EVENT *)NULL ) &&
            ( ( pTimerEvent->EventType != EventType ) ||
              ( pTimerEvent->dwPortId  != dwPortId )  ||
              ( ( pTimerEvent->EventType == TIMER_EVENT_TIMEOUT ) &&
                ( ( pTimerEvent->Id       != Id )       ||
                  ( pTimerEvent->Protocol != Protocol ) ||
                  ( pTimerEvent->fAuthenticator != fAuthenticator ) ) ) );
        
          pTimerEvent = pTimerEvent->pNext
        );

    //
    // If event was not found simply return.
    //

    if ( pTimerEvent == (TIMER_EVENT *)NULL )
    {
        return;
    }

    //
    // If this is the first element to be removed
    //

    if ( pTimerEvent == TimerQ.pQHead )
    {
        TimerQ.pQHead = pTimerEvent->pNext;

        if ( TimerQ.pQHead != (TIMER_EVENT *)NULL )
        {   
            TimerQ.pQHead->pPrev = (TIMER_EVENT*)NULL;
            TimerQ.pQHead->Delta += pTimerEvent->Delta;
        }
    }
    else if ( pTimerEvent->pNext == (TIMER_EVENT*)NULL )
    {
        //
        // If this was the last element to be removed
        //

        pTimerEvent->pPrev->pNext = (TIMER_EVENT*)NULL;
    }
    else
    {
        pTimerEvent->pNext->Delta += pTimerEvent->Delta;
        pTimerEvent->pPrev->pNext = pTimerEvent->pNext;
        pTimerEvent->pNext->pPrev = pTimerEvent->pPrev;
    }

    LOCAL_FREE( pTimerEvent );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\engine\timer.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    timer.h
//
// Description: Contains prototypes for the timer functionality.
//
// History:
//      Nov 11,1993.    NarenG          Created original version.
//

DWORD
TimerThread(
    IN LPVOID arg
);

VOID
TimerTick(
    OUT BOOL * pfQueueEmpty
);

DWORD
InsertInTimerQ(
    IN DWORD            dwPortId,
    IN HPORT            hPort,
    IN DWORD            Id,
    IN DWORD            Protocol,
    IN BOOL             fAuthenticator,
    IN TIMER_EVENT_TYPE EventType,
    IN DWORD            Timeout
);

VOID
RemoveFromTimerQ(
    IN DWORD            dwPortId,
    IN DWORD            Id,
    IN DWORD            Procotol,
    IN BOOL             fAuthenticator,
    IN TIMER_EVENT_TYPE EventType
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\engine\util.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    util.c
//
// Description: Contains utility routines used by the PPP engine.
//
// History:
//      Oct 31,1993.    NarenG          Created original version.
//
#define UNICODE         // This file is in UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>     // needed for winbase.h

#include <windows.h>    // Win32 base API's
#include <stdlib.h>
#include <string.h>
#include <wchar.h>

#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <rpc.h>

#include <winsock2.h>

#include <rtinfo.h>
#include <iprtrmib.h>
#include <ipinfoid.h>
#include <lmcons.h>
#include <lmwksta.h>
#include <lmapibuf.h>
#include <lmsname.h>
#include <rasman.h>
#include <rtutils.h>
#include <mprapip.h>
#include <mprlog.h>
#include <raserror.h>
#include <mprerror.h>
#include <rasppp.h>
#include <pppcp.h>
#include <ppp.h>
#include <smevents.h>
#include <smaction.h>
#include <timer.h>
#include <util.h>
#include <worker.h>
#include <bap.h>
#include <dsrole.h>
#include <ntlsapi.h>
#define INCL_RASAUTHATTRIBUTES
#include <ppputil.h>

#define PASSWORDMAGIC 0xA5

#define CLASSA_ADDR(a)  (( (*((UCHAR *)&(a))) & 0x80) == 0)
#define CLASSB_ADDR(a)  (( (*((UCHAR *)&(a))) & 0xc0) == 0x80)
#define CLASSC_ADDR(a)  (( (*((UCHAR *)&(a))) & 0xe0) == 0xc0)
#define CLASSE_ADDR(a)  ((( (*((UCHAR *)&(a))) & 0xf0) == 0xf0) && \
                        ((a) != 0xffffffff))

#define CLASSA_MASK     0x000000ff
#define CLASSB_MASK     0x0000ffff
#define CLASSC_MASK     0x00ffffff
#define CLASSD_MASK     0x000000e0
#define CLASSE_MASK     0xffffffff

#define GetClassMask(a)\
    (CLASSA_ADDR((a)) ? CLASSA_MASK : \
        (CLASSB_ADDR((a)) ? CLASSB_MASK : \
            (CLASSC_ADDR((a)) ? CLASSC_MASK : CLASSE_MASK)))

VOID ReverseString( CHAR* psz );

//**
//
// Call:        InitRestartCounters
//
// Returns:     none.
//
// Description: Will initialize all the counters for the Control Protocol
//              to their initial values.
//
VOID
InitRestartCounters( 
    IN PCB *  pPcb, 
    IN CPCB * pCpCb 
)
{
    pCpCb->ConfigRetryCount = PppConfigInfo.MaxConfigure;
    pCpCb->TermRetryCount   = PppConfigInfo.MaxTerminate;
}

//**
//
// Call:        GetPCBPointerFromhPort
//
// Returns:     PCB *   - Success
//              NULL    - Failure
//
// Description: Give an HPORT, this function will return a pointer to the
//              port control block for it.
//
PCB * 
GetPCBPointerFromhPort( 
    IN HPORT hPort 
)
{
    PCB * pPcbWalker = NULL;
    DWORD dwIndex    = HashPortToBucket( hPort );

    for ( pPcbWalker = PcbTable.PcbBuckets[dwIndex].pPorts;
          pPcbWalker != (PCB *)NULL;
          pPcbWalker = pPcbWalker->pNext
        )
    {
        if ( pPcbWalker->hPort == hPort )
            return( pPcbWalker );
    }

    return( (PCB *)NULL );

}

//**
//
// Call:        GetBCBPointerFromhConnection
//
// Returns:     BCB *   - Success
//              NULL    - Failure
//
// Description: Given an HCONN, this function will return a pointer to the
//              bundle control block for it.
//
BCB * 
GetBCBPointerFromhConnection( 
    IN HCONN hConnection
)
{
    BCB * pBcbWalker = NULL;
    DWORD dwIndex    = HashPortToBucket( hConnection );

    for ( pBcbWalker = PcbTable.BcbBuckets[dwIndex].pBundles;
          pBcbWalker != (BCB *)NULL;
          pBcbWalker = pBcbWalker->pNext
        )
    {
        if ( pBcbWalker->hConnection == hConnection )
            return( pBcbWalker );
    }

    return( (BCB *)NULL );
}

//**
//
// Call:    NumLinksInBundle
//
// Returns: The number of links whose LCP is in the Opened state in the bundle
//          represented by pBcb
//
DWORD
NumLinksInBundle(
    IN BCB * pBcb
)
{
    DWORD   dwForIndex;
    PCB *   pPcb;
    CPCB *  pCpCb;
    DWORD   dwNumLinks  = 0;

    PPP_ASSERT( NULL != pBcb );

    for (dwForIndex = 0; dwForIndex < pBcb->dwPpcbArraySize; dwForIndex++)
    {
        pPcb = pBcb->ppPcb[dwForIndex];

        if ( NULL == pPcb )
        {
            continue;
        }

        pCpCb = GetPointerToCPCB( pPcb, LCP_INDEX );
        PPP_ASSERT( NULL != pCpCb );

        if ( FSM_OPENED == pCpCb->State )
        {
            dwNumLinks += 1;
        }
    }

    return( dwNumLinks );
}

//**
//
// Call:    GetPCBPointerFromBCB
//
// Returns: PCB *   - Success
//          NULL    - Failure
//
// Description: Given a BCB*, this function will return a pointer to the
//      PCB in it with the highest dwSubEntryIndex.
//
PCB * 
GetPCBPointerFromBCB( 
    IN BCB * pBcb
)
{
    DWORD   dwForIndex;
    PCB *   pPcb            = NULL;
    PCB *   pPcbTemp;
    CPCB *  pCpCb;
    DWORD   dwSubEntryIndex = 0;

    if ( pBcb == NULL )
    {
        return( NULL );
    }

    for (dwForIndex = 0; dwForIndex < pBcb->dwPpcbArraySize; dwForIndex++)
    {
        if ( ( pPcbTemp = pBcb->ppPcb[dwForIndex] ) != NULL )
        {
            pCpCb = GetPointerToCPCB( pPcbTemp, LCP_INDEX );
            PPP_ASSERT( NULL != pCpCb );

            if ( FSM_OPENED == pCpCb->State )
            {
                if ( pPcbTemp->dwSubEntryIndex >= dwSubEntryIndex )
                {
                    pPcb = pPcbTemp;
                    dwSubEntryIndex = pPcbTemp->dwSubEntryIndex;
                }
            }
        }
    }

    return( pPcb );
}

//**
//
// Call:        HashPortToBucket
//
// Returns:     Index into the PcbTable for the HPORT passed in.
//
// Description: Will hash the HPORT to a bucket index in the PcbTable.
//
DWORD
HashPortToBucket(
    IN HPORT hPort
)
{
    return( (HandleToUlong(hPort)) % PcbTable.NumPcbBuckets );
}

//**
//
// Call:        InsertWorkItemInQ
//
// Returns:     None.
//
// Description: Inserts a work item in to the work item Q.
//
VOID
InsertWorkItemInQ(
    IN PCB_WORK_ITEM * pWorkItem
)
{
    //
    // Take Mutex around work item Q
    //

    EnterCriticalSection( &(WorkItemQ.CriticalSection) );

    if ( WorkItemQ.pQTail != (PCB_WORK_ITEM *)NULL )
    {
        WorkItemQ.pQTail->pNext = pWorkItem;
        WorkItemQ.pQTail = pWorkItem;

        if ( ProcessLineDown == pWorkItem->Process )
        {
            //
            // If a lot of work items are coming in, the worker thread may get 
            // overwhelmed and the following might happen in the work item Q:
            // IPCP(port 1)-LineDown(1)-LineUp(1)
            // We will send the reply to the IPCP packet to the wrong (ie new)
            // peer.
            // Proposed solution: Insert a LineDown at the beginning of the 
            // queue, as well as at the end:
            // LineDown(1)-IPCP(port 1)-LineDown(1)-LineUp(1).
            // However, this will not take care of the following case:
            // IPCP(1)-LD(1)-LU(1)-LCP(1)-LD(1)-LU(1)-LCP(1)
            // We transform the above to:
            // LD(1)-LD(1)-IPCP(1)-LD(1)-LU(1)-LCP(1)-LD(1)-LU(1)-LCP(1)
            // However, the frequency of this problem will be a lot less.
            //

            PCB_WORK_ITEM * pWorkItem2;

            pWorkItem2 = (PCB_WORK_ITEM *)LOCAL_ALLOC( LPTR,
                                                       sizeof(PCB_WORK_ITEM));

            if ( NULL != pWorkItem2 )
            {
                pWorkItem2->hPort = pWorkItem->hPort;
                pWorkItem2->Process = ProcessLineDown;
                PppLog( 2, "Inserting extra PPPEMSG_LineDown for hPort=%d",
                                pWorkItem2->hPort );

                pWorkItem2->pNext = WorkItemQ.pQHead;
                WorkItemQ.pQHead = pWorkItem2;
            }
        }
    }
    else
    {
        WorkItemQ.pQHead = pWorkItem;
        WorkItemQ.pQTail = pWorkItem;
    }

    SetEvent( WorkItemQ.hEventNonEmpty );

    LeaveCriticalSection( &(WorkItemQ.CriticalSection) );
}

//**
//
// Call:        NotifyCallerOfFailureOnPort
//
// Returns:     None
//
// Description: Will notify the caller or initiator of the PPP connection on
//              the port about a failure event.
//
VOID
NotifyCallerOfFailureOnPort(
    IN HPORT hPort,
    IN BOOL  fServer,
    IN DWORD dwRetCode
)
{
    PPP_MESSAGE PppMsg;
    DWORD       dwMsgId = fServer ? PPPDDMMSG_PppFailure : PPPMSG_PppFailure;

    ZeroMemory( &PppMsg, sizeof( PppMsg ) );

    PppMsg.hPort   = hPort;
    PppMsg.dwMsgId = dwMsgId;

    switch( dwMsgId )
    {
    case PPPDDMMSG_PppFailure:

        PppMsg.ExtraInfo.DdmFailure.dwError = dwRetCode;

        PppConfigInfo.SendPPPMessageToDdm( &PppMsg );

        break;

    case PPPMSG_PppFailure:

        PppMsg.ExtraInfo.Failure.dwError         = dwRetCode;
        PppMsg.ExtraInfo.Failure.dwExtendedError = 0;

        RasSendPppMessageToRasman( PppMsg.hPort, (LPBYTE) &PppMsg );

        break;
    }

}

//**
//
// Call:        NotifyCallerOfFailure
//
// Returns:     None
//
// Description: Will notify the caller or initiator of the PPP connection on
//                      the port about a failure event.
//
VOID
NotifyCallerOfFailure( 
    IN PCB * pPcb,
    IN DWORD dwRetCode
)
{
    //
    // Discard all non-LCP packets
    //
    
    pPcb->PppPhase = PPP_LCP;

    NotifyCaller( pPcb,
                  ( pPcb->fFlags & PCBFLAG_IS_SERVER )
                  ? PPPDDMMSG_PppFailure
                  : PPPMSG_PppFailure,
                  &dwRetCode );
}

//**
//
// Call:        NotifyCaller
//
// Returns:     None.
//
// Description: Will notify the caller or initiater of the PPP connection
//              for the port about PPP events on that port.
//
VOID
NotifyCaller( 
    IN PCB * pPcb,
    IN DWORD dwMsgId,
    IN PVOID pData                      
)
{
    DWORD               dwRetCode;
    PPP_MESSAGE         PppMsg;

    ZeroMemory( &PppMsg, sizeof( PppMsg ) );

    PppLog( 2, "NotifyCaller(hPort=%d, dwMsgId=%d)", pPcb->hPort, dwMsgId );

    PppMsg.hPort   = pPcb->hPort;
    PppMsg.dwMsgId = dwMsgId;

    switch( dwMsgId )
    {
    case PPPDDMMSG_Stopped:

        if ( !(pPcb->fFlags & PCBFLAG_IS_SERVER) )
        {
            return;
        }

        PppMsg.ExtraInfo.DdmStopped.dwReason = *((DWORD*)pData);

        PppConfigInfo.SendPPPMessageToDdm( &PppMsg );

        break;

    case PPPDDMMSG_PortCleanedUp:

        if ( !(pPcb->fFlags & PCBFLAG_IS_SERVER) )
        {
            return;
        }

        PppConfigInfo.SendPPPMessageToDdm( &PppMsg );

        break;

    case PPPDDMMSG_PppFailure:

        if ( !(pPcb->fFlags & PCBFLAG_IS_SERVER) )
        {
            return;
        }

        PppMsg.ExtraInfo.DdmFailure.dwError = *((DWORD*)pData);

        if ( pPcb->pBcb->szRemoteUserName[0] != (CHAR)NULL )
        {
            strcpy(PppMsg.ExtraInfo.DdmFailure.szUserName,
                   pPcb->pBcb->szRemoteUserName);
        }
        else
        {
            PppMsg.ExtraInfo.DdmFailure.szUserName[0] = (CHAR)NULL;
        }

        if ( pPcb->pBcb->szRemoteDomain[0] != (CHAR)NULL )
        {
            strcpy(PppMsg.ExtraInfo.DdmFailure.szLogonDomain,
                   pPcb->pBcb->szRemoteDomain);
        }
        else
        {
            PppMsg.ExtraInfo.DdmFailure.szLogonDomain[0] = (CHAR)NULL;
        }

        PppConfigInfo.SendPPPMessageToDdm( &PppMsg );

        break;

    case PPPDDMMSG_NewBundle:
    case PPPDDMMSG_NewLink:

        if ( !(pPcb->fFlags & PCBFLAG_IS_SERVER) )
            return;

        if ( dwMsgId == PPPDDMMSG_NewBundle )
        {
            PppMsg.ExtraInfo.DdmNewBundle.pClientInterface
                                               = GetClientInterfaceInfo( pPcb );
        }

        PppConfigInfo.SendPPPMessageToDdm( &PppMsg );

        break;

    case PPPDDMMSG_CallbackRequest:

        if ( !(pPcb->fFlags & PCBFLAG_IS_SERVER) )
            return;

        {
        PPPDDM_CALLBACK_REQUEST * pPppDdmCallbackRequest = 
                                ( PPPDDM_CALLBACK_REQUEST *)pData;


        CopyMemory( &(PppMsg.ExtraInfo.CallbackRequest), 
                    pPppDdmCallbackRequest,
                    sizeof( PPPDDM_CALLBACK_REQUEST ) );

        }

        PppConfigInfo.SendPPPMessageToDdm( &PppMsg );

        break;

    case PPPDDMMSG_PppDone:

        if ( !(pPcb->fFlags & PCBFLAG_IS_SERVER) )
            return;

        PppMsg.ExtraInfo.ProjectionResult = *((PPP_PROJECTION_RESULT*)pData);

        PppConfigInfo.SendPPPMessageToDdm( &PppMsg );

        break;

    case PPPDDMMSG_Authenticated:

        //
        // Only server wants to know about authentication results.
        //

        if ( !(pPcb->fFlags & PCBFLAG_IS_SERVER) )
            return;

        strcpy( PppMsg.ExtraInfo.AuthResult.szUserName,
                pPcb->pBcb->szRemoteUserName); 

        strcpy( PppMsg.ExtraInfo.AuthResult.szLogonDomain, 
                pPcb->pBcb->szRemoteDomain ); 

        PppMsg.ExtraInfo.AuthResult.fAdvancedServer = 
                                pPcb->fFlags & PCBFLAG_IS_ADVANCED_SERVER;

        PppConfigInfo.SendPPPMessageToDdm( &PppMsg );

        break;

    case PPPMSG_PppDone:
    case PPPMSG_AuthRetry:
    case PPPMSG_Projecting:
    case PPPMSG_CallbackRequest:
    case PPPMSG_Callback:
    case PPPMSG_ChangePwRequest:
    case PPPMSG_LinkSpeed:
    case PPPMSG_Progress:

        if ( pPcb->fFlags & PCBFLAG_IS_SERVER )
            return;

        RasSendPppMessageToRasman( PppMsg.hPort, (LPBYTE) &PppMsg );

        break;

    case PPPMSG_Stopped:

        if ( pPcb->fFlags & PCBFLAG_IS_SERVER )
            return;

        PppMsg.dwError = *((DWORD*)pData);

        if(pPcb->fFlags & PCBFLAG_RECVD_TERM_REQ)
        {
            PppMsg.ExtraInfo.Stopped.dwFlags = 
                PPP_FAILURE_REMOTE_DISCONNECT;
                    
        }
        else
        {
            PppMsg.ExtraInfo.Stopped.dwFlags = 0;
        }

        RasSendPppMessageToRasman( PppMsg.hPort, (LPBYTE) &PppMsg );

        break;

    case PPPMSG_PppFailure:

        if ( pPcb->fFlags & PCBFLAG_IS_SERVER )
            return;

        PppMsg.ExtraInfo.Failure.dwError          = *((DWORD*)pData);
        PppMsg.ExtraInfo.Failure.dwExtendedError  = 0;

        RasSendPppMessageToRasman( PppMsg.hPort, (LPBYTE) &PppMsg );

        break;

    case PPPMSG_ProjectionResult:

        if ( pPcb->fFlags & PCBFLAG_IS_SERVER )
            return;

        PppMsg.ExtraInfo.ProjectionResult = *((PPP_PROJECTION_RESULT*)pData);

        RasSendPppMessageToRasman( PppMsg.hPort, (LPBYTE) &PppMsg );

        break;

    case PPPMSG_InvokeEapUI:

        if ( pPcb->fFlags & PCBFLAG_IS_SERVER )
            return;

        PppMsg.ExtraInfo.InvokeEapUI = *((PPP_INVOKE_EAP_UI*)pData);

        RasSendPppMessageToRasman( PppMsg.hPort, (LPBYTE)&PppMsg );

        break;

    case PPPMSG_SetCustomAuthData:

        if ( pPcb->fFlags & PCBFLAG_IS_SERVER )
            return;

        PppMsg.ExtraInfo.SetCustomAuthData= *((PPP_SET_CUSTOM_AUTH_DATA*)pData);

        RasSendPppMessageToRasman( PppMsg.hPort, (LPBYTE)&PppMsg );

        break;

    default:
        
        PPP_ASSERT( FALSE );

        break;
    }

    return;
}

//**
//
// Call:        LogPPPEvent
//
// Returns:     None
//
// Description: Will log a PPP event in the eventvwr.
//
VOID
LogPPPEvent( 
    IN DWORD dwEventId,
    IN DWORD dwData
)
{
    PppLog( 2, "EventLog EventId = %d, error = %d", dwEventId, dwData );
 
    PppLogError( dwEventId, 0, NULL, dwData );
}

//**
//
// Call:        GetCpIndexFromProtocol
//
// Returns:     Index of the CP with dwProtocol in the CpTable.
//              -1 if there is not CP with dwProtocol in CpTable.
//
// Description:
//
DWORD
GetCpIndexFromProtocol( 
    IN DWORD dwProtocol 
)
{
    DWORD dwIndex;

    for ( dwIndex = 0; 
          dwIndex < ( PppConfigInfo.NumberOfCPs + PppConfigInfo.NumberOfAPs );
          dwIndex++
        )
    {
        if ( CpTable[dwIndex].CpInfo.Protocol == dwProtocol )
            return( dwIndex );
    }

    return( (DWORD)-1 );
}

//**
//
// Call:        IsLcpOpened
//
// Returns:     TRUE  - LCP is in the OPENED state.
//              FALSE - Otherwise
//
// Description: Uses the PppPhase value of the PORT_CONTROL_BLOCK to detect 
//              to see if the LCP layer is in the OPENED state.
//
BOOL
IsLcpOpened(
    PCB * pPcb
)
{
    if ( pPcb->PppPhase == PPP_LCP )
        return( FALSE );
    else
        return( TRUE );
}

//**
//
// Call:        GetConfiguredInfo
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
GetConfiguredInfo(
    IN PCB *                       pPcb,
    IN DWORD                       CPIndex,
    IN OUT PPP_PROJECTION_RESULT * pProjectionResult,
    OUT BOOL *                     pfNCPsAreDone
)
{
    DWORD               dwIndex;
    CPCB *              pCpCb;
    DWORD               dwRetCode;

    pProjectionResult->ip.dwError  = ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
    pProjectionResult->at.dwError  = ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
    pProjectionResult->ipx.dwError = ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
    pProjectionResult->nbf.dwError = ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
    pProjectionResult->ccp.dwError = ERROR_PPP_NO_PROTOCOLS_CONFIGURED;

    //
    // Check to see if we are all done
    //

    for (dwIndex = LCP_INDEX+1; dwIndex < PppConfigInfo.NumberOfCPs; dwIndex++)
    {
        pCpCb = GetPointerToCPCB( pPcb, dwIndex );

        if ( pCpCb->fConfigurable )
        {
            if ( pCpCb->NcpPhase == NCP_CONFIGURING )
            {
                return( NO_ERROR );
            }

            switch( CpTable[dwIndex].CpInfo.Protocol )
            {
            case PPP_IPCP_PROTOCOL:

                pProjectionResult->ip.dwError = pCpCb->dwError;

                if ( pProjectionResult->ip.dwError == NO_ERROR )
                {

                    /* Assumption is made here that the
                    ** PPP_PROJECTION_RESULT.wszServerAddress field immediately
                    ** follows the PPP_PROJECTION_RESULT.wszAddress field and 
                    ** that both fields are 15 + 1 WCHARs long.
                    */

                    dwRetCode =(CpTable[dwIndex].CpInfo.RasCpGetNegotiatedInfo)(
                               pCpCb->pWorkBuf,
                               &(pProjectionResult->ip));

                    if ( dwRetCode != NO_ERROR )
                    {
                        PppLog( 2, "IPCP GetNegotiatedInfo returned %d", 
                                dwRetCode );

                        pCpCb->dwError = dwRetCode;

                        pCpCb->NcpPhase = NCP_CONFIGURING;

                        FsmClose( pPcb, dwIndex );

                        return( ( dwIndex == CPIndex ) ? dwRetCode : NO_ERROR );
                    }

                    pPcb->pBcb->nboRemoteAddress = 
                        pProjectionResult->ip.dwRemoteAddress;

                    if (   pProjectionResult->ip.fSendVJHCompression
                        && pProjectionResult->ip.fReceiveVJHCompression )
                    {
                        pPcb->pBcb->fFlags |= BCBFLAG_IPCP_VJ_NEGOTIATED;
                    }
                }

                break;

            case PPP_ATCP_PROTOCOL:

                pProjectionResult->at.dwError = pCpCb->dwError;

                if ( pProjectionResult->at.dwError == NO_ERROR )
                {
                    dwRetCode=(CpTable[dwIndex].CpInfo.RasCpGetNegotiatedInfo)(
                              pCpCb->pWorkBuf,
                              &(pProjectionResult->at) );

                    if ( dwRetCode != NO_ERROR )
                    {
                        pCpCb->dwError = dwRetCode;

                        pCpCb->NcpPhase = NCP_CONFIGURING;

                        FsmClose( pPcb, dwIndex );

                        return( ( dwIndex == CPIndex ) ? dwRetCode : NO_ERROR );
                    }
                }

                break;

            case PPP_IPXCP_PROTOCOL:

                pProjectionResult->ipx.dwError = pCpCb->dwError;

                if ( pProjectionResult->ipx.dwError == NO_ERROR )
                {
                    dwRetCode =(CpTable[dwIndex].CpInfo.RasCpGetNegotiatedInfo)(
                               pCpCb->pWorkBuf,
                               &(pProjectionResult->ipx) );

                    if ( dwRetCode != NO_ERROR )
                    {
                        pCpCb->dwError = dwRetCode;

                        pCpCb->NcpPhase = NCP_CONFIGURING;

                        FsmClose( pPcb, dwIndex );

                        return( ( dwIndex == CPIndex ) ? dwRetCode : NO_ERROR );
                    }
                }

                break;

            case PPP_CCP_PROTOCOL:

                pProjectionResult->ccp.dwError = pCpCb->dwError;

                if ( pProjectionResult->ccp.dwError == NO_ERROR )
                {
                    dwRetCode= (CpTable[dwIndex].CpInfo.RasCpGetNegotiatedInfo)(
                               pCpCb->pWorkBuf,
                               &(pProjectionResult->ccp));

                    if ( dwRetCode != NO_ERROR )
                    {
                        pCpCb->dwError = dwRetCode;

                        pCpCb->NcpPhase = NCP_CONFIGURING;

                        FsmClose( pPcb, dwIndex );

                        return( ( dwIndex == CPIndex ) ? dwRetCode : NO_ERROR );
                    }

                    if ( RAS_DEVICE_TYPE( pPcb->dwDeviceType ) != 
                         RDT_Tunnel_L2tp )
                    {
                        DWORD   dwEncryptionType;

                        //
                        // Not L2TP. In the case of L2TP, we are interested in 
                        // the IpSec encryption, not MPPE.
                        //

                        dwEncryptionType =
                            pProjectionResult->ccp.dwSendProtocolData &
                            ( MSTYPE_ENCRYPTION_40  |
                              MSTYPE_ENCRYPTION_40F |
                              MSTYPE_ENCRYPTION_56  |
                              MSTYPE_ENCRYPTION_128 );

                        switch ( dwEncryptionType )
                        {
                        case MSTYPE_ENCRYPTION_40:
                        case MSTYPE_ENCRYPTION_40F:

                            pPcb->pBcb->fFlags |= BCBFLAG_BASIC_ENCRYPTION;
                            break;

                        case MSTYPE_ENCRYPTION_56:

                            pPcb->pBcb->fFlags |= BCBFLAG_STRONGER_ENCRYPTION;
                            break;

                        case MSTYPE_ENCRYPTION_128:

                            pPcb->pBcb->fFlags |= BCBFLAG_STRONGEST_ENCRYPTION;
                            break;
                        }
                    }
                }

                break;

            case PPP_NBFCP_PROTOCOL:

                pProjectionResult->nbf.dwError = pCpCb->dwError;

                //
                // We call this even if we have an error one the client side
                // since we need the failure information
                //

                if ( ( pProjectionResult->nbf.dwError == NO_ERROR ) ||
                     ( !( pPcb->fFlags & PCBFLAG_IS_SERVER ) ) )
                {
                    dwRetCode=(CpTable[dwIndex].CpInfo.RasCpGetNegotiatedInfo)(
                              pCpCb->pWorkBuf,
                              &(pProjectionResult->nbf) );

                    if ( dwRetCode != NO_ERROR )
                    {
                        pCpCb->dwError = dwRetCode;

                        pCpCb->NcpPhase = NCP_CONFIGURING;

                        FsmClose( pPcb, dwIndex );

                        return( ( dwIndex == CPIndex ) ? dwRetCode : NO_ERROR );
                    }
                }

                break;

            default:

                break;
            }
        }
        else
        {
            //
            // The protocol may have been de-configured because CpBegin failed
            //

            if ( pCpCb->dwError != NO_ERROR )
            {   
                switch( CpTable[dwIndex].CpInfo.Protocol )
                {
                case PPP_IPCP_PROTOCOL:
                    pProjectionResult->ip.dwError  = pCpCb->dwError;
                    break;

                case PPP_ATCP_PROTOCOL:
                    pProjectionResult->at.dwError  = pCpCb->dwError;
                    break;

                case PPP_IPXCP_PROTOCOL:
                    pProjectionResult->ipx.dwError = pCpCb->dwError;
                    break;

                case PPP_NBFCP_PROTOCOL:
                    pProjectionResult->nbf.dwError = pCpCb->dwError;
                    break;

                case PPP_CCP_PROTOCOL:
                    pProjectionResult->ccp.dwError = pCpCb->dwError;
                    break;

                default:
                    break;
                }
            }
        }
    }

    if ( ( pPcb->fFlags & PCBFLAG_IS_SERVER ) && 
         ( pProjectionResult->nbf.dwError != NO_ERROR ))
    {
        //
        // If NBF was not configured copy the computername to the wszWksta
        // field
        //

        if ( *(pPcb->pBcb->szComputerName) == (CHAR)NULL )
        {
            pProjectionResult->nbf.wszWksta[0] = (WCHAR)NULL;
        }
        else  
        {
            CHAR chComputerName[NETBIOS_NAME_LEN+1];
        
            memset( chComputerName, ' ', NETBIOS_NAME_LEN );
        
            chComputerName[NETBIOS_NAME_LEN] = (CHAR)NULL;

            strcpy( chComputerName, 
                    pPcb->pBcb->szComputerName + strlen(MS_RAS_WITH_MESSENGER));

            chComputerName[strlen(chComputerName)] = (CHAR)' ';

            MultiByteToWideChar(
                CP_ACP,
                0,
                chComputerName,
                -1,
                pProjectionResult->nbf.wszWksta,
                sizeof( pProjectionResult->nbf.wszWksta ) );

            if ( !memcmp( MS_RAS_WITH_MESSENGER,        
                          pPcb->pBcb->szComputerName,
                          strlen( MS_RAS_WITH_MESSENGER ) ) )
            {
                pProjectionResult->nbf.wszWksta[NETBIOS_NAME_LEN-1] = (WCHAR)3;
            }
        }
    }

    *pfNCPsAreDone = TRUE;

    return( NO_ERROR );
}

//**
//
// Call:        AreNCPsDone
//
// Returns:     NO_ERROR        - Success
//              anything else   - Failure
//
// Description: If we detect that all configurable NCPs have completed their
//              negotiation, then the PPP_PROJECTION_RESULT structure is also
//              filled in.
//              This is called during the FsmThisLayerFinished or FsmThisLayerUp
//              calls for a certain CP. The index of this CP is passed in.
//              If any call to that particular CP fails then an error code is
//              passed back. If any call to any other CP fails then the error
//              is stored in the dwError field for that CP but the return is
//              successful. This is done so that the FsmThisLayerFinshed or
//              FsmThisLayerUp calls know if they completed successfully for
//              that CP or not. Depending on this, the FSM changes the state
//              for that CP or not.
//
DWORD
AreNCPsDone( 
    IN  PCB *                           pPcb,
    IN  DWORD                           CPIndex,
    OUT PPP_PROJECTION_RESULT *         pProjectionResult,
    OUT BOOL *                          pfNCPsAreDone
)
{
    DWORD dwRetCode;

    *pfNCPsAreDone = FALSE;

    ZeroMemory( pProjectionResult, sizeof( PPP_PROJECTION_RESULT ) );

    dwRetCode = GetConfiguredInfo( pPcb, 
                                   CPIndex, 
                                   pProjectionResult,
                                   pfNCPsAreDone );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    if ( !(*pfNCPsAreDone ) )
    {
        return( NO_ERROR );
    }

    //
    // Now get LCP information
    //

    pProjectionResult->lcp.hportBundleMember = (HPORT)INVALID_HANDLE_VALUE;
    pProjectionResult->lcp.szReplyMessage = pPcb->pBcb->szReplyMessage;

    dwRetCode = (CpTable[LCP_INDEX].CpInfo.RasCpGetNegotiatedInfo)(
                                    pPcb->LcpCb.pWorkBuf,
                                    &(pProjectionResult->lcp));

    if ( RAS_DEVICE_TYPE( pPcb->dwDeviceType ) == RDT_Tunnel_L2tp )
    {
        if ( pPcb->pBcb->fFlags & BCBFLAG_BASIC_ENCRYPTION )
        {
            pProjectionResult->lcp.dwLocalOptions |= PPPLCPO_DES_56;
            pProjectionResult->lcp.dwRemoteOptions |= PPPLCPO_DES_56;
        }
        else if ( pPcb->pBcb->fFlags & BCBFLAG_STRONGEST_ENCRYPTION )
        {
            pProjectionResult->lcp.dwLocalOptions |= PPPLCPO_3_DES;
            pProjectionResult->lcp.dwRemoteOptions |= PPPLCPO_3_DES;
        }
    }

    pProjectionResult->lcp.dwLocalEapTypeId = pPcb->dwServerEapTypeId;
    pProjectionResult->lcp.dwRemoteEapTypeId = pPcb->dwClientEapTypeId;

    return( dwRetCode );
}

//**
//
// Call:        GetUid
//
// Returns:     A BYTE value viz. unique with the 0 - 255 range
//
// Description:
//
BYTE
GetUId(
    IN PCB * pPcb,
    IN DWORD CpIndex
)
{
    BYTE UId;

    //
    // For NCPs get the UID from the BCB
    //

    if ( ( CpIndex != LCP_INDEX ) && ( CpIndex >= PppConfigInfo.NumberOfCPs ) )
    {
        UId = (BYTE)(pPcb->pBcb->UId);

        (pPcb->pBcb->UId)++;

        return( UId );
    }

    UId = (BYTE)(pPcb->UId);

    (pPcb->UId)++;

    return( UId );
}

//**
//
// Call:        AlertableWaitForSingleObject
//
// Returns:     None
//
// Description: Will wait infintely for a single object in alertable mode. If 
//              the wait completes because of an IO completion it will 
//              wait again.
//
VOID
AlertableWaitForSingleObject(
    IN HANDLE hObject
)
{
    DWORD dwRetCode;

    do 
    {
        dwRetCode = WaitForSingleObjectEx( hObject, INFINITE, TRUE );

        PPP_ASSERT( dwRetCode != 0xFFFFFFFF );
        PPP_ASSERT( dwRetCode != WAIT_TIMEOUT );
    }
    while ( dwRetCode == WAIT_IO_COMPLETION );
}

//**
//
// Call:        NotifyIPCPOfNBFCPProjectiont
//
// Returns:     TRUE  - Success
//              FALSE - Failure
//
// Description: Will notify IPCPs of all the configuration information,
//              specifically it is looking for NBFCP information.
//              Will return FALSE if the IPCP was not notified 
//              successfully. 
//              
//
BOOL
NotifyIPCPOfNBFCPProjection( 
    IN PCB *                    pPcb, 
    IN DWORD                    CpIndex
)
{
    CPCB*                   pCpCb;
    DWORD                   dwRetCode;
    PPP_PROJECTION_RESULT   ProjectionResult;
    PPPCP_NBFCP_RESULT      NbfCpResult;
    DWORD                   NBFCPIndex;
    DWORD                   IPCPIndex;

    NBFCPIndex = GetCpIndexFromProtocol( PPP_NBFCP_PROTOCOL );

    IPCPIndex = GetCpIndexFromProtocol( PPP_IPCP_PROTOCOL );

    //
    // No IPCP installed, we are done
    //

    if ( IPCPIndex == (DWORD)-1 )
    {
        return( TRUE );
    }
       
    if ( CpTable[CpIndex].CpInfo.Protocol == PPP_IPCP_PROTOCOL )
    {
        if ( NBFCPIndex != (DWORD)-1 )
        {
            pCpCb = GetPointerToCPCB( pPcb, NBFCPIndex );

            if ( pCpCb == NULL )
            {
                return( FALSE );
            }

            if ( pCpCb->fConfigurable )
            {
                if ( pCpCb->NcpPhase == NCP_CONFIGURING )
                {
                    //
                    // NBFCP is still being configured, we need to wait 
                    // until it is done
                    //

                    PppLog( 2, "Waiting for NBFCP to complete" );
              
                    return( TRUE );
                }
            }
        }
    }

    if ( CpTable[CpIndex].CpInfo.Protocol == PPP_NBFCP_PROTOCOL )
    {
        pCpCb = GetPointerToCPCB( pPcb, IPCPIndex );

        if ( pCpCb == NULL )
        {
            return( FALSE );
        }

        if ( pCpCb->fConfigurable )
        {
            if ( pCpCb->NcpPhase == NCP_CONFIGURING )
            {
                //
                // IPCP is still being configured, we need to wait 
                // until it is done
                //

                PppLog( 2, "Waiting for IPCP to complete" );
              
                return( TRUE );
            }
        }
        else
        {
            //
            // IPCP not configurable, we are done.
            //

            return( TRUE );
        }
    }

    //
    // If we are here that means we need to notify IPCP of NBFCP projection.
    // NBF may or may not be configurable, or may or may not have projected
    // successfully
    //

    ZeroMemory( &ProjectionResult, sizeof( PPP_PROJECTION_RESULT ) );

    ZeroMemory( &NbfCpResult, sizeof( NbfCpResult ) );

    ProjectionResult.nbf.dwError = ERROR_PPP_NO_PROTOCOLS_CONFIGURED;

    if ( NBFCPIndex != (DWORD)-1 )
    {
        pCpCb = GetPointerToCPCB( pPcb, NBFCPIndex );

        if ( pCpCb == NULL )
        {
            return( FALSE );
        }

        if ( pCpCb->fConfigurable )
        {
            if ( ProjectionResult.nbf.dwError == NO_ERROR )
            {
                dwRetCode = (CpTable[NBFCPIndex].CpInfo.RasCpGetNegotiatedInfo)(
                                       pCpCb->pWorkBuf,
                                       &(ProjectionResult.nbf) );

                if ( dwRetCode != NO_ERROR )
                {
                    pCpCb->dwError = dwRetCode;

                    pCpCb->NcpPhase = NCP_CONFIGURING;

                    FsmClose( pPcb, NBFCPIndex );

                    return( FALSE );
                }
            }
        }
    }

    //
    // Notify IPCP of NBFCP projection
    //

    pCpCb = GetPointerToCPCB( pPcb, IPCPIndex );

    if ( pCpCb == NULL )
    {
        return( FALSE );
    }

    dwRetCode = (CpTable[IPCPIndex].CpInfo.RasCpProjectionNotification)(
                                                pCpCb->pWorkBuf,
                                                (PVOID)&ProjectionResult );

    PppLog( 2, "Notifying IPCP of projection notification" );

    if ( dwRetCode != NO_ERROR )
    {
        PppLog( 2,"RasIPCPProjectionNotification returned %d", dwRetCode );

        pCpCb->dwError = dwRetCode;

        pCpCb->NcpPhase = NCP_CONFIGURING;

        FsmClose( pPcb, IPCPIndex );

        return( FALSE );
    }

    return( TRUE );
}

//**
//
// Call:        CalculateRestartTimer
//
// Returns:     The value of the restart timer in seconds based on the link
//              speed.
//
// Description: Will get the link speed from rasman and calculate the value
//              if the restart timer based on it.
//
DWORD
CalculateRestartTimer(
    IN HPORT hPort
)
{
    RASMAN_INFO RasmanInfo;

    if ( RasGetInfo( NULL, hPort, &RasmanInfo ) != NO_ERROR )
    {
        return( PppConfigInfo.DefRestartTimer );
    }

    if ( RasmanInfo.RI_LinkSpeed <= 1200 )
    {
        return( 7 );
    }

    if ( RasmanInfo.RI_LinkSpeed <= 2400 )
    {
        return( 5 );
    }

    if ( RasmanInfo.RI_LinkSpeed <= 9600 )
    {
        return( 3 );
    }
    else
    {
        return( 1 );
    }

}

//**
//
// Call:    CheckCpsForInactivity
//
// Returns: None
//
// Description: Will call each Control protocol to get the time since last
//      activity.
//
VOID
CheckCpsForInactivity(
    IN PCB * pPcb, 
	IN DWORD dwEvent				//Type of event to check against
)
{
    DWORD dwRetCode;
    DWORD dwIndex;
    DWORD dwTimeSinceLastActivity = 0;
	

    PppLog( 2, "Time to check Cps for Activity for port %d", pPcb->hPort );

    dwRetCode = RasGetTimeSinceLastActivity( pPcb->hPort,
                                             &dwTimeSinceLastActivity );

    if ( dwRetCode != NO_ERROR )
    {
        PppLog(2, "RasGetTimeSinceLastActivityTime returned %d\r\n", dwRetCode);

        return;
    }

    PppLog(2, "Port %d inactive for %d seconds",
              pPcb->hPort, dwTimeSinceLastActivity );

    //
    // If all the stacks have been inactive for at least AutoDisconnectTime
    // then we disconnect.
    //
	
	if ( dwEvent == TIMER_EVENT_AUTODISCONNECT )
	{
		if ( dwTimeSinceLastActivity >=  pPcb->dwAutoDisconnectTime)
		{
			PppLog(1,"Disconnecting port %d due to inactivity.", pPcb->hPort);

			if ( !( pPcb->fFlags & PCBFLAG_IS_SERVER ) )
			{
				HANDLE hLogHandle;

				if( pPcb->pBcb->InterfaceInfo.IfType == ROUTER_IF_TYPE_FULL_ROUTER)
				{
					hLogHandle = RouterLogRegisterA( "RemoteAccess" );
				}
				else
				{
					hLogHandle = PppConfigInfo.hLogEvents;
				}

				if ( hLogHandle != NULL )
				{
					CHAR * pszPortName = pPcb->szPortName;

					RouterLogInformationA( hLogHandle, 
										   ROUTERLOG_CLIENT_AUTODISCONNECT,
										   1, 
										   &pszPortName,
										   NO_ERROR );

					if ( hLogHandle != PppConfigInfo.hLogEvents )
					{
						RouterLogDeregisterA( hLogHandle );
					}
				}
			}

			//
			// Terminate the link
			//

			pPcb->LcpCb.dwError = ERROR_IDLE_DISCONNECTED;

			FsmClose( pPcb, LCP_INDEX );
		}
		else
		{
			InsertInTimerQ( pPcb->dwPortId,
							pPcb->hPort,
							0,
							0,
							FALSE,
							TIMER_EVENT_AUTODISCONNECT,
							pPcb->dwAutoDisconnectTime - dwTimeSinceLastActivity );
		}
	}
	//
	// Do the LCP Echo request if its pppoe
	//
	else if (   (RDT_PPPoE == RAS_DEVICE_TYPE(pPcb->dwDeviceType))
	        &&  (dwEvent == TIMER_EVENT_LCP_ECHO ))
	{
		
		if ( pPcb->fEchoRequestSend )
		{
		    //
			// Because the line was inactive for dwEchoTimeout, we send an echo
			// request and did not get any response back in 3 seconds after that.
			// So we have to disconnect the port.
			//
			pPcb->dwNumEchoResponseMissed ++;
			if ( pPcb->dwNumEchoResponseMissed >= pPcb->dwNumMissedEchosBeforeDisconnect )
			{
				PppLog(1,"Missed %d consecutive echo responses.  Disconnecting port %d "
						"due to no echo responses.", pPcb->dwNumMissedEchosBeforeDisconnect, pPcb->hPort);
				//
				// Terminate the link
				//
				pPcb->LcpCb.dwError = ERROR_IDLE_DISCONNECTED;
				pPcb->fEchoRequestSend = 0;
				pPcb->dwNumEchoResponseMissed = 0;
				FsmClose( pPcb, LCP_INDEX );
			}
			else
			{
				//no response yet.  So send one more echo request.
				FsmSendEchoRequest( pPcb, LCP_INDEX);
				InsertInTimerQ( pPcb->dwPortId,
								pPcb->hPort,
								0,
								0,
								FALSE,
								TIMER_EVENT_LCP_ECHO,
								pPcb->dwLCPEchoTimeInterval
							  );
			}
		}
		else
		{
			//
			//No echo request send or we have got a response for echo already
			//

		    //
			// check to see if the the inactivity is more than EchoTimeout
			//
			if ( dwTimeSinceLastActivity >=  pPcb->dwIdleBeforeEcho )
			{
			    //
				// call the lcp cp to make the echo request
				//
				if ( FsmSendEchoRequest( pPcb, LCP_INDEX) )
				{
				    //
					// send the echo requesst and set the flag
					//
					pPcb->fEchoRequestSend = 1;
					//Setup for next echo request here.
					InsertInTimerQ( pPcb->dwPortId,
									pPcb->hPort,
									0,
									0,
									FALSE,
									TIMER_EVENT_LCP_ECHO,
									pPcb->dwLCPEchoTimeInterval );

				}
				else
				{
					PppLog (1, "Send EchoRequest Failed...");
				}


			}
			else
			{
				InsertInTimerQ( pPcb->dwPortId,
								pPcb->hPort,
								0,
								0,
								FALSE,
								TIMER_EVENT_LCP_ECHO,
								pPcb->dwIdleBeforeEcho - dwTimeSinceLastActivity );
			}
		}
	}
}

//These functions are in ppputil.lib.  Should be used from there
#if 0
//**
//
// Call:
//
// Returns:
//
// Description:
//
CHAR*
DecodePw(
	IN CHAR chSeed,
    IN OUT CHAR* pszPassword )

    /* Un-obfuscate 'pszPassword' in place.
    **
    ** Returns the address of 'pszPassword'.
    */
{
    return EncodePw( chSeed, pszPassword );
}

//**
//
// Call:
//
// Returns:
//
// Description:
//
CHAR*
EncodePw( 
	IN CHAR chSeed,
    IN OUT CHAR* pszPassword )

    /* Obfuscate 'pszPassword' in place to foil memory scans for passwords.
    **
    ** Returns the address of 'pszPassword'.
    */
{
    if (pszPassword)
    {
        CHAR* psz;

        ReverseString( pszPassword );

        for (psz = pszPassword; *psz != '\0'; ++psz)
        {
            if (*psz != chSeed)
                *psz ^= chSeed;
			/*
            if (*psz != (CHAR)PASSWORDMAGIC)
                *psz ^= PASSWORDMAGIC;
			*/
        }
    }

    return pszPassword;
}
//**
//
// Call:        ReverseString
//
// Returns:
//
// Description:
//
VOID
ReverseString(
    CHAR* psz )

    /* Reverses order of characters in 'psz'.
    */
{
    CHAR* pszBegin;
    CHAR* pszEnd;

    for (pszBegin = psz, pszEnd = psz + strlen( psz ) - 1;
         pszBegin < pszEnd;
         ++pszBegin, --pszEnd)
    {
        CHAR ch = *pszBegin;
        *pszBegin = *pszEnd;
        *pszEnd = ch;
    }
}
#endif

//**
//
// Call:        GetLocalComputerName
//
// Returns:     None
//
// Description: Will get the local computer name. Will also find out if the
//              the messenger is running and set the appropriate prefix.
//
VOID
GetLocalComputerName( 
    IN OUT LPSTR szComputerName 
)
{
    SC_HANDLE           ScHandle;
    SC_HANDLE           ScHandleService;
    SERVICE_STATUS      ServiceStatus;
    CHAR                chComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD               dwComputerNameLen;

    *szComputerName = (CHAR)NULL;

    //
    // Open the local service control manager
    //

    ScHandle = OpenSCManager( NULL, NULL, GENERIC_READ );

    if ( ScHandle == (SC_HANDLE)NULL )
    {
        return;
    }

    ScHandleService = OpenService( ScHandle,
                                   SERVICE_MESSENGER,
                                   SERVICE_QUERY_STATUS );

    if ( ScHandleService == (SC_HANDLE)NULL )
    {
        CloseServiceHandle( ScHandle );
        return;
    }

    
    if ( !QueryServiceStatus( ScHandleService, &ServiceStatus ) )
    {
        CloseServiceHandle( ScHandle );
        CloseServiceHandle( ScHandleService );
        return;
    }

    CloseServiceHandle( ScHandle );
    CloseServiceHandle( ScHandleService );

    if ( ServiceStatus.dwCurrentState == SERVICE_RUNNING )
    {
        strcpy( szComputerName, MS_RAS_WITH_MESSENGER );		
    }
    else
    {
        strcpy( szComputerName, MS_RAS_WITHOUT_MESSENGER );		
    }

    //
    // Get the size of the buffer to hold local computer name
    //
	dwComputerNameLen = sizeof(chComputerName);

	if ( !GetComputerNameA(	chComputerName,
						&dwComputerNameLen
					  )
	   )
	 
	{
		*szComputerName = (CHAR)NULL;
		return;
	}
	
    strcpy( szComputerName+strlen(szComputerName), chComputerName );

    CharToOemA( szComputerName, szComputerName );

    PppLog( 2, "Local identification = %s", szComputerName );

    return;
}

//**
//
// Call:        InitEndpointDiscriminator
//
// Returns:     NO_ERROR - Success
//              non-zero - Failure
//
// Description: Will obtain a unique end-point discriminator to be used to
//              negotiate multi-link. This end-point discrimintator has to
//              globally unique to this machine.
//
//              We first try to use a Class 3 IEEE 802.1 address of any 
//              netcard that is in this local machine.
//
//              If this fails we use the RPC UUID generator to generate a 
//              Class 1 discriminator.
//
//              If this fails we simply use the local computer name as the 
//              Class 1 discriminator.
//      
//              Simply use a random number if all else fails.    
//
//              NOTE: For now we skip over NwLnkNb because it may return an
//              address of 1 and not the real MAC address. There is not way
//              in user mode for now to get the address.
//
DWORD
InitEndpointDiscriminator( 
    IN OUT BYTE EndPointDiscriminator[]
)
{
    DWORD   dwRetCode;
    LPBYTE  pBuffer;
    DWORD   EntriesRead;
    DWORD   TotalEntries;
    PWCHAR  pwChar;  
    DWORD   dwIndex;
    UUID    Uuid;
    DWORD   dwComputerNameLen;
    PWKSTA_TRANSPORT_INFO_0 pWkstaTransport;

    //
    // Enumerate all the transports used by the local rdr and then get the
    // address of the first LAN transport card
    //

    dwRetCode = NetWkstaTransportEnum(  NULL,     // Local 
                                        0,        // Level
                                        &pBuffer, // Output buffer
                                        (DWORD)-1,// Pref. max len
                                        &EntriesRead,
                                        &TotalEntries,
                                        NULL );

    if ( ( dwRetCode == NO_ERROR ) && ( EntriesRead > 0 ) )
    {
        pWkstaTransport = (PWKSTA_TRANSPORT_INFO_0)pBuffer; 

        while ( EntriesRead-- > 0 )
        {
            if ( !pWkstaTransport->wkti0_wan_ish )
            {
                EndPointDiscriminator[0] = 3;   // Class 3

                pwChar = pWkstaTransport->wkti0_transport_address;

                for ( dwIndex = 0; dwIndex < 6; dwIndex++ )
                {
                    EndPointDiscriminator[dwIndex+1] = ( iswalpha( *pwChar ) 
                                                       ? *pwChar-L'A'+10
                                                       : *pwChar-L'0'
                                                     ) * 0x10
                                                     +
                                                     ( iswalpha( *(pwChar+1) ) 
                                                       ? *(pwChar+1)-L'A'+10
                                                       : *(pwChar+1)-L'0'
                                                     );

                    pwChar++;
                    pwChar++;
                }

                NetApiBufferFree( pBuffer );

                return( NO_ERROR );
            }

            pWkstaTransport++;
        }
    }

    if ( dwRetCode == NO_ERROR )
    {
        NetApiBufferFree( pBuffer );
    }

    EndPointDiscriminator[0] = 1;   // Class 1

    //
    // We failed to get the mac address so try to use UUIDGEN to get an unique
    // local id
    //

    dwRetCode = UuidCreate( &Uuid );

    if ( ( dwRetCode == RPC_S_UUID_NO_ADDRESS ) ||
         ( dwRetCode == RPC_S_OK )              ||
         ( dwRetCode == RPC_S_UUID_LOCAL_ONLY) )
    {
        
        HostToWireFormat32( Uuid.Data1, EndPointDiscriminator+1 );
        HostToWireFormat16( Uuid.Data2, EndPointDiscriminator+5 );
        HostToWireFormat16( Uuid.Data3, EndPointDiscriminator+7 );
        CopyMemory( EndPointDiscriminator+9, Uuid.Data4, 8 );

        return( NO_ERROR );
    }

    // 
    // We failed to get the UUID so simply use the computer name
    //

    dwComputerNameLen = 20;

    if ( !GetComputerNameA( EndPointDiscriminator+1, &dwComputerNameLen ) ) 
    {
        //
        // We failed to get the computer name so use a random number
        // 

            srand( GetCurrentTime() );

        HostToWireFormat32( rand(), EndPointDiscriminator+1 );
    }

    return( NO_ERROR );
}

//**
//
// Call:        AllocateAndInitBcb
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Allocates and initializes a Bundle control block
//
DWORD
AllocateAndInitBcb(
    PCB * pPcb
)
{
    DWORD dwIndex;
    DWORD dwRetCode;

    //
    // Allocate space for NumberOfNcp - LCP - 1 already in the
    // Bcb structure
    //

    pPcb->pBcb = (BCB *)LOCAL_ALLOC( LPTR, 
                                     sizeof( BCB ) +
                                     ( sizeof( CPCB ) *
                                     ( PppConfigInfo.NumberOfCPs - 2 ) ) );
               
    if ( pPcb->pBcb == (BCB *)NULL )
    {
        return( GetLastError() );
    }

    pPcb->pBcb->dwBundleId          = GetNewPortOrBundleId();
    pPcb->pBcb->UId                 = 0;           
    pPcb->pBcb->dwLinkCount         = 1;
    pPcb->pBcb->dwAcctLinkCount     = 1;
    pPcb->pBcb->dwMaxLinksAllowed   = 0xFFFFFFFF;
    pPcb->pBcb->fFlags              = 0;
    pPcb->pBcb->hLicense            = INVALID_HANDLE_VALUE;
    pPcb->pBcb->BapCb.dwId          = 0;
    pPcb->pBcb->hTokenImpersonateUser = INVALID_HANDLE_VALUE;
	pPcb->pBcb->chSeed = GEN_RAND_ENCODE_SEED;		//random number seed for encode/decode password
    //
    // The most common case is to have no more than 2 links in the bundle.
    //
    
    pPcb->pBcb->ppPcb = (PPCB *)LOCAL_ALLOC( LPTR, sizeof( PPCB ) * 2 );

    if ( pPcb->pBcb->ppPcb == (PPCB *) NULL )
    {
        LOCAL_FREE( pPcb->pBcb );
        pPcb->pBcb = NULL;

        return( GetLastError() );
    }

    pPcb->pBcb->dwPpcbArraySize = 2;
    pPcb->pBcb->ppPcb[0] = pPcb;
    pPcb->pBcb->ppPcb[1] = NULL;

    for( dwIndex=0; dwIndex < PppConfigInfo.NumberOfCPs-1; dwIndex++ )
    {
        CPCB * pCpCb = &(pPcb->pBcb->CpCb[dwIndex]);

        pCpCb->NcpPhase = NCP_DEAD;
    }

    return( NO_ERROR );
}

//**
//
// Call:        DeallocateAndRemoveBcbFromTable
//
// Returns:     None
//
// Description: Will remove the Bcb from the hash table
//
VOID
DeallocateAndRemoveBcbFromTable(
    IN BCB * pBcb
)
{
    DWORD       dwIndex;
    BCB *       pBcbWalker  = (BCB *)NULL;
    BCB *       pBcbTemp    = (BCB *)NULL;

    if ( NULL == pBcb )
    {
        return;
    }

    dwIndex = HashPortToBucket( pBcb->hConnection );
    pBcbWalker = PcbTable.BcbBuckets[dwIndex].pBundles;
    pBcbTemp   = pBcbWalker;

    while( pBcbTemp != (BCB *)NULL )
    {
        if ( pBcbTemp->hConnection == pBcb->hConnection )
        {
            if ( pBcbTemp == PcbTable.BcbBuckets[dwIndex].pBundles )
            {
                PcbTable.BcbBuckets[dwIndex].pBundles = pBcbTemp->pNext;
            }
            else
            {
                pBcbWalker->pNext = pBcbTemp->pNext;
            }

            break;
        }

        pBcbWalker = pBcbTemp;
        pBcbTemp = pBcbWalker->pNext;
    }

    //
    // Release the licence if there is one
    //

    if ( INVALID_HANDLE_VALUE != pBcb->hLicense )
    {
        NtLSFreeHandle( (LS_HANDLE)(pBcb->hLicense) );
    }

    ZeroMemory( pBcb->szPassword,
                sizeof( pBcb->szPassword ) );
    ZeroMemory( pBcb->szOldPassword, 
                sizeof( pBcb->szOldPassword ) );

    //
    // Close the OpenThreadToken() handle obtained from Rasman
    //

    if ( INVALID_HANDLE_VALUE != pBcb->hTokenImpersonateUser )
    {
        CloseHandle( pBcb->hTokenImpersonateUser );
    }

    //
    // pCustomAuthConnData, pCustomAuthUserData, szPhonebookPath,
    // szEntryName, and szServerPhoneNumber are allocated by RasMan
    // and MUST be LocalFree'd, not LOCAL_FREE'd.
    //

    LocalFree( pBcb->pCustomAuthConnData );
    LocalFree( pBcb->pCustomAuthUserData );
    LocalFree( pBcb->EapUIData.pEapUIData );
    LocalFree( pBcb->szPhonebookPath );
    LocalFree( pBcb->szEntryName );
    LocalFree( pBcb->BapCb.szServerPhoneNumber );
    LocalFree( pBcb->BapCb.szClientPhoneNumber );
    LocalFree( pBcb->szReplyMessage );

    if ( NULL != pBcb->szTextualSid )
    {
        LOCAL_FREE( pBcb->szTextualSid );
    }

    if ( NULL != pBcb->szRemoteIdentity )
    {
        LOCAL_FREE( pBcb->szRemoteIdentity );
    }


    if ( NULL != pBcb->ppPcb )
    {
        LOCAL_FREE( pBcb->ppPcb );
    }

    LOCAL_FREE( pBcb );
}

//**
//
// Call:        RemovePcbFromTable
//
// Returns:     None
//
// Description: Will remove the Pcb from the hash table
//
VOID
RemovePcbFromTable(
    IN PCB * pPcb
)
{
    DWORD       dwIndex     = HashPortToBucket( pPcb->hPort );
    PCB *       pPcbWalker  = (PCB *)NULL;
    PCB *       pPcbTemp    = (PCB *)NULL;

    pPcbWalker = PcbTable.PcbBuckets[dwIndex].pPorts;
    pPcbTemp = pPcbWalker;

    while( pPcbTemp != (PCB *)NULL )
    {
        if ( pPcbTemp->hPort == pPcb->hPort )
        {
            if ( pPcbTemp == PcbTable.PcbBuckets[dwIndex].pPorts )
            {
                PcbTable.PcbBuckets[dwIndex].pPorts = pPcbTemp->pNext;
            }
            else
            {
                pPcbWalker->pNext = pPcbTemp->pNext;
            }

            break;
        }

        pPcbWalker = pPcbTemp;
        pPcbTemp = pPcbWalker->pNext;
    }
}

//**
//
// Call:        WillPortBeBundled
//
// Returns:     TRUE  - Port will be bundled after authentication
//              FALSE - Port cannot be bundled 
//
// Description: Will check to see if the usernames and discriminators match
//
BOOL
WillPortBeBundled(
    IN  PCB *   pPcb
)
{
    PCB*    pPcbWalker;
    DWORD   dwIndex;

    //
    // Optimization: Have rasman tell PPP that the port will be bundled.
    //

    //
    // Walk thru the list of PCBs
    //

    for ( dwIndex = 0; dwIndex < PcbTable.NumPcbBuckets; dwIndex++ )
    {
        for ( pPcbWalker = PcbTable.PcbBuckets[dwIndex].pPorts;
              pPcbWalker != NULL;
              pPcbWalker = pPcbWalker->pNext )
        {
            //
            // Don't bundle a port with itself.
            //

            if ( pPcbWalker->hPort == pPcb->hPort )
            {
                continue;
            }

            //
            // If the current port negotiated MRRU ie multilink.
            //

            if ( pPcbWalker->fFlags & PCBFLAG_CAN_BE_BUNDLED )
            {
                LCPCB * pLcpCb1 = (LCPCB*)(pPcbWalker->LcpCb.pWorkBuf);
                LCPCB * pLcpCb2 = (LCPCB*)(pPcb->LcpCb.pWorkBuf);

                if ( _stricmp(pPcbWalker->pBcb->szLocalUserName,
                              pPcb->pBcb->szLocalUserName) != 0 )
                {
                    //
                    // Authenticator mismatch, not in our bundle
                    //

                    continue;
                }

                if ( ( pLcpCb1->Remote.Work.EndpointDiscr[0] != 0 ) &&
                     ( memcmp(pLcpCb1->Remote.Work.EndpointDiscr,
                            pLcpCb2->Remote.Work.EndpointDiscr,
                            sizeof(pLcpCb1->Remote.Work.EndpointDiscr))!=0))
                {
                    //
                    // Discriminator mismatch, not in our bundle
                    //

                    continue;
                }

                return( TRUE );
            }
        }
    }

    return( FALSE );
}

//**
//
// Call:        CanPortsBeBundled
//
// Returns:     TRUE  - Ports can be bundled
//              FALSE - Ports cannot be bundled 
//
// Description: Will check to see if the usernames and discriminators match
//
BOOL
CanPortsBeBundled(
    IN PCB * pPcb1,
    IN PCB * pPcb2,
    IN BOOL  fCheckPolicy
)
{
    CPCB *  pCpCb;     
    LCPCB * pLcpCb1 = (LCPCB*)(pPcb1->LcpCb.pWorkBuf);
    LCPCB * pLcpCb2 = (LCPCB*)(pPcb2->LcpCb.pWorkBuf);

    if (    fCheckPolicy
         && ( PppConfigInfo.fFlags & PPPCONFIG_FLAG_WKSTA )
         && ( pPcb1->fFlags & PCBFLAG_IS_SERVER )
         && ( pPcb2->fFlags & PCBFLAG_IS_SERVER ) )
    {
        //
        // RAS server policy on workstation. Allow multilinking of devices in
        // the same device class only, ie all devices are dial-up, or all
        // devices are VPN, or all devices are DCC (direct)
        //

        if ( ( pPcb1->dwDeviceType & RDT_Tunnel ) !=
             ( pPcb2->dwDeviceType & RDT_Tunnel ) )
        {
            return( FALSE );
        }

        if ( ( pPcb1->dwDeviceType & RDT_Direct ) !=
             ( pPcb2->dwDeviceType & RDT_Direct ) )
        {
            return( FALSE );
        }
    }

    //
    // If the current port is in PPP_NCP phase meaning that it is post 
    // authentication and callback.
    //

    if ( pPcb1->PppPhase == PPP_NCP )
    {

        if ( ( _stricmp(pPcb1->pBcb->szLocalUserName,
                        pPcb2->pBcb->szLocalUserName) != 0 )||
             ( _stricmp(pPcb1->pBcb->szRemoteUserName,
                        pPcb2->pBcb->szRemoteUserName) != 0 ))
        {
            //
            // Authenticator mismatch, not in our bundle
            //

            return( FALSE );
        }

        if ( ( pLcpCb1->Remote.Work.EndpointDiscr[0] != 0 ) &&
             ( memcmp(pLcpCb1->Remote.Work.EndpointDiscr,
                    pLcpCb2->Remote.Work.EndpointDiscr,
                    sizeof(pLcpCb1->Remote.Work.EndpointDiscr))!=0))
        {
            //
            // Discriminator mismatch, not in our bundle
            //

            return( FALSE );
        }

        if ( ( pLcpCb1->Local.Work.EndpointDiscr[0] != 0 ) &&
             ( memcmp(pLcpCb1->Local.Work.EndpointDiscr,
                    pLcpCb2->Local.Work.EndpointDiscr,
                    sizeof(pLcpCb1->Local.Work.EndpointDiscr))!=0))
        {
            //
            // Discriminator mismatch, not in our bundle
            //

            return( FALSE );
        }

        return( TRUE );
    }

    return( FALSE );
}

//**
//
// Call:        TryToBundleWithAnotherLink
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will search through all the PCBs for a port that can be bundled.
//              We follow the criteria specified by RFC 1717.
//              phPortMulttlink will point to an HPORT that this port was 
//              bundled with if this function returns TRUE.
//              
//              If the link is to be bundled, and its link discriminator is not 
//              unique, we return a unique discriminator in pwLinkDiscriminator.
//
DWORD
TryToBundleWithAnotherLink( 
    IN  PCB *   pPcb
) 
{
    DWORD   dwIndex;
    PCB *   pPcbWalker;
    BCB *   pBcbOld         = NULL;
    DWORD   dwRetCode       = NO_ERROR;
    DWORD   dwForIndex;
    PPCB *  ppPcb;
    DWORD   CpIndex;
    CPCB *  pCpCb;

    pPcb->hportBundleMember = (HPORT)INVALID_HANDLE_VALUE;

    //
    // Walk thru the list of PCBs
    //

    for ( dwIndex = 0; dwIndex < PcbTable.NumPcbBuckets; dwIndex++ )
    {
        for( pPcbWalker = PcbTable.PcbBuckets[dwIndex].pPorts;
             pPcbWalker != NULL;
             pPcbWalker = pPcbWalker->pNext )
        {
            //
            // Don't bundle a port with itself.
            //

            if ( pPcbWalker->hPort == pPcb->hPort )
            {
                continue;
            }

            //
            // If the current port negotiated MRRU ie multilink.
            //

            if ( ( pPcbWalker->fFlags & PCBFLAG_CAN_BE_BUNDLED ) &&
                 ( CanPortsBeBundled( pPcbWalker, pPcb, TRUE ) ) )
            {
                if ( pPcbWalker->pBcb->dwLinkCount >= 
                                pPcbWalker->pBcb->dwMaxLinksAllowed )
                {
                    dwRetCode = ERROR_PORT_LIMIT_REACHED;

                    break;
                }

                CpIndex = GetCpIndexFromProtocol( PPP_BACP_PROTOCOL );

                if (CpIndex != (DWORD)-1)
                {
                    pCpCb = GetPointerToCPCB( pPcbWalker, CpIndex );

                    if (   pCpCb->State != FSM_OPENED
                        && ( pPcb->pBcb->fFlags & BCBFLAG_BAP_REQUIRED ))
                    {
                        PppLog( 1, "BAP is required for this user, but BACP "
                                "is not open. hPort = %d", pPcb->hPort );

                        dwRetCode = ERROR_BAP_REQUIRED;

                        break;
                    }
                }

                //
                // Either there was no authenticator and no discriminator,or
                // there were both and there was match for both. So join the
                // bundle in either case.
                //

                dwRetCode = RasPortBundle( pPcbWalker->hPort, pPcb->hPort );

                if ( dwRetCode == NO_ERROR )
                {
                    PppLog( 2, "Bundling this link with hPort = %d", 
                                pPcbWalker->hPort );

                    pPcb->hportBundleMember = pPcbWalker->hPort;
                    break;
                }
            }
        }

        if ( pPcb->hportBundleMember != (HPORT)INVALID_HANDLE_VALUE )
        {
            break;
        }
    }

    //
    // Bundle the port
    //

    if ( ( dwRetCode == NO_ERROR ) && 
         ( pPcb->hportBundleMember != (HPORT)INVALID_HANDLE_VALUE ) )
    {
        pPcbWalker->fFlags  |= PCBFLAG_IS_BUNDLED;
        pPcb->fFlags        |= PCBFLAG_IS_BUNDLED;

        pBcbOld = pPcb->pBcb;
        pPcb->pBcb = pPcbWalker->pBcb;

        pPcbWalker->hportBundleMember = pPcb->hPort;

        pPcb->pBcb->dwLinkCount++;
        pPcb->pBcb->dwAcctLinkCount++;

        for ( dwForIndex = 0; dwForIndex < pPcb->pBcb->dwPpcbArraySize; dwForIndex++ )
        {
            //
            // If there is a free space in the array of back pointers, use it
            //
            
            if ( pPcb->pBcb->ppPcb[dwForIndex] == NULL )
            {
                PppLog( 2, "Found slot %d for port %d in BCB back pointer array",
                    dwForIndex, pPcb->hPort );
                pPcb->pBcb->ppPcb[dwForIndex] = pPcb;
                break;
            }
        }

        if ( dwForIndex == pPcb->pBcb->dwPpcbArraySize )
        {
            //
            // The array of back pointers is full. ReAlloc.
            //

            ppPcb = (PPCB *) LOCAL_REALLOC( pPcb->pBcb->ppPcb,
                    2 * pPcb->pBcb->dwPpcbArraySize * sizeof( PPCB * ) );

            if (ppPcb == NULL)
            {
                //
                // Can we really assume that pPcb->pBcb->ppPcb will be left 
                // intact? The documentation for HeapReAlloc does not say so.
                //
                
                pPcb->pBcb = pBcbOld;
                pBcbOld = NULL;

                pPcbWalker->pBcb->dwLinkCount--;
                pPcbWalker->pBcb->dwAcctLinkCount--;
                pPcb->fFlags &= ~PCBFLAG_IS_BUNDLED;

                PppLog( 1, "Couldn't ReAlloc BCB back pointer array for port %d",
                    pPcb->hPort );

                dwRetCode = GetLastError();
                goto LDone;
            }

            pPcb->pBcb->ppPcb = ppPcb;
            PppLog( 2, "Found slot %d for port %d in BCB back pointer array after ReAlloc",
                dwForIndex, pPcb->hPort );

            pPcb->pBcb->ppPcb[dwForIndex++] = pPcb;
            pPcb->pBcb->dwPpcbArraySize *= 2;

            //
            // We are assuming that the new memory will be zeroed.
            //
        }
    }

LDone:

    DeallocateAndRemoveBcbFromTable( pBcbOld );
    return( dwRetCode );

}

//**
//
// Call:        AdjustHTokenImpersonateUser
//
// Returns:     VOID
//
// Description: Sets hTokenImpersonateUser in pPcb by finding another link that
//              pPcb is capable of bundling with and stealing its
//              hTokenImpersonateUser. The original hTokenImpersonateUser may
//              be INVALID_HANDLE_VALUE if this link came up because BAP called
//              RasDial.
//              

VOID
AdjustHTokenImpersonateUser(
    IN  PCB *   pPcb
)
{
    DWORD   dwIndex;
    PCB*    pPcbWalker;
    HANDLE  hToken;
    HANDLE  hTokenDuplicate;

    if ( INVALID_HANDLE_VALUE != pPcb->pBcb->hTokenImpersonateUser )
    {
        return;
    }

    for ( dwIndex = 0; dwIndex < PcbTable.NumPcbBuckets; dwIndex++ )
    {
        for( pPcbWalker = PcbTable.PcbBuckets[dwIndex].pPorts;
             pPcbWalker != NULL;
             pPcbWalker = pPcbWalker->pNext )
        {
            if ( pPcbWalker->hPort == pPcb->hPort )
            {
                continue;
            }

            hToken = pPcbWalker->pBcb->hTokenImpersonateUser;

            //
            // If the current port negotiated MRRU ie multilink.
            //

            if ( ( pPcbWalker->fFlags & PCBFLAG_CAN_BE_BUNDLED ) &&
                 ( CanPortsBeBundled( pPcbWalker, pPcb, FALSE ) ) &&
                 ( INVALID_HANDLE_VALUE != hToken ) )
            {
                if (DuplicateHandle(
                        GetCurrentProcess(),
                        hToken,
                        GetCurrentProcess(),
                        &hTokenDuplicate,
                        0,
                        TRUE,
                        DUPLICATE_SAME_ACCESS))
                {
                    pPcb->pBcb->hTokenImpersonateUser = hTokenDuplicate;
                }

                return;
            }
        }
    }
}

//**
//
// Call:        FLinkDiscriminatorIsUnique
//
// Returns:     TRUE  - Unique Link Discriminator
//              FALSE - Non-unique Link Discriminator 
//
// Description: Returns TRUE if the link discriminator of the link in pPcb is
//              unique with respect to the other links in the same bundle.
//              Otherwise, it returns FALSE and sets *pdwLinkDisc to a unique
//              value that can be used as link discrim.
//              

BOOL
FLinkDiscriminatorIsUnique(
    IN  PCB *   pPcb,
    OUT DWORD * pdwLinkDisc
) 
{
    DWORD   dwForIndex;
    DWORD   dwNewDisc;
    DWORD   dwTempDisc;
    DWORD   fDiscIsUnique = TRUE;

    dwNewDisc = ((LCPCB*)
                 (pPcb->LcpCb.pWorkBuf))->Local.Work.dwLinkDiscriminator;

    *pdwLinkDisc = 0; // The highest link discriminator seen so far
    
    for ( dwForIndex = 0;
          dwForIndex < pPcb->pBcb->dwPpcbArraySize; 
          dwForIndex++ )
    {
        if ( ( pPcb->pBcb->ppPcb[dwForIndex] != NULL ) &&
             ( pPcb->pBcb->ppPcb[dwForIndex] != pPcb ) )
        {
            dwTempDisc = ((LCPCB *)
                          (pPcb->pBcb->ppPcb[dwForIndex]->LcpCb.pWorkBuf))
                          ->Local.Work.dwLinkDiscriminator;

            if ( dwTempDisc > *pdwLinkDisc )
            {
                *pdwLinkDisc = dwTempDisc;
            }
                
            if ( dwTempDisc == dwNewDisc )
            {
                fDiscIsUnique = FALSE;
            }
        }
    }

    if ( fDiscIsUnique )
    {
        return( TRUE );
    }
    
    if ( *pdwLinkDisc != 0xFFFF )
    {
        *pdwLinkDisc += 1;

        return( FALSE );
    }

    //
    // Find a unique link discriminator
    //

    for ( dwTempDisc = 0; // A candidate for unique discriminator
          dwTempDisc < 0xFFFF; 
          dwTempDisc++ )
    {
        for ( dwForIndex = 0;
              dwForIndex < pPcb->pBcb->dwPpcbArraySize;
              dwForIndex++ )
        {
            if ( pPcb->pBcb->ppPcb[dwForIndex] != NULL )
            {
                if ( dwTempDisc ==
                     ((LCPCB *)
                      (pPcb->pBcb->ppPcb[dwForIndex]->LcpCb.pWorkBuf))
                      ->Local.Work.dwLinkDiscriminator )
                {
                    break;
                }
            }
        }

        if ( dwForIndex == pPcb->pBcb->dwPpcbArraySize )
        {
            *pdwLinkDisc = dwTempDisc;

            break;
        }
    }

    if ( dwTempDisc == 0xFFFF )
    {
        PppLog( 1, "FLinkDiscriminatorIsUnique couldn't find a unique link "
                "discriminator for port %d",
                pPcb->hPort );
    }

    return( FALSE );
}

//**
//
// Call:        CreateAccountingAttributes
//
// Returns:     VOID
//
// Description:
//
VOID
CreateAccountingAttributes(
    IN PCB * pPcb
)
{
    CHAR                    szAcctSessionId[20];
    CHAR                    szAcctMultiSessionId[20];
    DWORD                   dwIndex = 0;
    DWORD                   dwEncryptionType;
    BYTE                    abEncryptionType[6];
    DWORD                   dwRetCode;
    RAS_AUTH_ATTRIBUTE *    pAttributes                     = NULL;
    RAS_AUTH_ATTRIBUTE *    pClassAttribute                 = NULL;
    RAS_AUTH_ATTRIBUTE *    pFramedRouteAttribute           = NULL;
    RAS_AUTH_ATTRIBUTE *    pDomainAttribute                = NULL;
    HANDLE                  hAttribute;
    DWORD                   dwValue;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pGlobalDomainInfo;
    LCPCB *                 pLcpCb = (LCPCB*)(pPcb->LcpCb.pWorkBuf);
    
    RasAuthAttributeDestroy( pPcb->pAccountingAttributes );

    pPcb->pAccountingAttributes = NULL;

    if ( !( pPcb->fFlags & PCBFLAG_IS_SERVER ) )
    {
        return;
    }

    //
    // Check to see how many class attributes we have to send if any.
    //

    if ( pPcb->pAuthProtocolAttributes != NULL )    
    {
        pAttributes = pPcb->pAuthProtocolAttributes;

    }
    else if ( pPcb->pAuthenticatorAttributes != NULL )
    {
        pAttributes = pPcb->pAuthenticatorAttributes;
    }

    pClassAttribute = RasAuthAttributeGetFirst( raatClass, 
                                                pAttributes,
                                                &hAttribute );

    while( pClassAttribute != NULL )
    {
        dwIndex++;

        pClassAttribute = RasAuthAttributeGetNext( &hAttribute, raatClass );
    }

    //
    // Check to see how many Framed-Route attributes we have to send if any.
    //

    pFramedRouteAttribute = RasAuthAttributeGetFirst( raatFramedRoute, 
                                            pPcb->pAuthenticatorAttributes,
                                            &hAttribute );

    while( pFramedRouteAttribute != NULL )
    {
        dwIndex++;

        pFramedRouteAttribute = RasAuthAttributeGetNext( &hAttribute,
                                            raatFramedRoute );
    }

    pDomainAttribute = RasAuthAttributeGetVendorSpecific( 
                                                311,
                                                10,
                                                pAttributes );

    ZeroMemory( szAcctSessionId, sizeof( szAcctSessionId ) );

    _itoa(PppConfigInfo.GetNextAccountingSessionId(),szAcctSessionId, 10);

    ZeroMemory( szAcctMultiSessionId, sizeof( szAcctMultiSessionId ) );

    _itoa( pPcb->pBcb->dwBundleId, szAcctMultiSessionId, 10 );

    //
    // Allocate max total number of attributes that will be used in the
    // start and stop accouting messages.
    //

    pPcb->pAccountingAttributes = RasAuthAttributeCreate( 
                                    PPP_NUM_ACCOUNTING_ATTRIBUTES +
                                    dwIndex );

    if ( pPcb->pAccountingAttributes == NULL )
    {
        return;
    }

    do 
    {
        //
        // First insert user attributes
        //

        for( dwIndex = 0; 
             pPcb->pUserAttributes[dwIndex].raaType != raatMinimum;    
             dwIndex++ )
        {
            dwRetCode = RasAuthAttributeInsert( 
                                dwIndex,
                                pPcb->pAccountingAttributes,
                                pPcb->pUserAttributes[dwIndex].raaType,
                                FALSE,
                                pPcb->pUserAttributes[dwIndex].dwLength,
                                pPcb->pUserAttributes[dwIndex].Value );

            if ( dwRetCode != NO_ERROR )
            {
                break;
            }
        }

        if ( dwRetCode != NO_ERROR )
        {
            break;
        }

        //
        // Now insert the class attributes if there were any
        //

        pClassAttribute = RasAuthAttributeGetFirst( raatClass,
                                                    pAttributes,
                                                    &hAttribute );

        while( pClassAttribute != NULL )
        {
            dwRetCode = RasAuthAttributeInsert(
                                    dwIndex++,
                                    pPcb->pAccountingAttributes,
                                    pClassAttribute->raaType,
                                    FALSE,
                                    pClassAttribute->dwLength,
                                    pClassAttribute->Value );

            if ( dwRetCode != NO_ERROR )
            {
                break;
            }

            pClassAttribute = RasAuthAttributeGetNext( &hAttribute, 
                                                       raatClass );
        }

        if ( dwRetCode != NO_ERROR )
        {
            break;
        }

        //
        // Now insert the Framed-Route attributes if there were any
        //

        pFramedRouteAttribute = RasAuthAttributeGetFirst( raatFramedRoute,
                                                pPcb->pAuthenticatorAttributes,
                                                &hAttribute );

        while( pFramedRouteAttribute != NULL )
        {
            dwRetCode = RasAuthAttributeInsert(
                                    dwIndex++,
                                    pPcb->pAccountingAttributes,
                                    pFramedRouteAttribute->raaType,
                                    FALSE,
                                    pFramedRouteAttribute->dwLength,
                                    pFramedRouteAttribute->Value );

            if ( dwRetCode != NO_ERROR )
            {
                break;
            }

            pFramedRouteAttribute = RasAuthAttributeGetNext( &hAttribute, 
                                                       raatFramedRoute );
        }

        if ( dwRetCode != NO_ERROR )
        {
            break;
        }

        //
        // Now insert the domain attribute if there was one
        //

        if ( pDomainAttribute != NULL )
        {
            dwRetCode = RasAuthAttributeInsert(
                                    dwIndex++,
                                    pPcb->pAccountingAttributes,
                                    pDomainAttribute->raaType,
                                    FALSE,
                                    pDomainAttribute->dwLength,
                                    pDomainAttribute->Value );

            if ( dwRetCode != NO_ERROR )
            {
                break;
            }
        }

        dwRetCode = RasAuthAttributeInsert(     
                                    dwIndex++,
                                    pPcb->pAccountingAttributes,
                                    raatAcctSessionId,
                                    FALSE,
                                    strlen( szAcctSessionId ),
                                    szAcctSessionId );

        if ( dwRetCode != NO_ERROR )
        {
            break;
        }

        if ( NULL != pPcb->pBcb->szRemoteIdentity )
        {
            dwRetCode = RasAuthAttributeInsert(
                                        dwIndex++,
                                        pPcb->pAccountingAttributes,
                                        raatUserName,
                                        FALSE,
                                        strlen( pPcb->pBcb->szRemoteIdentity ),
                                        pPcb->pBcb->szRemoteIdentity );

            if ( dwRetCode != NO_ERROR )
            {
                break;
            }
        }

        if ( 0 != pPcb->pBcb->nboRemoteAddress )
        {
            dwRetCode = RasAuthAttributeInsert(
                                        dwIndex++,
                                        pPcb->pAccountingAttributes,
                                        raatFramedIPAddress,
                                        FALSE,
                                        4,
                                        (LPVOID)
                                        LongToPtr(ntohl( pPcb->pBcb->nboRemoteAddress )) );

            if ( dwRetCode != NO_ERROR )
            {
                break;
            }
        }

        {
            ULONG mru = (pLcpCb->Remote.Work.MRU > LCP_DEFAULT_MRU) ?
                        LCP_DEFAULT_MRU : pLcpCb->Remote.Work.MRU;
                        
            dwRetCode = RasAuthAttributeInsert(
                            dwIndex++,
                            pPcb->pAccountingAttributes,
                            raatFramedMTU,
                            FALSE,
                            4,
                            (LPVOID)
                            UlongToPtr(( mru )));
        }                                    

        if ( dwRetCode != NO_ERROR )
        {
            break;
        }

        if ( pPcb->pBcb->fFlags & BCBFLAG_IPCP_VJ_NEGOTIATED )
        {
            dwRetCode = RasAuthAttributeInsert(
                                        dwIndex++,
                                        pPcb->pAccountingAttributes,
                                        raatFramedCompression,
                                        FALSE,
                                        4,
                                        (LPVOID) 1 );
                                        // VJ TCP/IP header compression

            if ( dwRetCode != NO_ERROR )
            {
                break;
            }
        }

        if ( pPcb->szCallbackNumber[0] != 0 )
        {
            dwRetCode = RasAuthAttributeInsert(
                                        dwIndex++,
                                        pPcb->pAccountingAttributes,
                                        raatCallbackNumber,
                                        FALSE,
                                        strlen(pPcb->szCallbackNumber),
                                        (LPVOID)pPcb->szCallbackNumber ); 

            if ( dwRetCode != NO_ERROR )
            {
                break;
            }
        }

        if ( pPcb->dwSessionTimeout > 0 )
        {
            dwRetCode = RasAuthAttributeInsert(
                                        dwIndex++,
                                        pPcb->pAccountingAttributes,
                                        raatSessionTimeout,
                                        FALSE,
                                        4,
                                        (LPVOID)
                                        ULongToPtr(pPcb->dwSessionTimeout) );

            if ( dwRetCode != NO_ERROR )
            {
                break;
            }
        }

        if ( pPcb->dwAutoDisconnectTime > 0 )
        {
            dwRetCode = RasAuthAttributeInsert(
                                        dwIndex++,
                                        pPcb->pAccountingAttributes,
                                        raatIdleTimeout,
                                        FALSE,
                                        4,
                                        (LPVOID)
                                        ULongToPtr(pPcb->dwAutoDisconnectTime) );

            if ( dwRetCode != NO_ERROR )
            {
                break;
            }
        }

        if ( pPcb->pBcb->dwMaxLinksAllowed != 0xFFFFFFFF )
        {
            //
            // There is a real limit
            //

            dwRetCode = RasAuthAttributeInsert(
                                        dwIndex++,
                                        pPcb->pAccountingAttributes,
                                        raatPortLimit,
                                        FALSE,
                                        4,
                                        (LPVOID)
                                        ULongToPtr(pPcb->pBcb->dwMaxLinksAllowed) );

            if ( dwRetCode != NO_ERROR )
            {
                break;
            }
        }

        dwRetCode = RasAuthAttributeInsert(
                                    dwIndex++,
                                    pPcb->pAccountingAttributes,
                                    raatAcctMultiSessionId,
                                    FALSE,
                                    strlen(szAcctMultiSessionId),
                                    (LPVOID)szAcctMultiSessionId ); 

        if ( dwRetCode != NO_ERROR )
        {
            break;
        }

        dwRetCode = RasAuthAttributeInsert(
                                    dwIndex++,
                                    pPcb->pAccountingAttributes,
                                    raatAcctLinkCount,
                                    FALSE,
                                    4,
                                    (LPVOID)ULongToPtr(pPcb->pBcb->dwAcctLinkCount) );

        if ( dwRetCode != NO_ERROR )
        {
            break;
        }

        //
        // Insert event timestamp attribute
        //

        dwRetCode = RasAuthAttributeInsert(
                                    dwIndex++,
                                    pPcb->pAccountingAttributes,
                                    raatAcctEventTimeStamp,
                                    FALSE,
                                    4,
                                    (LPVOID)ULongToPtr(GetSecondsSince1970()) );

        if ( dwRetCode != NO_ERROR )
        {
            break;
        }

        if ( PppConfigInfo.fRadiusAuthenticationUsed )
        {
            dwValue = 1; // RADIUS
        }
        else
        {
            dwValue = 0;
            pGlobalDomainInfo = NULL;

            dwRetCode = DsRoleGetPrimaryDomainInformation(
                            NULL,   
                            DsRolePrimaryDomainInfoBasic,
                            (PBYTE *)&pGlobalDomainInfo );

            if ( NO_ERROR == dwRetCode )
            {
                if (   ( pGlobalDomainInfo->MachineRole ==
                         DsRole_RoleMemberServer )
                    || ( pGlobalDomainInfo->MachineRole ==
                         DsRole_RoleMemberWorkstation ) )
                {
                    dwValue = 3; // Remote
                }
                else
                {
                    dwValue = 2; // Local
                }

                DsRoleFreeMemory(pGlobalDomainInfo);
            }
            else
            {
                dwRetCode = NO_ERROR;
            }
        }

        if ( 0 != dwValue )
        {
            dwRetCode = RasAuthAttributeInsert(
                                        dwIndex++,
                                        pPcb->pAccountingAttributes,
                                        raatAcctAuthentic,
                                        FALSE,
                                        4,
                                        (LPVOID)ULongToPtr(dwValue) );

            if ( dwRetCode != NO_ERROR )
            {
                break;
            }
        }

        //
        // Insert encryption attribute
        //

        dwEncryptionType = 0;

        if ( pPcb->pBcb->fFlags & BCBFLAG_BASIC_ENCRYPTION )
        {
            dwEncryptionType = 0x00000002;
        }
        else if ( pPcb->pBcb->fFlags & BCBFLAG_STRONGER_ENCRYPTION )
        {
            dwEncryptionType = 0x00000008;
        }
        else if ( pPcb->pBcb->fFlags & BCBFLAG_STRONGEST_ENCRYPTION )
        {
            dwEncryptionType = 0x00000004;
        }

        abEncryptionType[0] = 8;    // Vendor-Type = MS_MPPE_EncryptionType
        abEncryptionType[1] = 6;    // Vendor-Length = 6
        HostToWireFormat32( dwEncryptionType, abEncryptionType + 2 );

        dwRetCode = RasAuthAttributeInsertVSA(
                                    dwIndex++,
                                    pPcb->pAccountingAttributes,
                                    311,
                                    6,
                                    abEncryptionType );

        if ( dwRetCode != NO_ERROR )
        {
            break;
        }

    } while( FALSE );

    //
    // Do not send accounting start if there was any error
    //

    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pPcb->pAccountingAttributes );

        pPcb->pAccountingAttributes = NULL;

        return;
    }

    //
    // NULL terminate 
    //

    pPcb->pAccountingAttributes[dwIndex].raaType    = raatMinimum;
    pPcb->pAccountingAttributes[dwIndex].dwLength   = 0;
    pPcb->pAccountingAttributes[dwIndex].Value      = NULL;
}

//**
//
// Call:        MakeStartAccountingCall
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Start backend authentication module accounting
//
VOID
MakeStartAccountingCall(
    IN PCB * pPcb
)
{
    LCPCB *                 pLcpCb = (LCPCB*)(pPcb->LcpCb.pWorkBuf);
    RAS_AUTH_ATTRIBUTE *    pAcctInterimIntervalAttribute               = NULL;
    RAS_AUTH_ATTRIBUTE *    pAttributes                                 = NULL;

    if ( pPcb->fFlags & PCBFLAG_ACCOUNTING_STARTED )
    {
        //
        // Already started
        //

        return;
    }

    pPcb->fFlags |= PCBFLAG_ACCOUNTING_STARTED;

    if ( pLcpCb->Local.Work.AP == 0 ) 
    {
        //
        // If the remote side was not authenticated then do not send an
        // accounting request as per RADIUS accounting RFC 2139 sec 5.6.
        //

        return;
    } 

    if ( PppConfigInfo.RasAcctProviderStartAccounting != NULL )
    {
        RAS_AUTH_ATTRIBUTE *    pAccountingAttributes;

        CreateAccountingAttributes( pPcb );

        pAccountingAttributes = RasAuthAttributeCopy( 
                                    pPcb->pAccountingAttributes );

        if ( NULL == pAccountingAttributes )
        {
            return;
        }

        RtlQueueWorkItem( StartAccounting, 
                          pAccountingAttributes, 
                          WT_EXECUTEDEFAULT );

        if ( pPcb->pAuthProtocolAttributes != NULL )    
        {
            pAttributes = pPcb->pAuthProtocolAttributes;

        }
        else if ( pPcb->pAuthenticatorAttributes != NULL )
        {
            pAttributes = pPcb->pAuthenticatorAttributes;
        }

        //
        // See if we have to do interim accounting
        //

        pAcctInterimIntervalAttribute = RasAuthAttributeGet(
                                                raatAcctInterimInterval,    
                                                pAttributes );
 
        if ( pAcctInterimIntervalAttribute != NULL )
        {
            DWORD dwInterimInterval = 
                               PtrToUlong(pAcctInterimIntervalAttribute->Value);

            if ( dwInterimInterval < 60 )
            {
                dwInterimInterval = 60;
            }

            InsertInTimerQ( 
                        pPcb->dwPortId,
                        pPcb->hPort,
                        0,
                        0,
                        FALSE,
                        TIMER_EVENT_INTERIM_ACCOUNTING,
                        dwInterimInterval );
        }
    }

    return;
}

//**
//
// Call:        InitializeNCPs
//
// Returns:     NO_ERROR 
//              Non-zero return code.
//
// Description: Will run through and initialize all the NCPs that are enabled
//              to run.
//
DWORD
InitializeNCPs(
    IN PCB * pPcb,
    IN DWORD dwConfigMask
)
{
    DWORD       dwIndex;
    BOOL        fInitSuccess    = FALSE;
    DWORD       dwRetCode       = NO_ERROR;

    if ( pPcb->fFlags & PCBFLAG_NCPS_INITIALIZED )
    {
        return( NO_ERROR );
    }
    
    pPcb->fFlags |= PCBFLAG_NCPS_INITIALIZED;

    //
    // Initialize all the CPs for this port
    //

    for( dwIndex=LCP_INDEX+1; dwIndex < PppConfigInfo.NumberOfCPs; dwIndex++ )
    {
        CPCB * pCpCb = GetPointerToCPCB( pPcb, dwIndex );

        pCpCb->fConfigurable = FALSE;

        if ( !( CpTable[dwIndex].fFlags & PPPCP_FLAG_AVAILABLE ) )
        {
            PppLog( 2, "Will not initialize CP %x",
                CpTable[dwIndex].CpInfo.Protocol );

            continue;
        }

        switch( CpTable[dwIndex].CpInfo.Protocol )
        {

        case PPP_IPCP_PROTOCOL:

            if ( dwConfigMask & PPPCFG_ProjectIp )
            {
                //
                // Make sure we have a valid interface handle if we are not
                // a client dialing out
                //

                if ( pPcb->pBcb->InterfaceInfo.IfType != (DWORD)-1 )
                {
                    if (pPcb->pBcb->InterfaceInfo.hIPInterface ==
                                                        INVALID_HANDLE_VALUE ) 
                    {
                        break;
                    }
                }

                pCpCb->fConfigurable = TRUE;

                if ( FsmInit( pPcb, dwIndex ) )
                {
                    fInitSuccess = TRUE;
                }
            }

            break;
            
        case PPP_ATCP_PROTOCOL:

            if ( dwConfigMask & PPPCFG_ProjectAt )
            {
                pCpCb->fConfigurable = TRUE;

                if ( FsmInit( pPcb, dwIndex ) )
                {
                    fInitSuccess = TRUE;
                }
            }

            break;

        case PPP_IPXCP_PROTOCOL:

            if ( dwConfigMask & PPPCFG_ProjectIpx )
            {
                //
                // Make sure we have a valid interface handle if we are not
                // a client dialing out
                //

                if ( pPcb->pBcb->InterfaceInfo.IfType != (DWORD)-1 )
                {
                    if ( pPcb->pBcb->InterfaceInfo.hIPXInterface ==
                                                        INVALID_HANDLE_VALUE )
                    {
                        break;
                    }
                }

                pCpCb->fConfigurable = TRUE;

                if ( FsmInit( pPcb, dwIndex ) )
                {
                    fInitSuccess = TRUE;
                }
            }

            break;

        case PPP_NBFCP_PROTOCOL:

            if ( dwConfigMask & PPPCFG_ProjectNbf )
            {
                //
                // If we are not a client dialing in or out do not enable
                // NBF
                //

                if ( ( pPcb->pBcb->InterfaceInfo.IfType != (DWORD)-1 ) &&
                     ( pPcb->pBcb->InterfaceInfo.IfType != 
                                                        ROUTER_IF_TYPE_CLIENT ))
                {
                    break;
                }

                pCpCb->fConfigurable = TRUE;

                if ( FsmInit( pPcb, dwIndex ) )
                {
                    fInitSuccess = TRUE;
                }
            }

            break;

        case PPP_CCP_PROTOCOL:

            pCpCb->fConfigurable = TRUE;

            if ( !( FsmInit( pPcb, dwIndex ) ) )
            {
                //
                // If encryption failed to initialize and we are forcing
                // encryption, then bring down the link
                //

                if ( dwConfigMask & ( PPPCFG_RequireEncryption        |
                                      PPPCFG_RequireStrongEncryption ) )
                {
                    //
                    // We need to send an Accounting Stop if RADIUS sends
                    // an Access Accept but we still drop the line.
                    //

                    pPcb->fFlags |= PCBFLAG_SERVICE_UNAVAILABLE;

                    dwRetCode = ERROR_NO_LOCAL_ENCRYPTION;
                }
            }

            break;

        case PPP_BACP_PROTOCOL:

            if ( ( dwConfigMask & PPPCFG_NegotiateBacp ) &&
                 ( pPcb->pBcb->fFlags & BCBFLAG_CAN_DO_BAP ) )
            {
                pCpCb->fConfigurable = TRUE;

                if ( !( FsmInit( pPcb, dwIndex ) ) )
                {
                    pPcb->pBcb->fFlags &= ~BCBFLAG_CAN_DO_BAP;
                }
            }

            break;

        default:

            break;
        }

        if ( dwRetCode != NO_ERROR )
        {
            break;
        }
    }

    //
    // If we failed to initialize one of the CPs, or CCP failed to
    // initialize and we require encryption, then we fail.
    //

    if ( ( !fInitSuccess ) || ( dwRetCode != NO_ERROR ) )
    {
        if ( dwRetCode == NO_ERROR )
        {
            dwRetCode = ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
        }

        for(dwIndex=LCP_INDEX+1;dwIndex < PppConfigInfo.NumberOfCPs;dwIndex++)
        {
            CPCB * pCpCb = GetPointerToCPCB( pPcb, dwIndex );

            if ( pCpCb->fBeginCalled == TRUE )
            {
                if ( pCpCb->pWorkBuf != NULL )
                {
                    (CpTable[dwIndex].CpInfo.RasCpEnd)( pCpCb->pWorkBuf );

                    pCpCb->pWorkBuf = NULL;
                }

                pCpCb->fBeginCalled = FALSE;
                pCpCb->fConfigurable = FALSE;
            }
        }
    }

    return( dwRetCode );
}

//**
//
// Call:        GetPointerToCPCB
//
// Returns:     Pointer to Control Protocol Control Block
//
// Description: Returns the appropriate pointer for a give CP, will return the
//              (first) local side for the AP.
//
CPCB *
GetPointerToCPCB(
    IN PCB * pPcb,
    IN DWORD CpIndex
)
{
    //
    // If the C.P. is LCP or authentication, then return the pointer to the
    // Pcb's CPCB
    //
    if ( CpIndex == (DWORD)-1 )
    {
        return( NULL );
    }
    else if ( CpIndex == LCP_INDEX )
    {
        return( &(pPcb->LcpCb) );
    }
    else if ( CpIndex >= PppConfigInfo.NumberOfCPs )
    {
        if ( CpTable[CpIndex].CpInfo.Protocol == PPP_CBCP_PROTOCOL )
        {
            return( &(pPcb->CallbackCb) );
        }

        if (CpTable[CpIndex].CpInfo.Protocol == pPcb->AuthenticatorCb.Protocol)
        {
            return( &(pPcb->AuthenticatorCb) );
        }

        if (CpTable[CpIndex].CpInfo.Protocol == pPcb->AuthenticateeCb.Protocol)
        {
            return( &(pPcb->AuthenticateeCb) );
        }
    }
    else
    {
        //
        // Otherwise for NCPs return the pointer to the Pcb's CPCB in its BCB.
        //

        return( &(pPcb->pBcb->CpCb[CpIndex-1]) );
    }

    return( NULL );
}

//**
//
// Call:        GetNewPortOrBundleId
//
// Returns:     New Id
//
// Description: Simply returns a new Id for a new port or bundle.
//

DWORD
GetNewPortOrBundleId(
    VOID
)
{
    return( PppConfigInfo.PortUIDGenerator++ );
}

//**
//
// Call:        QueryBundleNCPSate
//
// Returns:     NCP_DEAD
//              NCP_CONFIGURING
//              NCP_UP
//              NCP_DOWN
//
// Description: Will check to see if the NCPs for a certain bundle have 
//              completed their negotiation, either successfully or not.
//              If unsuccessfuly, then the retcode is 
//              ERROR_PPP_NO_PROTOCOLS_CONFIGURED
//
NCP_PHASE
QueryBundleNCPState(
    IN     PCB *   pPcb
)
{
    DWORD  dwIndex;
    CPCB * pCpCb;
    BOOL   fOneNcpConfigured    = FALSE;
    BOOL   fAllNcpsDead         = TRUE;

    for (dwIndex = LCP_INDEX+1; dwIndex < PppConfigInfo.NumberOfCPs; dwIndex++)
    {
        pCpCb = GetPointerToCPCB( pPcb, dwIndex );

        if ( pCpCb->fConfigurable )
        {
            if ( pCpCb->NcpPhase == NCP_CONFIGURING )
            {
                return( NCP_CONFIGURING );
            }
            
            if ( pCpCb->NcpPhase == NCP_UP )
            {
                fOneNcpConfigured = TRUE;
            }

            if ( pCpCb->NcpPhase != NCP_DEAD )
            {
                fAllNcpsDead = FALSE;
            }
        }
    }

    if ( fOneNcpConfigured )
    {
        return( NCP_UP );
    }

    if ( fAllNcpsDead )
    {
        return( NCP_DEAD );
    }

    return( NCP_DOWN );
}

//**
//
// Call:        NotifyCallerOfBundledProjection
//
// Returns:     None
//
// Description: Will notify the caller (i.e. supervisor or rasphone) about 
//              this link being bundled.
//              
//
VOID
NotifyCallerOfBundledProjection( 
    IN PCB * pPcb
)
{
    DWORD                       dwRetCode;
    PPP_PROJECTION_RESULT       ProjectionResult;
    BOOL                        fNCPsAreDone = FALSE;

    ZeroMemory( &ProjectionResult, sizeof( ProjectionResult ) );

    //
    // Notify the ras client and the ras server about the 
    // projections
    //

    dwRetCode = GetConfiguredInfo( pPcb,
                                   0,   // don't care
                                   &ProjectionResult,
                                   &fNCPsAreDone );

    if ( dwRetCode != NO_ERROR )
    {
        return;
    }


    if ( !fNCPsAreDone )
    {
        return;
    }

    //
    // Now get LCP information
    //

    ProjectionResult.lcp.hportBundleMember = pPcb->hportBundleMember;
    ProjectionResult.lcp.szReplyMessage = pPcb->pBcb->szReplyMessage;

    dwRetCode = (CpTable[LCP_INDEX].CpInfo.RasCpGetNegotiatedInfo)(
                                    pPcb->LcpCb.pWorkBuf,
                                    &(ProjectionResult.lcp));

    if ( RAS_DEVICE_TYPE( pPcb->dwDeviceType ) == RDT_Tunnel_L2tp )
    {
        if ( pPcb->pBcb->fFlags & BCBFLAG_BASIC_ENCRYPTION )
        {
            ProjectionResult.lcp.dwLocalOptions |= PPPLCPO_DES_56;
            ProjectionResult.lcp.dwRemoteOptions |= PPPLCPO_DES_56;
        }
        else if ( pPcb->pBcb->fFlags & BCBFLAG_STRONGEST_ENCRYPTION )
        {
            ProjectionResult.lcp.dwLocalOptions |= PPPLCPO_3_DES;
            ProjectionResult.lcp.dwRemoteOptions |= PPPLCPO_3_DES;
        }
    }

    ProjectionResult.lcp.dwLocalEapTypeId = pPcb->dwServerEapTypeId;
    ProjectionResult.lcp.dwRemoteEapTypeId = pPcb->dwClientEapTypeId;

    if ( dwRetCode != NO_ERROR )
    {
        return;
    }

    if ( pPcb->fFlags & PCBFLAG_IS_SERVER )
    {
        NotifyCaller( pPcb, PPPDDMMSG_PppDone, &ProjectionResult );
    }
    else
    {
        NotifyCaller( pPcb, PPPMSG_ProjectionResult, &ProjectionResult);

        NotifyCaller( pPcb, PPPMSG_PppDone, NULL );
    }
}

//**
//
// Call:        StartNegotiatingNCPs
//
// Returns:     None
//
// Description: Will start NCP negogiating for the particular port or bundle
//
VOID
StartNegotiatingNCPs(
    IN PCB * pPcb
)
{
    DWORD       dwIndex;

    pPcb->PppPhase = PPP_NCP;

    for (dwIndex = LCP_INDEX+1; dwIndex < PppConfigInfo.NumberOfCPs; dwIndex++)
    {
        CPCB * pCpCb = GetPointerToCPCB( pPcb, dwIndex );

        if ( pCpCb->fConfigurable )
        {
            pCpCb->NcpPhase = NCP_CONFIGURING;

            FsmOpen( pPcb, dwIndex );

            FsmUp( pPcb, dwIndex );
        }
    }
}

//**
//
// Call:        StartAutoDisconnectForPort
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will insert an auto disconnect and sesison timeout item in the 
//              timer Q
//
VOID
StartAutoDisconnectForPort( 
    IN PCB * pPcb 
)
{
    //
    // Do session timeout if there is any
    //

    if ( pPcb->fFlags & PCBFLAG_IS_SERVER )
    {
        RAS_AUTH_ATTRIBUTE * pAttribute;
        RAS_AUTH_ATTRIBUTE * pUserAttributes = ( pPcb->pAuthProtocolAttributes )
                                               ? pPcb->pAuthProtocolAttributes
                                               : pPcb->pAuthenticatorAttributes;

        pAttribute = RasAuthAttributeGet( raatSessionTimeout, pUserAttributes);

        if ( pAttribute != NULL )
        {
            pPcb->dwSessionTimeout = PtrToUlong(pAttribute->Value);
        }
        else
        {
            pPcb->dwSessionTimeout = PppConfigInfo.dwDefaultSessionTimeout;
        }

        PppLog( 2, "AuthAttribute SessionTimeout = %d", pPcb->dwSessionTimeout);
                          
        if ( pPcb->dwSessionTimeout > 0 )
        {
            //
            // Remove any previous session-disconnect time item from the
            // queue if there was one.
            //

            RemoveFromTimerQ( pPcb->dwPortId,
                              0,
                              0,
                              FALSE,
                              TIMER_EVENT_SESSION_TIMEOUT );

            InsertInTimerQ( pPcb->dwPortId,
                            pPcb->hPort,
                            0,
                            0,
                            FALSE,
                            TIMER_EVENT_SESSION_TIMEOUT,
                            pPcb->dwSessionTimeout );
        }
    }

    //
    // Do not start autodisconnect for router interfaces that have 
    // dialed in, the router dialing in will take care of this.
    //

    if ( ( pPcb->fFlags & PCBFLAG_IS_SERVER ) && 
         ( pPcb->pBcb->InterfaceInfo.IfType == ROUTER_IF_TYPE_FULL_ROUTER ) )
    {
        return;
    }

    //
    // If the AutoDisconnectTime is not infinte, put a timer
    // element on the queue that will wake up in AutoDisconnectTime.
    //

    if ( pPcb->dwAutoDisconnectTime > 0 )
    {
        PppLog( 2, "Inserting autodisconnect in timer q for port=%d, sec=%d",
                    pPcb->hPort, pPcb->dwAutoDisconnectTime );

        //
        // Remove any previous auto-disconnect time item from the
        // queue if there was one.
        //

        RemoveFromTimerQ( pPcb->dwPortId,
                          0,
                          0,
                          FALSE,
                          TIMER_EVENT_AUTODISCONNECT);

        InsertInTimerQ( pPcb->dwPortId,
                        pPcb->hPort,
                        0,
                        0,
                        FALSE,
                        TIMER_EVENT_AUTODISCONNECT,
                        pPcb->dwAutoDisconnectTime );
    }
}

//**
//
// Call:        StartLCPEchoForPort
//
// Returns:     None
//              
//
// Description: Will insert an LCPEcho item in the timer Q
//

VOID
StartLCPEchoForPort( 
    IN PCB * pPcb 
)
{
    if ( !(pPcb->fFlags & PCBFLAG_IS_SERVER) )
    {
		//if this is a client.
		//check to see if the connection type is broadband - PPPOE in particular
		
		if (   (RAS_DEVICE_TYPE(pPcb->dwDeviceType) == RDT_PPPoE)
		    && pPcb->dwIdleBeforeEcho )
		{
			PppLog( 2, "LCPEchoTimeout = %d", pPcb->dwIdleBeforeEcho);
			pPcb->fEchoRequestSend = 0;				
			pPcb->dwNumEchoResponseMissed = 0;		//No responses missed yet
	        InsertInTimerQ( pPcb->dwPortId,
		                    pPcb->hPort,
			                0,
				            0,
					        FALSE,
						    TIMER_EVENT_LCP_ECHO,
							pPcb->dwIdleBeforeEcho );
							
		}
	}
	return;
}


//**
//
// Call:        NotifyCompletionOnBundledPorts
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will notify all ports that are bundled with this port and
//              are waiting to for negotiation to complete on the bundle.
//
VOID
NotifyCompletionOnBundledPorts(
    IN PCB * pPcb
)
{
    DWORD   dwIndex;
    PCB *   pPcbWalker;

    //
    // Walk thru the list of PCBs
    //

    for ( dwIndex = 0; dwIndex < PcbTable.NumPcbBuckets; dwIndex++ )
    {
        for( pPcbWalker = PcbTable.PcbBuckets[dwIndex].pPorts;
             pPcbWalker != NULL;
             pPcbWalker = pPcbWalker->pNext )
        {
            if ( ( pPcbWalker->hPort != pPcb->hPort ) &&
                 ( pPcbWalker->fFlags & PCBFLAG_IS_BUNDLED ) &&
                 ( CanPortsBeBundled( pPcbWalker, pPcb, TRUE ) ) )
            {
                //
                // In our bundle so notify the caller of completion on this
                // port.
                //

                RemoveFromTimerQ( pPcbWalker->dwPortId,
                                  0,
                                  0,
                                  FALSE,
                                  TIMER_EVENT_NEGOTIATETIME );

                NotifyCallerOfBundledProjection( pPcbWalker );

                StartAutoDisconnectForPort( pPcbWalker );
            }
        }
    }
}

//**
//
// Call:        RemoveNonNumerals
//
// Returns:     VOID
//
// Description: Removes any character that is not an ASCII digit from
//              the string szString
//
VOID
RemoveNonNumerals( 
    IN  CHAR*   szString
)
{
    CHAR    c;
    DWORD   dwIndexOld;
    DWORD   dwIndexNew;

    if (NULL == szString)
    {
        return;
    }

    for (dwIndexOld = 0, dwIndexNew = 0;
         (c = szString[dwIndexOld]) != 0;
         dwIndexOld++)
    {
        if (isdigit(c))
        {
            szString[dwIndexNew++] = c;
        }
    }

    szString[dwIndexNew] = 0;
}

//**
//
// Call:        GetTextualSid
//
// Returns:     TRUE         - Success
//              FALSE        - Failure
//
// Description: The GetTextualSid function will convert a binary Sid to a
//              textual string. Obtained from the Knowledge Base.
//              Article ID: Q131320
//
BOOL
GetTextualSid( 
    IN  PSID    pSid,           // binary Sid
    OUT CHAR*   TextualSid,     // buffer for Textual representaion of Sid
    IN  LPDWORD dwBufferLen     // required/provided TextualSid buffersize
)
{ 
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwSidRev=SID_REVISION;
    DWORD dwCounter;
    DWORD dwSidSize;

    //
    // test if Sid passed in is valid
    //

    if(!IsValidSid(pSid))
        return FALSE;

    //
    // obtain SidIdentifierAuthority
    //

    psia=GetSidIdentifierAuthority(pSid);

    //
    // obtain sidsubauthority count
    //

    dwSubAuthorities=*GetSidSubAuthorityCount(pSid);

    //
    // compute buffer length
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //

    dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //

    if (*dwBufferLen < dwSidSize)
    {
        *dwBufferLen = dwSidSize;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // prepare S-SID_REVISION-
    //

    dwSidSize=wsprintfA(TextualSid, "S-%lu-", dwSidRev );

    //
    // prepare SidIdentifierAuthority
    //

    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
    {
        dwSidSize+=wsprintfA(TextualSid + lstrlenA(TextualSid),
                    "0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
    }
    else
    {
        dwSidSize+=wsprintfA(TextualSid + lstrlenA(TextualSid),
                    "%lu",
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
    }

    //
    // loop through SidSubAuthorities
    //

    for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
    {
        dwSidSize+=wsprintfA(TextualSid + dwSidSize, "-%lu",
                    *GetSidSubAuthority(pSid, dwCounter) );
    }

    return TRUE;
}

//**
//
// Call:        TextualSidFromPid
//
// Returns:     NULL        - Failure
//              non-NULL    - Success
//
// Description: Will LOCAL_ALLOC a Textual Sid for a user whose pid is dwPid.
//
CHAR*
TextualSidFromPid(
    DWORD   dwPid
)
{
#define BUF_SIZE    256

    BOOL        fFreeTextualSid         = FALSE;
    CHAR*       szTextualSid            = NULL;
    HANDLE      ProcessHandle           = NULL;
    HANDLE      TokenHandle             = INVALID_HANDLE_VALUE;

    TOKEN_USER  ptgUser[BUF_SIZE];
    DWORD       cbBuffer;
    DWORD       cbSid;

    szTextualSid = LOCAL_ALLOC( LPTR, sizeof( CHAR ) * BUF_SIZE );

    if ( NULL == szTextualSid )
    {
        BapTrace( "LOCAL_ALLOC() returned error %d", GetLastError() );
        goto LDone;
    }

    fFreeTextualSid = TRUE;

    ProcessHandle = OpenProcess(
            PROCESS_ALL_ACCESS,
            FALSE /* bInheritHandle */,
            dwPid );

    if ( NULL == ProcessHandle )
    {
        BapTrace( "OpenProcess() returned error %d", GetLastError() );
        goto LDone;
    }

    if ( !OpenProcessToken( ProcessHandle, TOKEN_QUERY, &TokenHandle ) )
    {
        BapTrace( "OpenProcessToken() returned error %d", GetLastError() );
        goto LDone;
    }

    cbBuffer = BUF_SIZE;

    if ( !GetTokenInformation(
                TokenHandle,
                TokenUser,
                ptgUser, 
                cbBuffer,
                &cbBuffer ) ) // Look at KB article Q131320
    {
        BapTrace( "GetTokenInformation() returned error %d", GetLastError() );
        goto LDone;
    }

    cbSid = BUF_SIZE;

    if ( !GetTextualSid(
                ptgUser->User.Sid,
                szTextualSid,
                &cbSid ) )
    {
        BapTrace( "GetTextualSid() returned error %d", GetLastError() );
        goto LDone;
    }

    fFreeTextualSid = FALSE;

LDone:

    if ( NULL != ProcessHandle )
    {
        CloseHandle( ProcessHandle );
    }

    if ( INVALID_HANDLE_VALUE != TokenHandle )
    {
        CloseHandle( TokenHandle );
    }

    if ( fFreeTextualSid )
    {
        LOCAL_FREE( szTextualSid );
        szTextualSid = NULL;
    }

    return( szTextualSid );
}

//**
//
// Call:        GetRouterPhoneBook
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will LocalAlloc and set pszPhonebookPath to point to the
//              full path of the router phonebook.
//
DWORD
GetRouterPhoneBook(
    CHAR**  pszPhonebookPath
) 
{
    DWORD dwSize;
    DWORD cchDir = GetWindowsDirectoryA( NULL, 0 );
    CHAR* szPhonebookPath;

    *pszPhonebookPath = NULL;

    if ( cchDir == 0 )
    {
        return( GetLastError() );
    }

    dwSize=(cchDir+lstrlenA("\\system32\\ras\\router.pbk")+1)*sizeof(CHAR);

    if ( ( szPhonebookPath = LocalAlloc( LPTR, dwSize ) ) == NULL )
    {
        return( GetLastError() );
    }

    if ( GetWindowsDirectoryA( szPhonebookPath, cchDir ) == 0 )
    {
        LocalFree( szPhonebookPath );
        return( GetLastError() );
    }

    if ( szPhonebookPath[cchDir-1] != '\\' )
    {
        lstrcatA( szPhonebookPath, "\\" );
    }

    lstrcatA( szPhonebookPath, "system32\\ras\\router.pbk" );

    *pszPhonebookPath = szPhonebookPath;
    return( NO_ERROR );
}

//**
//
// Call:        GetCredentialsFromInterface
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Get the credentials for the interface called
//              pPcb->pBcb->szRemoteUserName.
//
DWORD
GetCredentialsFromInterface(
    PCB *   pPcb
) 
{
    WCHAR   wchUserName[UNLEN+1];
    WCHAR   wchPassword[PWLEN+1];
    WCHAR   wchDomainName[DNLEN+1];
    WCHAR   wchInterfaceName[UNLEN+1];
    DWORD   dwRetCode;

    wchUserName[0] = wchPassword[0] = wchDomainName[0] = wchInterfaceName[0] = 
        0;

    if ( 0 == MultiByteToWideChar(
                    CP_ACP,
                    0,
                    pPcb->pBcb->szRemoteUserName,
                    -1,
                    wchInterfaceName,
                    sizeof( wchInterfaceName ) / sizeof( WCHAR ) ) )
    {
        dwRetCode = GetLastError();

        return( dwRetCode );
    }

    dwRetCode =  MprAdminInterfaceGetCredentialsInternal(
                                        NULL,
                                        wchInterfaceName,
                                        wchUserName,
                                        wchPassword,
                                        wchDomainName );

    if ( NO_ERROR == dwRetCode )
    {
        if ( 0 == WideCharToMultiByte(
                        CP_ACP,
                        0,
                        wchUserName,
                        -1,
                        pPcb->pBcb->szLocalUserName,
                        sizeof( pPcb->pBcb->szLocalUserName ),
                        NULL,
                        NULL ) )
        {
            dwRetCode = GetLastError();

            return( dwRetCode );
        }

        if ( 0 == WideCharToMultiByte(
                        CP_ACP,
                        0,
                        wchPassword,
                        -1,
                        pPcb->pBcb->szPassword,
                        sizeof( pPcb->pBcb->szPassword ),
                        NULL,
                        NULL ) )
        {
            dwRetCode = GetLastError();

            return( dwRetCode );
        }

        if ( 0 == WideCharToMultiByte(
                        CP_ACP,
                        0,
                        wchDomainName,
                        -1,
                        pPcb->pBcb->szLocalDomain,
                        sizeof( pPcb->pBcb->szLocalDomain ),
                        NULL,
                        NULL ) )
        {
            dwRetCode = GetLastError();

            return( dwRetCode );
        }

        //
        // Null out password buffer
        //

        ZeroMemory( wchPassword, sizeof( wchPassword ) );
        EncodePw( pPcb->pBcb->chSeed, pPcb->pBcb->szPassword );
        EncodePw( pPcb->pBcb->chSeed, pPcb->pBcb->szOldPassword );
    }

    return( dwRetCode );
}

//**
//
// Call:        IsCpIndexOfAp
//
// Returns:     TRUE  - The CpIndex belongs to an Authentication Protocol
//              FALSE - Otherwise 
//
// Description:
//
BOOL
IsCpIndexOfAp( 
    IN DWORD CpIndex 
)
{
    if ( CpIndex >= PppConfigInfo.NumberOfCPs )
    {
        return( TRUE );
    }

    return( FALSE );
}

//**
//
// Call:        StartAccounting
//
// Returns:     None
//
// Description: Will start accounting if the back-end authentication provider
//              supports it.
//
VOID
StartAccounting(
    PVOID pContext
)
{
    DWORD                dwRetCode;
    RAS_AUTH_ATTRIBUTE * pInAttributes  = (RAS_AUTH_ATTRIBUTE*)pContext;
    RAS_AUTH_ATTRIBUTE * pOutAttributes = NULL;

    dwRetCode = (*PppConfigInfo.RasAcctProviderStartAccounting)( 
                                                    pInAttributes,
                                                    &pOutAttributes );

    if ( pOutAttributes != NULL )
    {
        PppConfigInfo.RasAuthProviderFreeAttributes( pOutAttributes );
    }

    RasAuthAttributeDestroy( pInAttributes );
}

//**
//
// Call:        InterimAccounting
//
// Returns:     None
//
// Description: Will send and interim accounting packet if the back-end 
//              authentication provider supports it.
//
VOID
InterimAccounting(
    PVOID pContext
)
{
    DWORD                dwRetCode;
    RAS_AUTH_ATTRIBUTE * pInAttributes  = (RAS_AUTH_ATTRIBUTE*)pContext;
    RAS_AUTH_ATTRIBUTE * pOutAttributes = NULL;

    dwRetCode = (*PppConfigInfo.RasAcctProviderInterimAccounting)(
                                                    pInAttributes,
                                                    &pOutAttributes );

    if ( pOutAttributes != NULL )
    {
        PppConfigInfo.RasAuthProviderFreeAttributes( pOutAttributes );
    }

    RasAuthAttributeDestroy( pInAttributes );
}




//**
//
// Call:        StopAccounting
//
// Returns:     None
//
// Description: Will stop accounting if the back-end authentication provider
//              supports it.
//
VOID
StopAccounting(
    PVOID pContext
)
{
    DWORD						dwRetCode;
	PSTOP_ACCOUNTING_CONTEXT	pAcctContext = (PSTOP_ACCOUNTING_CONTEXT)pContext;
    RAS_AUTH_ATTRIBUTE * pInAttributes  = pAcctContext->pAuthAttributes;
    RAS_AUTH_ATTRIBUTE * pOutAttributes = NULL;
	PPPE_MESSAGE PppMessage;

    //
    // It is possible that StopAccounting will be queued on a worker thread 
    // soon after a StartAccounting (Win2000 bug 376334). We don't want the 
    // StopAccounting to finish before the StartAccounting. Hence the sleep.
    // The real fix is to make sure that the same thread calls both 
    // StartAccounting and StopAccounting.
    //
	PppLog ( 2, "Stopping Accounting for port %d", pAcctContext->pPcb->hPort );
    Sleep( 2000 );

    dwRetCode = (*PppConfigInfo.RasAcctProviderStopAccounting)( 
                                                    pInAttributes,
                                                    &pOutAttributes );

    if ( pOutAttributes != NULL )
    {
        PppConfigInfo.RasAuthProviderFreeAttributes( pOutAttributes );
    }

    RasAuthAttributeDestroy( pInAttributes );

    ZeroMemory ( &PppMessage, sizeof(PppMessage));

    PppMessage.hPort    = pAcctContext->pPcb->hPort;
    PppMessage.dwMsgId  = PPPEMSG_PostLineDown;
	PppMessage.ExtraInfo.PostLineDown.pPcb = (VOID *)pAcctContext->pPcb;
	//Call PostLineDown
    SendPPPMessageToEngine( &PppMessage );
	LocalFree(pAcctContext);
}

//**
//
// Call:        StripCRLF
//
// Returns:     Strips out CR and LF characters from the string
//
// Description:
//
VOID
StripCRLF(
    CHAR*   psz
)
{
    DWORD   dw1;
    DWORD   dw2;
    CHAR    ch;

    if ( NULL == psz )
    {
        return;
    }

    dw1 = 0;
    dw2 = 0;

    while ( ( ch = psz[dw1++] ) != 0 )
    {
        if (   ( ch == 0xD )
            || ( ch == 0xA ) )
        {
            //
            // Don't copy this character
            //

            continue;
        }

        psz[dw2++] = ch;
    }

    psz[dw2] = 0;
}

//**
//
// Call:        GetUserAttributes
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
RAS_AUTH_ATTRIBUTE * 
GetUserAttributes( 
    PCB * pPcb 
)
{
    RAS_AUTH_ATTRIBUTE *    pAttributes     = NULL;
    DWORD                   dwRetCode       = NO_ERROR;
    DWORD                   dwIndex         = 0;
    RAS_CONNECT_INFO *      pConnectInfo    = NULL;
    DWORD                   dwSize          = 0;
    DWORD                   dwNASPortType   = (DWORD)-1;
    DWORD                   dwValue;
    BOOL                    fTunnel         = FALSE;

    if ( pPcb->pUserAttributes != NULL )
    {
        return( NULL );
    }

    pAttributes = RasAuthAttributeCreate( PPP_NUM_USER_ATTRIBUTES );

    if ( pAttributes == NULL )
    {
        return( NULL );
    }

    do
    {
        if ( PppConfigInfo.szNASIdentifier[0] != 0 )
        {
            dwRetCode = RasAuthAttributeInsert(
                                        dwIndex++,
                                        pAttributes,
                                        raatNASIdentifier,
                                        FALSE,
                                        strlen( PppConfigInfo.szNASIdentifier ),
                                        (LPVOID)PppConfigInfo.szNASIdentifier );

            if ( dwRetCode != NO_ERROR )
            {
                break;
            }
        }

        if ( PppConfigInfo.dwNASIpAddress != 0 )
        {
            dwRetCode = RasAuthAttributeInsert(
                                        dwIndex++,
                                        pAttributes,
                                        raatNASIPAddress,
                                        FALSE,
                                        4,
                                        (LPVOID)ULongToPtr(PppConfigInfo.dwNASIpAddress) );
        }

        if ( dwRetCode != NO_ERROR )
        {
            break;
        }

        dwRetCode = RasAuthAttributeInsert( dwIndex++,
                                            pAttributes,
                                            raatServiceType,
                                            FALSE,
                                            4,
                                            UlongToPtr
                                            ( ( pPcb->fFlags &
                                                PCBFLAG_THIS_IS_A_CALLBACK ) ?
                                                    4 :     // Callback Framed
                                                    2 ) );  // Framed

        if ( dwRetCode != NO_ERROR )
        {
            break;
        }

        dwRetCode = RasAuthAttributeInsert( dwIndex++,
                                            pAttributes,
                                            raatFramedProtocol,
                                            FALSE,
                                            4,
                                            (LPVOID)1 ); //PPP
        if ( dwRetCode != NO_ERROR )
        {
            break;
        }

        dwRetCode = RasAuthAttributeInsert( dwIndex++,
                                            pAttributes,
                                            raatNASPort,
                                            FALSE,
                                            4,
                                            (LPVOID)pPcb->hPort );
        if ( dwRetCode != NO_ERROR )
        {
            break;
        }

        {
            BYTE    MSRASVendor[10];
            BYTE    MSRASVersion[30];
            BYTE    bLength;

            HostToWireFormat32( 311, MSRASVendor );     // Vendor-Id
            MSRASVendor[4] = 9; // Vendor-Type: MS-RAS-Vendor
            MSRASVendor[5] = 6;                         // Vendor-Length
            HostToWireFormat32( 311, MSRASVendor + 6) ; // Vendor-Id

            dwRetCode = RasAuthAttributeInsert( dwIndex++,
                                                pAttributes,
                                                raatVendorSpecific,
                                                FALSE,
                                                10,
                                                &MSRASVendor );
            if ( dwRetCode != NO_ERROR )
            {
                break;
            }

            bLength = (BYTE)strlen( MS_RAS_VERSION );
            RTASSERT( 30 >= 6 + bLength );

            HostToWireFormat32( 311, MSRASVersion );    // Vendor-Id
            MSRASVersion[4] = 18; // Vendor-Type: MS-RAS-Version
            MSRASVersion[5] = 2 + bLength;              // Vendor-Length
            CopyMemory( MSRASVersion + 6, MS_RAS_VERSION, bLength );

            dwRetCode = RasAuthAttributeInsert( dwIndex++,
                                                pAttributes,
                                                raatVendorSpecific,
                                                FALSE,
                                                6 + bLength,
                                                &MSRASVersion );
            if ( dwRetCode != NO_ERROR )
            {
                break;
            }
        }

		
        switch( RAS_DEVICE_TYPE( pPcb->dwDeviceType ) )
        {
        case RDT_Modem:
        case RDT_Serial:
            dwNASPortType = 0;
            break;

        case RDT_Isdn:
            dwNASPortType = 2;
            break;

        case RDT_Tunnel_Pptp:
        case RDT_Tunnel_L2tp:
            dwNASPortType = 5;
            fTunnel = TRUE;
            break;

        default:
            dwNASPortType = (DWORD)-1;
            break;
        }

        if ( dwNASPortType != (DWORD)-1 )
        {
            dwRetCode = RasAuthAttributeInsert( dwIndex++,
                                                pAttributes,
                                                raatNASPortType,
                                                FALSE,
                                                4,
                                                (LPVOID)ULongToPtr(dwNASPortType) );
            if ( dwRetCode != NO_ERROR )
            {
                break;
            }
        }

        if ( fTunnel )
        {
            dwValue = 0;
            ((BYTE*)(&dwValue))[0] =
                ( RAS_DEVICE_TYPE( pPcb->dwDeviceType ) == RDT_Tunnel_Pptp ) ?
                    1 : 3;

            dwRetCode = RasAuthAttributeInsert( 
                                dwIndex++,
                                pAttributes,
                                raatTunnelType, 
                                FALSE,
                                4,
                                (LPVOID)ULongToPtr(dwValue) );

            if ( dwRetCode != NO_ERROR )
            {
                break;
            }

            dwRetCode = RasAuthAttributeInsert( 
                                dwIndex++,
                                pAttributes,
                                raatTunnelMediumType, 
                                FALSE,
                                4,
                                (LPVOID)1 ); // IP

            if ( dwRetCode != NO_ERROR )
            {
                break;
            }
        }

        if (   ( pPcb->fFlags & PCBFLAG_IS_SERVER )
            && ( pPcb->fFlags & PCBFLAG_THIS_IS_A_CALLBACK ) )
        {
            //
            // send the calling-station-id attrib with the number dialed
            //

            dwRetCode = RasAuthAttributeInsert(
                                dwIndex++,
                                pAttributes,
                                raatCallingStationId,
                                FALSE,
                                strlen( pPcb->szCallbackNumber ),
                                (VOID*) pPcb->szCallbackNumber );

            if ( dwRetCode != NO_ERROR )
            {
                break;
            }
        }

        if ( RasGetConnectInfo( pPcb->hPort, &dwSize, NULL )
                                                    == ERROR_BUFFER_TOO_SMALL )
        {
            if ( ( pConnectInfo = LOCAL_ALLOC( LPTR, dwSize ) ) != NULL )
            {
                if ( RasGetConnectInfo( pPcb->hPort, &dwSize, pConnectInfo )
                                                    == NO_ERROR )
                {
                    if (   ( pConnectInfo->dwCalledIdSize > 0 )
                        && ( pConnectInfo->pszCalledId[0] != 0 ) )
                    {
                        dwRetCode = RasAuthAttributeInsert( 
                                            dwIndex++,
                                            pAttributes,
                                            raatCalledStationId, 
                                            FALSE,
                                            strlen(pConnectInfo->pszCalledId),
                                            (LPVOID)pConnectInfo->pszCalledId );

                        if ( dwRetCode != NO_ERROR )
                        {
                            break;
                        }

                        if ( fTunnel )
                        {
                            dwRetCode = RasAuthAttributeInsert( 
                                            dwIndex++,
                                            pAttributes,
                                            raatTunnelServerEndpoint, 
                                            FALSE,
                                            strlen(pConnectInfo->pszCalledId),
                                            (LPVOID)pConnectInfo->pszCalledId );

                            if ( dwRetCode != NO_ERROR )
                            {
                                break;
                            }
                        }
                    }
                    else if (    ( pConnectInfo->dwAltCalledIdSize > 0 )
                              && ( pConnectInfo->pszAltCalledId[0] != 0 ) )
                    {
                        dwRetCode = RasAuthAttributeInsert(
                                        dwIndex++,
                                        pAttributes,
                                        raatCalledStationId,
                                        FALSE,
                                        strlen(pConnectInfo->pszAltCalledId),
                                        (LPVOID)pConnectInfo->pszAltCalledId );

                        if ( dwRetCode != NO_ERROR )
                        {
                            break;
                        }

                        if ( fTunnel )
                        {
                            dwRetCode = RasAuthAttributeInsert( 
                                        dwIndex++,
                                        pAttributes,
                                        raatTunnelServerEndpoint, 
                                        FALSE,
                                        strlen(pConnectInfo->pszAltCalledId),
                                        (LPVOID)pConnectInfo->pszAltCalledId );

                            if ( dwRetCode != NO_ERROR )
                            {
                                break;
                            }
                        }
                    }        

                    if (    ( pConnectInfo->dwCallerIdSize > 0 )
                         && ( pConnectInfo->pszCallerId[0] != 0 ) )
                    {
                        dwRetCode = RasAuthAttributeInsert(
                                            dwIndex++,
                                            pAttributes,
                                            raatCallingStationId,
                                            FALSE,
                                            strlen(pConnectInfo->pszCallerId),
                                            (LPVOID)pConnectInfo->pszCallerId );

                        if ( dwRetCode != NO_ERROR )
                        {
                            break;
                        }

                        if ( fTunnel )
                        {
                            dwRetCode = RasAuthAttributeInsert( 
                                            dwIndex++,
                                            pAttributes,
                                            raatTunnelClientEndpoint, 
                                            FALSE,
                                            strlen(pConnectInfo->pszCallerId),
                                            (LPVOID)pConnectInfo->pszCallerId );

                            if ( dwRetCode != NO_ERROR )
                            {
                                break;
                            }
                        }
                    }

                    StripCRLF( pConnectInfo->pszConnectResponse );

                    if ( pConnectInfo->dwConnectResponseSize > 0 )
                    {
                        dwRetCode = RasAuthAttributeInsert(
                                      dwIndex++,
                                      pAttributes,
                                      raatConnectInfo,
                                      FALSE,
                                      strlen( pConnectInfo->pszConnectResponse),
                                      (LPVOID)pConnectInfo->pszConnectResponse);

                        if ( dwRetCode != NO_ERROR )
                        {
                            break;
                        }
                    }
                }
            }
        }

        pAttributes[dwIndex].raaType  = raatMinimum;
        pAttributes[dwIndex].dwLength = 0;
        pAttributes[dwIndex].Value    = NULL;

    } while( FALSE );

    if ( pConnectInfo != NULL )
    {
        LOCAL_FREE( pConnectInfo );
    }

    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pAttributes );

        return( NULL );
    }

    return( pAttributes );
}

//**
//
// Call:        MakeStopOrInterimAccountingCall
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
VOID
MakeStopOrInterimAccountingCall(
    IN PCB *    pPcb,
    IN BOOL     fInterimAccounting
)
{
    ULARGE_INTEGER          qwCurrentTime;
    ULARGE_INTEGER          qwUpTime;
    DWORD                   dwRemainder;
    DWORD                   dwActiveTimeInSeconds;
    DWORD                   dwRetCode;
    BYTE buffer[sizeof(RAS_STATISTICS) + (MAX_STATISTICS * sizeof (ULONG))];
    RAS_STATISTICS *        pStats = (RAS_STATISTICS *)buffer;
    DWORD                   dwSize = sizeof (buffer);
    DWORD                   dwIndex;
    RAS_AUTH_ATTRIBUTE *    pAttribute;
    RAS_AUTH_ATTRIBUTE *    pAccountingAttributes;
    LCPCB *                 pLcpCb = (LCPCB*)(pPcb->LcpCb.pWorkBuf);
	PSTOP_ACCOUNTING_CONTEXT  pStopAcctContext = NULL;

	if ( !pLcpCb )
	{
		return;
	}
    if ( pLcpCb->Local.Work.AP == 0 )
    {
        //
        // If the remote side was not authenticated then do not send an
        // accounting request as per RADIUS accounting RFC 2139 sec 5.6.
        //

        RasAuthAttributeDestroy( pPcb->pAccountingAttributes );

        pPcb->pAccountingAttributes = NULL;

        return;
    }

    if ( fInterimAccounting )
    {
        if ( PppConfigInfo.RasAcctProviderInterimAccounting == NULL )
        {
            RasAuthAttributeDestroy( pPcb->pAccountingAttributes );

            pPcb->pAccountingAttributes = NULL;

            return;
        }
    }
    else
    {
        if ( PppConfigInfo.RasAcctProviderStopAccounting == NULL )
        {
            RasAuthAttributeDestroy( pPcb->pAccountingAttributes );

            pPcb->pAccountingAttributes = NULL;

            return;
        }
    }

    //
    // If we have not sent an interim accouting packet then we need to
    // create attributes
    //

    if ( !( pPcb->fFlags & PCBFLAG_INTERIM_ACCT_SENT ) )
    {
        //
        // Find out where the array is terminated and then insert attributes
        //

        for ( dwIndex = 0;
              pPcb->pAccountingAttributes[dwIndex].raaType != raatMinimum;
              dwIndex++ );

        //
        // Undo the NULL termination
        //

        pPcb->pAccountingAttributes[dwIndex].raaType  = raatReserved;
        pPcb->pAccountingAttributes[dwIndex].dwLength = 0;
        pPcb->pAccountingAttributes[dwIndex].Value    = NULL;

        do
        {
            //
            // Insert session time
            //

            GetSystemTimeAsFileTime( (FILETIME*)&qwCurrentTime );

            if ( ( qwCurrentTime.QuadPart > pPcb->qwActiveTime.QuadPart ) &&
                 ( pPcb->qwActiveTime.QuadPart > 0 ) )
            {
                qwUpTime.QuadPart = 
                           qwCurrentTime.QuadPart - pPcb->qwActiveTime.QuadPart;

                dwActiveTimeInSeconds = RtlEnlargedUnsignedDivide(  
                                        qwUpTime,(DWORD)10000000,&dwRemainder);

                dwRetCode = RasAuthAttributeInsert(
                                       dwIndex++,
                                       pPcb->pAccountingAttributes,
                                       raatAcctSessionTime,
                                       FALSE,
                                       4,
                                       (PVOID)ULongToPtr(dwActiveTimeInSeconds) );

                if ( dwRetCode != NO_ERROR )
                {
                    break;
                }
            }

            //
            // Insert Input and Output bytes and packets
            //

            dwRetCode = RasPortGetStatisticsEx(
                                            NULL,
                                            pPcb->hPort,
                                            (PBYTE)pStats,
                                            &dwSize);

            if ( dwRetCode == NO_ERROR )
            {
                dwRetCode = RasAuthAttributeInsert(
                                    dwIndex++,
                                    pPcb->pAccountingAttributes,
                                    raatAcctOutputOctets,
                                    FALSE,
                                    4,
                                    (PVOID)ULongToPtr(pStats->S_Statistics[BYTES_XMITED]));

                if ( dwRetCode != NO_ERROR )
                {
                    break;
                }

                dwRetCode = RasAuthAttributeInsert(
                                    dwIndex++,
                                    pPcb->pAccountingAttributes,
                                    raatAcctInputOctets,
                                    FALSE,
                                    4,
                                    (PVOID)ULongToPtr(pStats->S_Statistics[BYTES_RCVED]));

                if ( dwRetCode != NO_ERROR )
                {
                    break;
                }            

                dwRetCode = RasAuthAttributeInsert(
                                    dwIndex++,
                                    pPcb->pAccountingAttributes,
                                    raatAcctOutputPackets,
                                    FALSE,
                                    4,
                                    (PVOID)ULongToPtr(pStats->S_Statistics[FRAMES_XMITED]));

                if ( dwRetCode != NO_ERROR )
                {
                    break;
                }            
    
                dwRetCode = RasAuthAttributeInsert(
                                    dwIndex++,
                                    pPcb->pAccountingAttributes,
                                    raatAcctInputPackets,
                                    FALSE,
                                    4,
                                    (PVOID)ULongToPtr(pStats->S_Statistics[FRAMES_RCVED]));

                if ( dwRetCode != NO_ERROR )
                {
                    break;
                }
            }

        } while (FALSE);

        if ( dwRetCode != NO_ERROR )
        {
            RasAuthAttributeDestroy( pPcb->pAccountingAttributes );

            pPcb->pAccountingAttributes = NULL;

            return;
        }
        
        //
        // Null terminate the array
        //

        pPcb->pAccountingAttributes[dwIndex].raaType  = raatMinimum;
        pPcb->pAccountingAttributes[dwIndex].dwLength = 0;
        pPcb->pAccountingAttributes[dwIndex].Value    = NULL;

        pPcb->fFlags |= PCBFLAG_INTERIM_ACCT_SENT;
    }
    else
    {
        //
        // Else we need to update session time and other attributes
        //

        GetSystemTimeAsFileTime( (FILETIME*)&qwCurrentTime );

        if ( ( qwCurrentTime.QuadPart > pPcb->qwActiveTime.QuadPart ) &&
             ( pPcb->qwActiveTime.QuadPart > 0 ) )
        {
            qwUpTime.QuadPart =     
                        qwCurrentTime.QuadPart - pPcb->qwActiveTime.QuadPart;

            dwActiveTimeInSeconds = RtlEnlargedUnsignedDivide(  
                                    qwUpTime,(DWORD)10000000,&dwRemainder);

            pAttribute = RasAuthAttributeGet( raatAcctSessionTime,
                                          pPcb->pAccountingAttributes );

            if ( pAttribute != NULL )
            {
                pAttribute->Value = (PVOID)ULongToPtr(dwActiveTimeInSeconds);
            }
        }

        //
        // Update Input and Output bytes and packets
        //

        dwRetCode = RasPortGetStatisticsEx( NULL,
                                        pPcb->hPort,
                                        (PBYTE)pStats,
                                        &dwSize);

        if ( dwRetCode == NO_ERROR )
        {
            pAttribute = RasAuthAttributeGet( raatAcctOutputOctets,
                                              pPcb->pAccountingAttributes );

            if ( pAttribute != NULL )
            {
                pAttribute->Value = (PVOID)(ULongToPtr(pStats->S_Statistics[BYTES_XMITED]));
            }

            pAttribute = RasAuthAttributeGet( raatAcctInputOctets,
                                              pPcb->pAccountingAttributes );

            if ( pAttribute != NULL )
            {
                pAttribute->Value = (PVOID)(ULongToPtr(pStats->S_Statistics[BYTES_RCVED]));
            }

            pAttribute = RasAuthAttributeGet( raatAcctOutputPackets,
                                              pPcb->pAccountingAttributes );

            if ( pAttribute != NULL )
            {
                pAttribute->Value = (PVOID)(ULongToPtr(pStats->S_Statistics[FRAMES_XMITED]));
            }

            pAttribute = RasAuthAttributeGet( raatAcctInputPackets,
                                          pPcb->pAccountingAttributes );

            if ( pAttribute != NULL )
            {
                pAttribute->Value = (PVOID)(ULongToPtr(pStats->S_Statistics[FRAMES_RCVED]));
            }
        }
    }

    pAttribute = RasAuthAttributeGet( raatAcctLinkCount,
                                      pPcb->pAccountingAttributes );

    if ( pAttribute != NULL )
    {
        pAttribute->Value = (LPVOID)(ULongToPtr(pPcb->pBcb->dwAcctLinkCount));
    }

    pAttribute = RasAuthAttributeGet( raatAcctEventTimeStamp,
                                      pPcb->pAccountingAttributes );

    //
    // Insert event timestamp attribute
    //

    if ( pAttribute != NULL )
    {
        pAttribute->Value = (LPVOID)ULongToPtr(GetSecondsSince1970());
    }

    if ( !fInterimAccounting )
    {
        DWORD dwTerminateCause = 9;

        //
        // If this is a stop accounting call, then find out where the
        // array is terminated and then insert stop accounting attributes
        //

        for ( dwIndex = 0;
              pPcb->pAccountingAttributes[dwIndex].raaType != raatMinimum;
              dwIndex++ );

        //
        // Undo the NULL termination
        //

        pPcb->pAccountingAttributes[dwIndex].raaType  = raatReserved;
        pPcb->pAccountingAttributes[dwIndex].dwLength = 0;
        pPcb->pAccountingAttributes[dwIndex].Value    = NULL;

        //
        // Insert termination cause attribute
        //

        if ( pPcb->LcpCb.dwError == ERROR_IDLE_DISCONNECTED )
        {
            dwTerminateCause = 4;
        }
        else if ( pPcb->LcpCb.dwError == ERROR_PPP_SESSION_TIMEOUT )
        {
            dwTerminateCause = 5;
        }
        else if ( pPcb->fFlags & PCBFLAG_SERVICE_UNAVAILABLE )
        {
            dwTerminateCause = 15;
        }
        else if ( pPcb->fFlags & PCBFLAG_DOING_CALLBACK )
        {
            dwTerminateCause = 16;
        }
        else
        {
            RASMAN_INFO RasmanInfo;

            if ( RasGetInfo( NULL, pPcb->hPort, &RasmanInfo ) == NO_ERROR )
            {
                switch( RasmanInfo.RI_DisconnectReason )
                {
                case USER_REQUESTED:
                    dwTerminateCause = 6;
                    if ( pPcb->fFlags & PCBFLAG_RECVD_TERM_REQ )
                    {
                        //
                        // Even though we brought the line down, it was at the 
                        // client's request.
                        //
                        dwTerminateCause = 1;
                    }
                    break;

                case REMOTE_DISCONNECTION:
                    dwTerminateCause = 1;
                    break;

                case HARDWARE_FAILURE:
                    dwTerminateCause = 8;
                    break;

                default:
                    break;
                }
            }
        }

        dwRetCode = RasAuthAttributeInsert(
                                        dwIndex++,
                                       pPcb->pAccountingAttributes,
                                       raatAcctTerminateCause,
                                       FALSE,
                                       4,
                                       (LPVOID)ULongToPtr(dwTerminateCause) );
        
        pPcb->pAccountingAttributes[dwIndex].raaType  = raatMinimum;
        pPcb->pAccountingAttributes[dwIndex].dwLength = 0;
        pPcb->pAccountingAttributes[dwIndex].Value    = NULL;
    }

    if ( fInterimAccounting )
    {
        pAccountingAttributes = RasAuthAttributeCopy( 
                                    pPcb->pAccountingAttributes );

        if ( NULL == pAccountingAttributes )
        {
            return;
        }
    }
    else
    {
		pStopAcctContext = (PSTOP_ACCOUNTING_CONTEXT) LocalAlloc ( LPTR, sizeof(STOP_ACCOUNTING_CONTEXT));
		if ( NULL == pStopAcctContext )
		{
			PppLog( 1, "Failed to allocate memory for Stop Accounting Context" );
			return;
		}
		
		pStopAcctContext->pPcb= pPcb;			//actually there is no need to pass the accounting attributes separately
												//need to revisit once this is done.
		pStopAcctContext->pAuthAttributes = pPcb->pAccountingAttributes;
        pAccountingAttributes = pPcb->pAccountingAttributes;
    }
	
    RtlQueueWorkItem( fInterimAccounting ? InterimAccounting : StopAccounting,   
					  fInterimAccounting ? (PVOID)pAccountingAttributes : (PVOID)pStopAcctContext, 
                      WT_EXECUTEDEFAULT );
}

//**
//
// Call:        GetClientInterfaceInfo
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
PBYTE
GetClientInterfaceInfo(
    IN PCB * pPcb
)
{
    HANDLE                 hAttribute;
    PBYTE                  pClientInterface = NULL;
    PBYTE                  pClientInterface2= NULL;
    DWORD                  dwCount          = 0;
    DWORD                  dwRetCode        = NO_ERROR;
    BYTE *                 pbValue          = NULL;
    MIB_IPFORWARDROW *     pStaticRoute     = NULL;
    MIB_IPFORWARDROW *     pStaticRouteSaved= NULL;
    RAS_AUTH_ATTRIBUTE *   pStaticRoutes    = RasAuthAttributeGetFirst(
                                                raatFramedRoute,
                                                pPcb->pAuthenticatorAttributes,
                                                &hAttribute );
    BYTE *                 pbFilter         = NULL;

    pbFilter = RasAuthAttributeGetConcatVendorSpecific(
                    311,
                    22,
                    pPcb->pAuthenticatorAttributes );
   
    if ( ( pStaticRoutes == NULL ) && ( pbFilter == NULL ) )
    {
        return( NULL );
    }

    if ( pbFilter != NULL )
    {
        dwRetCode = MprInfoDuplicate( pbFilter, 
                                      &pClientInterface );

        LocalFree( pbFilter );
        pbFilter = NULL;

        if ( dwRetCode != NO_ERROR )
        {
            return( NULL );
        }
    }

    if ( pStaticRoutes != NULL )
    {
        if ( pClientInterface == NULL )
        {
            //
            // Allocate header
            //

            dwRetCode = MprInfoCreate(RTR_INFO_BLOCK_VERSION,&pClientInterface);

            if ( dwRetCode != NO_ERROR )
            {
                PppLog( 1, "Failed to allocate memory for static routes" );

                return( NULL );
            }
        }

        //
        // Find out how many routes there are
        //

        for ( dwCount = 0; pStaticRoutes != NULL; dwCount++ )
        {
            pStaticRoutes=RasAuthAttributeGetNext(&hAttribute, raatFramedRoute);
        }

        pStaticRoute = (MIB_IPFORWARDROW*)
                            LOCAL_ALLOC( LPTR, 
                                         dwCount * sizeof( MIB_IPFORWARDROW ) );

        pStaticRouteSaved = pStaticRoute;

        if ( pStaticRoute == NULL )
        {
            PppLog( 1, "Failed to allocate memory for static routes" );

            MprInfoDelete( pClientInterface );

            return( NULL );
        }

        for (
            pbValue = NULL,
            pStaticRoutes = RasAuthAttributeGetFirst( 
                                            raatFramedRoute,
                                            pPcb->pAuthenticatorAttributes,
                                            &hAttribute );

            pStaticRoutes != NULL;

            pStaticRoute++,
            pStaticRoutes = RasAuthAttributeGetNext( &hAttribute, 
                                                     raatFramedRoute ) )
        {
            CHAR  * pChar;
            DWORD   dwUniqueDigits  = 0; 
            DWORD   dwMask          = 0;
            DWORD   dwIndex;

            LocalFree( pbValue );

            pbValue = LocalAlloc( LPTR, pStaticRoutes->dwLength + 1 );

            if ( NULL == pbValue )
            {
                PppLog( 1, "Failed to allocate memory for static routes" );

                continue;
            }

            CopyMemory( pbValue, (BYTE *)(pStaticRoutes->Value),
                        pStaticRoutes->dwLength );

            pChar = strtok( (CHAR *) pbValue, "/" );

            if ( pChar != NULL )
            {
                pStaticRoute->dwForwardDest = inet_addr( pChar );

                if ( pStaticRoute->dwForwardDest == INADDR_NONE )
                {
                    PppLog(1,   
                          "Ignoring invalid static route - no destination IP");

                    continue;
                }

                pChar = strtok( NULL, " " );

                if ( pChar == NULL )
                {
                    PppLog( 1, "Ignoring invalid static route - no MASK");

                    continue;
                }

                dwUniqueDigits = atoi( pChar );

                if ( dwUniqueDigits > 32 )
                {
                    PppLog( 1, "Ignoring invalid static route - invalid MASK");

                    continue;
                }

                for ( dwIndex = 0; dwIndex < dwUniqueDigits;  dwIndex++ )
                {
                    dwMask |= ( 0x80000000 >> dwIndex );
                }

                HostToWireFormat32( dwMask,     
                                    (PBYTE)&(pStaticRoute->dwForwardMask));
            }
            else
            {
                pChar = strtok( (CHAR *) pbValue, " " );

                if ( pChar == NULL )
                {
                    PppLog(1, 
                           "Ignoring invalid static route - no destination IP");

                    continue;
                }
                else
                {
                    pStaticRoute->dwForwardDest = inet_addr( pChar );
                    pStaticRoute->dwForwardMask = GetClassMask( 
                                                pStaticRoute->dwForwardDest );
                }
            }

            pChar = strtok( NULL, " " );

            if ( pChar == NULL )
            {
                PppLog( 1, "Ignoring invalid static route - no next hop IP");

                continue;
            }

            pStaticRoute->dwForwardNextHop = inet_addr( pChar );

            if ( pStaticRoute->dwForwardDest == INADDR_NONE )
            {
                PppLog(1,"Ignoring invalid static route - invalid nexthop IP");

                continue;
            }

            pChar = strtok( NULL, " " );

            if ( pChar != NULL )
            {
                pStaticRoute->dwForwardMetric1 = atoi( pChar );
            }

            pChar = strtok( NULL, " " );

            if ( pChar != NULL )
            {
                pStaticRoute->dwForwardMetric2 = atoi( pChar );
            }

            pChar = strtok( NULL, " " );

            if ( pChar != NULL )
            {
                pStaticRoute->dwForwardMetric3 = atoi( pChar );
            }

            pChar = strtok( NULL, " " );

            if ( pChar != NULL )
            {
                pStaticRoute->dwForwardMetric4 = atoi( pChar );
            }

            pChar = strtok( NULL, " " );

            if ( pChar != NULL )
            {
                pStaticRoute->dwForwardMetric5 = atoi( pChar );
            }
        } 

        LocalFree( pbValue );

        dwRetCode = MprInfoBlockAdd( pClientInterface,
                                     IP_ROUTE_INFO,
                                     sizeof( MIB_IPFORWARDROW ),
                                     dwCount,
                                     (PBYTE)pStaticRouteSaved,
                                     &pClientInterface2 );

        MprInfoDelete( pClientInterface );

        if ( dwRetCode != NO_ERROR )
        {
            PppLog( 1, "MprInfoBlockAdd failed and returned %d", dwRetCode );

            LOCAL_FREE( pStaticRouteSaved );

            return( NULL );
        }
        else
        {
            pClientInterface = pClientInterface2;
        }

        LOCAL_FREE( pStaticRouteSaved );
    }

    return( pClientInterface );
}

//**
//
// Call:        LoadParserDll
//
// Returns:     VOID
//
// Description: Loads the parser DLL with the entry points PacketFromPeer,
//              PacketToPeer, and PacketFree.
//
VOID
LoadParserDll(
    IN  HKEY    hKeyPpp
)
{
    LONG        lRet;
    DWORD       dwType;
    DWORD       dwSize;
    CHAR*       pszPath             = NULL;
    CHAR*       pszExpandedPath     = NULL;
    HINSTANCE   hInstance           = NULL;
    FARPROC     pPacketFromPeer;
    FARPROC     pPacketToPeer;
    FARPROC     pPacketFree;
    BOOL        fUnloadDLL          = TRUE;

    //
    // Find how big the path is
    //
    dwSize = 0;
    lRet = RegQueryValueExA(
                hKeyPpp,
                RAS_VALUENAME_PARSEDLLPATH,
                NULL,
                &dwType,
                NULL,
                &dwSize
                );

    if (ERROR_SUCCESS != lRet)
    {
        goto LDone;
    }

    if (   (REG_EXPAND_SZ != dwType)
        && (REG_SZ != dwType))
    {
        goto LDone;
    }

    pszPath = LOCAL_ALLOC(LPTR, dwSize);

    if (NULL == pszPath)
    {
        goto LDone;
    }

    //
    // Read the path
    //

    lRet = RegQueryValueExA(
                hKeyPpp,
                RAS_VALUENAME_PARSEDLLPATH,
                NULL,
                &dwType,
                pszPath,
                &dwSize
                );

    if (ERROR_SUCCESS != lRet)
    {
        goto LDone;
    }

    //
    // Replace the %SystemRoot% with the actual path.
    //

    dwSize = ExpandEnvironmentStringsA(pszPath, NULL, 0);

    if (0 == dwSize)
    {
        goto LDone;
    }

    pszExpandedPath = LOCAL_ALLOC(LPTR, dwSize);

    if (NULL == pszExpandedPath)
    {
        goto LDone;
    }

    dwSize = ExpandEnvironmentStringsA(
                            pszPath,
                            pszExpandedPath,
                            dwSize );
    if (0 == dwSize)
    {
        goto LDone;
    }

    if (   (NULL != PppConfigInfo.pszParserDllPath)
        && (!strcmp(pszExpandedPath, PppConfigInfo.pszParserDllPath)))
    {
        //
        // The DLL is already loaded
        //

        fUnloadDLL = FALSE;
        goto LDone;
    }

    hInstance = LoadLibraryA(pszExpandedPath);

    if (NULL == hInstance)
    {
        goto LDone;
    }

    fUnloadDLL = FALSE;

    pPacketFromPeer = GetProcAddress(hInstance, "PacketFromPeer");
    pPacketToPeer = GetProcAddress(hInstance, "PacketToPeer");
    pPacketFree = GetProcAddress(hInstance, "PacketFree");

    FreeLibrary(PppConfigInfo.hInstanceParserDll);
    PppConfigInfo.hInstanceParserDll = hInstance;
    hInstance = NULL;

    if (NULL != PppConfigInfo.pszParserDllPath)
    {
        LOCAL_FREE(PppConfigInfo.pszParserDllPath);
    }
    PppConfigInfo.pszParserDllPath = pszExpandedPath;
    pszExpandedPath = NULL;

    PppConfigInfo.PacketFromPeer =
        (VOID(*)(HANDLE, BYTE*, DWORD, BYTE**, DWORD*)) pPacketFromPeer;
    PppConfigInfo.PacketToPeer =
        (VOID(*)(HANDLE, BYTE*, DWORD, BYTE**, DWORD*)) pPacketToPeer;
    PppConfigInfo.PacketFree =
        (VOID(*)(BYTE*)) pPacketFree;

LDone:

    if (NULL != pszPath)
    {
        LOCAL_FREE(pszPath);
    }

    if (NULL != pszExpandedPath)
    {
        LOCAL_FREE(pszExpandedPath);
    }

    if (NULL != hInstance)
    {
        FreeLibrary(hInstance);
    }

    if (fUnloadDLL)
    {
        FreeLibrary(PppConfigInfo.hInstanceParserDll);
        PppConfigInfo.hInstanceParserDll = NULL;

        if (NULL != PppConfigInfo.pszParserDllPath)
        {
            LOCAL_FREE(PppConfigInfo.pszParserDllPath);
        }
        PppConfigInfo.pszParserDllPath = NULL;

        PppConfigInfo.PacketFromPeer = NULL;
        PppConfigInfo.PacketToPeer = NULL;
        PppConfigInfo.PacketFree = NULL;
    }
}

//**
//
// Call:        PortSendOrDisconnect
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
PortSendOrDisconnect(
    IN PCB *        pPcb,
    IN DWORD        cbPacket
)
{
    DWORD   dwRetCode;
    BYTE*   pData                       = NULL;
    DWORD   dwSize                      = 0;
    BOOL    fBufferReceivedFromParser   = FALSE;

    if ( NULL != PppConfigInfo.PacketToPeer )
    {
        PppConfigInfo.PacketToPeer(
                pPcb->hPort,
                (BYTE*)(pPcb->pSendBuf), 
                cbPacket,
                &pData,
                &dwSize );
    }

    if ( NULL == pData )
    {
        pData = (BYTE*)(pPcb->pSendBuf);
        dwSize = cbPacket;
    }
    else
    {
        fBufferReceivedFromParser = TRUE;
    }

    dwRetCode = RasPortSend( pPcb->hPort, 
                             pData, 
                             dwSize );

    if ( NO_ERROR != dwRetCode )
    {
        PppLog( 1, "RasPortSend on port %d failed: %d",
                pPcb->hPort, dwRetCode );

        pPcb->LcpCb.dwError = dwRetCode;

        pPcb->fFlags |= PCBFLAG_STOPPED_MSG_SENT;

        NotifyCaller( pPcb,
                      ( pPcb->fFlags & PCBFLAG_IS_SERVER )
                            ? PPPDDMMSG_Stopped
                            : PPPMSG_Stopped,
                      &(pPcb->LcpCb.dwError) );
    }

    if ( fBufferReceivedFromParser )
    {
        PPP_ASSERT( NULL != PppConfigInfo.PacketFree );
        PppConfigInfo.PacketFree( pData ); 
    }

    return( dwRetCode );
}

//**
//
// Call:        ReceiveViaParser
//
// Returns:     VOID
//
// Description:
//
VOID 
ReceiveViaParser(
    IN PCB *        pPcb,
    IN PPP_PACKET * pPacket,
    IN DWORD        dwPacketLength
)
{
    BYTE*   pData                       = NULL;
    DWORD   dwSize                      = 0;
    BOOL    fBufferReceivedFromParser   = FALSE;

    if ( NULL != PppConfigInfo.PacketFromPeer )
    {
        PppConfigInfo.PacketFromPeer(
                pPcb->hPort,
                (BYTE*)pPacket, 
                dwPacketLength,
                &pData,
                &dwSize );
    }

    if ( NULL == pData )
    {
        pData = (BYTE*)pPacket;
        dwSize = dwPacketLength;
    }
    else
    {
        fBufferReceivedFromParser = TRUE;
    }

    FsmReceive( pPcb, (PPP_PACKET*) pData, dwSize );

    if ( fBufferReceivedFromParser )
    {
        PPP_ASSERT( NULL != PppConfigInfo.PacketFree );
        PppConfigInfo.PacketFree( pData ); 
    }
}

//**
//
// Call:        GetSecondsSince1970
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD 
GetSecondsSince1970(
    VOID
)
{
    SYSTEMTIME      LocalTime;
    TIME_FIELDS     LocalTimeFields;
    LARGE_INTEGER   TempTime;
    LARGE_INTEGER   SystemTime;
    DWORD           RetTime;

    GetLocalTime( &LocalTime );

    LocalTimeFields.Year =         LocalTime.wYear;
    LocalTimeFields.Month =        LocalTime.wMonth;
    LocalTimeFields.Day =          LocalTime.wDay;
    LocalTimeFields.Hour =         LocalTime.wHour;
    LocalTimeFields.Minute =       LocalTime.wMinute;
    LocalTimeFields.Second =       LocalTime.wSecond;
    LocalTimeFields.Milliseconds = LocalTime.wMilliseconds;
    LocalTimeFields.Weekday =      LocalTime.wDayOfWeek;

    RtlTimeFieldsToTime(&LocalTimeFields, &TempTime);

    RtlLocalTimeToSystemTime(&TempTime, &SystemTime);

    RtlTimeToSecondsSince1970(&SystemTime, &RetTime);

    return( RetTime );
}

//**
//
// Call:        IsPschedRunning
//
// Returns:     TRUE iff Psched is running
//
// Description:
//
BOOL
IsPschedRunning(
    VOID
)
{
    SC_HANDLE       hCont   = NULL;
    SC_HANDLE       hSched  = NULL;
    DWORD           dwErr   = NO_ERROR;
    SERVICE_STATUS  Status;
    BOOL            fRet    = FALSE;

    //
    // Initialize
    //

    ZeroMemory( &Status, sizeof(Status) );
    
    do
    {
        hCont = OpenSCManager( NULL, NULL, GENERIC_READ );

        if ( hCont == NULL )
        {
            dwErr = GetLastError();
            PppLog( 1, "OpenSCManager failed: %d", dwErr );
            break;
        }

        hSched = OpenService( hCont, TEXT("psched"), SERVICE_QUERY_STATUS );

        if ( hSched == NULL )
        {
            dwErr = GetLastError();
            PppLog( 1, "OpenService failed: %d", dwErr );
            break;
        }

        if ( !QueryServiceStatus( hSched, &Status ))
        {
            dwErr = GetLastError();
            PppLog( 1, "QueryServiceStatus failed: %d", dwErr );
            break;
        }
        
        fRet = ( Status.dwCurrentState == SERVICE_RUNNING );
        
    } while ( FALSE );

    //
    // Cleanup
    //

    if ( hSched )
    {
        CloseServiceHandle( hSched );
    }
    if ( hCont )
    {
        CloseServiceHandle( hCont );
    }

    return( fRet );
}

//**
//
// Call:        LogPPPPacket
//
// Returns:     None
//
// Description:
//
VOID
LogPPPPacket(
    IN BOOL         fReceived,
    IN PCB *        pPcb,
    IN PPP_PACKET * pPacket,
    IN DWORD        cbPacket
)
{
    SYSTEMTIME  SystemTime;
    CHAR *      pchProtocol;
    CHAR *      pchType;
    BYTE        Id = 0;
    BYTE        bCode;
    DWORD       cbTracePacketSize = cbPacket;
    DWORD       dwUnknownPacketTraceSize;
    BOOL        fPrint = TRUE;

    dwUnknownPacketTraceSize = PppConfigInfo.dwUnknownPacketTraceSize;

    GetSystemTime( &SystemTime );

    if ( cbPacket > PPP_CONFIG_HDR_LEN )
    {
        bCode = *(((CHAR*)pPacket)+PPP_PACKET_HDR_LEN);

        if ( ( bCode == 0 ) || ( bCode > TIME_REMAINING ) )
        {
            pchType = "UNKNOWN";
        }
        else
        {
            pchType = FsmCodes[ bCode ];
        }

        Id = *(((CHAR*)pPacket)+PPP_PACKET_HDR_LEN+1);
    }
    else
    {
        pchType = "UNKNOWN";
    }

    if ( cbPacket > PPP_PACKET_HDR_LEN  )
    {
        switch( WireToHostFormat16( (CHAR*)pPacket ) )
        {
        case PPP_LCP_PROTOCOL:
            pchProtocol = "LCP";
            break;
        case PPP_BACP_PROTOCOL:
            pchProtocol = "BACP";
            break;
        case PPP_BAP_PROTOCOL:
            pchProtocol = "BAP";
            pchType = "Protocol specific";
            break;
        case PPP_PAP_PROTOCOL:
            pchProtocol = "PAP";
            pchType = "Protocol specific";
            fPrint = FALSE;
            break;
        case PPP_CBCP_PROTOCOL:   
            pchProtocol = "CBCP";
            pchType = "Protocol specific";
            break;
        case PPP_CHAP_PROTOCOL:  
            pchProtocol = "CHAP";
            pchType = "Protocol specific";
            break;
        case PPP_IPCP_PROTOCOL:
            pchProtocol = "IPCP";
            break;
        case PPP_ATCP_PROTOCOL:  
            pchProtocol = "ATCP";
            break;
        case PPP_IPXCP_PROTOCOL:  
            pchProtocol = "IPXCP";
            break;
        case PPP_NBFCP_PROTOCOL: 
            pchProtocol = "NBFCP";
            break;
        case PPP_CCP_PROTOCOL:    
            pchProtocol = "CCP";
            break;
        case PPP_EAP_PROTOCOL:    
            pchProtocol = "EAP";
            pchType = "Protocol specific";
            if ( cbTracePacketSize > dwUnknownPacketTraceSize )
            {
                cbTracePacketSize = dwUnknownPacketTraceSize;
            }
            break;
        case PPP_SPAP_NEW_PROTOCOL:
            pchProtocol = "SHIVA PAP";
            pchType = "Protocol specific";
            break;
        default:
            pchProtocol = "UNKNOWN";
            if ( cbTracePacketSize > dwUnknownPacketTraceSize )
            {
                cbTracePacketSize = dwUnknownPacketTraceSize;
            }
            break;
        }
    }
    else
    {
        pchProtocol = "UNKNOWN";
    }

    PppLog( 1, "%sPPP packet %s at %0*d/%0*d/%0*d %0*d:%0*d:%0*d:%0*d",
                 fReceived ? ">" : "<", fReceived ? "received" : "sent",
                 2, SystemTime.wMonth,
                 2, SystemTime.wDay,
                 2, SystemTime.wYear,
                 2, SystemTime.wHour,
                 2, SystemTime.wMinute,
                 2, SystemTime.wSecond,
                 3, SystemTime.wMilliseconds );
    PppLog(1,
       "%sProtocol = %s, Type = %s, Length = 0x%x, Id = 0x%x, Port = %d",
       fReceived ? ">" : "<", pchProtocol, pchType, cbPacket, Id,
       pPcb->hPort );

    if ( fPrint )
    {
        TraceDumpExA( PppConfigInfo.dwTraceId,
                      TRACE_LEVEL_1 | TRACE_USE_MSEC,
                      (CHAR*)pPacket, 
                      cbTracePacketSize, 
                      1,
                      FALSE,
                      fReceived ? ">" : "<" );
    }

    PppLog(1," " );
}

//**
//
// Call:        PppLog
//
// Returns:     None
//
// Description: Will print to the PPP logfile
//
VOID
PppLog(
    IN DWORD DbgLevel,
    ...
)
{
    va_list     arglist;
    CHAR        *Format;
    char        OutputBuffer[1024];

    va_start( arglist, DbgLevel );

    Format = va_arg( arglist, CHAR* );

    vsprintf( OutputBuffer, Format, arglist );

    va_end( arglist );

    TracePutsExA( PppConfigInfo.dwTraceId,
                  (( DbgLevel == 1 ) ? TRACE_LEVEL_1 : TRACE_LEVEL_2 )
                  | TRACE_USE_MSEC, OutputBuffer );
} 

#ifdef MEM_LEAK_CHECK

LPVOID
DebugAlloc( DWORD Flags, DWORD dwSize ) 
{
    DWORD Index;
    LPBYTE pMem = (LPBYTE)HeapAlloc( PppConfigInfo.hHeap,
                                     HEAP_ZERO_MEMORY,dwSize+8);

    if ( pMem == NULL )
        return( pMem );

    for( Index=0; Index < PPP_MEM_TABLE_SIZE; Index++ )
    {
        if ( PppMemTable[Index] == NULL )
        {
            PppMemTable[Index] = pMem;
            break;
        }
    }

    PPP_ASSERT( Index != PPP_MEM_TABLE_SIZE );

    return( (LPVOID)pMem );
}

BOOL
DebugFree( PVOID pMem )
{
    DWORD Index;

    for( Index=0; Index < PPP_MEM_TABLE_SIZE; Index++ )
    {
        if ( PppMemTable[Index] == pMem )
        {
            PppMemTable[Index] = NULL;
            break;
        }
    }

    ASSERT( Index != PPP_MEM_TABLE_SIZE );

    return( HeapFree( PppConfigInfo.hHeap, 0, pMem ) );
}

LPVOID
DebugReAlloc( PVOID pMem, DWORD dwSize ) 
{
    DWORD Index;

    if ( pMem == NULL )
    {
        PPP_ASSERT(FALSE);
    }

    for( Index=0; Index < PPP_MEM_TABLE_SIZE; Index++ )
    {
        if ( PppMemTable[Index] == pMem )
        {
            PppMemTable[Index] = HeapReAlloc( PppConfigInfo.hHeap,
                                              HEAP_ZERO_MEMORY,
                                              pMem, dwSize );

            pMem = PppMemTable[Index];

            break;
        }
    }

    PPP_ASSERT( Index != PPP_MEM_TABLE_SIZE );

    return( (LPVOID)pMem );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\engine\util.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    util.h
//
// Description: Contains prototype of utility funtions and procedures
//
// History:
//      Oct 31,1993.    NarenG          Created original version.
//

#ifndef _UTIL_
#define _UTIL_

#include "lcp.h"

DWORD
AllocateAndInitBcb(
    PCB * pPcb
);

VOID
NotifyCaller( 
    IN PCB * pPcb,
    IN DWORD PppEvent,
    IN PVOID pData                      
);

VOID
NotifyCallerOfFailureOnPort(
    IN HPORT hPort,
    IN BOOL  fServer,
    IN DWORD dwRetCode
);

VOID
NotifyCallerOfFailure( 
    IN PCB * pPcb,
    IN DWORD dwRetCode
);

VOID
InitRestartCounters( 
    IN PCB *  pPcb, 
    IN CPCB * pCpCb 
);

VOID
HostToWireFormat16(
    IN     WORD  wHostFormat,
    IN OUT PBYTE pWireFormat
);

WORD
WireToHostFormat16(
    IN PBYTE pWireFormat
);

VOID
HostToWireFormat32( 
    IN     DWORD dwHostFormat,
    IN OUT PBYTE pWireFormat
);

DWORD
WireToHostFormat32(
    IN PBYTE pWireFormat
);

DWORD
HashPortToBucket(
    IN HPORT hPort
);

VOID
InsertWorkItemInQ(
    IN PCB_WORK_ITEM * pWorkItem
);

VOID
LogPPPEvent( 
    IN DWORD dwEventId,
    IN DWORD dwData
);

DWORD
GetCpIndexFromProtocol( 
    IN DWORD dwProtocol 
);

BOOL
IsLcpOpened(
    PCB * pPcb
);

PCB * 
GetPCBPointerFromhPort( 
    IN HPORT hPort 
);

BCB * 
GetBCBPointerFromhConnection( 
    IN HCONN hConnection
);

DWORD
NumLinksInBundle(
    IN BCB * pBcb
);

PCB * 
GetPCBPointerFromBCB( 
    IN BCB * pBcb
);

DWORD
AreNCPsDone( 
    IN PCB *                       pPcb,
    IN DWORD                       CpIndex,
    IN OUT PPP_PROJECTION_RESULT * pProjectionResult,
    IN OUT BOOL *                  pfNCPsAreDone
);

BYTE
GetUId(
    IN PCB * pPcb,
    IN DWORD CpIndex
);

VOID
AlertableWaitForSingleObject(
    IN HANDLE hObject
);

BOOL
NotifyIPCPOfNBFCPProjection( 
    IN PCB *                    pPcb, 
    IN DWORD                    CpIndex
);

DWORD
CalculateRestartTimer(
    IN HPORT hPort
);

VOID
CheckCpsForInactivity( 
    IN PCB * pPcb,
	IN DWORD dwEvent
);

CHAR*
DecodePw(
	IN CHAR chSeed,
    IN OUT CHAR* pszPassword 
);

CHAR*
EncodePw(
	IN CHAR chSeed,
    IN OUT CHAR* pszPassword 
);

VOID
GetLocalComputerName( 
    IN OUT LPSTR szComputerName 
);

DWORD
InitEndpointDiscriminator( 
    IN OUT BYTE EndPointDiscriminator[]
);

VOID
DeallocateAndRemoveBcbFromTable(
    IN BCB * pBcb
);

VOID
RemovePcbFromTable(
    IN PCB * pPcb
);

BOOL
WillPortBeBundled(
    IN  PCB *   pPcb
);

DWORD
TryToBundleWithAnotherLink( 
    IN  PCB *   pPcb
); 

VOID
AdjustHTokenImpersonateUser(
    IN  PCB *   pPcb
);

BOOL
FLinkDiscriminatorIsUnique(
    IN  PCB *   pPcb,
    OUT DWORD * pdwLinkDisc
);

DWORD
InitializeNCPs(
    IN PCB * pPcb,
    IN DWORD dwConfigMask
);

CPCB *
GetPointerToCPCB(
    IN PCB * pPcb,
    IN DWORD CpIndex
);

DWORD
GetNewPortOrBundleId(
    VOID
);

NCP_PHASE
QueryBundleNCPState(
    IN PCB * pPcb
);

VOID
NotifyCallerOfBundledProjection( 
    IN  PCB * pPcb
);

VOID
StartNegotiatingNCPs(
    IN PCB * pPcb
);

VOID
StartAutoDisconnectForPort( 
    IN PCB * pPcb 
);

VOID
StartLCPEchoForPort( 
    IN PCB * pPcb 
);

VOID
NotifyCompletionOnBundledPorts(
    IN PCB * pPcb
);

VOID
RemoveNonNumerals( 
    IN  CHAR*   szString
);

CHAR*
TextualSidFromPid(
    DWORD   dwPid
);

DWORD
GetRouterPhoneBook(
    CHAR**  pszPhonebookPath
);

DWORD
GetCredentialsFromInterface(
    PCB *   pPcb
);

BOOL
IsCpIndexOfAp( 
    IN DWORD CpIndex 
);

VOID
StopAccounting(
    PVOID pContext
);

VOID
InterimAccounting(
    PVOID pContext
);

VOID
StartAccounting(
    PVOID pContext
);

PBYTE
GetClientInterfaceInfo(
    IN PCB * pPcb
);

VOID
LoadParserDll(
    IN  HKEY    hKeyPpp
);

DWORD
PortSendOrDisconnect(
    IN PCB *        pPcb,
    IN DWORD        cbPacket
);

VOID 
ReceiveViaParser(
    IN PCB *        pPcb,
    IN PPP_PACKET * pPacket,
    IN DWORD        dwPacketLength
);

DWORD
GetSecondsSince1970(
    VOID
);

BOOL
IsPschedRunning(
    VOID
);

VOID
PppLog(
    IN DWORD DbgLevel,
    ...
    );

VOID
LogPPPPacket(
    IN BOOL         fReceived,
    IN PCB *        pPcb,
    IN PPP_PACKET * pPacket,
    IN DWORD        cbPacket
);

VOID
CreateAccountingAttributes(
    IN PCB * pPcb
);

VOID
MakeStartAccountingCall(
    IN PCB * pPcb
);

VOID
MakeStopOrInterimAccountingCall(
    IN PCB *    pPcb,
    IN BOOL     fInterimAccounting
);

RAS_AUTH_ATTRIBUTE * 
GetUserAttributes( 
    PCB * pPcb 
);

#define BYTESPERLINE 16

#ifdef MEM_LEAK_CHECK

#define PPP_MEM_TABLE_SIZE 100

PVOID PppMemTable[PPP_MEM_TABLE_SIZE];

#define LOCAL_ALLOC     DebugAlloc
#define LOCAL_FREE      DebugFree
#define LOCAL_REALLOC   DebugReAlloc

LPVOID
DebugAlloc( DWORD Flags, DWORD dwSize );

BOOL
DebugFree( PVOID pMem );

LPVOID
DebugReAlloc( PVOID pMem, DWORD dwSize );

#else

#define LOCAL_ALLOC(Flags,dwSize)   HeapAlloc( PppConfigInfo.hHeap,  \
                                               HEAP_ZERO_MEMORY, dwSize )

#define LOCAL_FREE(hMem)            HeapFree( PppConfigInfo.hHeap, 0, hMem )

#define LOCAL_REALLOC(hMem,dwSize)  HeapReAlloc( PppConfigInfo.hHeap,  \
                                                 HEAP_ZERO_MEMORY,hMem,dwSize)

#endif

#define PPP_ASSERT      RTASSERT

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\engine\worker.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    worker.c
//
// Description: This module contains code for the worker thread.
//
// History:
//      Nov 11,1993.    NarenG          Created original version.
//      Jan 09,1995     RamC            Close hToken in ProcessLineDownWorker()
//                                      routine to release the RAS license.
//
// Tab Stop = 8

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>     // needed for winbase.h

#include <windows.h>    // Win32 base API's
#include <stdlib.h>
#include <string.h>
#include <wchar.h>

#include <ntlsapi.h>
#include <lmcons.h>
#include <mprlog.h>
#include <raserror.h>
#include <mprerror.h>
#include <rasman.h>
#include <rtutils.h>
#include <rasppp.h>
#include <pppcp.h>
#include <ppp.h>
#include <smaction.h>
#include <smevents.h>
#include <receive.h>
#include <auth.h>
#include <callback.h>
#include <init.h>
#include <lcp.h>
#include <timer.h>
#include <util.h>
#include <worker.h>
#include <bap.h>
#include <rassrvr.h>
#define INCL_RASAUTHATTRIBUTES
#include <ppputil.h>

//**
//
// Call:        WorkerThread
//
// Returns:     NO_ERROR
//
// Description: This thread will wait for an item in the WorkItemQ and then
//              will process it. This will happen in a never-ending loop.
//
#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

DWORD
WorkerThread(
    IN LPVOID pThreadParameter
)
{
    PCB_WORK_ITEM * pWorkItem        = (PCB_WORK_ITEM*)NULL;
    DWORD           dwTimeToSleepFor = INFINITE;
    HINSTANCE       hInstance;
    HANDLE          hEvents[3];
    DWORD           dwSignaledEvent;
    DWORD           dwTimeBeforeWait;
    DWORD           dwTimeElapsed;
    BOOL            fTimerQEmpty     = TRUE;

    hEvents[0] = WorkItemQ.hEventNonEmpty;
    hEvents[1] = TimerQ.hEventNonEmpty;
    hEvents[2] = PppConfigInfo.hEventChangeNotification;

    RegNotifyChangeKeyValue( PppConfigInfo.hKeyPpp,
                             TRUE,
                             REG_NOTIFY_CHANGE_LAST_SET,
                             PppConfigInfo.hEventChangeNotification,
                             TRUE );


    for(;;)
    {
        dwTimeBeforeWait = GetCurrentTime();

        //
        // Wait for work to do
        //

        dwSignaledEvent = WaitForMultipleObjectsEx(
                                        3,
                                        hEvents,
                                        FALSE,
                                        dwTimeToSleepFor,
                                        TRUE );


        switch( dwSignaledEvent )
        {
        case 0:

            //
            // Take Mutex around work event Q
            //

            EnterCriticalSection( &(WorkItemQ.CriticalSection) );

            //
            // Remove the first item
            //

            PPP_ASSERT( WorkItemQ.pQHead != (PCB_WORK_ITEM*)NULL );

            pWorkItem = WorkItemQ.pQHead;

            WorkItemQ.pQHead = pWorkItem->pNext;

            if ( WorkItemQ.pQHead == (PCB_WORK_ITEM*)NULL )
            {
                ResetEvent( WorkItemQ.hEventNonEmpty );

                WorkItemQ.pQTail = (PCB_WORK_ITEM *)NULL;
            }

            LeaveCriticalSection( &(WorkItemQ.CriticalSection) );

            pWorkItem->Process( pWorkItem );

            //
            // Zero out work item since it may have contained the password
            //

            ZeroMemory( pWorkItem, sizeof( PCB_WORK_ITEM ) );

            LOCAL_FREE( pWorkItem );

            break;

        case WAIT_TIMEOUT:

            TimerTick( &fTimerQEmpty );

            dwTimeToSleepFor = fTimerQEmpty ? INFINITE : 1000;

            continue;

        case 1:

            fTimerQEmpty = FALSE;

            break;

        case 2:

            //
            // Process change notification event
            //

            ProcessChangeNotification( NULL );

            RegNotifyChangeKeyValue(
                                PppConfigInfo.hKeyPpp,
                                TRUE,
                                REG_NOTIFY_CHANGE_LAST_SET,
                                PppConfigInfo.hEventChangeNotification,
                                TRUE );

            break;

        case WAIT_IO_COMPLETION:

            break;

        default:

            PPP_ASSERT( FALSE );
        }

        if ( !fTimerQEmpty )
        {
            if ( dwTimeToSleepFor == INFINITE )
            {
                dwTimeToSleepFor = 1000;
            }
            else
            {
                //
                // We did not get a timeout but do we need to call the timer?
                // Has over a second passed since we called the TimerQTick?
                //

                dwTimeElapsed =
                        ( GetCurrentTime() >= dwTimeBeforeWait )
                        ? GetCurrentTime() - dwTimeBeforeWait
                        : GetCurrentTime() + (0xFFFFFFFF - dwTimeBeforeWait);

                if ( dwTimeElapsed >= dwTimeToSleepFor )
                {
                    TimerTick( &fTimerQEmpty );

                    dwTimeToSleepFor = fTimerQEmpty ? INFINITE : 1000;
                }
                else
                {
                    dwTimeToSleepFor -= dwTimeElapsed;
                }
            }
        }
    }

    return( NO_ERROR );
}
#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


//**
//
// Call:        ProcessLineUpWorker
//
// Returns:     None
//
// Description: Will do the actual processing of the line up event.
//
//
VOID
ProcessLineUpWorker(
    IN PCB_WORK_ITEM *  pWorkItem,
    IN BOOL             fThisIsACallback
)
{
    DWORD       dwRetCode;
    DWORD       dwLength;
    DWORD       dwComputerNameLen;
    DWORD       dwIndex;
    PCB *       pNewPcb             = NULL;
    RASMAN_INFO RasmanInfo;
    DWORD       dwError;
    BOOL        fSuccess            = FALSE;

    do
    {
        PppLog( 1, "Line up event occurred on port %d", pWorkItem->hPort );

        pNewPcb = GetPCBPointerFromhPort( pWorkItem->hPort );

        if ( NULL == pNewPcb )
        {
            //
            // Allocate and initialize pNewPcb
            //

            pNewPcb = (PCB *)LOCAL_ALLOC( LPTR, sizeof( PCB ) );

            if ( pNewPcb == (PCB *)NULL )
            {
                //
                // Tell the owner of the port that we failed to open it.
                //

                NotifyCallerOfFailureOnPort(
                                    pWorkItem->hPort,
                                    pWorkItem->fServer,
                                    GetLastError() );

                break;
            }
        }
        else
        {
            if (!( pNewPcb->fFlags & PCBFLAG_PORT_IN_LISTENING_STATE ))
            {
                PppLog( 1, "Line up on port %d without a line down!",
                    pWorkItem->hPort );

                return;
            }

            //
            // We will put it back in the table later
            //

            RemovePcbFromTable( pNewPcb );
        }

        if ( !pWorkItem->fServer )
        {
            if ( !(pWorkItem->PppMsg.Start.ConfigInfo.dwConfigMask &
                                                      ( PPPCFG_ProjectNbf
                                                      | PPPCFG_ProjectIp
                                                      | PPPCFG_ProjectIpx
                                                      | PPPCFG_ProjectAt ) ) )
            {
                NotifyCallerOfFailureOnPort( pWorkItem->hPort,
                                             pWorkItem->fServer,
                                             ERROR_PPP_NO_PROTOCOLS_CONFIGURED);

                break;
            }
        }

        //
        // Get Rasman info for this port. We need this to get the devicetype
        // and BAP
        //

        dwError = RasGetInfo( NULL, pWorkItem->hPort, &RasmanInfo );

        if ( NO_ERROR != dwError )
        {
            PppLog(1,"RasGetInfo failed and returned returned %d", dwError);

            break;
        }

        pNewPcb->pSendBuf           = (PPP_PACKET*)NULL;
        pNewPcb->hPort              = pWorkItem->hPort;
        pNewPcb->pNext              = (PCB*)NULL;
        pNewPcb->UId                = 0;
        pNewPcb->dwPortId           = GetNewPortOrBundleId();
        pNewPcb->RestartTimer       = CalculateRestartTimer( pWorkItem->hPort );
        pNewPcb->PppPhase           = PPP_LCP;
        pNewPcb->fFlags            |= pWorkItem->fServer ? PCBFLAG_IS_SERVER:0;
        pNewPcb->fFlags            |= fThisIsACallback
                                      ? PCBFLAG_THIS_IS_A_CALLBACK
                                      : 0;
        pNewPcb->pUserAttributes            = NULL;
        pNewPcb->pAuthenticatorAttributes   = NULL;
        pNewPcb->pAuthProtocolAttributes    = NULL;
        pNewPcb->pAccountingAttributes      = NULL;
        pNewPcb->dwOutstandingAuthRequestId = 0xFFFFFFFF;
        pNewPcb->dwDeviceType               = RasmanInfo.RI_rdtDeviceType;

        GetSystemTimeAsFileTime( (FILETIME*)&(pNewPcb->qwActiveTime) );

        if ( NULL == pNewPcb->pBcb )
        {
            if ( ( dwRetCode = AllocateAndInitBcb( pNewPcb ) ) != NO_ERROR )
            {
                NotifyCallerOfFailureOnPort(
                                       pWorkItem->hPort,
                                       pWorkItem->fServer,
                                       dwRetCode );

                break;
            }
        }

        dwRetCode = RasPortGetBundle(NULL,
                                     pNewPcb->hPort,
                                     &(pNewPcb->pBcb->hConnection) );

        if ( dwRetCode != NO_ERROR )
        {
            NotifyCallerOfFailureOnPort(
                                   pWorkItem->hPort,
                                   pWorkItem->fServer,
                                   dwRetCode );

            break;
        }

        pNewPcb->pBcb->fFlags |= pWorkItem->fServer ? BCBFLAG_IS_SERVER:0;
        pNewPcb->pBcb->szRemoteUserName[0]  = (CHAR)NULL;
        pNewPcb->pBcb->szRemoteDomain[0]    = (CHAR)NULL;

        pNewPcb->pBcb->szOldPassword[0] = '\0';
        EncodePw( pNewPcb->pBcb->chSeed, pNewPcb->pBcb->szOldPassword );

        if ( pNewPcb->fFlags & PCBFLAG_IS_SERVER )
        {
            pNewPcb->dwEapTypeToBeUsed          = 0xFFFFFFFF;
            pNewPcb->fCallbackPrivilege         = RASPRIV_NoCallback;
            pNewPcb->pBcb->hTokenImpersonateUser= INVALID_HANDLE_VALUE;

            pNewPcb->dwAuthRetries = ( fThisIsACallback )
                                     ? 0
                                     : pWorkItem->PppMsg.DdmStart.dwAuthRetries;

            if ( fThisIsACallback )
            {
                strcpy( pNewPcb->szCallbackNumber,
                    pWorkItem->PppMsg.CallbackDone.szCallbackNumber );
            }
            else
            {
                strcpy( pNewPcb->szPortName,
                    pWorkItem->PppMsg.DdmStart.szPortName );
                PppLog( 1, "PortName: %s", pNewPcb->szPortName );
            }

            ZeroMemory( &(pNewPcb->ConfigInfo), sizeof( pNewPcb->ConfigInfo ) );
            ZeroMemory( &(pNewPcb->Luid), sizeof( LUID ) );
            pNewPcb->pBcb->szComputerName[0] = (CHAR)NULL;
            pNewPcb->ConfigInfo = PppConfigInfo.ServerConfigInfo;
            pNewPcb->dwAutoDisconnectTime = 0;
            pNewPcb->pBcb->szLocalUserName[0]   = (CHAR)NULL;
            pNewPcb->pBcb->szLocalDomain[0]     = (CHAR)NULL;
            pNewPcb->pBcb->szPassword[0]        = (CHAR)NULL;

            pNewPcb->pBcb->fFlags |= BCBFLAG_CAN_ACCEPT_CALLS;

            pNewPcb->pBcb->BapCb.szServerPhoneNumber =
                LocalAlloc( LPTR, sizeof(CHAR) * (RAS_MaxCallbackNumber + 1) );

            if ( NULL == pNewPcb->pBcb->BapCb.szServerPhoneNumber )
            {
                dwRetCode = GetLastError();

                NotifyCallerOfFailureOnPort(
                                       pWorkItem->hPort,
                                       TRUE,
                                       dwRetCode );

                break;
            }

            pNewPcb->pBcb->BapCb.szClientPhoneNumber =
                LocalAlloc( LPTR, sizeof(CHAR) * (RAS_MaxCallbackNumber + 1) );

            if ( NULL == pNewPcb->pBcb->BapCb.szClientPhoneNumber )
            {
                dwRetCode = GetLastError();

                NotifyCallerOfFailureOnPort(
                                       pWorkItem->hPort,
                                       TRUE,
                                       dwRetCode );

                break;
            }

            if ( GetCpIndexFromProtocol( PPP_BACP_PROTOCOL ) == (DWORD)-1 )
            {
                PppConfigInfo.ServerConfigInfo.dwConfigMask &=
                                                        ~PPPCFG_NegotiateBacp;
            }

            if ( PppConfigInfo.ServerConfigInfo.dwConfigMask &
                                                          PPPCFG_NegotiateBacp)
            {
                //
                // We won't check for successful return from this function.
                // If it fails, szServerPhoneNumber will remain an empty string.
                //

                FGetOurPhoneNumberFromHPort(
                        pNewPcb->hPort,
                        pNewPcb->pBcb->BapCb.szServerPhoneNumber);
            }

            pNewPcb->pUserAttributes = GetUserAttributes( pNewPcb );
        }
        else
        {
            pNewPcb->dwEapTypeToBeUsed = pWorkItem->PppMsg.Start.dwEapTypeId;

            pNewPcb->pBcb->hTokenImpersonateUser =
                pWorkItem->PppMsg.Start.hToken;
            pNewPcb->pBcb->pCustomAuthConnData =
                pWorkItem->PppMsg.Start.pCustomAuthConnData;
            pNewPcb->pBcb->pCustomAuthUserData =
                pWorkItem->PppMsg.Start.pCustomAuthUserData;

            //
            // EapUIData.pEapUIData is allocated by rasman and freed by engine.
            // raseap.c must not free it.
            //

            pNewPcb->pBcb->EapUIData =
                pWorkItem->PppMsg.Start.EapUIData;

            if (pWorkItem->PppMsg.Start.fLogon)
            {
                pNewPcb->pBcb->fFlags |= BCBFLAG_LOGON_USER_DATA;
            }
            if (pWorkItem->PppMsg.Start.fNonInteractive)
            {
                pNewPcb->fFlags |= PCBFLAG_NON_INTERACTIVE;
            }
            if (pWorkItem->PppMsg.Start.dwFlags & PPPFLAGS_DisableNetbt)
            {
                pNewPcb->fFlags |= PCBFLAG_DISABLE_NETBT;
            }

            //
            // We do this to get the sub entry index, which is required by BAP.
            // If this function fails, BAP will think that the sub entry is not
            // connected. BAP will not work correctly, but nothing very bad will
            // happen.
            //

            pNewPcb->dwSubEntryIndex = RasmanInfo.RI_SubEntry;

            pNewPcb->dwAuthRetries = 0;
            strcpy( pNewPcb->pBcb->szLocalUserName,
                    pWorkItem->PppMsg.Start.szUserName );

            DecodePw( pWorkItem->PppMsg.Start.chSeed, pWorkItem->PppMsg.Start.szPassword );
            strcpy( pNewPcb->pBcb->szPassword,
                    pWorkItem->PppMsg.Start.szPassword );
            EncodePw( pWorkItem->PppMsg.Start.chSeed, pWorkItem->PppMsg.Start.szPassword );

            EncodePw( pNewPcb->pBcb->chSeed, pNewPcb->pBcb->szPassword );

            strcpy( pNewPcb->pBcb->szLocalDomain,
                    pWorkItem->PppMsg.Start.szDomain );
            pNewPcb->Luid       = pWorkItem->PppMsg.Start.Luid;
            pNewPcb->ConfigInfo = pWorkItem->PppMsg.Start.ConfigInfo;
            pNewPcb->dwAutoDisconnectTime
                                = pWorkItem->PppMsg.Start.dwAutoDisconnectTime;

			//Set the LCPEchoTimeout here
			pNewPcb->dwLCPEchoTimeInterval = PppConfigInfo.dwLCPEchoTimeInterval;				//Time interval between LCP echos
			pNewPcb->dwIdleBeforeEcho = PppConfigInfo.dwIdleBeforeEcho;					//Idle time before the LCP echo begins
			pNewPcb->dwNumMissedEchosBeforeDisconnect = PppConfigInfo.dwNumMissedEchosBeforeDisconnect;	//Num missed echos before disconnect

			
            CopyMemory( pNewPcb->pBcb->InterfaceInfo.szzParameters,
                        pWorkItem->PppMsg.Start.szzParameters,
                        sizeof( pNewPcb->pBcb->InterfaceInfo.szzParameters ));

            GetLocalComputerName( pNewPcb->pBcb->szComputerName );

            strcpy( pNewPcb->szPortName, pWorkItem->PppMsg.Start.szPortName );
            PppLog(1,"PortName: %s", pNewPcb->szPortName);

            PPP_ASSERT( NULL == pNewPcb->pBcb->szPhonebookPath );
            PPP_ASSERT( NULL == pNewPcb->pBcb->szEntryName );
            PPP_ASSERT( NULL == pNewPcb->pBcb->BapCb.szServerPhoneNumber );

            pNewPcb->pBcb->szPhonebookPath
                = pWorkItem->PppMsg.Start.pszPhonebookPath;
            pNewPcb->pBcb->szEntryName = pWorkItem->PppMsg.Start.pszEntryName;

            //
            // pszPhoneNumber will have the originally dialed number, even if
            // this is a callback.
            //

            pNewPcb->pBcb->BapCb.szServerPhoneNumber
                = pWorkItem->PppMsg.Start.pszPhoneNumber;

            RemoveNonNumerals(pNewPcb->pBcb->BapCb.szServerPhoneNumber);

            pNewPcb->pBcb->BapParams = pWorkItem->PppMsg.Start.BapParams;

            pNewPcb->pBcb->fFlags |= BCBFLAG_CAN_ACCEPT_CALLS;
            pNewPcb->pBcb->fFlags |= BCBFLAG_CAN_CALL;

            if ( pNewPcb->ConfigInfo.dwConfigMask & PPPCFG_NoCallback )
            {
                pNewPcb->pBcb->fFlags &= ~BCBFLAG_CAN_ACCEPT_CALLS;
            }

            if ( pWorkItem->PppMsg.Start.PppInterfaceInfo.IfType == (DWORD)-1 )
            {
                pNewPcb->pBcb->InterfaceInfo.IfType      = (DWORD)-1;
                pNewPcb->pBcb->InterfaceInfo.hIPInterface= INVALID_HANDLE_VALUE;
                pNewPcb->pBcb->InterfaceInfo.hIPXInterface
                                                         = INVALID_HANDLE_VALUE;
            }
            else
            {
                pNewPcb->pBcb->InterfaceInfo =
                                    pWorkItem->PppMsg.Start.PppInterfaceInfo;

                //
                // If we are a router dialing out and fRedialOnLinkFailure is
                // set that means that we are a persistent interface so set
                // Idle-Disconnect time to 0.
                //

                if ( pNewPcb->pBcb->InterfaceInfo.IfType
                                                == ROUTER_IF_TYPE_FULL_ROUTER )
                {
                    if ( pWorkItem->PppMsg.Start.fRedialOnLinkFailure )
                    {
                        pNewPcb->dwAutoDisconnectTime = 0;
                    }

                    lstrcpy( pNewPcb->pBcb->szRemoteUserName,
                             pNewPcb->pBcb->szEntryName );
                    if (pNewPcb->ConfigInfo.dwConfigMask &
                                                        PPPCFG_AuthenticatePeer)
                    {
                        pNewPcb->pUserAttributes = GetUserAttributes( pNewPcb );
                    }
                }
            }

            if ( pNewPcb->pBcb->InterfaceInfo.IfType
                                                != ROUTER_IF_TYPE_FULL_ROUTER )
            {
                //
                // We want HKEY_CURRENT_USER to represent the logged on user,
                // not the service.
                //

                // What about the asynchronous RasDial case? Is it
                // possible that the process represented by dwPid is now gone?
                // Will it help if you use ImpersonateLoggedOnUser() to get
                // callback numbers?

                pNewPcb->pBcb->szTextualSid =
                    TextualSidFromPid( pWorkItem->PppMsg.Start.dwPid );
            }

            if ( GetCpIndexFromProtocol( PPP_BACP_PROTOCOL ) == (DWORD)-1 )
            {
                pNewPcb->ConfigInfo.dwConfigMask &= ~PPPCFG_NegotiateBacp;
            }
        }

        PppLog( 2, "Starting PPP on link with IfType=0x%x,IPIf=0x%x,IPXIf=0x%x",
                    pNewPcb->pBcb->InterfaceInfo.IfType,
                    pNewPcb->pBcb->InterfaceInfo.hIPInterface,
                    pNewPcb->pBcb->InterfaceInfo.hIPXInterface );

        //
        // Allocate bundle block for this port
        //

        dwLength = LCP_DEFAULT_MRU;

        dwRetCode = RasGetBuffer((CHAR**)&(pNewPcb->pSendBuf), &dwLength );

        if ( dwRetCode != NO_ERROR )
        {
            NotifyCallerOfFailure( pNewPcb, dwRetCode );

            break;
        }

        PppLog( 2, "RasGetBuffer returned %x for SendBuf", pNewPcb->pSendBuf);

        //
        // Initialize LCP and all the NCPs
        //

        pNewPcb->LcpCb.fConfigurable = TRUE;

        if ( !( FsmInit( pNewPcb, LCP_INDEX ) ) )
        {
            NotifyCallerOfFailure( pNewPcb, pNewPcb->LcpCb.dwError );

            break;
        }

        //
        // Ask RasMan to do RasPortReceive
        //

        dwRetCode = RasPppStarted( pNewPcb->hPort );

        if ( dwRetCode != NO_ERROR )
        {
            NotifyCallerOfFailure( pNewPcb, dwRetCode );

            break;
        }

        fSuccess = TRUE;

        //
        // Insert NewPcb into PCB hash table
        //

        dwIndex = HashPortToBucket( pWorkItem->hPort );

        PppLog( 2, "Inserting port in bucket # %d", dwIndex );

        pNewPcb->pNext = PcbTable.PcbBuckets[dwIndex].pPorts;

        PcbTable.PcbBuckets[dwIndex].pPorts = pNewPcb;

        //
        // Insert NewPcb's BCB into BCB hash table
        //

        dwIndex = HashPortToBucket( pNewPcb->pBcb->hConnection );

        PppLog( 2, "Inserting bundle in bucket # %d", dwIndex );

        pNewPcb->pBcb->pNext = PcbTable.BcbBuckets[dwIndex].pBundles;

        PcbTable.BcbBuckets[dwIndex].pBundles = pNewPcb->pBcb;

        //
        // Initialize the error as no response. If and when the first
        // REQ/ACK/NAK/REJ comes in we reset this to NO_ERROR
        //

        pNewPcb->LcpCb.dwError = ERROR_PPP_NO_RESPONSE;

        //
        // Start the LCP state machine.
        //

        FsmOpen( pNewPcb, LCP_INDEX );

        FsmUp( pNewPcb, LCP_INDEX );

        //
        // Start NegotiateTimer.
        //

        if ( PppConfigInfo.NegotiateTime > 0 )
        {
            InsertInTimerQ( pNewPcb->dwPortId,
                            pNewPcb->hPort,
                            0,
                            0,
                            FALSE,
                            TIMER_EVENT_NEGOTIATETIME,
                            PppConfigInfo.NegotiateTime );
        }

        //
        // If this is the server and this is not a callback line up, then we
        // receive the first frame in the call
        //

        if ( ( pNewPcb->fFlags & PCBFLAG_IS_SERVER ) && ( !fThisIsACallback ) )
        {
            PPP_PACKET * pPacket;

            if ( pNewPcb->LcpCb.dwError == ERROR_PPP_NO_RESPONSE )
            {
                pNewPcb->LcpCb.dwError = NO_ERROR;
            }

            //
            // Skip over the frame header and check if this is an LCP packet
            //

            pPacket=(PPP_PACKET*)(pWorkItem->PppMsg.DdmStart.achFirstFrame+12);

            if ( WireToHostFormat16( pPacket->Protocol ) == PPP_LCP_PROTOCOL )
            {
                ReceiveViaParser(
                            pNewPcb,
                            pPacket,
                            pWorkItem->PppMsg.DdmStart.cbFirstFrame - 12 );
            }
        }
    }
    while ( FALSE );

    if ( !fSuccess )
    {
        if ( !pWorkItem->fServer )
        {
            if ( INVALID_HANDLE_VALUE != pWorkItem->PppMsg.Start.hToken )
            {
                CloseHandle( pWorkItem->PppMsg.Start.hToken );
            }

            LocalFree( pWorkItem->PppMsg.Start.pCustomAuthConnData  );
            LocalFree( pWorkItem->PppMsg.Start.pCustomAuthUserData  );
            LocalFree( pWorkItem->PppMsg.Start.EapUIData.pEapUIData );
            LocalFree( pWorkItem->PppMsg.Start.pszPhonebookPath );
            LocalFree( pWorkItem->PppMsg.Start.pszEntryName     );
            LocalFree( pWorkItem->PppMsg.Start.pszPhoneNumber   );

            if (   ( NULL != pNewPcb )
                && ( NULL != pNewPcb->pBcb ) )
            {
                //
                // Do not LocalFree or CloseHandle twice
                //

                pNewPcb->pBcb->hTokenImpersonateUser = INVALID_HANDLE_VALUE;

                pNewPcb->pBcb->pCustomAuthConnData = NULL;
                pNewPcb->pBcb->pCustomAuthUserData = NULL;
                pNewPcb->pBcb->EapUIData.pEapUIData = NULL;
                pNewPcb->pBcb->szPhonebookPath = NULL;
                pNewPcb->pBcb->szEntryName = NULL;
                pNewPcb->pBcb->BapCb.szServerPhoneNumber = NULL;
            }
        }

        if ( NULL != pNewPcb )
        {
            DeallocateAndRemoveBcbFromTable( pNewPcb->pBcb );

            if ( NULL != pNewPcb->pSendBuf )
            {
                RasFreeBuffer( (CHAR*)(pNewPcb->pSendBuf) );
            }

            LOCAL_FREE( pNewPcb );
        }
    }
}

//**
//
// Call:        ProcessLineUp
//
// Returns:     None
//
// Description: Called to process a line up event.
//
VOID
ProcessLineUp(
    IN PCB_WORK_ITEM * pWorkItem
)
{
    ProcessLineUpWorker( pWorkItem,
                         ( pWorkItem->fServer )
                         ? FALSE
                         : pWorkItem->PppMsg.Start.fThisIsACallback );
}



//**
//
// Call:        ProcessPostLineDown
//
// Returns:     None.
//
// Description: Handles Post Line Down cleanup only in the case accounting is setup.
//              see Whistler BUG:174822
//
VOID
ProcessPostLineDown(
    IN PCB_WORK_ITEM * pWorkItem
)
{   
	//This function will be always called as a result of
	//postlinedown message.  So get the pcb from the work item directly.
	PCB *       pPcb            = (PCB *)pWorkItem->PppMsg.PostLineDown.pPcb;
	if ( pPcb == (PCB*)NULL )
	{
		PppLog( 1, "PostLineDown: PCB not found in post line down! Port = %d", pWorkItem->hPort );
		return;
	}
	PostLineDownWorker(pPcb);
}

VOID 
PostLineDownWorker( 
	PCB * pPcb
)
{
    PppLog( 1, "Post line down event occurred on port %d", pPcb->hPort );

	if ( !( pPcb->fFlags & PCBFLAG_DOING_CALLBACK ) )
	{		
		NotifyCaller( pPcb, PPPDDMMSG_PortCleanedUp, NULL );
	}
	else
	{
		if ( !(pPcb->fFlags & PCBFLAG_IS_SERVER ) )
		{
			//
			// If we get here and this flag is sent then we have not sent
			// the callback message to the client, hence we send it now.
			//

			NotifyCaller( pPcb, PPPMSG_Callback, NULL );
		}
	}

	if (   !(pPcb->fFlags & PCBFLAG_IS_SERVER )
		&& !(pPcb->fFlags & PCBFLAG_STOPPED_MSG_SENT) )
	{
		DWORD   dwError = 0;

		NotifyCaller( pPcb, PPPMSG_Stopped, &dwError );
	}

	if ( pPcb->fFlags & PCBFLAG_PORT_IN_LISTENING_STATE )
	{
		//
		// This flag is set in FListenForCall in bap.c
		//

		NotifyCallerOfFailure( pPcb, NO_ERROR );
	}
	
	LOCAL_FREE( pPcb );
}



//**
//
// Call:        ProcessLineDownWorker
//
// Returns:     None.
//
// Description: Handles a line down event. Will remove and deallocate all
//              resources associated with the port control block.
//
VOID
ProcessLineDownWorker(
    IN PCB_WORK_ITEM * pWorkItem,
	BOOL * pfFinalStage
)
{
    DWORD       dwIndex         = HashPortToBucket( pWorkItem->hPort );
    PCB *       pPcb            = GetPCBPointerFromhPort( pWorkItem->hPort );
    LCPCB *     pLcpCb;
    DWORD       dwForIndex;
    DWORD       dwErr;

	*pfFinalStage = TRUE;	

    PppLog( 1, "Line down event occurred on port %d", pWorkItem->hPort );

    //
    // If the port is already deleted then simply return.
    //

    if ( pPcb == (PCB*)NULL )
    {
        PppLog( 1, "PCB not found for port %d!", pWorkItem->hPort );
        *pfFinalStage = FALSE;
        return;
    }

    //
    // pPcb->pBcb may be NULL if the pPcb was allocated in FListenForCall and it
    // did not go thru ProcessLineUpWorker or ProcessRasPortListenEvent,
    // which is impossible. I have seen this happen once, when before the
    // server had a chance to call back, I hung up the connection, and
    // ProcessStopPPP sent a line down to all ports.
    //

    if ( pPcb->pBcb == (BCB*)NULL )
    {
        RemovePcbFromTable( pPcb );

        NotifyCaller( pPcb, PPPDDMMSG_PortCleanedUp, NULL );

        *pfFinalStage = FALSE;
        return;
    }

    //
    // Remove PCB from table
    // Important Note: Not removing this at this point in time can cause
	//	 a lot of grief!
	RemovePcbFromTable( pPcb );

	
    //
    // Cancel outstanding receive
    //

    RasPortCancelReceive( pPcb->hPort );

    FsmDown( pPcb, LCP_INDEX );

    //
    // Remove Auto-Disconnect and high level timer event from the timer Q
    //

    RemoveFromTimerQ( pPcb->dwPortId,
                      0,
                      0,
                      FALSE,
                      TIMER_EVENT_NEGOTIATETIME );

    RemoveFromTimerQ( pPcb->dwPortId,
                      0,
                      0,
                      FALSE,
                      TIMER_EVENT_LCP_ECHO );

	RemoveFromTimerQ( pPcb->dwPortId,
					  0,
					  0,
					  FALSE,
					  TIMER_EVENT_HANGUP
					);

	RemoveFromTimerQ( pPcb->dwPortId,
					  0,
					  0,
					  FALSE,
					  TIMER_EVENT_AUTODISCONNECT
					);

    if ( pPcb->fFlags & PCBFLAG_IS_SERVER )
    {
        RemoveFromTimerQ( pPcb->dwPortId,
                          0,
                          0,
                          FALSE,
                          TIMER_EVENT_SESSION_TIMEOUT );
    }

    //
    // Make stop accounting call. Need to make this call before unbundling
    // because we need to send some mulitlink information.
    //

    if ( pPcb->pAccountingAttributes != NULL )
    {
        RemoveFromTimerQ( pPcb->dwPortId,
                          0,
                          0,
                          FALSE,
                          TIMER_EVENT_INTERIM_ACCOUNTING );

        MakeStopOrInterimAccountingCall( pPcb, FALSE );
    }

    if ( pPcb->fFlags & PCBFLAG_CONNECTION_LOGGED )
    {
        LPSTR lpsSubStringArray[5];

        lpsSubStringArray[0] = pPcb->pBcb->szEntryName;
        lpsSubStringArray[1] = pPcb->pBcb->szLocalUserName;
        lpsSubStringArray[2] = pPcb->szPortName;

        PppLogInformation(ROUTERLOG_DISCONNECTION_OCCURRED,3,lpsSubStringArray);
    }

    //
    // Close all CPs if this is the last port in the bundle if it is bundled,
    // or if it was not bundled.
    //

    if ( ( ( pPcb->fFlags & PCBFLAG_IS_BUNDLED ) &&
           ( pPcb->pBcb->dwLinkCount == 1 ) )
         ||
         ( !(pPcb->fFlags & PCBFLAG_IS_BUNDLED) ) )
    {
        for(dwIndex=LCP_INDEX+1;dwIndex<PppConfigInfo.NumberOfCPs;dwIndex++)
        {
            CPCB * pCpCb = GetPointerToCPCB( pPcb, dwIndex );

            if (   ( NULL != pCpCb )
                && ( pCpCb->fBeginCalled == TRUE ) )
            {
                if ( pCpCb->pWorkBuf != NULL )
                {
                    (CpTable[dwIndex].CpInfo.RasCpEnd)( pCpCb->pWorkBuf );
                    pCpCb->pWorkBuf = NULL;
                }

                pCpCb->fBeginCalled = FALSE;
            }
        }

        if ( pPcb->pBcb != NULL )
        {
            //
            // Take care of the RAS server policy on workstation
            //

            if ( pPcb->pBcb->fFlags & BCBFLAG_WKSTA_IN )
            {
                if ( pPcb->dwDeviceType & RDT_Tunnel )
                {
                    PppConfigInfo.fFlags &= ~PPPCONFIG_FLAG_TUNNEL;
                }
                else if ( pPcb->dwDeviceType & RDT_Direct )
                {
                    PppConfigInfo.fFlags &= ~PPPCONFIG_FLAG_DIRECT;
                }
                else
                {
                    PppConfigInfo.fFlags &= ~PPPCONFIG_FLAG_DIALUP;
                }
            }

            DeallocateAndRemoveBcbFromTable( pPcb->pBcb );
        }
    }
    else if ( ( pPcb->fFlags & PCBFLAG_IS_BUNDLED ) &&
              ( pPcb->pBcb->dwLinkCount > 1 ) )
    {
        if ( pPcb->pBcb->fFlags & BCBFLAG_CAN_DO_BAP )
        {
            //
            // Reset the start time for the sample period. Now that the
            // bandwidth has changed, ndiswan shouldn't ask us to bring
            // links up or down based on what happened in the past.
            //

            BapSetPolicy( pPcb->pBcb );
        }

        pPcb->pBcb->dwLinkCount--;

        for ( dwForIndex = 0;
              dwForIndex < pPcb->pBcb->dwPpcbArraySize;
              dwForIndex++)
        {
            if ( pPcb->pBcb->ppPcb[dwForIndex] == pPcb )
            {
                pPcb->pBcb->ppPcb[dwForIndex] = NULL;
                break;
            }
        }

        if ( dwForIndex == pPcb->pBcb->dwPpcbArraySize )
        {
            PppLog( 1, "There is no back pointer to this PCB!!");
        }
    }

    //
    // Close the Aps.
    //

    pLcpCb = (LCPCB*)(pPcb->LcpCb.pWorkBuf);
    if ( pLcpCb != NULL)
    {
		dwIndex = GetCpIndexFromProtocol( pLcpCb->Local.Work.AP );

		if ( dwIndex != (DWORD)-1 )
		{
			ApStop( pPcb, dwIndex, TRUE );
		}

		dwIndex = GetCpIndexFromProtocol( pLcpCb->Remote.Work.AP );

		if ( dwIndex != (DWORD)-1 )
		{
			ApStop( pPcb, dwIndex, FALSE );
		}

		//
		// Close CBCP
		//

		dwIndex = GetCpIndexFromProtocol( PPP_CBCP_PROTOCOL );

		if ( dwIndex != (DWORD)-1 )
		{
			CbStop( pPcb, dwIndex );
		}

		//
		// Close LCP
		//

		(CpTable[LCP_INDEX].CpInfo.RasCpEnd)(pPcb->LcpCb.pWorkBuf);
		pPcb->LcpCb.pWorkBuf = NULL;
	}

    

    if ( pPcb->pSendBuf != (PPP_PACKET*)NULL )
    {
        RasFreeBuffer( (CHAR*)(pPcb->pSendBuf) );
    }

    if ( pPcb->pUserAttributes != NULL )
    {
        RasAuthAttributeDestroy( pPcb->pUserAttributes );

        pPcb->pUserAttributes = NULL;
    }

    if ( pPcb->pAuthenticatorAttributes != NULL )
    {
        PppConfigInfo.RasAuthProviderFreeAttributes(
                                            pPcb->pAuthenticatorAttributes );

        pPcb->pAuthenticatorAttributes = NULL;
    }

    //
    // Notify the server that the port is now cleaned up
    //
	// if accounting is turned on, do not notify the DDM that 
	// we are done as yet.  But do it in post clenup
	//moved to post line down
	/*
    if ( !( pPcb->fFlags & PCBFLAG_DOING_CALLBACK ) )
    {
		if ( 
        NotifyCaller( pPcb, PPPDDMMSG_PortCleanedUp, NULL );
    }
    else
    {
        if ( !(pPcb->fFlags & PCBFLAG_IS_SERVER ) )
        {
            //
            // If we get here and this flag is sent then we have not sent
            // the callback message to the client, hence we send it now.
            //

            NotifyCaller( pPcb, PPPMSG_Callback, NULL );
        }
    }
	*/

    //
    // Send PPPMSG_Stopped to rasman, if we haven't already. If we get a
    // PPPEMSG_Stop and then a PPPEMSG_LineDown before we call ProcessClose,
    // rasman will never get a PPPMSG_Stopped. This is because pPcb will be
    // deallocated and gone by the time we call ProcessClose. Note that we
    // process a LineDown immediately and do not put it only at the end of
    // the worker queue.
    //
    // DDM is not affected because of PPPDDMMSG_PortCleanedUp above.
    //

    //
    // If should be OK to remove PCBFLAG_STOPPED_MSG_SENT. Most probably rasman
    // can gracefully handle 2 PPPMSG_Stopped's. However, we don't want to take
    // chances this close to shipping.
    //  moved to post line down
	/*
    if (   !(pPcb->fFlags & PCBFLAG_IS_SERVER )
        && !(pPcb->fFlags & PCBFLAG_STOPPED_MSG_SENT) )
    {
        DWORD   dwError = 0;

        NotifyCaller( pPcb, PPPMSG_Stopped, &dwError );
    }

    if ( pPcb->fFlags & PCBFLAG_PORT_IN_LISTENING_STATE )
    {
        //
        // This flag is set in FListenForCall in bap.c
        //

        NotifyCallerOfFailure( pPcb, NO_ERROR );
    }

    LOCAL_FREE( pPcb );
	*/
	//if there are accounting attributes, 
	if ( pPcb->pAccountingAttributes != NULL )
	{
		//do not call the post line down
		//in ProcessLineDown but let the accounting thread send a message back to indicate that it is done
		
		*pfFinalStage = FALSE;
	}
}

//**
//
// Call:        ProcessLineDown
//
// Returns:     None.
//
// Description: Handles a line down event. Will remove and deallocate all
//              resources associated with the port control block.
//
VOID
ProcessLineDown(
    IN PCB_WORK_ITEM * pWorkItem
)
{
	BOOL		fFinalStage = TRUE;		//tells us if we should call ProcessPostLineDown 
									//right here or let accounting thread call it.
	PCB *       pPcb            = GetPCBPointerFromhPort( pWorkItem->hPort );
	
	ProcessLineDownWorker( pWorkItem, &fFinalStage );
	if ( fFinalStage )
    {
		PostLineDownWorker(pPcb);	    
    }
}

//**
//
// Call:        ProcessClose
//
// Returns:     None
//
// Description: Will process an admin close event. Basically close the PPP
//              connection.
//
VOID
ProcessClose(
    IN PCB_WORK_ITEM * pWorkItem
)
{
    DWORD dwIndex;
    PCB * pPcb = GetPCBPointerFromhPort( pWorkItem->hPort );

    if ( pPcb == (PCB*)NULL )
    {
        return;
    }

    if (  (!( pPcb->fFlags & PCBFLAG_IS_BUNDLED )) ||
          ( ( pPcb->fFlags & PCBFLAG_IS_BUNDLED ) &&
            ( pPcb->pBcb->dwLinkCount == 1 ) ) )
    {
        for (dwIndex = LCP_INDEX+1;
             dwIndex < PppConfigInfo.NumberOfCPs;
             dwIndex++)
        {
            CPCB * pCpCb = GetPointerToCPCB( pPcb, dwIndex );

            if ( ( NULL != pCpCb ) &&
                 ( pCpCb->fConfigurable == TRUE ) &&
                 ( pCpCb->pWorkBuf != NULL ) &&
                 ( CpTable[dwIndex].CpInfo.RasCpPreDisconnectCleanup != NULL ) )
            {
                (CpTable[dwIndex].CpInfo.RasCpPreDisconnectCleanup)(
                                                            pCpCb->pWorkBuf );
            }
        }
    }

    if ( pPcb->LcpCb.dwError == NO_ERROR )
    {
        pPcb->LcpCb.dwError = pWorkItem->PppMsg.PppStop.dwStopReason;
    }

    FsmClose( pPcb, LCP_INDEX );
}

//**
//
// Call:        ProcessReceive
//
// Returns:     None
//
// Description: Will handle a PPP packet that was received.
//
VOID
ProcessReceive(
    IN PCB_WORK_ITEM * pWorkItem
)
{
    PCB *  pPcb = GetPCBPointerFromhPort( pWorkItem->hPort );

    if ( pPcb == (PCB*)NULL )
        return;

    ReceiveViaParser( pPcb, pWorkItem->pPacketBuf, pWorkItem->PacketLen );

    LOCAL_FREE( pWorkItem->pPacketBuf );
}

//**
//
// Call:        ProcessThresholdEvent
//
// Returns:     None
//
// Description: Will handle a BAP threshold event (Add-Link or Drop-Link)
//
VOID
ProcessThresholdEvent(
    IN PCB_WORK_ITEM * pWorkItem
)
{
    BCB *   pBcb    = GetBCBPointerFromhConnection( pWorkItem->hConnection );

    if ( pBcb == NULL )
    {
        BapTrace( "HCONN %d has no port", pWorkItem->hConnection );

        return;
    }

    if ( pWorkItem->PppMsg.BapEvent.fAdd )
    {
        BapEventAddLink( pBcb );
    }
    else
    {
        BapEventDropLink( pBcb );
    }

    BapSetPolicy( pBcb );
}

//**
//
// Call:        ProcessCallResult
//
// Returns:     None
//
// Description: Will handle the result of a BAP call attempt (Success or Failure)
//
VOID
ProcessCallResult(
    IN PCB_WORK_ITEM * pWorkItem
)
{
    PCB * pPcb;
    BCB * pBcb = GetBCBPointerFromhConnection(pWorkItem->hConnection);
    DWORD dwErr;

    if ( pBcb == NULL )
    {
        BapTrace( "HCONN 0x%x has no port", pWorkItem->hConnection );

        dwErr = RasHangUp( pWorkItem->PppMsg.BapCallResult.hRasConn );

        if (0 != dwErr)
        {
            BapTrace("RasHangup failed and returned %d", dwErr);
        }

        return;
    }

    PPP_ASSERT( BAP_STATE_CALLING == pBcb->BapCb.BapState );

    BapEventCallResult( pBcb, &(pWorkItem->PppMsg.BapCallResult) );
}

//**
//
// Call:        ProcessRasPortListenEvent
//
// Returns:     None
//
// Description: Will handle a RasPortListen event (when the client is trying to
// accept a call).
//
VOID
ProcessRasPortListenEvent(
    IN PCB_WORK_ITEM * pWorkItem
)
{
    RASMAN_INFO         RasmanInfo;
    RASMAN_PPPFEATURES  RasmanPppFeatures;
    DWORD               dwErr;
    PCB *               pPcb                = NULL;
    BCB *               pBcb                = NULL;
    PCB *               pPcbSibling;
    CHAR                szPassword[PWLEN+1];

    ZeroMemory( &RasmanPppFeatures, sizeof(RasmanPppFeatures) );
    RasmanPppFeatures.ACCM = 0xFFFFFFFF;

    pPcb = GetPCBPointerFromhPort( pWorkItem->hPort );

    if ( NULL == pPcb )
    {
        BapTrace( "Couldn't get the PCB for hPort %d", pWorkItem->hPort );
        dwErr = ERROR_PORT_NOT_FOUND;
        goto LDone;
    }

    //
    // We can't just use pPcb->pBcb because TryToBundleWithAnotherLink(), etc
    // have not yet been called. pPcb->hConnection was set in FListenForCall()
    //

    pBcb = GetBCBPointerFromhConnection( pPcb->hConnection );

    if ( NULL == pBcb )
    {
        BapTrace( "Couldn't get the BCB for HCONN 0x%x", pPcb->hConnection );
        dwErr = ERROR_BUNDLE_NOT_FOUND;
        goto LDone;
    }

    BapTrace( "ProcessRasPortListenEvent on HCONN 0x%x", pBcb->hConnection );

    dwErr = RasGetInfo(NULL, pPcb->hPort, &RasmanInfo );

    if ( NO_ERROR == dwErr )
    {
        dwErr = RasmanInfo.RI_LastError;
    }

    if ( NO_ERROR != dwErr )
    {
        BapTrace( "RasGetInfo on hPort %d returned error %d%s",
            pPcb->hPort, dwErr,
            dwErr == ERROR_REQUEST_TIMEOUT ? " (ERROR_REQUEST_TIMEOUT)" : "" );
        goto LDone;
    }

    if ( LISTENCOMPLETED == RasmanInfo.RI_ConnState )
    {
        dwErr = RasPortConnectComplete( pPcb->hPort );

        if ( NO_ERROR != dwErr )
        {
            BapTrace( "RasPortConnectComplete on hPort %d returned error %d",
                pPcb->hPort, dwErr );
            goto LDone;
        }

        dwErr = RasPortSetFraming( pPcb->hPort, PPP, &RasmanPppFeatures,
                    &RasmanPppFeatures );

        if ( NO_ERROR != dwErr )
        {
            BapTrace( "RasPortSetFraming on hPort %d returned error %d",
                pPcb->hPort, dwErr );
            goto LDone;
        }

        pPcbSibling = GetPCBPointerFromBCB( pBcb );

        if ( NULL == pPcbSibling )
        {
            BapTrace( "Couldn't get a PCB for HCONN 0x%x", pPcb->hConnection );
            dwErr = !NO_ERROR;
            goto LDone;
        }

        DecodePw( pPcbSibling->pBcb->chSeed, pPcbSibling->pBcb->szPassword );
        strcpy( szPassword, pPcbSibling->pBcb->szPassword );
        EncodePw( pPcbSibling->pBcb->chSeed, pPcbSibling->pBcb->szPassword );

        if ( NULL != pPcbSibling->pBcb->pCustomAuthConnData )
        {
            dwErr = RasSetRasdialInfo(
                    pPcb->hPort,
                    pPcbSibling->pBcb->szPhonebookPath,
                    pPcbSibling->pBcb->szEntryName,
                    pPcbSibling->pBcb->BapCb.szServerPhoneNumber,
                    pPcbSibling->pBcb->pCustomAuthConnData->cbCustomAuthData,
                    pPcbSibling->pBcb->pCustomAuthConnData->abCustomAuthData );

            if ( NO_ERROR != dwErr )
            {
                BapTrace( "RasSetRasDialInfo failed. dwErr = %d", dwErr );
                goto LDone;
            }
        }

        if ( NULL != pPcbSibling->pBcb->pCustomAuthUserData )
        {
            RASEAPINFO  RasEapInfo;

            RasEapInfo.dwSizeofEapInfo =
                pPcbSibling->pBcb->pCustomAuthUserData->cbCustomAuthData;
            RasEapInfo.pbEapInfo =
                pPcbSibling->pBcb->pCustomAuthUserData->abCustomAuthData;

            dwErr = RasSetEapLogonInfo(
                    pPcb->hPort,
                    FALSE /* fLogon */,
                    &RasEapInfo );

            if ( NO_ERROR != dwErr )
            {
                BapTrace( "RasSetEapLogonInfo failed. dwErr = %d", dwErr );
                goto LDone;
            }
        }

        // This function returns before any LCP packet is exchanged.

        dwErr = RasPppStart(
                    pPcb->hPort,
                    pPcb->szPortName,
                    pPcbSibling->pBcb->szLocalUserName,
                    szPassword,
                    pPcbSibling->pBcb->szLocalDomain,
                    &(pPcbSibling->Luid),
                    &(pPcbSibling->ConfigInfo),
                    &(pBcb->InterfaceInfo),
                    pBcb->InterfaceInfo.szzParameters,
                    FALSE /* fThisIsACallback */,
                    INVALID_HANDLE_VALUE,
                    pPcbSibling->dwAutoDisconnectTime,
                    FALSE /* fRedialOnLinkFailure */,
                    &(pPcbSibling->pBcb->BapParams),
                    TRUE /* fNonInteractive */,
                    pPcbSibling->dwEapTypeToBeUsed,
                    (pPcbSibling->fFlags & PCBFLAG_DISABLE_NETBT) ?
                        PPPFLAGS_DisableNetbt : 0
                    );

        if ( NO_ERROR != dwErr )
        {
            BapTrace( "RasPppStart failed. dwErr = %d", dwErr );
            goto LDone;
        }

        BapTrace( "RasPppStart called successfully for hPort %d on HCONN 0x%x",
            pPcb->hPort, pBcb->hConnection );

        {
            CHAR*   apsz[3];

            apsz[0] = pPcbSibling->pBcb->szEntryName;
            apsz[1] = pPcbSibling->pBcb->szLocalUserName;
            apsz[2] = pPcb->szPortName;
            PppLogInformation(ROUTERLOG_BAP_SERVER_CONNECTED, 3, apsz);
        }
    }

LDone:

    if (NULL != pBcb)
    {
        pBcb->fFlags &= ~BCBFLAG_LISTENING;
        pBcb->BapCb.BapState = BAP_STATE_INITIAL;
        BapTrace("BAP state change to %s on HCONN 0x%x",
            SzBapStateName[BAP_STATE_INITIAL], pBcb->hConnection);
    }

    if (NO_ERROR != dwErr && NULL != pPcb)
    {
        NotifyCallerOfFailure( pPcb, NO_ERROR );

        RemovePcbFromTable( pPcb );

        LOCAL_FREE( pPcb );
    }
}

//**
//
// Call:        ProcessTimeout
//
// Returns:     None
//
// Description: Will process a timeout event.
//
VOID
ProcessTimeout(
    IN PCB_WORK_ITEM * pWorkItem
)
{
    DWORD       dwRetCode;
    DWORD       dwIndex;
    CPCB *      pCpCb;
    BCB *       pBcb;
    PCB *       pPcb;

    if ( pWorkItem->Protocol == PPP_BAP_PROTOCOL )
    {
        //
        // The hPort in pWorkItem is actually an hConnection
        //

        pBcb = GetBCBPointerFromhConnection( pWorkItem->hPort );

        if (pBcb != NULL)
        {
            BapEventTimeout( pBcb, pWorkItem->Id );
        }
        return;
    }

    pPcb = GetPCBPointerFromhPort( pWorkItem->hPort );

    if (   ( pPcb == (PCB*)NULL )
        || ( pWorkItem->dwPortId != pPcb->dwPortId ) )
    {
        return;
    }

    switch( pWorkItem->TimerEventType )
    {

    case TIMER_EVENT_TIMEOUT:

        FsmTimeout( pPcb,
                    GetCpIndexFromProtocol( pWorkItem->Protocol ),
                    pWorkItem->Id,
                    pWorkItem->fAuthenticator );
        break;

    case TIMER_EVENT_AUTODISCONNECT:

        //
        // Check to see if this timeout workitem is for AutoDisconnect.
        //

        CheckCpsForInactivity( pPcb, TIMER_EVENT_AUTODISCONNECT );

        break;

    case TIMER_EVENT_HANGUP:

        //
        // Hangup the line
        //

        FsmThisLayerFinished( pPcb, LCP_INDEX, FALSE );

        break;

    case TIMER_EVENT_NEGOTIATETIME:

        //
        // Notify caller that callback has timed out. We don't do anything for
        // the client since it may be in interactive mode and may take much
        // longer, besides, the user can allways cancel out.
        //

        if ( pPcb->fFlags & PCBFLAG_IS_SERVER )
        {
            if ( pPcb->PppPhase != PPP_NCP )
            {
                pPcb->LcpCb.dwError = ERROR_PPP_TIMEOUT;

                NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );

                break;
            }

            //
            // Check to see if all CPs are done or only IPXCP is remaining
            //

            for ( dwIndex = LCP_INDEX+1;
                  dwIndex < PppConfigInfo.NumberOfCPs;
                  dwIndex++)
            {
                pCpCb = GetPointerToCPCB( pPcb, dwIndex );

                if ( pCpCb->fConfigurable )
                {
                    if ( pCpCb->NcpPhase == NCP_CONFIGURING )
                    {
                        if ( CpTable[dwIndex].CpInfo.Protocol ==
                             PPP_IPXCP_PROTOCOL )
                        {
                            //
                            // If we are only waiting for IPXWAN to complete
                            //

                            if ( pCpCb->State == FSM_OPENED )
                            {
                                continue;
                            }
                        }

                        pPcb->LcpCb.dwError = ERROR_PPP_TIMEOUT;

                        NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );

                        return;
                    }
                }
            }

            dwIndex = GetCpIndexFromProtocol( PPP_IPXCP_PROTOCOL );

            if ( dwIndex == (DWORD)-1 )
            {
                //
                // No IPXCP installed in system
                //

                break;
            }

            pCpCb = GetPointerToCPCB( pPcb, dwIndex );

            //
            // We are waiting for IPXWAN so simply complete it with failure
            //

            if ( ( pCpCb->State == FSM_OPENED ) &&
                 ( pCpCb->NcpPhase == NCP_CONFIGURING ) )
            {
                PppLog( 2,
                     "Closing down IPXCP since completion routine not called");

                pCpCb = GetPointerToCPCB( pPcb, dwIndex );

                pCpCb->dwError = ERROR_PPP_NOT_CONVERGING;

                NotifyCallerOfFailure( pPcb, pCpCb->dwError );
            }
        }
        else
        {
            if (   ( pPcb->pBcb->InterfaceInfo.IfType ==
                                                    ROUTER_IF_TYPE_FULL_ROUTER )
                || ( pPcb->fFlags & PCBFLAG_NON_INTERACTIVE ) )
            {
                //
                // If we are a router dialing out, then we are in
                // non-interactive mode and hence this timeout should bring
                // down the link
                //

                pPcb->LcpCb.dwError = ERROR_PPP_TIMEOUT;

                NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );
            }
        }

        break;

    case TIMER_EVENT_SESSION_TIMEOUT:

        if ( pWorkItem->dwPortId == pPcb->dwPortId )
        {
            pPcb->LcpCb.dwError = ERROR_PPP_SESSION_TIMEOUT;

            NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );
        }

        break;

    case TIMER_EVENT_FAV_PEER_TIMEOUT:

        //
        // Drop the line if it isn't the last one in the bundle
        //

        if ( pPcb->pBcb->dwLinkCount > 1 &&
             pWorkItem->dwPortId == pPcb->dwPortId)
        {
            //
            // We compare dwPortId just to make sure that this is not a new
            // pPcb with the same hPort. dwPortId is never recycled, but hPort
            // is.
            //

            CHAR*   psz[3];

            if (!(pPcb->fFlags & PCBFLAG_IS_SERVER))
            {
                psz[0] = pPcb->pBcb->szEntryName;
                psz[1] = pPcb->pBcb->szLocalUserName;
                psz[2] = pPcb->szPortName;
                PppLogInformation(ROUTERLOG_BAP_DISCONNECTED, 3, psz);
            }

            BapTrace( "Forcibly disconnecting hPort %d: Favored peer failed "
                "to do so",
                pPcb->hPort);

            pPcb->LcpCb.dwError = ERROR_BAP_DISCONNECTED;

            FsmClose( pPcb, LCP_INDEX );
        }

        break;

    case TIMER_EVENT_INTERIM_ACCOUNTING:

        {
            RAS_AUTH_ATTRIBUTE *    pAttributes = NULL;
            RAS_AUTH_ATTRIBUTE *    pAttribute  = NULL;

            MakeStopOrInterimAccountingCall( pPcb, TRUE );

            if ( pPcb->pAuthProtocolAttributes != NULL )
            {
                pAttributes = pPcb->pAuthProtocolAttributes;

            }
            else if ( pPcb->pAuthenticatorAttributes != NULL )
            {
                pAttributes = pPcb->pAuthenticatorAttributes;
            }

            pAttribute = RasAuthAttributeGet(raatAcctInterimInterval,
                                             pAttributes);

            if ( pAttribute != NULL )
            {
                DWORD dwInterimInterval = PtrToUlong(pAttribute->Value);

                if ( dwInterimInterval < 60 )
                {
                    dwInterimInterval = 60;
                }

                InsertInTimerQ(
                        pPcb->dwPortId,
                        pPcb->hPort,
                        0,
                        0,
                        FALSE,
                        TIMER_EVENT_INTERIM_ACCOUNTING,
                        dwInterimInterval );
            }
        }

        break;
	
	case TIMER_EVENT_LCP_ECHO:
		{
			//
			// Check to see if this timeout workitem is for AutoDisconnect.
			//

			CheckCpsForInactivity( pPcb, TIMER_EVENT_LCP_ECHO );
		}
		break;
    default:

        break;
    }

}

//**
//
// Call:        ProcessRetryPassword
//
// Returns:     None
//
// Description:
//
VOID
ProcessRetryPassword(
    IN PCB_WORK_ITEM * pWorkItem
)
{
    PPPAP_INPUT PppApInput;
    PCB *       pPcb        = GetPCBPointerFromhPort( pWorkItem->hPort );
    LCPCB *     pLcpCb;


    if ( pPcb == (PCB*)NULL )
    {
        return;
    }

    if ( pPcb->PppPhase != PPP_AP )
    {
        return;
    }

    ZeroMemory( pPcb->pBcb->szPassword, sizeof( pPcb->pBcb->szPassword ) );

    strcpy( pPcb->pBcb->szLocalUserName, pWorkItem->PppMsg.Retry.szUserName );

    DecodePw( pWorkItem->PppMsg.Retry.chSeed, pWorkItem->PppMsg.Retry.szPassword );
    strcpy( pPcb->pBcb->szPassword, pWorkItem->PppMsg.Retry.szPassword );
    EncodePw( pWorkItem->PppMsg.Retry.chSeed, pWorkItem->PppMsg.Retry.szPassword );

    strcpy( pPcb->pBcb->szLocalDomain, pWorkItem->PppMsg.Retry.szDomain );

    PppApInput.pszUserName = pPcb->pBcb->szLocalUserName;
    PppApInput.pszPassword = pPcb->pBcb->szPassword;
    PppApInput.pszDomain   = pPcb->pBcb->szLocalDomain;

    //
    // Under the current scheme this should always be "" at this point but
    // handle it like it a regular password for robustness.
    //

    DecodePw( pPcb->pBcb->chSeed, pPcb->pBcb->szOldPassword );
    PppApInput.pszOldPassword = pPcb->pBcb->szOldPassword;

    pLcpCb = (LCPCB *)(pPcb->LcpCb.pWorkBuf);

    ApWork( pPcb,
            GetCpIndexFromProtocol( pLcpCb->Remote.Work.AP ),
            NULL,
            &PppApInput,
            FALSE );

    //
    // Encrypt the password
    //

    EncodePw( pPcb->pBcb->chSeed, pPcb->pBcb->szPassword );
    EncodePw( pPcb->pBcb->chSeed, pPcb->pBcb->szOldPassword );
}

//**
//
// Call:        ProcessChangePassword
//
// Returns:     None
//
// Description:
//
VOID
ProcessChangePassword(
    IN PCB_WORK_ITEM * pWorkItem
)
{
    PPPAP_INPUT PppApInput;
    PCB *       pPcb        = GetPCBPointerFromhPort( pWorkItem->hPort );
    CPCB *      pCpCb;
    LCPCB *     pLcpCb;

    if ( pPcb == (PCB*)NULL )
    {
        return;
    }

    if ( pPcb->PppPhase != PPP_AP )
    {
        return;
    }

    ZeroMemory( pPcb->pBcb->szLocalUserName,
                sizeof( pPcb->pBcb->szLocalUserName ) );
    strcpy(pPcb->pBcb->szLocalUserName, pWorkItem->PppMsg.ChangePw.szUserName);

    DecodePw( pWorkItem->PppMsg.ChangePw.chSeed, pWorkItem->PppMsg.ChangePw.szNewPassword );
    ZeroMemory( pPcb->pBcb->szPassword, sizeof( pPcb->pBcb->szPassword ) );
    strcpy( pPcb->pBcb->szPassword, pWorkItem->PppMsg.ChangePw.szNewPassword );
    EncodePw( pWorkItem->PppMsg.ChangePw.chSeed, pWorkItem->PppMsg.ChangePw.szNewPassword );

    DecodePw( pWorkItem->PppMsg.ChangePw.chSeed, pWorkItem->PppMsg.ChangePw.szOldPassword );
    ZeroMemory(pPcb->pBcb->szOldPassword, sizeof( pPcb->pBcb->szOldPassword ));
    strcpy(pPcb->pBcb->szOldPassword, pWorkItem->PppMsg.ChangePw.szOldPassword);
    EncodePw( pWorkItem->PppMsg.ChangePw.chSeed, pWorkItem->PppMsg.ChangePw.szOldPassword );

    PppApInput.pszUserName = pPcb->pBcb->szLocalUserName;
    PppApInput.pszPassword = pPcb->pBcb->szPassword;
    PppApInput.pszDomain   = pPcb->pBcb->szLocalDomain;
    PppApInput.pszOldPassword = pPcb->pBcb->szOldPassword;

    pLcpCb = (LCPCB *)(pPcb->LcpCb.pWorkBuf);

    ApWork( pPcb,
            GetCpIndexFromProtocol( pLcpCb->Remote.Work.AP ),
            NULL,
            &PppApInput,
            FALSE );

    //
    // Encrypt the passwords
    //

    EncodePw( pPcb->pBcb->chSeed, pPcb->pBcb->szPassword );
    EncodePw( pPcb->pBcb->chSeed, pPcb->pBcb->szOldPassword );
}

//**
//
// Call:        ProcessGetCallbackNumberFromUser
//
// Returns:     None
//
// Description: Will process the event of the user passing down the
//              "Set by caller" number
//
VOID
ProcessGetCallbackNumberFromUser(
    IN PCB_WORK_ITEM * pWorkItem
)
{
    PPPCB_INPUT  PppCbInput;
    PCB *        pPcb           = GetPCBPointerFromhPort( pWorkItem->hPort );

    if ( pPcb == (PCB*)NULL )
    {
        return;
    }

    if ( pPcb->PppPhase != PPP_NEGOTIATING_CALLBACK )
    {
        return;
    }

    ZeroMemory( &PppCbInput, sizeof( PppCbInput ) );

    strcpy( pPcb->szCallbackNumber,
            pWorkItem->PppMsg.Callback.szCallbackNumber );

    PppCbInput.pszCallbackNumber = pPcb->szCallbackNumber;

    CbWork( pPcb, GetCpIndexFromProtocol(PPP_CBCP_PROTOCOL),NULL,&PppCbInput);
}

//**
//
// Call:        ProcessCallbackDone
//
// Returns:     None
//
// Description: Will process the event of callback compeletion
//              "Set by caller" number
VOID
ProcessCallbackDone(
    IN PCB_WORK_ITEM * pWorkItem
)
{
    ProcessLineUpWorker( pWorkItem, TRUE );
}

//**
//
// Call:        ProcessStopPPP
//
// Returns:     None
//
// Description: Will simply set the events whose handle is in hPipe
//
VOID
ProcessStopPPP(
    IN PCB_WORK_ITEM * pWorkItem
)
{
    PRAS_OVERLAPPED pOverlapped;
    HINSTANCE       hInstance;
    PCB *           pPcbWalker;
    DWORD           dwIndex;
    PCB_WORK_ITEM   WorkItem;
    HANDLE          hEvent;

    //
    // Insert line down events for all ports
    //

    for ( dwIndex = 0; dwIndex < PcbTable.NumPcbBuckets; dwIndex++ )
    {
        RTASSERT( NULL == PcbTable.PcbBuckets[dwIndex].pPorts );
    }

    hInstance = LoadLibrary("rasppp.dll");

    if (hInstance == NULL)
    {
        return;
    }

    PppLog( 2, "All clients disconnected PPP-Stopped" );

    hEvent = pWorkItem->hEvent;

    //
    // PPPCleanUp() needs to be called before PostQueued...(). Otherwise,
    // Rasman may call StartPPP() and there will be a race condition.
    // Specifically, between ReadRegistryInfo and PPPCleanUp, both of which
    // access CpTable.
    //

    PPPCleanUp();

    pOverlapped = malloc(sizeof(RAS_OVERLAPPED));

    if (NULL == pOverlapped)
    {
        return;
    }

    pOverlapped->RO_EventType = OVEVT_RASMAN_FINAL_CLOSE;

    if ( !PostQueuedCompletionStatus( hEvent, 0, 0, (LPOVERLAPPED) pOverlapped ) )
    {
        free( pOverlapped );
    }

    FreeLibraryAndExitThread( hInstance, NO_ERROR );
}

//**
//
// Call:        ProcessInterfaceInfo
//
// Returns:     None
//
// Description: Processes the information interface information received from
//              DDM
//
VOID
ProcessInterfaceInfo(
    IN PCB_WORK_ITEM * pWorkItem
)
{
    DWORD     dwRetCode;
    DWORD     dwIndex;
    NCP_PHASE dwNcpState;
    HPORT     hPort;
    PCB *     pPcb = NULL;
    CPCB *    pCpCb;

    dwRetCode = RasBundleGetPort(NULL, pWorkItem->hConnection, &hPort );

    if ( dwRetCode != NO_ERROR )
    {
        return;
    }

    if ( ( pPcb = GetPCBPointerFromhPort( hPort ) ) == NULL )
    {
        return;
    }

    pCpCb = GetPointerToCPCB( pPcb, LCP_INDEX );

    PPP_ASSERT( NULL != pCpCb );

    if ( FSM_OPENED != pCpCb->State )
    {
        return;
    }

    pPcb->PppPhase = PPP_NCP;

    pPcb->pBcb->InterfaceInfo = pWorkItem->PppMsg.InterfaceInfo;

    if ( ROUTER_IF_TYPE_FULL_ROUTER == pPcb->pBcb->InterfaceInfo.IfType )
    {
        if ( NULL == pPcb->pBcb->szPhonebookPath )
        {
            dwRetCode = GetRouterPhoneBook( &(pPcb->pBcb->szPhonebookPath) );

            if ( dwRetCode != NO_ERROR )
            {
                pPcb->LcpCb.dwError = dwRetCode;

                NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );

                return;
            }
        }

        if ( NULL == pPcb->pBcb->szEntryName )
        {
            pPcb->pBcb->szEntryName =
                LocalAlloc( LPTR, (lstrlen(pPcb->pBcb->szRemoteUserName)+1) *
                                  sizeof(CHAR));

            if ( NULL == pPcb->pBcb->szEntryName )
            {
                pPcb->LcpCb.dwError = GetLastError();

                NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );

                return;
            }

            lstrcpy( pPcb->pBcb->szEntryName, pPcb->pBcb->szRemoteUserName );
        }

        //
        // Even if an error occurs, we don't have to free the alloc'd strings.
        // They will be freed when pPcb is freed.
        //
    }

    //
    // If we are not bundled.
    //

    if ( !(pPcb->fFlags & PCBFLAG_IS_BUNDLED) )
    {
        dwRetCode = InitializeNCPs( pPcb, pPcb->ConfigInfo.dwConfigMask );

        if ( dwRetCode != NO_ERROR )
        {
            pPcb->LcpCb.dwError = dwRetCode;

            NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );

            return;
        }

        //
        // Start negotiating the NCPs
        //

        StartNegotiatingNCPs( pPcb );

        return;
    }

    //
    // If we are bundled.
    // If negotiation has not started then start it, otherwise wait for it to
    // finish.
    //

    dwNcpState = QueryBundleNCPState( pPcb );

    switch ( dwNcpState )
    {
    case NCP_UP:

        NotifyCallerOfBundledProjection( pPcb );

        RemoveFromTimerQ( pPcb->dwPortId,
                          0,
                          0,
                          FALSE,
                          TIMER_EVENT_NEGOTIATETIME );

        StartAutoDisconnectForPort( pPcb );
		StartLCPEchoForPort ( pPcb );

        break;

    case NCP_CONFIGURING:

        PppLog( 2, "Bundle NCPs not done for port %d, wait", pPcb->hPort );

        break;

    case NCP_DOWN:

        pPcb->LcpCb.dwError = ERROR_PPP_NO_PROTOCOLS_CONFIGURED;

        NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );

        break;

    case NCP_DEAD:

        dwRetCode = InitializeNCPs( pPcb, pPcb->ConfigInfo.dwConfigMask );

        if ( dwRetCode != NO_ERROR )
        {
            pPcb->LcpCb.dwError = dwRetCode;

            NotifyCallerOfFailure( pPcb, pPcb->LcpCb.dwError );

            return;
        }

        //
        // Start NCPs for the bundle.
        //

        StartNegotiatingNCPs( pPcb );

        break;
    }
}

//**
//
// Call:        ProcessAuthInfo
//
// Returns:     None
//
// Description: Processes the information returned by the back-end
//              authentication module
//
VOID
ProcessAuthInfo(
    IN PCB_WORK_ITEM * pWorkItem
)
{
    PCB *   pPcb    = GetPCBPointerFromhPort( pWorkItem->hPort );
    LCPCB * pLcpCb  = NULL;
    DWORD   CpIndex;
    PPPAP_INPUT PppApInput;
    DWORD   dwRetCode;

    //
    // If we couldn't find the PCB because the port is disconnected
    //

    if ( pPcb == NULL )
    {
        if ( pWorkItem->PppMsg.AuthInfo.pOutAttributes != NULL )
        {
            PppConfigInfo.RasAuthProviderFreeAttributes(
                                pWorkItem->PppMsg.AuthInfo.pOutAttributes );
        }

        return;
    }

    pLcpCb = (LCPCB*)(pPcb->LcpCb.pWorkBuf);

    //
    // If this is a different instance of this port, ie port was disconnected
    // and reconnected.
    //

    if ( pPcb->dwPortId != pWorkItem->dwPortId )
    {
        if ( pWorkItem->PppMsg.AuthInfo.pOutAttributes != NULL )
        {
            PppConfigInfo.RasAuthProviderFreeAttributes(
                                pWorkItem->PppMsg.AuthInfo.pOutAttributes );
        }

        return;
    }

    CpIndex = GetCpIndexFromProtocol( pWorkItem->Protocol );

    //
    // If we renegotiated a different authentication protocol
    //

    if ( CpIndex != GetCpIndexFromProtocol( pLcpCb->Local.Work.AP ) )
    {
        PppConfigInfo.RasAuthProviderFreeAttributes(
                                pWorkItem->PppMsg.AuthInfo.pOutAttributes );

        return;
    }

    //
    // If the id of this request doesn't match
    //

    if ( pWorkItem->PppMsg.AuthInfo.dwId != pPcb->dwOutstandingAuthRequestId )
    {
        if ( pWorkItem->PppMsg.AuthInfo.pOutAttributes != NULL )
        {
            PppConfigInfo.RasAuthProviderFreeAttributes(
                                pWorkItem->PppMsg.AuthInfo.pOutAttributes );
        }

        return;
    }

    if ( 0 == pLcpCb->Local.Work.AP )
    {
        do
        {
            dwRetCode = NO_ERROR;

            if ( NO_ERROR != pWorkItem->PppMsg.AuthInfo.dwError )
            {
                dwRetCode = pWorkItem->PppMsg.AuthInfo.dwError;

                break;
            }

            if ( NO_ERROR != pWorkItem->PppMsg.AuthInfo.dwResultCode )
            {
                dwRetCode = pWorkItem->PppMsg.AuthInfo.dwResultCode;

                break;
            }

            pPcb->pAuthenticatorAttributes =
                                pWorkItem->PppMsg.AuthInfo.pOutAttributes;

            //
            // Set all the user connection parameters authorized by the
            // back-end authenticator
            //

            dwRetCode = SetUserAuthorizedAttributes(
                                    pPcb,
                                    pPcb->pAuthenticatorAttributes,
                                    TRUE,
                                    NULL,
                                    NULL );

            if ( dwRetCode != NO_ERROR )
            {
                break;
            }

            FsmThisLayerUp( pPcb, CpIndex );
        }
        while ( FALSE );

        if ( NO_ERROR != dwRetCode )
        {
            pPcb->LcpCb.dwError = dwRetCode;

            NotifyCallerOfFailure( pPcb, dwRetCode );

            if ( pWorkItem->PppMsg.AuthInfo.pOutAttributes != NULL )
            {
                PppConfigInfo.RasAuthProviderFreeAttributes(
                                    pWorkItem->PppMsg.AuthInfo.pOutAttributes );
            }
        }

        return;
    }

    //
    // If this authenticator is not configurable
    //

    if ( !pPcb->AuthenticatorCb.fConfigurable )
    {
        if ( pWorkItem->PppMsg.AuthInfo.pOutAttributes != NULL )
        {
            PppConfigInfo.RasAuthProviderFreeAttributes(
                                pWorkItem->PppMsg.AuthInfo.pOutAttributes );
        }

        return;
    }

    //
    // Free previously allocated attributes if any.
    //

    if ( pPcb->pAuthenticatorAttributes != NULL )
    {
        PppConfigInfo.RasAuthProviderFreeAttributes(
                                               pPcb->pAuthenticatorAttributes );

        pPcb->pAuthenticatorAttributes = NULL;
    }

    ZeroMemory( &PppApInput, sizeof( PppApInput ) );
    PppApInput.dwAuthResultCode     = pWorkItem->PppMsg.AuthInfo.dwResultCode;
    PppApInput.dwAuthError          = pWorkItem->PppMsg.AuthInfo.dwError;
    PppApInput.fAuthenticationComplete = TRUE;

    pPcb->pAuthenticatorAttributes =
                                pWorkItem->PppMsg.AuthInfo.pOutAttributes;

    PppApInput.pAttributesFromAuthenticator =
                                pWorkItem->PppMsg.AuthInfo.pOutAttributes;

    ApWork( pPcb, CpIndex, NULL, &PppApInput, TRUE );
}

//**
//
// Call:        ProcessDhcpInform
//
// Returns:     None
//
// Description: Processes the information returned by the call to
//              DhcpRequestOptions
//
VOID
ProcessDhcpInform(
    IN PCB_WORK_ITEM * pWorkItem
)
{
    DWORD   dwErr;
    PCB*    pPcb;
    HPORT   hPort;
    DWORD   IPCPIndex;
    CPCB*   pCpCb;
    BOOL    fFree       = TRUE;

    PppLog( 2, "ProcessDhcpInform" );

    dwErr = RasBundleGetPort(NULL, pWorkItem->hConnection, &hPort );

    if ( dwErr != NO_ERROR )
    {
        PppLog( 2, "RasBundleGetPort(%d) failed: %d",
            pWorkItem->hConnection, dwErr );

        goto LDone;
    }

    if ( ( pPcb = GetPCBPointerFromhPort( hPort ) ) == NULL )
    {
        PppLog( 2, "GetPCBPointerFromhPort(%d) failed", hPort );

        goto LDone;
    }

    IPCPIndex = GetCpIndexFromProtocol( PPP_IPCP_PROTOCOL );

    if ( IPCPIndex == (DWORD)-1 )
    {
        PppLog( 2, "GetCpIndexFromProtocol(IPCP) failed" );

        goto LDone;
    }

    pCpCb = GetPointerToCPCB( pPcb, IPCPIndex );

    if ( NULL == pCpCb )
    {
        PppLog( 2, "GetPointerToCPCB(IPCP) failed" );

        goto LDone;
    }

    if ( PppConfigInfo.RasIpcpDhcpInform != NULL )
    {
        dwErr = PppConfigInfo.RasIpcpDhcpInform(
                    pCpCb->pWorkBuf,
                    &(pWorkItem->PppMsg.DhcpInform) );

        if ( NO_ERROR == dwErr )
        {
            fFree = FALSE;
        }
    }

LDone:

    LocalFree(pWorkItem->PppMsg.DhcpInform.wszDevice);
    LocalFree(pWorkItem->PppMsg.DhcpInform.szDomainName);

    if (fFree)
    {
        LocalFree(pWorkItem->PppMsg.DhcpInform.pdwDNSAddresses);
    }
}

//**
//
// Call:        ProcessIpAddressLeaseExpired
//
// Returns:     None
//
// Description: Processes the expiry of the lease of an Ip address from a
//              Dhcp server.
//
VOID
ProcessIpAddressLeaseExpired(
    IN PCB_WORK_ITEM * pWorkItem
)
{
    PppLog( 2, "ProcessIpAddressLeaseExpired" );

    if ( PppConfigInfo.RasIphlpDhcpCallback != NULL )
    {
        PppConfigInfo.RasIphlpDhcpCallback(
                    pWorkItem->PppMsg.IpAddressLeaseExpired.nboIpAddr );
    }
}

//**
//
// Call:        ProcessEapUIData
//
// Returns:     None
//
// Description:
//
VOID
ProcessEapUIData(
    IN PCB_WORK_ITEM * pWorkItem
)
{
    PPPAP_INPUT PppApInput;
    PCB *       pPcb        = GetPCBPointerFromhPort( pWorkItem->hPort );
    LCPCB *     pLcpCb;

    if ( pPcb == (PCB*)NULL )
    {
        return;
    }

    if ( pPcb->PppPhase != PPP_AP )
    {
        return;
    }

    pLcpCb = (LCPCB *)(pPcb->LcpCb.pWorkBuf);

    ZeroMemory( &PppApInput, sizeof( PppApInput ) );

    PppApInput.fEapUIDataReceived = TRUE;

    PppApInput.EapUIData = pWorkItem->PppMsg.EapUIData;

    ApWork( pPcb,
            GetCpIndexFromProtocol( pLcpCb->Remote.Work.AP ),
            NULL,
            &PppApInput,
            FALSE );

    //
    // EapUIData.pEapUIData is allocated by rasman and freed by engine.
    // raseap.c must not free it.
    //

    LocalFree( pWorkItem->PppMsg.EapUIData.pEapUIData );
}

//**
//
// Call:        ProcessChangeNotification
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will be called whenever there is a change in configuration
//              that has to be picked up
//
VOID
ProcessChangeNotification(
    IN PCB_WORK_ITEM * pWorkItem
)
{
    DWORD   dwIndex;
    DWORD   dwRetCode;
    DWORD   cTotalNumProtocols;

    PppLog( 2, "Processing change notification event" );

    //
    // Re-read all the ppp key values
    //

    ReadPPPKeyValues( PppConfigInfo.hKeyPpp );

    LoadParserDll( PppConfigInfo.hKeyPpp );

    //
    // Walk thru the CP table and invoke the change notification method
    // for each one.
    //

    cTotalNumProtocols = PppConfigInfo.NumberOfCPs + PppConfigInfo.NumberOfAPs;

    for ( dwIndex = 0; dwIndex < cTotalNumProtocols; dwIndex++ )
    {
        if ( ( CpTable[dwIndex].fFlags & PPPCP_FLAG_AVAILABLE ) &&
             ( CpTable[dwIndex].CpInfo.RasCpChangeNotification != NULL ) )
        {
            dwRetCode = CpTable[dwIndex].CpInfo.RasCpChangeNotification();

            if ( dwRetCode != NO_ERROR )
            {
                PppLog( 2,
                       "ChangeNotification for Protocol 0x%x failed, error=%d",
                       CpTable[dwIndex].CpInfo.Protocol, dwRetCode );
            }
        }
    }
}

//**
//
// Call:        ProcessProtocolEvent
//
// Returns:     None
//
// Description: Will be called whenever a protocol is installed or uninstalled.
//
VOID
ProcessProtocolEvent(
    IN PCB_WORK_ITEM * pWorkItem
)
{
    DWORD   dwIndex;
    DWORD   dwProtocol;
    DWORD   cTotalNumProtocols;
    CHAR*   szSubKey;
    CHAR*   SubStringArray[2];
    DWORD   dwError;

    PppLog( 2, "Processing protocol event" );

    //
    // Ignore any message other than one saying that a protocol was installed.
    //

    if ( pWorkItem->PppMsg.ProtocolEvent.ulFlags != RASMAN_PROTOCOL_ADDED )
    {
        if (   ( pWorkItem->PppMsg.ProtocolEvent.ulFlags ==
                    RASMAN_PROTOCOL_REMOVED )
            && ( pWorkItem->PppMsg.ProtocolEvent.usProtocolType == IP ) )
        {
            //
            // NT5 Bug 398226. When PSched is installed/uninstalled, IP is
            // unbound from wanarp so that PSched can be bound/unbound between
            // IP and wanarp. The server adapter needs to be mapped again.
            //

            RasSrvrAdapterUnmapped();
        }

        return;
    }

    switch ( pWorkItem->PppMsg.ProtocolEvent.usProtocolType )
    {
    case IP:

        dwProtocol = PPP_IPCP_PROTOCOL;
        PppLog( 2, "Adding IP" );
        break;

    case IPX:

        dwProtocol = PPP_IPXCP_PROTOCOL;
        PppLog( 2, "Adding IPX" );
        break;

    case ASYBEUI:

        dwProtocol = PPP_NBFCP_PROTOCOL;
        PppLog( 2, "Adding ASYBEUI" );
        break;

    case APPLETALK:

        dwProtocol = PPP_ATCP_PROTOCOL;
        PppLog( 2, "Adding APPLETALK" );
        break;

    default:

        return;

    }

    cTotalNumProtocols = PppConfigInfo.NumberOfCPs + PppConfigInfo.NumberOfAPs;

    for ( dwIndex = 0; dwIndex < cTotalNumProtocols; dwIndex++ )
    {
        if ( dwProtocol == CpTable[dwIndex].CpInfo.Protocol )
        {
            if (    !( CpTable[dwIndex].fFlags & PPPCP_FLAG_INIT_CALLED )
                 && CpTable[dwIndex].CpInfo.RasCpInit )
            {
                PppLog( 1, "RasCpInit(%x, TRUE)", dwProtocol );

                dwError = CpTable[dwIndex].CpInfo.RasCpInit(
                                TRUE /* fInitialize */ );

                CpTable[dwIndex].fFlags |= PPPCP_FLAG_INIT_CALLED;

                if ( NO_ERROR != dwError )
                {
                    SubStringArray[0] = CpTable[dwIndex].CpInfo.SzProtocolName;
                    SubStringArray[1] = "(unknown)";

                    PppLogErrorString(
                              ROUTERLOG_PPPCP_INIT_ERROR,
                              2,
                              SubStringArray,
                              dwError,
                              2 );

                    PppLog(
                        1,
                        "RasCpInit(TRUE) for protocol 0x%x returned error %d",
                        dwProtocol, dwError );
                }
                else
                {
                    CpTable[dwIndex].fFlags |= PPPCP_FLAG_AVAILABLE;
                }
            }

            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\engine\worker.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	worker.h
//
// Description: 
//
// History:
//	Nov 11,1993.	NarenG		Created original version.
//

DWORD
WorkerThread( 
    IN LPVOID pThreadParameter 
);

VOID
ProcessLineUp( 
    IN PCB_WORK_ITEM * pWorkItem 
);

VOID
ProcessLineDown( 
    IN PCB_WORK_ITEM * pWorkItem 
);

VOID
ProcessPostLineDown(
    IN PCB_WORK_ITEM * pWorkItem
);

VOID 
PostLineDownWorker( 
	PCB * pPcb
);

VOID
ProcessClose(
    IN PCB_WORK_ITEM * pWorkItem 
);

VOID
ProcessReceive( 
    IN PCB_WORK_ITEM * pWorkItem 
);

VOID
ProcessThresholdEvent(
    IN PCB_WORK_ITEM * pWorkItem
);

VOID
ProcessCallResult(
    IN PCB_WORK_ITEM * pWorkItem
);

VOID
ProcessRasPortListenEvent(
    IN PCB_WORK_ITEM * pWorkItem
);

VOID
ProcessTimeout( 
    IN PCB_WORK_ITEM * pWorkItem 
);

VOID
ProcessRetryPassword( 
    IN PCB_WORK_ITEM * pWorkItem 
);

VOID
ProcessChangePassword( 
    IN PCB_WORK_ITEM * pWorkItem 
);

VOID
ProcessCallbackDone( 
    IN PCB_WORK_ITEM * pWorkItem 
);

VOID
ProcessGetCallbackNumberFromUser(
    IN PCB_WORK_ITEM * pWorkItem 
);

VOID
ProcessStopPPP( 
    IN PCB_WORK_ITEM * pWorkItem 
);

VOID
ProcessInterfaceInfo(
    IN PCB_WORK_ITEM * pWorkItem
);

VOID
ProcessAuthInfo(
    IN PCB_WORK_ITEM * pWorkItem
);

VOID
ProcessDhcpInform(
    IN PCB_WORK_ITEM * pWorkItem
);

VOID
ProcessIpAddressLeaseExpired(
    IN PCB_WORK_ITEM * pWorkItem
);

VOID
ProcessEapUIData(
    IN PCB_WORK_ITEM * pWorkItem
);

VOID
ProcessChangeNotification(
    IN PCB_WORK_ITEM * pWorkItem
);

VOID
ProcessProtocolEvent(
    IN PCB_WORK_ITEM * pWorkItem
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasatcp\rasatcp.h ===
/********************************************************************/
/**               Copyright(c) 1998 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    rasatcp.h

//
// Description: Contains defines for the rasatcp component.  This is really
//              a thin wrapper layer, so not much happens here!
//
// History:     Feb 26, 1998    Shirish Koti     Created original version.
//
//***
#ifndef _RASATCP_H_
#define _RASATCP_H_


#define ARAP_DEVICE_NAME    L"\\Device\\AtalkArap"

#define ATCP_SIGNATURE      0x08121994

#define ATCP_OPT_APPLETALK_ADDRESS          1
#define ATCP_OPT_ROUTING_PROTOCOL           2
#define ATCP_OPT_SUPPRESS_BROADCAST         3
#define ATCP_OPT_AT_COMPRESSION_PROTOCOL    4
#define ATCP_OPT_RESERVED                   5
#define ATCP_OPT_SERVER_INFORMATION         6
#define ATCP_OPT_ZONE_INFORMATION           7
#define ATCP_OPT_DEFAULT_ROUTER_ADDRESS     8

// modify this value appropriately, if Apple ever defines more options
#define ATCP_OPT_MAX_VAL                    9

#define ATCP_NOT_REQUESTED  0
#define ATCP_REQ            1
#define ATCP_REJ            2
#define ATCP_NAK            3
#define ATCP_ACK            4

// the only routing option we support is no routing info
#define ATCP_OPT_ROUTING_NONE   0

// we define the Server-Class for "Appletalk PPP Dial-In Server"
#define ATCP_SERVER_CLASS               0x001

// NT5.0: Major version = 05, minor version = 0
#define ATCP_SERVER_IMPLEMENTATION_ID   0x05000000

#define ARAP_BIND_SIZE      sizeof(PROTOCOL_CONFIG_INFO)+sizeof(ARAP_BIND_INFO)

#define DDPPROTO_RTMPRESPONSEORDATA     1

typedef struct _ATCPCONN
{
    DWORD               Signature;
    PVOID               AtalkContext;     // stack's context
    HPORT               hPort;
    HBUNDLE             hConnection;
    DWORD               Flags;
    NET_ADDR            ClientAddr;       // what we give to the client
    CRITICAL_SECTION    CritSect;
    BOOLEAN             SuppressRtmp;
    BOOLEAN             SuppressAllBcast;
    BOOLEAN             fLineUpDone;
    RASMAN_ROUTEINFO    RouteInfo;
} ATCPCONN, *PATCPCONN;

#define ATCP_CONFIG_REQ_DONE    0x1


#if DBG

#define ATCP_DBGPRINT(_x)   \
{                           \
    DbgPrint("ATCP: ");     \
    DbgPrint _x;            \
}

#define ATCP_ASSERT(_x)                                                           \
{                                                                                 \
    if (!(_x))                                                                    \
    {                                                                             \
        DbgPrint("ATCP: Assertion failed File %s, line %ld",__FILE__, __LINE__);  \
        DbgBreakPoint();                                                          \
    }                                                                             \
}

#define ATCP_DUMP_BYTES(_a,_b,_c)   atcpDumpBytes(_a,_b,_c)

#else
#define ATCP_DBGPRINT(_x)
#define ATCP_ASSERT(_x)
#define ATCP_DUMP_BYTES(_a,_b,_c)
#endif


//
// Global externs
//
extern HANDLE              AtcpHandle;
extern CRITICAL_SECTION    AtcpCritSect;
extern NET_ADDR            AtcpServerAddress;
extern NET_ADDR            AtcpDefaultRouter;
extern DWORD               AtcpNumConnections;
extern UCHAR               AtcpServerName[NAMESTR_LEN];
extern UCHAR               AtcpZoneName[ZONESTR_LEN];


//
// prototypes from exports.c
//

DWORD
AtcpInit(
    IN  BOOL    fInitialize
);

DWORD
AtcpBegin(
    OUT PVOID  *ppContext,
    IN  PVOID   pInfo
);

DWORD
AtcpEnd(
    IN PVOID    pContext
);

DWORD
AtcpReset(
    IN PVOID    pContext
);

DWORD
AtcpThisLayerUp(
    IN PVOID    pContext
);

DWORD
AtcpMakeConfigRequest(
    IN  PVOID       pContext,
    OUT PPP_CONFIG *pSendBuf,
    IN  DWORD       cbSendBuf
);

DWORD
AtcpMakeConfigResult(
    IN  PVOID       pContext,
    IN  PPP_CONFIG *pReceiveBuf,
    OUT PPP_CONFIG *pSendBuf,
    IN  DWORD       cbSendBuf,
    IN  BOOL        fRejectNaks
);

DWORD
AtcpConfigAckReceived(
    IN PVOID       pContext,
    IN PPP_CONFIG *pReceiveBuf
);

DWORD
AtcpConfigNakReceived(
    IN PVOID       pContext,
    IN PPP_CONFIG *pReceiveBuf
);

DWORD
AtcpConfigRejReceived(
    IN PVOID       pContext,
    IN PPP_CONFIG *pReceiveBuf
);

DWORD
AtcpGetNegotiatedInfo(
    IN  PVOID               pContext,
    OUT PPP_ATCP_RESULT    *pAtcpResult
);

DWORD
AtcpProjectionNotification(
    IN PVOID  pContext,
    IN PVOID  pProjectionResult
);


//
// prototypes from rasatcp.c
//

DWORD
atcpStartup(
    IN  VOID
);


VOID
atcpOpenHandle(
	IN VOID
);


DWORD
atcpAtkSetup(
    IN PATCPCONN   pAtcpConn,
    IN ULONG       IoControlCode
);


VOID
atcpCloseHandle(
	IN VOID
);


PATCPCONN
atcpAllocConnection(
    IN  PPPCP_INIT   *pPppInit
);


DWORD
atcpCloseAtalkConnection(
    IN  PATCPCONN   pAtcpConn
);


DWORD
atcpParseRequest(
    IN  PATCPCONN   pAtcpConn,
    IN  PPP_CONFIG *pReceiveBuf,
    OUT PPP_CONFIG *pSendBuf,
    IN  DWORD       cbSendBuf,
    OUT BYTE        ParseResult[ATCP_OPT_MAX_VAL],
    OUT BOOL       *pfRejectingSomething
);

DWORD
atcpPrepareResponse(
    IN  PATCPCONN   pAtcpConn,
    OUT PPP_CONFIG *pSendBuf,
    IN  DWORD       cbSendBuf,
    OUT BYTE        ParseResult[ATCP_OPT_MAX_VAL]
);

VOID
atcpDumpBytes(
    IN PBYTE    Str,
    IN PBYTE    Packet,
    IN DWORD    PacketLen
);

#endif // _RASIPCP_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasatcp\rasatcp.c ===
/********************************************************************/
/**               Copyright(c) 1998 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    rasatcp.c

//
// Description: Contains routines that implement the ATCP functionality.
//
// History:     Feb 26, 1998    Shirish Koti     Created original version.
//
//***

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <lmcons.h>
#include <string.h>
#include <stdlib.h>
#include <llinfo.h>
#include <rasman.h>
#include <rtutils.h>
#include <devioctl.h>
#include <rasppp.h>
#include <pppcp.h>
#define INCL_HOSTWIRE
#include <ppputil.h>
#include <raserror.h>

#include <arapio.h>
#include "rasatcp.h"

//
// Globals
//
HANDLE              AtcpHandle=NULL;
CRITICAL_SECTION    AtcpCritSect;
NET_ADDR            AtcpServerAddress;
NET_ADDR            AtcpDefaultRouter;
DWORD               AtcpNumConnections=0;
UCHAR               AtcpServerName[NAMESTR_LEN];
UCHAR               AtcpZoneName[ZONESTR_LEN];


//***
//
// Function:    atcpStartup
//              This routine does init time setup
//
// Return:      result of operation
//
//***$

DWORD
atcpStartup(
    IN  VOID
)
{
    DWORD   dwRetCode=NO_ERROR;
    DWORD   dwSrvNameLen=MAX_COMPUTERNAME_LENGTH+1;


    // get the server name
    if (!GetComputerName((LPTSTR)&AtcpServerName[1],&dwSrvNameLen))
    {
        dwRetCode = GetLastError();
        ATCP_DBGPRINT(("atcpStartup: GetComputerName failed %ld\n",dwRetCode));
        return(dwRetCode);
    }

    // store it in Pascal string format
    AtcpServerName[0] = (BYTE)dwSrvNameLen;

    InitializeCriticalSection( &AtcpCritSect );

    return(dwRetCode);
}


//***
//
// Function:    atcpOpenHandle
//              Opens the RAS device exported by the appletalk stack
//
// Parameters:  None
//
// Return:      None
//
// Globals:     AtcpHandle, if successful
//
//***$

VOID
atcpOpenHandle(
	IN VOID
)
{
    NTSTATUS		    status;
    OBJECT_ATTRIBUTES	ObjectAttributes;
    UNICODE_STRING	 	DeviceName;
    IO_STATUS_BLOCK		IoStatus;
    HANDLE              hLocalHandle;


    if (AtcpHandle)
    {
        ATCP_DBGPRINT(("atcpOpenHandle: handle %lx already open!\n",AtcpHandle));
        return;
    }

    RtlInitUnicodeString( &DeviceName, ARAP_DEVICE_NAME );

    InitializeObjectAttributes(
                    &ObjectAttributes,
		    	    &DeviceName,
			        OBJ_CASE_INSENSITIVE,
			        NULL,
			        NULL );
		
    status = NtCreateFile(
                    &hLocalHandle,
                    SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                    &ObjectAttributes,
                    &IoStatus,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN_IF,
                    0,
                    NULL,
                    0 );


    if ( NT_SUCCESS(status) )
    {
        AtcpHandle = hLocalHandle;
        ATCP_DBGPRINT(("atcpOpenHandle: NtCreateFile succeeded\n",status));
    }
    else
    {
        ATCP_DBGPRINT(("atcpOpenHandle: NtCreateFile failed %lx\n",status));
    }

}


//***
//
// Function:    atcpCloseHandle
//              Closes the RAS device (opened in atcpOpenHandle)
//
// Parameters:  None
//
// Return:      None
//
// Globals:     AtalkHandle
//
//***$

VOID
atcpCloseHandle(
	IN VOID
)
{
    NTSTATUS	status=STATUS_SUCCESS;


    if (!AtcpHandle)
    {
        ATCP_DBGPRINT(("atcpCloseHandle: handle already closed!\n"));
        return;
    }

    status = NtClose( AtcpHandle );

    AtcpHandle = NULL;

    if ( !NT_SUCCESS( status ) )
    {
        ATCP_DBGPRINT(("atcpCloseHandle: NtClose failed %lx\n",status));
        ATCP_ASSERT(0);
    }
    else
    {
        ATCP_DBGPRINT(("atcpCloseHandle: NtClose succeeded\n",status));
    }
}



//***
//
// Function:    atcpAtkSetup
//              This is the entry point into the stack to tell the stack to
//              set up a context for this connection, to get a network address
//              for the dial-in client, server's zone name, and router address
//
// Parameters:  pAtcpConn - connection context
//
// Return:      status returned by NtDeviceIoControlFile
//
//***$

DWORD
atcpAtkSetup(
    IN PATCPCONN   pAtcpConn,
    IN ULONG       IoControlCode
)
{


    NTSTATUS                status;
    IO_STATUS_BLOCK         iosb;
    HANDLE                  Event;
    BYTE                    Buffer[sizeof(ARAP_SEND_RECV_INFO) + sizeof(ATCPINFO)];
    PARAP_SEND_RECV_INFO    pSndRcvInfo;
    PATCPINFO               pAtcpInfo;
    PATCP_SUPPRESS_INFO     pSupprInfo;
    DWORD                   dwRetCode=NO_ERROR;


    RtlZeroMemory((PBYTE)Buffer, sizeof(Buffer));

    pSndRcvInfo = (PARAP_SEND_RECV_INFO)Buffer;
    pSndRcvInfo->StatusCode = (DWORD)-1;
    pSndRcvInfo->pDllContext = (PVOID)pAtcpConn;
    pSndRcvInfo->IoctlCode = IoControlCode;
    pSndRcvInfo->ClientAddr = pAtcpConn->ClientAddr;

    if (IoControlCode == IOCTL_ATCP_SETUP_CONNECTION)
    {
        pSndRcvInfo->DataLen = sizeof(ATCPINFO);
    }
    else if (IoControlCode == IOCTL_ATCP_SUPPRESS_BCAST)
    {
        // if we don't need to suppress broadcasts, done here
        if ((!pAtcpConn->SuppressRtmp) && (!pAtcpConn->SuppressAllBcast))
        {
            return(NO_ERROR);
        }
        pSndRcvInfo->DataLen = sizeof(ATCP_SUPPRESS_INFO);

        pSupprInfo = (PATCP_SUPPRESS_INFO)&pSndRcvInfo->Data[0];
        pSupprInfo->SuppressRtmp = pAtcpConn->SuppressRtmp;
        pSupprInfo->SuppressAllBcast = pAtcpConn->SuppressAllBcast;
    }
    else
    {
        pSndRcvInfo->DataLen = 0;
    }

    Event = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (Event == NULL)
    {
        ATCP_DBGPRINT(("atcpAtkSetup: CreateEvent failed (%ld)\n",GetLastError()));
        return(ARAPERR_OUT_OF_RESOURCES);
    }

    status = NtDeviceIoControlFile(
                    AtcpHandle,
                    Event,                          // Event
                    NULL,                           // ApcRoutine
                    NULL,                           // ApcContext
                    &iosb,                          // IoStatusBlock
                    IoControlCode,                  // IoControlCode
                    Buffer,                         // InputBuffer
                    sizeof(Buffer),                 // InputBufferSize
                    Buffer,                         // OutputBuffer
                    sizeof(Buffer));                // OutputBufferSize


    if (status == STATUS_PENDING)
    {
        status = NtWaitForSingleObject(
                    Event,                   // Handle
                    TRUE,                    // Alertable
                    NULL);                   // Timeout

        if (NT_SUCCESS(status))
        {
            status = iosb.Status;
        }
    }

    if (status != STATUS_SUCCESS)
    {
        ATCP_DBGPRINT(("atcpAtkSetup: NtDeviceIoControlFile failure (%lx)\n",
            status));
        dwRetCode = ARAPERR_IOCTL_FAILURE;
    }

    CloseHandle(Event);

    dwRetCode = pSndRcvInfo->StatusCode;

    if (dwRetCode != NO_ERROR)
    {
        ATCP_DBGPRINT(("atcpAtkSetup: ioctl %lx failed %ld\n",
            IoControlCode,dwRetCode));
        return(dwRetCode);
    }

    //
    // for SETUP ioctl, we have some info from stack we need to copy
    //
    if (IoControlCode == IOCTL_ATCP_SETUP_CONNECTION)
    {
        pAtcpInfo = (PATCPINFO)&pSndRcvInfo->Data[0];

        // get the client's address out
        EnterCriticalSection(&pAtcpConn->CritSect);

        pAtcpConn->AtalkContext = pSndRcvInfo->AtalkContext;
        pAtcpConn->ClientAddr = pSndRcvInfo->ClientAddr;

        LeaveCriticalSection(&pAtcpConn->CritSect);

        //
        // get the default router's address and the zone name
        //
        EnterCriticalSection( &AtcpCritSect );

        AtcpServerAddress = pAtcpInfo->ServerAddr;
        AtcpDefaultRouter = pAtcpInfo->DefaultRouterAddr;

        ATCP_ASSERT(pAtcpInfo->ServerZoneName[0] < ZONESTR_LEN);

        CopyMemory(&AtcpZoneName[1],
                   &pAtcpInfo->ServerZoneName[1],
                   pAtcpInfo->ServerZoneName[0]);

        AtcpZoneName[0] = pAtcpInfo->ServerZoneName[0];

        // got one more connection!
        AtcpNumConnections++;

        LeaveCriticalSection( &AtcpCritSect );
    }

    return(dwRetCode);
}



//***
//
// Function:    atcpAllocConnection
//              This routine allocates an ATCP connection block, initializes
//              it with info provided by PPP engine.
//
// Parameters:  pInfo - PPPCP_INIT info
//
// Return:      pointer to ATCP connection if successful, NULL otherwise
//
//***$

PATCPCONN
atcpAllocConnection(
    IN  PPPCP_INIT   *pPppInit
)
{
    PATCPCONN   pAtcpConn=NULL;


    pAtcpConn = (PATCPCONN)LocalAlloc(LPTR, sizeof(ATCPCONN));

    if (pAtcpConn == NULL)
    {
        ATCP_DBGPRINT(("atcpAllocConnection: malloc failed\n"));
        return(NULL);
    }

    memset( pAtcpConn, 0, sizeof(ATCPCONN) );

    pAtcpConn->Signature = ATCP_SIGNATURE;

    // by default, broadcasts are not suppressed
    pAtcpConn->SuppressRtmp = FALSE;
    pAtcpConn->SuppressAllBcast = FALSE;

    pAtcpConn->fLineUpDone = FALSE;

    InitializeCriticalSection( &pAtcpConn->CritSect );

    pAtcpConn->hPort       = pPppInit->hPort;
    pAtcpConn->hConnection = pPppInit->hConnection;

    return(pAtcpConn);
}



//***
//
// Function:    atcpParseRequest
//              This routine parses the incoming ATCP packet and prepares a
//              response as appropriate (Rej, Nak or Ack)
//
//              AppleTalk-Address
//                  1 6 0 AT-NET(2) AT-Node (1)
//              Routing-Protocol
//                  2 4 0 0 (Routing protocol - last 2 bytes - can be 0, 1, 2, 3:
//                           we only support 0)
//              Suppress-Broadcasts
//                  3 2     (to suppress all broadcasts)
//                  3 3 1   (to suppress RTMP bcasts.  We don't support other types)
//              AT-Compression-Protocol
//                  4 4 Undefined!
//              Server-information
//                  6 Len .....
//              Zone-Information
//                  7 Len ZoneName
//              Default-Router-Address
//                  8 6 0 AT-NET(2) AT-Node (1)
//
//
// Parameters:  pAtcpConn - the connection
//              pReceiveBuf - PPP_CONFIG info: the request
//              pSendBuf - PPP_CONFIG info: our response
//              cbSendBuf - how big is the Data buffer for our response (for Rej)
//              ParseResult - array where we mark off options we saw
//              pfRejectingSomething - pointer to TRUE if Rejecting something
//
// Return:      result of the operation
//
//***$

DWORD
atcpParseRequest(
    IN  PATCPCONN   pAtcpConn,
    IN  PPP_CONFIG *pReceiveBuf,
    OUT PPP_CONFIG *pSendBuf,
    IN  DWORD       cbSendBuf,
    OUT BYTE        ParseResult[ATCP_OPT_MAX_VAL+1],
    OUT BOOL       *pfRejectingSomething
)
{
    PPP_OPTION UNALIGNED    *pRequest;
    PPP_OPTION UNALIGNED    *pReject;
    DWORD                    BytesLeftInSendBuf;
    PBYTE                    pOptData;
    USHORT                   OptDataLen;
    USHORT                   PktLen;
    USHORT                   RequestLen;
    USHORT                   UnParsedBytes;
    NET_ADDR                 ClientAddr;
    DWORD                    i;


    *pfRejectingSomething = FALSE;

    pRequest  = (PPP_OPTION UNALIGNED* )pReceiveBuf->Data;
    pReject   = (PPP_OPTION UNALIGNED* )pSendBuf->Data;

    BytesLeftInSendBuf = cbSendBuf;

    PktLen = WireToHostFormat16( pReceiveBuf->Length );
    UnParsedBytes = PktLen - PPP_CONFIG_HDR_LEN;

    // initialize for now to "nothing requested"
    for (i=0; i<ATCP_OPT_MAX_VAL; i++)
    {
        ParseResult[i] = ATCP_NOT_REQUESTED;
    }

    //
    // we loop until we have parsed all the bytes
    //
    while (UnParsedBytes > 0)
    {
        RequestLen = (USHORT)pRequest->Length;

        if (UnParsedBytes < RequestLen)
        {
            ATCP_DBGPRINT(("atcpParseRequest: too few bytes %d vs. %d\n",
                UnParsedBytes,RequestLen));
            return(ERROR_PPP_INVALID_PACKET);
        }

        //
        // assume we're going to accept this option.  We'll overwrite if that's
        // not the case
        //
        ParseResult[pRequest->Type] = ATCP_ACK;

        // the point where the data portion for this option starts
        pOptData = &pRequest->Data[0];

        // remove the Type and Len bytes, remaining is option data
        OptDataLen = RequestLen - 2;

#if 0
        ATCP_DBGPRINT(("atcpParseRequest: type %d OptLen %d    (",
            pRequest->Type,OptDataLen));
        for (i=0; i<OptDataLen; i++)
        {
            DbgPrint(" 0x%x",pOptData[i]);
        }
        DbgPrint(" )\n");
#endif


        //
        // now look at each of the options and see if we should reject it,
        // modify it or accept it (Rej, Nak or Ack)
        //
        switch (pRequest->Type)
        {
            //
            // client wants an appletalk address.  We don't allow the client to
            // request which address he wants.
            //
            case ATCP_OPT_APPLETALK_ADDRESS:

                if (RequestLen != 6)
                {
                    ATCP_DBGPRINT(("atcpParseRequest: AT_ADDR wrong pktlen %d\n",
                        RequestLen));
                    return(ERROR_PPP_INVALID_PACKET);
                }

                ClientAddr.ata_Network =
                    WireToHostFormat16(&pOptData[1]);

                ClientAddr.ata_Node = (USHORT)pOptData[3];

                if ((ClientAddr.ata_Network == 0) ||
                    (ClientAddr.ata_Node == 0)    ||
                    (ClientAddr.ata_Network != pAtcpConn->ClientAddr.ata_Network) ||
                    (ClientAddr.ata_Node != pAtcpConn->ClientAddr.ata_Node))
                {
                    ParseResult[pRequest->Type] = ATCP_NAK;
                }

                break;


            //
            // client wants some routing protocol.  we don't send out Routing
            // info, so we should just Nak this option (unless the client also
            // is telling us not to send any routing info)
            //
            case ATCP_OPT_ROUTING_PROTOCOL:

                if (RequestLen < 4)
                {
                    ATCP_DBGPRINT(("atcpParseRequest: ROUTING wrong pktlen %d\n",
                        RequestLen));
                    return(ERROR_PPP_INVALID_PACKET);
                }

                //
                // we don't send out Routing info, so attempt to negotiate any
                // other protocol should be Nak'ed
                //
                if ((*(USHORT *)&pOptData[0]) != ATCP_OPT_ROUTING_NONE)
                {
                    ParseResult[pRequest->Type] = ATCP_NAK;
                }

                break;


            //
            // client wants to suppress broadcasts of some (or all) types of
            // DDP types.
            //
            case ATCP_OPT_SUPPRESS_BROADCAST:

                //
                // client wants us to suppress only some bcasts?
                //
                if (OptDataLen > 0)
                {
                    // if requesting RTMP data suppression, we'll allow it
                    if (pOptData[0] == DDPPROTO_RTMPRESPONSEORDATA)
                    {
                        pAtcpConn->SuppressRtmp = TRUE;
                    }

                    // hmm, some other protocol: sorry, no can do
                    else
                    {
                        ATCP_DBGPRINT(("atcpParseRequest: Naking suppression %d\n",
                            pOptData[0]));
                        ParseResult[pRequest->Type] = ATCP_NAK;
                    }
                }
                else
                {
                    pAtcpConn->SuppressAllBcast = TRUE;
                }

                break;

            //
            // client wants to negotiate some compression.  No compression
            // scheme is defined, so we just have to reject this option
            //
            case ATCP_OPT_AT_COMPRESSION_PROTOCOL:

                ATCP_DBGPRINT(("atcpParseRequest: COMPRESSION sending Rej\n"));

                if (BytesLeftInSendBuf >= RequestLen)
                {
                    CopyMemory((PVOID)pReject, (PVOID)pRequest, RequestLen);
                    BytesLeftInSendBuf -= RequestLen;
                }
                else
                {
                    ATCP_DBGPRINT(("atcpParseRequest: PPP engine's buffer too small\n",
                        RequestLen));
                    return(ERROR_BUFFER_TOO_SMALL);
                }

                pReject = (PPP_OPTION UNALIGNED *)((BYTE* )pReject + RequestLen);

                *pfRejectingSomething = TRUE;

                ParseResult[pRequest->Type] = ATCP_REJ;

                break;


            //
            // for the following options, we just take note of the fact that
            // the client has requested it and we send the info over.  Nothing
            // to negotiate in these options.
            // (We aren't supposed to Nak these either)
            //
            case ATCP_OPT_RESERVED:
            case ATCP_OPT_SERVER_INFORMATION:
            case ATCP_OPT_ZONE_INFORMATION:
            case ATCP_OPT_DEFAULT_ROUTER_ADDRESS:

                break;

            default:

                ATCP_DBGPRINT(("atcpParseRequest: unknown type %d\n",
                    pRequest->Type));
                return(ERROR_PPP_INVALID_PACKET);
        }

        //
        // move to the next option
        //
        UnParsedBytes -= RequestLen;

        pRequest = (PPP_OPTION UNALIGNED *)((BYTE* )pRequest + RequestLen);
    }

    //
    // see if we are rejecting some option.  If so, set some values
    //
    if (*pfRejectingSomething)
    {
        pSendBuf->Code = CONFIG_REJ;

        HostToWireFormat16( (USHORT)((PBYTE)pReject - (PBYTE)pSendBuf),
                            pSendBuf->Length );

        ATCP_DUMP_BYTES("atcpParseRequest: Rejecting these options:",
                        &pSendBuf->Data[0],
                        (DWORD)WireToHostFormat16( pSendBuf->Length)-4);
    }
    return(NO_ERROR);
}




//***
//
// Function:    atcpPrepareResponse
//              This routine prepares a response, depending on what all info
//              was parsed out from the client's request.
//
// Parameters:  pAtcpConn - the connection
//              pSendBuf - PPP_CONFIG info: our response
//              cbSendBuf - how big is the Data buffer for our response
//              ParseResult - array where we have the parsed info
//
// Return:      result of the operation
//
//***$

DWORD
atcpPrepareResponse(
    IN  PATCPCONN   pAtcpConn,
    OUT PPP_CONFIG *pSendBuf,
    IN  DWORD       cbSendBuf,
    OUT BYTE        ParseResult[ATCP_OPT_MAX_VAL+1]
)
{
    DWORD                   dwRetCode=NO_ERROR;
    DWORD                   BytesLeftInSendBuf;
    PPP_OPTION UNALIGNED   *pResponse;
    PBYTE                   pOptData;
    USHORT                  OptDataLen;
    USHORT                  OptionType;
    DWORD                   i;
    BOOL                    fNakingSomething=FALSE;
    BOOL                    fRequestingSomething=FALSE;
    BOOL                    fIncludeThisOption;


    pResponse = (PPP_OPTION UNALIGNED* )pSendBuf->Data;
    BytesLeftInSendBuf = cbSendBuf;

    // first find out if we are going to be Nak'ing anything
    for (OptionType=1; OptionType<ATCP_OPT_MAX_VAL; OptionType++ )
    {
        if (ParseResult[OptionType] == ATCP_NAK)
        {
            fNakingSomething = TRUE;
        }
    }

    //
    // go through our array to see which options we must send Nak to
    // (or construct Ack for the whole request)
    //
    for (OptionType=1; OptionType<ATCP_OPT_MAX_VAL; OptionType++ )
    {
        //
        // if this option is not (to be) requested, we don't send anything
        //
        if (ParseResult[OptionType] == ATCP_NOT_REQUESTED)
        {
            continue;
        }

        // if Nak'ing something and it's not this option to be Nak'ed, skip it
        if (fNakingSomething && (ParseResult[OptionType] != ATCP_NAK))
        {
            continue;
        }

        //
        // make sure we have at least 2 bytes for the OptionType and OptionLen
        //
        if (BytesLeftInSendBuf < 2)
        {
            ATCP_DBGPRINT(("atcpPrepareResponse: A: buf too small\n"));
            return(ERROR_BUFFER_TOO_SMALL);
        }

        BytesLeftInSendBuf -= 2;

        pOptData = &pResponse->Data[0];
        OptDataLen = 0;

        fIncludeThisOption = TRUE;

        switch (OptionType)
        {
            //
            // tell client (again) the client's network address
            //
            case ATCP_OPT_APPLETALK_ADDRESS:

                OptDataLen = sizeof(NET_ADDR);

                if (BytesLeftInSendBuf < OptDataLen)
                {
                    ATCP_DBGPRINT(("atcpPrepareResponse: B: buf too small\n"));
                    return(ERROR_BUFFER_TOO_SMALL);
                }

                // skip the reserved byte
                *pOptData++ = 0;

                //
                // if we are sending our REQUEST, send server's address
                //
                if (ParseResult[OptionType] == ATCP_REQ)
                {
                    // put in the network address
                    HostToWireFormat16(AtcpServerAddress.ata_Network, pOptData);
                    pOptData += sizeof(USHORT);

                    // put in the network node
                    ATCP_ASSERT(pAtcpConn->ClientAddr.ata_Node != 0);
                    *pOptData++ = (BYTE)AtcpServerAddress.ata_Node;

                    fRequestingSomething = TRUE;
                }

                //
                // no, we must send the client's network address
                //
                else
                {
                    // put in the network address
                    HostToWireFormat16(pAtcpConn->ClientAddr.ata_Network, pOptData);
                    pOptData += sizeof(USHORT);

                    // put in the network node
                    ATCP_ASSERT(pAtcpConn->ClientAddr.ata_Node != 0);
                    *pOptData++ = (BYTE)pAtcpConn->ClientAddr.ata_Node;
                }

                break;

            //
            // tell client (again) that we support no routing info
            //
            case ATCP_OPT_ROUTING_PROTOCOL:

                OptDataLen = sizeof(USHORT);

                HostToWireFormat16(ATCP_OPT_ROUTING_NONE, pOptData);
                pOptData += sizeof(USHORT);
                break;

            //
            // tell client that we can suppress RTMP or all Bcast
            //
            case ATCP_OPT_SUPPRESS_BROADCAST:

                // if this is an ack, see if we have agreed to suppressing RTMP
                if (!fNakingSomething)
                {
                    if (pAtcpConn->SuppressRtmp)
                    {
                        OptDataLen = 1;
                        *pOptData++ = DDPPROTO_RTMPRESPONSEORDATA;
                    }
                }

                break;

            //
            // we reach here only if are Acking the client's entire request
            //
            case ATCP_OPT_SERVER_INFORMATION:

                ATCP_ASSERT(ParseResult[OptionType] != ATCP_NAK);
                ATCP_ASSERT(!fNakingSomething);

                OptDataLen = sizeof(USHORT) + sizeof(DWORD) + AtcpServerName[0];

                if (BytesLeftInSendBuf < OptDataLen)
                {
                    ATCP_DBGPRINT(("atcpPrepareResponse: C: buf too small\n"));
                    return(ERROR_BUFFER_TOO_SMALL);
                }

                // copy the server's class-id
                HostToWireFormat16(ATCP_SERVER_CLASS, pOptData);
                pOptData += sizeof(USHORT);

                // copy the server's implementation-id
                HostToWireFormat32(ATCP_SERVER_IMPLEMENTATION_ID, pOptData);
                pOptData += sizeof(DWORD);

                // copy the server's name
                CopyMemory(pOptData, &AtcpServerName[1], AtcpServerName[0]);

                break;

            //
            // we reach here only if are Acking the client's entire request
            //
            case ATCP_OPT_ZONE_INFORMATION:

                ATCP_ASSERT(ParseResult[OptionType] != ATCP_NAK);
                ATCP_ASSERT(!fNakingSomething);

                // if we don't have a zone name, skip this option
                if (AtcpZoneName[0] == 0)
                {
                    fIncludeThisOption = FALSE;
                    break;
                }

                OptDataLen = AtcpZoneName[0];

                if (BytesLeftInSendBuf < OptDataLen)
                {
                    ATCP_DBGPRINT(("atcpPrepareResponse: D: buf too small\n"));
                    return(ERROR_BUFFER_TOO_SMALL);
                }

                // copy the zone name
                CopyMemory(pOptData, &AtcpZoneName[1], AtcpZoneName[0]);

                break;


            //
            // we reach here only if are Acking the client's entire request
            //
            case ATCP_OPT_DEFAULT_ROUTER_ADDRESS:

                ATCP_ASSERT(ParseResult[OptionType] != ATCP_NAK);
                ATCP_ASSERT(!fNakingSomething);

                // if we don't have a router address, skip this option
                if (AtcpDefaultRouter.ata_Network == 0)
                {
                    fIncludeThisOption = FALSE;
                    break;
                }

                OptDataLen = sizeof(NET_ADDR);

                if (BytesLeftInSendBuf < OptDataLen)
                {
                    ATCP_DBGPRINT(("atcpPrepareResponse: E: buf too small\n"));
                    return(ERROR_BUFFER_TOO_SMALL);
                }

                // skip the reserved byte
                *pOptData++ = 0;

                // put in the network address
                HostToWireFormat16(AtcpDefaultRouter.ata_Network, pOptData);
                pOptData += sizeof(USHORT);

                // put in the network node
                *pOptData++ = (BYTE)AtcpDefaultRouter.ata_Node;

                break;

            default:
                ATCP_DBGPRINT(("atcpPrepareResponse: opt %d ignored\n",OptionType));
                ATCP_ASSERT(0);
                break;
        }

        if (fIncludeThisOption)
        {
            BytesLeftInSendBuf -= OptDataLen;

            pResponse->Type = (BYTE)OptionType;
            pResponse->Length = OptDataLen + 2;   // 2 = 1 Type byte + 1 Length byte

            pResponse = (PPP_OPTION UNALIGNED *)
                            ((BYTE* )pResponse + pResponse->Length);
        }

    }

    HostToWireFormat16( (USHORT)((PBYTE)pResponse - (PBYTE)pSendBuf),
                        pSendBuf->Length );

    pSendBuf->Code = (fNakingSomething) ? CONFIG_NAK :
                     ((fRequestingSomething)? CONFIG_REQ : CONFIG_ACK);

#if 0
    if (pSendBuf->Code == CONFIG_REQ)
    {
        ATCP_DUMP_BYTES("atcpParseRequest: Sending our request:",
                        &pSendBuf->Data[0],
                        (DWORD)WireToHostFormat16( pSendBuf->Length)-4);
    }
    else if (pSendBuf->Code == CONFIG_NAK)
    {
        ATCP_DUMP_BYTES("atcpParseRequest: Nak'ing these options:",
                        &pSendBuf->Data[0],
                        (DWORD)WireToHostFormat16( pSendBuf->Length)-4);
    }
    else
    {
        ATCP_DUMP_BYTES("atcpParseRequest: Ack packet from us to client:",
                        &pSendBuf->Data[0],
                        (DWORD)WireToHostFormat16( pSendBuf->Length)-4);
    }
#endif

    return(NO_ERROR);
}



//***
//
// Function:    atcpCloseAtalkConnection
//              This routine tells the stack to close this ATCP connection
//
// Parameters:  pAtcpConn - the connection to close
//
// Return:      result of the operation
//
//***$

DWORD
atcpCloseAtalkConnection(
    IN  PATCPCONN   pAtcpConn
)
{
    DWORD       dwRetCode=NO_ERROR;

    // tell the stack that this connection is going away!
    dwRetCode = atcpAtkSetup(pAtcpConn, IOCTL_ATCP_CLOSE_CONNECTION);

    return(dwRetCode);
}



#if DBG

//***
//
// Function:    atcpDumpBytes
//              DEBUG only: This routine dumps out a given packet to debugger
//
// Parameters:  Str - string, if any, to be printed out
//              Packet - packet!
//              PacketLen - how big is the packet
//
// Return:      none
//
//***$

VOID
atcpDumpBytes(
    IN PBYTE    Str,
    IN PBYTE    Packet,
    IN DWORD    PacketLen
)
{

    DWORD   i;


    if (Str)
    {
        DbgPrint("%s: Packet size %ld\n  ",Str,PacketLen);
    }
    else
    {
        DbgPrint("Packet size %ld\n  ",PacketLen);
    }

    for (i=0; i<PacketLen; i++)
    {
        DbgPrint("%x ",Packet[i]);
    }
    DbgPrint("\n");
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasatcp\exports.c ===
/********************************************************************/
/**               Copyright(c) 1998 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    exports.c

//
// Description: Contains routines that are exported to the PPP engine.  The
//              engine calls into these routines for ATCP connections
//
// History:     Feb 26, 1998    Shirish Koti     Created original version.
//
//***

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <lmcons.h>
#include <string.h>
#include <stdlib.h>
#include <llinfo.h>
#include <rasman.h>
#include <rtutils.h>
#include <devioctl.h>
#include <rasppp.h>
#include <pppcp.h>
#define INCL_HOSTWIRE
#include <ppputil.h>
#include <raserror.h>

#include <arapio.h>
#include "rasatcp.h"


//***
//
// Function:    AtcpGetInfo
//              PPP engine calls this routine to get entry points into ATCP
//
// Parameters:  dwProtocolId - unused here!
//              pInfo - info that we fill out and pass back to PPP engine
//
// Return:      NO_ERROR
//
//***$

DWORD
AtcpGetInfo(
    IN  DWORD       dwProtocolId,
    OUT PPPCP_INFO *pInfo
)
{

    ZeroMemory( pInfo, sizeof(PPPCP_INFO) );

    pInfo->Protocol = (DWORD )PPP_ATCP_PROTOCOL;
    lstrcpy(pInfo->SzProtocolName, "Atcp");
    pInfo->Recognize = 7;
    pInfo->RasCpInit = AtcpInit;
    pInfo->RasCpBegin = AtcpBegin;
    pInfo->RasCpReset = AtcpReset;
    pInfo->RasCpEnd = AtcpEnd;
    pInfo->RasCpThisLayerUp = AtcpThisLayerUp;
    pInfo->RasCpMakeConfigRequest = AtcpMakeConfigRequest;
    pInfo->RasCpMakeConfigResult = AtcpMakeConfigResult;
    pInfo->RasCpConfigAckReceived = AtcpConfigAckReceived;
    pInfo->RasCpConfigNakReceived = AtcpConfigNakReceived;
    pInfo->RasCpConfigRejReceived = AtcpConfigRejReceived;
    pInfo->RasCpGetNegotiatedInfo = AtcpGetNegotiatedInfo;
    pInfo->RasCpProjectionNotification = AtcpProjectionNotification;

    return 0;
}


//***
//
// Function:    AtcpInit
//              PPP engine calls this routine to initialize ATCP
//
// Parameters:  fInitialize - TRUE to initialize, FALSE to de-initialize
//
// Return:      NO_ERROR if things go fine
//              Errorcode if something fails
//
//***$

DWORD
AtcpInit(
    IN  BOOL    fInitialize
)
{
    DWORD   dwRetCode=NO_ERROR;


    if (fInitialize)
    {
        // open handle to appletalk stack
        if (!AtcpHandle)
        {
            atcpOpenHandle();
        }

        dwRetCode = atcpStartup();
    }
    else
    {
        // if we had a handle open to appletalk stack, close it
        if (AtcpHandle)
        {
            atcpCloseHandle();
        }
    }

    return(dwRetCode);
}



//***
//
// Function:    AtcpBegin
//              PPP engine calls this routine to mark starting of a connection
//              setup.
//
// Parameters:  ppContext - context that we pass back
//              pInfo - PPPCP_INIT info
//
// Return:      result of the operation
//
//***$

DWORD
AtcpBegin(
    OUT PVOID  *ppContext,
    IN  PVOID   pInfo
)
{

    DWORD       dwRetCode;
    PATCPCONN   pAtcpConn=NULL;


    *ppContext = NULL;

    // open handle to stack if not already done so
    if (!AtcpHandle)
    {
        atcpOpenHandle();
    }

    if (AtcpHandle == NULL)
    {
        ATCP_DBGPRINT(("atcpAtkSetup: AtcpHandle is NULL!\n"));
        return(ARAPERR_IOCTL_FAILURE);
    }

    //
    // allocate, initialize our connection context
    //
    if ((pAtcpConn = atcpAllocConnection((PPPCP_INIT *)pInfo)) == NULL)
    {
        ATCP_DBGPRINT(("AtcpBegin: malloc failed\n"));
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // tell stack to allocate a context for this connection.  Also, reserve a
    // network addr for this client and get zone, router info
    //
    dwRetCode = atcpAtkSetup(pAtcpConn, IOCTL_ATCP_SETUP_CONNECTION);

    if (dwRetCode != NO_ERROR)
    {
        ATCP_DBGPRINT(("AtcpBegin: atcpAtkSetup failed %lx\n",dwRetCode));
        LocalFree(pAtcpConn);
        return(dwRetCode);
    }

    ATCP_DBGPRINT(("AtcpBegin: client's network addr %x.%x (%lx)\n",
        pAtcpConn->ClientAddr.ata_Network,pAtcpConn->ClientAddr.ata_Node,pAtcpConn));

    //
    // allocate Route so we can call RasActivateRoute later...
    //
    dwRetCode = RasAllocateRoute(
                    pAtcpConn->hPort,
                    APPLETALK,
                    TRUE,
                    &pAtcpConn->RouteInfo);

    if (dwRetCode != NO_ERROR)
    {
        ATCP_DBGPRINT(("AtcpBegin: RasAllocateRoute failed %lx\n",dwRetCode));

        // tell the stack to close the connection
        atcpCloseAtalkConnection(pAtcpConn);

        LocalFree(pAtcpConn);
        return(dwRetCode);
    }

    *ppContext = (PVOID)pAtcpConn;

    return 0;
}


//***
//
// Function:    AtcpThisLayerUp
//              PPP engine calls this routine to tell us ATCP setup is done
//
// Parameters:  pContext - our context
//
// Return:      result of the operation
//
//***$

DWORD
AtcpThisLayerUp(
    IN PVOID    pContext
)
{
    PATCPCONN   pAtcpConn;
    BYTE                    ConfigInfo[ARAP_BIND_SIZE];
    PROTOCOL_CONFIG_INFO   *pCfgInfo;
    PARAP_BIND_INFO         pBindInfo;
    DWORD                   dwRetCode;


    pAtcpConn = (PATCPCONN)pContext;

    ATCP_ASSERT(pAtcpConn->Signature == ATCP_SIGNATURE);

    EnterCriticalSection(&pAtcpConn->CritSect);
    if (pAtcpConn->fLineUpDone)
    {
        ATCP_DBGPRINT(("AtcpThisLayerUp: LineUp already done\n"));
        LeaveCriticalSection(&pAtcpConn->CritSect);
        return(NO_ERROR);
    }

    pAtcpConn->fLineUpDone = TRUE;

    LeaveCriticalSection(&pAtcpConn->CritSect);

    if (pAtcpConn->SuppressRtmp || pAtcpConn->SuppressAllBcast)
    {
        atcpAtkSetup(pAtcpConn, IOCTL_ATCP_SUPPRESS_BCAST);
    }

    pCfgInfo = (PROTOCOL_CONFIG_INFO *)ConfigInfo;
    pBindInfo = (PARAP_BIND_INFO)&pCfgInfo->P_Info[0];
    pCfgInfo->P_Length = ARAP_BIND_SIZE;

    //
    // plumb our protocol-specific info
    //
    pBindInfo->BufLen = sizeof( ARAP_BIND_INFO );
    pBindInfo->pDllContext = pAtcpConn;
    pBindInfo->fThisIsPPP = TRUE;
    pBindInfo->ClientAddr = pAtcpConn->ClientAddr;
    pBindInfo->AtalkContext = pAtcpConn->AtalkContext;
    pBindInfo->ErrorCode = (DWORD)-1;

    //
    // pass it down to ndiswan so our stack gets a line-up!
    //
    dwRetCode = RasActivateRoute(
                    pAtcpConn->hPort,
                    APPLETALK,
                    &pAtcpConn->RouteInfo,
                    pCfgInfo);

    if (dwRetCode != NO_ERROR)
    {
        ATCP_DBGPRINT(("AtcpProjectionNotification: RasActivateRoute failed %lx\n",
            dwRetCode));

        return(dwRetCode);
    }

    ATCP_DBGPRINT(("AtcpThisLayerUp: LineUp done on %lx\n",pAtcpConn));

    return 0;
}


//***
//
// Function:    AtcpMakeConfigRequest
//              PPP engine calls this routine to ask us to prepare an
//              ATCP ConfigRequest packet
//
// Parameters:  pContext - our context
//              pSendBuf - PPP_CONFIG info for this request
//              cbSendBuf - how big is the Data buffer
//
// Return:      result of the operation
//
//***$

DWORD
AtcpMakeConfigRequest(
    IN  PVOID       pContext,
    OUT PPP_CONFIG *pSendBuf,
    IN  DWORD       cbSendBuf
)
{
    PATCPCONN   pAtcpConn;
    DWORD       dwRetCode;
    USHORT      OptionType;
    BOOL        fConfigDone=FALSE;
    BYTE        ParseResult[ATCP_OPT_MAX_VAL];


    pAtcpConn = (PATCPCONN)pContext;

    ATCP_ASSERT(pAtcpConn->Signature == ATCP_SIGNATURE);

    EnterCriticalSection(&pAtcpConn->CritSect);
    if (pAtcpConn->Flags & ATCP_CONFIG_REQ_DONE)
    {
        fConfigDone = TRUE;
    }
    LeaveCriticalSection(&pAtcpConn->CritSect);

    if (fConfigDone)
    {
        pSendBuf->Code = CONFIG_REQ;
        HostToWireFormat16(4, pSendBuf->Length );
        ATCP_DBGPRINT(("AtcpMakeConfigRequest: our-side config done, returning\n"));
        return(NO_ERROR);
    }

    // initialize everything to not-needed
    for (OptionType=1; OptionType<ATCP_OPT_MAX_VAL; OptionType++ )
    {
        ParseResult[OptionType] = ATCP_NOT_REQUESTED;
    }

    // set the ones we want
    ParseResult[ATCP_OPT_APPLETALK_ADDRESS] = ATCP_REQ;
    ParseResult[ATCP_OPT_SERVER_INFORMATION] = ATCP_REQ;
    ParseResult[ATCP_OPT_ZONE_INFORMATION] = ATCP_REQ;
    ParseResult[ATCP_OPT_DEFAULT_ROUTER_ADDRESS] = ATCP_REQ;

    // prepare our ConfigRequest
    dwRetCode = atcpPrepareResponse(
                    pAtcpConn,
                    pSendBuf,
                    cbSendBuf,
                    ParseResult);

    if (dwRetCode != NO_ERROR)
    {
        ATCP_DBGPRINT(("AtcpMakeConfigRequest: atcpPrepareResponse failed %lx\n",
            dwRetCode));
        return(dwRetCode);
    }

    return(NO_ERROR);
}


//***
//
// Function:    AtcpMakeConfigResult
//              PPP engine calls this routine to ask us to prepare a response:
//              ConfigAck, ConfigNak or ConfigReject
//
// Parameters:  pContext - our context
//              pReceiveBuf - PPP_CONFIG info: the request
//              pSendBuf - PPP_CONFIG info: our response
//              cbSendBuf - how big is the Data buffer for our response
//              fRejectNaks - if TRUE, Reject an option instead of Nak'ing it
//
// Return:      result of the operation
//
//***$

DWORD
AtcpMakeConfigResult(
    IN  PVOID       pContext,
    IN  PPP_CONFIG *pReceiveBuf,
    OUT PPP_CONFIG *pSendBuf,
    IN  DWORD       cbSendBuf,
    IN  BOOL        fRejectNaks
)
{
    PATCPCONN   pAtcpConn;
    DWORD       dwRetCode;
    BYTE        ParseResult[ATCP_OPT_MAX_VAL+1];
    BOOL        fRejectingSomething=FALSE;


    pAtcpConn = (PATCPCONN)pContext;

    ATCP_ASSERT(pAtcpConn->Signature == ATCP_SIGNATURE);

    //
    // parse this request.
    //
    dwRetCode = atcpParseRequest(
                    pAtcpConn,
                    pReceiveBuf,
                    pSendBuf,
                    cbSendBuf,
                    ParseResult,
                   &fRejectingSomething);

    if (dwRetCode != NO_ERROR)
    {
        ATCP_DBGPRINT(("AtcpMakeConfigResult: atcpParseRequest failed %lx\n",
            dwRetCode));
        return(dwRetCode);
    }

    //
    // If some option needs to be rejected, the outgoing buffer already
    // contains the appropriate stuff: just return here
    //
    if (fRejectingSomething)
    {
        return(NO_ERROR);
    }

    //
    // we are not rejecting any option.  Prepare a response buffer to send
    //
    dwRetCode = atcpPrepareResponse(
                    pAtcpConn,
                    pSendBuf,
                    cbSendBuf,
                    ParseResult);

    if (dwRetCode != NO_ERROR)
    {
        ATCP_DBGPRINT(("AtcpMakeConfigResult: atcpPrepareResponse failed %lx\n",
            dwRetCode));
        return(dwRetCode);
    }

    return(NO_ERROR);

}


//***
//
// Function:    AtcpConfigAckReceived
//              PPP engine calls this routine to tell us that we got ConfigAck
//
// Parameters:  pContext - our context
//              pReceiveBuf - PPP_CONFIG info: the ack
//
// Return:      result of the operation
//
//***$

DWORD
AtcpConfigAckReceived(
    IN PVOID       pContext,
    IN PPP_CONFIG *pReceiveBuf
)
{
    PATCPCONN   pAtcpConn;

    pAtcpConn = (PATCPCONN)pContext;

    ATCP_ASSERT(pAtcpConn->Signature == ATCP_SIGNATURE);

    // client is happy with our-side configuration
    EnterCriticalSection(&pAtcpConn->CritSect);
    pAtcpConn->Flags |= ATCP_CONFIG_REQ_DONE;
    LeaveCriticalSection(&pAtcpConn->CritSect);

    return 0;
}


//***
//
// Function:    AtcpConfigNakReceived
//              PPP engine calls this routine to tell us that we got ConfigNak
//
// Parameters:  pContext - our context
//              pReceiveBuf - PPP_CONFIG info: the ack
//
// Return:      result of the operation
//
//***$

DWORD
AtcpConfigNakReceived(
    IN PVOID       pContext,
    IN PPP_CONFIG *pReceiveBuf
)
{
    PATCPCONN   pAtcpConn;

    ATCP_DBGPRINT(("AtcpConfigNakReceived entered\n"));

    pAtcpConn = (PATCPCONN)pContext;

    ATCP_ASSERT(pAtcpConn->Signature == ATCP_SIGNATURE);

    ATCP_DUMP_BYTES("AtcpConfigNakReceived: Nak received from client",
                    &pReceiveBuf->Data[0],
                    (DWORD)WireToHostFormat16( pReceiveBuf->Length ) - 4);
    return 0;
}


//***
//
// Function:    AtcpConfigRejReceived
//              PPP engine calls this routine to tell us that we got ConfigRej
//
// Parameters:  pContext - our context
//              pReceiveBuf - PPP_CONFIG info: the ack
//
// Return:      result of the operation
//
//***$

DWORD
AtcpConfigRejReceived(
    IN PVOID       pContext,
    IN PPP_CONFIG *pReceiveBuf
)
{
    PATCPCONN   pAtcpConn;

    ATCP_DBGPRINT(("AtcpConfigRejReceived entered\n"));

    pAtcpConn = (PATCPCONN)pContext;

    ATCP_ASSERT(pAtcpConn->Signature == ATCP_SIGNATURE);

    return 0;
}


//***
//
// Function:    AtcpGetNegotiatedInfo
//              PPP engine calls this routine to retrieve from us the info that
//              finally got negotiated.
//
// Parameters:  pContext - our context
//              pReceiveBuf - PPP_CONFIG info: the ack
//
// Return:      result of the operation
//
//***$

DWORD
AtcpGetNegotiatedInfo(
    IN  PVOID               pContext,
    OUT PPP_ATCP_RESULT    *pAtcpResult
)
{
    PATCPCONN   pAtcpConn;

    pAtcpConn = (PATCPCONN)pContext;

    ATCP_ASSERT(pAtcpConn->Signature == ATCP_SIGNATURE);

    pAtcpResult->dwError = 0;

    pAtcpResult->dwLocalAddress = *(DWORD *)&AtcpServerAddress;
    pAtcpResult->dwRemoteAddress = *(DWORD *)&pAtcpConn->ClientAddr;

    return 0;
}


//***
//
// Function:    AtcpProjectionNotification
//              PPP engine calls this routine to tell us that all CPs have been
//              negotiated.
//
// Parameters:  pContext - our context
//              pProjectionResult - PPP_PROJECTION_RESULT info
//
// Return:      result of the operation
//
//***$

DWORD
AtcpProjectionNotification(
    IN PVOID  pContext,
    IN PVOID  pProjectionResult
)
{
    PATCPCONN               pAtcpConn;


    ATCP_DBGPRINT(("AtcpProjectionNotification entered\n"));

    pAtcpConn = (PATCPCONN)pContext;

    ATCP_ASSERT(pAtcpConn->Signature == ATCP_SIGNATURE);

    return 0;
}


//***
//
// Function:    AtcpReset
//              Don't know when/why PPP engine calls this routine: this routine
//              just returns success!
//
// Parameters:  pContext - our context
//
// Return:      always 0
//
//***$

DWORD
AtcpReset(
    IN PVOID    pContext
)
{
    PATCPCONN   pAtcpConn;

    ATCP_DBGPRINT(("AtcpReset entered\n"));

    pAtcpConn = (PATCPCONN)pContext;

    ATCP_ASSERT(pAtcpConn->Signature == ATCP_SIGNATURE);

    return 0;
}




//***
//
// Function:    AtcpEnd
//              PPP engine calls this routine to mark end of a connection.
//
// Parameters:  pContext - our context
//
// Return:      result of the operation
//
//***$

DWORD
AtcpEnd(
    IN PVOID    pContext
)
{
    PATCPCONN   pAtcpConn;

    ATCP_DBGPRINT(("AtcpEnd entered\n"));

    pAtcpConn = (PATCPCONN)pContext;

    ATCP_ASSERT(pAtcpConn->Signature == ATCP_SIGNATURE);

    // tell the stack to close the connection
    atcpCloseAtalkConnection(pAtcpConn);

    // deactivate the ras route so stack gets a line-down
    RasDeAllocateRoute(pAtcpConn->hConnection, APPLETALK);

#if DBG
    // mess up the memory so we can catch bad things (using free'd memory etc.)
    memset( pAtcpConn, 'f', sizeof(ATCPCONN) );
    pAtcpConn->Signature = 0xDEADBEEF;
#endif

    LocalFree(pAtcpConn);

    EnterCriticalSection( &AtcpCritSect );
    AtcpNumConnections--;
    LeaveCriticalSection( &AtcpCritSect );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasbacp\rasbacp.h ===
/*

Copyright (c) 1997, Microsoft Corporation, all rights reserved

File:
    rasbacp.h

Description:
    Remote Access PPP Bandwidth Allocation Control Protocol

History:
    Mar 24, 1997: Vijay Baliga created original version.

*/

#ifndef _RASBACP_H_
#define _RASBACP_H_

// BACP option types 

#define BACP_OPTION_FAVORED_PEER    0x01

// BACP control block 

typedef struct _BACPCB
{
    DWORD   dwLocalMagicNumber;
    DWORD   dwRemoteMagicNumber;
    
} BACPCB, *PBACPCB;

#endif // #ifndef _RASBACP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasbacp\rasbacp.c ===
/*

Copyright (c) 1997, Microsoft Corporation, all rights reserved

Description:
    Remote Access PPP Bandwidth Allocation Control Protocol core routines

History:
    Mar 24, 1997: Vijay Baliga created original version.

*/

#include <nt.h>         // Required by windows.h
#include <ntrtl.h>      // Required by windows.h
#include <nturtl.h>     // Required by windows.h
#include <windows.h>    // Win32 base API's

#include <rasman.h>     // Required by pppcp.h
#include <pppcp.h>      // For PPP_CONFIG, PPP_BACP_PROTOCOL, etc

#define INCL_HOSTWIRE
#include <ppputil.h>    // For HostToWireFormat16(), etc

#include <stdlib.h>     // For rand(), etc
#include <rtutils.h>    // For TraceRegister(), etc
#include <raserror.h>   // For ERROR_PPP_INVALID_PACKET, etc
#include <rasbacp.h>

DWORD DwBacpTraceId;

/*

Returns:
    VOID

Description:
    Used for tracing.
    
*/

VOID   
TraceBacp(
    CHAR * Format, 
    ... 
) 
{
    va_list arglist;

    va_start(arglist, Format);

    TraceVprintfEx(DwBacpTraceId, 
                   0x00010000 | TRACE_USE_MASK | TRACE_USE_MSEC,
                   Format,
                   arglist);

    va_end(arglist);
}

/*

Returns:
    A random number

Description:
    Returns a 4 octet random number that can be used as a magic number.

*/

DWORD
CreateMagicNumber(
    VOID
)
{
    srand(GetCurrentTime());
    return(rand());
}

/*

Returns:
    NO_ERROR: Success
    non-zero error: Failure

Description:
    Called to initialize/uninitialize this CP. In the former case, fInitialize 
    will be TRUE; in the latter case, it will be FALSE.

*/

DWORD
BacpInit(
    IN  BOOL    fInitialize
)
{
    static  BOOL    fInitialized    = FALSE;

    if (fInitialize && !fInitialized)
    {
        fInitialized = TRUE;
        DwBacpTraceId = TraceRegister("RASBACP");
        TraceBacp("RasBacpDllMain: DLL_PROCESS_ATTACH");
    }
    else if (!fInitialize && fInitialized)
    {
        fInitialized = FALSE;
        TraceBacp("RasBacpDllMain: DLL_PROCESS_DETACH");
        TraceDeregister(DwBacpTraceId);
    }

    return(NO_ERROR);
}

/*

Returns:
    NO_ERROR: Success
    non-zero error: Failure

Description:
    This entry point is called once before any other call to BACP is made. 
    Allocate a work buffer and initialize it.

*/

DWORD
BacpBegin(
    IN OUT VOID** ppWorkBuf, 
    IN     VOID*  pInfo
)
{
    DWORD       dwError;

    TraceBacp("BacpBegin");
    
    *ppWorkBuf = LocalAlloc(LPTR, sizeof(BACPCB));

    if (*ppWorkBuf == NULL)
    {
        dwError = GetLastError();
        TraceBacp("BacpBegin: ppWorkBuf is NULL. Error: %d", dwError);
        return(dwError);
    }

    return(NO_ERROR);
}

/*

Returns:
    NO_ERROR: Success

Description:
    This entry point frees the BACP work buffer.
*/

DWORD
BacpEnd(
    IN VOID * pWorkBuf
)
{
    TraceBacp("BacpEnd");

    if (pWorkBuf != NULL)
    {
        LocalFree(pWorkBuf);
    }

    return( NO_ERROR );
}

/*

Returns:
    NO_ERROR: Success

Description:
    This entry point is called to reset the state of BACP. Will re-initialize 
    the work buffer.

*/

DWORD
BacpReset(
    IN VOID * pWorkBuf
)
{
    BACPCB * pBacpCb = (BACPCB *)pWorkBuf;

    TraceBacp("BacpReset");
    
    pBacpCb->dwLocalMagicNumber = CreateMagicNumber();
    pBacpCb->dwRemoteMagicNumber = 0;

    TraceBacp("BacpReset: Local Magic-Number: %d", pBacpCb->dwLocalMagicNumber);

    return(NO_ERROR);
}

/*

Returns:
    NO_ERROR: Success

Description:
    This entry point is called when BACP is entering Open state.

*/

DWORD
BacpThisLayerUp(
    IN VOID* pWorkBuf
)
{
    BACPCB *    pBacpCb = (BACPCB *)pWorkBuf;

    TraceBacp("BacpThisLayerUp: Local Magic-Number: %d, "
        "Remote Magic-Number: %d",
        pBacpCb->dwLocalMagicNumber,
        pBacpCb->dwRemoteMagicNumber);

    return(NO_ERROR);
}

/*

Returns:
    NO_ERROR: Success
    ERROR_BUFFER_TOO_SMALL: pSendConfig is too small

Description:
    This entry point is called to make a confifure request packet.
    
*/

DWORD
BacpMakeConfigRequest(
    IN VOID *       pWorkBuffer,
    IN PPP_CONFIG * pSendConfig,
    IN DWORD        cbSendConfig
)
{
    BACPCB *        pBacpCb    = (BACPCB*)pWorkBuffer;
    PPP_OPTION *    pPppOption = (PPP_OPTION *)pSendConfig->Data;

    TraceBacp("BacpMakeConfigRequest");
    
    if (cbSendConfig < PPP_CONFIG_HDR_LEN + PPP_OPTION_HDR_LEN + 4)
    {
        TraceBacp("BacpMakeConfigRequest: Buffer is too small. Size: %d", 
            cbSendConfig);
            
        return(ERROR_BUFFER_TOO_SMALL);
    }

    pSendConfig->Code = CONFIG_REQ;
    HostToWireFormat16((WORD)(PPP_CONFIG_HDR_LEN + PPP_OPTION_HDR_LEN + 4), 
        pSendConfig->Length);

    pPppOption->Type   = BACP_OPTION_FAVORED_PEER;
    pPppOption->Length = PPP_OPTION_HDR_LEN + 4;
    HostToWireFormat32(pBacpCb->dwLocalMagicNumber, pPppOption->Data);

    return(NO_ERROR);
}

/*

Returns:
    NO_ERROR: Success
    ERROR_PPP_INVALID_PACKET: Length of option is wrong

Description:
    This entry point is called when a configure request packet is received.
    
*/

DWORD
BacpMakeConfigResult(
    IN  VOID *        pWorkBuffer,
    IN  PPP_CONFIG *  pRecvConfig,
    OUT PPP_CONFIG *  pSendConfig,
    IN  DWORD         cbSendConfig,
    IN  BOOL          fRejectNaks 
)
{
    BACPCB *        pBacpCb         = (BACPCB*)pWorkBuffer;
    PPP_OPTION *    pSendOption     = (PPP_OPTION *)(pSendConfig->Data);
    PPP_OPTION *    pRecvOption     = (PPP_OPTION *)(pRecvConfig->Data);
    LONG            lSendLength     = cbSendConfig - PPP_CONFIG_HDR_LEN;
    LONG            lRecvLength     = WireToHostFormat16(pRecvConfig->Length)
                                        - PPP_CONFIG_HDR_LEN;
    DWORD           dwResultType    = CONFIG_ACK;
    DWORD           dwResult;

    TraceBacp("BacpMakeConfigResult");
    
    while(lRecvLength > 0) 
    {
        if (pRecvOption->Length == 0)
        {
            TraceBacp("BacpMakeConfigResult: Invalid option. Length is 0");
            
            return(ERROR_PPP_INVALID_PACKET);
        }

        if ((lRecvLength -= pRecvOption->Length) < 0)
        {
            TraceBacp("BacpMakeConfigResult: Invalid option. Length: %d", 
                pRecvOption->Length);
            
            return(ERROR_PPP_INVALID_PACKET);
        }

        // We only know BACP_OPTION_FAVORED_PEER
        
        if ((pRecvOption->Length != PPP_OPTION_HDR_LEN + 4) ||
            (pRecvOption->Type != BACP_OPTION_FAVORED_PEER))
        {
            TraceBacp("BacpMakeConfigResult: Unknown option. "
                "Type: %d, Length: %d",
                pRecvOption->Type, pRecvOption->Length);
                
            dwResult = CONFIG_REJ;
        }
        else
        {
            pBacpCb->dwRemoteMagicNumber =
                WireToHostFormat32(pRecvOption->Data);

            // A Magic-Number of zero is illegal and MUST always be Nak'd.
            
            if ((pBacpCb->dwRemoteMagicNumber == 0) ||
                (pBacpCb->dwRemoteMagicNumber == pBacpCb->dwLocalMagicNumber))
            {
                TraceBacp("BacpMakeConfigResult: Unacceptable Magic-Number: %d", 
                    pBacpCb->dwRemoteMagicNumber);
                    
                pBacpCb->dwRemoteMagicNumber = CreateMagicNumber();

                TraceBacp("BacpMakeConfigResult: Suggesting new "
                    "Magic-Number: %d",
                    pBacpCb->dwRemoteMagicNumber);
                    
                dwResult = CONFIG_NAK;
            }
            else
            {
                dwResult = CONFIG_ACK;
            }
        }

        /*
        
        If we were building an ACK and we got a NAK or reject OR we were 
        building a NAK and we got a reject.
        
        */

        if ( ((dwResultType == CONFIG_ACK) && (dwResult != CONFIG_ACK)) ||
             ((dwResultType == CONFIG_NAK) && (dwResult == CONFIG_REJ)))
        {
            dwResultType  = dwResult;
            pSendOption = (PPP_OPTION *)(pSendConfig->Data);
            lSendLength = cbSendConfig - PPP_CONFIG_HDR_LEN;
        }


        // Add the option to the list.

        if (dwResult == dwResultType)
        {
            /*
            
            If this option is to be rejected, simply copy the rejected option 
            to the send buffer.

            */

            if ((dwResult == CONFIG_REJ) ||
                ((dwResult == CONFIG_NAK) && (fRejectNaks)))
            {
                CopyMemory(pSendOption, pRecvOption, pRecvOption->Length);
            }
            else
            {
                pSendOption->Type   = BACP_OPTION_FAVORED_PEER;
                pSendOption->Length = PPP_OPTION_HDR_LEN + 4;
                HostToWireFormat32(pBacpCb->dwRemoteMagicNumber,
                    pSendOption->Data);
            }

            lSendLength -= pSendOption->Length;

            pSendOption  = (PPP_OPTION *)
               ((BYTE *)pSendOption + pSendOption->Length);
        }

        pRecvOption = (PPP_OPTION *)((BYTE*)pRecvOption + pRecvOption->Length);
    }

    /*

    If this was an NAK and we have cannot send any more NAKS then we make this 
    a REJECT packet.
    
    */

    if ((dwResultType == CONFIG_NAK) && fRejectNaks)
        pSendConfig->Code = CONFIG_REJ;
    else
        pSendConfig->Code = (BYTE)dwResultType;

    TraceBacp("BacpMakeConfigResult: Sending %s",
        pSendConfig->Code == CONFIG_ACK ? "ACK" :
        (pSendConfig->Code == CONFIG_NAK ? "NAK" : "REJ"));
        
    HostToWireFormat16((WORD)(cbSendConfig - lSendLength), pSendConfig->Length);

    return(NO_ERROR);
}

/*

Returns:
    NO_ERROR: Success
    ERROR_PPP_INVALID_PACKET: This is not the packet we sent

Description:
    This entry point is called when a configure ack or configure rej packet is 
    received.

*/

DWORD
BacpConfigAckOrRejReceived(
    IN VOID *       pWorkBuffer,
    IN PPP_CONFIG * pRecvConfig
)
{
    BACPCB *        pBacpCb         = (BACPCB *)pWorkBuffer;
    PPP_OPTION *    pRecvOption     = (PPP_OPTION *)(pRecvConfig->Data);
    DWORD           dwLength        = WireToHostFormat16(pRecvConfig->Length);
    DWORD           dwMagicNumber   = WireToHostFormat32(pRecvOption->Data);

    TraceBacp("BacpConfigAckOrRejReceived");
  
    if ((dwLength != PPP_CONFIG_HDR_LEN + PPP_OPTION_HDR_LEN + 4) ||
        (pRecvOption->Type != BACP_OPTION_FAVORED_PEER) ||
        (pRecvOption->Length != PPP_OPTION_HDR_LEN + 4) ||
        (dwMagicNumber != pBacpCb->dwLocalMagicNumber))
    {
        TraceBacp("BacpConfigAckOrRejReceived: Invalid packet received");
        
        return(ERROR_PPP_INVALID_PACKET);
    }
    else
        return(NO_ERROR);
}

/*

Returns:
    NO_ERROR: Success
    ERROR_PPP_INVALID_PACKET: Length of option is wrong

Description:
    This entry point is called when a configure nak packet is received.
    
*/

DWORD
BacpConfigNakReceived(
    IN VOID *       pWorkBuffer,
    IN PPP_CONFIG * pRecvConfig
)
{
    BACPCB *        pBacpCb     = (BACPCB *)pWorkBuffer;
    PPP_OPTION *    pOption     = (PPP_OPTION*)(pRecvConfig->Data);
    LONG            lRecvLength = WireToHostFormat16(pRecvConfig->Length)
                                    - PPP_CONFIG_HDR_LEN;
    TraceBacp("BacpConfigNakReceived");
    
    while (lRecvLength > 0)
    {
        if (pOption->Length == 0)
        {
            TraceBacp("BacpConfigNakReceived: Invalid option. Length is 0");
            
            return(ERROR_PPP_INVALID_PACKET);
        }

        if ((lRecvLength -= pOption->Length) < 0)
        {
            TraceBacp("BacpConfigNakReceived: Invalid option. Length: %d", 
                pOption->Length);
            
            return(ERROR_PPP_INVALID_PACKET);
        }

        if ((pOption->Type == BACP_OPTION_FAVORED_PEER) &&
            (pOption->Length == PPP_OPTION_HDR_LEN + 4))
        {
            pBacpCb->dwLocalMagicNumber = WireToHostFormat32(pOption->Data);

            TraceBacp("BacpConfigNakReceived: New Local Magic-Number: %d",
                pBacpCb->dwLocalMagicNumber);
        }

        pOption = (PPP_OPTION *)((BYTE *)pOption + pOption->Length);
    }

    return(NO_ERROR);
}

/*

Returns:
    NO_ERROR: Success
    ERROR_INVALID_PARAMETER: Protocol id is unrecogized

Description:
    This entry point is called to get all information for the control protocol
    in this module.

*/

DWORD
BacpGetInfo(
    IN  DWORD       dwProtocolId,
    OUT PPPCP_INFO* pCpInfo
)
{
    if (dwProtocolId != PPP_BACP_PROTOCOL)
        return(ERROR_INVALID_PARAMETER);

    ZeroMemory(pCpInfo, sizeof(PPPCP_INFO));

    pCpInfo->Protocol               = PPP_BACP_PROTOCOL;
    lstrcpy(pCpInfo->SzProtocolName, "BACP");
    pCpInfo->Recognize              = PROT_REJ;
    pCpInfo->RasCpInit              = BacpInit;
    pCpInfo->RasCpBegin             = BacpBegin;
    pCpInfo->RasCpEnd               = BacpEnd;
    pCpInfo->RasCpReset             = BacpReset;
    pCpInfo->RasCpThisLayerUp       = BacpThisLayerUp;
    pCpInfo->RasCpMakeConfigRequest = BacpMakeConfigRequest;
    pCpInfo->RasCpMakeConfigResult  = BacpMakeConfigResult;
    pCpInfo->RasCpConfigAckReceived = BacpConfigAckOrRejReceived;
    pCpInfo->RasCpConfigNakReceived = BacpConfigNakReceived;
    pCpInfo->RasCpConfigRejReceived = BacpConfigAckOrRejReceived;

    return(NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rascbcp\rascbcp.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    rascbcp.c
//
// Description: This module contains code to implement the PPP Callback
//              Control Protocol.
//
// History:     April 11,1994.      NarenG      Created original version
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <crypt.h>

#include <windows.h>
#include <lmcons.h>
#include <string.h>
#include <stdlib.h>
#include <rasman.h>
#include <pppcp.h>
#define INCL_PWUTIL
#define INCL_HOSTWIRE
#include <ppputil.h>
#include "rascbcp.h"
#include <raserror.h>

//**
//
// Call:        CbCPGetInfo
//
// Returns:     NO_ERROR
//
// Description: CbCPGetInfo entry point called by the PPP engine.
//              See RasCpGetInfo interface documentation.
//
DWORD
CbCPGetInfo(
    IN  DWORD       dwProtocolId,
    OUT PPPCP_INFO* pInfo
)
{
    ZeroMemory( pInfo, sizeof(PPPCP_INFO) );

    pInfo->Protocol         = (DWORD)PPP_CBCP_PROTOCOL;
    lstrcpy(pInfo->SzProtocolName, "CBCP");
    pInfo->Recognize        = MAX_CBCP_CODE + 1;
    pInfo->RasCpBegin       = CbCPBegin;
    pInfo->RasCpEnd         = CbCPEnd;
    pInfo->RasApMakeMessage = CbCPMakeMessage;

    return( NO_ERROR );
}

//**
//
// Call:        CbCPBegin
//
// Returns:     NO_ERROR             - success
//              non-zero return code - failure
//
// Description: RasCpBegin entry point called by the PPP engine thru the
//              passed address. See RasCp interface documentation. This is
//              called by the PPP engine before any other calls to CbCP is
//              made.
//
DWORD
CbCPBegin(
    OUT VOID** ppWorkBuf,
    IN  VOID*  pInfo
)
{
    PPPCB_INPUT *     pInput = (PPPCB_INPUT *)pInfo;
    CBCP_WORKBUFFER * pWorkBuf;
    DWORD             dwRetCode;

    //
    // Allocate work buffer.
    //

    pWorkBuf = (CBCP_WORKBUFFER *)LocalAlloc(LPTR,sizeof(CBCP_WORKBUFFER));

    if ( pWorkBuf == NULL )
    {
        return( GetLastError() );
    }

    pWorkBuf->State   = CBCP_STATE_INITIAL;

    pWorkBuf->fServer = pInput->fServer;

    //
    // If we are the server side then get all the callback information for
    // this user
    //

    if ( pWorkBuf->fServer )
    {
        pWorkBuf->fCallbackPrivilege = pInput->bfCallbackPrivilege;

        strcpy( pWorkBuf->szCallbackNumber, pInput->pszCallbackNumber );
    }
    else
    {
        pWorkBuf->CallbackDelay = pInput->CallbackDelay;
    }

    //
    // Register work buffer with engine.
    //

    *ppWorkBuf = pWorkBuf;

    return( NO_ERROR );
}

//**
//
// Call:        CbCPEnd
//
// Returns:     NO_ERROR        - success
//
// Description: Called by the PPP engine to notify this Control Protocol to
//              clean up.
//
DWORD
CbCPEnd(
    IN VOID* pWorkBuffer
)
{
    CBCP_WORKBUFFER * pWorkBuf = (CBCP_WORKBUFFER *)pWorkBuffer;

    if ( pWorkBuf->pRequest != (PPP_CONFIG *)NULL )
    {
        LocalFree( pWorkBuf->pRequest );
    }

    if ( pWorkBuf->pResponse != (PPP_CONFIG *)NULL )
    {
        LocalFree( pWorkBuf->pResponse );
    }

    if ( pWorkBuf != NULL )
    {
        LocalFree( pWorkBuf );
    }

    return( NO_ERROR );
}

//**
//
// Call:        CbCPMakeMessage
//
// Returns:     NO_ERROR                - success
//              non-zero return code    - failure
//
// Description: Called by the PPP engine to process a CbCP event. ie to send
//              a packet, to process a received packet or to process a timeout
//              event.
//
DWORD
CbCPMakeMessage(
    IN  VOID*         pWorkBuffer,
    IN  PPP_CONFIG*   pReceiveBuf,
    OUT PPP_CONFIG*   pSendBuf,
    IN  DWORD         cbSendBuf,
    OUT PPPAP_RESULT* pResult,
    IN  PPPAP_INPUT*  pInput
)
{
    CBCP_WORKBUFFER* pWorkBuf = (CBCP_WORKBUFFER *)pWorkBuffer;

    return( (pWorkBuf->fServer)

            ? CbCPSMakeMessage( pWorkBuf,
                                pReceiveBuf,
                                pSendBuf,
                                cbSendBuf,
                                (PPPCB_RESULT *)pResult,
                                (PPPCB_INPUT *)pInput )

            : CbCPCMakeMessage( pWorkBuf,
                                pReceiveBuf,
                                pSendBuf,
                                cbSendBuf,
                                (PPPCB_RESULT *)pResult,
                                (PPPCB_INPUT *)pInput ) );
}

//**
//
// Call:        CbCPCMakeMessage
//
// Returns:     NO_ERROR            - success
//              non-zero return     - failure
//
// Description: Called to process the client side of Callback Control
//              Protocol.
//
DWORD
CbCPCMakeMessage(
    IN  CBCP_WORKBUFFER * pWorkBuf,
    IN  PPP_CONFIG*       pReceiveBuf,
    OUT PPP_CONFIG*       pSendBuf,
    IN  DWORD             cbSendBuf,
    OUT PPPCB_RESULT*     pResult,
    IN  PPPCB_INPUT*      pInput
)
{
    DWORD dwRetCode;
    DWORD dwLength;

    switch( pWorkBuf->State )
    {

    case CBCP_STATE_INITIAL:

        //
        // Do nothing, wait for request
        //

        pWorkBuf->State                     = CBCP_STATE_WAIT_FOR_REQUEST;
        pResult->Action                     = APA_NoAction;
        pResult->fGetCallbackNumberFromUser = FALSE;

        break;

    case CBCP_STATE_WAIT_FOR_REQUEST:

        //
        // We have received a callback request from the server.
        // Save the callback request.
        //

        dwLength = WireToHostFormat16( pReceiveBuf->Length );

        if ( ( dwLength < PPP_CONFIG_HDR_LEN ) ||
             ( pReceiveBuf->Code != CBCP_CODE_Request ) )
        {
            return( ERROR_PPP_INVALID_PACKET );
        }

        pWorkBuf->pRequest = (PPP_CONFIG *)LocalAlloc( LPTR, dwLength );

        if ( pWorkBuf->pRequest == (PPP_CONFIG *)NULL )
        {
            return( GetLastError() );
        }

        memcpy( pWorkBuf->pRequest, pReceiveBuf, dwLength );

        //
        // Find out what kind of callback privileges we have.
        //

        dwRetCode = GetCallbackPrivilegeFromRequest(
                                        pWorkBuf->pRequest,
                                        &(pWorkBuf->fCallbackPrivilege));
        if ( dwRetCode != NO_ERROR )
        {
            return( dwRetCode );
        }

        //
        // If we have user specifiable callback, then we need to get this
        // information from the user.
        //

        if ( pWorkBuf->fCallbackPrivilege == RASPRIV_CallerSetCallback )
        {
            pResult->fGetCallbackNumberFromUser=TRUE;
            pResult->Action                    =APA_NoAction;
            pWorkBuf->State                    =CBCP_STATE_GET_CALLBACK_NUMBER;
            break;
        }

        //
        // Otherwise we make a reponse with preset or no callback
        //

        dwRetCode = MakeResponse( pWorkBuf->fCallbackPrivilege,
                                  (LPSTR)NULL,
                                  pWorkBuf->CallbackDelay,
                                  pWorkBuf->pRequest,
                                  pSendBuf,
                                  cbSendBuf );

        if ( dwRetCode != NO_ERROR )
        {
            return( dwRetCode );
        }

        //
        // Save the response sent
        //

        dwLength = WireToHostFormat16( pSendBuf->Length );

        pWorkBuf->pResponse = (PPP_CONFIG *)LocalAlloc( LPTR, dwLength );

        if ( pWorkBuf->pResponse == (PPP_CONFIG *)NULL )
        {
            return( GetLastError() );
        }

        memcpy( pWorkBuf->pResponse, pSendBuf, dwLength );

        pResult->Action         = APA_SendWithTimeout;
        pResult->bIdExpected    = pReceiveBuf->Id;
        pWorkBuf->State         = CBCP_STATE_WAIT_FOR_ACK;

        break;

    case CBCP_STATE_GET_CALLBACK_NUMBER:

        //
        // If we have not received any packet when we are called that means
        // that we have got the callback number from the user.
        //

        if ( pReceiveBuf == (PPP_CONFIG *)NULL )
        {
            //
            // If no callback number was supplied then we do not want to
            // do callback
            //

            if ( *(pInput->pszCallbackNumber) == (CHAR)NULL )
            {
                pWorkBuf->fCallbackPrivilege = RASPRIV_NoCallback;
            }

            dwRetCode = MakeResponse( pWorkBuf->fCallbackPrivilege,
                                      pInput->pszCallbackNumber,
                                      pWorkBuf->CallbackDelay,
                                      pWorkBuf->pRequest,
                                      pSendBuf,
                                      cbSendBuf );

            if ( dwRetCode != NO_ERROR )
            {
                return( dwRetCode );
            }

            //
            // Save the response sent
            //

            dwLength = WireToHostFormat16( pSendBuf->Length );

            pWorkBuf->pResponse = (PPP_CONFIG*)LocalAlloc( LPTR, dwLength );

            if ( pWorkBuf->pResponse == NULL )
            {
                return( GetLastError() );
            }

            memcpy( pWorkBuf->pResponse, pSendBuf, dwLength );

            pResult->Action         = APA_SendWithTimeout;
            pResult->bIdExpected    = pWorkBuf->pResponse->Id;
            pWorkBuf->State         = CBCP_STATE_WAIT_FOR_ACK;

            break;
        }
        else
        {

            if ( pReceiveBuf->Code == CBCP_CODE_Request )
            {
                //
                // If we received another callback request, just save the id.
                // If the current request is different than the previous one
                //

                dwLength = WireToHostFormat16( pWorkBuf->pRequest->Length );

                if (( WireToHostFormat16( pReceiveBuf->Length ) != dwLength ) ||
                    ( memcmp( ((PBYTE)(pWorkBuf->pRequest))+PPP_CONFIG_HDR_LEN,
                               ((PBYTE)pReceiveBuf) + PPP_CONFIG_HDR_LEN,
                               dwLength - PPP_CONFIG_HDR_LEN ) ) )
                {
                    return( ERROR_PPP_INVALID_PACKET );
                }

                pWorkBuf->pRequest->Id = pReceiveBuf->Id;
            }
            else
            {
                return( ERROR_PPP_INVALID_PACKET );
            }
        }

        pResult->Action                     = APA_NoAction;
        pResult->fGetCallbackNumberFromUser = FALSE;

        break;

    case CBCP_STATE_WAIT_FOR_ACK:

        //
        // If the receive buffer is NULL, then we have a timeout event,
        // resend the response
        //

        if ( pReceiveBuf == (PPP_CONFIG *)NULL )
        {
            dwLength = WireToHostFormat16( pWorkBuf->pResponse->Length );

            if ( dwLength > cbSendBuf )
            {
                return( ERROR_BUFFER_TOO_SMALL );
            }

            memcpy( pSendBuf, pWorkBuf->pResponse, dwLength );

            pResult->Action = APA_SendWithTimeout;

            break;
        }

        //
        // If we received another request then simply respond with
        // the same response except change the id.
        //

        if ( pReceiveBuf->Code == CBCP_CODE_Request )
        {
            //
            // If the current request is different than the previous one
            //

            dwLength = WireToHostFormat16( pWorkBuf->pRequest->Length );

            if ( ( WireToHostFormat16( pReceiveBuf->Length ) != dwLength ) ||
                 ( memcmp( ((PBYTE)(pWorkBuf->pRequest)) + PPP_CONFIG_HDR_LEN,
                           ((PBYTE)pReceiveBuf) + PPP_CONFIG_HDR_LEN,
                           dwLength - PPP_CONFIG_HDR_LEN ) ) )
            {
                return( ERROR_PPP_INVALID_PACKET );
            }

            if ( dwLength > cbSendBuf )
            {
                return( ERROR_BUFFER_TOO_SMALL );
            }

            pWorkBuf->pRequest->Id  = pReceiveBuf->Id;
            pWorkBuf->pResponse->Id = pReceiveBuf->Id;
            pResult->bIdExpected    = pReceiveBuf->Id;
            pResult->Action         = APA_SendWithTimeout;

            memcpy( pSendBuf,
                    pWorkBuf->pResponse,
                    WireToHostFormat16( pWorkBuf->pResponse->Length ) );

            break;
        }

        //
        // If this is an ACK, then validate it and then prepare for callback
        //

        if ( pReceiveBuf->Code == CBCP_CODE_Ack )
        {
            dwLength = WireToHostFormat16( pWorkBuf->pResponse->Length );

            if ( ( WireToHostFormat16( pReceiveBuf->Length ) != dwLength ) ||
                 ( memcmp( ((PBYTE)(pWorkBuf->pResponse)) + PPP_CONFIG_HDR_LEN,
                           ((PBYTE)pReceiveBuf) + PPP_CONFIG_HDR_LEN,
                           dwLength - PPP_CONFIG_HDR_LEN ) ) )
            {

                //
                // If this Ack is invalid then we resend the response.
                //

                dwLength = WireToHostFormat16( pWorkBuf->pResponse->Length );

                if ( dwLength > cbSendBuf )
                {
                    return( ERROR_BUFFER_TOO_SMALL );
                }

                memcpy( pSendBuf, pWorkBuf->pResponse, dwLength );

                pResult->Action = APA_SendWithTimeout;

                break;
            }

            //
            // We are done
            //

            pResult->Action              = APA_Done;
            pResult->bfCallbackPrivilege = (BYTE)(pWorkBuf->fCallbackPrivilege);

            break;
        }
        else
        {
            return( ERROR_PPP_INVALID_PACKET );
        }

        //
        // Fall through
        //

    default:

        pResult->Action                     = APA_NoAction;
        pResult->fGetCallbackNumberFromUser = FALSE;

        break;
    }

    return( NO_ERROR );
}

//**
//
// Call:        CbCPSMakeMessage
//
// Returns:     NO_ERROR            - success
//              non-zero return     - failure
//
// Description: Will be called to process and server side Callback Control
//              Protocol event.
//
DWORD
CbCPSMakeMessage(
    IN  CBCP_WORKBUFFER *   pWorkBuf,
    IN  PPP_CONFIG*         pReceiveBuf,
    OUT PPP_CONFIG*         pSendBuf,
    IN  DWORD               cbSendBuf,
    OUT PPPCB_RESULT*       pResult,
    IN  PPPCB_INPUT*        pInput
)
{
    DWORD dwRetCode;
    DWORD dwLength;

    switch( pWorkBuf->State )
    {

    case CBCP_STATE_INITIAL:

        //
        // Make the request based on the user's callback privelege
        //

        dwRetCode = MakeRequest( pWorkBuf->fCallbackPrivilege,
                                     pSendBuf,
                                     cbSendBuf );

        if ( dwRetCode != NO_ERROR )
        {
            return( dwRetCode );
        }

        //
        // Set the Id of the first request to 1
        //

        pSendBuf->Id = 1;

        //
        // Save the request
        //

        dwLength = WireToHostFormat16( pSendBuf->Length );

        pWorkBuf->pRequest = (PPP_CONFIG *)LocalAlloc( LPTR, dwLength );

        if ( pWorkBuf->pRequest == (PPP_CONFIG *)NULL )
        {
            return( GetLastError() );
        }

        memcpy( pWorkBuf->pRequest, pSendBuf, dwLength );

        pResult->Action         = APA_SendWithTimeout2;
        pResult->bIdExpected    = pWorkBuf->pRequest->Id;
        pWorkBuf->State         = CBCP_STATE_WAIT_FOR_RESPONSE;

        break;

    case CBCP_STATE_WAIT_FOR_RESPONSE:

        //
        // If the Receive buffer is NULL that means that we got a timeout.
        // So resend the request.
        //

        if ( pReceiveBuf == (PPP_CONFIG *)NULL )
        {
            dwLength = WireToHostFormat16( pWorkBuf->pRequest->Length );

            if ( cbSendBuf < dwLength )
            {
                return( ERROR_BUFFER_TOO_SMALL );
            }

            //
            // Increment the request id
            //

            (pWorkBuf->pRequest->Id)++;

            memcpy( pSendBuf, pWorkBuf->pRequest, dwLength );

            pResult->Action         = APA_SendWithTimeout2;
            pResult->bIdExpected    = pWorkBuf->pRequest->Id;
            pWorkBuf->State         = CBCP_STATE_WAIT_FOR_RESPONSE;

            break;
        }

        //
        // Fall through
        //

    case CBCP_STATE_DONE:

        if ( pReceiveBuf == NULL )
        {
            //
            // If we receive a timeout in the DONE state, we just ignore it.
            //

            pResult->Action = APA_NoAction;
            break;
        }

        //
        // If we have received a response from the client, then validate
        // it and send an ACK or another request.
        //

        if ( pReceiveBuf->Code == CBCP_CODE_Response )
        {
            //
            // Check the id of the response packet. If the Id is bad then
            // silently discard it
            //

            if ( pReceiveBuf->Id != pWorkBuf->pRequest->Id )
            {
                return( ERROR_PPP_INVALID_PACKET );
            }

            dwRetCode = ValidateResponse( pReceiveBuf, pWorkBuf );

            if ( dwRetCode == ERROR_PPP_INVALID_PACKET )
            {
                //
                // If the response received was invalid, resend the request
                //

                dwLength = WireToHostFormat16( pWorkBuf->pRequest->Length );

                if ( cbSendBuf < dwLength )
                {
                    return( ERROR_BUFFER_TOO_SMALL );
                }

                //
                // Increment the request id
                //

                (pWorkBuf->pRequest->Id)++;

                memcpy( pSendBuf, pWorkBuf->pRequest, dwLength );

                pResult->Action         = APA_SendWithTimeout2;
                pResult->bIdExpected    = pWorkBuf->pRequest->Id;
                pWorkBuf->State         = CBCP_STATE_WAIT_FOR_RESPONSE;

                break;
            }
            else if ( dwRetCode != NO_ERROR )
            {
                return( dwRetCode );
            }

            //
            // Send the Ack
            //

            dwLength = WireToHostFormat16( pReceiveBuf->Length );

            if ( cbSendBuf < dwLength )
            {
                return( ERROR_BUFFER_TOO_SMALL );
            }

            memcpy( pSendBuf, pReceiveBuf, dwLength );
            pSendBuf->Code  = CBCP_CODE_Ack;
            pSendBuf->Id    = pReceiveBuf->Id;

            pWorkBuf->State              = CBCP_STATE_DONE;
            pResult->Action              = APA_SendAndDone;
            pResult->bfCallbackPrivilege = (BYTE)(pWorkBuf->fCallbackPrivilege);
            pResult->CallbackDelay       = pWorkBuf->CallbackDelay;

            strcpy( pResult->szCallbackNumber, pWorkBuf->szCallbackNumber );
        }
        else
        {
            return( ERROR_PPP_INVALID_PACKET );
        }

        break;

    default:

        break;
    }

    return( NO_ERROR );
}

//**
//
// Call:        MakeRequest
//
// Returns:     NO_ERROR                - success
//              ERROR_BUFFER_TOO_SMALL  - failure
//
// Description: Will make a callback request packet based on the user's
//              callback privilege. The Id will be filled in by the caller.
//
static DWORD
MakeRequest(
    IN     DWORD        fCallbackPrivilege,
    IN OUT PPP_CONFIG * pSendBuf,
    IN     DWORD        cbSendBuf
)
{
    PPP_OPTION * pOption;
    DWORD        dwLength = PPP_CONFIG_HDR_LEN;

    if ( cbSendBuf < PPP_CONFIG_HDR_LEN )
    {
        return( ERROR_BUFFER_TOO_SMALL );
    }

    pOption = (PPP_OPTION *)(pSendBuf->Data);

    pSendBuf->Code = CBCP_CODE_Request;

    if ( ( fCallbackPrivilege & RASPRIV_NoCallback ) ||
         ( fCallbackPrivilege & RASPRIV_CallerSetCallback ) )
    {
        if ( cbSendBuf < dwLength + PPP_OPTION_HDR_LEN )
        {
            return( ERROR_BUFFER_TOO_SMALL );
        }

        pOption->Type   = CBCP_TYPE_NO_CALLBACK;
        pOption->Length = PPP_OPTION_HDR_LEN;

        dwLength += pOption->Length;
        pOption = (PPP_OPTION *)(((BYTE *)pOption) + pOption->Length);
    }

    if ( fCallbackPrivilege & RASPRIV_CallerSetCallback )
    {
        if ( cbSendBuf < dwLength + PPP_OPTION_HDR_LEN + 2 )
        {
            return( ERROR_BUFFER_TOO_SMALL );
        }

        pOption->Type       = CBCP_TYPE_CALLER_SET;
        pOption->Length     = PPP_OPTION_HDR_LEN + 3;

        *(pOption->Data)    = 0;                // Callback Delay
        *(pOption->Data+1)  = CBCP_PSTN_NUMBER; // Callback Address type
        *(pOption->Data+2)  = 0;    // Callback Address terminating NULL

        dwLength += pOption->Length;
        pOption = (PPP_OPTION *)(((BYTE *)pOption) + pOption->Length);
    }

    if ( fCallbackPrivilege & RASPRIV_AdminSetCallback )
    {
        if ( cbSendBuf < dwLength + PPP_OPTION_HDR_LEN + 1)
        {
            return( ERROR_BUFFER_TOO_SMALL );
        }

        pOption->Type       = CBCP_TYPE_CALLEE_SET;
        pOption->Length     = PPP_OPTION_HDR_LEN + 1;

        *(pOption->Data)    = 0;    // Callback Delay

        dwLength += pOption->Length;
    }

    HostToWireFormat16( (WORD)dwLength, (PBYTE)(pSendBuf->Length) );

    return( NO_ERROR );
}

//**
/